(lp0
((dp1
S'text'
p2
(lp3
VYou can use Emit to access the Sizeof opcode and bypass compiler's restriction on getting sizeof(T):
p4
as(dp5
S'author'
p6
V335858
p7
stp8
a((dp9
g2
(lp10
VNot knowing much about your model, here is a blind mechanical translation of your query:
p11
as(dp12
g6
V335858
p13
stp14
a((dp15
g2
(lp16
VSee if you can avoid storing  with the object, otherwise a possibility of it getting out of sequence will always remain
p17
aVYou can pair up an object with its sequence for downstream consumption when enumerating through the container:
p18
as(dp19
g6
V335858
p20
stp21
a((dp22
g2
(lp23
VThe same
p24
aVm file is likely included in your project twice
p25
aVSee this thread for suggestions on how this could have happened
p26
as(dp27
g6
V335858
p28
stp29
a((dp30
g2
(lp31
VThe second one is probably faster, because you end up with a single roundtrip
p32
aVBoth are equally awful, because you do not use parameterized queries
p33
as(dp34
g6
V335858
p35
stp36
a((dp37
g2
(lp38
VA grossly simplified meaning of k in Floyd-Warshall is a "way point" in the graph
p39
aVThe last two lines could be interpreted as follows: "If you can get from i to k and then from k to j faster than from i to j through any path that you found so far, then the path from i to j through k becomes the new shortest path"
p40
as(dp41
g6
V335858
p42
stp43
a((dp44
g2
(lp45
VFile
p46
aVReadLines is not available before
p47
aVNET 4
p48
aV0
p49
aVYou need to make sure you are compiling for
p50
aVNET 4
p51
aV0+, or a compatible version of Mono
p52
as(dp53
g6
V335858
p54
stp55
a((dp56
g2
(lp57
VPerhaps not the fastest to execute, but the fastest to type up:
p58
as(dp59
g6
V335858
p60
stp61
a((dp62
g2
(lp63
VFirst, I think you meant
p64
aVBack to your question: You do not need to "resolve the issue", because ANTLR has no problem dealing with tail recursion
p65
aVI'm nearly certain that it replaces tail recursion with a loop in the code that it generates
p66
aVThis tutorial (search for the chapter called "Expressions" on the page) explains how to arrive at the e1 = e2 (op e2)* structure
p67
aVIn general, though, you define expressions in terms of higher-priority expressions, so the actual recursive call happens only when you process parentheses and function parameters:
p68
as(dp69
g6
V335858
p70
stp71
a((dp72
g2
(lp73
VSteep learning curve of ANTLR consists mostly of learning recursive descent parsing technique
p74
aVThe syntax and the idiosyncrasies of the tool contribute to the complexity, but they are secondary
p75
aVIn other words, you would need to learn how to do parsers no matter what, but with the checks built into automatic parser generator you minimize your chances of coding an invalid grammar
p76
aVYou could also opt for a pre-built SQL parser (here is one for
p77
aVNET and another one for Java)
p78
aVI tried them both, and they work fine
p79
aVYou may need TopCoder membership to download the components
p80
aVBoth these components use generated parsers, but they use JavaCC and its C# port instead of ANTLR
p81
aVThe grammars are reasonably close, though, so you may choose them as a starting point for your project
p82
as(dp83
g6
V335858
p84
stp85
a((dp86
g2
(lp87
VYou need a back inserter to copy into vectors:
p88
as(dp89
g6
V335858
p90
stp91
a((dp92
g2
(lp93
VThe assignment operator is missing from your Vector3f class
p94
aVTemplate expansion of vector's push_back needs an assignment operator to copy the value into the vector, so the compiler complains that it cannot find it
p95
aVIf you get to modify that header, you will also need to define a  copy constructor
p96
as(dp97
g6
V335858
p98
stp99
a((dp100
g2
(lp101
VTo solve the problem that you stated in your post,  and RTTI are definitely the right tools
p102
aVHowever, issuing a warning at runtime while providing compile-time support for a '+' operation may point to issues in the design where the users of your API would not expect exactly the behavior that your API provides
p103
as(dp104
g6
V335858
p105
stp106
a((dp107
g2
(lp108
VStandard SQL does not let you select columns in "group by" queries that do not either (1) appear on the group by list, or (2) included in an aggregate function
p109
aVAny industrial strength SQL engine (DB2, Oracle, SQL Server) would consider your query incorrect
p110
aVIn cases when you need to choose a specific item or a default when it is not in the database, the coalesce function is used
p111
aVWith this function in hand, you should be able to formulate your query without "group by"
p112
as(dp113
g6
V335858
p114
stp115
a((dp116
g2
(lp117
VOn SQL Server, you can use HOST_NAME() as follows:
p118
as(dp119
g6
V335858
p120
stp121
a((dp122
g2
(lp123
VThis depends on your circumstances: how fast do you need it, what is your starting point, and so on
p124
aVIn an unconstrained world, I think the best thing is to roll your own library for building dynamic queries
p125
aVYou can use Scott's or Joseph's work as an inspiration, but in the end it all "bottoms out" in the Linq
p126
aVExpression library
p127
aVOne advantage to the "do it yourself" approach is that you would not need to bridge from your code to someone's framework
p128
aVRather, you would code directly to
p129
aVNET APIs
p130
aVThis may be useful when you already have a representation of your dynamic queries, for example, in a model that you present to users through a UI, in an XML file, etc
p131
aVAll you need is to walk that representation recursively, and produce System
p132
aVLinq
p133
aVExpression as the return
p134
aVFWIW, my company took this approach when
p135
aVNET 3
p136
aV5 came out, and we are very happy with the outcome
p137
as(dp138
g6
V335858
p139
stp140
a((dp141
g2
(lp142
VThe use of  in the constructor is not necessary: compilers are smart enough to tell parameter names from member names
p143
aVThe snippet below compiles and runs just fine:
p144
aVIn general, use of  for disambiguation is valid, but unnecessary: as you correctly noted, you can simply use different names for parameters and members, and that's that
p145
aVHowever, there are cases when you must use , otherwise things are not going to compile
p146
aVHere is a somewhat contrived example - using  to set up a "back reference", as follows:
p147
as(dp148
g6
V335858
p149
stp150
a((dp151
g2
(lp152
VThere are at least two ways to deal with this issue:
p153
aV(1) initialize collection yourself in the constructor,
p154
aVor (2) use  instead of :
p155
as(dp156
g6
V335858
p157
stp158
a((dp159
g2
(lp160
VYou can use reflection:
p161
as(dp162
g6
V335858
p163
stp164
a((dp165
g2
(lp166
VYour call to dumpMem is correct, but your program is not storing the results of your calculations at the correct location: the region you call "Fibonacci" remains initialized to 1, 1, and ten zeros
p167
aVYou need to make sure that your loop starts writing at the offset of Fibonacci plus 2, and moves ten times in one-byte increments (ten, not twelve, because you provided the two initial items in the initializer)
p168
aVI'm sorry, I cannot be any more specific, as any question containing the word "Fibonacci" inevitably turns out to be someone's homework :-)
p169
as(dp170
g6
V335858
p171
stp172
a((dp173
g2
(lp174
VTake a look at serialization surrogates: they provide a good alternative to implementing ISerializable when you cannot or do not want to mix serialization logic with the business logic of the class (in your case, SparceMatrix)
p175
as(dp176
g6
V335858
p177
stp178
a((dp179
g2
(lp180
VBridge design pattern would be a good choice
p181
as(dp182
g6
V335858
p183
stp184
a((dp185
g2
(lp186
VYou need to use Refresh method of your data context to invalidate the cache
p187
as(dp188
g6
V335858
p189
stp190
a((dp191
g2
(lp192
s(dp193
g6
V335858
p194
stp195
a((dp196
g2
(lp197
s(dp198
g6
V335858
p199
stp200
a((dp201
g2
(lp202
VYou need to use SelectMany instead of Select
p203
as(dp204
g6
V335858
p205
stp206
a((dp207
g2
(lp208
VYou got it almost right, but you need to use properties instead of variables:
p209
aVYou cannot use FomeFunction in the constructor because SomeProperty has not been initialized by the derived class
p210
aVOutside of constructor it's fine, though
p211
aVIn general, accessing virtual members in the constructor should be considered suspicious
p212
aVIf you must pass values from derived classes to base class constructor, it's best to do it explicitly through parameters of a protected constructor
p213
as(dp214
g6
V335858
p215
stp216
a((dp217
g2
(lp218
VYour algorithm will not work in certain mazes that have circular paths: once you get into one of these, you'll be going in circles
p219
aVTo fix this, you need to add a boolean array visited[R][C][DIR], where DIR is a number from zero to three representing a direction
p220
aVWhen you leave cell [r][c] in the direction [d], set visited[r][c][d] to true
p221
aVNext time you visit the same cell, see if you have left it in the same direction before; if you did, skip that direction, and go for the next one down the line
p222
as(dp223
g6
V335858
p224
stp225
a((dp226
g2
(lp227
VInstead of an int, you need to store a list of values:  Add value to the list instead of incrementing count, like this:
p228
as(dp229
g6
V335858
p230
stp231
a((dp232
g2
(lp233
VThe best data structure to use for this task is a suffix tree
p234
aVOnce initialized, this tree will let you quickly find all words starting in a given sequence of characters
p235
aVIt is relatively easy piece of coding, too
p236
as(dp237
g6
V335858
p238
stp239
a((dp240
g2
(lp241
VI think you mean Covariance and Contravariance
p242
as(dp243
g6
V335858
p244
stp245
a((dp246
g2
(lp247
VIt's not just a simple function call, it's also a dereference of the internal rand object that take place in there
p248
aVJIT compiler can optimize your loop a lot when you call next random directly, but not when it's inside another class
p249
aVThe function is called more than 2,000,000 times, and it takes three microseconds to evaluate
p250
aVIt's not the fastest function in the world, but it's not overly slow either: it's the multiplication effect that kills the performance
p251
aVIf matcher is not locking, or if it's OK to create multiple copies of it, you can speed it up by parallelizing your algorithm, say, eight-way for your Core2-Quad
p252
aVThe code should finish in under a second
p253
as(dp254
g6
V335858
p255
stp256
a((dp257
g2
(lp258
VYour code is grossly off: you do not alter 'c' inside a loop, making it spin indefinitely
p259
aVIt's a good idea to sketch your algorithm on a piece of paper before you start coding
p260
aVIn your case, pseudocode should look like this:
p261
aVOpen file
p262
aVRead the secret
p263
aVClose file
p264
aVRepeat three times:
p265
aV--- Display the prompt
p266
aV--- Read user input
p267
aV--- If user input matches the secret, congratulate the user and exit
p268
aVTell the user his guess was incorrect
p269
aVAt this point, converting it to C should be more or less mechanical
p270
aVGood luck
p271
as(dp272
g6
V335858
p273
stp274
a((dp275
g2
(lp276
s(dp277
g6
V335858
p278
stp279
a((dp280
g2
(lp281
VCompiler simply inserts an instruction for comparing two bytes for equality - a very efficient operation
p282
aVOf course in your case 'a'=='b' is equivalent to a constant
p283
as(dp284
g6
V335858
p285
stp286
a((dp287
g2
(lp288
VIn windows, Daemon programs are implemented as Services
p289
as(dp290
g6
V335858
p291
stp292
a((dp293
g2
(lp294
VI think they meant that the IP register cannot be accessed directly in the same way the other registers are accessed
p295
aVProgrammers can definitely write to IP, for example by issuing a jump instruction
p296
as(dp297
g6
V335858
p298
stp299
a((dp300
g2
(lp301
VAccording to C specification, casting function pointers results in unspecified behavior, but many compilers (e
p302
aVg
p303
aVgcc) do what you expect them to do, because function pointer is just an address in memory
p304
aVJust to be safe, I would re-declare func1 and func2 to take void*, and then cast these pointers to char* and int* as required
p305
as(dp306
g6
V335858
p307
stp308
a((dp309
g2
(lp310
VSTL containers use iterators instead of pointers
p311
aVIf you have an iterator that points to an element of your linked list, you can access element's data through it, insert at the iterator's position using the list's insert method, and delete at iterator's position using the erase method
p312
as(dp313
g6
V335858
p314
stp315
a((dp316
g2
(lp317
VThis invocation should work:
p318
aVFor class (static) function:
p319
aVFor member function:
p320
as(dp321
g6
V335858
p322
stp323
a((dp324
g2
(lp325
VMember pointer (as opposed to a simple pointer to a member) is simply an offset into the structure, not a pointer at all
p326
aVYou can get data through it only in conjunction with the structure itself (or a pointer to a structure): the value of the offset is added to the address of the structure, and the result is dereferenced to produce the value of the member
p327
aVNow suppose a member is a reference, so accessing data through it already requires a dereference (compiler hides it from us, but it needs to spit out the corresponding instructions in its output)
p328
aVIf C++ were to allow member pointers to references, they'd be of yet another type: an offset that needs to be added to the base, and then dereferenced twice
p329
aVIt is too much work to improve an already obscure feature; prohibiting it is a much better way out
p330
as(dp331
g6
V335858
p332
stp333
a((dp334
g2
(lp335
VYou could provide a delegate protocol specific to your model, which is shared by both your controllers
p336
aVThis protocol could have methods such as  and so on, providing listeners with info on what's changed in the model
p337
aVIf you register both controllers as delegates for your shared model, both implementing this shared protocol, the cross-controller dependency would be removed without introducing any new dependencies
p338
aVHowever, this is only my opinion, which is rather subjective
p339
aVYour approach is perfectly fine, too - I think it is absolutely OK for the master to be a delegate of the detail at the same time as the detail is a delegate of the master
p340
aVIt is better than giving each controller a pointer to the other one, because you do not need to think about retain cycles
p341
as(dp342
g6
V335858
p343
stp344
a((dp345
g2
(lp346
VWhat you are trying to achieve is called polymorphism
p347
aVIn C++, you will need to define a common (possibly abstract) base class C for A and B, make doSomething a virtual function, override it in both A and B, and make pointers of type C*
p348
aVHere is a good introductory article on the topic
p349
as(dp350
g6
V335858
p351
stp352
a((dp353
g2
(lp354
V specifies a format with 9 total characters: 2 digits before the dot, the dot itself, and six digits after the dot
p355
as(dp356
g6
V335858
p357
stp358
a((dp359
g2
(lp360
VSince you used reflection to create your objects, it's only fair that you need to continue using it to call their methods:
p361
as(dp362
g6
V335858
p363
stp364
a((dp365
g2
(lp366
VYour code is almost there, just need a few modifications
p367
aVAn important thing to remember is that  does not modify the value that you pass to it, and it is not required to return the pointer to the same chunk of memory that you passed to it
p368
aVHere is a working example of using realloc
p369
aVIt is rather straightforward, so you should be able to fix your code by simply following the example
p370
as(dp371
g6
V335858
p372
stp373
a((dp374
g2
(lp375
VTo speed things up a bit, you can unroll one loop using a cute little trick:
p376
as(dp377
g6
V335858
p378
stp379
a((dp380
g2
(lp381
VTo deal with the simplest case, you can do this:
p382
aVFor general case, do this:
p383
as(dp384
g6
V335858
p385
stp386
a((dp387
g2
(lp388
VHere is one way to do it:
p389
as(dp390
g6
V335858
p391
stp392
a((dp393
g2
(lp394
VI'd like to hear about experience from other people
p395
aVI wrote a library with several thousands lines of code, and a coverage suite that was longer than the library itself
p396
aVAt 99
p397
aV98%, I covered every single line except one: the method came from a legacy project, and I did not know how to construct a test case that would hit that line
p398
aVWhen my library went into production, the very first bug report was caused by that single untested line
p399
aVMy take-home lesson from that project was that the lines you don't know how to hit are the most dangerous
p400
aVIf your project is decision-intensive, it's in your best interest to get 100% coverage
p401
as(dp402
g6
V335858
p403
stp404
a((dp405
g2
(lp406
VYou are correct in the sense that your code does precisely what you say it should do
p407
aVThe real question is whether or not that is what you are looking to achieve
p408
aVA negative number cast to unsigned int becomes a very large positive number
p409
aVFor example, negative one becomes the largest positive integer that can be expressed in an unsigned int after the cast to unsigned (try it
p410
aVWhen you add two negative numbers that were cast to unsigned, you are guaranteed to get an overflow
p411
aVIf that is indeed what you are trying to do, your code is definitely doing it
p412
as(dp413
g6
V335858
p414
stp415
a((dp416
g2
(lp417
VThis may not translate to exactly the same query when SQL is produced, but it should do the trick:
p418
as(dp419
g6
V335858
p420
stp421
a((dp422
g2
(lp423
s(dp424
g6
V335858
p425
stp426
a((dp427
g2
(lp428
VFirst, your code does not swap pointers: all it does is assigning the value of pNew to pComp
p429
aVThe reason the program is not doing what you expect is that in C and C++ parameters are passed by value
p430
as(dp431
g6
V335858
p432
stp433
a((dp434
g2
(lp435
VJava passes  by value, so your assignment  has no effect
p436
aVYour  function should return the node it creates, instead of taking one as a parameter
p437
as(dp438
g6
V335858
p439
stp440
a((dp441
g2
(lp442
VIn SQL null is not equal to anything, including other nulls
p443
aVYou need to use  instead of the  operation
p444
as(dp445
g6
V335858
p446
stp447
a((dp448
g2
(lp449
VThis depends a lot on what you are planning to do with the year
p450
aVIf you plan to pass it around a lot, creating your custom  encapsulating an int may be a good idea, because you wouldn't need to validate the same number multiple times
p451
aVOtherwise, a plain old  would work just fine
p452
as(dp453
g6
V335858
p454
stp455
a((dp456
g2
(lp457
s(dp458
g6
V335858
p459
stp460
a((dp461
g2
(lp462
s(dp463
g6
V335858
p464
stp465
a((dp466
g2
(lp467
VIs this a problem with intellisense
p468
aVThis compiles fine:
p469
as(dp470
g6
V335858
p471
stp472
a((dp473
g2
(lp474
VScott Meyers page lists several code checking tools (PC-Lint, CodeCheck, and CodeAdvisor) capable of issuing warnings for calls of virtual functions from constructors
p475
as(dp476
g6
V335858
p477
stp478
a((dp479
g2
(lp480
VIf you use memory tracking tool to find memory leaks, unbalanced allocs/deallocs from your top level would show up as leaks
p481
aVThis will distract you from your task of finding the real memory leaks
p482
aVOther than that, you are safe: OS will free up the memory and other resources for you
p483
as(dp484
g6
V335858
p485
stp486
a((dp487
g2
(lp488
VTwo circles intersect if, and only if, the distance between their centers is between the sum and the difference of their radii
p489
aVGiven two circles (x0,y0,R0) and (x1,y1,R1), the formula is as follows:
p490
aVSquaring both sides lets you avoid the slow SQRT, and stay with ints if your inputs are integer:
p491
aVSince you need only a yes/no test, this check is faster than calculating the exact intersection points
p492
aVEdit: corrected for the "one circle inside the other" case
p493
as(dp494
g6
V335858
p495
stp496
a((dp497
g2
(lp498
VThink about it this way: when you put an asterisk in front of a pointer, you remove an asterisk from the type of the result:
p499
aVString in C is char*, so you need to use *ptr
p500
as(dp501
g6
V335858
p502
stp503
a((dp504
g2
(lp505
VI think this is because your  is null
p506
aVTry changing the lines at the top as follows:
p507
aVAs a matter of optimization, you can calculate "i moths back" outside of your Linq expression
p508
aVIn case there are many blog entries, you wouldn't be doing  more times than necessary
p509
as(dp510
g6
V335858
p511
stp512
a((dp513
g2
(lp514
VI think you are missing  in the  rule
p515
as(dp516
g6
V335858
p517
stp518
a((dp519
g2
(lp520
VAssign an instance to a weak variable:
p521
aVThe instance will be dealloced right away
p522
aVAlternatively, you can disable ARC on your unit test file and call dealloc
p523
as(dp524
g6
V335858
p525
stp526
a((dp527
g2
(lp528
VAccording to Microsoft, you get  if the process exits between the time you called  and the time you access
p529
aVChecking  may help, but it is not guaranteed, because there's still enough time for the process to exit before you make the next call
p530
as(dp531
g6
V335858
p532
stp533
a((dp534
g2
(lp535
s(dp536
g6
V335858
p537
stp538
a((dp539
g2
(lp540
VIf you have access to C++ STL, use next_permutation, and do an additional check of a[i]
p541
aV= i in a  loop
p542
as(dp543
g6
V335858
p544
stp545
a((dp546
g2
(lp547
VUse ToLowerInvariant instead
p548
as(dp549
g6
V335858
p550
stp551
a((dp552
g2
(lp553
V is not, strictly speaking, a keyword
p554
aVIt is part of XML Schema (XSD) "language", letting you create simple types by restricting other simple types, including built-in numeric types
p555
aVIn your case, the integer value is restricted to two values - 36 and 40
p556
as(dp557
g6
V335858
p558
stp559
a((dp560
g2
(lp561
V"Dimension of an Array" is the number of indices, or subscripts, that you need in order to specify an individual element of the array
p562
aVDimensions and subscripts may be confusing
p563
aVSubscript is a number (or another type of associative key), while dimension is a description of the range of acceptable keys; you need one subscript for each dimension of the array
p564
aVFor example, in C/C++  is an array with two dimensions: of size 10 and of size 5
p565
aVYou need two subscripts, or keys, to address its elements
p566
aVOne subscript has to be between 0 and 9, inclusive; the other subscript is between 0 and 4
p567
as(dp568
g6
V335858
p569
stp570
a((dp571
g2
(lp572
VI think this is because the 's translator is under-optimized
p573
aVUse of a "property" () triggers creation of a sub-query, which turns out to be unnecessary
p574
aVIt is worth to note that any RDBMS worth its salt would generate identical query plans for both SQL queries, so in the end it would not matter either way
p575
as(dp576
g6
V335858
p577
stp578
a((dp579
g2
(lp580
VUse MakeGenericType method:
p581
as(dp582
g6
V335858
p583
stp584
a((dp585
g2
(lp586
VSee the answer to this question for a suggestion on how to make your example work:
p587
aVYou should change your INSERT to return that inserted ID to you right away (in an OUTPUT clause)
p588
as(dp589
g6
V335858
p590
stp591
a((dp592
g2
(lp593
VYou need to have an assignment operator for your class, a destructor, and a copy constructor
p594
as(dp595
g6
V335858
p596
stp597
a((dp598
g2
(lp599
VCreate a set of ints, and put random numbers between 0 and list's length minus one into it in a loop, while the size of the set is not equal the desired number of random elements
p600
aVGo through the set, and pick list elements as indicated by the numbers in the set
p601
aVThis way would keep your original list intact
p602
as(dp603
g6
V335858
p604
stp605
a((dp606
g2
(lp607
VThe connection string (
p608
aVis intended for hiding the physical location of the database files when you decide to move files
p609
aVNo matter where your files are, the programs that use your database should not care, because logically it's the same database
p610
aVWhen you move your DB files, you need to re-point your SQL Express database to the new location, and keep the connection string intact
p611
as(dp612
g6
V335858
p613
stp614
a((dp615
g2
(lp616
VYou can disable scrolling on the , override  in your view controller, check if any of the touches began in the area where you'd like to enable swipes, and if the answer is 'yes', re-enable scrolling
p617
aVAlso override  and  to disable scrolling when the touches are over
p618
as(dp619
g6
V335858
p620
stp621
a((dp622
g2
(lp623
VTechnically, Breadth-first search (BFS) by itself does not let you find the shortest path, simply because BFS is not looking for a shortest path: BFS describes a strategy for searching a graph, but it does not say that you must search for anything in particular
p624
aVDijkstra's algorithm adapts BFS to let you find single-source shortest paths
p625
aVIn order to retrieve the shortest path from the origin to a node, you need to maintain two items for each node in the graph: it's current shortest distance, and the preceding node in the shortest path
p626
aVInitially all distances are set to infinity, and all predecessors are set to empty
p627
aVIn your example, you set A's distance to zero, and then proceed with the BFS
p628
aVOn each step you check if you can improve the distance of a descendant, i
p629
aVe
p630
aVthe distance from the origin to the predecessor plus the length of the edge that you are exploring is less than the current best distance for the node in question
p631
aVIf you can improve the distance, set the new shortest path, and remember the predecessor through which that path has been acquired
p632
aVWhen the BFS queue is empty, pick a node (in your example, it's E) and traverse its predecessors back to the origin
p633
aVThis would give you the shortest path
p634
aVIf this sounds a bit confusing, wikipedia has a nice pseudocode section on the topic
p635
as(dp636
g6
V335858
p637
stp638
a((dp639
g2
(lp640
VYou do not need to pre-fill with 10: zero works just as well
p641
aVI think the best approach to solving the spiral is to think of how you do it manually: start in a corner, and go horizontally until you hit non-zero or an edge of the array
p642
aVThen you turn right
p643
aVStop when the current number goes past N*N
p644
aVNow let's look at what each part of the algorithm means:
p645
aVStarting in the corner means setting x=0 and y=0
p646
aVGoing in a straight line means x=x+dx, y=y+dy, where either dx or dy is zero, and dy or dx is 1 or -1
p647
aVTurning right means assigning dx to dy and -dy to dx
p648
aVHere is how it looks in the code:
p649
as(dp650
g6
V335858
p651
stp652
a((dp653
g2
(lp654
VUse CAST or CONVERT
p655
aVHere is a useful list illustrating CONVERT codes for dates
p656
as(dp657
g6
V335858
p658
stp659
a((dp660
g2
(lp661
VWrite your own lengthWithDoubleLetters/2 rule taking a list of characters and returning its length counting double letters as one:
p662
as(dp663
g6
V335858
p664
stp665
a((dp666
g2
(lp667
VWhen you add an integer to a pointer, the value of the pointer increases by the value of the integer times the size of the type pointed to by the pointer
p668
aVIf  is 48, then adding one to a pointer shifts it by 48, adding 2 - by 2*48, and so on
p669
as(dp670
g6
V335858
p671
stp672
a((dp673
g2
(lp674
VYou are dealing with a GDB issue, not a C issue
p675
aVYou can also do #4, which is arguably better than #3
p676
as(dp677
g6
V335858
p678
stp679
a((dp680
g2
(lp681
VParse the strings, convert them to numbers, and sort on the first number
p682
aVThe actual mechanics of doing that depends on your programming language
p683
aVIn C# you can use Linq:
p684
as(dp685
g6
V335858
p686
stp687
a((dp688
g2
(lp689
VGood chances are, you wouldn't find any differences: any reasonably modern compiler knows to optimize both into the same code
p690
as(dp691
g6
V335858
p692
stp693
a((dp694
g2
(lp695
VYou need to declare  as
p696
aVYou can use  to avoid such mistakes in the future:
p697
aVThis would make your code compile, but it would not do what you're trying to do (bubblesort)
p698
aVThe problem is that you are passing a single string (which is also an "array" of characters) instead of an array of strings, which is, in a very lose sense, "an array of arrays of characters"
p699
aVYour bubblesort needs to accept  as its first parameter
p700
as(dp701
g6
V335858
p702
stp703
a((dp704
g2
(lp705
VAdd an array  for the result, and initialize its first  members using a loop from 0 to
p706
aVNow observe that to get  you can add  to , and subtract
p707
aVNow you can do the rest of the items in a single non-nested loop:
p708
as(dp709
g6
V335858
p710
stp711
a((dp712
g2
(lp713
VUse double  brace in your format string
p714
as(dp715
g6
V335858
p716
stp717
a((dp718
g2
(lp719
VYou should use plain , not  in the declaration, like this:
p720
as(dp721
g6
V335858
p722
stp723
a((dp724
g2
(lp725
VThis should produce a table of counts of category matches between each pair of items that share at least one category
p726
aVI suspect that it may be a bit slow, though
p727
aVI don't have an instance of MySQL at the moment to try it out
p728
as(dp729
g6
V335858
p730
stp731
a((dp732
g2
(lp733
VYou cannot alias table names in single-table DELETE in MySql
p734
aVYou need to use full table name, like this:
p735
as(dp736
g6
V335858
p737
stp738
a((dp739
g2
(lp740
VYou need to either qualify  with its namespace (which is ), or import the namespace at the top of your CPP file:
p741
as(dp742
g6
V335858
p743
stp744
a((dp745
g2
(lp746
VYou need to iterate the content of , not their indexes
p747
as(dp748
g6
V335858
p749
stp750
a((dp751
g2
(lp752
VYou read the number of rows and columns like this:
p753
aVYou do it before the nested loops that read the rest of the file
p754
aVThen you use the numbers from the file as your end-of-loop targets, rather than hard-coding 50 and 8
p755
as(dp756
g6
V335858
p757
stp758
a((dp759
g2
(lp760
VI verified that your query works in
p761
aVNET 4
p762
ag49
aVAre you missing a reference to  from your assembly
p763
as(dp764
g6
V335858
p765
stp766
a((dp767
g2
(lp768
VNaming parameters has a significant advantage when you work with IDEs that support auto-completion
p769
aVWhen you start typing the name of your function, the IDE pops up a list of suggestions
p770
aVSeeing  tells you a lot more than simply
p771
as(dp772
g6
V335858
p773
stp774
a((dp775
g2
(lp776
VTry disabling the index temporarily
p777
as(dp778
g6
V335858
p779
stp780
a((dp781
g2
(lp782
VThe value of the certificate comes mostly from the trust of the internet users in the issuer of the certificate
p783
aVTo that end, Verisign is tough to beat
p784
aVA certificate says to the client that you are who you say you are, and the issuer has verified that to be true
p785
aVYou can get a free SSL certificate signed, for example, by StartSSL
p786
aVYet it is not going to be much different from a self-signed certificate: the browser bar is not going to turn green when communicating with your site over https
p787
aVThe cheapest SSL certificate that turns the bar green will cost you a few hundred dollars, and you would need to go through a process of proving the identity of your company to the issuer of the certificate by submitting the relevant documents
p788
as(dp789
g6
V335858
p790
stp791
a((dp792
g2
(lp793
VThis is because  is , but the column that it references, , is
p794
aVYou need to make both of them the same type (, because you called it "Number")
p795
as(dp796
g6
V335858
p797
stp798
a((dp799
g2
(lp800
VI copied your code and verified the behavior that you are getting
p801
aVI can explain the mechanics of it, but not the logic behind it
p802
aVHere is what's going on: each of the two  directives produces a hidden variable  in its corresponding class
p803
aVIn addition, the directive synthesizes a getter for  in , and a getter/setter pair in
p804
aVThe getter of  in  overrides the getter of  in ; the setter does not, because there is nothing to override
p805
aVAt this point, 's  in  becomes orphaned: neither the getter of  nor its setter reference it
p806
aVThe setter references 's , not 's
p807
aVThat's why you are seeing different values printed in the  method of
p808
aVPutting the method in  behaves the way that you would expect
p809
aVEDIT:
p810
aVNaturally, the next question is how to make the behavior that you want
p811
aVIt turns out to be simple: do not synthesize the property in , and implement a setter of  in 's implementation file (without putting it in the interface, so that it remains read-only to the clients of your interface)
p812
as(dp813
g6
V335858
p814
stp815
a((dp816
g2
(lp817
s(dp818
g6
V335858
p819
stp820
a((dp821
g2
(lp822
VUnlike the new collection implementations, Hashtable is synchronized
p823
aVThat's why I could imagine a situation when using Hashmap would create a problem, and using Hashtable would resolve it
p824
aVThe fact that it's single core is of no consequence: if Thread1 is pre-empted in the middle of a  call, Thread2 will see an inconsistent state, and may crash
p825
as(dp826
g6
V335858
p827
stp828
a((dp829
g2
(lp830
VStrict aliasing rule is about two pointers of different types referencing the same location in memory (ISO/IEC9899/TC2)
p831
aVAlthough your example reinterprets the address of  as an address of , it does not reference memory location inside  through the reinterpreted pointer, because  is located past the boundary of
p832
aVSince memory locations referenced through pointers are not the same, I'd say that it is not in violation of the strict aliasing rule
p833
aVFWIW,  seems to agree with that assessment, and does not produce a warning
p834
aVThis is not enough to decide that it's legal code, though: your example makes an assumption that the address of a nested structure is the same as that of its outer structure
p835
aVIncidentally, this is a safe assumption to make according to the C99 standard:
p836
aV6
p837
aV7
p838
aV2
p839
aV1-13
p840
aVA pointer to a structure object, suitably converted, points to its initial member
p841
aVThe two considerations above make me think that your code is legal
p842
as(dp843
g6
V335858
p844
stp845
a((dp846
g2
(lp847
VYour code uses the default initializer for the union, which is its first member
p848
aVBoth 12 and 1 go into the characters of ax, hence the result that you see (which is very much compiler-dependent)
p849
aVIf you wanted to initialize through the second memmber () you would use a designated initializer:
p850
as(dp851
g6
V335858
p852
stp853
a((dp854
g2
(lp855
VAssuming that  and  are two parameters passed to your stored procedure, all it needs to do is to run this update statement:
p856
as(dp857
g6
V335858
p858
stp859
a((dp860
g2
(lp861
VYou are assigning  instead of
p862
as(dp863
g6
V335858
p864
stp865
a((dp866
g2
(lp867
VThis should work:
p868
as(dp869
g6
V335858
p870
stp871
a((dp872
g2
(lp873
VIt looks like your code of the  is missing the part of what to do on insertion:
p874
aVWithout this code, your  has only the old objects when you switch away and come back
p875
aVYou should also initiate reload of the data from the model at the end of the method:
p876
as(dp877
g6
V335858
p878
stp879
a((dp880
g2
(lp881
VYou did not finish initializing your array
p882
aVThe initializer at the point of declaration also has no effect, you can remove the assignment, since you're initializing the array in the constructor anyway
p883
as(dp884
g6
V335858
p885
stp886
a((dp887
g2
(lp888
VPassing  to a UI class is not in itself a problem, as long as the methods of the class are not called through , as in your example
p889
aVYou call  right in the constructor of the , which should be avoided: your  class may not be ready to return the correct result
p890
aVOne thing to note is that you couple your  to the  class, which may be too much coupling
p891
aVYou should consider extracting an interface from , and let  interact only with what's intended for it:
p892
as(dp893
g6
V335858
p894
stp895
a((dp896
g2
(lp897
VSince you are simply retrieving a member of the  by its primary key, and you know there will be exactly one staff member by that ID, you should replace  with
p898
aVEdit 1:
p899
aVPerhaps you can fold your query a bit:
p900
aVEdit 2:
p901
as(dp902
g6
V335858
p903
stp904
a((dp905
g2
(lp906
VThere is a post that appears to imply that you can fool XCode into using svn 1
p907
aV7 client by changing your PATH and setting up a couple of soft links in strategic places
p908
aVUnfortunately, the post is in Chinese
p909
aVFortunately, Google translate and the presence of UNIX commands make it possible to decrypt what the post is saying
p910
aVI will try it in the next few days, and update the answer if anything useful comes out of this exercise
p911
aVEDIT: I tried the steps from the post, and it worked
p912
aVHere is what I did:
p913
aVDownloaded and installed svn client 1
p914
ag838
aV2 into
p915
aVAdded /opt/subversion/bin to my  in
p916
aVCreated a backup directory
p917
aVMoved  to
p918
aVRan
p919
aVAfter that I re-started XCode, went to Organizer, and was able to attach a working copy of a checkout created with svn 1
p920
ag838
aV2 client
p921
aVOrganizer showed a green dot next to the repository, displayed a list of revisions, etc
p922
aV, so at this point I believe that the trick has worked
p923
as(dp924
g6
V335858
p925
stp926
a((dp927
g2
(lp928
VThis is not going to work:  is based on hash code and equality checks; arrays do not pay attention to their elements when calculating their hash code
p929
aVThat's why the two arrays that you tried to use as keys are considered different
p930
aVYou can define a class , put an array into it in a constructor, and define  and  that use array elements
p931
as(dp932
g6
V335858
p933
stp934
a((dp935
g2
(lp936
VIf  is the diagonal and  is the ratio of  to , then
p937
aVHere is why:
p938
aVA*A + B*B = D*D
p939
as(dp940
g6
V335858
p941
stp942
a((dp943
g2
(lp944
VUsing plain URLs is a sure way of letting script kiddies run you out of business
p945
aVIf there is no way for you to track if a call to the expensive web service was legitimate, set up your own web service that fronts the real web service to make sure that your own web service can verify the legitimacy of the call before forwarding the request to the real web service
p946
as(dp947
g6
V335858
p948
stp949
a((dp950
g2
(lp951
VWhen , the replacement string becomes
p952
aVIt contains a reference to group number 110, which certainly does not exist
p953
aVYou need to make sure that your proxy string does not start in a digit
p954
aVIn your case you can do it by not capturing the last slash, and changing the replacement string to , like this:
p955
aVEdit:
p956
aVRawling pointed out that
p957
aVNET's regexp library addresses this issue: you can enclose  in curly braces to avoid false aliasing, like this:
p958
as(dp959
g6
V335858
p960
stp961
a((dp962
g2
(lp963
VUsing  skips the file, and gets you command's output through an in-memory buffer
p964
as(dp965
g6
V335858
p966
stp967
a((dp968
g2
(lp969
VYou need to hide  from SQL parser, because it is part of the string literal:
p970
as(dp971
g6
V335858
p972
stp973
a((dp974
g2
(lp975
VTry extending your mask to 32 bits, like this:
p976
aVEdit: I did a quick check, and it appears to work for my test case
p977
aVNice formula, by the way
p978
as(dp979
g6
V335858
p980
stp981
a((dp982
g2
(lp983
VYou know that you are not calling  on an , but the compiler does not: your  is evaluated at run-time
p984
aVSince  is the only special case in your template, try this:
p985
as(dp986
g6
V335858
p987
stp988
a((dp989
g2
(lp990
VAt the minimum, you should decouple your classes with interfaces
p991
aVThis way your intended contract between the two classes would be captured explicitly through the interfaces
p992
aVOther than that, it depends a lot on the nature of interaction that you are planning
p993
as(dp994
g6
V335858
p995
stp996
a((dp997
g2
(lp998
VAdd a  to the table
p999
aVYou can find out the cell on which the user long-pressed by calling
p1000
aVSee the accepted answer to this question for a complete example
p1001
as(dp1002
g6
V335858
p1003
stp1004
a((dp1005
g2
(lp1006
VYou can make a method that takes one or more strings, like this:
p1007
aVThe benefit of this approach becomes evident when you need to test session for other things:
p1008
as(dp1009
g6
V335858
p1010
stp1011
a((dp1012
g2
(lp1013
VHere is an excellent article on the subject of working with floats
p1014
aVThere is a discussion covering precisely your example - an increment of 0
p1015
aV1:
p1016
aVHow many stars is it going to print
p1017
aVTen
p1018
aVRun it and be surprised
p1019
aVThe code just keeps on printing the stars until we break it
p1020
aVWhere's the problem
p1021
aVAs we already know, doubles are not infinitely precise
p1022
aVThe problem we encountered here is the following: In binary, the representation of 0
p1023
aV1 is not finite (as it is in base 10)
p1024
aVDecimal 0
p1025
aV1 is equivalent to binary 0
p1026
aV0(0011), where the part in the parentheses is repeated forever
p1027
aVWhen 0
p1028
aV1 is stored in a double variable, it gets rounded to the closest representable value
p1029
aVThus if we add it 10 times the result is not exactly equal to one
p1030
aVI highly recommend reading the whole article if you work a lot with floating point numbers
p1031
as(dp1032
g6
V335858
p1033
stp1034
a((dp1035
g2
(lp1036
VIf I understand your intent correctly, the  is a factory method
p1037
aVIf this assumption is correct, you should declare it in the  class (notice the  - it's an indicator of a class method), and rewrite the implementation like this:
p1038
aVLater you can use it in your code:
p1039
aVBecause of the synthesize, there is no dealloc method, if I understand that correctly
p1040
aVNo, dealloc is not there because of Automatic Reference Counting (the presence of  modifier tells you that you're in the ARC land)
p1041
as(dp1042
g6
V335858
p1043
stp1044
a((dp1045
g2
(lp1046
Vs override of the  method is invoked because that's what the Java spec calls for
p1047
aVHere is a great discussion of why you should not do it
p1048
aVThe value of x is zero because  has not finished initializing yet
p1049
as(dp1050
g6
V335858
p1051
stp1052
a((dp1053
g2
(lp1054
VYou cannot do it, because the object returned from  already inherits from some other class, and you cannot inherit from two classes in Java
p1055
aVYou need to keep  as an instance variable of your class that implements the  interface
p1056
aVYou will initialize  in the constructor of the , and provide an interface to access  through a method:
p1057
aVYour  should respond to calls of  by returning its  member
p1058
as(dp1059
g6
V335858
p1060
stp1061
a((dp1062
g2
(lp1063
VStart with the  from the picker, and keep adding 24*60*60 seconds to it until it's a Monday
p1064
aVAdd the resulting date to the result
p1065
aVContinue adding 7*24*60*60 seconds to the last date you added and pushing the result onto the return list until you have all 64 Mondays
p1066
aVHere is how you tell if a  falls on Monday:
p1067
aVEDIT: DaveDeLong pointed out a deficiency in the above algorithm: it will shift the time two times on the days of changing to daylight savings time
p1068
aVInstead of counting seconds manually, use this code to add a day to :
p1069
as(dp1070
g6
V335858
p1071
stp1072
a((dp1073
g2
(lp1074
VYou can create an array of size known at runtime with the "new" operator:
p1075
as(dp1076
g6
V335858
p1077
stp1078
a((dp1079
g2
(lp1080
VIf you are not reaching either of the two branches, it must be because  returns
p1081
aVI don't see another way of making it happen
p1082
as(dp1083
g6
V335858
p1084
stp1085
a((dp1086
g2
(lp1087
VThere is no legal way of doing it: the class is sealed, and the property is read-only
p1088
aVIf the class implements an interface with the  property, you could wrap that class into yours, and provide a getter and a setter
p1089
aVAs it stands, however, your only choice is hacking through reflection, and it's not a valid choice at all
p1090
aVDepending on how the property is implemented, it may be impossible even with reflection
p1091
as(dp1092
g6
V335858
p1093
stp1094
a((dp1095
g2
(lp1096
VThe problem with your code is that it is assuming that  denotes a regular type
p1097
aVIt is not a normal type: rather, it is a generic type definition
p1098
aVThat is why the  ,  etc
p1099
aVare not going to work
p1100
aVis of type  if the following condition is true:
p1101
as(dp1102
g6
V335858
p1103
stp1104
a((dp1105
g2
(lp1106
VThe function takes a reference, so you need to pass it a variable of which the compiler may take an address
p1107
as(dp1108
g6
V335858
p1109
stp1110
a((dp1111
g2
(lp1112
VHere is the closest thing to your code in C#  (it is not exactly the same, because in Objective-C you can "override" static methods, but in C# you cannot)
p1113
as(dp1114
g6
V335858
p1115
stp1116
a((dp1117
g2
(lp1118
VHere is an example of using va_list
p1119
aVYou can get the same effect if you pass an array and a count instead of var args, like this:
p1120
as(dp1121
g6
V335858
p1122
stp1123
a((dp1124
g2
(lp1125
VYou need to take address (as in ) only when you pass arguments to
p1126
aVInteger and single-character arguments of  are passed by value:
p1127
aVCalls to , on the other hand, require pointers
p1128
aVSince you are scanning single-characters as characters, not as strings, you should be passing an address of room, paintcode, etc
p1129
as(dp1130
g6
V335858
p1131
stp1132
a((dp1133
g2
(lp1134
V provides storage for references to elements, but it does not construct the elements themselves
p1135
aVYou need to assign them individually in your code:
p1136
aVThis works differently for value types: if you make  a , you wouldn't need two loops
p1137
as(dp1138
g6
V335858
p1139
stp1140
a((dp1141
g2
(lp1142
VTry moving the read of the file to outside the loop:
p1143
as(dp1144
g6
V335858
p1145
stp1146
a((dp1147
g2
(lp1148
VYou cannot force a method change upon a class from the outside
p1149
aVThere are ways to achieve functionality like that when either (1) classB is designed in such a way as to support replacing its methods, e
p1150
ag303
aVthough a settable delegate, or (2) if classB implements an interface, which you can implement, wrap classB inside it, and replace a method
p1151
aVExample #1 - settable delegate:
p1152
aVExample #2 - interfaces
p1153
as(dp1154
g6
V335858
p1155
stp1156
a((dp1157
g2
(lp1158
VYou cannot do it in a single statement: the pointer (actually, the reference) that you would like to be assigned to  is not allocated at the time you want to assign it
p1159
aVYou need to use an intermediate variable - for example, like this:
p1160
as(dp1161
g6
V335858
p1162
stp1163
a((dp1164
g2
(lp1165
VYou need to add a check for the args itself to be non-null
p1166
aVThe ANE is not appropriate for individual components, so you need to use more general AE, like this:
p1167
as(dp1168
g6
V335858
p1169
stp1170
a((dp1171
g2
(lp1172
VIn C++ you cannot combine declaration and initialization
p1173
aVWhen you do not specify constructor parameters of , you do not call its default constructor: you simply declare it
p1174
aVYou need to also initialize it in the corresponding C++ file, like this:
p1175
aVEquation
p1176
aVh
p1177
aVEquation
p1178
aVcpp:
p1179
aVNote the absence of  in the CPP file: it is not there by design
p1180
aVThe compiler already knows from the declaration that  is static
p1181
aVEdit: You have a choice with static constant members of integral and enumerated types: you can initialize them in the CPP file as in the example above, or you can give them a value in the header
p1182
aVYou still need to define that member in your C++ file, but you must not give it a value at the definition time
p1183
as(dp1184
g6
V335858
p1185
stp1186
a((dp1187
g2
(lp1188
VWhen you iterate a
p1189
aVNET collection using its iterator, you must not modify that collection
p1190
aVIf you do, you are asking for trouble
p1191
aVYou should defer the deletion instead of deleting right in the  loop
p1192
aVFor example, you can collect everything you need to delete in a list, and then delete it outside of
p1193
as(dp1194
g6
V335858
p1195
stp1196
a((dp1197
g2
(lp1198
VIt is not too hard, and you do not need to know much about pointers:
p1199
aVNote that the initial argument (at position 0) is the name of the program
p1200
aVThat is what C programs expect: their first "actual" argument is at position 1
p1201
as(dp1202
g6
V335858
p1203
stp1204
a((dp1205
g2
(lp1206
VSince integer/long division drops the decimal part altogether, and because your  is declared as , the result of  is an integer
p1207
aVThe result of  is a double, because  forces the result of the division into
p1208
aVYou can also specify the type as  explicitly, as in the snippet below:
p1209
as(dp1210
g6
V335858
p1211
stp1212
a((dp1213
g2
(lp1214
VYou need to synchronize access to your map, for example by using a POSIX mutex
p1215
aVThe link has some simple to follow examples of how you use mutual exclusion variables
p1216
as(dp1217
g6
V335858
p1218
stp1219
a((dp1220
g2
(lp1221
VThe depth is usually used to describe a property of a tree node, while the height is used to describe the property of the entire tree, as in the following examples:
p1222
aVRoot node has a depth of zero
p1223
aVNode X has a depth of N
p1224
aVThe height of the tree is M
p1225
aVThe height of a tree is defined as the depth of its deepest node
p1226
as(dp1227
g6
V335858
p1228
stp1229
a((dp1230
g2
(lp1231
VAnonymous type is a regular static type in
p1232
aVNET, it's just that you do not give it a name (a compiler, however, does)
p1233
aVThat's why casting it to  will not work
p1234
aVHowever, if you have control over , you can construct and return a  object instead of anonymous, and then your code is going to work
p1235
aVThis should do the trick:
p1236
as(dp1237
g6
V335858
p1238
stp1239
a((dp1240
g2
(lp1241
VIf using boost is an option, and the library takes  (as opposed to an ) you could use a File Descriptor Sink to wrap your file descriptor, construct a stream from of it, and pass it to your target library
p1242
as(dp1243
g6
V335858
p1244
stp1245
a((dp1246
g2
(lp1247
VYou can call  of the view that you need redrawn on timer, and have its  call your  (instead of calling your  on timer directly)
p1248
aVThis way you would avoid unusual manipulations with your CG Context, and prevent rendering when the rectangle has been scrolled off the screen
p1249
aVEdit:
p1250
aVYou use UIGraphicsPushContext and UIGraphicsPopContext when you want a specific context to become the context on which UI Kit operates
p1251
aVMy initial understanding of what they do was incorrect (I'm relatively new to iOS development myself)
p1252
aVFor example, there are operations (e
p1253
ag303
aVsome operations setting a color or other drawing parameters) that operate implicitly on the current context
p1254
aVIf you set up a context for, say, drawing on a bitmap, and then you want to use an operation that modifies the state of the current context (i
p1255
ag630
aVan operation that modifies the context parameters, but does not take a specific context reference as a parameter), you push the bitmap context to make it current, perform the operation that implicitly references it, and pop the context right back
p1256
aVSpecial thanks go to rob mayoff for explaining this to me
p1257
as(dp1258
g6
V335858
p1259
stp1260
a((dp1261
g2
(lp1262
VIf a method is meaningless in the superclass, adding it there simply to avoid casting is not a good idea
p1263
aVIf a method is meaningful in the superclass, and it should reasonably take no action there, then you should put the method in the superclass and override it in the subclass
p1264
aVIf the functionality of the added method does not belong in a superclass at all, add and implement a second interface in your subclass, and program to that interface instead when you need the additional functionality
p1265
aVEdit: You can add an interface , and add it to the subclass that needs
p1266
aVIf you add more subclasses that need , make them implement that interface too
p1267
as(dp1268
g6
V335858
p1269
stp1270
a((dp1271
g2
(lp1272
VYou need to use  in order to put ints into
p1273
as(dp1274
g6
V335858
p1275
stp1276
a((dp1277
g2
(lp1278
VHere is how you sort arrays using custom logic, with alphabetic sorting for tie-breaking:
p1279
as(dp1280
g6
V335858
p1281
stp1282
a((dp1283
g2
(lp1284
VYou can group and total the numbers one by one, like this:
p1285
aVHere is a link with explanations of this subject from Microsoft
p1286
aVEdit: added grouping
p1287
as(dp1288
g6
V335858
p1289
stp1290
a((dp1291
g2
(lp1292
VYou need to tell your  that the data has changed by calling
p1293
as(dp1294
g6
V335858
p1295
stp1296
a((dp1297
g2
(lp1298
VYou cannot use array lists without synchronization, because the parceling thread (thread #6) will be writing to the places from which the other five would be reading
p1299
aVUsing  is a good choice for your task
p1300
aVCreate and initialize an array of five  objects, and pass each thread the index of its collection in the array through the parameter object
p1301
aVEach of the five "worker" threads should loop on the call to  on the blocking collection at the index passed at initialization, and do whatever they need to do
p1302
aVThe work parceling thread should use  to add values designated for each thread
p1303
as(dp1304
g6
V335858
p1305
stp1306
a((dp1307
g2
(lp1308
VIf I got your meaning right and you need the latest date from TableB, then the query below should do it:
p1309
as(dp1310
g6
V335858
p1311
stp1312
a((dp1313
g2
(lp1314
VThe trick to solving recursive problems is to pretend that you are done already
p1315
aVTo solve this homework by yourself, you need to answer three questions:
p1316
aVHow do you reverse an empty list
p1317
aV(i
p1318
ag630
aVa list with  set to )
p1319
aVHow do you reverse a list with only one item
p1320
aVIf someone could reverse all items on the list except the initial one for you, where do you add the first item from the initial list to the pre-reversed "tail" portion of the list
p1321
aVYou answered the first two already:  and  are the right answers
p1322
aVNow think of the third one:
p1323
aVAt this point,  contains pre-reversed tail of your list
p1324
aVAll you need to do is set lh->next to NULL, add it to the back of the list that you are holding, and return
p1325
aVThe final code looks like this:
p1326
as(dp1327
g6
V335858
p1328
stp1329
a((dp1330
g2
(lp1331
VYou can provide an implementation of  that does not rely on a
p1332
aVInstead of filling it before evaluation, you can treat its checks for ,  as your callbacks, and ignore the calls to
p1333
as(dp1334
g6
V335858
p1335
stp1336
a((dp1337
g2
(lp1338
VThere is also a third choice: put the columns that all users have in common into , and create three tables for ,  and  joining to  as 1 to 0
p1339
aV1
p1340
aVYou should consider this choice as an alternative when the number of shared columns is significant
p1341
as(dp1342
g6
V335858
p1343
stp1344
a((dp1345
g2
(lp1346
VOur product ran into this limitation back in the
p1347
aVNET 3
p1348
aV5 days, when the limit was 4
p1349
aVWe ended up grouping the extra parameters in a single object, for which we created a monstrous generic type with 32 type parameters:
p1350
aVThis worked quite well for us
p1351
aVEventually we extended it to 64, and created 64 different classes to avoid padding type parameters with , like is shown above
p1352
aVOf course we wrote a little script to generate these 64 generic classes
p1353
as(dp1354
g6
V335858
p1355
stp1356
a((dp1357
g2
(lp1358
VUse  command to figure out the name of the missing function
p1359
aVIn your case, it's
p1360
as(dp1361
g6
V335858
p1362
stp1363
a((dp1364
g2
(lp1365
VYou may not use  attribute with public members, because it confuses the tester
p1366
aVAccording to this,  is used to test private properties and methods as if they were public
p1367
aVYour property is already public, so you need to remove  from its declaration
p1368
as(dp1369
g6
V335858
p1370
stp1371
a((dp1372
g2
(lp1373
V is used as a flag variable (i
p1374
ag630
aVa variable that communicates a single binary condition, yes or no)
p1375
aVThe program sets  to one when it has interpreted the character  as a special character, and printed its slash-prefixed value
p1376
aVThe program checks that  flag later on to determine if it has printed  or not
p1377
aVIf the answer is no, then the program prints ; otherwise, it continues to the next iteration of the loop
p1378
as(dp1379
g6
V335858
p1380
stp1381
a((dp1382
g2
(lp1383
VLine1 does definition of the static data member , which includes setting its value
p1384
aVFor static data members of non-integral types, member definition is indeed the only place to set a value
p1385
aVFor integers, longs, enums, etc
p1386
aVyou can put the value in with the declaration
p1387
aVYou must still include a definition, but in that case you must not put in any value
p1388
aVEDIT: As Mike Seymor pointed out, the #2 is out of date
p1389
aVAccording to the new C++11 standard, the alternative syntax that was reserved only for integral types by the 1998 and C++03 standards has been extended to all constants, regardless of their type
p1390
as(dp1391
g6
V335858
p1392
stp1393
a((dp1394
g2
(lp1395
VThis should work:
p1396
as(dp1397
g6
V335858
p1398
stp1399
a((dp1400
g2
(lp1401
VThere are two ways of printing decimals - on CPUs with division/remainder instructions (modern CPUs are like that) and on CPUs where division is relatively slow (8-bit CPUs of 20+ years ago)
p1402
aVThe first method is simple: int-divide the number by ten, and store the sequence of remainders in an array
p1403
aVOnce you divided the number all the way to zero, start printing remainders starting from the back, adding the ASCII code of zero () to each remainder
p1404
aVThe second method relies on the lookup table of powers of ten
p1405
aVYou define an array of numbers like this:
p1406
aVThen you start with the largest power, and see if you can subtract it from the number at hand
p1407
aVIf you can, keep subtracting it, and keep the count
p1408
aVOnce you cannot subtract it without going negative, print the count plus the ASCII code of zero, and move on to the next smaller power of ten
p1409
as(dp1410
g6
V335858
p1411
stp1412
a((dp1413
g2
(lp1414
VYour sort does not work because you are sorting on a string literal
p1415
aVIt is not illegal, but it is not particularly useful either
p1416
aVYou need to provide a sorting field through the API of , for example, like this:
p1417
as(dp1418
g6
V335858
p1419
stp1420
a((dp1421
g2
(lp1422
VYou need to use reflection to call a generic with the type parameter not known at compile time, like this:
p1423
as(dp1424
g6
V335858
p1425
stp1426
a((dp1427
g2
(lp1428
VIt does not work because  is passed by value
p1429
aVAssigning  to it has no effect on the caller's end
p1430
aVYour algorithm for detecting duplicates seems fine
p1431
aVIf you do not want to use a more elegant LINQ way suggested in the other answer, change the method to return your list:
p1432
as(dp1433
g6
V335858
p1434
stp1435
a((dp1436
g2
(lp1437
VThis is because you have semicolons in your
p1438
aVThis is how it should look:
p1439
aVdoes a literal text substitution, so your line looks like this to the compiler:
p1440
aVview_height = (float) width * 800; / 700;;
p1441
as(dp1442
g6
V335858
p1443
stp1444
a((dp1445
g2
(lp1446
VYou need to copy the content of the file in binary mode, like this:
p1447
aVYour current program reads it as a very long string in UTF-8 encoding, which probably accounts for the change in file size
p1448
as(dp1449
g6
V335858
p1450
stp1451
a((dp1452
g2
(lp1453
VOnce you have constructed your tree map, copy its sorted keys into an array, and use  to look up the index in O(logN) time
p1454
aVIf you need the value, do a lookup on the original map too
p1455
aVEdit: this is how you copy keys into an array
p1456
as(dp1457
g6
V335858
p1458
stp1459
a((dp1460
g2
(lp1461
s(dp1462
g6
V335858
p1463
stp1464
a((dp1465
g2
(lp1466
V will put a digit only if it is not a leading zero
p1467
aVwill put a digit even if it is a trailing zero
p1468
aVYou could use zeros in front, too, if you wanted a fixed number of digits printed
p1469
as(dp1470
g6
V335858
p1471
stp1472
a((dp1473
g2
(lp1474
VI am not very good at VB syntax, but you know that something is Nullable(Of [Enum]) when this condition is true:
p1475
aVEdit: corrected syntax (once again)
p1476
as(dp1477
g6
V335858
p1478
stp1479
a((dp1480
g2
(lp1481
VThe two functions are implemented in exactly the same way
p1482
aVLogically, however, extension methods let you provide common functionality across multiple interfaces, so it is more than just a "syntactic sugar"
p1483
as(dp1484
g6
V335858
p1485
stp1486
a((dp1487
g2
(lp1488
VThis block of code is intended for use by programs that make decisions based on what they read from the stream
p1489
aVSometimes such programs need to look at a few character from the stream without actually consuming the input
p1490
aVFor example, if your input looks like  and you must split it into , , ,  (i
p1491
ag630
aVseparate groups of consecutive letters from groups of consecutive digits) you do not know that you have reached the end of a group of letters until you see a digit
p1492
aVHowever, you do not want to consume that digit at the time you see it: all you need is to know that the group of letters is ending; you need a way to "put back" that digit
p1493
aVAn  comes in handy in this situation: once you see a digit after a group of letters, you put the digit back by calling
p1494
aVYour next iteration will pick that digit back up through the same  mechanism, sparing you the need to preserve the character that you read but did not consume
p1495
as(dp1496
g6
V335858
p1497
stp1498
a((dp1499
g2
(lp1500
VNew line is printed after, not before the text that you pass to
p1501
as(dp1502
g6
V335858
p1503
stp1504
a((dp1505
g2
(lp1506
VYou are correct, the recognition and interpretation of this attribute is built into the compiler
p1507
as(dp1508
g6
V335858
p1509
stp1510
a((dp1511
g2
(lp1512
VYou assign the value of  to , and then immediately override it with the value of another array of ints
p1513
aVIn   and  no longer reference the same place in memory, and  remains uninitialized (hence the garbage)
p1514
as(dp1515
g6
V335858
p1516
stp1517
a((dp1518
g2
(lp1519
VThis is because you increment  before setting
p1520
aVThis leaves  set to a potentially incorrect value
p1521
aVUse  instead, and in general, pay attention to the order of your increments: there are more places in your program where you got it wrong :)
p1522
as(dp1523
g6
V335858
p1524
stp1525
a((dp1526
g2
(lp1527
V and / are orthogonal, meaning that any combination of them is valid
p1528
aVsays that there is a strong link between the object and its retained property (i
p1529
ag630
aVthe object referenced by the property should not be released while it is pointed to by this object)
p1530
aV/ means that the access to the property should or should not be synchronized
p1531
aVHere is a great explanation of the atomic/nonatomic
p1532
aVNote that all of this is meaningful only when you use
p1533
as(dp1534
g6
V335858
p1535
stp1536
a((dp1537
g2
(lp1538
VThat is exactly what happens, unless  starts a new thread
p1539
as(dp1540
g6
V335858
p1541
stp1542
a((dp1543
g2
(lp1544
VRegardless of which thread has registered a delegate with the singleton (or added an event to the singleton, it does not matter) the notification will happen in the context of the notifying thread
p1545
aVIf you need to make one thread do things as directed by another thread, you need to communicate that intent with data
p1546
aVFor example, each thread could set up a blocking queue, and wait for items to be pushed into their queue by others
p1547
aVThese items could be delegates, objects, or pure data items that need to be interpreted before taking an action
p1548
aVThe important thing is that in order for the action to happen in a thread, the thread itself must execute that action
p1549
as(dp1550
g6
V335858
p1551
stp1552
a((dp1553
g2
(lp1554
VYou need a slash in front of the quote in the literal:
p1555
as(dp1556
g6
V335858
p1557
stp1558
a((dp1559
g2
(lp1560
VYou can tell that they are not using a split view controller by turning the screen vertically: split view moves the master into a popover; contacts simply rotates, without popping the master portion out
p1561
aVI think that they use a single, highly customized, view for the contacts
p1562
as(dp1563
g6
V335858
p1564
stp1565
a((dp1566
g2
(lp1567
VYou need to group by the author, and pick the :
p1568
aVYou should also consider using a modern join syntax, and preserve info about authors with different IDs but the same last name:
p1569
as(dp1570
g6
V335858
p1571
stp1572
a((dp1573
g2
(lp1574
VI think the use of  makes it clear to the readers of your code that you expect precisely one item
p1575
aVYou can add an assert after the end to catch logical errors, like this:
p1576
as(dp1577
g6
V335858
p1578
stp1579
a((dp1580
g2
(lp1581
VThere is a quick and dirty way to find out, and it works for both built-in and custom types
p1582
aVIts major drawback is that it relies on exceptions in a normal flow, but it gets the job done
p1583
as(dp1584
g6
V335858
p1585
stp1586
a((dp1587
g2
(lp1588
VThere's always a  statement, but I would recommend nesting an  with an inverse of the breaking condition
p1589
as(dp1590
g6
V335858
p1591
stp1592
a((dp1593
g2
(lp1594
VAdd a common interface to your  classes, define  there, and add a constraint to your generic requiring  parameters to implement the common interface
p1595
as(dp1596
g6
V335858
p1597
stp1598
a((dp1599
g2
(lp1600
VFlatten the list, and then do a normal  condition:
p1601
as(dp1602
g6
V335858
p1603
stp1604
a((dp1605
g2
(lp1606
VIf you give your decimal a smaller scale, it is going to work:
p1607
aVThis returns
p1608
as(dp1609
g6
V335858
p1610
stp1611
a((dp1612
g2
(lp1613
VDespite the fact that writing code in assembly became increasingly rare, it is still very good to learn assembly simply to understand how things work under the hood
p1614
aVModern optimizing compilers of C/C++ let you write code in C that translates into assembly instructions of very high quality, often surpassing what you could write manually at the expense of making the result less readable (e
p1615
aVg by inserting empty instructions to optimize the use of CPU's pipeline)
p1616
aVIf you write a compiler for a new architecture, a very low-level library, or an embedded system with strict resource constraints, you may need to use assembly
p1617
aVFor everything else, C and C++ will do as well or better
p1618
as(dp1619
g6
V335858
p1620
stp1621
a((dp1622
g2
(lp1623
V chooses a format based on the value being formatted to achieve the most compact representation
p1624
aVIf you would like to choose a specific format, you need to use the  overload instead
p1625
aVFor example, if you call
p1626
aVyou will get  string as the result
p1627
as(dp1628
g6
V335858
p1629
stp1630
a((dp1631
g2
(lp1632
VThis is a dirty hack to force a memory release: if the rest of your program is written correctly, you never need to do anything like this
p1633
aVNormally, your retains and releases are in balance, so you never need to look at the retain count
p1634
aVWhat this piece of code says is "I don't know who retained me and forgot to release, I just want my memory to get released; I don't care that the others references would be dangling from now on"
p1635
aVThis is not going to compile with ARC (oddly enough, switching to ARC may just fix the error the author was trying to work around)
p1636
as(dp1637
g6
V335858
p1638
stp1639
a((dp1640
g2
(lp1641
VYes, the task will always complete
p1642
aVThe garbage collector is not going to get to its relevant parts while the task is running
p1643
as(dp1644
g6
V335858
p1645
stp1646
a((dp1647
g2
(lp1648
VDefinitions are not executable code
p1649
aVThey are just instructions to the compiler, letting it know the size and the type of the variable
p1650
aVIn this sense, the definition is not bypassed by the  statement
p1651
aVIf you use a class with a constructor instead of an , the call of the constructor would be bypassed by the , but the storage would be allocated anyway
p1652
aVThe class instance would remain uninitialized, however, so using it before its definition/initialization line gets the control is an error
p1653
as(dp1654
g6
V335858
p1655
stp1656
a((dp1657
g2
(lp1658
VTry a recursive approach:
p1659
aVCall  passing it the desired number of 0's and 1's
p1660
aVFor example, if you need 3 ones and 3 zeros, call it like this:
p1661
as(dp1662
g6
V335858
p1663
stp1664
a((dp1665
g2
(lp1666
VYou need to declare it , like this , and use it without prefixes:
p1667
as(dp1668
g6
V335858
p1669
stp1670
a((dp1671
g2
(lp1672
V expects an assignable value, i
p1673
ag630
aVa variable
p1674
aVreturns a value that cannot be assigned
p1675
aVIf you need a value plus one, use  instead
p1676
as(dp1677
g6
V335858
p1678
stp1679
a((dp1680
g2
(lp1681
VThe issue is most likely in the  line
p1682
aVIf you change it to
p1683
aVyou should see the exception thrown on that line, because you force evaluation of the
p1684
aVInstead of comparing objects, you should compare their IDs, like this:
p1685
aV(edited to reflect the conversation in the comments and changes to the OP)
p1686
as(dp1687
g6
V335858
p1688
stp1689
a((dp1690
g2
(lp1691
VI assume that  is a local variable, right
p1692
aVTry declaring the array static - then its data should get loaded from a text block
p1693
aVThe meaning of the variable and its initialization is going to change, however
p1694
as(dp1695
g6
V335858
p1696
stp1697
a((dp1698
g2
(lp1699
VA number of minutes is a time interval, not an absolute date
p1700
aVYou need to know what does the number of minutes represent, i
p1701
ag630
aVthe number of minutes since what event, in order to get an absolute date
p1702
aVAssuming it's the number of minutes since the beginning of, say, a specific year, you can do it like this:
p1703
as(dp1704
g6
V335858
p1705
stp1706
a((dp1707
g2
(lp1708
VAssuming it's UNIX time in milliseconds, try this:
p1709
aVFor the number from your post, SQL-2008 returns
p1710
as(dp1711
g6
V335858
p1712
stp1713
a((dp1714
g2
(lp1715
VTry this:
p1716
as(dp1717
g6
V335858
p1718
stp1719
a((dp1720
g2
(lp1721
VIn order to move to the next letter in the word fact, you need to make the word from the fact a third argument, and take it along for the ride
p1722
aVIn your , you will pick words one by one, and call , passing the word you picked along, like this:
p1723
aVThe you'll need to change your base case to do something when the letters in the word being corrected run out before the letters of the word that you picked
p1724
aVWhat you do depends on your assignment: you could backtrack , declare a match , attach word's tail to the correction  or do something else
p1725
aVYou also need an easy case to cover the situation when the first letter of the word being corrected matches the first letter of the word that you picked:
p1726
aVFinally, you need the most important case: what to do when the initial letters do not match
p1727
aVThis is probably the bulk of your assignment: the rest is just boilerplate recursion
p1728
aVIn order to get it right, you may need to change  to  to be able to calculate the number of matches, and later compare it to the number of letters in the original word
p1729
aVThis would let you drop "corrections" like  -->  as having only 20% of matching letters
p1730
as(dp1731
g6
V335858
p1732
stp1733
a((dp1734
g2
(lp1735
VEven if C# compiler supported tail recursion optimization (which it does not) it wouldn't detect it in case of your program, because  does not call itself directly
p1736
aVA functor that it uses calls , but that is not enough to optimize a recursive tail call
p1737
aVOn a side note,  provides a more compact replacement for  in your case:
p1738
as(dp1739
g6
V335858
p1740
stp1741
a((dp1742
g2
(lp1743
VYou're almost there: it's
p1744
as(dp1745
g6
V335858
p1746
stp1747
a((dp1748
g2
(lp1749
VYou are almost there:
p1750
aVuse
p1751
aVinstead of
p1752
aVIf you need to set all elements of your vector to a value other than zero, say, , use
p1753
as(dp1754
g6
V335858
p1755
stp1756
a((dp1757
g2
(lp1758
V,  and  are expressions
p1759
aVThey denote special built-in values, so they are considered literals (along with more traditional literals, such as  and )
p1760
aV, , , etc
p1761
aVare keywords
p1762
aVThey communicate your declarations and statements to the compiler, but they do not represent values
p1763
aVThat is why they are not literals
p1764
as(dp1765
g6
V335858
p1766
stp1767
a((dp1768
g2
(lp1769
VA better approach would be to not format dates at all, parameterize your  statement, and pass dates as command parameters
p1770
as(dp1771
g6
V335858
p1772
stp1773
a((dp1774
g2
(lp1775
VTo trace this recursive call in a debugger, set break point on the  statement, and run your program
p1776
aVWhen the breakpoint is reached:
p1777
aVInspect the value of ,
p1778
aVLook at the call stack window
p1779
aVThe number of items on the call stack would grow with each recursive invocation; the value of  would go down by one
p1780
aVWhen you are several levels deep into the call, click different items on the call stack
p1781
aVIt would bring you to the call site (i
p1782
ag630
aV)
p1783
aVYou will be able to inspect the value of  at this level of the stack
p1784
as(dp1785
g6
V335858
p1786
stp1787
a((dp1788
g2
(lp1789
VThis is because the  part is "erased" from the type in Java (i
p1790
ag630
aVthe class of  and  is exactly the same)
p1791
as(dp1792
g6
V335858
p1793
stp1794
a((dp1795
g2
(lp1796
VThis is usually done for audit purposes
p1797
aVYou should do it only if you have a corresponding requirement in your design
p1798
aVFor stronger flavors of history keeping, consider CQRS, or temporal tables
p1799
as(dp1800
g6
V335858
p1801
stp1802
a((dp1803
g2
(lp1804
VUnless you are willing to go into dynamic SQL territory (which would likely be an overkill for something like an ) consider using :
p1805
aVAs gbn noted below, this would work only because your three sort columns are of the same type
p1806
aVHad it not been like that, you'd need to add a cast (perhaps to ) in order for the SQL server to accept your query
p1807
as(dp1808
g6
V335858
p1809
stp1810
a((dp1811
g2
(lp1812
VIt is
p1813
aVI must note, however, that using char arrays for strings is not what you do in C++
p1814
aVYou should use  instead, it gives you a lot more flexibility
p1815
as(dp1816
g6
V335858
p1817
stp1818
a((dp1819
g2
(lp1820
VThey both do exactly the same thing, but the first one uses the alternative syntax for calling a setter (I'm ignoring the difference due to introduction of the  variable)
p1821
aVBehind the scene, the compiler generates identical code for the two calls
p1822
as(dp1823
g6
V335858
p1824
stp1825
a((dp1826
g2
(lp1827
VSince enlarging is not an option, your only options are cropping and extending
p1828
aVTry this: let's say your image is , and the desired aspect ratio of width to height is
p1829
aVUsing the width and the aspect ratio, calculate the target height
p1830
aVUsing the height and the aspect ratio, calculate the target width
p1831
aVCalculate area changes  and
p1832
aVif  is less than , use target width; pad or crop the image horizontally based on the sign of
p1833
aVOtherwise, use target height; pad or crop the image vertically based on the sigh of
p1834
aVHere is a quick example:
p1835
aVResulting action: since  is less than , crop image vertically to 240
p1836
as(dp1837
g6
V335858
p1838
stp1839
a((dp1840
g2
(lp1841
VProtected and private inheritance do not create an is a relationship between classes, which is required in order to do  outside a class or its friend
p1842
aVEssentially, private/protected inheritance is an inheritance of an implementation, not an inheritance of an interface
p1843
aVThat is why  does not work
p1844
as(dp1845
g6
V335858
p1846
stp1847
a((dp1848
g2
(lp1849
VTry
p1850
as(dp1851
g6
V335858
p1852
stp1853
a((dp1854
g2
(lp1855
VThis should work:
p1856
aVEdit: This assumes that you do not have a link from students to parents; if you do, use it instead of a join for better readability
p1857
as(dp1858
g6
V335858
p1859
stp1860
a((dp1861
g2
(lp1862
VThere is a problem in your code even if the data does not use quotes: your dynamically generated SQL statements are wide-open to SQL interjection attacks
p1863
aVYou need to re-write your query to use query parameters
p1864
aVThis will address the problem with the quotes, and make your SQL a lot more robust
p1865
aVHere is a short example of how to modify your  to use parameters:
p1866
as(dp1867
g6
V335858
p1868
stp1869
a((dp1870
g2
(lp1871
VTerms "shallow" and "deep" come from visualizing your graph with the starting node at the top: the "depth" of a node is the number of edges that you need to traverse in order to get to that node from the starting node
p1872
aVThe statement about BFS tells you that nodes with fewer edges between them and the starting node are discovered before nodes separated from the start by more edges
p1873
as(dp1874
g6
V335858
p1875
stp1876
a((dp1877
g2
(lp1878
VAsserts are conditionally compiled out of your code when  is defined
p1879
aVIf you define  in the corresponding build settings section, you will deactivate asserts in your code regardless of the release or debug mode
p1880
as(dp1881
g6
V335858
p1882
stp1883
a((dp1884
g2
(lp1885
VWhen you hard-code the implementation class, you know what interface(s) it implements, so you can simply look at the source code or the documentation to know which interfaces a class implements
p1886
aVIf you are receiving an object of an unknown type, you have several ways to check for an implementation of an interface:
p1887
as(dp1888
g6
V335858
p1889
stp1890
a((dp1891
g2
(lp1892
VUse  for
p1893
aVI also use  to see warnings related to possible violations of strict aliasing rules
p1894
as(dp1895
g6
V335858
p1896
stp1897
a((dp1898
g2
(lp1899
VGenerate a private symmetric key for use in your application, and encrypt your integer with it
p1900
aVThis will satisfy all three requirements, including the hardest #3: one would need to guess your key in order to break your scheme
p1901
as(dp1902
g6
V335858
p1903
stp1904
a((dp1905
g2
(lp1906
VUse  and
p1907
aVThis prints
p1908
as(dp1909
g6
V335858
p1910
stp1911
a((dp1912
g2
(lp1913
Vpointers can only hold addresses to other variables
p1914
aVThis is incorrect: references hold addresses of other variables; pointers can hold addresses of anything, or even nothing in particular (e
p1915
ag303
ag1783
aVIn this case,  holds an address of a memory block of 7 bytes, containing ASCII codes for ,,,,,, and
p1916
as(dp1917
g6
V335858
p1918
stp1919
a((dp1920
g2
(lp1921
VYou cannot use strings directly, but you can make an array of key strings, quickly search it, and switch on the index, like this:
p1922
as(dp1923
g6
V335858
p1924
stp1925
a((dp1926
g2
(lp1927
VYou need to use  to "escape" the curly brace
p1928
aVinterprets  as 'literal {' followed by , resulting in the wrong format error
p1929
as(dp1930
g6
V335858
p1931
stp1932
a((dp1933
g2
(lp1934
V needs to take parameters by const reference, not by value
p1935
aVAnother thing to keep in mind is that sort uses assignment operator for the ; check that your assignment operator is working correctly
p1936
aVTaking care of these two issues should fix the problem
p1937
as(dp1938
g6
V335858
p1939
stp1940
a((dp1941
g2
(lp1942
VSince both selects read from the same table, you can do this:
p1943
as(dp1944
g6
V335858
p1945
stp1946
a((dp1947
g2
(lp1948
VI see two problems with your code:
p1949
aVYou need to pass  a  array of size sufficient to store the input string, not simply a char pointer
p1950
aVYou need to copy strings passed into  (use )
p1951
as(dp1952
g6
V335858
p1953
stp1954
a((dp1955
g2
(lp1956
VBoth statements contain a declaration and a constructor invocation
p1957
aVThe invocations of the constructor are identical, therefore you get a  in both cases
p1958
aVThe declarations are different: in the first case, you declare a variable of type , a superclass of ; in the second case, you declare a variable of type
p1959
aVThe difference is that in the subsequent code you can invoke methods of  without a cast only when you declare the variable as ; if you declare it as , you would need a cast
p1960
as(dp1961
g6
V335858
p1962
stp1963
a((dp1964
g2
(lp1965
VYou are correct,  expects and writes an
p1966
aVIf you enter a value less than , it fits in the bytes outside , so you see  when you print  back
p1967
aVI tried reading a  and printing it back; I entered , and got , which makes perfect sense (65536 occupies precisely 16 bits; you see the remaining  through the two bytes of the )
p1968
aVThis behavior is dangerous, because the other two bytes of the  end up in a "variable next door" to the , which is very, very bad
p1969
aVI hope this should convince you not to do it
p1970
aVP
p1971
aVS
p1972
aVTo read a  with , declare a temporary  variable, read the value into it using , and then cast it to
p1973
as(dp1974
g6
V335858
p1975
stp1976
a((dp1977
g2
(lp1978
VYou can use Excel's functionality directly to calculate
p1979
aVMicrosoft says you are not supposed to use it, but it works very well
p1980
aVIf you need a 100% compatibility with Excel, this solution is hard to beat
p1981
aVYou need to add to your project a reference to  in order for this code to compile
p1982
as(dp1983
g6
V335858
p1984
stp1985
a((dp1986
g2
(lp1987
VI don't think there is an off-the-shelf method that does what you need, but you can easily "flatten" your array in a  loop, and hide the method in a category:
p1988
aVEdit: added a category
p1989
as(dp1990
g6
V335858
p1991
stp1992
a((dp1993
g2
(lp1994
VThe call of  does not run the query
p1995
aVThe  returned by the chain of calls does not collect  objects until you enumerate the return results in your  loop
p1996
aVThere is an advantage and a disadvantage to this
p1997
aVThe advantage is that you save all the CPU time needed to evaluate your query in cases when the query results are not needed
p1998
aVThe disadvantage is that if you need to enumerate results multiple times, the second time around the system will need to recalculate the results again
p1999
aVThe fix to address this last issue is to enumerate your query results right away, and put them into an array or a list, like this:
p2000
as(dp2001
g6
V335858
p2002
stp2003
a((dp2004
g2
(lp2005
s(dp2006
g6
V335858
p2007
stp2008
a((dp2009
g2
(lp2010
VIt's probably here:
p2011
aVWhen  (i
p2012
ag630
aVat the last element),  is out of range
p2013
as(dp2014
g6
V335858
p2015
stp2016
a((dp2017
g2
(lp2018
VMy guess is that your  is empty
p2019
aVUse  to add elements to it
p2020
as(dp2021
g6
V335858
p2022
stp2023
a((dp2024
g2
(lp2025
V methods are close enough (but not really equivalent) substitute of class methods of Objective C
p2026
aVThe difference is that in C++ you cannot override static methods
p2027
as(dp2028
g6
V335858
p2029
stp2030
a((dp2031
g2
(lp2032
VThere are several ways to return multiple values:
p2033
aVYou can create a class or a struct with multiple fields, and return an instance from your method
p2034
aVYou can add output parameters to your method
p2035
aVYou can return an array
p2036
aVYou can return a  (not recommended)
p2037
aVIn this particular case, I would prefer the first way to return two values:
p2038
as(dp2039
g6
V335858
p2040
stp2041
a((dp2042
g2
(lp2043
VYou are passing a pointer to the node
p2044
aVLike all parameters in C, it is passed by value, therefore  has no effect in the caller
p2045
aVYou need to change the signature to accept , and add a level of indirection in order to make the changes in  be reflected in the
p2046
aVOf course you'll need to pass  to the  method:
p2047
ag1971
ag1972
aVSince you are adding {2,"two"} to the front of the list, your output will be  "two: 2, one : 1"
p2048
as(dp2049
g6
V335858
p2050
stp2051
a((dp2052
g2
(lp2053
VAs far as I know, there is no tokenizer in the STL
p2054
aVBut if you are willing to use boost, there's a very good tokenizer class there
p2055
aVOther than that, character by character is your best C++ way of addressing it (unless you are willing to go the C route, and use  on your raw  strings)
p2056
as(dp2057
g6
V335858
p2058
stp2059
a((dp2060
g2
(lp2061
VAccdording to this documentation page,
p2062
aVthe address of a block returned by malloc or realloc in the GNU system is always a multiple of eight (or sixteen on 64-bit systems)
p2063
aVIn general,  implementations are system-specific
p2064
aVAll of them keep some memory for their own bookkeeping (e
p2065
ag303
aVthe actual length of the allocated block) in order to be able to release that memory correctly when you call
p2066
aVIf you need to align to a specific boundary, use other functions, such as
p2067
as(dp2068
g6
V335858
p2069
stp2070
a((dp2071
g2
(lp2072
VNot unless the parameters at the tail of the signature have defaults, for example:
p2073
aVIf there are defaults, then you can supply only the non-defaulted parameters, and optionally some defaulted ones, i
p2074
ag630
aVany of the following invocations would be valid:
p2075
as(dp2076
g6
V335858
p2077
stp2078
a((dp2079
g2
(lp2080
VIt looks like  is in the  directory, a sibling directory of
p2081
aVYou should either get both files in the same directory, or use  if you absolutely must keep the files where they are
p2082
as(dp2083
g6
V335858
p2084
stp2085
a((dp2086
g2
(lp2087
VIs this possible
p2088
aVThis is not possible in C++
p2089
aVIf using boost is an option, consider creating a vector of  objects instead: this way, your statically-typed  would be prepared to accept elements of different types
p2090
as(dp2091
g6
V335858
p2092
stp2093
a((dp2094
g2
(lp2095
VPut the unique side into an , and go through the non-unique side one by one
p2096
aVIf you find an item at  in the , add  to the result
p2097
aVAssuming that  is implemented as a hash set with  amortized insertion and lookup times, this algorithm gets you  time complexity, where  is the number of items in the larger list, and  is the number of items in the smaller set
p2098
aVThis is as fast as you can do an intersection
p2099
as(dp2100
g6
V335858
p2101
stp2102
a((dp2103
g2
(lp2104
VFrom this link at Microsoft:
p2105
as(dp2106
g6
V335858
p2107
stp2108
a((dp2109
g2
(lp2110
VAnd what does it mean INCLUDE ([PositionKey])
p2111
aVThis question is indeed the key to the answer
p2112
aVYou can add columns to your index to improve performance:
p2113
aVAn index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns
p2114
aVIf you run a lot of queries that look like this
p2115
aVyour query wouldn't need to touch the table at all - it will be a quick index lookup
p2116
as(dp2117
g6
V335858
p2118
stp2119
a((dp2120
g2
(lp2121
VIf you  your number with 0x03, you will get the last two bits
p2122
as(dp2123
g6
V335858
p2124
stp2125
a((dp2126
g2
(lp2127
VThere is no concept that parallels C++'s  in C#
p2128
aVTo make your life easier and save you some typing, C# lets you skip the type in declaration/initialization of local variables:
p2129
aVis the same as
p2130
aVYou still need to use the full type in member declarations
p2131
aVHowever, it is a good practice to declare members as interfaces, not as exact types:
p2132
aVThis could let you switch implementation at a later time without having to change anything else in your code
p2133
as(dp2134
g6
V335858
p2135
stp2136
a((dp2137
g2
(lp2138
VStart with group by:
p2139
aVIf you must have them in the same row, use pivot:
p2140
as(dp2141
g6
V335858
p2142
stp2143
a((dp2144
g2
(lp2145
VUse  method that takes a custom match evaluator
p2146
as(dp2147
g6
V335858
p2148
stp2149
a((dp2150
g2
(lp2151
V is not a method
p2152
aVIt is a compile-time construct that determines the amount of memory a particular type or a variable occupies
p2153
aV, on the other hand, is a function that counts the number of consecutive non-zero  values starting at the specified location in memory (which happens to be the same as determining the length of a zero-terminated C string)
p2154
as(dp2155
g6
V335858
p2156
stp2157
a((dp2158
g2
(lp2159
VSince this is rather specific to your problem at hand, you will very likely need to develop your own collection
p2160
aVI would wrap two s from Apache Commons into my own collection class that deals with updates of both multi-maps at the same time, and use my class to perform inserts and queries
p2161
as(dp2162
g6
V335858
p2163
stp2164
a((dp2165
g2
(lp2166
VGiven the apparent complexity of your update, it would probably make sense to move its logic to a stored procedure, and then map your updates to that stored procedure
p2167
as(dp2168
g6
V335858
p2169
stp2170
a((dp2171
g2
(lp2172
VNo, you could also use  for objects that you do not own
p2173
aVNo, you could also use  on the property
p2174
aVMy understanding is that  items are just like , without the additional safety of clearing them out when the item they point to gets released (and the overhead that goes with it)
p2175
aVThis is entirely an ARC thing
p2176
as(dp2177
g6
V335858
p2178
stp2179
a((dp2180
g2
(lp2181
VUse  method, and pass it an array of control characters on which you would like to split:
p2182
aVNow  contains an array of substrings of the original line that were separated by the special characters
p2183
aVMultiple special characters in a row are ignored
p2184
as(dp2185
g6
V335858
p2186
stp2187
a((dp2188
g2
(lp2189
VCreate a
p2190
aVFor each number that you get from the stream:
p2191
aV-- Add the number to the set
p2192
aV-- If , remove the smallest element of the set
p2193
aVAt each point,  contains up to  largest items in the set (the number will be less than  if there were fewer than  distinct items in the stream up to this point)
p2194
aVCoding this in C++ should be trivial
p2195
as(dp2196
g6
V335858
p2197
stp2198
a((dp2199
g2
(lp2200
VLinq to Objects does not reorder to avoid a would-be run-time step to do something that should be optimized at coding time
p2201
aVThe resharpers of the world may at some point introduce code analysis tools to smoke out optimization opportunities like this, but it is definitely not a job for the runtime
p2202
as(dp2203
g6
V335858
p2204
stp2205
a((dp2206
g2
(lp2207
VPut the four arrays into an array of arrays, and use  as an index
p2208
aVAssuming that  arrays have enough space to store the data, you can do this:
p2209
as(dp2210
g6
V335858
p2211
stp2212
a((dp2213
g2
(lp2214
VYou are comparing pointers to strings, rather than the strings themselves
p2215
aVYou need to change your code to
p2216
as(dp2217
g6
V335858
p2218
stp2219
a((dp2220
g2
(lp2221
VYou can find all sequences of white space characters in the  string, and replace them with a single white space
p2222
aVThis way you would be able to replace multiple spaces in the  as well, and the rest of your search algorithm would continue working unchanged
p2223
aVHere is a way to remove duplicates using STL:
p2224
as(dp2225
g6
V335858
p2226
stp2227
a((dp2228
g2
(lp2229
VThere is a post about saving s here
p2230
aVThe guy is using  function to enumerate through the elements of the path:
p2231
as(dp2232
g6
V335858
p2233
stp2234
a((dp2235
g2
(lp2236
VIn addition to the "normal" allocation route (i
p2237
ag630
aVthrough ) some classes provide so called "factory methods"
p2238
aVThese are class methods that allocate objects internally
p2239
aVThe advantage of using factory methods is that they can create a suitable subclass  to return to the caller
p2240
aVIn both cases, though, the allocation is ultimately done by
p2241
as(dp2242
g6
V335858
p2243
stp2244
a((dp2245
g2
(lp2246
VSelect the window in the storyboard, and open its Simulated Metrics property page (upper-right corner, an icon that looks like a shield next to the ruler icon)
p2247
aVIf the Simulated Metrics group is collapsed, expand it by clicking the black triangle to its left
p2248
aVThere you will find an Orientation property; set it to
p2249
as(dp2250
g6
V335858
p2251
stp2252
a((dp2253
g2
(lp2254
VUse one of overloads of the
p2255
aVHere is one possible way:
p2256
as(dp2257
g6
V335858
p2258
stp2259
a((dp2260
g2
(lp2261
VGreedy strategy should work for this problem
p2262
aVFind the first letter of the suspected substring (blr) in the big string (*b*angalore)
p2263
aVFind the second letter starting at the index of the first letter plus one (anga*l*ore)
p2264
aVFind the third letter starting at the index of the second letter plus one (o*r*e)
p2265
aVContinue until you can no longer find the next letter of blr in the string (no match), or you run out of letters in the subsequence (you have a match)
p2266
aVHere is a sample code in C++:
p2267
as(dp2268
g6
V335858
p2269
stp2270
a((dp2271
g2
(lp2272
VSince both branches of the  assign a value to , assignment prior to  has no effect
p2273
aVDeciding on whether or not to initialize a string to  vs
p2274
aVan empty string is an application-level decision, often centered around the distinction between "the string is not there" and "the string is there, but it is empty"
p2275
as(dp2276
g6
V335858
p2277
stp2278
a((dp2279
g2
(lp2280
VFirst, use the answer to this question to determine the size of your file
p2281
aVThen divide that number by two
p2282
aVRead the input line by line, and write it to the first output stream; check  after each call
p2283
aVOnce you're past the half-way point, switch the output to the second file
p2284
aVThis wouldn't split the strings evenly between the files, but the total number of characters in these strings should be close enough, and it wouldn't split your file in the middle of a string
p2285
as(dp2286
g6
V335858
p2287
stp2288
a((dp2289
g2
(lp2290
VThis is definitely not the same exact thing: for starters, the second one works, while the first one does not :)
p2291
aVThe reason the first snippet does not work is because it uses an iterator from the  list, and it is not possible to assign to the original collection through 's iterator
p2292
aVThe second snippet uses  to access the underlying list or array
p2293
aVThis construct allows reading and writing; that's why it works
p2294
aVAs far as accessing all elements of the list or array in the same order is concerned, both constructs are identical
p2295
as(dp2296
g6
V335858
p2297
stp2298
a((dp2299
g2
(lp2300
VYou are correct about the reason why the  signature is preferred
p2301
aVIt actually explains another thing - why the length needs to be returned (the buffer is sized at the , so we usually need to inform the caller of how much of that did we actually use)
p2302
aVWhen you allocate strings inside a function, you do not usually return the size of the string, because  can be used to find that out
p2303
aVLook at  for an example of a function that allocates strings dynamically
p2304
aVSo I would change the signature of your function to
p2305
as(dp2306
g6
V335858
p2307
stp2308
a((dp2309
g2
(lp2310
Va
p2311
aVYes, it does
p2312
aVMutable  objects could be updated without the reader noticing, which will lead to inconsistent states
p2313
aVb
p2314
aVYes, you can: make a mutable  that returns immutable  on request
p2315
aVThis way you'll create new  objects on reads, not on writes
p2316
aVcould internally cache the immutable  that it constructs and returns, and invalidate that "cache" on mutating calls
p2317
aVEdit: I am assuming that the reason you are caching (as opposed to creating a queue between threads 2 and 3) is that the consumer thread may read other entries in addition to the one of which thread 2 sends the notification
p2318
aVIf this assumption is incorrect, you may not need a cache at all
p2319
as(dp2320
g6
V335858
p2321
stp2322
a((dp2323
g2
(lp2324
V should be , otherwise the memory that you have allocated on the line just above is leaked, and the pointer  becomes aliased to the pointer in
p2325
as(dp2326
g6
V335858
p2327
stp2328
a((dp2329
g2
(lp2330
VYou are looking to introduce another level of indirection in your design: essentially, instead of storing a reference to  and  you are looking to store something that would let you get the most current  and
p2331
aVYour #3 (delegate) option stands out as the most elegant to me, because you do not need to introduce new classes to implement delayed evaluation
p2332
aVAll you need is a  that  passes to  - no new classes, interfaces, or delegates; everything remains nicely encapsulated
p2333
aVNow if  changes its , or  changes its ,  would continue returning the correct  automatically
p2334
aVThis is because under the hood,  holds a reference to , but it has no idea that it does
p2335
as(dp2336
g6
V335858
p2337
stp2338
a((dp2339
g2
(lp2340
VThis prints combinations, as in your example, not permutations, as in the title of the question
p2341
as(dp2342
g6
V335858
p2343
stp2344
a((dp2345
g2
(lp2346
s(dp2347
g6
V335858
p2348
stp2349
a((dp2350
g2
(lp2351
VMake a protected virtual abstract function returning , and a non-virtual, non-abstract, public template function to hide it from the users of your interface
p2352
as(dp2353
g6
V335858
p2354
stp2355
a((dp2356
g2
(lp2357
VSome of your links don't have a  - they have  instead
p2358
aVThe NPE comes from that
p2359
aVYou see it only when you call  because the actual evaluation does not happen until then
p2360
aVTo change your code to guard against NPE, add a  condition:
p2361
as(dp2362
g6
V335858
p2363
stp2364
a((dp2365
g2
(lp2366
VIt should probably be
p2367
aVYour code would probably compile too, but it would return , because of the way the comma operator works
p2368
aVThis is almost certainly not what you had in mind, though
p2369
as(dp2370
g6
V335858
p2371
stp2372
a((dp2373
g2
(lp2374
VThe  property of your  returns the amount of scroll
p2375
aVIts  component tells you how much has been scrolled horizontally;  tells you how much has been scrolled vertically
p2376
as(dp2377
g6
V335858
p2378
stp2379
a((dp2380
g2
(lp2381
VMy guess would be it's JPA (of which Hibernate is also a provider)
p2382
aVBecause of this alias (which wasn't available in 2005) the declining trend for Hibernate may be misleading: some of the growing JPA uses are backed by the "declining" Hibernate, offsetting or even reversing the decline
p2383
as(dp2384
g6
V335858
p2385
stp2386
a((dp2387
g2
(lp2388
VI think it's , where
p2389
aVprocessors search for  of  elements each, followed by  pairwise merges done in parallel
p2390
aVThe first  merges are done by even-numbered processors, next 'P'/4' - by processors at locations divisible by 8, then by 16, and so on
p2391
aVEdit  is introduced to cover the case when you have significantly more processor nodes than the elements that you need to search
p2392
as(dp2393
g6
V335858
p2394
stp2395
a((dp2396
g2
(lp2397
VHere is how you do it with regular expressions:
p2398
aVThis code finds
p2399
as(dp2400
g6
V335858
p2401
stp2402
a((dp2403
g2
(lp2404
VYou shouldn't exit after exploring the first child
p2405
aVYou don't need the  statement in front of the  loop
p2406
as(dp2407
g6
V335858
p2408
stp2409
a((dp2410
g2
(lp2411
VHere is an example how to do it with :
p2412
aVThe first  produces  because  is true; the second produces
p2413
as(dp2414
g6
V335858
p2415
stp2416
a((dp2417
g2
(lp2418
VAccording to Microsoft's docs, you cannot use  after : you must list the values manually
p2419
aVAssuming that  returns ,,, you can rewrite your code like this:
p2420
as(dp2421
g6
V335858
p2422
stp2423
a((dp2424
g2
(lp2425
VSpace complexity describes how much space your program needs
p2426
aVSince  does not declare arrays, each level requires  space
p2427
aVNow all you need to do is to figure out how many nested levels can be active at the most at any given time
p2428
aVEdit:
p2429
aVso much for letting you figure out the solution for yourself :)
p2430
as(dp2431
g6
V335858
p2432
stp2433
a((dp2434
g2
(lp2435
VYou can use s, unique 128-bit integers, that can be created using
p2436
aVThey already incorporates timestamp info, so you may be able to use s as your session IDs without additional timestamps
p2437
aVIf you use  for yor connection to the server, you do not need to do any additional encryption either
p2438
as(dp2439
g6
V335858
p2440
stp2441
a((dp2442
g2
(lp2443
VOne way without using regexp is below:
p2444
as(dp2445
g6
V335858
p2446
stp2447
a((dp2448
g2
(lp2449
VThere must be something else in your code that you are not doing right, because overriding methods as you show in the OP causes  to recognize my objects as identical:
p2450
aVTest
p2451
aVh:
p2452
aVTest
p2453
aVm:
p2454
aVmain
p2455
aVc:
p2456
aVThis snippet produces , as expected
p2457
as(dp2458
g6
V335858
p2459
stp2460
a((dp2461
g2
(lp2462
VZero
p2463
aVThe -d constant is not a real constant: it does not have a type, and it does not occupy data memory
p2464
aVIts occurrences in your program are replaced with the literal , that's all
p2465
aVThe constant value does occupy program memory in the binary code of your program, but it's not the kind of memory to which you could take a pointer without getting into the undefined behavior territory
p2466
as(dp2467
g6
V335858
p2468
stp2469
a((dp2470
g2
(lp2471
VAssuming there's a new line at the end of the string that you would like to remove, you can do this:
p2472
aVWhen there are no new lines,  would remain the same
p2473
as(dp2474
g6
V335858
p2475
stp2476
a((dp2477
g2
(lp2478
VYour code broke the rule of three: if you have a destructor, you need a copy constructor and an assignment operator
p2479
aVAs it stands, the default assignment operator provided by C++ "for free" creates an alias between s of your two instances, so the second destructor tries to release an already released chunk of memory
p2480
aVWhat you need to do is to allocate a new chunk of memory and copy the value of  into it in your assignment operator and your copy constructor
p2481
as(dp2482
g6
V335858
p2483
stp2484
a((dp2485
g2
(lp2486
VAssuming that your dictionary needs to hold managers with mixed type arguments, you can implement an  interface in , make a , and add a generic wrapper to cast instances back to , like this:
p2487
as(dp2488
g6
V335858
p2489
stp2490
a((dp2491
g2
(lp2492
VUse :
p2493
as(dp2494
g6
V335858
p2495
stp2496
a((dp2497
g2
(lp2498
VC provides a special type of structure member known as a bit field, which is an integer with an explicitly specified number of bits
p2499
aVNon-integral types cannot be used as base types for bit fields
p2500
as(dp2501
g6
V335858
p2502
stp2503
a((dp2504
g2
(lp2505
VI believe that their main reason was portability of programs targeting CLR
p2506
aVIf they were to allow a type as basic as  to be platform-dependent, making portable programs for CLR would become a lot more difficult
p2507
aVProliferation of -ed integral types in platform-neutral C/C++ code to cover the use of built-in  is an indirect hint as to why the designers of CLR decided on making built-in types platform-independent
p2508
aVDiscrepancies like that are a big inhibitor to the "write once, run anywhere" goal of execution systems based on VMs
p2509
aVEdit More often than not, the size of an  plays into your code implicitly through bit operations, rather than through arithmetics (after all, what could possibly go wrong with the , right
p2510
aVBut the errors are usually more subtle
p2511
aVConsider an example below:
p2512
aVThis code computes and processes all combinations of 20 items
p2513
aVAs you can tell, the code fails miserably on a system with 16-bit , but works fine with ints of 32 or 64 bits
p2514
aVUnsafe code would provide another source of headache: when the  is fixed at some size (say, 32) code that allocates 4 times the number of bytes as the number of ints that it needs to marshal would work, even though it is technically incorrect to use 4 in place of
p2515
aVMoreover, this technically incorrect code would remain portable
p2516
aVUltimately, small things like that play heavily into the perception of platform as "good" or "bad"
p2517
aVUsers of
p2518
aVNET programs do not care that a program crashes because its programmer made a non-portable mistake, or the CLR is buggy
p2519
aVThis is similar to the way the early Windows were widely perceived as non-stable due to poor quality of drivers
p2520
aVTo most users, a crash is just another
p2521
aVNET program crash, not a programmers' issue
p2522
aVTherefore is is good for perception of the "
p2523
aVNET ecosystem" to make the standard as forgiving as possible
p2524
as(dp2525
g6
V335858
p2526
stp2527
a((dp2528
g2
(lp2529
VIt sounds like all you need to do is to rename your  file to :
p2530
aVI am extremely pleased that all I had to do was make the suffix to the yacc file be
p2531
aVym instead of
p2532
aVy to get Xcode to do all the right things
p2533
aVI have not tried this, but the linked post suggests that XCode has enough smarts built into it in order to deal with parser generators "automagically"
p2534
as(dp2535
g6
V335858
p2536
stp2537
a((dp2538
g2
(lp2539
VIf your  file comes from a non-UNIX system, it may contain multiple line separators (e
p2540
ag303
aVinstead of )
p2541
aVIn this case,  will insert empty strings for empty character sequences between  and
p2542
aVYou can remove empty strings from  using this method:
p2543
as(dp2544
g6
V335858
p2545
stp2546
a((dp2547
g2
(lp2548
VYour  imports , and your  imports , creating a circular reference
p2549
aVThis is not allowed
p2550
aVYou can put everything in the
p2551
aVThen you can simply import  in places where you need to reference
p2552
aVIf you would like to hide common imports (e
p2553
ag303
aV), you can put them into  file
p2554
as(dp2555
g6
V335858
p2556
stp2557
a((dp2558
g2
(lp2559
VLeaving aside the issues of your incorrect pointer arithmetics (the possibility of padding between  and  invalidates your assumption), here is a quick illustration of what's going on with  pointer when you use multiple inheritance:
p2560
aVand  print different numbers;  prints the same number as , because  is listed first in the list of bases
p2561
aVIf you switch  and  there, then  and  would be the same
p2562
aVThe "magic" is in the C++ compiler: it is smart enough to give each member function a correct  pointer
p2563
as(dp2564
g6
V335858
p2565
stp2566
a((dp2567
g2
(lp2568
VAs far as I know, using  is the only way to control who can inherit a class
p2569
aVIf the inheritors must be in a different assembly, you can let classes from another assembly see internals of your assembly using  attribute (the target assembly must be signed in order for this to work with signed assemblies)
p2570
as(dp2571
g6
V335858
p2572
stp2573
a((dp2574
g2
(lp2575
VFor words in languages that use latin alphabet, you can calculate word's 26-bit "signature" by setting bit #i to one only when the word contains letter #i of the alphabet:
p2576
aVYou can then store the signature along with its word and the word's length in the database
p2577
aVOnce you get the word you need to match, calculate its signature, and query the database for all words that match the signature and the target words's length
p2578
aVFor each candidate word with matching length and signature, convert the word to upper case, sort its letters, and compare the sorted result to sorted target
p2579
aVIf the target matches, add the word to the list of answers
p2580
as(dp2581
g6
V335858
p2582
stp2583
a((dp2584
g2
(lp2585
V is not the right method from which to call
p2586
aVYou should add that layer at the point when you construct your object with an , or when you set an  on an existing object
p2587
aVAlternatively, you can draw the image yourself in the , but it is probably not going to be as fast
p2588
as(dp2589
g6
V335858
p2590
stp2591
a((dp2592
g2
(lp2593
VUse  to round up
p2594
as(dp2595
g6
V335858
p2596
stp2597
a((dp2598
g2
(lp2599
VYou cannot use  with multiple patterns, but you can change your select to use one pattern at a time:
p2600
as(dp2601
g6
V335858
p2602
stp2603
a((dp2604
g2
(lp2605
VThe problem is that you are calling  from inside the
p2606
aVInstead of this, you should assign elements of your class field by field, like this:
p2607
as(dp2608
g6
V335858
p2609
stp2610
a((dp2611
g2
(lp2612
VI think brute force approach should work: try all s from 2 (1 is a trivial solution) and up, taking , a
p2613
aVIf  is less than 2, stop
p2614
aVOtherwise, compute  and , and compare them to  (you need  and  to compensate for errors in floating point representations)
p2615
aVAssuming your integers fit in 64 bits, you would not need to try more than 64 values of
p2616
aVHere is an example in C++:
p2617
aVWhen invoked with 65536, it produces this output:
p2618
as(dp2619
g6
V335858
p2620
stp2621
a((dp2622
g2
(lp2623
VIn C#, the  go before the name of the variable (i
p2624
ag630
aVit is not like in C/C++)
p2625
as(dp2626
g6
V335858
p2627
stp2628
a((dp2629
g2
(lp2630
VIt is not too surprising: the execution plan for the tiny insert is computed once, and then reused 1000 times
p2631
aVParsing and preparing the plan is quick, because it has only four values to del with
p2632
aVA 1000-row plan, on the other hand, needs to deal with 4000 values (or 4000 parameters if you parameterized your C# tests)
p2633
aVThis could easily eat up the time savings you gain by eliminating 999 roundtrips to SQL Server, especially if your network is not overly slow
p2634
as(dp2635
g6
V335858
p2636
stp2637
a((dp2638
g2
(lp2639
VIf you put template definition in cpp file, the definitions will not be available outside that cpp file
p2640
aVWhen you include  from , the compiler sees the declaration of your template class, but it does not see the implementation of the methods
p2641
aVOnce you move them to the  header, everything should compile
p2642
as(dp2643
g6
V335858
p2644
stp2645
a((dp2646
g2
(lp2647
VXOR with the bits that you want to flip
p2648
as(dp2649
g6
V335858
p2650
stp2651
a((dp2652
g2
(lp2653
VIn general, the answer is no
p2654
aVIt works for 30 and 15 because 30 is even, but it would not work as easily for odd numbers
p2655
aV"Duff's device" was invented to deal with general case
p2656
aVIt is quite ugly, though
p2657
as(dp2658
g6
V335858
p2659
stp2660
a((dp2661
g2
(lp2662
VTry this:
p2663
aVThis is how it works:
p2664
aVFrom the type of
p2665
aVobtain the property called
p2666
aVget the type of that property
p2667
aVwhich we know to be a generic type with at least one type parameter
p2668
aVWe get the first type parameter - in your example it should be
p2669
ag1971
ag1972
aVgets you , the generic type of which  is a generic instance
p2670
as(dp2671
g6
V335858
p2672
stp2673
a((dp2674
g2
(lp2675
VYou can write a constant expression that evaluates to the same number:
p2676
aVThis compiles with g++ 4
p2677
ag839
ag1340
as(dp2678
g6
V335858
p2679
stp2680
a((dp2681
g2
(lp2682
VYou need to tell Java that the int is in hex, like this:
p2683
as(dp2684
g6
V335858
p2685
stp2686
a((dp2687
g2
(lp2688
VYou are missing a semicolon after the class definition in your
p2689
aVh file
p2690
as(dp2691
g6
V335858
p2692
stp2693
a((dp2694
g2
(lp2695
VIn PostgerSQL you have several wildcards that you can use in  expressions
p2696
aVAn underscore  matches a single character:
p2697
as(dp2698
g6
V335858
p2699
stp2700
a((dp2701
g2
(lp2702
VIf there should be only one lesson that you learn from this exercise, make it this: the order in which you do your multiplications and divisions matters
p2703
aVEven if it does not matter in mathematics, it often matters in your program
p2704
aVFor example, in math there is no difference between  and ; In your program, it would make the difference between passing and failing
p2705
aV(P
p2706
ag1972
aVof course you need to fix the bug in your logic, too: you should not be multiplying  by lcm)
p2707
aVEDIT
p2708
aVTo understand why the order makes the difference here, consider calculating  of  and
p2709
aVis divisible by , so it is the
p2710
aVHowever, when you calculate , you get an overflow; then you divide by , but you do not get  back
p2711
aVSince the divisor is , you can divide it out of  before multiplying by  without truncating the result by integer division
p2712
aVThis little trick that experienced programmers use without thinking can save you hours of debugging
p2713
as(dp2714
g6
V335858
p2715
stp2716
a((dp2717
g2
(lp2718
VUse ,  and  to leverage the power of STL:
p2719
as(dp2720
g6
V335858
p2721
stp2722
a((dp2723
g2
(lp2724
VEach valid keypad corresponds to a 26-bit number with exactly nine bits set to 1
p2725
aVWith only 2042975 valid combinations to try, brute force should be the first thing to attempt, before other approaches that require more thinking
p2726
aVThe algorithm would go like this pseudocode:
p2727
as(dp2728
g6
V335858
p2729
stp2730
a((dp2731
g2
(lp2732
VStream refers to a sequence of data elements made available over time
p2733
aVData elements in streams could be of any kind: characters, strings, special-purpose data structures, etc
p2734
aVA text file could be trivially interpreted as a stream of characters
p2735
aVIn the context of programming languages, the word token usually refers to a sequence of one or more related characters from a stream of characters
p2736
aVTokens offer a level of abstraction on top of character streams, and are often themselves grouped in streams for further processing
p2737
aVThe usual processing sequence in compilers of programming languages starts with lexical analyzers converting streams of characters into streams of tokens, which are then passed on to parsers
p2738
aVTypical representation of a token consists of a type indicator and the content of the token
p2739
aVHere is an example: consider this fragment of C++ program:
p2740
aVA lexer analyzer groups this program into a stream of ten tokens:
p2741
as(dp2742
g6
V335858
p2743
stp2744
a((dp2745
g2
(lp2746
VHere is an example of how you can do it:
p2747
as(dp2748
g6
V335858
p2749
stp2750
a((dp2751
g2
(lp2752
VYou need to initialize your list:
p2753
as(dp2754
g6
V335858
p2755
stp2756
a((dp2757
g2
(lp2758
VThis works even for strings that do not contain dashes (in these cases the entire string is returned)
p2759
as(dp2760
g6
V335858
p2761
stp2762
a((dp2763
g2
(lp2764
VAssuming that your Oracle service is local, you can use
p2765
aVIf the service is started, this command will return right away
p2766
aVOtherwise, it will wait for the service start-up to complete before returning
p2767
aVIf a service name contains spaces, enclose the name in double quotation marks
p2768
as(dp2769
g6
V335858
p2770
stp2771
a((dp2772
g2
(lp2773
VThe  creates a new instance of the class being copied, and also copies scalar fields into the corresponding members of the copy
p2774
aVIt provides a better starting point for deep copying than just a plain , because you need to "fix" only the items requiring deep copying
p2775
as(dp2776
g6
V335858
p2777
stp2778
a((dp2779
g2
(lp2780
VThe simplest solution would be to add a method called  returning the value of  "truncated" to midnight, and sort on  instead
p2781
as(dp2782
g6
V335858
p2783
stp2784
a((dp2785
g2
(lp2786
VI think you need to reference  inside your  call, like this:
p2787
as(dp2788
g6
V335858
p2789
stp2790
a((dp2791
g2
(lp2792
VRecall that invoking a "non-pure" virtual function from a constructor/destructor ignores the fact that the function is virtual, and always calls the implementation in your class, not in the derived class being constructed
p2793
aVThat's why you cannot call pure virtual from constructor or destructor: as far as they are concerned, your pure virtual function has no implementation
p2794
as(dp2795
g6
V335858
p2796
stp2797
a((dp2798
g2
(lp2799
VWhile the other process is running, the command line processor is not running: it is suspended
p2800
aVThe only "multitasking" facility that was available in DOS was "Terminate and Stay Resident"
p2801
as(dp2802
g6
V335858
p2803
stp2804
a((dp2805
g2
(lp2806
V will change the sign from positive to negative and vice versa
p2807
as(dp2808
g6
V335858
p2809
stp2810
a((dp2811
g2
(lp2812
VEntity Framework
p2813
aVNHibernate
p2814
aVLinq 2 SQL (distant third, because it is in maintenance mode)
p2815
as(dp2816
g6
V335858
p2817
stp2818
a((dp2819
g2
(lp2820
VYou clear out the string yourself by assigning  to its elements in a loop
p2821
aVYou should not be using internals of the string
p2822
aVInstead, create a temporary one-character string, and re-assign its first character in a loop, like this:
p2823
as(dp2824
g6
V335858
p2825
stp2826
a((dp2827
g2
(lp2828
VMessage Queuing services are designed for use in situations like yours
p2829
aVThey provide guaranteed message delivery, so if the writer was busy writing while the reader was not running, the reader would find a queue full of messages after starting up
p2830
as(dp2831
g6
V335858
p2832
stp2833
a((dp2834
g2
(lp2835
VIf you know for sure that you have two underscores, use this code:
p2836
aVThis will fail if the number of underscores is less than two
p2837
as(dp2838
g6
V335858
p2839
stp2840
a((dp2841
g2
(lp2842
V is an instance method, not a class method
p2843
aVYou need to use , which is a class method:
p2844
as(dp2845
g6
V335858
p2846
stp2847
a((dp2848
g2
(lp2849
VYou need to skip four elements, then take the max of the next four (#5
p2850
aV#8, inclusive):
p2851
as(dp2852
g6
V335858
p2853
stp2854
a((dp2855
g2
(lp2856
VBring the table of genres in the memory (it cannot be that big), and recursively traverse it to create a mapping between an  and a transitive closure of its descendents, like this:
p2857
aVThe data above stays only in memory
p2858
aVYou recompute it every time on start-up, and on updates to the genres table
p2859
aVWhen it is time to query for all songs in a specific genre, use the pre-calculated table in an  query, like this:
p2860
as(dp2861
g6
V335858
p2862
stp2863
a((dp2864
g2
(lp2865
VWhy isn't ID 7 a Fail
p2866
aVIt overlaps (intersects) with ID 6
p2867
aVID7 is not failing because ID6 has failed and eliminated from our consideration
p2868
aVThis point that you made in the comments eliminates a possibility of SQL-only solution, because your definition of  becomes recursive
p2869
aVIn other words, in order to know if something has failed or not, it is not sufficient to know the  and  date: you must also know the pass or fail status of the "previous generation" of records
p2870
aVHere is a query that can help you determine the first overlapping ID, disregarding the "overlaps with failed records do not count" rule:
p2871
aVIt returns these results for the data from your table:
p2872
aVIf you must pay attention to the "overlaps with failed" rule, you need to apply it sequentially; SQL is not very good at it
p2873
as(dp2874
g6
V335858
p2875
stp2876
a((dp2877
g2
(lp2878
VThe goal of your challenge is useless, because generics of
p2879
aVNET are as much a run-time construct as a compile-time construct
p2880
aVEven if your program compiles without an error, one could still expand your generic through reflection, passing a "non-approved" type
p2881
aVI understand where you are coming from (I loved that book by Andrei Alexandrescu very much, too) but an important thing to understand about C# generics is that generics are not C++ templates
p2882
aVApart from the small syntactic similarities, they are not even that close: "ain't the same ballpark, ain't the same league, ain't even the same sport"
p2883
aVThe major driving force behind the need to do compile-time validation of the sort "ints are OK, doubles are not OK) was that you could access operations implicitly:  would succeed if the types of  and  supplied at template expansion allowed the  operation
p2884
aVIt is not the same in C#: if you want an operation to be done on a value passed to a generic, you must either stipulate the existence of that operation explicitly through a type constraint, or provide an explicit way to perform that operation (a delegate, an interface, etc
p2885
aVEither way, telling the compiler that your template works for ints nut not for doubles does not buy you absolutely anything
p2886
as(dp2887
g6
V335858
p2888
stp2889
a((dp2890
g2
(lp2891
VUse BigInteger or BigDecimal
p2892
as(dp2893
g6
V335858
p2894
stp2895
a((dp2896
g2
(lp2897
VAccording to a source at Microsoft, Sum() on an empty set is  because of the way it works in SQL:
p2898
aVwhen the table is empty im getting this exception: InvalidOperationException
p2899
aVIn SQL, Sum() aggregate operator returns null for an empty set
p2900
aVSo this is as designed
p2901
as(dp2902
g6
V335858
p2903
stp2904
a((dp2905
g2
(lp2906
VUse Dependency Walker
p2907
aVIt is a free utility that scans EXEs and DLLs, and builds a hierarchical tree diagram of all dependent modules
p2908
aVEdit:
p2909
aVOn linux try binscan or ELF Library Viewer (from SO answer by J-16 SDiZ)
p2910
as(dp2911
g6
V335858
p2912
stp2913
a((dp2914
g2
(lp2915
VCheck connectionstrings
p2916
aVcom
p2917
as(dp2918
g6
V335858
p2919
stp2920
a((dp2921
g2
(lp2922
VThis is a good idea
p2923
aVYou can use the partial class feature of C# to achieve this result
p2924
as(dp2925
g6
V335858
p2926
stp2927
a((dp2928
g2
(lp2929
VIn order to calculate a sum generically, you need to provide two actions:
p2930
aVA way to sum zero items
p2931
aVA way to sum two items
p2932
aVIn Java, you do it through an interface
p2933
aVHere is a complete example:
p2934
as(dp2935
g6
V335858
p2936
stp2937
a((dp2938
g2
(lp2939
VYou need to call  on the hBitmap:
p2940
as(dp2941
g6
V335858
p2942
stp2943
a((dp2944
g2
(lp2945
VI think you could use the other overload of :
p2946
aVThis works because the  is now boxed, and the assignment of reference types is atomic
p2947
as(dp2948
g6
V335858
p2949
stp2950
a((dp2951
g2
(lp2952
VIf you must visit all leaf nodes, you cannot speed up the search: it is going to go through all nodes no matter what
p2953
aVA typical trick played to speed up a search on trees is organizing them in some special way that simplifies the search of the tree
p2954
aVFor example, by building a binary search tree, you make your search
p2955
aVYou could also store some helpful values in the non-leaf nodes from which you could later construct the answer to your search query
p2956
aVFor example, you could decide to store the _bestLeaf "pointing" to the leaf with the highest _nodeDelta of all leaves under the current subtree
p2957
aVIf you do that, your search would become an  lookup
p2958
aVYour inserts and removals would become more expensive, however, because you would need to update up to  items on the way back to root with the new  ( is the branching factor of your tree)
p2959
as(dp2960
g6
V335858
p2961
stp2962
a((dp2963
g2
(lp2964
VEndianness is a feature of the platform that is often known at compile time
p2965
aV, ,  and  are not always functions: they may be macros that use conditional compile to perform their "magic"
p2966
aVIn order for them to work, sometimes either  or  is d (but not both), (edit2) or in other implementations both BIG_ENDIAN and LITTLE_ENDIAN are set to different values, and also a BYTE_ORDER is defined to be equal to one or the other
p2967
aVYou can examine the values of these definitions to find out the endian-ness of your platform at compile time; the way you do that would depend on your implementation, though
p2968
aVEdit1 If your platform implements endianness functions as functions, not as macros, you could use any of these functions to see if it converts  to itself
p2969
aVIf it does, then your hardware is big-endian
p2970
ag1971
ag1972
aVSpecial thanks to CharlesBailey for his observation on the initial edit of my answer
p2971
as(dp2972
g6
V335858
p2973
stp2974
a((dp2975
g2
(lp2976
VYou may not modify the collection while you are enumerating it
p2977
aVmodifies , which is not allowed
p2978
aVIf you move  outside the loop, it should work
p2979
as(dp2980
g6
V335858
p2981
stp2982
a((dp2983
g2
(lp2984
s(dp2985
g6
V335858
p2986
stp2987
a((dp2988
g2
(lp2989
V expression should work
p2990
as(dp2991
g6
V335858
p2992
stp2993
a((dp2994
g2
(lp2995
VThis should do it
p2996
aVUpon completion,  would contain 10 bytes between file's offset of 50 and 60, and  would contain a number from 0 to 10, indicating how many bytes were actually read (this is of interest when the file has at least 50 but less than 60 bytes)
p2997
aVIf the file is less than 50 bytes, you will see
p2998
as(dp2999
g6
V335858
p3000
stp3001
a((dp3002
g2
(lp3003
VIgnoring the fact that adding to the collection being iterated over throws an exception
p3004
aVThere is definitely another way
p3005
aVWhen a  needs to know about its siblings, you should encapsulate  inside a class, say
p3006
aVYou can give each  a reference to its parent collection when you insert a level into a collection, and stop passing  in the methods than need the siblings
p3007
as(dp3008
g6
V335858
p3009
stp3010
a((dp3011
g2
(lp3012
VYou need an outer join:
p3013
aVThis will return a , not an empty string   for id=2
p3014
aVIf you need an empty string instead, use coalesce
p3015
aVOn SQL Server it would look like this:
p3016
as(dp3017
g6
V335858
p3018
stp3019
a((dp3020
g2
(lp3021
VYou need to remove  from the constructor's signature: it's already there implicitly
p3022
as(dp3023
g6
V335858
p3024
stp3025
a((dp3026
g2
(lp3027
VI have lots of Resource strings like the second one, all of which include some other Resource string in them
p3028
aVInstead of storing pre-made format strings ready for use, you could store raw material for building real format strings, and add code to expand them pro grammatically before use
p3029
aVFor example, you could store strings like this:
p3030
aVOf course passing these strings to  as-is is not going to work
p3031
aVYou need to parse these strings, for example with s, and find all instances where you have a word between curly braces, instead of a number
p3032
aVYou could then replace each word with its sequence number, and produce an array of parameters based on the names that you find between curly braces
p3033
aVIn this case, you will get these two values (pseudocode):
p3034
aVNote: Of course, producing this array of  required recursion
p3035
aVAt this point, you can invoke  to produce your final string:
p3036
aVThis returns the string that has resource strings pre-replaced for your callers:
p3037
aVThe callers can now use this string for formatting, without bothering with other resource values
p3038
as(dp3039
g6
V335858
p3040
stp3041
a((dp3042
g2
(lp3043
VYou can use  with an array constant, like this:
p3044
as(dp3045
g6
V335858
p3046
stp3047
a((dp3048
g2
(lp3049
VYes, your algorithm gets you the same result
p3050
aVThis enhancement to the classic 0-1 Knapsack is reasonably popular: Wikipedia explains it as follows:
p3051
aVAdditionally, if we use only a 1-dimensional array m[w] to store the current optimal values and pass over this array i + 1 times, rewriting from m[W] to m[1] every time, we get the same result for only O(W) space
p3052
aVNote that they specifically mention your backward loop
p3053
as(dp3054
g6
V335858
p3055
stp3056
a((dp3057
g2
(lp3058
VTry adding  after the first
p3059
aVThis has a decent chance of being of help, in case Eclipse does not auto-flush after
p3060
as(dp3061
g6
V335858
p3062
stp3063
a((dp3064
g2
(lp3065
VIf your sets are really small, the best representation is using bit sets
p3066
aVFirst, you build a map from strings to consecutive integers 0
p3067
aVN, where N is the number of distinct strings
p3068
aVThen you build your sets by bitwise OR-ing of  into a number
p3069
aVThis lets you turn your set operations into bitwise operations, which are extremely fast (an intersection is an ; a union is an , and so on)
p3070
aVHere is an example: Let's say you have two sets,  and
p3071
aVFirst, you build a string-to-number map, like this:
p3072
aVThen your sets would become  and
p3073
aVTheir intersection is , and their union is
p3074
aVYou know a set  is a subset of set  if
p3075
as(dp3076
g6
V335858
p3077
stp3078
a((dp3079
g2
(lp3080
s(dp3081
g6
V335858
p3082
stp3083
a((dp3084
g2
(lp3085
VThe answer depends on the indexes that you make available to the SQL engine
p3086
aVIf  is indexed but  is not, the engine is likely to start with ; if  is indexed but  is not, then the engine would probably start with the name; if both fields are indexed, the engine will search that index, and look up the rows by internal ids
p3087
aVNote that all of this is highly dependent on the RDBMS that you are using
p3088
aVSome engines would forego index searches altogether in favor of full table scans when the number of rows is low
p3089
as(dp3090
g6
V335858
p3091
stp3092
a((dp3093
g2
(lp3094
VIn UTF16, you may see bytes that are equal to  in the middle of the string; , , and  will return incorrect results for strings like that, because they operate under the assumption that strings are zero-terminated
p3095
aVYou can use copy, equal, and distance from the STL to copy, compare, and calculate length based on template-based iterators
p3096
as(dp3097
g6
V335858
p3098
stp3099
a((dp3100
g2
(lp3101
VThe key words here are can be
p3102
aVThe issue is that locals and params (which are essentially a flavor of locals) may be in registers, while instance and static variables will ultimately end up in memory (they would get into registers for the time necessary to operate on them, but eventually back to the memory they go)
p3103
as(dp3104
g6
V335858
p3105
stp3106
a((dp3107
g2
(lp3108
VThey are different things: you decide how vectors are ordered, and you can also put as many equal things into a vector as you please
p3109
aVSets are ordered in accordance to that set's internal rules (you may set the rules, but the set will deal with the ordering), and you cannot put multiple equal items into a set
p3110
aVOf course you could maintain a vector of unique items, but your performance would suffer a lot when you do set-oriented operations
p3111
aVFor example, assume that you have a set of 10000 items and a vector of 10000 distinct unordered items
p3112
aVNow suppose that you need to check if a value X is among the values in the set (or among the values in the vector)
p3113
aVWhen X is not among the items, searching the vector would be some 100 times slower
p3114
aVYou would see similar performance differences on calculating set unions and intersections
p3115
aVTo summarize, sets and vectors have different purposes
p3116
aVYou can use a vector instead of a set, but it would require more work, and would likely hurt the performance rather severely
p3117
as(dp3118
g6
V335858
p3119
stp3120
a((dp3121
g2
(lp3122
VYou can create a view that adds a calculation of substring (1,20) to the list of columns, and then use that calculated column in query expressions
p3123
as(dp3124
g6
V335858
p3125
stp3126
a((dp3127
g2
(lp3128
VEvery column in your select with group by must be either aggregated on, or included in group by
p3129
aVConditions on aggregated expressions must appear in the having clause, like this:
p3130
as(dp3131
g6
V335858
p3132
stp3133
a((dp3134
g2
(lp3135
VYou set up a UINavigationController that displays the data from the parent level of the hierarchy, putting a disclosure indicator  on cells corresponding to groups with one or more subscription
p3136
aVWhen the user taps the disclosure indicator, you push another table-based view controller on the stack, and give it the subscriptions of the current group to display
p3137
as(dp3138
g6
V335858
p3139
stp3140
a((dp3141
g2
(lp3142
VYou are almost there
p3143
aVYou need to consider what happens when , and return the result from the final  branch (hint:  and  can freely switch places)
p3144
as(dp3145
g6
V335858
p3146
stp3147
a((dp3148
g2
(lp3149
VYou need to have two sorts - first by the  part, and second by the numeric part, like this:
p3150
as(dp3151
g6
V335858
p3152
stp3153
a((dp3154
g2
(lp3155
VYou need to include namespace, like this:
p3156
as(dp3157
g6
V335858
p3158
stp3159
a((dp3160
g2
(lp3161
VTry this:
p3162
aVObviously, you will need to add exception handling code around this skeletal implementation
p3163
as(dp3164
g6
V335858
p3165
stp3166
a((dp3167
g2
(lp3168
VWhen string representations are used for visualization and similar purposes, the best approach is to override  method
p3169
aVStart with the most nested type, and go up the hierarchy
p3170
aVUse  of nested objects to implement  of outer objects
p3171
aVOne very useful method in formatting collections of objects is : it lets you format a collection without an explicit loop
p3172
as(dp3173
g6
V335858
p3174
stp3175
a((dp3176
g2
(lp3177
VSince you do not want to group by, you could use a correlated query:
p3178
aVI have not tried this in MySQL, but it should work
p3179
as(dp3180
g6
V335858
p3181
stp3182
a((dp3183
g2
(lp3184
VThe  interfaces in the EXE and in the DLL are not the same, even though their structures are identical
p3185
aVYou need to make a third dll with the interface, and share it among the DLLs and the EXE
p3186
aVCommon:
p3187
aVDLL:
p3188
aVEXE:
p3189
as(dp3190
g6
V335858
p3191
stp3192
a((dp3193
g2
(lp3194
VIn Java, statics are initialized when the class is first used, not when the static member itself is first used
p3195
aVYou can force "pre-loading" by using any other member of that class, not necessarily the static field itself
p3196
as(dp3197
g6
V335858
p3198
stp3199
a((dp3200
g2
(lp3201
VYou can use  repeatedly:
p3202
as(dp3203
g6
V335858
p3204
stp3205
a((dp3206
g2
(lp3207
VYour initializer of the array with a C string is invalid
p3208
aVThe good news is that you do not need it at all:
p3209
aVNote that I padded your  array with an extra element for the terminating zero
p3210
as(dp3211
g6
V335858
p3212
stp3213
a((dp3214
g2
(lp3215
VIf you modify any part of the object that is a part of the "key" (as defined by your custom comparator) you need to remove and re-insert the object for the tree set to "learn" about the change
p3216
aVYou should not be doing it while you are iterating, either: a good approach is to collect items that need changing in one loop, and then modify and re-insert them in another loop
p3217
as(dp3218
g6
V335858
p3219
stp3220
a((dp3221
g2
(lp3222
VThe best way to address the issue is to pass datetime values as datetime values, not as strings
p3223
aVThis would be easier both on the SQL server and on the readers of your stored procedure's source code
p3224
as(dp3225
g6
V335858
p3226
stp3227
a((dp3228
g2
(lp3229
VAs far as the logic of your design goes, you are not doing anything wrong
p3230
aVHowever, Java has a limitation that prevents you from implementing the same generic interface with different type parameters, which is due to the way it implements generics (through type erasure)
p3231
aVIn your code,  inherits from  its implementation of , and tries to add a  of its own; this is not allowed
p3232
aVThe simplest way to address this limitation is to override  in the , cast the player passed in to , and compare it to  goalkeeper
p3233
aVEdit
p3234
as(dp3235
g6
V335858
p3236
stp3237
a((dp3238
g2
(lp3239
VThe biggest practical difference is that you can provide different delegate instances for the same delegate from the same class, while you cannot do it with interfaces
p3240
as(dp3241
g6
V335858
p3242
stp3243
a((dp3244
g2
(lp3245
VTaking  is not the right way of finding the number of  elements
p3246
aVUse  instead
p3247
as(dp3248
g6
V335858
p3249
stp3250
a((dp3251
g2
(lp3252
VI think you are looking for
p3253
aVIt does not have a corresponding  wrapper, but it provides the operations that you are looking for: adding other  instances as children, iterating over siblings, associating your own data with a tree node, and so on
p3254
aVBecoming comfortable with Core Foundation programming takes some time, but it is usually better than rolling your own
p3255
as(dp3256
g6
V335858
p3257
stp3258
a((dp3259
g2
(lp3260
VYou should allocate memory for terminating zero, like this:
p3261
aVIf you fail to allocate an extra byte,  will write past the end of the allocated block, causing heap corruption
p3262
as(dp3263
g6
V335858
p3264
stp3265
a((dp3266
g2
(lp3267
VModify the connection string in your application that uses DB to point to your SQL server, like this:
p3268
aVFor example, if the name of your SQL server host computer is , and your database is called  connection string would look like this:
p3269
aVMake sure the user running your DB application has permissions to access the database, or replace  with appropriate user name and password
p3270
aVYou can find more information about DB connection strings here http://www
p3271
aVconnectionstrings
p3272
aVcom/
p3273
as(dp3274
g6
V335858
p3275
stp3276
a((dp3277
g2
(lp3278
VThis expression inserts dashes into the string after the 4-th and 6-th position, and throws away characters after the 8-th position
p3279
aVFor example,  becomes
p3280
aVSubstr cuts out three parts from the string: , , and  in my example
p3281
aVglues the parts back together, inserting dashes in between
p3282
aVbetween two string expressions represent concatenation, i
p3283
ag630
aVit makes one string by gluing the part on its left to the part on its right
p3284
as(dp3285
g6
V335858
p3286
stp3287
a((dp3288
g2
(lp3289
VSince you are looking up different rows of prices for campaign prices and default prices, you need two joins: one for the default price (inner, because the default is always there) and one for the campaign #3 price (outer, because it may not exist)
p3290
aVreturns its first operand if it is not null; otherwise, it returns its second operand
p3291
as(dp3292
g6
V335858
p3293
stp3294
a((dp3295
g2
(lp3296
VIn order to make data available to other functions, you need to pass it as a parameter, or make it available through a global (not recommended) or a static variable
p3297
aVThe best approach is to make a function that parses command line parameters, and stores the results in a  that you define specifically for the purpose of representing command line arguments
p3298
aVYou could then pass that structure around, or make it available statically or globally (again, using globals is almost universally a bad idea)
p3299
as(dp3300
g6
V335858
p3301
stp3302
a((dp3303
g2
(lp3304
VThe left operand is not a function, it is the value the function returns
p3305
aVSpecifically,  returns an instance of , which has some 20 overloads of  defined
p3306
as(dp3307
g6
V335858
p3308
stp3309
a((dp3310
g2
(lp3311
VYou should initialize  property in the constructor, like this:
p3312
aVEDIT
p3313
ag1971
ag1972
aVMicrosoft suggests starting the names of your properties in capital letters, to avoid confusion with member variables, which should be named starting with a lowercase letter
p3314
as(dp3315
g6
V335858
p3316
stp3317
a((dp3318
g2
(lp3319
VYou don't need a long, you need a double
p3320
aVor
p3321
aVOf course this will work too:
p3322
as(dp3323
g6
V335858
p3324
stp3325
a((dp3326
g2
(lp3327
VUsing effectively immutable objects lets you avoid creating a considerable number of classes
p3328
aVInstead of making pairs of [mutable builder]/[immutable object] classes, you can build one effectively immutable class
p3329
aVI usually define an immutable interface, and a mutable class that implements this interface
p3330
aVAn object is configured through its mutable class methods, and then published through its immutable interface
p3331
aVAs long as the clients of your library program to the interface, to them your objects remain immutable through their published lifetime
p3332
as(dp3333
g6
V335858
p3334
stp3335
a((dp3336
g2
(lp3337
VThis is because the  is static, and therefore is shared among all instances of the class
p3338
aVWhat you probably wanted is something along these lines:
p3339
aVPlease note that this may be overly simplistic, and not suitable in multithreaded environments
p3340
as(dp3341
g6
V335858
p3342
stp3343
a((dp3344
g2
(lp3345
VThis snippet makes an array of bytes with your string encoded in UTF-8:
p3346
as(dp3347
g6
V335858
p3348
stp3349
a((dp3350
g2
(lp3351
VYou are on the right track with using the
p3352
aVIn fact, you are almost there
p3353
aVYou already have two view controllers - one for the login page, and one for the home page
p3354
aVIn the , push both controllers onto the 's stack: first the "home" controller, then the "login" one
p3355
aVOnce the login controller detects that the login has been successful, call  or  to get to the home page
p3356
as(dp3357
g6
V335858
p3358
stp3359
a((dp3360
g2
(lp3361
VLeaving "that ARC thing" on is the best thing you can do to help yourself avoid countless hours debugging these pesky memory leaks and dangling pointer references
p3362
aVInstead of turning it off, read more about it to get a solid understanding of the feature
p3363
aVCLang people did an OK job explaining it in their documentation, but also there are other places where this great new feature is explained in much detail
p3364
as(dp3365
g6
V335858
p3366
stp3367
a((dp3368
g2
(lp3369
VTake a look at Java Persistence API
p3370
aVYou can generate JPA entities from an existing database in Eclipse
p3371
as(dp3372
g6
V335858
p3373
stp3374
a((dp3375
g2
(lp3376
VYou can do this:
p3377
as(dp3378
g6
V335858
p3379
stp3380
a((dp3381
g2
(lp3382
VUsing parameterized queries would go long way toward protecting you from SQL injection attacks, because most bad things happen in the value portion of your  conditions
p3383
aVFor exampleg given a condition , do this:
p3384
aVThen, bind  and , and run your query
p3385
aVIn C#, you would start with an in-memory representation of your  clause in hand, go through it element-by-element, and produce two output objects:
p3386
aVA string with the  clause, where constants are replaced by automatically generated parameter references , , and so on (use your favorite naming scheme for these blind parameters: the actual names do not matter)
p3387
aVA dictionary of name-value pairs, where names correspond to the parameters that you've inserted in your  clause, and values that correspond to the constants that you pulled from the expression representation
p3388
aVWith these outputs in hand, you prepare your dynamic query using the string, add parameter values using the dictionary, and then execute the query against your RDBMS source
p3389
aVDO NOT DO THIS
p3390
as(dp3391
g6
V335858
p3392
stp3393
a((dp3394
g2
(lp3395
V cannot be used to find the amount of memory that you allocated dynamically using
p3396
aVYou should store this number separately, along with the pointer to the allocated chunk of memory
p3397
aVMoreover, you must update this number every time you use  or
p3398
as(dp3399
g6
V335858
p3400
stp3401
a((dp3402
g2
(lp3403
VIf you would like to refactor it manually, try this:
p3404
aVNow you can invoke this logic as follows:
p3405
aVThere is an easier way of getting the first matching ID using LINQ - it is nearly always a better choice than rolling your own loop, let alone making nine similar loops
p3406
as(dp3407
g6
V335858
p3408
stp3409
a((dp3410
g2
(lp3411
VConsidering the clarifications from your comment, you should be able to produce the second kid of output from your post by running this query:
p3412
as(dp3413
g6
V335858
p3414
stp3415
a((dp3416
g2
(lp3417
VYou should not sort : it defines the permutation according to which you are sorting your array of strings
p3418
aVThe simplest way to do it is with a temporary array, like this:
p3419
aVThis works, because
p3420
aVThis problem can be solved without a temporary array as well, but the algorithm is more complex
p3421
as(dp3422
g6
V335858
p3423
stp3424
a((dp3425
g2
(lp3426
VUsing the trick from this article
p3427
aVThis looks a bit ugly, but it does the trick:
p3428
as(dp3429
g6
V335858
p3430
stp3431
a((dp3432
g2
(lp3433
VThere are no function pointers in Java, you need to do it through inheritance and/or interfaces
p3434
aVHere is an example:
p3435
aVIn your main program's constructor or static initializer:
p3436
aVIn your drawing code:
p3437
as(dp3438
g6
V335858
p3439
stp3440
a((dp3441
g2
(lp3442
VIt is a Bitwise/Logical OR - assign operator
p3443
aVis the same as
p3444
aVSince  is an , in your case  performs a bitwise operation
p3445
as(dp3446
g6
V335858
p3447
stp3448
a((dp3449
g2
(lp3450
VYour application is "sandboxed", meaning that it cannot access files outside of its temporary and document file space
p3451
aVis outside the "sandbox area", so iOS correctly does not let you access that file
p3452
aVIn a nutshell, if you would like to transfer data using temporary files, you'd need something like this for a file name:
p3453
aVThis document provides further reading on the subject
p3454
as(dp3455
g6
V335858
p3456
stp3457
a((dp3458
g2
(lp3459
VThe reason for the change almost certainly was to "push" the evaluation of your predicate into the underlying store, which backs your
p3460
aVInstead of bringing all  into memory and then using  to decide which ones to keep, the author of the changed API decided to use , and needed an  for that
p3461
aVYou are correct on the origin of the error: unlike in-memory predicates,  cannot use objects that it does not know, e
p3462
ag303
aVarbitrary instances of
p3463
aVWhat you need to do is to change the expression to avoid referencing objects of data types not supported by your target data store (I assume the expression eventually makes its way into either an Entity Framework or a Linq2Sql context)
p3464
aVFor example, instead of saying
p3465
aVyou should say
p3466
aV(your backing store almost certainly understands integers)
p3467
as(dp3468
g6
V335858
p3469
stp3470
a((dp3471
g2
(lp3472
VAs correctly noted above,  takes more than 24 megabytes
p3473
aVYou can try reducing the amount of memory by moving the largest dimension to the end of the array, like this:
p3474
aVThis may be enough for your program to squeak by in the programming contest
p3475
as(dp3476
g6
V335858
p3477
stp3478
a((dp3479
g2
(lp3480
VI do not have a Mac handy to verify if this works in OS X, but C standard library offers the  function in the  header, which could be used together with  to get the number of seconds that passed since the time when your program has launched
p3481
aVEDIT
p3482
aVThis should get you the time within one second from your program's launch, no matter at what point you invoke it:
p3483
as(dp3484
g6
V335858
p3485
stp3486
a((dp3487
g2
(lp3488
VTrivial constructor does nothing at all
p3489
aVThe list from your post says that a constructor is trivial when:
p3490
aVYou did not make your constructor do work by providing a non-default constructor
p3491
aVThe bases of your class did not make your constructor do work associated with preparing to handle virtual functions, virtual base classes, or non-trivial constructors of their own
p3492
aVThe data members of your class did not make your constructor do work associated with calling their own non-trivial constructors
p3493
aVThese rules taken together mean that the constructor has nothing to do, hence it is trivial
p3494
aVIn case of , it all depends on its data members: if they all have trivial constructors, and if you did not provide a non-trivial constructor yourself,  will have a trivial constructor too
p3495
as(dp3496
g6
V335858
p3497
stp3498
a((dp3499
g2
(lp3500
VIf you insist on using a number, hex is not the only base out there: what about base-26
p3501
aVThere is nothing wrong with comparing strings lexicographically, as long as both strings are of the same length
p3502
as(dp3503
g6
V335858
p3504
stp3505
a((dp3506
g2
(lp3507
VThe distance between two  numbers is calculated as an absolute value of their difference:
p3508
aVYou can put it in an  statement or do anything you wish with the result:
p3509
as(dp3510
g6
V335858
p3511
stp3512
a((dp3513
g2
(lp3514
VThis is correct
p3515
aVis called short-circuit  evaluation, or an OR-ELSE operator
p3516
aVThis is important in situations when evaluating the right-hand side may cause an undesirable consequence:
p3517
aVwould crash if it were not for short-circuiting
p3518
as(dp3519
g6
V335858
p3520
stp3521
a((dp3522
g2
(lp3523
V lacks the  method, so it inherits a default implementation from
p3524
aVThe only ways to get value of  are getting an  structure, or a
p3525
aVThe conversion error is introduced in the process of converting  to a
p3526
as(dp3527
g6
V335858
p3528
stp3529
a((dp3530
g2
(lp3531
VNobody except you could possibly share your private key with the government: it does not leave your computer when you get your SSL certificate from the certification authority
p3532
as(dp3533
g6
V335858
p3534
stp3535
a((dp3536
g2
(lp3537
VReturning from the method ends the scope of , hence the pointer is no longer fixed once you return
p3538
aVIt is safe to pass fixed pointers up the chain, e
p3539
ag303
aVBut returning makes the pointer non-fixed again
p3540
aVLogically, this makes sense: there is no alternative way for the CLR to decide when the pointer should become non-fixed after you have returned it from the call
p3541
as(dp3542
g6
V335858
p3543
stp3544
a((dp3545
g2
(lp3546
VYou get a concurrent modification exception because sublist is backed by the original list:
p3547
aVThe returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa
p3548
aVThe returned list supports all of the optional list operations supported by this list
p3549
aVIf you would like to avoid an exception, make a copy of the first sublist before modifying it
p3550
as(dp3551
g6
V335858
p3552
stp3553
a((dp3554
g2
(lp3555
VIt is an initialization of a structure
p3556
as(dp3557
g6
V335858
p3558
stp3559
a((dp3560
g2
(lp3561
V inherits from , which has a  property
p3562
aVIf you assign  to , you could fetch it back from the  in your / methods
p3563
as(dp3564
g6
V335858
p3565
stp3566
a((dp3567
g2
(lp3568
VIf you often call several identical SQL statements in a row, the answer is clear-cut: use SPs to reduce the number of round trips
p3569
aVThe load on your SQL server is not going to change, but the network latency will go down due to reduced number of round-trips
p3570
aVAs an added bonus, your system architecture may become easier to understand and maintain, because the complex SQL logic would be encapsulated in your data access layer
p3571
aVThis may not have anything to do with your SSL errors, but the situation with timeouts has a decent chance of improving
p3572
as(dp3573
g6
V335858
p3574
stp3575
a((dp3576
g2
(lp3577
VC string is a pointer to a zero-terminated sequence of characters
p3578
aVin front of  indicates to the compiler and to the programmer calling the function that  is not going to modify the data pointed to by the  pointer
p3579
aVThis point is easier to understand when you look at :
p3580
aVits second argument is , but its first argument is not
p3581
aVThis tells the programmer that the data pointed to by the first pointer may be modified by the function, while the data pointed to by the second pointer will remain constant upon return from
p3582
as(dp3583
g6
V335858
p3584
stp3585
a((dp3586
g2
(lp3587
VCircular dependency is not in itself a bad thing, as long as it makes sense in the real-world scenario that you are modeling
p3588
aVFor example, if two classes,  and , both represent numbers (presumably, using different representation), it makes sense to let one to be constructed from the other, and let it go both ways
p3589
aVAdding a third class may be a better option, but only if using it does not force you into the "friendship" territory, or forces you to write materially inferior code to avoid "friendship" declarations
p3590
aVSyntax would become less "fluent", too
p3591
aVSometimes, it is a good thing, for example, when you convert strings to numbers
p3592
aVBut there are times when the extra  is annoying, for example, when you construct C++ strings from C strings (but not the other way around)
p3593
aVUltimately, it boils to the ability of your library users to communicate their intentions in the most comprehensive way
p3594
aVIntroduction of circular dependencies among classes should be secondary to this goal
p3595
as(dp3596
g6
V335858
p3597
stp3598
a((dp3599
g2
(lp3600
VYou cannot, because of type erasure in the implementation of Java generics
p3601
aVWhen you need to know the class, the typical trick is to pass Class as a separate parameter called "type token", like this:
p3602
aVThis trick is discussed at some length in the tutorial on Java generics (see the bottom of the page for an example)
p3603
as(dp3604
g6
V335858
p3605
stp3606
a((dp3607
g2
(lp3608
s(dp3609
g6
V335858
p3610
stp3611
a((dp3612
g2
(lp3613
VSince you have four distinct variables, you can't get much more elegant than using Substring:
p3614
aVWere you looking for an array of four 2-character substrings, you could get fancier:
p3615
aVEDIT: The same can be done with a LINQ expression:
p3616
as(dp3617
g6
V335858
p3618
stp3619
a((dp3620
g2
(lp3621
VIn plain terms, short-circuiting means stopping evaluation once you know that the answer can no longer change
p3622
aVFor example, if you are evaluating a chain of logical s and you discover a  in the middle of that chain, you know the result is going to be false, no matter what are the values of the rest of the expressions in the chain
p3623
aVSame goes for a chain of s: once you discover a , you know the answer right away, and so you can skip evaluating the rest of the expressions
p3624
aVYou indicate to Java that you want short-circuiting by using  instead of  and  instead of
p3625
aVThe first set in your post is short-circuiting
p3626
aVNote that this is more than an attempt at saving a few CPU cycles: in expressions like this
p3627
aVshort-circuiting means a difference between correct operation and a crash (in the case where mystring is null)
p3628
as(dp3629
g6
V335858
p3630
stp3631
a((dp3632
g2
(lp3633
VThe system maintains an autorelease pool for you
p3634
aVIt is created before your program is started, and drained regularly when the event loop gets control
p3635
aVIn most situations, you do not need your own autorelease pool: just call  before returning your object, and you will be OK
p3636
ag1971
ag1972
aVIf you would like to learn about situations when you do need your own autorelease pool, Apple put together a nice guide for you
p3637
as(dp3638
g6
V335858
p3639
stp3640
a((dp3641
g2
(lp3642
VThis is almost certainly because the memory for your C string gets released at some point
p3643
aVIf you absolutely must have that global (and from the fact that you initialize it from your constructor it sounds like this may not be entirely right), make it
p3644
aVIt will hold on to its value until it is released explicitly
p3645
aVUse  whenever a conversion to  is necessary
p3646
as(dp3647
g6
V335858
p3648
stp3649
a((dp3650
g2
(lp3651
VI always put long test strings into resources, and maintain consistent naming between tests and their resources to keep the mapping easy
p3652
aVI use the same name for the resource and the test
p3653
aVWhen I need several resources for a test, I add a suffix , , , and so on
p3654
as(dp3655
g6
V335858
p3656
stp3657
a((dp3658
g2
(lp3659
VThis is because in order to pass an instance of  to a constructor with the second signature the constructor would need to call itself, resulting in infinite recustion leading to stack overflow
p3660
aVTry it out, this is a very instructive exercise
p3661
as(dp3662
g6
V335858
p3663
stp3664
a((dp3665
g2
(lp3666
VThis happens when the joined  table contains multiple rows for a key in the  table
p3667
aVThis query
p3668
aVShould tell you which rows have duplicates
p3669
as(dp3670
g6
V335858
p3671
stp3672
a((dp3673
g2
(lp3674
VStatic methods cannot be abstract or virtual in Java (which makes sense when you consider the way Java does dispatch through vtables)
p3675
aVWhat you should do is create an instance, and make it a singleton
p3676
aVConsidering the way you access , you do not need polymorphic behavior
p3677
aVPerhaps your real case is more complicated, but your snippet does not show a need for polymorphism
p3678
as(dp3679
g6
V335858
p3680
stp3681
a((dp3682
g2
(lp3683
VIf you are on
p3684
aVNET 3 or later, the simplest solution is to use SynchronizedCollection
p3685
as(dp3686
g6
V335858
p3687
stp3688
a((dp3689
g2
(lp3690
VOne of the easiest solutions would be to use  of :
p3691
as(dp3692
g6
V335858
p3693
stp3694
a((dp3695
g2
(lp3696
s(dp3697
g6
V335858
p3698
stp3699
a((dp3700
g2
(lp3701
V10000h will be read from memory no matter what - either from its location in the data memory, or from its location in the instruction memory
p3702
aVFor smaller constant values CPUs provide special instructions that do not require an additional space for the value being added, but this depends on the specific architecture
p3703
aVThe add immediate will probably be faster because of caching: by the time the instruction is decoded, the constant will be in cache, and the addition will be very quick
p3704
aVSmall off-topic note: your example shows a case when an optimizing C compiler would produce a faster code than a hand-written assembly: instead of adding 10000h, optimizer may increment the upper half-word by one, and leave the lower half-word as is
p3705
as(dp3706
g6
V335858
p3707
stp3708
a((dp3709
g2
(lp3710
V is not a pointer to a pointer, it is a contiguous chunk of memory suitable for storing 100 values of type double, which compiler knows how to address because you specified the dimensions
p3711
aVYou need to pass it to a function as an array
p3712
aVYou can omit the size of the initial dimension, as follows:
p3713
aVHowever, this will not let you pass arrays with the last dimension other than ten
p3714
aVThe best solution in C++ is to use : it is nearly as efficient, and significantly more convenient
p3715
as(dp3716
g6
V335858
p3717
stp3718
a((dp3719
g2
(lp3720
VFirst, I would drop the  from all expressions: all it does is reordering the bits in your private representation of the bit set, so you can flip this order without anyone noticing
p3721
aVSecond, you can get rid of the branch by using a clever bit hack:
p3722
aVThird, you can simplify your getter by letting the compiler do the conversion:
p3723
as(dp3724
g6
V335858
p3725
stp3726
a((dp3727
g2
(lp3728
VUse regex:
p3729
aVPut the characters you don't want preceeding  between square brackets in the regexp
p3730
aVThe expression in the answer ignores , , , , and
p3731
as(dp3732
g6
V335858
p3733
stp3734
a((dp3735
g2
(lp3736
V cannot convert your expression to be used with the back-end store
p3737
aVYou need to bring a string into memory first, then you can use 's projection method to call your method, like this:
p3738
as(dp3739
g6
V335858
p3740
stp3741
a((dp3742
g2
(lp3743
VYou should be able to use
p3744
aVto move the stream to a specific place
p3745
aVEDIT: The next question is how to find the
p3746
aVSince you want to move the position back through the file, not forward, it follows that you have read each position at some point
p3747
aVYou need to keep track of where you are in the stream as you read your lines, and store positions in a
p3748
aVInitially, the list should contain  at position zero
p3749
aVAs you process lines, add the length of the line plus the size of line break to the list
p3750
aVWhen you want to go back to line ,  should have the position you need
p3751
aVFor example, if your file has the lines below, your encoding uses one character per letter, and the line separator in the file is Windows-style
p3752
aVthen your  list should have  Note that I added 2 on each line for the separator characters
p3753
ag1971
ag1972
aVThis is an ugly solution, isn't it
p3754
aVIf it is any comfort, you are not the first person who ran into it
p3755
aVHere is a somewhat obscene rant from someone who wanted to solve a similar problem back in 2007
p3756
as(dp3757
g6
V335858
p3758
stp3759
a((dp3760
g2
(lp3761
VLINQ is excellent for searching; it's much worse at generating, so it is a wrong tool for the job
p3762
aVSo is recursion (although it is a better choice than LINQ)
p3763
aVWhat you need is two nested loops, like this:
p3764
aVHere is what the code does: at each iteration of the inner loop it places the first and the second element from the  array at distinct positions  and
p3765
aVNested loops go from  to , making sure all position combinations are covered
p3766
as(dp3767
g6
V335858
p3768
stp3769
a((dp3770
g2
(lp3771
VIf your underlying collection is , you will be forced to sort it from scratch every time the set changes, spending  time doing it
p3772
aVI think a much more efficient way of dealing with the issue is to replace  with , and keep it sorted through the insertions
p3773
aVAdding and removing elements in a sorted array would still be : although you can find the position using binary search (see  method), the insertion/removal is generally  (with a very low constant, though)
p3774
aVMaintaining uniqueness property of the set is also easy: if the binary search finds the same element that you were about to insert, simply skip the insertion
p3775
aVSame-value checks would take
p3776
as(dp3777
g6
V335858
p3778
stp3779
a((dp3780
g2
(lp3781
VIn order to make this syntax work,  must return the object on which it operates
p3782
aVThis is reasonably common
p3783
aVIn C++ you return a reference to itself - see C++ streams for an example
p3784
as(dp3785
g6
V335858
p3786
stp3787
a((dp3788
g2
(lp3789
V is a fancy way to write ; there is no boxing/unboxing going on there, just the plain CLR conversion between 16-bit and 32-bit integers
p3790
aVThe second case boxes and unboxes to the same type, which is allowed: value type  gets wrapped in an , and then gets unwrapped
p3791
aVThe third case tries to unbox to a different type ( instead of ) which is not allowed
p3792
as(dp3793
g6
V335858
p3794
stp3795
a((dp3796
g2
(lp3797
VThe easiest way to apply this method in your code is to apply it the most direct way - recursively
p3798
aVIt works for any number , not only for , so I wrote code that takes  as a parameter to make it more interesting:
p3799
as(dp3800
g6
V335858
p3801
stp3802
a((dp3803
g2
(lp3804
VThis should split the string into an array of 8-character substrings
p3805
as(dp3806
g6
V335858
p3807
stp3808
a((dp3809
g2
(lp3810
VYour expression find a match in the middle of the string
p3811
aVIf you add anchors to the beginning and to the end of your expression, the strings from your list will be ignored
p3812
aVYour expression would match empty strings, but that't the price you pay for being able to match  and  strings
p3813
aVA better choice would be
p3814
aVbecause it would match the decimal point only if at least one digit is present after it
p3815
as(dp3816
g6
V335858
p3817
stp3818
a((dp3819
g2
(lp3820
VI used Gesture Recognizers with a scroll view, and they work fine
p3821
aVIn your case, I would select a single tap recognizer, like this:
p3822
as(dp3823
g6
V335858
p3824
stp3825
a((dp3826
g2
(lp3827
VYou cannot pick a table to join in a case statement
p3828
aVYou should left-join to both tables, and then pick the value from one of them in the  statement, like this:
p3829
aVYou probably do not need the last expression (the  one), because it is going to be equal to  if there is a row in either  or  that matches
p3830
aVYou also have to put the  clause after the  clause:
p3831
aVEDIT: Taking into account ypercube's great suggestion, the query would look like this:
p3832
as(dp3833
g6
V335858
p3834
stp3835
a((dp3836
g2
(lp3837
VThere are many errors in your code:
p3838
aVYour  needs to be in the outer scope (syntax)
p3839
aVYou compare  to  instead of  to  (semantic)
p3840
aVYou are adding  to the output instead of  (semantic)
p3841
aVYou ignore the return of  (semantic)
p3842
aVHere is your modified code:
p3843
aVThis has some remaining issues
p3844
aVFor example, using  and  for termination conditions
p3845
aVIt is also very inefficient, but it should be a decent start
p3846
as(dp3847
g6
V335858
p3848
stp3849
a((dp3850
g2
(lp3851
VYou needed to keep track of what you have printed, for example in a
p3852
aVDeclare  at the top, then add an :
p3853
aVAn even easier solution is to remove :
p3854
as(dp3855
g6
V335858
p3856
stp3857
a((dp3858
g2
(lp3859
VInterface builder needs the method tagged with :
p3860
as(dp3861
g6
V335858
p3862
stp3863
a((dp3864
g2
(lp3865
VAssign nulls to variables referencing your objects, the use  to force  garbage collection
p3866
aVYou may need to call it twice in a row to speed non-accessible objects through the process
p3867
as(dp3868
g6
V335858
p3869
stp3870
a((dp3871
g2
(lp3872
VYou can use two loops - something like this should work:
p3873
as(dp3874
g6
V335858
p3875
stp3876
a((dp3877
g2
(lp3878
VTry using constructors:
p3879
aVThe you can create and initialize your atests in a simple loop:
p3880
as(dp3881
g6
V335858
p3882
stp3883
a((dp3884
g2
(lp3885
VThat Objective-C syntax is an extension of C syntax does not mean that it could not have its own compiler
p3886
aVC++ is the same way - its syntax is compatible with C (for the most part, anyway) but it has its own set of tools
p3887
aVCompilers for C, C++, and Objective-C can reuse parts of each other for preprocessing, syntactic analysis and code generation, but there is not need to run them sequentially (e
p3888
ag303
aVObjective-C ==> C ==> Target code)
p3889
aVCompilers no longer go through human-readable assembly language, either (this has been the case for a very long time, too)
p3890
as(dp3891
g6
V335858
p3892
stp3893
a((dp3894
g2
(lp3895
VSince you store the dates in date and date/time specific representations, formatting does not play into it at all (as opposed to some highly discouraged storage schemes when date/time is stored as strings, when formatting does matter, but for a wrong reason)
p3896
aVWhen you query MySQL from your C# code, you will get the correct dates no matter what your locale is
p3897
aVThey will be displayed differently based on the locale, but they will represent the proper date regardless of the locale settings
p3898
as(dp3899
g6
V335858
p3900
stp3901
a((dp3902
g2
(lp3903
VStaying with the "EXISTS" expressions, you could do something like this:
p3904
aVYou could also do it with an inner join instead of a correlated query, but I think this syntax should produce a sufficiently performant query as well
p3905
as(dp3906
g6
V335858
p3907
stp3908
a((dp3909
g2
(lp3910
VYou cannot do arbitrary nesting with RegExp - it is impossible even theoretically because of the limitations of RegExp model
p3911
aVWhat you need in this case is a parser
p3912
aVIt does not require much work to build a very simple recursive descent parser manually, but once the complexity becomes considerable, you should switch to a parser generator
p3913
aVMy personal favorite is ANTLR, but you have lots of other choices
p3914
as(dp3915
g6
V335858
p3916
stp3917
a((dp3918
g2
(lp3919
VWhat that someone probably meant was that you can let GC collect an object before it goes out of scope by setting the variable that holds a reference to that object to
p3920
aVThis technique has been of value in the past for some very rare cases (for example, before a long-running loop that does not reference an object)
p3921
aVThe compiler technology these days renders this idea virtually useless, because compilers are smart enough to detect these conditions, and act accordingly
p3922
as(dp3923
g6
V335858
p3924
stp3925
a((dp3926
g2
(lp3927
VWhat happens there is an undefined behavior, since  is out of scope at the time you referenced it in the call to  operator
p3928
aVIt does not crash because  and  happen to have the same address with your specific architecture and the implementation of C++
p3929
aVIn other words, others who try replicating your experiment on other architectures or with other compilers would probably get different results
p3930
as(dp3931
g6
V335858
p3932
stp3933
a((dp3934
g2
(lp3935
VCheck
p3936
aVIf it is anything other than , you should not be using the current transaction
p3937
aVIt goes without saying that you should check  for  before taking its status
p3938
as(dp3939
g6
V335858
p3940
stp3941
a((dp3942
g2
(lp3943
VChecking the error code of a wrapped exception is not a good practice, because it hurts encapsulation rather severely
p3944
aVImagine at some point rewriting the logic to read from a non-SQL source, say, a web service
p3945
aVIt would throw something other than  under the same condition, and your outer code would have no way to detect it
p3946
aVYou should add code to the block catching  to check for  right then and there, and throw  with some property that differentiates it from  thrown in response to non- and  with  in some meaningful way
p3947
aVFor example, if the magic number  means you've encountered a duplicate (a pure speculation on my part at this point), you could do something like this:
p3948
aVWhen you catch  later, you can check its  property, and act accordingly
p3949
aVEDIT 1 (in response to the comment that the DB-reading code cannot check for )
p3950
aVYou can also change your  to check for  in its constructor, like this:
p3951
aVThis is less desirable, because it breaks encapsulation, but at least it does it in a single place
p3952
aVIf you need to examine other types of exceptions (e
p3953
ag303
aVbecause you've added a web service source), you could add it to the  method, and everything would work again
p3954
as(dp3955
g6
V335858
p3956
stp3957
a((dp3958
g2
(lp3959
VI think ANTLR gets genuinely confused with two overlapping rules that cover the  input:
p3960
aVA single token , or
p3961
aVA sequence of three tokens of type , with texts of , , and
p3962
aVI think you should modify your  and  rules to move the  into the lexer, like this:
p3963
as(dp3964
g6
V335858
p3965
stp3966
a((dp3967
g2
(lp3968
VYou are not copying your  array in the  and the constructor
p3969
aVThat is why all instances of the key class end up sharing the same array that you modify in the loop
p3970
aVYou should change setFactors as follows:
p3971
as(dp3972
g6
V335858
p3973
stp3974
a((dp3975
g2
(lp3976
Vis the same as
p3977
aVIn other words, if  is an offset into string ,  would print the string  starting from the position at the  offset
p3978
aVis assigned , or *(&(a[1])), or simply , which points to
p3979
aVCount the squares on your diagram to find the value of  (it is 5)
p3980
aVis
p3981
aVDisclaimer: if anyone tried to check in such code at my company, he would no longer be working for us
p3982
as(dp3983
g6
V335858
p3984
stp3985
a((dp3986
g2
(lp3987
VAlthough this is not what you are trying to do considering the large amount of working code that you have in the project, you should still consider separating your parser and lexer more thoroughly
p3988
aVI is best to let the parser and the lexer do what they do best, rather than "fusing" them together
p3989
aVThe most obvious indication of something being wrong is the lack of symmetry between your  and  tokens: one is part of a composite token, while the other one is a stand-alone token
p3990
aVIf refactoring is at all an option, you could change the parser and lexer like this:
p3991
aVYou may need to enable backtracking and memoization for this to work (but try compiling it without backtracking first)
p3992
as(dp3993
g6
V335858
p3994
stp3995
a((dp3996
g2
(lp3997
VMake sure the build action on your resource is set to "embed resource"
p3998
as(dp3999
g6
V335858
p4000
stp4001
a((dp4002
g2
(lp4003
VYou are not changing the object in the assignment statement, you replace one immutable object with another one
p4004
aVObject  does not change to , it gets discarded, and a reference to  gets written into  in its stead
p4005
aVIn contrast,  represents a mutable object
p4006
aVYou can do this:
p4007
aVHere, you did not re-assign : it still points to the same object, but the content of that object has changed
p4008
as(dp4009
g6
V335858
p4010
stp4011
a((dp4012
g2
(lp4013
VArrays are represented and passed as pointers, so you are not copying anything here
p4014
aVIn contrast, if you were passing a single , it would be passed by value
p4015
aVBelow is a code snippet to illustrate this last point:
p4016
as(dp4017
g6
V335858
p4018
stp4019
a((dp4020
g2
(lp4021
VYou do not need all these loops: with the length of 3, you need to perform only two checks, like this:
p4022
aVFor arrays of arbitrary size, you could use a single loop:
p4023
as(dp4024
g6
V335858
p4025
stp4026
a((dp4027
g2
(lp4028
VYou have an extra dereference of  in the  check, and you are not initializing the pointer
p4029
aVThe program should look like this after the fix:
p4030
as(dp4031
g6
V335858
p4032
stp4033
a((dp4034
g2
(lp4035
VThe thing to do when the number of loops that you need is too high or is not known at compile time is to use recursion
p4036
as(dp4037
g6
V335858
p4038
stp4039
a((dp4040
g2
(lp4041
VAny number is either not equal to one or not equal to two: you can be certain of that :)
p4042
aVWhat you probably wanted to write was
p4043
as(dp4044
g6
V335858
p4045
stp4046
a((dp4047
g2
(lp4048
VYou should use  instead of
p4049
aVThe compiler checks your format string against the parameters that you are passing to , sees that you are passing an unsigned but print it as a signed integer, and issues a warning
p4050
aVThe warning indicates that for numbers greater than or equal to 2^31  would output a large negative number, when the data type implies a different semantic, namely, a large positive integer
p4051
aVEDITED in response to comments by Josh Caswell and thepepp
p4052
as(dp4053
g6
V335858
p4054
stp4055
a((dp4056
g2
(lp4057
VUse  operator to force  values to the back, like this:
p4058
aVYou need to cast to , because otherwise your nulls will sort together with your 0xFFs
p4059
as(dp4060
g6
V335858
p4061
stp4062
a((dp4063
g2
(lp4064
VUsing  is more explicit as far as conveying the meaning goes
p4065
aVYou can "assign" that meaning to , and the computer would be fine with it
p4066
aVThe readers of your program, however, would need to decypher that meaning from the way you use the  enum value, or from reading your comments
p4067
aV, on the other hand, is self-documenting and self-explanatory
p4068
as(dp4069
g6
V335858
p4070
stp4071
a((dp4072
g2
(lp4073
VIt does not work because your  is an instance variable, not a class variable
p4074
aVYou need to make it static, and make sure you increment the id in a thread-safe way, for example by using interlocked instructions
p4075
as(dp4076
g6
V335858
p4077
stp4078
a((dp4079
g2
(lp4080
VYou did not override the variable, you shadowed it with a brand-new instance variable declared in a more specific scope
p4081
aVThis is the variable printed in your  method
p4082
as(dp4083
g6
V335858
p4084
stp4085
a((dp4086
g2
(lp4087
VYou can allocate an array of 1000000 integers - it is only four megabytes, a small number by today's standards
p4088
aVPrime #1000000 should fit in a 32-bit integer (prime #500000 is under 8000000, so 2000000000 should be more than enough of a range for the first 1000000 primes)
p4089
aVYou are more likely to encounter issues with the time, not with the space for your computation
p4090
aVRemember that you can stop testing candidate divisors when you reach the square root of the candidate prime, and that you can use the primes that you found so far as your candidate divisors
p4091
as(dp4092
g6
V335858
p4093
stp4094
a((dp4095
g2
(lp4096
VI think the problem is that you are adding the views of both controllers to the , and also use the navigation controller incorrectly
p4097
aVHere is what you should do instead:
p4098
aVCreate the navigation controller first
p4099
aVPush the registration page, and then the login page onto the controller
p4100
aVHide the [back] button for the login page
p4101
aVAdd navigation controller as the only subview of the main window
p4102
aVIn the controller of the login page, call navigation controller's  to display the registration page
p4103
as(dp4104
g6
V335858
p4105
stp4106
a((dp4107
g2
(lp4108
VI do not have a clear-cut rule, but my "rule of thumb" is to store locally only the configuration that is specific to the computer on which the program runs, and store all shared configuration data in a database
p4109
aVWe developed a small library for storing and editing/versioning our configuration in a database
p4110
aVWe also designed a shared configuration store with separate areas for each application, and an ability to reuse config entries in multiple applications
p4111
aVWe store high-level configuration entries, such as rules, query definitions, etc
p4112
aVin the database
p4113
aVThe location-specific configuration, such as locations of plugin assemblies, connection string for the DB-based configuration library, logging settings, etc
p4114
aVgo into the "regular" web/app
p4115
aVconfig files
p4116
aVThis lets us keep a relatively clean separation of local vs
p4117
aVshared configuration
p4118
as(dp4119
g6
V335858
p4120
stp4121
a((dp4122
g2
(lp4123
VHere is a great resource for playing around with various regular expressions in JavaScript
p4124
aVYour particular expression looks like this:
p4125
as(dp4126
g6
V335858
p4127
stp4128
a((dp4129
g2
(lp4130
VIf you insist on using , your code should be slightly modified:
p4131
aVYou should consider using  instead of  for safety reasons
p4132
aVAlso,  is a more conventional function for concatenating C string
p4133
aVEDIT Here is an example of using  instead of
p4134
as(dp4135
g6
V335858
p4136
stp4137
a((dp4138
g2
(lp4139
VExpression trees represent IL structures that are roughly of the same kind that you see in your C#/VB
p4140
aVNET programs
p4141
aVYou cannot parameterize that property expression for the same reason that you cannot "parameterize" the following code:
p4142
aVIf you need to implement this functionality, and your expression trees are not passed to , you can write a helper function taking an object and a string, and returning value of that object's property identified by the string; then you can use  to invoke that helper function into the expression tree that you are building
p4143
as(dp4144
g6
V335858
p4145
stp4146
a((dp4147
g2
(lp4148
VYou cannot use binary search in the worst case scenario, when all numbers are equally spaced at
p4149
aVThe idea of a binary search and other divide-and-conquer algorithms is that you eliminate roughly half of the remaining range at each step
p4150
aVWhen all items are spaced at , every range of three or more consecutive items could potentially contain a pair of neighbors with the distance of , so you cannot eliminate either one of the two sub-ranges under consideration
p4151
aVYou will eventually examine every single pair of consecutive items, costing you
p4152
aVThat said, you can probably optimize a general case to do considerably better than  because of potential pruning opportunities
p4153
as(dp4154
g6
V335858
p4155
stp4156
a((dp4157
g2
(lp4158
VFirst, there is a nice and easy way to ensure that your properties are not null: it is called encapsulation
p4159
aVMake sure the properties are set in the constructor, and do validation in their setter if you choose to expose one
p4160
aVThis way the properties will be non-null after the object is constructed (otherwise, constructor would throw an exception), and the property setters would leave property values in a consistent state (otherwise, setters would throw an exception)
p4161
aVNow to the actual question: if one or both values could potentially be coming from other instances of , make the calculating method static
p4162
aVOtherwise, make it an instance method
p4163
ag1971
ag1972
aVIf your method returns a value, does not have parameters, and does not produce side effects, consider making it a calculated property instead of a method
p4164
as(dp4165
g6
V335858
p4166
stp4167
a((dp4168
g2
(lp4169
VYou cannot pop an instance of a controller that you have not pushed yet, even though it may be  identical to another controller to which you would like to return
p4170
aVIn your code snippet, you are trying to pop the stack of the navigation controller to a newly created object
p4171
aVThis controller is not on the stack, because you have just created it
p4172
aVSince the navigation controller cannot find a controller that you are looking for, it throws an error
p4173
as(dp4174
g6
V335858
p4175
stp4176
a((dp4177
g2
(lp4178
VThe problem is in the line below - it is a data reader, not a string returned by the data reader:
p4179
aVYou should replace this with
p4180
as(dp4181
g6
V335858
p4182
stp4183
a((dp4184
g2
(lp4185
VSince  is allocated statically, you cannot free and re-allocate it
p4186
aVBut you can pre-allocate more space to fit additional characters, like this:
p4187
aVNote that  would start at 100, and remain at 100, no matter what's the length of the string inside it
p4188
aVTo find out the current length of the C string inside it, use
p4189
as(dp4190
g6
V335858
p4191
stp4192
a((dp4193
g2
(lp4194
VThe loop would run for the same number of times, but there is a difference is in the body of the loop: the first loop would see original  and , while the second one would see them post-increment
p4195
as(dp4196
g6
V335858
p4197
stp4198
a((dp4199
g2
(lp4200
VMake this method take nullable  instead of plain , change code to pay attention to  values in these, and add three single-line overloads forwarding the calls to the do-work private method
p4201
as(dp4202
g6
V335858
p4203
stp4204
a((dp4205
g2
(lp4206
VIf the number of items in the list is  and the max number of items in sublist is , the solution of your problem comes from solving a Linear Diophantine Equation
p4207
aVwith additional constraints
p4208
aVWhere  is the number of sublists of the exact size , and  is the number of sublists of length
p4209
aVEDIT : Because of the coefficients to the equation are always off by one from each other, the solution is rather straightforward:
p4210
aVExample 1:
p4211
aVExample 2:
p4212
aVLook up an algorithm for solving linear Diophantine equations on the net - it is not that complicated, if you understand Euclidean algorithm well
p4213
aVThe number of solutions of the equation without constraints is infinite, but once you add the constraints, you should get a single solution
p4214
as(dp4215
g6
V335858
p4216
stp4217
a((dp4218
g2
(lp4219
VThis should work in memory, but I am not sure if it could be translated into SQL by EF:
p4220
as(dp4221
g6
V335858
p4222
stp4223
a((dp4224
g2
(lp4225
VYou do not need both  and  - you need one or the other:
p4226
aVOR
p4227
as(dp4228
g6
V335858
p4229
stp4230
a((dp4231
g2
(lp4232
VYou can call it like this:
p4233
as(dp4234
g6
V335858
p4235
stp4236
a((dp4237
g2
(lp4238
VC++ uses references for what you are trying to do:
p4239
aVReferences and pointers are similar, with one very important distinction: there is no such thing as a null reference (Constructing one is Undefined Behavior in C++ you can construct one, but doing so is considered a hack)
p4240
as(dp4241
g6
V335858
p4242
stp4243
a((dp4244
g2
(lp4245
VYou have a typo: the condition should be , not
p4246
aVThe rest of the program should work, but you may consider changing a couple of really small things:
p4247
aVConsider combining initialization of  with its calculation
p4248
aVConsider using  in place of
p4249
as(dp4250
g6
V335858
p4251
stp4252
a((dp4253
g2
(lp4254
VYou cannot override variables in C#, but you can override properties:
p4255
aVAnother approach would be to change the value in the subclass, like this:
p4256
as(dp4257
g6
V335858
p4258
stp4259
a((dp4260
g2
(lp4261
VYou need , not
p4262
aValways "rounds" up, while  rounds up or down depending on the value after the decimal point
p4263
as(dp4264
g6
V335858
p4265
stp4266
a((dp4267
g2
(lp4268
VIn C++ it would be a compile error to return anything other than  from :
p4269
aVIn C it is a warning, you will get a float reinterpreted as an : for example, 2
p4270
aV1F would be reinterpreted as 224
p4271
as(dp4272
g6
V335858
p4273
stp4274
a((dp4275
g2
(lp4276
VThe main thing about the API design exposing multiple functions is its internal consistency
p4277
aVEverything else comes as a distant second
p4278
aVThe decision on whether or not you pass index/length pairs depends on the way the API is expected to be used
p4279
aVIf you expect users to write series of method calls that take or put data in different segments of the same array, as in , then you need index/length pairs
p4280
aVOtherwise, it is an overkill
p4281
aVInput first or output first is your decision, but once you make it, stick with it in all methods with similar signatures
p4282
aVPassing output buffer is a reasonable option only if the buffer gets reused in the client
p4283
aVOtherwise, it's wasted effort in building and maintaining an extra set of API methods
p4284
aVOf course this decision is closely correlated with your choice to go with index/length pairs: if you take index and length, you should also take the output buffer
p4285
as(dp4286
g6
V335858
p4287
stp4288
a((dp4289
g2
(lp4290
V is a convention for declaring untyped pointers
p4291
aVSuch pointers need to be re-interpreted as pointers to some data type
p4292
aVWhether or not it works depends on what you or the API put at the address pointed to by the  pointer: if it is a sequence of  values with no gaps, a simple cast to  is going to work; otherwise, you may need to perform additional conversion
p4293
as(dp4294
g6
V335858
p4295
stp4296
a((dp4297
g2
(lp4298
VYou should cast to unsigned int, not to int
p4299
aVEDIT Casting boxed values (i
p4300
ag630
aVthrough an ) requires knowing the exact type of the property, including if it is nullable or not, etc
p4301
aVCalling
p4302
aVlets you find out the exact type
p4303
as(dp4304
g6
V335858
p4305
stp4306
a((dp4307
g2
(lp4308
VYou are not comparing apples to apples
p4309
aVYour C program does no copying of data from  buffer into your program's memory
p4310
aVIt also operates on raw files
p4311
aVYour C++ program needs to traverse the length of each string several times - once in the stream code to know when to terminate the string that it returns to you, once in the constructor of , and once in your code's call to
p4312
aVIt is possible that you could improve the performance of your C program, for example by using  if it is available to you
p4313
aVBut the biggest win comes from not having to copy your data
p4314
aVEDIT: edited in response to a comment by bames53
p4315
as(dp4316
g6
V335858
p4317
stp4318
a((dp4319
g2
(lp4320
VYou can implement the Levenshtein Distance algorithm, it provides a very nice measure of how close a match between two strings you have
p4321
aVIt measures how many keystrokes you need to make in order to turn one string into the other
p4322
aVYou can find a C++ implementation here
p4323
aVCompute Levenshtein Distance between string #4 and the three strings that you have
p4324
aVPick the string with the smallest distance
p4325
as(dp4326
g6
V335858
p4327
stp4328
a((dp4329
g2
(lp4330
V spawns the thread, and returns right away
p4331
aVBy the time the thread awakens from its random sleep, the loop will be finished, and the value of  will have advanced all the way to 10
p4332
aVThe value of , on the other hand, is captured and frozen before the call, so you will get all values from  to  in a random order, depending on how long each thread gets to sleep based on your random number generator
p4333
as(dp4334
g6
V335858
p4335
stp4336
a((dp4337
g2
(lp4338
VThis depends on when you want your program to stop
p4339
aVThere are several common approaches:
p4340
aVNever: you run an infinite loop until end-user hits  or otherwise terminates your program using the facilities of your operating system
p4341
aVUntil the user enters a special marker, i
p4342
ag630
aVa "keyword" , , etc
p4343
aVon a line by itself
p4344
aVUntil the user enters an empty line (i
p4345
ag630
aVhits )
p4346
aVSince the max number in your case is 100, you can use it as the limit to automatically terminate the input once the max is reached
p4347
as(dp4348
g6
V335858
p4349
stp4350
a((dp4351
g2
(lp4352
s(dp4353
g6
V335858
p4354
stp4355
a((dp4356
g2
(lp4357
VIf you are looking for a way to overload  for your own function unrelated to streams, here is how you can do it:
p4358
aVIn this example,  will be called on the instance of  returned from , and  will be passed to it as an argument
p4359
as(dp4360
g6
V335858
p4361
stp4362
a((dp4363
g2
(lp4364
VYou can create a list of closed roads by ID, and use the not provable operator, like this:
p4365
as(dp4366
g6
V335858
p4367
stp4368
a((dp4369
g2
(lp4370
VNot only does  expect void methods, it also expect them not to take any arguments
p4371
aVYou can wrap it in a lambda, an anonymous delegate, or a named static function
p4372
aVHere is one way of doing it:
p4373
aVHere is another syntax:
p4374
aVThe third syntax (with a named function) is the most boring:
p4375
as(dp4376
g6
V335858
p4377
stp4378
a((dp4379
g2
(lp4380
VIn most implementations,  tries allocating on the stack, and the size of the stack is limited as compared to the overall memory size
p4381
aVYou can often allocate larger arrays on the heap than on the stack, like this:
p4382
aVNote that if the file size  is larger than 5000000, you will write past the end of the buffer
p4383
aVYou should limit the amount of data that you read:
p4384
as(dp4385
g6
V335858
p4386
stp4387
a((dp4388
g2
(lp4389
VSince your call to  in the second example succeeds, it looks like you have enough elements in your  to store values for all values of  before entering the loop
p4390
aVHowever,  adds more elements to the back of the vector, past the position at the index
p4391
aVThat is why you see all zeros when you print values in the loop
p4392
aVIf you change the first example to print
p4393
aVyou will see values that you just pushed
p4394
aVThey would not be at the same positions as in the first example, though
p4395
as(dp4396
g6
V335858
p4397
stp4398
a((dp4399
g2
(lp4400
V is different from the other two constants in that it is initialized with a literal value
p4401
aVThis lets compiler put that value everywhere the constant is used, like this:
p4402
aVcan be replaced by
p4403
aVThis means that the compiler does not need to allocate space and store  in it
p4404
aVand  are different: one is calculated using a function, and the other one is supplied from a different compilation unit
p4405
aVThis means that the compiler can no longer perform the substitution the way it could with : the values of the  and  are not known to the compiler
p4406
aVTherefore the compiler generates code for
p4407
aVin the same way as if  were a variable stored in some place in memory
p4408
aVSince in this case  is an external constant, the linker will resolve its location, and fill in the information the compiler is missing (namely, the address of ) to make the program complete and ready to run
p4409
as(dp4410
g6
V335858
p4411
stp4412
a((dp4413
g2
(lp4414
VThis is because you are compiling with Automatic Reference Counting on
p4415
aVYou need to use a different construct with ARC:
p4416
aVAnother option is to turn off ARC for a specific file
p4417
as(dp4418
g6
V335858
p4419
stp4420
a((dp4421
g2
(lp4422
VSince you are not allowed to use outside libraries, you are not restricted to a specific format of the  file either
p4423
aVIn fact, they don't even need it to be all in the same file
p4424
aVYou can write your own tar-like utility in C# that walks a directory tree, and produces two files: a "header" file that consists of a serialized dictionary mapping  instances to an offset/length pairs, and a big file containing the content of individual files concatenated into one giant blob
p4425
aVThis is not a trivial task, but it's not overly complicated either
p4426
as(dp4427
g6
V335858
p4428
stp4429
a((dp4430
g2
(lp4431
VBoolean is a system type with two values understood by s, s, s etc
p4432
aVof the
p4433
aVNET
p4434
aVYou check for true value like this:
p4435
aVThe default value of  variables is
p4436
aVThis applies only to class/struct variables: local ones need to be initialized explicitly
p4437
as(dp4438
g6
V335858
p4439
stp4440
a((dp4441
g2
(lp4442
VIt should be
p4443
aVThe two variables differ by a level of indirection (simply speaking, the number of stars in their declaration is not the same)
p4444
aVYou need to add an  in front of the  to offset the extra  of the
p4445
as(dp4446
g6
V335858
p4447
stp4448
a((dp4449
g2
(lp4450
VYour last attempt was very close - here is one way to fix it:
p4451
as(dp4452
g6
V335858
p4453
stp4454
a((dp4455
g2
(lp4456
VIn cases like this I pass constructor arguments for the expected result into the test case, and, do the check myself
p4457
aVAlthough it is not as concise, it gets the job done
p4458
as(dp4459
g6
V335858
p4460
stp4461
a((dp4462
g2
(lp4463
VIt is probably because the  property of  is  by default, and passing  to  causes a crash
p4464
aVYou need to make sure the  is not  when you pass it to be copied, for example like this:
p4465
aVYou should also eliminate the first line - it serves no purpose, because the allocated and assigned value gets overwritten immediately
p4466
as(dp4467
g6
V335858
p4468
stp4469
a((dp4470
g2
(lp4471
VIf the only issue that you have with your solution is its alleged "non-OOP-edness", you could go for the Singleton Pattern instead
p4472
aVThis is a widely used pattern for situations when you must have a single instance of a class that needs to be shared among multiple parts of the system that are otherwise disconnected
p4473
aVThe pattern remains somewhat controversial, because some regard it as a glorified version of a global variable, but it is efficient at getting the job done
p4474
as(dp4475
g6
V335858
p4476
stp4477
a((dp4478
g2
(lp4479
V can absolutely be renamed to  in the last rule, and the logic of the rule will not change
p4480
aVThe reason the author hesitated to use  is probably because that variable does not denote a "midpoint" the way  does in the first rule
p4481
aVPersonally, I would go with more descriptive variable names -  and  sound like good candidates:
p4482
as(dp4483
g6
V335858
p4484
stp4485
a((dp4486
g2
(lp4487
VIf freely available C version of  is any indication, it does not look like anything you would expect
p4488
aVIt would not be of much help to you to find the
p4489
aVNET version, because the problem that you are solving (i
p4490
ag630
aVthe one with integers) is orders of magnitudes simpler, and can be solved in a few lines of C# code with the exponentiation by squaring algorithm
p4491
as(dp4492
g6
V335858
p4493
stp4494
a((dp4495
g2
(lp4496
VWell, segmentation fault errors happen when the pointer points to something wrong, not necessarily when the pointer is empty
p4497
aVThere is nothing wrong in the code snippet that you posted:  is a  that stays valid for the life of the program, and the return of  is done by value, so you are not returning a pointer to a local either
p4498
aVThe issue is most likely in the code that iterates over apples returned from
p4499
as(dp4500
g6
V335858
p4501
stp4502
a((dp4503
g2
(lp4504
VA quick approach would be to search from the back for a , then search back for starting from that position, and split the resulting string at the semicolons
p4505
aVRepeat the same process until you can no longer find a semicolon
p4506
aVA better approach would be to write a simple recursive descent parser with a single rule: the detection would be a lot more reliable if errors in the source are present
p4507
as(dp4508
g6
V335858
p4509
stp4510
a((dp4511
g2
(lp4512
VRe-declaration of Id in the descendent interface indeed hides the one in the parent
p4513
aVI use two different workarounds for this, entailing tradeoffs that I do not particularly like
p4514
aV1 - Using an abstract or even a non-abstract class instead of a mutable interface
p4515
aVThe biggest drawback is that the users of your library can no longer program to an interface
p4516
aV2 - Using a method instead of a property
p4517
aVThis is not ideal, because the setter is not idiomatic, and looks disconnected from the getter
p4518
as(dp4519
g6
V335858
p4520
stp4521
a((dp4522
g2
(lp4523
VAssuming that you are looking to sum up the amounts of everything higher up on the list and including the current line, a simplest to understand (but not necessarily the most efficient) answer would use a correlated query:
p4524
as(dp4525
g6
V335858
p4526
stp4527
a((dp4528
g2
(lp4529
VSince the question has an accepted and correct answer, I will be brief: here is a short program that you can run to see the incorrect behavior happening for yourself
p4530
aVThe  function spawns a thread, and modifies the data being squared in a loop concurrently with another loop calling the  with a volatile pointer
p4531
aVRelatively speaking, it does not fail often, but it does so very reliably in less than a second:
p4532
as(dp4533
g6
V335858
p4534
stp4535
a((dp4536
g2
(lp4537
V has a number of implementations of the  interface (e
p4538
ag303
aV), which may be of use in your situation
p4539
aVThere is also a  class that lets your thread block while waiting for the input
p4540
as(dp4541
g6
V335858
p4542
stp4543
a((dp4544
g2
(lp4545
VHashMap is not going to do it, but a TreeMap could
p4546
aVYou will need to normalize and reverse your keys (i
p4547
ag630
aVdecide how many bits you'd like to keep, and reverse the bits to make the less significant bits to be your most significant)
p4548
aVThen you can strip the less significant bits (formerly the most significant bits) from your keys, and use range searches of the tree map to find your answer
p4549
as(dp4550
g6
V335858
p4551
stp4552
a((dp4553
g2
(lp4554
VTechnical interviews are often designed to measure the depth of the candidate's knowledge, not any particular ability
p4555
aVArguably, there has been no need to implement your own linked lists and binary trees for good 15
p4556
aV20 years, yet the questions asking to implement these data structures routinely come up in technical interviews
p4557
aVA smart candidate should be able to figure out high-level concurrency APIs from a short tutorial and the API docs
p4558
aVYou ask about thread primitives to see if the candidate understands what is happening behind the scenes when he or she uses concurrency in general, no matter what API is called
p4559
aVPersonally, when I ask questions about things you'd never use, I do not insist on getting the correct names or the right order of the API method parameters
p4560
aVAs long as the candidates are clear on the concept, I do not mind them not remembering the particulars of the specific API
p4561
as(dp4562
g6
V335858
p4563
stp4564
a((dp4565
g2
(lp4566
VYou are correct, it is
p4567
aVDo the substitution
p4568
aVNow your loops change to this:
p4569
aVThis is your familiar , hence the result is  after the reverse substitution
p4570
as(dp4571
g6
V335858
p4572
stp4573
a((dp4574
g2
(lp4575
VIs there a problem with it
p4576
aVYes and no
p4577
aVIn your example, there is no problem
p4578
aVBut if you try doing self-joins, or join to the same table through multiple paths, you need to alias your tables in order to make it work
p4579
aVHere is an example when the same table () is used more than once:
p4580
as(dp4581
g6
V335858
p4582
stp4583
a((dp4584
g2
(lp4585
VIt is not clear why you would want a recursive solution for this problem, but the solution is relatively straightforward
p4586
aVHere is pseudocode:
p4587
aVmeans the first character;  denotes concatenation
p4588
as(dp4589
g6
V335858
p4590
stp4591
a((dp4592
g2
(lp4593
VIf  is an , use  format
p4594
aVThe  format is for C strings
p4595
as(dp4596
g6
V335858
p4597
stp4598
a((dp4599
g2
(lp4600
VStart by implementing a converter to hex, and use hex as your human-readable format during the initial stages of development
p4601
aVDoing HEX is easy, because you do not need to implement division: simply convert individual items to HEX, glue them together, and you are done
p4602
aVOnce your division algorithm is in place, you can implement conversion to decimal format by the usual "get the remainder % 10 and divide away" approach
p4603
as(dp4604
g6
V335858
p4605
stp4606
a((dp4607
g2
(lp4608
VAssuming that users do inserts in their own transactions, the engine commits each transaction in isolation
p4609
aVAs the commits make their way into the table, they get ordered in an arbitrary way, based on which thread gets what execution time slice earlier
p4610
aVIf users insert data that interferes with table constraints (say, they insert non-unique values into a unique column) the transaction of one random user would succeed, while all the others would fail
p4611
as(dp4612
g6
V335858
p4613
stp4614
a((dp4615
g2
(lp4616
VFirst, to answer your question about the crash, I think the reason you are getting segmentation fault is that you fail to multiply  by  in the call to
p4617
aVYou end up writing past the end of the block that has been allocated, eventually triggering a segfault
p4618
aVAs far as "deciding to free an object and when [
p4619
aVto keep an object" goes, C does not decide any of it for you: it simply does it when you tell it to by calling , without asking you any further questions
p4620
aVThis "obedience" ends up costing you sometimes, because you can accidentally free something you still need
p4621
aVIt is a good idea to NULL out the pointer, to improve your chance of catching the issue faster (unfortunately, this is not enough to eliminate the problem altogether, because of shared pointers)
p4622
aVTo summarize, managing memory in C is a tedious task that requires a lot of thinking and discipline
p4623
aVYou need to check the result of every allocation call to see if it has failed, and perform many auxiliary tasks when it does
p4624
as(dp4625
g6
V335858
p4626
stp4627
a((dp4628
g2
(lp4629
VI think that the reason the performance of your list lags that of the  is that you allocate a lot of small objects, whereas  (and , which is based on ) allocate in much larger chunks
p4630
aVIf you are set on improving performance of this particular piece of code, you could roll your own lookaside list by pre-allocating memory in large chunks, and then partitioning it into  as needed
p4631
aVRemember, however, that the memory management implications of doing this would be serious: you need to avoid creating blocks that linger in memory for much longer than it is required, causing a de facto memory leak
p4632
as(dp4633
g6
V335858
p4634
stp4635
a((dp4636
g2
(lp4637
VYou can define a variable of the same type as your  (say, ), make it available in the header, and define it in one of the sources, like this:
p4638
aVHeader:
p4639
aVC file:
p4640
aVUsages:
p4641
as(dp4642
g6
V335858
p4643
stp4644
a((dp4645
g2
(lp4646
VObjective C is a superset of C, and  is an operator in C
p4647
aVIt evaluates to the last expression in the chain, and creates a sequence point
p4648
aVSemicolon  cannot be used in an expression because it is not an operator
p4649
aVYou may have seen the  operator at work in a more common situation that involves  loops:
p4650
as(dp4651
g6
V335858
p4652
stp4653
a((dp4654
g2
(lp4655
VYour class violates the rule of three by defining a destructor without a copy constructor and an assignment operator
p4656
aVOnce you define these, your code should run OK: STL containers rely heavily on these, so you should ask yourself if you've implemented all three every time you use a class as a template argument for an STL container
p4657
as(dp4658
g6
V335858
p4659
stp4660
a((dp4661
g2
(lp4662
VTo me, this depends on what's the split between the  and the  branch relative sizes: if one is massively larger than the other, and the smaller one represents a logically exceptional situation, I put the shorter one into , and add a ; when they are roughly equal, both in size and in the logic flow, I keep them in their own  and  branches
p4663
aVvs
p4664
as(dp4665
g6
V335858
p4666
stp4667
a((dp4668
g2
(lp4669
VThis is the bit fields feature
p4670
aVIt has been available since the early C days
p4671
aVMicrosoft has a nice write-up on this feature, complete with pretty pictures showing the layout which is compiler-specific (they say that the pic is specific to MS)
p4672
as(dp4673
g6
V335858
p4674
stp4675
a((dp4676
g2
(lp4677
VThe slowdown is expected: the query does not get evaluated until you enumerate the results, so you skip this line in the debugger pretty quickly: all it does is preparing to query the data source; the querying is done on enumerating the results
p4678
aVAs far as I can tell without profiling your code, the issue is probably related to a big out-of-db select that happens when you convert  and  to : essentially, you bring the data from both tables into memory before doing your select
p4679
aVIf your tables are of considerable size, this is probably where most of the time goes
p4680
aVBut again, the only sure way to tell is profiling
p4681
as(dp4682
g6
V335858
p4683
stp4684
a((dp4685
g2
(lp4686
VSet  of your recognizer to
p4687
aVOtherwise, it "consumes" the touch for itself, and does not pass it on to the table view
p4688
aVThat's why the selection event never happens
p4689
as(dp4690
g6
V335858
p4691
stp4692
a((dp4693
g2
(lp4694
VThe issue in your code is that  does not copy  to  : the assignment merely creates a new alias for the existing object
p4695
aVTo make your code work, use
p4696
aVI must add that this is probably the most inefficient way of looking up the min element in a list, and also a rather archaic container
p4697
aVI would prefer using  instead of , and using LINQ's  function to get the minimum element
p4698
as(dp4699
g6
V335858
p4700
stp4701
a((dp4702
g2
(lp4703
VAs far as I know, there is no cheap and legal way of running Xcode, the iOS development environment, on a PC
p4704
aVYou do not need an iPhone, but you need an intel-based Mac running OS X
p4705
aVIf you plan to do iOS 5 development, your Mac needs to run the version code-named "Lion"
p4706
aVPre-lion version (Snow Leopard) will work too, but the latest version of the Xcode development environment is available only for Lion
p4707
aVThe distribution of the development tools includes a very good simulator for iPhone and iPad, which is fully integrated with the development environment
p4708
as(dp4709
g6
V335858
p4710
stp4711
a((dp4712
g2
(lp4713
VWhen the parameter is of DB type , it is a good practice to defensively strip the time part on setting the parameter, like this:
p4714
aVPlease let me know if this does not help, and I'll remove my answer
p4715
as(dp4716
g6
V335858
p4717
stp4718
a((dp4719
g2
(lp4720
VThe simplest thing to do would be to skip the string altogether, and use the definition of a multi-digit number from the elementary school:
p4721
aVYou could also create a string from your digits and parse it, but that is less efficient:
p4722
as(dp4723
g6
V335858
p4724
stp4725
a((dp4726
g2
(lp4727
VWhy bother with ticks
p4728
aVYou can force the time to exactly  or , like this:
p4729
as(dp4730
g6
V335858
p4731
stp4732
a((dp4733
g2
(lp4734
VIn Java all non-final instance methods are subject to override (i
p4735
ag630
aVvirtual)
p4736
aVThis equally applies to inner classes, so your code overrides 's  method
p4737
as(dp4738
g6
V335858
p4739
stp4740
a((dp4741
g2
(lp4742
VThe number of rows the  displays is controlled through 's  method
p4743
aVYour code should listen to changes of , update the number of points in your custom instance of the  with which you have configured your , and finally call  on the  to complete the update
p4744
as(dp4745
g6
V335858
p4746
stp4747
a((dp4748
g2
(lp4749
VIf using boost is an option, you could use
p4750
aVTechnically, it is not a pointer but a type-safe single-item container, but it should be able to get the job done without resorting to the "big guns" way of using
p4751
as(dp4752
g6
V335858
p4753
stp4754
a((dp4755
g2
(lp4756
VYour  needs to override the  method in such a way that hash codes of equal  instances are also equal (but not necessarily the other way around)
p4757
as(dp4758
g6
V335858
p4759
stp4760
a((dp4761
g2
(lp4762
VIn C# with LINQ you can do this:
p4763
aVThis sums up squared pairwise differences between individual coordinates, and returns the arithmetic square root of the sum
p4764
aVEDIT : This solution works for any number of dimensions greater or equal to one (thanks to Austin Salonen for pointing it out)
p4765
as(dp4766
g6
V335858
p4767
stp4768
a((dp4769
g2
(lp4770
VYou do not need to nest seven levels, all you need is five: four loops to try all four-way combinations of words that fit in the 16-letter set, and an extra loop to check the four vertical combinations implied by the choice of the horizontal words
p4771
aVYou need an efficient way to manage the set of letters that you are currently using
p4772
aVOne way to deal with it would be creating an array of counters, like this:
p4773
aVtries to "subtract" the word from the counts, and returns  if it succeeds
p4774
aVadds the word back to the counts
p4775
aVNow you can write a four-way nested skeleton of your code, like this:
p4776
aVThe check of vertical words adds the fifth and the last nesting level
p4777
aVI converted words to a hash set to speed up the check:
p4778
aVYou can find this program on the pastebin
p4779
aVIt finishes in several minutes on my computer without producing a solution
p4780
aVI verified that it finds solutions when they exist, though (when you comment out  and  and uncomment the last two lines, the program finds both the valid combination and its transposed image)
p4781
as(dp4782
g6
V335858
p4783
stp4784
a((dp4785
g2
(lp4786
VThe  data structure is portable as long as you do not cause undefined behavior by writing into one part of it and reading from the other
p4787
aVSpecifically, writing to  and reading from  or vice versa is undefined behavior
p4788
as(dp4789
g6
V335858
p4790
stp4791
a((dp4792
g2
(lp4793
VSince other answers have covered why you are getting an error, here is a way to move in one of the four directions in response to a key press: use lookup tables instead of the conditionals/switches
p4794
aVSetup portion:
p4795
aVThe function:
p4796
as(dp4797
g6
V335858
p4798
stp4799
a((dp4800
g2
(lp4801
VI do not think that XCode lets you set this flag for a folder or a group, but you have two reasonable alternatives to setting the flag on individual files:
p4802
aVIf your library is self-contained, you can create a separate project for it in the same workspace as your application, and disable ARC for that project
p4803
aVIf you are OK modifying the source of that library, you can attempt an automated ARC conversion
p4804
as(dp4805
g6
V335858
p4806
stp4807
a((dp4808
g2
(lp4809
VYou are almost there: you need to add watching the button in the intervals between blinking the LED:
p4810
as(dp4811
g6
V335858
p4812
stp4813
a((dp4814
g2
(lp4815
VAssuming that this is a homework, I'll suggest a general idea without the code:
p4816
aVStart by splitting the string on the  characters
p4817
aVCreate an initially empty map of  to  with the counts
p4818
aVGo through the parts you've got back from the split, and parse them as  values
p4819
aVFor each value, see if there is a corresponding item in the map; if there is a number there, increment it; otherwise, add an entry with the new number and
p4820
aVOnce you're done with the tokens, go through the map and find the max value
p4821
aVIf the max is , return the first token
p4822
aVIf the max is not , go through the map again, and collect all keys where the value is equal to max
p4823
aVThis approach lets you work with very large numbers, and it does not discriminate between numbers with and without leading zeros
p4824
aVIn other words, it will identify  in  sequence as a unique winner, not as a tie with
p4825
as(dp4826
g6
V335858
p4827
stp4828
a((dp4829
g2
(lp4830
VThe  adds an anonymous delegate to the event
p4831
aVInstead of creating a named method with the signature , you can use C#2
p4832
aV0 syntax to create such delegates anonymously in the body of another function
p4833
aVAnother way of doing it would be to use a more concise lambda syntax from C#3
p4834
aV5+:
p4835
as(dp4836
g6
V335858
p4837
stp4838
a((dp4839
g2
(lp4840
VNOTE : The original answer has been replaced with one in which I have a lot more confidence (and I can explain it, too)
p4841
aVBoth answers produced the same results on my set of test cases
p4842
aVYou can solve this problem using a dynamic programming approach
p4843
aVThe key observation is that it never makes sense to decrement a number to a value not found in the original array
p4844
aV(Informal proof: suppose that you decremented a number  to a value  that is not in the original sequence in order to avoid removing a number  from the result sequence
p4845
aVThen you can decrement  to  instead, and reduce the cost by )
p4846
aVNow the solution becomes easy to understand: it is a DP in two dimensions
p4847
aVIf we sort the elements of the distinct elements of the original sequence  into a sorted array , the length of  becomes the first dimension of the DP; the length of  becomes the second dimension
p4848
aVWe declare
p4849
aVThe value of  is the cost of solving subproblem  while keeping the last element of the solution under
p4850
aVNote: this cost includes the cost of eliminating  if it is less than
p4851
aVThe first row  is computed as the cost of trimming  to , or zero if
p4852
aVThe value of  next row is calculated as the minimum of , where  is the cost of trimming  to , or  if it needs to be eliminated because  is bigger than
p4853
aVThe answer is calculated as the minimum of the last row
p4854
aVHere is an implementation in C#:
p4855
aVThis direct implementation has space complexity of
p4856
aVYou can reduce it to  by observing that only two last rows are used at the same time
p4857
as(dp4858
g6
V335858
p4859
stp4860
a((dp4861
g2
(lp4862
VThe use of  in one case and  in the other does not make it comparing apples-to-apples
p4863
aVOnce you replace  with  for non-concurrent children, the speed of running both versions becomes more or less the same
p4864
as(dp4865
g6
V335858
p4866
stp4867
a((dp4868
g2
(lp4869
VIn particular that a reference type that is not initialized will always have a null value
p4870
aVI think you are mixing up local variables and member variables
p4871
aVSection 5
p4872
aV3 talks specifically about local variables
p4873
aVUnlike member variables that do get defaulted, local never default to null value or anything else: they simply must be assigned before they are first read
p4874
aVSection 5
p4875
aV3 explains the rules that the compiler uses to determine if a local variable has been assigned or not
p4876
as(dp4877
g6
V335858
p4878
stp4879
a((dp4880
g2
(lp4881
Vcallee' performs a few different things, each of which might throw the same type of exception
p4882
aVI think this is the real culprit:  should be throwing either a different type of exception based on kind of failure has happened, or the exceptions of the same type should carry enough additional information to let the caller figure out how to handle this particular exception
p4883
aVOf course if the caller is not intended to handle the exception at all, it shouldn't be in the business of catching it in the first place
p4884
as(dp4885
g6
V335858
p4886
stp4887
a((dp4888
g2
(lp4889
VTry adding  to isolate your code from EF's:
p4890
as(dp4891
g6
V335858
p4892
stp4893
a((dp4894
g2
(lp4895
VI think the reason is that the compiler is interpreting the  literal as a signed 64-bit number, since it does not fit into a signed 32-bit int
p4896
aVIf you replace the number with , you should get the result you expect
p4897
as(dp4898
g6
V335858
p4899
stp4900
a((dp4901
g2
(lp4902
VYou can add a class extension, and store the global data in ivar, like this:
p4903
aVThis will hide the  from the interface, and make it available throughout the methods you implement inside your implementation block of
p4904
as(dp4905
g6
V335858
p4906
stp4907
a((dp4908
g2
(lp4909
VThe second argument of  is , not :
p4910
aVEDIT: For MS VS, I defined  as follows:
p4911
aVThen the invocation looks like this:
p4912
as(dp4913
g6
V335858
p4914
stp4915
a((dp4916
g2
(lp4917
VIt is called "syntax highlighting"
p4918
as(dp4919
g6
V335858
p4920
stp4921
a((dp4922
g2
(lp4923
VIt should be  rather than :
p4924
aVThe reason for this is that in C anything that is not zero is considered  in an  statement, while Java forces you to use Booleans
p4925
aVIn this case, the expression can evaluate either to 4 or to 0, so comparing it with 1 is always false
p4926
as(dp4927
g6
V335858
p4928
stp4929
a((dp4930
g2
(lp4931
VYour definition is circular: it tries to put a  inside an , and a vector of edges inside a
p4932
aVYou need to make one of these a pointer, for example, like this:
p4933
ag1971
ag1972
aVYou were missing a semicolon after the struct
p4934
as(dp4935
g6
V335858
p4936
stp4937
a((dp4938
g2
(lp4939
VYou can try this:
p4940
as(dp4941
g6
V335858
p4942
stp4943
a((dp4944
g2
(lp4945
VYour compare function needs to return a boolean 0 or 1, not an integer 1 or -1, and it should have a strongly-typed signature:
p4946
aVThe error you were seeing are due to  interpreting everything non-zero returned from the comp function as , meaning that the left-hand side is less than the right-hand side
p4947
aVNOTE : This answer has been heavily edited as the result of conversations with sbi and Mike Seymour
p4948
as(dp4949
g6
V335858
p4950
stp4951
a((dp4952
g2
(lp4953
VCompare the remainder of the division to zero, like this:
p4954
aVThe modulus operator () returns the remainder of division
p4955
aVFor 12 and 6 it is 0, but for 20 and 6 it is 2
p4956
aVThe formula it uses is:
p4957
as(dp4958
g6
V335858
p4959
stp4960
a((dp4961
g2
(lp4962
VComparing doubles for equality is a bad idea in general
p4963
aVYou should make candidate an int, and change the program around like this:
p4964
aVNote the  around the : it drops the non-integer part of the square root
p4965
as(dp4966
g6
V335858
p4967
stp4968
a((dp4969
g2
(lp4970
VAlthough there is no need to use a pattern in situations when the format of the input text is always the same, a situation when the format needs to change
p4971
aVFor example, if you think that your application may support additional file formats in the future, the Strategy Pattern would come in handy
p4972
aVAn application using this approach would program to the interface of FileParser, and the differences between parsing delimited and parsing fixed-width files would be encapsulated in the implementation of the  that you pick at run time
p4973
as(dp4974
g6
V335858
p4975
stp4976
a((dp4977
g2
(lp4978
VYou can try wrapping the  in another select, and add a  on all columns:
p4979
as(dp4980
g6
V335858
p4981
stp4982
a((dp4983
g2
(lp4984
VYou can program this straight from the definition:
p4985
aVThe algorithm tries doubling all substrings of length len, and replace doubled strings with singles
p4986
as(dp4987
g6
V335858
p4988
stp4989
a((dp4990
g2
(lp4991
VYou can use string's  method, like this:
p4992
aVThis will print array elements converted to , separated by
p4993
as(dp4994
g6
V335858
p4995
stp4996
a((dp4997
g2
(lp4998
VRight-click your project, and choose "Options" from the context menu
p4999
aVIn the left pane of the "Options" dialog, open the "Build" subtree
p5000
aVFrom the "Build" subtree, choose "Output"
p5001
aVUse "Assembly name" property in the right pane to name your executable
p5002
as(dp5003
g6
V335858
p5004
stp5005
a((dp5006
g2
(lp5007
VFirst, find a base for your recursion by solving a degenerate case (a  grid)
p5008
aVThen look for a recurrence step by imagining that part of the problem, say,  is already solved, and see if you can expand upon that solution by adding one row or one column to it, making the solution  or
p5009
aVThis should be simple: for each point you add, see if a grid point is below the diagonal, and then add up the number of paths leading to that point from the bottom and from the left
p5010
aVOne of these points would be in the , the other would be in the additional row or column that you are building
p5011
aVWith the degenerate case and a recursive step in hand, build your solution by first solving a  problem, then , then  and so on, until you have your  solution
p5012
as(dp5013
g6
V335858
p5014
stp5015
a((dp5016
g2
(lp5017
VI would stay away from  in favor of  if possible: using "plain" list reveals too much about your implementation
p5018
aVis a good choice as it gives you best flexibility in choosing the actual implementation, but it may not be sufficient if you need to find out the number of elements available to you without enumerating through the collection
p5019
as(dp5020
g6
V335858
p5021
stp5022
a((dp5023
g2
(lp5024
VTry this:
p5025
aVThis will create 25 instances of your class, and put them into an array
p5026
as(dp5027
g6
V335858
p5028
stp5029
a((dp5030
g2
(lp5031
VYou are missing the std namespace reference in the cc file
p5032
aVYou should also call   because there is no implicit conversion from  to  expected by 's constructor
p5033
as(dp5034
g6
V335858
p5035
stp5036
a((dp5037
g2
(lp5038
VYou need to initialize  array before the  loop:
p5039
as(dp5040
g6
V335858
p5041
stp5042
a((dp5043
g2
(lp5044
VFirst, construct character counts for the short string
p5045
aVThen construct character counts for the long string
p5046
aVFor each character count of the short string, divide the count from the long string by the count of the short string, keeping only the integer part
p5047
aVPick the smallest integer - it is the answer to your problem
p5048
as(dp5049
g6
V335858
p5050
stp5051
a((dp5052
g2
(lp5053
VThis makes your code immune to re-ordering of the enum values
p5054
aVHere is an illustration of how it works:
p5055
aVThis is what the program printed
p5056
aVNote how  and  have switched places to match the order of the
p5057
as(dp5058
g6
V335858
p5059
stp5060
a((dp5061
g2
(lp5062
VThis depends on whether the  is a  (a reference type) or a  (a value type)
p5063
aVYour explanation is correct for reference types, but value types are copied in their entirety, so the list will grow by the size of your value type as you add elements to the list
p5064
aVAlso note that list growing will not be uniform with element additions, because internally  allocates memory in chunks, expecting to accommodate more elements
p5065
as(dp5066
g6
V335858
p5067
stp5068
a((dp5069
g2
(lp5070
VThere's a comment right above that constructor in the source code:
p5071
aVThat explains why the documentation of this non-public constructor is not included in the public documentation
p5072
as(dp5073
g6
V335858
p5074
stp5075
a((dp5076
g2
(lp5077
VUse this regexp:
p5078
aVIts group 1 will capture the name
p5079
ag1971
ag1972
aVYou should move  outside the loop
p5080
as(dp5081
g6
V335858
p5082
stp5083
a((dp5084
g2
(lp5085
VNot only does your code display the first name and last name in different cells, it also does not work for rows at indexes greater than one
p5086
aVThis is because your table data source reads from a brand-new array that you create with alloc/init on the first line, rather than reading from your model
p5087
aVYour little array contains only two objects, explaining the two rows
p5088
aVHere is what you need to do: first, make an array of users available to your table's data source
p5089
aVSuppose it's called
p5090
aVPut user data for each user into that array
p5091
aVSuppose each user is stored as an object of type  that responds to  and  calls with the first and the last name of the user
p5092
aVNow put this code into your table's data source:
p5093
aVEDIT : If your  stores the first and the last names in separate consecutive string objects, you can still do it (though I recommend against it, because it will be confusing to people who maintain your program in the future)
p5094
aVFirst, you need to change the method that returns the number of items in the table to return  instead of just
p5095
aVThen you can modify your code as follows:
p5096
aVEDIT2 : Here is how you create a class that stores the first and the last name of a user
p5097
aVYou add the  part to , and the  part to  file
p5098
aVYou then import  in
p5099
aVm files from which you reference  class, and use  to initialize new instances
p5100
aVThe sample below assumes that you use ARC:
p5101
aVMYUser
p5102
aVh file:
p5103
aVMYUser
p5104
aVm file:
p5105
as(dp5106
g6
V335858
p5107
stp5108
a((dp5109
g2
(lp5110
VYou need to use  (uppercase C) instead of  (lowercase c) format specifier in the first call to
p5111
aVThe lowercase 'c' format specifier is for 8-bit characters; the uppercase 'C' is for unicode
p5112
aVEDIT : If you want to do it more efficiently, copy the data into an array of  elements, reverse the array, and feed the result into another
p5113
aVThis lets you reverse the string in  steps:
p5114
as(dp5115
g6
V335858
p5116
stp5117
a((dp5118
g2
(lp5119
VI think that the source of your confusion is an assumption that  is a single operation; it is not
p5120
aVHere is what's going on:
p5121
aVA placement new operator is called to allocate memory
p5122
aVA constructor is called to initialize the allocated memory
p5123
aVThe first call needs to return the value (a )
p5124
aVIt is a block of memory suitable to store your object
p5125
aVThe second call is a constructor
p5126
aVIt gets the value from the placement new operator as its hidden  parameter, and performs its regular initialization tasks on it
p5127
as(dp5128
g6
V335858
p5129
stp5130
a((dp5131
g2
(lp5132
VThe call of  counters the effect of  by deleting the last character of the
p5133
aVEach loop iteration proceeds as follows:
p5134
aVappend a character
p5135
aVprint the result
p5136
aVperform a recursive invocation at the level
p5137
aVremove the character we added at step 1
p5138
as(dp5139
g6
V335858
p5140
stp5141
a((dp5142
g2
(lp5143
VYou have a semicolon after the nested loop
p5144
aVThis makes a syntactically correct empty loop, followed by a block that references an undeclared variable
p5145
aVAs a side note, it is typical to name loop variables with lowercase letters, typically starting in , , , , and and so on
p5146
aVLowercase  is often skipped due to its similarity to uppercase
p5147
as(dp5148
g6
V335858
p5149
stp5150
a((dp5151
g2
(lp5152
VUse  method:
p5153
aVSince  is an instance of a generic type with exactly one type parameter, the type  will be returned in the 0-th position of the returned array
p5154
as(dp5155
g6
V335858
p5156
stp5157
a((dp5158
g2
(lp5159
VWithout changing the rest of your data structures for something more efficient (say, a ) you could achieve the same effect with a single  and a nested loop:
p5160
as(dp5161
g6
V335858
p5162
stp5163
a((dp5164
g2
(lp5165
VYou can override the getter for text label returning (a) your label or (b) nil:
p5166
aVThis will prevent users of your derived class from accessing the label of the base cell type
p5167
as(dp5168
g6
V335858
p5169
stp5170
a((dp5171
g2
(lp5172
VRemove the semicolon  after :
p5173
aVsubstitutes its arguments literally, so your expression after preprocessing becomes
p5174
aVAs you can see, there is a semicolon in the middle of the expression, which is a syntax error
p5175
aVOn the other hand, your other expression
p5176
aVdoes not exhibit such problem, because having two semicolons in a row as in
p5177
aVis syntactically valid
p5178
as(dp5179
g6
V335858
p5180
stp5181
a((dp5182
g2
(lp5183
VTry this regexp:  (Java string: )
p5184
aVThis expression has a drawback of matching zero-length strings
p5185
aVIf your input must have exactly one special character, remove the question mark  from the expression
p5186
as(dp5187
g6
V335858
p5188
stp5189
a((dp5190
g2
(lp5191
VTo find out if it is the last row in a section, call  on the data source delegate (presumably, it's , since you are in a  method)
p5192
aVIf the value returned from that method equals , you are at the last row
p5193
aVIf additionally , you are at the only row
p5194
aVIf  but  returned a number other than 1, you are looking at the first row in a section
p5195
as(dp5196
g6
V335858
p5197
stp5198
a((dp5199
g2
(lp5200
VYou do not need a second , and the second  was probably intended to be an :
p5201
aV(the reason I think you wanted an  is because otherwise you have a conjunction of contradictory clauses , which is always false)
p5202
aVEDIT : In response to OP's comment about the results he is trying to get, here is a different query:
p5203
aVNow the conjunction clauses are no longer contradictory, because they refer to two different rows  and
p5204
as(dp5205
g6
V335858
p5206
stp5207
a((dp5208
g2
(lp5209
VTechnically, you are correct: base-16 encoding will save some amount of space, at the expense of readability (anyone who can read your new XML could be safely labeled a geek)
p5210
aVBut wait, there is more to it
p5211
aVFirst, why stop at base-16, when you can easily go to base-64 to save even more bytes, at the expense of even more readability
p5212
aVNow even geeks will be out
p5213
aVSecond, many XSD features will become unusable: all these built-in XSD data types, min and max constraints for your numbers, digit patterns, etc
p5214
aVwork only with decimal integers
p5215
aVAnd third, if you are even minimally concerned about saving space, why bother with XML in the first place
p5216
aVThe format treats space rather liberally, intentionally bringing lots of markup to make the data human readable
p5217
aVWhich brings us right back where we started: using HEX kills readability
p5218
aVIn short, you are right, but the small savings in space are not worth the trouble
p5219
as(dp5220
g6
V335858
p5221
stp5222
a((dp5223
g2
(lp5224
VBoth  and  are of type
p5225
aVIf you declare  as  as well, you would correctly capture division results between 0 and 1
p5226
aVIf you need to make it an integer later, use , , or  to round up, down, or to the nearest whole number
p5227
as(dp5228
g6
V335858
p5229
stp5230
a((dp5231
g2
(lp5232
VI think the reason you are seeing this is that you include  twice at some point: once directly and once indirectly
p5233
aVYou probably need to add an include guard to your header:
p5234
as(dp5235
g6
V335858
p5236
stp5237
a((dp5238
g2
(lp5239
VIf you are set in using regexp, transform your string like this:
p5240
aVThis expression captures the elements of your date, and re-orders them to bring slower-changing elements closer to the beginning of the string
p5241
aVNow the strings can be alphabetized to sort on the date
p5242
as(dp5243
g6
V335858
p5244
stp5245
a((dp5246
g2
(lp5247
VTry this:
p5248
aVThis code snippet produces the following output:
p5249
as(dp5250
g6
V335858
p5251
stp5252
a((dp5253
g2
(lp5254
VThe error has nothing to do with the declaration at hand: most likely, it is a delayed consequence of error that you made earlier
p5255
aVSome of the code that ran prior to hitting the map declaration has corrupted the heap in one way or another
p5256
aVThings that could potentially lead to a "delayed" crash are
p5257
aVReleasing memory that has not been allocated to you
p5258
aVReleasing memory several times
p5259
aVWriting to outside the memory region that has been allocated to you
p5260
aVThese errors may trigger a crash immediately, but they often do not: instead, a corrupted piece of some sensitive heap structure waits to be allocated to trigger a crash
p5261
aVWhen  allocates memory for its internals, it triggers the crash by requesting memory from a corrupted heap
p5262
aVThe best way to find out is to use a memory profiling tool
p5263
aVIt should pinpoint the error to you at the time it happens, letting you address the problem instead of chasing its consequence
p5264
as(dp5265
g6
V335858
p5266
stp5267
a((dp5268
g2
(lp5269
VYou are not accessing the private variable there, at least not directly: you are accessing a public property, which has legitimate access to the private ivar
p5270
aVYour code is equivalent to this:
p5271
aVThe  statement created the getter and the setter methods for you
p5272
aVIf you want only a getter to be available, mark your property , and do all writings through an ivar in the  class
p5273
as(dp5274
g6
V335858
p5275
stp5276
a((dp5277
g2
(lp5278
VThis is because you declared two separate inner-scope variables in both branches of
p5279
aVNeither of these two variables is visible outside its scope, so you are getting an error
p5280
aVYou should move the declaration out of , like this:
p5281
aVNow  is visible outside of your  statement
p5282
as(dp5283
g6
V335858
p5284
stp5285
a((dp5286
g2
(lp5287
VThis is a tricky select, but it does what you need it to do:
p5288
aVRunning this produces the following output:
p5289
as(dp5290
g6
V335858
p5291
stp5292
a((dp5293
g2
(lp5294
VThere is no mistake, this is a boolean  operator, as opposed to the  operator represented by
p5295
aVThe difference is that the regular  does not short-circuit, while  does
p5296
aVIn your specific case,  will be called even if  returns
p5297
aVIf you replace  with , this would no longer happen (i
p5298
ag630
aVwill not get called if  is )
p5299
as(dp5300
g6
V335858
p5301
stp5302
a((dp5303
g2
(lp5304
VDisable your tap recognizer in the selector that the recognizer calls
p5305
aVOverride  in the view to which you add subviews on tapping the recognizer, and re-enable it from there
p5306
aVThe recognizer will remain inactive through the time while the new subview is being added
p5307
aVIf you animate the addition, you should get a sufficient delay to avoid reacting to double-taps
p5308
as(dp5309
g6
V335858
p5310
stp5311
a((dp5312
g2
(lp5313
VSince all you do is concatenating two memory blocks, you can use :
p5314
aVIf hardware provides single-instruction copying, you may get some performance improvement from it
p5315
aVOn the other hand, optimizers can probably figure out what you're doing anyway, and replace your code with calls to  for you
p5316
as(dp5317
g6
V335858
p5318
stp5319
a((dp5320
g2
(lp5321
VThe most important thing that is wrong here is that your code is too slow: even if you fix other issues, such as using a wrong data type for your integers and trying out some divisors that are definitely not prime, iterating by one down from 10^11 will simply not finish in your computer's lifetime is extremely wasteful
p5322
aVI highly recommend that you read through the example on page 35 of this classic book, where Dijkstra takes you through the process of writing a program printing the first 1000 prime numbers
p5323
aVThis example should provide enough mathematical intuition to you to speed up your own calculations, including the part where you start your search from the square root of the number that you are trying to factor
p5324
as(dp5325
g6
V335858
p5326
stp5327
a((dp5328
g2
(lp5329
VThis is because of a circular reference between your header files
p5330
aVYou can break it by forward-declaring one of the classes inside the header of the other, like this:
p5331
as(dp5332
g6
V335858
p5333
stp5334
a((dp5335
g2
(lp5336
VC array of fixed size (2 in your case) should be perfectly acceptable in your situation
p5337
aVSince your vector does not grow dynamically, I think this should work just fine:
p5338
as(dp5339
g6
V335858
p5340
stp5341
a((dp5342
g2
(lp5343
VThe classic solutions to this problem are (1) to make  , or (2) to use an  or a functor to your class
p5344
aV(1)
p5345
aV(2)
p5346
as(dp5347
g6
V335858
p5348
stp5349
a((dp5350
g2
(lp5351
VYou can resolve additional DLLs yourself on an event the assembly fires to let you know that it cannot find a type
p5352
as(dp5353
g6
V335858
p5354
stp5355
a((dp5356
g2
(lp5357
VTo group by 3, use this LINQ query:
p5358
aVThe output of this program looks like this:
p5359
aVNote how this code uses  instead of a slower
p5360
aVOf course since you use some other objects instead of strings, you will need to replace  with
p5361
as(dp5362
g6
V335858
p5363
stp5364
a((dp5365
g2
(lp5366
VYou can use this expression to convert your strings to SQL type
p5367
aVThis expression uses the  format only when it cannot use its default  format
p5368
aVThis expression should be used inside a  statement
p5369
aVI am assuming that the name of your  column containing a date string is
p5370
as(dp5371
g6
V335858
p5372
stp5373
a((dp5374
g2
(lp5375
VNo, not really: you could use
p5376
aVThe important thing is to get a single value to "pair up" with scalars produced in the aggregation
p5377
aVAn alternative is to put these values in the key at the group by stage: if you know they would be the same, add them to the key of the group, and pull them from there during the aggregation stage
p5378
as(dp5379
g6
V335858
p5380
stp5381
a((dp5382
g2
(lp5383
VYou have  instead of , so neither of your  loops executes
p5384
aVI think the loops should be as follows:
p5385
as(dp5386
g6
V335858
p5387
stp5388
a((dp5389
g2
(lp5390
VThis code should do the same thing in all three languages: it prints all bits of a number recursively
p5391
aVLet's work through what happens when you call  on the number 5:
p5392
aVAs the result, , the binary representation of 5, is printed
p5393
as(dp5394
g6
V335858
p5395
stp5396
a((dp5397
g2
(lp5398
VYou can do this:
p5399
aVAlternatively, you can map two classes to three tables:
p5400
aVThis way, all common data will end up in the same table
p5401
aVReading would be a bit more complex, because you would need to join to the event table to get the common fields
p5402
aVAnyway, there are pluses and minuses to each alternative, the choice is up to you
p5403
as(dp5404
g6
V335858
p5405
stp5406
a((dp5407
g2
(lp5408
VThere is no way around pairwise matching: the way as efficient as it gets
p5409
aVIf you need to do your record linkage faster, try using a string distance metrics that requires less computations than the edit distance (Bonacci distance, Jaro\u2013Winkler distance, etc
p5410
aVYou could also use another metric as a preprocessing step, and then compute edit distance to confirm or deny the match
p5411
as(dp5412
g6
V335858
p5413
stp5414
a((dp5415
g2
(lp5416
VUse  as your regexp
p5417
aVUse and as your replacement string
p5418
aVI tried your example on
p5419
aVNET Regex Tester, and it produced the desired output
p5420
as(dp5421
g6
V335858
p5422
stp5423
a((dp5424
g2
(lp5425
VTry this code:
p5426
aVThe key element here is the  search option
p5427
as(dp5428
g6
V335858
p5429
stp5430
a((dp5431
g2
(lp5432
VI ran across several designs where a #4 was possible:
p5433
aVSplit your columns into searchable and auxiliary
p5434
aVDefine a table with only searchable columns, and an extra BLOB column
p5435
aVPut everything in one table: searchable columns go as-is, auxiliary go as a BLOB
p5436
aVWe used this approach with BLOBs of XML data or even binary data, representing the entire serialized object
p5437
aVThe downside is that your auxiliary columns remain non-searchable for all practical purposes
p5438
aVThe upside is that you can add new auxiliary columns at will without changing the schema
p5439
aVYou can also make schema changes to make previously auxiliary columns searchable with a schema change and a very simple program
p5440
as(dp5441
g6
V335858
p5442
stp5443
a((dp5444
g2
(lp5445
VHere is how I would re-factor this grammar to make it work:
p5446
aVThis separates long names from one-character pitch names, which get "reunited" in the parser
p5447
aVAlso the "sharp" token gets its own name, and gets recognized in the parser as an optional token
p5448
as(dp5449
g6
V335858
p5450
stp5451
a((dp5452
g2
(lp5453
VSince you have a nice integer types and bit operations in C#, you do not have to jump through the same hoops as in Excel
p5454
aVHere is how you convert the initial part :
p5455
aV, , and  are even simpler:
p5456
aVmeans "shift (binary representation) to the right";  means "shift (binary representation) to the left"
p5457
aVShifting by one is equivalent to multiplying or dividing by two in the same way that shifting a decimal number is equivalent to multiplying or int-dividing by ten
p5458
aVmeans bitwise
p5459
aV255 is a number with the last eight bits set to one; AND-ing with it keeps the last eight bits of the original number
p5460
aVEDIT : Here is a corrected version of your re-write that returns the right result:
p5461
as(dp5462
g6
V335858
p5463
stp5464
a((dp5465
g2
(lp5466
VThis should do the trick:
p5467
aVNow the dictionary  contains word-count pairs from your sentence
p5468
aVFor example,  is 3
p5469
as(dp5470
g6
V335858
p5471
stp5472
a((dp5473
g2
(lp5474
Vis the value (correct)
p5475
aVis the address of the value
p5476
aVEDIT In your case, this address is uninitialized, so it is not pointing anywhere in particular (thanks Keith Nicholas for mentioning this)
p5477
aVis the address of the [pointer that should contain the] address of the value
p5478
aV(it's worth pointing out that your program may crash :)
p5479
as(dp5480
g6
V335858
p5481
stp5482
a((dp5483
g2
(lp5484
VYou need to add  to your class declaration: otherwise, all members declared are private by default
p5485
as(dp5486
g6
V335858
p5487
stp5488
a((dp5489
g2
(lp5490
VThere is no magic:  must be somewhere in your dbml file
p5491
aVOpen that file in a text editor (if you use Visual Studio, right-click and choose "Open With
p5492
aV, then "Text Editor")
p5493
aVNow search for , and remove it from the XML
p5494
as(dp5495
g6
V335858
p5496
stp5497
a((dp5498
g2
(lp5499
VIf it does not matter which user you pick from the list of users with the same e-mail, you can do this:
p5500
aVAgain, this assumes that when e-mail addresses are the same, it does not matter which user you'd pick
p5501
as(dp5502
g6
V335858
p5503
stp5504
a((dp5505
g2
(lp5506
VYou can use regions, like this:
p5507
aVVisual Studio will display a little  next to the  line
p5508
aVClick it to hide the variables
p5509
as(dp5510
g6
V335858
p5511
stp5512
a((dp5513
g2
(lp5514
VCall  or  to get single or multiple selections
p5515
aVWhen a cell is selected, this method of your view controller gets called:
p5516
aVcontains the selected position
p5517
as(dp5518
g6
V335858
p5519
stp5520
a((dp5521
g2
(lp5522
VThis is because there is an implicit conversion operator for String to SqlString
p5523
aVIn other words, you are not dealing with a simple built-in cast: designers of SqlString decided to allow you cast strings to SqlString
p5524
aVThey didn't do it for Object, hence the error that you are seeing
p5525
as(dp5526
g6
V335858
p5527
stp5528
a((dp5529
g2
(lp5530
VYou need to add block variables, and set them from inside your blocks:
p5531
aVAt this point you can make assertions about the values of  and : if the expected one is not set, your test has failed
p5532
as(dp5533
g6
V335858
p5534
stp5535
a((dp5536
g2
(lp5537
VI think you are missing  in your  loop:
p5538
as(dp5539
g6
V335858
p5540
stp5541
a((dp5542
g2
(lp5543
VYour example illustrates the reason why compilers cannot do it: the values of , , and  are calculated, not stored
p5544
aVThe compiler knows the address of , and calculates the other two with the knowledge of the array size in hand
p5545
aVWith double pointers, on the other hand, all three pointers would need to be stored in sequential memory locations, forming an array of pointers
p5546
as(dp5547
g6
V335858
p5548
stp5549
a((dp5550
g2
(lp5551
VThe problem with your hierarchy is that your  now inherits  twice: once through , and once through
p5552
aVC++ feature called Virtual Inheritance is designed to deal with situations like that
p5553
aVNote that you need to make 's inheriting   as well
p5554
as(dp5555
g6
V335858
p5556
stp5557
a((dp5558
g2
(lp5559
VYour query mixes up unrelated things - a list of notifications, and a scalar set of counts
p5560
aVIt also ties whether or not you get any results to the requirement to have at least one notification
p5561
aVFrom a design standpoint, these two should not be mixed, so I would re-write it as two queries
p5562
aVYou should use a correlated subquery for your counts:
p5563
aVThe query for notifications is a simplified version of your original query:
p5564
as(dp5565
g6
V335858
p5566
stp5567
a((dp5568
g2
(lp5569
V\u005cuFFFF is the "character" that sorts last in the 16-bit "alphabet", i
p5570
ag630
aVafter any valid letter, character, or special symbol
p5571
aVWhen you do binary search for a string in a sorted array, you find a place where that string could be inserted
p5572
aVWhen you have multiple identical strings, you get a location ahead of the first one
p5573
aVWhen you append "the last letter of the alphabet" after your string, the insertion point will be after the last of the identical strings, hence giving you a range of identical strings in a sorted array
p5574
aVImagine this: suppose you are not allowed to use letter  in your words
p5575
aVNow you have a sorted array of strings:
p5576
aVIf you search for , binary search tells you the first place where you can insert it, which is 2
p5577
aVIf you search for , thoug, binary search would return 4, because  comes alphabetically right after
p5578
aVThis lets you know that the range between 2, inclusive, and 4, exclusive, is occupied by the string
p5579
aVIf both searches return the same number, you know that the string is not present in the array
p5580
aVIn the paragraph that you quoted,  plays the role of the "prohibited letter Z" from my example
p5581
as(dp5582
g6
V335858
p5583
stp5584
a((dp5585
g2
(lp5586
VA hack frequently used in programming competitions in the absence of leading zeros is to compare string's lengths first; if lengths are not equal, the longer string wins; otherwise, return the result of lexicographical comparing of the strings
p5587
aVEDIT : Since you care mostly about re-usability of your solution, you would get the biggest "bang for the buck" if you implement your own Comparator
p5588
aVThis would let you reuse the same implementation with standard Java classes
p5589
aVFor example, you would be able to use your comparator with sorted maps, to do array and list sorts, binary searches, and so on
p5590
as(dp5591
g6
V335858
p5592
stp5593
a((dp5594
g2
(lp5595
VIn your example, it's simply
p5596
aVMore elaborate example would require going back a few levels from the , as follows:
p5597
aVThe algorithm to make a relative path would look as follows:
p5598
aVRemove the longest common prefix (in this case, it is )
p5599
aVCount the number of folders in  (in this case, it is 2: )
p5600
aVInsert  for each remaining folder
p5601
aVConcatenate with the remainder of the absolute path after the suffix removal
p5602
aVThe end result looks like this:
p5603
as(dp5604
g6
V335858
p5605
stp5606
a((dp5607
g2
(lp5608
VTry naming the expression in your SQL, giving it an alias:
p5609
aVThen use  to retrieve the value
p5610
as(dp5611
g6
V335858
p5612
stp5613
a((dp5614
g2
(lp5615
VTry this select:
p5616
aVIt joins both tables on , and keeps only the rows where null-ness of the corresponding columns is different
p5617
aVEDIT Replaced  that causes syntax errors with a longer expression that does not compare booleans
p5618
as(dp5619
g6
V335858
p5620
stp5621
a((dp5622
g2
(lp5623
V is a Format Specifier
p5624
aVThis particular one expects a any Objective-C object, not only an
p5625
as(dp5626
g6
V335858
p5627
stp5628
a((dp5629
g2
(lp5630
VThis will skip the common prefix of two strings:
p5631
aVFor example, if you pass  and , this would return
p5632
as(dp5633
g6
V335858
p5634
stp5635
a((dp5636
g2
(lp5637
VThe  function interprets the value that you pass it according to the format specifier in a matching position
p5638
aVIf you tell  that you pass an , but pass  instead,  would re-interpret one as the other, and print the results that you see
p5639
as(dp5640
g6
V335858
p5641
stp5642
a((dp5643
g2
(lp5644
VTake a look at HashSet
p5645
aVNote that in order for objects to work with HashSet, they need to provide correct implementations of  and  methods of the  class
p5646
as(dp5647
g6
V335858
p5648
stp5649
a((dp5650
g2
(lp5651
VProtected methods are intended for sharing implementation with subclasses
p5652
aVInterfaces have nothing to offer as far as implementation sharing goes, because they have no implementation at all
p5653
aVTherefore all methods on interfaces must be public
p5654
as(dp5655
g6
V335858
p5656
stp5657
a((dp5658
g2
(lp5659
VSemicolon  is a valid statement in C (and therefore in Objective C)
p5660
aVThis statement does not do anything - it represents an empty operation
p5661
aVIn your example this statement is not necessary, but there are cases when it is important
p5662
aVFor example, copying C strings can be done as follows:
p5663
aVThe semicolon at the end is essential to the working of this construct
p5664
as(dp5665
g6
V335858
p5666
stp5667
a((dp5668
g2
(lp5669
VYou correctly identified the key issue here as letting SQL driver decide the sizes, scales, and precisions on your parameters for you
p5670
aVYour idea of reducing the number of query plans by limiting precisions / scales / sizes of parameters also sounds correct
p5671
aVFor strings, you can set the size to the largest value that you expect: it should work correctly when your query compares parameter strings with large size limits to s of smaller size
p5672
aVPicking just a few precisions for decimals also sounds right
p5673
aVSee if you can get it down to just one pair of precision/scale: it may be possible (it worked out very well for our projects at work)
p5674
aVIf you manage to do it, you'd be able to go to a single query plan per SQL query
p5675
as(dp5676
g6
V335858
p5677
stp5678
a((dp5679
g2
(lp5680
VThis is rather straightforward: you have three spots where you could either put a comma or to put nothing
p5681
aVThere are eight combinations corresponding to 2^3 binary numbers
p5682
aVFor each number from 0 to 7, inclusive, produce a binary representation
p5683
aVPut a comma in each position where binary representation has 1; do not put comma where there's zero
p5684
as(dp5685
g6
V335858
p5686
stp5687
a((dp5688
g2
(lp5689
VHex has a useful property of using two digits to a single byte
p5690
aVThis is very convenient for looking at raw memory, memory addresses, etc
p5691
aVBack in my PDP days we used octal a lot, because we could read machine code easier
p5692
aVBase-64 does not offer such nice divisibility: it's 6 bits, so it is 4 digits for 3 bytes
p5693
as(dp5694
g6
V335858
p5695
stp5696
a((dp5697
g2
(lp5698
VYou can do this:
p5699
aVAt this point,  can be assigned to an :
p5700
as(dp5701
g6
V335858
p5702
stp5703
a((dp5704
g2
(lp5705
VYou should definitely not using regexp for this problem: generally speaking, regexp is not good when you need to count anything
p5706
aVYou cannot even write a regexp to check if brackets in an expression are balanced
p5707
aVFor this problem a simple counter will be sufficient: increment on , decrement on , check for zero in the end to know the answer to your problem
p5708
as(dp5709
g6
V335858
p5710
stp5711
a((dp5712
g2
(lp5713
VYou can do certainly do it, except when you are pointing at the last element of the list: in this case,  would return , and you would see bad access as the result
p5714
as(dp5715
g6
V335858
p5716
stp5717
a((dp5718
g2
(lp5719
VFor a temporary array that stores only integers and gets thrown away after a relatively short task I would definitely prefer a C-style array: this would avoid a great deal of overhead, and is also simple to read
p5720
as(dp5721
g6
V335858
p5722
stp5723
a((dp5724
g2
(lp5725
VYou can use LINQ to flatten your 2D array:
p5726
aVor
p5727
as(dp5728
g6
V335858
p5729
stp5730
a((dp5731
g2
(lp5732
VSince 10 cannot be stored in a single character, you would either need to use two digits, or to ask the user to guess a number from 0 to 9, inclusive
p5733
aVTo make an  from a single-digit character use this code snippet:
p5734
aVThis works, because digits 0 through 9 are located next to each other in the ASCII encoding: the code for  equals the code for  plus one; the code for  equals the code for  plus two, and so on
p5735
aVTherefore, when you subtract the code of  (which is denoted as  in C) from a single-digit character, you get the integer value of the corresponding digit
p5736
as(dp5737
g6
V335858
p5738
stp5739
a((dp5740
g2
(lp5741
VThat's right, it is exactly what's supposed to happen (nothing), because  is not the right place from which you do drawing in iOS
p5742
aVYou need to implement a different method:
p5743
aVThis method of your  implementation gets called to do the drawing
p5744
aVTrying to draw on the screen from about anywhere else is not going to produce the desired results
p5745
as(dp5746
g6
V335858
p5747
stp5748
a((dp5749
g2
(lp5750
VThis happens because your staging table contains multiple rows with the same value of primKey
p5751
aVIf it does not matter to you which  pair among the duplicated ones makes it into the insert, you can bypass the issue entirely by adding a simple , like this:
p5752
as(dp5753
g6
V335858
p5754
stp5755
a((dp5756
g2
(lp5757
VFirst, you need to tell C# that  implements
p5758
aVNow you can compare individual items, like this:
p5759
as(dp5760
g6
V335858
p5761
stp5762
a((dp5763
g2
(lp5764
VYou are overflowing stack, because n++ post-increments the value, making a recursive call with the same values as in the current invocation
p5765
as(dp5766
g6
V335858
p5767
stp5768
a((dp5769
g2
(lp5770
VImplement  method in your data shource to update the model on the end of the drag operation
p5771
aVImplement  to return  for the rows that the user should be able to move
p5772
aVHere is a short tutorial on the subject
p5773
as(dp5774
g6
V335858
p5775
stp5776
a((dp5777
g2
(lp5778
VFeel free to fix the comment in Wikipedia: the output should indeed be
p5779
aVThe other part is correct, though: the code where a  is called even after the  reference has been statically cast to a reference to its superclass is indeed a demonstration of how overriding of a virtual method works in C++
p5780
aVAnother way to demonstrate the same point is through use of a pointer instead of a reference:
p5781
as(dp5782
g6
V335858
p5783
stp5784
a((dp5785
g2
(lp5786
VFind the position of the  character, then get a substring 0 through that position
p5787
aVNote that  does not include the character at the index position
p5788
as(dp5789
g6
V335858
p5790
stp5791
a((dp5792
g2
(lp5793
VYou can use this answer to convert your string to a byte array, and insert the result into a  column
p5794
aVThe idea is to use  with a  to serialize the string, harvest the resulting byte array from the memory stream, and write it into a  column
p5795
as(dp5796
g6
V335858
p5797
stp5798
a((dp5799
g2
(lp5800
VI think the problem is that you misunderstood the semantics of the  call: it does not create an array list of  elements; rather, it creates an  with the initial capacity enough to hold at least  elements
p5801
aVI am not sure what kind of elements you are planning to add to your ArrayList of ArrayLists, but here is one way to test your code that creates a two-dimensional ArrayList:
p5802
as(dp5803
g6
V335858
p5804
stp5805
a((dp5806
g2
(lp5807
VYou see the difference between PHP and Java because PHP's  understands negative numbers, but Java's  does not: it throws an exception
p5808
aVIn PHP, passing negative 1 to  means "get me the last character", but in Java you need to pass the index of the last character (i
p5809
ag630
aV) to achieve the same effect
p5810
aVIf this is not a mistake, and this is precisely the effect that you wanted to achieve, you can address this issue with an  condition:
p5811
aVEDIT As Thomas correctly pointed out, the other difference between PHP version of  and Java's  is in their treatment of the second argument: PHP thinks it's length; Java thinks it's the index of the last character plus one
p5812
as(dp5813
g6
V335858
p5814
stp5815
a((dp5816
g2
(lp5817
VThe most direct way to build your query is by adding a correlated subquery: your SQL reads almost like English:
p5818
as(dp5819
g6
V335858
p5820
stp5821
a((dp5822
g2
(lp5823
VUsing reflection is required when your program does not have a compile-time access to the class, for example, when the class is provided in a library at run-time, and the name of the class and the path to the library are provided to your program as part of configuration
p5824
aVIndependently developed plug-ins for your program are good candidates for reflection-based instantiation
p5825
aVReflection-based instantiation may be desirable in other cases as well: for example, when you know which classes you want, but you do not know ahead of time in what way you want them to be connected
p5826
aVConstructing expression trees is an example of this situation
p5827
as(dp5828
g6
V335858
p5829
stp5830
a((dp5831
g2
(lp5832
VYou can do the additions on the SQL Server side, and then simply fetch the result in your C# code using :
p5833
aVThis assumes that you have an open connection  that points to the right server
p5834
as(dp5835
g6
V335858
p5836
stp5837
a((dp5838
g2
(lp5839
VCocoa provides  class for that purpose:
p5840
aVThis creates an object that you can add to :
p5841
aVYou can use  to access a  representing the address of the structure that you put in
p5842
as(dp5843
g6
V335858
p5844
stp5845
a((dp5846
g2
(lp5847
VYou do not need regex for something that simple:  works faster, and is easier to understand:
p5848
aVIf you insist on using regex, you can do this:
p5849
as(dp5850
g6
V335858
p5851
stp5852
a((dp5853
g2
(lp5854
VFirst, it looks like you can move the last two lines
p5855
aVoutside of the , because they do the same thing in all six cases
p5856
aVNext, since it looks like your code assigns Val(0) to the item with the smallest key,  to the value in the middle, and  to the largest one, you can put , , and  in an array of keys, , , and  into an array of values, and sort them, like this:
p5857
as(dp5858
g6
V335858
p5859
stp5860
a((dp5861
g2
(lp5862
VIf performance is most important to you, then using a separate object is likely to be a better solution: you will save on formatting a date as a string every time you are preparing a lookup key
p5863
aVIn addition, having a multipart key is easier to extend, should you decide to add more parts to the key: it is much easier to overlook a missing element of a concatenation than a missing parameter of a constructor
p5864
as(dp5865
g6
V335858
p5866
stp5867
a((dp5868
g2
(lp5869
VHere is one approach: take each count, shift it left by five, and bitwise-or the number of the letter in the lower five bits
p5870
aVSort the resulting numbers, and convert their least-significant five bits back to the letter by and-ing with  and adding
p5871
as(dp5872
g6
V335858
p5873
stp5874
a((dp5875
g2
(lp5876
VJava compiler sees that you have declared your variables as  (making them constants, rather than variables), computes  at compile time, and internalizes the result
p5877
as(dp5878
g6
V335858
p5879
stp5880
a((dp5881
g2
(lp5882
VIn order to test waiting and notifications, you need multiple threads
p5883
aVOtherwise, the waiting thread will block, and never get to the notifying code, because it is on the same thread
p5884
ag1971
ag1972
aVImplementing connection pools is not an easy undertaking
p5885
aVI would not even bother, since you can use ready-made ones
p5886
as(dp5887
g6
V335858
p5888
stp5889
a((dp5890
g2
(lp5891
VWhat you see is correct:  retains objects added to it, so  remains live even though your code has released its reference to it
p5892
aVThe second reference (from inside ) is what holds your inner array formerly known as  from being released
p5893
aVThere is no copying involved
p5894
as(dp5895
g6
V335858
p5896
stp5897
a((dp5898
g2
(lp5899
VApproximate equality is defined in terms of the absolute difference: if an absolute difference does not exceed a certain, presumably small, number, then you can say that the values you are comparing are "close enough"
p5900
aVYou must be very careful to not confuse "close enough" end "equals", because the two are fundamentally different: equality is transitive (i
p5901
ag630
aVa==b and b==c together imply that a==c), while "close enough" is not transitive
p5902
as(dp5903
g6
V335858
p5904
stp5905
a((dp5906
g2
(lp5907
VThe  function from the C library is an incredibly dull piece of code: you can translate it to Java in five minutes or less
p5908
aVIf you must avoid writing your own, you could use the  constructor to make Java string bypassing , and parse it to complete the conversion
p5909
as(dp5910
g6
V335858
p5911
stp5912
a((dp5913
g2
(lp5914
V captures properties using JavaBean conventions
p5915
aVIt works by cloning the object graph and recording the steps that were necessary to create the clone
p5916
aVA class that you would like to use with XmlEncoder without any customizations needs to follow JavaBeans conventions ( for properties or  for boolean properties, etc
p5917
aVMy guess is that the only property available like that in your class is , hence it's the only one being serialized
p5918
aVThe article at the link also explains how you can customize the process by providing your own persistence delegate, but I would try adding getters/setters first to see if that is enough to make it work
p5919
as(dp5920
g6
V335858
p5921
stp5922
a((dp5923
g2
(lp5924
VThis is because int
p5925
aVParse throws NumberFormatException if the string does not contain a parsable integer;  is not a prasable integer
p5926
as(dp5927
g6
V335858
p5928
stp5929
a((dp5930
g2
(lp5931
VIn iOS applications the model data is often kept in a singleton, rather than in a global variable
p5932
aVHere is an article briefly describing singletons in Objective-C
p5933
aVYou can load your data in the class method that initializes your shared singleton
p5934
aVUploading the data back is a bit trickier, because the singleton itself does not know when to do it
p5935
aVTherefore you should make an instance method  in your singleton class, and call that method when your application is about to close
p5936
aVmethod of your application delegate is a good place to initiate the upload
p5937
as(dp5938
g6
V335858
p5939
stp5940
a((dp5941
g2
(lp5942
VYou can do it with a simple loop:
p5943
as(dp5944
g6
V335858
p5945
stp5946
a((dp5947
g2
(lp5948
VThis is because there are no stack arrays in Java
p5949
aVHere is Java equivalent:
p5950
aVIt looks a lot like allocating dynamically-sized arrays in C++
p5951
aVOf course you don't have to worry about calling a , because it's garbage collected
p5952
as(dp5953
g6
V335858
p5954
stp5955
a((dp5956
g2
(lp5957
VThis is an example of template metaprogramming
p5958
aVThis program calculates factorial at compile time using recursion
p5959
aVThe base of recursion is here:
p5960
aVIt says that factorial of 1 is 1
p5961
aVThe other template simply says that factorial of a number is that number times factorial minus 1
p5962
aVSince there is really no "calling" in the classic sense, the template instantiates itself with a template argument equal to  calculated at compile time
p5963
ag1971
ag1972
aVThe warning shows that factorial of 34 overflows 32-bit integer
p5964
as(dp5965
g6
V335858
p5966
stp5967
a((dp5968
g2
(lp5969
VWhen your program knows about the structure of your table at compile-time or through configuration, using  is not a good idea: any change in the structure of your table could break the structure of the results coming back from the query, ultimately causing run-time errors
p5970
aVHowever, there are cases when  is indispensable
p5971
aVSpecifically, if your program "learns" dynamically of the structure of your tables by reading metadata coming back from a query, using the "all columns" request lets your program pick up changes to your tables dynamically
p5972
aVIt goes without saying that using  for ad-hoc queries in your favorite flavor of SQL Studio/SQLPlus/etc
p5973
aVis very common and convenient
p5974
as(dp5975
g6
V335858
p5976
stp5977
a((dp5978
g2
(lp5979
VNo, base-64 encoding uses a whole byte to represent six bits of the data being encoded
p5980
aVThe lost two bits is the price of using only alphanumeric, plus and slash as your symbols (basically, excluding the numbers representing not visible or special characters in plain ASCII/UTF-8 encoding)
p5981
aVThe result that you are getting is (64*4/3) rounded up to the nearest 4-byte boundary
p5982
as(dp5983
g6
V335858
p5984
stp5985
a((dp5986
g2
(lp5987
VThe best way to deal with plug-ins is to "sandbox" each one of them in an individual app domain
p5988
aVThis way you can safely react to their execution errors, unload them if you need to, and manage them in whatever ways you like
p5989
aVBut most importantly for this question, you can monitor their loading of assemblies using this event hook
p5990
aVIf you see them loading a DLL that you do not want to allow, you can simply throw an exception
p5991
aVYour code would catch the exception, clean up the app domain, and optionally send the clients a warning for trying to do something that is not allowed
p5992
aVThe only downside to this approach is that it is rather non-trivial to implement
p5993
as(dp5994
g6
V335858
p5995
stp5996
a((dp5997
g2
(lp5998
VThis line has an off by one mistake:
p5999
aVis not the last character of the string, it's the  character
p6000
aVAlso you are returning a stack variable - this is not going to work
p6001
aVYou should reverse the string in place:
p6002
aVYou can then return
p6003
as(dp6004
g6
V335858
p6005
stp6006
a((dp6007
g2
(lp6008
VThe best-performant solution would be to write HEX yourself
p6009
aVThis is not a difficult task if you use a lookup table:
p6010
as(dp6011
g6
V335858
p6012
stp6013
a((dp6014
g2
(lp6015
VAssuming that the  has fields  and , and that you also have a function called , you can do your select as follows:
p6016
aVIf you do not want to "break out" the individual fields of the product, you can bring it through the anonymous type in its entirety:
p6017
aVYou would access product fields as , not as  from the first example
p6018
as(dp6019
g6
V335858
p6020
stp6021
a((dp6022
g2
(lp6023
VYou can use Regex
p6024
aVSplit(string s, string pattern) method
p6025
aVThe pattern you need is
p6026
as(dp6027
g6
V335858
p6028
stp6029
a((dp6030
g2
(lp6031
VYour function that replaces sequences of spaces with a single space can be re-written in a single line:
p6032
aVIf you would like to make it an extension method, you can do it like this:
p6033
as(dp6034
g6
V335858
p6035
stp6036
a((dp6037
g2
(lp6038
VThere are two interpretations of escape sequences going on: first by the Java compiler, and then by the regexp engine
p6039
aVWhen Java compiler sees two slashes, it replaces them with a single slash
p6040
aVWhen there is  following a slash, Java replaces it with a tab; when there is a  following a double-slash, Java leaves it alone
p6041
aVHowever, because two slashes have been replaced by a single slash, regexp engine sees , and interprets it as a tab
p6042
aVI think that it is cleaner to let the regexp interpret  as a tab (i
p6043
ag630
aVwrite  in Java) because it lets you see the expression in its intended form during debugging, logging, etc
p6044
aVIf you convert  with  to string, you will see a tab character in the middle of your regular expression, and may confuse it for other whitespace
p6045
aVPatterns with  do not have this problem: they will show you a  with a single slash, telling you exactly the kind of whitespace that they match
p6046
as(dp6047
g6
V335858
p6048
stp6049
a((dp6050
g2
(lp6051
VThis is not what the tutorial asks you to do
p6052
aVI think they want you to literally replace  with ,  with , and  with , like this:
p6053
aVThis will lead you to understanding of bitwise operations on integers  and
p6054
as(dp6055
g6
V335858
p6056
stp6057
a((dp6058
g2
(lp6059
VIf your ranges are consecutive, as in your example (i
p6060
ag630
aVthere are no gaps), you can store their endpoints in an array, like this:
p6061
aVNote that the endpoints are sorted
p6062
aVYou can now use a binary search method to find the insertion point of 44 in this array, which is 3, will be returned (binary search will return bitwise complement of 3; you'd need to apply  to get the actual value)
p6063
as(dp6064
g6
V335858
p6065
stp6066
a((dp6067
g2
(lp6068
VThere are several ways of doing it
p6069
aVOne of the simpler ones would be to use  and  combination:
p6070
as(dp6071
g6
V335858
p6072
stp6073
a((dp6074
g2
(lp6075
VThe primary concern is that regexp is fundamentally the wrong tool for processing XML files
p6076
aVIt is far too easy to trick regexp into returning wrong results to you, for example by adding a  section
p6077
aVThe speed is by far the secondary concern: it is impossible to even tell if XML is well-formed with a regex, let alone processing corner cases correctly
p6078
aVNow to answer your question, the speed depends a lot on the structure of your regular expression
p6079
aVIt is possible to construct a file/regexp combination where regexp would be faster, and another pair of file/regexp where the LINQ2XML route would be faster
p6080
aVBut LINQ2XML would still be reasonably fast, and it will most likely be more correct
p6081
as(dp6082
g6
V335858
p6083
stp6084
a((dp6085
g2
(lp6086
VFirst, you need to add some space to  in order to fit the content of  in , otherwise you'll be writing past the allocated area
p6087
aVSecond, you are not passing  to , because you enclosed  in double quotes
p6088
as(dp6089
g6
V335858
p6090
stp6091
a((dp6092
g2
(lp6093
VAssigning to loop variables inside  loop is not allowed
p6094
aVYou need a regular  loop with a counter, or you can try something slightly fancier:
p6095
as(dp6096
g6
V335858
p6097
stp6098
a((dp6099
g2
(lp6100
VArithmetic shift of a signed value sign-extends the operand
p6101
aVIf you switch the type of your temporary variables to , your solution would avoid this problem
p6102
as(dp6103
g6
V335858
p6104
stp6105
a((dp6106
g2
(lp6107
VYes, there is: I ran a quick experiment, and it looks like the string version is about 3 times slower
p6108
ag1340
aV466s vs 4
p6109
aV583s
p6110
aVThis is not surprising, because the overload with strings needs an extra loop to go through all characters of the
p6111
aVThis loop runs exactly one time, but the overhead is still there
p6112
as(dp6113
g6
V335858
p6114
stp6115
a((dp6116
g2
(lp6117
VThis is because the call returns a  object, and it is not
p6118
aVYou need to check the  property:
p6119
as(dp6120
g6
V335858
p6121
stp6122
a((dp6123
g2
(lp6124
VYou can use  method to search the array in reverse for an object that passes a test using a block, and then delete the object at the resulting position:
p6125
as(dp6126
g6
V335858
p6127
stp6128
a((dp6129
g2
(lp6130
VYou need to add , otherwise you get NPE
p6131
aVWhen you create an array in Java, JVM allocates space for  references to your objects, but not for the objects themselves
p6132
aVYou need to allocate these one by one using the  operator
p6133
as(dp6134
g6
V335858
p6135
stp6136
a((dp6137
g2
(lp6138
VYou can try this:
p6139
aVHowever, this returns the number of bytes in the file, not the number of characters
p6140
aVIt is not the same unless the encoding is known to be one byte per character (e
p6141
ag303
aVASCII)
p6142
aVYou'd need to "rewind" the file back to the beginning after you've learned the size:
p6143
as(dp6144
g6
V335858
p6145
stp6146
a((dp6147
g2
(lp6148
VThis is because you declared the function as taking a pointer to boolean, not a boolean
p6149
aVThis is how the declaration should look:
p6150
aVaccompanies id types (i
p6151
ag630
aVthe ones you define through )
p6152
aVRegular C types, enums, structs, etc
p6153
aVdo not need a  in the declaration, unless you actually want to pass a pointer
p6154
as(dp6155
g6
V335858
p6156
stp6157
a((dp6158
g2
(lp6159
VYou do not need an extra level of indirection with , because you are not passing an expression in your example: you are passing a simple
p6160
aVThis should work for you:
p6161
as(dp6162
g6
V335858
p6163
stp6164
a((dp6165
g2
(lp6166
VIf you store digits backwards, your arrays will be much easier to manipulate, because their ones, tens, hundreds, etc
p6167
aVwill be aligned with each other (i
p6168
ag630
aVthey will be sitting at the same index)
p6169
aVYou could then implement the addition the same way they teach in the elementary school: go through arrays of digits one by one, add them, check for digit overflow (), and pay attention to the carry flag (result digit is , carry flag is )
p6170
aVIf the carry flag is not zero when you are done with the addition, and there are no additional digits remaining on either side, add the carry flag to the end of the result array
p6171
aVThe only remaining issue is displaying the lists
p6172
aVYou can do it with a simple backward loop
p6173
ag1971
ag1972
aVIf you would like to double-check your mulch-trilion calculation against something that is known to work, use  to compute the expected results, and check your results against theirs
p6174
as(dp6175
g6
V335858
p6176
stp6177
a((dp6178
g2
(lp6179
VThe return type should be  or , not :
p6180
aVOther than that, you are fine
p6181
as(dp6182
g6
V335858
p6183
stp6184
a((dp6185
g2
(lp6186
VMake a class method returning that constant, like this:
p6187
as(dp6188
g6
V335858
p6189
stp6190
a((dp6191
g2
(lp6192
VSince the actual type  is available to you only through reflection, you would need to access methods of  through reflection as well:
p6193
aVEDIT You could also define an additional  interface that does not use generics, and uses  instead:
p6194
aVYour  would remain generic, but you would get access to its  by casting to :
p6195
as(dp6196
g6
V335858
p6197
stp6198
a((dp6199
g2
(lp6200
VThis is because by convention  does not point to a valid location in the container: it sits at a location one past the end of the container, so dereferencint it is illegal
p6201
aVThe situation with  is different: you can dereference it when  (i
p6202
ag630
aVwhen the container is not empty):
p6203
aVIf you need to access the last element, you can do this:
p6204
aVAgain, this works only when your vector contains at least one element
p6205
as(dp6206
g6
V335858
p6207
stp6208
a((dp6209
g2
(lp6210
VAdd a  to your singleton class, and call it from your  implementation:
p6211
aVThe implementation iside the  could use the same clean pattern of looking up day array, then the lesson inside its day, and then deleting the requested item:
p6212
as(dp6213
g6
V335858
p6214
stp6215
a((dp6216
g2
(lp6217
VAs far as I know, this is not doable: you must implement the operator overload in the type that uses it
p6218
aVSince  is not your type, you cannot override operators in it
p6219
aVHowever, you can derive your own type from , and override the operator inside your class
p6220
as(dp6221
g6
V335858
p6222
stp6223
a((dp6224
g2
(lp6225
VYou should make result the type , and return it back to the caller
p6226
aVThe caller could then compare it to , and then quickly convert back to digit if it's not -1 by adding :
p6227
aVAs a side note, you can replace your switch with a lookup in a long string of characters:
p6228
as(dp6229
g6
V335858
p6230
stp6231
a((dp6232
g2
(lp6233
VDefine named constants for these literals, and use comments to explain what the number represents
p6234
as(dp6235
g6
V335858
p6236
stp6237
a((dp6238
g2
(lp6239
VYou are right, you cannot do it when all you need is to store a single bit: you must save at least a byte
p6240
aVHowever, if you have multiple items with each one taking less than a byte, you can pack multiple items together in a single byte
p6241
aVUsing 4-bit doors as an example, suppose that you want to store information about two doors
p6242
aVYou need eight bits for that, and that's a single byte
p6243
aVYou can save the first door in the lower four bits, and the second door in the upper four bits
p6244
aVWhen you need to get the state of the first door, mask away the second one by applying  operation: it strips off the higher part of the byte
p6245
aVWhen you need the second door, shift its bits into position using the shift left: : it moves the upper four bits into the upper four bits, and clears off the ones in the upper half of the byte in case your value gets sigh-extended
p6246
aVFinally, in C you have another option: you can use bit fields
p6247
aVThis may be useful when you would like to pack elements of arbitrary length into a few words to save space
p6248
aVNote that this technique should be applied with care, when the savings are relatively high, or the memory is too scarse (e
p6249
ag303
aVyou are writing embedded code for an 8-bit microcontroller)
p6250
as(dp6251
g6
V335858
p6252
stp6253
a((dp6254
g2
(lp6255
VIn Objective C,  means , akin to  in C/C++
p6256
aVYou can return  for from a function returning  to indicate that you do not want to return anything in particular
p6257
as(dp6258
g6
V335858
p6259
stp6260
a((dp6261
g2
(lp6262
VYou are almost there: you should change the meaning of the  variable to the remaining number of matches, rather than the original number requested
p6263
aVThen you can rewrite the method without keeping an additional count at all, as follows:
p6264
as(dp6265
g6
V335858
p6266
stp6267
a((dp6268
g2
(lp6269
VIf you change your string slightly to match the format of your input exactly, it works fine
p6270
aVAll you need to do is removing spaces and the comma from the string, like this:
p6271
aVWith this string I get the result below:
p6272
aVIt is , not , because my time zone is four hours behind GMT
p6273
as(dp6274
g6
V335858
p6275
stp6276
a((dp6277
g2
(lp6278
VYou see an endless loop because your p is of an integral type (e
p6279
ag303
aVan )
p6280
aVNo matter how many times you add  to an int, it would remain 0, because  truncates double/fp values assigned to it
p6281
aVIn other words, it is equivalent to a loop where you add zero on each step
p6282
aVIf you make  a  or a , your problem would go away
p6283
aVEDIT (Suggested by Oli Charlesworth's comment)
p6284
aVIt is worth noting that using floats and doubles to control loops is discouraged, because the results are not always as clean as in your example
p6285
aVChanging the step from  (which is 2 to the negative power of 1) to  (which is not an integral negative power of 2) would change the results that you see in a rather unexpected way
p6286
aVIf you need to iterate by a non-integer step, you should consider using this simple pattern:
p6287
as(dp6288
g6
V335858
p6289
stp6290
a((dp6291
g2
(lp6292
VYou can use  method, like this:
p6293
aVYou can use a different separator instead of
p6294
as(dp6295
g6
V335858
p6296
stp6297
a((dp6298
g2
(lp6299
VYou do not know where the middle is until you scan the whole line
p6300
aVBut you can scan the entire line, and then print only the second half, like this:
p6301
aVThis is how the above code works:  determines the length of the entire string (21), then we divide it in half using integer division (10), add it to the pointer to the beginning of the line, and pass the result to
p6302
as(dp6303
g6
V335858
p6304
stp6305
a((dp6306
g2
(lp6307
VUsing number one in production code should be out of the question, because having public fields is a sure sign of poor use of encapsulation
p6308
aVThe numbers two and three are similar, with one important difference: if you plan to serialize your class, you should prefer #3, because you have tighter control over the variables that you can serialize
p6309
aVOther than that, #2 and #3 are identical
p6310
aVI always start with #2, and go for #3 only when necessary
p6311
as(dp6312
g6
V335858
p6313
stp6314
a((dp6315
g2
(lp6316
VYou are right, there is such technique
p6317
aVEach winning pattern starts at the upper edge or at the left edge, and continues for three steps
p6318
aVIn each of these steps, one of the following happens:
p6319
aVRow number gets incremented, and column stays the same
p6320
aVColumn number gets incremented, and row stays the same
p6321
aVBoth row and column number gets incremented (first diagonal)
p6322
aVRow number gets incremented, and column number gets decremented (the other diagonal)
p6323
aVSo now you can write a function like this:
p6324
aVUsing this function, you can check if a player has three in a row starting at (r,c), with the step dr rows and dc columns:
p6325
as(dp6326
g6
V335858
p6327
stp6328
a((dp6329
g2
(lp6330
VThis is probably a historical thing, due most probably to the way the scan lines are ordered in a television raster (left to right, top to bottom)
p6331
as(dp6332
g6
V335858
p6333
stp6334
a((dp6335
g2
(lp6336
VHex-Bin conversion is easy, because each hex digit is four bit long
p6337
aVMemorize this table, and you'll be able to do conversion in your head very easily:
p6338
aVJust replace each hex digit with its corresponding four bits, and you'll get the first part of your answer
p6339
aVNow for the GB: K means 10 binary zeros, M means 20 binary zeros, G means 30 binary zeros
p6340
aVAdd zeros to the end of your HEX-converted-to-BIN number to get your final answer
p6341
as(dp6342
g6
V335858
p6343
stp6344
a((dp6345
g2
(lp6346
VThe value returned by  could potentially be different for each non-empty subset of your set
p6347
aVAdditionally, each string may belong to multiple "groups", depending on what other items are there in a group: for example, if the original list contained some  items, the  items could have been grouped with  items as well
p6348
aVIf you redefine the requirement as grouping by the longest common prefix, you could compute pairwise common prefixes, get the longest one, and group by it, like this:
p6349
as(dp6350
g6
V335858
p6351
stp6352
a((dp6353
g2
(lp6354
VIf I get your meaning correctly, you are looking for the  to become an alias for
p6355
aVAll you need to do is assign  to :
p6356
aVNow calling  would add elements to
p6357
aVHowever,  is not a copy of : it is only another name for
p6358
aVIf you create a copy, it would be completely independent of the original
p6359
aVIn particular, adding elements to a copy would not change the content of the original in any way
p6360
as(dp6361
g6
V335858
p6362
stp6363
a((dp6364
g2
(lp6365
VThis is done totally on purpose: the reason for that is to make it impossible to guess a password using a dictionary attack
p6366
aVFast turn-around is crucial for a dictionary attack
p6367
aVSlowing down on incorrect passwords is a way to slow the attack to a crawl, making it impossible to execute in a meaningful time interval
p6368
as(dp6369
g6
V335858
p6370
stp6371
a((dp6372
g2
(lp6373
VThis is because you are ignoring the return value of your recursive invocation:
p6374
as(dp6375
g6
V335858
p6376
stp6377
a((dp6378
g2
(lp6379
VYou are not printing your grid, you are printing dots and new line symbols
p6380
aVI am assuming that this is homework, so I am not writing any code for you, just hints of what to do:
p6381
aVGo through your array with two nested loops, and set its content to all dots
p6382
aVSet  to
p6383
aVSet  to
p6384
aVGo through your array with two nested loops, and print the character at
p6385
aVCall  after each line (it is not necessary to pass it an empty string)
p6386
aVOnce this base version is working, you can work on optimizing it
p6387
aVFor example, you could switch to printing  in a single loop instead of using two nested loops
p6388
aVBut that would be "points for style": first of all, you need to get the most basic thing work
p6389
as(dp6390
g6
V335858
p6391
stp6392
a((dp6393
g2
(lp6394
VThere is a way to do it in two steps: first, go through the original set, and make a set of action items
p6395
aVThen go through the set of action items, and apply them to the original set
p6396
aVAn action item is a base class with subclasses
p6397
aVEach subclass takes in a set, and performs a specific operation on it, for example:
p6398
aVNow you can create a collection of s in the first pass, and run them in the second pass
p6399
as(dp6400
g6
V335858
p6401
stp6402
a((dp6403
g2
(lp6404
VYour code does not really work: I ran it in a loop 100,000 times, and it failed once on my 8-core computer, producing this output:
p6405
aVI shortened the runs to make the error appear faster
p6406
aVHere are my modifications:
p6407
aVThis is not a coincidence, considering the lack of synchronization around the reading and writing of a shared variable
p6408
as(dp6409
g6
V335858
p6410
stp6411
a((dp6412
g2
(lp6413
VYou need to "rewind" back to  on finding the duplicate, so that you start searching for duplicates again:
p6414
aVYour original method would fail if you start with this array
p6415
aVthen generate 3, check it against 8 and 7, find duplicate 3, and generate 8 as a replacement
p6416
aVAt this point, your algorithm would check 8 against 1, and be satisfied that there's no duplicate; this would be incorrect
p6417
as(dp6418
g6
V335858
p6419
stp6420
a((dp6421
g2
(lp6422
VYou can use  to do the trick
p6423
aVNote that this is only a sample
p6424
aVYou should strongly consider rewriting this using , because  is not re-entrant
p6425
as(dp6426
g6
V335858
p6427
stp6428
a((dp6429
g2
(lp6430
VWhen you perform a left outer join and there is no record in ,  will be null
p6431
aVWhile you're at it, you might as well switch to the standard syntax for joins:
p6432
aVHowever, the old syntax should also work:
p6433
as(dp6434
g6
V335858
p6435
stp6436
a((dp6437
g2
(lp6438
VStart by observing that  is the product of all numbers from 21 to 500, inclusive and  Next, observe that you can perform modulo multiplication item by item, taking  at the end of each operation
p6439
aVYou should be able to write your program now
p6440
aVBe careful not to overflow the number: 32 bits may not be enough
p6441
as(dp6442
g6
V335858
p6443
stp6444
a((dp6445
g2
(lp6446
VYou can create ten separate arrays of 2000 for each member of , and use Flyweight Pattern
p6447
aVIn this implementation, each GLParticle would be passed its index into the 's arrays, along with an instance of  that contains the arrays
p6448
aVThis is slightly more cumbersome, but this is the first pattern to try when having lots of fine-grained objects becomes too expensive in terms of the CPU cycles
p6449
as(dp6450
g6
V335858
p6451
stp6452
a((dp6453
g2
(lp6454
VIdeally, you should have a separate suite of tests that pins down your localization
p6455
aVAs far as testing for the current culture goes, my first choice would be to force your specific locale onto the test execution environment, rather than relying on the default provided by the operating system
p6456
aVIf this is not possible, I would parameterize my unit tests by the current locale, in a way similar to how you handle localization in the main system, and read the expected values from that localizable storage
p6457
aVThe important point is that switching the settings on the host computer should not be enough to bring down your unit test suite
p6458
as(dp6459
g6
V335858
p6460
stp6461
a((dp6462
g2
(lp6463
VI discovered a nice trick that you can play on your temporal tables: add a special column that I call continuity ID for lack of a better term
p6464
aVThis column is equal to the primary key of the record that opens a group of related records representing the same item or action that you are modeling - in your case, a deployment
p6465
aVLet's say the primary keys of the three rows in your example 1, 2, and 3
p6466
aVThen the continuity ID of the first record would be 1; the continuity IDs of the other two records would be 2, because they represent the same deployment, and the first record that belongs to the deployment they represent has the primary key of 2
p6467
aVWith the continuity ID column in place, you can put additional fields into your temporal table, and be able to answer questions about what happened to your deployment relatively easily: given an ID of one of the records in the group (say, the most recent) you can easily query for the beginning and end dates, for the history of the item over time, for a state of the item as of a particular time, et cetera
p6468
as(dp6469
g6
V335858
p6470
stp6471
a((dp6472
g2
(lp6473
VIn C arrays are tied to pointers
p6474
aVArray index is a number that you add to the pointer to the array's initial element
p6475
aVThis is tied to one of the addressing modes of PDP-11, where you could specify a base address, and place an offset to it in a register to simulate an array
p6476
aVBy the way, this is the same place from which  and  came from: PDP-11 provided so-called auto-increment and auto-decrement addressing modes
p6477
ag1971
ag1972
aVI think Pascal used  by default; generally, you were allowed to specify the range of your array explicitly, so you could start it at -10 and end at +20 if you wanted
p6478
as(dp6479
g6
V335858
p6480
stp6481
a((dp6482
g2
(lp6483
VYou cannot do it with , but you can do it with :
p6484
aVThe  operator is intended for checking class hierarchy all the way, down to the , including the checks for all interfaces
p6485
aVIt lets you know if an instance of the object you have can be cast to the type you specified without triggering class cast exception
p6486
aV, on the other hand, returns the specific class of the given object
p6487
as(dp6488
g6
V335858
p6489
stp6490
a((dp6491
g2
(lp6492
VThe absolutely simplest way is to use four nested loops:
p6493
aVThis does not scale well, because adding extra characters requires adding a level of nesting
p6494
aVRecursive approach is more flexible, but it is harder to understand:
p6495
aVCall recursive method like this:
p6496
as(dp6497
g6
V335858
p6498
stp6499
a((dp6500
g2
(lp6501
VDid you try passing a quoted string to the
p6502
aVYou should be able to do that by properly escaping the quotes:
p6503
as(dp6504
g6
V335858
p6505
stp6506
a((dp6507
g2
(lp6508
VStart by finding the longest common subsequence
p6509
aVThis will identify the elements that will not move:
p6510
aVElements of the LCS are enclosed in parentheses
p6511
aVGo through both sequences from index 0, recording the operations required to make the sequences identical
p6512
aVIf the current item of the first sequence is not part of the LCS, remove it, and mark the place where it has been before, in case you need to insert it at a later time
p6513
aVIf the current element is part of the LCS, insert the element from the second sequence in front of it
p6514
aVThis could be either a simple insertion, or a move
p6515
aVIf the item that you are inserting is in the original list, make it a move; otherwise, make it an insert
p6516
aVHere is a demo using your example
p6517
aVCurly braces show the current element
p6518
aVis a member of LCS, so we must insert
p6519
aVis in the original sequence, so we record a move:
p6520
aVItems are the same, so we move on to the next one:
p6521
aVAgain the numbers are the same - move to the next one:
p6522
aVis a member of LCS, so we must insert
p6523
aVThe original element does not have , so it's a simple insertion:
p6524
aVYet again the numbers are the same - move to the next one:
p6525
aV4' is not a member of LCS, so it gets deleted:
p6526
aVWe reached the end of the first sequence - we simply add the remaining items of the second sequence to the first one, paying attention to the list of prior deletions
p6527
aVFor example, if  had been removed earlier, we would transform that deletion into a move at this time
p6528
aVBut since the original list did not have , we record our final operation:
p6529
as(dp6530
g6
V335858
p6531
stp6532
a((dp6533
g2
(lp6534
VYou can define a dictionary of the assemblies from your directory, like this:
p6535
aVLoad this dictionary with the assemblies from your known directory, like this:
p6536
aVProvide an implementation for the hook
p6537
aVand hook it up to the event:
p6538
aVThis should do the trick
p6539
as(dp6540
g6
V335858
p6541
stp6542
a((dp6543
g2
(lp6544
VThis is acceptable only when you type your query by hand into an interactive DB tool
p6545
aVWhen your SQL statement is executed by your program, you cannot be absolutely confident about the order of columns in a table, unless you are the only developer who has access to your database
p6546
aVIn other words, in any team environment there is an opportunity that someone would break your query simply by re-ordering columns in your database
p6547
aVLogically, your table would remain the same, but your program would still break
p6548
as(dp6549
g6
V335858
p6550
stp6551
a((dp6552
g2
(lp6553
VYou should not wait for the view to disappear, and cancel the operation in the  method of your table view cell
p6554
aVOtherwise you may see a cell get recycled before the download finishes (e
p6555
ag303
aVbecause the user did a fast scroll), and then the finished download would show wrong content before the correct one overwrites it
p6556
aVOther than that, your approach looks workable
p6557
as(dp6558
g6
V335858
p6559
stp6560
a((dp6561
g2
(lp6562
VHere is a very good example illustrating the issue the prohibition on reordering is aimed to address (taken from here):
p6563
aVIn this example,  is volatile, but  is not
p6564
aVIf writer and reader are executed concurrently and the reader sees  set to ,  is guaranteed to be
p6565
aVPrior to Java-5, compiler was free to re-order the writes to  and , so you could see  at zero after you've seen  set to
p6566
aVThis was confusing, and lead to subtle errors
p6567
aVJava-5 memory model addressed this issue by making volatile writes almost equivalent to synchronization
p6568
as(dp6569
g6
V335858
p6570
stp6571
a((dp6572
g2
(lp6573
VThe first time through you replace the  tag in  with the details of the first user
p6574
aVOnce you do that, it never goes back to  again, so everybody gets that dude's details until your cache is reset
p6575
aVYou should avoid modifying objects that you get from cache:
p6576
as(dp6577
g6
V335858
p6578
stp6579
a((dp6580
g2
(lp6581
VWhen you call , you can pass any  as its last parameter
p6582
aVThe same object will be made available to your callback through 's  property
p6583
as(dp6584
g6
V335858
p6585
stp6586
a((dp6587
g2
(lp6588
VAny collection that supports sorting with a custom comparer will do - even an array
p6589
aVImplement your custom comparator as follows:
p6590
as(dp6591
g6
V335858
p6592
stp6593
a((dp6594
g2
(lp6595
VThis is because you are missing  statements between your cases
p6596
aVThis is because you are missing a
p6597
aVCompiler tells you that when your  is, for example, 4, whatever you assign to it in the  will get immediately overwritten by , because there is no
p6598
aVIt also tells you that when  is negative or more than 5, your  is uninitialized
p6599
as(dp6600
g6
V335858
p6601
stp6602
a((dp6603
g2
(lp6604
VThe problem is that yuu have semicolons after
p6605
aVThis is the only thing preventing you from using your "constants", which are not technically constants; they are preprocessor definitions
p6606
aVLogically, the C++ compiler runs the text of your program through a preprocessor, a text filter that executes the directives starting in
p6607
aVThe  directive instructs preprocessor to find all occurrences of its left part, and replace them verbatim with its right part
p6608
aVIn your case, it includes semicolons, resulting in invalid expressions after replacement
p6609
aVFor example,
p6610
aVbecomes
p6611
aVThis is an error, and the compiler reports it as invalid syntax
p6612
as(dp6613
g6
V335858
p6614
stp6615
a((dp6616
g2
(lp6617
VPut this in your header file
p6618
aVand keep this in a C file:
p6619
as(dp6620
g6
V335858
p6621
stp6622
a((dp6623
g2
(lp6624
VYou can use this ugly regexp:
p6625
aVTranslated to plain English, it means "a two-digit string that does not start in , or a two-digit string that starts in  but does not have  as its second digit"
p6626
as(dp6627
g6
V335858
p6628
stp6629
a((dp6630
g2
(lp6631
VIs there a way to do this in one query
p6632
aVAbsolutely
p6633
aVYou can use  to "mask out" parts of your query
p6634
aVFor example,
p6635
aVwill pay attention to  only when
p6636
aVOtherwise, the whole subexpression would evaluate to , effectively excluding itself from the query condition
p6637
as(dp6638
g6
V335858
p6639
stp6640
a((dp6641
g2
(lp6642
VYou can create a  of IP addresses, and keep client IP addresses there
p6643
aVLookup in hash set does not require a loop: you simply use its  method
p6644
as(dp6645
g6
V335858
p6646
stp6647
a((dp6648
g2
(lp6649
Vis not a keyword, it is an optional annotation that helps the compiler check that you indeed are overriding a method
p6650
aVIf you say  but there is no method to override, the compiler will tell you that you've probably made a typo
p6651
aVRename  to  to see the effect
p6652
aVInterface cannot have any implementations, while abstract class may optionally provide implementations for some of its methods
p6653
aVIn addition, interfaces cannot have data members
p6654
aVDefining a method as abstract means that the derived class must provide an implementation
p6655
aVNot declaring it abstract says that derived classes simply can provide their own implementation, but they do not need to
p6656
as(dp6657
g6
V335858
p6658
stp6659
a((dp6660
g2
(lp6661
VI can't figure out how to determine the "size" of an arbitrary "r1"
p6662
aVYou cannot do that: the information about the size that you passed to  is irreversibly lost after the call
p6663
aVAll you have at that point is a pointer to the chunk of at least 24 bytes of memory
p6664
aVIf you need the size, you need to store it somewhere else - for example, in a separate variable that you carry around
p6665
aVTwo typical work-arounds to this issue include (1) storing a zero-terminated string in the allocated space, and using the length of that string as the proxy to the size of the allocated chunk, and (2) defining your own structure that contains both the size and the allocated pointer
p6666
aVNeither solution is ideal, but at least the choice is with you
p6667
as(dp6668
g6
V335858
p6669
stp6670
a((dp6671
g2
(lp6672
VAs noted in the other answer, the example is obsolete; I would not recommend using it
p6673
aVIf you are set on making it work just as an exercise, change your SQL to insert the ID that you created into , as follows:
p6674
as(dp6675
g6
V335858
p6676
stp6677
a((dp6678
g2
(lp6679
VTry this:
p6680
aVEDIT (in response to a comment)
p6681
aVIf you need to put this into a temp table, change the query to this:
p6682
as(dp6683
g6
V335858
p6684
stp6685
a((dp6686
g2
(lp6687
VAs far as security goes, the answer is "not really": determined hackers could get to your private fields and call your private functions with a little bit of reflection; all they need is a JAR with your code in it
p6688
aVAlthough hiding "sensitive" information does not make your class more secure, it makes it (along with systems built from it) a lot more maintainable
p6689
aVSo this answer is not an excuse for making all members of your classes public
p6690
as(dp6691
g6
V335858
p6692
stp6693
a((dp6694
g2
(lp6695
VThe  is a regular class template, it is not connected to the compiler in any special way as to find out about user-defined  types
p6696
aVIf you look at the  file, it has the default template definition that returns zeros for everything, and a whole bunch of type-specific specifications for the individual types, returning the right constants
p6697
aVYou can "plug in" your  into  by providing a specification of  by yourself
p6698
aVYou can copy the one for  from the , and modify it to suit your needs
p6699
as(dp6700
g6
V335858
p6701
stp6702
a((dp6703
g2
(lp6704
VI think you can speed up your search considerably by marking a state visited before proceeding with a recursive call
p6705
aVOther than that, there aren't too many optimizations for this puzzle: you simply need to try all possible moves
p6706
as(dp6707
g6
V335858
p6708
stp6709
a((dp6710
g2
(lp6711
VThe answer to your question is no: releasing the memory allocated for the object has nothing to do with calling the  method
p6712
aVIt happens in due course when the garbage collector gets to it
p6713
aVGenerally speaking,  is intended for speeding up the release of external resources, such as file handles, semaphores, db handles, and other items often allocated by the operating system
p6714
aVIf your object holds on to other  objects, it should dispose them in its call to dispose as well
p6715
aVFinalizer, however, is different: it is called as part of garbage collection, and is intended for releasing external resources that have not been released during the dispose (presumably, because the user forgot to call )
p6716
aVFinalizers must not call  of other objects that your object may hold, because they are in the process of being garbage collected already
p6717
as(dp6718
g6
V335858
p6719
stp6720
a((dp6721
g2
(lp6722
VIn case of comparing items the answer is no: you cannot put, say, a  between  and , and expect the compiler to figure out that you meant it to apply its built-in  operator on objects of type
p6723
aVHowever, your solution could be optimized a little, because you are paying for the indirection twice
p6724
aVSince you have declared your  an  already, you could drop the  parameter, and call  without going through the lambda
p6725
aVThis would cutting down on the overhead of a second indirection
p6726
aVOf course it would not let you customize the way in which you compare your items, but that would be a routine case of paying for flexibility with CPU cycles
p6727
as(dp6728
g6
V335858
p6729
stp6730
a((dp6731
g2
(lp6732
VThe command that you are talking about allocates a block of length that is sufficient to store  items of type , and stores the result at the -th position in the array of pointers called
p6733
aVThe program creates a "triangular"  array: its elements are arrays of different lengths, arranged in such an order that  can hold  elements
p6734
aVBy the way, this code is missing calls to  for the items it has allocated
p6735
as(dp6736
g6
V335858
p6737
stp6738
a((dp6739
g2
(lp6740
VYou can check the class of the sender like this:
p6741
aVHowever, this may not be the optimal setup: potentially you could wire up different selectors when you create your table cells with a switch vs
p6742
aVtext field for a better solution
p6743
as(dp6744
g6
V335858
p6745
stp6746
a((dp6747
g2
(lp6748
VYou're almost there:
p6749
aVI also suggest switching to "straight" array syntax when accessing the array, rather than relying on array-as-pointer semantic, i
p6750
ag630
aVuse  rather than  in your expressions:
p6751
ag1971
ag1972
aV: I assume that you have not started learning about STL; more appropriate solutions exist with the use of standard C++ library
p6752
as(dp6753
g6
V335858
p6754
stp6755
a((dp6756
g2
(lp6757
VAssuming that all your values are of integer type, you should create a  to store variable values, and pass it to your  method:
p6758
aVThe evaluation should become relatively straightforward:
p6759
as(dp6760
g6
V335858
p6761
stp6762
a((dp6763
g2
(lp6764
VYou can use left outer join, and check the results for null in the joined ID column, like this:
p6765
aVWhen you examine the result set that you get back, you will get non-null in  only when the item is in the , and a non-null in  only when the item is in the
p6766
aVYou can use this test to determine the type without having an explicit column
p6767
as(dp6768
g6
V335858
p6769
stp6770
a((dp6771
g2
(lp6772
VIf your data is that simple, you can use  directly:
p6773
aVRunning this program produces the following output (I added line breaks for clarity; they are not in the output):
p6774
aVYou need that root element if you would like to read the information back
p6775
aVThe most expedient way would be using LINQ2XML:
p6776
as(dp6777
g6
V335858
p6778
stp6779
a((dp6780
g2
(lp6781
VYou can use this query to produce results below:
p6782
aVThis does not get everything into a single row like you wanted (you'd need a pivot for that, and I don't think sqlite has it), but it lets you see what is going on
p6783
aVHere is what you'd get from this query:
p6784
aVEDIT (in response to a comment):
p6785
aVIf you are looking to shorten the query time, try reducing the number of joins, and remove the symmetric duplicates, like this:
p6786
as(dp6787
g6
V335858
p6788
stp6789
a((dp6790
g2
(lp6791
VIf I understood your question correctly, you can solve it by excluding names with null end times in any other row:
p6792
as(dp6793
g6
V335858
p6794
stp6795
a((dp6796
g2
(lp6797
VThe first thing I would do is profile your code, and see what takes so much time
p6798
aVMy guess is that a lot of time is spent here:
p6799
aVIf my guess is right, you should be able to gain some speed by switching template from  to a regular C array of integers
p6800
aVEDIT:
p6801
aVNow that I see the profile, I think my guess was right
p6802
aVDid you try switching to C arrays
p6803
aVIf you are open to a different approach to rendering fonts, see this article on texture atlases, it may give you some nice ideas
p6804
as(dp6805
g6
V335858
p6806
stp6807
a((dp6808
g2
(lp6809
VThis should work:
p6810
as(dp6811
g6
V335858
p6812
stp6813
a((dp6814
g2
(lp6815
VAs others noted, your  contains a mixture of  and  objects
p6816
aVThis is the most obvious thing that you need to address before you do anything else
p6817
aVYou can use  class method for that (it's autoreleased, so you'll need to remove the call to  at the end of your method)
p6818
aVA less obvious thing is that the model of your UITableView must be updated before you call , otherwise you would get another exception in a much less obvious place
p6819
as(dp6820
g6
V335858
p6821
stp6822
a((dp6823
g2
(lp6824
VThis should work:
p6825
aVConvert the expression for  in the same way
p6826
aVThe reason you see the warnings is that your expression converts from long to double and back to do the math
p6827
aVYou can avoid it by re-shuffling your expressions a bit to stay entirely within integral types
p6828
aVNote the conversion to  to avoid overflowing (thanks, Nick)
p6829
aVEDIT You can further simplify this and eliminate the conversion:
p6830
as(dp6831
g6
V335858
p6832
stp6833
a((dp6834
g2
(lp6835
Vshould be
p6836
aVThe way you wrote it,  expression of the first level unifies with  variable at the next level, never going for the  fact
p6837
as(dp6838
g6
V335858
p6839
stp6840
a((dp6841
g2
(lp6842
VInstead of writing several thousand lines of code to convert files using  / , you could use XSLT
p6843
aVWe are still talking hundreds of lines of code, and perhaps slower execution speeds, but if you are good at XSLT you could get it done much faster
p6844
aVThe other approach would be to build a C# program that links both the old class and the new class (of course you'd need to rename the old class to avoid naming collision)
p6845
aVThe program would load  from disk, construct  from the values of its attributes, and serialize  to disk
p6846
aVEssentially, this approach moves the task of conversion into the C# territory, which may be a lot more familiar to you
p6847
as(dp6848
g6
V335858
p6849
stp6850
a((dp6851
g2
(lp6852
VYou can use  and  format specifiers with  to display 64-bit integers
p6853
aVYour constant appears to fit in 64-bit signed number, with the limits of:
p6854
as(dp6855
g6
V335858
p6856
stp6857
a((dp6858
g2
(lp6859
VThis is because  for  takes a single character - any character, including
p6860
aVWhen you hit "return" button after entering your float value, I/O system gives you the float, and buffers the "return" character
p6861
aVWhen you call  with , the character is already there, so it gives it to you right away
p6862
aVTo address this problem, create a buffer for a string, call  with , and use the first character of the string as your selector character, like this:
p6863
as(dp6864
g6
V335858
p6865
stp6866
a((dp6867
g2
(lp6868
VAlthough your writing solution is more or less acceptable, your reading solution is fundamentally flawed: it uses the internal storage of your old string as a character buffer for your new string, which is very, very bad (to put it mildly)
p6869
aVYou should switch to a formatted way of reading and writing the streams, like this:
p6870
aVWriting:
p6871
aVReading:
p6872
aVThis way you would not need to bother determining the lengths of your strings at all
p6873
aVThis code is different in that it stops at whitespace characters; you can use  if you want to stop only at  characters
p6874
as(dp6875
g6
V335858
p6876
stp6877
a((dp6878
g2
(lp6879
VThis may work for you:
p6880
as(dp6881
g6
V335858
p6882
stp6883
a((dp6884
g2
(lp6885
VDefault assignments apply to class members, but not to local variables
p6886
aVAs Eric Lippert explained it in this answer, Microsoft could have initialized locals by default, but they choose not to do it because using an unassigned local is almost certainly a bug
p6887
as(dp6888
g6
V335858
p6889
stp6890
a((dp6891
g2
(lp6892
VSearching your files for  with regexp option in Visual Studio should turn up static variables for you
p6893
aVIt will also bring operators , but they should be relatively easy to filter out visually
p6894
as(dp6895
g6
V335858
p6896
stp6897
a((dp6898
g2
(lp6899
VCongratulations on discovering the most vexing parse
p6900
aVScott Meyers describes it as follows:
p6901
aVIn general, the [C++] language (thanks, unfortunately, to its history) will try to interpret any declaration made like this as the declaration of a function
p6902
aVIn your case, introducing parentheses disambiguates the parse, forcing it to become a local
p6903
as(dp6904
g6
V335858
p6905
stp6906
a((dp6907
g2
(lp6908
VLittle-endian / big-endian is a property of hardware
p6909
aVIn general, binary code compiled for one hardware cannot run on another hardware, except in a virtualization environments that interpret machine code, and emulate the target hardware for it
p6910
aVThere are bi-endian CPUs (e
p6911
ag303
aVARM, IA-64) that feature a switch to change endianness
p6912
aVAs far as byte-order-independent programming goes, the only case when you really need to do it is to deal with networking
p6913
aVThere are functions such as  and  to help you converting your hardware's byte order to network's byte order
p6914
as(dp6915
g6
V335858
p6916
stp6917
a((dp6918
g2
(lp6919
VOne way to preserve all whitespace in your XML is to use a  section
p6920
aVThe details depend on the way you do your serialization
p6921
aVSee this question for an explanation in a web service context
p6922
aVIf you serialize manually, use  method
p6923
as(dp6924
g6
V335858
p6925
stp6926
a((dp6927
g2
(lp6928
VYou cannot write data into space allocated for C-string literals: they are constants
p6929
aVThis is the part that leads to this behavior:
p6930
aVTwo things are wrong:
p6931
aVYour variable  does not have enough space for any non-empty string
p6932
aVEven if it did, writing to that space would not be allowed
p6933
aVTo fix this issue you could either (1) switch to using  (recommended) or (2) change declarations of your C strings to character arrays, like this:
p6934
as(dp6935
g6
V335858
p6936
stp6937
a((dp6938
g2
(lp6939
VUsing associated objects is a messy solution
p6940
aVInstead, you could create a false target object, give it your  and your , and have access to both of them in the selector method
p6941
aVIt is a lot more readable, and your code expresses your intent a lot better
p6942
aVHere is a quick and dirty example:
p6943
aVAdd  method to your controller:
p6944
aVNow you can create your tap recognizer like this:
p6945
as(dp6946
g6
V335858
p6947
stp6948
a((dp6949
g2
(lp6950
VA 5x5 grid can be checked in constant time:  is the same as
p6951
as(dp6952
g6
V335858
p6953
stp6954
a((dp6955
g2
(lp6956
VOne way is to replace all characters except digits with spaces, and use strtok to tokenize the resulting string
p6957
aVHere is a dirty pseudocodish example that you could modify to fit your needs:
p6958
aVThe main thing that makes this example dirty is the use of , which is not thread safe
p6959
aVYou should use  instead
p6960
aVOf course you would need to parse the strings for integers yourself ( is a good choice for that)
p6961
as(dp6962
g6
V335858
p6963
stp6964
a((dp6965
g2
(lp6966
VThis is because the second expression uses a reluctant (as opposed to greedy) quantifier, which means that it does not attempt to match the entire string and back off from there, like the first one does
p6967
aVThis expression  tries to advance as far as possible into your input string, so it goes all the way to the end
p6968
aVOnce it's there, it discovers that it has a match, and so it stops
p6969
aVThe reluctant version  does not do that: it matches to the first , and stops
p6970
aVThis article provides a great read on quantifiers
p6971
as(dp6972
g6
V335858
p6973
stp6974
a((dp6975
g2
(lp6976
VYou have forgotten to modify your prototype at the top of your file
p6977
aVIt still says
p6978
aVIt should be
p6979
as(dp6980
g6
V335858
p6981
stp6982
a((dp6983
g2
(lp6984
VThis obscure syntax lets you skip elements when creating an array aggregate
p6985
aVTake a look at this program:
p6986
aVIt uses the same syntax to skip elements 1, 3, and 4 of the array
p6987
aVThis is what this program prints:
p6988
aVYour program does the same thing, but it initializes an array of structures, and calculating the indexes into its array aggregate using bit shifts of compile-time constants
p6989
aVYou can find the values of these indexes in the comments (0x08, 0x10, 0x18, 0x20, and 0x28)
p6990
as(dp6991
g6
V335858
p6992
stp6993
a((dp6994
g2
(lp6995
VAssuming that you would like to keep only the first occurrence of the character, you can do this:
p6996
aVThe  array contains flags, one per character, indicating that we've seen this character already
p6997
aVIf your characters are all ASCII, you can shrink the  array to
p6998
as(dp6999
g6
V335858
p7000
stp7001
a((dp7002
g2
(lp7003
VThis error usually happens when the primary key is generated in the database, but the EF is not properly configured read the value back from the database after the insert
p7004
aVAs the result, both inserted items end up with an empty key in the EF context, triggering the error
p7005
aVSince the inserted data has different keys in the database, your DB schema appears to be correct
p7006
aVYou need to check your EDM to see that  on the PK column is set to  or whatever it should be in firebird
p7007
as(dp7008
g6
V335858
p7009
stp7010
a((dp7011
g2
(lp7012
VYour "loop through s3" code is empty
p7013
aVYou should do some checking inside your loop
p7014
aVYou should also set  to  before the loop, and check for it to be  after the loop
p7015
as(dp7016
g6
V335858
p7017
stp7018
a((dp7019
g2
(lp7020
VI think they do it in this specific example to use the sign bit
p7021
aVJava lacks unsigned types, so it is not possible to emulate  with  for numbers that use the most significant bit
p7022
aVNote how the code uses only  throughout your example
p7023
aVI am reasonably certain that this is to get full use of the entire bit range
p7024
as(dp7025
g6
V335858
p7026
stp7027
a((dp7028
g2
(lp7029
VIn order to vary the number of "nested loops" you need to use recursion
p7030
aVInitial call looks like this:
p7031
aVEDIT (in response to a comment by OP)
p7032
aVTo understand what is going on, you need to understand the meaning of the parameters first:
p7033
aVis the array of strings
p7034
aVEach element of the array corresponds to a nesting level of the imaginary nested loops: element 0 is for the outer loop, element 1 is for the first level of nesting, and so on
p7035
aVis the partially constructed result string
p7036
aVIt is empty at the initial level, has one character at the first level of nesting, two at the second, and so on
p7037
aVis the nesting level
p7038
aVIt is zero in the initial level, one at the first nesting level, and so on
p7039
aVThe function has two parts - the stopping condition, and the body of the recursive call
p7040
aVThe stopping condition is simple: once we get to the last level,  result is no longer "partial": it is complete; we can print it out and exit
p7041
aVHow do we know that we're at the last level
p7042
aVThe number of elements of  equals the number of levels, so when  equals the length of the  array, we're done
p7043
aVThe body of the recursive call is a loop
p7044
aVIt does the same thing that your nested loops do, but for only one level: each iteration adds one letter from its own array, and calls itself recursively for the next level
p7045
aVThe best way to see this in action is to set a breakpoint on the line with the  statement, and look at the call stack window
p7046
aVClick each invocation level, and inspect the values of function parameters
p7047
aVIf you are up for an exercise, try modifying this function to take two parameters instead of three
p7048
aVHint: you can eliminate the last parameter by observing that the length of  always matches the value of
p7049
as(dp7050
g6
V335858
p7051
stp7052
a((dp7053
g2
(lp7054
VThis is because you are not supposed to modify constants: after all, they are called constants for a reason
p7055
aVModifying a constant is undefined behavior according to the C standard, which often means that your program is going to crash
p7056
aVNote that it has nothing to do with your pointer being constant: the crash is because what your pointer points to is a string constant
p7057
aVHere is how to do what you are trying to do legally:
p7058
as(dp7059
g6
V335858
p7060
stp7061
a((dp7062
g2
(lp7063
VYou can try this:
p7064
aVThis expression lets you skip non-alphanumeric characters after  and before the first alphanumeric character, if any
p7065
aVIt also lets you have non-alphanumerics preceding the closing
p7066
aVEDIT
p7067
aVIn response to your comment about : as far as I know, you cannot "glue together" multiple non-contiguous matched groups
p7068
aVThe easiest solution is to use another regexp in your C# hosting program:
p7069
aVYou would need to go back to your original regexp, because the one from the answer matches only the first contiguous block of alphanumerics
p7070
as(dp7071
g6
V335858
p7072
stp7073
a((dp7074
g2
(lp7075
VYou are almost there: replace
p7076
aVwith
p7077
aVAlso,  needs to be  (last char is for null termination; don't forget to set  before calling )
p7078
aVOnce you're done with this initial fix, take a look at other solutions available on the internet: you will see how to do the whole thing in five or six lines
p7079
aVEDIT As an additional challenge, see if you can use these two string constants to avoid the long chain of if-then-else statements in your first method:
p7080
aVHint: observe how the first string is exactly four times longer than the second one
p7081
as(dp7082
g6
V335858
p7083
stp7084
a((dp7085
g2
(lp7086
V clause introduces a condition on individual rows;  clause introduces a condition on aggregations, i
p7087
ag630
aVresults of selection where a single result, such as count, average, min, max, or sum, has been produced from multiple rows
p7088
aVYour query calls for a second kind of condition (i
p7089
ag630
aVa condition on an aggregation) hence  works correctly
p7090
aVAs a rule of thumb, use  before  and  after
p7091
aVIt is a rather primitive rule, but it is useful in 90+ %% of cases
p7092
aVWhile you're at it, you may want to re-write your query using ANSI version of the join:
p7093
aVThis would eliminate  that was used as a theta join condition
p7094
as(dp7095
g6
V335858
p7096
stp7097
a((dp7098
g2
(lp7099
VApart from re-considering your inheritance hierarchy that forces you to do this somewhat un-orthodox operation, you have several solutions, all requiring some coding
p7100
aVYou can add an explicit conversion operator to your base class
p7101
aVYou can add an extension method that does the copying for you
p7102
aVAs far as transforming your inheritance hierarchy goes, you could use the Decorator Design Pattern to add special functionality to your  class, giving it functionality of a  without subclassing
p7103
as(dp7104
g6
V335858
p7105
stp7106
a((dp7107
g2
(lp7108
VAssuming that you are going through arrays of  values, here is what you can do:
p7109
aVInitial call looks like this:
p7110
as(dp7111
g6
V335858
p7112
stp7113
a((dp7114
g2
(lp7115
VThis is because  returns Object
p7116
aVIf you call , you would not need to cast
p7117
aVFrom the documentation:
p7118
aVpublic Object nextElement()
p7119
aVReturns the same value as the nextToken method, except that its declared return value is Object rather than String
p7120
aVIt exists so that this class can implement the Enumeration interface
p7121
aVEDIT Regarding the variables that are not used: the reason you get the warning is that the variables are assigned, but not printed, saved, or analyzed in some way
p7122
aVIf you add a call to, say,  with first and last name, the warnings would go away
p7123
as(dp7124
g6
V335858
p7125
stp7126
a((dp7127
g2
(lp7128
VIs Struct's address is same as address of its first member
p7129
aVYes, this is actually mandated by the C and C++ standards
p7130
aVFrom the C standard:
p7131
ag837
ag838
ag839
aV1-13
p7132
aVA pointer to a structure object, suitably converted, points to its initial member
p7133
aVThe size of your  should be two bytes
p7134
aVYou should not convert a pointer to it to , though: instead, you should use  to copy your  into the buffer that you send over the network
p7135
aVEDIT Since you use scatter-gather I/O with , you do not need to cast  to anything:  is , so you can simply set
p7136
aVNote: This works only as long as your  does not contain virtual functions, base classes, etc
p7137
aV(thanks, Timo)
p7138
aVEDIT2
p7139
aVIn order to get {0x81, 0x05} in your , you should change the order of structure elements as follows:
p7140
as(dp7141
g6
V335858
p7142
stp7143
a((dp7144
g2
(lp7145
VBefore you can do anything to , you need to add  at position
p7146
aVYou can do this by resizing the vector (preferred), or by calling
p7147
as(dp7148
g6
V335858
p7149
stp7150
a((dp7151
g2
(lp7152
VThis is because your  is unsigned
p7153
aVAll numbers added to it are interpreted as unsigned, hence small negative numbers become large positive numbers in two's complement representation
p7154
as(dp7155
g6
V335858
p7156
stp7157
a((dp7158
g2
(lp7159
VThis happens because you put the terminating zero of a C string outside the allocated space
p7160
aVYou should be allocating one extra character at the end of your string copy, and adding  there
p7161
aVOr better yet, you should use
p7162
aVit keeps reading from memory without this
p7163
aVThis is by design: C strings are zero-terminated
p7164
aVsignals to string routines in C that the end of the string has been reached
p7165
aVThe same convention holds in C++ when you work with C strings
p7166
as(dp7167
g6
V335858
p7168
stp7169
a((dp7170
g2
(lp7171
VThis macro does not describe  as a volatile unsigned int pointer to the address
p7172
aVIt describes  as an unsigned integer value located at the , most likely, a hardware-specific register
p7173
aVThe reason you need  is to prevent the compiler from "optimizing" multiple writes to a hardware register
p7174
aVFor example, if you need to signal something to the hardware by setting the value to 1 and then clearing it, you could write
p7175
aVWithout  the compiler could drop the first assignment as insignificant;  prevents it from doing so
p7176
as(dp7177
g6
V335858
p7178
stp7179
a((dp7180
g2
(lp7181
VIt is hard to be too specific without seeing the content of your , but in general you should not be performing network operations synchronously in the  code
p7182
aVYou should set the labels to temporary placeholders, and initiate an asynchronous call that takes a block that executes on completion of the asynchronous operation
p7183
aVYou should be setting the real values of your labels from inside that asynchronous block
p7184
as(dp7185
g6
V335858
p7186
stp7187
a((dp7188
g2
(lp7189
VCreate a static instance variable, and use  on it
p7190
aVNote #1: using  would be valid only in non-concurrent environments;  works even if you allocate your robots from multiple threads
p7191
aVEDIT This does not deal with re-using robot IDs
p7192
aVIf you need reuse, the solution is a lot more complex: you need a list of reusable IDs, and a  around the code that accesses that list
p7193
aVNote #2: If you would like to reuse smaller IDs ahead of larger IDs (as opposed to reusing IDs released earlier before IDs released later, as I coded it) you can replace  with  and make a few adjustments around the parts where an ID to be reused is taken from the collection
p7194
as(dp7195
g6
V335858
p7196
stp7197
a((dp7198
g2
(lp7199
VIt is not only redundant, but also is dangerous: if  happens to be , your application is going to throw an exception if you use ; without , it would simply assign  to
p7200
as(dp7201
g6
V335858
p7202
stp7203
a((dp7204
g2
(lp7205
VMoving  to the end of your method may be the most expedient way to address the problem
p7206
aVIf that does not work, move the logic into
p7207
aVA better way to deal with this would be to avoid reading the current state from the view at all
p7208
aVRather, the view should pass the state to the model on each update
p7209
aVThis way you would be able to harvest the current state from your model, entirely independently from the state of your view
p7210
as(dp7211
g6
V335858
p7212
stp7213
a((dp7214
g2
(lp7215
VOf the compiled languages Objective C is great deal more dynamic, but its facilities are not the same as in Javascript, a language with prototype-based inheritance
p7216
aVWhat you can do in C++ is to provide a virtual method taking a , and returning a function pointer that takes an instance of your class as its first argument, for a poor man's version of dynamic dispatch
p7217
aVThe only thing that would need to be shared in this instance is the type of the function pointer
p7218
as(dp7219
g6
V335858
p7220
stp7221
a((dp7222
g2
(lp7223
VShould I ignore the Tag property in the implementation of Equals
p7224
aVNo, I think this is a bad idea
p7225
aVDoes doing so make the code harder to understand
p7226
aVAbsolutely: a new developer would not understand how come two devices with different tags put in a hash set become one device
p7227
aVIs there a better way of doing what I'm trying to do
p7228
aVThere are at least two ways that I can think:
p7229
aVProvide a custom comparator
p7230
aVAdd a class called , and keep the  "tagless"
p7231
aVI would prefer the second approach, because it does look like your  models a real-world "tag" glued onto the device locator, which ignores its tag other than for display purposes
p7232
as(dp7233
g6
V335858
p7234
stp7235
a((dp7236
g2
(lp7237
VIn general, no: lines are delimited with a special character, your program would need to read all characters, and count the line breaks in order to do what you need
p7238
aVIn special cases when your lines are all of the same length (which happens more often in programming competitions than in practice) you could reposition the file read pointer to a specific place, and read your line from there
p7239
ag1971
ag1972
aVThe only place where I saw it in practice was UUENCODEd files
p7240
as(dp7241
g6
V335858
p7242
stp7243
a((dp7244
g2
(lp7245
VThis is because you declared a constructor  that takes 3 integer parameters, but did not provide its implementation
p7246
aVYou could either provide it inline in the header
p7247
aVor separately in the cpp file, like this:
p7248
as(dp7249
g6
V335858
p7250
stp7251
a((dp7252
g2
(lp7253
VIn the simplest form, you need three tables: one for your buses, one for their stops, and one for the timetables
p7254
aVThe first two tables are self-explanatory
p7255
aVHere is an example of the third table for a route with three stops that makes one run in the morning and one run in the evening:
p7256
as(dp7257
g6
V335858
p7258
stp7259
a((dp7260
g2
(lp7261
VYou should drop  altogether, and use  instead
p7262
aVWhile you are at it, you can also drop , and use
p7263
aVYour code would become a lot more readable that way:
p7264
as(dp7265
g6
V335858
p7266
stp7267
a((dp7268
g2
(lp7269
VThe  method in Java serves a specific purpose: it determines if the objects are logically equal, i
p7270
ag630
aVtheir content is the same, whatever that may mean in the context of each specific class
p7271
aVThis is in contrast to the objects being the same: two different objects could be logically equivalent
p7272
aVGoing back to your example,  and  are different objects that represent the same logical entity - an integer value of
p7273
aVThey model the same concept - an integer number, and integer numbers with the same value are identical to each other
p7274
aVand  are, therefore, equal
p7275
aVThe  and  objects, on the other hand, do not represent the same logical entity (in fact, they do not represent anything)
p7276
aVThat's why they are neither the same nor are equivalent
p7277
as(dp7278
g6
V335858
p7279
stp7280
a((dp7281
g2
(lp7282
VIn regular expressions  by itself does not mean anything
p7283
aVIt modifies the expression in front of it
p7284
aVThere may be confusion with wildcards, where  means the same thing as  in regular expressions
p7285
aVIn regular expressions  by itself or as the first character in an expression is illegal
p7286
as(dp7287
g6
V335858
p7288
stp7289
a((dp7290
g2
(lp7291
VWhen your positive number suddenly turns negative after , it's a sure sign of integer overflow
p7292
aVYou need to pick a data type that is capable of holding larger integers, e
p7293
ag303
aVOn a side note, your algorithm is not searching for the largest prime factor, as required in the problem
p7294
aVIt searches for the largest factor, which is not necessarily a prime one
p7295
aVBy the way, if you can prove that stopping the search upon reaching the square root of the number being factored is correct, you could speed up your program a great deal
p7296
as(dp7297
g6
V335858
p7298
stp7299
a((dp7300
g2
(lp7301
VAt the time when the parser detects the  tag, the source id and float_array id are not available: they have not been parsed yet
p7302
aVThe usual trick is to wait for the child element, and do the processing when it becomes available
p7303
aVYou can do it by creating a new  object (or whatever corresponds to XML's  tag in your model), and make it available to the  method, for example by setting it into an ivar called
p7304
aVOnce you detect  element, parse its , and call
p7305
as(dp7306
g6
V335858
p7307
stp7308
a((dp7309
g2
(lp7310
VBecause of the nature of hash tables, you cannot sort them on the key in place: they organize their keys in buckets based on their hash code, a value outside of hash table's control
p7311
aVHowever, you can read key-value pairs in whatever order that you like
p7312
aVHere is how you can do it using LINQ:
p7313
as(dp7314
g6
V335858
p7315
stp7316
a((dp7317
g2
(lp7318
VWhat you are looking for is a factory method, sometimes also called a virtual constructor (which is not technically correct, because it's neither a constructor nor a virtual method)
p7319
aVInstead of calling a constructor, you call a static method that calls a constructor of the class determined by the arguments passed in
p7320
as(dp7321
g6
V335858
p7322
stp7323
a((dp7324
g2
(lp7325
VYou are calculating the result correctly, but you are not printing it right
p7326
aVAlso you do not need a second loop:
p7327
aVIf you'd like to show off, you could replace the conditional with two exclamation points:
p7328
as(dp7329
g6
V335858
p7330
stp7331
a((dp7332
g2
(lp7333
VYou can split the string at , and calculate the result like this:
p7334
aVTo format the value back, use
p7335
as(dp7336
g6
V335858
p7337
stp7338
a((dp7339
g2
(lp7340
VYou should not iterate over the cells of , because some of them (in fact, most of them) may not be present until you request them
p7341
aVaggressively recycles its cells, so if a cell is not visible, it is very likely that you would be creating it from scratch only to put it back into recycle queue moments later
p7342
aVChanging your model and calling  the way your post suggests would be the right solution
p7343
aViOS will ensure that it runs the update in a smallest number of CPU cycles possible, so you do not need to worry about the cells that are already created
p7344
aVThis is also the easiest approach in terms of your coding effort
p7345
as(dp7346
g6
V335858
p7347
stp7348
a((dp7349
g2
(lp7350
VIf you force the data into memory before running the select by calling , I think your query should run fine
p7351
as(dp7352
g6
V335858
p7353
stp7354
a((dp7355
g2
(lp7356
VI am assuming that this is a homework assignment, so I would provide hints rather than the code
p7357
aVI hope this is sufficient to develop your own code, because the task at hand is only moderately complex
p7358
aVYou would need one fact and three rules
p7359
aVThe fact would ignore the element (i
p7360
ag630
aVuse ), unify the list with an empty list, and say that the returned level is -1 (not found)
p7361
aVThe first and the second rules would be the "textbook" list search, unifying the element with the head of the list, and returning the level 1; the other rule would ignore the head, and return the level of the element in the tail
p7362
aVThe final rule would unify the head of the list with a nested list of head and tail, make a recursive call, and check the returned value to see if it is more than zero
p7363
aVIf it is, the return value is the nested return plus one; otherwise, recursively check the tail, and return the result of that check
p7364
as(dp7365
g6
V335858
p7366
stp7367
a((dp7368
g2
(lp7369
VYou are correct, and your colleague is wrong: one can access a dictionary from multiple threads only in the absence of writers
p7370
aVNET 4
p7371
aV0 adds  class that does precisely what its name implies
p7372
as(dp7373
g6
V335858
p7374
stp7375
a((dp7376
g2
(lp7377
VThis is because you are instructing  to write the data that it reads into the memory allocated for the  value, i
p7378
ag630
aVinto read-only memory
p7379
aVIf you would like to make your string constant writable, change
p7380
aVto
p7381
aVNote that this is not safe either: it may crash when the user enters more than seven characters
p7382
aVAdd a limit to your format specifier in order to address that issue:
p7383
ag1971
ag1972
aVThe commented out  works fine because it is not modifying the string constant; rather, it modifies a pointer to character constant, which is allowed
p7384
as(dp7385
g6
V335858
p7386
stp7387
a((dp7388
g2
(lp7389
VThis is going to keep the columns that you did not touch the way they are in the database at the time of the read
p7390
aVOn  call LINQ2SQL compares the values in the fields of the object to the values in the database, and updates only the ones that have changed
p7391
as(dp7392
g6
V335858
p7393
stp7394
a((dp7395
g2
(lp7396
VThe real problem is on this line:
p7397
aVSince this is a , C# needs to know the inner /s layout before it could produce outer 's layout
p7398
aVAnd the inner  includes an inner inner , which in turn includes an inner inner inner , and so on
p7399
aVThe compiler cannot produce a layout because of this circular reference issue
p7400
aVNote:  is a shorthand for  which is itself a
p7401
as(dp7402
g6
V335858
p7403
stp7404
a((dp7405
g2
(lp7406
VThe decision to hide or not to hide rests entirely with you as the designer of your library
p7407
aVIf you would like to reserve the right to change your  at will in the future, you should not be exposing any of its members to "the world"
p7408
aVIf you are providing a  as means to communicate with your library in the first place (for example, a  representing a point in 3D), then you cannot hide its members from the world, as it would defeat the purpose
p7409
as(dp7410
g6
V335858
p7411
stp7412
a((dp7413
g2
(lp7414
VIn terms of concurrency problems, you will be fine as long as your threads do not read or write to the same portion of your array concurrently
p7415
aVYou may see slowdowns because of "False Sharing" hazard, though, so you may want to be on the lookout for unexpected slow-downs when the number of threads increases
p7416
as(dp7417
g6
V335858
p7418
stp7419
a((dp7420
g2
(lp7421
VThere is time between the moment a call to  is initiated and the moment when  writes a string to the log
p7422
aVIt may get pre-empted during that time, and so another thread could potentially sneak in its log entry before this instance of  wakes up
p7423
aVHere is a possible sequence of events that leads to your printout:
p7424
aVThread A calls , 2 goes on the stack as 's parameter, and 3 is written to
p7425
aVThread A gets pre-empted in the middle of preparing log's output
p7426
aVMain thread calls , 3 goes on the stack as 's parameter, and 4 is written to
p7427
aVMain thread writes  to the log without being pre-empted
p7428
aVThread A wakes up, takes 2 from the stack, formats its output, and writes  to the log
p7429
as(dp7430
g6
V335858
p7431
stp7432
a((dp7433
g2
(lp7434
VNo, probably not, at least not by far
p7435
aVI tried this quick and dirty benchmark:
p7436
aVMy  method skips all sorts of validations, and gets a result that is only a 40% improvement on : 1
p7437
aV14 s vs
p7438
ag1340
aV86 s
p7439
aVAdding just a basic validation to the dirty  eliminates its advantage almost entirely: this method
p7440
aVruns in 1
p7441
aV62 s, or a 13% improvement while staying fundamentally incorrect
p7442
as(dp7443
g6
V335858
p7444
stp7445
a((dp7446
g2
(lp7447
VThis is because  is in your  file
p7448
aVIt should not be there: the way you have it now, you get a separate static variable in each compilation unit that includes your  file
p7449
aVThe right way of doing it is to declare  static in your class, and initialize it in a single  file
p7450
aVIn your
p7451
aVh file:
p7452
aVIn your cpp file:
p7453
as(dp7454
g6
V335858
p7455
stp7456
a((dp7457
g2
(lp7458
VHere is one way of doing it:
p7459
as(dp7460
g6
V335858
p7461
stp7462
a((dp7463
g2
(lp7464
VThere is no such feature built into the language, but you have two standard ways of implementing it:
p7465
aVThe first one is throwing an exception
p7466
aVYou hinted at it in your post
p7467
aVThe callers would need to expect this exception, and be prepared to handle it
p7468
aVThe second one is a factory method
p7469
aVIt may return null if it fails to instantiate your class for whatever reason
p7470
aVYour callers need to be ready to handle null returns from your factory method
p7471
aVChoosing between the two options is not easy
p7472
aVThe guideline is that if rejecting instantiation is an exceptional situation, e
p7473
ag303
aVa programming or a configuration error, then go the exception route
p7474
aVIf rejections are going to happen routinely, e
p7475
ag303
aVbecause some resource is temporarily unavailable, then go the factory method route
p7476
aVOf course there are exceptions to these rules, so use your best judgement
p7477
as(dp7478
g6
V335858
p7479
stp7480
a((dp7481
g2
(lp7482
VIt is hard to believe that your application has memory requirements that are so strict at this day and age
p7483
aVWithout questioning your motives any further, here is what you can do:
p7484
as(dp7485
g6
V335858
p7486
stp7487
a((dp7488
g2
(lp7489
VYou cannot decouple the logic of reporting the progress from the logic that does the work, but you can decouple the logic that reports progress from the logic that updates the progress bar
p7490
aVOne way of doing it is by providing an event in the class that does the work to report its progress to interested parties that registered an event handler with the logic that does the work, and call it periodically as the progress changes
p7491
aVYour background worker would then become an "interested party" by registering to receive these event notifications from the "do the work" logic, and call its own  with the data that it receives from the event
p7492
aVThis way the "do the work" logic could remain unaware of the  of the background worker
p7493
as(dp7494
g6
V335858
p7495
stp7496
a((dp7497
g2
(lp7498
VYou can do it in two paths: first, sort  using your favorite sorting algorithm, but instead  of comparing  to  directly, compare  to
p7499
aVNow re-arrange  according to the indexes in  - and you are done
p7500
aVThe second step may look like this (in pseudocode):
p7501
as(dp7502
g6
V335858
p7503
stp7504
a((dp7505
g2
(lp7506
VThis should work (I am using SQL Server date-time functions)
p7507
as(dp7508
g6
V335858
p7509
stp7510
a((dp7511
g2
(lp7512
VYour code breaks when both states are equal to zero
p7513
aVYou could fix it by using this condition
p7514
aVinstead of
p7515
aVor try this instead:
p7516
as(dp7517
g6
V335858
p7518
stp7519
a((dp7520
g2
(lp7521
Vfunction is not necessary because you compare
p7522
aVIf you wanted to replace all occurrences of  with ,  would be applicable:
p7523
as(dp7524
g6
V335858
p7525
stp7526
a((dp7527
g2
(lp7528
VThis is because of Java type erasure: your
p7529
aVis actually a syntactic sugar on top of
p7530
aVTo be fair, that "syntactic sugar" lets the compiler do some very nice and important checking, but at run-time there is only one copy of the  method, and it uses  as the type of your variable
p7531
aVIf you have experienced generics in other languages (C#, C++ templates, Ada) type erasure would come in contrast to what you know, but this is how it works under the cover
p7532
as(dp7533
g6
V335858
p7534
stp7535
a((dp7536
g2
(lp7537
VAssuming that the units of measure are always expressed as a single character at the back of the string, you can do this:
p7538
as(dp7539
g6
V335858
p7540
stp7541
a((dp7542
g2
(lp7543
VThe reason that you get an exception is that the member  of type  is not initialized to, say,  somewhere in the constructor or in the declaration
p7544
aVThe reference to  in this context means "the object itself"; it is entirely not necessary in your code, because there is nothing to disambiguate
p7545
as(dp7546
g6
V335858
p7547
stp7548
a((dp7549
g2
(lp7550
VDefine an ivar , and set it up as follows in your designated initializer:
p7551
aVThen at runtime look up the imgage from the :
p7552
as(dp7553
g6
V335858
p7554
stp7555
a((dp7556
g2
(lp7557
VYou are not adding the views that you create in a loop as subviews to your main view
p7558
aVThat's why they do not become visible
p7559
aVAs a side note, I think you would be better off using  objects instead of : they are lighter-weight, and require about the same amount of work
p7560
as(dp7561
g6
V335858
p7562
stp7563
a((dp7564
g2
(lp7565
s(dp7566
g6
V335858
p7567
stp7568
a((dp7569
g2
(lp7570
VThis is because is an instance variable of your , not your view controller
p7571
aVIf you move the declaration and the initialization to your view controller, the error will go away
p7572
aVIt would not make it a global variable, though, which is good if it works for you
p7573
aVIf it does not work for you, make the variable a truly global one: move the declaration out of the app delegate, and add  keyword, like this:
p7574
aVNow add the definition in the
p7575
aVm file, like this:
p7576
aVMake sure the definition is outside the  block
p7577
as(dp7578
g6
V335858
p7579
stp7580
a((dp7581
g2
(lp7582
VWhen represented as a float, your number has an exponent of 16 (i
p7583
ag630
aVthe value is its mantisse times 2^16, or 65536)
p7584
aVThe mantisse then becomes
p7585
aVIn order to fit in a 32-bit float, the mantisse is truncated to 23 bits, so now it becomes
p7586
aVWhen multiplied back by , it becomes
p7587
aVNote the  in the third position after the decimal point: the output routine of C++ that you used rounds it up, making your final number look like
p7588
aVEDIT Explanation of the rounding: (Rick Regan's comment)
p7589
aVThe rounding occurs first in binary (to 24 bits), in decimal to binary conversion, and then to decimal, in
p7590
aVThe stored value is 1
p7591
aV1110001001000000001 x 2^16 = 1
p7592
aV8837909698486328125 x 2^16 = 123456
p7593
aV125
p7594
aVIt prints as 123456
p7595
aV13, but only because Visual C++ uses "round half away from zero" rounding
p7596
aVRick has an outstanding article on the subject, too
p7597
aVIf you would like to play with other numbers and their float representations, here is a very useful IEEE-754 calculator
p7598
as(dp7599
g6
V335858
p7600
stp7601
a((dp7602
g2
(lp7603
VThe performance implication of using the setters vs
p7604
aVthe constructor is negligible, because roughly the same thing is going on in both instances: data passed to a method gets stored in an instance variable
p7605
aVWith ten setters you pay the price for nine additional method calls, but they are so extremely cheap that you are not likely to find any difference, especially if they get inlined by JIT compiler
p7606
aVLogical implications are a lot more severe: if your object is not valid until you set all ten instance variables, then you definitely need to use a constructor with ten parameters: performance gains, real or not, are secondary to the logical integrity of your class, which should not be compromised
p7607
as(dp7608
g6
V335858
p7609
stp7610
a((dp7611
g2
(lp7612
VFirst, to answer your original question of "how to do the cast in this case": the answer is you cannot do it, because you use an anonymous type
p7613
aVThe error that you see is due to the implicitly typed  variable being incompatible with the grouped results
p7614
aVTry this:
p7615
aVYou will need to use the  block ahead of group by, too, because the  produced by  is an  on groups of records, not on records themselves
p7616
as(dp7617
g6
V335858
p7618
stp7619
a((dp7620
g2
(lp7621
VThis is not a naming conflict: in C#, local variables take precedence over instance variables with the same name, because their scope is narrower
p7622
aVWhen the compiler matches a name reference to a name declaration, it uses the matching declaration with the narrowest scope
p7623
aVSee documentation on Reference Matching for detailed information on the subject
p7624
as(dp7625
g6
V335858
p7626
stp7627
a((dp7628
g2
(lp7629
VIf you must remove entries while enumerating, walk the list in backward direction, and remove items that you need to remove
p7630
aVNote that this is not required in case of your post, where you know the values that need to be removed
p7631
as(dp7632
g6
V335858
p7633
stp7634
a((dp7635
g2
(lp7636
VYou can initialize the  lazily, for the price of having to use  instead of unqualified
p7637
aVHere is how you can do it:
p7638
aVIn the
p7639
aVh file:
p7640
aVIn the
p7641
aVm file:
p7642
as(dp7643
g6
V335858
p7644
stp7645
a((dp7646
g2
(lp7647
VThe key to solving this problem is realization of the fact that "square" in "fast exponentiation by squares" is not a magic number: it could be cubes, or any power that you would like
p7648
aVThis particular problem calls for exponentiation by cubes, though, because  is written in the base-3 notation
p7649
aVIt is relatively easy to extend the classic algorithm to work with cubes:
p7650
aVThe problem in SPOJ is set in a way that makes C++ I/O prohibitively slow, so this whole annoying manipulation with character pointers is, unfortunately, necessary
p7651
as(dp7652
g6
V335858
p7653
stp7654
a((dp7655
g2
(lp7656
VThe most obvious error is that your  is outside the loop: once set to , it never gets set back to
p7657
aVYou do not see any output because your program never stops
p7658
aVAs a side note, you do not need to check all primes all the way to the last one you've discovered: you can stop once you reach the square root of the candidate prime, i
p7659
ag630
aVYou are not going to notice any effect when your limit is 100, but if you try 100000, it would help a lot more
p7660
as(dp7661
g6
V335858
p7662
stp7663
a((dp7664
g2
(lp7665
VIt all makes perfect sense
p7666
aVHere is the sequence of events:
p7667
aVYou call
p7668
aVSince this is the first use of , its static members  is initialized to
p7669
aVSince this is the first use of , its static member  gets initialized to
p7670
aVThis is not the first use of , so  is read directly
p7671
aVSince it has not been statically initialized yet, it's still set to its default value of
p7672
aVHence  becomes 2
p7673
aVAt this point, 's static initializer adds 2 from  to  from 's own , which remains set to the default value of
p7674
aVThe sequence of static intialization continues with setting  to
p7675
aVNow  is ready to use, and  proceeds to printing , according to the values stored in the corresponding fields of  and
p7676
as(dp7677
g6
V335858
p7678
stp7679
a((dp7680
g2
(lp7681
VUnlike Java, C++ has multiple inheritance
p7682
aVHere is one example where scope resolution of the kind you're talking about becomes important:
p7683
as(dp7684
g6
V335858
p7685
stp7686
a((dp7687
g2
(lp7688
VYou can do it with "little magic" from LINQ:
p7689
aVThe only drawback is that this code will compile even if  is instantiated with a type  that does not support addition; of course it will throw an exception at run-time
p7690
aVAn added benefit is that this should work with user-defined  operators
p7691
as(dp7692
g6
V335858
p7693
stp7694
a((dp7695
g2
(lp7696
VI would try this expression instead:
p7697
aVThis would take care of  and  empty paragraphs as well
p7698
as(dp7699
g6
V335858
p7700
stp7701
a((dp7702
g2
(lp7703
VBecause removing at the end does not require moving the data
p7704
aVAdding may require copying to resize the storage array, but it's time is amortized
p7705
aVBecause adding at the end does not require walking the list, but indexing does
p7706
as(dp7707
g6
V335858
p7708
stp7709
a((dp7710
g2
(lp7711
VThere is nothing wrong with this trick when it is done in assembly: optimizers have been routinely making use of knowing where parts of an integer are to save CPU cycles and reduce the size of the code
p7712
aVFor example, when a 32-bit integer variable is initialized to a value that fits in only 16 bits, optimizing compilers would replace the instruction that stores a 32-bit value in memory with a faster instruction that stores a 16-bit value to the lower bits of the variable, and clear the upper 16 bits
p7713
aVMoreover, many optimizers would go even further: if a constant is divisible by 2^16, they would store the value divided by 2^16 to the upper 16 bits, and clear lower 16 bits
p7714
aVSome architectures restrict such manipulations to addresses of certain properties, for example, by requiring all 4-byte memory load/store instructions to be done at addresses divisible by four
p7715
aVThese restrictions may reduce applicability of partial-value writing tricks
p7716
as(dp7717
g6
V335858
p7718
stp7719
a((dp7720
g2
(lp7721
VYou should be passing 's class, not 's instance to get this to work:
p7722
as(dp7723
g6
V335858
p7724
stp7725
a((dp7726
g2
(lp7727
VThe standard way of dealing with this issue in iOS is attaching a  to your , and implement  method
p7728
aVInside this method you can validate the string to be of the correct "shape" for your purposes (one dot, no more than two digits after the dot, etc
p7729
aVand supply a different string if the input does not follow the expected format
p7730
as(dp7731
g6
V335858
p7732
stp7733
a((dp7734
g2
(lp7735
VIn your constructor you are using wrong variable references:
p7736
as(dp7737
g6
V335858
p7738
stp7739
a((dp7740
g2
(lp7741
VEvery compiler I know implements constant folding, i
p7742
ag630
aVcalculates constant expressions at compile time, so there is no difference
p7743
aVThe standard, however, does not mandate it:
p7744
aVA constant expression can be evaluated during translation rather than runtime, and accordingly may be used in any place that a constant may be
p7745
aVYou can explicitly disable this optimization with some compilers
p7746
aVFor example,  disables constant folding for floating point expressions in gcc
p7747
as(dp7748
g6
V335858
p7749
stp7750
a((dp7751
g2
(lp7752
VWhen your substring is a prefix as in your example, you can use  to search for
p7753
aVThis does not work for non-prefix substrings: in the general case, searching a map is not much different from searching other containers
p7754
as(dp7755
g6
V335858
p7756
stp7757
a((dp7758
g2
(lp7759
VMake sure that you decide on making a template library for the right reasons
p7760
aVMaking a container library a template is a good reason: all containers of the standard C++ library are done as templates
p7761
aVSimply avoiding the link step alone is not a good reason
p7762
as(dp7763
g6
V335858
p7764
stp7765
a((dp7766
g2
(lp7767
VUse this syntax:
p7768
as(dp7769
g6
V335858
p7770
stp7771
a((dp7772
g2
(lp7773
VYes, it is acceptable: the , , etc
p7774
aVaccess modifiers were introduced in part to support designs where accessing ivars from outside the class is required
p7775
aVYou should avoid writing directly to ivars, though
p7776
as(dp7777
g6
V335858
p7778
stp7779
a((dp7780
g2
(lp7781
VThis is a combined declaration of  and a type definition
p7782
aVis te name of a newly defined type;  is the structure tag
p7783
aVYou can use it as follows:
p7784
aVThis combined declaration is equivalent to the following two declarations:
p7785
aVand
p7786
as(dp7787
g6
V335858
p7788
stp7789
a((dp7790
g2
(lp7791
VI think you are looking for something like this:
p7792
aVThe  statement separates the execution path on the , and then  further separates it on the
p7793
aVIf the number of sections is significant, you could use an outer  outside of the inner switches
p7794
as(dp7795
g6
V335858
p7796
stp7797
a((dp7798
g2
(lp7799
VIt does not matter, the performance is the same
p7800
aVIn 1978 when C was invented these would map to different PDP-11 instructions, resulting in faster performance of  and
p7801
aVThese days, however, the operations are optimized into the same exact sequences of instructions
p7802
as(dp7803
g6
V335858
p7804
stp7805
a((dp7806
g2
(lp7807
VYou should initially set  to , and  to
p7808
as(dp7809
g6
V335858
p7810
stp7811
a((dp7812
g2
(lp7813
VYou are missing  in the  example
p7814
aVshould be
p7815
as(dp7816
g6
V335858
p7817
stp7818
a((dp7819
g2
(lp7820
VYes - derive it from
p7821
aVMake sure that you do it for the right reason: as a rule, runtime exceptions indicate programming errors, rather than errors that a program could potentially react to in some meaningful way
p7822
as(dp7823
g6
V335858
p7824
stp7825
a((dp7826
g2
(lp7827
VYour program does not work because your widening has no effect
p7828
aVYou are assigning a local array  to a pass-by-value parameter, so the change has no effect
p7829
aVEven if it did, the loops in the  would explore the wrong part of the widened array (the upper-left corner, as opposed to the center, where the real data is stored)
p7830
aVFinally, your innermost  compares  to  instead of
p7831
aVInstead of widening the array, you should add more conditions to the innermost  of the  function:
p7832
as(dp7833
g6
V335858
p7834
stp7835
a((dp7836
g2
(lp7837
VThis is because you are returning a pointer to local
p7838
aVThis is undefined behavior
p7839
aVreturns a pointer into the  character array
p7840
aVYou put that pointer into , and return to the caller
p7841
aVAt this time the memory inside  becomes invalid: any garbage can be written into it
p7842
aVTo avoid this problem, you should either pass a buffer/length pair for the return value, or use  on the string that you are returning
p7843
aVIn the later case you should remember to free the memory allocated for the returned string by
p7844
aVOn a related subject, you should avoid using , because it is not re-entrant, and will cause issues in multithreaded environments
p7845
aVConsider using  instead
p7846
as(dp7847
g6
V335858
p7848
stp7849
a((dp7850
g2
(lp7851
VI put a mbox befor the "Vol_Plicuri[i] = total
p7852
aVSplit('|')[0]
p7853
aVTrim();" and was not null
p7854
aVMake sure that  is set to a non-null value
p7855
as(dp7856
g6
V335858
p7857
stp7858
a((dp7859
g2
(lp7860
VAssuming that all reports implement , you can do it using , like this:
p7861
aVYou can then replace the switch with this code:
p7862
as(dp7863
g6
V335858
p7864
stp7865
a((dp7866
g2
(lp7867
VA quick benchmark shows that  has a slight edge:
p7868
aVThis produces
p7869
aVmaking the  access about 40% slower assuming an even blend of hits and misses
p7870
aVMoreover, when I change the program to always miss (i
p7871
ag630
aValways looking up ) the two versions become equally fast:
p7872
aVWhen I make it "all hits", however, the  remains a clear winner:
p7873
as(dp7874
g6
V335858
p7875
stp7876
a((dp7877
g2
(lp7878
Vshould be an array, not a reference, like this
p7879
aVYou should be passing an entire array to the sort, not a single element, like this:
p7880
aVOther than this, your code appears OK
p7881
aVI should add that this is not a C++ - ish solution: the preferred way of managing arrays in C++ is through using the  container from the standard library
p7882
aVThe nice thing about vectors is that you do not need to pass their size "on the side"
p7883
as(dp7884
g6
V335858
p7885
stp7886
a((dp7887
g2
(lp7888
VMove the method to a static class, and make it an extension method, like this:
p7889
aVYou can now use it as if it were an instance method
p7890
aVYou need to put your  class into the same namespace, or add a  directive for it
p7891
as(dp7892
g6
V335858
p7893
stp7894
a((dp7895
g2
(lp7896
VThis may work:
p7897
aV(heavily edited - my first answer did not have a chance of working
p7898
as(dp7899
g6
V335858
p7900
stp7901
a((dp7902
g2
(lp7903
VIf you do not care for the bit to be in the least significant position (e
p7904
ag303
aVbecause you need it for a boolean condition) you can do this:
p7905
aVThis may be faster because of constant folding: it is only one operation at runtime instead of two
p7906
as(dp7907
g6
V335858
p7908
stp7909
a((dp7910
g2
(lp7911
VThis inside a loop should work:
p7912
as(dp7913
g6
V335858
p7914
stp7915
a((dp7916
g2
(lp7917
V means "a directory two levels above the current one"
p7918
aVThe  denotes a verbatim string literal
p7919
as(dp7920
g6
V335858
p7921
stp7922
a((dp7923
g2
(lp7924
VYou cannot declare an array and assign it to an existing pointer in a single declaration
p7925
aVHowever, you can assign an array pointer to a newly declared pointer, like this:
p7926
aVIf you insist on staying within a single line, you could use an ugly macro, like this:
p7927
aVThe clarity of this one-liner is far lower than that of a two-line version from your post, so I would keep your initial version
p7928
aVEDIT (in response to the edit of the question)
p7929
aVAnother option is to create an unused pointer variable in a declaration, and assign your pointer in an initializer, like this:
p7930
as(dp7931
g6
V335858
p7932
stp7933
a((dp7934
g2
(lp7935
VConstruct an , and call  in a try-catch block
p7936
aVIf you do not get an exception, it's a
p7937
aVNET assembly
p7938
aVThis is not bullet-proof, but may provide a reasonable way to get started
p7939
as(dp7940
g6
V335858
p7941
stp7942
a((dp7943
g2
(lp7944
VThis is because  should not be called on  values
p7945
aVTry changing your code as follows:
p7946
as(dp7947
g6
V335858
p7948
stp7949
a((dp7950
g2
(lp7951
VThe #3 is actually #1: static initialization does not start until the first use of the class to which it belongs
p7952
aVIt is possible if  is called from the static constructor or a static initialization block
p7953
aVIf you do not invoke  directly or indirectly from your static constructor, you should be fine
p7954
as(dp7955
g6
V335858
p7956
stp7957
a((dp7958
g2
(lp7959
VThe two methods are different: the first has package visibility, while the second one is public
p7960
aVThe difference is that package-visible methods appear public only to methods inside the same package, while public methods are visible to all methods, inside and outside the package
p7961
aVSo the answer to your question depends on your intent: if your method is truly part of your component's interface, make it private; if it is designed for use only inside the package, keep it at the default package visibility
p7962
as(dp7963
g6
V335858
p7964
stp7965
a((dp7966
g2
(lp7967
VI think you put  instead of :
p7968
as(dp7969
g6
V335858
p7970
stp7971
a((dp7972
g2
(lp7973
VFirst, C# code checks for presence of a method, not a property
p7974
aVSecond, C# code compares return to :
p7975
aVEDIT To check for fields, change the method as follows:
p7976
as(dp7977
g6
V335858
p7978
stp7979
a((dp7980
g2
(lp7981
VThis is not a question of storing, it is a question of formatting
p7982
aVThis code produces :
p7983
as(dp7984
g6
V335858
p7985
stp7986
a((dp7987
g2
(lp7988
VThis should work:
p7989
as(dp7990
g6
V335858
p7991
stp7992
a((dp7993
g2
(lp7994
VType parameter  has been added to  to enable one specific idiom1 - use of  objects as type-safe object factories
p7995
aVEssentially, the addition of  lets you instantiate classes in a type-safe manner, like this:
p7996
aVType parameter  represents the class itself, enabling you to avoid unpleasant effects of type erasure by storing  in a generic class or passing it in as a parameter to a generic method
p7997
aVNote that  by itself would not be sufficient to complete this task2: the type of  is erased, so it becomes  under the hood
p7998
aVHere is a classic example where  parameter of the class becomes important
p7999
aVIn the example below, Java compiler is able to ensure type safety, letting you produce a typed collection from a SQL string and an instance of
p8000
aVNote that the class is used as a factory, and that its type safety can be verified at compile time:
p8001
aVSince Java erases the type parameter, making it a  or a class specified as the generic's upper bound, it is important to have access to the  object inside the  method
p8002
aVSince  returns an object of type , the compiler can perform type checking, eliminating a cast
p8003
aV1 SUN Oracle has published a good article explaining all this
p8004
aV2 This is different from implementations of generics without type erasure, such as one in
p8005
aVNET
p8006
as(dp8007
g6
V335858
p8008
stp8009
a((dp8010
g2
(lp8011
VThe data in databases is often organized in pages
p8012
aVThese pages are almost universally aligned with memory boundaries for memory and cache management
p8013
aVChoosing 2^n sizes for your data is good to optimize the use of space in your database
p8014
aVNote: Depending on the RDBMS engine, 256 may not be the best choice for variable-length strings from the memory alignment perspective, because the length of the string takes space as well, i
p8015
ag630
aVa  takes up 258 bytes
p8016
as(dp8017
g6
V335858
p8018
stp8019
a((dp8020
g2
(lp8021
VThe operation is not directly supported, so you need to use a mask
p8022
aVDepending on the size of your  variable, you need to pick a mask of a different size
p8023
aVIf  is , use ; if  is , use
p8024
aVAlternatively, you can declare  as unsigned: then the regular shift-assign would not sign-extend the
p8025
aVIn fact, big part of the reason the  operator was added to Java is the absence of unsigned types in the language
p8026
as(dp8027
g6
V335858
p8028
stp8029
a((dp8030
g2
(lp8031
VYou do not need to override the  method - the  already has a very good pair of  that are efficient in terms of CPU cycles and in terms of distributing different strings to different hash buckets
p8032
aVA pair of  methods is required for items placed in a hash set in order to enable the correct work of the container:  decides on the hash "bucket" in which the object is placed, and  resolves collisions among non-equal objects with identical hash codes
p8033
aVWikipedia has an illustrated article on hash tables
p8034
aVRead through it to improve your understanding of the  concepts, they are fundamental to using unsorted associative containers in any language, including Java
p8035
as(dp8036
g6
V335858
p8037
stp8038
a((dp8039
g2
(lp8040
VA problem with your approach is that the  for  is in the , and vice versa
p8041
aVA somewhat cleaner way would be to keep your  with the struct, and use structure tags in the declarations, like this:
p8042
ag2311
ag1177
ag2314
ag1177
as(dp8043
g6
V335858
p8044
stp8045
a((dp8046
g2
(lp8047
VThis construct works in SQL Server
p8048
aVI do not have a DB2 instance handy to verify that it works there as well, but the syntax is reasonably standard
p8049
as(dp8050
g6
V335858
p8051
stp8052
a((dp8053
g2
(lp8054
VPrograms and data are stored as numbers in memory cells
p8055
aVEach memory cell has a unique number, called its address
p8056
aVThe range of numbers representing valid addresses is called address space
p8057
aVWhen programs run, the CPU reads data from memory and writes results back to memory
p8058
aVCPU communicates the desired location to the memory by specifying the address of the memory cell targeted by a read or a write operation
p8059
aVThere are multiple ways in which the CPU can come up with an address (remember, address is only a number)
p8060
aVThe number representing the address could be in a register, it could be stored at another memory location, it could be calculated by adding or subtracting an offset to a register, and so on
p8061
aVIn all cases your compiled program instructs CPU on how to come up with (or generate) the address it needs to read or write
p8062
aVModern architectures let multiple programs execute as if they own the entire logical address space
p8063
aVIn other words, several programs could write to memory location at the same address without stepping over each others' results
p8064
aVThis is done by virtualizing the address space: let's say programs A and B generate a write to memory location at 0x1000
p8065
aVThe CPU, aided by the operating system, could performs additional adjustments to the address, and map it to physical address 0x60001000 for program A, and to 0x5F001000 for program B
p8066
aVBoth programs think that they wrote to the location at 0x1000, because they operate in a virtual address space
p8067
aVTheir model of the memory is a contiguous block starting at 0 and continuing to 0x000100000000 (assuming that your system has 4GiB of memory available to processes)
p8068
aVBut this model works only because the CPU additionally translates their logical addresses to physical addresses, which are allocated and taken away as needed in the process of running the program
p8069
aVBecause the same number representing an address means different things to a program and to a CPU, the address space of the program is called virtual, and the address space of the CPU is called physical
p8070
as(dp8071
g6
V335858
p8072
stp8073
a((dp8074
g2
(lp8075
VI assume that this is a homework, so I'll stay away from too specific recommendations
p8076
aVYou declared the variable  on line 19, so you need to remove the second declaration at line 34
p8077
aVYou also need to move the declaration of  to before the  statement
p8078
aVThis is because C++ requires all locals to be initialized exactly once, and there is no way a compiler could make sure of that if the first time through the loop you take  and the second time around it takes  where  is declared
p8079
aVThis will make your program compile, but it would not work as expected
p8080
aVLook at the opening/closing braces in your program, and ensure that the code blocks are nested in the way that you expect
p8081
as(dp8082
g6
V335858
p8083
stp8084
a((dp8085
g2
(lp8086
VYou can remove all attributes like this:
p8087
aVThis expression matches an opening tag, but captures only its header  and the closing  as groups 1 and 2
p8088
aVuses references to these groups to join them back in the output as
p8089
aVThis cuts out the attributes in the middle of the tag
p8090
as(dp8091
g6
V335858
p8092
stp8093
a((dp8094
g2
(lp8095
VThe easiest way to understand Duff's device is to separate its two logical components, the  and the  loop, from each other
p8096
aVHere is a logically equivalent implementation, where the two statements are no longer nested:
p8097
aVNote the labels inside the loop: they are normal C labels, not  labels
p8098
aVThe only difference between this code and Duff's device is that Duff's code exploits the ability of using  labels inside a  loop, as long as the loop itself starts and ends inside the  statement, eliminating the need for "regular" labels and gotos
p8099
as(dp8100
g6
V335858
p8101
stp8102
a((dp8103
g2
(lp8104
VThis error tells you that you cannot call update without specifying an instance of
p8105
aVTwo things could have happened:
p8106
aVYou have forgotten to make the  method , or
p8107
aVYou need to make an instance of  that you created somewhere using the  operator available to your  method
p8108
aVNote 1: The way it is coded now,  is not accessible, because it comes after the  statement
p8109
aVNote 2: It is very undesirable for a getter  to have side effects, such as updating something in an instance of another class
p8110
aVIt is a nearly 100% indication that something is wrong with your design
p8111
as(dp8112
g6
V335858
p8113
stp8114
a((dp8115
g2
(lp8116
VI think  is the best choice: it leaves the decision on whether or not the object is copyable to the derived classes, while prohibiting the copying at the abstract class level, preventing the dreaded object slicing
p8117
as(dp8118
g6
V335858
p8119
stp8120
a((dp8121
g2
(lp8122
VAssuming that you can get the whole source into memory, you can do this:
p8123
as(dp8124
g6
V335858
p8125
stp8126
a((dp8127
g2
(lp8128
VVariable  is only a pointer
p8129
aVIt is not wrong to return a local pointer from a function, you do it all the time
p8130
aVFor example, when you store a result of  in a pointer, the pointer is local, but the storage it points to is not
p8131
aVIt is, however, wrong to return a pointer to a local storage
p8132
aVSince in your example  never points to a locally allocated data, your code works correctly as written
p8133
aVEDIT (in response to the Follow Up)
p8134
aVabcde" is a constant var which resides in the constants-area (part of the heap
p8135
aVThe constants area is not usually part of the heap, it is either a separate arrea, usually adjacent to the area where the machine code of your program is stored
p8136
aVc vanishes, but "abcde" still remains in the heap, right
p8137
aVabcde" remains in the constants area, not in the heap, but the concept is correct: the pointer to that constant remains valid throughout the entire run-time of your program
p8138
as(dp8139
g6
V335858
p8140
stp8141
a((dp8142
g2
(lp8143
VYou do not need to keep your container generic on : you can instantiate an existing generic container on , like this:
p8144
as(dp8145
g6
V335858
p8146
stp8147
a((dp8148
g2
(lp8149
VYou get an error because your syntax is wrong: after  there needs to be , like this:
p8150
aVSQL needs to know how to "link up" the rows of the table that you are joining to the row(s) of the other table(s) in the query
p8151
aVI am assuming that  has a foreign key into  called
p8152
aVIf the  is present in both  and , you need to prefix it with the table name or an alias
p8153
aVIn fact, it's a good idea to do it anyway for added clarity
p8154
as(dp8155
g6
V335858
p8156
stp8157
a((dp8158
g2
(lp8159
VIn C++ case labels are constant expressions, not expressions in general
p8160
aVYou need a chain of if-then-else statements to do what you are trying to do
p8161
aVAlternatively, you can enumerate the values in the switch
p8162
aVThis runs marginally faster (though it does not matter in cases like yours), but it is considerably less readable:
p8163
as(dp8164
g6
V335858
p8165
stp8166
a((dp8167
g2
(lp8168
VIn C# the size of your array initializer must match the declared size of the array
p8169
aVYou do not need to declare the size if you would like to avoid duplication
p8170
aVIf you need all entries to be of the same size, you can do it with a little helper function , like this:
p8171
as(dp8172
g6
V335858
p8173
stp8174
a((dp8175
g2
(lp8176
VYou are opening the file for appending and reading
p8177
aVYou should be opening it for reading, or moving your read pointer to the place from which you are going to read (the beginning, I assume)
p8178
aVor
p8179
aVAlso,  does not zero-terminate your string, so you should terminate it before printing:
p8180
as(dp8181
g6
V335858
p8182
stp8183
a((dp8184
g2
(lp8185
VYou need to check the return value of
p8186
aVIf a read has been successful,  returns the pointer to the buffer that you passed to it (i
p8187
ag630
aVin your example)
p8188
aVIf the End-of-File is encountered and no characters have been read,  returns
p8189
aVTry this:
p8190
as(dp8191
g6
V335858
p8192
stp8193
a((dp8194
g2
(lp8195
VThe function is looking for a  of C strings (that's the most likely meaning of  inside a container named
p8196
aVHere is how you can build one:
p8197
aVIf you or your team designed this function, you may want to suggest changing the container type to a more C++ - ish
p8198
aVIf you are reading your patterns from a file, you can populate your array as follows:
p8199
aVEDIT (in response to a comment)
p8200
as(dp8201
g6
V335858
p8202
stp8203
a((dp8204
g2
(lp8205
VYou have a package-visible  and a  property that returns it
p8206
aVYou should make  private or package-visible, or make your  public
p8207
aVYou could also move the  out of your class, if it makes sense in the broader context
p8208
aVWhich option is right is your design decision
p8209
ag1971
ag1972
aVThe comment calls your  an Enumerator, which is not a correct name for an enumerated type
p8210
as(dp8211
g6
V335858
p8212
stp8213
a((dp8214
g2
(lp8215
VTo answer the second part of your question, you can get the number of entries in your  by using the  class, like this:
p8216
aVNote that the trick with counters in an array works only when the  values are consecutive
p8217
aVThis is somewhat more fragile than a , which would work even if you decide to assign your enumeration constants non-consecutive or negative values
p8218
aVOf course you would need to initialize the counts to zero at the beginning to avoid the "element is not there" exception at runtime
p8219
as(dp8220
g6
V335858
p8221
stp8222
a((dp8223
g2
(lp8224
VThis is a collection initializer
p8225
aVYou can use it on collections with an  method
p8226
aVThe pair of parentheses before the curly braces is optional
p8227
aVThis is very convenient, because you can use it on collections other than lists, for example on dictionaries:
p8228
aVThis lets you avoid a lengthier initialization sequence:
p8229
as(dp8230
g6
V335858
p8231
stp8232
a((dp8233
g2
(lp8234
VYou can generate an array of random numbers, and then sort it using Array sort
p8235
as(dp8236
g6
V335858
p8237
stp8238
a((dp8239
g2
(lp8240
VAssuming that this is a homework, here's a hint: this piece of code looks very suspicious:
p8241
aVSince  represents a position and is never assigned a character, you are effectively checking if the position is equal to the ASCII code of
p8242
as(dp8243
g6
V335858
p8244
stp8245
a((dp8246
g2
(lp8247
VCreating the statement outside the loop is cleaner, and may be somewhat faster, though you'd need to profile in order to see if it makes much difference in your case
p8248
aVIf the loop is doing the same thing with different data values, I would prefer PreparedStatement for speed
p8249
as(dp8250
g6
V335858
p8251
stp8252
a((dp8253
g2
(lp8254
VNo, there is no difference: starting with C# 2
p8255
aV0, you can specify delegates using a method group
p8256
aVNote: In an unlikely case that you need 1
p8257
aV0 compatibility, the second syntax would be your only option
p8258
as(dp8259
g6
V335858
p8260
stp8261
a((dp8262
g2
(lp8263
VThe concepts of re-entrancy and thread safety are related, but not equivalent
p8264
aVYou can write a re-entrant function that is not thread-safe, and a thread-safe function that is not re-entrant
p8265
aVI will use C# for my examples:
p8266
aVRe-entrant Function that is not Thread-Safe
p8267
aVThis function reverses the entries of an array:
p8268
aVThis function is clearly re-entrant, because it does not reference outside resources
p8269
aVIts thread safety, however, is conditional upon not passing it the same  from multiple threads
p8270
aVIf several threads concurrently pass  the same instance of an array, an incorrect result may be produced
p8271
aVOne way of making this function unconditionally thread-safe would be an addition of a lock:
p8272
aVThread-Safe Function that is not Re-Entrant
p8273
aVThis function calls function   times, and returns the value that has been returned more times than other values
p8274
aVThis function is thread-safe, because it locks the static array that it uses to do the counting
p8275
aVHowever, it is not re-entrant: for example, if the functor  passed in were to call , wrong results would be returned
p8276
as(dp8277
g6
V335858
p8278
stp8279
a((dp8280
g2
(lp8281
VYou need two pairs of curly braces (one for the array, one for the struct), instead of a single pair of parentheses
p8282
as(dp8283
g6
V335858
p8284
stp8285
a((dp8286
g2
(lp8287
VThis happens because you have an uninitialized pointer
p8288
aVIt does not crash as long as you get lucky, but using such pointers is undefined behavior
p8289
as(dp8290
g6
V335858
p8291
stp8292
a((dp8293
g2
(lp8294
VIn case of a binary search recursion does not help you express your intent any better than the iteration does, so an iterative approach is better
p8295
aVI think the best approach for an interview would be to submit a solution that calls : it shows the interviewer that you not only know some basic-level syntax and how to code a freshman-year algorithm, but that you do not waste time re-writing boilerplate code
p8296
as(dp8297
g6
V335858
p8298
stp8299
a((dp8300
g2
(lp8301
VIn terms of performance there should be no difference when you use modern optimizing compiles
p8302
aVBack in 1978, the first way was somewhat faster on PDP-11, because indirect autoincrement addressing required fewer cycles to process, and there was no optimizers capable of converting index+offset to autoincrement
p8303
ag1971
ag1972
aVSetting  has no effect, because  is passed by value
p8304
as(dp8305
g6
V335858
p8306
stp8307
a((dp8308
g2
(lp8309
VThe call part is the same, but the assignment part is skipped in the IL
p8310
aVTake a look - here is a disassembly of a simple program:
p8311
aVThe disassembly looks like this:
p8312
aVThe top four lines are common; the last three lines from the first call deal with the assignment; they are missing in the disassembly for the second call
p8313
as(dp8314
g6
V335858
p8315
stp8316
a((dp8317
g2
(lp8318
VCreate a  representing the current time (9:00 AM)
p8319
aVCreate a  representing the time interval (4 hours)
p8320
aVUse  method to produce the time of the next notification
p8321
aVThe 12/24 hour clock does not play into it at all: you can format the next time the way you or your user wish - as a 24-hour clock using the  mask or as a 12-hour clock using  mask
p8322
as(dp8323
g6
V335858
p8324
stp8325
a((dp8326
g2
(lp8327
VYou can use  from commons lang to "glue" the strings together:
p8328
aVThis might be a bit faster in case that you need to join more than two arrays, but in case of just two arrays it will almost certainly be slower
p8329
as(dp8330
g6
V335858
p8331
stp8332
a((dp8333
g2
(lp8334
VTry this:
p8335
aVThis assumes that  changes from 0 to totalFriends-1, inclusive
p8336
aVFor example, if  and , the answer this function returns is 12, one third through the range of 8
p8337
aV20 (inclusive)
p8338
as(dp8339
g6
V335858
p8340
stp8341
a((dp8342
g2
(lp8343
VThe  is only a representation of an expression, it cannot be executed
p8344
aVCalling  gives you a compiled delegate, a piece of code that you can call
p8345
aVEssentially, your program composes a small code snippet at runtime, and then call it as if it were processed by the compiler
p8346
aVThis is what the last two lines of your code do: as you can see, the compiled snippet can analyze the length of the string that you pass in - when the length is less than five, you get a  back; when it's five or more, you get a
p8347
aVWhat happens on first execution of the compiled snippet is platform-dependent, and should not be detectable by programmers using the
p8348
aVNET platform
p8349
as(dp8350
g6
V335858
p8351
stp8352
a((dp8353
g2
(lp8354
VYou can use :
p8355
as(dp8356
g6
V335858
p8357
stp8358
a((dp8359
g2
(lp8360
VWhat you are looking for is called edit distance or Levenshtein distance
p8361
aVThe wikipedia article explains how it is calculated, and has a nice piece of pseudocode at the bottom to help you code this algorithm in C# very easily
p8362
as(dp8363
g6
V335858
p8364
stp8365
a((dp8366
g2
(lp8367
VYou need to dump everything into a single group, and use a regular
p8368
aVI am not sure if LINQ-to-SQL would be able to translate it correctly, but it's definitely worth a try
p8369
as(dp8370
g6
V335858
p8371
stp8372
a((dp8373
g2
(lp8374
VSince generic collections implement object-based interfaces defined in the  namespace, you can do this:
p8375
aVOf course the type checking is now shifted to runtime, so you need to make sure that  would be of the correct type, because the compiler cannot check it after the cast
p8376
as(dp8377
g6
V335858
p8378
stp8379
a((dp8380
g2
(lp8381
VDeclaring a column  does not automatically makes it indexed; declaring it a primary key does:
p8382
aVYou can add the constraint to an existing database like this:
p8383
as(dp8384
g6
V335858
p8385
stp8386
a((dp8387
g2
(lp8388
VC++ lacks built-in reflection capabilities of more dynamic languages, so you cannot do what you would like using he out of the box capabilities of the language
p8389
aVHowever, if all members are of the same type, you can do it with a map of pointers to members and a little preparation:
p8390
as(dp8391
g6
V335858
p8392
stp8393
a((dp8394
g2
(lp8395
VYes, it is equivalent; there is no reason why this might be inferior to the original code
p8396
aVYou could also do the same thing on a single line, like this:
p8397
as(dp8398
g6
V335858
p8399
stp8400
a((dp8401
g2
(lp8402
VYou can use  for this: it is lighter-weight than , and very simple to use
p8403
aVThe idea is based on examples from this post, and is lifted from a working project
p8404
as(dp8405
g6
V335858
p8406
stp8407
a((dp8408
g2
(lp8409
VUsing forward declarations improves decoupling
p8410
aVIf you can avoid including  by using a forward declaration, it is a good idea to use forward declaration
p8411
aVIt is better not only because your builds run faster (after all, preprocessed headers can deal with compiler efficiency pretty well) but because it tells the readers of your declaration that the structure of your class  does not depend on knowing anything about your class , other than that it exists*
p8412
aVEDIT (to answer your question) The only downside to forward declarations that I know is that you cannot them in all situations: for example, a declaration similar to this
p8413
aVwould not compile, because the compiler needs to know the size of
p8414
aVHowever, the compiler finds such issues very reliably, and informs you about them in unambiguous terms
p8415
aV* The implementation of class  could very well depend on knowing the details of class
p8416
aVHowever, this dependency becomes an implementation detail of  hidden from the users of your class; you can change it at any time without breaking the code dependent upon class
p8417
as(dp8418
g6
V335858
p8419
stp8420
a((dp8421
g2
(lp8422
VYou can make the  variable of type  to avoid casts outside ifs:
p8423
aVAlternatively, you can keep the type of , and use method invocation syntax rather than member (dot) syntax outside the ifs:
p8424
aVFinally, you can avoid casts and square brackets altogether by declaring additional variables inside your ifs:
p8425
as(dp8426
g6
V335858
p8427
stp8428
a((dp8429
g2
(lp8430
VThe issue that causes this is your sampling interval: you go in increments of one second, so your program calculates the fall to negative heights
p8431
aVYou should change your code slightly:
p8432
aV}
p8433
aVThis will not print the time the object hits the ground
p8434
aVYou should do this calculation after the loop, using the remaining altitude, speed (), and , and solving the equation for the time remaining, getting the fraction representing seconds
p8435
as(dp8436
g6
V335858
p8437
stp8438
a((dp8439
g2
(lp8440
VThe details depend on your RDBMS, but many engines offer some kind of a COALESCE function
p8441
aVHere is how you do it in SQL Server:
p8442
aVWhen a coalesce function is not available, you can use a conditional expression
p8443
aVHere is the syntax for SQL Server:
p8444
as(dp8445
g6
V335858
p8446
stp8447
a((dp8448
g2
(lp8449
VHere is how you can do it using a  class from this answer:
p8450
aVThis code assumes that each key is present in both maps
p8451
as(dp8452
g6
V335858
p8453
stp8454
a((dp8455
g2
(lp8456
VBoth values are expressed in the same units
p8457
aVYou have a 32-bit system, so the size of an address is 32 bits, or 4 bytes
p8458
aVThe size of double on your system is 8 bytes
p8459
aVThe result of an integer division  is zero
p8460
as(dp8461
g6
V335858
p8462
stp8463
a((dp8464
g2
(lp8465
VYou cannot do it with  without iterating over all of its keys
p8466
aVI assume that this is not what you are after, so here is a way do it with a :
p8467
as(dp8468
g6
V335858
p8469
stp8470
a((dp8471
g2
(lp8472
VIn order for your new StaffRole instance to be 'found' in the combobox you need to describe why two StaffRole instances should be considered equivalent
p8473
aVSo you need to override  and
p8474
aVTechnically, you need only , but these two methods need to be overriden together
p8475
aVOne way to deal with it is to base object equality on  equality, like this:
p8476
as(dp8477
g6
V335858
p8478
stp8479
a((dp8480
g2
(lp8481
VYou should use  instead - it uses a single lookup
p8482
aVThe call is short enough to use "inline", without adding a wrapper function
p8483
aVreturns a  indicating if the lookup has been successful or not
p8484
as(dp8485
g6
V335858
p8486
stp8487
a((dp8488
g2
(lp8489
VYou can use String Utils from Apache Commons like this:
p8490
aVIf you are not looking to use external frameworks, you can roll your own, like this:
p8491
as(dp8492
g6
V335858
p8493
stp8494
a((dp8495
g2
(lp8496
VEDIT Since you cannot use the  trick or subqueries, you need to come up with a condition that spells out the definition of  using the elementary "less then" relations
p8497
aVThink about the problem in terms of comparing each record to all records in the same table
p8498
aVYou can do it by building a self-join such that all records that you select from the table that you join with have an earlier date
p8499
aVThere will be some records for which it is not possible to find a pair with a strictly earlier date; that is the record that you want
p8500
aVObviously, you need an outer join to bring the base record into the results, because the match does not exist
p8501
aVThe record that you are looking for will have a unique structure letting you identify it among the records that you do not want to see
p8502
as(dp8503
g6
V335858
p8504
stp8505
a((dp8506
g2
(lp8507
VThe type initializer of a static class is the code that sets the values of its static variables
p8508
aVIn your case, it is this code:
p8509
aVMake sure that  can access  and  without a problem
p8510
aVThe exception thrown from the initializer should have more information to help you debug the issue
p8511
as(dp8512
g6
V335858
p8513
stp8514
a((dp8515
g2
(lp8516
VYou can define an implicit conversion operator, like this:
p8517
as(dp8518
g6
V335858
p8519
stp8520
a((dp8521
g2
(lp8522
VSince  is checked, an alternative to catching the  is to declare your method as throwing it:
p8523
as(dp8524
g6
V335858
p8525
stp8526
a((dp8527
g2
(lp8528
VThis regular expression matches the expressions the way you wanted:
p8529
aVproduces this output:
p8530
aVAll you need to do is detecting if a value has single quotes around it, and unquote if necessary
p8531
as(dp8532
g6
V335858
p8533
stp8534
a((dp8535
g2
(lp8536
VYou do not need  for your scenario: a straightforward delegate-based approach should do
p8537
aVThe view should define a delegate interface, and provide a non-retaining  property
p8538
aVThe controller should implement the delegate interface, and set itself as view's delegate
p8539
aVThe view would then notify its delegate without even knowing that it notifies the controller
p8540
aVThe controller would then pass the notification along to the model
p8541
as(dp8542
g6
V335858
p8543
stp8544
a((dp8545
g2
(lp8546
VThis is because your query no longer returns instances of : it returns instances of an anonymous class with two members -  and ; there is no  among the members of the anonymous class, hence the error that you are seeing
p8547
aVI would try binding to , or better yet, give  a more meaningful name, say, , like this:
p8548
aVThen your binding would be more readable
p8549
as(dp8550
g6
V335858
p8551
stp8552
a((dp8553
g2
(lp8554
VYou can use  to "tokenize" a chain of whitespace-separated integers:
p8555
aVObviously, this code is skeletal, and skips the relevant checks
p8556
aVSee documentation for the precise information on how  handles various unexpected situations
p8557
as(dp8558
g6
V335858
p8559
stp8560
a((dp8561
g2
(lp8562
VThis is a very common way to structure your tables with ranges of dates, especially in temporal database designs
p8563
aVIt lets you perform range-based queries very efficiently, assuming that indexes on both columns exist
p8564
aVYou query the data like this:
p8565
aVis the date for which you would like to query, e
p8566
ag303
aV'2012-03-05'
p8567
aVNote the  on one side and  on the other side, without
p8568
aVThis is done to ensure that the from-to ranges define non-overlapping intervals
p8569
as(dp8570
g6
V335858
p8571
stp8572
a((dp8573
g2
(lp8574
VYou can apply your math skills and use  and  to check digits of a number without converting it to a string:
p8575
aVThe idea is to "shift" the decimal representation of the number by dividing it by a power of ten, and then get the last digit by computing the remainder after division by ten
p8576
as(dp8577
g6
V335858
p8578
stp8579
a((dp8580
g2
(lp8581
VI think you should be able to do it with a single select without joins or subqueries
p8582
aVTry this:
p8583
as(dp8584
g6
V335858
p8585
stp8586
a((dp8587
g2
(lp8588
VThis is because  is mapped to an unsigned long type, so  becomes , a rather large positive integer
p8589
aVTry this:
p8590
aVNote how I re-wrote your macro to reference  as its parameter, and added a cast to  to ensure that comparing to  would bring an expected result
p8591
as(dp8592
g6
V335858
p8593
stp8594
a((dp8595
g2
(lp8596
VYou cannot load a 32-bit assembly into a running 64-bit process, or a 64-bit assembly into a running 32-bit process, not even into a separate application domain
p8597
aVThe reason you see it working with NUnit is that NUnit runner is a 32-bit application
p8598
aVI ran into a similar issue when my assembly failed to run inside NUnit because of a reference to a 64-bit C++ assembly
p8599
aVI ended up compiling my C++ code twice, and loading the needed library dynamically, based on a  check in an unsafe context (a complete hack)
p8600
aVIf you must interact with a 32-bit third-party DLL from your 64-bit application, the only option that I know is to write a wrapper that runs in a separate 32-bit host process, and communicates to your application using the interprocess communication facilities
p8601
aVThis approach brings some important performance implications with it, so you need to think twice before adopting it
p8602
as(dp8603
g6
V335858
p8604
stp8605
a((dp8606
g2
(lp8607
VName hiding of C# ( modifier) is called shadowing in VB
p8608
aVNET (keyword )
p8609
aVThis can be thought of as polymorphism only in the sense that overriding is a "polymorphism", i
p8610
ag630
aVstatic or compile-time
p8611
aVIt is not a polymorphism in the classical sense of calling virtual functions
p8612
as(dp8613
g6
V335858
p8614
stp8615
a((dp8616
g2
(lp8617
V cannot replace one character  with two characters
p8618
aVThe signature of the template method requires  for the last two parameters, but you are passing a string instead of a character
p8619
aVHere is how you can do what you need:
p8620
as(dp8621
g6
V335858
p8622
stp8623
a((dp8624
g2
(lp8625
VThe  is the length of the actual buffer, but that buffer is private to the string; in other words, it is not yours to access
p8626
aVThe  of the standard library may allocate more memory than is required to storing the actual characters of the string
p8627
aVThe capacity is the total allocated length
p8628
aVHowever, accessing characters outside  and  is still illegal
p8629
aVYou call  in cases when you anticipate resizing of the string to avoid unnecessary re-allocations
p8630
aVFor example, if you are planning to concatenate ten 20-character strings in a loop, it may make sense to reserve 201 characters (an extra one is for the zero terminator) for your string, rather than expanding it several times from its default size
p8631
as(dp8632
g6
V335858
p8633
stp8634
a((dp8635
g2
(lp8636
VFor two arrays two nested loops should do:
p8637
aVFor more nesting you would need a recursive or an equivalent stack-based solution
p8638
aVCall this recursive function from your  like this:
p8639
as(dp8640
g6
V335858
p8641
stp8642
a((dp8643
g2
(lp8644
VIn addition to adding the file to the project, you need to make sure that it gets added to the output bundle
p8645
aVOpen the project in Xcode, navigate to your target, switch to the "Build Phases" tab, and add "LockDialog
p8646
aVjava" to the "Copy Bundle Resources" list
p8647
as(dp8648
g6
V335858
p8649
stp8650
a((dp8651
g2
(lp8652
VTopCoder offers a very powerful SQL Parser component
p8653
aVI used it in a real project (also built for TopCoder) and it works very well
p8654
aVIts parser grammar is very complex, more than a thousand lines of code
p8655
aVRebuilding it would likely turn into a costly effort
p8656
as(dp8657
g6
V335858
p8658
stp8659
a((dp8660
g2
(lp8661
VYou misunderstood the signature of the selector that you register with the timer
p8662
aVThe sender is , not the userInfo object that you pass into its constructor:
p8663
as(dp8664
g6
V335858
p8665
stp8666
a((dp8667
g2
(lp8668
VYou need to remove  from the definitions in the cpp file: the compiler already knows the  and  are  from their declarations
p8669
aVEverything else looks right
p8670
as(dp8671
g6
V335858
p8672
stp8673
a((dp8674
g2
(lp8675
VSince  signature is , your error message is inverted
p8676
aVIt should be "Expecting one, got two"
p8677
aVYour actual list is correct, it has two items, as directed by the code
p8678
aVThe expected one, however, is incorrect: it has only a single item that you added to it during the test set-up
p8679
as(dp8680
g6
V335858
p8681
stp8682
a((dp8683
g2
(lp8684
VYou can do it in a single line
p8685
aVThis is not the fastest way to do it: in case  is relatively long, this should be faster:
p8686
as(dp8687
g6
V335858
p8688
stp8689
a((dp8690
g2
(lp8691
VReading past the end of vararg list is undefined behavior, so the reason for the second 20 is a pure luck: your code could have printed any integer number, or even crash
p8692
as(dp8693
g6
V335858
p8694
stp8695
a((dp8696
g2
(lp8697
VUnfortunately, you need to do it manually: processing escape sequences is compiler's job, by the time the  constant ends up in the area of string constants in the compiled code, the  is already replaced by the ASCII code 9 ()
p8698
aVIt should not be that difficult - in fact, it's an exercise number 3
p8699
aV2 of the classic K&R; book:
p8700
aVExercise 3-2
p8701
aVWrite a function escape(s,t) that converts characters like newline and tab into
p8702
aVvisible escape sequences like \u005cn and \u005ct as it copies the string t to s
p8703
aVUse a switch
p8704
aVWrite a
p8705
aVfunction for the other direction as well, converting escape sequences into the real characters
p8706
as(dp8707
g6
V335858
p8708
stp8709
a((dp8710
g2
(lp8711
VAssuming that by "reduce" you mean "eliminate", a logically equivalent chain of nested  statements that does not use the  is as follows:
p8712
as(dp8713
g6
V335858
p8714
stp8715
a((dp8716
g2
(lp8717
VPutting additional instance variables in class extensions was not possible prior to Clang/LLVM 2
p8718
ag49
aVObjective C compiler "assembles" the ivars of the class from the definitions in the header and in the class extension, arriving at the final layout
p8719
aVClass extensions is a relatively new language feature of Objective-C, so its absence in other languages, such is C++, should come as no surprise
p8720
aVYet other languages, such as C#, may implement a comparable feature with partial classes
p8721
aVYou are correct about the second part: only private instance variables and properties are suitable for use in class extensions; protected and of course public instance variables should be in the
p8722
aVh file
p8723
as(dp8724
g6
V335858
p8725
stp8726
a((dp8727
g2
(lp8728
VHint: Gray code of  is
p8729
aVGo through all numbers of the  range, and compute their Gray code representation using this simple formula
p8730
aVEDIT Another hint: the simplest way to convert an integer to binary is using :
p8731
as(dp8732
g6
V335858
p8733
stp8734
a((dp8735
g2
(lp8736
VYou have initialized it to , but then promptly replaced the initial entry with a seven-item array
p8737
aVBy the time you get into the iteration, the array at the element zero has only seven items, not fifteen
p8738
aVIf you would like to keep it , copy the names of the days into the array of 15 items
p8739
aVAlso if you would like the index to go full length of the array, use , , or
p8740
as(dp8741
g6
V335858
p8742
stp8743
a((dp8744
g2
(lp8745
VCorrectness of recursive algorithms is often proven by mathematical induction
p8746
aVThis method consists of two parts: first, you establish the basis, and then you use an inductive step
p8747
aVIn your case, the basis is all cases when k=0, or when k is odd but n is even
p8748
aVThe inductive step requires proving that when  is correct, , ,  and  are all correct
p8749
as(dp8750
g6
V335858
p8751
stp8752
a((dp8753
g2
(lp8754
VYou cannot use strings ( values) as your case labels
p8755
aVAlso,  is not doing what you think it does: the value will be off significantly
p8756
aVYou should use  instead
p8757
aVMoreover, the  is entirely unnecessary: you can use  instead
p8758
aVFinally, you do not even need a loop: there is a very convenient function that does what you need:
p8759
as(dp8760
g6
V335858
p8761
stp8762
a((dp8763
g2
(lp8764
VIf you cannot express your calculation in a single-line expression, add a static function, and call it in the way you normally call the constructor of the superclass:
p8765
aVEDIT Multiple-argument case:
p8766
as(dp8767
g6
V335858
p8768
stp8769
a((dp8770
g2
(lp8771
VAt the first glance, this looks like a classic case of tail recursion modulo cons, a generalization of tail call
p8772
aVIt is equivalent to a loop with the number of iterations
p8773
aVHowever, it is not that simple: the tricky thing here is the addition of  to a growing string: this is in itself a linear operation, and it is repeated  times
p8774
aVHence the complexity of your function is
p8775
as(dp8776
g6
V335858
p8777
stp8778
a((dp8779
g2
(lp8780
VAssuming that this is a homework, here is a hint: you need to put an  operation inside your two nested loops such that the operation does not need a loop
p8781
aVFor example, you can start with an array of  items, do nested loops on  and  that reverse array elements between  and , and then sort the resulting array
p8782
aVReversing is , sorting is , so sorting dominates; two outer loops provide the remaining
p8783
aVBoth sorting and reversing can be done using standard library functions, without additional loops
p8784
as(dp8785
g6
V335858
p8786
stp8787
a((dp8788
g2
(lp8789
VTo speed up your implementation, the  call should be replaced by a lookup: pre-calculate a table of the first 30 powers of , and use it at runtime
p8790
aVSince the limit on length is 30, you need only 31 element:
p8791
as(dp8792
g6
V335858
p8793
stp8794
a((dp8795
g2
(lp8796
VAlmost certainly your file does not exist
p8797
aVModify your code as follows to log if a file exists or not:
p8798
as(dp8799
g6
V335858
p8800
stp8801
a((dp8802
g2
(lp8803
VAccording to the Java language standard, the second semicolon is an empty statement
p8804
aVAn empty statement does nothing
p8805
aVExecution of an empty statement always completes normally
p8806
as(dp8807
g6
V335858
p8808
stp8809
a((dp8810
g2
(lp8811
VThis is because according to the source that you linked,  expects an array as its first argument:
p8812
aVmeans "a pointer to an integer", or "an integer array"
p8813
aVConsidering the usage, it is "an integer array" that the signature implies
p8814
aVHence, you need to change the signature of your C# :
p8815
as(dp8816
g6
V335858
p8817
stp8818
a((dp8819
g2
(lp8820
VThis is because  needs a valid regular expression;  is not a valid regular expression, while  is a valid regular expression
p8821
as(dp8822
g6
V335858
p8823
stp8824
a((dp8825
g2
(lp8826
VWhatever you are trying to do is almost certainly wrong
p8827
aVAt the very least, it goes against the rule that you should not be trying to access visuals of one view from inside the other view
p8828
aVYou should put the data from the  that you plan to share into your model class, whatever it may be, and access that data through the model, rather than trying to access  directly
p8829
as(dp8830
g6
V335858
p8831
stp8832
a((dp8833
g2
(lp8834
VThis is because you have not allocate your objects prior to using them:
p8835
aVIt's worth adding that using pointers in this situation is, well, pointless: string objects in the standard C++ library allocate the data for the string from the heap; strings are usually not much more than a pair of pointers anyway
p8836
as(dp8837
g6
V335858
p8838
stp8839
a((dp8840
g2
(lp8841
VTry using  instead:  has multiple overloads matching your argument list; specifying  forces the use of the specific overload:
p8842
aVNote that this  may be suboptimal depending on the use of : every time you use it in your code, a call will be made to  to calculate the same value
p8843
aVA better approach would be to use a static variable, set it once, and use it from that point on
p8844
as(dp8845
g6
V335858
p8846
stp8847
a((dp8848
g2
(lp8849
VIt is because you are dereferencing uninitialized pointers
p8850
aVThis is undefined behavior
p8851
aVOne of the overloads of  operator in the C++ standard library interprets  as a C string, not as a pointer
p8852
aVSine your C string is not initialized, the  operator prints junk
p8853
aVThere is no similar overload for  that would interpret it as anything other than a pointer, hence you see the correct behavior in the second case
p8854
aVIf you do not want your  pointer to be interpreted as a C string, cast your pointer to
p8855
aV( lets you show the pointer using a more conventional base-16 notation)
p8856
as(dp8857
g6
V335858
p8858
stp8859
a((dp8860
g2
(lp8861
VHere is how  is usually implemented:
p8862
aVAs you can see,  does not perform any conversion by itself: instead, it sets an option in the base stream to use hex for printing of numbers passed into it at a later point
p8863
aVEDIT (in response to a comment)
p8864
aVAs hammar correctly notes, the other part of the puzzle is how  is being called
p8865
aVThere is an overload of the  operator with this signature:
p8866
aVThis overload is essential implementation detail of  stream manipulators
p8867
aVIt is this overload that calls , and lets it do its "magic" (which of course should not sound like magic to you any longer)
p8868
as(dp8869
g6
V335858
p8870
stp8871
a((dp8872
g2
(lp8873
VThe basic structure of a recursive algorithm with multiple loops is as follows:
p8874
aVThe setup for calling  from the top level requires two vectors - one for the indexes, and one for the number of iterations at each level
p8875
aVThe example below sets up three nested loops, iterating 5, 6, and 9 times at each level:
p8876
as(dp8877
g6
V335858
p8878
stp8879
a((dp8880
g2
(lp8881
VYou can use  for single-digit numbers
p8882
as(dp8883
g6
V335858
p8884
stp8885
a((dp8886
g2
(lp8887
VThis is because you do it in : this is too soon to parse a , it may be incomplete at that stage
p8888
aVTry doing it when the end-user thinks that the entry is complete - for example, in the lost focus event handler
p8889
aVAlternatively, you can use  method to avoid exceptions on partial entries
p8890
as(dp8891
g6
V335858
p8892
stp8893
a((dp8894
g2
(lp8895
VOne way would be to implement the  delegate method of your scroll view delegate, determine the currently visible rectangle using  and  properties of your , compute the new location of your buttons relative to the visible rectangle of the scroll view, and reposition your buttons into that rectangle by setting their  property as desired
p8896
as(dp8897
g6
V335858
p8898
stp8899
a((dp8900
g2
(lp8901
VYou can make a copy before you start sorting, and then copy from that stored copy into the array being sorted in each iteration of the loop
p8902
as(dp8903
g6
V335858
p8904
stp8905
a((dp8906
g2
(lp8907
VAssuming that each string in the list contains one or more integer numbers separated by spaces, you can try this approach:
p8908
aVYou can use method group instead of lambda in the last select:
p8909
as(dp8910
g6
V335858
p8911
stp8912
a((dp8913
g2
(lp8914
VYou should forward-declare the  instead of including :
p8915
aVInside headerB
p8916
aVh:
p8917
aVThis works because you are not using the actual , only a pointer to it
p8918
aVYou cannot pull the same trick with , because  includes the actual
p8919
as(dp8920
g6
V335858
p8921
stp8922
a((dp8923
g2
(lp8924
VThere is a recent article on IBM developerWorks that explains how to use OpenLDAP client libraries in the iOS environment
p8925
aVYou can use OpenLDAP client libraries to access LDAP sources, including Active Directory
p8926
aVNot all Active Directory operations are supported, but even basic queries should be sufficient for building a browsing application
p8927
as(dp8928
g6
V335858
p8929
stp8930
a((dp8931
g2
(lp8932
VFirst, make a  out of the characters in your , then split that string at the space, and finally parse each token into an , like this:
p8933
as(dp8934
g6
V335858
p8935
stp8936
a((dp8937
g2
(lp8938
VYour  provides wrong payment info because it, quite honestly, does not have access to that payment object that you are creating
p8939
aVInstantiating  does not help: you need a different approach here
p8940
aVOne way to deal with the problem is to make a  method, instead of overriding
p8941
aVIt is a good idea to avoid using the plain  in your business code, reserving it to debugging and logging
p8942
aVIt's almost the same as your code, only the payment object is now passed in
p8943
aVNow you can modify your click handler to use this new method, like this:
p8944
as(dp8945
g6
V335858
p8946
stp8947
a((dp8948
g2
(lp8949
VMy reading of the standard suggests that this is left up to the implementation and the optimizer
p8950
aVSection 5
p8951
ag1340
ag839
aV3, part 10:
p8952
aVEXAMPLE 2 In executing the fragment
p8953
aVthe \u2018\u2018integer promotions\u2019\u2019 require that the abstract machine promote the value of each variable to int size and then add the two ints and truncate the sum
p8954
aVProvided the addition of two chars can be done without overflow, or with overflow wrapping silently to produce the correct result, the actual execution need only produce the same result, possibly omitting the promotions
p8955
aVMy understanding is that the standard lets the compiler decide if it is OK to use 8-bit addition, as long as the result is not going to be distinguishable from the addition of ints and converted to chars
p8956
aVNOTE Back at my days in the embedded world (mid-nineties), the C compiler that we used for our 8-bit platforms, Whitesmith compiler for 68HC11, produced a "plain" 8-bit addition instruction for adding two s
p8957
aVThe only way to find out for sure what happens in your fujitsu system would be to compile-to-assembly and check for yourself
p8958
as(dp8959
g6
V335858
p8960
stp8961
a((dp8962
g2
(lp8963
VYou should most definitely put your common macros in a single header for your entire project: code duplication is a dangerous thing that makes your maintenance costs go through the roof
p8964
aVThe warnings that you see may have to do with including the same header multiple times
p8965
aVYou need to use include guards to avoid them
p8966
aVEDIT (in response to the question update)
p8967
aVYour implementation of include guards is missing
p8968
aVIt should be as follows:
p8969
as(dp8970
g6
V335858
p8971
stp8972
a((dp8973
g2
(lp8974
VWhen users enter a number higher than ,  caps it at  anyway
p8975
aVThe value cannot be negative, either
p8976
aVIf you need to extend the range, use  for input, and cast to  after the check
p8977
aVThis will not guard against numbers that are outside of range of , though
p8978
aVFor a general-purpose solution, you can read a , and do a conversion yourself using  as your result
p8979
as(dp8980
g6
V335858
p8981
stp8982
a((dp8983
g2
(lp8984
VUse  regexp
p8985
aVYou can use , but that excludes  character as well
p8986
aVDetailed information can be found here: java
p8987
aVutil
p8988
aVregex
p8989
aVPattern
p8990
as(dp8991
g6
V335858
p8992
stp8993
a((dp8994
g2
(lp8995
VThe main problem in your code is that you are trying to represent all subsets using the same data structure as the original set
p8996
aVA set of all subsets will be a vector of vectors of ints, not a plain vector of ints
p8997
aVIt is a good idea to properly pluralize your variable names, for example
p8998
aVgetsubset should be getsubsets
p8999
aVallsubset should be allsubsets
p9000
as(dp9001
g6
V335858
p9002
stp9003
a((dp9004
g2
(lp9005
VThere is no pre-built method for that - you would need to write it yourself
p9006
aVThe simplest way would be to write two s first for the number of rows and the number of columns, and then write all  elements one by one
p9007
aVDecoding is equally simple - read the two ints for  and , and then run two nested loops reading the s
p9008
aVDefine two helper functions for that to avoid copy-pasting the same code twice
p9009
as(dp9010
g6
V335858
p9011
stp9012
a((dp9013
g2
(lp9014
VYou can do it with some preparation using delegates, like this:
p9015
aVWhen it is time to call your action, do it as follows:
p9016
as(dp9017
g6
V335858
p9018
stp9019
a((dp9020
g2
(lp9021
VThe first way is slightly easier to read, because your  serves as a more meaningful object
p9022
aVHowever, passing  and  is not ideal:  and  would be slightly better
p9023
aVThere is a definite advantage to the first way of doing it, though: you could add a  method to the class of your  object, avoiding the need to pass the same  twice to two different methods
p9024
as(dp9025
g6
V335858
p9026
stp9027
a((dp9028
g2
(lp9029
VFor the user to enter more characters than you allow, he must go at least one character over the limit
p9030
aVSince it does not matter to you by how many characters the user has "overstepped" your limit, you can pass  as your limit, and see if the length is greater than
p9031
aVOf course you need to make enough space in the buffer to hold the 13-th character and a zero terminator
p9032
aVEDIT You also need to call  to skip to the end of the line on each failed attempt
p9033
as(dp9034
g6
V335858
p9035
stp9036
a((dp9037
g2
(lp9038
VIn C++, scope resolution operator  is used instead of  in Java
p9039
aVYou call static methods like this:
p9040
aVIn the header:
p9041
aVIn the cpp file:
p9042
aVYour static method  needs to be public in the  class
p9043
as(dp9044
g6
V335858
p9045
stp9046
a((dp9047
g2
(lp9048
VTry this:
p9049
as(dp9050
g6
V335858
p9051
stp9052
a((dp9053
g2
(lp9054
VSince  is not a valid float value,  returns
p9055
aVFrom the  documentation:
p9056
aV[
p9057
aVreturns 0
p9058
aV0 if the receiver doesn\u2019t begin with a valid text representation of a floating-point number
p9059
as(dp9060
g6
V335858
p9061
stp9062
a((dp9063
g2
(lp9064
VUnlike Java, C++ allows free-standing functions
p9065
aVThe  function that is called when you run your program is free-standing , not a member
p9066
aVIf you modify your cpp file as follows, things should compile:
p9067
as(dp9068
g6
V335858
p9069
stp9070
a((dp9071
g2
(lp9072
VYou can parse the string to get two  numbers and an  part (, , and ), and then calculate the fraction as follows:
p9073
as(dp9074
g6
V335858
p9075
stp9076
a((dp9077
g2
(lp9078
V is an integer type with at least 64 bits
p9079
aVIt will fit signed 40 bit values on all platforms
p9080
aVYou can also use  for unsigned values of 64 bits or more
p9081
as(dp9082
g6
V335858
p9083
stp9084
a((dp9085
g2
(lp9086
VYou cannot use regular expressions for checking anything that needs counting: it is not powerful enough
p9087
aVIt is theoretically impossible to use regular expressions for a simpler problem of validating if parentheses in a string are balanced
p9088
aVYou need to build a parser for your expressions
p9089
aVA simple top-down parser will do, or you could use a parser generator, such as ANTLR or JavaCC
p9090
aVYou can also use one of the available open source expression languages for your project
p9091
as(dp9092
g6
V335858
p9093
stp9094
a((dp9095
g2
(lp9096
VThe way you are calling the method, the reflection thinks that you are passing three individual parameters, rather than a single array parameter
p9097
aVTry this:
p9098
as(dp9099
g6
V335858
p9100
stp9101
a((dp9102
g2
(lp9103
VYes, to an extend
p9104
aVAlthough two processors from the same family might have different assembly languages, in reality one language may be an extension of the other
p9105
aVSometimes processors from different manufacturers (e
p9106
ag303
aVIntel and AMD) share a great deal of their instruction set
p9107
aVMoreover, in spite of the vast number of assembly languages out there, they all share a relatively small number of fundamental concepts
p9108
aVOnce you learn to program in one assembly language, learning a second one is usually an order of magnitude easier undertaking
p9109
aVOf course there are exceptions to this rule: for example, learning an assembly for a CPU that follows Harvard architecture is slightly trickier than learning your second Von Neumann assembly
p9110
aVSwitching between RISC and CISC may present challenges as well
p9111
aVIt depends: if your PC and your netbook have CPUs from the same family, you may get lucky
p9112
aVThere's more than the instruction set to being able to run an assembly language program, though: the operating system matters a lot, too
p9113
aVFor example, Linux and Windows do not share the same format of executable files
p9114
aVThere is a lot more to hardware than the instruction set
p9115
aVThere are CPUs with identical instruction sets that use very different hardware
p9116
aVThe classic example is 8088 vs
p9117
aV8086: their instruction sets are identical, but their hardware differs rather fundamentally because of the width of their external data bus
p9118
aVYou run assembly code by first compiling it, the same way you do your C programs
p9119
aVis a typical extension for your assembly programs, but it's far from being a universal rule
p9120
aVYou can also embed assembly into your C/C++ files using compiler-specific extensions
p9121
as(dp9122
g6
V335858
p9123
stp9124
a((dp9125
g2
(lp9126
VYou are absolutely right, there is a better way
p9127
aVIf your implementations share a great deal of code, you can use template method pattern to reuse as much implementation as possible
p9128
aVDefine a  method in the superclass, and make it abstract
p9129
aVThen write your  method in the superclass that does the common thing and calls  when needed
p9130
aVFinally, override only  in the subclasses
p9131
as(dp9132
g6
V335858
p9133
stp9134
a((dp9135
g2
(lp9136
VYou can do it with an , like this:
p9137
aVYou need to add a root tag to deal with XML namespaces, and fix the well-formedness error in your XML for this to work
p9138
as(dp9139
g6
V335858
p9140
stp9141
a((dp9142
g2
(lp9143
VApart from the fact that the idea of storing unencrypted private keys in unsecured storage is questionable, you could use  or  data type to store the bytes of your keys without converting them to
p9144
as(dp9145
g6
V335858
p9146
stp9147
a((dp9148
g2
(lp9149
VIf the objects from your library hold only pointers or references to objects from the the restricted library, you could forward-declare them in the header, rather than including the headers themselves
p9150
aVFor example, you can do this
p9151
aVinstead of this:
p9152
aVIn the case with forward declarations only the CPP file needs to include the  header
p9153
aVOf course if you must include instances of "restricted" classes or inherit from them, you have no way around including their headers in your header files
p9154
as(dp9155
g6
V335858
p9156
stp9157
a((dp9158
g2
(lp9159
VIf  is a subclass of , its instances may be used everywhere where instances of  could be used
p9160
aVThe inverse is not true
p9161
aVHere is a real-life example using Apple's classes: consider  and its subclass
p9162
aVSince  is an , the following assignment is valid:
p9163
aVHowever, since  is not necessarily an , the following assignment is invalid:
p9164
aVEDIT From the language point of view, both assignments are valid: the code is going to compile, and may even run if you steer clear of 's methods not also supported by , thanks to the dynamic method dispatch mechanism of Objective C
p9165
aVBut the compiler can no longer validate the code that involves the variable, and tell you of other potential problems
p9166
as(dp9167
g6
V335858
p9168
stp9169
a((dp9170
g2
(lp9171
VYou can use  with a block that searches inside the dictionary, but it is suboptimal: you will be re-doing the same search over and over for each cell, which might slow down your app, especially when the user scrolls through your table quickly
p9172
aVYou would be a lot better off creating an  with the items as soon as you get the feed, and re-use that when you render your table cells
p9173
aVExample:
p9174
aVConstruct  when you receive your JSON feed, like this:
p9175
aVWhen you need to decided whether or not to show your accessory view, do this:
p9176
as(dp9177
g6
V335858
p9178
stp9179
a((dp9180
g2
(lp9181
VThe answer depends on your intended usage pattern
p9182
aVIf you plan to have nulls in the mix, and you would like to consider  values to be less than non-null values, then your implementation is correct; if you would like to consider  values to be greater than non-null objects, then the commented out return values ( and ) should be used instead
p9183
aVIf you do not plan to allow nulls in the mix, throwing an  or allowing  would be the right choice
p9184
as(dp9185
g6
V335858
p9186
stp9187
a((dp9188
g2
(lp9189
VMember pointers use different syntax
p9190
aVHere is your code modified to use it:
p9191
as(dp9192
g6
V335858
p9193
stp9194
a((dp9195
g2
(lp9196
VIt appears that your method can be replaced by a simple two-dimensional array
p9197
as(dp9198
g6
V335858
p9199
stp9200
a((dp9201
g2
(lp9202
VIf the algorithm needs ten items, then use
p9203
aVI suspect that the C++ code was itself ported from C code, where the programmer called , like this:
p9204
aVWhoever converted that code to C++ has probably forgotten to take away the multiplier
p9205
aVThis has resulted in a functionally correct, yet somewhat memory inefficient code (although wasting 30 bytes these days hardly even counts as inefficient)
p9206
as(dp9207
g6
V335858
p9208
stp9209
a((dp9210
g2
(lp9211
VYou could replace
p9212
aVwith
p9213
aVwhich should work unless  sometimes contains
p9214
ag1971
ag1972
aVIf you are up for learning something very, very cool, convert this expression to a lambda:
p9215
aVYou can now re-write your select like this:
p9216
as(dp9217
g6
V335858
p9218
stp9219
a((dp9220
g2
(lp9221
VThere is no easier way to get to the end of the line marker, but you could save some time by storing what you read as you read your data
p9222
aVThe you would not need to go back, and your loop will be very fast
p9223
aVCreate a character array of size , and use it as a circular buffer: when you get to the end of the array, just circle back to its beginning
p9224
aVStore the character in the next position of your circular buffer
p9225
aVWhen you detect , your buffer contains the  prior characters, only slightly out of order: the prefix starts at your buffer pointer and goes to the end of the buffer, and the suffix starts at zero and goes to your buffer pointer minus one
p9226
aVHere is an example of how you can make it work (assuming  == 20):
p9227
as(dp9228
g6
V335858
p9229
stp9230
a((dp9231
g2
(lp9232
VAlthough your code snippet does not require it, here is an answer to the question in the title of your post:
p9233
aVYou can use  to get an array of  objects representing the addresses of your host
p9234
aVYou can then call  on an individual  object to convert it to an array of bytes
p9235
as(dp9236
g6
V335858
p9237
stp9238
a((dp9239
g2
(lp9240
VYou cannot catch  unless it's thrown by the user code
p9241
aV(more info)
p9242
aVIn visual studio, from the "Debug" menu, choose "New Breakpoint > Break at Function
p9243
aVIn the "Function" field of the "New Breakpoint" dialog, enter
p9244
aVRun your program in the debugger
p9245
aVOnce you get the stack overflow, the debugger will stop at your breakpoint
p9246
as(dp9247
g6
V335858
p9248
stp9249
a((dp9250
g2
(lp9251
VYou can skip double-buffering your string, skip parsing the single character, and use  to parse integers, like this:
p9252
aVIn C++,  should be in the  include file
p9253
as(dp9254
g6
V335858
p9255
stp9256
a((dp9257
g2
(lp9258
VFor the first question, the answer is yes, absolutely: the objects inside non-referenced array and no other references do get garbage collected
p9259
aVAs for the second question, the document talks about placing forgetting an object inside a referenced collection, for example a cache of some sort, a static field, a thread-local store, etc
p9260
as(dp9261
g6
V335858
p9262
stp9263
a((dp9264
g2
(lp9265
VTry using  and  to denote the beginning and the end of the line, as follows:
p9266
aVNote that in addition to lines consisting of only whitespace characters, this expression will also match empty lines; if this is not desirable, replace  with a
p9267
as(dp9268
g6
V335858
p9269
stp9270
a((dp9271
g2
(lp9272
VYou can try this - perhaps equally clunky, but at least a bit shorter:
p9273
as(dp9274
g6
V335858
p9275
stp9276
a((dp9277
g2
(lp9278
VSTL map is an ordered container
p9279
aVThe order of items that you get during the iteration is independent of the order in which you insert the items into the container
p9280
aVThe order of iteration is determined by two things:
p9281
aVThe value of the key, and
p9282
aVThe  class passed as the template parameter to the
p9283
aVYou can iterate the map in reverse order (your code snippet shows that you already know how it is done)
p9284
aVThe performance penalty for reverse-iterating a map, if any, is negligible
p9285
aVYou can also provide a non-default  ( instead of the default ) to have the default order of iteration altered
p9286
as(dp9287
g6
V335858
p9288
stp9289
a((dp9290
g2
(lp9291
VThe first way will create a very real, not at all a "dummy object" for the
p9292
aVUnless there are other references to  below the last line of your code, the optimizer has enough information to let the environment garbage-collect  as soon as it's done with
p9293
aVThe fact that there is no variable for  does not make the object created by  less real
p9294
aVThe compiler will probably optimize both snippets into identical bytecode, too
p9295
as(dp9296
g6
V335858
p9297
stp9298
a((dp9299
g2
(lp9300
VThis result is heavily system-dependent
p9301
aVIt indicates that on your particular system copying a value of a reference (which is most likely implemented as a pointer) has higher cost than copying a value of an integer
p9302
aVThe most probable reason for that difference is that your integer requires 32-bits to represent, and your pointer/reference representation requires 64-bits
p9303
aVEDIT This is not to mention the cost of accessing your integers: getting their values would require an additional indirection
p9304
aVSince you are passing only two items, use of caching hides that additional cost to a large extent, but the cost is there
p9305
aVYou are absolutely right about larger types, though: passing a reference to, say, a large  or a  still requires only 64 bit (or whatever that size is on your system), regardless of how many items your structure has, or how many items your  holds
p9306
aVThe larger the structure, the higher the costs to pass it by value, and therefore the savings that you realize by making it a reference
p9307
as(dp9308
g6
V335858
p9309
stp9310
a((dp9311
g2
(lp9312
VIn 's , store the current  of your ; compare the stored value to the  in the  to determine if it was a zoom in or a zoom out
p9313
aVIf the value has increased, it was a zoom in; otherwise, it was a zoom out
p9314
as(dp9315
g6
V335858
p9316
stp9317
a((dp9318
g2
(lp9319
VThere are two major ways for a compiler to return a value:
p9320
aVPut a value in a register before returning, and
p9321
aVHave the caller pass a block of stack memory for the return value, and write the value into that block [more info]
p9322
aVThe #1 is usually used with anything that fits into a register; #2 is for everything else (large structs, arrays, et cetera)
p9323
aVIn your case, the compiler uses #1 both for the return of  and for the return of your function
p9324
aVOn Linux and Windows, the compiler did not perform any value-distorting operations on the register with the returned value between writing it into the pointer variable and returning from your function; on Mac, it did
p9325
aVHence the difference in the results that you see: in the first case, the left-over value in the return register happened to co-inside with the value that you wanted to return anyway
p9326
as(dp9327
g6
V335858
p9328
stp9329
a((dp9330
g2
(lp9331
VStart with replacing  with  in the opcode, resulting in
p9332
aVThen take the value corresponding to your register from the lookup table (A=111, B=000, C=001, and so on), and shift it left by 3 positions using  operator
p9333
aVFinally,  the two values together, like this:
p9334
aVDeclare this for use everywhere you need : A is at index 0, B is at index 1, then there are C, D, E, H, and L
p9335
aVFor , use this code:
p9336
as(dp9337
g6
V335858
p9338
stp9339
a((dp9340
g2
(lp9341
VNumbers that start in  are in hexadecimal (base 16) notation
p9342
aVThey use digits  for hex digits , and letters  for hex digits  through
p9343
aVHexadecimal notation is more convenient than decimal to show bit operations, because the base 16 is , so a digit corresponds to four bits; the results of bitwise operations are confined to a single digit; they do not "bleed" into adjacent digits
p9344
aVConversion table of binary to hex is as follows:
p9345
aVYou can convert a hex number to binary by direct replacement of digits using this table
p9346
aVFor example,  becomes  in binary
p9347
aVWith these substitution rules in hand, you can follow the text from the documentation in binary:
p9348
aV0xff00 & 0xf0f0 is: 0xf000
p9349
aVbecomes
p9350
aVIn binary it makes more sense: the result of a bitwise  is  only when both operands have  in the corresponding bit; otherwise, the result is
p9351
aVYou should be able to follow the remaining operations  and  more readily as well
p9352
as(dp9353
g6
V335858
p9354
stp9355
a((dp9356
g2
(lp9357
VIt should be the other way around:
p9358
aVreturns radians; it's this value that you need to convert to degrees, not the parameter  of the
p9359
as(dp9360
g6
V335858
p9361
stp9362
a((dp9363
g2
(lp9364
VUse negative numbers to left-align (i
p9365
ag630
aV"pad" to the right)
p9366
aVThis prints
p9367
as(dp9368
g6
V335858
p9369
stp9370
a((dp9371
g2
(lp9372
VThis is because when  is a pointer,  is the number of bytes required to store a pointer, not the size of the array, as in the code that you commented out
p9373
aVYou need to pass the size that you allocated (i
p9374
ag630
aV1024) instead, like this:
p9375
as(dp9376
g6
V335858
p9377
stp9378
a((dp9379
g2
(lp9380
VYou should get rid of , replacing it with a list of IDs, like this:
p9381
as(dp9382
g6
V335858
p9383
stp9384
a((dp9385
g2
(lp9386
VYou cannot cast it because  is not an object, just an alias for a built-in type
p9387
aVYou can always create a new  object from , of course:
p9388
aVEDIT : replaced  with
p9389
as(dp9390
g6
V335858
p9391
stp9392
a((dp9393
g2
(lp9394
VFrom Apple's documentation:
p9395
aVWhen the enumeration is done, enumerationBlock is invoked with group set to nil
p9396
aVWhen enumeration is done, your first block will see
p9397
as(dp9398
g6
V335858
p9399
stp9400
a((dp9401
g2
(lp9402
VYou are right, this is probably an error
p9403
aVHowever, Java compiler has no way of knowing that  method is a "pure function", i
p9404
ag630
aVproduces no side effects and is otherwise meaningless unless you keep its return value
p9405
as(dp9406
g6
V335858
p9407
stp9408
a((dp9409
g2
(lp9410
VThe question to which you are referring talks about generic cloning that works for anything that supports serialization
p9411
aVWhen you want cloning just for your specific object, simply implement
p9412
as(dp9413
g6
V335858
p9414
stp9415
a((dp9416
g2
(lp9417
VIn general, the answer is yes, you can easily get crashes all over the place
p9418
aVFor example, if one thread reads an element of a linked list while the other thread deletes it, you get undefined behavior (read: a crash)
p9419
aVThe easiest thing is to use mutex, but if you are up for some advanced techniques and got access to compare and swap operation, you can implement a lock-free linked list, but you should first profile your application to see that the speed improvement is worth your effort
p9420
as(dp9421
g6
V335858
p9422
stp9423
a((dp9424
g2
(lp9425
VYou can do it with just the standard cocoa classes, but the syntax gets somewhat ridiculous, and the amount of set-up is staggering too
p9426
aVA few pointers to note:
p9427
aVThe  in your expression became  so that you could reference it from the  dictionary
p9428
aVThe  became simply ; note the added method to support it
p9429
aVThere are no built-in trigonometric functions; see how  and a category is used to get around it
p9430
as(dp9431
g6
V335858
p9432
stp9433
a((dp9434
g2
(lp9435
VThere are two competing schools of thought on the need to test private methods - one says that you should not test them, because they are an implementation detail; the other says that you should test them, because you need to test everything
p9436
aVWithout getting in the middle of the argument between the two, I should mention that both sides have valid points going for their approach
p9437
aVHowever, one thing you should definitely avoid is making your would-be private methods public for the sole purpose of testing them
p9438
aVIf you decide to go with the "test private methods" approach, you should make these methods internal, not public, and let the testing assembly see the internal methods using the  attribute in your target assembly
p9439
as(dp9440
g6
V335858
p9441
stp9442
a((dp9443
g2
(lp9444
VYou could use  for each digit/symbol, and animate the movement of the images that yo display
p9445
aVUsing  there would be limited to letters and digits; with  you could add other typical slot-machine visuals, such as cherries, etc
p9446
as(dp9447
g6
V335858
p9448
stp9449
a((dp9450
g2
(lp9451
VNot throwing an exception is the normal course of action
p9452
aVYour test will successfully verify that an exception is not thrown
p9453
as(dp9454
g6
V335858
p9455
stp9456
a((dp9457
g2
(lp9458
VSince you are not modifying the outer dictionary, only the inner one, you need only one call to ; the other call should be :
p9459
as(dp9460
g6
V335858
p9461
stp9462
a((dp9463
g2
(lp9464
VUnless  is a compile-time constant expression,  is not a compile-time constant either
p9465
aVThe best way of making a two-dimensional array in C++ is using  of s, for example, like this:
p9466
as(dp9467
g6
V335858
p9468
stp9469
a((dp9470
g2
(lp9471
V is not a private variable of another class; it is a private variable of another instance of the same class
p9472
aVTherefore the access is completely legal
p9473
as(dp9474
g6
V335858
p9475
stp9476
a((dp9477
g2
(lp9478
VYou almost got it right -- the second nested  should be , not just a :
p9479
as(dp9480
g6
V335858
p9481
stp9482
a((dp9483
g2
(lp9484
VYou can use  to parse HEX
p9485
aVThis will avoid the need to cast it to  from an
p9486
as(dp9487
g6
V335858
p9488
stp9489
a((dp9490
g2
(lp9491
VAdd a non-static property covering the static string, and reference that property instead:
p9492
as(dp9493
g6
V335858
p9494
stp9495
a((dp9496
g2
(lp9497
VIf superscripted digits is all you want, the easiest thing would be to use the superscripted digits from Unicode
p9498
aVYou can put them in , and use in  without further modifications
p9499
aVIf you need more functionality, you can use  with
p9500
as(dp9501
g6
V335858
p9502
stp9503
a((dp9504
g2
(lp9505
VBecause small integers are interned in Java, and you tried the numbers on different sides of the "smallness" limit
p9506
as(dp9507
g6
V335858
p9508
stp9509
a((dp9510
g2
(lp9511
VReading from a member of the union other than the one most recently written to outside the "byte footprint" of the member to which you have most recently written leads to undefined unspecified behavior
p9512
aVYou should not be reading  until after you have written to it: Whatever you see there is non-portable junk
p9513
aVEDIT 1 Edited in response to Cristoph's comment
p9514
as(dp9515
g6
V335858
p9516
stp9517
a((dp9518
g2
(lp9519
VIf you ever need to return something more than a boolean, it is extremely likely that you are going to modify other parts of the interface as well
p9520
aVDo not make things more complex than they need to be: simplicity is prerequisite of reliability
p9521
as(dp9522
g6
V335858
p9523
stp9524
a((dp9525
g2
(lp9526
VCast  to a pointer to a  function that takes can be called with no parameters (the  part of the expression)
p9527
aVCall that function through a pointer with an empty parameter list (the  part after it)
p9528
aVEDIT 1: Edited in response to Cristoph's comment
p9529
as(dp9530
g6
V335858
p9531
stp9532
a((dp9533
g2
(lp9534
V(tongue in cheek) Every time you encounter a  statement in a C++ program, you know that you've missed an inheritance opportunity
p9535
aVThe two ways I know to refactor multiple parallel switches are (1) building a multi-dimension array of function pointers, and (2) using a variation of the visitor pattern
p9536
as(dp9537
g6
V335858
p9538
stp9539
a((dp9540
g2
(lp9541
VThere is no built-in Java-like way of initializing synthesized properties or ivars in Objective C
p9542
aVHowever, since your properties look almost identical, you might want to consider making them  instead of synthesizing them
p9543
aVFor sure, you would need to write two scary-looking methods (here is a nice and clean example for you), but in return you get a uniform way of storing your properties as objects inside
p9544
aVThis opens up several interesting alternatives not available with plain ivars: you could defer initialization of your properties until they are needed, you could provide default values for unset properties, or you could initialize your properties "wholesale" by filling in the dictionary with values for their keys
p9545
as(dp9546
g6
V335858
p9547
stp9548
a((dp9549
g2
(lp9550
VThis happens because both inclusions happen in the same compilation unit
p9551
aVYou can work around this problem by moving the inclusion of one of the enums into a separate compilation unit, at a cost of making the values of that enumerator non-compile-time constants (in fact, they become global variables)
p9552
aVIn pp_workaround
p9553
aVh:
p9554
aVIn pp_workaround
p9555
aVm:
p9556
aVNow you can include  instead of , and use  instead of
p9557
aVNot everything will work the same, but the compile-time error should be gone
p9558
aVEDIT If your code lets you import the conflicting headers only in your
p9559
aVm file, you can fix the problem (rather than working around it) by wrapping the connection code in an additional abstraction layer of your own, like this:
p9560
aVIn the paypal_init
p9561
aVh:
p9562
aVIn the paypal_init
p9563
aVm:
p9564
aVin the authnet_init
p9565
aVh:
p9566
aVin the authnet_init
p9567
aVm:
p9568
aVIn your main file:
p9569
as(dp9570
g6
V335858
p9571
stp9572
a((dp9573
g2
(lp9574
VYou can dereference it, it is just that the result is not going to be what you'd expect:  is not an , it's a pointer to an  (OK, a one-dimensional array)
p9575
aVIf you want to see  printed, add another star:
p9576
as(dp9577
g6
V335858
p9578
stp9579
a((dp9580
g2
(lp9581
VShort answer: because they use different instances of the  variable
p9582
aVLong answer: you should only declare  in the header, not define it
p9583
aVDefining should happen in the
p9584
aVm file, like this:
p9585
aVIn the mainViewController
p9586
aVh:
p9587
aVIn the mainViewController
p9588
aVm:
p9589
aVThe way your code is written, a separate  is created for each
p9590
aVm file that includes ; I am sure this is not what you intended
p9591
as(dp9592
g6
V335858
p9593
stp9594
a((dp9595
g2
(lp9596
VThe reason your code does not compile is that  is a pointer, not a reference; therefore, you need to use  operator instead of the  operator
p9597
as(dp9598
g6
V335858
p9599
stp9600
a((dp9601
g2
(lp9602
VThe argument of  and the first argument of  are interpreted differently: the former is just a character sequence, while the later is a regular expression
p9603
aVSince  is a meta-character of the Java's regexp language that cannot appear unescaped on its own (it must follow an expression being repeated zero or more times in the match), it is treated differently by the two methods
p9604
as(dp9605
g6
V335858
p9606
stp9607
a((dp9608
g2
(lp9609
VThe fact that it gives correct result is an artifact of the particular character encoding for digits and letters
p9610
aVYou should convert the numbers to ,  them, and convert back to :
p9611
aVEDIT (in response to Jon Skeet's comment): Using  instead of  to address the four-byte limit issue
p9612
as(dp9613
g6
V335858
p9614
stp9615
a((dp9616
g2
(lp9617
VI would go with number 1 or number 4
p9618
aVNumber 2 loses to number 4 in readability, and is not as self-explanatory as number 4, while number 3 reveals too much implementation
p9619
aVNumber three is a good thing to have as a private method hiding implementation details of your saving process
p9620
ag1971
ag1972
aVNumber 4 would be more appropriate if you expect to add other  values, say,  and
p9621
as(dp9622
g6
V335858
p9623
stp9624
a((dp9625
g2
(lp9626
VThis is probably shorter, but it might be slower:
p9627
as(dp9628
g6
V335858
p9629
stp9630
a((dp9631
g2
(lp9632
VSingleton introduces global state, and is often criticized as an anti-pattern because of that
p9633
aVA good old private static variable inside your class would probably do just fine, unless you must make that preprocessed data available to other parts of your system
p9634
as(dp9635
g6
V335858
p9636
stp9637
a((dp9638
g2
(lp9639
VYou can use back reference  to refer to the value of the matched expression:
p9640
aVFor example,
p9641
aVproduces
p9642
aVNote the excessive number of slashes in the replacement: I need to pass two backslashes to regexp (the first one escapes the second one), and for each one I must put two in order for the Java to do its own escaping, for the final count of four
p9643
as(dp9644
g6
V335858
p9645
stp9646
a((dp9647
g2
(lp9648
VYou can use lookahead and lookbehind
p9649
aVThe space before:
p9650
aVThe space after:
p9651
as(dp9652
g6
V335858
p9653
stp9654
a((dp9655
g2
(lp9656
VThis code suffers from multiple issues, all due to a single misunderstanding of pointers and their relation to arrays in C
p9657
aVYour  should be returning , not
p9658
aVHence, you should not be dereferencing  on the return line
p9659
aVYou should call  once and store its result, instead of calling it in a loop
p9660
aVYou need to call  on the result returned from
p9661
as(dp9662
g6
V335858
p9663
stp9664
a((dp9665
g2
(lp9666
VAssuming that the fields of  are  and , you can find a match using a loop, like this:
p9667
as(dp9668
g6
V335858
p9669
stp9670
a((dp9671
g2
(lp9672
VHere is one way:
p9673
aVThe expression matches 6 digits with an optional slash + one or two digits at the end
p9674
as(dp9675
g6
V335858
p9676
stp9677
a((dp9678
g2
(lp9679
VJava has a convenient  class which can store a virtually unlimited number of bits
p9680
aVWhen the number of bits is large, this representation makes sense
p9681
aVHowever, when the number of bits is relatively small, this representation would use more space than an integer
p9682
aVIf the number of bits is limited to 32, using  is going to be wasteful
p9683
aVWith only 20 bits you could potentially make an array of  sets, and avoid storing the keys altogether
p9684
aVBut this counts as premature optimization
p9685
aVA better way to approach this problem is to start with the most convenient representation for you, that fits your application design logically
p9686
aVWhen the application is working, profile its memory usage to determine if you need to optimize the representation of your bit sets; more likely than not, you wouldn't need to do anything about it, at least not right away
p9687
as(dp9688
g6
V335858
p9689
stp9690
a((dp9691
g2
(lp9692
VI think you should start over, and build an algorithm from this simple description:
p9693
aVPrepare a  of prime numbers that are less than or equal to 2^16
p9694
aVRun through this list from low to high, trying each prime in turn as a candidate divisor
p9695
aVEvery time you run into a working divisor, continually divide it out until you can no longer divide the number by it; then continue to the next prime
p9696
aVOnce you reach the end of the list of primes, your remaining number should be printed as well, unless it is equal to
p9697
aVFinding a list of primes is a fun problem in itself
p9698
aVDijkstra wrote a fascinating chapter on it back in 1972
p9699
aVThis article has a C++ implementation and a very nice discussion
p9700
as(dp9701
g6
V335858
p9702
stp9703
a((dp9704
g2
(lp9705
VI think you'd have easier time simply splitting the string at  using  method:
p9706
as(dp9707
g6
V335858
p9708
stp9709
a((dp9710
g2
(lp9711
VNo, accessing elements outside of the index range is undefined behavior
p9712
aVIn your case, the element at the address just prior to the beginning of your array is set to 27
p9713
aVSince accessing array elements in C is nothing more than doing "straight" pointer arithmetic, passing negative indexes is not disallowed
p9714
aVYou could construct a legitimate use case where indexes are negative and positive:
p9715
as(dp9716
g6
V335858
p9717
stp9718
a((dp9719
g2
(lp9720
VApart from the fact that  for POD-types does not zero-initializes the array, and  would write the terminating  past the end of the allocated area, everything looks fine: in particular,  will delete the entire block
p9721
aVThe reason for writing past the end of the allocated block is that the 10-character string  requires 11 bytes to store
p9722
as(dp9723
g6
V335858
p9724
stp9725
a((dp9726
g2
(lp9727
VThere are three major ways of dealing with mapping logical requirements like yours to DB tables - (1) using a single table for both users and admins, (2) using two separate tables, and (3) using three tables, one containing the common data among the two categories of users
p9728
aVThe first and the third ways are good for cases when customers and admins should sometimes be used interchangeably; the second way is better when it is not a concern
p9729
aVI prefer the #3, because it's the most normalized way of modeling the two kinds of users
p9730
as(dp9731
g6
V335858
p9732
stp9733
a((dp9734
g2
(lp9735
VApart from the  and  placement issue,  should be
p9736
aVA safer way would be to use  - the compiler would count the number of characters for you
p9737
as(dp9738
g6
V335858
p9739
stp9740
a((dp9741
g2
(lp9742
VYou need to add  to your implementation, and call CFRelease on  there:
p9743
as(dp9744
g6
V335858
p9745
stp9746
a((dp9747
g2
(lp9748
VApart from having an off-by-one possibility in case the number of bytes is odd (you'll miss the last byte) your code is OK
p9749
aVYou can optimize it by dropping the  array altogether, swapping  and  bytes before calling , and passing  as the starting index to the  method
p9750
as(dp9751
g6
V335858
p9752
stp9753
a((dp9754
g2
(lp9755
Vhow is passing a function pointer preferrable to putting a conditional inside the function myfunc
p9756
aVSometimes it is impossible to put a condition there: for example, if you are writing a sorting algorithm, and you do not know what you are sorting ahead of time, you simply cannot put a conditional; function pointer lets you "plug in" a piece of computation into the main algorithm without jumping through hoops
p9757
aVAs far as how the mechanism works, the idea is simple: all your compiled code is located in the program memory, and the CPU executes it starting at a certain address
p9758
aVThere are instructions to make CPU jump between addresses, remember the current address and jump, recall the address of a prior jump and go back to it, and so on
p9759
aVWhen you call a function, one of the things the CPU needs to know is its address in the program memory
p9760
aVThe name of the function represents that address
p9761
aVYou can supply that address directly, or you can assign it to a pointer for indirect access
p9762
aVThis is similar to accessing values through a pointer, except in this case you access the code indirectly, instead of accessing the data
p9763
as(dp9764
g6
V335858
p9765
stp9766
a((dp9767
g2
(lp9768
VTry this:
p9769
aVThis will truncate the sign portion of the  before adding it to CS, and ten truncate everything past the eight's bit once again to emulate unsigned addition
p9770
as(dp9771
g6
V335858
p9772
stp9773
a((dp9774
g2
(lp9775
Vso does the reason for using properties evaporate
p9776
aVWith ARC making the "ownership magic" available to ivars, this particular aspect of why one would choose properties over ivars does evaporate
p9777
aVHowever, many others remain:
p9778
aVatomic/nonatomic distinction is available for properties, not for ivars
p9779
aVflexibility afforded by properties (readonly/read+write distinction) is not available for ivars
p9780
aVability to perform calculation and argument checking is not available to ivars
p9781
aVI continue using properties as my default way of keeping state that may be exposed to outside classes or internal "sibling" classes, because additional flexibility more than outweighs the small additional cost at run-time
p9782
as(dp9783
g6
V335858
p9784
stp9785
a((dp9786
g2
(lp9787
VLeaving the merits of singleton pattern aside (there is a school of thought that describes it as an anti-pattern) it should not be necessary to subclass it to simply add static functionality
p9788
aVHere are language-specific approaches that I would prefer to subclassing a singleton:
p9789
aVUse a free-standing function enclosed in a C++ namespace
p9790
aVUse an extension class in C#
p9791
aVUse a helper class in Java
p9792
aVUse a Category in Objective-C
p9793
as(dp9794
g6
V335858
p9795
stp9796
a((dp9797
g2
(lp9798
VI think the problem is that in the interface builder your layout does not show at the same size, because it lacks the navigation bar at the top
p9799
aVIn the visual editor, choose the window hosting your table view, go to the , and choose  for the  entry in the  section of the inspector
p9800
aVThe layout of your design will change
p9801
aVResize your table view, move your button, rebuild the app, and run it again; this should do the trick
p9802
as(dp9803
g6
V335858
p9804
stp9805
a((dp9806
g2
(lp9807
VThis constraint comes from C standard's section 6
p9808
ag838
aV8/4, so it's not just your compiler:
p9809
aVAll the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals
p9810
aVThe reason for this is that unlike C++ standard, C sdoes not require execution environments to provide an entry point for pre-run initialization (while certainly not prohibiting it; The manner and timing of static initialization (5
p9811
ag1340
aV2) is unspecified)
p9812
as(dp9813
g6
V335858
p9814
stp9815
a((dp9816
g2
(lp9817
VThis depends on your logical model
p9818
aVIf you have an instance of a class implementing a protocol with optional methods, then using  is appropriate when you are trying to call one of these optional methods
p9819
aVIf you want the method you call to be required, create a do-nothing "guard" in the classes that you pass
p9820
aVBoth techniques are valid, it's only a matter of whether or not you'd like your users to be conscious of the need to implement a specific method
p9821
as(dp9822
g6
V335858
p9823
stp9824
a((dp9825
g2
(lp9826
VThis is because you pass  to , which is incorrect for C strings
p9827
aVYou should pass  instead, no ampersand
p9828
aVYou should also allocate sufficient space to store the values the users enter, and instruct  on the max size of the buffer
p9829
as(dp9830
g6
V335858
p9831
stp9832
a((dp9833
g2
(lp9834
VThe easiest way is to use LINQ:
p9835
as(dp9836
g6
V335858
p9837
stp9838
a((dp9839
g2
(lp9840
VYou can do it using reflection, but IMO it is too fragile: it introduces an invisible dependency on the name of the method that you call
p9841
aVA better approach would be to define a delegate based on your method, and store it in the struct/class instead of the method name
p9842
aVInstead of defining your own delegate types, you can use pre-defined ones based on  or , depending on your need to return values from the reports
p9843
as(dp9844
g6
V335858
p9845
stp9846
a((dp9847
g2
(lp9848
VThe code point that you are trying to encode does not fit in 16 bits
p9849
aVTherefore you need to use UTF-32 encoding:
p9850
as(dp9851
g6
V335858
p9852
stp9853
a((dp9854
g2
(lp9855
VYou can use  method to test each object with a block returning a
p9856
as(dp9857
g6
V335858
p9858
stp9859
a((dp9860
g2
(lp9861
VYou can get all classes from the  assembly using this little hack:
p9862
aVYou can further filter on it by  or  property
p9863
as(dp9864
g6
V335858
p9865
stp9866
a((dp9867
g2
(lp9868
VYou can loop through all non-indexed properties of an object like this:
p9869
aVSince  returns indexers as well as simple properties, you need an additional filter before calling  to know that it is safe to pass  as the second parameter
p9870
aVYou may need to modify the filter further in order to weed out write-only and otherwise inaccessible properties
p9871
as(dp9872
g6
V335858
p9873
stp9874
a((dp9875
g2
(lp9876
VYou can put your buttons into an array, like this:
p9877
aVDeclare an instance variable  in your header, then
p9878
aVNow all your buttons are in an array
p9879
aVYou can access them by index or in any other way that you may need, e
p9880
ag303
aVwith a fast enumeration loop
p9881
as(dp9882
g6
V335858
p9883
stp9884
a((dp9885
g2
(lp9886
VSince this is homework, there's a small hint:
p9887
aVThe reason that you do not act on a conflict that you detect is most likely because you ignore the return value of  that you call recursively from
p9888
aVThe problem of eight queens is explored in depth in this excellent work by E
p9889
aVW
p9890
aVDijkstra on page 72
p9891
aVIt's coded in ALGOL-60 (which become obsolete even before my time), but the ideas are language-agnostic
p9892
as(dp9893
g6
V335858
p9894
stp9895
a((dp9896
g2
(lp9897
VThe reason that you see the problem is that an array of strings cannot be used as a key in a dictionary without supplying a custom  or writing a wrapper around it
p9898
aVEDIT Here is a quick and dirty implementation of a custom comparer:
p9899
aVHere is how you can use it:
p9900
as(dp9901
g6
V335858
p9902
stp9903
a((dp9904
g2
(lp9905
VNo, adding methods does not increase the footprint of the object, only the footprint of the compiled code
p9906
aVIn other words, the per-instance memory cost is zero
p9907
as(dp9908
g6
V335858
p9909
stp9910
a((dp9911
g2
(lp9912
VYou can do it like this:
p9913
aVThe idea is to keep a separate read and write pointers ( for reading and  for writing), always advance the reading pointer, and advance the writing pointer only when it's not pointing to a given character
p9914
as(dp9915
g6
V335858
p9916
stp9917
a((dp9918
g2
(lp9919
VTry putting  inside a nested query, like this:
p9920
as(dp9921
g6
V335858
p9922
stp9923
a((dp9924
g2
(lp9925
Vhow you can tackle recursion without having to trace every single method call
p9926
aVThere are several ways of "understanding" recursive programs - one involves thinking of a recursive call as a black box, and the other requires "playing out" a few cases and guessing the pattern
p9927
aVThe first method assumes that the recursive method is already written, and that it does some known thing
p9928
aVThis is useful when you think of recursive descent parsers; it is not that good for programs that produce output (as opposed to consuming input), such as yours
p9929
aVThe second method is more applicable to programs similar to your example
p9930
aVPlay it out for values 0, 1, 2, and 3
p9931
aVDid you notice the pattern
p9932
aVThe output for  lists outputs for  prior items, and prints  at the end
p9933
aVOnce you think that you can continue the pattern, you know that you have an understanding of your recursive program
p9934
as(dp9935
g6
V335858
p9936
stp9937
a((dp9938
g2
(lp9939
VJava and C are different languages
p9940
aVWhat's allowed in standard C only as dynamic allocations (/) is allowed in Java by default, because all array allocations in Java are dynamic anyway; the concept of explicit stack allocation is missing from Java
p9941
as(dp9942
g6
V335858
p9943
stp9944
a((dp9945
g2
(lp9946
VThe standard trick is to use a proxy (or surrogate) design pattern
p9947
aVThe idea is to return a temporary object enclosing your target pointer that supports both a conversion to  pointer and an assignment of  that forwards the assignment to the target pointer
p9948
aVScott Meyer has a discussion of this pattern in his  book
p9949
as(dp9950
g6
V335858
p9951
stp9952
a((dp9953
g2
(lp9954
VYou found one standard solution
p9955
aVThe other solution that works would be to call ToList on the LINQ operation that produces your keys object: doing so would disconnect keys from instanceroles collection, allowing for arbitrary independent modifications on the original collection
p9956
as(dp9957
g6
V335858
p9958
stp9959
a((dp9960
g2
(lp9961
VIt does return a member pointer
p9962
aVYou can use it to access  indirectly, as follows:
p9963
aVThis code works in a context where  is accessible, for example in a member function
p9964
aVThis example is not too interesting, because your class does not have other members of type
p9965
aVIn situations where multiple such members exist, member pointers become more valuable: you can postpone the binding to a particular member to run-time
p9966
as(dp9967
g6
V335858
p9968
stp9969
a((dp9970
g2
(lp9971
VYou need to sort the indexes that you would like to return from largest to smallest in order to avoid removing something at the wrong index
p9972
aVHere is why: let's say have a list of five items, and you'd like to remove items at indexes  and
p9973
aVIf you remove the item at  first, the item that was at index  would be at index , and index  would no longer be in the list at all (causing your exception)
p9974
aVIf you go backwards, all indexes would be there up to the moment when you're ready to remove the corresponding item
p9975
as(dp9976
g6
V335858
p9977
stp9978
a((dp9979
g2
(lp9980
VTry using specific column lists instead of wildcard  to ensure that the individual sets can be -ed
p9981
as(dp9982
g6
V335858
p9983
stp9984
a((dp9985
g2
(lp9986
VYou are correct, since  is declared as , assigning  would make a copy of the string passed in
p9987
aVI am not certain that copying would go through exactly the same code path as the , but it would achieve the same purpose of creating a copy of the original string, shielding you from unexpected consequences of users passing in a mutable object and mutating its value behind your back
p9988
as(dp9989
g6
V335858
p9990
stp9991
a((dp9992
g2
(lp9993
VYou can do it like this:
p9994
aVThis works because  supports initialization from  through this constructor
p9995
aVIf you need to do additional preparations on the elements of , you could use LINQ and add a
p9996
aVThe example below adds single quotes around each element:
p9997
as(dp9998
g6
V335858
p9999
stp10000
a((dp10001
g2
(lp10002
VYou have a nearly OK version of the Selection Sorter
p10003
aVYou need to start your  at , not at
p10004
aVOtherwise you're re-scanning the sorted portion of the array
p10005
aVYou should also note that selection sort is an in-place algorithm; if you are looking to make a copy of the array, you should use  method, otherwise  is creating an alias, not a copy
p10006
aVFinally, the  statement in the nested loop should swap  and , not simply put  in:
p10007
as(dp10008
g6
V335858
p10009
stp10010
a((dp10011
g2
(lp10012
VTake a look at the  function
p10013
aVIt lets you find a pointer to the first occurrence of a specific string (say, ) inside another string
p10014
aVOnce you have two pointers (to the beginning and to the end of your string) you can allocate enough memory using  (don't forget the terminating zero ), use  to copy the characters, and finally zero-terminate your string
p10015
as(dp10016
g6
V335858
p10017
stp10018
a((dp10019
g2
(lp10020
VYou need to mark  as  in the header to make it a declaration, and provide a definition for it in one of the cpp files
p10021
aVOtherwise, the variable is declared in each compilation unit where the header is included, which is not the effect you are looking for
p10022
ag1971
ag1972
aVI assume that you know why global variables are not good, right
p10023
as(dp10024
g6
V335858
p10025
stp10026
a((dp10027
g2
(lp10028
V57 is ASCII for the digit
p10029
aVAssuming that by the "value of the char" you mean "the numeric value of the digit the char represents", you can use the simple trick available in ASCII:
p10030
aVThis trick works, because all digits are encoded in order starting with the digit zero (ASCII code 48)
p10031
aVSo when you subtract  (which is another way to write 48) from 57, you get 9, the value of the digit
p10032
as(dp10033
g6
V335858
p10034
stp10035
a((dp10036
g2
(lp10037
VYou can use  with a custom comparator of pairs that ignores small differences in the values, like this:
p10038
as(dp10039
g6
V335858
p10040
stp10041
a((dp10042
g2
(lp10043
VI think the problem is not in your implementation, but rather in your analysis of the problem
p10044
aVand  are not first-class actors, they are roles of the actors
p10045
aVIf you model them as such, you'd get a somewhat cleaner model:
p10046
aVYou'd have a person table with addresses and so on
p10047
aVYou'd also have an address table with addresses of the people
p10048
aVYou'd also have a person_role table, with the role code (donor, recipient) and other relevant information
p10049
aVYou may want to get fancy, and add  and , with a foreign key into the  table
p10050
as(dp10051
g6
V335858
p10052
stp10053
a((dp10054
g2
(lp10055
VA common idiom to express a "forever" loop in C and other C-like languages, including Objective-C, is to use an empty :
p10056
as(dp10057
g6
V335858
p10058
stp10059
a((dp10060
g2
(lp10061
VThis is because  class is an inner class of , but not a static inner class
p10062
aVOnly static inner classes can be instantiated without an "enclosing" instance context; non-static need a "parent" instance
p10063
aVIf  does not need to use any of the 's state, declare it ; otherwise, add an instance method to  and instantiate  from there
p10064
ag1971
ag1972
aVI am assuming that you are accessing  from the same package, because it has package visibility
p10065
aVIf this is not intentional, you will need to make the class  as well
p10066
aVEDIT This is how you add an instance method to  returning :
p10067
aVNow outside  you can do this:
p10068
as(dp10069
g6
V335858
p10070
stp10071
a((dp10072
g2
(lp10073
VSince the cases are not mutually exclusive, you need three separate cases:
p10074
as(dp10075
g6
V335858
p10076
stp10077
a((dp10078
g2
(lp10079
VTry this:
p10080
as(dp10081
g6
V335858
p10082
stp10083
a((dp10084
g2
(lp10085
VI think the loop should be as follows:
p10086
aVThe change is  instead of
p10087
as(dp10088
g6
V335858
p10089
stp10090
a((dp10091
g2
(lp10092
VThe code you tried (from the comment) should have worked
p10093
aVThe reason it did not work is that your  was
p10094
aVYou need to initialize your  - set it to  in the initializer; then your code
p10095
aVwill work perfectly
p10096
aVYou do not even need the first line - the second one replaces the content of  with that of the
p10097
as(dp10098
g6
V335858
p10099
stp10100
a((dp10101
g2
(lp10102
VTry this:
p10103
as(dp10104
g6
V335858
p10105
stp10106
a((dp10107
g2
(lp10108
VThe best approach would be to code your own implementation of Binary Search for the buffers
p10109
aVThis approach carefully avoids potential performance hits associated with creating views, copying large arrays etc
p10110
aV, and stays compact at the same time
p10111
aVThe code sample at the link returns the rightmost point; you need to replace  with  on the  line to get the leftmost point
p10112
aVThis saves you potentially costly backward linear search, or using a "backward" , which requires wrapping your  into  objects
p10113
as(dp10114
g6
V335858
p10115
stp10116
a((dp10117
g2
(lp10118
VAssuming that  pairs are in a dictionary/map, you can find max depth using memoization technique:
p10119
aVMain function (pseudocode):
p10120
aVRecursive depth function:
p10121
as(dp10122
g6
V335858
p10123
stp10124
a((dp10125
g2
(lp10126
VNo, it wouldn't be efficient, because you wouldn't know the carry for bit  until you've processed all bits through
p10127
aVThis is the problem solved by carry look-ahead adders in hardware
p10128
aVThere is no way to implement addition of BitSets in a way that does not involve examining all their bits one-by-one in the worst case
p10129
aVAn alternative strategy depends a lot on your specific requirements: if you mutate your bit sets a lot, you may want to roll your own, based on Sun's Oracle's implementation
p10130
aVYou can shamelessly copy borrow their code, and add an implementation of  that operates on the "guts" of the , stored as
p10131
aVYou'll need to be very careful dealing with overflows (remember, all numbers in Java are signed), but otherwise it should be rather straightforward
p10132
as(dp10133
g6
V335858
p10134
stp10135
a((dp10136
g2
(lp10137
VYou can do this:
p10138
aVIt would be somewhat more complex if the second string allowed : you would need to check for it, and move it to the back of the string if it is present before enclosing your character set in square brackets
p10139
as(dp10140
g6
V335858
p10141
stp10142
a((dp10143
g2
(lp10144
VYou did not escape the dot  and the question mark  meta-characters
p10145
as(dp10146
g6
V335858
p10147
stp10148
a((dp10149
g2
(lp10150
VThe assignment on line 27  should be
p10151
aVThere is a missing semicolon after  on line 6
p10152
aVThere is a missing coma after the string literal on line 13:
p10153
as(dp10154
g6
V335858
p10155
stp10156
a((dp10157
g2
(lp10158
VThis line
p10159
aVshould be
p10160
aVSince you are allocating an array of , you need to replace the flexible array member with a pointer:  should be changed to
p10161
as(dp10162
g6
V335858
p10163
stp10164
a((dp10165
g2
(lp10166
VThe quoted doc warns you that you should not assume that  is implemented as
p10167
aVin the  header, that's all
p10168
aVObviously, an include file may contain things other than  in it; in this case, the implementors took precautions to make  behave in thread-safe way, but that's an unnecessary detail
p10169
aVThe truly must-know thing is that you must include
p10170
aVIf you are really curious about the details, bring up your  in an editor, and take a look
p10171
aVHowever, you need to remember that implementations on other systems may (and often will) be different
p10172
as(dp10173
g6
V335858
p10174
stp10175
a((dp10176
g2
(lp10177
VNot only is your query incorrect, but it may also open you to SQL Interjection Attacks
p10178
aVYou need to parameterize your query by replacing the pasted-in values with question marks, preparing the statement, and executing it
p10179
aVSee the tutorial that I linked
p10180
aVFinally, storing a password as plain text is a very, very bad idea
p10181
as(dp10182
g6
V335858
p10183
stp10184
a((dp10185
g2
(lp10186
VThis is because you got fancy with your  operators
p10187
aVInstead of  you should use
p10188
aVThe expression  adds  to , and leaves it there
p10189
aVYour  access different array elements, and then you've got  in the loop header to advance your index even further from where it should be
p10190
as(dp10191
g6
V335858
p10192
stp10193
a((dp10194
g2
(lp10195
VConsider re-structuring your program as a simple Recursive Descent Parser
p10196
aVFirst, you need to change the  function to take a  to be parsed, and the current position from which to start the parse, passed by reference
p10197
aVThis way you can structure your code so that when you see a  you call the same function at the next position get a  back, and consume the closing
p10198
aVWhen you see a  by itself, you return without consuming it
p10199
aVThis lets you consume formulas with unlimited nesting of  and , although I am not sure if it is necessary (it's been more than 20 years since the last time I saw a chemical formula)
p10200
aVThis way you'd write the code for parsing composite only once, and re-use it as many times as needed
p10201
aVIt will be easy to supplement your reader to consume formulas with dashes etc
p10202
aV, because your parser will need to deal only with the basic building blocks
p10203
as(dp10204
g6
V335858
p10205
stp10206
a((dp10207
g2
(lp10208
VYou're almost right: this code sets the third bit of the second byte
p10209
aV, and
p10210
aVEverything is off by one, so 10 means "bit number eleven", 1 means "second byte", hence setting the third bit of the second byte is correct for the argument of 10
p10211
as(dp10212
g6
V335858
p10213
stp10214
a((dp10215
g2
(lp10216
VThis is because
p10217
aVNET strings are immutable;  returns a new string, rather than modifying an existing one
p10218
aVIf you need to modify the string, add an assignment, like this:
p10219
aVThis should be equivalent to
p10220
as(dp10221
g6
V335858
p10222
stp10223
a((dp10224
g2
(lp10225
VThis code is not doing what you described: instead of taking the second byte in its entirety, it cuts out its last seven bits (the  part;  is binary ), and concatenates them to the two last two bits of the first number (the  part)
p10226
as(dp10227
g6
V335858
p10228
stp10229
a((dp10230
g2
(lp10231
VTry using  instead of , for example as follows:
p10232
as(dp10233
g6
V335858
p10234
stp10235
a((dp10236
g2
(lp10237
VThe displayed text is always "0%"
p10238
aVThis is because you are not casting the float to integer: you are passing a float to an unsuspecting function expecting an integer
p10239
aVYou should add a cast:
p10240
as(dp10241
g6
V335858
p10242
stp10243
a((dp10244
g2
(lp10245
VAny object declared inside a  and  block is destructed upon exiting that block, regardless of the use of that block as part of a composite statement (e
p10246
ag303
aVa body of a  loop)
p10247
aVAll pointers to such objects become invalid as well
p10248
aVEDIT as 0A0D correctly pointed out, the lifetime of objects created with  is controlled explicitly; they would survive exits from a block, but they also need to be deleted manually
p10249
as(dp10250
g6
V335858
p10251
stp10252
a((dp10253
g2
(lp10254
Vwhen the pointer function is called does the loop wait for that function to end its execution and then continue looping or does the loop continue to call functions while the first function is running
p10255
aVIn this respect the call through a pointer is not different from a call of a named function: they both complete synchronously, i
p10256
ag630
aVthe caller waits for the function to return
p10257
aVThe most likely reason has to do with console buffering information, which may result in significant delays displaying what's queued
p10258
as(dp10259
g6
V335858
p10260
stp10261
a((dp10262
g2
(lp10263
VThe list of interfaces a C# class implements is flattened, so when a class implements an interface by virtue of inheriting it through multiple interfaces that it implements, the number of implementations the class needs to provide remains one
p10264
aVFor example, if a class implements two interfaces both of which inherit from , that class still needs to implement  only once
p10265
aVThis is in contrast to C++, where functions that are inherited from the same base class through multiple paths of non-virtual inheritance need to be overriden separately
p10266
aVExtension methods are orthogonal to this issue, because the implementations they provide cannot be overriden
p10267
aVI wrote a blog post on extension methods and their role in sharing implementation "horizontally"
p10268
aVI view them as a mechanism of providing functionality in a way entirely independent of the "vertical" implementation sharing that you get through class inheritance
p10269
as(dp10270
g6
V335858
p10271
stp10272
a((dp10273
g2
(lp10274
VYour  function is not declared , so when you call
p10275
aVthe compiler tells you that you are calling a non-const function from inside a  function
p10276
aVThere are several ways to deal with this - one is to make  const; the other is to make  static (if you can)
p10277
as(dp10278
g6
V335858
p10279
stp10280
a((dp10281
g2
(lp10282
VI think this is because you call  instead of  - an innocent autocompletion bug
p10283
as(dp10284
g6
V335858
p10285
stp10286
a((dp10287
g2
(lp10288
VThe first option uses Automated Reference Counting (ARC); the second one does not
p10289
aVNeither one is "more correct" than the other - the first one is simply more modern
p10290
aVYou should use ARC unless you have strong reasons not to (e
p10291
ag303
aVbecause of the need to support legacy code on legacy platforms)
p10292
aVHere is a link to learn more about ARC
p10293
as(dp10294
g6
V335858
p10295
stp10296
a((dp10297
g2
(lp10298
VThis is because your expression requires the strings with ,  and  to end right there ( matches the end of input)
p10299
aVRemove the  from these sub-expressions, and move it to the end of the expression
p10300
as(dp10301
g6
V335858
p10302
stp10303
a((dp10304
g2
(lp10305
VI do not think that you are doing anything wrong: although the whole code can be folded to a single line like this
p10306
aVI know people who prefer to see it on multiple lines
p10307
aVThe compiler should figure out all necessary optimizations related two writing back to  "unnecessarily", so I think you're good
p10308
as(dp10309
g6
V335858
p10310
stp10311
a((dp10312
g2
(lp10313
VYou can use ticks of the original timespan:
p10314
as(dp10315
g6
V335858
p10316
stp10317
a((dp10318
g2
(lp10319
VOne example that comes to my mind is Harvard architecture with separate address spaces for code and for data
p10320
aVIn computers of that architecture the compiler can store constant data in the code memory
p10321
aVSince the two address spaces are separate, a pointer to an address in the code memory could be numerically equal to a pointer in the data memory, without pointing to the same address
p10322
as(dp10323
g6
V335858
p10324
stp10325
a((dp10326
g2
(lp10327
VTo answer the original question about the display settings, I'd try this:
p10328
aVIf  is , I would use Celsius; otherwise, I'd use Fahrenheit
p10329
as(dp10330
g6
V335858
p10331
stp10332
a((dp10333
g2
(lp10334
VYou can do this using methods of the  class:
p10335
as(dp10336
g6
V335858
p10337
stp10338
a((dp10339
g2
(lp10340
VYour algorithm is unnecessarily complex - all you need is a loop and a counter
p10341
aVCheck the initial character for  (you already do that)
p10342
aVSet the counter to zero, and go through each character one by one
p10343
aVIf the character is not a letter or a parentheses, return false
p10344
aVIf the character is an opening , increment the counter
p10345
aVIf the character is a closing , decrement the counter; if the counter is less than zero, return false
p10346
aVReturn  if the count is zero after the loop has ended; otherwise return
p10347
as(dp10348
g6
V335858
p10349
stp10350
a((dp10351
g2
(lp10352
V has a  method that would block the consumer if there is nothing to take, and wait for a producer side to provide an item
p10353
aVlacks such method - if it is empty, the consumer would need to handle the wait, and the producer would need to provide a non-empty notification
p10354
as(dp10355
g6
V335858
p10356
stp10357
a((dp10358
g2
(lp10359
VBoth sides of a conditional operator must be compatible in order to participate in the same ternary operation
p10360
aVAccording to Java Language Specification 15
p10361
aV25, in your case
p10362
aVbinary numeric promotion (5
p10363
ag837
aV2) is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands
p10364
aVGenerally, there is a long list of rules the language follows to arrive at the result type of the ternary conditional operator
p10365
aVPlease read the language specifications if you need more details
p10366
as(dp10367
g6
V335858
p10368
stp10369
a((dp10370
g2
(lp10371
VAn insert statement works on a single table; you need two separate insert statements - one for each table
p10372
aVIf you would like both inserts to either succeed or to fail (as opposed to one succeeding and one failing) you should execute both statements in a single transaction
p10373
as(dp10374
g6
V335858
p10375
stp10376
a((dp10377
g2
(lp10378
VDoing it the second way is dangerous, because it breaks symmetric property of the equality
p10379
aVJava expects implementations of  to be reflexive, symmetric, and transitive
p10380
aVSecond implementation breaks symmetry: if you compare  to a  representing it's ID you'd get , but if you compare the string to the user, you will get a
p10381
as(dp10382
g6
V335858
p10383
stp10384
a((dp10385
g2
(lp10386
VI assume that you would like to solve this one by yourself, so I will give you a hint: this problem has optimal substructure
p10387
aVImagine that you have both solutions for  coins (without the leftmost one and without the rightmost one)
p10388
aVWould it be easy to calculate a solution for  coins then
p10389
aVYou can use two related techniques to exploit this property - dynamic programming and its subtype called memoization
p10390
aVThe idea is to store a solution to each sub-problem with  coins missing from the left and  coins missing from the right (use an  array for it)
p10391
aVBefore solving a sub-problem, check the array to see if you've already solved it
p10392
aVYou would need to solve at most  subproblems to arrive at a solution
p10393
aVHere is pseudocode for a memoized solution:
p10394
aVI remember TopCoder running this problem some time in early 2005 or 2006, but I do not remember enough details to search their problem archive
p10395
as(dp10396
g6
V335858
p10397
stp10398
a((dp10399
g2
(lp10400
VYou can use  function of
p10401
as(dp10402
g6
V335858
p10403
stp10404
a((dp10405
g2
(lp10406
VThis preprocessor macro has a single replacement split across multiple lines
p10407
aVThe  at the end of the line lets you write a single "logical" line on multiple lines of text
p10408
aVEverything that follows  will be placed in the text of the program when  pattern is matched; presumably, both these definitions will be further processed by the preprocessor, because they look like references to other macro definitions
p10409
as(dp10410
g6
V335858
p10411
stp10412
a((dp10413
g2
(lp10414
VSince your  value can be used as a unique key, you could potentially create an  on the side, populate it with  objects from the first array using  value as the key, go through the second array, do the overwrites, and finally harvest the values of the resultant  into your final output
p10415
aVNote that this approach might be helpful only if your arrays are relatively long (1000+ items)
p10416
aVIf you deal with 10
p10417
aV100 items, I wouldn't bother, and code two nested loops as you suggested
p10418
as(dp10419
g6
V335858
p10420
stp10421
a((dp10422
g2
(lp10423
VIf this is all your uses of  in that fragment of code, it is indeed pointless
p10424
aVIf you continue appending after the initial call to , then it is not entirely pointless
p10425
aVYour last example makes a lot more sense than the first two, though
p10426
aVI am assume that constants in your post are only for clarity
p10427
aVIf they are indeed constants, the compiler will do constant folding, making the first example equivalent to
p10428
as(dp10429
g6
V335858
p10430
stp10431
a((dp10432
g2
(lp10433
VIt is valid to use conditional as an lval in C++, but not in C
p10434
aVIn C++ (ISO
p10435
aVIEC 14882:1998(E) 5
p10436
aV16
p10437
aV4)
p10438
aVIf the second and third operands are lvalues and have the same type, the result is of that type and is an lvalue
p10439
aVIf you would like to use similar trick in C, you should use pointers:
p10440
aVISO/IEC 9899:TC2, 6
p10441
aV5
p10442
aV14
p10443
ag837
aVIf both the second and third operands are pointers or one is a null pointer constant and the other is a pointer, the result type is a pointer to a type qualified with all the type qualifiers of the types pointed-to by both operands
p10444
as(dp10445
g6
V335858
p10446
stp10447
a((dp10448
g2
(lp10449
VYou get the exception because there is no exact representation of the result of the division
p10450
aVIn order to work around this problem, you need to use the overload with the scale and rounding mode, like this:
p10451
aVHere is your modified code on ideone
p10452
as(dp10453
g6
V335858
p10454
stp10455
a((dp10456
g2
(lp10457
VYour use of  appears inconsistent with its declaration
p10458
aVFrom the way you use the  field it appears that  was intended as an array of  structs, not an array of arrays of  structs
p10459
aVIf this is the case, change your declaration to this:
p10460
aVThen change your usage as follows:
p10461
aVOf course this assumes that  is four or more
p10462
as(dp10463
g6
V335858
p10464
stp10465
a((dp10466
g2
(lp10467
VThis is because you are sorting numbers lexicographically (i
p10468
ag630
aVas if they were words)
p10469
aVYou should provide your own implementation of the sort comparer that converts strings to integers, and only then compares them for ordering
p10470
as(dp10471
g6
V335858
p10472
stp10473
a((dp10474
g2
(lp10475
VWell, your schema is somewhat unorthodox (to say the least), but it's doable:
p10476
as(dp10477
g6
V335858
p10478
stp10479
a((dp10480
g2
(lp10481
VThere is a problem in your  code that may or may not be the cause of your crash, but should definitely be fixed: when you recursively remove  or  that results in deleting the node, you should also set the  or  pointer in the parent to ; otherwise you open up your code to errors associated with dangling pointers
p10482
as(dp10483
g6
V335858
p10484
stp10485
a((dp10486
g2
(lp10487
VTry using this comparison instead:
p10488
as(dp10489
g6
V335858
p10490
stp10491
a((dp10492
g2
(lp10493
VFrom your description it sounds like you are looking for a pointer to a pointer
p10494
aVarrays may have different number of elements, as determined by the value returned by the  function
p10495
as(dp10496
g6
V335858
p10497
stp10498
a((dp10499
g2
(lp10500
VC standard section 5
p10501
ag1340
ag1340
aV2 defines nine phases of C translation
p10502
aVPreprocessing phase is number 4; keywords are recognized as such only in the phase 7; before that phase all keywords are considered regular preprocessing tokens
p10503
aVSee the standard for further details
p10504
aVkeyword: one of
p10505
aVauto break case [
p10506
aVThe above tokens (case sensitive) are reserved (in translation phases 7 and 8) for use as
p10507
aVkeywords, and shall not be used otherwise
p10508
as(dp10509
g6
V335858
p10510
stp10511
a((dp10512
g2
(lp10513
VYou are missing
p10514
aVat the top of your
p10515
aVh file
p10516
as(dp10517
g6
V335858
p10518
stp10519
a((dp10520
g2
(lp10521
VYou should use  instead of
p10522
as(dp10523
g6
V335858
p10524
stp10525
a((dp10526
g2
(lp10527
VUnless I am missing something, the formula you are looking for is
p10528
aVThe idea is to multiply the sum which is computed with this formula  and a multiplier of your choice by adding  outside the first formula
p10529
aVAn extra set of parentheses prevents Excel from parsing the formula correctly
p10530
as(dp10531
g6
V335858
p10532
stp10533
a((dp10534
g2
(lp10535
VThis may not be the only issue, but you are not zero-terminating the string that you pass to
p10536
aVThe  character in the third position of  may be garbage, because you never wrote to that position of the array
p10537
aVTo address this issue, you should add this line before the call of :
p10538
as(dp10539
g6
V335858
p10540
stp10541
a((dp10542
g2
(lp10543
VIt looks like you are looking for a 2D array 1000 by 64
p10544
aVIf this is indeed the case, you can do this:
p10545
aVThis uses the standard trick of preventing the array from decaying into a pointer
p10546
as(dp10547
g6
V335858
p10548
stp10549
a((dp10550
g2
(lp10551
VThe  condition is not correct, because it tries to compare a single value to a set; this is precisely what the error is trying to tell you
p10552
aVTry this instead:
p10553
as(dp10554
g6
V335858
p10555
stp10556
a((dp10557
g2
(lp10558
VThis is required by the C language standard
p10559
aVAccording to section 6
p10560
ag838
ag839
aV1 part 4:
p10561
aVA bit-\ufb01eld shall have a type that is a quali\ufb01ed or unquali\ufb01ed version of _Bool, signed int, unsigned int, or some other implementation-de\ufb01ned type
p10562
as(dp10563
g6
V335858
p10564
stp10565
a((dp10566
g2
(lp10567
VYou should use a parameterized statement
p10568
aVTry using this code instead:
p10569
as(dp10570
g6
V335858
p10571
stp10572
a((dp10573
g2
(lp10574
VC does not provide a built-in way to find the size of dynamically allocated chunks of memory
p10575
aVYou have to store the size, and pass it "on the side"
p10576
aVOne way to address this would be to create a  combining a pointer and a  value describing the number of elements allocated in the array
p10577
as(dp10578
g6
V335858
p10579
stp10580
a((dp10581
g2
(lp10582
VYour  code expects the array to be terminated by zero
p10583
aVThe calling code is not doing it, so the behavior is unspecified (I got segfault when I tried your code)
p10584
aVThe other issue is that you should put parentheses around :
p10585
aVWhen I run your code with this modification and enter zero for the last element, your code runs fine
p10586
as(dp10587
g6
V335858
p10588
stp10589
a((dp10590
g2
(lp10591
VYou need to take the address of  because the function needs to modify it
p10592
aVis passed by pointer, so you need the "take address" operator  for it
p10593
aVC and Objective-C pass parameters by value
p10594
aVIf you pass  without an ampersand and the method that you call modifies it, your function that made the call would not see any changes, because the method would operate on its local copy of
p10595
aVYou know that you need an ampersand in front of the corresponding parameter if you look at the signature of the method and see  there:
p10596
as(dp10597
g6
V335858
p10598
stp10599
a((dp10600
g2
(lp10601
V and  cannot use s and other non-id objects as keys or values, so the cast is not going to work
p10602
aVMost likely the values are of type , so you need to call  on them:
p10603
as(dp10604
g6
V335858
p10605
stp10606
a((dp10607
g2
(lp10608
VEclipse asks you to add  to all serializable classes
p10609
aVSince JFrame implements , your class does too, hence it should have a
p10610
aVNote that it is not required, only strongly suggested
p10611
as(dp10612
g6
V335858
p10613
stp10614
a((dp10615
g2
(lp10616
VYour way of building a string of length N is very inefficient
p10617
aVYou should either use  with its convenient  method, or build an array of  characters, and use the corresponding constructor of the
p10618
as(dp10619
g6
V335858
p10620
stp10621
a((dp10622
g2
(lp10623
VIf you do not mind duplicate student names with multiple accepted tests, you can try doing it with :
p10624
as(dp10625
g6
V335858
p10626
stp10627
a((dp10628
g2
(lp10629
VYou do not need a ternary operator for something that involves a Boolean:
p10630
aVIf you wanted to return, say, an integer, you could do it with a ternary conditional operator like this:
p10631
as(dp10632
g6
V335858
p10633
stp10634
a((dp10635
g2
(lp10636
VThis is because when you call a function in C or C++, arrays decay to pointers
p10637
aVIn the first case, the compiler sees  as an array; in the second case, all it sees is a pointer to a pointer
p10638
as(dp10639
g6
V335858
p10640
stp10641
a((dp10642
g2
(lp10643
VI think you misunderstood the 5 of the first iteration: it must be coming from somewhere else
p10644
aVis figured out at compile time - it is the size of , so you should see 32 on every iteration
p10645
aVIf you are looking for the length of the string, use  instead
p10646
as(dp10647
g6
V335858
p10648
stp10649
a((dp10650
g2
(lp10651
VThe storyboard part is somewhat irrelevant: the standard way of achieving this in cocoa is to define a singleton object as your model, share its header among the controllers defined in your application (through storyboard or otherwise) and create an instance of your shared model in the application start-up code
p10652
aVFor information on implementing singletons in Objective C read this link
p10653
as(dp10654
g6
V335858
p10655
stp10656
a((dp10657
g2
(lp10658
VOn your last point, you definitely need to be a lot more careful about resource management in C++ than in Java
p10659
aVIn particular, you need to decide when an object is no longer needed
p10660
aVReturning by reference has an effect of aliasing to the returned object
p10661
aVIt is not noticeable when the object you are sharing is immutable, but unlike Java's Strings, C++ string are mutable
p10662
aVTherefore if you return  by value and then rename your , the caller would see the old name even after the renaming
p10663
aVIf you return by reference, however, the caller will see a change as soon as  is renamed
p10664
aVWhen you deal with copying complex objects, you can decide how much is copied by providing a custom implementation of a copy constructor
p10665
aVIf you decide to provide a copy constructor, don't forget the rule of three, and override the other two
p10666
as(dp10667
g6
V335858
p10668
stp10669
a((dp10670
g2
(lp10671
VIt does not look like you need a dictionary: a simple LINQ expression should give you a list of items with no duplicates:
p10672
aVIf you insist on having a dictionary, you can use  instead:
p10673
aVUsing  in the normal program flow is strongly discouraged, because it hides your intent: exceptions in C# are reserved for, well, exceptional situations, not regular things that you can safely trap with an  condition
p10674
as(dp10675
g6
V335858
p10676
stp10677
a((dp10678
g2
(lp10679
VYour code can be simplified a lot by observing that  is an integer expression returning the index of the lowercase letter, and  does the same thing for the uppercase letters
p10680
aVSo the nested loop and the arrays of upper and lower cases are not necessary
p10681
aVYou can tell if a character is uppercase or lowercase by calling  or
p10682
aVYou can get percentages by adding up all counts, and calculating percentages the usual way:
p10683
as(dp10684
g6
V335858
p10685
stp10686
a((dp10687
g2
(lp10688
VLeaving any part of the  loop out is OK
p10689
aVLeaving all parts out is OK too - in fact, it's the idiomatic way of expressing an infinite loop as shown in the K&R; book
p10690
aVYou should carefully consider your other options though; it is possible that a  or a  /  loop presents a more readable alternative
p10691
as(dp10692
g6
V335858
p10693
stp10694
a((dp10695
g2
(lp10696
VIf you need a fixed-number strings, you can use  nested loops (three in your case)
p10697
aVIf  is not fixed, you would need a more general recursive solution
p10698
as(dp10699
g6
V335858
p10700
stp10701
a((dp10702
g2
(lp10703
VHeader is required only to get the prototypes
p10704
aVImplementation is compiled separately, and assembled into the finished library or executable by the linker
p10705
as(dp10706
g6
V335858
p10707
stp10708
a((dp10709
g2
(lp10710
VThe type of built-in  is represented by
p10711
aVSince  cannot be inherited, you do not need : you can simply check the type in question for equality to  to see if the type of a parameter is built-in
p10712
as(dp10713
g6
V335858
p10714
stp10715
a((dp10716
g2
(lp10717
VI always put a  at the end of the  chain, and do not assign the default value to the variable upfront
p10718
aVIf the exception is thrown, it tells me not only that the application cannot continue, but also reports the reason why it cannot proceed
p10719
aVMoreover, it does that as soon as it finds out that it cannot proceed, which is very desirable for error reporting (generally, you want to report an error as soon as possible)
p10720
aVThere is one special case, when you structured your code in such a way that the combination of s is such that you never run off the tail of the  chain, but the compiler cannot verify it automatically
p10721
aVFor example, you validated the input before, and you know that there is no path through your code that can change it
p10722
aVIn this specific case you should use an assertion rather than throwing an exception, because it indicates an error with your reasoning about your code, rather than a simple coding error
p10723
as(dp10724
g6
V335858
p10725
stp10726
a((dp10727
g2
(lp10728
VYou can recall that  loop lets you perform any modifications in the last expression, not only
p10729
aVFor this case, you can use
p10730
aVThen in each iteration the name will ne at , the author at , the number of pages at , and the genre at
p10731
as(dp10732
g6
V335858
p10733
stp10734
a((dp10735
g2
(lp10736
VThere is no way to do template meta-programming in C# the C++ style, but you can do it using reflection:
p10737
as(dp10738
g6
V335858
p10739
stp10740
a((dp10741
g2
(lp10742
VThe C++ standard, section 7
p10743
aV2, part 1, requires only that the constant expression be of an integral or enumerated type; there is no requirement for the constant values to be distinct
p10744
aVThis gives you additional flexibility at aliasing your constants, if you think it makes your code more expressive
p10745
aVFor example,
p10746
aVis better than
p10747
as(dp10748
g6
V335858
p10749
stp10750
a((dp10751
g2
(lp10752
VBut everytime after the click of good button i am getting the Array count as only 1
p10753
aVThis is not surprising, considering that you are creating a brand-new  on the previous line
p10754
aVTo fix this, you need to make  an instance variable (AKA ivar), initialize it to  in your designated initializer, and then use
p10755
aVto add objects to the array
p10756
aVIf you are looking to use  instead, the strategy would be identical, except you would need to decide on an object that you would like to use as unique keys to your
p10757
aVAlso remember that  is not ordered, so you might need to take care of sorting each time you display your dictionary items to users
p10758
as(dp10759
g6
V335858
p10760
stp10761
a((dp10762
g2
(lp10763
V in  nested type declaration means that  objects can be created outside the context of the  instance
p10764
aVYour errors have nothing to do with : you get NPEs because your lists are not initialized
p10765
aVYou can add initialization in the constructor of the , or add an initializer
p10766
as(dp10767
g6
V335858
p10768
stp10769
a((dp10770
g2
(lp10771
VYou do not need to call : the run loop will "autorelease" the objects for you some time after your method completes
p10772
aVWith short-running loops (such as yours, that have only ten iterations) there is nothing else to worry about
p10773
aVFor loops with thousands of iterations, you may consider adding an Autorelease Pool
p10774
aVI thought it might be causing a memory leak since a the end of the function it will autorelease tempString but not all of the previous allocations of tempString
p10775
aVEach invocation of the  method adds its return value to autorelease pool, so no matter how many times you loop executes, all returned strings will be autoreleased
p10776
as(dp10777
g6
V335858
p10778
stp10779
a((dp10780
g2
(lp10781
VThis behavior corresponds to the documented way the  method is supposed to work:
p10782
aVParameters: val - double to convert to a BigDecimal
p10783
aVReturns: a BigDecimal whose value is equal to or approximately equal to the value of val
p10784
aVThrows: NumberFormatException - if val is infinite or NaN
p10785
as(dp10786
g6
V335858
p10787
stp10788
a((dp10789
g2
(lp10790
VIf you call the function before declaring it, C implies a return type of , not
p10791
aVYou should add this declaration in the header or at the top of your file to address the problem:
p10792
as(dp10793
g6
V335858
p10794
stp10795
a((dp10796
g2
(lp10797
VWhen you create an object with , you are responsible for calling
p10798
aVWhen you create an object with , the resulting  is responsible for keeping count and calling  when the use count goes to zero
p10799
aVGoing out of scope does mean leaving a block
p10800
aVThis is when the destructor is called, assuming that the object was not allocated with  (i
p10801
ag630
aVit is a stack object)
p10802
aVAbout the only time when you need to call a destructor explicitly is when you allocate the object with a placement
p10803
as(dp10804
g6
V335858
p10805
stp10806
a((dp10807
g2
(lp10808
VNot unless your destructor  calls  on the pointers
p10809
aVCalling  will, however, invoke the destructors of non-pointer members
p10810
as(dp10811
g6
V335858
p10812
stp10813
a((dp10814
g2
(lp10815
VIf you repeat the  in the  clause, the statement will work:
p10816
aVIt wouldn't be fast, because it wouldn't use indexes, but it should work
p10817
aVA somewhat better approach would be as follows:
p10818
aVThis will return the same results, but it can use indexes on  and  if you define them, EDIT and change the second operand of  to not use the leading
p10819
as(dp10820
g6
V335858
p10821
stp10822
a((dp10823
g2
(lp10824
VGenerally, you need to pay attention to values of nullable columns
p10825
aVDB signals that the returned value is  by returning a special object called
p10826
aVYou cannot cast it to  or anything else, so your code should check for null by using  like this:
p10827
as(dp10828
g6
V335858
p10829
stp10830
a((dp10831
g2
(lp10832
VAssuming that the mysterious "process the file" operation is self-contained, the biggest thing you should worry about is your DB connection: do not make it shared, obtain a new one each time from a connection string, and use a connection pool
p10833
aVDo not make your method synchronized, unless you need to access shared state inside your class; otherwise, your method would not be able to make progress concurrently on multiple threads
p10834
as(dp10835
g6
V335858
p10836
stp10837
a((dp10838
g2
(lp10839
Vbut since the call to super has to be the first line in B's constructor this scheme won't work
p10840
aVWhy wouldn't it work
p10841
aVIf you put calculations of the hash code in a static function of a subclass, you would be able to pass pre-made hash code to the constructor of your superclass
p10842
as(dp10843
g6
V335858
p10844
stp10845
a((dp10846
g2
(lp10847
VThere are two building blocks that you need to know to build this yourself:
p10848
aVGetting  least significant bits requires constructing a bit mask with  ones at the end
p10849
aVYou do it like this:
p10850
aVis : it has a single  at the st position, and all zeros after it
p10851
aVSubtracting one gives you the mask that you need
p10852
aVDropping  least significant bits is a simple shift to the right:
p10853
aVNow your algorithm for cutting out from  to  becomes a two-step process: you shift the original value  bits to the right, and then perform a bit-wise  with the mask of  ones
p10854
aVThis fragment cuts out bits from 4, inclusive, to 16, exclusive, and prints  when you run it
p10855
aVBits are numbered from zero
p10856
as(dp10857
g6
V335858
p10858
stp10859
a((dp10860
g2
(lp10861
VThe program does what you asked it to do
p10862
aVThe source of your confusion is in the  constant, which is actually , because  is eight bits
p10863
aVPacking it together with  as you do should produce , and it does
p10864
as(dp10865
g6
V335858
p10866
stp10867
a((dp10868
g2
(lp10869
VAccording to SAX parser specification, you may be getting multiple callbacks for , representing chunks of the same character block
p10870
aVYou should combine consecutive ones into a single string
p10871
aVThe Parser will call [] method to report each chunk of character data
p10872
aVSAX parsers may return all contiguous character data in a single chunk, or they may split it into several chunks; however, all of the characters in any single event must come from the same external entity so that the Locator provides useful information
p10873
as(dp10874
g6
V335858
p10875
stp10876
a((dp10877
g2
(lp10878
VBefore calling , JVM needs to initialize the  class by running its static initializer
p10879
aVThis call is responsible for the first call of
p10880
aVOnce the initialization is complete, JVM calls  again, ultimately producing the output that you see
p10881
as(dp10882
g6
V335858
p10883
stp10884
a((dp10885
g2
(lp10886
VThis is expected: if the key is not present in the , an attempt to read at that key fails
p10887
aVYou should assign an empty array to the element at the  before accessing it
p10888
aVHere is the typical pattern of accessing a dictionary when you do not know if the key is present or not:
p10889
aVEDIT (in response to the edit of the question)
p10890
aVYou see an exception only when you try reading the dictionary at the previously unknown key
p10891
aVAssignments such as yours
p10892
aVare allowed, even though the key is not in the dictionary at the time of the assignment: this performs an "insert or update" operation on your dictionary
p10893
as(dp10894
g6
V335858
p10895
stp10896
a((dp10897
g2
(lp10898
VC does not provide a portable way to tell statically allocated memory blocks from dynamically allocated ones
p10899
aVYou can build your own  with a string pointer and a flag indicating the type of memory occupied by the object
p10900
aVIn C++ you can make it a class with two different constructors, one per memory type, to make your life easier
p10901
aVAs far as aborting your program goes, trying to free or re-allocate memory that has not been allocated dynamically is undefined behavior, so aborting is a fair game
p10902
as(dp10903
g6
V335858
p10904
stp10905
a((dp10906
g2
(lp10907
VThe reason you are getting  is because you are trying to convert an  based on an an anonymous type to  ( creates an instance of an anonymous type with two fields -  and ) You should remove the  part to make it work
p10908
aVIf you would like to select only  and , create a named type with these two fields, and return an  of that type:
p10909
as(dp10910
g6
V335858
p10911
stp10912
a((dp10913
g2
(lp10914
VThis should work:
p10915
as(dp10916
g6
V335858
p10917
stp10918
a((dp10919
g2
(lp10920
VThis approach is valid as long as your individual forms are never running concurrently or your error provider is re-entrant, and your error provider does not need a permanent link back to your forms
p10921
aVFrom the example that you show it appears that your provider requires you to pass the control on which to set the error state, so it has a good chance of being re-entrant
p10922
as(dp10923
g6
V335858
p10924
stp10925
a((dp10926
g2
(lp10927
VThe assignments in declarations provide default values for optional parameters
p10928
aVmeans a call to 's default constructor
p10929
aVThe effect of the default parameters is as follows: you can invoke  constructor with zero, one, or two parameters
p10930
aVIf you specify two parameter expressions, they are passed as usual
p10931
aVIf you specify only one expression, its value is passed as the first parameter, and the second one is defaulted to
p10932
aVIf you pass no parameters, the first parameter is defaulted to an instance of  created with its default constructor, and the second one is defaulted to
p10933
as(dp10934
g6
V335858
p10935
stp10936
a((dp10937
g2
(lp10938
VWhen you are in the run loop of an application, there is a default autorelease pool created for you
p10939
aVHowever, when you are running with your own , you need to create an autorelease pool manually at the top of your , and drain it periodically
p10940
aVIf you are compiling with the new LLVM compiler, use the new  feature instead
p10941
as(dp10942
g6
V335858
p10943
stp10944
a((dp10945
g2
(lp10946
VYou never advance program counter directly - CPU does it for you by executing your program
p10947
aVAs the programmer, you manipulate program counter by executing various jump instructions (conditional, unconditional, jumps to subroutine, etc
p10948
aVOne specific case when you need to add an offset to the program counter is when you branch in position-independent code
p10949
aVHowever, even in this case you do not add the size of the instruction to the program counter: instead, you provide the offset of the place to which you would like to jump by executing a "branch to relative address"
p10950
as(dp10951
g6
V335858
p10952
stp10953
a((dp10954
g2
(lp10955
VYou need to sign your assembly if you would like to deploy it to the Global Assembly Cache:
p10956
aVAssemblies deployed in the global assembly cache must have a strong name
p10957
aVIn other deployment scenarios strong names (which implies signing) is not required, but encouraged
p10958
as(dp10959
g6
V335858
p10960
stp10961
a((dp10962
g2
(lp10963
VIf you are running the latest SQL Server 2012, you can use  function to make a "first of the month" date, like this:
p10964
as(dp10965
g6
V335858
p10966
stp10967
a((dp10968
g2
(lp10969
VThese numbers come from the IEEE-754 standard, which defines the standard representation of floating point numbers
p10970
aVWikipedia article at the link explains how to arrive at these ranges knowing the number of bits used for the signs, mantissa, and the exponent
p10971
as(dp10972
g6
V335858
p10973
stp10974
a((dp10975
g2
(lp10976
VYou need to declare your array as an instance variable (AKA "ivar") inside the curly braces section of the the interface declaration in your
p10977
aVh file, and also initialize it in your designated initializer
p10978
aVIn the
p10979
aVh file:
p10980
aVIn the
p10981
aVm file:
p10982
aVNow you can use  in all instance methods of your class
p10983
aVEDIT: This sample assumes that you are using automated reference counting
p10984
aVSince this is your first app, using ARC is a good idea (XCode asks you if you would like to use it when you create a new project)
p10985
as(dp10986
g6
V335858
p10987
stp10988
a((dp10989
g2
(lp10990
VThere is no "programmatic" benefit: once the code is compiled, there is no difference in the generated libraries or executables
p10991
aVIt is a matter of preference and sometimes coding standards of your organization
p10992
aVOur company prefers using the  except for rare cases where it is not possible
p10993
as(dp10994
g6
V335858
p10995
stp10996
a((dp10997
g2
(lp10998
VStarting with MySQL 5
p10999
ag49
aV3, you can simply use
p11000
aVM represents the maximum column length in characters
p11001
aVIn MySQL 5
p11002
aV0, the range of M is 0 to 255 before MySQL 5
p11003
ag49
aV3, and 0 to 65,535 in MySQL 5
p11004
ag49
aV3 and later
p11005
as(dp11006
g6
V335858
p11007
stp11008
a((dp11009
g2
(lp11010
VThe reason it does not work is that you are ignoring the length of the : instead of comparing the length of the initial word and the rest of the sentence, you should compare the length of the initial word to the length of the longest word found in the rest of the sentence
p11011
as(dp11012
g6
V335858
p11013
stp11014
a((dp11015
g2
(lp11016
VYou can use the  method inherited by  from , or write a custom method that formats  to your liking
p11017
as(dp11018
g6
V335858
p11019
stp11020
a((dp11021
g2
(lp11022
VVisitor pattern is used to implement double dispatch
p11023
aVIn plain words it means that the code that gets executed depends on runtime types of two objects
p11024
aVWhen you call a regular virtual function, it is a single dispatch: the piece of code that gets executed depends on the runtime type of a single object, namely, the one the virtual method of which you are calling
p11025
aVWith the visitor pattern, the method that is being called ultimately depends on the type of two objects - the type of the object implementing the , and the type of the object on which you call  (i
p11026
ag630
aVthe  subclass)
p11027
aVThere are other ways to implement double dispatch in C++
p11028
aVItem 31 of Scott Meyer's "More Effective C++" treats this subject in depth
p11029
as(dp11030
g6
V335858
p11031
stp11032
a((dp11033
g2
(lp11034
VIf you read more often then you write, you could cache the result of your search
p11035
aVCreate a list of non-zero items, and keep it there until the next write
p11036
aVYou could also keep a set of all indexes into the original array where the value is not zero
p11037
aVEvery time you change a value in the list to zero, remove the index of that value from the set; every time you set a value to non-zero, add its index to the set
p11038
aVThis way instead of searching for non-zero entries you would simply harvest then from the set of known indexes
p11039
as(dp11040
g6
V335858
p11041
stp11042
a((dp11043
g2
(lp11044
VIf you know the size of the array, you can  it, and make a pointer to it
p11045
aVHere is a short snippet that demonstrates this use:
p11046
as(dp11047
g6
V335858
p11048
stp11049
a((dp11050
g2
(lp11051
VYou can sort the array using descriptors or using comparators, whatever you feel more comfortable with
p11052
aVHere is an example of using comparators:
p11053
as(dp11054
g6
V335858
p11055
stp11056
a((dp11057
g2
(lp11058
VProgress bar's progress value is between  and , your code sets it in the increments of , which is out of range
p11059
aVYour increment should be , not
p11060
as(dp11061
g6
V335858
p11062
stp11063
a((dp11064
g2
(lp11065
VYou correctly identified the place where you are "going wrong" in your comment: the problem is not in that you are setting the value incorrectly, but in that you are setting it on a brand-new instance that is local to the method, and is promptly discarded upon the exit from that method
p11066
aVIn general, your model class(es) should be created when your application starts up, and remain available during the entire lifetime of your application
p11067
aVThis is often accomplished using singletons
p11068
as(dp11069
g6
V335858
p11070
stp11071
a((dp11072
g2
(lp11073
VThe parallel with Java is very good
p11074
aVThe only difference is that Objective C provides a way to access a property as if it were a variable, and Java does not
p11075
aVThe other difference is that in Objective C you can synthesize properties, while in Java you need to write your getters and setters manually
p11076
aVProperty is a "syntactic sugar" over a getter method or a pair of a getter and a setter methods
p11077
aVProperties are often (but not always) backed by an instance variable, but they can be implemented in any way that you can implement a parameterless instance method
p11078
as(dp11079
g6
V335858
p11080
stp11081
a((dp11082
g2
(lp11083
VThis is very simple in Java:
p11084
aVThe constructor  performs a shallow copy of the list that you supply as parameter, which is precisely the semantics that you are looking for
p11085
as(dp11086
g6
V335858
p11087
stp11088
a((dp11089
g2
(lp11090
VYou do not need to go character by character: for your purposes, going line-by-line is sufficient, and you get the
p11091
aVNET to deal with system-dependent line breaks for you as an added bonus
p11092
aVEDIT: Your program does not work because of an error unrelated to you checking the : you are zeroing out the  and  after each character, instead of clearing them only when you see a newline character
p11093
as(dp11094
g6
V335858
p11095
stp11096
a((dp11097
g2
(lp11098
VWhen you are calling an event handler of an identical event (i
p11099
ag630
aVwhen you are calling a doubleclick event from another doubleclick event) you should pass event arguments through to it
p11100
aVEvent arguments contain important information about the doubleclick, for example, its location
p11101
aVIf the handler "down the chain" does not care about these arguments, passing  will not cause a problem; however, you should not assume that the handler you are calling ignores the argument, and pass something valid to it
p11102
aVHere is an example of how you can use event arguments to figure out the position of the doubleclick
p11103
as(dp11104
g6
V335858
p11105
stp11106
a((dp11107
g2
(lp11108
VThe idea is very simple:
p11109
aVWrite a function  that takes a string, and returns  if it is a palindrome and  if it is not
p11110
aVWith that function in hand, write two nested loops cutting out different substrings from the original string
p11111
aVPass each substring to , and pick the longest one among the strings returning
p11112
aVYou can further optimize your program by examining longest substrings ahead of shorter ones
p11113
aVIf you examine substrings from longest to shortest, you'll be able to return as soon as you find the first palindrome
p11114
as(dp11115
g6
V335858
p11116
stp11117
a((dp11118
g2
(lp11119
VArrays and pointers are not the same type, even though arrays do decay to pointers when passed to functions
p11120
aVYou can change the method signature to take an array
p11121
aVbut if you are doing C++,  would provide a much better and more flexible option
p11122
as(dp11123
g6
V335858
p11124
stp11125
a((dp11126
g2
(lp11127
VYou are very close - you forgot to reference the  array, and tried indexing the expression itself
p11128
aVNaturally, the compiler complained, because you do not have a  overloaded
p11129
aVThis should work:
p11130
as(dp11131
g6
V335858
p11132
stp11133
a((dp11134
g2
(lp11135
V does not "know" it's at the end of file until you try to read some more
p11136
aVSince  tells you how many items it got, you can use this simple trick:
p11137
as(dp11138
g6
V335858
p11139
stp11140
a((dp11141
g2
(lp11142
VYou can wrap your queries in :
p11143
as(dp11144
g6
V335858
p11145
stp11146
a((dp11147
g2
(lp11148
VYou should use  which returns  instead of  which returns
p11149
aVThen you could use  method:
p11150
as(dp11151
g6
V335858
p11152
stp11153
a((dp11154
g2
(lp11155
VAssuming that this is homework, here is a hint: read on exponentiation by squaring, it gives you everything you need to build a solution, including pseudocode
p11156
aVYour current implementation makes no distinction between even and odd values of , which is correct only when  is a power of two
p11157
aVYou can expand your solution to work for all  (see below)
p11158
aVWhen you get a return value of  and  is even, you should square the result and take a remainder of the square
p11159
aVYou can expand this to work for all , not only powers of , by additionally multiplying the result by  and take remainder for odd values of
p11160
as(dp11161
g6
V335858
p11162
stp11163
a((dp11164
g2
(lp11165
VSince  is an , you need to pass all arguments that you pass to the 's constructor to the constructor of , and then some:
p11166
as(dp11167
g6
V335858
p11168
stp11169
a((dp11170
g2
(lp11171
VI think you misunderstood the post: the author is not arguing that an abstract class is better in this situation - on the contrary, he is arguing that an interface is a better fit
p11172
aVAs far as  (or more precisely ) goes, the number comes from realization that if you have  orthogonal behavior contracts, you can make  non-empty combinations from them
p11173
aVIf you use interfaces to add contracts to classes that implement them, you need only as many interfaces as there are behaviors: the user will be able to make combinations of behaviors that he chooses to implement, up to
p11174
aVIf you were to try achieving the same flexibility with abstract classes, you would end up creating not only your desired implementations, but also all the intermediate ones required all the way to a single root, because Java lets you inherit classes only one at a time
p11175
as(dp11176
g6
V335858
p11177
stp11178
a((dp11179
g2
(lp11180
VThere is a -safe way to do this: instead of
p11181
aVwrite
p11182
aVIt will not crash if  is null, and it will return true if trimming  results in an empty string
p11183
as(dp11184
g6
V335858
p11185
stp11186
a((dp11187
g2
(lp11188
VOne of the key ideas of OOP is keeping the data close to the code that operates on it
p11189
aVNon-static methods enable you to do just that: you can define functionality that is closely tied to a set of attributes so that the users of your class (which is a combination of attributes and functionality over these attributes) could pay attention to the functionality rather than to the data itself
p11190
as(dp11191
g6
V335858
p11192
stp11193
a((dp11194
g2
(lp11195
VThe key to the answer is called object interning
p11196
aVJava interns small numbers (less than 128), so all instances of  with  in the interned range are the same
p11197
aVNumbers above 128 are not interned, hence  objects are not equal to each other
p11198
as(dp11199
g6
V335858
p11200
stp11201
a((dp11202
g2
(lp11203
VYou cannot increment an array, but you can increment a pointer
p11204
aVIf you convert the array you declare to a pointer, you will get it to work:
p11205
as(dp11206
g6
V335858
p11207
stp11208
a((dp11209
g2
(lp11210
VNo, an assignment operator will need to deal with releasing whatever resources  may hold before performing an assignment
p11211
aVThe destructor will be called only when  is about to go out of scope
p11212
as(dp11213
g6
V335858
p11214
stp11215
a((dp11216
g2
(lp11217
VYour code is working correctly - when you read a string with doubled slashes back, they becomes single slashes again
p11218
aVThis is called escaping
p11219
aVIt is designed to let you enter special characters as sequences starting in
p11220
aVSingle slash becomes special in this scheme, so you need to escape it with a slash as well
p11221
as(dp11222
g6
V335858
p11223
stp11224
a((dp11225
g2
(lp11226
VWhen you write structures as is with , you get then written as they are in memory, including the "dead bytes" inside the struct that are inserted due to the padding
p11227
aVAdditionally, your multi-byte data is written with the endiannes of your system
p11228
aVIf you do not want that to happen, write a function that serializes the data from your structure
p11229
aVYou can write only the non-padded areas, and also write multibyte data in a predictable order (e
p11230
ag303
aVin the network byte order)
p11231
as(dp11232
g6
V335858
p11233
stp11234
a((dp11235
g2
(lp11236
VWriting to  address is not guaranteed to crash your program reliably, so GCC introduced  for that
p11237
aVIt looks like clang decided to go further, and eliminate such writes altogether, almost forcing you into using
p11238
aVTheir other option of casting  to  pointer does not look attractive compared to , because it's "merely" an undefined behavior
p11239
as(dp11240
g6
V335858
p11241
stp11242
a((dp11243
g2
(lp11244
VMake a  flag that indicates that the stream has been initialized, and set it to false
p11245
aVWhen you receive the next chunk of data, check the flag first
p11246
aVIf it is not set, skip all characters until you see an exclamation point
p11247
aVOnce you see it, discard everything in front of it, and copy the rest of the string into the buffer
p11248
aVIf the "is initialized" flag is set, append the entire string to the buffer without skipping characters
p11249
aVOnce you finish the append, scan the buffer for  and  delimited sections
p11250
aVFor each occurrence of that pattern, call a designated method with a complete portion of the pattern
p11251
aVYou can get fancy, and define your own "secondary" delegate for processing pre-validated strings
p11252
aVYou may need to detect disconnections, and set the "is initialized" flag back to
p11253
as(dp11254
g6
V335858
p11255
stp11256
a((dp11257
g2
(lp11258
VIn both your examples, local variables of  type are allocated on the stack
p11259
aVThe compiler is free to produce the same code from both snippets if there is no way for your program to detect a difference
p11260
aVThe memory area for global variables is the same as the memory area for static variables - it's neither on the stack nor on the heap
p11261
aVYou can place variables in that area by declaring them  inside the function
p11262
aVThe consequence of doing so is that the instance becomes shared among concurrent invocations of your function, so you need to carefully consider synchronization when you use statics
p11263
aVHere is a link to a discussion of the memory layout of a running C program
p11264
as(dp11265
g6
V335858
p11266
stp11267
a((dp11268
g2
(lp11269
VThis means that the split returns exactly one element  - the entire string
p11270
aVThere is no array element at index 1, so
p11271
aVthrows the  exception
p11272
aVThis, in turn, means that the string that you pass does not contain a comma  character
p11273
as(dp11274
g6
V335858
p11275
stp11276
a((dp11277
g2
(lp11278
VYour  method in the first example assigns the newly created  to its parameter, which is passed by value, and is promptly discarded upon exiting from the method
p11279
aVWhat happens here is that a copy of the reference to  is made (not a copy of the array, only a copy of a reference to that array) before calling
p11280
aVThat copy is no longer attached to the  member of
p11281
aVYour second example is not passing a class - it's passing an instance of the class, and then it correctly uses the dot notation to assign the  property in your instance
p11282
aVThat's why this second example works, and the first example does not
p11283
aVIf you use  instead of  throughout your program, you can rewrite your first example to make it work:
p11284
as(dp11285
g6
V335858
p11286
stp11287
a((dp11288
g2
(lp11289
VCreate a  with the words that you would like to exclude, and use  to determine if the word is in the set
p11290
aVIf it is, the count will be ; it will be  otherwise
p11291
as(dp11292
g6
V335858
p11293
stp11294
a((dp11295
g2
(lp11296
Vhow does the compiler determine that it needs to invoke func() of derived
p11297
aVIn the same exat way - by invoking
p11298
aVRecall that  belongs to the derived class even inside the base class, because each derived class is a base class as well, so the same way of accessing virtual functions works for it too
p11299
as(dp11300
g6
V335858
p11301
stp11302
a((dp11303
g2
(lp11304
VIt is easier to understand the idea if you un-optimizer the algorithm from your tutorial, and use a simpler  algorithm that searches back linearly instead of looking up in the map
p11305
aVThen modify the code that prints the sequence to search for prior element backward rather than storing it in the
p11306
aVThen you could print all sequences with a simple recursive backtracker:
p11307
as(dp11308
g6
V335858
p11309
stp11310
a((dp11311
g2
(lp11312
VFollowing C convention for strings, an imaginary  would need to return a pointer to , or take in a buffer and length as parameters
p11313
aVThis brings about the problem of ownership: the interface cannot tell you what to do with the return value
p11314
aVShould you  it
p11315
aVIs it a static storage that shouldn't be freed
p11316
aVIs it safe to call this function from multiple threads
p11317
aVShould you pass a buffer for the result
p11318
aVWhat happens if the buffer is not long enough for the number you are printing
p11319
aVAll these questions do not have definitive answers on which everybody would agree, so my guess is that the standardization committee decided against inclusion of this function in the end: they figured that  would do the trick
p11320
as(dp11321
g6
V335858
p11322
stp11323
a((dp11324
g2
(lp11325
VYou should not use  of the entire , because you will inevitably run into issues with padding and endian-ness
p11326
aVThe C side will dump the entire  the way it is in the memory, with all its gaps that the compiler puts in for performance etc
p11327
aVThat's "the mother of non-portability"
p11328
aVInstead, you should use protocol buffers, JSON, or some other mean of portable serialization to accomplish your task
p11329
as(dp11330
g6
V335858
p11331
stp11332
a((dp11333
g2
(lp11334
VAbsolutely - you would need to write a moderate amount of code to implement it, but you can certainly do it manually if you must:
p11335
aVThis version takes an output argument and returns ; you can easily modify it to throw an exception and return  "the factory method style"
p11336
as(dp11337
g6
V335858
p11338
stp11339
a((dp11340
g2
(lp11341
VMulti-dimensional arrays are not very well supported by the built-in components of C and C++
p11342
aVYou can pass an -dimension array only when you know  dimensions at compile time:
p11343
aVHowever, the standard library supplies  container, that works very well for multi-dimension arrays: in your case, passing  would be the proper way of dealing with the task in C++
p11344
aVAs an added bonus, you wouldn't need to pass dimensions of the matrix to the function:  represents the first dimension, and  represents the second dimension
p11345
as(dp11346
g6
V335858
p11347
stp11348
a((dp11349
g2
(lp11350
VSynchronized static method in  is essentially the same as  block
p11351
aVYour second example should be rewritten as
p11352
aVto be correct
p11353
aVIf you would like to be defensive about your class synchronization, you should synchronize on a private static object not visible outside your class
p11354
aVThis prevents malicious code from blocking your static methods by executing  on their class object, thus blocking the legitimate method
p11355
aVAs far as "locking all objects" goes, non-static methods marked  will not be locked by execution of a static  method, because regular  methods lock on an instance of the object, not on its class
p11356
as(dp11357
g6
V335858
p11358
stp11359
a((dp11360
g2
(lp11361
VThe biggest reason why you use pointers and references is not because it lets you use less memory (although it certainly does), but because it lets you use less time
p11362
aVCopying objects takes time, you often need to allocate additional memory, and then deallocate it in the end
p11363
aVEven more importantly, objects such as streams are not meant to be copied at all: they contain internal state that is relevant to a physical object, - a file on disk or a network stream, - and their associated buffers, that does not make much sense to copy
p11364
as(dp11365
g6
V335858
p11366
stp11367
a((dp11368
g2
(lp11369
V is an untyped associative container that uses  class to return results of enumeration through its key-value pairs
p11370
aVis a generic replacement of  that was introduced in C# 2
p11371
ag49
aVIt uses  generic objects to represent its key-value pairs
p11372
aVThe only place where you should see  these days is legacy code that must run on
p11373
aVNET 1
p11374
aV1, before generics have been introduced
p11375
aVIt's been kept around for compatibility reasons, but you should prefer  whenever you can
p11376
as(dp11377
g6
V335858
p11378
stp11379
a((dp11380
g2
(lp11381
VThe problem with  is -ness of your iterator: the  operator is not , so you need to use  instead, and dereference the iterator that it returns:
p11382
aVYou could also switch to non-const iterator and use
p11383
as(dp11384
g6
V335858
p11385
stp11386
a((dp11387
g2
(lp11388
VThe error message is pretty clear on that: the error is because you have a "naked" employee number on the select list, but you are not grouping by it (which makes sense, assuming that employee number is unique: it would make your  useless)
p11389
aVIf you are looking for the total salary paid to all employees by department, all you need to do is removing the employee number:
p11390
as(dp11391
g6
V335858
p11392
stp11393
a((dp11394
g2
(lp11395
VYou can compare characters to their ASCII code directly, without a cast:
p11396
aVOf course character constants look better in their natural form:
p11397
as(dp11398
g6
V335858
p11399
stp11400
a((dp11401
g2
(lp11402
VIt looks like you are trying to initialize your structure to indicate that the  member is to be used, and that the value of that  should be
p11403
aVSince C++ before C++11 lacks designated initializers, you cannot do it with an initializer: only the first field of the  can be initialized, so you need to do your assignment in code:
p11404
aVC++11 lets you do it like this:
p11405
as(dp11406
g6
V335858
p11407
stp11408
a((dp11409
g2
(lp11410
VThis code gives you an error because your  function needs to be :
p11411
aVIn C# there is a distinction between functions that operate on instances (non-static) and functions that do not operate on instances (static)
p11412
aVInstance functions can call other instance functions and static functions because they have an implicit reference to the instance
p11413
aVIn contrast, static functions can call only static functions, or else they must explicitly provide an instance on which to call a non-static function
p11414
aVSince  is static, all functions that it calls need to be static as well
p11415
as(dp11416
g6
V335858
p11417
stp11418
a((dp11419
g2
(lp11420
VThis is because  is the size of a  pointer on your system, not the length of the string
p11421
aVYou need to write out the length separately from the string, too
p11422
as(dp11423
g6
V335858
p11424
stp11425
a((dp11426
g2
(lp11427
VYes, you are right
p11428
aVYour code is making a copy, modifies it, and then promptly discards
p11429
aVYou should instead modify the structure passed in through a pointer:
p11430
aVNote the  operator
p11431
aVIt is the pointer equivalent of the  member access operator
p11432
aVIt is equivalent to
p11433
aVbut it looks nicer
p11434
aVYou can do the same thing in the , although it is merely an inefficiency there:
p11435
as(dp11436
g6
V335858
p11437
stp11438
a((dp11439
g2
(lp11440
VIt is a matter of taste or coding standards of your company
p11441
aVMy rule of thumb is that if all my constructors assign the same value to a variable, I use the first form; if the value comes from outside, or different constructors assign different values to a variable, I use the second form
p11442
as(dp11443
g6
V335858
p11444
stp11445
a((dp11446
g2
(lp11447
VYou can use this dirty hack:
p11448
as(dp11449
g6
V335858
p11450
stp11451
a((dp11452
g2
(lp11453
VYour algorithm is a good start, but it is not going to produce correct results
p11454
aVThe problem is that the hash tables the way you describe them are a one-way street: once a word gets added, it stays counted forever
p11455
aVYou need an array of  (24*60)  hash maps organized the way that you describe; these are your minute-by-minute counts
p11456
aVYou need two additional hash maps - for the rolling total of the hour and the day
p11457
aVDefine two operations on hash maps -  and , with the semantic of merging counts of identical words, and removing words when their count drops to zero
p11458
aVEach minute you start a new hash map, and update counts from the feed
p11459
aVAt the end of the minute, you place that hash map into the array for the current minute, add it to the rolling total for the hour and for the day, and then subtract the hash map of an hour ago from the hourly running total, and subtract the hash map of 24 hours ago from the daily running total
p11460
aVFinally, you need a way to produce the top 100 words given a hash map
p11461
aVThis should be a trivial task - add items to an array of  entries, sort on  the count, and keep the top 100
p11462
as(dp11463
g6
V335858
p11464
stp11465
a((dp11466
g2
(lp11467
VYou do not need to write an extension on  (your example is not doing it either)
p11468
aVYou need an extension on
p11469
aVYou can do it like this:
p11470
as(dp11471
g6
V335858
p11472
stp11473
a((dp11474
g2
(lp11475
VYou can use  keyword to make your variables from the first example private
p11476
aVThat is not the main point of adding variables in a class extension
p11477
aVRather, adding ivars in an extension lets you remove unwanted dependencies from the header without using forward declarations
p11478
aVFor example, if  is defined in  and you want to add  as a private variable, doing it in the header would require either a forward declaration , or an inclusion of  header inside your own header
p11479
aVOn the other hand, adding a variable to an extension (your second way) lets you include  in your implementation
p11480
aVm file, avoiding the clutter of forward declarations and unnecessary header dependencies
p11481
as(dp11482
g6
V335858
p11483
stp11484
a((dp11485
g2
(lp11486
VThe syntax gets a little ugly, but I think you can do it:
p11487
aVThis returns 0 to 2 rows
p11488
aVIf 2 rows are returned, pick the 1st one
p11489
aVEDIT You can try avoiding the cost of the second query by using this monstrous construct
p11490
aVI am not sure if MySQL is going to handle it well, but it has a decent chance of avoiding the second query:
p11491
as(dp11492
g6
V335858
p11493
stp11494
a((dp11495
g2
(lp11496
VThe syntax with  requires a little getting used to
p11497
aVA 2D vector of  looks like this:
p11498
aVIf you would like to set specific dimensions, use constructors that take size:
p11499
aVThis produces a  vector of zeros
p11500
aVYou can do this
p11501
aVto provide initial values for your elements ( in this case)
p11502
aVAs a rule of thumb, you want your vectors passed by reference and returned by value
p11503
as(dp11504
g6
V335858
p11505
stp11506
a((dp11507
g2
(lp11508
VUse :
p11509
aVRegardless of this, if you are writing the string over itself, you shouldn't use  - the objects that you copy must not overlap:
p11510
aVIf copying takes place between objects that overlap, the behavior is undefined
p11511
aVand a string definitely overlaps with itself
p11512
aVRemoving whitespace from a string can be easily achieved with a simple function:
p11513
as(dp11514
g6
V335858
p11515
stp11516
a((dp11517
g2
(lp11518
VTo avoid matching quoted nested inside square brackets, you need to check that one of the following is true:
p11519
aVThe last non-whitespace character preceding the opening double quote is not a , or
p11520
aVThe first non-whitespace character following the closing double-quote is not a
p11521
aVThis can be done using this regexp:
p11522
aVIt uses the lookaround feature of
p11523
aVNET regexp engine
p11524
aVNote how this expression avoids the reluctant qualifier  inside the quoted string by using  instead of
p11525
as(dp11526
g6
V335858
p11527
stp11528
a((dp11529
g2
(lp11530
VYou are assigning to a location occupied by a string constant, an undefined behavior
p11531
aVIf you know the max lengths of your strings, you can do this:
p11532
aVIt's not a precise equivalent, but it should work
p11533
aVIf you do not know max length, or do not want to waste a few bytes here and there, you can still pull it off with a little more work:
p11534
as(dp11535
g6
V335858
p11536
stp11537
a((dp11538
g2
(lp11539
VIn addition to its "technical" side (i
p11540
ag630
aVinability to instantiate),  has a semantic side facing the user of your library: it communicates an intent for others to extend the class
p11541
aVThis is not something you are expected to do with , hence marking it  would be a mistake
p11542
as(dp11543
g6
V335858
p11544
stp11545
a((dp11546
g2
(lp11547
VThis is called Exponentiation by Squaring
p11548
aVAs far as implementation goes, it is a matter of taste
p11549
aVYour recursive implementation is good, but non-recursive implementations (from the link above) may look a little cleaner to people who do not like recursion or erroneously believe that it is somehow "wasteful" or "slow"
p11550
as(dp11551
g6
V335858
p11552
stp11553
a((dp11554
g2
(lp11555
VThis does not perform well because  on a list is linear
p11556
aVThe resulting algorithm is
p11557
aVYou should make a  from the  on the common attribute, and look up by the key instead of searching with ; dictionary lookup is  amortized, so it will make your algorithm linear in the length of the list
p11558
as(dp11559
g6
V335858
p11560
stp11561
a((dp11562
g2
(lp11563
VThe implementation of  that I found on the web looks like this:
p11564
aVI'm not an expert in VB, but I think it translates to this:
p11565
as(dp11566
g6
V335858
p11567
stp11568
a((dp11569
g2
(lp11570
VThe problem is that you are missing a semicolon after the closing brace in your class definition
p11571
as(dp11572
g6
V335858
p11573
stp11574
a((dp11575
g2
(lp11576
VYou should re-organize your tests to address arbitrary re-ordering, for example, like this:
p11577
aVSplit the string into individual messages
p11578
aVSeparate general messages and all other messages
p11579
aVOrder expected and actual messages in the same order (e
p11580
ag303
aValphabetical)
p11581
aVCompare ordered lists of expected and actual messages
p11582
aVNow that they are ordered the same, they should equal item-by-item
p11583
aVCheck that the general messages come after all other messages in the actual message stream
p11584
as(dp11585
g6
V335858
p11586
stp11587
a((dp11588
g2
(lp11589
VYou can use
p11590
aVIf you need to use , call your predicate's  inside the block; otherwise, simply check the object's integer value to be
p11591
as(dp11592
g6
V335858
p11593
stp11594
a((dp11595
g2
(lp11596
VYou can do it like this:
p11597
as(dp11598
g6
V335858
p11599
stp11600
a((dp11601
g2
(lp11602
VNo, there is no way to cast one to the other, because these are two unrelated types, as far as the compiler knows
p11603
aVIf the fields of the target type are assignable, you can write a short method that uses reflection to copy the fields
p11604
aVYou could also build code that saves objects of the source type to XML, and reads that XML into the objects of the target type
p11605
aVThis is slightly more fragile, because it relies on the presence of identical fields and the fact that they are converted to XML in the same way
p11606
as(dp11607
g6
V335858
p11608
stp11609
a((dp11610
g2
(lp11611
VC++ supplies a  class that can be used like this:
p11612
as(dp11613
g6
V335858
p11614
stp11615
a((dp11616
g2
(lp11617
VThis does what you need:
p11618
aVHere is a link to a test on SQLFiddle
p11619
as(dp11620
g6
V335858
p11621
stp11622
a((dp11623
g2
(lp11624
VYour code crashes because you are passing an address of an address to , which is not what you allocated
p11625
aVChange your code to this:
p11626
aVIt will no longer crash
p11627
aVThe rule on this is simple: since you assigned the results of  to , you should be passing , not , to
p11628
aVSame goes for
p11629
aVAlso note that this code deletes all rows that you allocated, including the last one (the loop condition is now , not )
p11630
aVThanks bjhend
p11631
as(dp11632
g6
V335858
p11633
stp11634
a((dp11635
g2
(lp11636
VAs far as I know,  is an implementation of  that keeps the string data in code memory
p11637
aVCompiler creates instances of it when you use  constants
p11638
aVYou can use  anywhere an  could be used due to subclass/superclass relationship, but obviously not the other way around
p11639
as(dp11640
g6
V335858
p11641
stp11642
a((dp11643
g2
(lp11644
VThe problem is that you are declaring a pointer to a pointer to a pointer to a pointer to 64-bit integer, not a four-dimensional array of 64-bit integers
p11645
aVWhen you dereference it with a chain of , the compiler looks up a pointer in an uninitialized block that you have just allocated, tries to dereference it, and promptly crashes
p11646
aVIf your at least three of the four sizes (say, , , and ) were compile-time constants, you could allocate  3-D arrays, and use the regular square-bracket syntax to access elements
p11647
aVIf that is not possible, you'll either have to live with the overhead of pointers, or allocate a "plain" array and implement your own addressing scheme into it to make believe it's 4-D
p11648
ag1971
ag1972
aVI am silently assuming here that the overhead of using  is prohibitive in your situation
p11649
aVIf you have enough memory for the additional pointers, though, I'd definitely go for a vector of vectors of vectors of vectors of 64-bit integers: it is fast, it is reliable, and it is easy to use
p11650
aVEDIT : This is what you can do if three of the four dimensions are constants:
p11651
as(dp11652
g6
V335858
p11653
stp11654
a((dp11655
g2
(lp11656
VIf the number of items is capped at a certain number (say, 15) you could store a list of small numbers in a larger numeric type
p11657
aVEssentially, your list becomes a "mask" of 4-bit groups, where each group represents a number from 0 to 15, inclusive
p11658
aVWith 15 items you need 60 bits to store such a list
p11659
aVConveniently, most databases support 64-bit integer types, so all you need to do is implementing a packing algorithm
p11660
aVSince the number of items is 15 and the number of states that can be stored in 4 bits is 16, you can use combination of all zeros to mean "not present"; all non-zero combinations represent a number of the item
p11661
aVThis is a lot faster and significantly more compact than storing lists of numbers in a string
p11662
aVIt is harder to expand, though, because the length of the bit group (4 in this case) depends on the number of items that you desire to store
p11663
as(dp11664
g6
V335858
p11665
stp11666
a((dp11667
g2
(lp11668
VYou can implement Fisher-Yates shuffle of numbers zero to , where  is the number of items in , and then combine an item at  with a random item from
p11669
as(dp11670
g6
V335858
p11671
stp11672
a((dp11673
g2
(lp11674
VYou can use regular expressions to do it
p11675
aVThis fragment prints  and
p11676
as(dp11677
g6
V335858
p11678
stp11679
a((dp11680
g2
(lp11681
VNot a built-in one, but you can write a short recursive program to do walk the directory tree recursively
p11682
as(dp11683
g6
V335858
p11684
stp11685
a((dp11686
g2
(lp11687
VYes, using junction tables is the correct way of implementing many-to-many relations in RDBMS
p11688
aVYou can add more attributes to your junction table (i
p11689
ag630
aV) if necessary
p11690
aVFor example, if the relations are ordered, you can add a third field that specifies an ordering of the  combinations
p11691
aVHere is a link to an answer on Stack Overflow that gives a nice detailed example of a many-to-many table
p11692
as(dp11693
g6
V335858
p11694
stp11695
a((dp11696
g2
(lp11697
VThis is a well-known problem called Longest Common Substring
p11698
aVIt can be solved in , where  and  are lengths of the individual strings, using dynamic programming approach
p11699
aVThe article in Wikipedia contains easy-to-follow pseudocode
p11700
as(dp11701
g6
V335858
p11702
stp11703
a((dp11704
g2
(lp11705
VThe second query runs against an index , so it completes nearly instantaneously
p11706
aVThe first one, however, needs to scan the table, because there is no suitable index to use
p11707
aVCreate an index on  to fix this problem
p11708
as(dp11709
g6
V335858
p11710
stp11711
a((dp11712
g2
(lp11713
VYou can use a   of s of s, but  presents a better option in C++
p11714
aVIt lets you store multiple items for the same key without managing vectors inside each map entry
p11715
aVHere is an example of using the map:
p11716
aVEdited to mention hash map
p11717
as(dp11718
g6
V335858
p11719
stp11720
a((dp11721
g2
(lp11722
VWithout preparation on your part, you may need to resort to a hack: when your  deserialization constructor gets the value of , enclose the code in /, and set  to its default value when you catch an exception
p11723
aVIn the future, add an  value  (or any other name that does not collide with arguments that you pass to ), and set it to a constant that you maintain in your class to indicate compatible and incompatible changes in serialization:
p11724
as(dp11725
g6
V335858
p11726
stp11727
a((dp11728
g2
(lp11729
VYou can use  method to find all keys where the value equals
p11730
aVIn the implementation below only the first key will be found
p11731
aVIf you need all keys where the object is , do not assign
p11732
as(dp11733
g6
V335858
p11734
stp11735
a((dp11736
g2
(lp11737
VSince  sets the width for the next output value, not for the previous one, you should move  calls to before the items being formatted:
p11738
as(dp11739
g6
V335858
p11740
stp11741
a((dp11742
g2
(lp11743
VIt is called conditional operator, a kind of ternary operator (as opposed to more familiar binary  or unary  operators)
p11744
aVConditional operator takes a condition, evaluates it, and returns its second or third operand depending on that result
p11745
as(dp11746
g6
V335858
p11747
stp11748
a((dp11749
g2
(lp11750
VYou should add a separate forward declaration of the struct:
p11751
aVSome compilers do take your definition the way you posted it, but I've seen older compilers that require a separate forward declaration
p11752
aVThis may be related to an older standard, or an incomplete standard implementation
p11753
aVIn fact, on a project where we needed to write code that runs on five platforms with different compilers, we made it a companywide coding standard requirement to have the forward declaration separate from the struct's typedef
p11754
as(dp11755
g6
V335858
p11756
stp11757
a((dp11758
g2
(lp11759
VYou can use  to check if the underscore is there:
p11760
as(dp11761
g6
V335858
p11762
stp11763
a((dp11764
g2
(lp11765
VYou should use  instead of , and use a conditional expression inside, like this:
p11766
aVThis example is for SQL Server (see sqlfiddle here), but other RDBMSs have similar capabilities
p11767
as(dp11768
g6
V335858
p11769
stp11770
a((dp11771
g2
(lp11772
VYou can use 's  method to wrap your matrix and write it to file
p11773
as(dp11774
g6
V335858
p11775
stp11776
a((dp11777
g2
(lp11778
VYou can use these rules of thumb to decide what storage model will work for your app
p11779
aVIf the data fits in memory entirely and is relatively unstructured, use plist
p11780
aVIf the data fits in memory entirely and has tree-like structure, use XML
p11781
aVIf the data does not fit in memory and has a structure of a graph, and the app does not need extraordinary query capabilities, use Core Data
p11782
aVIf the data does not fit in memory, has a complex structure, or the app benefits from powerful query capabilities provided by relational databases, use sqlite
p11783
aVIf the data must be secret (e
p11784
ag303
aVa password), use keychain
p11785
aVNote that these choices often overlap, because multiple storage models will fit the same app
p11786
aVYour final decision depends on your personal preferences - you pick a technology that you understand better
p11787
aVThere was a very good question about sqlite vs
p11788
aVCore Data on Stack Overflow, you may want to read through the answers to that question
p11789
as(dp11790
g6
V335858
p11791
stp11792
a((dp11793
g2
(lp11794
VThe condition should be , because  does not change with each iteration of the loop
p11795
aVBetter yet, change your code as follows:
p11796
aVThis would calculate the ending index once, and avoid recalculations in the loop
p11797
as(dp11798
g6
V335858
p11799
stp11800
a((dp11801
g2
(lp11802
VYou need to read registry keys to detect versions at service pack granularity
p11803
aVThis article explains what key/value pairs you need to look for
p11804
aVFor example, you can tell  from  by looking at values inside
p11805
aVplain" 3
p11806
aV5 has , while  has
p11807
aVScroll to the bottom of the article at the link to see the entire table
p11808
as(dp11809
g6
V335858
p11810
stp11811
a((dp11812
g2
(lp11813
VAn object is "declared" equal to another object in
p11814
aVNET is if its  method returns true
p11815
aVYou need to implement that method for your  class, otherwise
p11816
aVNET considers your objects different unless they are reference-equal
p11817
aVThe fact that all fields are the same does not matter to
p11818
aVNET: if you need field-by-field equality semantics, you need to provide an implementation of  that supports it
p11819
aVWhen you override , don't forget to override  as well - these must be overriden together
p11820
aVIf you do not want to or cannot override  for some reason, you could use an overload of  that takes an instance of  to assist in comparing collection elements
p11821
as(dp11822
g6
V335858
p11823
stp11824
a((dp11825
g2
(lp11826
VIf  is compile-time constant, you can speed up your code by avoiding repeated object creation
p11827
aVYou can make your program shorter by one line, too:
p11828
aVAs far as I know,  should be good enough for cryptographic applications, but you may need to consult a cryptography expert if the data that you are planning to protect is of high value to you or especially to your clients
p11829
aVEDIT : Edited in response to nielsbot's comment
p11830
as(dp11831
g6
V335858
p11832
stp11833
a((dp11834
g2
(lp11835
VYou are right, walking trees and graphs recursively in code that does  is a big source of inefficiency
p11836
aVGenerally, you rewrite recursive code with a stack - in a similar way to how it is usually implemented in compiled code
p11837
aVI did not get a chance to try it out, but this should work:
p11838
as(dp11839
g6
V335858
p11840
stp11841
a((dp11842
g2
(lp11843
VLike this:
p11844
aVIf  is negative,  will be reduced by that quantity; otherwise, it will be increased
p11845
as(dp11846
g6
V335858
p11847
stp11848
a((dp11849
g2
(lp11850
VIf you must use regex, you can use  and replace it with an empty string
p11851
aVIt is easier to locate the trailing , and chop off the string at its index
p11852
aVIn C#, that would be
p11853
as(dp11854
g6
V335858
p11855
stp11856
a((dp11857
g2
(lp11858
VYour last attempt was very close: the first line should be
p11859
aVbecause  takes element type as its first parameter
p11860
aVOther than that, it should work perfectly
p11861
as(dp11862
g6
V335858
p11863
stp11864
a((dp11865
g2
(lp11866
VYes - you can call , passing the desired number of milliseconds
p11867
aVYour running code will pause, wait for the number of milliseconds that you passed, and then resume execution
p11868
aVThis technique is universal - it would work in winforms or in console applications
p11869
aVIn winforms you should not make a call to  from the UI thread
p11870
aVInstead, you should split your method in two - before the delay and after the delay, spawn a thread with a , and call the second part of your code through
p11871
as(dp11872
g6
V335858
p11873
stp11874
a((dp11875
g2
(lp11876
VYou are close - there needs to be something that removes the first element when the  operation fails
p11877
aVAlso, your "copy" rule was not entirely correct
p11878
aVTry this:
p11879
as(dp11880
g6
V335858
p11881
stp11882
a((dp11883
g2
(lp11884
VThere are two things that are obviously wrong:
p11885
aVYou do not need variable , because one of the dimensions is fixed, and you "unrolled" the loop five times
p11886
aVYou swapped the indexes:  should go first, that's the one changing from  to
p11887
aVFor example:
p11888
aVYou could put the loop back to shorten your code:
p11889
as(dp11890
g6
V335858
p11891
stp11892
a((dp11893
g2
(lp11894
VNo, you cannot do that
p11895
aVThe compiler builds a state machine to implement , and the calling code that enumerates through your enumerable is as much a part of its working as your code is
p11896
aVThe compiler builds a hidden object that stores the current state of your code, including its call stack and locals, and it calls different pieces of your method as the caller invokes  and
p11897
aVTrying to enumerate your object from the beginning while another enumeration is in progress would mess up the ongoing enumeration, which would not be good
p11898
aVIn this particular case, you don't want it to happen either: the implementation of  does not store the values that you produce, so if even if you could access your own  while enumerating, it would recursively call back itself multiple times to produce each new item, so it would take you ridiculously long time to produce even a moderate number of primes
p11899
as(dp11900
g6
V335858
p11901
stp11902
a((dp11903
g2
(lp11904
VEven though the  is the same as , passing character by reference does take more bytes on most systems: although the standard does not say anything specific about the implementation of references, an address (i
p11905
ag630
aVa pointer) is regularly passed behind the scenes
p11906
aVWith optimization on, it probably would not matter
p11907
aVWhen you code template functions, items of unknown type that will not be modified should always be passed by const reference
p11908
aVAs far as small types go, you can pass them by value with a  qualifier to emphasize the point that you aren't going to touch the argument through the signature of your function:
p11909
as(dp11910
g6
V335858
p11911
stp11912
a((dp11913
g2
(lp11914
Vshould be
p11915
aVOtherwise, you are writing an extra  that is part of zero-termination of your  string constant ( is two, not one)
p11916
as(dp11917
g6
V335858
p11918
stp11919
a((dp11920
g2
(lp11921
VThe problem with  part of the rule is that it keeps unifying unconditionally with itself at each level, and keeps recursing down; there is no exit condition out of this recursion
p11922
aVYou should make the argument swap at the level above:
p11923
aVAlternatively, you could make underlying rules below symmetric where it makes sense:
p11924
aVYou could now rewrite your  rule as follows:
p11925
as(dp11926
g6
V335858
p11927
stp11928
a((dp11929
g2
(lp11930
VThis depends a lot on what you are trying to achieve: for flexibility, hash map is better
p11931
aVBut the flexibility comes at a price: hash map is also larger and slower than a class with the identical number of strongly-typed fields
p11932
aVHash map has larger memory footprint than a class with identical number of fields
p11933
aVHash map forces boxing on primitives
p11934
aVHash map is slower to create and access
p11935
aVThere is also an impact on readability: when you business logic is specific to a class with a fixed number of fields, a special-purpose class clearly wins; when the fields are configured dynamically, hash table is your only option
p11936
aVYou could also have a hybrid design, when an object uses a hash map for its storage internally, presents nicely named fields externally, and exposes semantics to add more "fields" as you go
p11937
aVTo summarize, before you decide to go with a hash map for its flexibility, you should decide if you really need all that flexibility in your design
p11938
aVSometimes, the answer is "yes", and sometimes it is "no"; there is no "one size fits all" solution to this
p11939
as(dp11940
g6
V335858
p11941
stp11942
a((dp11943
g2
(lp11944
VThe reason it does not work is that you are calling  on a wrong instance of
p11945
aVYour  class creates its own, invisible,  object, stores it in a  variable, and disables its buttons; the form object that is visible to you does not get modified
p11946
aVTo fix this, you should pass the instance of your  form to the constructor of , and set it to a variable:
p11947
aVThe code that creates an instance of  class should pass the form as a parameter to the constructor:
p11948
as(dp11949
g6
V335858
p11950
stp11951
a((dp11952
g2
(lp11953
VThis is relatively straightforward: first, you need a rule that checks if a list  a value:
p11954
aVThen you need a rule that finds the first duplicate
p11955
aVNote the use of the cut operator  - it makes the rule stop after finding a duplicate
p11956
aVFinally, your  rule finds the first duplicate, cuts (very important), and checks that the first dup matches the value that you are checking
p11957
aVEDIT : If you are looking for the first consecutive duplicate, the program is even easier: you remove the  predicate, and rewrite the  as follows:
p11958
aVNow the predicate matches only when it finds two consecutive items
p11959
as(dp11960
g6
V335858
p11961
stp11962
a((dp11963
g2
(lp11964
V is a descendant of , so it can go wherever an  can go: , , and so on
p11965
aVPrimitives such as  and  cannot go in these classes, because they do not inherit from , and hence cannot participate in collections etc
p11966
aVIf I were to guess on the internals of
p11967
aVI'd say it's a union and a type selector field
p11968
aVHowever, the beauty of encapsulation lets me successfully program to  without knowing a first thing about its representation (and not missing that knowledge)
p11969
as(dp11970
g6
V335858
p11971
stp11972
a((dp11973
g2
(lp11974
VYou can use :
p11975
aVThis means "if the absolute difference between a and b is within 2
p11976
as(dp11977
g6
V335858
p11978
stp11979
a((dp11980
g2
(lp11981
VIf you insist on using "plain C" 2D arrays, the best thing is to pass a pointer to the result along with the two input parameters, rather than passing the arrays by value the way you did
p11982
aVHowever, the best thing to do in C++ is to use  instead, and pass it by reference
p11983
as(dp11984
g6
V335858
p11985
stp11986
a((dp11987
g2
(lp11988
VA common practice is to put all your state in your model class (as in "model - view - controller" pattern), and make your model a singleton
p11989
aVThen all globals go into the model class as properties, or become hidden behind publicly available methods
p11990
aVThis is better than scattered globals, because the readers of your code will need to look in a single place for all the state information of your application
p11991
aVHere is a stack overflow question with a relevant discussion
p11992
as(dp11993
g6
V335858
p11994
stp11995
a((dp11996
g2
(lp11997
VSince you know the index path of your target cell, you can call  to bring your cell into the view
p11998
aVThen the  will be created in the usual way - through a delegate
p11999
as(dp12000
g6
V335858
p12001
stp12002
a((dp12003
g2
(lp12004
VReverse your  loop to avoid calling  twice and discarding every other result:
p12005
as(dp12006
g6
V335858
p12007
stp12008
a((dp12009
g2
(lp12010
VYou can use reflection, iterate over metadata of your class, and pull fields through the reflection API
p12011
aVObviously, there is a cost attached to that: using reflection is slower than accessing fields directly; sometimes, considerably
p12012
aVHowever, you can certainly do it
p12013
aVHere is an example:
p12014
aVclass exposes many useful properties, such as  and , letting you pick which fields to include in your processing, and which fields to ignore
p12015
as(dp12016
g6
V335858
p12017
stp12018
a((dp12019
g2
(lp12020
VIn Java  represents a path name to a file or a directory, not a writable file stream
p12021
aVIf you need to create a file, call  on the  object:
p12022
as(dp12023
g6
V335858
p12024
stp12025
a((dp12026
g2
(lp12027
VUnfortunately, you cannot use va_arg like that:
p12028
aVNotice also that va_arg does not determine either whether the retrieved argument is the last argument passed to the function (or even if it is an element past the end of that list)
p12029
aVThe function should be designed in such a way that the amount of parameters can be inferred in some way by the values of either the named parameters or the additional arguments already read
p12030
aVA common "workaround" is to give the other "overload" a nice mnemonic name, such as
p12031
aVIt will not look as fancy, but it will certainly run faster
p12032
aVIf duplicating implementation is your concern, you could implement , , and  as wrappers to a hidden function that takes  and  as signed integers, and interprets negative numbers as missing parameters
p12033
aVIt is probably not a good idea to use this "convention" in your public interface, but it would probably work fine in a private implementation
p12034
as(dp12035
g6
V335858
p12036
stp12037
a((dp12038
g2
(lp12039
VYou can address this issue inside your  method
p12040
aVAssuming that you have implemented your static cells the way Apple's guide suggests, your  should look like a sequence of  statements returning the cells provided through  objects:
p12041
aVModify this code as follows:
p12042
aVWhen all text properties have been set, call  to force all cells to go through your  and get reconfigured
p12043
as(dp12044
g6
V335858
p12045
stp12046
a((dp12047
g2
(lp12048
VYou can serialize a completely initialized onject into a binary file, add that file as a resource, and load it into your array on startup
p12049
aVIf your constructors are CPU-intensive, you might get an improvement
p12050
aVSince your code appears to perform some sort of parsing, the chances of getting a decent improvement there are fairly high
p12051
as(dp12052
g6
V335858
p12053
stp12054
a((dp12055
g2
(lp12056
VBecause you reinterpret it in  as a signed integer
p12057
aVYou should use  to see an unsigned value
p12058
aVThere is no way for a function with variable number of arguments to know with certainty the type of the value that you pass
p12059
aVThat is why  relies on the format string to learn how many parameters you passed, and what their types are
p12060
aVIf you pass a type that does not match the corresponding format specifier,  will trust the specifier and interpret your data according to it
p12061
aVModern compilers may even warn you about it
p12062
as(dp12063
g6
V335858
p12064
stp12065
a((dp12066
g2
(lp12067
VThere is no universal header, but you can certainly make one for your application, and include it in all your files
p12068
aVIf you are not sure what file to include for a function that you need to call, you can use  command on UNIX
p12069
aVFor example,
p12070
aVshows this:
p12071
aVSYNOPSIS
p12072
aVIf you stay with it for enough time, you usually remember the "mapping" of functions to headers relatively quickly
p12073
as(dp12074
g6
V335858
p12075
stp12076
a((dp12077
g2
(lp12078
VYou could do your ORs ahead of ANDs:
p12079
aVThe initial shift  will be optimized out - it's there for consistent look
p12080
as(dp12081
g6
V335858
p12082
stp12083
a((dp12084
g2
(lp12085
VSplitting the string, counting parts, and throwing them away is not efficient
p12086
aVSearching for substring repeatedly without creating new objects would definitely be more efficient
p12087
aVSince the string is relatively long, you may benefit from implementing an advanced string search algorithm, for example Knuth-Morris-Pratt, to significantly decrease your search time
p12088
aVHere is an implementation that should be faster than your splitting code:
p12089
as(dp12090
g6
V335858
p12091
stp12092
a((dp12093
g2
(lp12094
VIf you cannot sacrifice a value, say, the smallest negative or a largest positive , to mean "not set", you need to keep track of what's set on the side
p12095
aVIn C++ you can use :
p12096
as(dp12097
g6
V335858
p12098
stp12099
a((dp12100
g2
(lp12101
VThis expression is ugly, but it would not overflow even for "borderline" values of
p12102
as(dp12103
g6
V335858
p12104
stp12105
a((dp12106
g2
(lp12107
VThe simplest way to reverse a string or any other container without an explicit loop in C++ is to use reverse iterators:
p12108
as(dp12109
g6
V335858
p12110
stp12111
a((dp12112
g2
(lp12113
VNo, you have to perform all these operations in your designated initializer, so there's no easy shortcut
p12114
aVTheoretically, you can go a macro route, but the macro is not going to be pretty, and it will be counterintuitive to the readers of your code
p12115
aVThis code is not much shorter, and it is a lot less familiar to others
p12116
aVI strongly recommend agains it
p12117
as(dp12118
g6
V335858
p12119
stp12120
a((dp12121
g2
(lp12122
VImages do not necessarily come from files or other named sources, so not all images even have a name
p12123
aVWhen you create an image from a file, you could store the name in a separate , and then refer to that stored name when necessary
p12124
as(dp12125
g6
V335858
p12126
stp12127
a((dp12128
g2
(lp12129
VIf there is a symbol that does not appear anywhere in your string, say, , you can do it like this:
p12130
aVTo be sure, this is suboptimal in terms of CPU cycles, but it does the trick in terms of staying on a single line
p12131
as(dp12132
g6
V335858
p12133
stp12134
a((dp12135
g2
(lp12136
VYou can subtract one, do , and add one back:
p12137
aVThis illustrates a problem of fighting the convention: instead of a simple  operation, you need a subtraction, a , and an addition
p12138
aVTather than fighting the C/C++ convention, it's best to embrace it for more efficiency and readability by others
p12139
as(dp12140
g6
V335858
p12141
stp12142
a((dp12143
g2
(lp12144
VA person has only one name, but might have multiple phone numbers
p12145
aVYou need to get all known phones, like this:
p12146
aVThen you can look for a specific number (home, work, mobile, etc
p12147
aVinside the
p12148
aVSame goes for the address
p12149
aVHere is a good answer demonstrating the technique; it's pre-ARC, so naturally you will need to add  to the casts
p12150
as(dp12151
g6
V335858
p12152
stp12153
a((dp12154
g2
(lp12155
VThis is because you lack a control statement that skips the second  when the first one succeeds
p12156
aVWhen you come into the block with , you switch it to , and then the second condition succeeds immediately, and you turn  back into
p12157
aVYou can an an  to fix this, but you can skip the  altogether by using an  that maps the current state to the new state
p12158
as(dp12159
g6
V335858
p12160
stp12161
a((dp12162
g2
(lp12163
VYou can use  as your expression and  as your replacement
p12164
aVThis is, however, hardly a good use for regexp: you can do it much easier with
p12165
as(dp12166
g6
V335858
p12167
stp12168
a((dp12169
g2
(lp12170
VYou could divide by , or change  to  in order to force a conversion to
p12171
aVOtherwise, you are getting integer division, which truncates off the decimal part
p12172
aVHere is a relevant question: "Java Integer Division, How do you produce a
p12173
as(dp12174
g6
V335858
p12175
stp12176
a((dp12177
g2
(lp12178
V and  fit your requirements ideally: if you put the value into the  and the index in , you can simply call a  on a vector of s, like this:
p12179
as(dp12180
g6
V335858
p12181
stp12182
a((dp12183
g2
(lp12184
VIt looks like one of the  objects that you are comparing with  is set to
p12185
aVThe built-in operator  compares the references and does not break, but your operator tries to dereference the task, and breaks
p12186
aVThis implementation returns  when both tasks are
p12187
aVYou should implement a symmetric null checking in the  operator
p12188
as(dp12189
g6
V335858
p12190
stp12191
a((dp12192
g2
(lp12193
VThe constant should be  (with a backslash), not  (with a forward slash)
p12194
as(dp12195
g6
V335858
p12196
stp12197
a((dp12198
g2
(lp12199
VYou can safely  any object that inherits from
p12200
aVThe  method will be called to produce the output
p12201
aVThe default implementation returns the name of the class, but you are free to override  on your own objects to produce any text that you think may be of help to you during debugging
p12202
as(dp12203
g6
V335858
p12204
stp12205
a((dp12206
g2
(lp12207
VYou cannot sort a  without relying on details of current implementation, but you can process its entries in any specific order using LINQ's sorting functionality:
p12208
aVPurely as a curiosity, you can pass ordered key-value pairs to 's constructor, and the resulting dictionary will enumerate in the order the items were provided in the enumeration to the constructor
p12209
aVHowever, relying on this functionality is very dangerous; you should not do it in your code
p12210
as(dp12211
g6
V335858
p12212
stp12213
a((dp12214
g2
(lp12215
VCatching all exceptions like this is not a good practice, except at the top level of your application, where you display a nice error message
p12216
aVDone right, it could preserve end user's perception of your program as slightly buggy, but reasonable overall
p12217
aVIn contrast, letting your application crash is the easiest way to convince your end users that your application is bad beyond repair
p12218
aVAs far as exception prevention goes, there are two major kinds of exceptions - programming errors (null pointer, class cast, out of range, etc
p12219
aVand environment errors (file not found, network path is unavailable, user entry error, etc
p12220
aVYou can and should avoid the first kind, and be prepared to handle the second kind
p12221
as(dp12222
g6
V335858
p12223
stp12224
a((dp12225
g2
(lp12226
VConsider your observable collection as a data source for a table
p12227
aVEach object from the collection occupies one row, and is displayed in the table across multiple columns
p12228
aVThe view (i
p12229
ag630
aVyour table) needs to know when to modify each cell in response to changing properties of objects, but also in response to adding and removing objects to and from the collection
p12230
aVYour observable collection takes care of dealing with table rows: it notifies its observers when an object gets inserted, removed, moved, and so on
p12231
aVHowever, it lacks knowledge of what's going on with individual objects, so it is of no help in dealing with table columns
p12232
aVThis is where your objects come in: by implementing  they let your table manage the data in the columns
p12233
as(dp12234
g6
V335858
p12235
stp12236
a((dp12237
g2
(lp12238
VSince this is homework, I will not post any code
p12239
aVIf you are not allowed to use , you can implement Selection Sort - it is very simple, and you have the beginnings of it written in your code already
p12240
aVThe idea is on each iteration of the outer loop on  to pick the smallest element in the segment from  to  using the inner loop on , and place that element at the -th position of your array
p12241
aVYour inner loop should look like this:
p12242
aVNow based on your  condition you either swap -th element with -th, or keep it in place and move on
p12243
aVFor sorting strings, use  method in your  condition
p12244
as(dp12245
g6
V335858
p12246
stp12247
a((dp12248
g2
(lp12249
VThe absolute value of  is probably not a culprit: allocating 30 pointers should go without trouble on any computer, including most micro-controllers
p12250
aVUsing  is not going to change anything: you are doing your allocation the way you're supposed to do it in C++
p12251
aVHere is the likely source of your error:
p12252
aVYou have allocated storage for  items, so the valid indexes are between  and
p12253
aVWriting one past the last element is undefined behavior, meaning that a crash could happen
p12254
aVYou got lucky with 20 elements, but 30 smoked out this bug for you
p12255
aVUsing  utility is a good way to catch memory errors that could cause crashes, even if they currently don't cause them
p12256
as(dp12257
g6
V335858
p12258
stp12259
a((dp12260
g2
(lp12261
VYou cannot combine variable declarations with
p12262
aVIf you would like to create an alias for  and call it simply , modify your code as follows:
p12263
as(dp12264
g6
V335858
p12265
stp12266
a((dp12267
g2
(lp12268
VYou can express the condition a little differently:
p12269
aVEither both  and  must be , or
p12270
aVmust be equal to
p12271
aVselect *
p12272
aVfrom myTable
p12273
aVWHERE ([myIDcolumn] is null AND @recID is null) OR  [myIDcolumn] = @recID
p12274
as(dp12275
g6
V335858
p12276
stp12277
a((dp12278
g2
(lp12279
VYou can think of the five-letter code as a number in base-62 notation: your "digits" are 26 lowercase and 26 uppercase letters, and digits from 0 to 9
p12280
aV(26+26+10) digits in total
p12281
aVGiven a number from 0 to  (which equals 916132832) (say, your primary key) you can do the conversion to a five-digit base-62 as follows:
p12282
aVHere is how to generate cryptographically strong random numbers (you need to add a reference to ):
p12283
as(dp12284
g6
V335858
p12285
stp12286
a((dp12287
g2
(lp12288
VIt is not a matter of efficiency, it is a matter of correctness: the two options that you presented do not model the same relationship between the records in the tables
p12289
aVEach record in the database means something
p12290
aVIf the meaning of the record in the junction table is "X coached at the camp Y of the school Z", then you should go with the option 2; if you are looking to model the meanings "X coached at the camp Y" independently of "X coached for school Z" and independently of "School Z ran camp Y", then you should go with option 1
p12291
aVIn both cases you should give your junction records independent primary keys, rather than relying on three-way combination of IDs: it will simplify your life when you implement code that applies corrections to the junction table
p12292
as(dp12293
g6
V335858
p12294
stp12295
a((dp12296
g2
(lp12297
VFrom the Java documentation:
p12298
aVNote that it is generally necessary to override the  method whenever this method [] is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes
p12299
aVSince  is an enum, adding this code to your class should fix it:
p12300
as(dp12301
g6
V335858
p12302
stp12303
a((dp12304
g2
(lp12305
VI think the error is on this line:
p12306
aVYou cannot print an array of integers like this: you should either convert it to string, or write a loop that prints the array digit by digit:
p12307
aVYou do not need to pass in the output array as well: you can create it inside the function
p12308
as(dp12309
g6
V335858
p12310
stp12311
a((dp12312
g2
(lp12313
VYou have to rewrite your loop: you should not make a decision that the apartment is not found until you finish the loop
p12314
aVYou do not need to assign the value to the temporary variable either - once the apartment is found, return it right away
p12315
aVYou can report that the apartment is not found only when you finish the loop
p12316
as(dp12317
g6
V335858
p12318
stp12319
a((dp12320
g2
(lp12321
VUse
p12322
aVThis method returns a Boolean with a value represented by the specified String
p12323
aVThe Boolean returned represents the value true if the string argument is not null and is equal, ignoring case, to the string "true"
p12324
as(dp12325
g6
V335858
p12326
stp12327
a((dp12328
g2
(lp12329
VUsing return code to indicate errors in Java is an anti-pattern
p12330
aVYou should use exceptions instead
p12331
aVIf an error is due to a programming error (invalid parameters, incorrect state), throw an instance of unchecked exception
p12332
aVWhen the error is because something went wrong in the environment (cannot connect to a server, cannot find a required file), throw a checked exception
p12333
as(dp12334
g6
V335858
p12335
stp12336
a((dp12337
g2
(lp12338
VThe simplest way is to convert  to , and use bit arithmetic:
p12339
as(dp12340
g6
V335858
p12341
stp12342
a((dp12343
g2
(lp12344
VThe reason you see this behavior is that  format is locale-specific
p12345
aVIn Japan, it formats the month as month's number followed by the  character
p12346
aVIf you would like a three-letter name of the months to be displayed regardless of the locale, pick US as the locale for your formatter:
p12347
as(dp12348
g6
V335858
p12349
stp12350
a((dp12351
g2
(lp12352
VPassing a pointer to a pointer (not a reference to a pointer, because C does not have references at all) would be a better solution, because you'd be able to null it out after the deletion
p12353
aVAs it is currently defined, the function may leave dangling pointers behind if its caller is not careful
p12354
aVOther than that little problem, this solution is valid: the caller can always assign  to the list head manually after passing it to
p12355
aVHere is how I would rewrite this with a pointer to pointer:
p12356
as(dp12357
g6
V335858
p12358
stp12359
a((dp12360
g2
(lp12361
VYou misunderstood the way  is used: it is not a number, it is a class that can be used to generate random numbers
p12362
aVTry this:
p12363
aVEvery time you call  you get a new random number
p12364
aVIf you would like the sequence of random numbers to be repeatable, pass a number (any number) to the constructor of the
p12365
aVBeware that every time you run your program the result will stay the same
p12366
as(dp12367
g6
V335858
p12368
stp12369
a((dp12370
g2
(lp12371
VYou need to use merge, it lets you match the data that you are trying to update or insert ("upsert") against the data that is currently in the table, and perform different actions based on the presence or absence of a match
p12372
aVThis example is from here
p12373
as(dp12374
g6
V335858
p12375
stp12376
a((dp12377
g2
(lp12378
VYou need another table to store invoices (what you call  now actually stores invoice items)
p12379
aVThis is the classic way of modeling a many to many relationship using a junction table (i
p12380
ag630
ag1783
as(dp12381
g6
V335858
p12382
stp12383
a((dp12384
g2
(lp12385
VIn order to be able to call method of subclasses polymorphically, you need to define a method with the same signature in the base class
p12386
aVYou do not need to make the class abstract, but in this case it makes sense to do so, because there are no genderless humans
p12387
aVHowever, if you would like to share some implementation among methods of derived classes, you could put common code in the base class implementation:
p12388
as(dp12389
g6
V335858
p12390
stp12391
a((dp12392
g2
(lp12393
VThis happens because you cannot assign a whole array at once
p12394
aVYou can assign a pointer, however:
p12395
aVNow your swap routine is going to work without further modifications
p12396
aVYou could also swap arrays one element at a time, but it is going to involve a lot more data copying
p12397
as(dp12398
g6
V335858
p12399
stp12400
a((dp12401
g2
(lp12402
VO'Reilly published a book called Programming Embedded Systems in C and C ++
p12403
aVThe book dedicates an entire chapter to precisely this exercise (the chapter is called, not surprisingly, "Das Blinkenlights")
p12404
as(dp12405
g6
V335858
p12406
stp12407
a((dp12408
g2
(lp12409
VSince  is between  and , you could do this:
p12410
aVThe idea is to chop off the right number of zeros from a string containing four elements
p12411
as(dp12412
g6
V335858
p12413
stp12414
a((dp12415
g2
(lp12416
VIt consumes more memory for new objects, that's right
p12417
aVBut that fact in itself does not create an issue, because garbage collector promptly reclaims all inaccessible memory
p12418
aVOf course you can turn it into an issue by creating links to the newly created strings, but that would be an issue of your program, not of JVM
p12419
as(dp12420
g6
V335858
p12421
stp12422
a((dp12423
g2
(lp12424
VYour approach works fine, but it does more work than it is necessary by writing the results every time the collection is modified
p12425
aVIt is writing of the file that is the costliest part of your  and  methods
p12426
aVOne way to address the problem would be to read your categories when your app starts up, cache your  in a singleton object, and reference it as your app runs
p12427
aVWhen end users make changes, you update the dictionary only in memory; do not write the data to the file immediately
p12428
aVIn your app delegate, listen to the  event, and write the data to the file in that handler
p12429
aVAlso listen to the  event, and read your file into
p12430
aVThis will save you a lot of CPU cycles, and provide smoother end-user experience
p12431
as(dp12432
g6
V335858
p12433
stp12434
a((dp12435
g2
(lp12436
VYou need to cast s to enums in C++, but you can hide the cast in a custom  operator:
p12437
aVWith this operator in place, you can write your original
p12438
aVand it will compile and run without a problem
p12439
as(dp12440
g6
V335858
p12441
stp12442
a((dp12443
g2
(lp12444
VIn general, yes, you can encode the rules of English to produce ordinal numbers
p12445
aVHowever, the first nineteen words will inevitably end up in a lookup table, because they are exceptions
p12446
aVIn case of numbering days of the month, the range of exceptional values (1 through 19) covers roughly 60% of the total number of word sequences that you need to produce, so it would make sense to skip the algorithm altogether, and put everything in a lookup table
p12447
aVThis would improve readability, and simplify internationalization in case you decide to support languages other than English
p12448
as(dp12449
g6
V335858
p12450
stp12451
a((dp12452
g2
(lp12453
VA common way to share data across classes in iOS apps is by following the singleton pattern
p12454
aVSystemModel
p12455
ag1177
aVSystemModel
p12456
aVm
p12457
aVNow you can use your instance like this:
p12458
aVYou could also convert instance variables to properties, and use the dot syntax
p12459
aVIt does not matter for floats and arrays, but for -based objects using properties is preferred
p12460
as(dp12461
g6
V335858
p12462
stp12463
a((dp12464
g2
(lp12465
VThe easiest way to start with delegates is by using pre-defined ones
p12466
aVFor example, a delegate that takes no arguments and returns a  would be
p12467
aVA delegate that takes a  and an , and returns a  would be , and so on
p12468
aVYou define your method like this:
p12469
aVYou can now call  like this:
p12470
aVYou can also use lambdas to inline small methods, like this:
p12471
as(dp12472
g6
V335858
p12473
stp12474
a((dp12475
g2
(lp12476
VI think your expression should be rewritten as follows:
p12477
aVIn simple terms,  flattens a "list of lists of items A" into a "list of items B" using a functor that extracts a list of items B from each single item A; this is not what you want to do
p12478
as(dp12479
g6
V335858
p12480
stp12481
a((dp12482
g2
(lp12483
VSince  is a longer version of the number that includes contact number as a substring, I think you want your search condition to be the other way around:
p12484
aVThis SQL Server version
p12485
aVIn Oracle or MySQL use
p12486
as(dp12487
g6
V335858
p12488
stp12489
a((dp12490
g2
(lp12491
VEven though  has only four data members (x, y, z, and a timestamp) it is not a , and therefore it does not let you refer to it statically (i
p12492
ag630
aVyou need to use a pointer)
p12493
aVThis is in contrast to , which is a C , so you can use it both through a pointer or without a pointer
p12494
aVUnfortunately, there is no way around copying the values in which you are interested: you are absolutely right that once the thread leaves your handler,  object may get reused behind your back
p12495
aVdoes not conform to copying protocol either, so you would need to write that copy routine yourself
p12496
as(dp12497
g6
V335858
p12498
stp12499
a((dp12500
g2
(lp12501
V offers a  method, which you can use as follows:
p12502
aVThis does not make a copy of the element, only builds a view into the vector
p12503
aVYou could add copying as follows:
p12504
as(dp12505
g6
V335858
p12506
stp12507
a((dp12508
g2
(lp12509
VYou need to create  with a comma and a dot in it, and use this method:
p12510
aVHere is an example:
p12511
as(dp12512
g6
V335858
p12513
stp12514
a((dp12515
g2
(lp12516
VAlthough you can initialize an array of characters from a string literal like this
p12517
aVyou cannot assign a string literal to an array of characters the way you are trying to do
p12518
aVYou need to copy your string into the character array using one of the string copy functions:
p12519
aVIf yo would like to copy  into the first four elements and pad the remaining elements of  with zeros, use :
p12520
aVIt is worth pointing out that you could make  a pointer, and either allocate memory for your strings dynamically, or assign it directly:
p12521
as(dp12522
g6
V335858
p12523
stp12524
a((dp12525
g2
(lp12526
VInstead of cutting off your literal, you could use  constructor that copies fewer characters than is available in your :
p12527
aVThis prints
p12528
aVThis approach is less wasteful than making a  and taking a substring
p12529
as(dp12530
g6
V335858
p12531
stp12532
a((dp12533
g2
(lp12534
VThis is because you are comparing s using
p12535
aVYou should use  instead
p12536
as(dp12537
g6
V335858
p12538
stp12539
a((dp12540
g2
(lp12541
VYou can use  class, like this:
p12542
aVYou may need to play with your regular expression to get it just right
p12543
aVThe reference that I liked describes the grammar of the regex language supported by Apple's classes
p12544
as(dp12545
g6
V335858
p12546
stp12547
a((dp12548
g2
(lp12549
VI would avoid using  as my primary key, opting for a unique index instead:
p12550
as(dp12551
g6
V335858
p12552
stp12553
a((dp12554
g2
(lp12555
VThe constructor does not specify a return type because it would be redundant: there is no type other than the one being constructed that a constructor could potentially "return"
p12556
aVI put "return" in quotes because technically constructors do not return anything: when they are invoked in a static context, they initialize an instance in place; when they are invoked in a dynamic context, it is the operator  that returns something, not a constructor
p12557
as(dp12558
g6
V335858
p12559
stp12560
a((dp12561
g2
(lp12562
VYour solution is good
p12563
aVYou can fight the additional verbosity by adding a type conversion to , letting you use  wherever a  could go
p12564
as(dp12565
g6
V335858
p12566
stp12567
a((dp12568
g2
(lp12569
VThe book is trying to teach you a particular programming technique called memoization, a kind of broader technique known as dynamic programming
p12570
aVOf course in real life knowing a closed-form solution is much better, but not in the context of solving this exercise
p12571
aVAnyway, the idea is to pass a 2D array as your fourth parameter, fill it with s initially, and check if there's a solution for the given combination of  and  in the array before computing anything
p12572
aVIf there is, return it; if there isn't, compute it recursively, store in the array, and only then return it
p12573
as(dp12574
g6
V335858
p12575
stp12576
a((dp12577
g2
(lp12578
VAbsolutely: all that can be computed one item at a time
p12579
aVKeep the current minimum and the current maximum, compute the running total, and the count
p12580
aVWhen you need the average, divide the running total by the count, and you'll get your answer
p12581
as(dp12582
g6
V335858
p12583
stp12584
a((dp12585
g2
(lp12586
VSince the size of  is 6 KB (assuming 32-bit s), it might be too big for allocation on the stack
p12587
aVTry moving it outside your , or allocate it dynamically
p12588
aVIf you move the declaration outside , make it static to avoid giving it global visibility
p12589
as(dp12590
g6
V335858
p12591
stp12592
a((dp12593
g2
(lp12594
VHandling CSV parsing is a lot tricker than your initial code implies, because quoted separators need to be ignored
p12595
aVFor example,
p12596
aVhas three columns, but  would find four tokens (, , "world
p12597
aV, and )
p12598
aVThere are many special cases to handle in order to build a full-featured CSV parser, so the fastest way to get it working is to use a pre-built one
p12599
aVFor example, you could use the parser described in this answer on Stack Overflow
p12600
as(dp12601
g6
V335858
p12602
stp12603
a((dp12604
g2
(lp12605
VThe easiest way is to use  member function of
p12606
aVThis solution works with both forward and back slashes
p12607
as(dp12608
g6
V335858
p12609
stp12610
a((dp12611
g2
(lp12612
VThis is because you are assigning to backing variables in your
p12613
aVYou should use  rewrite your code as follows:
p12614
aVThis would assign values through properties, which calls  for you
p12615
aVThe way your code is written now, the pointer is simply copied into ivars without calling , which ultimately causes the issue that you describe
p12616
as(dp12617
g6
V335858
p12618
stp12619
a((dp12620
g2
(lp12621
VYour first example is incorrect:  ensures that  is called on the variable declared inside  upon exiting
p12622
aVTherefore your first example returns a disposed object, which is almost certainly wrong
p12623
aVIn general, the  block is roughly equivalent to this:
p12624
aVSince this is a very common pattern in C#, a special syntax is provided for your convenience
p12625
as(dp12626
g6
V335858
p12627
stp12628
a((dp12629
g2
(lp12630
VI think that you are missing a call that emits return:
p12631
as(dp12632
g6
V335858
p12633
stp12634
a((dp12635
g2
(lp12636
VYou should move the  part to the end of the declaration, and add a semicolon after the forward declaration of
p12637
aVThere are also inaccuracies in the remaining of your code:
p12638
aVhas extra semicolon, should be
p12639
aVshould be
p12640
aVSemicolons are missing in a few places
p12641
aVa  is at the end of one line that shouldn't be there
p12642
aVneeds to return an
p12643
as(dp12644
g6
V335858
p12645
stp12646
a((dp12647
g2
(lp12648
VAnswering this question is not possible without making some quite unreasonable assumptions
p12649
aVSpatial locality is as much about algorithms as it is about data structures, so grouping logically related data elements together may be of no consequence or even worse based on an algorithm that you use
p12650
aVFor example, consider a representation of 100 points in 3D space
p12651
aVYou could put them in three separate arrays, or create a 3-tuple struct/class, and make an array of these
p12652
aVIf your algorithm must get all three coordinates of each point at once on each step, the tuple representation wins
p12653
aVHowever, think what would happen if you wanted to build an algorithm that operates on each dimension independently, and paralelize it three-way among three independent threads
p12654
aVIn this case three separate arrays would win hands down, because that layout would avoid false sharing, and improve spatial locality as far as the one-dimension-at-a-time algorithm is concerned
p12655
aVThis example shows that there is no "one size fits all" solution
p12656
aVSpatial locality should always be considered in the context of a specific algorithm; a good solution in one case could turn bad in other seemingly similar cases
p12657
as(dp12658
g6
V335858
p12659
stp12660
a((dp12661
g2
(lp12662
VYou need to add a pair of parentheses around (*argv) to change the order of evaluation
p12663
aVThe way you currently have it, the [1] is evaluated first, yielding an invalid pointer, which then gets dereferenced, causing undefined behavior
p12664
as(dp12665
g6
V335858
p12666
stp12667
a((dp12668
g2
(lp12669
VWith pre-C99 C you could initialize only the first member of the union
p12670
aVHowever, starting with C99 if you provide a name for the union member, you could use C99 feature of designated initializers:
p12671
as(dp12672
g6
V335858
p12673
stp12674
a((dp12675
g2
(lp12676
VFor positive numbers, you can use  function to get , and  to get the  part
p12677
aV(I linked C++ reference, but the same function is present in the C library)
p12678
as(dp12679
g6
V335858
p12680
stp12681
a((dp12682
g2
(lp12683
V implies a  argument, but you are passing
p12684
aVYou should make your variables , not a :
p12685
aVIt would also make sense to convert  to lower case before comparing to  and , because you ask end-users to enter uppercase  or
p12686
aVEDIT in response to the edit of the question: You cannot use  to read a value into
p12687
aVYou should use , and limit the length in the :
p12688
as(dp12689
g6
V335858
p12690
stp12691
a((dp12692
g2
(lp12693
VYou are passing an array of pointers in an ARC environment
p12694
aVYou need to specify one of the following:
p12695
aV__strong
p12696
aV__weak
p12697
aV__unsafe_unretained
p12698
aV__autoreleasing
p12699
aVI think in your case  should work, assuming that you do not do anything to the shapes that you pass to  concurrently
p12700
as(dp12701
g6
V335858
p12702
stp12703
a((dp12704
g2
(lp12705
VThey are hinting at method overloading, which is sometimes referred to as a compile-time polymorphism
p12706
aVIndeed, method overloading lets you invoke different pieces of code based on the types of objects passed in as parameters
p12707
aVOverloads are resolved at compile time, so the mechanism of overloading could be thought of as a compile-time polymorphism
p12708
as(dp12709
g6
V335858
p12710
stp12711
a((dp12712
g2
(lp12713
VThe constructors of abstract and non-abstract classes are not different; the classes, however, are different, and the compiler knows about that
p12714
aVThis is the reason the construction of abstract classes the way you show in the post is prohibited: the compiler simply checks the  flag, and disallows the construction at compile time
p12715
aVMoreover, CLR also has a runtime flag indicating that a class is abstract
p12716
aVThat is why you wouldn't be able to instantiate an abstract class at runtime through reflection
p12717
as(dp12718
g6
V335858
p12719
stp12720
a((dp12721
g2
(lp12722
VYou current regex matches
p12723
aVa string consisting of a single  character, or
p12724
aVa string consisting of a sequence of letters, digits, and some special characters, or
p12725
aVan empty string
p12726
aVIf you would like to change it to allow zero or one dash  only at the beginning of the string, remove the OR character  from your expression; if you would like to match at most one dash anywhere in the string, change expression to
p12727
aVEDIT 1: If you need to avoid two consecutive dashes, you can use this expression with negative lookbehind:
p12728
aVThe  part of the expression above matches a dash unless it is preceded by another dash
p12729
aVEDIT 2: If you have strings of 10000+ length, a positive regex solution is not as good as a negative one
p12730
aVInstead of looking for , it is much more efficient to look for , and use this expression for your negative match
p12731
aVIn other words, instead of specifying an expression defining the string that you want, you could define a much simpler expression for the string that you do not want:
p12732
aVNOTE: Sanitizing your strings is not the best way to avoid SQL injection attacks; using parameterized statements is
p12733
as(dp12734
g6
V335858
p12735
stp12736
a((dp12737
g2
(lp12738
VThe  operation returns the result of performing bitwise and on binary representations of two big integers
p12739
aVIn your particular example, bit number ten is extracted, because the binary representation of 512 is
p12740
as(dp12741
g6
V335858
p12742
stp12743
a((dp12744
g2
(lp12745
VI'm trying to pass a reference to a function as a parameter
p12746
aVIt's hard to explain
p12747
aVIt may be hard to explain, but it is very easy to implement: the code below calls  passing it a parameterized piece of code as a parameter
p12748
aVYou can use delegate types provided by the system ( and ) or write your own
p12749
as(dp12750
g6
V335858
p12751
stp12752
a((dp12753
g2
(lp12754
VI think that the key misunderstanding here is that the stack does not grow dynamically by itself
p12755
aVIt is set statically to a relatively small number, but you can change it in runtime (here is a link to an answer explaining how it is done with  call)
p12756
as(dp12757
g6
V335858
p12758
stp12759
a((dp12760
g2
(lp12761
VIf all but one dimension of your array are fixed, which is the situation that you describe, you can avoid using arrays of pointers: you could typedef a row as , and create an array of rows, like this:
p12762
aVNow you can pass around 2D arrays composed of  arrays like this:
p12763
as(dp12764
g6
V335858
p12765
stp12766
a((dp12767
g2
(lp12768
VYou can use regular expressions to find the first symbol that is not a digit or a decimal separator:
p12769
as(dp12770
g6
V335858
p12771
stp12772
a((dp12773
g2
(lp12774
VYou cannot have free-standing operations in C: you need to put initialization into your
p12775
as(dp12776
g6
V335858
p12777
stp12778
a((dp12779
g2
(lp12780
VYou can read the file in memory, move the line to where you need it, and write the file back
p12781
aVYou can use  and
p12782
aVThis code moves the string at position  up by one line:
p12783
as(dp12784
g6
V335858
p12785
stp12786
a((dp12787
g2
(lp12788
VThis question is not specific to Objective-C: the guideline for when to use inheritance is the same for all object-oriented languages, and it is based on substitutability, summarized by the Liskov Substitution Principle:
p12789
aVif S is a subtype of T, then objects of type T may be replaced with objects of type S
p12790
aVIn other words, use inheritance only when you can say "{derived} is a {base}>"; when you model a "{owner} has a {something}", use composition
p12791
aVStudent is a Person -- Inheritance
p12792
aVCar is a vehicle -- Inheritance
p12793
aVPerson has a House -- Composition (ivar or property)
p12794
aVCar has a(n) Engine -- Composition (ivar or property)
p12795
as(dp12796
g6
V335858
p12797
stp12798
a((dp12799
g2
(lp12800
VThis is because you have declared a constructor and a destructor of , but you are missing their definitions
p12801
aVYou can provide these definitions inline as part of the declaration of , presumably in the
p12802
aVh file:
p12803
aVor outside your class declaration in a cpp file:
p12804
aVAs a side note,  should probably be , not  unless you really want one-letter names
p12805
as(dp12806
g6
V335858
p12807
stp12808
a((dp12809
g2
(lp12810
Vcase MyEnum
p12811
aVVALUE1
p12812
aVtoString(): // Isn't this equal to "VALUE1"
p12813
aVNo, not necessarily: you are free to provide your own implementation of
p12814
ag8433
aVMoreover, someone who is maintaining your code could add this implementation after you leave the company
p12815
aVThat is why you should not rely on String values, and stick to using numeric values (as represented by the constants , , etc
p12816
aVof your s instead
p12817
as(dp12818
g6
V335858
p12819
stp12820
a((dp12821
g2
(lp12822
VGenerics in Java are very different from generics in
p12823
aVNET, because there is no type erasure in
p12824
aVNET
p12825
aVYou can specify that you are returning a list of IEmumerable, and then add List objects to your list
p12826
aVBecause List implements IEmumerable, this is not an error
p12827
aVIn your case, however, an object of type SelectList is added
p12828
aVI would make a guess and say that SelectList implements an IEnumerable of SelectListItem, or inherits a class that does it
p12829
aVI would also guess that there are other classes that work as a supply of SelectListItems in addition to the SelectList
p12830
aVSince the List returned from your method specifies an instance of a generic interface rather than a class as the list element type, you can mix and match different implementations of IEnumerable in the same list
p12831
as(dp12832
g6
V335858
p12833
stp12834
a((dp12835
g2
(lp12836
VYour algorithm is not correct: you cannot just sort your blocks lexicographically, because they are of different length
p12837
aV9 should be considered greater than 98, but it is smaller lexicographically (for the same reason as "car" sorts ahead of "cartoon" in a dictionary)
p12838
aVEDIT :
p12839
aVAs asaelr suggested in a comment, one way to compare two blocks of digits is gluing them together both ways ( and ;  means concatenation), and checking with order produces a larger number
p12840
aVIf  is bigger than , keep the current order; otherwise, switch the numbers
p12841
aVWhen a function that compares numbers like this is passed to , the correct result is produced
p12842
aVHere is an implementation of this simple algorithm:
p12843
as(dp12844
g6
V335858
p12845
stp12846
a((dp12847
g2
(lp12848
VThis is because when you xor a number with itself, it becomes zero, and when strlen sees zero, it thinks it's the end of the string
p12849
aVIf you store the length in a variable before the first loop and then use that saved length in your second loop instead of strlen, your program will produce the expected result
p12850
as(dp12851
g6
V335858
p12852
stp12853
a((dp12854
g2
(lp12855
VYou are missing a pair of square brackets in
p12856
aVIt should be
p12857
aVThe rest of your recursive rule looks fine
p12858
as(dp12859
g6
V335858
p12860
stp12861
a((dp12862
g2
(lp12863
VYou are almost there: instead of , use , and move your  clause inside it as a condition
p12864
aVThis should work:
p12865
as(dp12866
g6
V335858
p12867
stp12868
a((dp12869
g2
(lp12870
VXML tags cannot contain spaces
p12871
aVWhat you have in your XML element is
p12872
aVA tag called ,
p12873
aVthat has an attribute called  with the value ,
p12874
aVand another attribute called  with the value
p12875
aValready returns the values of all attributes to you in the attribute list that you get along with the element that has its  set to
p12876
as(dp12877
g6
V335858
p12878
stp12879
a((dp12880
g2
(lp12881
VIt is a recursive reverse
p12882
aVis the line without its first character;  is the first character
p12883
aVWhat the function is saying is "if the line is one character long, the answer is the line itself; otherwise, chop off the first character, compute the same function, and add the chopped off character to the end of the result"
p12884
aVYou can work out on a piece of paper how performing the steps above amounts to reversing a string
p12885
aVEDIT : It is worth noting that this implementation is going to crash with an exception if you try passing it an empty string
p12886
aVChanging  to  would address this problem (thanks to Tom Hawtin - tackline for mentioning this in a comment)
p12887
as(dp12888
g6
V335858
p12889
stp12890
a((dp12891
g2
(lp12892
VEnum constants must be valid Java identifiers
p12893
aVYou can override  if you would like them displayed differently
p12894
as(dp12895
g6
V335858
p12896
stp12897
a((dp12898
g2
(lp12899
VTry setting your view as the delegate of itself:
p12900
aVTechnically, you do not need to inherit  to respond to scrolling events: it is sufficient to set the  to an implementation of
p12901
aVAlso, the  method has been gone for about two years, so it is not going to be called on modern iOS installations
p12902
as(dp12903
g6
V335858
p12904
stp12905
a((dp12906
g2
(lp12907
VSince  looks for a single byte set to zero, it stops when it reaches , because five of its eight bytes are zero
p12908
aVconverted to  becomes
p12909
as(dp12910
g6
V335858
p12911
stp12912
a((dp12913
g2
(lp12914
VThey are final for security reasons
p12915
aVThere may be other reasons, but security is the most important
p12916
aVImagine an ability to inherit , and supply your own, mutable implementation to a security-sensitive API
p12917
aVThe API would have no choice but take your string (remember the substitution principle) then but you would be able to change the string from under them (on a concurrent thread or after the API has returned), even after they have checked it to be valid
p12918
aVSame goes for wrappers of primitives: you do not want to see them mutable under any circumstance, because it would violate important assumptions about their behavior encoded in the APIs using these classes
p12919
aVMaking  final addresses this issue by not letting others supply their own, potentially hostile, implementations of classes as fundamental as
p12920
as(dp12921
g6
V335858
p12922
stp12923
a((dp12924
g2
(lp12925
VThe easiest to understand way to do it is to search for the delimiters, and cut out a substring between their positions, like this:
p12926
as(dp12927
g6
V335858
p12928
stp12929
a((dp12930
g2
(lp12931
VQ: What am I missing here
p12932
aVYour assumption that  internally synchronizes on itself is not correct: according to the source code, the implementation uses  objects, instances of which are hidden inside the collection, so you cannot lock/synchronize on them
p12933
aVIn general, this is a recommendation that writers of class libraries should follow: if you need to synchronize on an object, do not synchronize on ; create a private object inside your class, and synchronize on that object instead
p12934
aVOtherwise, you may be facing concurrency issues caused by others synchronized on your object, and holding the lock indefinitely
p12935
as(dp12936
g6
V335858
p12937
stp12938
a((dp12939
g2
(lp12940
VYou can store the value as , make it , and define a function  that casts your stored delegate to the appropriate type:
p12941
aVYou can then call it like this:
p12942
aVThere is a little bit of ugliness going on around the  syntax, but it should probably do the trick
p12943
as(dp12944
g6
V335858
p12945
stp12946
a((dp12947
g2
(lp12948
VIt is not possible to find the pair of values from , because multiple pairs could produce identical results
p12949
aVIt is easy to see if you consider an example where all bits of  are set
p12950
aVThen all bits of  will be set as well, regardless of the value of
p12951
aVNow consider the situation when every odd bit of  is set, every even bit of  is set, and also the least significant bit of  is set
p12952
aVAgain, the result will have all its bits set, for a very different pair of  and
p12953
as(dp12954
g6
V335858
p12955
stp12956
a((dp12957
g2
(lp12958
VI don't think you can do it for properties added through associated object API, because 's  and  have no idea that your properties are there
p12959
aVIf you could create your custom  by inheriting  instead, you would be able to override  and  of your class, and encode/decode your properties along with the  ones
p12960
as(dp12961
g6
V335858
p12962
stp12963
a((dp12964
g2
(lp12965
VI think you have a misunderstanding of the  keyword semantic when it is applied to arrays in Java
p12966
aVIn both Java examples the arrays will remain unchanged, but their elements may be changed
p12967
aVAll your assignments will be executed correctly, and the values stored in the array will get changed
p12968
aVHowever, if you try
p12969
aVyou are going to see a compile error
p12970
aVWhen translating your code to C#, you may need to translate  either as  (when it is applied to a ), or as  (when it is applied to a member)
p12971
aVThe semantic of  arrays in C# and  arrays in Java are the same: your program cannot reassign the array, but it can freely modify its elements
p12972
aVFinally, there is a Java-specific case when  is used where you wouldn't need it in C# at all: when you need to use a variable inside a method of an anonymous local class in Java, you must make that variable
p12973
aVSince C# does not have anonymous local classes, you would need to translate that piece of code with something else, perhaps with anonymous delegates
p12974
aVSuch delegates are not restricted to using readonly variables
p12975
as(dp12976
g6
V335858
p12977
stp12978
a((dp12979
g2
(lp12980
VThe easiest solution is to move the  out of regexp and into SQL:
p12981
aVOtherwise, your regexp would have to include all  possible orders in a long chain of  statements, and that length grows very, very fast (with 5 keywords, you'd need to construct 120 distinct orderings
p12982
as(dp12983
g6
V335858
p12984
stp12985
a((dp12986
g2
(lp12987
VI think a small modification to your query should work:
p12988
aVYou could avoid the conditional by converting the  join to inner from left outer, but the query would not return rows with  of zero if delivery records with the status of  are missing for the product
p12989
as(dp12990
g6
V335858
p12991
stp12992
a((dp12993
g2
(lp12994
VFrom Oracle's documentation:
p12995
aVThere are two ways to create a new thread of execution
p12996
aVOne is to declare a class to be a subclass of Thread
p12997
aVThis subclass should override the run method of class Thread
p12998
aVThe other way to create a thread is to declare a class that implements the Runnable interface
p12999
aVSo the answer is "you may want to subclass  to override its  method
p13000
aVThe quoted paragraphs have been in the Java documentation going back as far as JDK 1
p13001
ag1340
aVJava has added other convenient classes for managing concurrency, most notably, the executors mentioned in the comments, possibly diminishing or eliminating the need to extend
p13002
aVThey cannot make it , however, because that would break backward compatibility
p13003
aVAs far as practical reasons go, I think the only reason you may want to extend  rather than implement  today would be to override its methods other than
p13004
aVFor example, you may want to add logging or additional clean-up
p13005
as(dp13006
g6
V335858
p13007
stp13008
a((dp13009
g2
(lp13010
VYou can use an array initializer:
p13011
aVAn array initializer may be specified in a declaration, or as part of an array creation expression, to create an array and provide some initial values
p13012
aVIt is written as a comma-separated list of expressions, enclosed by braces  and
p13013
as(dp13014
g6
V335858
p13015
stp13016
a((dp13017
g2
(lp13018
VYou are not limited to a single interface - you can build an entire hierarchy
p13019
aVFor example, you can make these three interfaces:
p13020
aVNow your boxes can implement an interface from the hierarchy that fits your design
p13021
aVWith a hierarchy in place, you can continue programming to the interface:
p13022
as(dp13023
g6
V335858
p13024
stp13025
a((dp13026
g2
(lp13027
VStrictly speaking, there is no "proper" way to write a  loop: you can leave out any combination of the three parts blank (in fact, K&R; suggest leaving all three blank to implement a "forever" loop), and there is no hard requirement to have a stopping condition depend on the loop counter
p13028
aVOne advantage of the  loop over the  loop is that you can freely use  inside the body, without a fear of forgetting to increment your counter
p13029
aVThis may help readability for loops with lots of embedded  statements
p13030
as(dp13031
g6
V335858
p13032
stp13033
a((dp13034
g2
(lp13035
VA general rule is that you should avoid including a header inside headers that do not use definitions from it
p13036
as(dp13037
g6
V335858
p13038
stp13039
a((dp13040
g2
(lp13041
VThat's a notation from Java 5 for variable length argument lists
p13042
aVIt is roughly equivalent to a String array, but lets you pass individual parameters that are combined into an array automatically
p13043
aVThis makes sense only when you plan to call a method from your program, so I do not see why it would be desirable to use this syntax for your main()
p13044
aVIt will work, however
p13045
as(dp13046
g6
V335858
p13047
stp13048
a((dp13049
g2
(lp13050
Vthis would have to be deleted before returning from the function to avoid memory leak
p13051
aVThis is not entirely correct: although it is true that you need to eventually  the pointer that you allocated with , you do not necessarily have to do it before exiting the function where the allocation happened
p13052
aVYou can do this:
p13053
as(dp13054
g6
V335858
p13055
stp13056
a((dp13057
g2
(lp13058
VThe simplest solution is to make 's constructor protected:
p13059
aVSince C++ does not provide explicit support for abstract classes, but you can add pure virtual functions to your class to get a similar effect
p13060
aVIf you do not have a suitable virtual function that you'd want to make pure virtual, a common idiom is to make your destructor pure virtual, and then provide an implementation outside the header
p13061
as(dp13062
g6
V335858
p13063
stp13064
a((dp13065
g2
(lp13066
VIf you call
p13067
aVyou will get an array of DirectoryInfo objects, which have a Name property with the info that you are looking for
p13068
as(dp13069
g6
V335858
p13070
stp13071
a((dp13072
g2
(lp13073
VYou can use TimeSpan
p13074
aVFromMinutes, and then retrieve hours and minutes from it
p13075
as(dp13076
g6
V335858
p13077
stp13078
a((dp13079
g2
(lp13080
VThree-slash comments are for the documentation builder
p13081
aVYou can generate documentation of your APIs straight from the source
p13082
aVYou can document what your API does, what parameters it takes, what exceptions it throws, etc
p13083
aVright in your source
p13084
aVMicrosoft provides tools to verify that your documentation is in sync with the actual API
p13085
aVFor example, if you add, remove, or rename a parameter, but forget to document the change, you will get a warning
p13086
aVThis is how you generate documentation from these tags using Visual Studio: link
p13087
as(dp13088
g6
V335858
p13089
stp13090
a((dp13091
g2
(lp13092
VYou cannot pass it as is, but you can pass a copy:
p13093
aVIt is often a good idea to make your API program take an interface rather than a class, like this:
p13094
aVThis little change lets you pass dictionaries of other kinds, such as  to your API
p13095
as(dp13096
g6
V335858
p13097
stp13098
a((dp13099
g2
(lp13100
VA row is just a string array , so you can find its size using the  property of the array
p13101
as(dp13102
g6
V335858
p13103
stp13104
a((dp13105
g2
(lp13106
V is a file system object that represents the current console
p13107
aVCopying files into this "directory" from the command line prints out the content of these files to your console:
p13108
aVis equivalent to
p13109
aVThese objects are there to let you use the familiar file APIs to interact with console
p13110
aVIt is a clever way to unify console API with file API
p13111
aVYou can use , , etc
p13112
aVto interact with the console in the same way that you interact with regular files
p13113
aVThis example writes  to the terminal:
p13114
as(dp13115
g6
V335858
p13116
stp13117
a((dp13118
g2
(lp13119
VThe way you lay out your cell now is fragile, because the order of painting the cells on screen matters a lot
p13120
aVTry moving the content up so that your buttons are flush with the top of the cell, and the time label fits into the cell entirely
p13121
aVAdd a thin header view to your table to make the top cell appear normal
p13122
aVKeeping the content of a cell entirely within its bounds should help you maintain reasonable scrolling speeds
p13123
aVEDIT : You could also put a second clipped label at the top of your cell, and make its content identical to that of the label in the prior row
p13124
aVYou would need to take special care to hide that label in the top row, but otherwise this should make your table immune to changes in the rendering order of its cells
p13125
as(dp13126
g6
V335858
p13127
stp13128
a((dp13129
g2
(lp13130
VYou need to reset  back to zero before the nested loop starts
p13131
aVOtherwise, the outer loop will execute 50 times, but the last 49 times the inner loop will not execute at all, because  is already above
p13132
as(dp13133
g6
V335858
p13134
stp13135
a((dp13136
g2
(lp13137
VWhat you observe is not a memory overflow, it is a numeric overflow
p13138
aVThe whole point of the exercise was to show that overflow does happen, and make you learn techniques to deal with it
p13139
aVIn this particular case, they expect you to either implement arbitrary precision integer arithmetic, or borrow a pre-made implementation and use it with your solution
p13140
as(dp13141
g6
V335858
p13142
stp13143
a((dp13144
g2
(lp13145
VThis is a feature of C# compiler, and the dictionary is not special: any collection that supports  can be initialized in this way
p13146
aVThe details are in the section 7
p13147
ag837
aV10
p13148
aV3 of the C# Language Specification 4
p13149
ag49
aVThe collection object to which a collection initializer is applied must be of a type that implements System
p13150
aVCollections
p13151
aVIEnumerable or a compile-time error occurs
p13152
aVFor each specified element in order, the collection initializer invokes an Add method on the target object with the expression list of the element initializer as argument list, applying normal overload resolution for each invocation
p13153
aVThus, the collection object must contain an applicable Add method for each element initializer
p13154
as(dp13155
g6
V335858
p13156
stp13157
a((dp13158
g2
(lp13159
VThe problem in your code is that you don't have one array list: you have many array lists
p13160
aVEach button handler has its own
p13161
aVYou should make one array list, and share it among all your handlers by passing it to their constructors
p13162
ag8433
as(dp13163
g6
V335858
p13164
stp13165
a((dp13166
g2
(lp13167
VIt looks like your  is declared and defined, but  is only declared, but not defined; this is why the linker complains
p13168
aVYou need to provide a definition of  to address this problem
p13169
as(dp13170
g6
V335858
p13171
stp13172
a((dp13173
g2
(lp13174
VIn Java,  denotes class methods and class variables (as opposed to instance methods and instance variables)
p13175
aVThese methods and variables can be accessed without an instance present
p13176
aVContrast this to instance methods and instance variables: they must be accessed through an object
p13177
aVFor example,  operates on an object:
p13178
aVIn contrast,  cannot operate on an object; moreover, it creates a new object when called:
p13179
aVNote how instance methods are called using  followed by a dot , while static methods are accessed using  followed by a dot
p13180
as(dp13181
g6
V335858
p13182
stp13183
a((dp13184
g2
(lp13185
VHere is a C# answer:
p13186
aVThe idea is to first group by the middle column (#1), and then convert groups to dictionary, using group key as the dictionary key, and creating  from each row in the group
p13187
as(dp13188
g6
V335858
p13189
stp13190
a((dp13191
g2
(lp13192
VYou can use regexp:
p13193
aVThis will ensure that  is present either at the beginning, at the end, or in between of two commas; it would not match strings where  is inside another number
p13194
aVFor example,  will not be matched
p13195
as(dp13196
g6
V335858
p13197
stp13198
a((dp13199
g2
(lp13200
V is a lambda expression, a convenient way to create an anonymous delegate that takes zero parameters
p13201
aVEssentially it creates a callable piece of code that in your case moves up twice and then moves down twice
p13202
aVYou are not limited to lambdas without parameters - you can create ones with arguments:
p13203
as(dp13204
g6
V335858
p13205
stp13206
a((dp13207
g2
(lp13208
VAssuming that you would like to subtract 130 minutes from the current time, you can use , like this:
p13209
aV130 minutes is 2 hours and 10 minutes, hence the  constant
p13210
aVHere is a quick demo on sqlfiddle
p13211
as(dp13212
g6
V335858
p13213
stp13214
a((dp13215
g2
(lp13216
VShould I keep my object definition as is or should I change EventDateUserTime to a Nullable
p13217
aVUltimately, this depends on your design: if the state of the object with unset  is legitimate, make the field nullable; if you always set it right after retrieving from LINQ, keep it non-nullable
p13218
aVPerhaps a better approach would be to make  a calculated property, and store the user time zone instead:
p13219
as(dp13220
g6
V335858
p13221
stp13222
a((dp13223
g2
(lp13224
VNo, JDBC does not let you do that
p13225
aVThe idea behind parameters is to speed up execution and avoid SQL interjections; parameterizing the columns that you are selecting does not help either of these two goals
p13226
as(dp13227
g6
V335858
p13228
stp13229
a((dp13230
g2
(lp13231
VYou can do it in O(n) with a hash table
p13232
aVPut all numbers in the hash for O(n), then go through them all again looking for
p13233
aVHash table returns "Yes" or "No" in O(1), and you need to go through all numbers, so the total is O(n)
p13234
aVAny set structure with O(1) setting and O(1) checking time will work instead of a hash table
p13235
as(dp13236
g6
V335858
p13237
stp13238
a((dp13239
g2
(lp13240
VIt is typical to implement shared functionality independent of the class instance in a static utility class, the same way that Java implements functionality common to all collections in the
p13241
aVIf the functionality depends on the instance, functionality can be shared by placing the implementation in a base class (often an abstract base class), and inheriting it in both classes that need the functionality in question
p13242
aVFinally, one could implement shared functionality in a package-private utility class, add public methods to both classes calling into that package-private utility class for the implementation
p13243
as(dp13244
g6
V335858
p13245
stp13246
a((dp13247
g2
(lp13248
VThis is because your string is not zero-terminated
p13249
aVThis will work:
p13250
aVThe  specifies the minimum width of the printout
p13251
aVSince you are printing a 3-character string, this will be ignored
p13252
aVIf you used , however, your string would be padded on the left with two spaces
p13253
as(dp13254
g6
V335858
p13255
stp13256
a((dp13257
g2
(lp13258
VWhen both classes define virtual functions, C++ compiler needs to build vtables for both classes  and
p13259
aVTo build 's vtable, the compiler needs  - that is where the reference is coming from
p13260
aVWhen  has no virtual functions, there are no reference to  from anywhere, hence you do not get a compile error
p13261
aVAs I'm sure you know, you can fix this error by making  a pure virtual, thus providing the needed value for the vtable (in this case, the value is zero)
p13262
as(dp13263
g6
V335858
p13264
stp13265
a((dp13266
g2
(lp13267
V is a generic type argument denoting the type of the expression on which you sort
p13268
aVFor example, if you sort strings by length,  will be , and  will be , as in the code below:
p13269
as(dp13270
g6
V335858
p13271
stp13272
a((dp13273
g2
(lp13274
VThe simplest way to do it would be to use  method:
p13275
as(dp13276
g6
V335858
p13277
stp13278
a((dp13279
g2
(lp13280
VThe easiest thing to do would be to implement a  method in your  class
p13281
aVWhile you are at it, move the two arrays ( and ) out of the constructor, make them , and rename to all-upper case:
p13282
aVAlso the selection of the card should not be done like you do:
p13283
aVcreates an array of  cards, and assigns it to
p13284
aVThis is incorrect: you have already created all your cards in the , it's a matter of taking a random one from it:
p13285
aVNote the little addition here:  is an array of 52  objects indicating that the card has been taken from the deck
p13286
aVHere is your code with my modifications from above working at ideone
p13287
as(dp13288
g6
V335858
p13289
stp13290
a((dp13291
g2
(lp13292
VYou should put declarations in the
p13293
aVh file, make them extern, and move definitions into a
p13294
aVc or
p13295
aVm file
p13296
aVFrom this
p13297
aVmyfunctions
p13298
ag1177
aVMove to this:
p13299
aVmyfunctions
p13300
ag1177
aVmyfunctions
p13301
aVc
p13302
as(dp13303
g6
V335858
p13304
stp13305
a((dp13306
g2
(lp13307
VCall stringByAddingPercentEscapesUsingEncoding on the result string to encode space characters as requiredby the rules of URLs
p13308
as(dp13309
g6
V335858
p13310
stp13311
a((dp13312
g2
(lp13313
VReading and writing the same file is not a good idea
p13314
aVYour XML is constructed correctly, it's just written incorrectly
p13315
aVOne approach that should work is to write the file to a different location (say ), close and remove the original  using 's  API, and then copy  to  using the  API
p13316
as(dp13317
g6
V335858
p13318
stp13319
a((dp13320
g2
(lp13321
VThe  stays in ARC, it's just that you shouldn't be calling  any longer: the compiler inserts the code for you
p13322
aVAnd of course all the calls to  cannot be made in  (or anywhere else)
p13323
as(dp13324
g6
V335858
p13325
stp13326
a((dp13327
g2
(lp13328
Vwill TreeSet#toArray(T[]) always return the elements in the same order, if no modifications are made to the set
p13329
aVAbsolutely -  returns elements in the same sorted order
p13330
aVOf course your elements should play nicely when it comes to implementing comparable in order for that sorting order to be what you expect
p13331
as(dp13332
g6
V335858
p13333
stp13334
a((dp13335
g2
(lp13336
VThe simplest (but definitely not the fastest to execute) way would be to cast your column to  before passing it to :
p13337
as(dp13338
g6
V335858
p13339
stp13340
a((dp13341
g2
(lp13342
VYou need to use the  function that breaks a double/float into an int an a fraction
p13343
as(dp13344
g6
V335858
p13345
stp13346
a((dp13347
g2
(lp13348
VYou already allocate a new , you are just not keeping it
p13349
aVYou need to change the function to return , and store the results in an array or a vector
p13350
aVAn even better approach would be to do  initialization in a constructor:
p13351
aVYou can now create all sets in a loop, and store pointers to them in an array:
p13352
as(dp13353
g6
V335858
p13354
stp13355
a((dp13356
g2
(lp13357
VThere are two ways a subclass can call a superclass method:
p13358
aVCall a method defined in the superclass as its own, or
p13359
aVCall a method defined in the superclass specifically requesting superclass's behavior
p13360
aVThe syntax for the first way is as follows:
p13361
aVthe syntax for the second way of invocation is as follows:
p13362
aVI think now you have enough information to trace what happens in your example without further help
p13363
as(dp13364
g6
V335858
p13365
stp13366
a((dp13367
g2
(lp13368
VIt looks like you are ready to learn about binary arithmetics
p13369
aVThink of a combination as a sequence of zeros and ones, representing a binary number
p13370
aVrepresents 4,  is 5, and so on
p13371
aVComing up with the next combination then is equivalent to incrementing the value - it is that simple
p13372
aVWith a little help of binary operations implemented in Java, C, C++, C# etc
p13373
aV, you arrive at this code:
p13374
aVRead a page or two on bit operations, then play with this code at ideone to see how it works
p13375
aVI encourage you to make some parallels to the world of decimals, you will learn a lot about number systems in general
p13376
as(dp13377
g6
V335858
p13378
stp13379
a((dp13380
g2
(lp13381
VNo, it is not possible: regular expression language allows parenthesized expressions representing capturing and non-capturing groups, lookarounds, etc
p13382
aV, where parentheses must be balanced
p13383
aVIt is not possible even in theory to write a regular expression that verifies if parentheses are balanced in a given string
p13384
aVWithout an ability to do that you wouldn't know where one regexp ends and the other one starts
p13385
aVIn general, regex grammar is relatively complex
p13386
aVTo get an idea of just how complex it is, take a look at the parser in the source of Java's  class
p13387
as(dp13388
g6
V335858
p13389
stp13390
a((dp13391
g2
(lp13392
VYes, you have to code the call to  yourself
p13393
aVHowever, your pointer may participate in the reference counting system indirectly if you put it in an instance of a reference-counted object:
p13394
aVThere is no way around writing that call to  - one way or the other, you have to have it in your code
p13395
as(dp13396
g6
V335858
p13397
stp13398
a((dp13399
g2
(lp13400
VYou can add a dummy loop around the block preceding the label, and use labeled break as an equivalent of goto:
p13401
as(dp13402
g6
V335858
p13403
stp13404
a((dp13405
g2
(lp13406
VOne way would be defining an array of C strings, and use it as a definition of your ordering:
p13407
aVNow you can search  for your string, and use its index in a switch statement
p13408
aVYou can get fancy and - sort your strings, and use  to find the index in
p13409
as(dp13410
g6
V335858
p13411
stp13412
a((dp13413
g2
(lp13414
VAre you trying to add a ToolTip
p13415
aVEDIT : You should remove  event, and add tooltip to the label in the constructor:
p13416
as(dp13417
g6
V335858
p13418
stp13419
a((dp13420
g2
(lp13421
VThis is because you are not starting a thread - instead, you are executing thread's code synchronously by calling ; you need to call  instead
p13422
aVBetter yet, you should use executors
p13423
as(dp13424
g6
V335858
p13425
stp13426
a((dp13427
g2
(lp13428
VYou need to subtract  to get the decimal value of a digit character:
p13429
aVBetter yet, you should use :
p13430
as(dp13431
g6
V335858
p13432
stp13433
a((dp13434
g2
(lp13435
VSince serializer needs to provide enough information to deserialize the data back, it must include some metadata about the object being serialized
p13436
aVSpecifically, the
p13437
aVpart stands for
p13438
aVIf you use  and its  method instead, you'll get the desired effect: your memory stream will contain just the four bytes from your integer
p13439
aVYou wouldn't be able to deserialize it without knowing that you wrote an  into the stream
p13440
as(dp13441
g6
V335858
p13442
stp13443
a((dp13444
g2
(lp13445
VThis is because you are compiling with ARC, and this source is pre-ARC
p13446
aVIf you change the compiler mode to disable ARC, it will compile fine
p13447
aVYou could also use the new-style autorelease pool (works without ARC too):
p13448
as(dp13449
g6
V335858
p13450
stp13451
a((dp13452
g2
(lp13453
VYou cannot do a conditional inner join like that - it's a syntax error
p13454
aVConsider re-writing as three outer joins and a where clause to limit the results
p13455
as(dp13456
g6
V335858
p13457
stp13458
a((dp13459
g2
(lp13460
VYou are using an unassigned pointer buf in your first call to realloc
p13461
aVChange to
p13462
aVto avoid this problem
p13463
aVOnce you get it working, you'll notice that your program is rather inefficient, with a realloc per character
p13464
aVConsider realloc-ing in larger chunks to reduce the number of reallocations
p13465
as(dp13466
g6
V335858
p13467
stp13468
a((dp13469
g2
(lp13470
VFirst, let's concentrate on getting the right results, and then we'll optimize
p13471
aVConsider your nested loops: you will get too many positives, because in most (pclient, client) pairs the IDs wouldn't match
p13472
aVI think you wanted to code it like this:
p13473
aVNow for the efficiency of that code:  uses linear search through lists
p13474
aVThis is not efficient - consider using structures that are faster to search, for example, hash sets
p13475
as(dp13476
g6
V335858
p13477
stp13478
a((dp13479
g2
(lp13480
V returns  when the number is out of range
p13481
aVComparing a 32-bit  to  is always false, because  is roughly two times smaller
p13482
aVIf you use  instead of , your solution will work, because the result will be in the range of
p13483
aVAlternatively, you could use  instead of
p13484
as(dp13485
g6
V335858
p13486
stp13487
a((dp13488
g2
(lp13489
VYou can use regular expressions for this:
p13490
aVThis regular expression is the heart of the solution:
p13491
aVIt matches the content of the  attribute, and captures the content between the quotes (note a pair of parentheses)
p13492
aVThis caption is then retrieved in , and used to extract the part of the string that you are looking for
p13493
as(dp13494
g6
V335858
p13495
stp13496
a((dp13497
g2
(lp13498
VIf I understand your idea right, your implementation is wrong in that it sets delayed actions to take place all at the same time
p13499
aVYou can space them out like this:
p13500
aVThis loop sets up eight delayed visibility changes - a group of four pairs of set visible at  followed by set invisible at
p13501
as(dp13502
g6
V335858
p13503
stp13504
a((dp13505
g2
(lp13506
VYou have declared a structure type, but not a structure variable
p13507
aVYou should change your code as follows:
p13508
as(dp13509
g6
V335858
p13510
stp13511
a((dp13512
g2
(lp13513
VSince this looks like homework, I'll give you several of hints:
p13514
aVSignature of  includes an  argument, conventionally named
p13515
aVThe initial argument is , not
p13516
aVis the easiest way to convert a string to an integer
p13517
as(dp13518
g6
V335858
p13519
stp13520
a((dp13521
g2
(lp13522
VEven though  is a subclass of , C# does not let you override a method with a subclass parameter
p13523
aVYou need to override the method with the signature from the base class, and then cast to  inside your function:
p13524
aVEdit:
p13525
aVSince  does not provide  and it looks like you need them, try overriding a different method:
p13526
as(dp13527
g6
V335858
p13528
stp13529
a((dp13530
g2
(lp13531
VJunction tables are the classic solution for modeling a many-to-many relationship in an RDBMS
p13532
aVYou do not need to join three tables to get cars for event1 - two tables is enough:
p13533
aVIf you need the event name, you need to join the event table as well:
p13534
as(dp13535
g6
V335858
p13536
stp13537
a((dp13538
g2
(lp13539
VThere is no such thing as new objects "expiring" in C++: it is not a garbage collected or reference counted language, so you are expected to manually code all memory management of objects that you allocated with  or
p13540
aVIn this particular case, you could use  to ensure automated deletion:
p13541
aVThere is no magic here, even though it does not look like there is a : the call to  is coded explicitly inside , so for all practical purposes it's still manual
p13542
aVA better solution would be to allocate your vector in the automatic storage, and pass a pointer to :
p13543
as(dp13544
g6
V335858
p13545
stp13546
a((dp13547
g2
(lp13548
VThis may not be optimal in terms of speed, but both queries are short enough to fit on a single line, and are easy to understand:
p13549
as(dp13550
g6
V335858
p13551
stp13552
a((dp13553
g2
(lp13554
VThis is because the source string does not contain double slashes: all doubled slashes are consumed by the compiler in the process of creating your string constant, and replaced by single slashes to arrive at your final string:
p13555
aVWhen you use a slash inside a string constant, two slashes are needed to represent one slash
p13556
aVWhen you use a slash inside a string constant that you pass to a regular expression, you need four slashes: two of the four will be consumed by the compiler, and then one of the remaining two will be consumed by the regex compiler
p13557
aVHere is your example that does what you expected it to do:
p13558
aVThe output looks like this:
p13559
as(dp13560
g6
V335858
p13561
stp13562
a((dp13563
g2
(lp13564
VThis is the way to execute a program quietly, and hide all its output
p13565
aVis a special filesystem object that throws away everything written into it
p13566
aVRedirecting a stream into it means hiding an output
p13567
aVThe  part means "redirect both the output and the error streams"
p13568
aVEven if your program writes to , that output will not be shown
p13569
as(dp13570
g6
V335858
p13571
stp13572
a((dp13573
g2
(lp13574
VThe easiest thing to do if you do not need to modify the variable would be to pass it down as a parameter to the function:
p13575
aVIf you need to modify the variable, you can return the new value from the method:
p13576
as(dp13577
g6
V335858
p13578
stp13579
a((dp13580
g2
(lp13581
VYour SQL is correct for the task that you are trying to perform, so the likely culprit is your data: other descriptions probably contain trailing blanks
p13582
aVTo verify, run this query:
p13583
aVThis assumes an RDBMS with  used for concatenation; some DBs use  instead of a
p13584
aVTo work around this, use
p13585
as(dp13586
g6
V335858
p13587
stp13588
a((dp13589
g2
(lp13590
VThe implementation should be split between the abstract and the concrete classes
p13591
aVYou can do it using the Template Method pattern:
p13592
aVYou can split the responsibility differently to get the precise return type:
p13593
as(dp13594
g6
V335858
p13595
stp13596
a((dp13597
g2
(lp13598
VIf you switch the pattern to
p13599
aVyou will be able to match an address string even if it has errors (e
p13600
ag303
aVcontains non-digits, not enough dots, etc
p13601
aVYou will most likely end up validating the address in code anyway, so this may be a good idea to capture what was intended to be used as an IP address, validate it explicitly in your code, and produce a more meaningful error message
p13602
as(dp13603
g6
V335858
p13604
stp13605
a((dp13606
g2
(lp13607
VThe interviewer was trying to see if you know about ternary search: if you require that the parts are strictly increasing and then strictly decreasing, you'd be able to get an answer in
p13608
aVSo the additional requirement the interviewer was looking for is probably that duplicate entries, if any, should occur on different sides of the ascending-descending switchover point
p13609
as(dp13610
g6
V335858
p13611
stp13612
a((dp13613
g2
(lp13614
VYes
p13615
aVIt's in the "remarks" section:
p13616
aVThe length of the byte array determines how many cryptographically strong random bytes are produced
p13617
aVThis method is thread safe
p13618
as(dp13619
g6
V335858
p13620
stp13621
a((dp13622
g2
(lp13623
VYou do not need to sort them, you need to merge
p13624
aVThis is done in  using a simple loop that keeps two indexes looking at the current element of the two parts, adding the smaller of the two to the final sequence, and advancing the index by one
p13625
aVHere is pseudocode:
p13626
aVAt each step the loop advances either  or , executing  times
p13627
as(dp13628
g6
V335858
p13629
stp13630
a((dp13631
g2
(lp13632
VYes, the performance is different: unlike variables in the automatic storage that are initialized every time, static variables are initialized only once, the first time you go through the function
p13633
aVIf  is not written to, there is no other differences
p13634
aVIf it is written to, the changes to static variables survive between calls, while changes to automatic variables get lost the next time through the function
p13635
as(dp13636
g6
V335858
p13637
stp13638
a((dp13639
g2
(lp13640
VIt looks like your code always excludes the current direction (up excludes 0, down excludes 1, and so on), so you can use  to decide the exclusion rather than using the switch, like this:
p13641
as(dp13642
g6
V335858
p13643
stp13644
a((dp13645
g2
(lp13646
VI would seriously question the UI design where you must render text that large as part of a table cell
p13647
aVThe best option would be to put a reasonably-sized summary in a cell with , build a separate view for the long text, and let the user navigate to that view by clicking the disclosure indicator
p13648
aVAs a side note, you could also put a scroll view inside the initial table cell (not all cells must be of the same type; you can make one with a scroll view in it, and use it for the cell at index zero)
p13649
aVIt's not going to be as usable as the regular cell with a disclosure indicator, though
p13650
as(dp13651
g6
V335858
p13652
stp13653
a((dp13654
g2
(lp13655
VIn Oracle, you need to double the quote:
p13656
aVHere is a link to a test query on sqlfiddle
p13657
as(dp13658
g6
V335858
p13659
stp13660
a((dp13661
g2
(lp13662
VIf you are changing the same button that has been pressed, this should work:
p13663
aVThis is because  is the button that has been pressed
p13664
as(dp13665
g6
V335858
p13666
stp13667
a((dp13668
g2
(lp13669
VGenerally, You cannot reliably do it using , because the compiler is allowed to pad the two structures differently
p13670
aVSo the safest way of performing a partial copy would be to assign the three fields individually
p13671
aVHowever, since the compiler inserts padding only between members with different alignment requirements, in your specific case you can use  like this:
p13672
aVThe offset of 's  is guaranteed to be zero because it is the initial member of the structure
p13673
aVSince members , , and  have identical alignment requirements, the padding, if any, will go after them in the , and before or after them in the
p13674
aVCast to  is required because the offset is expressed in bytes
p13675
aVThe expression
p13676
aVis the length of the run between  and , inclusive
p13677
aVNote that using  is not safe, because it may have padding at the end which is not present in , causing a read past the allocated memory
p13678
as(dp13679
g6
V335858
p13680
stp13681
a((dp13682
g2
(lp13683
VIn Objective-C method name includes all argument names, so the name of the method is
p13684
aVwhich includes both colons
p13685
aVIt has nothing to do with protocol implementations - it is simply the way the methods are named in Objective-C
p13686
aVSo an imaginary C# equivalent would be simply
p13687
as(dp13688
g6
V335858
p13689
stp13690
a((dp13691
g2
(lp13692
VArrays in the automatic storage are allocated on the stack
p13693
aVStack space is limited
p13694
aVWhen the space on the stack is insufficient to allocate automatic variables, stack overflow exception occurs
p13695
aVIf you need arrays that big, use static or dynamic allocation instead
p13696
aVFor static allocation, move declarations to outside
p13697
aVFor dynamic allocation, use the code below:
p13698
aVFinally, consider using standard containers instead of plain arrays:  is a better array if you do not need resizing (it is allocated on the stack, and will not solve this problem);  is also a good candidate to replace  arrays
p13699
as(dp13700
g6
V335858
p13701
stp13702
a((dp13703
g2
(lp13704
VTry rewriting this statement with a correlated  query:
p13705
as(dp13706
g6
V335858
p13707
stp13708
a((dp13709
g2
(lp13710
VYou are missing one crucial part - a flag by which you are going to distinguish directors from employees at runtime; this flag goes into
p13711
aVNow you can declare an array of pointers to  (it cannot be an array of  because directors are not going to fit)
p13712
aVYou can cast a pointer to  back to , because the pointer to the  is always the same as the pointer to its first member
p13713
as(dp13714
g6
V335858
p13715
stp13716
a((dp13717
g2
(lp13718
VNo, you are not guaranteed that unless your program is single-threaded
p13719
aVOtherwise two concurrent calls to  could possibly override each other's results
p13720
as(dp13721
g6
V335858
p13722
stp13723
a((dp13724
g2
(lp13725
VTry this:
p13726
aVis the number of items inside the individual lists (in your example, it's two)
p13727
as(dp13728
g6
V335858
p13729
stp13730
a((dp13731
g2
(lp13732
VUse word boundary  markers to match only whole words:
p13733
as(dp13734
g6
V335858
p13735
stp13736
a((dp13737
g2
(lp13738
VIf you know for sure that there are no duplicates among the rows that you are selecting, try replacing  with
p13739
aVMoreover, you could also replace  with simple addition:
p13740
as(dp13741
g6
V335858
p13742
stp13743
a((dp13744
g2
(lp13745
VYou need to change your grammar to specify that you expect an  token after your top-level rule finishes:
p13746
as(dp13747
g6
V335858
p13748
stp13749
a((dp13750
g2
(lp13751
VReferences do not present problems with slicing - in this respect, they are as good as pointers
p13752
aVThere is no "hard" reason to prefer pointers, unless you want semantics of  to be available to your code (i
p13753
ag630
aVan ability to pass "nothing", which is not there if you use references)
p13754
aVI think the pointer types are often used as parameters of polymorphic functions to match the semantic of collections: since you cannot make a  of references, your code will end up having to dereference pointers obtained from collections before passing them to functions
p13755
aVThis may be annoying
p13756
as(dp13757
g6
V335858
p13758
stp13759
a((dp13760
g2
(lp13761
VIn this case, the value is stored as a primitive
p13762
aVIf you changed the type to a primitive's wrapper , the value would go in as an "auto-boxed"  then
p13763
aVFor example, this code would autobox your values:
p13764
as(dp13765
g6
V335858
p13766
stp13767
a((dp13768
g2
(lp13769
VI think your  has a wrong signature
p13770
aVIt should be
p13771
aVYou should be using  to schedule this method
p13772
aVYou should also be calling  instead of :
p13773
as(dp13774
g6
V335858
p13775
stp13776
a((dp13777
g2
(lp13778
VThis will not work for general case, but it will do most practical cases right:
p13779
aVThis expression uses a negative lookbehind to match a forward slash unless it is preceded by a square bracket followed by a sequence of characters other than a closing square bracket
p13780
as(dp13781
g6
V335858
p13782
stp13783
a((dp13784
g2
(lp13785
VAssuming that you have access to C++ standard library, try this:
p13786
aVThis last assignment may not work - I do not have access to Embarcadero's headers, so I have no idea what's the type of
p13787
aVThere may be need to perform additional conversion
p13788
as(dp13789
g6
V335858
p13790
stp13791
a((dp13792
g2
(lp13793
VTry this:
p13794
as(dp13795
g6
V335858
p13796
stp13797
a((dp13798
g2
(lp13799
VYou forgot to initialize your
p13800
aVYou should add
p13801
aVto your designated initializer
p13802
aVIn Objective-C sending messages to  objects is legal - these messages are simply ignored
p13803
aVThat's why you do not see the items that you added
p13804
aVI also noticed that you add buttons to the view, but you never remove them
p13805
aVTo remove the buttons from the screen, change the code as follows:
p13806
as(dp13807
g6
V335858
p13808
stp13809
a((dp13810
g2
(lp13811
VI think you need to aggregate  as well:
p13812
as(dp13813
g6
V335858
p13814
stp13815
a((dp13816
g2
(lp13817
VCurrently, if your program is counting word  and encounters a token is , your algorithm counts it as zero occurrences
p13818
aVIf it needed to count it as two, you cound benefit from a more advanced approach
p13819
aVIf your program does what you want, you are processing as fast as you can: it is already linear in the number of letters of the longer "word", so you cannot speed it up further
p13820
aVAn even more interesting solution would be required to count words with self-aliasing: for example, count s inside  string
p13821
aVIf you needed to return  for this situation, you'd need a lot more advanced algorithm
p13822
as(dp13823
g6
V335858
p13824
stp13825
a((dp13826
g2
(lp13827
VYou need to modify the path in the call to  to include a full path, a path anchored by your user directory, or a path relative to the directory in which Eclipse runs your test program
p13828
aVFor example, if your project is located in , you can use this line:
p13829
as(dp13830
g6
V335858
p13831
stp13832
a((dp13833
g2
(lp13834
VYou can prepare a string with your numbers, and save it to the file:
p13835
as(dp13836
g6
V335858
p13837
stp13838
a((dp13839
g2
(lp13840
VYou need to concatenate the two arrays before iterating over their content:
p13841
aVA better approach would be enumerating your dictionary with a block, like this:
p13842
as(dp13843
g6
V335858
p13844
stp13845
a((dp13846
g2
(lp13847
VTry this:
p13848
aVYou will get back an enumerable of anonymous objects, each with two fields -  and
p13849
as(dp13850
g6
V335858
p13851
stp13852
a((dp13853
g2
(lp13854
VYou can pass a parameter that makes an instance of your target class from :
p13855
aVNow you can call your  like this:
p13856
as(dp13857
g6
V335858
p13858
stp13859
a((dp13860
g2
(lp13861
VIn C++ it is equally simple:
p13862
aVIn C that would be
p13863
aVNote that the C way works in C++ as well, but you should prefer containers to plain pointers whenever you can
p13864
as(dp13865
g6
V335858
p13866
stp13867
a((dp13868
g2
(lp13869
VYou do not call  - it gets called when end-users click your button
p13870
aVThe part of the system that detects button clicks knows how to inform your programs of the clicks using precisely one way: by calling a method with the signature
p13871
aVYou cannot add to or remove arguments from the argument list, or change the return type of the method: it must match this signature precisely
p13872
aVNow back to your : you need it to make a call to the  method, but it does not get passed to the event handler
p13873
aVHow do you get it then
p13874
aVTypically, the answer is that you store it on the instance of the object that does event handling: declare an instance variable of type , set it when you have enough data to set it, and pass it to  from inside your  method
p13875
as(dp13876
g6
V335858
p13877
stp13878
a((dp13879
g2
(lp13880
VThe problem with your implementation is that the execution sequence does not leave the method while in the
p13881
aVThis is the problem, because the UI subsystem never gets a chance to update the label to the  value before it gets a command to set it to
p13882
aVTo do this correctly, first you need to create a timer in your init method, like this:
p13883
aVThen you need to write the code for your  method:
p13884
as(dp13885
g6
V335858
p13886
stp13887
a((dp13888
g2
(lp13889
VIt's none of these - it is a pointer to integer, a beast that is different from any type that has the word "data" in its description
p13890
aVThe  is merely a numeric interpretation of a pointer as an unsigned integer number printed out in base-16
p13891
as(dp13892
g6
V335858
p13893
stp13894
a((dp13895
g2
(lp13896
VInstead of adding a "plain" int, you should be adding anexplicit interval:
p13897
aVYou are not limited to using , of course: you can use  if you need more precision
p13898
as(dp13899
g6
V335858
p13900
stp13901
a((dp13902
g2
(lp13903
VOne common way of implementing singleton in C++ is making the instance a function-static  inside the instance getter, rather than a class-static variable
p13904
aVThis ensures a call of destructor upon program's completion, and lets you create an instance that gets accessed polymorphically e
p13905
ag303
aVthrough a pointer to an abstract base class
p13906
aVScott Meyers provided a good discussion of this topic in his "More Effective C++" book
p13907
as(dp13908
g6
V335858
p13909
stp13910
a((dp13911
g2
(lp13912
VThe  is greedy - it will try matching as many characters as it possibly could
p13913
aVYou can make it reluctant by following it by question mark, but a better solution is to exclude  from the list if characters the  matches, like this:
p13914
aVHere is a link to very good explanation of greedy vs
p13915
aVreluctant
p13916
as(dp13917
g6
V335858
p13918
stp13919
a((dp13920
g2
(lp13921
VYou are completely ignoring the line that you get inside the condition of the nested while loop
p13922
aVYou should call getline from a single spot in your while loop, and then examine its content using a sequence of if-then-else conditions
p13923
as(dp13924
g6
V335858
p13925
stp13926
a((dp13927
g2
(lp13928
VUnfortunately, your list is very much spot-on
p13929
aVThe root cause of this is that DLL-to-DLL or DLL-to-EXE is defined on the level of the operating system, while the the interface between functions is defined on the level of a compiler
p13930
aVIn a way, your task is similar (although somewhat easier) to that of client-server interaction, when the client and the server lack binary compatibility
p13931
aVThe compiler maps what it can to the way the DLL importing and exporting is done in a particular operating system
p13932
aVSince language specifications give compilers a lot of liberty when it comes to binary layout of user-defined types and sometimes even built-in types (recall that the exact size of  is compiler-dependent, as long as minimal sizing requirements are met), importing and exporting from DLLs needs to be done manually to achieve binary-level compatibility
p13933
aVWhen you use the same version of the same compiler, this last issue above does not create a problem
p13934
aVHowever, as soon as a different compiler enters the picture, all bets are off: you need to go back to the plainly-typed interfaces, and introduce wrappers to maintain nice-looking interfaces inside your code
p13935
as(dp13936
g6
V335858
p13937
stp13938
a((dp13939
g2
(lp13940
VAs long as you stay under the size limits putting the images into your app bundle sounds like a valid choice
p13941
aVYou can use 's  API to list paths for items with a specific extensions inside your bundle
p13942
aVIf you adopt a naming scheme where a path name encodes the name that you want to give your image in the list, you can implement a simple method that extracts image name from a resource path name
p13943
as(dp13944
g6
V335858
p13945
stp13946
a((dp13947
g2
(lp13948
VThis is because creating a new array does not create individual objects inside the array; you should be creating them separately, e
p13949
ag303
aVin a loop
p13950
as(dp13951
g6
V335858
p13952
stp13953
a((dp13954
g2
(lp13955
VYou can use  expression to capture the match
p13956
aVThe expression meaning is as follows: find quoted  followed by a colon and an opening quote
p13957
aVThen match every character before the following quote, and capture the result in a capturing group
p13958
aVThis fragment prints
p13959
as(dp13960
g6
V335858
p13961
stp13962
a((dp13963
g2
(lp13964
VListing subclass-specific constants in a base class is not that great an idea, because ideally a superclass should not know about its subclasses
p13965
aVJust listing the constants in the base is not as bad as using them to differentiate among subclasses in the code of the base class
p13966
aVIdeally, you should move the constants into their respective subclasses
p13967
aVIf you cannot do it without breaking a compile, you've indeed stumbled upon a prime candidate for refactoring
p13968
as(dp13969
g6
V335858
p13970
stp13971
a((dp13972
g2
(lp13973
VTry this:
p13974
as(dp13975
g6
V335858
p13976
stp13977
a((dp13978
g2
(lp13979
VInstead of sorting integers of , sort their indexes using  to compare items, and then re-arrange  in accordance with the permutation that you get back from the sort
p13980
aVHere is a quick demo:
p13981
as(dp13982
g6
V335858
p13983
stp13984
a((dp13985
g2
(lp13986
VAvoiding memory issues was a very useful byproduct of properties
p13987
aVTheir primary purpose remains access control ( vs
p13988
aV) and information hiding (i
p13989
ag630
aVlogic behind getting and setting the property can change at any time with no change required to the users of your class)
p13990
aVIn addition, if you need the  semantics, it is still available with the ARC
p13991
as(dp13992
g6
V335858
p13993
stp13994
a((dp13995
g2
(lp13996
VYou can use a simple regex to match parts of the sequence instead of splitting on a regex:
p13997
aVThis program produces the output below:
p13998
as(dp13999
g6
V335858
p14000
stp14001
a((dp14002
g2
(lp14003
VConsidering the assignment, you should be storing  rather than  in the  array
p14004
aVMoreover, I would make it a 2-D array of Booleans - a dimension for the suite, and a dimension for the rank
p14005
as(dp14006
g6
V335858
p14007
stp14008
a((dp14009
g2
(lp14010
VYou specified  option, so it makes sense that the expression does not differentiate between upper and lower case letters
p14011
aVWith the  option specified,  will match any letter, including capital ones; similarly,  will match lowercase letters as well
p14012
aVYour failed unit tests expect a different behavior: both of them are checking that the password contains upper and lower case letters, while the input contains letters in the same case
p14013
as(dp14014
g6
V335858
p14015
stp14016
a((dp14017
g2
(lp14018
VNo, since you need to do it a constant number of times, the complexity remains
p14019
aVNote that there is one more operation that you need to perform - namely, comparing strings
p14020
aVHowever, it's , and  remains
p14021
aVAlso note that your  is "underdefined": you should say that  is
p14022
as(dp14023
g6
V335858
p14024
stp14025
a((dp14026
g2
(lp14027
VMy guess is that this optimization has to do with the fact that you have a  statement immediately after your : optimizer realizes that it could piggyback on the returns embedded into your
p14028
aVfunctions, and reduces  to ; the  the CPU hits inside the selected  serves as the return from the
p14029
aVTry inserting some code after the switch to see if the compiler would replace  with
p14030
aVEDIT :
p14031
aVYour code on ideone has a  for a different reason: it's an equivalent of this:
p14032
as(dp14033
g6
V335858
p14034
stp14035
a((dp14036
g2
(lp14037
VI think  is still the best choice for readability
p14038
aVHowever, since its values get stored in the DB, you should specify the values explicitly:
p14039
as(dp14040
g6
V335858
p14041
stp14042
a((dp14043
g2
(lp14044
VYou should be able to do it with a transaction scope:
p14045
aVIf anything fails in this sequence, and the call  is not reached, the background transaction is rolled back
p14046
aVFor a solution that works across multiple db contexts, see this answer
p14047
as(dp14048
g6
V335858
p14049
stp14050
a((dp14051
g2
(lp14052
VThis is a Java pattern that lets  you access constants from the interface without typing the name of that interface over and over
p14053
aVThe pattern has been around since the early days, many years before s made their way into the language
p14054
aVSome consider it questionable, because it leads to creating interfaces that do not specify a contract
p14055
as(dp14056
g6
V335858
p14057
stp14058
a((dp14059
g2
(lp14060
V would do the trick
p14061
aVCreate separate instances for consonants, vowels, etc
p14062
aV, and use them to test membership
p14063
aVUpdate : For English subset of characters you can build a  array - similar to the one that you use in the update, but without the offset by , and with upper/lower case duplication: it will be even faster - pretty much as fast as it gets
p14064
as(dp14065
g6
V335858
p14066
stp14067
a((dp14068
g2
(lp14069
VYou can learn a lot about / in your favorite book on C (not on C++, because C++ provides much better facilities for representing strings than C does)
p14070
aVThe declaration/assignment
p14071
aVshould be
p14072
aVbecause string literals are pointers to constants
p14073
aVIf you want a  of strings in C++, you do it like this:
p14074
aVThis works, because string literals can be implicitly converted to
p14075
as(dp14076
g6
V335858
p14077
stp14078
a((dp14079
g2
(lp14080
VThere needs to be an  per button, so you'll need to create all 17 of them
p14081
aVConnect buttons to outlets individually, and then you will be able to put them into an array inside your initializer if you need them in an array
p14082
aVYou can save on the  methods, though: make one method like this
p14083
aVYou can connect this method to all buttons, and look at the tag of the  to decide which button called your action
p14084
as(dp14085
g6
V335858
p14086
stp14087
a((dp14088
g2
(lp14089
VIf you need to access a collection from multiple threads, you should either use synchronization, or use a  if your
p14090
aVNET version is 3
p14091
aV0 or higher
p14092
aVHere is one way to make the collection accessible to your thread:
p14093
aVIf you are on
p14094
aVNET 4 or later, a much better alternative to managing your threads manually is presented by various classes of the  namespace
p14095
aVConsider exploring this alternative before deciding on your threading implementation
p14096
as(dp14097
g6
V335858
p14098
stp14099
a((dp14100
g2
(lp14101
VArray names are denoted differently in Java
p14102
aVYou can modify your method as follows to process arrays:
p14103
as(dp14104
g6
V335858
p14105
stp14106
a((dp14107
g2
(lp14108
VThe problem is that  needs to generate a SQL expression to pass to RDBMS, and it cannot do it when all it has is an opaque predicate
p14109
aVThe obvious but inefficient way is to rewrite your query as follows:
p14110
aVA less trivial way would be as follows:
p14111
aVNote how instead of a predicate this method takes a predicate expression
p14112
aVNow it is transparent to the EF, and can be converted to a SQL query without a problem
p14113
as(dp14114
g6
V335858
p14115
stp14116
a((dp14117
g2
(lp14118
VThis cannot be done in theory, and can be done in practice only when maximal number of nested parentheses is known upfront
p14119
aVThat solution requires a rather non-pleasant expression, and is usually attempted as a curious homework exercise
p14120
aVHere is a link with better explanation of why regexp language is not powerful enough to solve the matching parentheses problem
p14121
aVYou need a parser to solve this problem; a simple recursive descent one will do the trick
p14122
aVWikipedia article at the link above has a sample implementation in C, which you should be able to translate to other languages with relative ease
p14123
as(dp14124
g6
V335858
p14125
stp14126
a((dp14127
g2
(lp14128
VYou can use , , and two non-nullable booleans to implement the same requirement:
p14129
as(dp14130
g6
V335858
p14131
stp14132
a((dp14133
g2
(lp14134
VTechnically,  does not create an empty array - it creates an array full of zeros
p14135
aVSince s is immutable, you do need to use  if you'd like to be able to populate it later
p14136
aVYou can make an array with a specific capacity, and then put objects into it, like this:
p14137
aVSince  is an , you can create it in a method as , and then return it as  to the callers
p14138
as(dp14139
g6
V335858
p14140
stp14141
a((dp14142
g2
(lp14143
VAttributes inside your XML file contains doubled slashes, but you are matching single ones
p14144
aVTo match a double slash in an XML/TXT file, you need four slashes in your C# file
p14145
as(dp14146
g6
V335858
p14147
stp14148
a((dp14149
g2
(lp14150
VA cheating but quick way of getting several strings out of a query returning one row would be as follows:
p14151
aVThe idea is to combine both strings into one on the MySql side, and split them back on the C# side
p14152
aVThis trick lets you avoid looping through a reader, closing it, and so on
p14153
aVIt assumes that the names do not contain  characters
p14154
as(dp14155
g6
V335858
p14156
stp14157
a((dp14158
g2
(lp14159
VThis is surprisingly complex, but doable:
p14160
aVI think Apple's design overcomplicated things a bit, compared to, say,
p14161
aVNET or even Java, but it is manageable
p14162
as(dp14163
g6
V335858
p14164
stp14165
a((dp14166
g2
(lp14167
VThis is a classic SQL Injection target
p14168
aVYou should be glad that you found it now
p14169
aVBack to your problem, when users enter , replace it with , and use  instead of  in your query
p14170
aVFor example, when end-users enter , run this query:
p14171
aVset  parameter to , and run the query
p14172
aVI used
p14173
aVNET's  in the example, but query parameters are denoted in ways specific to your hosting language
p14174
aVFor example, they become  in Java
p14175
aVCheck any DB programming tutorial on use of parameterized queries to find out how it's done in your system
p14176
aVEDIT : If you would like to perform an insert based on a wildcard that specifies records in another table, you can do an insert-from-select, like this:
p14177
aVThis will insert a record with the value of the  parameter into  table for each company with the ID matching
p14178
as(dp14179
g6
V335858
p14180
stp14181
a((dp14182
g2
(lp14183
VThis works:
p14184
aVHere is the link to sqlfiddle
p14185
as(dp14186
g6
V335858
p14187
stp14188
a((dp14189
g2
(lp14190
VYou can use regular expressions with a capturing group for that:
p14191
as(dp14192
g6
V335858
p14193
stp14194
a((dp14195
g2
(lp14196
VYou are almost there - your code was missing a parameter name for the image in the first block:
p14197
aVI think this is a bug in Xcode, because it expanded the signature into precisely what you posted, without the parameter name
p14198
as(dp14199
g6
V335858
p14200
stp14201
a((dp14202
g2
(lp14203
VIf it is your root view controller, and you have access to your app delegate, you should be able to access your controller like this:
p14204
as(dp14205
g6
V335858
p14206
stp14207
a((dp14208
g2
(lp14209
VYou need to create a separate instance of  each time you populate and insert it, otherwise you keep re-using the same instance, so only the last state of it appears in each position of the array
p14210
as(dp14211
g6
V335858
p14212
stp14213
a((dp14214
g2
(lp14215
V's  method is used for Key Value Coding, not for using an array as an associative container
p14216
aVYou need to use
p14217
as(dp14218
g6
V335858
p14219
stp14220
a((dp14221
g2
(lp14222
VYou are very close: switch around the two loops to get the effect that you are looking for
p14223
aVEverything else looks good
p14224
as(dp14225
g6
V335858
p14226
stp14227
a((dp14228
g2
(lp14229
VWhen you open in append mode, the file pointer is returned to the end of file before every write
p14230
aVYou can reposition the pointer with  for reading, but as soon as you call a function that writes to the file, the pointer goes back to the end of file
p14231
aVThe answer at this link references the appropriate section of the C standard
p14232
aVUse the  mode if you would like to write to arbitrary places in file
p14233
aVAn existing file will be overwritten
p14234
aVIf you would like to append to an existing file initially, but then  to arbitrary place, use  followed by
p14235
as(dp14236
g6
V335858
p14237
stp14238
a((dp14239
g2
(lp14240
VEffectiveness relates to the ability to produce the desired result
p14241
aVSome tasks inherently do not have strict definitions - for example, machine translation between two human languages
p14242
aVDifferent algorithms exist to translate, say, from English to Spanish; their effectiveness is a measure of how good are the results that these algorithms produce
p14243
aVTheir efficiency , on the other hand, measure how fast they are at producing the results, how much memory they use, how much disk space they need, etc
p14244
as(dp14245
g6
V335858
p14246
stp14247
a((dp14248
g2
(lp14249
VWhen the user taps outside the delete mark in a cell, your program should receive a call to  on the table view delegate
p14250
as(dp14251
g6
V335858
p14252
stp14253
a((dp14254
g2
(lp14255
VThis regexp should do the trick
p14256
aVIt uses a negative lookbehind to avoid matching multiple dashes in a row
p14257
aVHere is a C# code that illustrates its use (also on ideone):
p14258
as(dp14259
g6
V335858
p14260
stp14261
a((dp14262
g2
(lp14263
VNo, you cannot do that: once you import a file, all its imports come in as well
p14264
aVHowever, if you want to use only , you can forward-declare it in your own header, instead of importing 's header:
p14265
aVNow you can make variables of type , use  as return type or a parameter type, etc
p14266
aVAt the same time, dependencies of 's header will not be loaded
p14267
aVIn general, it is a good idea to reduce the number of headers that you import inside your header, for example by moving imports related to implementation (rather than the interface) into the
p14268
aVm file, and using class extensions
p14269
as(dp14270
g6
V335858
p14271
stp14272
a((dp14273
g2
(lp14274
VFrom C++ spec, 12
p14275
ag1340
ag10442
aVIf there is no user-declared constructor for class X, a default constructor is implicitly declared
p14276
aVAn implicitly-declared default constructor is an  member of its class
p14277
aVYour  class declared a constructor, hence C++ compiler did not declare an implicit constructor for you
p14278
aVThe rationale for this behavior is that since you provided constructors that take parameters, you probably need these parameters in order to properly initialize an instance of your class
p14279
aVThe assumption here is that if you wanted a default constructor in addition to a non-default one, you'd simply declare it
p14280
as(dp14281
g6
V335858
p14282
stp14283
a((dp14284
g2
(lp14285
VYou do not need to use recursion for path reconstruction (in fact, you never have to use recursion in Java, it just happens to be a lot more convenient to use it to solve certain problems, including this one)
p14286
aVIn order to be able to figure out the shortest path in addition to the length, you need a second 2D array that stores successors of your node in the path
p14287
aVTake a look at this article, the array I am talking about is called  in their pseudocode
p14288
aVRecall that the logic of the algorithm goes as follows: "if you can get from  to  through  faster than going from  to  through any previously discovered path, then use the path though  as your current shortest path"
p14289
aVNow all you need to do is to store the decision to go through  in some other array, like this:
p14290
aVOnce Floyd-Warshal finishes, you can reconstruct the path from  to  by first reconstructing the path from  to  and then from  to
p14291
as(dp14292
g6
V335858
p14293
stp14294
a((dp14295
g2
(lp14296
VYou are missing an
p14297
as(dp14298
g6
V335858
p14299
stp14300
a((dp14301
g2
(lp14302
VThe easiest solution would be to use  of C# 4
p14303
aV0: calls to  method will block until something has been added to the queue, letting you avoid using synchronization primitives altogether
p14304
as(dp14305
g6
V335858
p14306
stp14307
a((dp14308
g2
(lp14309
VOverwriting a portion of a string is done with one of the several overloads of 's  member function, for example:
p14310
aVYou can play with this example at ideone [link]
p14311
as(dp14312
g6
V335858
p14313
stp14314
a((dp14315
g2
(lp14316
VYou extend an interface when a subinterface provides everything the superinterface provides, and does something else of importance
p14317
aVFor example,  implements , because sorted map is a map that supports all operations of a map, plus some operations applicable only to sorted maps
p14318
aVThis is similar to inheriting among classes, but it allows for multiple implementations
p14319
aVFor example, one could implement a  as a sorted list of keys plus a parallel array of values, rather than a tree
p14320
aVThis would let users swap in a faster or otherwise superior implementation without changing the rest of the code
p14321
aVIn other words, inheritance among interfaces lets you preserve the benefits of programming to interfaces
p14322
as(dp14323
g6
V335858
p14324
stp14325
a((dp14326
g2
(lp14327
VIt is SQL Server - specific
p14328
aVIn general, I would recommend against taking a sort order in a  method
p14329
aVInstead, I would provide a separate  and  methods, in a way LINQ does with
p14330
aVMoreover, if implementing  is an option, that would be my first choice: you'd be able to "piggyback" on the knowledge the users of your library have accumulated over the years of using LINQ
p14331
as(dp14332
g6
V335858
p14333
stp14334
a((dp14335
g2
(lp14336
VYou are ordering first by  when the flag is , and then resolve ties by  when the flag is
p14337
aVThis is because the first  expression evaluates to  when  is not , so all records with the flag of  are moved to after the records with the flag of
p14338
as(dp14339
g6
V335858
p14340
stp14341
a((dp14342
g2
(lp14343
VYou can link to a C++ library from C only when the C++ library has been designed to be used from C
p14344
aVSpecifically, the functions the library provides need to be exported with  block to avoid name mangling, and the interface should be designed in a way to be usable from plain C (i
p14345
ag630
aVno classes or member functions, only functionless structs and plain functions)
p14346
aVIt is worth mentioning that you can compile your C code with a C++ compiler, and it will for the most part be OK
p14347
aVThis lets you pretend that your C code is a C++ code, and freely mix in functionality provided through C++ - specific interfaces
p14348
as(dp14349
g6
V335858
p14350
stp14351
a((dp14352
g2
(lp14353
VYour prototype is for , but you are calling
p14354
aVIn this case, the  function has no prototype, so the last parameter is considered to be an
p14355
aVThat's why you do not get the expected conversion
p14356
aVRenaming the prototype should fix it:
p14357
as(dp14358
g6
V335858
p14359
stp14360
a((dp14361
g2
(lp14362
VYou get a crash because you are passing  an uninitialized pointer, and  dereferences it
p14363
aVYou do not get a crash the first time by pure luck
p14364
aVThis will not crash:
p14365
as(dp14366
g6
V335858
p14367
stp14368
a((dp14369
g2
(lp14370
VYou can use  to cache the data
p14371
aVBefore going to DB, check if the data is in the cache
p14372
aVIf it is not, read the DB and put the results in the cache; next time the access is going to be almost instantaneous
p14373
aVYou can also use Core Data to access the database: it caches results for you
p14374
as(dp14375
g6
V335858
p14376
stp14377
a((dp14378
g2
(lp14379
VHere is one way to do it: select the number of distinct event IDs associated with the user and the total number of event IDs out there
p14380
as(dp14381
g6
V335858
p14382
stp14383
a((dp14384
g2
(lp14385
VYou can use  to do it:
p14386
as(dp14387
g6
V335858
p14388
stp14389
a((dp14390
g2
(lp14391
VFrom the documentation of :
p14392
aVor binary streams, the value returned corresponds to the number of bytes from the beginning of the file
p14393
aVFor text streams, the value is not guaranteed to be the exact number of bytes from the beginning of the file, but the value returned can still be used to restore the position indicator to this position using fseek
p14394
aVSo yes, this is normal
p14395
as(dp14396
g6
V335858
p14397
stp14398
a((dp14399
g2
(lp14400
VLooks like each line in your file is whitespace-separated set of tokens
p14401
aVThe easiest thing to do in this case would be to use , and get the token that you want by its position in the string
p14402
as(dp14403
g6
V335858
p14404
stp14405
a((dp14406
g2
(lp14407
VYou cannot use aliased columns in the same , but you can wrap it into another select to make it work:
p14408
as(dp14409
g6
V335858
p14410
stp14411
a((dp14412
g2
(lp14413
VImplement  in the delegate, check the replacement string for special characters, and disallow the replacement if you detect any
p14414
aVThe easiest way to check for non-alphanumerics is as follows:
p14415
as(dp14416
g6
V335858
p14417
stp14418
a((dp14419
g2
(lp14420
VNo, there is no syntax like that
p14421
aVMoreover, because of type erasure, the actual type  is not available at runtime, so it wouldn't be possible inside a generic even if the syntax were available
p14422
aVThe trick is to pass  along with other parameters, and use reflection to get the method:
p14423
aVNow you can query the class for the method , and use that method in the calculations
p14424
aVThis does not help you get away from passing strings (i
p14425
ag630
aVthe compiler wouldn't trigger an error when the method does not exist) but you can make it work with generics in spite of type erasure
p14426
as(dp14427
g6
V335858
p14428
stp14429
a((dp14430
g2
(lp14431
VSemantics of the add-assign operators is different in C and C++:
p14432
aVC99 standard, 6
p14433
ag10442
aV16, part 3:
p14434
aVAn assignment operator stores a value in the object designated by the left operand
p14435
aVAn
p14436
aVassignment expression has the value of the left operand after the assignment, but is not an
p14437
aVlvalue
p14438
aVIn C++ 5
p14439
aV17
p14440
aV1:
p14441
aVThe assignment operator (=) and the compound assignment operators all group right-to-left
p14442
aVAll require a modi\ufb01able
p14443
aVlvalue as their left operand and return an lvalue with the type and value of the left operand after the assignment has taken place
p14444
aVEDIT : The behavior of  in C++ is undefined in C++98, but well defined in C++11
p14445
aVSee this answer to the question by aix for the relevant portions of the standards
p14446
as(dp14447
g6
V335858
p14448
stp14449
a((dp14450
g2
(lp14451
VYou can use LINQ
p14452
aVIt wouldn't be any faster, because you still need to look at each cell in case the value is not there, but it will fit in a single line:
p14453
aVFor searching for random text and returning an array of rows with at least one cell that has a case-insensitive match, use this:
p14454
as(dp14455
g6
V335858
p14456
stp14457
a((dp14458
g2
(lp14459
VThe "in increasing order" part of the input specification is the key: since both lists are pre-sorted, you can read the first one into an array, and then use binary search from the location of the last item to the end of the array to decide if you have a match or not
p14460
aVIn fact, even a linear search of the first array might work, because you will need to traverse it at most once
p14461
as(dp14462
g6
V335858
p14463
stp14464
a((dp14465
g2
(lp14466
VYou are writing past the array boundary: when you initialize an array with two characters, the last valid index is , not
p14467
aVYou should initialize your array with three items, as follows:
p14468
aVYou could as well use this version:
p14469
aVThis will give you a writable array with a zero-terminated string inside
p14470
as(dp14471
g6
V335858
p14472
stp14473
a((dp14474
g2
(lp14475
VYou can use the Median of Medians algorithm to find median of an unsorted array in linear time
p14476
as(dp14477
g6
V335858
p14478
stp14479
a((dp14480
g2
(lp14481
VThis is because the  removes rows with no corresponding  row
p14482
aVMoving the condition from the  filter to the  clause should address the problem:
p14483
as(dp14484
g6
V335858
p14485
stp14486
a((dp14487
g2
(lp14488
VAssuming the values are of type , you can try this:
p14489
as(dp14490
g6
V335858
p14491
stp14492
a((dp14493
g2
(lp14494
VProcesses are not like threads: you cannot get access to instances of classes running in different processes, because they are in a different address space
p14495
aVYou need to use interprocess communication facilities to communicate to other processes
p14496
as(dp14497
g6
V335858
p14498
stp14499
a((dp14500
g2
(lp14501
VChange the expression as follows:
p14502
aVUsing  in place of  ensures at least two matches of the prior regexp must be made
p14503
as(dp14504
g6
V335858
p14505
stp14506
a((dp14507
g2
(lp14508
VYou can try creating  with the content of the string, like this:
p14509
aVYou can also store an  to a file directly:
p14510
aVNOTE This answer is edited after Ken Thomases's note
p14511
as(dp14512
g6
V335858
p14513
stp14514
a((dp14515
g2
(lp14516
VI suspect that you need to qualify  with
p14517
aVor add  to the top of your cpp file
p14518
as(dp14519
g6
V335858
p14520
stp14521
a((dp14522
g2
(lp14523
VCreate a  for items that you have seen, scan through  recording duplicate indexes, then delete indexes that you marked as duplicates while going back starting at the end of the vectors
p14524
aVGoing back is important, because otherwise your indexes will get out of sync
p14525
as(dp14526
g6
V335858
p14527
stp14528
a((dp14529
g2
(lp14530
VSort the ends of the non-overlapping intervals in a single array
p14531
aVMark each end with a flag indicating if it is the beginning or the end of the interval, like this:
p14532
aVNow run a binary search with the target address, say,
p14533
aVThe insertion point falls on , which is marked as
p14534
aVThis means that  is one of the intervals
p14535
aVNow consider searching for
p14536
aVIts insertion point falls on , which is marked as
p14537
aVSince  is not equal to the , we know that  is not one of the intervals
p14538
aVThe cost of a search is , where  is the number of intervals
p14539
aVIf you feel adventurous, consider implementing an
p14540
aVThis is probably not worth it for non-overlapping intervals, though
p14541
as(dp14542
g6
V335858
p14543
stp14544
a((dp14545
g2
(lp14546
VAlthough  is a local variable, what it points to is not local - it is a compile-time string constant; it is legal to return that constant's address from a function
p14547
aVis different, because the compile-time string constant is copied into an automatic storage area, causing an undefined behavior on dereferencing the returned pointer
p14548
as(dp14549
g6
V335858
p14550
stp14551
a((dp14552
g2
(lp14553
VYou are zeroing out  in the process of reversing it
p14554
aVYou should make a copy, and compare the reversed product to it
p14555
aVNote that at this point your solution would print all palindromes, not just the lagrest one
p14556
aVGetting the largest one should be trivial, though
p14557
as(dp14558
g6
V335858
p14559
stp14560
a((dp14561
g2
(lp14562
VSince  is an , you can use the  method:
p14563
as(dp14564
g6
V335858
p14565
stp14566
a((dp14567
g2
(lp14568
V is the special name for the value being assigned in a setter
p14569
aVIts type is the same as the type of the property being assigned, in this case it's
p14570
aVWhatever you can do with any other variable of type , you can do with
p14571
aVSo if  has a property called , you can access that property as
p14572
as(dp14573
g6
V335858
p14574
stp14575
a((dp14576
g2
(lp14577
VI think your professor was driving at an idea of passing command line arguments to your Java program
p14578
aVRemember the  in the signature of
p14579
aVThat's the mechanism that he probably would like you to use, because it is the most flexible one
p14580
aVSince you can pass any number of strings to your program on the command line, you can make a convention that the first argument will be the name of the file the user wants your program to open
p14581
as(dp14582
g6
V335858
p14583
stp14584
a((dp14585
g2
(lp14586
VThe first parameter of the pattern is a regular expression
p14587
aVIt must conform to a regular expression language, a widely used way to describe such patterns
p14588
aVAlthough the fine details of regular expressions are very important to understand, and are often subjects of lengthy college courses, you can learn the basics by following a simple tutorial [link], following numerous examples, and trying your hand at writing regular expressions for your particular purposes
p14589
aVThere are many implementations of regular expression engines, with widely different capabilities
p14590
aVTo learn the particulars of the Java "dialect" of regular expressions, follow the documentation of the  class
p14591
as(dp14592
g6
V335858
p14593
stp14594
a((dp14595
g2
(lp14596
VYou should be able to get what you need by using  from zero:
p14597
as(dp14598
g6
V335858
p14599
stp14600
a((dp14601
g2
(lp14602
VThis is somewhat long in Cocoa, but you can do it:
p14603
aVThis prints
p14604
as(dp14605
g6
V335858
p14606
stp14607
a((dp14608
g2
(lp14609
VSince  is available only on the  subclass, you need to tell Java that you know you're looking at a , and cast explicitly:
p14610
aVThis is not a very good way to do things in Java, because you are explicitly testing for the type of subclass
p14611
as(dp14612
g6
V335858
p14613
stp14614
a((dp14615
g2
(lp14616
VParameter names are required so that you could use invocation syntax that specifies parameter names explicitly:
p14617
aVNote how this code switched first and last name around; the delegate will get them in the correct order, though:  will be passed to the first formal parameter of the delegate, and  will be passed to the second parameter
p14618
as(dp14619
g6
V335858
p14620
stp14621
a((dp14622
g2
(lp14623
VYou are pointing to the address correctly, but you may not pass a pointer to  to  in a position expecting an  pointer
p14624
aVThis is because  sees  specifier, it assumes that the corresponding position in the variadic argument list is a pointer to signed ; because of the way the varargs are implemented in C and C++,  has no other way of going about it
p14625
aVHere is how you should rewrite your loop:
p14626
as(dp14627
g6
V335858
p14628
stp14629
a((dp14630
g2
(lp14631
VAll pointers are of the size known to the compiler at compile time; it is the size of the item being pointed to that may be different
p14632
aVYou pass the required size to / yourself, so the compiler has no problem with allocation
p14633
aVEDIT (in response to a comment) There are cases when sizes of different pointers are different
p14634
aVFor example, in the code compiled for Harvard architecture a data pointer must include an extra storage that distinguishes the data stored in program memory from the data stored in the data memory, while function pointers do not need that extra storage
p14635
aVHowever, this is known to the compiler, so it knows the required allocation size from looking at the type of the pointer
p14636
as(dp14637
g6
V335858
p14638
stp14639
a((dp14640
g2
(lp14641
VYou are right, this is the make-or-break function for smooth scrolling
p14642
aVYou need to make it as fast as you can by avoiding as much calculation as possible
p14643
aVFor example, you could add caching for the image processed by your  method: set up an instance of  to store processed images; key them by the index path, and avoid recomputation when the same image is requiested multiple times during the process of scrolling
p14644
as(dp14645
g6
V335858
p14646
stp14647
a((dp14648
g2
(lp14649
VTry using positive lookahead assertion:
p14650
aVThis expression matches one or more word characters only if it is followed by an optional space and a double-digit decimal number enclosed in square brackets
p14651
as(dp14652
g6
V335858
p14653
stp14654
a((dp14655
g2
(lp14656
VThe method is behaving as described in the documentation:
p14657
aVThe characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign '-' ('\u005cu002D') to indicate a negative value
p14658
aVYou need to skip the first character if it is a  to do the parse correctly:
p14659
as(dp14660
g6
V335858
p14661
stp14662
a((dp14663
g2
(lp14664
VIt is already : Here is your code on ideone that verifies that
p14665
aVUnlike value types (i
p14666
ag630
aVs), reference (i
p14667
ag630
aV) objects are passed by reference
p14668
ag1971
ag1972
aVGenerics are available since C#2
p14669
aV0, so consider using  in place of  for improved type safety
p14670
as(dp14671
g6
V335858
p14672
stp14673
a((dp14674
g2
(lp14675
VHere is what the manual has to say about  problem:
p14676
aVNever use gets()
p14677
aVBecause it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use
p14678
aVIt has been used to break computer security
p14679
aVUse fgets() instead
p14680
aVThe leak problem happens because the pointer  is passed by value, so any changes, including assignments after reallocation, are done to its copy, not to the original pointer
p14681
aVAs a consequence, freeing  frees only the memory that has been allocated originally, leaking the -ed one
p14682
aVTo fix this, change  to take a pointer to a pointer, like this:
p14683
aVPass  to , and use  in place of  in the body of the function
p14684
as(dp14685
g6
V335858
p14686
stp14687
a((dp14688
g2
(lp14689
VThis is most likely because you are passing it a pointer to non-writable memory, such as one obtained from a string literal:
p14690
aVYou can change the call to avoid the error:
p14691
aVOn a side note, your change to upper case works only when all letters are in the lower case
p14692
aVYou should use  function instead of subtracting 32
p14693
as(dp14694
g6
V335858
p14695
stp14696
a((dp14697
g2
(lp14698
VThe use of the term function in the context of C/C++ is rather confusing, because it disagrees wiht the mathematical concept of a function as "something returning a value"
p14699
aVWhat C/C++ calls functions returning void corresponds to the concept of a procedure in other languages
p14700
aVThe major difference between a function and a procedure is that a function call is an expression, while a procedure call is a statement While functions are invoked for their return value, procedures are invoked for their side effects (such as producing output, changing state, and so on)
p14701
as(dp14702
g6
V335858
p14703
stp14704
a((dp14705
g2
(lp14706
VYou are not passing a method, you are passing the result of calling a method
p14707
aVThe only advantage of introducing a temp variable there is to help you debug: if you put a breakpoint on the second line, you'll be able to see the value you're passing to
p14708
aVOther than that, the two invocations are identical
p14709
as(dp14710
g6
V335858
p14711
stp14712
a((dp14713
g2
(lp14714
VIn case you do not know how many lists there are, you do not write nested loops: instead, you write recursion
p14715
aVAt each level of the invocation you loop a single list, like this:
p14716
aVCall  as follows:
p14717
as(dp14718
g6
V335858
p14719
stp14720
a((dp14721
g2
(lp14722
VThis is an issue with the formatting, not the number
p14723
aVIf you change  to
p14724
aVthe results look more along the lines of what you've expected:
p14725
aVThe "junk" at the end is due to the limited precision of floating point numbers
p14726
as(dp14727
g6
V335858
p14728
stp14729
a((dp14730
g2
(lp14731
VIt is possible to sort it without LINQ, as long as you manage to declare your list as that of a List of objects of anonymous type using the  syntax, or are willing to use :
p14732
as(dp14733
g6
V335858
p14734
stp14735
a((dp14736
g2
(lp14737
VSince you are not in a database, and you need a tight control over the sorting, you could use a single OrderBy with a custom IComparer that accesses only what it needs, and does not perform unnecessary evaluations
p14738
as(dp14739
g6
V335858
p14740
stp14741
a((dp14742
g2
(lp14743
VTry this:
p14744
aVThis expression uses negative lookahead and negative lookbehind to disallow spaces at the beginning or at the end of the string, and requiring the match of the entire string
p14745
as(dp14746
g6
V335858
p14747
stp14748
a((dp14749
g2
(lp14750
VYou cannot initialize a reference by assignment, it needs to be done in the initializer list:
p14751
aVThe  assignment is a call of the assignment operator on the value being referenced by  into the variable being referenced by , which is uninitialized
p14752
aVAssignment syntax works only when it is combined with the declaration:
p14753
as(dp14754
g6
V335858
p14755
stp14756
a((dp14757
g2
(lp14758
VYou can scan the string for spaces, and cut everything after the fifth space
p14759
aVIf there are only four spaces, keep the entire string (this means that there is no timezone)
p14760
aVThis answer has been edited after a comment by Jon
p14761
as(dp14762
g6
V335858
p14763
stp14764
a((dp14765
g2
(lp14766
VNET solution is more flexible than one involving a single global generator
p14767
aVIt lets each part of your application to create and use independent sequences of repeatable pseudorandom numbers, which is vital for debugging purposes
p14768
aVDebugging code that relies on pseudorandom numbers is no fun to start with; when the same generator is accessed from different parts of the code, it becomes impossible
p14769
aVAt the same time, if you want to have a shared instance of , you can easily make it available to your application with just a few lines of code:
p14770
as(dp14771
g6
V335858
p14772
stp14773
a((dp14774
g2
(lp14775
VSince you do not use the value of  unless there is a click, you do not need to update it on timer: it is sufficient to store the time at the moment when you start animation
p14776
aVKnowing that each image is shown for five seconds, you can calculate the index of the image being displayed by taking the difference, in seconds, between the time of the click and the time when you started the animation, dividing it by five, and taking the remainder of the division by the total number of images
p14777
aVSay you have ten images, each displaying for five seconds in a loop
p14778
aVLet's also say that the animation has started at
p14779
aVNow let's say there's a click at , or  seconds after the animation has started
p14780
aVAfter dividing by five you get ; taking the remainder of the division by ten, you get
p14781
aVTherefore, you know that the user has clicked on the third image in the animation loop (as usual, indexes start from zero)
p14782
as(dp14783
g6
V335858
p14784
stp14785
a((dp14786
g2
(lp14787
VThe second one implements an Objective-C Category on , i
p14788
ag630
aVmethods that operate on , but are not provided by the writers of  class
p14789
aVAdding categories lets you extend functionality of a class in a way that is somewhat similar to C#'s extension methods: the objects start responding to the messages defined in categories, making it convenient for you to write functionality in a flexible and modular way
p14790
as(dp14791
g6
V335858
p14792
stp14793
a((dp14794
g2
(lp14795
VYou need to add  before the array aggregate:
p14796
as(dp14797
g6
V335858
p14798
stp14799
a((dp14800
g2
(lp14801
VWhile singly linked list uses less memory per node (one pointer vs
p14802
aVtwo pointers), its deletion operation is  if all you have is a pointer to the node you want deleted, while doubly-linked deletion is
p14803
aVThere is a little-known trick that lets you delete from a singly-linked list in , but the list must be circular for it to work (move the content of  into the current, and delete )
p14804
aVDoubly-linked lists can be used in places where singly-linked lists would not work (a doubly-ended queue), but they require slightly more "housekeeping", and are slightly less efficient on insertions as the result
p14805
as(dp14806
g6
V335858
p14807
stp14808
a((dp14809
g2
(lp14810
VYou are missing double quotes, you put parameters in wrong places, and you do not need an  statement:
p14811
as(dp14812
g6
V335858
p14813
stp14814
a((dp14815
g2
(lp14816
VThe only case where using a map is appropriate is when you are designing a factory, and you need to pass different kinds of parameters to different classes being created
p14817
aVIn all other cases, a solution with a specialized parameter info class would be preferred
p14818
aVFor an example of where passing a map is appropriate, look at the  method: this method needs to pass parameters to constructors of driver-specific implementations of the  being created, so it wraps a map into , and lets the user pass it through to the driver-specific connection
p14819
aVNote that  does not have another solution that would be future-proof
p14820
aVI would strongly discourage using a map in all other cases: the added flexibility shifts error detection from compile-time to run-time, which has a strong potential of multiplying your headache beyond belief
p14821
as(dp14822
g6
V335858
p14823
stp14824
a((dp14825
g2
(lp14826
VAlthough there is more than one way to achieve these layouts, I would guess that you are looking at , the most flexible but also the hardest of them all to get right
p14827
aVYour first picture has six rows and four columns
p14828
aVFields occupy all columns in the first three rows; text area occupies the first column in rows four through six; buttons occupy individual cells
p14829
aVYour second picture has four rows and six columns
p14830
aVText areas are one column by three rows, text field is one row by six columns, and buttons are one cell each
p14831
aVOracle offers a tutorial on it - if you work through their examples, you should be able to make your own layouts that look like the ones in your pictures
p14832
as(dp14833
g6
V335858
p14834
stp14835
a((dp14836
g2
(lp14837
VYou can use , a reentrant version of , to separate elements of a string into tokens
p14838
aVYou can call  in a loop, call  on each token, and add tokens to the array for the row
p14839
aVhas a usage pattern that is nearly identical to that of , but it has an extra parameter to represent the current state of the tokenizer
p14840
aVRegular  keeps that state in the static memory, making the function non-re-entrant
p14841
as(dp14842
g6
V335858
p14843
stp14844
a((dp14845
g2
(lp14846
VMake an array of strings, and place the description at the index the description represents:  would be at index 13,  at index 12, and so on
p14847
aVSince  array never changes, you can initialize it once, and store in a static variable or an ivar
p14848
as(dp14849
g6
V335858
p14850
stp14851
a((dp14852
g2
(lp14853
VYour second option is incorrect: DFS does not explore all possible paths, unless your graph is a tree or a forest, and you start from the roots
p14854
aVThe second algorithm that I know is negating the weights and finding the shortest path, but it is somewhat slower than the top sort + DP algorithm that you listed as #1
p14855
as(dp14856
g6
V335858
p14857
stp14858
a((dp14859
g2
(lp14860
VThis LINQ solution should work:
p14861
as(dp14862
g6
V335858
p14863
stp14864
a((dp14865
g2
(lp14866
VIn C++11 where  is available, the answer is "yes, arrays should be avoided"
p14867
aVPrior to C++11, you may need to use C arrays to allocate arrays in the automatic storage (i
p14868
ag630
aVon the stack)
p14869
as(dp14870
g6
V335858
p14871
stp14872
a((dp14873
g2
(lp14874
VThis is C99 feature called designated initializers
p14875
aVIt lets you specify the names of the fields to which you set values, rather than specifying the values in the order the corresponding fields appear in the declaration
p14876
aVAdditionally, this syntax lets you initialize members of unions other than the first one - something that was impossible before C99
p14877
as(dp14878
g6
V335858
p14879
stp14880
a((dp14881
g2
(lp14882
VAccording to the C standard, Section 6
p14883
ag10442
aV3
p14884
aV4
p14885
aV2:
p14886
aVThe sizeof operator yields the size (in bytes) of its operand, which may be an
p14887
aVexpression or the parenthesized name of a type
p14888
aVThe size is determined from the type of
p14889
aVthe operand
p14890
aVThe result is an integer
p14891
aVIf the type of the operand is a variable length array
p14892
aVtype, the operand is evaluated; otherwise, the operand is not evaluated and the result is an
p14893
aVinteger constant
p14894
aVIn your case, the operands  and  are pointers (which makes sense, because you have just assigned to them the result of calling )
p14895
aVTherefore, their size is the same as the size of any other pointer on your system - 4 bytes
p14896
aVIn case you are wondering, there is no standard way to determine how much memory you have -ed; if you need that size for future reference, you need to store that number in a separate variable
p14897
as(dp14898
g6
V335858
p14899
stp14900
a((dp14901
g2
(lp14902
VTry this:
p14903
aVThe  part is optional - the compiler figures out the parameter types from the left side of the  assignment
p14904
aVEDIT The problem with your code is that it accesses modified closure
p14905
aVYou should make a temp variable from , and use it inside your lambda to fix the problem
p14906
as(dp14907
g6
V335858
p14908
stp14909
a((dp14910
g2
(lp14911
VTry making  nullable (i
p14912
ag630
aV, not )
p14913
aVOtherwise, it would not be possible to insert the first user
p14914
aVYou also need to change  to  to make the model aware of the fact that there may not be a
p14915
aVSee this answer for details on setting up optional links in code first
p14916
as(dp14917
g6
V335858
p14918
stp14919
a((dp14920
g2
(lp14921
VYou need to initialize your variable before you can access it
p14922
aVAlso you should derive your class from
p14923
as(dp14924
g6
V335858
p14925
stp14926
a((dp14927
g2
(lp14928
VThis is not a truth table - rather, it's a table of binary numbers
p14929
aVYou can use Java's  method to generate the zeros and ones that you need; inserting spaces should be trivial
p14930
as(dp14931
g6
V335858
p14932
stp14933
a((dp14934
g2
(lp14935
VAlthough you cannot do it with generics, there is a simple, easy to understand, solution that lets you avoid code duplication in cases like that:
p14936
as(dp14937
g6
V335858
p14938
stp14939
a((dp14940
g2
(lp14941
VYou should make  a reference and initialize it in the initializer list
p14942
aVOtherwise, C++ tries to make a copy of an instance of the  - precisely the thing that you wanted to avoid
p14943
as(dp14944
g6
V335858
p14945
stp14946
a((dp14947
g2
(lp14948
VAccording to C standard, 6
p14949
aV9
p14950
ag1340
aV12, reaching an end of the function is undefined behavior only if the caller uses the returned value:
p14951
aVIf the  that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined
p14952
aVThat's why the compiler must let this code compile
p14953
as(dp14954
g6
V335858
p14955
stp14956
a((dp14957
g2
(lp14958
VThe reason you are getting bus errors is because you are attempting to write into non-writable area (i
p14959
ag630
aVinto the character constant, and also past the end of it); this is undefined behavior
p14960
aVThe call to  tries to write into the terminating zero of , and then continues writing past the end of the string constant
p14961
aVThis is undefined behavior, so your program crashes
p14962
aVTo fix this problem, you need to copy  into , rather than assigning it to the  pointer
p14963
as(dp14964
g6
V335858
p14965
stp14966
a((dp14967
g2
(lp14968
VWindows calculator interprets 60 as degrees; your calculator interprets 60 as radians
p14969
aVBoth answers are correct
p14970
aVIf you want the number interpreted as degrees instead, multiply by  and divide by 180
p14971
as(dp14972
g6
V335858
p14973
stp14974
a((dp14975
g2
(lp14976
VThis is not how you declare ten strings of 10,000 characters each - you declared a 2D array of strings, 10x10000
p14977
aVThis is how you do it the C++ way if you want each string to have 10,000 characters:
p14978
aVNote that you need to specify the character that you want repeated 10,000 times
p14979
aVSince  is designed to grow dynamically, you can skip the 10,000 part altogether: the library will allocate as much memory as it needs
p14980
aVYou can also use  in C++11
p14981
as(dp14982
g6
V335858
p14983
stp14984
a((dp14985
g2
(lp14986
VConstant is an identifier, not a string literal (string literals have double quotes around them; identifiers do not)
p14987
aVConstant value, on the other hand, is a string literal, not an identifier
p14988
aVYou need to switch it around like this:
p14989
as(dp14990
g6
V335858
p14991
stp14992
a((dp14993
g2
(lp14994
VThis is because the example you show uses shared memory API, which provides you a flat chunk of memory, not an array of, say, floats
p14995
aVTherefore, you need to do all your pointer manipulations manually
p14996
aVYou could also cast your shared pointer to  and use an index, like this:
p14997
as(dp14998
g6
V335858
p14999
stp15000
a((dp15001
g2
(lp15002
VYou can count your rows, and add  when the count is divisible by four:
p15003
as(dp15004
g6
V335858
p15005
stp15006
a((dp15007
g2
(lp15008
VSince you are casting a pointer, you should be casting it to a pointer to a structure, rather than a structure itself, like this:
p15009
aVAlso note that your parentheses are in a wrong place
p15010
as(dp15011
g6
V335858
p15012
stp15013
a((dp15014
g2
(lp15015
VThis will work:
p15016
aVThe idea is to first decompose each character with diacritical mark into a sequence of its base character and a sequence of Unicode combining diacritical marks (that's done by ), then go through the string, and remove all such marks one by one (that's what the loop does)
p15017
as(dp15018
g6
V335858
p15019
stp15020
a((dp15021
g2
(lp15022
VUsing  indexes into the container permanently is fragile, because you cannot delete or insert items in the middle of the container without reshuffling all your indexes
p15023
aVUsing indexes temporarily during a copy or a serialization operation is a lot better: use pointers as you describe in your first approach for operations that do not rely on node identity, and create a temporary identity of a node (say, its index) only for the duration of the operation where it is required
p15024
aVFor example, before you start a copying operation in the copy constructor, create a , and an
p15025
aVPerform copying in two passes: first, add a copy of the node without the references to the vector, and an address of the old node to the map
p15026
aVThen go through your nodes again, and resolve references by looking up the address of the new node in the vector using its index from the unordered map
p15027
as(dp15028
g6
V335858
p15029
stp15030
a((dp15031
g2
(lp15032
VThe simplest way to reuse code among methods of the same class like that is to define a private method for that calculation
p15033
aVThis way you'd be able to reference that code by calling a method, rather than by copy-pasting some code
p15034
aVIn fact, every time you copy-paste, you know you're missing a method
p15035
aVIf you need to share code among related classes, you can make a protected method in the base class
p15036
aVFinally, for project-wide "horizontal" reuse you can define a static helper class, and your methods to it as public static
p15037
aVThis way every class in your project would be able to reuse your calculation
p15038
as(dp15039
g6
V335858
p15040
stp15041
a((dp15042
g2
(lp15043
VSince  is not executed before  block has finished, and because the entire method is , the lock is not released until after the  block has finished
p15044
aVIf you need to release the lock on exception rather than on returning from the method, you can nest your  block inside the / block:
p15045
as(dp15046
g6
V335858
p15047
stp15048
a((dp15049
g2
(lp15050
VWhen you declare an int, you do not add : it's not an  type
p15051
aVWhat you have is a pointer to an ; on a 32-bit platform it increments by 4
p15052
as(dp15053
g6
V335858
p15054
stp15055
a((dp15056
g2
(lp15057
VYou do not need to release  in either of these cases: copy becomes an independent object; its creation does not increment the original's reference count
p15058
aVRetaining will increment ref count of  precisely the way you described in your post
p15059
as(dp15060
g6
V335858
p15061
stp15062
a((dp15063
g2
(lp15064
VUsing an interface rather than the class is definitely the right way to go, both for information hiding and testability reasons
p15065
aVI would even go further, and suggest using  instead of  if you can: this would give you even more flexibility as far as choosing an alternative implementation goes, while letting your users perform mostly the same operations
p15066
aVMoreover, I would probably not use an automatic assignable property for it: I'd return a read-only version, and provided separate methods for manipulating the list on my own class
p15067
aVHere is what I would do:
p15068
aVThis hides implementation of the list from users, does not let them modify the list behind your back, and does not even tell them that you're using a
p15069
aVIf you would decide to use, say, a  at some later date, you'd be able to swap it in without a fear of breaking something in the code that uses your class
p15070
as(dp15071
g6
V335858
p15072
stp15073
a((dp15074
g2
(lp15075
V uses up to four bytes per character, so the name could occupy as much as 1020 bytes all by itself
p15076
as(dp15077
g6
V335858
p15078
stp15079
a((dp15080
g2
(lp15081
VYou are missing parameter designators (colons) in front of  and
p15082
aVWithout these designators JDBC does not know that these are parameters, confusing them for column names
p15083
as(dp15084
g6
V335858
p15085
stp15086
a((dp15087
g2
(lp15088
VI think that in addition to  of the view controller that is shown modally returning , your navigation controller's  should be overridden to return  when that modal view controller is showing, and  otherwise
p15089
as(dp15090
g6
V335858
p15091
stp15092
a((dp15093
g2
(lp15094
VWhen in doubt, check the language specification
p15095
aVAccording to C# language specification, section 3
p15096
ag10442
aV1:
p15097
ag14884
ag10442
aV1 Declared accessibility
p15098
aVThe declared accessibility of a member can be one of the following:
p15099
aVPublic, which is selected by including a public modifier in the member declaration
p15100
aVThe intuitive meaning of public is \u201caccess not limited\u201d
p15101
aVProtected, which is selected by including a protected modifier in the member declaration
p15102
aVThe intuitive meaning of protected is \u201caccess limited to the containing class or types derived from the containing class\u201d
p15103
aV-Internal, which is selected by including an internal modifier in the member declaration
p15104
aVThe intuitive meaning of internal is \u201caccess limited to this program\u201d
p15105
aVProtected internal (meaning protected or internal), which is selected by including both a protected and an internal modifier in the member declaration
p15106
aVThe intuitive meaning of protected internal is \u201caccess limited to this program or types derived from the containing class\u201d
p15107
aVPrivate, which is selected by including a private modifier in the member declaration
p15108
aVThe intuitive meaning of private is \u201caccess limited to the containing type\u201d
p15109
aVAs you can see from the last section, all methods of the containing class (in your case, it's ) have access to the private field
p15110
aVand no, this is not a bad practice at all: this is precisely the purpose of private fields
p15111
as(dp15112
g6
V335858
p15113
stp15114
a((dp15115
g2
(lp15116
VYou can adapt a Java set to search for duplicates among objects of an arbitrary type: wrap your target class in a private wrapper that evaluates equality based on your criteria, and construct a set of wrappers
p15117
aVHere is a somewhat lengthy example that illustrates the technique
p15118
aVIt considers two people with the same first name to be equal, and so it detects three duplicates in the array of five objects
p15119
aVYou can play with this example on ideone [link]
p15120
as(dp15121
g6
V335858
p15122
stp15123
a((dp15124
g2
(lp15125
VYou can use this expression:
p15126
aVIt's a non-capturing word boundary designator, followed by one or more digits, followed by a hyphen, one or more digits, and finally another non-capturing word boundary
p15127
aVIf the numbers to match are always 4 digits long, this is more exact:
p15128
as(dp15129
g6
V335858
p15130
stp15131
a((dp15132
g2
(lp15133
VIn order for this to work, the library needs to be written a certain way: it should take its s by reference or by pointer, and not by value (which is, unfortunately, the default way the parameters are passed in C++)
p15134
aVIf you pass a  to a function that expects a  by value, the  gets sliced to a , and effectively becomes a  as far as the function is concerned
p15135
as(dp15136
g6
V335858
p15137
stp15138
a((dp15139
g2
(lp15140
VThe runtime does not keep any such information - it is compiled into the binary code the compiler generates as constants
p15141
aVThe compiler knows the size of each type, so it knows how to generate proper machine code for cleaning up the stack, accessing array elements, accessing fields of the struct, et cetera
p15142
aVThere is no need to keep this information around at runtime, because the binary code already contains all the appropriate instructions
p15143
as(dp15144
g6
V335858
p15145
stp15146
a((dp15147
g2
(lp15148
VIn Java this problem is often addressed with  objects: if you do not want a reference to prevent an object  from being collected, make it a : Java will null it out when  is no longer strongly referenced from anywhere else
p15149
aVFor example, you can make a  that keeps all objects that are alive, and make all other references to  weak
p15150
aVWhen an object is removed from the list and its last strong reference is gone, it becomes collectable regardless of the number of weak references to it
p15151
aVThe obvious downside is that you need to pay attention to nulls before dereferencing each weak reference
p15152
aVAt this point, Java does all reference tracking for you; all you need to do is to clean out the weak references that went null, which is much easier than searching through a large number of lists
p15153
as(dp15154
g6
V335858
p15155
stp15156
a((dp15157
g2
(lp15158
V is significant only when you  your property accessors
p15159
aVSince you are providing your own implementation for both the getter and the setter, the things you put in parentheses after  are ignored; I usually put  or  there, just to remind myself of what kind of access is available on these properties
p15160
aVYour code is correct, it will work without creating memory issues with or without ARC
p15161
as(dp15162
g6
V335858
p15163
stp15164
a((dp15165
g2
(lp15166
VCreate a hash set of the names that you have seen, add names to it as you go through the list, and keep only the items that do not have an entry in the  hash set:
p15167
aVNote that this approach ignores prenom altogether, because you wanted people without repetitions in nom only
p15168
aVThis keeps the first person with the given name
p15169
aVYou can also do it with a hash map:
p15170
as(dp15171
g6
V335858
p15172
stp15173
a((dp15174
g2
(lp15175
VYour query is expressed as efficiently as it gets
p15176
aVYou need to make sure that you have correct indexes in order for SQLite to execute the query efficiently
p15177
aVMake sure that an index exists on the  table's  column:
p15178
aVAn index on  may also come in handy:
p15179
as(dp15180
g6
V335858
p15181
stp15182
a((dp15183
g2
(lp15184
VYou need two nested loops to do it:
p15185
aVThe outer loop iterates until you get to the end of ; inner loop prints the remaining elements of  starting at the index of
p15186
aVNote that you shouldn't be re-seeding  in a loop - you do it only once before the loop
p15187
aVHere is the link to this program on ideone
p15188
as(dp15189
g6
V335858
p15190
stp15191
a((dp15192
g2
(lp15193
VYou're almost there: since you need repeated character, you shouldn't be passing , just a plain
p15194
aVAlso buffers of C strings need to be longer by one character than the string; the last element of the buffer must be the zero character
p15195
aVNote that making  a public member variable is not a good idea: users of  shouldn't be able to reassign a new buffer, so providing an accessor  and making  private is probably a good idea
p15196
as(dp15197
g6
V335858
p15198
stp15199
a((dp15200
g2
(lp15201
VWhat I don't get is why A() is called
p15202
aVDoes anyone know
p15203
aVinherits , so before constructing ,  component of  must be constructed
p15204
aVSince you are not specifying which constructor of  you wish to call, compiler chooses the default one
p15205
aVEDIT (in response to the edit of the question)
p15206
aVAs far as calling  repeatedly part is concerned, here is where your logic is wrong: you said
p15207
aVit tries to call , which doesn't exist, so it calls B(const A&) again, instead
p15208
aVbut this is not what is going on: it is not calling 's operator , it calls 's operator  that the compiler has gratuitously generated for you
p15209
aVTo verify, change the line to , and the infinite recursion will disappear
p15210
aVSo why an infinite recursion then
p15211
aVRecall that the signature of the generated assignment operator is
p15212
aVCompiler needs an instance of  to pass to the , but you are passing an instance of
p15213
aVHowever, you defined a constructor of  that takes
p15214
aVThis is sufficient for the compiler to produce the correct call by creating a temporary B, constructing it from , and calling , like this:
p15215
aVOn a side note, assignment in C++ is an lval, so your overload of the assignment operator should be returning, by reference, the object being assigned to (i
p15216
ag630
ag1783
as(dp15217
g6
V335858
p15218
stp15219
a((dp15220
g2
(lp15221
VYou can make an expression , and use regex to enumerate the matches, like this:
p15222
as(dp15223
g6
V335858
p15224
stp15225
a((dp15226
g2
(lp15227
VThere is no state-keeping constructs in the preprocessor
p15228
aVHowever, in C++11 you can use lambdas to express the individual cases, put them in an array, and use in a way similar to a  with breaks after each case:
p15229
aVNow your array indexes would get "renumbered" automatically every time you remove a case from the middle
p15230
as(dp15231
g6
V335858
p15232
stp15233
a((dp15234
g2
(lp15235
VInteger division removes the fractional part, so all you need is a simple loop:
p15236
as(dp15237
g6
V335858
p15238
stp15239
a((dp15240
g2
(lp15241
VThis is because you are setting a date column though a string, and Java's default string format for a date is not compatible with what Oracle expects
p15242
aVChange
p15243
aVto
p15244
aVto fix this problem
p15245
as(dp15246
g6
V335858
p15247
stp15248
a((dp15249
g2
(lp15250
VJava's and C++ random numbers are both pseudorandom
p15251
aVOf course the algorithms are different, so the results are different too
p15252
aVIf you would like a random number generator that is strong enough to use for cryptography, you can use : its interface is less intuitive, and it consumes more CPU, but the quality of its output is much higher than of a regular PRNG of Java,
p15253
as(dp15254
g6
V335858
p15255
stp15256
a((dp15257
g2
(lp15258
VIf you are willing to forego type safety, you can do it with a little recursion (no surprise here, right
p15259
aVand reflection
p15260
aVThe idea is to write your method in a way that it recurses down until the array has only one dimension
p15261
aVOnce you're at the single-dimension level, do the work; otherwise, call yourself recursively, and aggregate your findings from the prior levels if necessary
p15262
aVHere is a quick demo:
p15263
as(dp15264
g6
V335858
p15265
stp15266
a((dp15267
g2
(lp15268
VThis Java feature is called "anonymous class", not "an override of method on instance creation"
p15269
aVThere is no identical feature in C#
p15270
aVC# took a different route - instead of providing convenience syntax for creation of subclasses, it expanded upon its delegate features, providing anonymous delegates and lambdas
p15271
aVLambdas let you plug in pieces of code
p15272
as(dp15273
g6
V335858
p15274
stp15275
a((dp15276
g2
(lp15277
VThe following is a deifnition, not a declaration:
p15278
aVDefinitions go in cpp files; in the header you need a declaration, like this:
p15279
aVThe definition
p15280
aVshould go in the cpp file
p15281
aVOtherwise, each cpp file that includes the header with a definition will define its own , resulting in a linker error that you see
p15282
as(dp15283
g6
V335858
p15284
stp15285
a((dp15286
g2
(lp15287
VAssuming that this is a homework, here's a couple of hints:
p15288
aVThe value in the variable is not in decimal, hex, or any other system: it is in whatever system that your hardware supports (most likely, it is binary)
p15289
aVTo convert a value to hex, you need to separate out 4-bit chunks by shifting right and masking with , and indexing into an array of hexadecimal digits
p15290
as(dp15291
g6
V335858
p15292
stp15293
a((dp15294
g2
(lp15295
VSAX parsers do not guarantee to get all characters at once
p15296
aVYou may get multiple calls with chunks of characters from any given block; your code should concatenate them into a single string
p15297
aVThe parser object may send the delegate several parser:foundCharacters: messages to report the characters of an element
p15298
aVBecause string may be only part of the total character content for the current element, you should append it to the current accumulation of characters until the element changes
p15299
as(dp15300
g6
V335858
p15301
stp15302
a((dp15303
g2
(lp15304
VIn order to use instances of a class as keys in a  you need to override its  and  methods
p15305
aVOnce you do, everything should work fine
p15306
as(dp15307
g6
V335858
p15308
stp15309
a((dp15310
g2
(lp15311
VThis may not be the cleanest solution because it uses exceptions in the normal program flow, but it is certainly short, because it avoids the loop:
p15312
as(dp15313
g6
V335858
p15314
stp15315
a((dp15316
g2
(lp15317
VRecall that Objective C is a superset of C
p15318
aVWhen you declare a variable without  in C, it is an indication that the memory for that variable is allocated either in the automatic storage if it is a local variable, as part of its outer structure if it is a member of a structure, or in the static memory if it is a static or a global
p15319
aVUsing the typename or a structure tag without  in a parameter list of a function indicates passing by value
p15320
aVThe designers of the Objective C language could have taken the Java-like route, making every class instance is a pointer without the pointer syntax, but then the readers of programs in Objective C would need to know if a name represents a typedef based on a  or an  type to answer even the most basic questions about objects of that type, such as if it is implicitly passed by pointer or by value, if it is allocated as part of the owning structure or as a heap object pointed to by a pointer inside the structure, and so on
p15321
aVTo avoid this kind of confusion, designers of Objective C decided to preserve the explicit pointer syntax for  objects
p15322
as(dp15323
g6
V335858
p15324
stp15325
a((dp15326
g2
(lp15327
VYou cannot declare two properties that differ only in type
p15328
aVYou can use the  syntax if you make your entire class generic on
p15329
as(dp15330
g6
V335858
p15331
stp15332
a((dp15333
g2
(lp15334
VI do not know if it is possible to pause rendering a context to the screen, but you can render to an off-screen bitmap, and then quickly render that bitmap to the screen
p15335
aVThis will hide the process of rendering from the end users
p15336
aVHere is a link to the Stack Overflow answer explaining the process of rendering to an offscreen bitmap
p15337
as(dp15338
g6
V335858
p15339
stp15340
a((dp15341
g2
(lp15342
VYou are missing the reluctant qualifier after  - it should be  instead
p15343
as(dp15344
g6
V335858
p15345
stp15346
a((dp15347
g2
(lp15348
VI do not know much about cocos, but in Objective C you need to simply locate a reference to the object in question to access its properties
p15349
aVThere are several ways to access objects from other objects:
p15350
aVPass an instance of the object the properties of which you need to access to the initializer or another setter of the object that needs to perform the access
p15351
aVCreate a singleton instance and add a class method for accessing it
p15352
aVCreate a map () or a cache () that lets you locate instances of objects by a string key that your program assigns to them
p15353
as(dp15354
g6
V335858
p15355
stp15356
a((dp15357
g2
(lp15358
VStrings in C# are immutable reference objects
p15359
aVThis means that references to them are passed around (by value), and once a string is created, you cannot modify it
p15360
aVMethods that produce modified versions of the string (substrings, trimmed versions, etc
p15361
aVcreate modified copies of the original string
p15362
as(dp15363
g6
V335858
p15364
stp15365
a((dp15366
g2
(lp15367
V operator uses inclusive ends of the interval
p15368
aVUse specific compare operations whenever you are looking to exclude one or both ends of the interval
p15369
aVAdditionally,  is convenient when you test against a complex expression: for example, writing something like
p15370
aVis easier than repeating the  expression twice
p15371
as(dp15372
g6
V335858
p15373
stp15374
a((dp15375
g2
(lp15376
VI never used , but from my experience with other code coverage products I would guess that you do not have a test case where the loop is exited the "regular" way without hitting the  statement
p15377
as(dp15378
g6
V335858
p15379
stp15380
a((dp15381
g2
(lp15382
VNot surprisingly, you need an instance in order to access an instance variable
p15383
aVYou can make that instance a singleton if it fits your design, or make the variable you increment  rather than ivar, which will make it accessible directly from a class method
p15384
aVIf there are multiple instances that you need to access from a class method, you need some sort of a registry for your objects, such as an  that maps your objects by keys
p15385
as(dp15386
g6
V335858
p15387
stp15388
a((dp15389
g2
(lp15390
VJava  is a 16-bit type, and  is an 8-bit type
p15391
aVYou have a loop that tries to insert  shorts into a buffer that's -bytes long; it needs to be  bytes long to fit all your data
p15392
as(dp15393
g6
V335858
p15394
stp15395
a((dp15396
g2
(lp15397
VIt is a testing issue: if you put each string by itself, your regexp matches them flawlessly
p15398
aVSince you put both items in the tester's box, and your regex has  and  requiring the entire string to match, two strings together do not match
p15399
as(dp15400
g6
V335858
p15401
stp15402
a((dp15403
g2
(lp15404
VYou can use a simple regular expression:
p15405
aVis a lookbehind;  is the content of the capturing group , which is the content of the link before the replacement
p15406
as(dp15407
g6
V335858
p15408
stp15409
a((dp15410
g2
(lp15411
VBusy loop is a bad idea - it eats your batteries alive
p15412
aVPerhaps  would work better
p15413
as(dp15414
g6
V335858
p15415
stp15416
a((dp15417
g2
(lp15418
VYou are looking for a value, not for a statement, and that value is
p15419
aVYou cannot assign  to variables of primitive data types, such as  and , but you can use it with their boxed counterparts -- , , et cetera
p15420
aVWhen you do that, you should be careful to check your values for  before accessing them
p15421
aVOtherwise, an innocent-looking  may throw a null reference exception
p15422
as(dp15423
g6
V335858
p15424
stp15425
a((dp15426
g2
(lp15427
VThe code that causes the issue is not in the post, but it's very likely your constructor: if you assign the pointer  to the member , then you store the string constant inside your class
p15428
aVThen code of the  than tries to write into non-writable memory, causing access violation
p15429
aVYou can fix your constructor to avoid this problem:
p15430
as(dp15431
g6
V335858
p15432
stp15433
a((dp15434
g2
(lp15435
VUse Karnaugh Map - there is a solver available online
p15436
aVPick "three values", enter the expected results for all eight combinations, and use the expression the solver produces:
p15437
aVEDIT : You can expand this solution to do the whole byte at once, rather than doing it one bit at a time, by using the  bitwise NOT operator:
p15438
as(dp15439
g6
V335858
p15440
stp15441
a((dp15442
g2
(lp15443
VAlthough it is possible to write to a specific memory location, it does not necessarily mean that it is safe to do so
p15444
aVIn environments where you own the entire memory space (specifically, embedded systems) it is commonplace to write to a specific memory address to perform memory-mapped I/O operations
p15445
aVIn situations when the operating environment is in control of your memory space, it is unsafe to write to any memory that has not been allocated to your program
p15446
as(dp15447
g6
V335858
p15448
stp15449
a((dp15450
g2
(lp15451
VIn C++,  needs to return an :
p15452
aVC++ standard, 3
p15453
ag837
ag1340
aV2:
p15454
aVAn implementation shall not predefine the main function
p15455
aVThis function shall not be overloaded
p15456
aVIt shall have a return type of type , but otherwise its type is implementation-defined
p15457
aVIf not, what is the best way that it can output a vector
p15458
aVTo output a vector, you need to copy it to a file or an output stream:
p15459
aVThe code fragment above writes the content of  to the standard output
p15460
as(dp15461
g6
V335858
p15462
stp15463
a((dp15464
g2
(lp15465
VThe persistence strategy depends on your query requirements
p15466
aVIf you are looking for an ability to perform operations on more than one character at a time based on one or more of their attributes (e
p15467
ag303
aVgive an extra life to all three-eyed characters, look up all characters with more than five lives, etc
p15468
aVthen you should save individual attributes into their own columns
p15469
aVIf a character is always treated as a BLOB, and you have no issues tying the serialization strategy to the data in RDBMS, then use
p15470
aVHybrid solutions when you store everything as a BLOB, but also make a subset of attributes available in their separate columns, are also possible
p15471
aVIn fact, it is very common to include at least some identifying attributes to simplify searches
p15472
as(dp15473
g6
V335858
p15474
stp15475
a((dp15476
g2
(lp15477
VStack is allocated at runtime; layout of each stack frame, however, is decided at compile time, except for variable-size arrays
p15478
as(dp15479
g6
V335858
p15480
stp15481
a((dp15482
g2
(lp15483
VLet's say that you are trying to fit  items of widths  in  rows of width ; your  is fixed, your  is unknown
p15484
aVFirst, let's make a few important observations:
p15485
aVGiven a , it is easy to check if choosing that particular  makes your arrangement into exactly  rows: you can do it by going over the items one by one, calculating the running total, and using  as your cutoff point
p15486
aVThe minimum value of  is the smallest ; the maximum is the total of s
p15487
aVIncreasing  can make the number of rows required for that  go down, but it cannot make it go up; hence, the function  is monotonic
p15488
aVThese observations lead to a simple algorithm: run a binary search for the smallest  such that   by running a checker based on the running total at each step of the binary search
p15489
aVHere is a skeletal implementation in C#:
p15490
as(dp15491
g6
V335858
p15492
stp15493
a((dp15494
g2
(lp15495
VYou have code that waits for user input, interprets the commands that it reads from the user, runs them, and goes back to waiting for user input in a loop, like this pseudocode:
p15496
aVModify your function to concatenate s and run them before entering the loop:
p15497
as(dp15498
g6
V335858
p15499
stp15500
a((dp15501
g2
(lp15502
VI would use  as my base type
p15503
aVWriting to binary stream is going to be fun no matter what, because you'll need to pack four of these numbers to get a whole number of bytes into the stream (assuming that you want packing)
p15504
as(dp15505
g6
V335858
p15506
stp15507
a((dp15508
g2
(lp15509
VThere is no built-in way of dealing with closures in C++ prior to C++11, so the easiest way of addressing the issue without using libraries such as boost would be as follows: define an integer member variable called , in addition to your  and  variables
p15510
aVSet average to the right value when you create your object, and update it every time the  or  is changed
p15511
aVStore the pointer in the list, and use it to access the average
p15512
aVThis is not as good as calculating the result on the fly
p15513
aVIf you are using C++11, a better solution is available:
p15514
as(dp15515
g6
V335858
p15516
stp15517
a((dp15518
g2
(lp15519
VYou are correct:  indeed does not "move", because there is nothing to move
p15520
aVIf you need to scan a bunch of ints, you can use  - it tells you how much it read, so you can feed the next pointer back to the function on the next iteration
p15521
as(dp15522
g6
V335858
p15523
stp15524
a((dp15525
g2
(lp15526
VYou can group by the index divided by the batch size, like this:
p15527
as(dp15528
g6
V335858
p15529
stp15530
a((dp15531
g2
(lp15532
VAbsolutely
p15533
aVMake sure that you pass it by reference, not by value
p15534
as(dp15535
g6
V335858
p15536
stp15537
a((dp15538
g2
(lp15539
V gives all subclasses access to the property, even when the subclass is outside the DLL
p15540
aVThis is inconsistent with the type of the property being , because it would require a subclass from the outside to have access to the internal type
p15541
aVConsider this example: I subclass  from outside your DLL
p15542
as(dp15543
g6
V335858
p15544
stp15545
a((dp15546
g2
(lp15547
VIt is a  loop of Java, not the  loop of Pascal
p15548
aVIts expression specifies the continuation condition, not the exit condition
p15549
as(dp15550
g6
V335858
p15551
stp15552
a((dp15553
g2
(lp15554
V on strings can be faster for the same reason why a lookup in a hash set of strings may be faster than a lookup in a list of strings: you can do a lookup in  rather than in , where  is the number of strings
p15555
aVRecall that  is more efficient than a chain of  statements because it is a calculated jump: an offset in code is calculated based on the value, and then the jump to that offset is executed
p15556
aVJava can pull a similar trick on strings using the mechanism similar to that employed in hash maps and hash sets
p15557
as(dp15558
g6
V335858
p15559
stp15560
a((dp15561
g2
(lp15562
VThe compiler is right, it is indeed incompatible
p15563
aVConsider this:
p15564
aVNow inside  you do this:
p15565
aVThis should be allowed, because  extends
p15566
aVHowever, upon return from  your  would contain a , which is not good
p15567
aVTo fix this, create an array of , and populate it with pointers to
p15568
ag1971
ag1972
aVDon't forget to make  virtual, otherwise it's not going to work the way you expect
p15569
as(dp15570
g6
V335858
p15571
stp15572
a((dp15573
g2
(lp15574
VIn your case,  is not producing a , you are passing it a  as its first parameter
p15575
aVExceptions:
p15576
aVArgumentNullException -  or  is null
p15577
aVIf you would like to make  inputs valid, you could change your call as follows:
p15578
aVThis will return with no match (assuming that  does not match empty strings) when  is , rather than throwing an exception
p15579
as(dp15580
g6
V335858
p15581
stp15582
a((dp15583
g2
(lp15584
VThe constant in the  statement is
p15585
aVIt is very close to its  version, but not exactly equals it, because  is not represented exactly
p15586
aVTry the same trick with  or any other number that can be represented exactly, and you will get an
p15587
aVYou could also cast  to  to get an :
p15588
as(dp15589
g6
V335858
p15590
stp15591
a((dp15592
g2
(lp15593
VYou can try this approach:
p15594
aVYou can now use the  method, and cast the result to  for the result of your query
p15595
as(dp15596
g6
V335858
p15597
stp15598
a((dp15599
g2
(lp15600
VDoing a single query is faster than running several queries to retrieve the same amount of data, because you save on the number of network round-trips
p15601
aVIn my experience, the number of roundtrips is usually the biggest killer of performance in multi-query scenarios
p15602
aVComparing to a single query with three conditions, like this,
p15603
aVis different: most optimizers figure out that it is the same as the  query, so your performance stays the same
p15604
as(dp15605
g6
V335858
p15606
stp15607
a((dp15608
g2
(lp15609
VYou can use  to construct composite strings, like this:
p15610
as(dp15611
g6
V335858
p15612
stp15613
a((dp15614
g2
(lp15615
VThis assignment throws an exception because you are writing to an address pointed to by an uninitialized pointer
p15616
aVYou need to allocate memory for the pointer to a pointer array and then to the pointer array before you can make an assignment
p15617
aVAfter you are done with these arrays, don't forget to  them
p15618
aVIf using pointers to pointers to pointers is not an explicit requirement, consider using  instead
p15619
as(dp15620
g6
V335858
p15621
stp15622
a((dp15623
g2
(lp15624
VYou can use the generic function below to flatten a 2D array into an , put elements into a hash set, and check the terms against that hash table
p15625
as(dp15626
g6
V335858
p15627
stp15628
a((dp15629
g2
(lp15630
V provides a method that performs the conversion that you need:
p15631
as(dp15632
g6
V335858
p15633
stp15634
a((dp15635
g2
(lp15636
VThe math works out as follows:
p15637
aVwith shifts and bitwise operations:
p15638
aVIn most CPUs, even some archaic 8-bit ones, this interpretation is done in hardware: you load bytes into parts of a 16-bit register or into separate 8-bit registers that can work as a 16-bit pair, and the hardware works with the data as if it were a single 16-bit number
p15639
as(dp15640
g6
V335858
p15641
stp15642
a((dp15643
g2
(lp15644
VThe second part of your question is very close to the description of the Repository Pattern
p15645
aVThis approach can be used to address the record-by-record access issue by forcing insertions of user-specific filters
p15646
aVThis approach decouples your client business logic from the implementation of row-based security: if you later decide to change the way that you implement your record-by-record access, all you need to modify is your repository implementation
p15647
aVThe clients will not even need to recompile
p15648
aVEF defines a repository for all your business entities as a partial class
p15649
aVYou can add an interface on top of it (in a separate file), and implement the methods of your repository using EF-generated methods:
p15650
aVYou can add methods for writing that would set  on orders and issues before saving them to the database
p15651
as(dp15652
g6
V335858
p15653
stp15654
a((dp15655
g2
(lp15656
VThere is a non- object called  that is built specifically to represent s in situations where "plain"  is not acceptable
p15657
aVIf you replace your s with  object,  will take them
p15658
aVYou would need to check for  on the way out, though
p15659
aVNote that this is important only when you must differentiate between a value not being set and a value being set to
p15660
aVIf your code is such that it can interpret a missing value as , you do not need to use  at all
p15661
as(dp15662
g6
V335858
p15663
stp15664
a((dp15665
g2
(lp15666
VThe UI does not get a chance to update before your action listener is finished
p15667
aVIf you would like to change something after the delay, you should schedule it on a different thread, rather than wait inside the event handler:
p15668
as(dp15669
g6
V335858
p15670
stp15671
a((dp15672
g2
(lp15673
VThere are two common ways to store strings:
p15674
aVCharacters and Terminator
p15675
aVLength and Characters
p15676
aVWhen you use #1, you need to "sacrifice" one character to serve as the terminator; when you use #2, you do not have such limitation
p15677
aVC uses the first method of storing strings
p15678
aVIt uses character zero to serve as the terminator; the other 255 characters can be used to represent characters of the string
p15679
aVLua uses the second method of storing strings
p15680
aVAll 256 possible character values, including zeros, can be used in Lua strings
p15681
aVFor example, you can construct a three-character string from characters , , , and Lua will treat it as a three character string
p15682
aVYou can construct the same string in C, but its string-processing libraries will treat it as a single-character string:  would return ,  will write character  and stop, and so on
p15683
as(dp15684
g6
V335858
p15685
stp15686
a((dp15687
g2
(lp15688
VThis class is package private because SUN (and by extension, Oracle) believe that the methods of this platform-dependent class are likely to undergo significant change in the future, and therefore must not be accessible directly
p15689
aVAll implementations of this abstract class are in native code; Java programmers should not be able to create their own
p15690
aVThe biggest danger of using a hidden class through reflection is not the performance, but a very real possibility that its methods or even the entire class would disappear in the  next upgrade of the JDK, no matter how minor
p15691
aVNon-public APIs are, well, non-public; changing them is fair game even in a maintenance release, so you have only yourself to blame if your program stops working after what seemed like a routine JDK update
p15692
as(dp15693
g6
V335858
p15694
stp15695
a((dp15696
g2
(lp15697
VWhen arrays are passed by value, they decay to pointers
p15698
aVThe common trick to work around that is wrapping your fixed-size array in a , like this:
p15699
aVNow you can pass your wrapped arrays by value to functions, assign them, and so on
p15700
as(dp15701
g6
V335858
p15702
stp15703
a((dp15704
g2
(lp15705
VYou can allocate your data and node in a single go to save on the number of  calls
p15706
as(dp15707
g6
V335858
p15708
stp15709
a((dp15710
g2
(lp15711
VThis is not a category, it is a class extension (notice the empty parentheses)
p15712
aVYou can keep private implementation details, including private ivars, in the extension to limit the declarations in the
p15713
aVh file to the interface of your class
p15714
aVNote that you can add ivars only in the extensions, not in categories
p15715
aVOne very important consequence of this approach is that if you need ivars of types that require additional headers needed only for implementation, you can avoid including that header in the header of your interface, hiding implementation dependencies from users of your class
p15716
as(dp15717
g6
V335858
p15718
stp15719
a((dp15720
g2
(lp15721
VIf the order of strings does not matter, you can sort both arrays to find duplicates, like this:
p15722
as(dp15723
g6
V335858
p15724
stp15725
a((dp15726
g2
(lp15727
VC#-style initialization does not work in C++
p15728
aVYou need to put initializers in the initialization section of your constructor (i
p15729
ag630
aVbetween  and the opening brace  of the constructor:
p15730
aVThe way you have it now,  is not defined as , so calls of  do not compile either
p15731
as(dp15732
g6
V335858
p15733
stp15734
a((dp15735
g2
(lp15736
s(dp15737
g6
V335858
p15738
stp15739
a((dp15740
g2
(lp15741
VWhen  is 1, it means that you can use index zero
p15742
aVIndex of  is not valid
p15743
aVIn general, only indexes from zero to , inclusive, are valid
p15744
as(dp15745
g6
V335858
p15746
stp15747
a((dp15748
g2
(lp15749
VThere will be no discernable difference in the execution speed
p15750
aVThe only distinction between the code that uses temporary variables for intermediate results is that you'd be able to see intermediate values in the debugger
p15751
aVMoreover, if the values of intermediate variables are not used after the call to the target function, good chances are that the compiler will optimize these variables out, producing an identical byte code
p15752
as(dp15753
g6
V335858
p15754
stp15755
a((dp15756
g2
(lp15757
VReplacing characters in a C string is painful, because you perform manipulations at a very low level, compared to, say, C++
p15758
aVYou literally need to work out an algorithm for it
p15759
aVFirst, observe that in-place replacement is not always possible: if the substring that you are replacing is shorter than the replacement, you would need to allocate more memory
p15760
aVIt is easier to allocate the memory for the result either way, so you may proceed as follows:
p15761
aVFind the length of the string after the replacement
p15762
aVFor that, you'd need to find the beginning and the end of the comment you're replacing, and do the math
p15763
aVNext, you allocate a new chunk of memory for the result, and memcpy the source up to the replacement point into it
p15764
aVNow you copy the replacement string, and finally the ending portion of the source into the result
p15765
aVFinally, you free the buffer of the source string, and return the result
p15766
as(dp15767
g6
V335858
p15768
stp15769
a((dp15770
g2
(lp15771
VYour left side specifies one or more  items, but the right side mentions only one
p15772
aVTry adding a , like this:
p15773
as(dp15774
g6
V335858
p15775
stp15776
a((dp15777
g2
(lp15778
VYou may get a tiny performance hit for an extra level of dereferencing, but it would not be noticeable in a UI code, and you will get so much extra clarity in return that you wouldn't regret it
p15779
aVEventually you may want to externalize state keeping into a third class, and then use that state from both your hand-written and generated code, or use the Generation Gap Pattern to manage complexity introduced by the need to integrate with the generated code
p15780
as(dp15781
g6
V335858
p15782
stp15783
a((dp15784
g2
(lp15785
VThe two queries return the same set of rows, and they will have identical run time
p15786
aVThe reason  is often used is to simplify the process of producing computer-generated  clauses; optimizers of all non-toy RDBMS engines ignore this condition as
p15787
aVSearch around on Stack Overflow for explanations of how  helps with generated queries
p15788
as(dp15789
g6
V335858
p15790
stp15791
a((dp15792
g2
(lp15793
VBoth your formulas will overflow, but under different circumstances:
p15794
aVThe  part of your  formula will overflow when  and  are both close to the integer limit on the same side of the range (i
p15795
ag630
aVboth positive or both negative)
p15796
aVThe  part of your  formula will overflow when  is positive and  is negative, and both values are close to the respective ends of the representable integer values
p15797
aVThere are no "generic" rules, you do it case-by-case: look at parts of your formula, think of situations that could cause overflow, and come up with ways to avoid it
p15798
aVFor example, the  formula can be shown to avoid overflow when you average values with the same sign
p15799
aVThis is the hard way; the easy way is to use higher-capacity representations for intermediate results
p15800
aVFor example, if you use  instead of  to do intermediate calculations and copy the results back to  only when you are done, you will avoid overflow assuming that the end result fits in an
p15801
as(dp15802
g6
V335858
p15803
stp15804
a((dp15805
g2
(lp15806
VTry this:
p15807
aVEDIT : With accounts:
p15808
as(dp15809
g6
V335858
p15810
stp15811
a((dp15812
g2
(lp15813
VA call of the default constructor is performed implicitly if you do not specify which constructor to call
p15814
aVWhen you omit a constructor call, C# will call the default one for you; if there is no default constructor, your code would not compile
p15815
aV10
p15816
aV11
p15817
aV1 Constructor initializers
p15818
aVAll instance constructors (except those for class object) implicitly include an invocation of another instance constructor immediately before the constructor-body
p15819
ag9057
aVIf an instance constructor has no constructor initializer, a constructor initializer of the form  is implicitly provided
p15820
aVAccording to the C# spec, the two code snippets from your question are equivalent to each other
p15821
as(dp15822
g6
V335858
p15823
stp15824
a((dp15825
g2
(lp15826
VAssuming that  is not a field of , but rather a property representing a collection of  items related to this , try this query instead:
p15827
as(dp15828
g6
V335858
p15829
stp15830
a((dp15831
g2
(lp15832
VEveryone have correctly identified the invalid cast in your code
p15833
aVYou do not need that cast at all: Java will convert  to  implicitly:
p15834
as(dp15835
g6
V335858
p15836
stp15837
a((dp15838
g2
(lp15839
VYou see an exception because  throws  if the beginIndex is negative, or endIndex is larger than the length of this String object, or beginIndex is larger than endIndex
p15840
aVYou check for the length to be at least 2, and then do , causing an exception
p15841
aVYou can avoid the problem with  in  by switching to  API, which does not throw exceptions even when you compare your string to a longer one
p15842
as(dp15843
g6
V335858
p15844
stp15845
a((dp15846
g2
(lp15847
VAsk the user to provide a password when casting/changing their non-traceable votes, and do the same thing that you do when you store user's authentication information (salt+one-way hash) twice: once with the salt that you have stored along with the hashed password, and once more with the salt that you have randomly generated for this specific pair of
p15848
aVA request to set or change a vote should contain these pieces:
p15849
aVUser name
p15850
aVPassword hash #1 for the authentication salt #1
p15851
aVPassword hash #2 for the poll-specific salt #2
p15852
aVThe vote itself
p15853
aVYou use the user name and hash #1 to verify that you're getting a vote from a known user, and then store hash #2 along with the vote itself in the user votes table
p15854
aVThe value of hash #2 and salt #2 are used to uniquely identify the vote
p15855
aVSince password hash is one-way, only a person who knows a plain-text password could produce hash #2
p15856
aVWhen salt #1 is different from salt #2, even a person in possession of both databases would not be able to establish the connection back to a user casting the vote
p15857
as(dp15858
g6
V335858
p15859
stp15860
a((dp15861
g2
(lp15862
VI think the problem is that your nested loop increments  instead of
p15863
as(dp15864
g6
V335858
p15865
stp15866
a((dp15867
g2
(lp15868
VTry this:
p15869
as(dp15870
g6
V335858
p15871
stp15872
a((dp15873
g2
(lp15874
VA rule of thumb that I adopted from here is
p15875
aVUse composition when you can, private inheritance when you have to
p15876
aVOne specific example of the "you have to" is when the class from which you inherit has some virtual or pure virtual functions that you must implement in order to use your private base: you simply cannot do it without inheriting
p15877
aVIt does not look from your description that using inheritance is unavoidable; therefore, I think it is best to use composition
p15878
as(dp15879
g6
V335858
p15880
stp15881
a((dp15882
g2
(lp15883
V does not include the terminating , but  does:
p15884
aVA newline character makes fgets stop reading, but it is considered a valid character and therefore it is included in the string copied to str
p15885
aVSimply change your  line to this:
p15886
as(dp15887
g6
V335858
p15888
stp15889
a((dp15890
g2
(lp15891
VNo, you cannot release the array before the block, because the objects inside the array and the array itself will not be usable after the call of release, before your block gets a chance to retain it
p15892
aVYou can make your array autoreleased, in which case the release would happen after the function exits
p15893
as(dp15894
g6
V335858
p15895
stp15896
a((dp15897
g2
(lp15898
VSetting  to  ensures that the animation is removed from the image's layer on completion, not that the image layer is removed from the superlayer
p15899
aVYou need to add a delegate, track the completion event, and call  on your view
p15900
aVImplement  method on the delegate, then call
p15901
as(dp15902
g6
V335858
p15903
stp15904
a((dp15905
g2
(lp15906
VSQL's  operator provides an optional  clause:
p15907
aVYou can set the escape character to a single character of your liking, and escape metacharacters with it
p15908
as(dp15909
g6
V335858
p15910
stp15911
a((dp15912
g2
(lp15913
VYou can filter the original dictionary, and use  on the result:
p15914
as(dp15915
g6
V335858
p15916
stp15917
a((dp15918
g2
(lp15919
VFast enumeration does not usually create new objects, it is going through the existing ones
p15920
aVThat is why it is almost never the right thing to do: fast enumeration of regular containers (, , ) does not retain objects before making them available to the loop, so releasing them would be an error
p15921
aVEven inside a  method you shouldn't do it: releasing the container releases its items too, so you shouldn't be releasing them individually
p15922
as(dp15923
g6
V335858
p15924
stp15925
a((dp15926
g2
(lp15927
VYou can construct  from each of the 2^10 combinations:
p15928
as(dp15929
g6
V335858
p15930
stp15931
a((dp15932
g2
(lp15933
VIn general, the  construct should be used when you create an object assigned to the variable, either with the  operator or though a factory method
p15934
aVThe  property of  in  creates the connection only if it does not exist already; in all other cases, the property simply returns an existing one
p15935
aVIn your code, the first invocation gets a "live" connection, operates on it, and then closes it through the call of  implicitly performed by
p15936
aVAt this point, the  of  has a reference to a released object
p15937
aVThe second invocation picks up that released object, and tries to use it, triggering an error
p15938
aVTo fix this, simply replace  with assignments:
p15939
as(dp15940
g6
V335858
p15941
stp15942
a((dp15943
g2
(lp15944
VAccording to this page, Smalltalk will produce a different result:
p15945
aVin APL evaluation is strictly right to left, in Smalltalk it's strictly left to right
p15946
aVAPL will get the right result by coincidence - it will get an unexpected value on
p15947
as(dp15948
g6
V335858
p15949
stp15950
a((dp15951
g2
(lp15952
VYou can make the equality comparer a private static variable, and use that variable in your methods:
p15953
aVIn your class declaration:
p15954
aVIn your method:
p15955
aVOne advantage of this approach is that it looks symmetric; the other is that it wouldn't throw if  or  is
p15956
as(dp15957
g6
V335858
p15958
stp15959
a((dp15960
g2
(lp15961
VThere is nothing in the language to enforce this (except for having a lone visible constructor that takes all the required parameters), but you can do it idiomatically, with a variation on the builder pattern and some method chaining:
p15962
aVThe  method can ensure that all the required fields are set before calling the appropriate constructor of  with all the required parameters
p15963
as(dp15964
g6
V335858
p15965
stp15966
a((dp15967
g2
(lp15968
VYou can do it by adding your own "secondary cache" layer to your data source
p15969
aVWhen you initialize your data source, pre-create as many cells as needed, and put them into an array
p15970
aVWhen your  fails, go for that array first, and take a cell from there
p15971
aVOnce the array is exhausted, start creating new cells (if you create enough cells upfront, you shouldn't need to create new ones on the fly: dequeuing will eventually stop failing when you have enough cells rotating in and out of visibility)
p15972
as(dp15973
g6
V335858
p15974
stp15975
a((dp15976
g2
(lp15977
VIn java, you use anonymous classes implementing interfaces
p15978
aVThis is somewhat more verbose, but it works just fine:
p15979
as(dp15980
g6
V335858
p15981
stp15982
a((dp15983
g2
(lp15984
VThe usual trick is to set a separate parameter for selecting everything:
p15985
aVWhen you set the second parameter to , filtering by genre is used; when you set it to , everything is returned
p15986
aVIf you are willing to switch to using named JDBC parameters, you could rewrite with one parameter, and use  to mean "select everything":
p15987
as(dp15988
g6
V335858
p15989
stp15990
a((dp15991
g2
(lp15992
VYou have a buffer overrun
p15993
aVIf you change your  loop to stop after reading ten characters, even if space has not been reached, you should do fine
p15994
aVAdditionally, you are passing a character at  into , and have it interpreted as a pointer
p15995
aVThis will segfault no matter what
p15996
as(dp15997
g6
V335858
p15998
stp15999
a((dp16000
g2
(lp16001
VYou cannot use  to concatenate elements unless they form a valid preprocessing token together, but you can call 's constructor that takes a C string, like this:
p16002
as(dp16003
g6
V335858
p16004
stp16005
a((dp16006
g2
(lp16007
VNo, you are not reusing the  seven times: each iteration of the loop creates a new instance of  in a call to the class method , and assigns it to the variable of the same name:
p16008
aVYour code would be better off if you declared that variable inside the loop:
p16009
aVThis is a very good programming style for situations when your buttons perform very similar actions
p16010
aVFor example, calculator buttons differ only in the number that they insert
p16011
aVWhen the buttons perform actions that differ a lot (e
p16012
ag303
aVinsertion vs
p16013
aVdeletion) you are better off creating them separately, not in a loop, and servicing their clicks using separate methods
p16014
as(dp16015
g6
V335858
p16016
stp16017
a((dp16018
g2
(lp16019
VThere is nothing "weird" going on here: array variables are references to the actual arrays (also known as pointers in other languages)
p16020
aVWhen you manipulate array variables, all you do is manipulating pointers
p16021
aVWhen you assign an array variable to another one, you create an alias to the array pointed to by the variable you assign, and make the array previously pointed to by the variable being assigned eligible for garbage collection
p16022
aVBecause the assignment  makes  an alias of , filling  with data acts exactly the same as filling  with data: once the assignment is complete,  and  are merely two different names for the same thing
p16023
aVAs far as pass by value is concerned, none of it is going on in your example: the concept of passing by value applies only when you pass objects as parameters to the methods that you call
p16024
aVIn your example, variables , , , and  are not method parameters, they are local variables
p16025
aVYou do pass them by reference to methods  and  (or more precisely, you pass by value the references to your objects to  and , because in Java everything is passed by value), that is why modifications to your arrays done by  are visible upon the return from the method
p16026
as(dp16027
g6
V335858
p16028
stp16029
a((dp16030
g2
(lp16031
VWhat you are trying to implement is called double dispatch: a function that behaves as virtual with respect to two objects
p16032
aVThere are several ways to implement it, one of the more common being the use of visitor pattern
p16033
aVScott Meyers has an excellent chapter on implementing double dispatch (Item #31 in his "More Effective C++" book)
p16034
aVHe starts with the discussion of the visitor pattern, and then proceeds to a very nice implementation with RTTI
p16035
as(dp16036
g6
V335858
p16037
stp16038
a((dp16039
g2
(lp16040
VYou can try this:
p16041
as(dp16042
g6
V335858
p16043
stp16044
a((dp16045
g2
(lp16046
VPolling is imprecise by its nature
p16047
aVThe higher your target precision gets, the more wasteful the polling becomes
p16048
aVIdeally, you should consider polling only if you cannot do something with interrupts; otherwise, using an interrupt should be preferred
p16049
aVOne exception to this rule is if you would like to "throttle" something intentionally, for example, when you may get several events per second, but you would like to react to only one event per minute
p16050
aVIn such cases you often use a combination of polling and interrupts, where an interrupt sets a flag, and polling does the real job, but only when the flag is set
p16051
as(dp16052
g6
V335858
p16053
stp16054
a((dp16055
g2
(lp16056
VFrom C++ standard, 11
p16057
ag839
aV2, page 208:
p16058
aVIn the absence of an access-speci\ufb01er for a base class, public is assumed when the derived class is declared struct and private is assumed when the class is declared class
p16059
aVSo yes, you are correct: when the derived class is a , it inherits other classes as  unless you specify otherwise
p16060
as(dp16061
g6
V335858
p16062
stp16063
a((dp16064
g2
(lp16065
VYou can create a large circular buffer, copy data from the chunks into that buffer, and store pairs of  in your queue
p16066
aVSince the chunks are allocated in the same order that they are consumed, the math to check for overlaps should be relatively straightforward
p16067
aVMemory allocators have become quite good these days, so I would not be surprised if a solution based on a "plain" allocator exhibited a comparable performance
p16068
as(dp16069
g6
V335858
p16070
stp16071
a((dp16072
g2
(lp16073
V is 8K (the block size) divided by  (the size of a pointer)
p16074
aVYou need to allocate an entire -byte block of pointers to 8K blocks; you can fit  pointers into one of these
p16075
aVFurther, you can fit  pointers to blocks of pointers to block for additional  capacity, and then  of pointers to blocks of pointers to blocks of pointers to 8K blocks
p16076
aVIf you think that it goes a little like a cumulative tale, you're not alone
p16077
as(dp16078
g6
V335858
p16079
stp16080
a((dp16081
g2
(lp16082
VThe  constant represents an interval of 24 hours, not a calendar day (midnight to midnight)
p16083
aVAnything beyond a day (a week, a month, a year) is a calendar unit, not a time unit
p16084
aVThe duration of calendar units depends on the calendar in use: for example, a week can be longer or shorter by an hour on weeks when daylight savings time goes in and out of effect, leap years are longer by a day, and so on
p16085
aVThat is why including calendar units into  enumeration would not make sense
p16086
as(dp16087
g6
V335858
p16088
stp16089
a((dp16090
g2
(lp16091
VYou can use , like this:
p16092
as(dp16093
g6
V335858
p16094
stp16095
a((dp16096
g2
(lp16097
VThe keyword is "ten": this means that the simplest approach with two nested loops checking each word against each other in front of it will do just fine
p16098
aVIf the number was, say, 10000000, an approach with hash tables, heaps, or sorted arrays would be warranted
p16099
aVWith only ten words, however, you do not need to build anything complex - just the basic C string read/compare knowledge would be required
p16100
as(dp16101
g6
V335858
p16102
stp16103
a((dp16104
g2
(lp16105
VAutoreleased instances are released when the run loop gets to them (or when you drain your autorelease pool manually)
p16106
aVThis means that the method that receives the instance of  returned from your method needs to retain it before relinquishing the control to the run loop
p16107
aVOtherwise the instance will get released, rendering whatever references that you might have invalid
p16108
aVThere is a shortcut for calling  and then autoreleasing the instance: you can invoke  class method like this:
p16109
as(dp16110
g6
V335858
p16111
stp16112
a((dp16113
g2
(lp16114
VI think this may be the dreaded "modified closure" error
p16115
aVCreate a temporary copy of the  loop variable, and use it instead in your queries
p16116
aVYou should avoid using loop variables in LINQ expressions, unless you "materialize" them right away (i
p16117
ag630
aVcall , , , , etc
p16118
aVWhen you need to use the value of your loop variable, make a temporary copy
p16119
aVThe reason is that LINQ defers execution of your query, so when by the time the query gets executed the value of the loop variable has changed, your results will change unexpectedly
p16120
as(dp16121
g6
V335858
p16122
stp16123
a((dp16124
g2
(lp16125
VTwo general cases when using a separate class for your delegate is needed are
p16126
aVWhen you need to perform unrelated actions in response to the same delegate message, or
p16127
aVWhen you would like to share the logic of the delegate among multiple views or controllers
p16128
aVAn example of the first situation would be a page with two unrelated tables
p16129
aVEach  would need its own delegate, so using the controller as the delegate would require an ugly  statement in each delegate method; defining and using separate delegates is clearly preferred in this case
p16130
aVAn example of the second situation would be a group of similar pages that show DB data from tables of similar structure
p16131
aVPages themselves are sufficiently dissimilar, so you cannot reuse the controller in its entirety
p16132
aVIf you choose to put the delegate into the controller, most of the logic behind the table view's data source would be identical
p16133
aVYou can put the code into a shared delegate implementation, and have each controller instantiate that delegate with the configuration parameters specific to the table associated with this controller
p16134
aVOne note to keep in mind when using another object besides the controller as your delegate: the controller should retain / keep a strong reference to the delegate, since the view will only keep a weak / assign reference to it
p16135
aVSee property "assign" and "retain" for delegate for more information on this
p16136
as(dp16137
g6
V335858
p16138
stp16139
a((dp16140
g2
(lp16141
VThe instance variable  produced by  is private to
p16142
aVYou need to make it protected in order for  to be able to access it
p16143
aVAdd an ivar declaration for  in the  section of , like this:
p16144
aVNow synthesize the accessors as usual, and your variable will become accessible to your subclass
p16145
as(dp16146
g6
V335858
p16147
stp16148
a((dp16149
g2
(lp16150
VIf you do not have liberty to modify the source code that does printing, you can use  on  to redirect to a file:
p16151
aVThis borders on a hack, however, because command-line redirects will stop working as expected
p16152
aVIf you do have access to the code that does printing, using  is preferred
p16153
aVYou can also switch your  temporarily for a function call, and then put it back:
p16154
as(dp16155
g6
V335858
p16156
stp16157
a((dp16158
g2
(lp16159
VYou should familiarize yourself with parameterized queries, and start using them to protect your system from SQL Injection attacks
p16160
aVAs an added benefit, this approach eliminates all possible data formatting issues, and speeds up your queries by letting SQL Server cache query plans
p16161
aVBut the main benefit is thwarting the attempts of "Bobby Tables" of the world to gain unauthorized access to your system
p16162
as(dp16163
g6
V335858
p16164
stp16165
a((dp16166
g2
(lp16167
VIt is often desirable to treat objects of concrete class polymorphically to avoid creating dependencies on specific types where you can avoid them
p16168
aVFor example, if you are creating a  with the intention of drawing it, and  is a method of a , then it is better to declare  as a shape, in case you decide to replace it with a square later on
p16169
aVOn the other hand, if your intention is to do something specific to , say, to set its radius, then you need to declare  as , because  may not be available on the
p16170
as(dp16171
g6
V335858
p16172
stp16173
a((dp16174
g2
(lp16175
V takes , so you need to call  on each element of your array:
p16176
as(dp16177
g6
V335858
p16178
stp16179
a((dp16180
g2
(lp16181
VThere are no sequence points in your expression, so the time when the side effects (i
p16182
ag630
aVthe results of incrementing ) become visible is undefined
p16183
aVIn plain words, the compiler is free to store the result of  back into the  at any time before the evaluation of the expression is completed
p16184
aVThis is the danger of making macros that take expressions with side effects
p16185
aVYou would be much better off with an equivalent function
p16186
as(dp16187
g6
V335858
p16188
stp16189
a((dp16190
g2
(lp16191
VYou should not show any information to your end users that they cannot understand, which includes all of the stack trace in its entirety
p16192
aVThe error you should show when you catch an exception like that should read something like this, in the language of your end-users:
p16193
aVOur program has experienced temporary difficulties
p16194
aVPlease call technical support line for assistance
p16195
aVEnd users couldn't care less about your program's inner organization, databases, stacks, et cetera
p16196
aVAll they know is that something that they thought should have work just failed, so they are looking for assistance
p16197
aVStack traces are for error logs: you can save them for yourself, or e-mail them to technical support, but you do not want to show them to the end users
p16198
as(dp16199
g6
V335858
p16200
stp16201
a((dp16202
g2
(lp16203
VYou can do it using a surrogate instead of an  in your map, like this:
p16204
as(dp16205
g6
V335858
p16206
stp16207
a((dp16208
g2
(lp16209
VThe most obvious case of circular reference is self-reference: you need it for linked lists, trees, and lots of other recursive structures
p16210
aVCircular references are often implicit within a hierarchy of relared classes, such as UI elements with arbitrary nesting, or expression trees
p16211
aVFinally, a common case of circular referencing is bidirectional parent-child relationship: a parent (e
p16212
ag303
aVa UI panel) holds a reference to an array of its children, and each child (e
p16213
ag303
aVbuttons, tables, etc
p16214
aVholds a references to the parent
p16215
aVThe parent needs to send motifications to its children to tell them that it became enabled, disabled, visible, or invisible; a child may notify the parent of the need to resize, change visual state, etc
p16216
aVThis last example is probably similar to your Creature-CreatureAI pair: they are separate because their concerns are dissimilar, but they have references to each other because they need to cooperate on different tasks
p16217
as(dp16218
g6
V335858
p16219
stp16220
a((dp16221
g2
(lp16222
VYou can call , pass an eight-byte buffer, and test the results that you get back
p16223
aVPut an rtf file into , get the first eight bytes, print them out, and put these eighht constants in an array of bytes in your program
p16224
aVThen compare that array to the eight bytes the  returns using
p16225
as(dp16226
g6
V335858
p16227
stp16228
a((dp16229
g2
(lp16230
VNo, there is no reliable and portable way to tell a pointer to local from a pointer to a heap object
p16231
aVThere is no way to declaratively prevent this, either
p16232
aVThere are hacks dependent on the memory layout of your particular system that work at runtime by invoking unspecified behavior (see this answer for an example), but you are on your own if you decide to give them a try
p16233
as(dp16234
g6
V335858
p16235
stp16236
a((dp16237
g2
(lp16238
VJava API for primitives follow a common pattern: a wrapper type for most primitives  define  returning an instance of the primitive type:
p16239
as(dp16240
g6
V335858
p16241
stp16242
a((dp16243
g2
(lp16244
VBlocking calls make the thread wait for the operation to complete
p16245
aVUse them when your thread cannot continue before the operation has completed, for example due to the data dependency on the input being received
p16246
aVNon-blocking calls return as soon as the information is buffered for transmission, or the read operation is initiated
p16247
aVUse them when there are no data dependencies
p16248
aVIn general, blocking always means "blocks the current thread", not "block all threads in my process
p16249
as(dp16250
g6
V335858
p16251
stp16252
a((dp16253
g2
(lp16254
VUnlike the API returning , a version with callback can return right away, and perform the callback later
p16255
aVThis may be important when the value to return is not immediately available, and getting it entails a considerable delay
p16256
aVFor example, and API that requests the data from a web service may take considerable time
p16257
aVWhen the result data is not required to proceed, you could initiate a call, and provide an asynchronous callback
p16258
aVThis way the caller would be able to proceed right away, and process notifications when they become available
p16259
aVConsider an API that takes a URL of an image, and returns an in-memory representation of the image
p16260
aVIf your API is
p16261
aVand your users need to pull ten images, they would either need to wait for each image to finish loading before requesting the next one, or start multiple threads explicitly
p16262
aVOn the other hand, if your API is
p16263
aVthen the users of your API would initiate all ten requests at the same time, and display the images as they become available asynchronously
p16264
aVThis approach greatly simplifies the thread programming the users are required to do
p16265
as(dp16266
g6
V335858
p16267
stp16268
a((dp16269
g2
(lp16270
VIf you know how many lists there are, you can do it with nested loops:
p16271
aVIf you do not know how many lists there are, you need a recursive solution:
p16272
as(dp16273
g6
V335858
p16274
stp16275
a((dp16276
g2
(lp16277
VThis is because  does not deliver all characters at once
p16278
aVYou need to concatenate all strings that you get between the callbacks of the  and  that you get for the  tag
p16279
aVIn the code below,  is an  ivar of your parser delegate
p16280
as(dp16281
g6
V335858
p16282
stp16283
a((dp16284
g2
(lp16285
VAlthough the number of rows is the same, the additional columns need to be transferred to the client, consuming network bandwidth
p16286
aVThe additional time is needed for the same reason why downloading a file seven times as large takes longer
p16287
aVThere may also be a need to read blocks from disk that might not otherwise be required, and in some cases even an inability to complete the query by reading only from an index
p16288
aVThat's why you are encouraged to always specify your select list explicitly
p16289
as(dp16290
g6
V335858
p16291
stp16292
a((dp16293
g2
(lp16294
VYou put a method outside all classes when the method's meaning is independent of a class
p16295
aVStatic classes in other languages (Java, C#) are a way to compensate for inability to put methods outside classes
p16296
aVSince C++ provides this ability out of the box through namespaces, the use of an additional "static class" would be counterintuitive to the readers of your code
p16297
as(dp16298
g6
V335858
p16299
stp16300
a((dp16301
g2
(lp16302
VThe
p16303
aVidentifier  type definition
p16304
aVblock after an identifier denotes a type constructed from a generic type definition
p16305
aVThis This definition is recursive: you can have generic types constructed from other generic types: in the same way that you can have arrays of arrays, you can construct lists of lists, lists of dictionaries, and so on
p16306
aVIn addition, you can build generic functions using similar constructs, except instead of the type or the interface name you put a name of a generic function
p16307
aVYou can build your own generic type and function definitions, and access them both directly or through reflection
p16308
aVThe concept is very powerful, because it expands strong typing to types built from other types
p16309
as(dp16310
g6
V335858
p16311
stp16312
a((dp16313
g2
(lp16314
VIs there any specific functionality inside C# which can help me
p16315
aVYes, there is
p16316
aVYou can build a LINQ Expression Tree from the data in your table, compile it dynamically into a function object, and execute the resultant lambda against your target object
p16317
aVThe library takes a litte time of getting used to, but the constructs that you get a very powerful and extremely fast, so the payback on spending the time to learn it is truly enormous
p16318
as(dp16319
g6
V335858
p16320
stp16321
a((dp16322
g2
(lp16323
VYou are passing uninitialized pointers to , storing the data in random locations
p16324
aVThis is undefined behavior
p16325
aVYou should allocate memory for your data, and use  with limits to read strings
p16326
as(dp16327
g6
V335858
p16328
stp16329
a((dp16330
g2
(lp16331
VI think you are missing single quotes in the condition expression:
p16332
aVshould be
p16333
aVSince the string  is not quoted, SQLite tries to interpret it as an identifier of a column name
p16334
as(dp16335
g6
V335858
p16336
stp16337
a((dp16338
g2
(lp16339
VThe problem is that you are trying to parse  with the lexer, i
p16340
ag630
aVyou are trying to make it a single token
p16341
aVIn reality, it looks like you want a multi-token production, since you'd like whitespace to be re-directed to hidden channel through
p16342
aVYou should change  from a lexer rule to a parser rule by changing its initial letter (or better yet, the entire name) to lower case
p16343
as(dp16344
g6
V335858
p16345
stp16346
a((dp16347
g2
(lp16348
VWildcards in  expressions can cause changes in query execution that make the RDBMS use full-table scans instead of using indexes
p16349
aVThis may slow down the query when there is a lot of data
p16350
aVI would recommend checking user's input for presence of at least a few non-wildcard characters in front of the first asterisk
p16351
aVAlso note that if you convert  to , and use , you'd need to take care of  as well, otherwise it would match any single character, not just the underscore
p16352
as(dp16353
g6
V335858
p16354
stp16355
a((dp16356
g2
(lp16357
VThe differences between  and  have to do with member visibility: the most notable difference is that 's members are public by default, and also that 's inheritance is public by default;  members and  inheritance are both private by default
p16358
aVOther than that, there is no difference: you can always write code with  that produces code equivalent to code written with , and vice versa
p16359
as(dp16360
g6
V335858
p16361
stp16362
a((dp16363
g2
(lp16364
VYou can use this test:
p16365
as(dp16366
g6
V335858
p16367
stp16368
a((dp16369
g2
(lp16370
VThe exception is thrown by your own code
p16371
aVYou can make your code more flexible to accept hex strings that have an odd number of digits:
p16372
aVNow you can remove the odd/even check, and your code will be alright
p16373
as(dp16374
g6
V335858
p16375
stp16376
a((dp16377
g2
(lp16378
VYou need to scale the random number to be in the range of a specific year, and add the year's beginning as the offset
p16379
aVThe number of milliseconds in a year changes from one year to another (leap years have an extra day, certain years have leap minutes, and so on), so you can determine the range before scaling as follows:
p16380
as(dp16381
g6
V335858
p16382
stp16383
a((dp16384
g2
(lp16385
VA sealed class is not intended to be used as a base class, while an unsealed class is
p16386
aVHence lies the distinction: an unsealed class needs to provide a way for its derived classes to implement  of their own, while a sealed class is free of this responsibility, because it cannot be extended
p16387
as(dp16388
g6
V335858
p16389
stp16390
a((dp16391
g2
(lp16392
VThere is no semantic difference between making a top-level class  and making an inner class : it tells the compiler that you cannot inherit from the class
p16393
aVMarking classes  is sometimes done to let the compiler skip a virtual table lookup, but this is often regarded as premature micro-optimization
p16394
as(dp16395
g6
V335858
p16396
stp16397
a((dp16398
g2
(lp16399
VSince you are using an array list of arrays of strings, the  method is not going to work: it uses  method to check for equality, but the implementation of  in C# arrays does not pay attention to the equality of array elements
p16400
aVHere is a link to the question discussing the problem of checking array equality in C#
p16401
as(dp16402
g6
V335858
p16403
stp16404
a((dp16405
g2
(lp16406
VChanging a line in a text file in place is possible only when the changed text has an identical length byte-for-byte with the original
p16407
aVWhen this cannot be guaranteed (and it certainly sounds like this is the case in your assignment) one common way that works particularly well when the files are small is to create a temporary file, write the new content into it, then swap the files, and delete the original
p16408
aVOne advantage of this method is that your file does not get corrupted if the write operation is stopped in the middle: the temporary file becomes corrupted, while the original stays intact
p16409
as(dp16410
g6
V335858
p16411
stp16412
a((dp16413
g2
(lp16414
VYou can do it on any object, not necessarily a  one using reflection
p16415
aVWhen you use , you can use any identifier for a method name, and the compiler will not complain:
p16416
as(dp16417
g6
V335858
p16418
stp16419
a((dp16420
g2
(lp16421
V is implied in the structure of  with missing :
p16422
aVdoes not make sense, because one variable cannot be equal to two different integer numbers at the same time
p16423
as(dp16424
g6
V335858
p16425
stp16426
a((dp16427
g2
(lp16428
VThis is a trick question
p16429
aVThe results of binary search on an unsorted array are undefined, as per documentation:
p16430
aVThe array must be sorted (as by the sort method, above) prior to making this call
p16431
aVIf it is not sorted, the results are undefined
p16432
aVThis means in particular that any number, including seven, is fair game
p16433
aVThe results on a sorted one are well-defined: you'll get a
p16434
aVAs if by magic, there are only two pairs that end in  on the list of answers, so  and  is the choice the examiners expect you to make
p16435
as(dp16436
g6
V335858
p16437
stp16438
a((dp16439
g2
(lp16440
VUse
p16441
aVInherit your handler from , and override  to concatenate string parts coming from the parser (you can use  for that)
p16442
aVClear the builder in  ; add the finished string to your list in
p16443
aVHere is a link to a quick tutorial on parsing XML in Java using SAX parser
p16444
as(dp16445
g6
V335858
p16446
stp16447
a((dp16448
g2
(lp16449
VSince hash codes do not need to be unique, there would be no problem if converting addresses of two objects in 64-bit space resulted in hash code collision: there is no requirement for hash codes of different objects to be different - only a requirement of hash codes of equal objects to be the same
p16450
aVIn Real LifeTM the default  values do look suspiciously similar to the object's address
p16451
aVHowever, this information is of no use to Java programmers: even if hash codes were equal to object's addresses, Java does not provide a mechanism to exploit this knowledge, rendering it a useless implementation detail
p16452
as(dp16453
g6
V335858
p16454
stp16455
a((dp16456
g2
(lp16457
VYou can print to a  using the output string stream, and then replace  with
p16458
aVThis snippet produces
p16459
as(dp16460
g6
V335858
p16461
stp16462
a((dp16463
g2
(lp16464
VThis is because you are passing the other  by value
p16465
aVThe balance gets changed OK, but on a different instance of the account, meaning that the copy gets modified, while the original stays intact
p16466
aVChange your code to passing  by reference to make it work
p16467
as(dp16468
g6
V335858
p16469
stp16470
a((dp16471
g2
(lp16472
VUse  to write serializable objects to streams in binary format:
p16473
as(dp16474
g6
V335858
p16475
stp16476
a((dp16477
g2
(lp16478
VYou should not define global variables in
p16479
aVh files
p16480
aVYou should declare them in
p16481
aVh, like this:
p16482
aVand then define them in one cpp file, like this:
p16483
aVOtherwise, every cpp file that includes your
p16484
aVh file will declare the  variable, resulting in a name collision
p16485
as(dp16486
g6
V335858
p16487
stp16488
a((dp16489
g2
(lp16490
VYou need synchronization inside  only if you initialize your singleton lazily
p16491
aVIf you could create an instance before the threads are started, you can drop synchronization in the getter, because the reference becomes immutable
p16492
aVOf course if the singleton object itself is mutable, you would need to synchronize its methods which access information that can be changed concurrently
p16493
as(dp16494
g6
V335858
p16495
stp16496
a((dp16497
g2
(lp16498
VGenerally, SAX is more memory-efficient than DOM, because the entire document does not need to be loaded into memory for processing
p16499
aVThe answer, however, depends on the specifics of your "Component B modifies the initial response XML" requirements
p16500
aVIf each change is local to its own XML sub-tree (i
p16501
ag630
aVyou may need data from all nodes leading to the root of the tree, but not siblings), SAX will work better
p16502
aVIf the changes require referencing siblings to produce the results, DOM will work better, because it would let you avoid constructing your own data structure for storing the siblings
p16503
as(dp16504
g6
V335858
p16505
stp16506
a((dp16507
g2
(lp16508
VReading a single file at multiple positions concurrently wouldn't let you go any faster (but it could slow you down considerably)
p16509
aVInstead of reading the file from multiple threads, read the file from a single thread, and parallelize the processing of these lines
p16510
aVA singe thread should read your CSV line-by-line, and put each line in a queue
p16511
aVMultiple working threads should then take the next line from the queue, parse it, convert to a request, and process the request concurrently as needed
p16512
aVThe splitting of the work would then be done by a single thread, ensuring that there are no missing lines or overlaps
p16513
as(dp16514
g6
V335858
p16515
stp16516
a((dp16517
g2
(lp16518
VThis has nothing to do with the macro: the problem would persist even if you expand this macro by hand
p16519
aVThe reason why this is failing is that initializer list in an assignment must be composed of constant expressions, so  is not allowed
p16520
aVIf you are using C99, change your macro to use a compound literal, like this:
p16521
aVThis will let you use the macro in assignments as well as in initializers
p16522
as(dp16523
g6
V335858
p16524
stp16525
a((dp16526
g2
(lp16527
VHere is what's going on: since you macro where the "stringization" operator  is applied is second-level, the sequence of operations works as follows:
p16528
aVPreprocessor identifies the arguments of  and performs argument substitution as per C 6
p16529
aV10
p16530
ag14884
ag1340
aVAt this point, the replacement looks like , because  is expanded as
p16531
aVPreprocessor continues expanding the macro chain with ; at this point, the fact that the macro has been called with  is lost: as far as the preprocessor is concerned, the expression passed to  is
p16532
aVA key to solving this problem is in this paragraph from the standard:
p16533
aVA parameter in the replacement list, unless preceded by a # or ## preprocessing token or followed by a ## preprocessing token (see below), is replaced by the corresponding argument after all macros contained therein have been expanded
p16534
aVThis means that if you would like to capture the exact expression, you need to do it in the very first level of the macro expansion
p16535
as(dp16536
g6
V335858
p16537
stp16538
a((dp16539
g2
(lp16540
VAssuming that  is a subclass of , you are looking at a cast operator that converts a variable of the type  to a variable of type
p16541
aVYou can write the same fragment more succinctly without a temporary variable:
p16542
aVThis operation checks for the  to be of the correct type before coercing its type to subclass, and cause  on failures
p16543
aVIt is a good idea to minimize the number of such casts in your program, because their validity cannot be reliably checked at compile time
p16544
as(dp16545
g6
V335858
p16546
stp16547
a((dp16548
g2
(lp16549
VThe concept of a class inheriting from a base class is independent of a class implementing an interface
p16550
aVIn the first case, the inheriting class acquires both the interface and the implementation of its base "for free"; in the second case, a class is checked to comply with the interface that it is declared to implement
p16551
aVA subclass inherits the interfaces that its base implements, but it is also free to implement additional interfaces
p16552
aVThis is very convenient when classes in a single hierarchy must assume multiple roles, depending on their place in the hierarchy
p16553
as(dp16554
g6
V335858
p16555
stp16556
a((dp16557
g2
(lp16558
VSince the number of lists in the outer list (i
p16559
ag630
aVthe list of lists) is not known until the runtime, you cannot know the number of the loops upfront
p16560
aVIn situations like this, you need a recursive solution:
p16561
aVHere is how to call it:
p16562
as(dp16563
g6
V335858
p16564
stp16565
a((dp16566
g2
(lp16567
VThere are several mistakes in your Java implementation of the diagrams:
p16568
aVspecifies  visibility, while your methods are
p16569
aVThe diagram does not specify what's in the body of each method; both bodies need to be empty
p16570
aVThe diagram does not specify how the variables  and  are initialized, so  and  need to be omitted
p16571
as(dp16572
g6
V335858
p16573
stp16574
a((dp16575
g2
(lp16576
V is an integer, while  is a string that may (or may not) be representing an integer
p16577
aVYou can compare only items of the same type, so either compare a string-to-string or an integer-to-integer:
p16578
aVor
p16579
aVThe second way will fall apart when you try comparing to zero ( returns zero to indicate an error)
p16580
as(dp16581
g6
V335858
p16582
stp16583
a((dp16584
g2
(lp16585
VThe biggest problem that I see with rolling your own  is that template specifications that recognize  will not recognize , going the default route
p16586
aVSpecifically,  uses a different code base to save space by packing bits in a representation of the vector; using  will result in a representation that is roughly eight times larger
p16587
as(dp16588
g6
V335858
p16589
stp16590
a((dp16591
g2
(lp16592
VThere is a C++ - specific solution that uses conversion operator to build a single-use guard:
p16593
aVHere is how you use the guard:
p16594
aVThis code prints , skipping
p16595
aVLack of conversion operators prevents you from replicating this solution in Java
p16596
as(dp16597
g6
V335858
p16598
stp16599
a((dp16600
g2
(lp16601
VYou can define your own interface, and use anonymous implementations to port the code:
p16602
aVIn order for the implementation to work, , , , , and  variables must be either instance/class variables, or be  local variables
p16603
as(dp16604
g6
V335858
p16605
stp16606
a((dp16607
g2
(lp16608
VA common C++ solution to this is the so-called virtual constructor idiom: you define a virtual function called  in the base class , and then override it in  to return a new instance of  and in  to return a new instance of
p16609
aVIf you need a blank instance instead of a clone, you could add a  function that uses the default constructor
p16610
as(dp16611
g6
V335858
p16612
stp16613
a((dp16614
g2
(lp16615
VOne way to hide the credentials would be making  a static function returning , like this:
p16616
ag8433
aVYou could then use it like this:
p16617
as(dp16618
g6
V335858
p16619
stp16620
a((dp16621
g2
(lp16622
VA typical trick one could use to model pointers to pointers in Java is using arrays: a reference to the array itself serves as the "pointer", while the array element serves as the item pointed to
p16623
aVYou can nest these as much as you'd like, but the code does not look nearly as nice as it does in C/C++
p16624
aVRather than porting C/C++ idioms into Java, you should build a mutable class that lets you change the item inside it
p16625
aVThis class would serve as a "pointer" to give you the functionality that you are looking for, and it would also add readability to your Java code
p16626
aVGenerics greatly simplify your task, requiring only one implementation that you could reuse
p16627
as(dp16628
g6
V335858
p16629
stp16630
a((dp16631
g2
(lp16632
VAccording to this thread on springsource, the following should work:
p16633
as(dp16634
g6
V335858
p16635
stp16636
a((dp16637
g2
(lp16638
VYou can avoid casting altogether by replacing the dot-syntax of accessing properties with the regular method invocation syntax:
p16639
as(dp16640
g6
V335858
p16641
stp16642
a((dp16643
g2
(lp16644
VPercentage is a formatting artifact in Excel
p16645
aVThe actual number is always a decimal fraction ( in your case)
p16646
aVPercentage is only a way to display your number on the worksheet
p16647
aVIf you know that a column represents percentage, you should multiply it by
p16648
as(dp16649
g6
V335858
p16650
stp16651
a((dp16652
g2
(lp16653
VYou are on the right path to avoiding Bobby Tables, but your understanding of  parameters is incomplete
p16654
aVNamed parameters behave like variables in a programming language: first, you use them in your SQL command, and then you supply their value in your VB
p16655
aVNET or C# program, like this:
p16656
aVNote how the text of your command became self-contained: it no longer depends on the value of the text from the text box, so the users cannot break your SQL by inserting their own command
p16657
aVbecame a name of the variable that stands for the value in the text of the command; the call to  supplies the value
p16658
aVAfter that, your  is ready to go
p16659
as(dp16660
g6
V335858
p16661
stp16662
a((dp16663
g2
(lp16664
VYou should process  or , depending on whether you'd like a reload to happen before or after thew view shows up on the screen
p16665
aVis called only once, when the view is loaded
p16666
as(dp16667
g6
V335858
p16668
stp16669
a((dp16670
g2
(lp16671
VIf I remove one of the  objects from my school (say by making its , or by changing my property to point at a new object), will its  be properly released
p16672
aVYes, it will be released as long as there are no other strong references to it
p16673
aVWhat do I have to do to make sure that this is the case
p16674
aVNothing in particular: ARC will decrement object's reference count when you set the reference to that object to , see that the object is no longer referenced, and proceed to deleting it
p16675
aVIt is smart enough to deal with the items referenced from the object being deleted, recursively, so you are not going to leak any memory
p16676
aVOne thing you have to worry about is circular references: if your  has a strong back-reference to , either make that reference , or clear it out at the same time as you set your reference of  to  (the second option is error-prone, and therefore is not recommended)
p16677
as(dp16678
g6
V335858
p16679
stp16680
a((dp16681
g2
(lp16682
VWhen an operation has side effects, C++ relies on sequence points rule to decide when side effects (such as increments, combined assignments, etc
p16683
aVhave to take effect
p16684
aVLogical / ( and ) operators, ternary  question mark operators, and commas create sequence points; , ,  and so on do not
p16685
aVIn contrast, Java completes side effects before proceeding with further evaluation
p16686
aVWhen you use an expression with side effects multiple times in the absence of sequence points, the resulting behavior is undefined in C++
p16687
aVAny result is possible, including one that does not make logical sense
p16688
as(dp16689
g6
V335858
p16690
stp16691
a((dp16692
g2
(lp16693
V is neither a static nor an instance variable, it is a local variable
p16694
aVIt absolutely does not matter whether the method in which it is declared is static or not: the variable's scope starts at the point of its declaration, and ends at the closing curly brace  of the scope in which it is declared
p16695
aVEach executing thread that goes through  gets its own copy of , which is invisible anywhere outside the variable's scope
p16696
as(dp16697
g6
V335858
p16698
stp16699
a((dp16700
g2
(lp16701
VThere are multiple issues with your program:
p16702
aVfits a single character
p16703
aVIt is not big enough to store book's title
p16704
aVYou pass addresses to , but you pass values to  (i
p16705
ag630
aVno  on 's parameters, except possibly to 's parameters)
p16706
aVYou do not need to  your input streams - it has no effect
p16707
aVI think you should change  to  (or whatever other max size you'd prefer), and  for
p16708
aVNote how the ampersand  is missing from : this is because arrays decay to pointers when passed to functions in C
p16709
as(dp16710
g6
V335858
p16711
stp16712
a((dp16713
g2
(lp16714
VThe  mutex is used to protect the state of the  structure itself, not the state of whatever the reader/writer lock may be protecting in your target program
p16715
aVThis mutex is held only during the time the lock is acquired or released
p16716
aVIt is entered into just briefly, to avoid corrupting the state that is needed for "bookkeeping" of the reader/writer lock itself
p16717
aVIn contrast, the reader/writer lock may be held for an extended period of time by the callers performing the actual reads and writes on the structure the lock protects
p16718
as(dp16719
g6
V335858
p16720
stp16721
a((dp16722
g2
(lp16723
VIf you added  to the first expression, it would be on , and thus added to the SQL
p16724
aVBut since you converted  to ,  is done in memory:  has an identically-named  extension method, and as far as compiler knows,  is , not , so the in-memory version gets called
p16725
as(dp16726
g6
V335858
p16727
stp16728
a((dp16729
g2
(lp16730
VYou should set it in the designated initializer
p16731
aVFor example, if your designated initializer is parameterless, you can do it like this:
p16732
as(dp16733
g6
V335858
p16734
stp16735
a((dp16736
g2
(lp16737
VIn general, if a library  depends on symbols defined in library , then  should appear ahead of  in the list of libraries supplied to
p16738
aVIt looks like you can work around this by supplying the names of your object files twice: this way, each pair of  will also appear in the list as , and will link regardless of the intra-object dependencies
p16739
aVSometimes you have cyclic references; then you must put an object on the 's list twice
p16740
aVTypically, you just play around with the ordering until you get it right
p16741
aVHowever, it does not look like it's possible with your 32-K command line
p16742
aVI read here that  and  can assist you in determining the right order automatically, but I cannot say if it's right or wrong, because I never used these tools
p16743
as(dp16744
g6
V335858
p16745
stp16746
a((dp16747
g2
(lp16748
VYou can use 's little known but very powerful regex feature, together with its ability to skip entries based on regular expressions:
p16749
aVOpen the file, and skip the first 11 lines in a loop
p16750
aVThen read the score, like this:
p16751
aVThis will skip everything in the file up to the opening  bracket, then skip the bracket itself, and read an integer entry
p16752
aVNote that  in the format string designates an entry to be skipped by
p16753
aVHere is a snippet at ideone
p16754
aVEDIT -- In response to the additional question from your edit: you cannot assign arrays like that, you should use  instead:
p16755
as(dp16756
g6
V335858
p16757
stp16758
a((dp16759
g2
(lp16760
VRegex-based solutions will not work, because there are too many very primitive cases that regexp cannot handle even in theory
p16761
aVAt the very least, you need a fully functional C parser
p16762
aVHowever, even a parser would not be sufficient, because you would need to be able to tell if an expression is part of an assignment or if it is used in an initializer
p16763
aVFortunately, there are several code analysis tools built specifically for checking compliance of CC+ code with the coding standards of your company
p16764
aVWe used one of them at our company many years ago to produce nightly compliance reports, and e-mail reminders to every team whose code is not in compliance
p16765
as(dp16766
g6
V335858
p16767
stp16768
a((dp16769
g2
(lp16770
VYour code does not call  in the loop like it should: the read is done once, and then the program either exists right away if the file is empty, or loops indefinitely
p16771
aVYou should move the call of  inside the  loop
p16772
aVOne typical way of coding it is placing the assignment inside the loop header, like this:
p16773
as(dp16774
g6
V335858
p16775
stp16776
a((dp16777
g2
(lp16778
VI stored them as strings in an header file which I included in every project's file but someone discouraged from doing this
p16779
aVAre they right
p16780
aVYes, they are absolutely right: "baking in" installation-specific strings with paths in a file system into a compiled code is not a good decision, because you must recompile simply to change locations of some key files
p16781
aVThis limits the flexibility of other members of your team to run your tests, and may prevent your tests from being ran automatically in an automated testing environment
p16782
aVA better solution would use a plain text configuration file with the locations of the key directories, and functions that read that file and produce correct locations at run-time
p16783
aVAlternatively, you could provide locations of key directories as command-line parameters to your program
p16784
aVThis way, users who run your program would be able to set correct locations without recompiling
p16785
as(dp16786
g6
V335858
p16787
stp16788
a((dp16789
g2
(lp16790
VAs long as you are not planning to instantiate components given their component type, and assuming that  has one or more  function, using RTTI should be sufficient for your purposes
p16791
aVYou can use  in place of , and replace the  with
p16792
aVOne thing I'm not certain about is how  would know what exact bits to return: the code instantiates  with no parameters when one is not found in the map, yet it's assumed that different instances would return different patterns of set and unset bits
p16793
aVI assume this is because your hash map is pre-populated for known component types, though
p16794
as(dp16795
g6
V335858
p16796
stp16797
a((dp16798
g2
(lp16799
VThe only difference between  and  is that  performs a range check, and  does not
p16800
aVIf you have checked the range already or have constructed your index in such a way that it cannot get out of range, and need to access an item repeatedly, you could save a few CPU cycles by opting for  instead of an
p16801
aVExample of a single check and multiple accesses:
p16802
aVExample of a case when the index is constructed to be inside limits:
p16803
as(dp16804
g6
V335858
p16805
stp16806
a((dp16807
g2
(lp16808
VHere is my shortest attempt
p16809
aVIt took about 40 minutes to type up, you can play with it on ideone (link)
p16810
aVThe code is very straightforward, assuming that you have at least a cursory familiarity with the basic recursive descent parsing technique
p16811
as(dp16812
g6
V335858
p16813
stp16814
a((dp16815
g2
(lp16816
VHere is a straightforward implementation (also on ideone):
p16817
aVThe key in the implementation is the  function, that performs the right turn given a pair of
p16818
aVThe rest is straightforward arithmetic
p16819
as(dp16820
g6
V335858
p16821
stp16822
a((dp16823
g2
(lp16824
VThere is an  container available starting with C++11
p16825
aVMany compilers that are not yet fully C++11 compatible support it as well
p16826
aVThis container does not order your items alphabetically, but being an associative container, it is not required to preserve the insertion (or any other) order of the items
p16827
aVIf you would like to preserve some order of the items in the container and also have it work as an associative container (i
p16828
ag630
aVa map) you can build your own container as a combination of a linked list and an unsorted map, similar to Java's
p16829
as(dp16830
g6
V335858
p16831
stp16832
a((dp16833
g2
(lp16834
VHere is a very simple implementation:
p16835
aVThe idea is to advance the source pointer after each copy, but move the destination pointer only when you see an alphanumeric character
p16836
aVHere is how you use it:
p16837
aVThis prints
p16838
as(dp16839
g6
V335858
p16840
stp16841
a((dp16842
g2
(lp16843
VOnce a variable is declared, it's type cannot change
p16844
aVYour  approach is the correct one:
p16845
aVI wouldn't call it confusing, either: as long as the scope of the  variable is limited to the body of the  operator, it is clear to the readers what is going on
p16846
as(dp16847
g6
V335858
p16848
stp16849
a((dp16850
g2
(lp16851
VThe language does not support class variables
p16852
aVYou implement class-specific state with global  variables in the compilation units of the implementation
p16853
aVIn the header (
p16854
aVh file):
p16855
aVIn the implementation (
p16856
aVm file):
p16857
aVUsage:
p16858
as(dp16859
g6
V335858
p16860
stp16861
a((dp16862
g2
(lp16863
VYou do not need to initialize data with , because  discards the 100 bytes that you allocated
p16864
aVIf the sender writes more data than is necessary, it is impossible to know how many bytes should be chopped off
p16865
aVThe sender should either indicate how many bytes he sends, or you should come up with a heuristic that lets you tell useless bytes from useful ones
p16866
aVFor example, if you know that unused bytes are always at the end of the packet, and that they are always set to zero, you could use this piece of code to set up your string:
p16867
as(dp16868
g6
V335858
p16869
stp16870
a((dp16871
g2
(lp16872
VAllocate as many factors as you think the number may have (32 sounds like a good candidate), and then use  to cut off the array at the actual limit:
p16873
as(dp16874
g6
V335858
p16875
stp16876
a((dp16877
g2
(lp16878
VYou can use RENAME on viwes, like this:
p16879
aVUse the RENAME statement to rename a table, view, sequence, or private synonym
p16880
as(dp16881
g6
V335858
p16882
stp16883
a((dp16884
g2
(lp16885
VYou cannot do it for local variables like this
p16886
aVFor member fields you can use reflection; for locals, the simplest approach is to use , for example, like this:
p16887
as(dp16888
g6
V335858
p16889
stp16890
a((dp16891
g2
(lp16892
VThis is equivalent to the good old algorithm of finding  by a linear search:
p16893
as(dp16894
g6
V335858
p16895
stp16896
a((dp16897
g2
(lp16898
VOne obvious issue with the headers that you posted is that they are declaring variables of types that may not be in scope
p16899
aVFor example, you declare
p16900
aVbut there is no
p16901
aVat the top of your file
p16902
aVWhen you include  from , you should be OK, because  is included ahead of
p16903
aVIn all other files you will have a problem, because  is an unknown type
p16904
aVTo correct this issue, include  at the top of your  file
p16905
aVThen create a simple project with just the  and a simple  that includes :
p16906
aVmain
p16907
ag13302
aVKeep adding the missing headers until this simple  compiles
p16908
aVThen add your  to the real project, and the problem should go away
p16909
as(dp16910
g6
V335858
p16911
stp16912
a((dp16913
g2
(lp16914
VThe problem is that  is passed by value, so modifications to it inside the function have no effect
p16915
aVYou need to pass it by pointer, and modify it indirectly:
p16916
aVYou also need to pass  instead of  as the second argument of
p16917
as(dp16918
g6
V335858
p16919
stp16920
a((dp16921
g2
(lp16922
VYou can add  to your button, pass a selector in its , and choose the duration time by setting its  property
p16923
as(dp16924
g6
V335858
p16925
stp16926
a((dp16927
g2
(lp16928
VEF 4 does not have built-in support for  type
p16929
aVThis article explains how to do reading by mapping entities to custom queries, capturing the type and value separately, and then decoding the value manually in your code
p16930
aVUnfortunately, this solution cannot be adapted for writing the data back
p16931
aVYou can try mapping inserts/updates/deletes to stored procedures, but I cannot tell you for sure that it is going to work, because I never tried it
p16932
as(dp16933
g6
V335858
p16934
stp16935
a((dp16936
g2
(lp16937
VYou should not embed business logic into your parser, because of potential maintenance headaches: you do not want to recompile your grammar to fix bugs in business logic, let alone the nightmarish prospects of having to debug your business logic inside a generated parser
p16938
aVSo option one should be out of the question for anything other than the smallest toy projects
p16939
aVOption two can be implemented in more than one way: you can (A) have ANTLR generate AST nodes for you, and write a tree parser, or (B) you could skip the tree parser, and produce your own representation in the actions of the parser
p16940
aVI tried both approaches on production projects, both in Java and in C#, and both these approaches worked very well
p16941
aVI think the choice between (A) and (B) is largely a matter of your personal taste, as long as the business logic is kept out of the parser
p16942
as(dp16943
g6
V335858
p16944
stp16945
a((dp16946
g2
(lp16947
VUse  property to set the current date/time, and  to set the earliest date that can be selected
p16948
as(dp16949
g6
V335858
p16950
stp16951
a((dp16952
g2
(lp16953
VThe logic of the  does not make sense: I wold expect either
p16954
aVor
p16955
as(dp16956
g6
V335858
p16957
stp16958
a((dp16959
g2
(lp16960
VThis macro
p16961
aVis indeed hazardous, but the hazards are not where you think they are
p16962
aVThe expression from your post
p16963
aVworks perfectly fine
p16964
aVHowever, consider what happens when the expression is not a simple variable, but is a function that is hard to calculate, or when it is an expression with side effects
p16965
aVFor example
p16966
aVor
p16967
aVor
p16968
aVIf  were a function, all three invocations would produce good results in predictable time
p16969
aVHowever, the macro makes the first call invoke  and  twice (what if the user enters a different number when prompted again
p16970
aV, and it post-increments  twice
p16971
aVMoreover, consider this seemingly simple expression:
p16972
aVSince  has a higher precedence than , the resulting expansion will look like this:
p16973
aVWhen  is positive,  will not be added, so the meaning of the expression will change dramatically
p16974
aVThis last shortcoming can be addressed by enclosing the expression in parentheses
p16975
aVYou should also enclose in parentheses each macro argument, like this:
p16976
as(dp16977
g6
V335858
p16978
stp16979
a((dp16980
g2
(lp16981
VWhat am i missing
p16982
aVI think you are missing a distinction between  and an empty string
p16983
aVDatabases distinguish between  and
p16984
aVIf your  succeeds, then you have a non-null string there, and so DB is happy to accept it as a valid value
p16985
aVIn general, using DB for user-side validation is somewhat wasteful: if you know that the field must not be empty, you should check for it in the UI; DB validation should serve as the last resort that preserves the integrity of your data model
p16986
as(dp16987
g6
V335858
p16988
stp16989
a((dp16990
g2
(lp16991
VYou need to make your dictionary mutable, otherwise it would not respond to the  selector:
p16992
aVThis is a common pattern in cocoa: you often see classes declared in pairs: /, /, /, and so on
p16993
aVMutable version is capable of doing everything that the immutable version can do, but it also supports operations that change its content
p16994
as(dp16995
g6
V335858
p16996
stp16997
a((dp16998
g2
(lp16999
VThe resolution of  is platform dependent
p17000
aVUse  to find the resolution on your platform
p17001
aVAccording to the results of your experiment, clock resolutions on pc-x86 and on your target platform are different
p17002
as(dp17003
g6
V335858
p17004
stp17005
a((dp17006
g2
(lp17007
VThe value that you are passing is decimal , which corresponds to octal  ( after applying )
p17008
aVYou should be passing either , or decimal
p17009
as(dp17010
g6
V335858
p17011
stp17012
a((dp17013
g2
(lp17014
VYou are not comparing apples to apples, because the loop with  runs   times, while  does not do any of that; it does not do any formatting either, so "fancy formatting magic" hardly applies
p17015
aVAnother important difference is that  flushes every time when you pass , while  does not
p17016
aVYou should remove  from both strings to make your benchmarks more equitable
p17017
as(dp17018
g6
V335858
p17019
stp17020
a((dp17021
g2
(lp17022
V// unicorns and what-not
p17023
aVIf  passes  an instance of itself in the constructor, you ain't need no stinkin unicorns:
p17024
aVEDIT (to answer the follow-up question)
p17025
aVIf you would like to make sure that multiple invocations of  do not modify the the state of  concurrently, you should protect its critical sections by using  keyword
p17026
aVIf the entire method represents a single critical section, you can add  to method's declaration, like this:
p17027
as(dp17028
g6
V335858
p17029
stp17030
a((dp17031
g2
(lp17032
VIn DEC's assembly languages (PDP-11, VAX)  means indirect addressing mode, i
p17033
ag630
aVan extra level of indirection
p17034
aVIn your case,  means that the address of the operand is taken from the address
p17035
as(dp17036
g6
V335858
p17037
stp17038
a((dp17039
g2
(lp17040
VC functions do not have access to instance variables of your class; only Objective C methods do
p17041
aVC functions can access global variables and static variables declared in the same compilation unit, but if you would like to give them access to instance variables, you need to pass them explicitly from your Objective C methods:
p17042
as(dp17043
g6
V335858
p17044
stp17045
a((dp17046
g2
(lp17047
VRegex should be fine in this situation: use  and  as your anchors, like this
p17048
aVand get the first capturing group which gets everything between the anchors
p17049
aVThis prints
p17050
as(dp17051
g6
V335858
p17052
stp17053
a((dp17054
g2
(lp17055
V is declared as a numeric type in the database, but you are trying to read it as a string
p17056
aVIf you must have your result as a string, you can either:
p17057
aVread it as a numeric type (say, a ) and convert to string in C#, or
p17058
aVchange your SQL to cast it to  on the RDBMS side
p17059
aVOn a side note, you should not bake parameter values into your queries to avoid Bobby Tables; you need to use parameterized queries instead
p17060
as(dp17061
g6
V335858
p17062
stp17063
a((dp17064
g2
(lp17065
VYou are almost there:
p17066
aVThis assumes that  in the  are unique; if they are not, add  after
p17067
as(dp17068
g6
V335858
p17069
stp17070
a((dp17071
g2
(lp17072
VI would rather agree with your colleague: inheriting  would expose methods that are not applicable to  objects, such as , , , and so on
p17073
aVMaking  a property behind a getter sounds like a better choice: it does not reveal irrelevant operations to the users of your class, and lets you inherit from a base class of your choice
p17074
as(dp17075
g6
V335858
p17076
stp17077
a((dp17078
g2
(lp17079
VYou can use reflection:
p17080
aVYou could also use a dictionary of delegates:
p17081
as(dp17082
g6
V335858
p17083
stp17084
a((dp17085
g2
(lp17086
VArray elements are always spaced at equal distances in the memory, so finding an element given an index requires a multiplication by the size of the element and an addition of the array's base in memory
p17087
aVBoth operations are often done within the space of a single instruction in hardware by employing an appropriate addressing mode
p17088
as(dp17089
g6
V335858
p17090
stp17091
a((dp17092
g2
(lp17093
VA quick search on the internet reveals that Perforce gets asked about that a lot, and they did something about it: here is a link to their knowledge base article
p17094
aVHere is the description of te problem from the article:
p17095
aVThe super user is unable to access the Perforce database due to the following conditions:
p17096
aVWhen the only super user account listed in the protections table is accidentally deleted, but still remains in the protections table
p17097
aVThe owner of the super user account forgets the super user account password
p17098
aVThe idea behind the fix is to stop the server, move  out of the way, bounce the server, change the password using any other account, then move  back, and bounce the server again
p17099
as(dp17100
g6
V335858
p17101
stp17102
a((dp17103
g2
(lp17104
VThe same bit pattern can be interpreted in many different ways
p17105
aVThe only difference between a signed and an unsigned integer is in the way their bit patterns are interpreted
p17106
aVYour code instructs  to interpret an unsigned int as signed, that's why you see a negative number
p17107
aVAs a matter of experimenting, try this:
p17108
aVThis will produce a large positive number - a situation directly opposite of what you described in your post
p17109
aVAgain,  is asked to interpret a signed number as an unsigned, so it happily throws the sign away, and prints the value as if it were unsigned
p17110
as(dp17111
g6
V335858
p17112
stp17113
a((dp17114
g2
(lp17115
VAdam's answer correctly identifies the problem; here is a solution: you can use LINQ to unbox any type, as long as it can be cast to  with a built-in or a custom conversion
p17116
aVThis method produces a LINQ expression that first unboxes the object to its actual type, and then applies the conversion
p17117
aVReplace the last line of your method
p17118
aVwith
p17119
aVto make it work
p17120
aVHere is a link to an article that explains how to make conversions of this kind more efficient by caching the compiled lambdas
p17121
as(dp17122
g6
V335858
p17123
stp17124
a((dp17125
g2
(lp17126
VYes, it is possible, but it is going to take
p17127
aVConsider stacks  (source) and  (target)
p17128
aVinit  to zero
p17129
aVpop the top element  off the stack , then push the remaining data onto stack , leaving  items on stack
p17130
aVpush  on top of
p17131
aVCopy elements back from  to
p17132
aVincrement
p17133
aVIf count is not equal the number of items on , go back to step 1
p17134
aVpop elements of  and push onto
p17135
aVSteps 0 through 5 reverse stack  in place; step 6 moves it over to , reversing the order and producing a copy of the original
p17136
aVIt's a destructive copy, though, because the original stack is now empty
p17137
as(dp17138
g6
V335858
p17139
stp17140
a((dp17141
g2
(lp17142
VIn general, changing the state in response to ST's getting the state is not a good idea, so numbering non-key fields should happen in your model, before you start with the generation
p17143
aVAdd a getter for  to the class of your model that hosts the  property
p17144
aVGo through all siblings, and number them as you need (i
p17145
ag630
aVstarting from one and skipping the keys in your numbering)
p17146
aVNow you can use this ST to produce the desired output:
p17147
aVSometimes it may not be possible to add methods such as  to your model classes
p17148
aVIn such cases you should wrap your classes into view classes designed specifically to work with string template, and add the extra properties there:
p17149
as(dp17150
g6
V335858
p17151
stp17152
a((dp17153
g2
(lp17154
VYou can put anything you want into a resx file and read it back, there should not be any problem with that
p17155
aVAs far as advantages go, you do not get any advantage from it compared to putting it into your application config file
p17156
aVOn the contrary, accessing the string becomes more cumbersome, and you cannot alter them at runtime
p17157
aVGenerally speaking, I see little difference between putting the connection string into resx and compiling it into your code with a compile-time constant
p17158
aVIt goes without saying that strings with passwords in them should never go into config or resx files as plain text
p17159
as(dp17160
g6
V335858
p17161
stp17162
a((dp17163
g2
(lp17164
VA slight change to your solution should do the trick - replace  with , like this:
p17165
as(dp17166
g6
V335858
p17167
stp17168
a((dp17169
g2
(lp17170
VThe second book is wrong: it is easy to check that the macro will not be expanded like that
p17171
aVHowever, you can get the effect that they describe by stringizing tokens using the  preprocessor operator:
p17172
aVNow you can print your variable as follows:
p17173
aVHere is a link to a working sample on ideone
p17174
aVNote the addition of the double quotes before and after the '#format', and the '#' before 'var' and 'format'
p17175
aVThe '#' operator causes the value of the variable to be made into a quoted string -- with double quotes of its own
p17176
aVThis makes the replaced strings be four quoted strings in a row, that the C compiler recognizes as a request to concatenate into one string
p17177
aVThus the strings: "xyz", " is %", "d" and "\u005cn" are concatenated into: "xyz is %d\u005cn"
p17178
aV(Note this example is different from the example in the original question in that the orignal example had "variable is
p17179
aVwhere the answer replaced 'variable' with an instance of the 'var' macro argument)
p17180
as(dp17181
g6
V335858
p17182
stp17183
a((dp17184
g2
(lp17185
VAccessing an unitialized variable is undefined behavior in both C and C++, so reading any value is possible
p17186
aVIt is also possible that your program crashes: once you get into undefined behavior territory, all bets are off1
p17187
aV1 I have never seen a program crashing over accessing an uninitalized variable, unless it's a pointer
p17188
as(dp17189
g6
V335858
p17190
stp17191
a((dp17192
g2
(lp17193
VYou are re-calculating , but you are not using it in
p17194
aVI think it should be
p17195
aVCurrently, you keep re-allocating at size 10
p17196
as(dp17197
g6
V335858
p17198
stp17199
a((dp17200
g2
(lp17201
VInsertion of line breaks is controlled by the second parameter of this overload:
p17202
aVIf you pass , you get line breaks; otherwise, you do not get line breaks
p17203
aVSingle-parameter overload does not insert breaks
p17204
as(dp17205
g6
V335858
p17206
stp17207
a((dp17208
g2
(lp17209
VThere is nothing that would do it automatically, but you can build something that works reasonably reliably: you can use  and , and combine them in such a way that the order in which you combine them mattered
p17210
aVHere is an example:
p17211
aVThis code prints
p17212
aVAs you can see, this code produces run-time constants for each structure that reacts to re-ordering of fields of different lengths and changing fields' types
p17213
aVIt also reacts to adding fields even if you forget to update the list of fields on which you base your computation, which should produce some sort of a safety net
p17214
as(dp17215
g6
V335858
p17216
stp17217
a((dp17218
g2
(lp17219
VYou get the same output because all your string point to the same place - namely, your  variable
p17220
aVYou should create new strings using the buffer 's data, like this:
p17221
aVAfter you do that, don't forget to delete the strings that you allocated by calling  on each string pointer at the end of your function, when you no longer need the strings
p17222
as(dp17223
g6
V335858
p17224
stp17225
a((dp17226
g2
(lp17227
VNo, you do not need to do anything special:  keyword is implied when there is no ARC keyword
p17228
aVEDIT You do not need to use  in the setter either: ARC knows to retain , because  is already a  reference
p17229
as(dp17230
g6
V335858
p17231
stp17232
a((dp17233
g2
(lp17234
VYou should split off logic into its own function whenever you think that it would aid readability: the cost of a function call itself is negligible
p17235
aVAlthough it is generally true that calling a function consumes some space and CPU cycles, you shouldn't be worrying about it at all: the instructions involved are optimized beyond belief, and the compiler can inline your code when it sees fit
p17236
aVEDIT (in response to comment by Potatoswatter)
p17237
aVOne thing you need to be careful is passing parameters, especially in C++, where user code can participate in the process of copying parameters being passed to the function
p17238
aVPassing large s by value can take more than a few cycles in C, too, so you should pass them by reference or by pointer whenever you can
p17239
as(dp17240
g6
V335858
p17241
stp17242
a((dp17243
g2
(lp17244
VMacros are replaced at compile time; they do not run at compile time
p17245
aVThe body of the macro will be "pasted in" in place of the reference to the name of the macro, as if you typed it in manually
p17246
aVIn general, compiler will evaluate constant expressions at compile time, with or without macros
p17247
aVYour  does not involve constant expressions - it is a run-time expression, so it is evaluated at run time
p17248
as(dp17249
g6
V335858
p17250
stp17251
a((dp17252
g2
(lp17253
VReading from a member of the union to which you have not previously assigned is undefined behavior
p17254
aVIn a union, at most one of the non-static data members can be active at any time, that is, the value of at most one of the non-static data members can be stored in a union at any time
p17255
aVThere is an exception to this rule when types share a common layout, which does not apply in your case
p17256
aVGenerally, if you assign to , then you can read only from ; if you would like to start reading from , you need to assign to  first
p17257
aVI guess this makes sense if the bool is being converted to an int, the bitwise complement is applied, and the result is converted back to a bool
p17258
aVThis is 100% correct: the snippet below
p17259
aVprints
p17260
aVis promoted to , tilde  is applied, and then the result is converted back to  using the usual "zero / not zero" rule
p17261
as(dp17262
g6
V335858
p17263
stp17264
a((dp17265
g2
(lp17266
VWhen you are slowly filling a large memory buffer, the time required for that grows non-linearly, because you need to re-allocate the buffer multiple times, each time copying the entire content to a new location in memory
p17267
aVThis takes time, especially when the buffer is 200MB+
p17268
aVIf you preallocate the buffer, your process may go faster
p17269
aVHowever, all the above is just my guess
p17270
aVYou should profile your application to see where the additional time really goes
p17271
as(dp17272
g6
V335858
p17273
stp17274
a((dp17275
g2
(lp17276
VAdd an observer like this:
p17277
aVProcess the event like this:
p17278
as(dp17279
g6
V335858
p17280
stp17281
a((dp17282
g2
(lp17283
VYour rule #1 applies with or without , so the rule #2 is the real decider: opt for a / if you must distinguish between situations when an exception has been thrown and the normal program completion
p17284
aVFor example, if your persistence layer may discover issues in the process of using a database connection, your connection needs to close regardless of the fact that there was an exception
p17285
aVIn this case, the  construct is a perfect choice
p17286
aVIn some cases you can set up  specifically to detect normal completion vs
p17287
aVan exceptional completion
p17288
aVAmbient transactions provide a perfect example:
p17289
aVIf 's  is called before  has been called,  knows that an exception has been thrown, and aborts the transaction
p17290
as(dp17291
g6
V335858
p17292
stp17293
a((dp17294
g2
(lp17295
VTry this:
p17296
aVHere is the "anatomy" of the statement:
p17297
aVapplies its condition to each item of , and returns  if  has been returned for any item from the list
p17298
aVThe predicate inside  tests for 's name to be equal to that of
p17299
aVYou can fold the  into LINQ as well:
p17300
as(dp17301
g6
V335858
p17302
stp17303
a((dp17304
g2
(lp17305
V is not that bad, as long as you do not spread it all over your code, and use a reasonable strategy to grow your dynamic array
p17306
aVRolling your own dynamic arrays in C is a matter of implementing a handful of easy functions
p17307
aVNumerous short articles walk you through this exercise - here is one for an example
p17308
aVThe article defines a  that represents your dynamic array, along with the currently used and the allocated size
p17309
aVIt also provides functions for initializing, growing, and de-allocating the array represented by the structure
p17310
aVThere is no explicit initialization function in the library - you initialize by passing  as the first parameter
p17311
aVThis is a valid approach, but you could also opt for a more traditional separation of  and
p17312
as(dp17313
g6
V335858
p17314
stp17315
a((dp17316
g2
(lp17317
VCopying and ARC are orthogonal: you make copies of mutable objects to "freeze" their state; ARC keeps track of object's reference count
p17318
aVobjects may or may not be mutable
p17319
aVWhen you receive an  as a parameter, you cannot be certain that it is immutable unless you check its type (and even then you may get false positives)
p17320
aVIf your algorithm relies on the string not changing after being set, making a copy is the right thing to do
p17321
aVARC, on the other hand, will ensure that the object is not released while you are holding a strong reference to it
p17322
as(dp17323
g6
V335858
p17324
stp17325
a((dp17326
g2
(lp17327
VI assume that by "nothing happened" you mean that you see the first image, but the sequence does not move beyond that
p17328
aVThis is probably because you  too soon: it does not even get a chance to start
p17329
as(dp17330
g6
V335858
p17331
stp17332
a((dp17333
g2
(lp17334
V is defined on many systems that can be programmed in C/C++, including many non-UNIX systems, and many systems that lack operating system altogether
p17335
aVRequiring  to zero out the memory goes against C's philosophy of saving CPU as much as possible
p17336
aVThe standard provides a zeroing cal  that can be used if you need to zero out the memory
p17337
aVBut in cases when you are planning to initialize the memory yourself as soon as you get it, the CPU cycles spent making sure the block is zeroed out are a waste; C standard aims to avoid this waste as much as possible, often at the expense of predictability
p17338
as(dp17339
g6
V335858
p17340
stp17341
a((dp17342
g2
(lp17343
VStatic variables are local to your compilation unit
p17344
aVTheir placement makes absolutely no difference, as long as they are declared ahead of their first use in the program
p17345
aVAlthough there are no purely technical reasons to keep static declarations at the top of the file, this is a rather widespread convention
p17346
aVI've seen it written out explicitly in the coding standards of several companies
p17347
aVWhen all programmers follow the same convention, the code looks more uniform, and uniformity is a great step toward code maintainability
p17348
aVWhen someone else opens your file and the code formatting looks familiar, that's a great plus
p17349
aVSo if other colleagues on your team do follow this convention, you should follow it as well
p17350
as(dp17351
g6
V335858
p17352
stp17353
a((dp17354
g2
(lp17355
V should be declared as
p17356
aVWhen you pass parameters to your thread, it is best to define a  for them, pass a pointer to that  as , and cast back to the right type inside the function
p17357
as(dp17358
g6
V335858
p17359
stp17360
a((dp17361
g2
(lp17362
VThe difference is in that  points to memory that belongs to a string constant, and is therefore not writable
p17363
aVWhen you do this
p17364
aVthe compiler copies the content of a non-writable string into a writable array
p17365
aVis not required, by the way
p17366
aVWhen you do this, however,
p17367
aVthe compiler leaves the pointer pointing to a non-writable memory region
p17368
aVAgain,  will be inserted by compiler
p17369
aVIf you are using , you can have it warn you about initializing writable  with string literals
p17370
aVThe option is
p17371
aVYou will get a warning that looks like this:
p17372
aVThe proper way to declare your  pointer is as follows:
p17373
as(dp17374
g6
V335858
p17375
stp17376
a((dp17377
g2
(lp17378
VThe problem is that the sequence of statements in your code is such that the check for the loop's exit condition is not reached until after the second input is requested
p17379
aVYou could add a check for  as soon as it's entered, and break out from the loop
p17380
aVAlternatively, you could ask for the miles to be entered ahead of the gallons
p17381
as(dp17382
g6
V335858
p17383
stp17384
a((dp17385
g2
(lp17386
VThe  method returns an object, which is always non-nil (hence you're seeing a  instead of a )
p17387
aVIf I remember it correctly, booleans are wrapped in
p17388
aVYou should pull the actual boolean value from the object returned by , like this:
p17389
as(dp17390
g6
V335858
p17391
stp17392
a((dp17393
g2
(lp17394
VIt is hard to compete with Wikipedia's explanation of exponentiation by squaring, but here is my take
p17395
aVThe key to the answer is in this formula:
p17396
aVThis immediately answers the "what to do when the power is even" question: if , then you could first square , and then raise the result to the power of
p17397
aVThe case of the odd power is a bit more complex: let's rewrite
p17398
aVas
p17399
aVNow you see what happens in that  branch: they subtract one from the odd number making it even, get , and multiply it by  in the end
p17400
aV*
p17401
aVNow for the time complexity: each step reduces the  by half, so the number of times the recursive call is made is
p17402
aV* The implementation does not subtract  from  explicitly
p17403
aVRather, it performs an integer division of , which discards the remainder of the division
p17404
as(dp17405
g6
V335858
p17406
stp17407
a((dp17408
g2
(lp17409
VThis is how it is supposed to work with explicit interface implementations:
p17410
aVA class that implements an interface can explicitly implement a member of that interface
p17411
aVWhen a member is explicitly implemented, it cannot be accessed through a class instance, but only through an instance of the interface
p17412
aVSo if you re-write your code like this, it should no longer fail:
p17413
as(dp17414
g6
V335858
p17415
stp17416
a((dp17417
g2
(lp17418
VThe only advantage the second method offers is that you would avoid constructing and disposing an instance of  in cases when construction of your  fails
p17419
aVOther than that, the two snippets are identical
p17420
as(dp17421
g6
V335858
p17422
stp17423
a((dp17424
g2
(lp17425
VTry this:
p17426
aVThis returns rows that belong to both 233 and 234 (this is how I read your question, anyway; I may have misunderstood the "belonging to multiple categories" part)
p17427
as(dp17428
g6
V335858
p17429
stp17430
a((dp17431
g2
(lp17432
VYou are missing a pair of parentheses in the loop header:
p17433
aVCurrently, your assignment takes , which is either  or , and assigns it to
p17434
aVThis never matches the space or
p17435
aVTo learn more about operation precedence in C, take a look at this chart
p17436
aVGenerally, though, it never hurts to add a pair of parentheses to force the operation order that you need
p17437
aVIf you are having doubts about precedence of operations in the expression that you are writing, chances are that your readers would have doubts too
p17438
as(dp17439
g6
V335858
p17440
stp17441
a((dp17442
g2
(lp17443
VTypically, RDBMS round-trips are a dominating factor, but in this case the costs to parse the  list may get high, too
p17444
aVIf you parameterize your queries, however, the second solution is very likely going to be faster, because parsing will be done only once
p17445
as(dp17446
g6
V335858
p17447
stp17448
a((dp17449
g2
(lp17450
VAlthough there is no performance penalty for it, there is certainly a loss of flexibility: unlike s, your C arrays are fixed-size
p17451
aVYou would not be able to use fast enumeration with C arrays, too, having to resort to using array indexes
p17452
aVIf these limitations are OK with your requirements, C arrays should work
p17453
aVThey play nicely with ARC, too: once a C array of strong references goes out of scope, ARC releases all instances that are not set to
p17454
as(dp17455
g6
V335858
p17456
stp17457
a((dp17458
g2
(lp17459
V does not take up four bytes: it takes up a single byte as usual
p17460
aVYou can check it by printing
p17461
aVThe other three bytes are padding that the compiler inserts to optimize access to other members of your class
p17462
aVDepending on hardware, it is often much faster to access multi-byte types, say, 4-byte integers, when they are located at an address divisible by four
p17463
aVA compiler may insert up to three bytes of padding before an int member to align it with a good memory address for faster access
p17464
aVIf you would like to experiment with class layouts, you can use a handy operation called
p17465
aVIt takes two parameters - the name of the member and the name of the class, and it returns the number of bytes from the base address of your struct to the position of the member in memory
p17466
as(dp17467
g6
V335858
p17468
stp17469
a((dp17470
g2
(lp17471
VOne way to refactor this would be passing the pages upfront, and passing them to a protected constructor:
p17472
ag1971
ag1972
aVI am not sure what this has to do with the factory method
p17473
aVYour post illustrates the Template Method Pattern
p17474
as(dp17475
g6
V335858
p17476
stp17477
a((dp17478
g2
(lp17479
VThere are several things that are wrong with your code:
p17480
aVYour nested loops assume that the array is square (you iterate both dimensions to ),
p17481
aVYou print the entire array after initializing each row, and
p17482
aVYou print the array incorrectly (Java array do not print their content when passed to )
p17483
aVThe first item is OK if your matrix is indeed always square
p17484
aVThe second item is easy to fix by moving the output outside of the second nested loop
p17485
aVThe third item is the hardest
p17486
aVIt would be a good exercise to write a static method that takes your 2D array, and prints it out element-by-element with two nested loops
p17487
aVYou can also use  if you would rather use a system function
p17488
as(dp17489
g6
V335858
p17490
stp17491
a((dp17492
g2
(lp17493
VParameters of functions that correspond to  are promoted before passing to your variadic function
p17494
aVand  are promoted to ,  is promoted to , etc
p17495
ag837
ag10442
ag839
ag839
aV7 The ellipsis notation in a function prototype declarator causes
p17496
aVargument type conversion to stop after the last declared parameter
p17497
aVThe default argument
p17498
aVpromotions are performed on trailing arguments
p17499
aVThe reason for this is that early versions of C did not have function prototypes; parameter types were declared at the function site but were not known at the call site
p17500
aVBut different types are represented differently, and the representation of the passed argument must match the called function's expectation
p17501
aVSo that char and short values could be passed to functions with int parameters, or float values could be passed to functions with double parameters, the compiler "promoted" the smaller types to be of the larger type
p17502
aVThis behavior is still seen when the type of the parameter is not known at the call site -- namely, for variadic functions or functions declared without a prototype (e
p17503
ag303
aV, )
p17504
as(dp17505
g6
V335858
p17506
stp17507
a((dp17508
g2
(lp17509
VTry using , that's the format that prints 's  (cocoa's analog to Java's )
p17510
as(dp17511
g6
V335858
p17512
stp17513
a((dp17514
g2
(lp17515
VSpring or not, Java local variables are thread safe as long as you do not share their objects manually with other threads
p17516
aVFor example, if your "business logic" code creates new threads and passes your local variables to these threads, the locals are not thread safe
p17517
aVOther than that, they are: each executing thread running your method will get its own local variable that is separate from all other local variables
p17518
as(dp17519
g6
V335858
p17520
stp17521
a((dp17522
g2
(lp17523
VThis behavior is correct
p17524
aVOtherwise, you'd get a chicken-and-egg problem: you would not be able to insert an answer without inserting a row for the question first, and you also would not be able to insert a question without first inserting a valid answer for it
p17525
aVYou will get a similar issue trying to delete a question or an answer being referenced
p17526
aVA typical solution to this is adding a column  to the  table
p17527
as(dp17528
g6
V335858
p17529
stp17530
a((dp17531
g2
(lp17532
VThis is probably not an answer that you were looking for, but it does not fit in a comment, so I pasted it here
p17533
aVThis piece of code should be equivalent to yours, but it does not have s, and it does not introduce additional indirection
p17534
aVThere is an additional check and a  on , but the compiler should be able to optimize it into a single access, and perhaps even put it in a register
p17535
as(dp17536
g6
V335858
p17537
stp17538
a((dp17539
g2
(lp17540
VOne way to separate algorithms from data structures on which they operate is by thinking of the operations that you need in order to implement your algorithm, abstract these operations out as an interface, code up your algorithm in terms of the interface, and have all data structures implement the interface
p17541
aVFor example, let's say that your sorting algorithm needs a way to compare items at positions  and , and a way to swap items  and
p17542
aVThen your interface would look like this:
p17543
aVNow you can implement your sorters in terms of :
p17544
aVFinally, you make your containers implement :
p17545
aVNote that all the above is simply a suggestion for your learning exercise
p17546
aVJava provides powerful sorting facilities that work on lists and arrays, and let you specify your sorting order to the smallest possible detail
p17547
aVTake a loop at the  method for more information
p17548
as(dp17549
g6
V335858
p17550
stp17551
a((dp17552
g2
(lp17553
VThe source of your confusion is the misunderstanding of when the concatenation is performed
p17554
aVJoining two consecutive string literals is done by the compiler at compile time, not by your program at run time
p17555
aVTherefore there is only one way to parse the first printf: both string literals belong to the "else" branch of the expression
p17556
aVYou can test it by setting i to zero and observing the output
p17557
as(dp17558
g6
V335858
p17559
stp17560
a((dp17561
g2
(lp17562
VYou have an off by one error indeed: the call
p17563
aVshould be
p17564
aVYour code passes  which is the length from the beginning of the string to the position of the last space; it should be the length of the last word, so you need to subtract the index of the first character (i
p17565
ag630
ag1783
aVYou are also not reversing the last word (see the other answer for the details on that)
p17566
as(dp17567
g6
V335858
p17568
stp17569
a((dp17570
g2
(lp17571
VYou can truncate the trailing digit by dividing by ten using integer division, and then multiplying back by ten
p17572
aVEveryone between 0, inclusive, and 10, exclusive, will be in the bucket 0
p17573
aVfrom 10 to 20 will be under the key , from 20 to 30 - under the key , and so on
p17574
as(dp17575
g6
V335858
p17576
stp17577
a((dp17578
g2
(lp17579
VThe  keyword is not a synchronization primitive
p17580
aVIt merely prevents caching of the value on the thread, but it does not prevent two threads from modifying the same value and writing it back concurrently
p17581
aVLet's say two threads come to the point when they need to increment the counter, which is now set to 5
p17582
aVBoth threads see 5, make 6 out of it, and write it back into the counter
p17583
aVIf the counter were not , both threads could have assumed that they know the value is 6, and skip the next read
p17584
aVHowever, it's volatile, so they both would read 6 back, and continue incrementing
p17585
aVSince the threads are not going in lock-step, you may see a value different from 10000 in the output, but there's virtually no chance that you would see 20000
p17586
as(dp17587
g6
V335858
p17588
stp17589
a((dp17590
g2
(lp17591
VThis has to do with the way the compiler determines the type of your lambda
p17592
aVWhen you return a plain , the only thing the compiler can imply is that you are returning an object
p17593
aVHence, your parameterless lambda is compatible with
p17594
aVHowever, the signature of your function says that you are returning , so the return type the compiler implied from your code is not compatible
p17595
aVWhen you cast that  to , you provide the compiler a the clue it is missing to make the lambda a
p17596
as(dp17597
g6
V335858
p17598
stp17599
a((dp17600
g2
(lp17601
VYou can try this:
p17602
aVThere is a correlated  query that checks if there are other sales on the same machine that happened at a later date
p17603
as(dp17604
g6
V335858
p17605
stp17606
a((dp17607
g2
(lp17608
VAll query optimizers worth their salt should produce query plans with identical performance for both queries: if there is an index on the column being optimized, both queries should use it; if there is no index, both would produce a full table scan
p17609
as(dp17610
g6
V335858
p17611
stp17612
a((dp17613
g2
(lp17614
VYou are passing 56 as the first argument instead of 2
p17615
aVThe function then interprets 56 as the number of arguments, and continue reading its "parameters" past the initialized area
p17616
aVWhen you modify the call to pass 2, the result returned from the function is 15
p17617
as(dp17618
g6
V335858
p17619
stp17620
a((dp17621
g2
(lp17622
VYou can try this approach:
p17623
as(dp17624
g6
V335858
p17625
stp17626
a((dp17627
g2
(lp17628
VSince headers are always compiled as part of
p17629
aVc/
p17630
aVcpp file, there is no need to specify header-to-header dependency
p17631
aVThe dependency that you have specified already is sufficient, because  will recompile when a
p17632
aVh and/or b
p17633
aVh change
p17634
as(dp17635
g6
V335858
p17636
stp17637
a((dp17638
g2
(lp17639
VI think the problem is in your C program, not in your C# program
p17640
aVWhen you produce your output, you do not put  at the end
p17641
aVHence  will wait forever, because there is no end-of-line marker in the stream
p17642
aVSince the output of your C program is used to synchronize the steps of your co-operating programs, it is also a very good idea to flush it to the output before waiting for the next portion of input:
p17643
as(dp17644
g6
V335858
p17645
stp17646
a((dp17647
g2
(lp17648
VThere are several ways of achieving this: you could use , or if you need to make multiple modifications you could use
p17649
as(dp17650
g6
V335858
p17651
stp17652
a((dp17653
g2
(lp17654
VThe trick from your link is a dirty hack
p17655
aVNot only does it reload the data, but also forces the table to redraw
p17656
aVIt tells your app that the device is getting a new orientation, so your table gets redrawn, along with other UI elements
p17657
aVThe standard way of refreshing a single row or a specific set of rows in your  is calling its  method: doing so calls through to your data source to get data for only the row(s) that have been updated, preventing the full reload
p17658
as(dp17659
g6
V335858
p17660
stp17661
a((dp17662
g2
(lp17663
VIn order to mitigate the absence of unsigned data types, Java introduced the  operator for shifting right, which does not sign-extend the value being shifted
p17664
aVThis is the only bit operation that would suffer from the fact that the number is interpreted as signed
p17665
aVIf you replace all  with , and replace all  operations on "unsigned" values with , you will get identical bit patterns in the results of your operations
p17666
as(dp17667
g6
V335858
p17668
stp17669
a((dp17670
g2
(lp17671
VSince  returns a one-dimensional array, there is no wonder why this does not compile
p17672
aVIf you were returning , it would compile, however
p17673
aVYou could also build your 2-D array manually with two nested loops:
p17674
aVThe code above assumes that you have at least one item in the , and that the length of all lists inside  is the same
p17675
as(dp17676
g6
V335858
p17677
stp17678
a((dp17679
g2
(lp17680
VInvoking static methods in Java requires you to specify the exact type
p17681
aVIt is not possible to invoke static methods polymorphically, eliminating the need for
p17682
aVPlease note that this approach is not universal across all languages: for example, you can override class methods in Objective-C, and Apple's cocoa frameworks make good use of this mechanism to customize their "factory" classes
p17683
aVHowever, in Java, C++, and C# class methods do not support polymorphic behavior
p17684
aVTheoretically, Java designers could have let you provide interface method implementations through  methods in case an implementation does not need to access the state from the instance
p17685
aVBut the same behavior is simple to achieve with a trivial wrapper:
p17686
aVJava compiler could have done the same thing on your behalf, but seeing a static method implement an instance method is both unusual and confusing, so my guess is that Java designers decided against providing this "piece of magic"
p17687
as(dp17688
g6
V335858
p17689
stp17690
a((dp17691
g2
(lp17692
VThe second approach is much better than the first one, because it hides the very fact of existence of Word and Pdf documents from the users of your library
p17693
aVThis becomes especially important when you decide to add more document types - e
p17694
ag303
aVRtf, Html, and so on: the users would get the benefits of the newly added types without having to recompile their code
p17695
aVIn fact, they would not even notice that you have changed anything: if done right, their code will "just work" with the documents of type they have never knew existed
p17696
ag1971
ag1972
aVIf you can scan the byte array and figure out the correct type from it, your API can "earn some points for style" by eliminating the second parameter
p17697
as(dp17698
g6
V335858
p17699
stp17700
a((dp17701
g2
(lp17702
VYour dealing with pointers is wrong in at least these places:
p17703
aVThe code with the comment "add the item to the vector" is very wrong: instead of adding an item, it overrides the pointer with an arbitrary
p17704
aVshould be
p17705
aVYour pointer arithmetic is incorrect: subtracting the size and adding an index will get you a pointer prior to the beginning of the allocated area, which is not correct
p17706
aVYou are assigning the results of  to a local variable  of type "pointer to vector"
p17707
aVThis assignment has no effect in the caller, because pointers are passed by value
p17708
aVIf you wanted to re-assing the vector in the , you should have taken  as the first parameter
p17709
aVThis code fragment does not look right at all: it appears that you should be assigning  instead of
p17710
aVYou do not free the old vector when you do a , causing a memory leak
p17711
as(dp17712
g6
V335858
p17713
stp17714
a((dp17715
g2
(lp17716
VThe reason you see this behavior is simple: you schedule a new thread each second, with the result becoming visible three seconds later
p17717
aVYou do not see anything for the first four seconds; then, the thread that has been started three seconds ago dumps; another thread will have been sleeping for two seconds by then, and yet another - for one second
p17718
aVThe next second thread #2 dumps; then thread #3, #4, and so on - you get a printout every second
p17719
aVIf you would like to see a printout every three seconds, you should schedule a new thread every three seconds with any delay that you would like: the initial thread will output in three seconds plus the delay; all the subsequent threads will be firing on three-second intervals
p17720
as(dp17721
g6
V335858
p17722
stp17723
a((dp17724
g2
(lp17725
VYou can try this approach:
p17726
aVEach row of  for which there exists a row of  such that any of its ids matches that of  will be returned
p17727
as(dp17728
g6
V335858
p17729
stp17730
a((dp17731
g2
(lp17732
VFrom the comments in the source code of the allocator:
p17733
aVTread-safety: NOT thread-safe unless USE_LOCKS defined non-zero
p17734
aVWhen USE_LOCKS is defined, each public call to malloc, free, etc is surrounded with a lock
p17735
aVBy default, this uses a plain pthread mutex, win32 critical section, or a spin-lock if if available for the platform and not disabled by setting USE_SPIN_LOCKS=0
p17736
aVYou need to compile the library with , otherwise you may see crashes
p17737
aVAnother possibility is that your program exhibits undefined behavior that does not lead to consequences with the regular
p17738
aVFor example, it might write one byte past the allocated area somewhere, but that byte could be part of a memory chunk that is a few bytes larger than what you have requested
p17739
aVUse valgrind to check your program for memory errors with "regular" malloc before linking it with the custom allocator
p17740
as(dp17741
g6
V335858
p17742
stp17743
a((dp17744
g2
(lp17745
VUse  to store byte arrays of arbitrary length in MySQL
p17746
as(dp17747
g6
V335858
p17748
stp17749
a((dp17750
g2
(lp17751
VYou have a pointer type mismatch: you are passing a pointer to a pointer to list node, but inside   you treat it as a pointer to node
p17752
aVEither remove the ampersand before  in the call to , or change your  as follows:
p17753
as(dp17754
g6
V335858
p17755
stp17756
a((dp17757
g2
(lp17758
VThe outer loop in snippets 2 and 3 will not exit because the inner loop does not exit: the  loop never gets a chance to check its continuation condition
p17759
aVSnippet 1 works fine, because you check the same condition inside the nested loop, and break out if the limiting count has been reached
p17760
aVYou can combine both conditions into a single loop, like this:
p17761
as(dp17762
g6
V335858
p17763
stp17764
a((dp17765
g2
(lp17766
VMake  a strong reference
p17767
aVThe reason why you usually declare variables for your subviews as  is that the existence of these links does not imply ownership
p17768
aVSubviews are owned by the object instantiated from a NIB/Storyboard
p17769
aVYou own that object directly, and you also own its dependent objects indirectly
p17770
aVThe  is a different story: you create it programmatically, so your NIB/Storyboard does not own it
p17771
aVTherefore, you should make the reference to it  (which is the default when there are no ARC modifiers)
p17772
as(dp17773
g6
V335858
p17774
stp17775
a((dp17776
g2
(lp17777
VTo avoid iterating through the sequence two times (once for the count and once for the element) it is probably a good idea to save your sequence in an array before getting its random element:
p17778
aVEDIT Implemented a very good idea by Chris Sinclair
p17779
as(dp17780
g6
V335858
p17781
stp17782
a((dp17783
g2
(lp17784
VYou need to use command line arguments in your :
p17785
aVThis code parses parameters using ; you could use  instead
p17786
as(dp17787
g6
V335858
p17788
stp17789
a((dp17790
g2
(lp17791
VYou can follow these steps to do what you need:
p17792
aVLoad the image
p17793
aVSplit it up into squareshow
p17794
aVCreate a  for each image, setting the location to the place of the square in the image before shuffling
p17795
aVGo through the layers, and set their positions to their target locations after shuffling
p17796
aVWatch the squares moving to their new placeswhat if you don't want the animation
p17797
as(dp17798
g6
V335858
p17799
stp17800
a((dp17801
g2
(lp17802
VYou can use  to get the effect that you are looking for:
p17803
as(dp17804
g6
V335858
p17805
stp17806
a((dp17807
g2
(lp17808
VFirst, you should compare only the next current key that has not been compared for being less than, and drop the  after , like this:
p17809
aVIf you need to compare only the timestamp, leave the first , and delete the remaining ones:
p17810
aVWhen you use this operator for comparing your keys, the items with identical timestamp will not be reordered
p17811
as(dp17812
g6
V335858
p17813
stp17814
a((dp17815
g2
(lp17816
VYou can filter your array using , like this:
p17817
as(dp17818
g6
V335858
p17819
stp17820
a((dp17821
g2
(lp17822
VYou cannot use , but you can use : it is a little inconvenience because your would-be- functions need to return , but if it unifies your code, it should be a small price to pay
p17823
aVThis inability to use  as a return type is at least partially responsible for a split between the  and  families of generic delegates: had it been possible to return , all  would become simply
p17824
aVUnfortunately, this is not possible
p17825
as(dp17826
g6
V335858
p17827
stp17828
a((dp17829
g2
(lp17830
VIf the compiler optimization settings let the compiler inline everything, there should be no performance differences
p17831
aVThe only disadvantage that I can spot is that expressions based on objects of this class may no longer qualify as compile-time constants, which may be important in template programming
p17832
aVOther than that, you end up with additional clarity at no runtime cost
p17833
ag1971
ag1972
aVYou are missing  in your  and :
p17834
as(dp17835
g6
V335858
p17836
stp17837
a((dp17838
g2
(lp17839
VTry using  implicit animation
p17840
aVCreate your layers and set their images in a loop, like this:
p17841
aVNow you can start animating your layers implicitly by setting their properties:
p17842
aVOnce you are done with the layers, remove them from superview:
p17843
as(dp17844
g6
V335858
p17845
stp17846
a((dp17847
g2
(lp17848
VThere is no way to require immutability of subclasses
p17849
aVYou can make sure that subclasses of your classes do not mutate your state by not providing setters and keeping your instance variables private, but if subclasses declare their own instance variables, they have full control over them
p17850
aVAs far as interfaces go, the only thing you can do is to not provide setters
p17851
aVHowever, implementations can provide setters of their own
p17852
as(dp17853
g6
V335858
p17854
stp17855
a((dp17856
g2
(lp17857
VIn order to be able to invoke a method inside a class, the method that does the invocation must have access to the class itself
p17858
aVTherefore, methods of the class inside of which a private class is defined will have access to the public method, and methods of other classes would not have the access
p17859
aVOf course if a private class inherits a public class or implements a public interface, the methods of the base class or the interface will be visible to everyone
p17860
as(dp17861
g6
V335858
p17862
stp17863
a((dp17864
g2
(lp17865
VYou should be able to simply plug in your case statement into an expression, without the  alias, of course:
p17866
as(dp17867
g6
V335858
p17868
stp17869
a((dp17870
g2
(lp17871
VYou need to pass your  as a method parameter:
p17872
aVNote that the name of your formal and actual parameter do not need to be the same
p17873
aVAlso note that  should be a class member function (i
p17874
ag630
aV), not an instance member function
p17875
aVFinally, note that printing without loops can be done using facilities of the standard C++ library:
p17876
as(dp17877
g6
V335858
p17878
stp17879
a((dp17880
g2
(lp17881
VModel-View-Controller approach suggests that the boolean value belongs in the Model code of your application
p17882
aVIt is a common thing to make your model a singleton:
p17883
aVQuizModel
p17884
ag1177
aVQuizModel
p17885
ag12457
aVNow you can use the boolean in your controller code: include , and write
p17886
aVor
p17887
as(dp17888
g6
V335858
p17889
stp17890
a((dp17891
g2
(lp17892
VThe  flag is for the compiler, not for the linker
p17893
aVIt tells the compiler that your Objective C code will be doing all the releasing and retaining manually
p17894
aVThis is necessary because the newly added ARC mode prohibits explicit use of , , , , and so on; you cannot call them even through a selector
p17895
aVConverting all your code to ARC may be a large task, so the compiler supports both the old and the new style of code
p17896
aVYou must tell the compiler if the file you're compiling is old or new; you do it by passing the  flag
p17897
aVThere are many other compiler flags
p17898
aVThey let you control the way the code is compiled and optimized, the way the errors and warnings are reported back to you, the paths where your headers are located, and so on
p17899
aVType  in the terminal window to see the list of compiler options
p17900
as(dp17901
g6
V335858
p17902
stp17903
a((dp17904
g2
(lp17905
VYou are looking for methods with variable number of parameters
p17906
aVMethods need to be declared like this:
p17907
aVInside the method you use macros to extract parameters one by one
p17908
aVThe first parameter needs to supply enough information to tell how many other parameters are passed
p17909
aVFor example,  can tell how many parameters are passed by counting unescaped  format specifiers
p17910
as(dp17911
g6
V335858
p17912
stp17913
a((dp17914
g2
(lp17915
VThis is not the way you initialize member variables in C++
p17916
aVYou need to set the value in the init list of the constructor:
p17917
aVYou can also move the initialization of your other variables into the initialization list:
p17918
as(dp17919
g6
V335858
p17920
stp17921
a((dp17922
g2
(lp17923
VThere is no notion of self-modifying code in C
p17924
aVAny attempt to pass control to a data block that is in the "data" memory, say, by casting a data pointer to a function pointer, is undefined behavior
p17925
aVThis model is there to let you program in C for non vov-neuman computers
p17926
aVThis said, you can probably optimize your RPN code to run much faster by replacing sequences of if-then-else statements with function pointers or a switch statement
p17927
aVYou could also program the target function into a dynamic library, read it at runtime, and use it in rendering
p17928
as(dp17929
g6
V335858
p17930
stp17931
a((dp17932
g2
(lp17933
VYou should be using  as your delimiter - a character constant, rather than a string literal
p17934
aVThe delimiter, second parameter of , is of type , to which a character constant can be converted implicitly; in contrast, a string literal cannot be converted to an , so that is what the compiler is telling you
p17935
as(dp17936
g6
V335858
p17937
stp17938
a((dp17939
g2
(lp17940
VYou should not be converting the  that you generated from the description to base-64
p17941
aVIt is a hex string, not the actual data bytes
p17942
aVYou should go straight from  to base-64 string, using any of the available base-64 encoders
p17943
aVFor example, you can download an implementation from this post, and use it as follows:
p17944
as(dp17945
g6
V335858
p17946
stp17947
a((dp17948
g2
(lp17949
VYou can do it like this:
p17950
aVBut you probably do not want to do it in this case
p17951
aVDeclaring an instance variable  means that the reference to the target object (a string in your case) will exist only as long as some other object holds a reference
p17952
aVWhen the last object holding a strong reference releases the string, your variable  will get -ed out automatically
p17953
aVThis is very useful when objects hold references to each other, such as in parent-child hierarchies
p17954
aVSince your  could not possibly hold a reference to your object, using the  reference for it is highly questionable
p17955
as(dp17956
g6
V335858
p17957
stp17958
a((dp17959
g2
(lp17960
VThere is a relatively straightforward way to do it - in C, use  function, like this:
p17961
aVIn C++, use :
p17962
as(dp17963
g6
V335858
p17964
stp17965
a((dp17966
g2
(lp17967
VYou can do this:
p17968
aVThis query will clear out the value  from the  in all rows that are set to
p17969
as(dp17970
g6
V335858
p17971
stp17972
a((dp17973
g2
(lp17974
VIf the number of digits is fixed as in your pattern, you can do this:
p17975
aVIf the number of digits can vary, add limits to the  elements
p17976
aVFor example, if the initial run of digits must be three to seven digits long, use
p17977
as(dp17978
g6
V335858
p17979
stp17980
a((dp17981
g2
(lp17982
VUsing exceptions for non-exceptional situations is not a great idea, especially when the exception is thrown and caught in the same method
p17983
aVA better approach would be to use a boolean variable that indicates a need for cleanup, and performing your cleanup inside a  block
p17984
as(dp17985
g6
V335858
p17986
stp17987
a((dp17988
g2
(lp17989
VThis boils down to the difference between C and C++
p17990
aVIn C it is OK to redefine a static variable with the same name and the same type; in C++, doing the same is an error
p17991
aVFrom the C standard:
p17992
aVA declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with a storage-class specifier static, constitutes a tentative definition
p17993
aVIf a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definitions for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0
p17994
aVFrom C++ standard:
p17995
aVC
p17996
ag1340
aV2, 3
p17997
aV1 Change: C++ does not have \u201ctentative de\ufb01nitions\u201d as in C
p17998
aVE
p17999
ag303
aV, at \ufb01le scope,
p18000
aVis valid in C, [but it is] invalid in C++
p18001
aVAs far as Objective C is concerned, the language does not support variables scoped at the class level; declaring  inside an  block has exactly the same effect as declaring it outside the  block
p18002
aVTo emulate class-scoped variables, use function-scoped static variables inside class methods
p18003
as(dp18004
g6
V335858
p18005
stp18006
a((dp18007
g2
(lp18008
VAll files in your project get compiled, except for the header files that are not included from any of the
p18009
aVm files, or headers the inclusion of which is suppressed conditionally
p18010
as(dp18011
g6
V335858
p18012
stp18013
a((dp18014
g2
(lp18015
VUse autorelease to avoid memory leaks when returning objects with uncertain ownership
p18016
aV's  method returns an autoreleased value already, so you do not need to do anything special in your case
p18017
aVWith objects of other classes, you can do this:
p18018
aVNote that if you use ARC you do not need to do any of this: the compiler is smart enough to figure most of it out for you
p18019
aVIn Objective C static methods of Java/C++/C# are called class methods
p18020
aVYou denote them with a  instead of  in the declaration, and remember that you cannot access instance methods from the implementation
p18021
aVIn the header:
p18022
aVIn the implementation:
p18023
as(dp18024
g6
V335858
p18025
stp18026
a((dp18027
g2
(lp18028
VCheck out clang, an open source front end to LLVM
p18029
as(dp18030
g6
V335858
p18031
stp18032
a((dp18033
g2
(lp18034
VThere is also a method number 4, which is similar to your method 1: put your data access code into a model class, and make it a singleton
p18035
aVThis is the standard way to share model state among different controllers
p18036
aVPutting all your data management code into that singleton model helps you avoid code duplication
p18037
as(dp18038
g6
V335858
p18039
stp18040
a((dp18041
g2
(lp18042
VYou are allocating  booleans, but you index that array using a variable that ranges from zero to
p18043
aVThis will be severely out of bounds for all  values greater than
p18044
aVYou should either allocate more booleans () or use a different variable to index into  (for example, , which ranges from  to )
p18045
aVI am sorry, I cannot be more precise than that because of your request not to comment on your algorithm of finding primes
p18046
ag1971
ag1972
aVIf you would like to read something on the topic of finding small primes,  here is a link to a great book by Dijkstra
p18047
aVHe teaches you how to construct a program for the first 1000 primes on pages 35
p18048
aV49
p18049
as(dp18050
g6
V335858
p18051
stp18052
a((dp18053
g2
(lp18054
VYes, this is reasonably common: because of connection pooling, an optimization technique that lets your program implicitly reuse connections to the database, this does not have as adverse an impact on performance as one might think
p18055
as(dp18056
g6
V335858
p18057
stp18058
a((dp18059
g2
(lp18060
VTry this:
p18061
aVThis is how it works:
p18062
aVFirst line splits by newline characters
p18063
aVSecond line removes empty items inserted for multiple separators in a row
p18064
aVThird line joins the strings back using a single space as the new separator
p18065
as(dp18066
g6
V335858
p18067
stp18068
a((dp18069
g2
(lp18070
VThis depends a lot on what you would like to do with them: if you plan the users of your class to be able to modify variables inside your class (a terrible and strongly discouraged thing) you can return pointers or references; otherwise, return the variable itself
p18071
aVThere is an exception to this rule when objects that you'd like to return are large, such as vectors, sets, maps, etc
p18072
aVIf you decide to make accessors to them, you should return them by constant reference
p18073
as(dp18074
g6
V335858
p18075
stp18076
a((dp18077
g2
(lp18078
VYou can do it with a loop:
p18079
as(dp18080
g6
V335858
p18081
stp18082
a((dp18083
g2
(lp18084
VI think you misunderstand the concept of character classes in regular expressions:  treats all characters after  as normal characters, not as metacharacters
p18085
aVTherefore you do not need the "OR" pipe  inside the class
p18086
aVSince the  is present in the character class, and because you are using  to invert the set, a single pipe is not matched by your regexp
p18087
as(dp18088
g6
V335858
p18089
stp18090
a((dp18091
g2
(lp18092
VThe  method applies to everything that supports Key Value Coding
p18093
aVIt lets you set a value for a property identified by a string
p18094
aVIn this particular case, the string comes from the name of the XML element the parser has finished processing, and the value comes from the text of the corresponding element
p18095
aVThe KVC trick lets you use the XML parser to set values of objects without hardcoding the names of objects' properties or methods
p18096
aVFor example, if you have a fragment of XML like this
p18097
aVand a KVC-compliant  class with  properties  and , the parser would be able to process the XML and set values of the properties without knowing anything about the structure of your XML or the structure of your  class
p18098
as(dp18099
g6
V335858
p18100
stp18101
a((dp18102
g2
(lp18103
VHere is one way of doing it using an auxiliary function:
p18104
aVNow you can use LINQ to get the items like this:
p18105
as(dp18106
g6
V335858
p18107
stp18108
a((dp18109
g2
(lp18110
VYou cannot split a structured file just like that: MP3 file has a header at the beginning of the file that describes what's inside the rest of the file
p18111
aVWhen you split your file, you get a header only in the first part
p18112
aVAs far as cutting non-structured files, say, text, your code should fare much better, as long as you do not mind your sentences split in the middle of a word
p18113
as(dp18114
g6
V335858
p18115
stp18116
a((dp18117
g2
(lp18118
VI think the key to understanding the post is in this statement:
p18119
aVSince I think it\u2019s a bad idea to use accessors during -init the copy semantics defined by the  are never used and ARC happily retains the reference instead of copying it
p18120
aVI think that Craig is talking specifically about the following case:
p18121
as(dp18122
g6
V335858
p18123
stp18124
a((dp18125
g2
(lp18126
VThe method  of  does not take parameters
p18127
aVIf you would like to set a new float number, you need to re-assign  ( does not have a mutable counterpart):
p18128
as(dp18129
g6
V335858
p18130
stp18131
a((dp18132
g2
(lp18133
VThe problem happens when you attempt treating a string as an image:
p18134
aVThe value inside the  array cannot be an image, because the array comes from a dictionary  that you read from a file using the  method
p18135
aVThis method will create objects of types , , , , , or
p18136
aVis not on the list of types that can be created by the  method, so your cast is invalid
p18137
aVFrom the error message it appears that you are getting an  instead of
p18138
aVCheck the value of that string to see what it represents: it is probably a URL, a file name, or some other form of identifier that can be used to obtain an image
p18139
aVDepending on what's in the string, change your program to load  rather based on the value of the string
p18140
aVPerhaps the code should be
p18141
aVbut it is impossible to tell for sure without knowing the value of your string
p18142
as(dp18143
g6
V335858
p18144
stp18145
a((dp18146
g2
(lp18147
VYou need to remove slashes on both sides of your pattern
p18148
aVSlashes are not metacharacters in cocoa's regular expressions, so the strings matched by your current expression would be single letters with slashes on both sides - , , , and so on
p18149
aVYou can also use a range in your character class, like this:
p18150
as(dp18151
g6
V335858
p18152
stp18153
a((dp18154
g2
(lp18155
VYou can use , like this:
p18156
aVAt this point, the array  contains 16 bytes of your key converted from hex to bytes
p18157
as(dp18158
g6
V335858
p18159
stp18160
a((dp18161
g2
(lp18162
VYou can use
p18163
aVIt is not overly C++ - ish, but it does the trick with remarkably few lines of code:
p18164
aVThe idea is to specify the characters accepted by the strings that you read using a very limited regular expression syntax
p18165
aVIn this case, the first string is read up to the plus, and the second string is read up to the equals sign
p18166
as(dp18167
g6
V335858
p18168
stp18169
a((dp18170
g2
(lp18171
VYour observation of initializing a mutable dictionary item-by-item being too long is certainly correct
p18172
aVIn fact, the upcoming version of Objective C will provide better syntax for this task:
p18173
aVHowever, there is something you can do until this nice syntax becomes available: you can prepare a dictionary the long way, save it in a file as a property list, and replace the long initialization code with a single read of plist, the way this answer to your previous question suggests:
p18174
as(dp18175
g6
V335858
p18176
stp18177
a((dp18178
g2
(lp18179
VYou can use this code:
p18180
aVYou can remove some of these checks if your constructors and setters verify that these conditions are always false
p18181
aVFor example, if you set content in the constructor and add a check to the setter to trap null assignments of , you could remove the  part
p18182
as(dp18183
g6
V335858
p18184
stp18185
a((dp18186
g2
(lp18187
VThe first operator sign-extends the value, shifting in a copy of the sign bit; the second one always shifts in a zero
p18188
aVThe reason for this is to emulate unsigned integers for the purpose of doing bit operations, partially compensating for the lack of unsigned integral types in Java
p18189
as(dp18190
g6
V335858
p18191
stp18192
a((dp18193
g2
(lp18194
VThis happens because arrays decay to pointers when they are passed to functions that take pointers as arguments
p18195
aVInside your , the
p18196
aVdeclaration is equivalent to
p18197
aVbecause the compiler has enough information to calculate the  from the aggregate initializer
p18198
aVIn the function header, however,  does not mean the same thing: there is no context around it to tell the compiler that it's anything but a pointer to an integer
p18199
as(dp18200
g6
V335858
p18201
stp18202
a((dp18203
g2
(lp18204
VIn your code you call  on line 17 before assigning  a non-null value on line 18
p18205
as(dp18206
g6
V335858
p18207
stp18208
a((dp18209
g2
(lp18210
V will return , because there are no elements called : the  call has removed them all
p18211
aVEven if it didn't, 's  method does not look at indirect descendants, so yo would need to supply the correct chain of element names leading to the element that you would like to modify
p18212
aVDid you mean to write
p18213
as(dp18214
g6
V335858
p18215
stp18216
a((dp18217
g2
(lp18218
VThere is a "bug" in the article's description of what needs to be done:
p18219
aVCalculate the perpDotProduct/crossproduct of all three points V1, V2, V3 with the testpoint P
p18220
aVshould be "Calculate the perpDotProduct/crossproduct of all three vectors with vectors to the testpoint P"
p18221
aVAs explained in the article, the algorithm returns  if all three points are visible at the same "angular direction" from the origin (the upper-left corner of your picture)
p18222
aVYour picture shows it precisely, too: vectors  for all pink points need to turn clockwise to reach the triangle if they are above the blue zone; if they are below the blue zone, the vectors would need to move counterclockwise
p18223
aVTo fix the algorithm, you need to compute cross products of vectors , , and
p18224
aVTake a look at this article for pseudocode
p18225
as(dp18226
g6
V335858
p18227
stp18228
a((dp18229
g2
(lp18230
VDo I have to store the size of each entry in an array
p18231
aVYou can use a separate storage area, or you could use the strategy that  implementations often follow: they store the size in a known location in front of the pointer that they return to you
p18232
aVWhen you call , they check the location immediately prior to the pointer that you pass in, grab the size from there, and proceed with deallocation
p18233
aVIn your case, you could push the size of the chunk right after the chunk itself
p18234
aVWhen it's time to pop the stack, pop the size first, and then pop the data chunk
p18235
aVOne thing that you need to be aware of when working with your stack is data alignment: depending on an architecture, storing multibyte types at odd offsets (offsets indivisible by four, eight, etc
p18236
aVmay cause performance degradation or bus errors
p18237
aVYou need to check your platform specifics to see if you need to introduce extra "padding" between consecutive elements pushed onto your stack
p18238
as(dp18239
g6
V335858
p18240
stp18241
a((dp18242
g2
(lp18243
VIf the lists are of the same size, you can use :
p18244
as(dp18245
g6
V335858
p18246
stp18247
a((dp18248
g2
(lp18249
VThe usual way the callback functions are passed in by Java programs is by passing instances of interfaces that implement a specific callback function
p18250
aVIt is typical, though not required, to implement the interface anonymously
p18251
aVFor example, here is an interface:
p18252
aVHere is the way you define your dialog's method that takes a callback:
p18253
aVHere is the way that you invoke that method:
p18254
as(dp18255
g6
V335858
p18256
stp18257
a((dp18258
g2
(lp18259
VYou do not need to release the memory back to the OS before the program exits, because the operating system will reclaim all memory that has been allocated to your process upon the termination of the process
p18260
aVIf you allocate an object that you need up to the completion of your process, you don't have to release it
p18261
aVWith that said, it is still a good idea to release the memory anyway: if your program uses dynamic memory a lot, you will almost certainly need to run a memory profiler to check for memory leaks
p18262
aVThe profiler will tell you about the blocks that you did not free at the end, and you will need to remember to ignore them
p18263
aVIt is a lot better to keep the number of leaks at zero, for the same reason that it is good to eliminate 100% of your compiler's warnings
p18264
as(dp18265
g6
V335858
p18266
stp18267
a((dp18268
g2
(lp18269
VI do not think the syntax on the line with  is valid
p18270
aVThis will perform the additions on a single line correctly, though:
p18271
as(dp18272
g6
V335858
p18273
stp18274
a((dp18275
g2
(lp18276
VThe proper way of setting up variables in a class is through the constructor of their class
p18277
aVDerived classes should use initializer list to set variables in their base classes
p18278
aVAlternatively, if the subclass controls the values in the base (i
p18279
ag630
aVthe user does not pass , , or  you can do this:
p18280
aVThe compiler will optimize this code to inline things properly, so you should not worry about the performance suffering from adding an extra layer of constructors
p18281
as(dp18282
g6
V335858
p18283
stp18284
a((dp18285
g2
(lp18286
VWhen you call  before calling , the  has not been initialized yet; it is still , so the assignment has no effect
p18287
as(dp18288
g6
V335858
p18289
stp18290
a((dp18291
g2
(lp18292
VSince log viewer is a read-only application of a , the way you do it is rather straightforward once you understand the basics
p18293
aVRecall that table views rely on their data models to provide them with the correct information that needs to be displayed
p18294
aVA data model for "the last fifty lines of log" could be as simple as an : use  to add lines, and  to remove the "overflow" lines, like this:
p18295
aVNow you can use  as your table's "model": the data provider can tell how many lines there are by looking at ; the content of each row in the table will be the object at the corresponding index in , and so on
p18296
aVTake a look at the  section of your favorite iOs tutorial for the "boilerplate code" that needs to be written in order to display array elements in a
p18297
as(dp18298
g6
V335858
p18299
stp18300
a((dp18301
g2
(lp18302
VYou are almost there: using an array is certainly the right thing to do
p18303
aVThe only problem is that you keep creating a new instance of the array every time you go through your  method
p18304
aVYou should make  an instance variable, and move its initialization code  to the designated initializer of the class where  is declared
p18305
aVIf you would like to give each notification that you insert an individual key by which you can find it later, use  instead of
p18306
aVRe-write the  method as follows:
p18307
aVWhen you call the  method, you'd be able to provide a key for the newly added notification, for example
p18308
aVand so on
p18309
as(dp18310
g6
V335858
p18311
stp18312
a((dp18313
g2
(lp18314
VYou can use 's  method instead of , and use formatting options to right-adjust the values that you print:
p18315
aVand so on
p18316
as(dp18317
g6
V335858
p18318
stp18319
a((dp18320
g2
(lp18321
VGiven that variables are declared only once, the  is a pointer expression, not a declaration
p18322
aVIt casts an  pointer to
p18323
as(dp18324
g6
V335858
p18325
stp18326
a((dp18327
g2
(lp18328
VYou can create a helper function to check the value for , as follows:
p18329
aVNow you can use this method in your LINQ query:
p18330
as(dp18331
g6
V335858
p18332
stp18333
a((dp18334
g2
(lp18335
VQueries return enumerations of objects of the same class
p18336
aVIt can be any class, but it needs to be just one for all rows
p18337
aVYou cannot return pairs of objects (a city and a contact name) without combining them into a single object
p18338
aVIn this case, you are combining them into an object of anonymous type, with two properties
p18339
aVOn a side note, there is no advantage to using  method at all, because both properties come from the same  class
p18340
aVIn fact, there is less efficient than returning customer objects unchanged, like this:
p18341
as(dp18342
g6
V335858
p18343
stp18344
a((dp18345
g2
(lp18346
VYou are absolutely right: assuming the same payload type (in your case it is ), the binary layout of these two node types is identical
p18347
aVIt is only the usage of the two pointers that makes the two node types different
p18348
aVIf you do not care about readability, you could use a node
p18349
aVto represent both a binary tree and a doubly linked list
p18350
aVIt wouldn't be a good idea, though, because the code would immediately become less recognizable to other programmers
p18351
as(dp18352
g6
V335858
p18353
stp18354
a((dp18355
g2
(lp18356
VThe common approach to controlling exposure of your classes to the world is hiding implementations behind interfaces and factories
p18357
aVCreate an interface for your , and a class for creating instances of  interface
p18358
aVPut the interface in the main package, and the factory in a sub-package
p18359
aVGive the factory public visibility
p18360
aVImplement the interface in the sub-package, giving it package visibility
p18361
aVCreate an instance of the class implementing the  interface in the factory
p18362
aVHere is an example of how you can do it:
p18363
aVThe users would access  like this:
p18364
as(dp18365
g6
V335858
p18366
stp18367
a((dp18368
g2
(lp18369
VYou do not need to use a subquery - simply use a  clause instead of  clause to filter by an aggregated column
p18370
as(dp18371
g6
V335858
p18372
stp18373
a((dp18374
g2
(lp18375
VIf I'm going to write test
p18376
aVone to network fd then extra zeros will be written to the fd
p18377
aVAlthough it is correct that extra bytes will be written, the content of these bytes is not necessarily going to be all zeros: it is undefined
p18378
aVIn general, reading the bytes belonging to a union that are beyond the area to which you have written some data through other fields is undefined behavior
p18379
aVIf you want to control how much data is written, you need to provide the specific type that you are writing out
p18380
as(dp18381
g6
V335858
p18382
stp18383
a((dp18384
g2
(lp18385
VYou shouldn't take what every book says for its face value: the similarities between function pointers of C and delegates of C# are rather superficial
p18386
aVComparing them feature-to-feature would produce a laundry list of differences, and the "safety" will be far from the top of that list
p18387
aVThe biggest safety problem with emulating C# delegates using function pointers is the ownership of data on which a function pointer operates
p18388
aVRecall that delegates are not restricted to static functions: you can produce a delegate from a member function, in which case the object becomes "embedded" in the delegate
p18389
aVThere is no similar functionality in C: you need to do a lot of work in order to "bind" a function pointer to a piece of data
p18390
aVIf the data becomes unavailable at some later point, and the function tries to use that data, it may trigger a crash
p18391
aVBut that difference is an attribute of garbage-collected vs
p18392
aVmanually managed memory environments
p18393
as(dp18394
g6
V335858
p18395
stp18396
a((dp18397
g2
(lp18398
VSince there hasn't been a solution so far that would literally "increment a string", here is one that does:
p18399
aVThe idea is simple: pretend that letters are your digits, and do an increment the way they teach in an elementary school
p18400
aVStart from the rightmost "digit", and increment it
p18401
aVIf you hit a nine (which is  in our system), move on to the prior digit; otherwise, you are done incrementing
p18402
aVThe obvious special case is when the "number" is composed entirely of nines
p18403
aVThis is when your "counter" needs to roll to the next size up, and add a "digit"
p18404
aVThis special condition is checked at the beginning of the method: if the string is composed of  letters , a string of  letter s is returned
p18405
aVHere is a link to a quick demonstration of this code on ideone
p18406
as(dp18407
g6
V335858
p18408
stp18409
a((dp18410
g2
(lp18411
VSure - you can compare the results of  right in the  statement:
p18412
as(dp18413
g6
V335858
p18414
stp18415
a((dp18416
g2
(lp18417
VI think the cleanest alternative would be to make a separate library for the shared
p18418
aVThe drawbacks are that your users would need to link  along with  and/or , and that in order to link  and  together both libraries need to be compiled with the same version of
p18419
aVIn return, the source of the libraries would stay nice and clean
p18420
aVAn alternative would be to use macros to alter function and variable names in the  to avoid linker errors
p18421
aVThe most important consequence of this is code duplication: both  and  would link identical pieces of code under different names
p18422
aVThe other one is readability: it would suffer tremendously, because each reference to a function in  would need to be wrapped in a macro
p18423
aVThis makes the second approach dirty, so I would definitely recommend making  a separate library
p18424
as(dp18425
g6
V335858
p18426
stp18427
a((dp18428
g2
(lp18429
VYou should use a date in the distant future for the second argument of  when it is used to compare the minimum
p18430
aVOtherwise, the first  would make  the minimum, and since it's the earliest possible date, no other date would be able to beat it to become the minimum
p18431
aVIf you change the forth line of your query to
p18432
aVyou should get correct results
p18433
as(dp18434
g6
V335858
p18435
stp18436
a((dp18437
g2
(lp18438
VYou can use  to mask the condition, like this:
p18439
aVIf the  is , the OR  will succeed immediately, and the AND  will be true (assuming that we've got to evaluating the OR , the left-hand side of the AND  must have been true)
p18440
aVIf the  is , on the other hand, the  would need to be evaluated in order to finish evaluating the condition
p18441
as(dp18442
g6
V335858
p18443
stp18444
a((dp18445
g2
(lp18446
VThe memory for C functions is always allocated from the code segment at the time the functions are loaded into memory
p18447
aVIf a function belongs to a dynamically linked library, the program may load and unload it at arbitrary times
p18448
as(dp18449
g6
V335858
p18450
stp18451
a((dp18452
g2
(lp18453
VYour  class should extend  rather than
p18454
aVprovides a  property, while  does not, triggering the "unrecognized selector" crash
p18455
as(dp18456
g6
V335858
p18457
stp18458
a((dp18459
g2
(lp18460
VTheoretically, you could do modifications faster under the condition that the lengths of the string representation of your new value takes up precisely as many characters as that of the old value
p18461
aVHowever, this would be a bad case of micro-optimization: unlike a database where rewriting an entire table may take considerable time, rewriting a plist in its entirety should go unnoticed, as far as the timing is concerned
p18462
aVYour code to locate and overwrite the old value in a file would not be pretty by any standard
p18463
aVIt has no chance of matching the clarity of a three-line "read-modify-write" code fragment that rewrites the whole thing
p18464
aVThis assumes that you are using your property list for its intended purpose, which is storing relatively small amounts of data
p18465
aVIf you are using a plist to store moderate to large amounts of data, perhaps you need to switch to using a database, where updating individual rows is permitted
p18466
as(dp18467
g6
V335858
p18468
stp18469
a((dp18470
g2
(lp18471
VPrimitive variables are passed by value, so the changes to the  parameter will be lost as soon as the method exits
p18472
aVIf you would like to preserve the change, return  from your method, and assign it to the , like this:
p18473
aVYou can also create your own mutable class that encapsulates a , and lets its users get and set its value
p18474
as(dp18475
g6
V335858
p18476
stp18477
a((dp18478
g2
(lp18479
VUnlike Java where  objects represent instances of time,  is a class that lets you perform operations on  objects, without representing a particular point in time at all
p18480
aVYou can use an instance of  to split an  into date components (day, month, hour, etc
p18481
aVaccording to a specific calendar, to add a number of time units to an , or compose a bunch of date-time components into an
p18482
aVYou could then convert the  to a string using
p18483
as(dp18484
g6
V335858
p18485
stp18486
a((dp18487
g2
(lp18488
VYes - you can do it by inverting the flow: instead of your code doing something when the instance of the base class is of a specific type, pass an action item to the object, and let the object decide whether to perform it or not
p18489
aVThis is the basic trick behind the Visitor Pattern
p18490
as(dp18491
g6
V335858
p18492
stp18493
a((dp18494
g2
(lp18495
VYou can try multiplying the flags indicating zero counts together
p18496
aVIf any of them is zero, the result will be zero
p18497
aVIf you would like to know which table has all zeros, you could transform the query as follows:
p18498
aVUse powers of two (1, 2, 4, 8, 16, 32, and so on) as your flags
p18499
aVOnes  in the binary representation of the result will tell you which tables have no records
p18500
as(dp18501
g6
V335858
p18502
stp18503
a((dp18504
g2
(lp18505
VIf you open the writer like this
p18506
aVit should open in append mode
p18507
as(dp18508
g6
V335858
p18509
stp18510
a((dp18511
g2
(lp18512
VStart by self-joining on
p18513
aVGroup by  and
p18514
aVSelect  and
p18515
aVTranslating this to SQL is mechanical:
p18516
as(dp18517
g6
V335858
p18518
stp18519
a((dp18520
g2
(lp18521
VIn order to play nicely with  your  class must implement a  and  methods
p18522
aVOtherwise, equal roles may get recorded twice in the dictionary, or querying by a valid key may fail
p18523
aVHere is a brief sample of how you could implement your / when your class has an identifying member:
p18524
as(dp18525
g6
V335858
p18526
stp18527
a((dp18528
g2
(lp18529
VEnsuring that a string represents a valid serialized object is nearly as hard as performing deserialization itself, because you would need to walk the serialized object graph, figuring out where each serialized field starts, and what would be the data that goes into that field
p18530
aVThe only operations that you could save are the allocations of the object and its dependents
p18531
aVThese operations are certainly not free, but they are highly optimized, so your savings are not going to be overly significant
p18532
aVInstead of pre-validating the string before deserialization, you could take a speculative approach, and assume that your deserialization will succeed
p18533
aVYour code could jump right into deserializing your string, and in most cases it will succeed
p18534
aV* To ensure that your code does not break when the string is invalid, wrap deserialization calls into a , and watch for deserialization exceptions
p18535
aVIf you catch any of them, you know that the string was invalid; if you do not catch deserialization exceptions, you would know that the string is valid, and you would also have your deserialized object ready for use
p18536
aVAssuming XML serialization, your code could do something like this:
p18537
aV* If your deserialization fails the overwhelming majority of the time, you may need to re-think this strategy
p18538
as(dp18539
g6
V335858
p18540
stp18541
a((dp18542
g2
(lp18543
VSince you cannot instantiate an abstract class, passing one by value is almost certainly an error; you need to pass it by pointer or by reference:
p18544
aVor
p18545
aVPassing by value will result in object slicing, with is nearly guaranteed to have unexpected (in a bad way) consequences, so the compiler flags it as an error
p18546
as(dp18547
g6
V335858
p18548
stp18549
a((dp18550
g2
(lp18551
VSurprisingly, it does have a meaning: it's an indexing into an array of characters that represent a string literal
p18552
aVIncidentally, this particular one indexes at , which is outside the limits of the literal, and is therefore undefined behavior
p18553
aVYou can construct an expression that works following the same basic pattern:
p18554
aVwill have the same effect as
p18555
as(dp18556
g6
V335858
p18557
stp18558
a((dp18559
g2
(lp18560
VIt appears from your comment that your  loads just fine, but it does not get a chance to refresh itself on the screen until you exit your method
p18561
aVIt is not enough to set a break point inside the method and wait for the view to load: you must exit the method before iOS realizes that it needs to call 's  method
p18562
aVTo fix this, split your method in three parts,   and , and set 's delegate in  to invoke  on , and the delegate in  to call
p18563
aVHere is how to implement this: start with a delegate that can call a selector when the loading has completed:
p18564
aVNow split your method into three parts - loading the first page, loading the second page, and loading the third page:
p18565
as(dp18566
g6
V335858
p18567
stp18568
a((dp18569
g2
(lp18570
VConsider sets of individual servers associated with each time segment
p18571
aVYou are looking to construct a subset of these sets such that its union included all servers
p18572
aVThis is known as the Set cover problem, which has been shown to be NP-complete
p18573
aVThis means that you cannot do better than the brute force approach that you described in your question, so keep the number of unique windows from all hosts as low as possible
p18574
ag1971
ag1972
aVI am not sure why templatetypedef deleted his answer - I think it was correct
p18575
as(dp18576
g6
V335858
p18577
stp18578
a((dp18579
g2
(lp18580
VThe keyword  in C# means a compile-time constant
p18581
aVIt is different from C++ and C, where the same keyword requires only a run-time const-ness
p18582
as(dp18583
g6
V335858
p18584
stp18585
a((dp18586
g2
(lp18587
VRecall that you can list the nodes of a BST in reverse order by doing a modofied inorder traversal where you explore the right subtree first
p18588
aVThis leads to a simple algorithm:
p18589
as(dp18590
g6
V335858
p18591
stp18592
a((dp18593
g2
(lp18594
VStatic members of the class are initialized in arbitrary order upon your program's start-up
p18595
aVThe  in the class is a declaration of your static variable, while  is its definition
p18596
aVAll definitions in C++ require to specify a type
p18597
aVThe fact that the definition of the count appears to have occurred in the file scope, the actual scope of the  remains private, as declared
p18598
as(dp18599
g6
V335858
p18600
stp18601
a((dp18602
g2
(lp18603
VBlock variables are copied to the heap automatically by ARC compilers:
p18604
ag838
ag10442
aVBlocks
p18605
aV__block variables of retainable object owner type are moved off the stack by initializing the heap copy with the result of moving from the stack copy
p18606
aVEDIT I think I misunderstood the question: you asked about block objects themselves, not block variables
p18607
aVThe answer in this case is slightly different, but it boils down to the same this: ARC does the correct thing automatically
p18608
aVARC knows that block literals must be copied if they're used after the current scope returns
p18609
aVNon-ARC code needs to explicitly copy and autorelease returned blocks:
p18610
aVWith ARC, this simply becomes:
p18611
aV(from here)
p18612
as(dp18613
g6
V335858
p18614
stp18615
a((dp18616
g2
(lp18617
VI think the major reason for the big difference is that the OS manages to cache almost the entire 1GB write that you do in small chunks
p18618
aVYou need to change the way your benchmark is set up: the code should write the same data, first time in 1024 chunks, and the second time in one chunk
p18619
aVYou also need to turn off the caching of data in the OS by specifying , like this:
p18620
aVWhen you run this code, the results look as follows:
p18621
as(dp18622
g6
V335858
p18623
stp18624
a((dp18625
g2
(lp18626
VYes, it is generally bad to expose an object as a public static variable, because everybody has a write access to it
p18627
aVMaking the variable  make it slightly better, but the best solution would be to make your variable , and provide a static getter
p18628
as(dp18629
g6
V335858
p18630
stp18631
a((dp18632
g2
(lp18633
VYour current solution produces strings that are 3
p18634
aV4 times longer than what's in the file because it concatenates decimal character codes into a string
p18635
aVJava provides a way of reading strings from streams without the need for writing loops, like this:
p18636
as(dp18637
g6
V335858
p18638
stp18639
a((dp18640
g2
(lp18641
VYour implementation is terribly inefficient to start with: rather than continuing the deletions recursively, you could change your loop to not advance if an object has been deleted, like this:
p18642
aVYou could do the same thing using , like this:
p18643
as(dp18644
g6
V335858
p18645
stp18646
a((dp18647
g2
(lp18648
VYour guideline is good enough as it is: it already says "wherever possible"
p18649
aVSo the task is really to spell out the "wherever possible" bit in some more details
p18650
aVI use this simple dichotomy: if the purpose of adding a method is to hide the differences among subclasses, use an extension method; if the purpose is to highlight the differences, use a virtual method
p18651
aVYour  method is an example of a method that introduce a difference among subclasses: the process of eating (or not) an apple depends on what kind of apple it is
p18652
aVTherefore, you should implement it as an instance method
p18653
aVAn example of a method that tries to hide the differences would be :
p18654
aVIf the process of throwing away an apple is the same regardless of the kind of the apple, the operation is a prime candidate for being implemented in an extension method
p18655
as(dp18656
g6
V335858
p18657
stp18658
a((dp18659
g2
(lp18660
VYour first way of passing the  is correct
p18661
aVThe compiler recognizes that the vector is passed to the function by reference from the signature in the header, makes a reference to your vector, and passes it to the function
p18662
aVThe fact that you see linker errors tells you that the compile stage completed successfully
p18663
aVThe linker error is there because you are failing to include the library where the  function is implemented
p18664
as(dp18665
g6
V335858
p18666
stp18667
a((dp18668
g2
(lp18669
VAbsolutely - you can create arrays of arrays, or even arrays of arrays of arrays, and so on
p18670
aVAll you need is to add more pairs of square brackets
p18671
as(dp18672
g6
V335858
p18673
stp18674
a((dp18675
g2
(lp18676
VIt depends on how you implement it
p18677
aVThere are two ways you can go about doing it:
p18678
aVUsing  or  In this case it's , because the ownership spec of the property trumps the ownership spec of the ivar1
p18679
aVManually writing  and
p18680
aVIn this case, the result will depend on the kind of backing variable that you choose for your implementation
p18681
ag839
aVHere is a link to the documentation that spells out the rules of how the ownership of properties is determined
p18682
aVSee Section 4
p18683
ag1340
ag1340
aV1 If the associated instance variable already exists, then its ownership qualification must equal the ownership of the property; otherwise, the instance variable is created with that ownership qualification [of the property]
p18684
aV2 A property's specified ownership is preserved in its metadata, but otherwise the meaning is purely conventional unless the property is synthesized
p18685
as(dp18686
g6
V335858
p18687
stp18688
a((dp18689
g2
(lp18690
VThis syntax means that an id variable adopts the protocol called MenuDelegate
p18691
aVThe syntax looks strange to me as well, but not as strange as that for calling methods
p18692
as(dp18693
g6
V335858
p18694
stp18695
a((dp18696
g2
(lp18697
VAssuming that  throws an exception when validation fails (it's the only option, since the method is ), you are missing a try/catch block inside your  loop:
p18698
aVOnce the exception is logged or otherwise processed in the  block, your loop will continue its iterations from where it left off
p18699
as(dp18700
g6
V335858
p18701
stp18702
a((dp18703
g2
(lp18704
VYou can think of generic type instances (e
p18705
ag303
aV) as of classes created from generic type definitions (e
p18706
ag303
aV) by literally replacing the name  with the name
p18707
aVThe type is not "erased" the way it is done in some languages (most notably, Java), it is kept with the generic type instance, so that all variables declared as type  in the generic type definition remain strongly typed in the generic type instance
p18708
aVIn case of a , there is no cast to or from  as long as you insert objects that are known to be of  type at compile time
p18709
aVThis is the case in the code from your post, but it may not always be true
p18710
aVFor example, when you insert a dynamically typed object, the compiler will add a cast:
p18711
as(dp18712
g6
V335858
p18713
stp18714
a((dp18715
g2
(lp18716
VThese are not compilation errors, these are link errors
p18717
aVYour sources compiled fine, but you did not supply implementations of the three virtual functions in the base class
p18718
aVWhen you mentioned a member function in a class declaration, all you did was declaring the function: you told the compiler what's the name of the function, what are its parameter types, and what's its return type; this makes the compiler happy
p18719
aVYou still need to supply some implementation, or mark the functions abstract, in order to satisfy the linker
p18720
aVIn your cpp file with the implementation of  add these:
p18721
aVAlternativelt, if there is no default implementation for some or all of these virtual functions, add  in the header:
p18722
as(dp18723
g6
V335858
p18724
stp18725
a((dp18726
g2
(lp18727
VThe assignment will not work, because the  type is not assignment-compatible with
p18728
aVHowever, the parameters of the two functors are compatible, so you can add a wrapper to make it work:
p18729
as(dp18730
g6
V335858
p18731
stp18732
a((dp18733
g2
(lp18734
VThe other answers show you a great way to perform the whole update entirely in RDBMS
p18735
aVIf you can do it like that, that's the perfect solution: you cannot beat it with a C# / RDBMS combination because of extra roundtrips and data transfer issues
p18736
aVHowever, if your update requires some calculations that for one reason or the other cannot be performed in RDBMS, you should modify your code to construct a single parameterized update in place of a potentially gigantic 150000-row update that you are currently constructing
p18737
aVThe idea is to make 150,000 updates that look the same into a single parameterized update that is actually a single statement
p18738
as(dp18739
g6
V335858
p18740
stp18741
a((dp18742
g2
(lp18743
VARC will insert a call to  when you set a  variable that references an object to
p18744
aVThe same thing is done when you have a C-style array of objects: setting an element of your array to  releases the item that was there unless it was /
p18745
aVIf you keep child view controllers in an , removing an object from the array decrements its reference count
p18746
as(dp18747
g6
V335858
p18748
stp18749
a((dp18750
g2
(lp18751
V is transitive, which is a fancy way of saying that if  and , then  as well
p18752
aVFor example, the compiler will have no problems with the following code:
p18753
as(dp18754
g6
V335858
p18755
stp18756
a((dp18757
g2
(lp18758
VYou cannot store multiple selectors in one selector, but making an array of selectors is a perfectly valid thing to do
p18759
aVThe simplest way would be to store string representations of your selectors in an , and create selectors from strings in the code that iterates over the array
p18760
aVAnother options besides selectors would be using blocks
p18761
aVBlocks are very good at encapsulating actions, too, and you do not need to store their target separately
p18762
as(dp18763
g6
V335858
p18764
stp18765
a((dp18766
g2
(lp18767
VYou cannot add items to arrays at will, because arrays are of fixed size
p18768
aVYou need to convert the array to a list first, then add items to te list, and finally convert the list back to array:
p18769
as(dp18770
g6
V335858
p18771
stp18772
a((dp18773
g2
(lp18774
VNo, you do not need to create copy
p18775
aVInstead, add a reference to  in the
p18776
aVRight-click [References->Add Reference
p18777
aVin , pick the "Projects" tab, select , and click [OK]
p18778
as(dp18779
g6
V335858
p18780
stp18781
a((dp18782
g2
(lp18783
VWhat's confusing me is that I was under the impression that when I declared the class as static, everything within the class should automatically be static as well
p18784
aVAll members of a static class must indeed be static, but it is not happening automatically: you must explicitly declare all the members static
p18785
aVThe purpose of declaring a class static is to let the compiler perform a check that all members are static, and to prevent any attempt at creating an instance of your static class
p18786
as(dp18787
g6
V335858
p18788
stp18789
a((dp18790
g2
(lp18791
VYou cannot pass a pointer to non-static member function as a pointer to a "regular" non-member function
p18792
aVYou should either make  static, or make  typedef a pointer to member function
p18793
aVNote that invoking a pointer to member function is different from invoking a function pointer, because you must supply an instance on which the member pointer is to be invoked
p18794
as(dp18795
g6
V335858
p18796
stp18797
a((dp18798
g2
(lp18799
VThe major pointer issue in your program is that when  is passed to  for the first time, its value is uninitialized
p18800
aVThis is undefined behavior
p18801
aVYou should initialize the pointer to , like this:
p18802
aVThe other problem is comparing strings: you need to use  rather than
p18803
aVRemember that  returns zero when strings are equal
p18804
aVThere are also memory leaks at the end of your program
p18805
aVYou should free , along with the words that are stored inside its elements
p18806
aVOf course the thing that you call  behaves precisely like a dynamic array
p18807
aVProgramming a hash table in C presents a different level of challenge, however, so I would encourage you to make your current approach work
p18808
as(dp18809
g6
V335858
p18810
stp18811
a((dp18812
g2
(lp18813
VThe shortest way would be to re-write it as one line, but it is not the most efficient:
p18814
aVYou should make the array a static readonly variable, and use it in your function:
p18815
as(dp18816
g6
V335858
p18817
stp18818
a((dp18819
g2
(lp18820
VIn SQL insert statements do not have a  clause (which makes sense, because the record is not there yet)
p18821
aVYou put the IDs together with all other values if you would like to insert a new record, or use an  statement if you would like to change an existing record
p18822
aVor
p18823
as(dp18824
g6
V335858
p18825
stp18826
a((dp18827
g2
(lp18828
VSince you cannot store s in an array, the line
p18829
aVis not doing what you think it should
p18830
aVYou need to pull the data from , not cast to
p18831
aVThe reason why the log output is correct is a bit funny: you made two mistakes in a row
p18832
aVFirst, you re-interpreted a pointer as an , and then you let  re-interpret it as an object again by adding a format specifier  that is incompatible with , but works fine with pointers
p18833
aVSince the  value contains a pointer to ,  produces the "correct" output
p18834
as(dp18835
g6
V335858
p18836
stp18837
a((dp18838
g2
(lp18839
VAssuming that I understood your question correctly, this should work:
p18840
aVis a comparator class that disregards the case when comparing strings
p18841
as(dp18842
g6
V335858
p18843
stp18844
a((dp18845
g2
(lp18846
VIf the number of entries is odd, your  will end up being , so when the next loop iteration dreferences it, your program is going to crash
p18847
aVYou should modify your condition to account for that:
p18848
aVComparing with  is optional in C, so you can skip the  to shorten the condition
p18849
aVOf course passing the  parameter through a global variable is unorthodox, to say the least
p18850
aVIt would be much better to pass it as a regular function parameter
p18851
as(dp18852
g6
V335858
p18853
stp18854
a((dp18855
g2
(lp18856
VIf you are trying to invoke an override from inside your initializer, it is not going to work
p18857
aVThe reason for it is easy to understand: since the override belongs to a subclass, and because the superclass instance initialization needs to be complete before the subclass initialization can start, calling a derived method would have violated the rules that by the time a "regular" method is called the initialization of the instance has completed
p18858
aVGenerally, calling virtuals from Java or C# constructors is not a good idea, for the same exact reason
p18859
aVIn C++, calling virtuals from a constructor redirects to the implementation in the cosntructor's own class (i
p18860
ag630
aVthe same thing that you observe in Objective C)
p18861
aVUnlike C# and Java where overriding static methods is not allowed, Objective C lets you provide class-specific implementations of class methods
p18862
aVYou can use this mechanism to achieve what you are trying to do: define a class method in the derived class, and call it from the base class, like this:
p18863
aVWhen you call
p18864
aVyou see
p18865
aVin the log
p18866
as(dp18867
g6
V335858
p18868
stp18869
a((dp18870
g2
(lp18871
VBit-shifting throws away the last two binary digits, not decimal digits
p18872
aVIt is equivalent to integer division by four
p18873
aVYou need to int-divide by 100 to throw away the last two decimal digits
p18874
aV101111000110000101001110bin = 12345678dec
p18875
aV101111000110000101001110bin >> 2dec = 1011110001100001010011bin
p18876
aV1011110001100001010011bin = 3086419dec
p18877
as(dp18878
g6
V335858
p18879
stp18880
a((dp18881
g2
(lp18882
VIf you look at the problem from the other end (quite literally
p18883
aVyou get an expression that looks for terminators, rather than for the content
p18884
aVThis expression worked a lot better:
p18885
aVHere is a link to this program on ideone
p18886
as(dp18887
g6
V335858
p18888
stp18889
a((dp18890
g2
(lp18891
VThe line  is equivalent to , the length of the initial string in your  array
p18892
aVAt the point where you have just allocated your array, the result is always zero; in other instances, it is the length of the first string
p18893
aVA preferred way of making containers in C++ is  or
p18894
aVIn your case using  is more appropriate, because your code allocates the  dynamically
p18895
as(dp18896
g6
V335858
p18897
stp18898
a((dp18899
g2
(lp18900
VNow that you have all entries and the sum, you are almost there:
p18901
aVYou need another loop to go over entries one at a time
p18902
aVTo calculate percentage, multiply the entry by , and then divide by the
p18903
aVNote the dot zero at the end of  - it's there on purpose
p18904
aVIf you are on Java 5 or later, a very convenient way of printing out a number followed by percentage sign is
p18905
aVNote, however, that the percent sign  needs to be escaped
p18906
as(dp18907
g6
V335858
p18908
stp18909
a((dp18910
g2
(lp18911
VOne major issue in your code is your use of : since  is immutable, the code should assign the result returned from the method to the original string, like this:
p18912
aVWhen you need to concatenate multiple strings dynamically, a better approach is to use
p18913
aVThis is a subclass of  which lets you append other strings like this:
p18914
aVYou can avoid appending strings altogether by using the  method
p18915
aVStarting the stack with the content of the program is not the right thing to do either: you should go through the  symbols one by one, push numbers, and process operations by popping two last items, inserting the operation between the left and the right sides, adding parentheses around it, and pushing it back onto the stack
p18916
as(dp18917
g6
V335858
p18918
stp18919
a((dp18920
g2
(lp18921
VDeclaring a class is not enough, you need an instance of class  to access its variables
p18922
aVFor example, you can add a declaration of member variable to class , like this:
p18923
aVNow you can access  like this:
p18924
aVThe other problem in your code is lack of definition of a declared static variable
p18925
aVYou need to add this to your CPP:
p18926
as(dp18927
g6
V335858
p18928
stp18929
a((dp18930
g2
(lp18931
VUse  and :
p18932
as(dp18933
g6
V335858
p18934
stp18935
a((dp18936
g2
(lp18937
VUse  to sort array  on keys from array
p18938
as(dp18939
g6
V335858
p18940
stp18941
a((dp18942
g2
(lp18943
VLambdas and other delegates are implemented as closures, special objects created by the compiler that combine a method of your lambda with all the data that the lambda needs to complete its execution
p18944
aVThe values of all local variables and parameters that are used inside the lambda are implicitly captured as data members of the closure, so they remain available until the lambda itself is no longer referenced
p18945
aVYou can think of the closure as a special anonymous class created specifically for your lambda
p18946
aVIn your case, a closure may look like this:
p18947
aVThe compiler makes this class invisibly for you, and then inserts its use into your code:
p18948
as(dp18949
g6
V335858
p18950
stp18951
a((dp18952
g2
(lp18953
VC arrays always decay to pointers when passed to a function or a method, so it is not copied in your example
p18954
aVA pointer to  is automatically a pointer to an array of , by virtue of the operator  being applicable to all pointers
p18955
aVSince your method does not modify the array, you may want to add  to highlight this fact in your API; other than that, your method is fine
p18956
as(dp18957
g6
V335858
p18958
stp18959
a((dp18960
g2
(lp18961
VThe problem with your code is that when you remove an item at index  and move to the next index , the item that was at  is never examined
p18962
aVThe best way of filtering a mutable array is using the  method
p18963
aVHere is how you use it:
p18964
as(dp18965
g6
V335858
p18966
stp18967
a((dp18968
g2
(lp18969
VIf I create an int, then do I need to call free(myint) or will the variable be destroyed automatically at the end of my function
p18970
aVIt depends on how you do it: automatic variables of primitive types are deallocated when they do out of scope:
p18971
aVIf you allocate your primitive using  or , you must use  at the end (I don't know why you'd want to use primitives like this, though):
p18972
aVSame rules are followed when you add primitive fields to your objects: if you use  in the , then you must use  in
p18973
aVOtherwise, the value is allocated "in line" with the rest of your object, and do not need separate deallocation
p18974
as(dp18975
g6
V335858
p18976
stp18977
a((dp18978
g2
(lp18979
VThe problem with passing by value in this case is that all assignments made to the formal argument inside the function are not visible to the caller
p18980
aVTherefore, this assignment
p18981
aVhas no effect on the  in the caller:
p18982
aVThe value of the  pointer in the function is changed, and then promptly discarded; tree's  remains
p18983
aVA fix to this problem would be passing a pointer to a pointer, like this:
p18984
as(dp18985
g6
V335858
p18986
stp18987
a((dp18988
g2
(lp18989
Vwhy isn't the top element just removed and then other elements can "fill in" for the the heap
p18990
aVThe reason for this is that the index of an element plays an important role in maintaining the structure of the heap
p18991
aVThe two children of an element at index  are located at indexes  and
p18992
aVIf you "just remove" the top element, you wouldn't end up with another heap: the indexes  and  would no longer contain children of the  element, because the  element would no longer be there
p18993
aVIn a sense, you will end up with two "broken" heaps instead of a properly working one
p18994
aVYou must replace the value at index zero, otherwise the indexing scheme among the remaining elements is going to break down
p18995
aVWhile removing an element from the top cannot go unnoticed, removing the one at the bottom is OK: all you need to do is to make a note that the smallest element is at  instead of
p18996
aVSo the sequence of operations becomes as follows:
p18997
aVRemove the element that can be removed safely
p18998
aVPut it in place of the element that cannot be removed safely
p18999
aVPercolate the element down the heap until it settles, picking the higher of its two parents at each step
p19000
as(dp19001
g6
V335858
p19002
stp19003
a((dp19004
g2
(lp19005
VWhen the  statement is executed, the method relinquish control to its caller
p19006
aVThat is why the  will not run; that's why the compiler complains
p19007
aVUnreachable statements are certain and reliable indicators of a logical error in your program
p19008
aVIt means that you put in statements that will not be executed, but you assume that they would be
p19009
aVThe compiler analyzes the flow, and reports these statements to you as error messages
p19010
as(dp19011
g6
V335858
p19012
stp19013
a((dp19014
g2
(lp19015
VYou can use this piece of code that uses only integers:
p19016
as(dp19017
g6
V335858
p19018
stp19019
a((dp19020
g2
(lp19021
VYou need to do math to calculate the correct point for the right alignment
p19022
aVUse  to calculate the width of the attributed string, subtract it from the width of the rectangle in which you would like it painted, and add the difference to the left coordinate of the point that you pass to the  method
p19023
as(dp19024
g6
V335858
p19025
stp19026
a((dp19027
g2
(lp19028
VMost computers for many decades provide addressing modes that let you specify the address as a combination of a base and an offset, and the actual calculation is carried out in the hardware for no additional cost in CPU clock cycles
p19029
aVMore recent (past few decades) computers offer hardware for virtualizing memory layout, meaning that even through the physical address of an item is different on every run, its address in the virtual address space remains the same
p19030
aVAgain, there is no additional cost for using the base address, because the calculations are performed implicitly and invisibly to the executing binary code of a program
p19031
as(dp19032
g6
V335858
p19033
stp19034
a((dp19035
g2
(lp19036
VThe  method adjusts the date for the time zone, formats it using a format string that chops off the time zone, and parses the formatted string back
p19037
aVThe resulting  is in the UTC time zone (the  in  indicates UTC time)
p19038
aVThe  method uses  that is set up for the local time zone, producing a different time
p19039
aVYou should set the formatter to use UTC to get the correct time: replace
p19040
aVwith
p19041
aVin the  method
p19042
as(dp19043
g6
V335858
p19044
stp19045
a((dp19046
g2
(lp19047
VA semicolon is an empty statement
p19048
aVYou can use it when evaluating the continuation condition of your  loop has a side effect: the loop will produce a chain of side effects that invalidate the loop condition upon completion, or run forever
p19049
aVFor example, if  gets you a new image every time you call it, the loop will continue until the returned image has width that is
p19050
aVHere is a simple example of using a  loop to find the first character after  in a string:
p19051
aVSince reading code like that may be confusing, it is typical to place the semicolon on a separate line, indented as a loop statement
p19052
as(dp19053
g6
V335858
p19054
stp19055
a((dp19056
g2
(lp19057
VSince you are writing the result into a variable that is different from the original, only the last letter gets replaced
p19058
aVYou should either write to the same box, or write to a temp string, and write it to the second box at the end
p19059
aVGenerally speaking, this is not the most efficient algorithm to do replacements, because it operates on an immutable string
p19060
aVYou would be better off creating a mutable string builder, and writing it one character at a time
p19061
as(dp19062
g6
V335858
p19063
stp19064
a((dp19065
g2
(lp19066
VThis is absolutely fine, as long as both sides of the conditional are expressions that can be used to initialize a reference (e
p19067
ag303
aVvariables, pointer dereferences, etc)
p19068
as(dp19069
g6
V335858
p19070
stp19071
a((dp19072
g2
(lp19073
VThe correct answer is the one that you marked
p19074
aVYou will be able to tell that  is a , but you wouldn't be able to get the type of its erased argument
p19075
aVThe remaning choices do not make sense
p19076
as(dp19077
g6
V335858
p19078
stp19079
a((dp19080
g2
(lp19081
VYou can do it like this:
p19082
aVThe second  is for the "all statuses" attribute: set it to  if you want to ignore the status; set it to zero if you would like the specific  to be considered
p19083
as(dp19084
g6
V335858
p19085
stp19086
a((dp19087
g2
(lp19088
VThese are instance methods, not class methods
p19089
aVTherefore you should use the name of the variable  to invoke them on the instance, rather than the name of the class :
p19090
aVIn general, all methods declared with a  in front take a variable with an instance of that class; methods declared with a  take the class name
p19091
aVThere is also an alternative syntax that you can use if  and  are declared as properties: you can write
p19092
aVThis is only a different syntax for the same thing, though; the setter methods will be invoked in both cases
p19093
as(dp19094
g6
V335858
p19095
stp19096
a((dp19097
g2
(lp19098
VYou can write a generic function with a  constraint on the type argument:
p19099
aVYou can now call this method like this:
p19100
as(dp19101
g6
V335858
p19102
stp19103
a((dp19104
g2
(lp19105
Vthis is just an example
p19106
aVthere maybe be pointers instead
p19107
aVIf you can switch to using pointers, you could replace header inclusions with forward declarations:
p19108
as(dp19109
g6
V335858
p19110
stp19111
a((dp19112
g2
(lp19113
VThe  loop on a  enumerates key-value pairs
p19114
aVThe key is in ; the value (i
p19115
ag630
aVyour target inner dictionary) is
p19116
as(dp19117
g6
V335858
p19118
stp19119
a((dp19120
g2
(lp19121
VAssuming that the other executable is a
p19122
aVNET application, load it into a new  and run it there
p19123
aVWhen the target executable throws an exception, you get
p19124
as(dp19125
g6
V335858
p19126
stp19127
a((dp19128
g2
(lp19129
VIt looks like your first token is a string, and the second token is a long
p19130
aVYou can use  to copy  into , and then  to parse an  to
p19131
as(dp19132
g6
V335858
p19133
stp19134
a((dp19135
g2
(lp19136
VStarting with Java-5,  is a generic container, meaning (in very plain terms) that you can specify the type of the element that you are planing to store, and have the compiler check that type for you automatically
p19137
aVUsing it without the type of the element is OK, but it triggers a warning
p19138
aVThis should get rid of the warning, and provide additional type safety checks:
p19139
aVAnother thing to note about vectors is that they are synchronized containers
p19140
aVIf you are not planning to use the fact that they are synchronized, you may be better off with  containers
p19141
as(dp19142
g6
V335858
p19143
stp19144
a((dp19145
g2
(lp19146
VWhat am I missing here
p19147
aVYou are missing a call to the designated initializer of the superclass, an assignment to , and a  statement
p19148
aVYour minimal unfinished constructor should look like this:
p19149
as(dp19150
g6
V335858
p19151
stp19152
a((dp19153
g2
(lp19154
VThere is no difference: the instance variable that you declare will be used, and its ARC properties will be overridden by these of your declared
p19155
aVA property's specified ownership is preserved in its metadata, but otherwise the meaning is purely conventional unless the property is synthesized
p19156
aVIf a property is synthesized, then the associated instance variable is the instance variable which is named, possibly implicitly, by the @synthesize declaration
p19157
aVIf the associated instance variable already exists, then its ownership qualification must equal the ownership of the property; otherwise, the instance variable is created with that ownership qualification
p19158
aVDeclaring an instance variable for a property that you intend to  is best avoided
p19159
aVIf you prefer an instance variable with a different name, you can use the synthesize syntax with the ivar name:
p19160
as(dp19161
g6
V335858
p19162
stp19163
a((dp19164
g2
(lp19165
VThe best thing for the developer to do is to use the latest command line SVN client
p19166
aVSince the developer is getting the  error, he has installed the command line tools with the new SVN client for sure; Xcode integration is merely a convenience, not a requirement
p19167
aVYou can integrate with the latest SVN using this answer, but it uses a back door way of integrating SVN with XCode, and is not guaranteed to work
p19168
as(dp19169
g6
V335858
p19170
stp19171
a((dp19172
g2
(lp19173
VIf you are looking to simplify the specific task of printing three items, you can do it using a #define macro:
p19174
aVIf you prefer a function-call syntax, consider using C-style output instead:  is a "first-class member" of the C++ standard library, there is no reason to shy away from it when it makes sense in your specific application:
p19175
aVThe advantage of  approach is that it is not limited to any specific number of arguments
p19176
as(dp19177
g6
V335858
p19178
stp19179
a((dp19180
g2
(lp19181
VIn spite of their ability to store numbers, registers are not exactly "space"
p19182
aVConsider this example: you have a bunch of business cards in a big box, and you would like to arrange them alphabetically
p19183
aVIn the process of doing so, you move cards in the box from one place to the other
p19184
aVAlthough you hold a card in your hands while you move it to its new place in the box, your hands do not provide storage for the cards in the same sense that the box does
p19185
aVThe place in your hands is too valuable to be called "space"
p19186
aVContinuing with the cards analogy, imagine that cards have different sizes
p19187
aVThe size of your hand lets you hold one large card, two medium cards, or four tiny cards at a time
p19188
aVHowever, when you sort the cards, the ability to take multiple cards is rarely of advantage to you, especially when the cards are uniformly shuffled: multiple cards have multiple destination spots, so you would need to do more complex or unnecessary operations if you grab multiple cards at the same time
p19189
aVSimilarly, a register of a CPU may contain multiple bytes, but if you need to perform a computation, there is often no way to tell CPU which bytes to use: a register participates in an operation as an indivisible unit
p19190
aVThat is why an entire word is used for the data in the register, even though only a single byte would be sufficient
p19191
as(dp19192
g6
V335858
p19193
stp19194
a((dp19195
g2
(lp19196
VSince  cannot hold  objects, the only way the condition
p19197
aVcould evaluate to  is that  is
p19198
aVYou need to make sure that the array is properly allocated
p19199
aVA typical place to do it is the designated initializer of your class
p19200
as(dp19201
g6
V335858
p19202
stp19203
a((dp19204
g2
(lp19205
VFor function-static variables the line
p19206
aVis not an assignment
p19207
aVRather, it is static initialization, which happens only once - the first time the code goes through your function
p19208
aVIn subsequent invocations the value will not be , because you assign a non-nil value to it
p19209
aVYour implementation is safe in single-threaded environments
p19210
aVFor concurrent environments you would need to add some form of synchronization
p19211
as(dp19212
g6
V335858
p19213
stp19214
a((dp19215
g2
(lp19216
VYou are correct about the interfaces, they offer you more flexibility in designing your inheritance hierarchy
p19217
aVSuppose that you have a hierarchy that starts with a base class , and continues down to various species of birds
p19218
aVNow suppose that you would like to add a mechanical bird to the hierarchy of birds, but you would rather derive it from the  base class
p19219
aVIf your feeder takes  arguments, your mechanical bird would need a special feeder
p19220
aVIf the feeder take an , however, there would be no problem sending a  to it, as long as it implements the  interface correctly
p19221
as(dp19222
g6
V335858
p19223
stp19224
a((dp19225
g2
(lp19226
VYou are not using the pointer to pointer correctly: this line in the  loop
p19227
aVshould be
p19228
aVIf you use it that way, you wouldn't need your  variable at all
p19229
aVSince this is C, not C++, it is OK to not cast
p19230
as(dp19231
g6
V335858
p19232
stp19233
a((dp19234
g2
(lp19235
VYou cannot add the same item to  more than once - that's the whole point of a dictionary, an associative container
p19236
aVBut you can replace an existing one like this:
p19237
aVand you can make a dictionary of lists if you need multiple items per key:
p19238
aVWhen you do not know for sure if the list for a key exists or not, you can use this pattern to add new items:
p19239
as(dp19240
g6
V335858
p19241
stp19242
a((dp19243
g2
(lp19244
VYou can use I/O manipulators to set the width that you need, and fill with zeros
p19245
aVFor example, this program prints :
p19246
aVYou have to take care of the negative values yourself, though:  prints , not
p19247
aVCheck if the value is negative, set the width to , and add a minus in front
p19248
as(dp19249
g6
V335858
p19250
stp19251
a((dp19252
g2
(lp19253
VThe control is always returned to the call originator
p19254
aVIn this case, the originator could be the operating environment, or another method that called  (remember, when it comes to being called,  is not special in any way; other methods can call it too)
p19255
as(dp19256
g6
V335858
p19257
stp19258
a((dp19259
g2
(lp19260
VYes, this is a good practice
p19261
aVIn fact, this is part of the reason why the short-circuiting   operator has been invented
p19262
aVThe operator evaluates its subexpressions left to right, and stops when it finds a false subexpression
p19263
aVThis is precisely what you want; the  operator lets you express this in a single line
p19264
as(dp19265
g6
V335858
p19266
stp19267
a((dp19268
g2
(lp19269
VThe key to answering this question is to understand the meaning of this expression:
p19270
aVThis is a pointer subtraction expression, which is defined as the distance in sizes of elements pointed to by the pointer between the first and the second pointer
p19271
aVThis works when both pointers are pointing to a memory region that has been allocated as a contiguous block (which is true about all C strings in general and the elements of  in particular)
p19272
aVThe pointer  is first advanced to the end of the string (note the semicolon  at the end of the loop, which means that the loop body is empty), and then  is subtracted
p19273
aVThe result is the length of the corresponding argument
p19274
as(dp19275
g6
V335858
p19276
stp19277
a((dp19278
g2
(lp19279
VYou can eliminate  leading zeros by multiplying by the -th power of ten
p19280
aVSince you are looking for the hundredth place, multiply  by , and convert it to an integer
p19281
as(dp19282
g6
V335858
p19283
stp19284
a((dp19285
g2
(lp19286
VThis is a security concern only for Set-user-ID and set-group-ID applications
p19287
aVFor applications running as the user itself there is no threat, because the operation in question would be rejected by the operating system anyway
p19288
aVConsider this scenario: you have a UNIX program running as  via set-user-id
p19289
aVThe program uses  to check file permissions of another user, and then runs the file as , but only if the permission check has been successful
p19290
aVLet's say the program is called , and you run it as follows:
p19291
aVAn attacker can make a program that exploits this security hole to run, using this algorithm:
p19292
aVWrite a file  of which the user has executing permissions
p19293
aVStart two threads,  and
p19294
aVThread  waits a few milliseconds, and executes  to replace  with a file that the attacker wants to run, but has no run permissions to do so
p19295
aVThread  calls
p19296
aVIf the attacker gets lucky by getting his timing right, your  would check the execute permissions on the old , but it would run the new , a copy of  that the hacker wasn't supposed to run
p19297
aVSince there is a short time window between the check and the execution, the attacker is bound to get lucky at some point, if he tries his strategy many times in a loop
p19298
as(dp19299
g6
V335858
p19300
stp19301
a((dp19302
g2
(lp19303
VA simple and dirty method of telling if you are the only one executing on a thread would rely on unguarded static variables:
p19304
as(dp19305
g6
V335858
p19306
stp19307
a((dp19308
g2
(lp19309
VSince this is almost certainly a homework, here is an explanation of the approach with no code
p19310
aVYou do not need two loops, you need two loop variables
p19311
aVStart the first one at the beginning of the word, and the second one at the end, compare the characters at loop indexes, and return false if they are different
p19312
aVIf the characters are the same, move to the next iteration by advancing the front index forward and the back index backward
p19313
aVStop when the front index is equal to or greater than the back index
p19314
aVHere is the syntax that lets you use two loop variables in a single loop:
p19315
as(dp19316
g6
V335858
p19317
stp19318
a((dp19319
g2
(lp19320
VYes, your interpretation is correct, this is an assignment of  to both variables
p19321
aVYou may try silencing it with parentheses (which may or may not work)
p19322
aVor to add a  to ignore the issue (this is highly compiler/IDE dependent)
p19323
as(dp19324
g6
V335858
p19325
stp19326
a((dp19327
g2
(lp19328
VThe simplest way of refactoring a duplicated code is to make a method out of the common part
p19329
aVAn important question is where to put it
p19330
aVWhen the objects are related, you can put the common code in their common ancestor; when they are not related, you might consider creating a helper class with only class methods, or defining a C-style freestanding function with the body of your method
p19331
aVIn case the objects are unrelated and you need to use their instance variables, there may be an opportunity to extract a common object
p19332
aVMove all common instance variables needed for the duplicated code into the new common object, along with the code that uses these variables
p19333
aVIf the variables are also needed in the original classes from which you have extracted the common part, add getters and setters as needed
p19334
aVCreate an ivar for the extracted class, and use its properties in place of the instance variables
p19335
as(dp19336
g6
V335858
p19337
stp19338
a((dp19339
g2
(lp19340
VA letter may be either before or after the digit, so this expression should work:
p19341
aVHere is a code example that uses this expression:
p19342
as(dp19343
g6
V335858
p19344
stp19345
a((dp19346
g2
(lp19347
VYour algorithm is entirely wrong
p19348
aVWith an added  it "works" when all rows are different, but it breaks when some of the rows are the same
p19349
aVIt counts the number of rows such that there exists another row that's different from it
p19350
aVFor example, if you run it on
p19351
aVyou will get an answer , but you should get a
p19352
aVThe algorithm should go like this:
p19353
aVAssume that all rows are distinct ()
p19354
aVFor each row , look at the rows below it
p19355
aVIf any of the rows  below the row  is equal to , decrement the  and break out of the inner loop
p19356
aVAt the end of the outer loop,  contains your answer
p19357
as(dp19358
g6
V335858
p19359
stp19360
a((dp19361
g2
(lp19362
VA  object lets you call a method that you do not know at compile time
p19363
aVYou need to know only the name of a method as a string in order to call it
p19364
aVWhen the name of the method that you are calling is known at compile time, using selectors is counterproductive: the code becomes less readable for no apparent advantage
p19365
aVWhen you are writing a library that needs to call methods in other code that is compiled separately from the library, selectors provide a way to decouple the two pieces of code
p19366
aVFor example, if you are writing a timer class that can call you back when a time interval is over, your timer does not know the name of the function that it needs to call, so it cannot write something like this:
p19367
aVBut if you give your timer a selector, the timer would be able to call you back
p19368
as(dp19369
g6
V335858
p19370
stp19371
a((dp19372
g2
(lp19373
VYou can pass a number in the format argument:
p19374
aVThis reads up to 20 characters into the
p19375
aVIf you do not know how much data you are going to read at compile time, you can prepare the format string at runtime:
p19376
as(dp19377
g6
V335858
p19378
stp19379
a((dp19380
g2
(lp19381
VYou can use the  method in a loop, like this:
p19382
as(dp19383
g6
V335858
p19384
stp19385
a((dp19386
g2
(lp19387
VIn C++ a boolean expression produces one of two values -  or
p19388
aVWhen you apply the unary minus  to the result, you get  or
p19389
aVWhen you re-interpret  as , you get
p19390
aVYou can convert this expression to Java with a conditional:
p19391
aVBecause of branching, it is not going to be as fast as the original one
p19392
aVThere's little you can do about the speed of it, however, as Java lacks abilities to re-interpret boolean values as numerics
p19393
as(dp19394
g6
V335858
p19395
stp19396
a((dp19397
g2
(lp19398
VNo, the thing that you describe as "the Java way" is actually an anti-way: there should be no catching of  subclasses in the regular flow of your program, because they signal programming errors
p19399
aVA better way would be to split the protocol into smaller parts: all required methods would end up in a single interface, and the optional methods would be in their own tiny interfaces
p19400
aVNow you can test your objects with  to determine if an optional interface and its implied method are implemented
p19401
aVHere is an example:
p19402
aVThen you can write this check:
p19403
as(dp19404
g6
V335858
p19405
stp19406
a((dp19407
g2
(lp19408
VYou can make global objects accessible by placing them in a class with class methods for accessing global objects, implementing  to prepare these objects, and storing them in static variables
p19409
aVHeader:
p19410
aVImplementation:
p19411
aVUsage:
p19412
aVYou could also make the variable static inside its method for lazy initialization
p19413
as(dp19414
g6
V335858
p19415
stp19416
a((dp19417
g2
(lp19418
VI had a very positive experience in my experiments at writing a 2D "packman-style" game using Core Graphics: if you do it right,  animation proves sufficiently reliable and simple to implement
p19419
aVHere is a link to a great article that explains how you can implement animated sprites in Cocoa
p19420
aVThe trick is to use image atlases to avoid managing multiple images at runtime
p19421
as(dp19422
g6
V335858
p19423
stp19424
a((dp19425
g2
(lp19426
VSubtracting ASCII code and UNICODE code points should work most of the time
p19427
aVFor an encoding-independent solution, you can use this snippet: this will work even if you use some really archaic encodings that were around when dinosaurs roamed the Earth
p19428
as(dp19429
g6
V335858
p19430
stp19431
a((dp19432
g2
(lp19433
VA semicolon by itself has two drawbacks:
p19434
aVUsers of your macro can write it without a semicolon, and the compiler will not complain, and
p19435
aVSome compilers may issue a warning about a possibly stray semicolon
p19436
aVThe  trick addresses both these concerns:
p19437
aVwill trigger an error, and the compiler will not warn you about a "stray" semicolon
p19438
as(dp19439
g6
V335858
p19440
stp19441
a((dp19442
g2
(lp19443
VIf the method is public, everyone can access it
p19444
aVThe trick to access control like yours is to expose a set of public operations through an interface, add auxiliary operations to a private class implementing the interface, and make your users program to the interface, not to a class
p19445
aVHere is an example:
p19446
aVUsage scenario:
p19447
as(dp19448
g6
V335858
p19449
stp19450
a((dp19451
g2
(lp19452
VYou are trying to assign a return value of type  to a variable of type
p19453
aVThis will not work
p19454
aVYou need to assign the return value of , like this:
p19455
as(dp19456
g6
V335858
p19457
stp19458
a((dp19459
g2
(lp19460
VWhen you call , its return value is not a  to the command's output, but an exit code of the command
p19461
aVThe command completes successfully, and returns ; that's why you see a
p19462
aVIf you would like to fetch the string returned by the  command, you need to capture the output stream and convert it to a string
p19463
as(dp19464
g6
V335858
p19465
stp19466
a((dp19467
g2
(lp19468
VI think the timing problem has to do with the fact that console is line buffered by default
p19469
aVThis means that every time you write a  character to it, your entire output buffer is sent to the console, which is a rather costly operation
p19470
aVThis is the price that you pay for the line to appear in the output immediately
p19471
aVYou can change this default behavior by changing the buffering strategy to full buffering
p19472
aVThe consequence is that the output will be sent to console in chunks that are equal to the size of your buffer, but individual operations will complete faster
p19473
aVMake this call before you first write to console:
p19474
aVThe timing of individual writes should improve, but the output will not appear in the console immediately
p19475
aVThis is not too useful for debugging, but the timing will improve
p19476
aVIf you set up a thread that calls  on regular time intervals, say, once every second, you should get a reasonable balance between the performance of individual writes and the delay between your program writing the output and the time when you can actually see it on the console
p19477
as(dp19478
g6
V335858
p19479
stp19480
a((dp19481
g2
(lp19482
VCall the  method of your  instance, it unescapes the percent  sequences, replacing them with their corresponding "raw" characters
p19483
aVYou can convert between escaped and unescaped strings by using 's  and  methods
p19484
as(dp19485
g6
V335858
p19486
stp19487
a((dp19488
g2
(lp19489
VThe  identifier is not a  tag, it is a type name in its own rights
p19490
aVYou use it without the  keyword
p19491
aVOnce defined, the name cannot be reused for a  tag
p19492
aVIn your example, you are not forward-declaring  type, you are forward-declaring a  with the tag , which gives you an error because the name  has already been taken for the
p19493
as(dp19494
g6
V335858
p19495
stp19496
a((dp19497
g2
(lp19498
VThe  is your , so getting the  is easy
p19499
aVGetting the associated label, however, is not: you need to build your own scheme to find it
p19500
aVOne way could be by marking your text fields by setting their  properties to different numbers
p19501
aVIf you set the tag of text field for the first label to 1 and the tag of text field for the second label to 2, you can do something like this:
p19502
as(dp19503
g6
V335858
p19504
stp19505
a((dp19506
g2
(lp19507
VThis question has to do with the history of the language: C++ borrowed from C, and C used to implicitly type everything untyped as  (as it turned out, it was a horrible idea)
p19508
aVThis included functions that were intended as procedures (recall that the difference between functions and procedures is that function invocations are expressions, while procedure invocations are statements)
p19509
aVIf I recall it correctly from reading the early C books, programmers used to patch this shortcoming with a :
p19510
aVThis convention has later been adopted in the C standard, and the  keyword has been introduced to denote functions that are intended as procedures
p19511
aVThis was very helpful, because the compiler could now check if your code is using a return value from a function that wasn't intended to return anything, and to warn you about functions that should return but let the control run off the end instead
p19512
as(dp19513
g6
V335858
p19514
stp19515
a((dp19516
g2
(lp19517
VThere are three problems with your code:
p19518
aVYou define primitives as pointers (you need to remove asterisks)
p19519
aVYou assume that  takes degrees (it takes radians)
p19520
aVYou use integer division (if  indeed took degrees, which it does not, you should have used  in place of )
p19521
aVTo convert degrees to radians, use this formula:
p19522
as(dp19523
g6
V335858
p19524
stp19525
a((dp19526
g2
(lp19527
VWith the number of template arguments fixed, a simple code like this will do:
p19528
aVThe expressions in the  statement are compile-time constants, so the optimizer will optimize it into the code that is equivalent to either calling the method "unguarded" (without a branch) or not calling the method at all
p19529
aVIn other words, the decision to call the method or not will be made at compile time by the optimizer for no run-time cost
p19530
as(dp19531
g6
V335858
p19532
stp19533
a((dp19534
g2
(lp19535
VThe value of  is undefined, because after the last  accessing properties of the array is illegal: essentially, you are accessing a dangling pointer
p19536
aVIf you would like to clear out the array without invalidating it, use  method
p19537
as(dp19538
g6
V335858
p19539
stp19540
a((dp19541
g2
(lp19542
VThe algorithm is a lot simpler if you think of your linked list in terms of node pairs
p19543
aVEach iteration of your loop should process two nodes -  and , and leave  equal to  upon exit
p19544
aVIt is also important to not forget deleting the middle node, if you are cutting it out of the list, otherwise you are going to see memory leaks
p19545
as(dp19546
g6
V335858
p19547
stp19548
a((dp19549
g2
(lp19550
VThere is no difference in ARC, but prior to it there was a difference:  returns an item with ref count of at least one that you'd need to  when you don't need it, while the class method returns an autoreleased item that you'd need to  if you would like to keep it
p19551
aVThe ARC compiler knows all this, and takes care of retaining/releasing for you based on your ownership specifications
p19552
as(dp19553
g6
V335858
p19554
stp19555
a((dp19556
g2
(lp19557
VFrom your last comment it appears that the problem is due to a dangling reference: you create a local variable , assign it to , and exit the initializer
p19558
aVAt this point,  is gone, but the  is pointing to the area in the memory where it once has been
p19559
aVYou can fix this problem by declaring  static:
p19560
as(dp19561
g6
V335858
p19562
stp19563
a((dp19564
g2
(lp19565
VTry this expression:
p19566
aVThe first capturing group will be ; the second one will contain the URL
p19567
aVHere is a quick demo on ideone
p19568
aVThis prints
p19569
as(dp19570
g6
V335858
p19571
stp19572
a((dp19573
g2
(lp19574
VHere is how you can do it (it's quite a bit longer, due to the fact that dictionaries in cocoa are not ordered)
p19575
aVThis prints
p19576
as(dp19577
g6
V335858
p19578
stp19579
a((dp19580
g2
(lp19581
VAs Mysticial pointed out, these are multicharacter literals
p19582
aVTheir type is implementation-dependent, but it's probably Java , because they use 48 bits
p19583
aVIn Java, you need to convert them to  manually:
p19584
as(dp19585
g6
V335858
p19586
stp19587
a((dp19588
g2
(lp19589
VYou are correct about  being the exit condition: your loop is equivalent to
p19590
aVWhen written this way, it should be clear why  is not printed the value is first printed, and only then incremented, that's why  is the last value that you print
p19591
aVThe  operator, on the other hand, will produce  only when it is given a zero
p19592
aVThat's why the loop would print  when the  operator is used in the loop condition
p19593
as(dp19594
g6
V335858
p19595
stp19596
a((dp19597
g2
(lp19598
VUnfortunately, no: inheritance in C# is a compile-time concept, so your object must inherit from its base class at compile time
p19599
aVAs far as the "cluttering your code with attributes meant for storage" goes, partial classes could very much help: put storage-related attributes in a separate file, and your code will look clean again
p19600
as(dp19601
g6
V335858
p19602
stp19603
a((dp19604
g2
(lp19605
VBy my understanding callers tells length by variable "l" and "getcc" returns back length in case buffer is not filled comleatly but it is not allowed go outside array range defined by caller
p19606
aVThis is spot on
p19607
aVBut reality told me that really it is not so important what size of buffer was created by caller
p19608
aVIt is ok, if you create size of 1, and getss fills with 11 characters long
p19609
aVIn output I will get all characters that "getss" has filled
p19610
aVThis is absolutely wrong: you invoked undefined behavior, and did not get a crash
p19611
aVA memory checker such as valgrind would report this behavior as an error
p19612
aVSo what is reason to pass length variable
p19613
aVThe length is there to avoid this kind of undefined behavior
p19614
aVI understand that this is rather frustrating when you do not know the length of the string being returned, but this is the only safe way of doing it that does not create questions of string ownership
p19615
aVOne alternative is to allocate the return value dynamically
p19616
aVThis lets you return strings of arbitrary length, but the caller is now responsible for freeing the returned value
p19617
aVThis is not very intuitive to the reader, because  and  happen in different places
p19618
aVThe answer in C++ is quite different, and it is a lot better: you use , a class from the standard library that represents strings of arbitrary length
p19619
aVObjects of this class manage the memory allocated for the string, eliminating the need of calling  manually
p19620
as(dp19621
g6
V335858
p19622
stp19623
a((dp19624
g2
(lp19625
VA general requirement for an interface to be a "callback interface" is that the interface provides a way for the callee to invoke the code inside the caller
p19626
aVThe main idea is that the caller has a piece of code that needs to be executed when something happens in the code of another component
p19627
aVCallback interfaces provide a way to pass this code to the component being called: the caller implements an interface, and the callee invokes one of its methods
p19628
aVThe callback mechanism may be implemented differently in different languages: C# has delegates and events in addition to callback interfaces, C has functions that can be passed by pointer, Objective C has delegate protocols, and so on
p19629
aVBut the main idea is always the same: the caller passes a piece of code to be called upon occurrence of a certain event
p19630
as(dp19631
g6
V335858
p19632
stp19633
a((dp19634
g2
(lp19635
VYou are attempting to read 101 strings , but you allocated space for 100 characters
p19636
aVYou pass a character instead of a character pointer to , causing a crash
p19637
aVIf you are trying to read 100 characters, you should pass  in the format line, and an address in the parameter part of  call:
p19638
aVYou should also either replace  with , or allocate
p19639
aVIf you are looking to get one string, call  once, not in a loop:
p19640
aVYou are also reading the 6-th character before you place any data into the character array
p19641
aVThat value is not going to change after the  loop
p19642
as(dp19643
g6
V335858
p19644
stp19645
a((dp19646
g2
(lp19647
VTry this:
p19648
aVThe first lambda lets you pick the key, the second one picks the value
p19649
aVYou can play with it and make values differ from the keys, like this:
p19650
aVIf your list contains duplicates, add  like this:
p19651
aVEDIT To comment on the valid reason, I think the only reason that could be valid for conversions like this is that at some point the keys and the values in the resultant dictionary are going to diverge
p19652
aVFor example, you would do an initial conversion, and then replace some of the values with something else
p19653
aVIf the keys and the values are always going to be the same,  would provide a much better fit for your situation:
p19654
as(dp19655
g6
V335858
p19656
stp19657
a((dp19658
g2
(lp19659
VThere is a slight difference when the code is compiled with ARC and the optimization is turned off: the first example would increment and decrement a reference count on the  object one extra time
p19660
aVWhen optimization is turned on, however, the compiler should be able to figure out that the  variable is not used beyond the call to 's initializer, and optimize it out
p19661
as(dp19662
g6
V335858
p19663
stp19664
a((dp19665
g2
(lp19666
VYou need to extract the year, month, and day components, and construct a new , like this:
p19667
aVYou do not need to get the time components and then set them back to zero: you can keep them at their defaults by not asking to extract them in the first place
p19668
as(dp19669
g6
V335858
p19670
stp19671
a((dp19672
g2
(lp19673
VYou need to use  method instead of setting the  property:
p19674
aVWhat happens now is that you set the title in the label that represents the view of the current state, but once the state changes from pushed to normal, the button resets the label back to the title for the new state (which is the text that you set in the IB)
p19675
as(dp19676
g6
V335858
p19677
stp19678
a((dp19679
g2
(lp19680
VYou can set a  variable only in a constructor or in an initializer
p19681
aVRegular methods cannot change the value of variables declared
p19682
as(dp19683
g6
V335858
p19684
stp19685
a((dp19686
g2
(lp19687
VI find a library analogy very useful to visualizing arrays of multiple dimensions:
p19688
aV8-dimensional array is a library
p19689
aV7-dimensional array is a floor in a library
p19690
aV6-dimensional array is a room on a floor in a library
p19691
aV5-dimensional array is a bookcase in a room on a floor in a library
p19692
aV4-dimensional array is a shelf in a bookcase in a room on a floor in a library
p19693
aV3-dimensional array is a book on a shelf in a bookcase in a room on a floor in a library
p19694
aV2-dimensional array is a page in a book on a shelf in a bookcase in a room on a floor in a library
p19695
aV1-dimensional array is a line on a page in a book on a shelf in a bookcase in a room on a floor in a library
p19696
aV0-dimensional array is a character in a line on a page in a book on a shelf in a bookcase in a room on a floor in a library
p19697
as(dp19698
g6
V335858
p19699
stp19700
a((dp19701
g2
(lp19702
VIf you are looking to replace all escaped character codes, not only the code for , you can use this snippet of code to do the conversion:
p19703
aVThe code relies on a regular expression to find all sequences of hex digits, converting them to , and casting the resultant value to a
p19704
as(dp19705
g6
V335858
p19706
stp19707
a((dp19708
g2
(lp19709
VAbsolutely, there is
p19710
aVIt's not "in Objective-C" though: most likely, you would need to code it yourself
p19711
aVThe idea is to convert your list of string to a suffix tree, a data structure that lets you search by prefix very quickly
p19712
aVSearching for possible completions in a suffix tree are very fast, but the structure itself is not easy to build
p19713
aVA quick search on the internet revealed that there is no readily available implementation in Objective C, but you may be able to port an implementation in another language, use a C implementation, or even write your own if you are not particularly pressed for time
p19714
aVPerhaps an easier approach would be to sort your strings alphabetically, and run a binary search on the prefix that has been entered so far
p19715
aVThough not as efficient as a suffix tree, the sorted array approach will be acceptable for 100K strings, because you get to the right spot in under seventeen checks
p19716
as(dp19717
g6
V335858
p19718
stp19719
a((dp19720
g2
(lp19721
VThis piece of code works by accident: the  pointer happens to have sufficient space to hold an integer value, and  reinterprets the pointer as an integer, but the program is still incorrect
p19722
aVA pointer to  should be assigned an address of an integer variable, like this:
p19723
aVNow you can assign the variable through the pointer:
p19724
aVYou can also read the value through the pointer or through the variable:
p19725
as(dp19726
g6
V335858
p19727
stp19728
a((dp19729
g2
(lp19730
VSince C/C++ pointers can be interpreted as arrays of values the pointers point to, the two ways of checking values of a  is by applying an indexing operator or by using pointer arithmetics
p19731
aVYou can do this:
p19732
aVor this:
p19733
aVIn addition, C++ library provides multiple functions for working with C strings
p19734
aVYou may find  helpful to check if your pointer points to an empty string
p19735
as(dp19736
g6
V335858
p19737
stp19738
a((dp19739
g2
(lp19740
VYou can send messages to objects without knowing their exact type at compile time
p19741
aVIn fact, you routinely do that when you send messages to objects that you get back from arrays: you do not need to cast  to the exact type, you can simply send a message, and Objective C will dispatch it correctly
p19742
aVThe only exception to this rule is accessing properties with the dot  syntax: you do need a cast there
p19743
aVEvery object whose class inherits from  responds to , , , and so on
p19744
aVThis is all that the ARC needs to know
p19745
aVIn the worst case you will get "an object does not respond to selector" message if an  that you have happens to point to something invalid
p19746
as(dp19747
g6
V335858
p19748
stp19749
a((dp19750
g2
(lp19751
VThe idiomatic solution in Objective C is to use :
p19752
aVThe NSNull class defines a singleton object used to represent null values in collection objects (which don\u2019t allow nil values)
p19753
aVCreate your , and fill it up with  objects:
p19754
aVWhen you check for the presence or absence of an object in your , compare the object at index to : if they are the same, replace with a real object; otherwise, the real object is already there
p19755
aV** edit summary ** edited to initialize the array using a loop (thanks bbum)
p19756
as(dp19757
g6
V335858
p19758
stp19759
a((dp19760
g2
(lp19761
VYes, this is correct
p19762
aVYour solution is the most trivial case of dynamic programming, a technique to greatly speed up algorithms for solutions that can be constructed from solutions from smaller sub-problems
p19763
aVYour problem at hand has precisely this property: a solution to  can be constructed in  if you are given a solution to , and that is what your algorithm did, for a running time of
p19764
aVSolutions like that are very helpful in practice: I once used an algorithm like yours to speed up a piece of start-up code in my program from several minutes to several seconds (it was adding vectors, so it went from  to )
p19765
as(dp19766
g6
V335858
p19767
stp19768
a((dp19769
g2
(lp19770
VThe reference  will indeed be one per class, as per its  specifier
p19771
aVHowever, only the reference will be shared among all threads, not the value inside its object
p19772
aVWhen you access ,  invokes system-specific code that provides storage on the current thread, and reads or writes to that thread-specific storage
p19773
as(dp19774
g6
V335858
p19775
stp19776
a((dp19777
g2
(lp19778
VThe "prehistoric" idiomatic way of making constants was including them into an interface, and then inheriting that interface:
p19779
aVCurrently, Java provides a better way of achieving the same effect: define your constants in a  single class, and then import that class statically
p19780
aVThe class will serve as a way to group relevant constants together:
p19781
as(dp19782
g6
V335858
p19783
stp19784
a((dp19785
g2
(lp19786
VYou have to construct a representation of your image as a particular format (say, JPEG or PNG), and then call  on the representation:
p19787
as(dp19788
g6
V335858
p19789
stp19790
a((dp19791
g2
(lp19792
VYou are returning a struct with a large array by value, and it does not fit on the stack
p19793
aVReturn the struct by pointer, and dereference that pointer in the caller
p19794
aVIt would help you avoid a memory leak, too
p19795
as(dp19796
g6
V335858
p19797
stp19798
a((dp19799
g2
(lp19800
VYes, you need to make  virtual in order for this to work
p19801
aVOtherwise,  has no idea that descendants could provide alternative implementations of , an happily calls 's version
p19802
aVCompiler may even inline the  inside  at the time 's code is compiled, making the implementation in  completely irrelevant
p19803
as(dp19804
g6
V335858
p19805
stp19806
a((dp19807
g2
(lp19808
VYou need to provide the tag for your , not only a typedef:
p19809
aVWithout the tag there, the  is undefined, causing the error
p19810
aVIt is very helpful to understand the anatomy of this typedef: it is a combination of two declarations:
p19811
aVand
p19812
aVWithout the tag, you are -ing a tagless
p19813
as(dp19814
g6
V335858
p19815
stp19816
a((dp19817
g2
(lp19818
VSince  objects are recycled, you need to add an  branch to clear off the image when the hostel is not favorite
p19819
aVAs you currently have it, a cell that has been used to display a favorite once would contain an image forever
p19820
as(dp19821
g6
V335858
p19822
stp19823
a((dp19824
g2
(lp19825
VYou need to declare the flag , otherwise the compiler can optimize your code and skip the reads of the flag
p19826
as(dp19827
g6
V335858
p19828
stp19829
a((dp19830
g2
(lp19831
VAn idiomatic solution in C# is to pass an instance of  to the constructor of your generic class
p19832
as(dp19833
g6
V335858
p19834
stp19835
a((dp19836
g2
(lp19837
VThis is because you let your code run off the end without hitting a return statement
p19838
aVYou also need to add null checks in more than one place throughout the code
p19839
aVYour  method has them, but your  does not
p19840
as(dp19841
g6
V335858
p19842
stp19843
a((dp19844
g2
(lp19845
VYou are trying to use a  instead of
p19846
aVThere is no operator  defined that would take  as its first argument, which is what the compiler is trying to tell you (in a rather cryptic way)
p19847
aVIf you're on C++11, you can write this:
p19848
as(dp19849
g6
V335858
p19850
stp19851
a((dp19852
g2
(lp19853
VThe double quotes in the first line are a syntax artifact for the compiler to distinguish a string literal from a variable name
p19854
aVThey are not there in the string; the string is , without double quotes
p19855
aVIf you write
p19856
aVcompiler will think that  represents an identifier; you enclose  in double quotes to tell the compiler that you want to use it literally as a string of 14 characters, not as a variable name
p19857
aVThe compiler then removes the double quotes, and uses the value as a string
p19858
aVThis should work:
p19859
as(dp19860
g6
V335858
p19861
stp19862
a((dp19863
g2
(lp19864
VThe reason it does not work is that Java does not allow free-standing code
p19865
aVYou must put your code inside a method, a constructor, or an initializer
p19866
aVThis is an initializer:
p19867
aVThis is a declaration followed by an assignment:
p19868
aVYou can do this kind of stuff in a function, if your  is a local variable (you'd need to drop  then)
p19869
aVBut in the class declaration it is not allowed
p19870
aVAdding curly braces around the assignment makes your code part of the constructor, where assignments are allowed again
p19871
aVThat's why the following assignment worked:
p19872
as(dp19873
g6
V335858
p19874
stp19875
a((dp19876
g2
(lp19877
VYou can use regular expression matcher with your predicate, like this:
p19878
aVThe piece of code above constructs a regular expression that matches strings with optional blanks at the beginning and/or at the end, with the target word surrounded by the "word boundary" markers
p19879
aVThe  after  means "match case-insensitively"
p19880
aVThis example uses an array of strings; to make it work in your environment, replace  with
p19881
as(dp19882
g6
V335858
p19883
stp19884
a((dp19885
g2
(lp19886
VIf you make your objects value types (i
p19887
ag630
aV), they will be stored next to each other in an array, the same way the instances of primitives (, , etc
p19888
aVare stored
p19889
aVFor example, if you declare
p19890
aVyour  objects will be stored consecutively in a memory block, because  is a value type
p19891
aVNote that you woulnd't need to call a constructor either: all s in your array will be initialized and ready to be used
p19892
as(dp19893
g6
V335858
p19894
stp19895
a((dp19896
g2
(lp19897
VA pointer to a pointer to an  is not the same as a  array
p19898
aVYou should either declare your function differently, or prepare your array differently:
p19899
aVChange  to this:
p19900
aVOr prepare the array like this:
p19901
as(dp19902
g6
V335858
p19903
stp19904
a((dp19905
g2
(lp19906
VYou can use LINQ:
p19907
aVThis code produces this output (ideone link):
p19908
aVNote the difference between  and : the former selects the key of the group, while the later selects the key of the original dictionary
p19909
as(dp19910
g6
V335858
p19911
stp19912
a((dp19913
g2
(lp19914
VIt is not the interface that "works" but one of its implementations, which is specific to your particular RDBMS vendor
p19915
aVIn fact, it is typically the vendor who provides the implementation of the  interface
p19916
aVWhen you call
p19917
aVdriver manager searches through registered JDBC drivers, finds the one for MySQL (it knows it's MySQL from the connection string), passes connection properties to the constructor of the class inside MySQL JDBC driver that implements , and returns the resultant  instance back to you
p19918
aVFor example, the driver may return an instance of a package-private class  that implements , and your program would use it to interact with RDBMS without knowing any details about the class, other than the fact that it implements
p19919
as(dp19920
g6
V335858
p19921
stp19922
a((dp19923
g2
(lp19924
VImplement  protocol, and respond to the  method
p19925
as(dp19926
g6
V335858
p19927
stp19928
a((dp19929
g2
(lp19930
VView controllers manage the logic of your view, providing a way to channel the data between the view and the mode, and react to events initiated by end-users through the user interface
p19931
aVIf multiple views happen to share the same logic of model-view interaction, it is a good idea to share view controllers among them
p19932
aVHowever, this is somewhat rare: in practice, different views call for different view controllers
p19933
aVSo in practice you create a new class for a new view controller almost every time that you need a view controller
p19934
aVYou can also start with several view controllers, and then unify some of them if you spot sufficient number of commonality in their code
p19935
as(dp19936
g6
V335858
p19937
stp19938
a((dp19939
g2
(lp19940
VOf course you can construct delegates from instance methods: that is a very powerful feature
p19941
aVThe problem that you are seeing has to do with a specific syntax of creating delegates - by using method groups
p19942
aVYou get a compile error because method groups (that's the official name for constructing delegates from "naked" method names) cannot be passed as parameters of "untyped" s
p19943
aVIf you change the signature of your  method to accept , your code will compile correctly
p19944
aVYou could also cast your method group explicitly, like this:
p19945
as(dp19946
g6
V335858
p19947
stp19948
a((dp19949
g2
(lp19950
VThis is how you declare it:
p19951
aVThis is how you call it:
p19952
as(dp19953
g6
V335858
p19954
stp19955
a((dp19956
g2
(lp19957
VWhen you declare a function parameter as , it is not different to your callers from : they could not care less what you do with that pointer, because to them it is all "pass by value" anyway
p19958
aVThe second  is there for you, not for your users
p19959
aVIf you know that you are not going to modify that pointer, then by all means declare it : it is going to help you and others who maintain your code to catch errors later
p19960
aVAs for the standard library, my guess is that they did not want to make it  because they wanted an ability to modify the poitners:
p19961
as(dp19962
g6
V335858
p19963
stp19964
a((dp19965
g2
(lp19966
VWalk your expression tree, and convert each element to an object from the  namespace, using the factory methods of the  class
p19967
aVIf you cannot modify your  class to add methods that let you implement the visitor pattern, you can rely on type checking the old style:
p19968
aVOf course you'll need a lot more logic in this method
p19969
aVThe crucial part is passing parameters: you need to figure out where your variables are and what is their type, use  to create it, and then compile your converted expression into a  of some sort using the  method
p19970
aVWith a compiled lambda in hand, you can plug in your expressions into LINQ's in-memory framework
p19971
aVIf you can make your  visitable, add a visitor that walks the expression and converts it to a LINQ expression using a stack
p19972
as(dp19973
g6
V335858
p19974
stp19975
a((dp19976
g2
(lp19977
VYou are getting an  because your list is not initialized:
p19978
aVThis assumes that you are constructing a 2-D structure
p19979
aVIf you would like to "flatten" your arrays into a single list of strings, create a list, and use its  method instead
p19980
as(dp19981
g6
V335858
p19982
stp19983
a((dp19984
g2
(lp19985
VThere is a major difference between C++ templates and C# generics: it does not matter what classes you pass to instantiate the generic, if the compiler does not know about a method on  at the time of compiling your generic class or method, it would give you an error
p19986
aVThis is because C# needs an ability to compile the generic code separately from its places of instantiation (remember, there are no headers in C#)
p19987
aVYou can define an interface, and restrict  to it in order to use properties and methods inside a generic
p19988
aVAdd  to your interface, and add  to your generic declaration
p19989
as(dp19990
g6
V335858
p19991
stp19992
a((dp19993
g2
(lp19994
VThere is no property type covariance in Objective C, so if you want a property returning a subclass of , you need to define a separate property, say , in your  subclass
p19995
aVYou can return the same value from your  property, too, and it would work
p19996
aVMoreover, if your users call methods on the , they would not even need to cast it to
p19997
as(dp19998
g6
V335858
p19999
stp20000
a((dp20001
g2
(lp20002
VThis is not a category, it's a class extension (note that there is no category name, the parentheses are empty)
p20003
aVIt is a very good idea to add your private methods to a class extension
p20004
aVDoing so ensures that all methods have declarations, and that these declarations are visible only to the parts of your code where you want them to be visible
p20005
aVNote that unlike ordinary categories, class extensions let you add instance variables
p20006
aVThis is very convenient when your implementation relies on classes that are not part of the interface of your class
p20007
as(dp20008
g6
V335858
p20009
stp20010
a((dp20011
g2
(lp20012
VYou can use the recognizer's  method:
p20013
as(dp20014
g6
V335858
p20015
stp20016
a((dp20017
g2
(lp20018
VIn the C# 4
p20019
aV0, you can switch around the parameter expressions in method invocation
p20020
aVWhen there is only one parameter, it does not help you much, if at all: there is no doubt about what the expression represents, if there is only one parameter
p20021
aVHowever, with multiple parameters, the feature becomes a lot more helpful: you can pair up parameter names with expressions representing their values, and pass parameters in any order that you like
p20022
aVReaders of your program would not need to refer to the method signature in order to understand what expression represents which parameter
p20023
aVThis prints
p20024
as(dp20025
g6
V335858
p20026
stp20027
a((dp20028
g2
(lp20029
VTry this:
p20030
aVThe idea is to construct a list of all possible  columns, and protect each one with a  condition so that only one of them is "active"
p20031
as(dp20032
g6
V335858
p20033
stp20034
a((dp20035
g2
(lp20036
VTechnically, you are not required to implement even the  and  if the inherited versions are sufficient
p20037
aVAlso, ARC does not free you from having to write  in all cases (but it certainly covers the overwhelming majority)
p20038
aVFor example, if you allocate memory for your object using , you need to free it in the
p20039
aVWhen you add instance variables to your class, you need to initialize them
p20040
aVTypically, you do that in a designated initializer
p20041
aVAgain, if you do not to initialize anything, you do not have to code your own initializer; same goes for deinitializer
p20042
aVThe only case when you need to implement a method is when you adopt a protocol with one or more methods marked
p20043
aVThese methods are marked in the protocol reference
p20044
aVFor example,  and  are marked with the "required method" tag in Apple's documentation
p20045
as(dp20046
g6
V335858
p20047
stp20048
a((dp20049
g2
(lp20050
VThe way that your diagram is showing it, the way you encrypt appears to be dependent on the way that you do synchronization
p20051
aVI doubt that this is the case (although I may be wrong)
p20052
aVIf the way you sync is truly independent of the way you encrypt, switch from inheritance to composition
p20053
aVMake  an object that has a  and an , like this:
p20054
aVNow you can configure your  objects with instances of  and , mixing and matching them without creating combinatorial explosion:
p20055
aVThis design features two applications of the Strategy Pattern - one for the synchronization behavior, and the other one for the encryption
p20056
as(dp20057
g6
V335858
p20058
stp20059
a((dp20060
g2
(lp20061
VYou can do it using memoization
p20062
aVHere is Java-like pseudodoce (, , and  are assumed to be instance variables available to the  method)
p20063
as(dp20064
g6
V335858
p20065
stp20066
a((dp20067
g2
(lp20068
VFor calculations to be most efficient, cache their result in the node itself
p20069
aVOtherwise, you'll be re-calculating the count every time the  property is looked up
p20070
aVThe cost of doing that is the need to invalidate the cache all the way up the parent chain, like this:
p20071
as(dp20072
g6
V335858
p20073
stp20074
a((dp20075
g2
(lp20076
VYou can do this with reflection, but the code becomes hard to read, and type safety disappears
p20077
aVC# provides a much better mechanism for passing executable code around - namely, the delegates
p20078
aVYou can do something like this:
p20079
as(dp20080
g6
V335858
p20081
stp20082
a((dp20083
g2
(lp20084
VThe problem with your code is that  does not always return you a valid cell; sometimes, it returns
p20085
aVIn such cases you need to allocate a new instance of your cell, and then initialize it the usual way
p20086
aVAs it currently stands, your method would return  if one is returned from the  method
p20087
as(dp20088
g6
V335858
p20089
stp20090
a((dp20091
g2
(lp20092
VYou can query with regular expressions:
p20093
aVThis expression prevents tags contained inside other tags from making it into the query results
p20094
aVFor example, it would select items with , but not with
p20095
as(dp20096
g6
V335858
p20097
stp20098
a((dp20099
g2
(lp20100
VTry this:
p20101
as(dp20102
g6
V335858
p20103
stp20104
a((dp20105
g2
(lp20106
VThe reason the encoded array is longer by about a quarter is that base-64 encoding uses only six bits out of every byte; that is its reason of existence - to encode arbitrary data, possibly with zeros and other non-printable characters, in a way suitable for exchange through ASCII-only channels, such as e-mail
p20107
aVThe way you get your original array back is by using :
p20108
as(dp20109
g6
V335858
p20110
stp20111
a((dp20112
g2
(lp20113
VFrom Java documentation:
p20114
aVThe matches method attempts to match the entire input sequence against the pattern
p20115
aVYour regular expression matches a single digit, not a number
p20116
aVAdd  after  to matchone or more digits:
p20117
aVAs a side note, you can combine initialization and declaration of pattern, making the constructor unnecessary:
p20118
as(dp20119
g6
V335858
p20120
stp20121
a((dp20122
g2
(lp20123
VWhen multiple overloads match a signature, Java picks the most specific method from among them
p20124
aVThe value of  matches both  and , but  is a subclass of , so  is picked
p20125
aVIf you add another overload with a sibling of  in the class hierarchy, you'd get a compile error
p20126
aV\u005c
p20127
aVHere is a link to a post that discusses your code example at some length
p20128
as(dp20129
g6
V335858
p20130
stp20131
a((dp20132
g2
(lp20133
VThe problem with  is that although it points to one past the end of the container, there may be nothing allocated at or beyond that location in memory
p20134
aVSince writing to memory locations that have not been allocated to your program is undefined behavior, you should indeed use
p20135
as(dp20136
g6
V335858
p20137
stp20138
a((dp20139
g2
(lp20140
VThe  prevents memory writes from being re-ordered, making it impossible for other threads to read uninitialized fields of your singleton through the singleton's pointer
p20141
aVConsider this situation: thread A discovers that , locks, confirms that it's still , and calls singleton's constructor
p20142
aVThe constructor makes a write into member  inside Singleton, and returns
p20143
aVThread A now writes the reference to the newly created singleton into , and gets ready to release its lock
p20144
aVJust as thread A gets ready to release its lock, thread B comes along, and discovers that  is not
p20145
aVThread  accesses  thinking that it has been initialized, but because the CPU has reordered writes, the data that thread A has written into  has not been made visible to thread B
p20146
aVTherefore, thread B sees an incorrect value inside , which is wrong
p20147
aVWhen you mark  volatile, a memory barrier is inserted
p20148
aVAll writes initiated prior to that of  will be completed before the  is modified, preventing the reordering situation described above
p20149
as(dp20150
g6
V335858
p20151
stp20152
a((dp20153
g2
(lp20154
VSince the values come from the dictionary, you can set up a loop to write all attributes:
p20155
as(dp20156
g6
V335858
p20157
stp20158
a((dp20159
g2
(lp20160
VYou do not get an error because a negative integer constant is implicitly converted to an unsigned value, becoming a very large number (the MSB is set to one)
p20161
aVA value is implicitly converted to 1,2, shifted, and assigned back; you get all zeros when the number is converted back to , but it is an undefined behavior3
p20162
aVThere are no conversion in lines 4 and 5 in the C sense; regular type promotions associated with passing arguments to variadic functions do apply
p20163
aVHowever, the  re-interprets unsigned as singed on line 4: the format specifier is the only thing that tells  of the type of the arguments passed to it
p20164
aV1Promotions before shifting: link
p20165
aV2Integer promotions: link
p20166
aV3 Shifting by 30 would be OK, because  is representable as an
p20167
as(dp20168
g6
V335858
p20169
stp20170
a((dp20171
g2
(lp20172
VThere is no difference in the inner workings
p20173
aVThe first way requires the type of  to be such that the compiler could verify the presence of the property; the second way works even if the compiler does not know the exact type (i
p20174
ag630
aVwhen the type is an )
p20175
aVThe second syntax is the original one; the first syntax was added for convenience and readability
p20176
aVThere are different schools of thought on the subject of using these syntaxes: some people will tell you not to use one syntax or the other, and provide very valid reasons for it
p20177
aVIn the end, though, this is your choice: you should pick one syntax, and stay with
p20178
aVAs long as you are consistent and your readers know of your preference, they should have no trouble reading and maintaining your code either way
p20179
as(dp20180
g6
V335858
p20181
stp20182
a((dp20183
g2
(lp20184
VUnder ARC you define your autorelease pools with  blocks
p20185
aVThese blocks create new pools of autoreleased objects, and drain them when the scope of the block ends
p20186
aVThis will drain autorelease pool and release all autoreleased objects in each iteration of the loop
p20187
aVThis is a wasteful thing to do with tiny strings, but it may be of great help with larger objects
p20188
aVA quick note on how autorelease works: all it does is giving your objects one additional call to  when the pool is drained
p20189
aVThe default pool is drained in the event loop (i
p20190
ag630
aVsome time after your method exits)
p20191
aVThe pools that you create manually are drained when the scope of  ends
p20192
aVI am originally from C# background and I am used to setting even my string at the end of loop to null
p20193
aVUnless you are re-using the variable later on, this adds perfectly useless lines of code to your program: the C# compiler has been smart enough for some time now to figure out the earliest point to make your objects available to garbage collection, so assignments to  are not helpful
p20194
as(dp20195
g6
V335858
p20196
stp20197
a((dp20198
g2
(lp20199
VUse  overload, and skip digits before comparing strings
p20200
aVThe LINQ expression  converts a string to an array of individual letters
p20201
as(dp20202
g6
V335858
p20203
stp20204
a((dp20205
g2
(lp20206
VCalling  on a  attribute triggers the exception
p20207
aVIt is not necessary (and in fact, it is incorrect) to compare 's value to , because LINQ2XML uses "plain"  for missing attributes
p20208
aVTry this:
p20209
as(dp20210
g6
V335858
p20211
stp20212
a((dp20213
g2
(lp20214
VThe message is more or less clear: you have declared your block as taking a block that takes a string argument, but you are passing it a string instead
p20215
aVIf you wanted a block that takes a string, here is a  for it:
p20216
as(dp20217
g6
V335858
p20218
stp20219
a((dp20220
g2
(lp20221
VSince the array is declared inside the scope of loop's body, you can think of it as of a new array being allocated in the automatic storage area for each loop iteration
p20222
aVThe content of that unititialized array is undefined, except for the character at the index to which you have assigned during the current iteration, so what you see there is indeterminate value:
p20223
aVC99 standard, section 6
p20224
ag838
aV8: If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate
p20225
aVWhen optimization is turned off, the array lands in the same spot in the automatic storage, so your program gets lucky; however, this is by no means guaranteed
p20226
aVMove the array to outside the loop, like this:
p20227
as(dp20228
g6
V335858
p20229
stp20230
a((dp20231
g2
(lp20232
VFirst, define two "generic" segues called  and  in the story board from your table view controller
p20233
aVOne segue should lead to the detail controller; the other one should lead back to the table view controller
p20234
aVThen, implement the  method with a condition that moves you to the next level when there is one, or to the detail screen when there is no next level:
p20235
as(dp20236
g6
V335858
p20237
stp20238
a((dp20239
g2
(lp20240
VRemove the extra bits by masking with :
p20241
aVYou can also trim the upper three bits off after the sequence of shifts:
p20242
aVAccording to the language specification, default integer promotions are applied to shift operands before shifting, and the result of the operation is the promoted type of the first operand
p20243
ag10442
aV8
p20244
aV1 The operands shall be of integral or enumerated type and integral promotions are performed
p20245
aVThe type of the result is that of the promoted left operand
p20246
aVIf an integral type can fit in an , then  is the result of the promotion
p20247
aVWhen you shift left, the most significant bits "spill" into the upper part of the
p20248
aVYour first snippet cuts them off by assigning back to ; you can achieve the same result by masking the result with
p20249
aVLink to ideone
p20250
as(dp20251
g6
V335858
p20252
stp20253
a((dp20254
g2
(lp20255
VIn order to save an array for further reference you need to make the class serializable (for example, by implementing )
p20256
aVWhat this means is that an object can be converted to a sequence of bytes which could be saved to a file or sent over the network, which can later be used to recreate the object in memory
p20257
aVThen you can do this to save the data to a file:
p20258
aVYou can read it back like this:
p20259
as(dp20260
g6
V335858
p20261
stp20262
a((dp20263
g2
(lp20264
VIt seems to be a common sense in C/C++ that, the function which  some memory should  them before the function finishes, right
p20265
aVNo, this is not necessarily true, you do not have to release memory in the same function, as long as you release it eventually before the program ends
p20266
aVOne common solution available in C++ (but not in C) is to deallocate memory in the destructor
p20267
aVIf you pass around objects that contain dynamically allocated memory while dealing correctly with the copy/move constructors and assignment operators, the memory will be released when the destructor is called
p20268
as(dp20269
g6
V335858
p20270
stp20271
a((dp20272
g2
(lp20273
VUse  for the tab character
p20274
aVUsing  may present a more readable option:
p20275
as(dp20276
g6
V335858
p20277
stp20278
a((dp20279
g2
(lp20280
VYou need another parameter to tell you which way you are going
p20281
aVYou also need to test for the end condition to know when to switch from going up to going down
p20282
aVIt would probably be easier to draw stars before recursing down, although both ways are certainly possible
p20283
as(dp20284
g6
V335858
p20285
stp20286
a((dp20287
g2
(lp20288
VC# compiler does not know anything about
p20289
aVAs far as the compiler is concerned, the access to  could happen at any time after calling , including the time before  has been assigned
p20290
aVYour second code snippet has a race condition: if the task on a concurrent thread gets around to displaying message box before the assignment is complete, you will see a null reference exception
p20291
aVTry this experiment:
p20292
aVNow replace the direct call of  with a call of  in your second snippet, and watch the program crash
p20293
as(dp20294
g6
V335858
p20295
stp20296
a((dp20297
g2
(lp20298
VYou can make a method that hides your :
p20299
aVYou can earn some "points for style" by making the method an extension (you need to add it to a static class then):
p20300
aVIf you know that you are inserting only reference type objects, replace  with  and add a  constraint to the generic
p20301
as(dp20302
g6
V335858
p20303
stp20304
a((dp20305
g2
(lp20306
VYou are correct, your  cannot be used the way it is derived: there is nothing that you can put into it
p20307
aVWhat you want for storing  and its subclasses is simply ; it will take objects of  and all its  correctly
p20308
as(dp20309
g6
V335858
p20310
stp20311
a((dp20312
g2
(lp20313
VI would strongly recommend against re-using -derived objects outside of database context
p20314
aVThe opportunity to reuse a few fields here and there does not worth the loss of clarity that will result from such an approach
p20315
aVThe problem is, the aggregated share price object that you are planning to create does not represent a share price - instead, it represents a share price aggregation for a time period
p20316
aVTherefore it is not a good idea to use the same class to represent both kinds of objects: they are conceptually different
p20317
aVAnother problem with your approach is that  includes a lot of things that are of no use outside of database context, such as object ID, a reference to the managed object context, and so on
p20318
aVKeeping them around in a meaningless state would be misleading to anyone maintaining your application
p20319
as(dp20320
g6
V335858
p20321
stp20322
a((dp20323
g2
(lp20324
VThis code will enumerate all files in your documents directory in the order they were created:
p20325
aVSee comments in the code to understand what is going on
p20326
as(dp20327
g6
V335858
p20328
stp20329
a((dp20330
g2
(lp20331
VThere is no difference between your first and second snippet in terms of how many objects are created
p20332
aVStrings , , and  will participate in the process, although their interned copies may be used
p20333
aVIn the absence of further references to , the compiler is free to transform your second snippet into your first one, eliminating the variables
p20334
aVIn addition, there may be an internal reallocation inside 's , if the memory in its internal string is insufficient to hold the data being appended
p20335
aVThis is only a theoretical possibility, but it is there
p20336
as(dp20337
g6
V335858
p20338
stp20339
a((dp20340
g2
(lp20341
VI think the complaint is somewhat misleading: you are not boxing the return value of  which is an , but you are casting it to  prematurely
p20342
aVTry changing the code to see if it helps you avoid the warning:
p20343
as(dp20344
g6
V335858
p20345
stp20346
a((dp20347
g2
(lp20348
VYou should change the statement to list the columns explicitly, and drop  from the list of values
p20349
aVThis way your insert statement is no longer dependent on the order of columns in your  table, and is also immune to addition of columns to the table
p20350
aVNote that although this design is probably OK for a toy or an education system, but in a real production system storing password in a table is very dangerous
p20351
aVStoring  is rather unusual, too: normally your system checks that  is the same as , and then inserts a salted password hash and a salt into the table
p20352
as(dp20353
g6
V335858
p20354
stp20355
a((dp20356
g2
(lp20357
VCreating a macro that compiles logging out conditionally is not equivalent to turning it off and on at runtime
p20358
aVOf course if you turn off logging with conditional compile, you will save on method invocation, but you wouldn't be able to turn the logging back on at will
p20359
aVOne solution that lets you save on the method invocation would be to wrap logging in a macro with an  statement that checks if the logging is enabled, and skips over the invocation if it is not enabled
p20360
aVThis will save you a cost of invocation, which in most cases is going to be more expensive than a simple condition check:
p20361
aVIf  has several overloads, you may need to define a separate macro for each set of parameters
p20362
as(dp20363
g6
V335858
p20364
stp20365
a((dp20366
g2
(lp20367
VThe problem with doubles in tree maps is exactly the same as it is with doubles in hash map - comparing for equality
p20368
aVIf you avoid calls of  and stay with range queries instead (e
p20369
ag303
aVby using ) you should be fine
p20370
aVThis prints
p20371
aVSee this snippet on ideone
p20372
as(dp20373
g6
V335858
p20374
stp20375
a((dp20376
g2
(lp20377
V has a  property of type
p20378
aVThis property lets you manipulate the current position, the current zoom level, and so on:
p20379
as(dp20380
g6
V335858
p20381
stp20382
a((dp20383
g2
(lp20384
VBlocks in Objective-C are "first-class citizen" objects
p20385
aVWhatever you can do to a regular object, be it passing as a parameter, storing in an array or a dictionary, and so on, you can do it to block objects as well
p20386
aVFor example, an array of block objects may be useful to encode a sequence of actions that is not known at compile time; a dictionary of block objects keyed by strings could be useful in implementing a scripting language, and so on
p20387
aVThe best way to call a block retrieved from a collection is casting it to its proper type, and using the regular block invocation syntax on it
p20388
as(dp20389
g6
V335858
p20390
stp20391
a((dp20392
g2
(lp20393
VThis should do what you need:
p20394
aVNote that your example is incorrect: when it's 1 AM on June-14th in UTC, it's still June-13th in EST, 8 PM standard or 9 PM daylight savings time
p20395
aVOn my system this program prints
p20396
as(dp20397
g6
V335858
p20398
stp20399
a((dp20400
g2
(lp20401
VAdd a tab gesture recognizer to your  object, and capture tap gestures through it
p20402
aVThis is how you add a tap recognizer to your view:
p20403
aVThis is what the  method signature looks like:
p20404
as(dp20405
g6
V335858
p20406
stp20407
a((dp20408
g2
(lp20409
VThese are the correct values for the  representation of the binary values that you have requested:  is 2,  is f, and  is d
p20410
aVIf you would like to print a binary representation, you can borrow  function from here, or build your own
p20411
as(dp20412
g6
V335858
p20413
stp20414
a((dp20415
g2
(lp20416
VThe reason to use  class in this situation is to force everyone inheriting your base class to override the abstract  method
p20417
aVWithout the class and the method being abstract, they may forget to do so, and the compiler would not catch them
p20418
aVIn addition to this pragmatic purpose, abstract classes provide a powerful way to communicate your design idea to the readers of your code
p20419
aVAn abstract class tells the reader that the methods inside provide some common implementation for a group of related classes, rather than implementing a single concept that you are modeling
p20420
aVVery often communicating your intent to your readers is as important as it is to write correct code, because otherwise they might break something while maintaining your code
p20421
aVIt is customary in Java to call abstract classes ; in your example that would be
p20422
as(dp20423
g6
V335858
p20424
stp20425
a((dp20426
g2
(lp20427
VIf you would like to create an array of strings, you are missing an asterisk, and terminating zeros:
p20428
aVThere is an easier way of doing the individual strings, too:
p20429
aVWhen you use the  construct, the content of your string literal (which includes a terminating zero) is copied into memory that you are allowed to write, producing the same effect as  construct
p20430
as(dp20431
g6
V335858
p20432
stp20433
a((dp20434
g2
(lp20435
VThe problem is that your  does not initialize its  member in the constructor (in fact, it has no constructor at all)
p20436
aVIf you expect to be able to access  right after constructing your , you should add a constructor, like this:
p20437
as(dp20438
g6
V335858
p20439
stp20440
a((dp20441
g2
(lp20442
VTry this:
p20443
aVThis works because binary codes of digits are consecutive
p20444
aVBy subtracting the code of zero character  you obtain the value of the digit as an integer number from zero to nine, inclusive
p20445
aVHere is a link to this snippet on ideone
p20446
aVIt prints
p20447
as(dp20448
g6
V335858
p20449
stp20450
a((dp20451
g2
(lp20452
VJava provides a special class for storing IP addresses:
p20453
aVUnlike , it is capable of handling 128-bit addresses in addition to 32-bit ones, and it is not as wasteful as a  in terms of the memory that it uses, which might become important in very high-volume situations
p20454
as(dp20455
g6
V335858
p20456
stp20457
a((dp20458
g2
(lp20459
VCreate a connectivity matrix of the subset of states in question (a  boolean matrix that includes a row and a column for each state in the subset, with  if and only if states  and  are adjacent to each other)
p20460
aVThe run the following algorithm:
p20461
aVVerify that all elements of  are set to  after the three loops finish
p20462
aVIf any element is , the states are not contiguous
p20463
aVIn case you have forgotten what is "that three-loop thing", it's the famous Floyd-Warshall algorithm for finding transitive closures of graphs
p20464
as(dp20465
g6
V335858
p20466
stp20467
a((dp20468
g2
(lp20469
VWhat you described strongly resembles a utility class, similar to Java's
p20470
aVThe class has only  methods, and a private constructor to prevent instantiations
p20471
aVThis is a well-known idiomatic pattern in Java - you can use it to create your own groups of methods providing related functionality
p20472
aVYou should not extend, or even instantiate, utility classes at all
p20473
aVStarting with Java-5, you can statically import them so that you could use their methods without making an explicit reference to their class
p20474
as(dp20475
g6
V335858
p20476
stp20477
a((dp20478
g2
(lp20479
VDivision is implemented in most SQL dialects: use , like this:
p20480
aVAssuming  is non-negative, you can shield yourself from division by zero (and use indexes on , if any*) by multiplying both sides by :
p20481
aV* Thanks Vincent Savard for this observation
p20482
as(dp20483
g6
V335858
p20484
stp20485
a((dp20486
g2
(lp20487
VYou can use regular expressions to do formatting, like this:
p20488
aVThis transforms the string into
p20489
aVIn order to apply this formatting dynamically as users type, create  upfront, store it in your , and use it in your  method
p20490
as(dp20491
g6
V335858
p20492
stp20493
a((dp20494
g2
(lp20495
VTry this:
p20496
aVThe strings that you get back for your summary text may need to be trimmed, but the basic idea should work
p20497
as(dp20498
g6
V335858
p20499
stp20500
a((dp20501
g2
(lp20502
VSubtracting zero from a pointer does not change the pointer, the same way that subtracting zero from a number does not change a number
p20503
aVYou should subtract the original pointer, not zero, to get the length:
p20504
as(dp20505
g6
V335858
p20506
stp20507
a((dp20508
g2
(lp20509
VAll these variables are automatic: global variables need to be declared outside the scope of a function; static variables need to have a  modifier
p20510
aVThe exact size is system-dependent
p20511
aVYou can find out by printing , , etc
p20512
aVThe exact time of allocation of automatic variables is compiler-dependent: some of them are allocated upon entering the function, some are upon entering a block where they are used, and some may be optimized out, and not allocated at all
p20513
as(dp20514
g6
V335858
p20515
stp20516
a((dp20517
g2
(lp20518
VAssuming that the data does not change after deployment, and that you run your unit tests before shipping your application (after all, why would you need unit tests if you didn't run them before shipping the app, right
p20519
aVthere is no reason to repeatedly testing your static data in an installed app
p20520
aVChecking the data in your unit tests is entirely sufficient: the only reason the data would change after installation is if your application is tampered with, and iOS prevents that already
p20521
as(dp20522
g6
V335858
p20523
stp20524
a((dp20525
g2
(lp20526
VJava passes references by value; swapping references in the method being called has no effect in the caller
p20527
aVYour strings are immutable, so there is nothing you can do to them in the  method that would be visible to the caller
p20528
aVIf you pass mutable objects, however, you will see that changes to them made in the  would reflect in the original:
p20529
aVThis works, because array is mutable (i
p20530
ag630
aVchanges can be made to its state), and because a reference to the original object is passed to the function being called (by value)
p20531
aVWhen  modifies the content of its , the content of  in the caller gets modified too, because it is the same object
p20532
as(dp20533
g6
V335858
p20534
stp20535
a((dp20536
g2
(lp20537
VYou can memoize your solution by storing the result of  in a
p20538
as(dp20539
g6
V335858
p20540
stp20541
a((dp20542
g2
(lp20543
VYou should assign the result of trim back to the  variable
p20544
aVOtherwise it is not going to work, because strings in Java are immutable
p20545
as(dp20546
g6
V335858
p20547
stp20548
a((dp20549
g2
(lp20550
VWhen your  method is called, the first responder has not been set to the correct field yet
p20551
aVReplace the  with  to fix this problem
p20552
as(dp20553
g6
V335858
p20554
stp20555
a((dp20556
g2
(lp20557
VThis is a ternary operator (also available in C, to which Objective C is a superset, and other languages that borrowed from it)
p20558
aVThe expression before  is evaluated first; if it evaluates to non-zero, the subexpression before  is taken as the overall result; otherwise, the subexpression after the colon  is taken
p20559
aVNote that subexpressions on both sides of  need to have the same type
p20560
aVAlso note that using macro for calculating  may produce unexpected results if arguments have side effects
p20561
aVFor example,  will produce a doubled side effect on one of the operands
p20562
as(dp20563
g6
V335858
p20564
stp20565
a((dp20566
g2
(lp20567
VThere is no benefit, because structs are passed by value
p20568
aVPassing multiple arguments one by one will take the same amount of allocations from a running program as the allocation of a
p20569
aVMoreover,  may give you worse results because of padding
p20570
aVEven if you pass your  by pointer, you would still need to allocate a new instance of your  before passing it to the next level of invocation
p20571
aVTheoretically, you could get some benefit by reusing a struct that you have allocated once in multiple invocations, but in most cases that would be a micro-optimization not worth your trouble (unless your profiler indicates otherwise)
p20572
as(dp20573
g6
V335858
p20574
stp20575
a((dp20576
g2
(lp20577
VYes, it is the same
p20578
aVDraw the truth table for both expressions, assuming that there are four input variables in both
p20579
aVThe value of  will not play into the second truth table: values in cells with  will match values in cells with
p20580
aVIn other words, you can think of the second expression as
p20581
aVYou will see that both tables match: the  subexpression has zeros in ;  has zeros only at
p20582
aVAdding  patches zero at  in the first subexpressions, so the results are equivalent
p20583
as(dp20584
g6
V335858
p20585
stp20586
a((dp20587
g2
(lp20588
VSometimes it is impossible to pinpoint the real problem, because the issue that causes the symptom has happened much earlier
p20589
aVYour issue provides a great example: when you release your object, cocoa has no idea that you've done anything wrong: you are releasing an object that you own, this is precisely what you should be doing, so there's no red flags
p20590
aVThe code that leads to a breakdown is executed well after your method has finished, and gave the control back to the run loop
p20591
aVIt is at this point that the run loop gets around to draining its autorelease pool, causing the second deallocation
p20592
aVAll it knows at this point, however, is that the run loop has made an invalid deallocation, not your code
p20593
aVBy the time the error happens the culprit is safely off the stack (and off the hook), so there is nothing else Xcode can report back to you
p20594
aVA solution to problems like this is to profile your memory use: the profiler should catch issues like that, and pinpoint the places where they happen
p20595
aVIt goes without saying that switching to automatic reference counting will save you lots of troubles in the memory management department
p20596
as(dp20597
g6
V335858
p20598
stp20599
a((dp20600
g2
(lp20601
VPrototype design pattern offers costs savings of two kinds - time savings and space savings
p20602
aVTime savings come in situations when creating an object requires a costly access to auxiliary information - say, requesting configuration data from a file, a database, or over a network
p20603
aVFor example, if you are building lots of pages from a template that is stored on a web server, it is cheaper to read the template once and clone it to get the starting point for each new page, rather than querying the web server separately for each page
p20604
aVMemory savings come from reusing immutable objects: if your original contains lots of strings, creating a new instance would need to either create entirely new immutable strings, or deal with string interning manually
p20605
aVUsing the prototype pattern gracefully avoids this problem by letting the clone share the immutable parts of the template
p20606
as(dp20607
g6
V335858
p20608
stp20609
a((dp20610
g2
(lp20611
VYes, every recursive function can be converted to an iterative one by following a rather mechanical process
p20612
aVRecall that compilers implement recursion by using a stack, which is typically implemented in the CPU's hardware
p20613
aVYou can build a software stack of your own, make it suitable for keeping the state of your function (i
p20614
ag630
aVits local variables), push the initial state onto that stack,  and write a  loop that pushes new state onto the stack instead of making a recursive call, popping the stack instead of returning, and continuing the process while the stack is not empty
p20615
as(dp20616
g6
V335858
p20617
stp20618
a((dp20619
g2
(lp20620
V is 8-bit long, while  requires nine bits to represent
p20621
aVConverting to  chops off the most significant bit of  which is  in binary, resulting in , which is  in binary
p20622
aVWhen you pass  to , it gets promoted to , which is then picked up by the  format specifier, and printed as
p20623
as(dp20624
g6
V335858
p20625
stp20626
a((dp20627
g2
(lp20628
VAssuming that you have a button called  connected as  to your view controller, you can use this code to animate your button to a new label:
p20629
as(dp20630
g6
V335858
p20631
stp20632
a((dp20633
g2
(lp20634
VGlobals are not the best thing to use in Objective C: it is much better to use a singleton
p20635
aVYou can do it like this:
p20636
aVHeader:
p20637
aVImplementation:
p20638
aVUsage:
p20639
as(dp20640
g6
V335858
p20641
stp20642
a((dp20643
g2
(lp20644
VSince the decimal part does not really represent the decimal portion of the hour, you need to chop if off and process it separately
p20645
aVIn SQL Server 2012:
p20646
aVPrior to SQL 2012:
p20647
as(dp20648
g6
V335858
p20649
stp20650
a((dp20651
g2
(lp20652
VIt looks like you declared a category on your class; you cannot add instance variables in a category
p20653
aVYou can, however, add them in a class extension
p20654
aVFor that, remove the name of the category (), and remove initialization, leaving the code as follows:
p20655
aVAll initialization needs to happen in your designated initializer (e
p20656
ag303
aVyour  method), like this:
p20657
as(dp20658
g6
V335858
p20659
stp20660
a((dp20661
g2
(lp20662
VAs far as I know, there is no public version of that table available in
p20663
aVNET
p20664
aVBecause this table is not a table of all prime numbers in a range, but rather a table of arbitrarily chosen subset of prime numbers suitable for a particular purpose (sizing hash-based containers)
p20665
aVNo, you should either generate your own table on the fly, or copy-paste a table from one of many complete sources
p20666
as(dp20667
g6
V335858
p20668
stp20669
a((dp20670
g2
(lp20671
VThe result of  is a pointer, while  itself is not a pointer, it is an array
p20672
aVYour constructor does not have an overload that takes an array and a pointer, hence the compile fails
p20673
aVThe idiomatic way of dealing with the problem of making the beginning and the ending iterators from an array is using the  and  functions:
p20674
aVThe overload takes care of figuring out where the end of your array is, freeing you from the need to add array's length to the pointer
p20675
as(dp20676
g6
V335858
p20677
stp20678
a((dp20679
g2
(lp20680
VLeaving aside the observation that regex is not the best tool for use with HTML, you can use  expression to make sure there's a word boundary before and after the string that you're matching
p20681
as(dp20682
g6
V335858
p20683
stp20684
a((dp20685
g2
(lp20686
VThere are at least two problems with your code: you are writing to a character buffer that you did not allocate, and you are constructing a palindrome from the second half of the string, rather than reversing it
p20687
aVSince this is C++, you shouldn't use C strings, and prefer C++ strings instead ( is the type that you need)
p20688
aVYou should also swap the characters at the two ends of the string, rather than simply assigning the character from the ending part to a character from the initial part of the string
p20689
aVThe most fitting function for swapping characters is
p20690
as(dp20691
g6
V335858
p20692
stp20693
a((dp20694
g2
(lp20695
VSearch linearly for the first inversion (i
p20696
ag630
aV), call its index
p20697
aVContinue until inversions stop, call the last index
p20698
aVReverse the array between  and , inclusive
p20699
aVIn your example,  is 4, and  is 6; array elements are numbered from zero
p20700
aVThe algorithm is linear in the number of entries in the original
p20701
as(dp20702
g6
V335858
p20703
stp20704
a((dp20705
g2
(lp20706
VYou can construct an array, and use LINQ to search it:
p20707
aVOn a side note, I assume that you realize that the way the  is defined is highly unorthodox (that's the most polite way of putting it), because it does not have fields, only constants
p20708
as(dp20709
g6
V335858
p20710
stp20711
a((dp20712
g2
(lp20713
VHere is an example of how you can do it by constructing instances of an anonymous type to group coordinates and unparsed values until the  clause, and then chopping off the coordinates to get the unparsed values back
p20714
aVThe distance formula squares both sides of the Cartesian distance formula to avoid the costs of taking a square root
p20715
as(dp20716
g6
V335858
p20717
stp20718
a((dp20719
g2
(lp20720
VI think the problem is not with the , but with 's interpretation of  symbol
p20721
aVIf you pass a format string to , and put the string that you would like to show as an object parameter, the percentage sign  should survive:
p20722
as(dp20723
g6
V335858
p20724
stp20725
a((dp20726
g2
(lp20727
VThe  takes C-style arrays, not  objects
p20728
aVThe  may do the trick, but you may be better off constructing a mutable dictionary as you go, bypassing s entirely
p20729
as(dp20730
g6
V335858
p20731
stp20732
a((dp20733
g2
(lp20734
VYou cannot do it with , because it needs your code to exit in order to fire
p20735
aVuses the event loop to decide when to call you back; if your program holds the control in its  loop, there is no way for the timer to fire, because the code that checks if it's time to fire or not is never reached
p20736
aVOn top of that, staying in a busy loop for nearly a second and a half is going to deplete your battery
p20737
aVIf you simply need to wait for , you are better off calling , like this:
p20738
aVYou can also use  from  to measure short time intervals, like this:
p20739
as(dp20740
g6
V335858
p20741
stp20742
a((dp20743
g2
(lp20744
VThe problem is with the precision of floating-point calculations: you should generally avoid comparing floats and double-precision numbers for equality using  operator, preferring a check for the difference to be smaller than a tiny epsilon (e
p20745
ag303
ag1783
aVThe first example works because the numbers are composed of powers of 2: , and
p20746
aVThe numbers from the second example cannot be decomposed as powers of 2 exactly, so the equality check does not work
p20747
as(dp20748
g6
V335858
p20749
stp20750
a((dp20751
g2
(lp20752
VYes, in cases like that you need explicit synchronization, because another thread could get  and start reading it before you have finished writing
p20753
aVIf you do this, however,
p20754
aVthen you wouldn't need to add explicit synchronization, because the switch from one reference over to the other reference is atomic
p20755
aVOf course there is an implicit assumption here that there is no writing outside the  method
p20756
aVEDIT: You also should switch from an auto-implemented property to a manually implemented property with a backing variable declared with  modifier
p20757
as(dp20758
g6
V335858
p20759
stp20760
a((dp20761
g2
(lp20762
VThe difference between multiple inheritance among interfaces vs
p20763
aVclasses is when you must inherit implementation
p20764
aVWhen you inherit method interface through multiple paths, you can say that the implementing class must implement the inherited method
p20765
aVWhen you inherit from multiple classes, you must decide which of the several implementations to choose
p20766
aVThis increases the complexity of the language very significantly, as you can see by examining the way multiple inheritance is implemented in C++
p20767
aVHere is an illustration:
p20768
aVWhat is going to happen when you do this
p20769
aVWith inheritance of interfaces,  would have to implement ; with inheritance of implementation, the language would need to decide, or provide you a way to specify it yourself
p20770
aVOne way or the other, the complexity is going to grow
p20771
as(dp20772
g6
V335858
p20773
stp20774
a((dp20775
g2
(lp20776
VThe condition of the  loop is in the middle - between the two semicolons
p20777
aVIn C++ it is OK to put almost any expression as a condition: anything that evaluates to zero means ; non-zero means
p20778
aVIn your case, the condition is : when you convert to C#, simply add :
p20779
as(dp20780
g6
V335858
p20781
stp20782
a((dp20783
g2
(lp20784
VYou can certainly include quotation marks in strings
p20785
aVAs long as you use such strings properly, there should be no issues
p20786
aVYou run into issues when you pass strings with quotes to methods that have special interpretation for them, such as methods that forward your strings to SQL parser
p20787
aVIn these cases quotes need to be hidden, for example through the use of parameterized SQL statements
p20788
aVHowever, it does not look like you are including a quotation mark in your string for a good purpose: displaying a measurement in inches is a display concern, there is absolutely no need to include the quotation mark in the server response or in the data written to the database
p20789
aVInstead, you should pass the measurement in its native form (an integer or a floating-point number), and add the quotation mark at the last moment, when you are about to display the string to users
p20790
aVFor example, you can do it like this:
p20791
as(dp20792
g6
V335858
p20793
stp20794
a((dp20795
g2
(lp20796
VYour way of solving this issue is so standard that it even has a name: it is called Template Method Pattern
p20797
aVThe idea is to provide a public method that executes the steps of your algorithm at high-level, and use overrides of protected abstract methods in subclasses to deal with lower-level steps of the algorithm
p20798
aVThis is the correct way of addressing the problem
p20799
as(dp20800
g6
V335858
p20801
stp20802
a((dp20803
g2
(lp20804
VIf you would like your block to get a copy of your ivar, make a local variable from it, and use that local inside your block instead of the ivar:
p20805
aVThe block will capture the value of that local variable at the time the block object is created, making all subsequent changes to  invisible to your block
p20806
as(dp20807
g6
V335858
p20808
stp20809
a((dp20810
g2
(lp20811
VProperty is a fancy name for one or two methods with specific signatures for which Objective-C provides a convention that lets you call them using the alternative dot  syntax
p20812
aVThere is no difference between a protocol declaring, say, a pair of
p20813
aVmethods, and a protocol declaring a read-write property:
p20814
aVSo you are absolutely right, implementing a property means implementing one or two methods, depending on whether you implement a read-only, write-only, or a read-write property
p20815
as(dp20816
g6
V335858
p20817
stp20818
a((dp20819
g2
(lp20820
V cannot be represented exactly as a floating-point number, but  can represent this value exactly (that's why we need NSDecimals in the first place)
p20821
aVAccording to IEEE 754 Calculator,  gets converted to , which is less than , and therefore compares as
p20822
as(dp20823
g6
V335858
p20824
stp20825
a((dp20826
g2
(lp20827
VDo variables declared in methods get erased after the method call is done
p20828
aVYes
p20829
aVObjective C methods are implemented "on top" of C functions, so the same rules apply
p20830
aVIn particular, your code exhibits undefined behavior (reading of uninitialized variable)
p20831
aVTo fix this issue, add an instance variable  in place of the automatic variable that your code snippet currently declares
p20832
aVautomatic is the "official" name of "stack" variables, i
p20833
ag630
aVvariables that you declare inside your methods / functions
p20834
as(dp20835
g6
V335858
p20836
stp20837
a((dp20838
g2
(lp20839
VIn order to change the text on the label, you need to assign its  property:
p20840
aVThe  is very flexible, it lets you create new s using a format string as a template, and replacing format specifiers with additional data that you can pass to the method
p20841
aVEntries with  inside the string get replaced with the data items that you pass
p20842
aVor  mean "integer",  or  mean "floating point", and so on
p20843
aVHere is the list of all specifiers
p20844
as(dp20845
g6
V335858
p20846
stp20847
a((dp20848
g2
(lp20849
VEndianness effects the order of bytes in multibyte words, not the order of bits in a byte itself
p20850
aVSo 1 is
p20851
aVand 256 is
p20852
as(dp20853
g6
V335858
p20854
stp20855
a((dp20856
g2
(lp20857
VYes, you can free memory allocated in a function that you call outside the function; this is precisely what you need to do in this case
p20858
aVAlternatives include passing a buffer and its length into the function, and returning the actual length to the caller, the way  does
p20859
aVThis may not be the best alternative, because the callers would need to call your function in a loop
p20860
as(dp20861
g6
V335858
p20862
stp20863
a((dp20864
g2
(lp20865
VIn Java you are returning a new object wrapper of type ; in Objective-C there is no object like that
p20866
aVThe object that you are returning in Java represents a single byte or  if the byte wasn't there (i
p20867
ag630
aVthe length of data array was zero)
p20868
aVThe closest thing in Objective-C would be :
p20869
aVYou would need to unwrap the value on the receiving end:
p20870
aVNote that the way you compute  by dividing  by the size of the element works only for C array objects
p20871
aVIt does not work for pointers and C arrays passed to your method
p20872
aVIf the array is passed into your method, its length needs to be passed as well
p20873
as(dp20874
g6
V335858
p20875
stp20876
a((dp20877
g2
(lp20878
V(from the comment) can I do above linq query with List
p20879
aVYes, here is how you can do it with :
p20880
aVThe  presents an interface that lets you enumerate its property-value pairs as if they were in a dictionary, making the process of checking them a lot simpler
p20881
as(dp20882
g6
V335858
p20883
stp20884
a((dp20885
g2
(lp20886
VYou get 8 bytes because the pointer on your computer is 64-bit
p20887
aVHence,  returns 8 -- you get the size of the pointer, not the size of the array
p20888
aVYou should be passing the size of the data to write alongside the pointer, for example, like this:
p20889
as(dp20890
g6
V335858
p20891
stp20892
a((dp20893
g2
(lp20894
VYou should put the text in your model class (assuming that you have one; if you don't, you need to create it)
p20895
aVWhen the end-user edits the text field, your code should change the string in your model; when the label displays, you should read its text from the model
p20896
aVThe easiest way of sharing your model among multiple classes is to define a singleton
p20897
aVHeader:
p20898
aVImplementation:
p20899
aVUsing the model:
p20900
as(dp20901
g6
V335858
p20902
stp20903
a((dp20904
g2
(lp20905
VThe straight call to
p20906
aVwill create a "shallow" copy: the list will be new, but the objects will be the same
p20907
aVIf you would prefer a "deep" copy, you can use LINQ to duplicate your items before adding them to the list:
p20908
aVAssuming that your class has a constructor that takes an instance of itself and produces a copy, similar to a copy constructor of C++, this would produce a list of copies of your objects
p20909
as(dp20910
g6
V335858
p20911
stp20912
a((dp20913
g2
(lp20914
VThe most likely problem is in the declaration of : if you declared it as holding seven characters or less, and forgot to allocate space for terminating zero, you'd get the results that you are describing
p20915
aVwill have enough space for strings of length 6 or less; for strings of length 7, you need
p20916
as(dp20917
g6
V335858
p20918
stp20919
a((dp20920
g2
(lp20921
VSince  is a variadic function implemented within the constraints of C, it cannot perform the cast internally: it is not possible to find the type of an argument passed in the vararg section of the function
p20922
aVObjective-C compiler will perform the default type promotions before making the call, but the  is converted to , not to  by default
p20923
aVThat is why you should either insert an explicit cast, or use a different format specifier
p20924
as(dp20925
g6
V335858
p20926
stp20927
a((dp20928
g2
(lp20929
VUnless some special "fast location" capabilities are required, such as search by last name or by student ID, a list would be an appropriate collection to use
p20930
aVIf you do need to organize your students by some attribute, say, by student ID, consider using :
p20931
aVgives you a predictable order of iteration
p20932
aVYou could use a regular , but the order of iteration will be arbitrary
p20933
aVFinally, you could use a , which would base the order of iteration on the ordering of the keys
p20934
as(dp20935
g6
V335858
p20936
stp20937
a((dp20938
g2
(lp20939
VUse
p20940
as(dp20941
g6
V335858
p20942
stp20943
a((dp20944
g2
(lp20945
VIt is very similar in C/C++:
p20946
aVLink to ideone implementation
p20947
as(dp20948
g6
V335858
p20949
stp20950
a((dp20951
g2
(lp20952
VI think there is nothing wrong with this design: it clearly designates  as a base, and  /  as instantiable classes
p20953
aVI would rename  to  (Java class libraries do this) to underscore the fact that the intended use for the class is to be used as a base for other classes
p20954
aVThere are C++ - specific issues, such as assignment through the base pointer, that make it very desirable to make all "non-leaf" classes abstract
p20955
aVAlthough the rule does not translate to Java literally, I think it is still a good idea to make non-leaf classes abstract, even when the class is self-sufficient
p20956
aVThis helps you make explicit separation between classes intended for direct instantiation and classes intended for extending, which is good for maintenance by people who are not familiar with your code base
p20957
aVTaking the rule a step further, it is a common practice in Java to make all leaf classes
p20958
aVThis is a good defensive rule, especially when your classes are immutable
p20959
aVEDIT : As far as modeling items in the cart goes, inheriting is not the best option
p20960
aVIn fact, I think it is a wrong thing to do
p20961
aVI would make my  own an , rather than extending it, because the item does not become another kind of entity by being placed in a cart
p20962
aVHere is how I think it should be modeled:
p20963
as(dp20964
g6
V335858
p20965
stp20966
a((dp20967
g2
(lp20968
VYou can split the string into the first character and the rest of the string, and then insert a dot  in between, like this:
p20969
aVYou can also use  to do it on longer strings, like this:
p20970
aVThis prints
p20971
as(dp20972
g6
V335858
p20973
stp20974
a((dp20975
g2
(lp20976
VIt looks like you are not including the header where  macro is defined
p20977
aVThat is why the compiler is complaining about an implicit declaration: it thinks it's a function returning an
p20978
as(dp20979
g6
V335858
p20980
stp20981
a((dp20982
g2
(lp20983
VJava cannot do the second optimization, because it does not know that  is free of side effects
p20984
aVAs far as the first benchmark goes, I am sure this is a mistake of some sort: Java compiler calculates the results of constant expressions at compile time, so the first two loops are equivalent
p20985
as(dp20986
g6
V335858
p20987
stp20988
a((dp20989
g2
(lp20990
VSynchronizing on
p20991
aVmakes no sense, because if  is , each thread will get a new object every time
p20992
aVSynchronizing on separate objects has no effect: threads will continue right away, because nobody else could possibly synchronize on the same  object
p20993
aVYou should initialize  in the constructor, before the first thread tries to obtain a lock
p20994
as(dp20995
g6
V335858
p20996
stp20997
a((dp20998
g2
(lp20999
VThis format is called binary-coded decimal
p21000
aVFor two-digit numbers, integer-divide by ten and multiply by sixteen, then add back the remainder of the division by ten:
p21001
as(dp21002
g6
V335858
p21003
stp21004
a((dp21005
g2
(lp21006
VAdd them to the list of acceptable characters one by one, like this:
p21007
aVHere is this example on ideone
p21008
aVSince you are using  into a buffer of limited size, it is a good idea to add a size constraint to the format specifier in order to avoid buffer overruns:
p21009
as(dp21010
g6
V335858
p21011
stp21012
a((dp21013
g2
(lp21014
VAll numbers in Lua are floating point1
p21015
aVYou can tell is a number represents a number with non-zero fractional part by using
p21016
aV1 Unless lua's code itself is compiled with a flag that instructs it to use integers instead of floating-point numbers, in which case you cannot use floating point numbers in your programs at all
p21017
as(dp21018
g6
V335858
p21019
stp21020
a((dp21021
g2
(lp21022
VThis may be marginally better, but not by much:
p21023
aVAfter declaring  you can stop calling ; you can also create a two-element array with an aggregate
p21024
as(dp21025
g6
V335858
p21026
stp21027
a((dp21028
g2
(lp21029
VYou can do it without external libraries: create a predicate with your expression followed by , and take its left expression
p21030
aVYou can then evaluate that expression, like this:
p21031
as(dp21032
g6
V335858
p21033
stp21034
a((dp21035
g2
(lp21036
VThey show you a decimal representation of a 64-bit binary number
p21037
aVTheir code interprets the number as an upside-down  matrix of bits, with the initial 16-bit portion thrown away
p21038
aVThe bits are re-grouped below to illustrate what is going on
p21039
aVI groped by bits by six, and put an asterisk for  and a space for  to produce an image below:
p21040
aVOn windows you can use the calculator application to convert binary to decimal and back
p21041
aVChoose [View/Programmer], and then select "Bin" radio button
p21042
aVHere is how you can convert a number to binary in Objective C:
p21043
as(dp21044
g6
V335858
p21045
stp21046
a((dp21047
g2
(lp21048
VYou need per-instance space to store member variables, but member functions are not part of an instance, at least not directly
p21049
aVThere is usually a single extra pointer that is required for each additional virtual member function, but that pointer goes to vtable which is shared among all instances of a class, and therefore does not add to per-member size
p21050
aVNon-virtual member functions take space only in the code memory: their space requirements are no different from free-standing functions, the only difference being the hidden parameter for passing the pointer to
p21051
aVThe first virtual function added to a class adds an extra pointer to the space required to store an instance; additional non-virtual member functions do not play into space requirements at all
p21052
as(dp21053
g6
V335858
p21054
stp21055
a((dp21056
g2
(lp21057
VThere is little you can do to the process of producing the negated value, but you can make the syntax of invoking it look less bulky by hiding your code in a category:
p21058
aVNow you can use the new method like this:
p21059
aVYou could also set up an  with inversions, and use it as follows:
p21060
as(dp21061
g6
V335858
p21062
stp21063
a((dp21064
g2
(lp21065
VYour methods are all wrong, because you modeled your operation incorrectly
p21066
aVIt is not supposed to contain its result, and it should do only one operation, not all of them
p21067
aVOperation object should be immutable, and it should produce an answer to a specific operation given two operands
p21068
aVYou should separate binary operations from unary as well
p21069
aVNow you can organize your operators by name:
p21070
aVWith this map, you can use your operations to perform calculations for you:
p21071
as(dp21072
g6
V335858
p21073
stp21074
a((dp21075
g2
(lp21076
VThe second method wins
p21077
aVAccording to the Java Language Specification (pdf),
p21078
aVThe first phase (15
p21079
aV12
p21080
ag839
aV2) performs overload resolution without permitting
p21081
aVboxing or unboxing conversion, or the use of variable arity method invocation
p21082
aVIf an applicable method is found during this stage, that method wins; no further search is performed
p21083
aVIn your case, it happens to be the second method, because the first one is a variable arity method that also requires boxing
p21084
as(dp21085
g6
V335858
p21086
stp21087
a((dp21088
g2
(lp21089
VThat's relatively simple, just leave out the autoincrement column from the column list:
p21090
aVPrepare the statement, set the two parameters, and execute in non query mode
p21091
as(dp21092
g6
V335858
p21093
stp21094
a((dp21095
g2
(lp21096
VYou need to mark the variable  in order for this example to work
p21097
aVWithout , the reading thread will read  once, and not read it again, because the compiler knows that the variable has not been written to
p21098
as(dp21099
g6
V335858
p21100
stp21101
a((dp21102
g2
(lp21103
VYou can do it like this:
p21104
aVThe "relative cleanliness" of the bracket vs
p21105
aVdot notation is in the eye of the beholder
p21106
aVExpressions like yours are OK, but longer chains of four or more look shorter, if not cleaner, when written using the dot notation
p21107
aVOne advantage of bracket notation is that you do not need to cast an  to the target type; dot notation will not work without a cast:
p21108
as(dp21109
g6
V335858
p21110
stp21111
a((dp21112
g2
(lp21113
VNo, there is no such syntax in Java, but there is an API (reflection) that lets you do that, albeit in a less direct way
p21114
as(dp21115
g6
V335858
p21116
stp21117
a((dp21118
g2
(lp21119
VThere are two problems with your statement - a real and a potential one:
p21120
aVReal: the semicolon before the  keyword needs to be removed
p21121
aVPotential: the statement needs to be converted for use with parameters, otherwise a single quote in the body of any of the string parameters will cause a syntax error
p21122
aVHere is how you can switch to parameterized prepared statements:
p21123
as(dp21124
g6
V335858
p21125
stp21126
a((dp21127
g2
(lp21128
VYou cannot do what you are trying to do: first, it is not possible to list several classes in a generic constraint; second, the type that you can put in a constraint must be such that you could inherit it (or implement it if it is an interface)
p21129
aVBoth  and  fail this check
p21130
aVIn cases like this, you would be better off with two separate overloads
p21131
as(dp21132
g6
V335858
p21133
stp21134
a((dp21135
g2
(lp21136
VSince you pass  to your view's , it gets created with the size of zero
p21137
aVYou need to pass a rectangle where the view is to be displayed, using
p21138
aVAs far as handling touches goes, you can customize it in your subclass of the scroll view by intercepting
p21139
aVThere is also a  flag that lets you control the timing of the events sent to your handling code
p21140
as(dp21141
g6
V335858
p21142
stp21143
a((dp21144
g2
(lp21145
VYou are passing uninitialized pointers to , which uses them to perform the writes; this is undefined behavior
p21146
aVYou are also passing an address of a string pointer to  and ; strings in C are pointers already, you should not pass pointers to them to I/O routines
p21147
aVIf you know a limit on the number of characters in a name / a city name, you can read strings like this:
p21148
as(dp21149
g6
V335858
p21150
stp21151
a((dp21152
g2
(lp21153
VYou need to provide forward declarations only when you are not including the header for the corresponding class
p21154
aVSince you are including both  and  already, you should skip the corresponding forward declarations altogether
p21155
aVIn the , however, you do not need : you are declaring a pointer to , not using its members, so you do not need an include
p21156
aVThe general rule is that you should forward-declare your classes if all you need is a pointer, and include their headers when you need knowledge of the members of the class
p21157
as(dp21158
g6
V335858
p21159
stp21160
a((dp21161
g2
(lp21162
VYes, a linked list per bucket is one way to do it: if the item is in the list, you are done; otherwise, add a new item at the end of the list
p21163
aVThe other is to try the next bucket in the table in a loop, until you find an empty one
p21164
as(dp21165
g6
V335858
p21166
stp21167
a((dp21168
g2
(lp21169
VYou are missing a pair of parentheses after :
p21170
as(dp21171
g6
V335858
p21172
stp21173
a((dp21174
g2
(lp21175
VYou should use  instead of , it does what you are looking for
p21176
aVI am not sure if the inner  is necessary, you may be able to get away with a  instead of materializing the intermediate list
p21177
as(dp21178
g6
V335858
p21179
stp21180
a((dp21181
g2
(lp21182
VThe error message means that the code is attempting to call method  on an object that does not have a method called
p21183
aVIf this is a method that your button is calling, you need to define it in your view controller class, presumably along with
p21184
aVmethods
p21185
aVHaving ten methods may be suboptimal, though: a better approach would be to tag the buttons with tags corresponding to their respective digits, use the same method for all digit buttons, and harvest the tag inside the invocation
p21186
aVis an  property of , defined as follows:
p21187
as(dp21188
g6
V335858
p21189
stp21190
a((dp21191
g2
(lp21192
VThe only way to do it short of employing  where available is to guard the  branch of the outer  statement with a separate condition, rather than making it an  branch
p21193
aVAssuming that there are calculations preceding the nested  that prevent you from performing both checks at once, you could do this:
p21194
aVHowever, if the code in your conditions literally consists of calling functions  and , there is no harm in duplicating the invocation of the  function inside the nested  branch
p21195
as(dp21196
g6
V335858
p21197
stp21198
a((dp21199
g2
(lp21200
VIt should be , not , to set the additional bits
p21201
aVYou could also join string representations together, and pass the result to  method
p21202
aVThis is not as efficient, but the code will look shorter
p21203
aVThis returns  for  (link to ideone)
p21204
as(dp21205
g6
V335858
p21206
stp21207
a((dp21208
g2
(lp21209
VThere are three main categories of variables in Objective-C:
p21210
aVInstance variables
p21211
aVStatic-scope variables (static, global, and function-static)
p21212
aVAutomatic-scope variables (locals and function/method parameters)
p21213
aVWhen you declare and synthesize a property, an instance variable is created for you
p21214
aVLocal variables, on the other hand, are declared in the scope of a code block, and cannot be declared through a property
p21215
as(dp21216
g6
V335858
p21217
stp21218
a((dp21219
g2
(lp21220
V cannot contain  objects
p21221
aVThere are two possibilities to get a  back from :
p21222
aVYour dictionary itself has not been initialized, or
p21223
aVThere is no object for the key that you have specified
p21224
aVPlease make sure that you have created an instance of your  or a compatible class (say, ) and assign it to the variable prior to querying it for the key
p21225
aVThen make sure the key in question contains an object
p21226
as(dp21227
g6
V335858
p21228
stp21229
a((dp21230
g2
(lp21231
VIt looks like  is declared as
p21232
aVIn order to get an item of type  from it you have to provide two indexes, not one
p21233
aVOn the other hand, if you are looking to get an entire sub-array from , the left side of the assignment needs to be compatible with a 1-D array of , for example, an  pointer
p21234
as(dp21235
g6
V335858
p21236
stp21237
a((dp21238
g2
(lp21239
VInstead of  which compares pointers, you should use  which compares contents of strings
p21240
as(dp21241
g6
V335858
p21242
stp21243
a((dp21244
g2
(lp21245
VTry this:
p21246
aVThe idea is to use LINQ's  function to find the first matching item without a loop
p21247
as(dp21248
g6
V335858
p21249
stp21250
a((dp21251
g2
(lp21252
VYou can use  to make a button of a standard type: a detail disclosure, an info, and so on
p21253
aVIn these cases you would not need to set the image at all - the system will do it for you automatically
p21254
aVWhen you pick rounded rectangle and set the image, the image would be clipped to the rounded rectangle's border; when you pick custom style, there will be no clipping
p21255
as(dp21256
g6
V335858
p21257
stp21258
a((dp21259
g2
(lp21260
VAs far as I know, there is nothing built in to address this problem
p21261
aVThe , , and  do not provide reliable approaches, because they would give you the size of an empty object or even an object pointer
p21262
aVThis means that the size of a ten-character string and the size of a hundred-character string would measure the same if you take any of these approaches
p21263
aVYou can get a better approximation of the in-memory size of an object by checking its serialized size, but the objects inside your collection need to conform to  in order for this to work
p21264
aVYou can make an implementation of  that calculates the total size of data that has been passed to it for serialization, without serializing the data "for real"
p21265
aVPass this coder to your collection's  method, then harvest the total size of all objects in the collection
p21266
as(dp21267
g6
V335858
p21268
stp21269
a((dp21270
g2
(lp21271
VYou do not need to take a pointer to the array in order to pass it to an array-generating function, because arrays already decay to pointers when you pass them to functions
p21272
aVSimply make the parameter , and use it as a regular array inside the function, the changes will be made to the array that you have passed in
p21273
aVAs a side note, you do not need to pass the size by pointer, because you are not changing it inside the function
p21274
aVMoreover, it is not a good idea to pass a pointer to constant to a parameter that expects a pointer to non-constant
p21275
as(dp21276
g6
V335858
p21277
stp21278
a((dp21279
g2
(lp21280
VYou can flatten a tree like this:
p21281
aVYou can then filter by  using
p21282
aVTo earn some "points for style", convert  to an extension function in a static class
p21283
aVTo earn some points for "even better style", convert  to a generic extension method that takes a tree and a function that produces descendents:
p21284
aVCall this function like this:
p21285
aVIf you would prefer flattening in pre-order rather than in post-order, switch around the sides of the
p21286
as(dp21287
g6
V335858
p21288
stp21289
a((dp21290
g2
(lp21291
VAs you have undoubtedly found out, redirect would not work
p21292
aVAn ability to do what you are trying to achieve depends on the capabilities of your shell interpreter
p21293
aVYou can almost certainly write a batch file that does what you want, but you could as well make it a feature of your own program, rather than relying on batch files
p21294
aVIf your program is started like this:
p21295
aVthe arguments would be taken from ; if your program is started like this:
p21296
aVthen the arguments would be whatever is passed on the command line
p21297
as(dp21298
g6
V335858
p21299
stp21300
a((dp21301
g2
(lp21302
VYou can use math to calculate the area code and the local exchange code for your number:
p21303
aVdrops the last four digits, giving you
p21304
aVFurther dividing by  gives you ; taking the remainder of the division by  gives you
p21305
aVPlease note that using an  to represent a telephone number limits your ability to store some more exotic phone numbers, such as
p21306
aVUsing a class encapsulating a  with additional validations may prove to be a better alternative:
p21307
aVThis produces the expected output on ideone
p21308
as(dp21309
g6
V335858
p21310
stp21311
a((dp21312
g2
(lp21313
VYou can use a combination of  and  (link to ideone):
p21314
aVThe  syntax may look unusual: this is a pointer expression equivalent to , which produces a pointer
p21315
aVSince you can pass a pair of array pointers where  C standard library expects a pair of iterators, this produces the expected results
p21316
as(dp21317
g6
V335858
p21318
stp21319
a((dp21320
g2
(lp21321
VA call to  begins a new subpath
p21322
aVYou should call it once before your nested  loop, and then use only  to preserve line connectivity:
p21323
as(dp21324
g6
V335858
p21325
stp21326
a((dp21327
g2
(lp21328
VDictionaries retain the objects that you put into them (all cocoa collections do that), so you do need to release
p21329
aVAlternatively you could create it as an autoreleased object, like this:
p21330
aVThis way you would not need to release  explicitly
p21331
as(dp21332
g6
V335858
p21333
stp21334
a((dp21335
g2
(lp21336
VUnfortunately, there is no way to resolve it nicely: exception specifications are part of the interface, so if someone who programs to your  interface is not expecting to see , it shouldn't be coming to them when they use
p21337
aVA common way to resolve it is by introducing a common exception, and wrapping  in it:
p21338
as(dp21339
g6
V335858
p21340
stp21341
a((dp21342
g2
(lp21343
VThis should work:
p21344
aVA block should capture all variables that its body uses, including the  pointer
p21345
aVSince you are not modifying the pointer itself, only the data to which it points, you do not need to do anything else (if you needed to modify the pointer itself, you'd need an additional temporary variable declared as )
p21346
as(dp21347
g6
V335858
p21348
stp21349
a((dp21350
g2
(lp21351
VYou cannot make a polymorphic "push-style" method with different signatures, but you can make a polymorphic "pull-style" method using the well-publicized Visitor Pattern
p21352
aVThe idea is to invert the sequence of interaction, and let the car object decide what to do: Instead of calling  and giving the car what you think it needs, call  and let the car take what it knows it needs, like this:
p21353
aVNow the signature of your polymorphic method is fixed, but the dispatch of the method takes two legs instead of one:
p21354
aVYou call
p21355
aVThe car calls  or
p21356
as(dp21357
g6
V335858
p21358
stp21359
a((dp21360
g2
(lp21361
VThis is incorrect:  is a reference, a concept that is similar to pointers in certain ways, but not at all identical
p21362
aVReferences are similar to pointers in that a value can be changed through a reference, just like it can be changed through a pointer
p21363
aVHowever, there is no such thing as "null reference", while NULL pointers are very common
p21364
aVWhen you call a function that takes a reference, you simply pass the variable the reference to which you are taking - no  operator is required:
p21365
as(dp21366
g6
V335858
p21367
stp21368
a((dp21369
g2
(lp21370
VAlthough  is not an object but a value of a primitive type, Java makes every attempt to hide this fact from you
p21371
aVStarting with Java 5, primitives are automatically converted to their corresponding object wrappers when necessary, so that you could store them in containers, pass them to methods requiring objects, and so on
p21372
as(dp21373
g6
V335858
p21374
stp21375
a((dp21376
g2
(lp21377
VThe problem most likely has to do with the order of evaluation: the variable in question has not been initialized at the time of the , but by the time an action is executed, the initialization is complete
p21378
aVYou can try adjusting the timing by accessing your global from another callback that happens later than , but to avoid the problem altogether, you could use a global singleton instead of a global variable
p21379
aVMake a separate class in which you keep your global state, include its header in places where you need to use it, and call its class methods to access your global variables, like this:
p21380
aVHeader:
p21381
aVImplementation:
p21382
aVUsage:
p21383
as(dp21384
g6
V335858
p21385
stp21386
a((dp21387
g2
(lp21388
VSadly, this is the way the  methods of  work:
p21389
aVAdjacent occurrences of the separator characters produce empty strings in the result
p21390
aVSimilarly, if the string begins or ends with separator characters, the first or last substring, respectively, is empty
p21391
aVSince you know that the first element will always be empty, you can make a sub-array starting at element :
p21392
aVAlternatively, you can use  to chop off the initial bullet character from the string before passing it to the  method:
p21393
as(dp21394
g6
V335858
p21395
stp21396
a((dp21397
g2
(lp21398
VThis should give you what you need:
p21399
aVYou need to call
p21400
aVbefore this property starts to produce the correct values
p21401
as(dp21402
g6
V335858
p21403
stp21404
a((dp21405
g2
(lp21406
VThe path to  does not play into what happens when you run your program: the only question is whether the directory has any files or not, and from the log it appears that it doesn't
p21407
aVTo create some files in the directory, run these commands in the terminal window:
p21408
aVThis will create three empty files
p21409
aVNow run your program, and see if it discovers the newly created  files; it should
p21410
aVOn your second question, the operating system would not let you create multiple file system objects with identical names, so the answer is no, you created only one
p21411
as(dp21412
g6
V335858
p21413
stp21414
a((dp21415
g2
(lp21416
VThe  starts off at zero, so it compares lower than any positive number the user enters
p21417
aVIn general, you start off the minimum high and your maximum low before entering a loop
p21418
aVThis sacrifices two numbers from the available range, which is usually OK
p21419
aVAlternatively, you could set both  and  to the initial element of the sequence
p21420
aVThe other problem is your use of  instead of : it's not hurting the result, but it does hurt readability a lot
p21421
aVFinally, you can search for both the  and the  in the same loop
p21422
as(dp21423
g6
V335858
p21424
stp21425
a((dp21426
g2
(lp21427
VWhen it comes to regular expressions, a character is an indivisible atomic unit, so you need to create a character class in order to match bits within a character
p21428
aVThere are two ways to include or exclude a group of characters in a character class - by listing them individually, as in , or by specifying a range, as in
p21429
aVIn the worst case, your group would contain 128 elements covering a single bit
p21430
aVHowever, if you are matching higher-order bits, you can use ranges to group consecutive characters together
p21431
aVFor example, matching bit 8 is
p21432
aVmatching bit 7 is
p21433
aVmatching bit 6 is
p21434
aVand so on
p21435
as(dp21436
g6
V335858
p21437
stp21438
a((dp21439
g2
(lp21440
VIf you would like to call a  constructor with an int parameter representing capacity, pass an  array with a single element - the size:
p21441
as(dp21442
g6
V335858
p21443
stp21444
a((dp21445
g2
(lp21446
VIf you can expose an interface rather than a class, expose the interface; expose the class only if you must do so, for example, to expose methods not available on the interface
p21447
aVYou should do it both in your interface and in your class
p21448
aVThe rationale is that information hiding is a "good thing", so if you can do it without losing of generality, you should do so
p21449
as(dp21450
g6
V335858
p21451
stp21452
a((dp21453
g2
(lp21454
VThe  route is not feasible unless there is only one  in your program, and an instance of that robot is available statically
p21455
aVPassing a  to the task may be OK, but it might reveal too much information and prohibit task usages with objects other than robots
p21456
aVA third alternative would be to make an interface-like class for completion notifications, extending it in the , and calling it from the task
p21457
aVUnfortunately, C++ does not make it particularly easy by pushing you into the virtual inheritance territory
p21458
aVYou could adopt a callback approach that is common in POSIX thread libraries (passing a void pointer and a function pointer that takes a void pointer), but that is not too C++-ish
p21459
aVFinally, if you are using C++11, you have anonymous functions that let you address the issue very gracefully by wrapping both a function and an object on which it operates in a single closure without using an external library, such as boost
p21460
aVHere is a quick example of the third approach (link to ideone):
p21461
as(dp21462
g6
V335858
p21463
stp21464
a((dp21465
g2
(lp21466
V, , and  are just the abstractions given to the process by the operating environment to interact with its inputs and outputs
p21467
aVDespite the fact that there is only one keyboard (in most cases, anyway) the operating system knows how to decide which process gets the current input, and delivers the keystrokes to the  of that process
p21468
aVSimilarly, despite there being only one screen, it may be partitioned into several windows
p21469
aVFinally, many processes have their input and output tied to a file stream
p21470
aVOperating systems can let you bind multiple processes to a single input or to a single output file, but even in that case the objects representing  and  streams inside the process will be separate: they would reference the same object in the operating system, and the OS will manage sharing that object among its users
p21471
as(dp21472
g6
V335858
p21473
stp21474
a((dp21475
g2
(lp21476
VFirst, I am assuming that this is a homework of sorts, so I wouldn't spoil your exercise by fixing your code
p21477
aVHere is the idea: you need to create a boolean variable that indicates if the nested loop has found anything or not, set it to "not found" going into the loop, and checking it after the loop
p21478
aVIf the loop indicates that an item has been found, skip it; otherwise, add it
p21479
aVRemember, you can do it only after the nested loop has finished, so calling  inside the nested loop is premature
p21480
as(dp21481
g6
V335858
p21482
stp21483
a((dp21484
g2
(lp21485
VYou cannot add gesture recognizers to layers, so you need to add a gesture recognizer to its containing view, and then perform an additional test to see if the tap happens to overlap the layer in question
p21486
aVAdd tap gesture recognizer to the parent view of the layer (let's assume that it's called ), then add this code to the selector of your gesture recognizer:
p21487
as(dp21488
g6
V335858
p21489
stp21490
a((dp21491
g2
(lp21492
VFor a small number of intervals, the straightforward approach should do the trick
p21493
aVIf most intervals fold into each other, you can perform a preliminary step of merging them to reduce the number of tests
p21494
aVIf the number of disjoint intervals is high, build an Interval Tree
p21495
aVHere is a link to an article with code example in Java
p21496
as(dp21497
g6
V335858
p21498
stp21499
a((dp21500
g2
(lp21501
Vbut the class is not a derived class
p21502
aVThe class is a derived class - it implicitly inherits from
p21503
aVIt is not clear why anyone would invoke  constructor for , though: it is done implicitly as well
p21504
aVAs far as the syntax goes, my guess is that C# adopted a syntax that is close to C++ initializer lists, not to Java invocation of base constructors
p21505
as(dp21506
g6
V335858
p21507
stp21508
a((dp21509
g2
(lp21510
VThere are two common ways to process a recursive structure in C# - by using  and by writing a recursive function
p21511
aVI prefer the second way, here is an example:
p21512
aVYou can use this utility class as follows:
p21513
aVA somewhat cheating way would be to employ a "recursive" lambda:
p21514
as(dp21515
g6
V335858
p21516
stp21517
a((dp21518
g2
(lp21519
VThese are two different things
p21520
aVThere are  permutations, but there is only one sorted order (the sorted permutation is the smallest lexicographically)
p21521
aVHere is an example of a sorted permutation:
p21522
aVHere is a list of permutations in lexicographic order:
p21523
aVHere is a program in C++ to generate permutations in lexicographic order:
p21524
as(dp21525
g6
V335858
p21526
stp21527
a((dp21528
g2
(lp21529
VSplitting for words does not require regex, string provides this capability:
p21530
aVis a LINQ extension method for converting  objects to lists ( method returns an array of strings)
p21531
aVTo group a list by 5 words, use this code snippet:
p21532
as(dp21533
g6
V335858
p21534
stp21535
a((dp21536
g2
(lp21537
VThere is no difference between the two
p21538
aVYou use a custom name when you want to break the established convention of + in cases when the alternative names make more sense from the point of view of English grammar
p21539
aVFor example,
p21540
aVreads better than
p21541
aVYou could have declared your property as , but then your setter would be , which sounds slightly worse than
p21542
as(dp21543
g6
V335858
p21544
stp21545
a((dp21546
g2
(lp21547
VOnce you get the content of the directory, call 's  method on the path of each file
p21548
aVThe method returns an  of file attributes of each particular file
p21549
aVGrab the attributes that you want using their keys - , , , and so on; all keys are listed in the documentation
p21550
aVThis will give you everything except the icon, for which you need to use 's  method
p21551
as(dp21552
g6
V335858
p21553
stp21554
a((dp21555
g2
(lp21556
VThe output does not "become stupid": you simply let your output stream choose the format for your floating-point numbers, and it picks scientific notation
p21557
aVThis gives you  (which means ) instead of
p21558
aVThe use of  tells the stream that you do not want scientific notation; you could also use  to force the scientific format
p21559
aVSince the precise format depends depends on your application requirements, the choice to use  or  is ultimately up to you
p21560
as(dp21561
g6
V335858
p21562
stp21563
a((dp21564
g2
(lp21565
VBoth C and C++ have function pointers that let you do what you are looking for:
p21566
aVThe  in parentheses is optional
p21567
aVThe reason you did not find anything on the topic is that for historic reasons both functions and procedures in C are called functions (the reason is that there were no  in the original language - procedures returned  by default, and the return value was ignored)
p21568
aVC++ inherited this naming convention
p21569
as(dp21570
g6
V335858
p21571
stp21572
a((dp21573
g2
(lp21574
VYou cannot instantiate an abstract class directly
p21575
aVThe reason it is declared abstract is that it is not meant to be used by itself - you have to provide an implementation of its abstract methods first
p21576
aVYou need to inherit your own class from the abstract base, implement its abstract methods, and then instantiate your class
p21577
aVAn instance of your class is automatically an instance of its abstract base
p21578
as(dp21579
g6
V335858
p21580
stp21581
a((dp21582
g2
(lp21583
VWhat you see is undefined behavior: it might work, or it may crash
p21584
aVThe pointer is pointing to a deleted instance - it is a dangling pointer
p21585
aVThis is an undefined behavior as well: you may see a zero or a garbage value
p21586
aVEric Lippert provided a very nice "book in a table drawer of a hotel room" analogy in his answer to a question about pointers to local variables after the function has returned, it is equally applicable here
p21587
as(dp21588
g6
V335858
p21589
stp21590
a((dp21591
g2
(lp21592
VAssignments in Java do not copy objects, they copy references
p21593
aVAfter this assignment
p21594
aVyour  is no longer pointing to the  object that you have allocated and assigned to  , it's the same as , creating an alias to the same object
p21595
aVThe original  is now irretrievably lost, becoming eligible for garbage collection
p21596
aVThe following assingment
p21597
aVoverwrites the name in the  variable through its  alias, leading to the result that you see
p21598
as(dp21599
g6
V335858
p21600
stp21601
a((dp21602
g2
(lp21603
VThe simplest approach is to use , like this:
p21604
aVEDIT: If not using ARC, you might want to retain/autorelease the object, otherwise it might be removed from the array (and released) before  is called (thanks for omz for this excellent comment)
p21605
as(dp21606
g6
V335858
p21607
stp21608
a((dp21609
g2
(lp21610
VThere are several approaches of dealing with non-nullable value types:
p21611
aVUsing  (the shorthand name for it is ), or
p21612
aVDefining an "empty"  entry, similar to how Microsoft defined one for
p21613
aVMake your method return  instead of , and return  through an  parameter, the way it is done in
p21614
aVUsing a special value:
p21615
aVReturning :
p21616
as(dp21617
g6
V335858
p21618
stp21619
a((dp21620
g2
(lp21621
VYou can use this code to capture the string before a terminating word:
p21622
aVThis code produces the following output (link):
p21623
aVHere is how this expression works: the  means "any of the words listed in the inner parentheses, when they appear on word boundaries"
p21624
aVThe expression just outside allows for  in order to capture something even if none of the terminating words appear in the source
p21625
as(dp21626
g6
V335858
p21627
stp21628
a((dp21629
g2
(lp21630
VThis is because malloc saves the information about the length of the allocated chunk, usually in a spot that precedes the address returned to your program
p21631
aVIt is not unusual for implementations to allocate an extra storage for a size_t, put the size there, add sizeof(size_t), and return it to you as the malloc-ed pointer
p21632
aVThe standard does not call for this implementation, thoug, so alternative implementations are possible, e
p21633
ag303
aVbased on a hash table
p21634
as(dp21635
g6
V335858
p21636
stp21637
a((dp21638
g2
(lp21639
VIn this situation you need  because reference initialization requires a variable with an address, not simply a value
p21640
aVTherefore the compiler must create an anonymous variable which you cannot access other than through the reference; the compiler does not want you to access the variable that you did not declare
p21641
aVIf you would declare the variable explicitly,  would be unnecessary:
p21642
as(dp21643
g6
V335858
p21644
stp21645
a((dp21646
g2
(lp21647
VThis is a classic C++ implementation of the singleton pattern, described in one of Scott Meyers C++ books
p21648
aVSingleton is a controversial pattern, so there is no industry-wide consensus on singleton being good or bad
p21649
aVAn alternative to singletons is a purely static objects
p21650
aVThis question has a good discussion
p21651
as(dp21652
g6
V335858
p21653
stp21654
a((dp21655
g2
(lp21656
VFirst, clear off the bits that are set in the mask from
p21657
aVThen, clear off the bits that are not set in the mask from
p21658
aVFinally,  the two results together:
p21659
aVThe tilde  operator produces the negated mask
p21660
aVing with  zeroes out the bits of  that are set in the mask
p21661
as(dp21662
g6
V335858
p21663
stp21664
a((dp21665
g2
(lp21666
VThere is no flaw in design - in fact, this design is only one step away from the well-known and very useful composite pattern
p21667
aVHowever, there is a significant flaw in the implementation
p21668
aVYour  aggregates instances of , rather than aggregating pointers
p21669
aVThis kills the ability to use elements of the  polymorphically
p21670
aVYou need to replace a vector of instances with a vector of pointers (preferably, smart pointers) in order to address this issue
p21671
aVA classic place for the composite pattern is representation of expression trees: you start off with an abstract base, and then add representations for constants, variables, function calls, unary expressions, binary expressions, conditionals, and so on
p21672
aVExpressions such as constants and variables do not reference other expressions, while expressions such as unary expressions, binary expressions, and function calls do
p21673
aVThis makes the object graph recursive, letting you represent expressions of arbitrary complexity
p21674
as(dp21675
g6
V335858
p21676
stp21677
a((dp21678
g2
(lp21679
VYou can use this expression  and this replacement:
p21680
as(dp21681
g6
V335858
p21682
stp21683
a((dp21684
g2
(lp21685
VYou can use  to make an in-memory representation first, and then write that representation into a file, like this:
p21686
aVThis assumes that the number of items is relatively small, because the string representation is created entirely in memory
p21687
aVReading back is not as nice as writing out, though: you start by reading back a string, theb split it to components using , and then go through components in a loop or with a block, adding  for each element of your split
p21688
as(dp21689
g6
V335858
p21690
stp21691
a((dp21692
g2
(lp21693
VThe problem that you are observing has to do with undefined behavior: you are writing to the memory that has been allocated to a string literal
p21694
aVTo avoid the issue, you should switch to using C++ : it makes your code a lot simpler by taking memory management out of the picture
p21695
as(dp21696
g6
V335858
p21697
stp21698
a((dp21699
g2
(lp21700
VCompiler cannot discriminate by return type because return values can undergo conversion before the assignment is performed
p21701
aVThe object on which the function is invoked, on the other hand, is a parameter (albeit an implicit one) to the function, so the compiler can discriminate on it
p21702
as(dp21703
g6
V335858
p21704
stp21705
a((dp21706
g2
(lp21707
VAssuming that the words are separated by single space, you can split and re-group like this:
p21708
as(dp21709
g6
V335858
p21710
stp21711
a((dp21712
g2
(lp21713
VAm I being lucky or am I missing something fundamental
p21714
aVYes, you are missing something fundamental: the compiler does not read the  from the memory as if the memory represented an
p21715
aVInstead, it reads a  as a char, and then sign-extends the value to fit in an , so   becomes   as well
p21716
aVSign-extending means adding s or s to the left of the most significant byte being extended, depending on the sign bit of that number
p21717
aVUnsigned types are always padded by zeros*
p21718
aVSign extension is usually done in a register by executing a dedicated hardware instruction, so it runs very fast
p21719
aV* As Eric Postpischil noted in a comment,  type may be signed or unsigned, depending on the C implementation
p21720
as(dp21721
g6
V335858
p21722
stp21723
a((dp21724
g2
(lp21725
VYou can provide the modal controller with an instance of parent before displaying it modally, letting it call you back:
p21726
aVDisplaying :
p21727
aVCalling back:
p21728
as(dp21729
g6
V335858
p21730
stp21731
a((dp21732
g2
(lp21733
VAnything that you can do with your regular classes you can do with singletons
p21734
aVThere is no language concept called "singleton", it is just a common usage pattern of regular Objective C classes
p21735
aVWhat makes a class a singleton is the way you ensure its instantiation happens only once, i
p21736
ag630
aVyour own supporting code
p21737
as(dp21738
g6
V335858
p21739
stp21740
a((dp21741
g2
(lp21742
VIt looks like you have missed a few  signs in some of your string literals:
p21743
aVTrying to access the resultant C strings as  causes bad access
p21744
as(dp21745
g6
V335858
p21746
stp21747
a((dp21748
g2
(lp21749
VWhen you declare a local variable without specifying a value, you need to assign it first before reading from it becomes valid
p21750
aVThe  that you see in your integer variable could be any garbage value, it is unspecified
p21751
aVReading this value is undefined behavior
p21752
aVThis is different from instance variables, which are initialized by default
p21753
as(dp21754
g6
V335858
p21755
stp21756
a((dp21757
g2
(lp21758
VThis method is implicitly defined by the compiler
p21759
aVFrom the documentation:
p21760
aVNote that for a particular enum type T, the implicitly declared public static T valueOf(String) method on that enum may be used instead of this method to map from a name to the corresponding enum constant
p21761
aVAll the constants of an enum type can be obtained by calling the implicit public static T[] values() method of that type
p21762
aVFrom the Java Language Specification, section 8
p21763
ag14950
aV2:
p21764
aVIn addition, if E is the name of an enum type, then that type has the following implicitly declared static methods:
p21765
as(dp21766
g6
V335858
p21767
stp21768
a((dp21769
g2
(lp21770
VThe  does not know of how the data is stored, so there are two choices for the  implementation:
p21771
aVMake it an abstract method, or
p21772
aVThrow  the way it does for many other methods, such as  or
p21773
aVOnly the first solution makes sense: collections must allow at least reading, while writing may be optional
p21774
as(dp21775
g6
V335858
p21776
stp21777
a((dp21778
g2
(lp21779
VYou have used  instead of
p21780
aVThis is incorrect: the  is a null character, while  is a multicharacter literal
p21781
aVMoreover, in C it is OK to skip a zero in your condition:
p21782
aVis a valid way to check character, integer, pointer, etc
p21783
aVfor being zero
p21784
as(dp21785
g6
V335858
p21786
stp21787
a((dp21788
g2
(lp21789
VTry this expression:
p21790
aVWhat this means is that the string must:
p21791
aVStarts and ends in a digit
p21792
aVContains at least one dash in the middle
p21793
aVafter the first digit and before the dash there's zero or more  characters
p21794
aVbetween the dash and the last digit there's zero or more  characters
p21795
as(dp21796
g6
V335858
p21797
stp21798
a((dp21799
g2
(lp21800
VSince the words that you are looking for are all five-character long, I can think of a rather ugly expression that would do the trick: let's say  is your base set, and  is your optional set
p21801
aVThen the expression
p21802
aVshould allow five-letter words of the structure that you are looking for
p21803
aVIn general, a need to count anything makes your regex non-readable
p21804
aVProblems like this one are good to illustrate this point: it is much easier to write  expression, and add an extra step in code to check that  appears in the text no more than once
p21805
aVYou can even use a regexp to do the additional check:
p21806
aVThe result in SQL would look as follows:
p21807
as(dp21808
g6
V335858
p21809
stp21810
a((dp21811
g2
(lp21812
VThe  utility should work for users without administrative rights
p21813
aVIn addition to specifying the user name and the password of your non-admin user you need to specify the database to which your user name has access:
p21814
aVAlternatively, you can "piggyback" on the windows login that has access to your database by specifying the  option:
p21815
aVWindows authentication should be turned on for this to work (try this out, or ask your DBA)
p21816
as(dp21817
g6
V335858
p21818
stp21819
a((dp21820
g2
(lp21821
VThe method  is on your view controller, not on your view
p21822
aVYou should set the target to :
p21823
aVEDIT (in response to the edit of the question) As omz has correctly noted, your  gets released upon 's  exit
p21824
aVThere are two ways of dealing with it:
p21825
aVFold the  method into the parent view controller, along with the code of , or
p21826
aVMake an instance variable for , rather than making it a local variable
p21827
as(dp21828
g6
V335858
p21829
stp21830
a((dp21831
g2
(lp21832
VThe entire array makes into the string, it is just that when you try displaying it only the portion up to the initial  is shown
p21833
aVHere is code to illustrate this point:
p21834
aVThis produces the following log output:
p21835
as(dp21836
g6
V335858
p21837
stp21838
a((dp21839
g2
(lp21840
VGlobal variables are already in the static memory, so C re-used the existing keyword  to make a global variable "file-scoped", and C++ followed the suite
p21841
aVThe keyword  hides your global from the map file
p21842
aVStatic members, on the other hand, are class-scoped, therefore they need to be available in the map file: other modules need to be able to access the static members of your class, both member functions and member variables, even if they are separately compiled
p21843
as(dp21844
g6
V335858
p21845
stp21846
a((dp21847
g2
(lp21848
VJava regex engine blocks special interpretation of all meta-characters between  and
p21849
aVFor example,  matches a single character (, , , or ), while  matches six characters - , , , , , and
p21850
aVSee the Special Characters section of the regex tutorial for more detail
p21851
aVThe method makes a regular expression from a string that is presumably provided externally (e
p21852
ag303
aVentered by a user)
p21853
aVSince the string may contain meta-characters, the method encloses the entire string in  and
p21854
aVIf the string already contains a , the method inserts the end of the quote, a match of , and a beginning of a new quote for each  that it finds
p21855
as(dp21856
g6
V335858
p21857
stp21858
a((dp21859
g2
(lp21860
VNo, it is not the same thing: arrays are reference objects, so  becomes an alias of , not its copy
p21861
aVAny assignment that you make to an element of  become "visible" through , and vice versa
p21862
aVIf you would like to make a copy of a single-dimension array, you can use its  method; note that the copy will be shallow, i
p21863
ag630
aVthe individual elements of the array will not be cloned (making the trick inapplicable to the 2-D array that you described in your post)
p21864
as(dp21865
g6
V335858
p21866
stp21867
a((dp21868
g2
(lp21869
VThis happens because you did not implement your initializers correctly
p21870
aVIn Objective C there is a concept of designated initializer, a single  function of your class that all other initializers must call
p21871
aVIt is the designated initializer that calls  directly; all other initializers need to call  indirectly by invoking the designated initializer
p21872
aVIn your particular case you need to move the code common to both your  and , if any, into the  initializer, and rewrite the plain  as follows:
p21873
aV** EDIT :** (in response to the comment indicating that this solution causes an infinite recursion) I think the reason why you get infinite recursion has to do specifically with implementation details of , which should not be inherited
p21874
aVAccording to Apple's documentation,
p21875
aVThe  class implements a specialized view controller that manages the navigation of hierarchical content
p21876
aVThis class is not intended for subclassing
p21877
aVInstead, you use instances of it as-is in situations where you want your application\u2019s user interface to reflect the hierarchical nature of your content
p21878
aVEDIT: The prohibition against subclassing has been lifted in iOS 6 - see the documentation for UINavigationController
p21879
as(dp21880
g6
V335858
p21881
stp21882
a((dp21883
g2
(lp21884
VSince the heights of the scroll view and its content match, and because it does not appear from your picture that you would like to add an empty space to the content, you should keep the  set to zero (as it is by default)
p21885
aVIf you would like the content's middle to be visible through the scroll view, set content offset to , like this:
p21886
as(dp21887
g6
V335858
p21888
stp21889
a((dp21890
g2
(lp21891
VThe behavior that you see is due to the fact that both  and  point to the same dictionary instance
p21892
aVThe change to one of them will always reflect in the other one
p21893
aVIf you do not want this behavior, make a copy of  before making it :
p21894
as(dp21895
g6
V335858
p21896
stp21897
a((dp21898
g2
(lp21899
VYou need to add a  loop at the top to get all the bytes
p21900
aVThe stream will attempt to read as many bytes as it can, but it is not required to return  bytes at once:
p21901
aVAn attempt is made to read as many as len bytes, but a smaller number may be read, possibly zero
p21902
aVEDIT: fixed while
p21903
as(dp21904
g6
V335858
p21905
stp21906
a((dp21907
g2
(lp21908
VSince your  and  are subviews of the same view, you can tag your label, and use  to find it from your button's action code:
p21909
as(dp21910
g6
V335858
p21911
stp21912
a((dp21913
g2
(lp21914
VHow to set a number for Rate instead of string
p21915
aVYou can use  instead of a string literal:
p21916
aVOther class methods for  include , , and
p21917
as(dp21918
g6
V335858
p21919
stp21920
a((dp21921
g2
(lp21922
VNo, this is not possible: imagine that  is compiled separately and given to you as a pre-compiled library to see why
p21923
aVSince  is not virtual, the compiler inserts a call straight to , without any indirection through vtable, into its output for
p21924
aVMoreover, the compiler could even inline the call if it chooses to do so, "baking in" the return of  into its output
p21925
as(dp21926
g6
V335858
p21927
stp21928
a((dp21929
g2
(lp21930
VIt looks like your  takes an  instance
p21931
aVYou need to prepare an array upfront in a loop, and then set it once, like this:
p21932
aVThis assumes that your  method expects an array of  instances wrapping s
p21933
as(dp21934
g6
V335858
p21935
stp21936
a((dp21937
g2
(lp21938
VThis is not confusing at all - in fact, this comes up all the time
p21939
aVThe way this works in model-view-controller systems is that you set up a model class, make it a singleton, and add references to that singleton in all controllers that need to share the data
p21940
aVModel
p21941
ag1177
aVModel
p21942
ag12457
aVNow you can use the shared session in your controller code: import , and write
p21943
as(dp21944
g6
V335858
p21945
stp21946
a((dp21947
g2
(lp21948
VTo check if a non-null  is empty, use  method:
p21949
aVIf a string could be , add a check before the length, like this:
p21950
aVIf you use Java-6 or later, you can simplify it further:
p21951
as(dp21952
g6
V335858
p21953
stp21954
a((dp21955
g2
(lp21956
VWhat you did here
p21957
aVis not a compare operation, it is a bit masking operation
p21958
aVThe compare operation is implicit in C and C++: an expression that evaluates to zero means "false", all non-zero values mean "true"
p21959
aVWhen used in a logic expression like yours, this is a shorthand for
p21960
aVNow to the bit operations: certain values represent bit combinations of two or more values
p21961
aVFor example,  represents a combination of a bit pattern for ALT (which is itself a combination of the left and the right ALT) and whatever other key that may be pressed at the same time
p21962
aVTo separate one value from a combination, a bit masking technique is used: a value that has ones in the bits of interest and zeros in all other bits (that's ) is AND-ed with the combination value (in your case, it's ) producing the bits of  in the bits indicated by s of
p21963
aVThe net result is that  will be non-zero only if the ALT has been pressed
p21964
as(dp21965
g6
V335858
p21966
stp21967
a((dp21968
g2
(lp21969
VYou were almost there:
p21970
aVgives you the whole element;  pulls an individual named attribute from it
p21971
as(dp21972
g6
V335858
p21973
stp21974
a((dp21975
g2
(lp21976
VThis kind of sorting is called Topological Sorting
p21977
aVThe easiest way to sort a list topologically is using a depth-first recursive search: the order in which you leave the nodes is reverse topological
p21978
aVIf you need to know the depth of a node in a tree so that you know how many dashes to place in front of a name, you can add an  variable to your depth-first recursive method
p21979
aVYou can borrow an implementation from Rosetta Code - it does not have one in C#, but the one in Java should be easy enough to translate
p21980
as(dp21981
g6
V335858
p21982
stp21983
a((dp21984
g2
(lp21985
VBinary search implies a sorted container
p21986
aVA set is either unordered (), in which case a binary search cannot be performed, or it is ordered (), in which case its lookup operation is already as efficient as a binary search (i
p21987
ag630
ag1783
as(dp21988
g6
V335858
p21989
stp21990
a((dp21991
g2
(lp21992
VYou can use this snippet for in-memory queries:
p21993
aVFor querying against SQL Server data source, you can use  to extract the day, the month, and the year, and compare them separately
p21994
as(dp21995
g6
V335858
p21996
stp21997
a((dp21998
g2
(lp21999
VSince you are putting the entire file into memory anyway, you might as well represent it as a structure that is easy to search:
p22000
aVCreate a mutable , with  keys and  values
p22001
aVRead the file into memory
p22002
aVGo through the string representing the file line-by-line
p22003
aVFor each , separate out the word part by searching for a  or a  character
p22004
aVGet a sub-string for the word (from zero to the index of the  or  minus one); this is your
p22005
aVCheck if the  contains your ; if it does not, add new
p22006
aVAdd  to the  that you found/created at the specific
p22007
aVOnce your are finished, throw away the original string representing the file
p22008
aVWith this structure in hand, you should be able to do your searches in time that no regex engine would be able to match, because you replaced a full-text scan, which is linear, with a hash look-up, which is constant-time
p22009
aV** EDIT: ** I checked the relative speed of this solution vs
p22010
aVregex, it is about 60 times faster on a simulator
p22011
aVThis is not at all surprising, because the odds are stacked heavily against the regex-based solution
p22012
aVReading the file:
p22013
aVSearching:
p22014
as(dp22015
g6
V335858
p22016
stp22017
a((dp22018
g2
(lp22019
VMethods that you pass to  do not need to be declared in a header file
p22020
aVIn fact, they do not even need to exist, as long as nobody tries to execute them at runtime
p22021
aVA string  is perfectly sufficient for the  to produce a valid selector for you; as long as the corresponding method is available at run-time (i
p22022
ag630
aVthe object's  returns  for it), the system will find and execute it correctly
p22023
as(dp22024
g6
V335858
p22025
stp22026
a((dp22027
g2
(lp22028
VYou need to create an array or another collection before you can use a  loop:
p22029
as(dp22030
g6
V335858
p22031
stp22032
a((dp22033
g2
(lp22034
VTry removing the parentheses:
p22035
aVIf you are curious of what's going on, search for the "most vexing parse"
p22036
as(dp22037
g6
V335858
p22038
stp22039
a((dp22040
g2
(lp22041
VYou are correct, running  multiple times may be suboptimal
p22042
aVCalling it once and then referencing its properties should be more efficient:
p22043
as(dp22044
g6
V335858
p22045
stp22046
a((dp22047
g2
(lp22048
VYou do not need to escape forward slash:
p22049
aVis a perfectly good string literal
p22050
aVThe  does not work because backslash  is an escape symbol in both C#'s string literals and regular expressions
p22051
aVTherefore, you need four backslashes to match a single backslash in a string
p22052
as(dp22053
g6
V335858
p22054
stp22055
a((dp22056
g2
(lp22057
VJava is not telling you that the file is not found, just that it may not be found at runtime, and your program is not ready to handle it
p22058
aVHere is one way to address this:
p22059
aVHere is another way:
p22060
aVThe first way ensures the compiler that your code is prepared to handle both exceptions separately; the second way ensures the compiler that your code is prepared to handle a superclass of both exceptions
p22061
aVThe two ways are not the same, because the second one covers more exceptions that the first one
p22062
aVFinally, there is an alternative to silence the compiler by declaring your function with a  block (either a common superclass or the two individual classes would do)
p22063
aVThis is a way to tell the compiler that your function has no idea of how to handle these exceptions, and that they should be handled by a caller
p22064
aVThe consequence of this approach is that every caller of your function must put a try/catch around the call, or declare the exceptions using
p22065
as(dp22066
g6
V335858
p22067
stp22068
a((dp22069
g2
(lp22070
VYou are very close - I think this should do it:
p22071
aVHere is a link to this example on sqlfiddle
p22072
as(dp22073
g6
V335858
p22074
stp22075
a((dp22076
g2
(lp22077
VIt depends on how you got your array in the first place
p22078
aVIf it is an array that is allocated in the automatic or static storage (i
p22079
ag630
aVa local or a global) there is nothing you can free, because you did not allocate anything (the compiler did it for you)
p22080
aVIf this is a dynamically allocated array, you can achieve the same effect by creating a smaller array with only eight elements, copying the original values into it, and then freeing the original array
p22081
aVThis does not guarantee that the amount of memory allocated to your program would necessarily go down, because the allocator of the eight-element array is allowed to allocate space for more elements
p22082
aVIf the numbers are 10000 and 8000, on the other hand, you will almost certainly get some savings (although the standard does not guarantee it either)
p22083
as(dp22084
g6
V335858
p22085
stp22086
a((dp22087
g2
(lp22088
VNo, the  variable of  will not change: once a reference is copied, it gets a life of its own
p22089
aVIf you change the  pointed by , however, 's parent will see that change
p22090
aVFor example, if you set ,  will change to  as well
p22091
as(dp22092
g6
V335858
p22093
stp22094
a((dp22095
g2
(lp22096
VThe problem is with the call of : you are averaging everything, not everything up to the  in the corresponding  position
p22097
aVYou are adding together all these zeros in the scores part to which you did not write, and then divide it by 100 - the length of the entire array
p22098
aVThe easiest way to address this issue is to return the position of the  entry from the  method:
p22099
aVNow you can use LINQ's  function to get the correct average:
p22100
as(dp22101
g6
V335858
p22102
stp22103
a((dp22104
g2
(lp22105
VThe big O of this is O(n^2)
p22106
aVAm i right
p22107
aVNo,  will be dominating over everything else, despite its tiny coefficient
p22108
as(dp22109
g6
V335858
p22110
stp22111
a((dp22112
g2
(lp22113
VYou are sorting before the names are populated; that does nothing
p22114
aVYou are printing a single item using a fixed multi-item list of parameter references  and so on; it is not going to work, and even if it did it would limit your output to the first seven items
p22115
aVYou do not know how many items to sort
p22116
aVChange  to return  (which is ), and use
p22117
aVThe simplest way to convert multiple strings into a single string is by using :
p22118
as(dp22119
g6
V335858
p22120
stp22121
a((dp22122
g2
(lp22123
VYou have a name collision with your own namespace
p22124
aVRename it, for example, to , or use full name of  for the 's  class:
p22125
as(dp22126
g6
V335858
p22127
stp22128
a((dp22129
g2
(lp22130
VYou should use a more reliable way of figuring out when you are at the end of the stream, rather than rolling your own counter with
p22131
aVYour method may not be precise enough, and the fact that you are using an unsafe code for that is also not too good
p22132
aVOne way probe if you are at the end of the stream or not is to use the  method:
p22133
aVA more common solution is to write the number of s that you are saving in a binary file in front of the actual list of integers
p22134
aVThis way you know when to stop without relying on the  length or the position of the stream
p22135
as(dp22136
g6
V335858
p22137
stp22138
a((dp22139
g2
(lp22140
VThe two problems are that you
p22141
aVperform an integer division ( returns an integer), and
p22142
aVyou swapped the dividend and the divisor (that's why you get zero instead of one)
p22143
aVThis is how you could fix it (note that  and  are swapped):
p22144
as(dp22145
g6
V335858
p22146
stp22147
a((dp22148
g2
(lp22149
VWill I get the LSB address of i, or the MSB
p22150
aVThis is platform dependent: it will be the lowest addressed byte, which may be MSB or LSB depending on your platform's endianness
p22151
aVAlthough this is not written in the standard directly, this is what's implied by section 6
p22152
ag14884
ag839
ag14884
aV7:
p22153
aVWhen a pointer to an object is converted to a pointer to a character type, the result points to the lowest addressed byte of the object
p22154
aVWill it act differently between platforms
p22155
aVYes
p22156
aVIs there a difference here between c and c++
p22157
aVNo: it is platform-dependent in both C and C++
p22158
as(dp22159
g6
V335858
p22160
stp22161
a((dp22162
g2
(lp22163
VAlthough LINQ2SQL queries performed against a database enjoy the indexes that may be defined in the database, there are no indexes for LINQ queries performed in memory
p22164
aVUnfortunately, you would need to roll your own: sort the list, use  to get the initial and the last positions, and then use LINQ to get all entries in between
p22165
as(dp22166
g6
V335858
p22167
stp22168
a((dp22169
g2
(lp22170
VCocoa provides  and , a pair of ordered containers similar to Java's  and C#'s
p22171
aVYou can add values to , and it will grow as you add more elements;  is read-only
p22172
as(dp22173
g6
V335858
p22174
stp22175
a((dp22176
g2
(lp22177
VTry moving your string manipulation to the Java side, and keep the SQL parameter:
p22178
as(dp22179
g6
V335858
p22180
stp22181
a((dp22182
g2
(lp22183
V is a C , you cannot pass  for it
p22184
aVYou can create a  separate method that does not take the unnecessary , and get rid of your  statement, like this:
p22185
aVIf you insist on keeping one method, you could designate one point as "special" (say, ), wrap it in a , and use instead of
p22186
aVYet another solution would be to wrap your  in :
p22187
as(dp22188
g6
V335858
p22189
stp22190
a((dp22191
g2
(lp22192
VThe  conveys the intent much better than the use of a default value, so I would definitely use it instead of checking for zero
p22193
aVIt also makes the check for nullness required, whereas if you are using a default value you may forget to do the check
p22194
aVIn case you do decide to go with zero as a "no parent", you should define a named constant for it:
p22195
as(dp22196
g6
V335858
p22197
stp22198
a((dp22199
g2
(lp22200
VIt does not matter, you can go either way
p22201
aVYou need to have at least one strong reference, and both choices provide it
p22202
aVIf you use strong references, the number of retain/release messages will increase, but the mechanics of this is hidden from you, so you would not notice anything
p22203
aVThere is an alternative choice that does not involve having references at all: make your model with its  array a singleton, and access it from your controllers as needed
p22204
aVThis way you would not need to pass it down to the next controller in the chain
p22205
as(dp22206
g6
V335858
p22207
stp22208
a((dp22209
g2
(lp22210
VThe problem that you see is related to the inability of the running  to find your dynamic library
p22211
aVThere are several system-dependent ways to deal with the issue
p22212
aVFor example, on Linux you can set  to include the directory where  is located
p22213
aVAlthough the compilation warnings are not related to the runtime error, it is still a good idea to fix them:
p22214
as(dp22215
g6
V335858
p22216
stp22217
a((dp22218
g2
(lp22219
VOf course there is - a simple loop would do the trick:
p22220
aVNote that the above code assumes that the lists are not empty
p22221
aVIf that assumption is not true, add a check for an empty list before getting the initial element
p22222
as(dp22223
g6
V335858
p22224
stp22225
a((dp22226
g2
(lp22227
VYou are missing a few things:
p22228
aVIf  is an Objective C object, as opposed to a C pointer, it is more conventional to assign  instead of
p22229
aVSame goes for string literals: if  is , you should assign  to it
p22230
aVOh, and  should not be enclosed in curly braces: the  token is sufficient to find where the implementation block ends
p22231
as(dp22232
g6
V335858
p22233
stp22234
a((dp22235
g2
(lp22236
VFrom the documentation of :
p22237
aV@property(nonatomic, assign) id dataSource
p22238
aVDiscussion
p22239
aVThe data source must adopt the UITableViewDataSource protocol
p22240
aVThe data source is not retained
p22241
aVThis means that  expects you to retain your data source object, which you did not do
p22242
aVSame goes for 's delegate (in fact, for almost any delegate in cocoa, except 's one)
p22243
aVThis design decision is made for a reason: the object that holds on to  very often also serves as its delegate
p22244
aVHad the delegate been retained, the programmers would have to deal with retain cycles
p22245
aVUnfortunately, the consequence of that decision is the problem that you are having: now you need to retain the data source (and the delegate, if any), e
p22246
ag303
aVby setting up an ivar
p22247
as(dp22248
g6
V335858
p22249
stp22250
a((dp22251
g2
(lp22252
VThe method that you provided in your post should work (cocoadev has relevant discussion)
p22253
aVHere is how you use this method:
p22254
as(dp22255
g6
V335858
p22256
stp22257
a((dp22258
g2
(lp22259
VA
p22260
aVWhere do I put this function in my Xcode project
p22261
aVPut the definition in a separate
p22262
aVc file, and a declaration in a separate header file
p22263
aVPrintFreeMem
p22264
ag1177
aVPrintFreeMem
p22265
ag13302
aVB
p22266
aVHow do I call it
p22267
aVYou can call it the way you call regular C functions, after including its header file:
p22268
as(dp22269
g6
V335858
p22270
stp22271
a((dp22272
g2
(lp22273
VMemory allocators are notoriously bad at allocating very small objects
p22274
aVThe situation has somewhat improved in the last decade, but the trick from the book is still relevant
p22275
aVMost allocators keep additional information with the block that they allocate to you, so that they could free the memory properly
p22276
aVFor example, the / pair of C or / pair of C++ needs to save the information about the length of the actual memory chunk somewhere; usually, this data ends up in the four bytes just prior to the address returned to you
p22277
aVThis means that at least four additional bytes will be wasted for each allocation
p22278
aVIf your tree node takes twelve bytes (four bytes for each of the two pointers plus four bytes for the number), sixteen bytes would be allocated for each node - a 33
p22279
aV3% increase
p22280
aVMemory allocator needs to perform additional bookkeeping as well
p22281
aVEvery time a chunk is taken from the heap, the allocator must account for it
p22282
aVFinally, the more memory your tree uses, the less is the chance that the adjacent node would be fetched in the cache when the current node is processed, because of the distance in memory to the next node
p22283
as(dp22284
g6
V335858
p22285
stp22286
a((dp22287
g2
(lp22288
VYour code produced  output on my system, so perhaps the problem has to do with your regional settings
p22289
aVThis answer provides information on how to make a date formatter that is independent of the local region settings of your system
p22290
as(dp22291
g6
V335858
p22292
stp22293
a((dp22294
g2
(lp22295
VSince hash tables are often used for building lookup tables that compilers use to look up information about symbols, such as variable names and function names, a compiler scenario is used to explain the point of #2
p22296
aVThe authors took a pair of variable names that are very commonly found in the same program,  and , and said that strings representing the names of these variables,  and , should not be hashed to the same slot
p22297
aVThis makes sense, because resolving hash collisions is the part of the lookup process that most negatively influences the speed
p22298
as(dp22299
g6
V335858
p22300
stp22301
a((dp22302
g2
(lp22303
VThis is an implementation of the null object pattern: a special object, , is designated to play the role of  in a situation where "real" s are not allowed
p22304
aVThe only requirement is that the null object must be different from all "regular" objects
p22305
aVThis way, the next time the program needs to find entries with no region, all it needs to do is a lookup by the  key
p22306
as(dp22307
g6
V335858
p22308
stp22309
a((dp22310
g2
(lp22311
VWhen we , we just print the character, and skip the switch altogether
p22312
aVThe loop goes through the format line looking for (1) a terminating zero, or (2) a percent sign
p22313
aVWhen the terminating zero is reached, the loop ends:
p22314
aVWhen a percent sign is reached, the following symbol is taken as a format character, and the next vararg is interpreted according to it
p22315
aVThere is a bug in this program - it produces a read past the end of the format string (an undefined behavior) when the percent symbol is the last character of the format string
p22316
aVTry this:
p22317
aVThe simulated end-of-line marker  is skipped, and the  output is produced
p22318
aVThe reason for this is an unconditional pre_increment of  in the header of the  statement
p22319
aVTo fix this problem, add the following case to the :
p22320
as(dp22321
g6
V335858
p22322
stp22323
a((dp22324
g2
(lp22325
VIf you have a  class representing the person (Bob, Bill, etc
p22326
aV, you can  on that instance
p22327
aVIf you do not have a class representing a , create a  that maps unique identifiers of your people to instances of named  objects
p22328
aVThe access to the dictionary itself should be synchronized
p22329
aVAlso note that mutex creation in
p22330
aVNET is non-trivial
p22331
aVSee this answer for details
p22332
as(dp22333
g6
V335858
p22334
stp22335
a((dp22336
g2
(lp22337
VSince you cannot implement mechanisms in software (although you can certainly model them), I assume that the question has been about the Elevator algorithm
p22338
aVThe algorithm looks deceivingly simple, yet it is surprisingly very tough to implement, even with a good set of data structures in hand
p22339
aVA good structure to use for this algorithm is three priority queues - (1) for the current direction with entries past the current point, (2) for the opposite direction, and (3) for the current direction prior to the current point
p22340
aVYour implementation would first decide the direction, then pick a queue into which to place the requested pair of  values
p22341
as(dp22342
g6
V335858
p22343
stp22344
a((dp22345
g2
(lp22346
VYou should not pay for what you do not use
p22347
aVUnlike plugged-in computers where CPU cycles cost you in terms of time, CPU cycles on a mobile device cost you both in time and in the battery use
p22348
aVIf your application is single-threaded, there is no reason to use , because the locking and unlocking operations would be a waste of time and battery
p22349
aVThe battery is more important than the time: while the latency associated with addition of extra operations may be invisible to your end-user, the cycles spent will reduce the time the mobile device can work after a single charge, a measure that a lot of users consider very important
p22350
as(dp22351
g6
V335858
p22352
stp22353
a((dp22354
g2
(lp22355
VYou should not be comparing  using the less then  operator
p22356
aVDepending on the content of the label, you should either convert the text to number and do a check, or compare strings alphabetically
p22357
aVThis is how to compare strings numerically, assuming that the text represents an integer number:
p22358
aVThis is how to compare strings alphabetically:
p22359
as(dp22360
g6
V335858
p22361
stp22362
a((dp22363
g2
(lp22364
VThis is a "poster-child" exercise for the  clause:
p22365
aVAt leasr one failed result:
p22366
aVAll passed:
p22367
aVSee how these queries work on your data set at
p22368
as(dp22369
g6
V335858
p22370
stp22371
a((dp22372
g2
(lp22373
VWith an asterisk and a square brackets, you are declaring an array of pointers to vectors instead of a vector
p22374
aVWith  you do not need square brackets or an asterisk:
p22375
aVThe reason the compiler thought that you were trying to call  on a  is that the square bracket operator, overloaded by the vector, is also a valid operator on an array or a pointer
p22376
as(dp22377
g6
V335858
p22378
stp22379
a((dp22380
g2
(lp22381
VYou are missing a space:
p22382
aVThe signature that you provided uses identifier  as the name of the first formal parameter, and an empty segment for the  parameter
p22383
as(dp22384
g6
V335858
p22385
stp22386
a((dp22387
g2
(lp22388
VYour teacher is absolutely right: even if you fix your program to return  in place of , your program still contains undefined behavior
p22389
aVThe issue is that the memory in which  used to be placed is ripe for reuse once  returns
p22390
aVThe memory may stay around untouched for you to access, so you might even print ten, but this behavior is still undefined: it may run on one platform and crash on ten others
p22391
as(dp22392
g6
V335858
p22393
stp22394
a((dp22395
g2
(lp22396
VI know there is the ability to constrain T to certain types
p22397
aVUnfortunately, the compiler has no idea that  is one of these types, so it has to complain
p22398
aVI only need it to work for ints, doubles, and bytes
p22399
aVYou can make three overloads then:
p22400
as(dp22401
g6
V335858
p22402
stp22403
a((dp22404
g2
(lp22405
VYou can use the fact that  is :
p22406
as(dp22407
g6
V335858
p22408
stp22409
a((dp22410
g2
(lp22411
VFrom the reference:
p22412
aVIf T is an arithmetic type (that is, an integral type or a floating-point type), provides the member constant value equal true
p22413
aVFor any other type, value is false
p22414
aVis an integral type, so the answer is
p22415
aVThe fact that the small integers that fit in a  are often interpreted as codepoints in a particular character encoding space is secondary
p22416
as(dp22417
g6
V335858
p22418
stp22419
a((dp22420
g2
(lp22421
VOne of the header files that you include contains a definition for , making the declaration
p22422
aVlook like
p22423
aVRenaming your  to something different, say , or  should help
p22424
as(dp22425
g6
V335858
p22426
stp22427
a((dp22428
g2
(lp22429
Vis there anyway to do it in linq or other
p22430
aVnet way
p22431
aVSure:
p22432
aVEDIT: (in response to a comment) If you would like to avoid the  part, you need either (1) a function that makes a mapping for you, or (2) a constructor of  that takes a  parameter:
p22433
aVOne way or the other, the  assignment needs to be made somewhere
p22434
as(dp22435
g6
V335858
p22436
stp22437
a((dp22438
g2
(lp22439
V"Multiple enumeration" is not an error, it is a warning (a re-sharper warning, if I am not mistaken)
p22440
aVYou can ignore it if you know for sure that you pass "materialized" collections (as opposed to ones obtained lazily, e
p22441
ag303
aVthrough a function that s its results)
p22442
aVIf changing the method signature to taking  makes sense because you want to pass results of various LINQ functions, then convert  inside your method
p22443
aVif you need to pass other collections in addition to arrays, use  instead of
p22444
aVIf the conversion is purely for aesthetic reasons, i
p22445
ag630
aVyou change the signature but keep passing arrays, you can ignore the warning altogether
p22446
as(dp22447
g6
V335858
p22448
stp22449
a((dp22450
g2
(lp22451
VYou are right, you should definitely refrain from implementing  as a call of
p22452
aVIn addition to a potential of creating an infinite chain of calls, that approach does not reflect  the symmetry of the operation in your code, because the code is not symmetric
p22453
aVA better approach is to implement a "symmetric" operation in a helper class or as a top-level function, depending on what is supported in your language, and then make both  and  call that helper implementation
p22454
as(dp22455
g6
V335858
p22456
stp22457
a((dp22458
g2
(lp22459
VThe easiest and IDE-independent way to do it is to encapsulate your variable behind a setter / getter pair, and add a statement to your code watching for setting the value :
p22460
aVWas:
p22461
aVChange to:
p22462
aVEncapsulating your variables is generally a good thing that usually proves useful outside of debugging context as well
p22463
as(dp22464
g6
V335858
p22465
stp22466
a((dp22467
g2
(lp22468
VThere are two relatively simple options to build a screen like that:
p22469
aVMake your controller a `UITableViewController, add two sections to the bottom of your static part, and put custom cells with buttons into these two sections, or
p22470
aVDefine the static content of your table in code
p22471
aVThe look of your screen will change slightly for option 1, but it is important only when you have many cells, forcing the sections with buttons off the screen until the user scrolls
p22472
aVThe second option requires writing some code, but not too much to cause you too much inconvenience
p22473
as(dp22474
g6
V335858
p22475
stp22476
a((dp22477
g2
(lp22478
VThe block that you are showing in your post is not an empty block, it is a static initializer
p22479
aVIt is used to provide non-trivial initialization for static variables of your class
p22480
aVLocal variables that you use during initialization go on stack, except for objects that you allocate from the heap
p22481
aVYou cannot access static variable  because you did not declare it
p22482
aVInstead, you declared a local variable  inside a static initializer
p22483
aVIf you would like to make  a static variable and then initialize it in a static initialization block, do this:
p22484
aVIn trivial cases like this, a straightforward initialization syntax works best:
p22485
aVInitializer blocks are reserved for more complex work, for example, when you need to initialize structures using a loop:
p22486
as(dp22487
g6
V335858
p22488
stp22489
a((dp22490
g2
(lp22491
VThe program segfaults because the pointer  is not initialized
p22492
aVYou need to allocate memory for the buffer before reading the data into it:
p22493
aVTo avoid restricting your input to  characters, use strings
p22494
aVThey resize dynamically as you need:
p22495
as(dp22496
g6
V335858
p22497
stp22498
a((dp22499
g2
(lp22500
VYou can do it in linear time  with this algorithm: construct vector  of the same size  as the original vector, such that  contains the length of the longest consecutive ascending run to which element  belongs
p22501
aVThe value of  can be calculated as follows:
p22502
aVWith  in hand, find the index of  element
p22503
aVThis is the last element of your run
p22504
aVTrack back to  to find the initial element of the run
p22505
aVNote that at each step of the algorithm you need only the element  to calculate , so you can optimize for constant space by dropping vector representation of  and keeping the prior one, the , and
p22506
aVHere is this algorithm optimized for constant space
p22507
aVVariable  represents  from the linear-space algorithm
p22508
aVHere is a link to this program on ideone
p22509
as(dp22510
g6
V335858
p22511
stp22512
a((dp22513
g2
(lp22514
VBoth ways that you tried should work
p22515
aVYour first approach sounds simpler to implement, but your second approach is more flexible
p22516
aVUsing your first approach, you can place the image behind the label using this the technique described in this answer, setting the dimensions of the entire label by setting its
p22517
aVThe  route should be rather straightforward, too
p22518
aVJust remember to set label's background to transparent, as described in this answer
p22519
as(dp22520
g6
V335858
p22521
stp22522
a((dp22523
g2
(lp22524
VThe problem is that  may have fewer than four characters, and your code does not check for that condition
p22525
aVChange your code as follows to account for this condition:
p22526
aVAlso note that your code as written does not "lock in" the  when characters are not equal to each other: for example,  and  will compare equal under your old algorithm
p22527
aVAdd  to exit the loop as soon as you see a
p22528
as(dp22529
g6
V335858
p22530
stp22531
a((dp22532
g2
(lp22533
VI think the problem has to do with the fact that your functions lack prototypes
p22534
aVIn cases like that, you should re-order functions so that the ones you call appear ahead of the ones that call them:
p22535
aVBut it is best to stick to using prototypes for all functions ahead of defining them
p22536
aVAlso note that string literals are
p22537
aVSince your functions do not modify the content of string literals, you should declare  instead of
p22538
as(dp22539
g6
V335858
p22540
stp22541
a((dp22542
g2
(lp22543
VThis is useful when you are planning to populate a collection with a large number of elements, or when you know the exact number of elements that you are going to load
p22544
aVResizing a collection takes CPU cycles, so resizing unnecessarily ultimately translates into reducing the time your device can operate on a battery
p22545
aVConsider this example: let's say you are about to load 3000 elements into an array
p22546
aVIf you allocate the default array with space for, say, 16 items, the array will need to resize eight times before arriving at the size necessary to hold 3000 elements
p22547
aVThe elements copied in the initial positions will need to be copied each time the array is resized, resulting in 3000+ additional copy operations
p22548
aVWhen you know the exact number of elements, you can prevent the copying from happening
p22549
aVIn addition, your array will not waste memory for elements that you are not going to add: if you add 3000 elements one by one, the array may grow to 4000 internally in anticipation of more elements; the last 1000 elements will be wasted
p22550
aVTo summarize, you should initialize your collections with capacity when you know the exact target size for sure
p22551
aVThis situation comes up often when you deserialize data from a file or a network connection
p22552
aVIn situations when you do not know the size, it is better not to make guesses, and let the default initialization run its course
p22553
as(dp22554
g6
V335858
p22555
stp22556
a((dp22557
g2
(lp22558
VHere is how you replace part of a string using , in response to  delegate call of :
p22559
as(dp22560
g6
V335858
p22561
stp22562
a((dp22563
g2
(lp22564
VThe reason the copy has not been made in this case is that  is immutable
p22565
aVYou do not need to make a copy of it to guard against changes to the array, because such changes cannot be made; it is sufficient to retain the same immutable array
p22566
aVIf you try this experiment with , you will get a different result
p22567
as(dp22568
g6
V335858
p22569
stp22570
a((dp22571
g2
(lp22572
VThe problem is that the  expects a  object as its first argument, while you are trying to pass it an integer ID instead
p22573
aVYou should change your code to either let  accept an integer  as its first argument, or by fetching a  by its  before calling the  method
p22574
as(dp22575
g6
V335858
p22576
stp22577
a((dp22578
g2
(lp22579
VLike all methods in Objective C, the  method can be inherited
p22580
aVIf you do not need to perform any initialization of the additional members of your class, you can use the  method of the superclass by omitting the method from your class
p22581
as(dp22582
g6
V335858
p22583
stp22584
a((dp22585
g2
(lp22586
Vthe single data type in Prolog is the term
p22587
aVThis statement is both correct and somewhat useless at the same time
p22588
aVIt goes to say that types do not play much role in Prolog: everything is a term, variables are untyped, they will unify with other terms as required
p22589
aVNumbers, atoms, and compound terms, on the other hand, are not data types - they are different kinds of of terms, which is slightly different
p22590
aVCompound terms further subdivide into lists, strings, and "other" kinds of functor-like terms
p22591
as(dp22592
g6
V335858
p22593
stp22594
a((dp22595
g2
(lp22596
VIf you are looking for an index of an item that is not zero (that may also be a non-digit) use this regular expression:
p22597
aVKeep in mind, Regex functions require the following library call:
p22598
aVThis will not work well when the string is composed entirely of zeros, so you may want to modify the expression to allow zero to be the last (or the only) character in the string:
p22599
as(dp22600
g6
V335858
p22601
stp22602
a((dp22603
g2
(lp22604
VYou get the error not because the functions are in different files: it is perfectly fine for functions from different compilation units to call each other
p22605
aVThe real problem is that you are trying to call a function from the other file without providing a prototype
p22606
aVWhen this happens, C assumes a return type of
p22607
aVMake a header file with this content:
p22608
aVget_data_byName
p22609
ag1177
aVNow include this header file in both of your C files:
p22610
aV#include "get_data_byName
p22611
aVh"
p22612
aVThe compilation warning will go away
p22613
as(dp22614
g6
V335858
p22615
stp22616
a((dp22617
g2
(lp22618
VYou can use the  from the current locale to get the relative order of the two items, and then construct either  or :
p22619
as(dp22620
g6
V335858
p22621
stp22622
a((dp22623
g2
(lp22624
VYou are currently capturing only the visible part because you are limiting the image context to what's visible
p22625
aVYou should limit it to what's available
p22626
aVhas a  property that has , telling you what is the size of the web view inside the scroll view
p22627
aVYou can use that size to set your image context like this:
p22628
aVEDIT (from a comment by Vad)
p22629
aVSolution was to call
p22630
aVin the initialization, and
p22631
aVwhen the page did finish loading
p22632
as(dp22633
g6
V335858
p22634
stp22635
a((dp22636
g2
(lp22637
VYou can wrap a getter and a setter in an object of an anonymous class implementing a simple interface:
p22638
aVThe  method would return an implementation of this interface that knows how to do a get and also knows how to do a set operation, based on other data passed in from the caller:
p22639
aVWhen you need to use the property in a condition, you'd use something like this:
p22640
aVWhen you need to set the property, you'd be able to call it like this:
p22641
as(dp22642
g6
V335858
p22643
stp22644
a((dp22645
g2
(lp22646
VYou should consider six mutually exclusive cases when solving this problem:
p22647
aVYou run out of elements in both lists
p22648
aVYou run out of elements in the first list, but not in the second
p22649
aVYou run out of elements in the second list, but not in the first
p22650
aVBoth lists have at least one element, and the head elements match
p22651
aVBoth lists have at least one element, and the head element of the first list is smaller
p22652
aVBoth lists have at least one element, and the head element of the first list is greater
p22653
aVThese six combinations cover the rules that you need to write
p22654
aVThe first two cases can be covered by a single rule:
p22655
aVThis means that if the first list is empty, there will be nothing to add to the output list
p22656
aVThe third case is simple too: if the second list is empty, the output is the same as the first list:
p22657
aVCase number four is slightly less trivial: if the heads unify, drop them both at the same time, and solve a smaller sub-problem:
p22658
aVCase number five inserts the head of the first list into the output, and case number six skips the head of the second list:
p22659
aVNote that this solution does not work as expected when the first list contains duplicates, and the second list does not contain duplicates of the corresponding elements
p22660
as(dp22661
g6
V335858
p22662
stp22663
a((dp22664
g2
(lp22665
VAssuming that you have just put an empty string literal in the post by mistake and your actual dates are as described in your post, you need to use  instead of  to parse hours in 24-hour system
p22666
aVYou also need to add  to your format string to parse the last zero of your time string:
p22667
aVThis produces the expected output (the difference in the hours is due to timezone difference):
p22668
as(dp22669
g6
V335858
p22670
stp22671
a((dp22672
g2
(lp22673
VFirst, your  is missing a base case:
p22674
aVThen, your  is almost right: you should use a different variable name to unify the results of  and the input of :
p22675
as(dp22676
g6
V335858
p22677
stp22678
a((dp22679
g2
(lp22680
VImplement
p22681
aVin the delegate, and check that all characters in  are of the kind that you allow
p22682
aVOne very simple way of checking characters for membership in a set is by using  class
p22683
as(dp22684
g6
V335858
p22685
stp22686
a((dp22687
g2
(lp22688
VThe fastest way to count bits is by using "magic numbers":
p22689
aVThis prints 9 (link to ideone)
p22690
aVThis takes 12 operations for 32-bit numbers - the same number a lookup-based method takes, but you do not need a lookup table
p22691
as(dp22692
g6
V335858
p22693
stp22694
a((dp22695
g2
(lp22696
VEven though both constructors can accept ,  inherits from , and is therefore more specific
p22697
as(dp22698
g6
V335858
p22699
stp22700
a((dp22701
g2
(lp22702
VIf the data coming back represents an array with a separator, e
p22703
ag303
aVa comma  you can take your string, and split it into an array, like this:
p22704
aVYou need to use the same separator character as the sending side
p22705
aVIf multiple characters can be used as separators, you may want to use  instead:
p22706
as(dp22707
g6
V335858
p22708
stp22709
a((dp22710
g2
(lp22711
Vs are always rectangular
p22712
aVFrom the documentation:
p22713
aVThe UIView class defines a rectangular area on the screen and the interfaces for managing the content in that area
p22714
aVEven though the view is limited to being rectangular, you can shape your active area in any way that you like
p22715
aVBy combining that with a transparent background, you can imitate a view of any shape that you can draw
p22716
aVWhen your rectangular view receives touches and other events, your event handlers should first check if the activity has happened in the inverted-T area
p22717
aVIf the activity is outside, the event should be ignored
p22718
as(dp22719
g6
V335858
p22720
stp22721
a((dp22722
g2
(lp22723
VNo, they are not the same
p22724
aVThe #2 will return  if the value is actually
p22725
aVFrom the documentation:
p22726
aVFor strings in Visual Basic, the empty string equals Nothing
p22727
aVTherefore, "" = Nothing is true
p22728
aVSo the behavior has to do with VB-specific handling of  with strings
p22729
aVNumber 4 returns  because the string is empty, but it is not
p22730
aVThere is another check that you can do:
p22731
aVBut if you need to detect specifically strings of zero length, you should compare them to
p22732
aVLike this:
p22733
as(dp22734
g6
V335858
p22735
stp22736
a((dp22737
g2
(lp22738
VSince the number of buttons is small (you indicated 28 in the comment), you can use powers of two as tags on your buttons, and use an integer bitmask to store the state of all 28 buttons in a single integer field
p22739
aVConsider this example with four buttons (you can expand it to 32 without much changes)
p22740
aVTag your buttons as follows:
p22741
aVWhen a button is selected,  its tag with the current state:
p22742
aVWhen a button is un-selected,  its tag's inverse with the current state:
p22743
aVTo toggle the state, you can  the tag with the current state:
p22744
aVWhen you need to re-apply the selected/not selected state to your buttons, you can do it in a loop like this:
p22745
as(dp22746
g6
V335858
p22747
stp22748
a((dp22749
g2
(lp22750
VYou are absolutely right about diagnosing your problem: the square brackets are meta-characters in the regular expression language, so they get interpreted by the regex engine
p22751
aVYou need to double-escape your slashes, because they are special characters in both Objective-C and regexp language:
p22752
as(dp22753
g6
V335858
p22754
stp22755
a((dp22756
g2
(lp22757
VThe best way to share the code across interfaces is through stateless extension methods
p22758
aVYou can build these extensions once, and use it in all classes implementing the interface, regardless of their inheritance chain
p22759
aVThis is what
p22760
aVNET did with  in LINQ, for rather impressive results
p22761
aVThis solution is not always possible, but you should prefer it whenever you can
p22762
aVAnother way to share logic is by creating an internal "helper" class
p22763
aVThis looks like the right choice in your case: implementations can call the internally shared code as helper's methods, without the need to duplicate any code
p22764
aVFor example:
p22765
aVThe helper class does not need to be static: if your shared methods need state, you can make your helper a regular class, and put an instance of it in each implementation of your interface where you would like to share code
p22766
as(dp22767
g6
V335858
p22768
stp22769
a((dp22770
g2
(lp22771
VThis is because you provided zero as an integer constant
p22772
aVThe resultant operations are all in integers, so the final value () is truncated to an  as well
p22773
aVChange zero to  to make it work:
p22774
aVThis produces  on ideone
p22775
as(dp22776
g6
V335858
p22777
stp22778
a((dp22779
g2
(lp22780
VTry this:
p22781
aVThis code compares every item in the  array from the second on to the initial item, returning  if the initial item is duplicated anywhere else in the array
p22782
as(dp22783
g6
V335858
p22784
stp22785
a((dp22786
g2
(lp22787
VYou have an "off by one" error:
p22788
as(dp22789
g6
V335858
p22790
stp22791
a((dp22792
g2
(lp22793
VThere is no "benefit" to this, it is simply how the language specification decided to deal with situations when static methods of related classes happen to have the same signature
p22794
aVThe language designers found no sensible way to provide an "override" functionality1, so they took the easy way out
p22795
aV1 There is a way to make overrides of static methods work on an abstract OO level, as evidenced by the way it is done in Objective-C
p22796
aVHowever, the alternative is harder to understand
p22797
as(dp22798
g6
V335858
p22799
stp22800
a((dp22801
g2
(lp22802
VSince this is a homework, I would not fix your code, and give you a few notes instead:
p22803
aVYou would not be able to do it with a single loop and no built-in functions; you need two nested loops
p22804
aVWhen you find a duplicate value, move the array items forward by one, and decrease the size of the "active area" of the array; you need another nested loop to do the move
p22805
as(dp22806
g6
V335858
p22807
stp22808
a((dp22809
g2
(lp22810
VYou can use  to convert between an / and an array of s
p22811
aVThis way you would be able to write eleven bytes followed by four bytes, followed by eleven more bytes, and so on
p22812
aVConverting to bytes:
p22813
aVConverting back to :
p22814
aVIf you are developing a cross-platform solution, keep in mind the following note from the documentation (thanks to  for the comment):
p22815
aVThe order of bytes in the array returned by the GetBytes method depends on whether the computer architecture is little-endian or big-endian
p22816
as(dp22817
g6
V335858
p22818
stp22819
a((dp22820
g2
(lp22821
VYou can use  for this:
p22822
aVThis code fragment prints  on ideone
p22823
aVNote how I changed your regex to use  in place of
p22824
aVThis improves efficiency, which may be important for longer inputs
p22825
as(dp22826
g6
V335858
p22827
stp22828
a((dp22829
g2
(lp22830
VCan someone please provide a throughough explanation on why the SO error occurs though
p22831
aVSure: in order to calculate , the compiler generates code like this:
p22832
aVGet
p22833
aVGet
p22834
aVAdd  to
p22835
aVReturn the result
p22836
aVWhen calling the property getter of  (remember, a getter is a regular no-argument function that uses a special syntax), the runtime places the return address on the stack
p22837
aVThe second step finds us back at the beginning, with one extra return address on the stack; the third step does it again, then the forth, the fifth, and so on
p22838
aVEach invocation deposits another return address on the stack
p22839
aVThis continues all the way to the limit of the stack, at which point an exception is thrown
p22840
as(dp22841
g6
V335858
p22842
stp22843
a((dp22844
g2
(lp22845
VBase-16 (or hex) notation is convenient because you can fit four bits in exactly one hex digit, making conversion to binary very easy, yet not requiring as much space as a full binary notation
p22846
aVThis is useful when you need to represent bit-oriented data in a human-readable form
p22847
aVLearning hex is easy - all you need to do is memorizing a short table of 16 rows defining hex-to-binary conversion:
p22848
aVWith this table in hand, you can easily convert hex strings of arbitrary length to their corresponding bit patterns:
p22849
aVConverting back is easy as well: group your binary digits by four, and use the table to make hex digits
p22850
as(dp22851
g6
V335858
p22852
stp22853
a((dp22854
g2
(lp22855
VThe  in the  should be a
p22856
aVEDIT You should also combine the two methods:
p22857
as(dp22858
g6
V335858
p22859
stp22860
a((dp22861
g2
(lp22862
VThis is because  inside the  condition consumes the integer, so the one after it reads the following one
p22863
aVEDIT You also need to combine the two loops, like this:
p22864
as(dp22865
g6
V335858
p22866
stp22867
a((dp22868
g2
(lp22869
VSince  on your system is most likely a 32-bit number, all bits are flipped, including the ones that were insignificant zeros in the original number:
p22870
aVbecomes
p22871
aVThis is a negative number: the most significant bit of  is zero, so it becomes  when flipped
p22872
aVIf you would like to keep only the bits of the original number, you need to mask with all ones in the significant positions of the number, like this:
p22873
aVing with  "cuts off" all bits except the last four
p22874
as(dp22875
g6
V335858
p22876
stp22877
a((dp22878
g2
(lp22879
VIn the first call of  you are passing a pointer to string literal, which is read-only, to
p22880
aVYou should not be calling  unless you have allocated the memory being freed
p22881
aVYou can fix this in the caller by using :
p22882
as(dp22883
g6
V335858
p22884
stp22885
a((dp22886
g2
(lp22887
VTry this:
p22888
aVThe idea is to put your  expressions in both orders, but use only one of them for each row
p22889
as(dp22890
g6
V335858
p22891
stp22892
a((dp22893
g2
(lp22894
VThe , , and  modifiers are applied to the expressions immediately preceding them, so in this case the asterisk is applied to  alone
p22895
aVIf you would like to apply it to , you can put parentheses around the entire expression:
p22896
aVIf you would like to prevent making a capturing group, use , like this:
p22897
as(dp22898
g6
V335858
p22899
stp22900
a((dp22901
g2
(lp22902
VThe best class to use for this operation is
p22903
aVYou set it to the desired date, and then use
p22904
aVto advance it by one millisecond
p22905
aVUse  to produce string representations
p22906
as(dp22907
g6
V335858
p22908
stp22909
a((dp22910
g2
(lp22911
VYou need to use the  API
p22912
aVYou should be careful of how you define the path, though:
p22913
aVStart by calling  on the initial point
p22914
aVProceed by drawing all segments except the closing one with
p22915
aVClose the path with
p22916
aVDo not add line to point on the final segment
p22917
aVThe call of  will produce a path colored with the fill color that you have previously set
p22918
aVHere is an example:
p22919
as(dp22920
g6
V335858
p22921
stp22922
a((dp22923
g2
(lp22924
VI would try this expression:
p22925
aVThe  expression at the beginning and at the end match zero or one special characters from your list in the comment
p22926
as(dp22927
g6
V335858
p22928
stp22929
a((dp22930
g2
(lp22931
VYou cannot do the copying automatically, but you can do it in a shared spot - i
p22932
ag630
aVin the constructor of the  class
p22933
aVThis way all derived classes would be able to use the same shared code if you pass the  as the parameter of your base constructor, like this:
p22934
aVEDIT (in response to a comment)
p22935
aVIf you do not have access to the source of , you can make a static helper method that does the copying for you, like this:
p22936
aVNow you can use it in your derived classes like this:
p22937
as(dp22938
g6
V335858
p22939
stp22940
a((dp22941
g2
(lp22942
VThere is a special class called  that is created specifically to use as null indicator in collections:
p22943
aVThe  class defines a singleton object used to represent  values in collection objects (which don\u2019t allow  values)
p22944
as(dp22945
g6
V335858
p22946
stp22947
a((dp22948
g2
(lp22949
VCaching images hardly belongs in the view layer; neither does the retrieval of these images from the server
p22950
aVYou should take the approach that you describe in your post - caching the images separately from the table, and then retrieve these images from that image cache
p22951
aVYou can build an  class that gives you an image based on its key, and use that provider in constructing the table cells
p22952
aVIn turn, the  decides on whether to load the images from the server or to load them from cache, hiding the details from the table view
p22953
aVThis approach gives you significant amount of flexibility: should you decide to save on the network traffic by caching the images locally on the device, the approach with a separate cache lets you do that without disturbing the view layer
p22954
aVIt also lets you save memory by flushing the cached images to temp files, for example, on receiving a low memory warning
p22955
as(dp22956
g6
V335858
p22957
stp22958
a((dp22959
g2
(lp22960
VYou can use  for this, and run a straightforward loop to do the increments:
p22961
aVThis code produces the following output on ideone:
p22962
as(dp22963
g6
V335858
p22964
stp22965
a((dp22966
g2
(lp22967
VYou need to define static variable in your cpp file, like this:
p22968
as(dp22969
g6
V335858
p22970
stp22971
a((dp22972
g2
(lp22973
VThere is nothing wrong with this: ASCII code of  is 120 in decimal
p22974
aVThe  syntax is a convenient syntax for entering small integer constants using their representation as ASCII characters; other than the syntax, constants in single quotes are regular integers
p22975
aVIf you would like the number re-interpreted as a character, use the corresponding format specifier in the  call, and get the  value from the  object:
p22976
as(dp22977
g6
V335858
p22978
stp22979
a((dp22980
g2
(lp22981
VThis should work:
p22982
aVThe condition is "the larger of the two left ends needs to be less than the smaller of the two right ends"
p22983
as(dp22984
g6
V335858
p22985
stp22986
a((dp22987
g2
(lp22988
VLinked list is a specific way of representing sequences of data elements in memory, where each element is paired with a pointer of sorts to the next element in the sequence
p22989
aVLinked lists let you perform a range of operations on their subsequences: you can cut out or insert entire chains of elements, or delete elements from the middle at a very low cost
p22990
aVStreams, on the other hand, are abstractions for accessing data in sequential order, without any specific requirements to their representation in memory
p22991
aVYou can use a linked list to implement a stream, but you could also use another data structure for that, such as a plain array or a circular array buffer
p22992
as(dp22993
g6
V335858
p22994
stp22995
a((dp22996
g2
(lp22997
VIf you would like to pick six numbers without repetitions from the array, shuffle the array using Knuth-Fisher\u2013Yates shuffle, and take the first six numbers:
p22998
aVThe first six elements of the  array contain a random selection from the original 11-element array
p22999
as(dp23000
g6
V335858
p23001
stp23002
a((dp23003
g2
(lp23004
VThis means that you need to go to your  file, and add a declaration for
p23005
aVLet's say it's ; then you should add the following line to your
p23006
aVh file:
p23007
aVSubstitute  for the correct type of your  property
p23008
aVMore information about properties can be found here
p23009
as(dp23010
g6
V335858
p23011
stp23012
a((dp23013
g2
(lp23014
VHere is a simple solution for C++:
p23015
aVOn ideone: link
p23016
as(dp23017
g6
V335858
p23018
stp23019
a((dp23020
g2
(lp23021
VThe problem with your implementation of the selection sort algorithm is that you do not modify the list being sorted
p23022
aVWhen you swap  and , the elements in the corresponding positions of the list remain in their old places
p23023
aVIf you stop using  and  and replace their use with  and , your sorting algorithm would produce different results
p23024
aVBetter yet, if the homework allows you to use standard library, take a look at a built-in way of sorting arrays in Java
p23025
as(dp23026
g6
V335858
p23027
stp23028
a((dp23029
g2
(lp23030
VYou should use  rather than doing individual character manipulations in a loop, and add whole chunks of string to the result:
p23031
as(dp23032
g6
V335858
p23033
stp23034
a((dp23035
g2
(lp23036
VYou would not be able to do this: unlike instance variables, -d constants do not leave a trace after the preprocessor is done with them
p23037
aVThey leave no metadata behind - all instances of  in the body of your program will be replaced with  even before the Objective C compiler proper gets to analyze your code
p23038
aVIf you need the constant names to be available at run time, you would need to build all the necessary metadata yourself
p23039
aVIn order to do that, you may want to look into "stringizing" operator of the preprocessor:
p23040
aVThis macro can be applied to a preprocessor constant, and produce a C string literal with its name:
p23041
as(dp23042
g6
V335858
p23043
stp23044
a((dp23045
g2
(lp23046
VYou can create multiple lookups, and then intersect them to do your searches
p23047
aVHere is a somewhat oversimplified example, but it should illustrate the idea:
p23048
aVThis prints
p23049
as(dp23050
g6
V335858
p23051
stp23052
a((dp23053
g2
(lp23054
VTo answer the question in the title of your post, dividing by a very small number will not cause a division by zero, but it may cause the result to become an infinity:
p23055
aVThis produces the following output:
p23056
as(dp23057
g6
V335858
p23058
stp23059
a((dp23060
g2
(lp23061
VWhat you are trying to achieve is incompatible with separate compiling, and is therefore not possible
p23062
aVThe volatile qualifier directs the compiler to treat a variable differently on each access, so every access to that variable from the module to the source of which you have no access would need to change as well
p23063
aVSince that module is compiled already, changing the way it treats some of its variables is not possible
p23064
as(dp23065
g6
V335858
p23066
stp23067
a((dp23068
g2
(lp23069
VSince the number of items is so small, you can model the checked/unchecked state with a single integer and bitmasks
p23070
aVUse the lower nine bits of the number to indicate a checked/unchecked state:
p23071
aVHere is how you check/uncheck/toggle an individual row: in the  of your delegate, do one of these:
p23072
aVIf you want to check/uncheck multiple rows at once, mask with a number composed of the bits corresponding to rows being checked/unchecked in the binary form For example, the number that has bits 2
p23073
aV8 set is
p23074
aVDon't forget to call  after manipulating the  variable
p23075
as(dp23076
g6
V335858
p23077
stp23078
a((dp23079
g2
(lp23080
VUse :
p23081
aVThis gives you the difference in seconds
p23082
aVMultiply  by  to get milliseconds
p23083
as(dp23084
g6
V335858
p23085
stp23086
a((dp23087
g2
(lp23088
VThe  operator of a  returns a character, not a string
p23089
aVDepending on circumstances, you should implement one or two of them:
p23090
aVThe first one produces a reference that cannot be modified
p23091
aVIf your string is immutable, that is all you need
p23092
aVThe second one produces a reference that can be modified
p23093
aVYou can use it to implement clever stuff, such as copy-on-modify and reference counting
p23094
as(dp23095
g6
V335858
p23096
stp23097
a((dp23098
g2
(lp23099
VWhen any piece of code receives an instance of an interface without knowing what class is behind it, that piece of code should be assured of the ability to call any method in an interface
p23100
aVThis is what makes an interface a contract between the callers and the providers of the functionality
p23101
aVThe only way to achieve that is to require all non-abstract classes implementing the interface to provide implementations for all its functions
p23102
aVThere are two general ways to deal with the need to not implement some of the functionality:
p23103
aVAdding a tester method and an implementation that throws , and
p23104
aVSplitting your interface as needed into parts so that all method of a part could be implemented
p23105
aVHere is an example of the first approach:
p23106
aVHere is an example of the second approach:
p23107
as(dp23108
g6
V335858
p23109
stp23110
a((dp23111
g2
(lp23112
VHash table's Load Factor is defined as
p23113
aVn/s, the ratio of the number of stored entries n and the size s of the table's array of buckets
p23114
aVHigh performance of hash table is maintained when the number of collisions is low
p23115
aVWhen the load factor is high, the probability of collisions increases
p23116
as(dp23117
g6
V335858
p23118
stp23119
a((dp23120
g2
(lp23121
VUnfortunately, even the C++11 version of the C++ standard lacks the designated initializers feature of C99
p23122
as(dp23123
g6
V335858
p23124
stp23125
a((dp23126
g2
(lp23127
VThe static variable of your class are not garbage collected until the app domain hosting your class is unloaded
p23128
aVThe  method will not be called, because it is an instance method, and you said that you wouldn't create any instances of your class
p23129
aVIf you would like to make use of the  method, make your object a singleton, create one instance of it, and dispose of it explicitly when your application is about to exit
p23130
as(dp23131
g6
V335858
p23132
stp23133
a((dp23134
g2
(lp23135
VI don't think this program can be solved using dynamic programming
p23136
aVWhy not
p23137
aVThis is a prime candidate for the dynamic programming approach
p23138
aVThe straightforward recursive approach is the only thing I can think of, which is too inefficient under the given constraints
p23139
aVCan you build a recursive solution that solves, say, a 5x5 grid
p23140
aVPerfect
p23141
aVStart with that, and then memoize it by adding an  array of best results for cells which you have already solved
p23142
aVStart that array with all large negative values, and then update it when you find a solution that is better
p23143
aVthan what's there already
p23144
aVOnce you 've finished with the cell, put the solution into the  array: the next time you come there recursively, check the array for a number, and if a value is there, return it without continuing with the recursion
p23145
aVThe memoized solution itself is rather straightforward
p23146
aVThe preprocessing step of the algorithm (subtracting negative numbers from neighboring cells) takes more code
p23147
aVHere is the solution on ideone, it returns  as expected
p23148
as(dp23149
g6
V335858
p23150
stp23151
a((dp23152
g2
(lp23153
VThis approach sorts pairs as a single unit, which is what it is expected to do: it never make sense to break up the  and the  of the pair
p23154
aVIf you would like to sort only the  item and leave the  in place, you will end up with a different set of pairs
p23155
aVIf you want to sort the  separately from the , place them in separate arrays (better yet, use s) and sort the first vector
p23156
aVThen iterate both vectors, and make a new set of pairs
p23157
as(dp23158
g6
V335858
p23159
stp23160
a((dp23161
g2
(lp23162
VEnd of line marker  is different from  in that it matches  as well, even if the end-of-line marker  or  is not found at the end of the file
p23163
aVI did not look at flex's implementation, but I would implement both  and  using boolean flags
p23164
aVThe  flag would be initially set, then reset to  after the first character in a line, then set back to  after the next end-of-line marker, and so on
p23165
as(dp23166
g6
V335858
p23167
stp23168
a((dp23169
g2
(lp23170
VYou are missing a closing parenthesis at the end of the statement, after the last field:
p23171
as(dp23172
g6
V335858
p23173
stp23174
a((dp23175
g2
(lp23176
VMonths in a  are zero-based
p23177
aVThe first month of the year in the Gregorian and Julian calendars is JANUARY which is 0
p23178
aVAssuming a Gregorian calendar,  is December, and  is January of next year, precisely the way your program shows it
p23179
as(dp23180
g6
V335858
p23181
stp23182
a((dp23183
g2
(lp23184
VSince the regexp string is first processed by the compiler before making it to the regexp processor, you need to double every backslahs in the expression, and add additional slashes for every doublequote
p23185
as(dp23186
g6
V335858
p23187
stp23188
a((dp23189
g2
(lp23190
VYou should convert it to string - otherwise, it's an enumerable, and the  does not produce the expected result
p23191
aVEDIT The same issue exists in this line:
p23192
aVyou should replace it with
p23193
as(dp23194
g6
V335858
p23195
stp23196
a((dp23197
g2
(lp23198
VThis is called a variadic function, not an overload
p23199
aVOverloading has nothing to do with object orientation
p23200
as(dp23201
g6
V335858
p23202
stp23203
a((dp23204
g2
(lp23205
VThe problem with assigning elements of the  is that the class owning the  will have no idea the  has been changed
p23206
aVThis is not good when you talk about, say, the origin of a frame:  is expected to move in response to changing the origin, but since the class would not be notified of the change, no moving would occur
p23207
aVSetting the , on the other hand, can be detected, because 's  method would be invoked
p23208
aVThis is the code in which  could take care of resizing, repositioning, and so on
p23209
as(dp23210
g6
V335858
p23211
stp23212
a((dp23213
g2
(lp23214
VThe  is zero because comma has the lowest precedence among all C++ operators
p23215
aVBecause its precedence is lower than that of the ternary conditional operator, the conditional operators are parsed as  and
p23216
aVIn both cases, the  statement is executed unconditionally
p23217
aVEDIT The first comma is different because the compiler has found a , so now it needs a  to complete the "when true" expression of the conditional
p23218
aVThat is why both  and  are taken in
p23219
as(dp23220
g6
V335858
p23221
stp23222
a((dp23223
g2
(lp23224
VIf you copied the printout exactly as formatted, it appears that the  key contains an array of arrays with a single element which is already the array that you wanr, so this should work for you:
p23225
aVThe reason I think this is an array in an array is that it shows two levels of nested parentheses around the list
p23226
as(dp23227
g6
V335858
p23228
stp23229
a((dp23230
g2
(lp23231
VYou've got a combination of Strategy and Visitor in a single group of methods; this is absolutely OK
p23232
aVYou could separate them out by giving the responses a common interface, and adding a visitor to it for harvesting the right response
p23233
aVThis would apply two patterns in sequence, rather than applying both at the same time
p23234
aVNow all your  implementations could return the common
p23235
aVYou could collect them all, and then go through them with an implementation of , and do what you need for each type inside the corresponding  method
p23236
as(dp23237
g6
V335858
p23238
stp23239
a((dp23240
g2
(lp23241
VQ1
p23242
aVAccording to C99 specification, section 6
p23243
ag10442
ag839
ag839
aV9, it is an undefined behavior in C:
p23244
aVIf the function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function, the behavior is undefined
p23245
aVThe expression "points to" a function taking an , while the function is defined as taking a
p23246
aVQ2
p23247
aVThe case with variables is also undefined behavior, because you are reading or assigning an  to/from
p23248
aVAssuming 4-byte integers, this will access three bytes past the memory location where it is valid
p23249
aVYou can test this by declaring more variables, like this:
p23250
as(dp23251
g6
V335858
p23252
stp23253
a((dp23254
g2
(lp23255
VFrom your description it sounds like you are working with ARC, and both properties / instance variables are declared as  (or )
p23256
aVThat is why local variables which are strong implicitly keep the objects from being released early
p23257
aVSince your custom button plans to keep the image and the label, you should make both properties / instance variables  by removing the  from their declarations
p23258
as(dp23259
g6
V335858
p23260
stp23261
a((dp23262
g2
(lp23263
VAs  goes through consecutive values, its last bits switches between 0 and 1 on each iteration
p23264
aVAs the result,  goes between 0 and 1 as well
p23265
aVXOR-ing the result with a bool gives you the same value if bool is false, and an inverted value if bool is true
p23266
aVNote how the sequence goes 0-1-0-1-0-1 when  is , and 1-0-1-0-1-0 when  is
p23267
aVTo convert this snippet to Java, compare the result of  with :
p23268
as(dp23269
g6
V335858
p23270
stp23271
a((dp23272
g2
(lp23273
V struct consists of two integers - the  and the
p23274
aVIt looks like  and  are the two expressions that you are looking for - the ranges for the left and right substring are as follows:
p23275
as(dp23276
g6
V335858
p23277
stp23278
a((dp23279
g2
(lp23280
VThis depends on which implementation of the binary search you use:
p23281
aVIn Java and
p23282
aVNET, the binary search will give you an arbitrary element; you must search both ways to get the range that you are looking for
p23283
aVIn C++ you can use  method to produce the result that you want in a single call
p23284
aVTo speed up searches in Java and
p23285
aVNET for cases when the equal range is too long for iterating linearly, you can look for a predecessor element and for the successor element, and take values in the middle of the range that you find, exclusive of the ends
p23286
aVShould this be too slow because of a second binary search, consider writing your own search that looks for both ends at the same time
p23287
aVThis may be a bit tedious, but it should run faster
p23288
as(dp23289
g6
V335858
p23290
stp23291
a((dp23292
g2
(lp23293
VThe idea behind the second paragraph is to prevent you from writing code like this:
p23294
aVWhile this is not a good code to start with, the comment states that this code is invalid (as opposed to, say, sub-optimal)
p23295
aVThey say that the exception may not follow at all, so the above loop may produce a failure silently
p23296
as(dp23297
g6
V335858
p23298
stp23299
a((dp23300
g2
(lp23301
VYou should be allocating  rather than a "plain" :
p23302
aVOtherwise, any attempt to connect s would result in a crash
p23303
aVOf course I'm only assuming that the NIB name matches the controller's name; if it does not, you need to use the correct name
p23304
as(dp23305
g6
V335858
p23306
stp23307
a((dp23308
g2
(lp23309
VYou need to reset the iterator  before you enter the inner loop, otherwise you'll go through the second list only once during the first iteration of the outer loop; the remaining iterations will stop at , skipping the inner loop altogether
p23310
as(dp23311
g6
V335858
p23312
stp23313
a((dp23314
g2
(lp23315
VYou have a mistake in your logical condition: it means "while all numbers are not equal"
p23316
aVTo break this condition, it is enough for one pair to become equal
p23317
aVYou needed to construct a different condition - either put "not" in front of it
p23318
aVor convert using De Morgan's law:
p23319
as(dp23320
g6
V335858
p23321
stp23322
a((dp23323
g2
(lp23324
VI assume I import my class, but once I've done that, what do I type to get at this variable
p23325
aVUnfortunately, it is not that simple: you need an object instance in order to set its instance variables
p23326
aVIt does not matter if you go through properties or not, you need an instance either way
p23327
aVThe way you get that instance differs depending on how your classes interact
p23328
aVSince you are using ARC and s, I am assuming that the  is located in a view controller that you open using a segue
p23329
aVIn this case, you need to import the destination controller's header in the starting controller's
p23330
aVm file, and add this code:
p23331
as(dp23332
g6
V335858
p23333
stp23334
a((dp23335
g2
(lp23336
VYour LINQ2SQL or EF provider complains that it cannot translate a query that uses an  in a context of an  list
p23337
aVReplacing a search for an application followed by a search for one of its resources with a single search for a resource by application ID may work better in your situation:
p23338
as(dp23339
g6
V335858
p23340
stp23341
a((dp23342
g2
(lp23343
VAn idiomatic way of dealing with static properties in Objective C is hiding them behind class methods (the ones with )
p23344
aVDeclare your string as a  inside the implementation of your class method, and use  for initialization:
p23345
aVThis way of setting up static objects is thread-safe
p23346
aVThe  will be initialized once, even if the method is called concurrently from several threads
p23347
aVNow you can get to your string from anywhere by calling
p23348
as(dp23349
g6
V335858
p23350
stp23351
a((dp23352
g2
(lp23353
VI think this has to do with  overflow: very large integers get reinterpreted as negatives when they overflow the size of  (32 bits)
p23354
aVUse  instead of :
p23355
as(dp23356
g6
V335858
p23357
stp23358
a((dp23359
g2
(lp23360
VI think you are looking for the :
p23361
as(dp23362
g6
V335858
p23363
stp23364
a((dp23365
g2
(lp23366
VA class in Java can inherit from exactly one class (if you do not specify the base class, it's )
p23367
aVThe only way to inherit from three classes is if they inherit from each other in a chain:
p23368
aVNow your  class inherits from , , and , but I doubt that this is what you were looking for
p23369
aVThe idiomatic solution in Java is to implement multiple interfaces instead of inheriting multiple classes
p23370
aVIf you must "inherit" implementation, use composition instead of inheritance
p23371
as(dp23372
g6
V335858
p23373
stp23374
a((dp23375
g2
(lp23376
VIterator of  iterates key-value pairs
p23377
aVIf you would like to iterate keys, change your code as follows:
p23378
aVUse  only if you must do so for backward compatibility; in
p23379
aVNET 2
p23380
aV0 and later, use  instead
p23381
as(dp23382
g6
V335858
p23383
stp23384
a((dp23385
g2
(lp23386
VIf you would like to use one of your Objective C classes inside your "regular" C++ class (as opposed to Objective C++) you could use the trick described in this article, which boils down to including  instead of , and using a wrapped  in place of a "real" Objective C object
p23387
as(dp23388
g6
V335858
p23389
stp23390
a((dp23391
g2
(lp23392
VIf you are trying to check if  is of a  type, you should check it like this:
p23393
as(dp23394
g6
V335858
p23395
stp23396
a((dp23397
g2
(lp23398
VThat is not how the  works
p23399
aVIt returns  or  based on whether the key is found or not, and sets its  parameter to the corresponding value if the key is there
p23400
aVIf you want to check if the key is there or not and do something when it's missing, you need something like this:
p23401
as(dp23402
g6
V335858
p23403
stp23404
a((dp23405
g2
(lp23406
VDoes anyone know of another, faster way
p23407
aVYes, this problem actually has a proper name
p23408
aVIt is called the Longest Common Substring, and it has a reasonably fast solution
p23409
aVHere is an implementation on ideone
p23410
aVIt finds and replaces all common substrings of ten characters or longer
p23411
as(dp23412
g6
V335858
p23413
stp23414
a((dp23415
g2
(lp23416
VYes, you can use , or  (works for positive numbers)
p23417
aVFor regular expressions, use
p23418
aVFor character set, use
p23419
as(dp23420
g6
V335858
p23421
stp23422
a((dp23423
g2
(lp23424
VIf the main thread is the only thread in the system that accesses , then the property access is effectively single-threaded, and you do not need
p23425
aVIf the main thread is the only one doing the writing, but other threads also read , declaring the property  is a good thing to do
p23426
aVIn case of multi-threaded access, make sure that you use immutable  rather than the , because even making your property  is not going to protect a mutable string from returning incorrect results on reads running concurrently with writes
p23427
as(dp23428
g6
V335858
p23429
stp23430
a((dp23431
g2
(lp23432
VFirst, I assume that the allocation is commented out by mistake
p23433
aVYou need to save the pointer that you allocate, and return it
p23434
aVOtherwise, you're returning a pointer , which points at the end of the concatenation result
p23435
aVYou are not terminating the resultant string; you need to add
p23436
aVYou should move the second loop to the outside of the first loop, and drop the  condition around it: if the first loop has terminated, you know that  points to
p23437
as(dp23438
g6
V335858
p23439
stp23440
a((dp23441
g2
(lp23442
VYou cannot do this in under , because the number of pairs that the algorithm will produce when the original array sorted in descending order is
p23443
aVYou simply cannot produce  results in  time
p23444
as(dp23445
g6
V335858
p23446
stp23447
a((dp23448
g2
(lp23449
VYou can do it like this:
p23450
aVThe  will split the string at , and  will put the parts back together
p23451
as(dp23452
g6
V335858
p23453
stp23454
a((dp23455
g2
(lp23456
VThe problem is that  is an unsigned type
p23457
aVWhen you subtract  from an unsigned zero, you end up with a really large positive number1 rather than
p23458
aVReplace the condition with an equivalent expression that uses addition to avoid the problem:
p23459
aV1 The value of  in 2-s complement representation used in most modern computers to represent negatives is a binary number composed entirely of ones
p23460
aVWhen this number gets re-interpreted as an unsigned 32-bit value, it becomes
p23461
as(dp23462
g6
V335858
p23463
stp23464
a((dp23465
g2
(lp23466
VYou can make a common interface, and make anonymous implementations that use patterns or whatever else you may want to transform your strings:
p23467
aVNote that implementations of  do not need to use regular expressions at all
p23468
aVThe loop at the bottom has no idea the regexp is involved in obtaining the results
p23469
as(dp23470
g6
V335858
p23471
stp23472
a((dp23473
g2
(lp23474
VThe condition that you tried implies that , , and  are in the same specific order as , , and
p23475
aVYou could try all six permutations, but that would make for a rather unreadable program
p23476
aVA better solution would be to add values to vectors, sort them, and then compare for equality, like this:
p23477
aVHere is a link to this snippet on ideone
p23478
as(dp23479
g6
V335858
p23480
stp23481
a((dp23482
g2
(lp23483
VAn array of characters is not a  pointer
p23484
aVAlthough arrays do decay to pointers when passed to functions, they are essentially different things (specifically, the compiler knows their exact length at compile time)
p23485
aVThe reason you see 5 for a four-character string is that string literals reserve one more  for the terminating zero
p23486
aV, on the other hand, is system-dependent: on systems with 32-bit pointers you will see , while on system with 64-bit pointers you will see
p23487
as(dp23488
g6
V335858
p23489
stp23490
a((dp23491
g2
(lp23492
VI think the problem is that you put a semicolon instead of a dot after
p23493
aVAlso consider rewriting the second rule to avoid introducing a singleton:
p23494
as(dp23495
g6
V335858
p23496
stp23497
a((dp23498
g2
(lp23499
VYes, this is legal
p23500
aVThis is useful for implementations of virtuals from the base class in implementations that do not intend on using the corresponding parameter: you must declare the parameter to match the signature of the virtual function in the base class, but you are not planning to use it, so you do not specify the name
p23501
aVThe other common case is when you provide a callback to some library, and you must conform to a signature that the library has established (thanks, Aasmund Eldhuset for bringing this up)
p23502
aVThere is also a special case for defining your own post-increment and post-decrement operators: they must have a signature with an  parameter, but that parameter is always unused
p23503
aVThis convention is bordering on a hack in the language design, though
p23504
as(dp23505
g6
V335858
p23506
stp23507
a((dp23508
g2
(lp23509
VYou need to make a copy of your  array when you insert it into the , otherwise you'll end up with multiple copies of the last page:
p23510
as(dp23511
g6
V335858
p23512
stp23513
a((dp23514
g2
(lp23515
VThe  on  returns  if the cell is not visible:
p23516
aVAn object representing a cell of the table or  if the cell is not visible or indexPath is out of range
p23517
aVIf you would like to get a cell all the time, call the same method on your data source:
p23518
as(dp23519
g6
V335858
p23520
stp23521
a((dp23522
g2
(lp23523
VThe prepared statement by itself is not going to be faster when you insert only once
p23524
aVHowever, if you need to run the same inserts multiple times, you will save on the time it takes to parse the query and prepare the query plan
p23525
aVThe prepared statement insert will be parsed once, the plan for it will be cached, and then reused for all subsequent insertions
p23526
aVThe statement with multiple embedded values, on the other hand, will need to be re-processed every time you run a new one, slowing the process down
p23527
aVOn the other hand, network roundtrips are slow as well
p23528
aVIt may be slower to do an extra roundtrip than to parse and prepare a query plan, so you should profile before making a decision one way or the other
p23529
as(dp23530
g6
V335858
p23531
stp23532
a((dp23533
g2
(lp23534
VAssuming that you are planning to do something like this
p23535
aVyou can pass your object "by reference" or by "value" (that is, by reference to the reference or by value of the reference, because  is a reference type)
p23536
aVIn both cases locking on the object is going to work
p23537
aVWhen you pass by reference, you'll be able to assign the variable passed at the top of the recursive chain, too, although I doubt that that is what you are planning to do
p23538
as(dp23539
g6
V335858
p23540
stp23541
a((dp23542
g2
(lp23543
VYou can do this, but you need to supply the type of the structure before your aggregate:
p23544
as(dp23545
g6
V335858
p23546
stp23547
a((dp23548
g2
(lp23549
VYour action needs to accept an  argument, even if you are not using it:
p23550
aVIn the :
p23551
as(dp23552
g6
V335858
p23553
stp23554
a((dp23555
g2
(lp23556
VI do not know of a built-in way to do it, but you can write a simple and fast program that finds you the right line without unnecessary allocations:
p23557
aVHere is a link to ideone
p23558
as(dp23559
g6
V335858
p23560
stp23561
a((dp23562
g2
(lp23563
VChances are that options A and B will be optimized into exactly the same output by the compiler, so the only thing that you gain with option B is readability
p23564
aVOption C will likely require an extra store instruction and a pair of  /  from the ARC, but you would not notice the impact compared to options A or B
p23565
as(dp23566
g6
V335858
p23567
stp23568
a((dp23569
g2
(lp23570
VYou need to do two things to speed this up:
p23571
aVConvert  to a  array in such a way that the object at index  has  equal to
p23572
aVYou can do it by iterating over the original bookings array when you receive it
p23573
aVCreate a  called  containing indexes of items that have been booked
p23574
aVYou can prepare it by going through all , and marking the indexes of  for items that have been booked
p23575
aVWith these two pre-processed items in place, you can eliminate the nested loops altogether: the outer one will be replaced by a lookup in , and the inner one - by a loopup in
p23576
as(dp23577
g6
V335858
p23578
stp23579
a((dp23580
g2
(lp23581
VYou should declare your global variables in the header, rather than defining them
p23582
aVMark the variable , put a definition into a  file, and initialize the variable to
p23583
aVHeader:
p23584
aVm file:
p23585
aVRebuild everything, and the crash should be eliminated
p23586
as(dp23587
g6
V335858
p23588
stp23589
a((dp23590
g2
(lp23591
V is an object too, and it is different from
p23592
aVYou should do  instead:
p23593
aVThis does not check for derived types, but this does:
p23594
aVStill, this does not let you call  without casting
p23595
aVThe easiest way to check and cast at the same time is as follows:
p23596
as(dp23597
g6
V335858
p23598
stp23599
a((dp23600
g2
(lp23601
VYou can use the  and a simple loop to achieve the results that you are looking for:
p23602
aVThis produces the result below:
p23603
as(dp23604
g6
V335858
p23605
stp23606
a((dp23607
g2
(lp23608
VFirst, put your buttons into an
p23609
aVYou need to declare a property and make connections in the interface builder
p23610
aVNext, create an  that maps  to instances of
p23611
aVInitialize the dictionary with 80 mappings - one for each kind
p23612
aVWith this dictionary and the button array in hand, you would be able to look up an index set by , iterate through indexes contained in it, and enable/disable buttons as required in a simple loop
p23613
aVAs an added bonus, your long chain of // will be gone too
p23614
aVHeader:
p23615
aVDesignated initializer:
p23616
aVWhen you need to enable/disable your buttons:
p23617
as(dp23618
g6
V335858
p23619
stp23620
a((dp23621
g2
(lp23622
VYou can do this with  method of :
p23623
as(dp23624
g6
V335858
p23625
stp23626
a((dp23627
g2
(lp23628
VThe second regexp is more efficient, because it does not backtrack
p23629
aVHere is a link to a nice article explaining the details
p23630
aVThe article explains how the expression
p23631
aVtakes 25 steps, while the expression
p23632
aVtakes only five to find a match in a  string, illustrating each of the steps the regex engine needs to take in order to produce a match
p23633
aVThere should be no difference between  and  - good regexp engines will convert both sub-expressions to the same compiled expression
p23634
aVThe anchored version with  is not doing the same thing as non-anchored , because the anchored version will not find a match when a dot  is the first character in the string
p23635
aVYou can fix this by replacing  with a
p23636
aVWith this difference out of the way,  will spend a little more time checking that there are no other matches (and there wouldn't be, because your expression is anchored), but that would not be significant for strings with long initial runs containing no dots
p23637
as(dp23638
g6
V335858
p23639
stp23640
a((dp23641
g2
(lp23642
VNo, this is not possible: variable names do not survive the compilation step, becoming addresses and offsets "baked into" the compiled binary code
p23643
aVIt is, however, possible to declare a variable the name of which is given by the developer at compile-time by using a  or a comparable option of your C compiler
p23644
as(dp23645
g6
V335858
p23646
stp23647
a((dp23648
g2
(lp23649
VThis is something that modern operating systems do by loading each process in a separate virtual address space
p23650
aVMultiple processes may reference the same virtual address, but the operating system, helped by modern hardware, will map each one to a separate physical address, and make sure that one process cannot access physical memory allocated to another process1
p23651
aV1 Debuggers are a notable exception: operating system often provide special mechanisms for debuggers to attach to other processes and examine their memory space
p23652
as(dp23653
g6
V335858
p23654
stp23655
a((dp23656
g2
(lp23657
VDoes ~0 mean its flipping 000000000 to 1111111111
p23658
aVYes, it does
p23659
aVDoes -1 essentially mean the same thing as 11111111111111111 bits
p23660
aVIn 2s complement representation, it does
p23661
as(dp23662
g6
V335858
p23663
stp23664
a((dp23665
g2
(lp23666
VYou can make your function a template on the type parameter of the , like this:
p23667
as(dp23668
g6
V335858
p23669
stp23670
a((dp23671
g2
(lp23672
VWith ten thousand rows you have no choice but load your data on demand
p23673
aVOtherwise, your app has no chance of performing at a decent level
p23674
aVA freeze like you describe would definitely be enough to see your app rejected1
p23675
aVThis approach is rather wasteful with memory, too, because out of ten thousand rows you need at most two dozen at any given time
p23676
aVA reasonably simple way to speed things up is to prepare an  for your pages of data (say, ten items per page), add code that gets the total count of records, and modify the code that retrieves the data to read records from a single page (use )
p23677
aVWhen your table shows rows, it should try getting a page of the row from the cache
p23678
aVIf the page is not there, it should load it from sqlite, and put in the cache
p23679
aVUsing pages will minimize the number of roundtrips to the database; using cache will let you manage an optimal use of memory
p23680
aV1 It does not look like your app has been rejected for a freeze this time around, but once you fix the "lacking native iOS functionality", the freeze will trigger another rejection
p23681
as(dp23682
g6
V335858
p23683
stp23684
a((dp23685
g2
(lp23686
VYou should change the settings of your project to allow for C++11
p23687
aVHere is a link to an answer that explains how it is done
p23688
as(dp23689
g6
V335858
p23690
stp23691
a((dp23692
g2
(lp23693
VYou can get the text of your button's label by checking
p23694
aVThis is not as reliable as the tag, though, especially when your app changes the text on the label in response to user interactions or due to selection of a new locale
p23695
aVAlso note that to set the label you need to use a different method:
p23696
as(dp23697
g6
V335858
p23698
stp23699
a((dp23700
g2
(lp23701
VYou should never include a  file in another  file or in a header
p23702
aVThis almost inevitably leads to duplicate object definitions
p23703
aVPut declarations into the header file, and definitions into the cpp files
p23704
aVInclude headers in cpp files where you need to have access to methods of objects defined in other cpp files
p23705
aVTake  as an example: the top part up to and including the  line need to go into the  file
p23706
aVEverything else has to remain in the
p23707
aVIn addition, you need to add  to the top of , along with other headers that you need to include
p23708
aVYou also need to remove  from the header, and use  in your declarations
p23709
aVIt is OK to put  in your  file, though
p23710
as(dp23711
g6
V335858
p23712
stp23713
a((dp23714
g2
(lp23715
VArrays in Java1 are indexed from zero, not from one
p23716
aVTherefore, your code that checks  and  should be changed to  and , or use2
p23717
aVinstead of
p23718
aVTo find the next available element from among the elements of a sub-array, you can use this loop:
p23719
aV1 As well as C, C++, C#, Objective C, and many other languages
p23720
aV2 This is something you may want to do if you expect the user to enter numbers one through ten rather than zero through nine - a more natural choice for seat numbering
p23721
as(dp23722
g6
V335858
p23723
stp23724
a((dp23725
g2
(lp23726
VThe problem has to do with the way you pass the  around
p23727
aVYou keep it in a property or an ivar on
p23728
aVbut you set it only when the cell is not available for reuse
p23729
aVWhen you reuse the cell, the  on  is set to the label from the prior run, causing you all sorts of problems
p23730
aVThe cleanest solution is to create your own class deriving from , move the initialization code that creates labels, icons, background colors, and so on into the designated initializer, and create properties for setting label texts
p23731
aVWith this class in place, you would be able to simplify your code as follows:
p23732
as(dp23733
g6
V335858
p23734
stp23735
a((dp23736
g2
(lp23737
VYou can make the delete indicators of all cells to appear by calling
p23738
aVfrom your button's handler
p23739
aVIf you want the indicator to appear only on the currently selected cell, you can do this:
p23740
as(dp23741
g6
V335858
p23742
stp23743
a((dp23744
g2
(lp23745
VA 2-D  array can be mapped to a vector  (you can use a row-major or a column-major order to do the mapping)
p23746
aVStart with a vector
p23747
aVFill its first half with the first choice, and the second half of the array with the second choice object
p23748
aVRun a Fisher-Yates shuffle, and convert the shuffled array to a 2-D array
p23749
aVThe array is now filled with elements that are evenly split among the two choices, and the choices at each particular index are random
p23750
as(dp23751
g6
V335858
p23752
stp23753
a((dp23754
g2
(lp23755
VThe minimum difference will be one of the differences from among the consecutive pairs in sorted order
p23756
aVSort the array, and go through the pairs of adjacent numbers looking for the smallest difference:
p23757
aVThis prints
p23758
as(dp23759
g6
V335858
p23760
stp23761
a((dp23762
g2
(lp23763
VThey look like a comment to me but that can't be right
p23764
aVYes, these are C-style comments
p23765
aVThey are used to exclude the name of an unused variable, most likely to avoid a warning from the compiler
p23766
aVYou can read about them in a C or C++ book of your choice
p23767
as(dp23768
g6
V335858
p23769
stp23770
a((dp23771
g2
(lp23772
VCurrently, your condition checks that non-Russian (technically, non-Cyrillic) characters are absent from the string, not that Cyrillic characters are present in the string
p23773
aVYour code will return  only for strings that are composed entirely of Cyrillic characters that do not have an equivalent character in the Latin alphabet1
p23774
aVTo fix this problem, remove the inversion, and invert the check, like this:
p23775
aV1 You have forgotten to include the soft stop  in your list, it looks like a lower-case , but it is not the same character
p23776
as(dp23777
g6
V335858
p23778
stp23779
a((dp23780
g2
(lp23781
VUI refreshes need to happen on the main thread
p23782
aVChange
p23783
aVto
p23784
as(dp23785
g6
V335858
p23786
stp23787
a((dp23788
g2
(lp23789
VYou can open an image context, and then harvest its content immediately, without drawing anything into it
p23790
aVThis should produce a blank  :
p23791
as(dp23792
g6
V335858
p23793
stp23794
a((dp23795
g2
(lp23796
VThere are two problems with your code:
p23797
aVYou are deleting the pointer to the  that you push_back, and
p23798
aVYou are not reading  at all (copy/paste bug; you're reading the data into  twice)
p23799
aVWhile it is OK to have a vector of pointers, it is inconvenient, because you have to do a lot of manual work to manage object's memory
p23800
aVYou can use  instead of  in your vector, like this:
p23801
as(dp23802
g6
V335858
p23803
stp23804
a((dp23805
g2
(lp23806
VThe following line has no effect until the gesture recognizer has been added to a view:
p23807
aVThis is because 's  is initially
p23808
aVMake the assignment on the last line of your  loop to correct this problem
p23809
aVAlso your  is always showing the tag of the last recognizer that you have added
p23810
aVnot the one that fired the event
p23811
aVChange  as follows:
p23812
aVYou should also replace the  instance variable with a local variable in the method that adds the recognizer to the view, and add a colon  to your selector name:
p23813
as(dp23814
g6
V335858
p23815
stp23816
a((dp23817
g2
(lp23818
VThe answer depends on your formatting requirements, but I think a good heuristic would be to chop off the decimal digits when the number shows a thousands separator:
p23819
as(dp23820
g6
V335858
p23821
stp23822
a((dp23823
g2
(lp23824
VYou run the bubble loop only once - you should run it until everything is sorted
p23825
aVYour bubble loop goes to ten, accessing , which is an undefined behavior
p23826
aVHere is how you can fix your main loop:
p23827
as(dp23828
g6
V335858
p23829
stp23830
a((dp23831
g2
(lp23832
VIt is almost certainly a stack overflow
p23833
aVWhen you flood-fill an area recursively, the number of items on the stack equals the length of the fronteer, which may get quite long for larger areas
p23834
aVYou should replace your recursive approach with a queue-based one to fix this problem
p23835
as(dp23836
g6
V335858
p23837
stp23838
a((dp23839
g2
(lp23840
VThis is called a reluctant quantifier
p23841
aVAn asterisk and a question mark  together mean "zero or more times, without matching more characters from the input than is needed"
p23842
aVThis is what prevents the dot  expression from matching the subsequent colon  in the input
p23843
aVA better expression to match the same sequence is , because it lets you avoid backtracking
p23844
aVHere is a link to an article explaining why
p23845
as(dp23846
g6
V335858
p23847
stp23848
a((dp23849
g2
(lp23850
VThe  in front of a string literal makes it a verbatim string literal, so the backslash  does not need to be doubled
p23851
aVYou can use  instead of  for the same effect
p23852
as(dp23853
g6
V335858
p23854
stp23855
a((dp23856
g2
(lp23857
VI do not know the answer to the first part of your question, but once you learn the answer to the second part, I am sure that you would go with a different solution anyway
p23858
aVmethod is called every time
p23859
aVSo, does that mean I created new object instance each time  method was executed
p23860
aVAbsolutely
p23861
aV"Modal" segue causes the new view to obscure the old one completely until the new view is closed
p23862
aVIf you go back and forth many times, your code will accumulate a whole "stack" of views underneath the current one
p23863
aVI also notice that  method is never called
p23864
aVSo, if answer to previous question is affirmative (each  execution creates new object instance), does that mean that my  object instances are never being unloaded and deleted
p23865
aVThis is correct, all the view controllers that you create are still there, ready for you to close the views on top of it
p23866
aVOr ARC is doing garbage collection behind the scenes
p23867
aVARC is not a garbage collector, it is a reference counting mechanism with a little automation from the compiler
p23868
aVThe objects are still there
p23869
aVYou should change your code to call
p23870
aVin the second controller, rather than using a modal segue that brings you back to the first one
p23871
as(dp23872
g6
V335858
p23873
stp23874
a((dp23875
g2
(lp23876
VYou cannot use the  way because  is a , not a ; the code will not compile unless there is an overload that takes a second parameter of type
p23877
aVhow the generic parameter 'M' is instantiated inside of a ShowDialog() method implementation
p23878
aVIt is not "instantiated" it is "inferred:
p23879
aVYou provided the instance already; the compiler infers the type from the invocation
p23880
as(dp23881
g6
V335858
p23882
stp23883
a((dp23884
g2
(lp23885
VYou need to add a prototype for  in the
p23886
aVThe  function should return  instead of
p23887
aVThe variable  should also be of type
p23888
aVOther than that, you should be OK: returning character pointers to string literals is OK, because they are not local to the function returning them
p23889
aVAlso consider simplifying your function using an array, like this:
p23890
as(dp23891
g6
V335858
p23892
stp23893
a((dp23894
g2
(lp23895
VYou need to add  qualifier to declarations of the variable and the function to fix this:
p23896
aVNote: The bottom of your function is missing, but make sure that you are not returning  without copying it
p23897
as(dp23898
g6
V335858
p23899
stp23900
a((dp23901
g2
(lp23902
V is an interface implemented by  class
p23903
aVAnother well-known implementation of the  is
p23904
aVprovides constant-time random access, while  provides constant time for non-sequential access
p23905
aVWhen you declare a variable that will hold an , consider accessing it through an interface, like this:
p23906
aVThis will let you swap in a different implementation without disturbing the rest of your code
p23907
as(dp23908
g6
V335858
p23909
stp23910
a((dp23911
g2
(lp23912
VYou can use  method, like this:
p23913
aVAlternatively, you can eliminate spaces before they enter , like this:
p23914
as(dp23915
g6
V335858
p23916
stp23917
a((dp23918
g2
(lp23919
VYes, doing concurrent updates without proper synchronization may cause crashes, even if your threads access different keys: the  is based on trees, trees get rebalanced, so you can cause a write to a parent of a node with a seemingly unrelated key
p23920
aVMoreover, it is not safe to perform read-only access concurrently with writing, or searching unlocked + locking on write: if you have threads that may update or delete nodes, you must lock out all readers before you write
p23921
as(dp23922
g6
V335858
p23923
stp23924
a((dp23925
g2
(lp23926
VThere is a big difference between Objective C and Java
p23927
aVJava is an interpreted language built from the ground up, while Objective C was built on top of C language
p23928
aVAnything that you can do in C is valid in Objective C as well
p23929
aVUnlike Java, C (and by extension, Objective C) has "raw memory allocation"
p23930
aVIn Java, a call to  automatically calls the constructor
p23931
aVThe language makes it impossible to go around this mechanism
p23932
aVIn Objective C, however, you can allocate raw memory
p23933
aVThe memory does not contain a ready-to-use object at the time it is returned to you from  - it is only partially prepared for use
p23934
aVThe memory block has a reference count, and it provides enough space to fit your object, but it is not ready to receive messages that your own subclass has implemented
p23935
aVThat is why you must call  (or use , which combines  and  for you)
p23936
aVThe  assignment/check lets you trap errors during the construction phase of your object
p23937
aVIf your own initializer fails, you can set  to report the problem up the chain
p23938
aVAssigning a different object is far less common, but it could be done as well
p23939
as(dp23940
g6
V335858
p23941
stp23942
a((dp23943
g2
(lp23944
VYou can call  method of the , passing the section number
p23945
aVHowever, it is your own code that produces this number based on what's in the model, so it may make sense to look at the implementation of  in your data source to see if you could get the same answer through an alternative path
p23946
as(dp23947
g6
V335858
p23948
stp23949
a((dp23950
g2
(lp23951
VThe  gets the high-priority queue, not creates it
p23952
aVThe three global queues are automatically created for your application; they are always available
p23953
aVThe three global queues are global only within your application, in the same sense as global variables are global
p23954
aVThese queues are still private to each application in which they are created
p23955
aVThe main difference between private and global queue is used to be that private queues are were sequential, while global queues are concurrent
p23956
aVThe differences between the two are summarized in Table 3-1 of GCD documentation
p23957
aVEDIT : In OS X v10
p23958
aV7 and later, the private queues can now also be concurrent by passing  (thanks, Rob, for the correction)
p23959
as(dp23960
g6
V335858
p23961
stp23962
a((dp23963
g2
(lp23964
VYou cannot do that: while your  is executing, no other updates to the screen are possible; the spinning gear will not get a chance to be drawn or updated
p23965
aVIf your  takes a few seconds, you should reconsider your strategy: perhaps you could isolate the drawing-intensive code in a function that draws to an in-memory bitmap, show a  with a placeholder image in place that was to be painted by your  code, do the rendering in a background thread, and replace the image of the  with what your code has painted
p23966
as(dp23967
g6
V335858
p23968
stp23969
a((dp23970
g2
(lp23971
VShort answer: you should add a separate method in the DLL that frees the memory for you
p23972
aVLong answer: there are different ways in which the memory can be allocated inside your DLL implementation
p23973
aVThe way you free the memory must match the way in which you have allocated the memory
p23974
aVFor example, memory allocated with  (with square brackets) needs to be freed with  (as opposed to  or )
p23975
aVC# does not provide a mechanism for you to do it; you need to send the pointer back to C++
p23976
as(dp23977
g6
V335858
p23978
stp23979
a((dp23980
g2
(lp23981
VThe problem is not with how you override, but with how you allocate:
p23982
aVWhen you cast  to , the object remains what it was - an instance of
p23983
aVYou need to allocate an instance of  in order to see your override work
p23984
as(dp23985
g6
V335858
p23986
stp23987
a((dp23988
g2
(lp23989
VYou can use a regular expression  to get the content of the quoted string, like this:
p23990
aVHere is a link to ideone
p23991
as(dp23992
g6
V335858
p23993
stp23994
a((dp23995
g2
(lp23996
VYou do not need to make the field volatile, because neither thread makes changes to the field itself: its value is set once in the initializer, and it does not change after that
p23997
aVYou may need to add synchronization to your methods, but declaring the variable  is entirely unnecessary in this case: using  would be a lot more appropriate
p23998
as(dp23999
g6
V335858
p24000
stp24001
a((dp24002
g2
(lp24003
VApproach 1 is useful mostly when the two packages are exclusive of each other, i
p24004
ag630
aVin cases when the cars have a common interface, the reds and blues are compiled into separate JARs, and only one of these two JARs is present at a time
p24005
aVWhen both packages could be present, this naming is confusing
p24006
aVApproaches 2 and 3 are nearly equivalent, because the names are sufficiently different from each other
p24007
aVCreating a separate package (approach 2) may or may not be an overkill, depending on the way the two groups of classes are used in your application
p24008
as(dp24009
g6
V335858
p24010
stp24011
a((dp24012
g2
(lp24013
VTokenizer will not do, you need a parser
p24014
aVRegexps are not particularly good at counting, and that is what you need to decide on where to end a parenthesized block with commas inside
p24015
aVA simple Recursive Descent Parser should work in your case
p24016
aVYou may want to get fancy and try ANTLR
p24017
aVIt is a great and powerful tool, but it is probably an overkill for simple expression such as the ones in your example
p24018
as(dp24019
g6
V335858
p24020
stp24021
a((dp24022
g2
(lp24023
VTry this:
p24024
aVThis approach constructs a list of 's element names that are not present in , puts them in a set, and then uses that set to filter 's elements
p24025
aVFor removed elements, reverse the order of operand that you pass to , and filter :
p24026
as(dp24027
g6
V335858
p24028
stp24029
a((dp24030
g2
(lp24031
VLeaving aside the observation that using a  operator to feed parameters to an object goes against the expectations of a casual reader, you can use lambdas to represent your functions
p24032
aVFor example, , a delegate that does not return a value, may be used like this:
p24033
as(dp24034
g6
V335858
p24035
stp24036
a((dp24037
g2
(lp24038
VA single declaration of a pointer to a data member, creates pointers for every object of that class
p24039
aVNo, it does not
p24040
aVA pointer to a member is a special object that is very different from a pointer; it is a lot more similar to an offset
p24041
aVGiven a pointer to an object of the class and a member pointer, you'd be able to get the value of a member; without the pointer to an object of a class a pointer to a member is useless
p24042
aVQuestions 2 and 3 stem from the same basic misunderstanding
p24043
as(dp24044
g6
V335858
p24045
stp24046
a((dp24047
g2
(lp24048
VThis is not surprising, because the behavior is not specified by the standard:
p24049
aVThere is no standard specification on what happens when the converted value would be out of the range of representable values by an int
p24050
aVThe  function gives you more info in the return, as it sets  to  when the value does not fit in a
p24051
as(dp24052
g6
V335858
p24053
stp24054
a((dp24055
g2
(lp24056
VConvert your table to a file, embed the file as a resource, read it once in a static initialization block, and store it in a  array
p24057
aVIt will not be distinguishable from an array initialized through an aggregate, except there would be no 65535 limit
p24058
aVStoring in a static variable will help you avoid "reads every second"
p24059
aVAs far as the format is concerned, you can put each row of the matrix in a separate line of the resource file
p24060
aVReading and maintaining this file would be simple, because there would be no other mark-up around your numbers
p24061
aVHere is a link to an answer explaining how to read a file from a resource
p24062
as(dp24063
g6
V335858
p24064
stp24065
a((dp24066
g2
(lp24067
VTry this:
p24068
as(dp24069
g6
V335858
p24070
stp24071
a((dp24072
g2
(lp24073
VEDIT : I did not notice the  parameter, here is an update:
p24074
as(dp24075
g6
V335858
p24076
stp24077
a((dp24078
g2
(lp24079
VYes, it is called
p24080
as(dp24081
g6
V335858
p24082
stp24083
a((dp24084
g2
(lp24085
VThis should work:
p24086
aVThe  is a comparison delegate
p24087
aVThe  method calls it with pairs of lists to compare, and the delegate that returns a negative number if  is shorter than , a positive number if  is longer than , and zero when the two lists are of the same length
p24088
as(dp24089
g6
V335858
p24090
stp24091
a((dp24092
g2
(lp24093
VIf you can change from  to , you could use the  method to produce a read-only wrapper of your list
p24094
aVThe wrapper is lightweight, does not require copying, and immediately reflects the changes to the underlying collection:
p24095
as(dp24096
g6
V335858
p24097
stp24098
a((dp24099
g2
(lp24100
VThis is a little tricky, because a property can be read-only, write-only, or read/write
p24101
aVTherefore, you need to check both underlying methods for being virtual, like this:
p24102
as(dp24103
g6
V335858
p24104
stp24105
a((dp24106
g2
(lp24107
VIf you are unsure of the case of the strings, convert both to lower case:
p24108
as(dp24109
g6
V335858
p24110
stp24111
a((dp24112
g2
(lp24113
VSort the first three elements, and take the middle one
p24114
aVIt's your non-unique number
p24115
aVGo through the list, and look for a number that is different from it:
p24116
aVLink to ideone
p24117
as(dp24118
g6
V335858
p24119
stp24120
a((dp24121
g2
(lp24122
VRecall that in a binary system a bit in a position  represents
p24123
aVTherefore, the formula for positive  is
p24124
as(dp24125
g6
V335858
p24126
stp24127
a((dp24128
g2
(lp24129
VYour solution is definitely a valid one, in the sense that it will get the job done
p24130
aVHowever, the problem of detecting a loop is usually formulated with the additional constraint of using  additional memory
p24131
aVThe hare and tortoise algorithm satisfies this constraint, while your algorithm does not: it requires  additional memory to store the per-node booleans
p24132
as(dp24133
g6
V335858
p24134
stp24135
a((dp24136
g2
(lp24137
VYou cannot trust classes that extend you to create a single instance of themselves1: even if you could somehow ensure that they all implement , there is no way to tell that inside that method they check  before constructing a new instance of themselves
p24138
aVStay in control of the process: create a , and instantiate the class passed in through reflection2
p24139
aVNow your code can decide whether to create an instance or not, without relying on the  of a subclass
p24140
aV1 A popular saying goes, "If you want a job done right, do it yourself
p24141
aV2 Here is a link describing a solution based on
p24142
as(dp24143
g6
V335858
p24144
stp24145
a((dp24146
g2
(lp24147
VI would be among the first to admit that the process of referencing a static library in Xcode is not entirely intuitive
p24148
aVHowever, using a static library is the best option, without a doubt
p24149
aVThe main reason is maintainability: when you copy source code of a library to many places, you must remember to update all of them to the latest code when you upgrade to the next version of the library
p24150
aVThis may be a rather error-prone process, especially when the underlying library source changes significantly (e
p24151
ag303
aVnew files are added, old files are renamed, etc
p24152
as(dp24153
g6
V335858
p24154
stp24155
a((dp24156
g2
(lp24157
VYou can automate the cut/paste process by using the search and replace feature of Visual Studio to find all declarations, and replace them with declarations that inherit from your base class
p24158
aVPress [Ctrl+H] to open Quick Replace
p24159
aVEnter  in the "Find what" box
p24160
aVEnter  in the "Replace with:" box
p24161
aVChoose "Current Project" in the "Look in:" box
p24162
aVCheck the "Use:" checkbox, and pick "Regular expressions" in the dropdown
p24163
aVKeep clicking  to find the next occurrence of a class declaration
p24164
aVIf the search highlights one of the sixty declarations that you want to modify, click , otherwise keep clicking
p24165
as(dp24166
g6
V335858
p24167
stp24168
a((dp24169
g2
(lp24170
VInstead of reading a string back, you should get the value using the  member:
p24171
aVOtherwise, the reading follows the usual pattern of treating spaces as separators
p24172
as(dp24173
g6
V335858
p24174
stp24175
a((dp24176
g2
(lp24177
VSince  in a class method refers to the class, you should not be making  a target of your selector:
p24178
aVInstead, you should be sending the selector to an object that responds to the selector
p24179
as(dp24180
g6
V335858
p24181
stp24182
a((dp24183
g2
(lp24184
VIn my experience, denormalizing for performance is not in itself an evil, but you need to check first that you cannot optimize the queries that you run against your initial 3NF design to give you reasonable timing
p24185
aVHere is a link to a nice article suggesting that reduction in the number of joins is a common (and good) reason to denormalize
p24186
as(dp24187
g6
V335858
p24188
stp24189
a((dp24190
g2
(lp24191
VOne of the most common ways to make a string from an array of bytes is encoding them in Base-64:
p24192
aVUse
p24193
aVto get your bytes back
p24194
as(dp24195
g6
V335858
p24196
stp24197
a((dp24198
g2
(lp24199
VYour  and  are reversed
p24200
aVUse  for output and  for input
p24201
as(dp24202
g6
V335858
p24203
stp24204
a((dp24205
g2
(lp24206
VNo, this is not possible
p24207
aVThe "class X implements interface Y" relationship is fixed at compile time, and cannot be altered at runtime
p24208
aVHowever, using interfaces to import constants into a class is a solution that dates back to Java 1
p24209
ag49
aVThis anti-pattern should not be used for new development
p24210
aVMoreover, localization with compile-time constants is not a native solution in Java
p24211
aVYou should localize using resource bundles
p24212
aVIf you need a way to switch implementations at runtime, replace constants with methods in your interface, and provide implementations that return different constants:
p24213
as(dp24214
g6
V335858
p24215
stp24216
a((dp24217
g2
(lp24218
VThe  is a logical  (as opposed to , which is a bitwise )
p24219
aVIt cares only that its operands as zero/non-zero values
p24220
aVZeros are considered , while non-zeros are treated as
p24221
aVIn your case, both operands are non-zero, hence they are treated as , resulting in a result that is  as well
p24222
aVC represents  as , explaining the overall result of your operation
p24223
aVIf you change the operation to , you would get a bitwise operation
p24224
aVwill give you a result of
p24225
as(dp24226
g6
V335858
p24227
stp24228
a((dp24229
g2
(lp24230
VThe purpose of inner classes is to "package" implementations of an operation in a way that you can use from other places
p24231
aVThis lets you implement a concept of callbacks, when you pass a piece of code to a method that can pass the control back to you
p24232
aVThe base class/interface is there to provide an access point to that piece of code
p24233
aVYou and the method that you call agree on the name and the signature of the callback method by agreeing on the interface that your inner class (actually, any class) must implement for the target method to be able to call you back
p24234
aVTo be more specific, in order for the window to call back your window listener, you must agree on the name and the signature of the  method
p24235
aVYou do it by implementing an interface
p24236
aVIn rare cases when the target method is one implemented by  (e
p24237
ag303
aV) you can derive your named or anonymous inner class from the top-level
p24238
as(dp24239
g6
V335858
p24240
stp24241
a((dp24242
g2
(lp24243
VThe first allocates an array of , and the other allocates an array of pointers to
p24244
aVIn the first case, you can write to fields by assigning  right away, while in the second case you must allocate the  itself before doing the actual writing
p24245
aVIt is OK to drop the cast of  result in C, so you could write
p24246
as(dp24247
g6
V335858
p24248
stp24249
a((dp24250
g2
(lp24251
VYou are converting the  to  but  remains a string
p24252
aVYou should either compare them as strings, like this
p24253
aVor as datetimes, like this:
p24254
aVEDIT: On SQL Server 2005 try this:
p24255
as(dp24256
g6
V335858
p24257
stp24258
a((dp24259
g2
(lp24260
VYou can use the  method instead of :
p24261
as(dp24262
g6
V335858
p24263
stp24264
a((dp24265
g2
(lp24266
VTry this:  will provide a value that tells you whether a number is an infinity or not
p24267
aVHere is an example code for a  of  values; you can change the  to use  instead
p24268
aVOn ideone: link
p24269
aVFor :
p24270
as(dp24271
g6
V335858
p24272
stp24273
a((dp24274
g2
(lp24275
VMake , and keep adding
p24276
aVitems to it until its size gets to
p24277
aVThe you know that you have your three indexes
p24278
as(dp24279
g6
V335858
p24280
stp24281
a((dp24282
g2
(lp24283
VYou can use LINQ expressions to do this conversion
p24284
aVThis article explains how
p24285
aVThe basic idea is to construct a LINQ expression equivalent to a cast expression
p24286
aVNow you can call  and pass it an  wrapping a value of the original type; it will return a coerced value back to you
p24287
aVThis code will pick up your custom type conversions too (for your own types, not for primitives)
p24288
aVIf necessary, you can add more conversions in between by increasing the level of nesting of your  objects
p24289
as(dp24290
g6
V335858
p24291
stp24292
a((dp24293
g2
(lp24294
VI think you have a simple copy/paste bug: join conditions for tables product2 and product3 errorneously reference product1's id in the first part of their join criteria
p24295
as(dp24296
g6
V335858
p24297
stp24298
a((dp24299
g2
(lp24300
VSelectors let you service concurrent communication across multiple channels using a single thread
p24301
aVIt may be useful on a client when you must communicate with several servers concurrently, or when you communicate with peer computers in the role of a client, such as when reading a torrent
p24302
as(dp24303
g6
V335858
p24304
stp24305
a((dp24306
g2
(lp24307
VThis is because you are defining the globals in the header, while you should be only declaring them
p24308
aVAdd  in front of your global definitions, and create a definition in a single cpp file
p24309
aVIn the header:
p24310
aVIn a cpp file:
p24311
as(dp24312
g6
V335858
p24313
stp24314
a((dp24315
g2
(lp24316
VYou can, but you do not have to: bit shifting will double the number, no matter what base you use for interpreting it later, because internally these s are still interpreted as binary by the underlying shift operations
p24317
aVYour implementation will have to decide on the tradeoff there, because your shifting will become harder to implement
p24318
aVOn the other hand, the printing in base-10 will remain simpler
p24319
aVAnother solution favoring the decimal system that you may consider is using binary-coded decimals (BCD)
p24320
aVBack in the day, hardware used to accelerate these operations (e
p24321
ag303
aV6502, the CPU of Apple-2) included special instructions for adding bytes in the BCD interpretation
p24322
aVYou would have to implement special correction if you use this representation, but it may be a worthy learning exercise
p24323
as(dp24324
g6
V335858
p24325
stp24326
a((dp24327
g2
(lp24328
VUse a good hashing algorithm to calculate a hash code of the  items in each row
p24329
aVOrganize rows by their hash code, and do a full compare only when the hash codes match
p24330
as(dp24331
g6
V335858
p24332
stp24333
a((dp24334
g2
(lp24335
VThis usually happens when your method is returning a generic list of  that is less accessible than the method returning it, for example
p24336
as(dp24337
g6
V335858
p24338
stp24339
a((dp24340
g2
(lp24341
VAdd a count variable, set it to zero, and break out of the loop when it reaches three:
p24342
aVI am purposely posting only a skeletal solution, assuming that this is a homework
p24343
as(dp24344
g6
V335858
p24345
stp24346
a((dp24347
g2
(lp24348
VThe expression is relatively simple:
p24349
aVThat is, 5 digits, an optional space, and one or more upper-case letter
p24350
aVThe anchors at both ends ensure that the entire input is matched
p24351
aVThe parentheses around the digits pattern and the letters pattern designate capturing groups one and two
p24352
aVAccess them to get the number and the word
p24353
as(dp24354
g6
V335858
p24355
stp24356
a((dp24357
g2
(lp24358
VThere is a cocoa feature that lets you build multicast delegates with relative ease - it's the Message Forwarding system built into the framework
p24359
aVMake a class that overrides , and return an instance of your object instead of a delegate
p24360
aVThis is what is sometimes called a "Trampoline object"
p24361
aVThe logic inside your  implementation can now decide which "real" objects should receive the message, and forward the invocation to one or more of them
p24362
aVAs an update to this accepted answer, I created my own multicasting delegate implementation here:
p24363
aVhttp://www
p24364
aVscottlogic
p24365
aVco
p24366
aVuk/blog/colin/2012/11/a-multicast-delegate-pattern-for-ios-controls/
p24367
as(dp24368
g6
V335858
p24369
stp24370
a((dp24371
g2
(lp24372
VFirst, to answer your question:
p24373
aVBut for some reason returned json object is
p24374
aVI wonder why
p24375
aVThe variable that you are returning has not been set at the time when you return it
p24376
aVYou cannot harvest the results immediately after the  method has returned: the call has to finish the roundtrip before calling back your block and setting  variable
p24377
aVNow a quick note on what to do about it: your method is attempting to convert an asynchronous call into a synchronous one
p24378
aVTry to keep it asynchronous if you can
p24379
aVRather than expecting a method that returns a , make a method that takes a block of its own, and pass the dictionary to that block when the  method completes:
p24380
as(dp24381
g6
V335858
p24382
stp24383
a((dp24384
g2
(lp24385
VYou should not test your private methods directly
p24386
aVInstead, you need to test them through the public methods
p24387
aVHere is a link to a question on programmers
p24388
aVstackexchange
p24389
aVcom discussing the matter
p24390
aVThe general idea of the answers is that you (or anyone else maintaining your code) should be free to change your private methods at any time by altering the signature, changing implementation, or removing them altogether
p24391
aVNobody outside your class should care - after all, that's the primary driver behind making these method private in the first place
p24392
aVIf you change your private nethod in an incompatible way, then unit tests of your public methods must break; otherwise, you didn't do a good job of testing your public methods
p24393
aVEffectively, this renders unit testing of private methods unnecessary
p24394
as(dp24395
g6
V335858
p24396
stp24397
a((dp24398
g2
(lp24399
VMicrosoft provides Active Directory Application Mode (ADAM) for these situations
p24400
aVYou can download it from here
p24401
as(dp24402
g6
V335858
p24403
stp24404
a((dp24405
g2
(lp24406
VYou can do it like this ( is a 16-bit number):
p24407
aVThe first line swaps the odd and even bits
p24408
aVThe second line swaps consecutive pairs
p24409
aVThe third line swaps groups of four bits
p24410
aVThe last line swaps the two bytes
p24411
aVYou can find more tricks like this here
p24412
aVHere is a link to ideone with this code snippet
p24413
aVIf you are trying to make sense of this, write binary representations of the "magic numbers" used in the example:
p24414
aVis
p24415
aVis
p24416
aVis
p24417
aVis
p24418
aVThe  operation clears out the "unwanted" bits; the shifts reposition the desired parts over the "zero gaps" opened up by the masking operation, and finally the  re-combines the two parts
p24419
as(dp24420
g6
V335858
p24421
stp24422
a((dp24423
g2
(lp24424
VWhen you do not pass anything, the  is not  - it is empty:
p24425
as(dp24426
g6
V335858
p24427
stp24428
a((dp24429
g2
(lp24430
VYou need to pass  flag to  in order to search up the hierarchy:
p24431
as(dp24432
g6
V335858
p24433
stp24434
a((dp24435
g2
(lp24436
VYour properties are not limited to synthesized ones - in fact, they are no more than a pair of methods that follow a certain naming convention
p24437
aVYou can remove the  instructions for the  and , and replace them with methods that get/set the first and the second elements of the  that holds nodes in case when there are more than two
p24438
as(dp24439
g6
V335858
p24440
stp24441
a((dp24442
g2
(lp24443
VIt looks like you are using  method somewhere, but you have forgotten to include a header with the category declaring it
p24444
aVIf you are using a popular base-64 encoding library for iOS, the header name is
p24445
as(dp24446
g6
V335858
p24447
stp24448
a((dp24449
g2
(lp24450
VThere would be no memory re-allocation in the , and there almost certainly will be a reallocation for the , although the standard does not say anything about that
p24451
aVThe string is like a vector in that it keeps the content separately from the string object itself
p24452
as(dp24453
g6
V335858
p24454
stp24455
a((dp24456
g2
(lp24457
VThe  and  are not "global variables of the function", they are local variables
p24458
aVThe problem is not in that "scope in C is not like in Java", but that some of the branches in your function fail to assign
p24459
aVSpecifically, there is no assignment in the branch that does
p24460
aVIf you declare a variable without a value in Java, the compiler look for code paths that uses this variable before an assignment, and alerts you if there is one; in C you have to watch for these situations yourself
p24461
aVIf you put  at the bottom, and make sure that all code paths assign  the right value, your code will work with a single  statement, just like your  does
p24462
as(dp24463
g6
V335858
p24464
stp24465
a((dp24466
g2
(lp24467
VFirst, the API that you expose should definitely be free of POCO, boost, qt, or any other type that is not part of the standard C++ library
p24468
aVThis is because the base libraries have their own release cycle, distinct from the release cycle of your library
p24469
aVIf the users of your library also use boost, but a different, incompatible, version, they would need to spend time to resolve the incompatibility
p24470
aVThe only exception to this rule is when you design a library to be released as part of a wider framework - say, an addition to the POCO toolkit
p24471
aVIn this case the release of your library is tied to the release of the entire toolkit
p24472
aVInternally, however, you should avoid using your own wrappers, unless the library that you are abstracting out is a true "commodity library"1
p24473
aVThe reason for this is that when you hide an external library behind your classes, most of the time you mimic the level of abstraction of the library that you are hiding
p24474
aVThe code that uses your wrapper will program to the level of abstraction dictated by the external library
p24475
aVWhen you swap the implementation behind your wrapper for a different framework, it is very likely that you would either (1) adapt the new framework to fit the level of abstraction of the old framework, or (2) will need to change the way in which you use your wrapper
p24476
aVBoth cases are highly suspect: if you do (1), perhaps you shouldn't switch in the first place, and if you do (2), then your wrappers prove to be useless
p24477
aV1 By "commodity library" I mean a library that provides a level of abstraction commonly found in other libraries that serve a similar purpose
p24478
as(dp24479
g6
V335858
p24480
stp24481
a((dp24482
g2
(lp24483
VIt is not what you think: the problem is the deletion of the
p24484
aVYou call  instead of  on an array allocated with  - an undefined behavior
p24485
aVOnce you fix that error, you will have other errors related to s initialized with string literals: passing them to  is also undefined behavior
p24486
aVThe root cause of the problem is that your class does not let you differentiate between the memory that you must release and the memory that you must not release
p24487
aVYou should do it uniformly, for example by always copying the content into an array that you allocate inside the constructor
p24488
as(dp24489
g6
V335858
p24490
stp24491
a((dp24492
g2
(lp24493
VThe outer loop of the first example executes  times
p24494
aVFor each iteration of the outer loop, the inner loop gets executed  times, so the overall complexity can be calculated as follows: one for the first iteration plus two for the second iteration plus three for the third iteration and so on, plus  for the -th iteration
p24495
aVThe second example is trickier: since  doubles every iteration, the outer loop executes only  times
p24496
aVAssuming that  is a power of , the total for the inner loop is
p24497
aVwhich is  for the complexity
p24498
aVFor s that are not powers of two the exact number of iterations is , which is still :
p24499
aVand so on
p24500
as(dp24501
g6
V335858
p24502
stp24503
a((dp24504
g2
(lp24505
VStatic functions have no  pointer because they do not have access to instance variables
p24506
aVThat is the reason why you declared them static in the first place (in OO literature static functions of C++ are often referred to as class functions)
p24507
aVThe reason the same pointer is returned from  is that the variable inside the method stores the pointer in the static storage,
p24508
aVmeaning that all invocations of the method will get the same value
p24509
aVYou are also wrong about the copying happening when you call instance functions
p24510
aVThe pointer  points to the object itself, so the changes that you make to  are performed on the actual object
p24511
as(dp24512
g6
V335858
p24513
stp24514
a((dp24515
g2
(lp24516
VThey both have access to all members of the class, including the private ones
p24517
aVYou need to decide if a function logically belongs to the class the access to members of which it needs, or if it belongs to another class or no class at all
p24518
aVIn the first case (a function that logically belongs to the class) make the function static; in the second case, make it a friend, and add to the class or the namespace where it logically belongs, according to your design
p24519
as(dp24520
g6
V335858
p24521
stp24522
a((dp24523
g2
(lp24524
VJava is identical to C# in this respect, all you need to do is declaring the variable outside both if statements, and set its initial value:
p24525
as(dp24526
g6
V335858
p24527
stp24528
a((dp24529
g2
(lp24530
VSearch for
p24531
aVand replace with
p24532
aVThe square brackets around dot  are to make sure it's not interpreted as meta-character (you can use  instead)
p24533
aVThe  is Visual Studio's symbol for an identifier
p24534
aVThe  in the replacement string references the first tagged expression (i
p24535
ag630
aVthe  expression), so the identifier will be "pasted in" inside the double quotes
p24536
as(dp24537
g6
V335858
p24538
stp24539
a((dp24540
g2
(lp24541
VYou use dot  operator to access non-static members, not the scope resolution operator
p24542
aVNote that the assignment below
p24543
aVmakes a copy of your singleton
p24544
aVYour  returns a reference, so you should probably make  a reference as well:
p24545
as(dp24546
g6
V335858
p24547
stp24548
a((dp24549
g2
(lp24550
VSince  requires zeroing out one or more pointers in places other than the current object, additional data structures are required to keep track of weak references
p24551
aVThis is in contrast to , , and , which do not require additional tracking
p24552
aVThe tracking structures and programs for manipulating them are built into the OS; the compiler inserts the code to perform the calls, but the OS support needs to be there in order for the compiled code to work
p24553
as(dp24554
g6
V335858
p24555
stp24556
a((dp24557
g2
(lp24558
VThe second code fragment avoids creation of two temporary objects (one for the  converted to , the other for the return value of ), so in theory it should be faster
p24559
aVHowever, micro-optimizations of this sort rarely pay off: it is unlikely that you would see a substantial gain from using the second form over the first one if you apply this optimization randomly
p24560
aVOf course the situation is different if your profiler tells you that your program spends a substantial percentage of its time checking the ending of the string like this; in this case, the optimization will likely help
p24561
as(dp24562
g6
V335858
p24563
stp24564
a((dp24565
g2
(lp24566
VYou need to split the C++ portion into a header file and a  file, otherwise the  will be defined twice
p24567
aVClassA
p24568
aVh:
p24569
aVClassA
p24570
aVcpp:
p24571
aVYour
p24572
aVmm file:
p24573
as(dp24574
g6
V335858
p24575
stp24576
a((dp24577
g2
(lp24578
VYou cannot conditionally join a table You need to join all tables unconditionally using an outer join, use the condition in the join criteria, and pick the values that you want from the returned data set, like this:
p24579
aVThe example above shows "requests" that have an  that references a person, an animal, or a thing
p24580
aVThe  column decides which table is referenced
p24581
aVThe result will have three columns for , at most one of which will be non-null
p24582
as(dp24583
g6
V335858
p24584
stp24585
a((dp24586
g2
(lp24587
VThe message describes the error adequately: your table has many countries in Europe, so  operator cannot be applied without some aggregation or more constraints in the subquery:
p24588
aVAdding  ensures that there would be precisely one number selected, and that number is the highest GDP among all European countries1
p24589
aV1 You might as well select the GDP of Germany right away :)
p24590
as(dp24591
g6
V335858
p24592
stp24593
a((dp24594
g2
(lp24595
VTry converting to , and then using :
p24596
aVEDIT : If you would like to make an , remove the :
p24597
aVThis will not run the query until the  is enumerated for the first time
p24598
as(dp24599
g6
V335858
p24600
stp24601
a((dp24602
g2
(lp24603
VTo avoid using two back-to-back calls of , you can use regular expressions
p24604
aVHowever, this is far less readable than the original:
p24605
aVLink to ideone
p24606
as(dp24607
g6
V335858
p24608
stp24609
a((dp24610
g2
(lp24611
VYou can change precision of the values that you print by using :
p24612
aVLink to ideone
p24613
as(dp24614
g6
V335858
p24615
stp24616
a((dp24617
g2
(lp24618
VFirst, you do not need to declare a variable  if you plan to , but if you do, you need to put it in curly braces
p24619
aVSecond, the declaration of the property needs to be inside the interface:
p24620
aVFinally, the syntax for the setter is
p24621
aVIf you choose to override the getter as well, the convention is
p24622
as(dp24623
g6
V335858
p24624
stp24625
a((dp24626
g2
(lp24627
VIt is OK to declare an object inside a loop if this is what your intention is
p24628
aVIn this case, each iteration of the loop will create a new instance of
p24629
aVYou can move the declaration outside the loop to reuse the same object:
p24630
as(dp24631
g6
V335858
p24632
stp24633
a((dp24634
g2
(lp24635
VTry this:
p24636
aVThis expression does not let the string preceding the  contain a dot
p24637
aVIf you would like to allow the dot, use  instead (ideone link)
p24638
aVEDIT: If you must avoid spaces, use a different expression (ideone link):
p24639
aVNow the list of consecutive characters in front of the keyword excludes spaces as well
p24640
as(dp24641
g6
V335858
p24642
stp24643
a((dp24644
g2
(lp24645
VIt is neither possible nor desirable to test the values and state changes of local variables of a method
p24646
aVThey are private details of the implementation, not something you are expected to test
p24647
aVInstead, your tests should judge the correctness of a method by observing something visible from the outside, such as return values, interactions with mocked environment, or externally visible changes of the object's state
p24648
as(dp24649
g6
V335858
p24650
stp24651
a((dp24652
g2
(lp24653
VYou should mark   in order for this to compile:
p24654
aVDoing so tells the compiler that the member function does not modify the state of the object, making it compatible with  pointers and references
p24655
as(dp24656
g6
V335858
p24657
stp24658
a((dp24659
g2
(lp24660
VThere is a big difference between  usage in C and C++
p24661
aVIn C,  declaration declares a structure with a tag, not a type name
p24662
aVAs the result, you must reference it by tag as  unless you add a  around it
p24663
aVIn C++,  is a synonym for , different only in the default member accessibility (private for , public for )
p24664
aVA type name is always defined for the  without a , so adding a  around your  in C++ is unnecessary
p24665
aVThis does not influence the way you declare your constructor: you can inline it in the header, or move it out to the implementation
p24666
aVEither way it is going to work
p24667
aVIt is probably better to put simple initializers that passes args to the initialization list in the header, while more complex initialization should probably go in the cpp file, but it is entirely up to you
p24668
as(dp24669
g6
V335858
p24670
stp24671
a((dp24672
g2
(lp24673
VRandom numbers are random, not unique
p24674
aVJust like a situation with throwing dice when you can roll several sixes in a row, your  can (and should) sometimes give you runs of identical numbers
p24675
aVIn order to make sure that the numbers are unique, build a set where you register each of the numbers that you have added already
p24676
aVWhen a random number comes up more than once, throw the second one away, and go for the next one
p24677
as(dp24678
g6
V335858
p24679
stp24680
a((dp24681
g2
(lp24682
VAssuming that this is a problem for which you do not want an explicit solution, here is a hint: mask the bits in question using , do a shift, and then  then in using bitwise
p24683
aVYou can "cut out" bits 3, 4, and 5 using the  mask, and bits 24, 25, and 26 using the  mask
p24684
aVTake a look at this solution to bit reversing problem for an inspiration
p24685
aVEDIT : (in response to "not a homework" comment) Since this is not a homework, here is a more in-depth explanation:
p24686
as(dp24687
g6
V335858
p24688
stp24689
a((dp24690
g2
(lp24691
VYou can keep a separate flag that indicates that the string has been initialized:
p24692
aVThis will take care of situations when  is assigned, including the cases when it is assigned , empty string, or
p24693
aVAnother solution is to make a static string to denote "uninitialized" value, and use  instead of  to check if it has changed
p24694
aVHowever, the  variable approach expresses your intent a lot more explicitly
p24695
as(dp24696
g6
V335858
p24697
stp24698
a((dp24699
g2
(lp24700
VThis is because the signature of  does not match that of
p24701
aVAccording to C++ standard, Section 13
p24702
ag14884
ag839
aV3:
p24703
aVFirst, to be a viable function, a candidate function shall have enough parameters to agree in number with the arguments in the list
p24704
aVA candidate function having more than m parameters is viable only if the (m+1)-st parameter has a default argument
p24705
aVNone of this applies in this case, so  is not considered viable for the invocation with an empty parameter list
p24706
as(dp24707
g6
V335858
p24708
stp24709
a((dp24710
g2
(lp24711
VAdding  to  in the class extension should do it:
p24712
as(dp24713
g6
V335858
p24714
stp24715
a((dp24716
g2
(lp24717
VThis is the offending line:
p24718
aVYou should replace it with
p24719
aVis a function that converts a C string representing an integer number in decimal representation to an
p24720
as(dp24721
g6
V335858
p24722
stp24723
a((dp24724
g2
(lp24725
VAssuming that this is homework, here is a no-code explanation of what you need to do:
p24726
aVDefine a class that wraps ; let's say you call it
p24727
aVDefine an operation that adds two s together, and returns a third  that equals their sum
p24728
aVYou can do it digit by digit, taking care of a possible carry into an extra digit, so you need to size your result accordingly
p24729
aVDefine an operation that multiplies your number by a power of ten by adding zeros to the array list
p24730
aVAgain, the operation should return a new , rather than modifying the current one
p24731
aVDefine an operation that multiplies a number by a single digit
p24732
aVYou can use multiplication, or a simple loop that uses addition
p24733
aVThe loop would not run more than nine times, so it shouldn't be too bad
p24734
aVCombine the three operations that you have (addition, multiplication by a digit, and multiplication by a power of ten) into a simple multiplication algorithm that you learned in the elementary school
p24735
as(dp24736
g6
V335858
p24737
stp24738
a((dp24739
g2
(lp24740
VThere is no quick way of doing that - you will end up "tokenizing" each line of the file, and then writing only the parts that you want
p24741
aVIf you know that each row contains a fixed number of integers (say, 4, as in your example), and you need to "cut out" several columns from it (say, columns 2 and 3), do this in a loop:
p24742
aVOf course you need to open the files before you start looping, close after you finish it, and test for the end of the input file in your loop condition
p24743
as(dp24744
g6
V335858
p24745
stp24746
a((dp24747
g2
(lp24748
VNo, you cannot overload on a return type or a parameter name
p24749
aVUnlike some other languages (most notably, Objective C1) parameter name is not part of the signature of your function
p24750
aVThe signature of a method consists of the name of the method and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right
p24751
aVThe signature of a method specifically does not include the return type, nor does it include the params modifier that may be specified for the right-most parameter
p24752
aV1 even there it's not exactly the parameter name that becomes part of the selector
p24753
as(dp24754
g6
V335858
p24755
stp24756
a((dp24757
g2
(lp24758
VYou can do it like this:
p24759
as(dp24760
g6
V335858
p24761
stp24762
a((dp24763
g2
(lp24764
V is for displaying textual content
p24765
aVIf you would like to mix text with images, the most common solution is to use , pre-define a simple HTML template, and then insert the text and an image reference into the template
p24766
aVHere is a link to an answer that explains how to use 's  method
p24767
as(dp24768
g6
V335858
p24769
stp24770
a((dp24771
g2
(lp24772
VFrom the documentation:
p24773
aVAll Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock:
p24774
aVA successful lock operation acts like a successful monitorEnter action
p24775
aVA successful unlock operation acts like a successful monitorExit action
p24776
aVIf you use  in both threads (i
p24777
ag630
aVthe reading and the writing ones), the reading thread will see the new value, because  flushes the cache
p24778
aVOtherwise, you need to declare the variable  to force a read from memory in the reading thread
p24779
as(dp24780
g6
V335858
p24781
stp24782
a((dp24783
g2
(lp24784
VIf you are starting with a recursive function that looks like this
p24785
aVchange it to this:
p24786
aVNow Start off the level at zero by calling
p24787
aVwill indicate the number of invocation of  above you
p24788
aVEDIT : (zero-at-the-top)
p24789
aVYou can also transform the function to return its level to implement the "zero at the top" strategy:
p24790
aVNote that in this case you cannot find your  until after the last recursive invocation has returned
p24791
as(dp24792
g6
V335858
p24793
stp24794
a((dp24795
g2
(lp24796
VYou can pass a  object down the recursion invocation chain, and store the number of nodes that you visited in a variable there:
p24797
aVNow your implementation is thread-safe, because it does not use "global" objects
p24798
aVInvoke it as follows:
p24799
as(dp24800
g6
V335858
p24801
stp24802
a((dp24803
g2
(lp24804
VCreate a permutation array, initially set to
p24805
aVSort the permutation according to the  key of the first array
p24806
aVUse the permutation to re-order both arrays
p24807
aVExample: let's say the first array is
p24808
aVThe permutation starts as , and becomes  after the sort
p24809
aVNow you can go through the permutation array, and re-order the original array and the second array as needed
p24810
as(dp24811
g6
V335858
p24812
stp24813
a((dp24814
g2
(lp24815
VThe first version is correct:
p24816
aVIt will compile, but it will not link
p24817
aVThe reason is that you have declared a parameterless constructor of , but you failed to define it
p24818
aVEiher add a definition
p24819
aVor if the default constructor is OK, remove the declaration from the Shape's header
p24820
as(dp24821
g6
V335858
p24822
stp24823
a((dp24824
g2
(lp24825
VThe overflow issue is not a "maybe", it's there for sure: when you exchange a high-magnitude negative with a large positive, you get an overflow, which is undefined behavior according to the standard
p24826
aVBut most importantly, there is absolutely no point to use this (or the xor trick) in place of the usual exchange (through a temp variable) for reasons of readability
p24827
as(dp24828
g6
V335858
p24829
stp24830
a((dp24831
g2
(lp24832
VYou can use the constructor of  where you specify the number of binary digits:
p24833
aVYou need roughly ten binary digits for each three decimal digits that the user wants
p24834
aVFor example, if you need a 30-digit random , use 100 binary digits
p24835
aVYou can cut off the unnecessary digits by using , and do it in a loop to ensure that the initial digit is not zero, ensuring the correct number of digits, like this:
p24836
aVLink to a demo
p24837
as(dp24838
g6
V335858
p24839
stp24840
a((dp24841
g2
(lp24842
VThe problem is that  is not created before the loop, it is declared before the loop
p24843
aVIt remains uninitialized until the assignment
p24844
aVat the very end
p24845
aVIn the meantime, the pointer points at some location in the memory which happens to be readable
p24846
aVThe memory is allocated to something else, though, and that something keeps changing
p24847
aVThat's why the two printouts are different
p24848
aVIn general, you must not be dereferencing pointers before the first assignment; it is undefined behavior that could return junk, or could crash your program
p24849
as(dp24850
g6
V335858
p24851
stp24852
a((dp24853
g2
(lp24854
VAlthough it is unlikely that you would see much difference either way1, option #3 sounds the most plausible: unlike the first option, it does not convert s to s multiple times; unlike the second option, it does not allocate and delete multiple  objects for its intermediate results2
p24855
aVIt also looks cleanest from the readability point of view: no code is duplicated, and output looks like an output, not like a concatenation
p24856
aV1 Insert a mandatory disclaimer about optimization before profiling being evil here
p24857
aV2 Small String Optimization may help on systems where it is supported (thanks, Prtorian), but the constructor and destructor calls for the intermediate objects are not going away
p24858
as(dp24859
g6
V335858
p24860
stp24861
a((dp24862
g2
(lp24863
VYes, it is necessary: if you allocate something on the dynamic store with  or , the compiler has no idea that you have no plans to pass the allocated object along after the function returns, so it is your responsibility to call  (or ) to free the object that you have allocated
p24864
aVYou can use  to avoid calling the  explicitly, but the call will be made by the destructor of  on your behalf
p24865
as(dp24866
g6
V335858
p24867
stp24868
a((dp24869
g2
(lp24870
VThere are several ways to do it - you can do a  loop with an index, or a  loop on the  array:
p24871
aVIn addition to checking each letter separately, you can check all letters at once (or any subset that you'd like) with regular expressions
p24872
as(dp24873
g6
V335858
p24874
stp24875
a((dp24876
g2
(lp24877
V[it shouldn't compile because] the specified line does not match in data types
p24878
aVThere is no compilation error because there exists a constructor of  that takes  as an argument, allowing for conversion between  and
p24879
as(dp24880
g6
V335858
p24881
stp24882
a((dp24883
g2
(lp24884
VThere are two cases here:
p24885
aV, the number of adjacent nodes is bounded by a constant , and
p24886
aV, the number of adjacent nodes is bounded only by , the number of nodes
p24887
aVIn the first case the complexity is , because  is a constant
p24888
aVIn the second case, it's  because of the reason that you explained in your question (i
p24889
ag630
aV" can be ))
p24890
as(dp24891
g6
V335858
p24892
stp24893
a((dp24894
g2
(lp24895
VIt should output the text in hexadecimal format one on each line
p24896
aVThis line
p24897
aValways formats the same number -
p24898
aVIt probably should be
p24899
as(dp24900
g6
V335858
p24901
stp24902
a((dp24903
g2
(lp24904
VYou do not need to make the sign part of the format - it can be parameterized, like this:
p24905
aVEven if you want to put it in the format, the format string can be prepared in an expression:
p24906
as(dp24907
g6
V335858
p24908
stp24909
a((dp24910
g2
(lp24911
VThe  class is designed for larger bit sets
p24912
aVWhen you need bit sets of size 23, even a bit set based ob 3 bytes would use too much memory, because an array of any size uses an additional reference for the array itself, which is most likely four to eight bytes
p24913
aVThe most economical solution in terms of memory is using s instead of bit sets, and writing your own implementations of the bit set operations that you need
p24914
aVSince operations on bit sets are for the most part copied from bitwise operations, you should have no problem implementing them:
p24915
aVand so on
p24916
as(dp24917
g6
V335858
p24918
stp24919
a((dp24920
g2
(lp24921
VYou are almost there: make a  of  to function pointer, initialize it with data pairing a string name to a corresponding function pointer, and then use that map at runtime to pick the correct pointer based on the string parameter passed in
p24922
aVLink to a demo with
p24923
aVHere is how you can do it without a  (it will be slower because of the linear search, but you can fix it by ordering names alphabetically and using binary search)
p24924
aVLink to a demo with arrays
p24925
as(dp24926
g6
V335858
p24927
stp24928
a((dp24929
g2
(lp24930
VImportant:  is not re-entrant, you should use  instead of it
p24931
aVYou can do it by saving a copy of the original string, and looking into offsets of the current token into that copy:
p24932
aVThis prints
p24933
aVDemo on ideone (link)
p24934
as(dp24935
g6
V335858
p24936
stp24937
a((dp24938
g2
(lp24939
VIt is possible, but it is not readable
p24940
aVThe  statement is much better
p24941
as(dp24942
g6
V335858
p24943
stp24944
a((dp24945
g2
(lp24946
V can grow to any size limited by the available memory by discarding its old array, allocating a brand-new one, and copying the values from the old array into the new one
p24947
aVThis operation can take  for any given insertion, the amortized cost is
p24948
as(dp24949
g6
V335858
p24950
stp24951
a((dp24952
g2
(lp24953
VI do not know why you are getting concurrent modification exceptions, because removing items through an iterator is legitimate: according to the documentation,
p24954
aVIf the Vector is structurally modified at any time after the Iterator is created, in any way except through the Iterator's own remove or add methods, the Iterator will throw a
p24955
aVTo answer your question about removing from the vector all elements that are equal to target, the simplest solution is to use 's  method
p24956
as(dp24957
g6
V335858
p24958
stp24959
a((dp24960
g2
(lp24961
VThis is how you invoke  to produce the desired effect:
p24962
as(dp24963
g6
V335858
p24964
stp24965
a((dp24966
g2
(lp24967
VYou should move the constraints on  into the  condition of the join, and remove it from the  clause:
p24968
aVOtherwise, entries for which there are no  end up with s in , and the  clause throws them away
p24969
as(dp24970
g6
V335858
p24971
stp24972
a((dp24973
g2
(lp24974
VTo check if two bits are at the same state, shift one of the bits to the position of the other,  them together,  with the bit indicating the position, and check that the result is zero
p24975
aVFor example, to see that bit 1 is the same as bit 3, do this:
p24976
as(dp24977
g6
V335858
p24978
stp24979
a((dp24980
g2
(lp24981
VYou can use a conditional inside a  to supply ones for items that you are looking for and zeros for other items, like this:
p24982
as(dp24983
g6
V335858
p24984
stp24985
a((dp24986
g2
(lp24987
VYou can do it recursively
p24988
aVAssuming that this is a learning exercise of sorts, I would give you pseudocode instead of a C program:
p24989
aVThe top three lines are a base case
p24990
aVstarts at zero, and indicates the position in the  array that needs to be filled by the current level of the recursive invocation
p24991
aVOnce  reaches , we print the current combination and return to the prior level
p24992
aVThe bottom three lines are a loop, similar to the nested loops in a solution to the problem when
p24993
aVThe "nesting" happens dynamically through recursion: you can think of the next level of the recursive invocation as another level of "loop nesting"
p24994
aVEssentially, the recursive solution lets you build  nested loops, where  is known only at run-time
p24995
as(dp24996
g6
V335858
p24997
stp24998
a((dp24999
g2
(lp25000
VThe primary reason for introducing delegates is to provide a mechanism for manipulating snippets of executable code: storing pointers to it, passing to functions, organize in data structures, and so on
p25001
aVLike all function invocations, invoking an individual delegate is synchronous, in the sense that the caller must wait for the delegate to finish before getting the control back
p25002
aVHowever, you can use delegates to implement asynchronous APIs by passing a piece of code that could be stored and executed later on (asynchronously)
p25003
aVThere are many uses of delegates in asynchronous APIs, for example,
p25004
aVNET Asynchronous I/O
p25005
aVThe core support of delegates remained the same, but the language added many important features to make it more convenient to define delegates
p25006
aVFor example, C#2
p25007
aV0 added anonymous delegates, and C#3
p25008
aV5 added lambdas
p25009
as(dp25010
g6
V335858
p25011
stp25012
a((dp25013
g2
(lp25014
VYour code allocates all four matrices in the automatic storage*, which may be limited
p25015
aVEven four times 80K may be too much for a mobile device
p25016
aVIf you need to deal with that much memory, consider allocating it from the dynamic memory using :
p25017
aV* Often referred to as "stack", by the name of the data structure that is frequently used in the implementation of automatic storage
p25018
as(dp25019
g6
V335858
p25020
stp25021
a((dp25022
g2
(lp25023
VNowhere is this declared and I think that's what's messing me up
p25024
aVWait, it's declared right there - in the header of the method:
p25025
aVis different from other variables that you have seen in that it is not a normal variable: it is a formal parameter of a method
p25026
aVUnlike regular variables which you initialize and assign explicitly with the assignment operator , formal parameters are assigned implicitly by virtue of calling a method
p25027
aVWhen you call the method, you pass it an expression with the actual parameter, which acts as an assignment of that expression to the formal parameter
p25028
aVImagine that the  variable is assigned  before the first call, and then it is assigned  before the second call to understand what is going on when you call
p25029
as(dp25030
g6
V335858
p25031
stp25032
a((dp25033
g2
(lp25034
VThere is no need to go for an advanced pattern: a simple list of tuples  is sufficient to satisfy your requirements
p25035
aVCreate a list of type , and add pairs of "checkers" and "makers" to it, as follows:
p25036
aVNow you can go through the checkers in a loop, and use its corresponding maker when you have a match:
p25037
as(dp25038
g6
V335858
p25039
stp25040
a((dp25041
g2
(lp25042
VYour  method does not draw anything; the code that you put in there belongs in your  implementation
p25043
aVYou should manipulate the layer configuration in the initializer; in your  you should call functions of your  based on the state of the view
p25044
aVFor example, to draw some text you would use , to draw some lines you would use , and so on
p25045
aVSee this question for information on the relationship between  and the  of your
p25046
as(dp25047
g6
V335858
p25048
stp25049
a((dp25050
g2
(lp25051
VYou move the functions out of the header into a cpp file by first creating the corresponding cpp file if it does not exist, and then copying the bodies of your functions into that file one by one, prefixing their names with the name of the class and two colons , like this:
p25052
aVfrom the header becomes
p25053
aVin the header, and
p25054
aVin the cpp file
p25055
as(dp25056
g6
V335858
p25057
stp25058
a((dp25059
g2
(lp25060
V is the name of the class
p25061
aVIf you are inside of a member function, you do not need to qualify data members with the name of the class
p25062
aVYou should also declare  before the chain of if-then-else:
p25063
aVYou would probably be better off with a  statement, or even an array of pairs for  and  values
p25064
aVIn the arrays above, when  is, say, 8, the  is , and the  is , matching the data from your  statement
p25065
as(dp25066
g6
V335858
p25067
stp25068
a((dp25069
g2
(lp25070
VTry this:
p25071
aVThe idea is to not manipulate  after you have started your process: it is useless
p25072
aVAlso you do not need to set  to , because you are starting the shell yourself by calling
p25073
as(dp25074
g6
V335858
p25075
stp25076
a((dp25077
g2
(lp25078
VFirst, your program modifies the format string: it becomes "%c\u005cn"
p25079
aVThen it prints 65, which is re-interpreted as an ASCII code, which is an upper-case
p25080
aVThis is identical to
p25081
aVor even
p25082
aVbecause  values are converted to  when passed to variadic functions such as
p25083
as(dp25084
g6
V335858
p25085
stp25086
a((dp25087
g2
(lp25088
VYou need to combine the two loops, so that both checks happen every time the end-user enters something new:
p25089
aVAfter the loop exits,  is a number between  and , inclusive
p25090
as(dp25091
g6
V335858
p25092
stp25093
a((dp25094
g2
(lp25095
VIt is the same as synchronizing on the  object implementing the method, so yes, it is possible, and yes, the mechanism effectively ignores the instance fro which the method is called:
p25096
aVis a shortcut for writing this:
p25097
as(dp25098
g6
V335858
p25099
stp25100
a((dp25101
g2
(lp25102
VThe empty char sequence is what gives you the trouble
p25103
aVYou need a rule that matches a non-empty sequence to be separate from the rule that matches both an empty and a non-empty one, like this:
p25104
as(dp25105
g6
V335858
p25106
stp25107
a((dp25108
g2
(lp25109
VThe simplest way is to do it using two shifts:
p25110
aVDemo on ideone: link
p25111
as(dp25112
g6
V335858
p25113
stp25114
a((dp25115
g2
(lp25116
VInitializing flexible array members with an aggregate is a gcc extension
p25117
aVThe good news is that since you are allocating the  statically, you do not need that member to be a flexible array: you can go for a fixed-size array instead
p25118
aVIt is very likely that somewhere in your code you have a definition of the constant that says how many items there are in the  array (otherwise, you'd need to rely on a "sentinel" value of sorts, similar to null terminator of C strings, to know where legitimate  values end)
p25119
aVIf you have that constant already, modify the definition of  to be
p25120
aVinstead of
p25121
aVWith this change in place, your code should compile correctly
p25122
aVIf you do not have a  constant, consider either adding one, or introducing a  value limiting the number of items in
p25123
aVEither way, converting the array to a non-flexible one will fix the error
p25124
as(dp25125
g6
V335858
p25126
stp25127
a((dp25128
g2
(lp25129
VJava has a more convenient class for this, called
p25130
aVYou do not need to check if the bit is set in a loop: you can make a mask, use a bitwise , and see if the result is non-empty to decide on whether to grant or deny the access:
p25131
aVWe used this class in a similar situation in my prior company, and the performance was acceptable for our purposes
p25132
as(dp25133
g6
V335858
p25134
stp25135
a((dp25136
g2
(lp25137
VThere is no such thing as "name space" for preprocessor definitions in the C standard1
p25138
aVNo matter how the  is defined2, the content of the second file will be ignored
p25139
aV1 The C99 standard, section 6
p25140
ag839
aV3, defines four name spaces - (1) for labels, (2) for struct/union/enum tags, (3) for members of each structure or union, and (4) for everything else
p25141
aVPreprocessor definitions do not belong in any of these name spaces, because "Macro names and macro parameters are not considered further here, because prior to the semantic phase of program translation any occurrences of macro names in the source file are replaced by the preprocessing token sequences that constitute their macro definitions
p25142
aV2 As far as defining  goes, you have several options: you can define it in your C file, in a header file, or pass it from the command line using the corresponding option of your C compiler
p25143
as(dp25144
g6
V335858
p25145
stp25146
a((dp25147
g2
(lp25148
VNo, it is not conceptually correct to call a lookup table a hash table: in your case a lookup table is a simple array
p25149
aVCalling something a hash table implies certain behavior in cases when the hash function is not perfect (i
p25150
ag630
aVin the presence of hash collisions); arrays have none of this behavior, so calling this a "hash lookup" would likely mislead your listeners or readers
p25151
aVIn general, any kind of associative storage, including hash tables, various trees, and so on, can be used to perform lookup operations
p25152
aVIn your case, the index of the array is associated with the value stored at that index, letting you look up the value in constant time
p25153
as(dp25154
g6
V335858
p25155
stp25156
a((dp25157
g2
(lp25158
VThe second form is slightly more readable, because it reduces the nesting level
p25159
aVThere is absolutely no performance penalty for using one form or the other
p25160
as(dp25161
g6
V335858
p25162
stp25163
a((dp25164
g2
(lp25165
VYou can use the  method, like this:
p25166
as(dp25167
g6
V335858
p25168
stp25169
a((dp25170
g2
(lp25171
VThis is not how the I/O works in C++: you cannot read from a stream and pass the result to a setter like that
p25172
aVYou need to read the street into a variable first, and then pass that var to set_street:
p25173
as(dp25174
g6
V335858
p25175
stp25176
a((dp25177
g2
(lp25178
VHere is your culprit:
p25179
aVOnce you do this,  and  refer to the same exact object, because arrays in Java are reference objects
p25180
aVAny change to 's content will be reflected in , because  and  are two different names for a single object
p25181
aVIf you need  to be a copy of , you should do it explicitly
p25182
aVHere is a link to an answer showing you how it is done
p25183
as(dp25184
g6
V335858
p25185
stp25186
a((dp25187
g2
(lp25188
VThis is because  is defined though one of the files included in the  header
p25189
aVThe streams provide support for input and output of strings, so they need to include a string header in order to define the corresponding  and  operations
p25190
as(dp25191
g6
V335858
p25192
stp25193
a((dp25194
g2
(lp25195
VYes, it is undefined behavior: passing to  anything that did not come from  is UB:
p25196
aVC++ standard, section 3
p25197
ag838
ag14884
ag839
aV3:
p25198
aVThe value of the first argument supplied to one of thea deallocation functions provided in the standard library may be a  pointer value; if so, and if the deallocation function is one supplied in the standard library, the call to the deallocation function has no effect
p25199
aVOtherwise, the value supplied to  in the standard library shall be one of the values returned by a previous invocation of either  or  in the standard library
p25200
aVThe consequences of undefined behavior are, well, undefined
p25201
aV"Nothing happens" is as valid a consequence as anything else
p25202
aVHowever, it's usually "nothing happens right away": deallocating an invalid memory block may have severe consequences in subsequent calls to the allocator
p25203
as(dp25204
g6
V335858
p25205
stp25206
a((dp25207
g2
(lp25208
VThere are two ways to go about doing this:
p25209
aVMake a shallow copy of the , and add attributes, or
p25210
aVMake a deep copy of the , and remove sub-elements
p25211
aVThe first way is less wasteful, especially when the element has lots of child nodes
p25212
aVHere is the first way:
p25213
aVHere is the second way:
p25214
as(dp25215
g6
V335858
p25216
stp25217
a((dp25218
g2
(lp25219
VThe  operator in Java checks if the two objects are the same, not that they are equal
p25220
aVTwo strings may have identical content, and compare negatively for equality
p25221
aVYou need to use  instead:
p25222
aVIf  values are allowed among the  elements, you need to add a  check to your condition to avoid an exception:
p25223
as(dp25224
g6
V335858
p25225
stp25226
a((dp25227
g2
(lp25228
VThe number  corresponds to
p25229
aVWhen  interprets it as ASCII, it ignores all bits beyond the last eight bits containing , which is the code for
p25230
aVFrom the C99 standard:
p25231
ag838
aV19
p25232
ag1340
ag837
aV8 -- : If no  length modifier is present, the int argument is converted to an , and the resulting character is written
p25233
as(dp25234
g6
V335858
p25235
stp25236
a((dp25237
g2
(lp25238
VAn equivalent operation to "remove everything but X" is "keep X"
p25239
aVThe simplest way to do it is constructing a new list with a single element at index , like this:
p25240
as(dp25241
g6
V335858
p25242
stp25243
a((dp25244
g2
(lp25245
VAssuming that the client knows exactly what type of the field it gets, you can change the property definition into a function to use generics, like this:
p25246
aVThe users must call this method like this:
p25247
aVHowever, the cast is still there, and it is not clear how the users are expected to know what type to supply as the generic type parameter
p25248
aVA better approach would be to use some sort of a double dispatch mechanism, for example, the visitor pattern, to "invert" the direction and let your field "push" the value into the caller
p25249
aVNow you can create instances of  interface, and pass them to  objects
p25250
aVThe visitors will receive callbacks with specific values without knowing the type of the  objects being visited
p25251
as(dp25252
g6
V335858
p25253
stp25254
a((dp25255
g2
(lp25256
VOne place to do it is in your  code: give your data source access to your , letting it access the value of its  property
p25257
aVThere, your  would be able to find out the appropriate number of rows by looking at the index and subtracting the count of inapplicable rows, and  would be able to re-index the rows based on the current selection
p25258
aVYou may need to keep additional data structures in the model in order to support the  method
p25259
aVSpecifically, you may want to add arrays for the three "special" days, so that the search for "what's row number three if Fridays is selected" does not need to loop through all the data in search of the third applicable row
p25260
as(dp25261
g6
V335858
p25262
stp25263
a((dp25264
g2
(lp25265
VMake a copy of the original vector, then walk the two vectors in search of matching items, and erase from the parallel vector when you do not find a match:
p25266
as(dp25267
g6
V335858
p25268
stp25269
a((dp25270
g2
(lp25271
VOne quick way to fix your program is to declare  as an array of pointers, like this:
p25272
aVWhen you read names in, use  for your buffer, and store the pointer into , like this:
p25273
aVNow sorting the  should work fine
p25274
aVThis has a limitation of being limited to 20 lines of 20 characters max
p25275
aVIf you learned about  in the class, you should be able to fix that by allocating your strings and the string array dynamically
p25276
as(dp25277
g6
V335858
p25278
stp25279
a((dp25280
g2
(lp25281
VYou cannot make
p25282
aVNET's list one-based, but you can either (1) adjust your index down by one every time you read, or (2) insert a useless entry at position  and ignore it after that (not recommended)
p25283
aVYou can inherit from list, and build your own data structure that adjusts indexes on the way in and out, but that would require a lot more effort, not to mention the amount of confusion among the readers, so I would strongly caution against doing that
p25284
as(dp25285
g6
V335858
p25286
stp25287
a((dp25288
g2
(lp25289
VThe use of  in this context is very appropriate
p25290
aVTo retrieve the values for a given key, you can use  looking for the key by name, followed by  looking for a blank line
p25291
as(dp25292
g6
V335858
p25293
stp25294
a((dp25295
g2
(lp25296
VThere are several reasons:
p25297
aVNot all addresses are created equal; In particular, in non Von Neuman (e
p25298
ag303
aVHarvard) architectures pointers to code memory (where you often store constants) and a pointers to data memory are different
p25299
aVYou need to know the underlying type in order to perform your accesses correctly
p25300
aVFor example, reading or writing a  is different from reading or writing a
p25301
aVYou need additional information to perform pointer arithmetic
p25302
aVNote that there is a pointer type that means "simply a pointer" in C, called
p25303
aVYou can use this pointer to transfer an address in memory, but you need to cast it to something useful in order to perform operations in the memory pointed to by
p25304
as(dp25305
g6
V335858
p25306
stp25307
a((dp25308
g2
(lp25309
VWrap the management of connection strings in a class, make that class a singleton, and use it to obtain the active connection string, like this:
p25310
as(dp25311
g6
V335858
p25312
stp25313
a((dp25314
g2
(lp25315
VThis is not a linker error, it is a compiler error
p25316
aVThe compiler is telling you that it does not know how to call function , because it lacks its definition or declaration
p25317
aVDeclaring a function as a friend is no substitute for a proper declaration
p25318
aVWhen you say  is a friend, you do not also introduce  into a scope
p25319
aVIn a sense, friendship declaration is a private detail of your class invisible from the outside
p25320
aVIn order to use a function in C++ you need to declare it first
p25321
aVThis is usually done through a header file corresponding to the implementation file, but you can do it simply like this:
p25322
aVvoid foo();
p25323
aVIf  is defined in the same file as , you can move  ahead of the  to fix the problem (seeing a function definition prior to first use is OK with the compiler)
p25324
as(dp25325
g6
V335858
p25326
stp25327
a((dp25328
g2
(lp25329
VYou cannot give it a class of , because there is no such class: the type of  is removed by the compiler during the process known as type erasure, leaving you with pure
p25330
as(dp25331
g6
V335858
p25332
stp25333
a((dp25334
g2
(lp25335
VSending an object the  message retrieves that object's dynamic type
p25336
aVThe object must be assigned prior to querying it for its
p25337
aVIn other words, declaring a property as  is not sufficient for its  to return : you must also assign it an instance of  or one of its subclasses
p25338
aVIn the later case, the result of sending  message will be different (i
p25339
ag630
aVthe  of the subclass will be returned)
p25340
as(dp25341
g6
V335858
p25342
stp25343
a((dp25344
g2
(lp25345
VOnce you fix your compile issue, you'll discover that your "coin" is not fair: it gives you "tails" a lot more often than "heads"
p25346
aVIn fact, you'd rarely get any "heads" at all
p25347
aVThis is because  gives you a  between  and , not an  of  and
p25348
aVTherefore you need to change your condition as follows:
p25349
as(dp25350
g6
V335858
p25351
stp25352
a((dp25353
g2
(lp25354
VYes, C# is converted to a stack-oriented programming language -- IL
p25355
aVWhen the compiler converts an expression to the internal language, it makes a list of operations that follow RPN
p25356
aVFor example, this method
p25357
aVgets converted to this internal language (see comments for explanation of what is going on):
p25358
aVAs you can see, the operands are pushed onto stack in the order that makes it convenient to perform operations by working from the back of the expression to its front - exactly the way the article explains it
p25359
aVThe exact algorithm of the conversion is compiler-dependent (strictly speaking, the end result is compiler-dependent as well, because there are multiple ways to convert an expression to a valid RPN sequence) but the basic idea of RPN is there
p25360
as(dp25361
g6
V335858
p25362
stp25363
a((dp25364
g2
(lp25365
VTry this expression:
p25366
aVThe groups matched by it will exclude the quotation marks, because they are enclosed in non-capturing parentheses  and
p25367
aVOf course you need to escape the double-quotes for use in C# code
p25368
aVIf the target string starts and/or ends in a quoted value, this expression will match empty groups as well (for the initial and for the trailing quote)
p25369
as(dp25370
g6
V335858
p25371
stp25372
a((dp25373
g2
(lp25374
VThat's easy: use  to get the mod of the number, and  for the integer division (i
p25375
ag630
aVdivision where the fractional part is discarded)
p25376
aVYour numbers are in the decimal system (i
p25377
ag630
aVthe base is ) so you divide and mod by 10, like this:
p25378
aVTo print a number digit-by-digit, least significant digit first, you can use this loop:
p25379
as(dp25380
g6
V335858
p25381
stp25382
a((dp25383
g2
(lp25384
VThe compiler is right:  is not a type that could possibly have methods, because it is not an -derived type
p25385
aVIf you have a method that takes  as parameter, you pass it after the colon , not as the receiver of the method
p25386
as(dp25387
g6
V335858
p25388
stp25389
a((dp25390
g2
(lp25391
VIf you know a limit upfront, and the limit is low, you can use nested loops
p25392
aVFor example, for thee-character strings use three nested loops, like this:
p25393
aVIf you do not know the length upfront, you need to use recursion
p25394
aVThe idea is to implement one loop in each level of recursive invocation, terminating when you are at the desired depth
p25395
as(dp25396
g6
V335858
p25397
stp25398
a((dp25399
g2
(lp25400
V expects your less-than operator to supply a transitive relationship, i
p25401
ag630
aVwhen the sort sees  is true and  is true, it implies that  is true as well
p25402
aVIn your implementation, the transitivity rule does not hold: when two items are equal, you randomly tell the sort that one of them is greater than the other
p25403
aVThis triggers the debug assertion
p25404
aVReturn false for equal values to fix this
p25405
as(dp25406
g6
V335858
p25407
stp25408
a((dp25409
g2
(lp25410
VDo not do this: storing multiple values in the single column kills the possibility of using referential integrity constraints, and turns into a nightmare to maintain (imagine maintaining everyone's lists when a new baby's born
p25411
aVThe simplest solution is to add a column with a  to each person's row
p25412
aVAll members of the same family will have this unique ID set to the same value; members of different families will have different s
p25413
aVThis is not ideal in cases of marriages, unless you are willing to either join the two families on marriage of their children, or move the bride or the groom to the family of the spouse
p25414
as(dp25415
g6
V335858
p25416
stp25417
a((dp25418
g2
(lp25419
VSearching for the lowest common ancestor in a binary search tree is simpler than that: observe that the LCA is the node where the searches for item A and item B diverge for the first time
p25420
aVStart from the root, and search for A and B at the same time
p25421
aVAs long as both searches take you in the same direction, continue the search
p25422
aVOnce you arrive at the node such that searching for A and B take you to different subtrees, you know that the current node is the LCA
p25423
as(dp25424
g6
V335858
p25425
stp25426
a((dp25427
g2
(lp25428
VThis is because the  member is an instance member, not a class (i
p25429
ag630
aVnot a static) member
p25430
aVYou should either (1) make an instance of  available at the point where you need to access , or (2) make  a static member
p25431
aVIf you decide on the first way, consider making  a singleton; if you decide on the second way, do not forget to define your  array in a cpp file, in addition to declaring it  in the header file
p25432
as(dp25433
g6
V335858
p25434
stp25435
a((dp25436
g2
(lp25437
VThe first way with casting  to  right away is not going to work, because the number  that you are trying to cast does not fit in 32 bits
p25438
aVYou need to stay in 64 bits as long as you can
p25439
aVThe trick to avoiding floating-point arithmetics is to multiply by  first, and then do the division
p25440
aVAs long as the number times  is within the allowed size (and in your case, it is) the result has a good precision:
p25441
aVDemo on ideone (prints 64)
p25442
as(dp25443
g6
V335858
p25444
stp25445
a((dp25446
g2
(lp25447
VAssigning just  will not assign zero to the
p25448
aVYou can initialize both characters in the array with a string literal in a single line, like this:
p25449
aVThis will put  into , and a terminating zero into
p25450
as(dp25451
g6
V335858
p25452
stp25453
a((dp25454
g2
(lp25455
VThere is no universal "better practice" when it comes to memory management, so you should do what's right for your particular design
p25456
aVIf you always allocate precisely 16 floats, embedding the array inside your class will reduce the number of calls to the dynamic allocator
p25457
aVThis may be helpful when the object is stored in the automatic memory, but there are situations when it may harm
p25458
aVFor example, if you create large arrays of this class in automatic storage, embedding the array would increase the chances of overflowing the stack
p25459
aVThe best approach is to profile your memory use and your timing, and see if allocating these arrays results in significant slow-downs, or contributes significantly to memory fragmentation
p25460
aVIf the current scheme does not give you any trouble, there is no reason to replace it
p25461
as(dp25462
g6
V335858
p25463
stp25464
a((dp25465
g2
(lp25466
VJava keywords are all lowercase
p25467
aVYou should use  instead of
p25468
as(dp25469
g6
V335858
p25470
stp25471
a((dp25472
g2
(lp25473
VYou need more question marks - six more, to be precise
p25474
aVJDBC interprets each question mark as a placeholder for a parameter, i
p25475
ag630
aVa promise by your program to supply a value after preparing the statement
p25476
aVWhen you call , , , etc
p25477
aVon your prepared statement, a corresponding numbered placeholder must exist
p25478
aVOtherwise,  is thrown
p25479
as(dp25480
g6
V335858
p25481
stp25482
a((dp25483
g2
(lp25484
VYou are almost there
p25485
aVMove the  block outside the  loop
p25486
aVOtherwise, it "continues" the inner-most loop, rather than the one you intended
p25487
aVAlternatively, you could enclose the  call in , because it's the only statement following the :
p25488
aVYour program on ideone: link
p25489
as(dp25490
g6
V335858
p25491
stp25492
a((dp25493
g2
(lp25494
VThe closest fit for what you are looking for is the
p25495
aVYou can use it as-is, or derive your own  exception from it
p25496
as(dp25497
g6
V335858
p25498
stp25499
a((dp25500
g2
(lp25501
VThe only difference between the two looping constructs is the ability to do pre-loop initialization and post-loop changes in the header of the  loop
p25502
aVThere is no performance difference between
p25503
aVand
p25504
aVconstructs
p25505
aVThe alternative is added for convenience and readability, there are no other implications
p25506
as(dp25507
g6
V335858
p25508
stp25509
a((dp25510
g2
(lp25511
VThe  preprocessor construct does not define a variable, it defines a constant
p25512
aVIt is not possible to change the value of , because it does not exist by the time the Objective C compiler starts looking at your code: it's replaced by  by then
p25513
aVWhat you are looking for is a global variable
p25514
aVDeclare it in the header like this
p25515
aVand then define it in a  file like this:
p25516
aVNow you have an assignable variable that you can change freely from any method that sees the declaration
p25517
as(dp25518
g6
V335858
p25519
stp25520
a((dp25521
g2
(lp25522
VJava methods are not first-class objects (or second or third-class objects; in fact, methods are not objects at all)
p25523
aVYou need to move the method into one of the classes - either your top class, or the anonymous inner class that you defined, like this:
p25524
as(dp25525
g6
V335858
p25526
stp25527
a((dp25528
g2
(lp25529
VThe two statement are executed by two different stages of the compiler:
p25530
aVis executed by the preprocessor
p25531
aVIt removes or leaves intact its guarded portion of code
p25532
aVThis is done at compile time, therefore the condition must be a compile-time constant
p25533
aVIf a part of the code is excluded by , the corresponding code does not go into the compiled executable
p25534
aVis processed by the compiler, and gets converted into executable code
p25535
aVIts expression can be computed at run-time
p25536
aVBoth sides of the expression remain in the compiled executable*
p25537
aV* Unless an optimizer detects that one part can be removed; this is not common
p25538
as(dp25539
g6
V335858
p25540
stp25541
a((dp25542
g2
(lp25543
VIt looks like you have forgotten to add  as a subview of its parent view:
p25544
aVAlso  is not the right place to create subviews
p25545
aVYou should expose  as a property of your view, and then access it from , like this:
p25546
as(dp25547
g6
V335858
p25548
stp25549
a((dp25550
g2
(lp25551
VYou should add  to the declaration in order to be able to modify a variable from inside the block:
p25552
as(dp25553
g6
V335858
p25554
stp25555
a((dp25556
g2
(lp25557
V has precedence over , so the condition is interpreted as
p25558
aVAll three records match this condition:
p25559
aVIf you are looking for a different order of evaluation, you can force it using parentheses
p25560
as(dp25561
g6
V335858
p25562
stp25563
a((dp25564
g2
(lp25565
VThere is no check for the value equality, only for the key equality
p25566
aVThe object will be replaced by its equal if the key that you specified matches a key that is already in the map
p25567
aVIf a value has been associated with the key previously, that value will be returned by the  method
p25568
aVHere is a snippet from the source of :
p25569
as(dp25570
g6
V335858
p25571
stp25572
a((dp25573
g2
(lp25574
VThere are two cases when you should throw an exception:
p25575
aVWhen you detect an error caused by incorrect use of your class (i
p25576
ag630
aVa programming error) throw an instance of unchecked exception, i
p25577
ag630
aVa subclass of
p25578
aVWhen you detect an error that is caused by something other than a programming error (invalid data, missing network connectivity, and so on) throw an instance of  that does not subclass
p25579
aVYou should catch exceptions of the second kind, and not of the first kind
p25580
aVMoreover, you should catch exceptions if your program has a course of action to correct the exceptional situation; for example, if you detect a loss of connectivity, your program could offer the user to re-connect to the network and retry the operation
p25581
aVIn situations when your code cannot adequately deal with the exception, let it propagate to a layer that could deal with it
p25582
as(dp25583
g6
V335858
p25584
stp25585
a((dp25586
g2
(lp25587
VThat is relatively straightforward:
p25588
as(dp25589
g6
V335858
p25590
stp25591
a((dp25592
g2
(lp25593
VYou should make a list from hashmap keys first:
p25594
aVThen you can shuffle the key list using the method in the  the way your post shows
p25595
aVThe last call of your loop makes no sense, however:
p25596
aVEven if you re-shuffle the keys fifty times, this would add the same map entries to another map fifty times over, resulting in the map with which you have started, because hash maps are unordered
p25597
as(dp25598
g6
V335858
p25599
stp25600
a((dp25601
g2
(lp25602
VThe memory that has been allocated to the temporary  is now invalid, but it has not been put to any other use
p25603
aVThat is why your read produces the value that was there the last time
p25604
aVHowever, this is undefined behavior
p25605
aVRunning valgrind should pinpoint the place of the error
p25606
aVIf you are wondering "how can it be", here is a great answer explaining what happens in a very similar situation
p25607
as(dp25608
g6
V335858
p25609
stp25610
a((dp25611
g2
(lp25612
VThe first API is better, because returning a reference rather than a pointer indicates that the object will exist (i
p25613
ag630
aVno need to test for )
p25614
aVBoth ways let you return polymorphic objects (i
p25615
ag630
aVa subclass of ), so there is no difference there
p25616
aVYou should prefer returning a reference when you can
p25617
as(dp25618
g6
V335858
p25619
stp25620
a((dp25621
g2
(lp25622
VThe way you defined your objects leaves  as your only option: the two anonymous classes are of different type
p25623
aVYou should either write
p25624
aVor initialize your list with instances of a named class (this is preferred, because  may be too heavy in your situation)
p25625
as(dp25626
g6
V335858
p25627
stp25628
a((dp25629
g2
(lp25630
VYour check misses negative values: if the size is  and the index is , the result of the integer division is zero, but the index is clearly out of range
p25631
aVYou can fix this issue by making the  parameter unsigned
p25632
aVThe type of  should be  as well
p25633
as(dp25634
g6
V335858
p25635
stp25636
a((dp25637
g2
(lp25638
VRather than running an insertion sort, you could use binary search to find the insertion point, and then insert the value there
p25639
aVBut this is slow, because you may need to shift a lot of data many times (think what happens if the random data comes in sorted in reverse of what you need, the timing would be )
p25640
aVThe fastest approach is to insert first, and then sort everything at once
p25641
aVIf this is not possible, consider replacing your array with a self-balancing ordered tree structure, such as an RB-Tree
p25642
as(dp25643
g6
V335858
p25644
stp25645
a((dp25646
g2
(lp25647
VTry using a  statement instead of an , and add some counting logic:
p25648
aVThere is a K&R; chapter that goes through this exercise in details, see section 1
p25649
ag10442
aV4 Word Counting
p25650
as(dp25651
g6
V335858
p25652
stp25653
a((dp25654
g2
(lp25655
VThe answer is usually in the  section that you have commented out: when there is nothing there, the code makes no sense
p25656
aVHowever, a typical thing to have in that spot is some sort of notification of your own delegate, like this:
p25657
aVThis should not be called unless the  has indeed changed
p25658
aVThe call may be costly, anywhere from "expensive" to "very expensive", depending on what the delegate really does
p25659
aVIt could be updating a screen with the images from the new library, or it could be saving new images into the cloud
p25660
aVIf there is no need to report the change, you could be wasting the CPU cycles, along with the battery and the network bandwidth
p25661
aVYour code has no way of knowing what the delegate is going to do, so you need to avoid calling back unless the change did happen
p25662
as(dp25663
g6
V335858
p25664
stp25665
a((dp25666
g2
(lp25667
Visn't that Overloading
p25668
aVNo, there is no overloading in C
p25669
aVIt is called a "variadic function"
p25670
aVAnd no, despite its appearance in C++ and absence from C, method overloading is not an object-oriented concept
p25671
aVIt is featured prominently in rather old programming languages, such as Prolog, that are not object-oriented
p25672
as(dp25673
g6
V335858
p25674
stp25675
a((dp25676
g2
(lp25677
VIt seems the best thing to do would be to set the vector size to 0, so that the complexity is constant
p25678
aVIn general, the complexity of resizing a vector to zero is linear in the number of elements currently stored in the
p25679
aVTherefore, setting 's size to zero offers no advantage over calling  - the two are essentially the same
p25680
aVHowever, at least one implementation (libstdc++, source in ) gives you an O(1) complexity for primitive types by employing partial template specialization
p25681
aVThe implementation of  navigates its way to the  function in , which performs a non-trivial compile-time optimization: it declares an auxiliary template class  with the template parameter of type
p25682
aVThe class has a partial specialization for  and an explicit specialization for
p25683
aVBoth specializations define a single static function called
p25684
aVIn case the template parameter is , the function body is empty; in case the parameter is , the body contains a loop invoking 's destructor by calling
p25685
aVThe trick comes on line 126:
p25686
aVThe auxiliary class is instantiated based on the result of the  check
p25687
aVThe checker returns  for built-in types, and  for types with non-trivial destructor
p25688
aVAs the result, the call to  becomes a no-op for , , and other POD types
p25689
aVThe  is different from the  in that it may need to delete structures that represent "hash buckets" of POD objects, as opposed to deleting objects themselves*
p25690
aVThe optimization of  to  is possible, but it is heavily dependent on the implementation, so I would not count on it
p25691
aV* The exact answer depends on the implementation: hash tables implementing collision resolution based on open addressing (linear probing, quadratic probing, etc
p25692
aVmay be able to delete all buckets in ; implementations based on separate chaining would have to delete buckets one-by-one, though
p25693
as(dp25694
g6
V335858
p25695
stp25696
a((dp25697
g2
(lp25698
VOne problem with using chained references, such as , is that higher-order dependencies get "baked into" the structure of code outside the class
p25699
aVIdeally, in cases when you refactor your class, your "forced changes" should be limited to the methods of the class being refactored
p25700
aVWhen you have multiple chained references in the client code, refactoring drives you to make changes in other places of your code
p25701
aVConsider an example: suppose that you'd like to replace  with an , an abstraction encapsulating users, companies, and electronic agents that can place an order
p25702
aVThis refactoring immediately presents multiple problems:
p25703
aVThe  property will be called something else, and it will have a different type
p25704
aVThe new property may not have an  that has  in cases when the order is placed by an electronic agent
p25705
aVThe human  associated with the order (suppose that your system needs one for legal reasons) may be related to the order indirectly, - for example, by being a designated go-to person in the definition of the
p25706
aVA solution to these problems would be to pass the order presentation logic everything that it needs directly, rather than having it "understand" the structure of the objects passed in
p25707
aVThis way you would be able to localize the changes to the code being refactored, without spreading the changes to other code that is potentially stable
p25708
as(dp25709
g6
V335858
p25710
stp25711
a((dp25712
g2
(lp25713
V is unsigned
p25714
aVThe negative  that you assigned to it gets re-interpreted as a positive 32-bit number
p25715
aVWhen you add it to , the value gets extended with 32 zeros to match the size of the other operand
p25716
aVThis is not what you wanted: since the number was negative, you need all ones in the upper half in order for the addition to produce the desired effect after the result of the addition is reduced modulo the number that is one greater than the largest value that can be represented by *
p25717
aVIf you declare the  as , the first and the second parts produce the expected number (demo on ideone)
p25718
aV* 6
p25719
ag839
aV5 (9) "A computation involving unsigned operands can never over\ufb02ow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type
p25720
aVThanks, Daniel Fischer for finding the relevant portion of the standard
p25721
as(dp25722
g6
V335858
p25723
stp25724
a((dp25725
g2
(lp25726
V executes your query against the backing data store (in this case, it's SQL RDBMS)
p25727
aVYour SQL RDBMS has no idea of *, and cannot use its implementation: the query function must be translatable to SQL, and  is not translatable
p25728
aVYou can convert  to  and do the query in memory, but that would be too inefficient
p25729
aVYou should change the signature to take a  predicate, and pass the name checker to it:
p25730
aVYou can now use this method as follows:
p25731
aV* Additionally, your  is not used in the method that you are showing: the  method would qualify as an implementation of , but it is not mentioned in the list of interfaces implemented by your  class
p25732
as(dp25733
g6
V335858
p25734
stp25735
a((dp25736
g2
(lp25737
VLike this:
p25738
as(dp25739
g6
V335858
p25740
stp25741
a((dp25742
g2
(lp25743
VYour sorting function is fine
p25744
aVThe only problem is that you enter elements at positions  through , inclusive, while you should use  through , inclusive, in both loops of the  function
p25745
aVIf you need to print numbers  through , use
p25746
as(dp25747
g6
V335858
p25748
stp25749
a((dp25750
g2
(lp25751
VI get a build error having to do with linking
p25752
aVLet me guess: your other file contains a  function
p25753
aVA project is not allowed to have multiple  functions (in fact, all non-static functions must have unique names)
p25754
aVThe  does not need to be in the  file, but there needs to be exactly one
p25755
aVOne solution is to rename the functions in other files except the one that you want to run to something else (, , and so on)
p25756
aVThis will stop the linker from complaining
p25757
aVHowever, this approach is error-prone
p25758
aVThe standard approach is to use multiple projects - one for each program that you write
p25759
aVYou can keep them in the same Xcode workspace for convenience, but each one should have a separate target and its own  file
p25760
as(dp25761
g6
V335858
p25762
stp25763
a((dp25764
g2
(lp25765
Vis causing the error
p25766
aVThis is expected: the projection is executed on the RDBMS side; your SQL database has no idea what's
p25767
aVThis member should be added when you are in memory, i
p25768
ag630
aVafter :
p25769
as(dp25770
g6
V335858
p25771
stp25772
a((dp25773
g2
(lp25774
VThe most likely reason for the  to remain internal is that it is not easy to define what constitutes a "structure" of a class:
p25775
aVDoes it include properties and fields, or just properties
p25776
aVDoes it include only public members, or the private members are included too
p25777
aVIs there a way to exclude a member from the structure for the purpose of comparing or making hash code
p25778
aVThe answers to these questions can change from one application to another, so hiding the class from outsiders was a wise decision
p25779
aVHowever, you know all these answers for your application, so you can build one of these  classes with relative ease
p25780
aVRecall that  lets you create compiled expressions at run-time
p25781
aVAll you need to do is to build a pair of expressions for each of your types, and plug them into your implementation of the structural comparer
p25782
aVIf you need to learn how to create expression trees and compile them into executable delegates  see this link
p25783
as(dp25784
g6
V335858
p25785
stp25786
a((dp25787
g2
(lp25788
VI am trying to find over the web how to write this for loop for extended objects, e
p25789
ag303
aVsomething like this
p25790
aVNo, this is not possible: you cannot statically type items supplied dynamically at run-time
p25791
aVHow is the correct way to write it
p25792
aVYou are already doing it:
p25793
aVIf you would like to test for  inside that loop, you can do it, but usually it tells that your design can be improved
p25794
aVA better alternative is to use a mechanism of double dispatch, such as the Visitor Pattern, to hide the details of special treatment for your subclasses
p25795
as(dp25796
g6
V335858
p25797
stp25798
a((dp25799
g2
(lp25800
VNo, you should not use
p25801
aVOnly headers should be included; code files should be compiled separately from one another
p25802
aVHow exactly it is done depends on your compiler, but usually you simply list the files to the compiler one by one, like this:
p25803
as(dp25804
g6
V335858
p25805
stp25806
a((dp25807
g2
(lp25808
VI don't know if it is possible to pass a variable among different processes
p25809
aVNo, it is not possible, at least not in the classical sense of passing a variable
p25810
aVYou have many options, though: inter-process communication can be done through shared memory (sometimes implemented through memory-mapped files), named pipes, etc
p25811
as(dp25812
g6
V335858
p25813
stp25814
a((dp25815
g2
(lp25816
VYour  is padded by four bytes, presumably to place  on the 8-byte boundary to speed up access to it
p25817
aVThis is platform-dependent: not all compilers will add these bytes
p25818
as(dp25819
g6
V335858
p25820
stp25821
a((dp25822
g2
(lp25823
V does not "see" the format specifier because you are passing a pointer to  plus one
p25824
aVThis is equivalent to passing  by itself:
p25825
aVwill print  and ignore
p25826
aVThis is not specific to , pointer arithmetic works like that with all  pointers, including pointers obtained from string literals (i
p25827
ag630
aVdouble-quoted sequences of characters)
p25828
as(dp25829
g6
V335858
p25830
stp25831
a((dp25832
g2
(lp25833
VYou should use 's  method to determine if the input is numeric before calling :
p25834
as(dp25835
g6
V335858
p25836
stp25837
a((dp25838
g2
(lp25839
VIt would print , unlike
p25840
aVwhich would print nothing
p25841
aVThis is the way the comma operator in C works -- it evaluates its operands one by one, and produces the result of the last one as its overall result
p25842
as(dp25843
g6
V335858
p25844
stp25845
a((dp25846
g2
(lp25847
VYou cannot compare  objects using the  or  operators: it compares pointers, giving you arbitrary results
p25848
aVUse the  method instead:
p25849
aVmeans that the receiver is less than the argument
p25850
aVmeans that the receiver is greater than the argument
p25851
aVmeans that the receiver is equal to the argument
p25852
as(dp25853
g6
V335858
p25854
stp25855
a((dp25856
g2
(lp25857
VBoth constructs1 create autoreleased strings
p25858
aVYou need to  them (explicitly or by assigning to a retained property), otherwise you will end up with dangling references once the autorelease is called2
p25859
aVOnce you call a  on an object, releasing it becomes your responsibility
p25860
aVA more robust approach with s is to use  properties, rather than retaining them
p25861
aVDoing so lets you avoid issues when a  passed into your  method gets mutated after you have validated its content
p25862
aV1 I am assuming that you are asking about pre-ARC version of Objective C tools; otherwise, you will not be able to call  or  explicitly
p25863
aV2 This usually happens some time after you exit from the method, and the control passes back to the run loop
p25864
as(dp25865
g6
V335858
p25866
stp25867
a((dp25868
g2
(lp25869
VHow about
p25870
as(dp25871
g6
V335858
p25872
stp25873
a((dp25874
g2
(lp25875
VI suspect that the problem is with your property being "copy" rather than "strong"; when you set it, mutanle dictionsry gets copied into an immutable one
p25876
aVTry changing your property to "strong"
p25877
as(dp25878
g6
V335858
p25879
stp25880
a((dp25881
g2
(lp25882
VYour interface declaration specifies that all implementations of the interface will provide a generic method with this signature:
p25883
aVIn other words, the caller would be able to pass an object of any type, and get back an object of the same exact type
p25884
aVYou implementation declaration, on the other hand, limits the user to a single type, i
p25885
ag630
aVthe
p25886
aVThat's why the compiler is complaining about inability to override
p25887
aVThe trick would work if the interface were generic, and a type implementing it was implementing a generic instance, like this:
p25888
as(dp25889
g6
V335858
p25890
stp25891
a((dp25892
g2
(lp25893
VYou can use the  method to add all elements of an  to a list:
p25894
as(dp25895
g6
V335858
p25896
stp25897
a((dp25898
g2
(lp25899
VBut that makes the compiler cry out loud
p25900
aVThat is because  returns
p25901
aVCast it to  to fix the problem:
p25902
aVYou could also use
p25903
as(dp25904
g6
V335858
p25905
stp25906
a((dp25907
g2
(lp25908
VThe piece of code below
p25909
aVdeclares a variable  of type  with no tag
p25910
aVThis is OK for a static struct that you plan to use in a single compilation unit, but if you plan to share a  among several
p25911
aVc files, you should not do it like that
p25912
aVInstead, you should define a tag for your  or make a  for it, and declare the variable of that type separately, using the  syntax
p25913
aVHere is an example:
p25914
aVPut this  declaration in the header:
p25915
aVPut this variable declaration in the
p25916
aVc file:
p25917
aVNow  is no longer global: you can access it inside your
p25918
aVc file, but it is not visible from the outside
p25919
aVIf you want to make it global, but avoid linker errors, add
p25920
aVto the header, and remove  from the declaration in the
p25921
aVc file
p25922
as(dp25923
g6
V335858
p25924
stp25925
a((dp25926
g2
(lp25927
VUnlike C++ where calls of virtuals in the constructor are restricted to the definition within the class itself, the overrides are fully honored in C#'s constructors
p25928
aVThe practice is frowned upon, and for a good reason (link), but it is still allowed: 's constructor calls the override supplied by , producing the output that you see
p25929
aVThis is the normal behavior of overriden virtual functions
p25930
as(dp25931
g6
V335858
p25932
stp25933
a((dp25934
g2
(lp25935
VYes, you can simply skip the  in the first  to achieve the fall-through effect:
p25936
aVMany programmers get into the trap of fall-through inadvertently by forgetting to insert the
p25937
aVThis caused me some headaches in the past, especially in situations when I did not have access to a debugger
p25938
as(dp25939
g6
V335858
p25940
stp25941
a((dp25942
g2
(lp25943
VWhen you specify an object in the  block, that object is used like a lock for that block: only one  block can use a lock object at any time
p25944
aVWhen you use two different objects as locks, they become two different locks: two threads can lock them both at the same time - one thread per lock
p25945
aVThis explains the inconsistent results: two threads can grab two separate locks concurrently, and modify the  concurrently, resulting in incorrect calculations
p25946
aVYou should use a single lock to protect a single resource from concurrent access
p25947
aVThis is what happens when you use ; the same would happen if you used  or  in both  blocks, except in this case a user of your object would not be able to cause your methods to block forever by synchronizing on your object, and intentionally not releasing the lock
p25948
as(dp25949
g6
V335858
p25950
stp25951
a((dp25952
g2
(lp25953
VI would avoid mixing bit operations and arithmetic operations in the same expression, so I would write
p25954
aVbut
p25955
aVReadability is the only thing to worry about here, because a good optimizer should produce the same exact code for both expressions
p25956
as(dp25957
g6
V335858
p25958
stp25959
a((dp25960
g2
(lp25961
VA general scenario is when you must pass a delayed calculation to your method
p25962
aVThis is useful when calculating something is expensive, for example, when you cache something
p25963
aVNow you can call this method as follows:
p25964
as(dp25965
g6
V335858
p25966
stp25967
a((dp25968
g2
(lp25969
VThis line
p25970
aVis a valid (partial) declaration, but it is not a valid assignment
p25971
aVIt should be
p25972
as(dp25973
g6
V335858
p25974
stp25975
a((dp25976
g2
(lp25977
VYour implementation uses  with a capital  instead of a lowercase one in the interface
p25978
aVThe method should be called
p25979
as(dp25980
g6
V335858
p25981
stp25982
a((dp25983
g2
(lp25984
VI am assuming that you are opting for a universal executable, so conditional compilation is not an option for you
p25985
aVWhen you make a universal executable, you should check the features that you are relying upon before making calls dependent on the device type
p25986
aVIn this particular case you are relying upon the screen having a particular size
p25987
aVInstead of hard-coding the "magic numbers" (42, 15, 440, and 60) you should calculate them from the current size of the available screen:
p25988
aVThere is a chance that calculating actual sizes from the screen size is not possible, because you do not want your view to scale proportionally to the screen
p25989
aVIn cases like that you can check the values of  and , detect the device size, and use the corresponding set of pre-defined sizes to init your view
p25990
as(dp25991
g6
V335858
p25992
stp25993
a((dp25994
g2
(lp25995
VThis is entirely up to you: if readers of your code, including yourself, prefer a more verbose style, by all means keep it: hard-to-read clever code is much more expensive in programmer's time than in CPU time
p25996
aVAfter all, it's only ReSharper's hint: paying attention or disregarding it is entirely up to you
p25997
aVReading LINQ code would become easier with time (I know it did become much easier for me, but it took considerable amount of writing LINQ code and looking at LINQ code written by other team members)
p25998
aVOne thing that we found particularly useful was commenting: a LINQ expression can fit a surprising amount of information in a short line of code, so spelling out the intent  in plain English helps figuring out the meaning once I stumble upon a line that I wrote a few months ago
p25999
as(dp26000
g6
V335858
p26001
stp26002
a((dp26003
g2
(lp26004
VI think the problem is the space after : you do not need the tenth number, but your code is asking for it anyway, because it waits to get a space after the ninth number
p26005
aVSeparately, your printing code can be optimized a little by dropping the :
p26006
as(dp26007
g6
V335858
p26008
stp26009
a((dp26010
g2
(lp26011
VThere is no operator , so you need to overload the  operator twice: once on the matrix, returning a surrogate object for the row, and once for the returned surrogate row:
p26012
as(dp26013
g6
V335858
p26014
stp26015
a((dp26016
g2
(lp26017
VThe function typically used to tokenize strings is , but it is not thread-safe; its modern version is  should be used instead
p26018
aVStart tokenizing the  in the first call, check the first token, and then go into one of several loops that depend on the content of the first token:
p26019
as(dp26020
g6
V335858
p26021
stp26022
a((dp26023
g2
(lp26024
VThe  function works on a single character, not on a string
p26025
aVIf you need to convert the whole string to upper case, you need to use a loop:
p26026
aVHowever, your  buffer does not have a sufficient length: it must have 2 characters to fit the null terminator:
p26027
aVMoreover, since you know that  is a single character, you can use
p26028
as(dp26029
g6
V335858
p26030
stp26031
a((dp26032
g2
(lp26033
VYour code is correct - it compiles and runs fine on ideone (link)
p26034
aVThe problem that you are seeing has to do with the way you are compiling and running your application
p26035
aVAt the command line prompt, do this:
p26036
aVThis will produce  file
p26037
aVRun it as follows:
p26038
aVAt this point the running program will be reading the input and producing the output on the console
p26039
aVIt will throw exceptions if the expected input is not available because you call  without checking for , but it will produce a result if you give it the input that it expects
p26040
as(dp26041
g6
V335858
p26042
stp26043
a((dp26044
g2
(lp26045
VIn C++11 you can use a delegated constructor feature:
p26046
aVWith the delegating constructors feature, you can concentrate common initializations and post initializations in one constructor named target constructor
p26047
aVDelegating constructors can call the target constructor to do the initialization
p26048
aVA delegating constructor can also be used as the target constructor of one or more delegating constructors
p26049
aVYou can use this feature to make programs more readable and maintainable
p26050
aVThe constructor with fewer parameters calls the constructor with more parameters, and the constructor with the most parameters does all the checking
p26051
aVNote that you should be able to unify the last three constructors by adding default values for  and , like this:
p26052
as(dp26053
g6
V335858
p26054
stp26055
a((dp26056
g2
(lp26057
VSince the loops that you are using are destructive (i
p26058
ag630
aVthey make  go to zero by the end of the loop) you need to combine the two loops into one:
p26059
as(dp26060
g6
V335858
p26061
stp26062
a((dp26063
g2
(lp26064
VCalling a static method through an instance does not require the instance to be there
p26065
aVAs long as the compiler is able to determine the type of the variable, it makes the equivalent call statically after evaluating the  expression and discarding the result:
p26066
aVFrom the Java Language Specification:
p26067
aVSection 15
p26068
aV12
p26069
ag1340
aV\u2756 If the form is , then the name of
p26070
aVthe method is the Identifier
p26071
aVLet T be the type of the Primary expression
p26072
aVThe class or interface to be searched is T if T is a class or interface type, or the upper bound of T if T is a type variable
p26073
aVSection 15
p26074
aV12
p26075
ag14885
aV1:
p26076
aVIf the second production for MethodInvocation, which includes a Primary, is
p26077
aVinvolved, then there are two subcases:
p26078
aV\u2756 If the invocation mode is  static, then there is no target reference
p26079
aVThe
p26080
aVexpression Primary is evaluated, but the result is then discarded
p26081
as(dp26082
g6
V335858
p26083
stp26084
a((dp26085
g2
(lp26086
VName mangling is invented to assist in resolving overloaded function names
p26087
aVYou can define several functions with the same name, differing only in the count and the types of their parameters
p26088
aVName mangling lets the linker resolve such functions to the correct place in the code
p26089
aVUnlike names of functions, names of static objects in the global namespace cannot be overloaded, so mangling them is not necessary
p26090
aVNames of objects that are outside of global namespace are, in fact, mangled
p26091
as(dp26092
g6
V335858
p26093
stp26094
a((dp26095
g2
(lp26096
VFor the data from your sample you can do it with a trivial pair of nested loops:
p26097
aVFor more complex data, you can use a string concatenation trick:
p26098
as(dp26099
g6
V335858
p26100
stp26101
a((dp26102
g2
(lp26103
VYour  operator should be changing the values of  and , but it does not
p26104
aVAdd code to set these values into , instead of creating :
p26105
as(dp26106
g6
V335858
p26107
stp26108
a((dp26109
g2
(lp26110
VThere are no such things as strings of s or s in C#*; the closest thing is a , but it does not support the typical string-specific operations, such as substrings, trimming, and so on
p26111
aVYou can do most of the things that you can with a string using
p26112
aVNET's LINQ
p26113
aVFor example,  would be
p26114
aV* The same is true for C++: there is  template that can be instantiated with other types, but  is an instance of a template class, not a template class itself
p26115
as(dp26116
g6
V335858
p26117
stp26118
a((dp26119
g2
(lp26120
VSince  is a language alias for , there is absolutely no difference between the first and the second expressions
p26121
aVStarting with
p26122
aVNET 2,  returns exactly the same object as , making all three statements exact equivalents of each other in terms of the value that they return
p26123
aVEven in
p26124
aVNET prior to 2 no multiple objects would be created due to interning
p26125
aVThe first and second snippets will produce IL code that is different from the third snippet, but they all would return the same object
p26126
as(dp26127
g6
V335858
p26128
stp26129
a((dp26130
g2
(lp26131
VAssuming that using the standard C++ library is an option, you should use
p26132
aVinstead of
p26133
aVThere is absolutely no downside, and you would get many convenient things for free
p26134
aVFor example, you would be able to find the size of the vector and each of its dimensions without passing a pair of numbers on the side, or coding in some assumptions
p26135
aVYou would be able to allocate without loops, and delete with no code at all
p26136
aVIf this is not an option, you can replace / with / as follows:
p26137
as(dp26138
g6
V335858
p26139
stp26140
a((dp26141
g2
(lp26142
VThis is because  is a meta-character that accepts "any character"
p26143
aVIt treats every single character of your string as a delimiter, "eating up" its entire content
p26144
aVEscape the dot it like this:
p26145
aVor use a character class, like this:
p26146
as(dp26147
g6
V335858
p26148
stp26149
a((dp26150
g2
(lp26151
VMost likely, the memory leak is coming from the destructor of your  or one of its subclasses: you are performing your  operations correctly, so the destructor itself must be at fault
p26152
aVOne common problem is not making destructors virtual in a polymorphic class hierarchy
p26153
aVYou are also absolutely right about uselessness of calling : it will leak your objects "wholesale" by "forgetting" the references to them
p26154
aVIf you are on C++11, consider changing the definition to use
p26155
aVThis will free you from the need to manage the memory of your entries manually, while letting you keep pointers to objects of derived classes in your
p26156
aVIf you use , calls to  will destroy the items pointed to by vector's elements
p26157
aVDealing with the vector of  is somewhat different (for example, inserting new items requires extra care, see this answer for details) but I think the positives of simplified memory management compensate for the slight inconveniences
p26158
aVEDIT : Since your  class is not polymorphic, consider switching to , unless you plan to switch to a polymorphic hierarchy later on
p26159
as(dp26160
g6
V335858
p26161
stp26162
a((dp26163
g2
(lp26164
VYou can use this query to retrieve the length of the span in seconds:
p26165
aVThe idea is to cut the parts to the left, to the right, and in the middle, multiply by the number of seconds in an hour and the number of seconds in a minute, and add the three components together
p26166
aVHere is a link to sqlfiddle
p26167
as(dp26168
g6
V335858
p26169
stp26170
a((dp26171
g2
(lp26172
VThere are several problems with this code:
p26173
aVYou are going through four elements of the array , while the array has only three elements
p26174
aVYou did not allocate space for the strings that you are reading with
p26175
aVYou do not pass the address of address when you read strings
p26176
aVTo fix the first problem, change  for  or , like this:
p26177
aVTo fix the second and the third problem, use :
p26178
aVOnce you are done with the data that you allocated, don't forget to free the strings:
p26179
as(dp26180
g6
V335858
p26181
stp26182
a((dp26183
g2
(lp26184
VIt looks like one or more of your attributes are missing
p26185
aVreturns , and calling  on it causes the NPE*
p26186
aVSince the execution is deferred, the call does not happen until you start looping through the
p26187
aVTo find the attribute that causes the problem remove all calls to  except for , verify that the crash does not happen, and start adding back the attributes one by one until the crash is back
p26188
aV* After seeing the XML that you added to your question it appears that all attributes are missing
p26189
aVHere is a link to a short article that discusses the differences
p26190
as(dp26191
g6
V335858
p26192
stp26193
a((dp26194
g2
(lp26195
VIt is customary to number bits in a byte according to their significance: bit  represents
p26196
aVAccording to this numbering scheme, the least significant bit gets number zero, the next bit is number one, and so on
p26197
aVGetting individual bits requires a shift and a masking operation:
p26198
aVShift by the number of bits to the right of the rightmost portion that you need to get (shifting by zero is ignored; I added it for illustration purposes)
p26199
aVMask with the highest number that fits in the number of bits that you would like to get: 1 for one bit, 3 for two bits, 7 for three bits,  for  bits
p26200
as(dp26201
g6
V335858
p26202
stp26203
a((dp26204
g2
(lp26205
VThere is no conditionals in Java regexp, but you can simulate them by writing two expressions that include mutually exclusive look-behind constructs, like this:
p26206
aVThis expression will match "then" when it is preceded by an ; it will match  when it is not preceded by an
p26207
as(dp26208
g6
V335858
p26209
stp26210
a((dp26211
g2
(lp26212
VWho does this
p26213
aV- Ultimately, it's the CPU who does this; the compiler generates all the relevant instructions for the CPU to perform the conversions
p26214
aVWhat is necessity of doing so many conversions
p26215
aV- The conversions are necessary to ensure consistency of the results across multiple platforms supported by multiple C compilers
p26216
aVWill it reduce/increase the performance of machine/compiler
p26217
aV- This will reduce the performance compared to "doing nothing", but nobody will notice the difference
p26218
aVIf it is reducing performance what should we do in order to increase it
p26219
aV- Nothing: if you must perform arithmetic operations on s, then you perform arithmetic operations on s
p26220
aVLet the optimizer take care of removing all unnecessary instructions for your platform
p26221
aVIn most cases, CPU has instructions that are compatible with the semantic required by the C language, so the generated code will be very short
p26222
aVOf course if you do not need to perform operations on signed characters, you can perform operations on unsigned characters
p26223
aVThis eliminated a good deal of sign extending
p26224
as(dp26225
g6
V335858
p26226
stp26227
a((dp26228
g2
(lp26229
VThe array is passed correctly, it's your code that's not doing the additions right
p26230
aVYou set  to  at the beginning, and move it in the increasing order with
p26231
aVAs the result, all your accesses to array elements are past the end of the row
p26232
aVLoop exit condition is not right either, unless your matrices are always square (in which case there is no point to pass separate counts for rows and columns)
p26233
aVThis should work:
p26234
as(dp26235
g6
V335858
p26236
stp26237
a((dp26238
g2
(lp26239
VSure, you can do that
p26240
aVThe logic does not change much from the second code snippet, except that you  the answers as you find them:
p26241
as(dp26242
g6
V335858
p26243
stp26244
a((dp26245
g2
(lp26246
Vwhy the following code is giving me an error when I try to set the value of number[i]
p26247
aVBecause strings in C# are immutable
p26248
aVArrays of characters are mutable, though, so you can do this:
p26249
aVThe most common way of building strings in C# is by using the  class
p26250
aVIt lets you change the content of the string by appending, removing, or replacing characters inside the string
p26251
as(dp26252
g6
V335858
p26253
stp26254
a((dp26255
g2
(lp26256
VYou get the correct string, it's Windows console that does not display the string correctly
p26257
aVHere is a link to an article that discusses a way to make Java console produce correct Unicode output using JNI
p26258
as(dp26259
g6
V335858
p26260
stp26261
a((dp26262
g2
(lp26263
VIt appears that you have two variables called  - the local that you declared in the constructor:
p26264
aVand the one that you access in the destructor:
p26265
aVThese variables are not the same: the one that you access in the destructor must be a global or an instance variable (more likely)
p26266
aVSince you rely on  to pass the state from the constructor to the destructor, you need to remove the local declaration from the constructor, and initialize the other  as appropriate
p26267
aVIf it is an instance variable, add its initialization to the initializer list, like this:
p26268
as(dp26269
g6
V335858
p26270
stp26271
a((dp26272
g2
(lp26273
VSince the character at the position passed as the first parameter is included in the result, position  should not be considered to be past the end of the string: it is at the end of the string
p26274
aVThe length of the string is a legal argument to pass to
p26275
as(dp26276
g6
V335858
p26277
stp26278
a((dp26279
g2
(lp26280
VThat's the same
p26281
aVAll  values are converted to  before being passed to  (or any other function that takes variable number of parameters)
p26282
aVprints
p26283
as(dp26284
g6
V335858
p26285
stp26286
a((dp26287
g2
(lp26288
VYour expression does not return two values (for  and for ), it returns only one
p26289
aVYour words will end up in keys, and values will remain empty
p26290
aVYou should rewrite the loop to iterate over one item, like this:
p26291
aVThis prints  (link to demo on ideone)
p26292
as(dp26293
g6
V335858
p26294
stp26295
a((dp26296
g2
(lp26297
VIf you number your bits and bytes from zero, dividing by eight using integer division should do the trick:
p26298
as(dp26299
g6
V335858
p26300
stp26301
a((dp26302
g2
(lp26303
VThe error is caused by this line:
p26304
aVThe value of  needs to be set before using it in an  statement
p26305
aVThis indicates an error in your code: you check if` statement, but you never assign to it
p26306
aVLook through the tutorial to find a line that looks like this:
p26307
aVMost likely, you did not enter this line into your program when you followed the tutorial
p26308
as(dp26309
g6
V335858
p26310
stp26311
a((dp26312
g2
(lp26313
VYes - simply remove
p26314
aVand everything will compile and run as expected
p26315
aVARC compiler inserts the call to  automatically, and prohibits explicit use of  in your code
p26316
as(dp26317
g6
V335858
p26318
stp26319
a((dp26320
g2
(lp26321
VOne of the most efficient ways to implement sets that can be quickly merged is by using Disjoint-set Data Structure
p26322
aVThe idea is to represent each set initially as a linked list, with the head of the list serving as the identifier for the entire set
p26323
aVAs sets get merged, nodes are re-pointed to the head to speed up further searches
p26324
aVThe article at the link has pseudo-code; C++ implementation should not be too difficult
p26325
aVYou would need to keep a separate  that connects the integers that you have seen so far with their node within the disjoint-set forest
p26326
aVYou would go through your data sets, take their items one by one, look up the item in the , and either follow the link to its set, or create a new "singleton" disjoint set with the item that you are adding
p26327
as(dp26328
g6
V335858
p26329
stp26330
a((dp26331
g2
(lp26332
VWriting to console is a relatively time-consuming task, especially compared to doing nothing at all
p26333
aVThis slows the execution down considerably
p26334
aVIf you redirect the output to a file, your loop will be slower than without printing, but faster than with printing to console
p26335
aVThat is the cause of the big difference in execution speeds with and without printing
p26336
as(dp26337
g6
V335858
p26338
stp26339
a((dp26340
g2
(lp26341
VIf you own the data model, and your binary data is small fixed-size array of bytes, you can change the SQL data type from  to , use  on the way into the database, and  on the way out
p26342
aVSwitching to string will make your data searchable: simply encode your search  as base64 string, and use the  operator in the search condition
p26343
as(dp26344
g6
V335858
p26345
stp26346
a((dp26347
g2
(lp26348
VThe easiest thing would be to store a state in a variable accessible from your code-behind, and have an  statement in the button's  deciding what to do
p26349
aVIt is probably not worth the trouble, as buttons that change their meaning may be confusing to your end users
p26350
aVI would do two separate buttons, but I would conditionally enable or disable them, based on the state of the application
p26351
aVWhen copying is the only action that makes sense, the  button would be enabled, and the  button would be disabled
p26352
aVWhen the state changes, so would the enabled/disabled status of these buttons
p26353
aVThis would give clean visual cues to the end users of your application, and make your application easier to test automatically with various UI test automation tools
p26354
as(dp26355
g6
V335858
p26356
stp26357
a((dp26358
g2
(lp26359
VWhat is the difference between an allocated  and
p26360
aVThe lifetime of a -ed string is not limited by the scope of its declaration
p26361
aVIn plain language, you can return -ed string from a function; you cannot do the same with  allocated in the automatic storage, because its memory will be reclaimed upon return from the function
p26362
aVCan literals be manipulated
p26363
aVString literals cannot be manipulated in place, because they are allocated in read-only storage
p26364
aVYou need to copy them into a modifiable space, such as static, automatic, or dynamic one, in order to manipulate them
p26365
aVThis cannot be done:
p26366
aVThis will work:
p26367
aVThis works too:
p26368
aVHow do you take care of null termination of string literals
p26369
aVC compiler takes care of null termination for you: all string literals have an extra character at the end, filled with
p26370
as(dp26371
g6
V335858
p26372
stp26373
a((dp26374
g2
(lp26375
V[is] there was a built in method or functionality where I could detect if a booleans value had changed in the function
p26376
aVYou can do it by encapsulating access to your  variables using setters:
p26377
aVReplace all assignments of these variables with calls of  and  to get reliable detection of changes in  and
p26378
as(dp26379
g6
V335858
p26380
stp26381
a((dp26382
g2
(lp26383
VYou can use regular expressions, like this:
p26384
aVThe core of this solution is this regular expression:
p26385
aVIt matches a sequence of non-space characters that follow colon+space  sequence all the way to the end of line
p26386
aVDemo on ideone: link
p26387
as(dp26388
g6
V335858
p26389
stp26390
a((dp26391
g2
(lp26392
VThe "best way" depends on your requirements: do you want the duplicates removed
p26393
aVUse a ; do you want to keep the duplicates
p26394
aVCopy, then sort
p26395
aVTrying to get the fastest one out of the two is premature optimization
p26396
as(dp26397
g6
V335858
p26398
stp26399
a((dp26400
g2
(lp26401
VYou can use  and , like this:
p26402
aVThis produces the following output:
p26403
aVDon't forget to include  in order for this to compile (link to ideone)
p26404
as(dp26405
g6
V335858
p26406
stp26407
a((dp26408
g2
(lp26409
VThis is a new syntax that has been recently added to Objective C
p26410
aVThere is also a new syntax for s, s, and accessing arrays with square brackets:
p26411
as(dp26412
g6
V335858
p26413
stp26414
a((dp26415
g2
(lp26416
VThis one is : the 10 of the outer loop is just a constant
p26417
as(dp26418
g6
V335858
p26419
stp26420
a((dp26421
g2
(lp26422
VThis is not because it's a binary column, but because  in SQL should not be compared to anything
p26423
aVEssentially,  condition filters out all rows - all checks for  and  always evaluate to
p26424
aVUse  instead:
p26425
as(dp26426
g6
V335858
p26427
stp26428
a((dp26429
g2
(lp26430
VThe problem is that you cannot return local arrays:
p26431
aVis invalid
p26432
aVYou need to copy  into dynamic memory before returning it
p26433
aVCurrently, since  is allocated in the automatic storage, the memory for your array gets reclaimed as soon as the function returns, rendering the returned value invalid
p26434
aVJava does not have the same issue because all objects, including arrays, are allocated in the dynamic storage
p26435
aVBetter yet, you should avoid using arrays in favor of C++ classes that are designed to replace them
p26436
aVIn this case, using a  would be a better choice
p26437
as(dp26438
g6
V335858
p26439
stp26440
a((dp26441
g2
(lp26442
VBecause  is not doing what you think it does: it's a projection, not a filter
p26443
aVThe expression  is calculated for each item on your list
p26444
aVYou'll get
p26445
aVThen the  gets called on the result, returning
p26446
aVFiltering is done with the  method that takes a predicate:
p26447
as(dp26448
g6
V335858
p26449
stp26450
a((dp26451
g2
(lp26452
VThe  statement does not care how the variable gets its value, - be it from a static function, a member function, a  operator, or any other way
p26453
aVAs soon as the closing brace of the  is reached, the  method on the variable will be called, closing the connection if it's an  instance, or doing whatever else the  is to do upon disposing
p26454
as(dp26455
g6
V335858
p26456
stp26457
a((dp26458
g2
(lp26459
VIt is hard to say which one is going to be faster without trying it, but a even a slightly slower instruction without a branch will usually be faster due to pipelining and branch prediction
p26460
aVIn your case, the branch predictor will be wrong 90% of the time, reducing the speed quite a bit
p26461
as(dp26462
g6
V335858
p26463
stp26464
a((dp26465
g2
(lp26466
VYou can combine the declaration and initialization, and use a conditional operator to avoid introducing a new scope with the  statement:
p26467
as(dp26468
g6
V335858
p26469
stp26470
a((dp26471
g2
(lp26472
VThe first assigns a list to a variable defined by its interface, the second defines the variable by class
p26473
aVThe first declaration will let you change the implementation later:
p26474
aVis valid, while the second would not let you change the implementation:
p26475
aVIt is worth noting that starting with Java 5  is a generic type, so you should specify the type parameter to improve type safety:
p26476
as(dp26477
g6
V335858
p26478
stp26479
a((dp26480
g2
(lp26481
VNamespaces and assemblies (DLLs) both provide ways to partition your project, but they do it in different ways: namespaces provide logical partitioning, while assemblies provide physical partitioning
p26482
aVVery often the boundaries of these partitioning match exactly, but it does not need to be so: you can have classes from the same namespace appear in multiple assemblies; you could also put classes from multiple namespaces into the same assembly
p26483
aVA rule of thumb for creating a new assembly that I follow is simple: if there is a situation when one group of classes can be used independently of another group of classes, the two groups should go to separate assemblies
p26484
aVThis gives you more flexibility in mixing your assemblies as dependencies of other projects
p26485
aVSince dependencies of your dependencies are loaded lazily, making smaller DLLs lets you better manage the runtime footprint of your application
p26486
aVThe biggest issue associated with multiple DLLs is a significant increase of compile time
p26487
aVFortunately, it can be addressed by managing the "Copy Local" setting
p26488
as(dp26489
g6
V335858
p26490
stp26491
a((dp26492
g2
(lp26493
VAssuming a JIT compiler, there should be no noticeable difference in efficiency - at least not enough to make a significant difference in the execution speed of your application
p26494
aVThere is a noticeable gain in flexibility, though: encapsulating the value in a method is nearly always good, because it lets you change the way the value is calculate later
p26495
aVA notable exception to this rule is pure constants, say, from the world of mathematics: it does not make much sense to encapsulate access to , because there is no chance that the value of this fundamental constant is going to change, prompting a need to switch the method the value is obtained in your program
p26496
as(dp26497
g6
V335858
p26498
stp26499
a((dp26500
g2
(lp26501
VYes,  is valid in this context, because it points to a valid location in memory allocated to your  array
p26502
aVis equivalent to
p26503
aVFollowing the chain of assignments in your example, it is the same as , or , which is valid
p26504
aVEDIT : The general rule is that an addition / subtraction of an integer and a pointer (and by extension, the equivalent indexing operations on pointers) need to produce a result that points to the same array or one element beyond the end of the array in order to be valid
p26505
aVThanks, Eric Postpischil for a great note
p26506
as(dp26507
g6
V335858
p26508
stp26509
a((dp26510
g2
(lp26511
VYou cannot make the scanner ignore input automatically, but you can write code to skip input yourself until you see that a double is available:
p26512
aVIf you need to put this code in multiple places, you can wrap it in a function:
p26513
as(dp26514
g6
V335858
p26515
stp26516
a((dp26517
g2
(lp26518
VWho creates it
p26519
aVObviously not me
p26520
aVWhat makes you so sure
p26521
aVOf course you do:
p26522
aVOr  owns two  methods in the methodtable
p26523
aVNo, it has just one  method, but it has something else: it knows about its base class, , which has its own  method
p26524
aVThat's why  has access to two s - its own and his 's
p26525
as(dp26526
g6
V335858
p26527
stp26528
a((dp26529
g2
(lp26530
V is not an array, it is a  implemented using a hidden array
p26531
aVYou need to add three items to it before you can address items by index, like this:
p26532
aVs grow automatically
p26533
aVIf you do not need this functionality, you use a plain array, for example, like this:
p26534
aVNow you can replace items by using the indexing operator:
p26535
as(dp26536
g6
V335858
p26537
stp26538
a((dp26539
g2
(lp26540
VThe rule is not universal: the  version is preferred when you implement a logically symmetric operation that takes two arguments of the same type, such as the case that your post demonstrates
p26541
aVThis implementation underscores the fact that the operation is truly symmetric: it's not a 'Object this' that adds  to itself - rather, that's an addition of  and
p26542
aVIn situations when the operation is non-symmetric - for example, when you add an  to an iterator, you should prefer the first way of implementing operators, namely
p26543
as(dp26544
g6
V335858
p26545
stp26546
a((dp26547
g2
(lp26548
VAll member functions share the same code, so they have the same address in the code segment of memory
p26549
aVMember functions operate on different instances only because they are implicitly passed different values of  pointer
p26550
aVThey are not tied in any way to any of the instances on which they operate
p26551
aVThe actual value of  could be determined  statically if the function is non-virtual, or dynamically (through the vtable) if the function is virtual
p26552
as(dp26553
g6
V335858
p26554
stp26555
a((dp26556
g2
(lp26557
VI was thinking of making two arrays, one of strings, and another with their corresponding function pointers
p26558
aVThat is the right approach
p26559
aVMake wrapper functions that take arguments of identical type* then call the "real" functions from inside your wrappers
p26560
aVIf you would like to "earn additional points for style", sort the array of strings alphabetically, and use binary search on the array of strings
p26561
aVThis will let you save a few CPU cycles when the two arrays get bigger
p26562
aV* Perhaps you could use , because that's what your  takes
p26563
as(dp26564
g6
V335858
p26565
stp26566
a((dp26567
g2
(lp26568
VSince there is no standard for serializing data in C++, the "preferred" way is what you prefer
p26569
aVBoost is entirely acceptable, unless your project explicitly prohibits the use of third-party libraries, in which case you can certainly roll your own
p26570
aVIf you choose to roll your own, make sure that your serializers and deserializers do not open and close the streams on their own
p26571
aVInstead, the callers need to pass the stream to them
p26572
aVSee this link for more information
p26573
as(dp26574
g6
V335858
p26575
stp26576
a((dp26577
g2
(lp26578
VYou cannot assign  to a  directly
p26579
aVYou need to parse strings to assign them to doubles, like this:
p26580
as(dp26581
g6
V335858
p26582
stp26583
a((dp26584
g2
(lp26585
VAssuming that the assignment is possible, you need to convert to a nullable , like this:
p26586
aVThe inner cast to  unboxes the value, and the outer cast to  makes it compatible with  of the conditional expression
p26587
aVIf the left-hand side of the assignment does not allow s, you need to decide on the value to set when  is
p26588
aVUsually, that's a :
p26589
as(dp26590
g6
V335858
p26591
stp26592
a((dp26593
g2
(lp26594
VThe easiest thing is to wait for the loop to finish, and then return the last value that it has produced
p26595
aVThe only valid reason why you need to wait for the loop to calculate all three results is that the calculation is dependent upon the value calculated by the prior iteration of the loop
p26596
aVIn this case, here is how you can do it:
p26597
aVIn case when you can calculate the value of the last iteration directly without running the previos iterations, there is no reason to run the loop at all
p26598
as(dp26599
g6
V335858
p26600
stp26601
a((dp26602
g2
(lp26603
VYou can certainly use dynamically allocated memory instead of the array, but the fundamental issue of the overrun remains there:
p26604
aVYou need to tell  that the space is limited, like this:
p26605
aVNote that  has an extra character space for the terminator:  limits the input to 200 "real" characters, so you need to provide an extra  for the
p26606
as(dp26607
g6
V335858
p26608
stp26609
a((dp26610
g2
(lp26611
VCollisions happen when two different items have the same hash code, so obviously  must deal with collisions
p26612
aVThe only difference is that the "regular" hash map uses  which can be  for different objects, while  uses  that can't be  for different object
p26613
aVThe reason the "regular" hash map has separate variables for keys and values is an implementation detail of the : its implementation uses linear probing to address collisions, and it also stores keys and values in the same table: the key is placed at , while the value is placed at
p26614
aVThe regular  defines an  class which combines the key with its value in the same object, and stores entries in buckets
p26615
as(dp26616
g6
V335858
p26617
stp26618
a((dp26619
g2
(lp26620
VThe code above exhibits undefined behavior: it should be
p26621
aVbecause the allocation was done with
p26622
aVWhen you use the correct operator, the entire array pointed to by the pointer gets deleted:
p26623
as(dp26624
g6
V335858
p26625
stp26626
a((dp26627
g2
(lp26628
VIf  is an instance variable or a static variable that can be changed from multiple threads, its value can change between the time you test it in the  statement and the time when you call its instance method
p26629
aVYou can modify the code to avoid this problem by copying the object into a local variable, like this:
p26630
aVSince  is a local variable, its value cannot change between the test and the call of
p26631
aVOf course the state of the playable object itself can change, but that is not something that can be fixed by  checking
p26632
as(dp26633
g6
V335858
p26634
stp26635
a((dp26636
g2
(lp26637
VIf your read is single-threaded, you can use , which avoids the overhead of locking the stream for each operation
p26638
aVGo character-by-character, accumulate the number, and wait for a space
p26639
aVWhen you see the space, save the number, and zero out the current value:
p26640
aVOf course this fragment ignores the "unimportant" stuff such as error checking, but it is OK when your input is "sanitized"
p26641
aVFor example, something like this can be used to save on I/O costs with an ACM online judge
p26642
as(dp26643
g6
V335858
p26644
stp26645
a((dp26646
g2
(lp26647
VThe first call should return ; the second call should return , and set  to
p26648
aVYou should prevent the second call from happening by setting  to a known bad number, e
p26649
ag303
aVa  immediately after the first call of , and subsequently checking  before making the second call (and not making the call if  is ):
p26650
aVThis code pattern will help when you need to make calls to  from multiple places, but you are not sure if the file is open, or if it has been closed already
p26651
aVPassing  to  is harmless (you would get an , of course)
p26652
as(dp26653
g6
V335858
p26654
stp26655
a((dp26656
g2
(lp26657
VThis assigns the value of  to an integer stored at the address pointed to by
p26658
aVThis assigns the address of  to
p26659
aVNote that in your example  is unassigned, so the behavior of  is undefined
p26660
aVHere is a better illustration:
p26661
as(dp26662
g6
V335858
p26663
stp26664
a((dp26665
g2
(lp26666
VThe point of declaring delegates in the first place is so that you could call a method without seeing its declaration
p26667
aVThat is why you need a different delegate type  for each function signature that you are planning to call indirectly through a delegate
p26668
as(dp26669
g6
V335858
p26670
stp26671
a((dp26672
g2
(lp26673
VI think this is a better design than the multithreaded-one in which each routine writing log should use some kind of synchronization scheme
p26674
aVIn a design where a dedicated thread is the only one writing to the log you must use synchronization too, except that instead of synchronizing access to the log you need to synchronize access to the producer-consumer queue of the thread that writes to the log
p26675
aVCould you provide more methods/examples to turn a multithreading problem to a simple single-thread problem
p26676
aVThe problem by no means has become simpler: the need of synchronization did not go away, only got moved from one place to the other
p26677
as(dp26678
g6
V335858
p26679
stp26680
a((dp26681
g2
(lp26682
VYou should be ordering by , it will give you the correct sort order
p26683
aVUse your expression that multiplies by  and adds a percentage sign to the end to format the output, not for sorting
p26684
as(dp26685
g6
V335858
p26686
stp26687
a((dp26688
g2
(lp26689
VIn order to declare a variable of any type, template or not, the entire definition of that type must be available
p26690
aVYou cannot forward-declare a template, and then start using it as if it were defined
p26691
aVAll you can do at that point is declaring a pointer to an object of a type based on the template, like this:
p26692
aVUnfortunately (but not unexpectedly) this moves the error to the next line
p26693
aVThe problem of initializing that pointer remains: once you attempt to invoke , you will see an error
p26694
aVYou need to re-arrange your code to move the definition of the template ahead of its place of use
p26695
aVThis may be somewhat tedious, but there is no way around it: the compiler needs to have the entire definition at the point where you start instantiating your template and calling its methods
p26696
as(dp26697
g6
V335858
p26698
stp26699
a((dp26700
g2
(lp26701
VThe  function expects a null-terminated string; you are passing a portion of the char array that has its termination past the boundaries of , so  interprets the entire value as a number
p26702
aVIf you would like to stick to your "cookie cutter" method of parsing the key, you need to make a copy, and pass it to :
p26703
aVHowever, I think that using  is a better choice:
p26704
as(dp26705
g6
V335858
p26706
stp26707
a((dp26708
g2
(lp26709
VI have a structure that is also array
p26710
aVAlthough there is no such thing as a "structure that is also array", you can make an array of structs
p26711
aVYou should untangle the  and the declaration of a  variable first, like this:
p26712
aVNow you can use  as a name of a type, declare variables of type , make pointers to them, pass arrays, and so on, as if it were a value of a built-in type, such as an :
p26713
as(dp26714
g6
V335858
p26715
stp26716
a((dp26717
g2
(lp26718
VA retain cycle is a situation when object  retains object , and object  retains object  at the same time*
p26719
aVHere is an example:
p26720
aVYou can fix a retain cycle in ARC by using  variables or  properties for your "back links", i
p26721
ag630
aVlinks to direct or indirect parents in an object hierarchy:
p26722
aV* This is the most primitive form of a retain cycle; there may be a long chain of objects that retain each other in a circle
p26723
as(dp26724
g6
V335858
p26725
stp26726
a((dp26727
g2
(lp26728
VYou can do it with a single iterator
p26729
aVMove the increment from the header to the middle of your loop, and exit the loop when you hit the end of your map, like this:
p26730
as(dp26731
g6
V335858
p26732
stp26733
a((dp26734
g2
(lp26735
VBecause instances of  are immutable*
p26736
aVreturns the correct string, but your program throws it away
p26737
aVChange your program as follows to correct the issue:
p26738
aV* That's a fancy way of saying "non-changeable": once a string instance  is created, there are no methods that you could call on it to change that value
p26739
as(dp26740
g6
V335858
p26741
stp26742
a((dp26743
g2
(lp26744
VThe new API lets you save a call to get the current device orientation: the two questions, namely
p26745
aVWhether or not the application should auto-rotate, regardless of the new orientation, and
p26746
aVWhat are the orientations a device supports
p26747
aVare most often answered statically, without making a call to check the current orientation
p26748
aVThe savings become more important when a screen has multiple views controlled by separate view controllers
p26749
aVSince the iOS is making a call into your app's  in response to an event from the accelerometer, it already knows the new orientation; if your app answers 'YES`, the iOS could then check the current orientation against the list of supported ones, and come up with a decision without your app querying for the current orientation
p26750
aVIn the unlikely case that your app needs to decide on auto-rotation based on the new orientation, the new API is no worse than the old one, so it's a "win-draw" situation
p26751
as(dp26752
g6
V335858
p26753
stp26754
a((dp26755
g2
(lp26756
VThe difference is that adding must be type-safe to preserve the integrity of the collection, while item checking/removal can afford to be "type-forgiving" without the risk of harming type safety of the collection
p26757
aVIn other words, if you add an element of a wrong type, the set will become invalid; on the other hand, if you check for a presence of an element of a wrong type, you'll simply get back a
p26758
aVSame goes for : if you pass an element of an incompatible type, it's not going to be in the set +, so the removal is going to be a no-op
p26759
aV+ Unless you put it in through a hack that exploits type erasure
p26760
as(dp26761
g6
V335858
p26762
stp26763
a((dp26764
g2
(lp26765
VYou need a dynamically growing container for a set of unknown size - a , for example:
p26766
aVAt this point, all  objects that your program created and started are elements of the  list
p26767
aVYou can enumerate them and do whatever else you were planning to do with them (e
p26768
ag303
aVwait for them to finish):
p26769
as(dp26770
g6
V335858
p26771
stp26772
a((dp26773
g2
(lp26774
VEven after you fix the bug with calculating the  coordinate that get reset back to 30 in each iteration, you will have the issue with reusing cells: your program adds new s to the cell, even though it may contain five  objects already
p26775
aVAfter a few rounds of reusing, the cell would have a few dozen images sitting atop of each other, with a disastrous effects on the performance - especially the performance of scrolling
p26776
aVYou should define a custom subclass of  with six  objects added as subviews, give it a method like this
p26777
aVand call this method in the loop (if you want six images, the loop should have , not  as its ending condition)
p26778
aVEDIT : Here is an oversimplified way to code this:
p26779
aVCustomCell
p26780
aVh:
p26781
aVCustomCell
p26782
aVm:
p26783
as(dp26784
g6
V335858
p26785
stp26786
a((dp26787
g2
(lp26788
VThe best way to ensure that a  (or in fact, any  resource) is closed is to use the  statement where it is possible
p26789
aVHere is how:
p26790
aVOnce the scope of the  statement ends, normally or through an exception, the  is closed automatically
p26791
as(dp26792
g6
V335858
p26793
stp26794
a((dp26795
g2
(lp26796
VThere will be no call to 's  method after the call of , even though the variable is wrapped in
p26797
aVIf you would like to make sure that the connection is disposed, either put the  inside /, or do not call  inside
p26798
aVYou can still exit if you set a flag, and act upon it after the  statement:
p26799
as(dp26800
g6
V335858
p26801
stp26802
a((dp26803
g2
(lp26804
VIf you must use assignments in the constructor (as opposed to using a list of initializers, which is preferred) the specific pattern to address this issue is to use  pointer, as follows:
p26805
as(dp26806
g6
V335858
p26807
stp26808
a((dp26809
g2
(lp26810
VYou need to add a loop to your , like this:
p26811
aVSince the decision to continue or to stop is made in the middle of the loop's body, using a "forever" loop is preferred
p26812
aVThere are multiple ways to achieve this, but since the  is the one described in K&R;, I recommend using it over other alternatives
p26813
as(dp26814
g6
V335858
p26815
stp26816
a((dp26817
g2
(lp26818
VThere are two ways to do it:
p26819
aVUse a regular string and escape the double quotes, or
p26820
aVUse a verbatim  string, and double the double quotes
p26821
aVor
p26822
as(dp26823
g6
V335858
p26824
stp26825
a((dp26826
g2
(lp26827
VThere is no difference between the two code snippets () - in fact, the optimizer could even optimize both fragments to the same binary code, assuming that there are no further uses of the  variable
p26828
aVNote, however, that division by a floating point zero  does not result in a run-time error, but produces an  or  instead
p26829
as(dp26830
g6
V335858
p26831
stp26832
a((dp26833
g2
(lp26834
VUPDATE : Since you are not allowed to use other predicates, try this:
p26835
aVThe first predicate deals with the base case, the second one removes the second element in a list of three or more items, and recurses down
p26836
as(dp26837
g6
V335858
p26838
stp26839
a((dp26840
g2
(lp26841
VIf the number of intervals is small, use a  with three members (, , and ), store them in a list, and run a linear search
p26842
aVIf the number of intervals is overwhelming, and the timing requirements make linear search prohibitive, create an interval tree, ans associate the messages with its leaf nodes
p26843
aVIf the intervals are not overlapping, you can create an interval class with two ends, and store interval objects in a  using their left boundary to compare intervals
p26844
aVWith this  in hand, you can find an interval quickly by calling  on the number that you are trying to locate and checking if the returned interval key overlaps the value that you are looking for
p26845
as(dp26846
g6
V335858
p26847
stp26848
a((dp26849
g2
(lp26850
VBecause without an assignment operator and a copy constructor you may end up with multiple  vectors pointing to the same heap item, resulting in undefined behavior upon destruction:
p26851
aVOf course you would not have this problem had you used a vector of objects or a vector of "smart pointers", rather than a vector of "plain old" pointers
p26852
aVSee the Rule of Three for more information
p26853
as(dp26854
g6
V335858
p26855
stp26856
a((dp26857
g2
(lp26858
VThis is a rather wasteful representation, using full eight bits for a single decimal digit - roughly a 60% waste of space
p26859
aVEven if you stay with this representation, you should consider switching the internal representation from a  to a , with the least significant digit stored at position , the digit for the tens stored at position , and so on
p26860
aVThis will let you implement addition with a single loop that adds digits at the same position if both digits are available, or adds the carry to the digit of the longer number
p26861
aVA better representation would be to use a base-256 system, and store individual "digits" as an array of bytes
p26862
aVNote that the addition is not the trickiest operation to implement: wait till you hit multiplication and division
p26863
aVTo take a peek at the complexity that you would need to address, download Java's implementation of
p26864
aVI am assuming that you are doing this for fun, not as part of a real project
p26865
aVOtherwise, there is no excuse for not using
p26866
aVNET's built-in representation of
p26867
as(dp26868
g6
V335858
p26869
stp26870
a((dp26871
g2
(lp26872
VI know I need to always be using >>> instead of >> for right shifting, but is this the only concern
p26873
aVYes, this is the only concern
p26874
aVShifting left works the same on signed and unsigned numbers; same goes for ing, ing, and ing
p26875
aVAs long as you use  for shifting right, you can use all 32 bits of a signed
p26876
as(dp26877
g6
V335858
p26878
stp26879
a((dp26880
g2
(lp26881
VWhen you put a declaration of a  variable in a  file, it gets re-defined in every  file from which the header is included
p26882
aVA brand-new variable will be created in each file, with the same name
p26883
aVThis is not an error in the  file: the variable is local to that file, and invisible to the linker, so there are no "multiple definitions" error
p26884
aVThat's because your test project used a single  file
p26885
aVSome sources seem to say that in C a static variable can only be used in the file in which it is declared
p26886
aVThat is absolutely correct: a  variable is very much like a file-scoped global variable, it should be defined in the  file
p26887
aVIf you want to share a variable, it needs to be a global then
p26888
aVDeclare it in the header with the  keyword, like this
p26889
aVand then define it in one of the  files like this:
p26890
as(dp26891
g6
V335858
p26892
stp26893
a((dp26894
g2
(lp26895
VAlthough you can certainly optimize your search by using hash tables, the best optimization is to let the database engine to the search for you
p26896
aVRDBMS engines are optimized for this kind of task - no client-side optimization should be able to beat it
p26897
aVYour biggest disadvantage is having to pull the data from the database into your program
p26898
aVThis is very slow
p26899
aVThe database engine has all the data right there - this is a huge advantage
p26900
aVFor example, if you are looking for rows representing users with identical first and last name, a simple query with a self-join will get you results in seconds, not minutes, because the data never leaves the engine
p26901
aVAssuming that  and  columns are indexed, this query will find you duplicates very quickly
p26902
as(dp26903
g6
V335858
p26904
stp26905
a((dp26906
g2
(lp26907
VThe simplest way of addressing this using the string from your example would be taking a substring:
p26908
aVThis works only when you are 100% certain that the first and the last characters are indeed square brackets
p26909
aVIf they are not, for example, when the string is untrimmed, you may need to perform additional string manipulations (e
p26910
ag303
aVtrimming the string)
p26911
as(dp26912
g6
V335858
p26913
stp26914
a((dp26915
g2
(lp26916
VThis is a function that takes a void pointer - a pointer without a specific type
p26917
aVVoid pointer type lets you pass a pointer to any data type to a function that is declared like that
p26918
aVThe function will have to cast the pointer to an appropriate type before reading/writing the data from it, or pass the pointer on to other functions that take
p26919
aVAny pointer can be cast to , implicitly or explicitly
p26920
aVFor example, you can call  like this:
p26921
aVYou can then call the same function with a different pointer type:
p26922
aVJudging from the name of the pointer, , it is likely that the function is trying to emulate object-oriented style of programming with constructs available in C
p26923
aVInstead of passing the pointer to data implicitly the way member-functions do, this style passes a pointer to data explicitly
p26924
aVThe pointer is often called  or
p26925
as(dp26926
g6
V335858
p26927
stp26928
a((dp26929
g2
(lp26930
V constructs a number by -ing in a number  with a binary number  (one shifted to the left 16 times)
p26931
aVIn C# you can use an expression directly, like this:
p26932
as(dp26933
g6
V335858
p26934
stp26935
a((dp26936
g2
(lp26937
VYou should add a class qualifier to the function definition, and remove the unused  parameter:
p26938
as(dp26939
g6
V335858
p26940
stp26941
a((dp26942
g2
(lp26943
VYou can read the number from a string stream as hex, and write it back to a different string stream as decimal:
p26944
aVLink to ideone
p26945
as(dp26946
g6
V335858
p26947
stp26948
a((dp26949
g2
(lp26950
VI am sure there is a mathematical calculation to answer this, but since this is a programming Q&A;, I'll tell you how to make your program give the answer faster: you can use memoization
p26951
aVCurrently, your program re-calculates the answer to  every time
p26952
aVHowever, the answer can be calculated once, because it does not change in subsequent invocations
p26953
aVAdd a 2D array for the result of , initialize with , and use it to look up results before calculating them to save a lot of time re-calculating the same numbers over and over:
p26954
as(dp26955
g6
V335858
p26956
stp26957
a((dp26958
g2
(lp26959
VTry this:
p26960
aVI do not know if it is going to work in Turbo Prolog, but it works fine in SWI, and it does not use any built-in predicates
p26961
aVpair of rules concatenates lists in positions 1 and 2 into a resultant list in position 3
p26962
aVThe first  deals with the empty list coming in; it is identical to yours, except it replaces singleton variables with underscores (a highly recommended practice)
p26963
aVThe second rule deals with the situation where the value  being replaced is at the head of the list; it replaces the values in the tail, and concatenates the replacement list  with the result of the replacement
p26964
aVThe last rule deals with the situation when the head value does not match the
p26965
aVIt recurses down one level, and prepends the head of the initial list to the head of the result of the replacement
p26966
aVAs a side note, the cut operator  is rarely necessary
p26967
aVIn case of this problem, you can definitely do without it
p26968
as(dp26969
g6
V335858
p26970
stp26971
a((dp26972
g2
(lp26973
VBecause all perfect squares are sums of consecutive odd numbers:
p26974
aV1 = 1
p26975
aV4 = 1 + 3
p26976
aV9 = 1 + 3 + 5
p26977
aV16 = 1 + 3 + 5 + 7
p26978
aVand so on
p26979
aVYour program attempts to subtract consecutive odd numbers from , and see if it drops to zero or goes negative
p26980
aVYou can make an informal proof of this by drawing squares with sides of  and observe that constructing a square  from square  requires adding  unit squares
p26981
as(dp26982
g6
V335858
p26983
stp26984
a((dp26985
g2
(lp26986
VDepending on the language, you should have a way to replace a string by regex
p26987
aVIn Java, you can do it like this:
p26988
aVThe  "anchor" indicates that the beginning of the input must be matched
p26989
aVThe  means a sequence of one or more  characters
p26990
aVHere is a link to ideone with this running program
p26991
aVThe same program in C#:
p26992
aV(link to ideone)
p26993
aVIn general, if you would like to make a match of anything only at the beginning of a string, add a  prefix to your expression; similarly, adding a  at the end makes the match accept only strings at the end of your input
p26994
as(dp26995
g6
V335858
p26996
stp26997
a((dp26998
g2
(lp26999
VNo, there is nothing in Objective-C that would let you built an iterable solution that easily
p27000
aVIn general, fast enumeration in Objective-C is built using an entirely different mechanism from C#, Java, or C++
p27001
aVAdopting the protocol is relatively complex, especially compared to C# with its , though it is certainly doable
p27002
aVI found that Objective C blocks provide a usable alternative to fast enumeration
p27003
aVConsider implementing a block-based enumeration instead of fast enumeration - it lets you program your own API using the style similar to
p27004
aVOn the flip side, the clients of your API would need to supply a block to use your enumeration
p27005
aVThis is not ideal, but usable, especially for complex enumerators, such as ones based on trees
p27006
as(dp27007
g6
V335858
p27008
stp27009
a((dp27010
g2
(lp27011
VThe simplest thing would be to search for a word in a sorted array, like this:
p27012
as(dp27013
g6
V335858
p27014
stp27015
a((dp27016
g2
(lp27017
VC# compiler is smart enough to implicitly figure out the type of  on the left side of  from the context
p27018
aVSince it knows that you are assigning the lambda to a variable of type , the compiler knows that  is an
p27019
aVAs far as the return type goes, the compiler knows that  is an , therefore the type of the  expression must also be
p27020
aVThat's how the compiler knows the return type of the lambda
p27021
aVNote that the same code would not have compiled without the exact type of  specified:
p27022
as(dp27023
g6
V335858
p27024
stp27025
a((dp27026
g2
(lp27027
VThe type of the lambda expression  is determined based on its context
p27028
aVSince the compiler knows that the lambda is assigned to , the compiler disregards the return type of the  method as if it were a statement expression
p27029
aVThis is a valid conversion:
p27030
aVIn other words, both
p27031
aVand
p27032
aVare correct usages of the  method; they can be used in lambdas in the same way
p27033
as(dp27034
g6
V335858
p27035
stp27036
a((dp27037
g2
(lp27038
VYou have very limited ability to validate a base-64 string all by itself: as long as the encoded string has the correct length (i
p27039
ag630
aVthe length, including the trailing equal signs, is divisible by four) and the string consists of only proper base64 characters, it is deemed a valid string
p27040
aVIf you need to tamper-proof your message, you need to prepare an additional piece of data describing the original text, and pass it to the destination along with your base64 encoded data
p27041
aVIn the simplest case, it could be a checksum of the text, but that scheme is easy to beat
p27042
aVA better approach is to prepare a digest of the original text using a cryptographic hash function, and pass that digest along with the base64 encoded text to the destination
p27043
aVKeep in mind that passing a digest will not prevent man-in-the-middle attacks, because the attacker can send his own digest along with a tampered message
p27044
as(dp27045
g6
V335858
p27046
stp27047
a((dp27048
g2
(lp27049
VFirst, you are casting the list, not the element that you get from it
p27050
aVAll you need to do is moving the parentheses to the right place:
p27051
aVThe way you placed the parentheses, Java tried casting  to  first, and after that attempted to call the  method on the  object
p27052
aVNext, you need to make a public method for looking at the front element of your queue: replace your
p27053
aVmethod with
p27054
aVSince  is , you should make it  to make it available to
p27055
as(dp27056
g6
V335858
p27057
stp27058
a((dp27059
g2
(lp27060
VInside class methods,  refers to the object representing the corresponding :
p27061
aVThis is the same object that you get in an instance method when you call
p27062
aVIt is useful if you would like to call methods on the  polymorphically
p27063
aVFor example, you can call  to create a new instance of the class on which the call is performed
p27064
as(dp27065
g6
V335858
p27066
stp27067
a((dp27068
g2
(lp27069
VThis query returns what you are looking for:
p27070
aVThe idea behind this solution is to partition the data by , and use the  function to decide which data to keep
p27071
aVI used  in the  sub-clause, which is not ideal
p27072
aVIf your actual table has a column with data that is better suited to determine what row is first, e
p27073
ag303
aVa timestamp column, you should use that other column instead
p27074
aVThe second column in the outer  needs to be the same as the column in the inner
p27075
aVHere is a link to this query on sqlfiddle
p27076
as(dp27077
g6
V335858
p27078
stp27079
a((dp27080
g2
(lp27081
V is a generic type parameterized on itself, so you can use its type parameter, like this:
p27082
as(dp27083
g6
V335858
p27084
stp27085
a((dp27086
g2
(lp27087
VYour current code compiles, but it it fundamentally wrong:  is a type that can store a single character, not an entire string
p27088
aVTherefore,  would point to a substring of a previously used string, each subsequent one overriding parts of previously entered ones
p27089
aVUnfortunately, string manipulation in C is far more complex than that - you need a 2D array or an array of pointers to do your task correctly:
p27090
aVNow you are ready to print:
p27091
aVFinally, you must free the data that you have allocated:
p27092
as(dp27093
g6
V335858
p27094
stp27095
a((dp27096
g2
(lp27097
VYou are almost there:
p27098
as(dp27099
g6
V335858
p27100
stp27101
a((dp27102
g2
(lp27103
VYou can use this expression for quick and dirty searches:
p27104
aVThis is not ideal, though: using an HTML or an XHTML parser is a much better solution, because it is much more powerful and robust than any regex-based solution
p27105
as(dp27106
g6
V335858
p27107
stp27108
a((dp27109
g2
(lp27110
VFirst, you should profile it
p27111
aVIt's only 500*100=50,000 operations at the max we're talking about
p27112
aVAn average modern computer is capable of finishing it off in under one-tenth of a second, unless you code it very inefficiently
p27113
aVAssuming that you would like to optimize it anyway, you should sort the master array, and run a binary search on it for each element of the randomized array
p27114
aVThis would reduce the number of operations from 50,000 to at most 900, because a binary search of 500 numbers requires at most 9 comparisons
p27115
aVHere is an implementation that uses built-in sorting and binary search functions ( and ) of the standard C library:
p27116
aVHere is a link to this running program on ideone
p27117
as(dp27118
g6
V335858
p27119
stp27120
a((dp27121
g2
(lp27122
VThis is a very good case for using regular expressions
p27123
aVYou string matches the following regexp:
p27124
aVMatch the input against this expression, and harvest the six groups of digits from the match:
p27125
aVIf you would like to allow for other characters, say, letters in the segments that are separated by dashes, you could use  instead of  to denote a letter, a digit, or an underscore
p27126
aVIf you would like to allow an unspecified number of such characters within a known range, say, two to four, you can use  in the regexp instead of the more specific , which means "exactly two"
p27127
aVFor example,
p27128
aVlets the first segment contain two to three digits or letters, and also allow for letters in segments two and three
p27129
as(dp27130
g6
V335858
p27131
stp27132
a((dp27133
g2
(lp27134
VYou cannot avoid constructing a key, but you can avoid constructing the entire key
p27135
aVFor example, let's say that you have a key class  that encapsulates an , and caches the computed hash code
p27136
aVFurther suppose that you provide implementations of  and  that access the cached hash code off your , and compare encapsulated vectors for equality
p27137
aVYou can define a constructor of  that always constructs an empty , and sets the cached hash code to a value passed to the constructor:
p27138
aVWith a key class like that, you can quickly find buckets by constructing a fake key:
p27139
as(dp27140
g6
V335858
p27141
stp27142
a((dp27143
g2
(lp27144
VYou need to escape the slash on front of the :
p27145
aVDepending on what output you would like to achieve, you may need to escape the remaining slashes as well
p27146
aVCurrently, the snippet produces a sequence of six characters with the code
p27147
aVIf this is what you want, your code fragment is complete
p27148
aVIf you would like to see a sequence of  literals, i
p27149
ag630
aVa string that looks like  when , you need to escape all slashes in the string:
p27150
aVFinally, if you would like the value formatted as a two-digit hex code even when the value is less than sixteen, use  format code to tell  that you want a leading zero
p27151
as(dp27152
g6
V335858
p27153
stp27154
a((dp27155
g2
(lp27156
VThe asterisk in C++ means many things depending on its place in the program
p27157
aVIn this specific instance, it modifies the meaning of  to be a pointer to an instance of , rather than an instance of
p27158
aVThe difference between the two is that the lifetime of an instance ends when it goes out of scope, while an instance that you allocate and reference through a pointer remains valid even after a pointer goes out of scope
p27159
aVIt is valid to have a declaration like this:
p27160
aVIn this case, it is not necessary to use , but the instance's life time is tied to the scope of the variable
p27161
as(dp27162
g6
V335858
p27163
stp27164
a((dp27165
g2
(lp27166
VYou can put all values in a set, and make sure that the set's cardinality equals the number of values that you put in:
p27167
as(dp27168
g6
V335858
p27169
stp27170
a((dp27171
g2
(lp27172
VI believe that weak variable or weak property is set to nil immediately after last strong variable or property was set to nil or another object
p27173
aVThis is not exactly true, because an object could be autoreleased
p27174
aVIn this case, the last strong reference may be gone, but the reference count of the instance would remain positive
p27175
aVIn cases like that, the  reference would not be -ed out until the autorelease process takes place
p27176
aVIs using weak variable or property to check if object is deallocated a technique commonly used
p27177
aVI seriously doubt that this technique has gained much popularity, because ARC is a relatively new thing to Objective C
p27178
aVHowever, the technique appears valid
p27179
aVIs it possible that this code will cause problem in the future
p27180
aVThis is very hard to guess, because the ARC Specification does not make any specific guarantees about the timing of -ing out the references, and because the spec allows compilers to optimize sequences of  and  messages that they send to ARC objects
p27181
as(dp27182
g6
V335858
p27183
stp27184
a((dp27185
g2
(lp27186
VYou should not use anchor elements  and
p27187
aVThey mean the beginning and the end of the entire input, not the beginning and the ending of the word
p27188
aVYou should also replace the dot  with  (meaning "anything but ") to make your expression more efficient
p27189
aVIf you would like to avoid replacing tagged elements inside a word, e
p27190
ag303
aVif you want to preserve  as is, rather than making it , you can put in markers of word boundaries  on both ends of the expression:
p27191
as(dp27192
g6
V335858
p27193
stp27194
a((dp27195
g2
(lp27196
VYour code is not correct, because it is possible that the input would end without providing an empty line
p27197
aVYou should check if a line is available before checking it for being empty:
p27198
as(dp27199
g6
V335858
p27200
stp27201
a((dp27202
g2
(lp27203
VC++ does not have a "root type" similar to C#'s
p27204
aVYou can use  to emulate the concept, but that requires using an external library
p27205
aVAs far as passing parameters by reference, you could pass by reference in C++ by using  syntax, or pass by pointer
p27206
as(dp27207
g6
V335858
p27208
stp27209
a((dp27210
g2
(lp27211
VThe problem is that your  does not modify the  member variable of your list, because the  variable inside  is a method parameter, not the instance variable
p27212
aVHere is what you need to do:
p27213
aVExposing  as a public member of the  is a violation of encapsulation
p27214
aVMake  a private variable
p27215
aVRemove parameter  from all methods that take it; use the private member  instead
p27216
aVAdd a check in  to see if the spot to be deleted is the
p27217
aVIf it is, perform a special operation that assigns  a new value, and exit; otherwise, do the  loop that you already have
p27218
as(dp27219
g6
V335858
p27220
stp27221
a((dp27222
g2
(lp27223
VI thin the spaces should be removed, like this:
p27224
aVOtherwise, space characters become part of the string that you match (i
p27225
ag630
aV13 digits followed by a space, or a space followed by ten digits)
p27226
aVYou could also try simplifying the expression like this:
p27227
aV(required ten plus three optional digits)
p27228
as(dp27229
g6
V335858
p27230
stp27231
a((dp27232
g2
(lp27233
VYou can use regular expressions for that
p27234
aVThe expression that you need looks like this:
p27235
aVThis prints out
p27236
as(dp27237
g6
V335858
p27238
stp27239
a((dp27240
g2
(lp27241
VI am assuming that you would like to store individual tokens in an array
p27242
aVAs is currently declared,  is an array of pointers to pointers
p27243
aVThat is not what you want for an array of C strings - you need to remove one asterisk:
p27244
aVNote that  needs to start at , not at , because the number of tokens that you are going to get is one greater than the number of spaces that you will find in the string
p27245
aVOnce you do, your program would still need some fixing in the way it deals with results of : you should not store results for use after the next call of , because these results become invalid
p27246
aVInstead, you should make duplicates of tokens before storing them in the  array:
p27247
as(dp27248
g6
V335858
p27249
stp27250
a((dp27251
g2
(lp27252
VYes:
p27253
aVproduces a list with the two elements that you specified
p27254
aVYou can pass that list to a function or do anything else with it
p27255
aVNote that if your target function takes  rather than a , you could shorten the syntax some more by sending a new array of s, because arrays  implement their corresponding  interface
p27256
as(dp27257
g6
V335858
p27258
stp27259
a((dp27260
g2
(lp27261
Vin C++, the name of an array is just the pointer to the first element of the array
p27262
aVThat's not correct: a name of an array can be converted to a corresponding pointer type "for free", but it is definitely not a pointer
p27263
aVThe easiest way you can tell is by comparing sizes of a pointer and of an array:
p27264
aVYour second example is a pointer to an array of s of size 5
p27265
aVIn a 32-bit environment this prints  and , as expected
p27266
as(dp27267
g6
V335858
p27268
stp27269
a((dp27270
g2
(lp27271
VImporting  is necessary, but not sufficient: you need to add a reference to  to your project in order for your target to link
p27272
aVIn Xcode, open the project, and choose your main target
p27273
aVOn the "Summary" page, find "Linked Frameworks and Libraries", and click [+] at the bottom
p27274
aVSelect "AudioToolbox
p27275
aVframework", and click [Add]
p27276
aVThis should fix the linking error
p27277
as(dp27278
g6
V335858
p27279
stp27280
a((dp27281
g2
(lp27282
VAssuming that your  directive looks like this
p27283
aVyou do not need to do anything in addition to what you are already doing: your property stores its value in the instance variable of the same name
p27284
aVEDITED : Removed the alternative that suggests setting  in the  method
p27285
as(dp27286
g6
V335858
p27287
stp27288
a((dp27289
g2
(lp27290
VThe compiler must treat  as changeable unless you say otherwise
p27291
aVDeclaring it  fixes the problem:
p27292
as(dp27293
g6
V335858
p27294
stp27295
a((dp27296
g2
(lp27297
VThe cleanest approach would be to hide a list behind a class that lets you enumerate over the content, and provides additional methods for identifying the primary item:
p27298
aVAn even cleaner implementation would encapsulate the list inside your  class, and expose only the methods that you want exposed:
p27299
as(dp27300
g6
V335858
p27301
stp27302
a((dp27303
g2
(lp27304
VWhen declaring , you missed the asterisk:
p27305
aVWith a mutable string in hand, you can do
p27306
aVto make  equal
p27307
aVYou do not have to go through a mutable string - this will also work:
p27308
as(dp27309
g6
V335858
p27310
stp27311
a((dp27312
g2
(lp27313
VTry using a join and a group by, like this:
p27314
aVNote that you need to use  in place of  because the condition uses an aggregation
p27315
aVHere is a link to a demo on sqlfiddle
p27316
as(dp27317
g6
V335858
p27318
stp27319
a((dp27320
g2
(lp27321
VThe trailing quote is fine, it should be there
p27322
aVIt's the one after the equal sign that is missing
p27323
aVThe imbalance of quotes happens because you are removing the initial quote, not because you are inserting a trailing one:
p27324
as(dp27325
g6
V335858
p27326
stp27327
a((dp27328
g2
(lp27329
VPretending there is no problem of SQL injection here*, you can quickly fix your code by adding quotation marks around
p27330
aVThe value of  should be
p27331
aVinstead of simply
p27332
aVYou need to add quotation marks around each string value; otherwise, strings are interpreted as names, which is not valid
p27333
aVEDIT : (in response to a comment) If all columns are of  type, you can put quotes around the entire string, and replace all commas with the quote-comma-quote pattern, like this:
p27334
aV* You should not put code like this into production, because it can be manipulated to harm your system rather severely
p27335
aVHere is a good illustration of the problem (link)
p27336
as(dp27337
g6
V335858
p27338
stp27339
a((dp27340
g2
(lp27341
VI do not know a good solution without string preprocessing, but if  is acceptable, you can use this code snippet:
p27342
aVThis code appends two zeros to strings ending in  (link to ideone)
p27343
as(dp27344
g6
V335858
p27345
stp27346
a((dp27347
g2
(lp27348
VIt is a multiplication by , modulo :
p27349
aVYou can detect the bits that got "shifted out" by performing a shift left followed by masking, in this case
p27350
as(dp27351
g6
V335858
p27352
stp27353
a((dp27354
g2
(lp27355
VBruce is trying to illustrate object slicing, a situation when a polymorphic object is passed by value
p27356
aVHere is how you can do it:
p27357
aVThis code outputs (link to ideone)
p27358
aVeven though you'd expect an object of type  to "say" , not
p27359
aVC++ compiler is smart in noticing that  is passed to  by value, so it adjusts the vtable to avoid calls of methods in the derived class
p27360
aVBonus exercise to test if you understand passing by reference: can you modify my code so that it prints
p27361
aVYou are allowed to insert a single character
p27362
as(dp27363
g6
V335858
p27364
stp27365
a((dp27366
g2
(lp27367
VYou get the warning because you did not assign a value to , which is a pointer
p27368
aVThis is undefined behavior
p27369
aVYou should declare it like this:
p27370
aVor like this:
p27371
aVin which case you need to replace  operator with  like this:
p27372
aVFinally, in C99 and later you can use designated initializers:
p27373
as(dp27374
g6
V335858
p27375
stp27376
a((dp27377
g2
(lp27378
VWhat value does this function return
p27379
aVneeds to be declared as returning an
p27380
aVThe return value is passed to the caller, which is usually the operating system
p27381
ag10442
ag1340
ag839
ag839
aV1 Program startup
p27382
aVThe function called at program startup is named main
p27383
aVThe implementation declares no
p27384
aVprototype for this function
p27385
aVIt shall be defined with a return type of int and with no
p27386
aVparameters:
p27387
aVor with two parameters (referred to here as argc and argv, though any names may be
p27388
aVused, as they are local to the function in which they are declared):
p27389
aVand if a function has two mains , what happens
p27390
aVLinker reports an error
p27391
as(dp27392
g6
V335858
p27393
stp27394
a((dp27395
g2
(lp27396
VWhen  is zero, you access the array at index  which equals ; that's one beyond the last valid index for the array, which is  through
p27397
aVThis will fix the problem:
p27398
as(dp27399
g6
V335858
p27400
stp27401
a((dp27402
g2
(lp27403
VWhat you call "ARC code" (, , etc
p27404
aVis actually manual reference counting, not automatic
p27405
aVIf you are compiling with no ARC, you need to  or copy the object as required
p27406
aVIf you are under ARC, the compiler will take care of it for you
p27407
aVSpecifically, the compiler will retain  if  is declared
p27408
as(dp27409
g6
V335858
p27410
stp27411
a((dp27412
g2
(lp27413
VYou can add
p27414
aVto remove the last word and the space preceding it
p27415
aVHere is a link to ideone with a running example
p27416
as(dp27417
g6
V335858
p27418
stp27419
a((dp27420
g2
(lp27421
VThere are two "wrap-around" issues in your program:
p27422
aVYour letters do not wrap around when the key and the current letter combine to produce a value beyond 26, and
p27423
aVYou read past the end of the key when the length of the word being encrypted exceeds the length of the key
p27424
aVHere is how you fix it: right after copying the key into , do this:
p27425
aVNow inside your loop do this:
p27426
aVThis will make the output look "normal"
p27427
aVOnce you figure out how the last formula works, you should be able to modify it to decode the word
p27428
as(dp27429
g6
V335858
p27430
stp27431
a((dp27432
g2
(lp27433
VYou should do it in the constructor of your class, like this:
p27434
aVNo matter how you construct , its  member will not be
p27435
aVYou should call the second overload of the constructor in place of the  syntax, this way you'd be able to make setters private (usually, it is a good thing to do)
p27436
as(dp27437
g6
V335858
p27438
stp27439
a((dp27440
g2
(lp27441
VThis is not equating two pointers, it is a pointer assignment
p27442
aVOnce
p27443
aVis executed, both pointers point to the same area of memory: accessing  becomes exactly the same as accessing ,  becomes equivalent to , and so on
p27444
aVNote that freeing  leaves  dangling, and vice versa
p27445
aVIn other words, after calling
p27446
aVaccessing  becomes undefined behavior
p27447
as(dp27448
g6
V335858
p27449
stp27450
a((dp27451
g2
(lp27452
VThe reason this happens is that  is a value type
p27453
aVIn order to coerce an expression returning a value type into  the compiler needs to insert a , a
p27454
aVFor s and other reference types, however, there is no need to box, so a "straight" member expression is returned
p27455
aVIf you would like to get to the  inside the , you can get its operand:
p27456
as(dp27457
g6
V335858
p27458
stp27459
a((dp27460
g2
(lp27461
VYou get a strange output because array's  method does not show the string containing individual members of the array; instead, it shows a strange string starting in  for arrays of primitive type
p27462
aVYou should prepare the string manually, or call , like this:
p27463
as(dp27464
g6
V335858
p27465
stp27466
a((dp27467
g2
(lp27468
VAll integer literals are of type , so your variable will be  unless you cast or add an explicit type qualifier at the end:
p27469
as(dp27470
g6
V335858
p27471
stp27472
a((dp27473
g2
(lp27474
VYou need to implement an algorithm for approximate matching of strings
p27475
aVOne of the most popular such algorithms is Levenshtein distance, one of several Edit distance algorithms
p27476
aVThe distance is calculated as the number of editing operations required to transform string A into string B - inserting, deleting, or changing a character counts as one edit operation
p27477
aVThe closer are the strings, the smaller is the edit distance between them
p27478
aVYou can calculate pairwise edit distances, and find the smallest one to identify the match
p27479
as(dp27480
g6
V335858
p27481
stp27482
a((dp27483
g2
(lp27484
VThe best way to tell is to try it out
p27485
aVHowever,  does not strike me as a particularly large or even as a marginally large number
p27486
aVConsider this: 1GHz CPU runs a billion elementary operations per second
p27487
aVEven if each lookup takes 100 elementary operations (in reality, it takes much fewer than that) a search of  items should complete in very short time, on the order of milliseconds
p27488
as(dp27489
g6
V335858
p27490
stp27491
a((dp27492
g2
(lp27493
VYou are almost there: you have added up the results for the left and the right subtree, but you have forgotten to add the result for the node itself:
p27494
as(dp27495
g6
V335858
p27496
stp27497
a((dp27498
g2
(lp27499
VThere's no hiding from reflection - even immutable classes are not immune
p27500
aVThere is nothing you can do about it, though, so "cannot be modified through reflection" is not one of the criteria of immutability
p27501
as(dp27502
g6
V335858
p27503
stp27504
a((dp27505
g2
(lp27506
VAssuming that this is a homework, here are a few points that should get you there:
p27507
aVThe substring that you are looking for starts one character after the  sign
p27508
aVThe server name ends with the first dot  in the string
p27509
aVYou take a substring with (you guessed it right
p27510
aVthe  method
p27511
aVThe first index in  is inclusive; the second indes is not inclusive
p27512
aVYou find the index of a character by using  method, substituting  for the character that you search
p27513
as(dp27514
g6
V335858
p27515
stp27516
a((dp27517
g2
(lp27518
VVB
p27519
aVNET and C# are different languages, so it is natural that the LINQ query syntax is different, too: C# requires , while VB
p27520
aVNET does not
p27521
aVMicrosoft's documentation requires that a query syntax query in C# must end in  or :
p27522
aVA query expression must begin with a from clause and must end with a select or group clause
p27523
aVBetween the first from clause and the last select or group clause, it can contain one or more of these optional clauses: where, orderby, join, let and even additional from clauses
p27524
aVYou can also use the into keyword to enable the result of a join or group clause to serve as the source for additional query clauses in the same query expression
p27525
aVSee C# language specification, section 7
p27526
aV16, for details on the syntax
p27527
aVYou do not have to add  if you use the function syntax:
p27528
as(dp27529
g6
V335858
p27530
stp27531
a((dp27532
g2
(lp27533
VYou need to iterate over the list elements using the  syntax, not the  syntax:
p27534
aVIn situations when you want to go through all elements of the list, you do not need an index variable
p27535
aVThe for each syntax added in Java 5 lets you go through the list more easily
p27536
as(dp27537
g6
V335858
p27538
stp27539
a((dp27540
g2
(lp27541
VThe  function has no idea of the structure behind the block of memory being released
p27542
aVA call to  releases only the block pointed to by the pointer passed as its argument
p27543
aVIn your case, you need to release  first, and then the  itself:
p27544
as(dp27545
g6
V335858
p27546
stp27547
a((dp27548
g2
(lp27549
VThe comment in  is for the use of
p27550
aVYou can leave it  if you do all your localizations yourself
p27551
aVOtherwise, you should make an effort to add a meaningful piece of information to help the people who do localizations for you
p27552
aVImproving their understanding of the context in which the translation is to be made has direct impact on the quality of the translations that you are going to get
p27553
as(dp27554
g6
V335858
p27555
stp27556
a((dp27557
g2
(lp27558
VHere is what you do:
p27559
aVOnce this loop is over, prompt for the radius
p27560
aVYou will nearly certainly need another loop to prevent the input of negative values for the radius, so do not prompt for it in the same loop
p27561
as(dp27562
g6
V335858
p27563
stp27564
a((dp27565
g2
(lp27566
VAssuming that the floating point value is stored in a string column, you can use the  function of SQLite:
p27567
aVSQLite will do an automatic conversion for you, but using a column of a floating-point type would be a better choice
p27568
as(dp27569
g6
V335858
p27570
stp27571
a((dp27572
g2
(lp27573
VYou can read strings from a stream using , and then to a split by finding the firs position of a space character  within the string, and using the  function twice (for the command to the left of the space and for the data to the right of space)
p27574
aVHere is a link to a demo on ideone
p27575
as(dp27576
g6
V335858
p27577
stp27578
a((dp27579
g2
(lp27580
VThe reason has to do with coding to an interface: if you code to , you have better assurance that you can switch to a different brand of RDBMS later, should there be a need to do so
p27581
aVIf you code to , on the other hand, your code may still be easy to port to use with, say, Oracle, but you would have less confidence of that (and you will have to do the porting, too)
p27582
as(dp27583
g6
V335858
p27584
stp27585
a((dp27586
g2
(lp27587
VYou should pass the address of , not the  itself:
p27588
as(dp27589
g6
V335858
p27590
stp27591
a((dp27592
g2
(lp27593
VNo, this is not possible: variable number of arguments is implemented as a "syntactic sugar" on top of passing an array; it is not possible to create an array of pass-by-reference parameters, because "is passed by reference" is not a property of a type
p27594
as(dp27595
g6
V335858
p27596
stp27597
a((dp27598
g2
(lp27599
VSince everything in your example is public, the error probably applies to the class itself
p27600
aVTry making the Spreadsheet class public, and see if it fixes the error
p27601
as(dp27602
g6
V335858
p27603
stp27604
a((dp27605
g2
(lp27606
VYour code masks the problem of the original string containing an end-of-line marker:
p27607
aVThis line chops off the trailing zero
p27608
aVThe comment is wrong, by the way:  does not include the , it includes
p27609
aVThis line ignores the trailing  because of  subtracts  again, even though you have subtracted it when you first called the function:
p27610
aVYou should do this:
p27611
aVNow you can correct your palindrome checker as follows:
p27612
as(dp27613
g6
V335858
p27614
stp27615
a((dp27616
g2
(lp27617
VAll instances of  will indeed share the same "pointer" to the method look-up table
p27618
aVHowever, the precise size of the object depends on the content of the  and the  above it
p27619
aVThe anonymous class the compiler generates provides space for storing the variables referenced by the  method, in addition to space for storing a reference to the  object of the enclosing class
p27620
aVFor example,
p27621
aVreserves the space in the object to store , , and ; each instance of the anonymous object will get a copy of these variables
p27622
as(dp27623
g6
V335858
p27624
stp27625
a((dp27626
g2
(lp27627
VTwo instantiations of a generic class with different type parameters will result in two independent classes, each with its own set of static variables
p27628
aVSo the answer is yes, the static variables  and  will be independent
p27629
aVIf you would like an opposite behavior (i
p27630
ag630
aVall generic classes sharing the same static variable) move the variable declaration into a non-generic class, and make it the base class of your generic, like this:
p27631
aVNow all instances of  will share the same , regardless of their type parameters
p27632
as(dp27633
g6
V335858
p27634
stp27635
a((dp27636
g2
(lp27637
VTry this:
p27638
aVThe idea is to tag the original items with their collection origin ( for English,  for German,  for Spanish), group them by ID, and then pull the details for individual languages using the tag that we added in the first step
p27639
as(dp27640
g6
V335858
p27641
stp27642
a((dp27643
g2
(lp27644
VI read that that virtual destructors must be declared in classes that have virtual methods
p27645
aVmust" is too strong a word: "should" fits much better into that advise
p27646
aVI just wanted to know why compilers dont manage virtual destructors for us
p27647
aVC++ designers tried to avoid compiler doing things that you did not ask it to do only under the most extreme circumstances
p27648
aVLanguage designers recognized that the decision to make a class polymorphic should rest with the designer of the program, so they refused to re-assign this responsibility to the compiler
p27649
aVThe following example shows that if destructors are not declared virtual the destructors of derived class are not called why is that
p27650
aVBecause your code is invalid: by declaring the destructor of  non-virtual you made a promise to never destroy  through a pointer to ; your  breaks this promise, invoking undefined behavior
p27651
aVNote that by merely declaring your  variable with the exact type you would have avoided the problem associated with the non-virtual destructor (link to ideone)
p27652
aVHowever, this leads to a rather shaky design, so you should avoid inheritance hierarchies with virtual functions and non-virtual destructors
p27653
as(dp27654
g6
V335858
p27655
stp27656
a((dp27657
g2
(lp27658
VI think you need to double the slashes in front of your s:
p27659
aVThis prints
p27660
as(dp27661
g6
V335858
p27662
stp27663
a((dp27664
g2
(lp27665
VBefore you use pointers, you need to allocate memory
p27666
aVAssuming that  is assigned a value already, you should calculate the length of the result string, allocate memory, do , and then , like this:
p27667
as(dp27668
g6
V335858
p27669
stp27670
a((dp27671
g2
(lp27672
VYour code creates instances of  using the default constructor, without passing anything that you get from the DB to it
p27673
aVThat is why you get a list of identical empty items; sorting them has no effect
p27674
aVRemove the first  to make it work:
p27675
aVYour first  forces the data into memory, where  can be applied
p27676
aVYou can replace it with an  call as well, to avoid creating a list in memory for the second time:
p27677
as(dp27678
g6
V335858
p27679
stp27680
a((dp27681
g2
(lp27682
VThe complexity of creating a trie is , where  is the number of words, and  is an average length of the word: you need to perform  lookups on the average for each of the  words in the set
p27683
aVSame goes for looking up words later: you perform  steps for each of the  words
p27684
aVHash insertions and lookups have the same complexity: for each word you need to check equality, which takes , for the overall complexity of
p27685
aVIf you need to look up entire words, hash table is easier
p27686
aVHowever, you cannot look up words by their prefix using a hash table; If prefix-based lookups are of no interest to you, use a hash table; otherwise, use a trie
p27687
as(dp27688
g6
V335858
p27689
stp27690
a((dp27691
g2
(lp27692
VYes,  header provides the  manipulator, letting you set the width of each field that you output to an
p27693
aVUsing  manipulator for each row instead of tab characters would provide tighter control over the output:
p27694
aVTo align strings on the left, add  manipulator:
p27695
as(dp27696
g6
V335858
p27697
stp27698
a((dp27699
g2
(lp27700
VYou can use regular expressions to do simple lexical analysis, like this:
p27701
aVThe heart of this solution is the following regular expression (quotes are un-escaped for readability):
p27702
aVIt has two capturing groups - the first one for flags or commands, and the second one (after the pipe symbol '|') for quoted strings
p27703
aVOnce the expression "sees" a quotation mark, it captures everything until the closing quote is found
p27704
aVThe capturing group strips both quotes by keeping them outside the parentheses
p27705
aVLink to ideone
p27706
as(dp27707
g6
V335858
p27708
stp27709
a((dp27710
g2
(lp27711
VI think a list of lists should work fine:
p27712
aVYou can insert new rows like this:
p27713
aVor insert a new element in a specific row:
p27714
aVNote that you need to have enough elements in your list in order to call an ; otherwise, you will get an out-of-range exception
p27715
aVThe easiest way to address this is to write a small utility method that adds empty items until the insertion is possible:
p27716
aVRewrite your program as follows:
p27717
as(dp27718
g6
V335858
p27719
stp27720
a((dp27721
g2
(lp27722
VYou can skip all characters to the first space, and then skip the space itself, like this:
p27723
aVThis code fragment prints  (link to ideone)
p27724
as(dp27725
g6
V335858
p27726
stp27727
a((dp27728
g2
(lp27729
VYou get this result because of an integer overflow: in a two's complement system of representing negative integers, taking the max value which is 2 and multiplying it by  gives you 2, which corresponds to
p27730
as(dp27731
g6
V335858
p27732
stp27733
a((dp27734
g2
(lp27735
Vis there a standard way of handling this
p27736
aVYes: make configuration process part of the initialization
p27737
aVInstead of exposing , perform all initialization in the constructor
p27738
aVThis will let your classes expose only the alternatives that make sense:
p27739
as(dp27740
g6
V335858
p27741
stp27742
a((dp27743
g2
(lp27744
VYou cannot consolidate facts, but you can turn them into a simple rule, like this:
p27745
aVis a built-in list predicate in SWI to test list membership
p27746
as(dp27747
g6
V335858
p27748
stp27749
a((dp27750
g2
(lp27751
VSince both sides of the conditional use the same key, you can cheat:
p27752
aVIn general case, however, you would end up with a considerably uglier, repetitive, statement:
p27753
as(dp27754
g6
V335858
p27755
stp27756
a((dp27757
g2
(lp27758
VAssuming that the idea is to use  in the context of , your code is perfectly valid
p27759
aVSince  does not care for the returned value to be  or  and would take any positive or negative number, this version is even shorter, but would work with  just as well:
p27760
aVThe reason  uses  is to let you use the same algorithm with different data types
p27761
as(dp27762
g6
V335858
p27763
stp27764
a((dp27765
g2
(lp27766
VThe reason you get a crash is that the NSDate* object is not initialized
p27767
aVYou need to assign it an instance representing the current date:
p27768
as(dp27769
g6
V335858
p27770
stp27771
a((dp27772
g2
(lp27773
VThe overlap effect can be achieved visually by composing your cell of two parts: a narrow one on the top and a wide one on the bottom
p27774
aVThe bottom part is simple: it is a grey rectangle with a text/image component inside
p27775
aVThe trick is in the part on the top
p27776
aVThe height of the top part equals the height of the entire colored tab
p27777
aVYour program can put one of two images there - either a tab on top of a narrow gray strip representing the bottom of the prior cell, or a tab on top of a brown background
p27778
aVInside your  check the
p27779
aVIf it is zero, pick the image with the brown background; otherwise, pick the image with the grey strip in the background at the top
p27780
as(dp27781
g6
V335858
p27782
stp27783
a((dp27784
g2
(lp27785
VIf you know the precise layout of the input, and the exact number of s, you can simplify this greatly:
p27786
aVHere is a link to a demo on ideone
p27787
as(dp27788
g6
V335858
p27789
stp27790
a((dp27791
g2
(lp27792
VA call of  returns an empty  if the parameter called  exists but has no value, and  is returned if there was no such parameter
p27793
as(dp27794
g6
V335858
p27795
stp27796
a((dp27797
g2
(lp27798
VIf all you have is two numbers, you do not need an array:  provides functions to find the smaller and the larger of two numbers, called  and
p27799
as(dp27800
g6
V335858
p27801
stp27802
a((dp27803
g2
(lp27804
VAlthough  is in fact an , that is not the same as saying that  is in fact a : the covariance of generics is not there
p27805
aVChanging the declaration
p27806
aVto one with wildcard
p27807
aVwill make your code compile, and attempts to get things from the  map will work:
p27808
aVHowever, attempts to add things to the map would fail:
p27809
aVObject blah = foo
p27810
aVput("key");
p27811
aVSince putting things in the map appears to be the goal of your method (after all, there must be a reason why you called it ) you wouldn't be able to make it work without specifying the exact type
p27812
as(dp27813
g6
V335858
p27814
stp27815
a((dp27816
g2
(lp27817
VIf you need the  statement to contain only the , you need to remove its , like this:
p27818
as(dp27819
g6
V335858
p27820
stp27821
a((dp27822
g2
(lp27823
VBefore ARC you needed to manually release objects that you allocated
p27824
aVSetting a property that is marked  to  does the releasing
p27825
aVThis is no longer necessary when you use the Automatic Reference Counting (ARC) feature, which is on by default in the compiler that comes with recent versions of Xcode
p27826
as(dp27827
g6
V335858
p27828
stp27829
a((dp27830
g2
(lp27831
VYour makefile is incorrect - it compiles  with a dependency on , but it does not link  at all
p27832
aVThat is why the compilation of  results in an unresolved reference
p27833
aVYou should change your make file as follows:
p27834
as(dp27835
g6
V335858
p27836
stp27837
a((dp27838
g2
(lp27839
VYou cannot execute an expression tree without compiling it first because expression trees serve a different purpose: they work as flexible blueprints for executable code, rather than being the the executable code itself (with is rather inflexible)
p27840
aVAn expression tree is a data structure that describes code (compiled or not) at an abstraction level that is higher than the code itself
p27841
aVUnlike code, the data structure can be manipulated to make a different structure that describes some other piece of code
p27842
aVUnlike the data structure, the code can be evaluated to produce a result
p27843
aVConsider this example:
p27844
aVIt shows an expression  being created, describing a simple expression tree
p27845
aVAt this point, we have a tree-like data structure with three nodes - two nodes representing parameters, and one node representing addition
p27846
aVWe can do lots of things with the expression tree, such as examining its content, finding its return type, and so on
p27847
aVWe can even manipulate its structure to make other expressions based on it: for example, we could add a third parameter, and make , like this:
p27848
aVOne thing we cannot do, however, is pass it two integer values and obtain their sum: expression trees do not provide methods for evaluating them
p27849
aVIn order to do that, you need real code, not a description of code
p27850
aVExpression trees provide a way to convert descriptions of code into code by way of compiling them
p27851
aVOnce you make an expression tree into lambda and call the  method on it, you get back a compiled CIL code that looks like this:
p27852
aVThis code can be passed two values for evaluation, and it will return the sum to you
p27853
aVHowever, some information is lost in translation: specifically, the names of parameters  and  are no longer there in the compiled code: they are not necessary to perform calculations, so they have been eliminated
p27854
as(dp27855
g6
V335858
p27856
stp27857
a((dp27858
g2
(lp27859
VUse SQLite
p27860
aVIt is ideal for situations like yours, and does not require a separate installation
p27861
aVAll you need is a library and a file with the seed database
p27862
aVBoth of these can be installed as part of installing your product
p27863
as(dp27864
g6
V335858
p27865
stp27866
a((dp27867
g2
(lp27868
VConversion of  to string is , where  is the number of digits in the result, when the base of the internal representation does not divide the target base; when the target base is divisible by the storage base, conversion takes
p27869
aVConsider conversion to base 10 when the internal representation is base-256
p27870
aVA division by ten has to happen  times; each time, all elements of the  representation get modified
p27871
aVThe number of elements in the representation is proportional to the number of digits in the printout, so the overall conversion takes
p27872
aVOn the other hand, converting to hex of a big int in base-256 internal representation takes , because division is not necessary in this case
p27873
aVEach subelement can be converted in isolation from the remaining ones, and the number of sub-elements is proportional to the number of digits in the printout
p27874
aVAs far as  goes, it's , where  is the number of characters in the string, because each character must be copied into the output
p27875
as(dp27876
g6
V335858
p27877
stp27878
a((dp27879
g2
(lp27880
VYour loop does not make sense: as soon as you return, looping is over
p27881
aVEssentially, your program is equivalent to this:
p27882
aVIf you would like to return multiple items from a method, return an array or a Java collection:
p27883
as(dp27884
g6
V335858
p27885
stp27886
a((dp27887
g2
(lp27888
VAssuming that the items inside are  objects, you can do it like this:
p27889
as(dp27890
g6
V335858
p27891
stp27892
a((dp27893
g2
(lp27894
VNo, or at least not directly: in Java you cannot inherit from an instance; you need to inherit from a class
p27895
aVHowever, you can build an anonymous class wrapping an instance returned from the builder
p27896
aVYou can call methods on the wrapped instance as you see fit, while overriding the ones that you need to override
p27897
aVAt this point,  behaves just like the  instance, except for the
p27898
aVAn unfortunate consequence is that you cannot access protected members of the
p27899
as(dp27900
g6
V335858
p27901
stp27902
a((dp27903
g2
(lp27904
V is a container for error information, it does not do anything on its own
p27905
aVThe class is designed so that different parts of your code could communicate error information to each other in a standardized way
p27906
aVSimply setting an error inside a method that takes  does nothing - it's the responsibility of the caller to check if  is non-, skip to the end of the method, display localized description, prompt the user for an action, and so on
p27907
aVHowever,  is flexible enough to enable you to do all that: the caller can provide pretty much any kind of information; you can track recovery attempts, display localized messages to the user, or store additional information in the  object, and return it further down the call chain
p27908
aVNote: Cocoa framework methods generally require that you check the direct return value before using the , not checking whether the error is
p27909
aVThe error is guaranteed to be valid if the method indicates failure, but it is not guaranteed to be  for success, even if you set it to  beforehand
p27910
as(dp27911
g6
V335858
p27912
stp27913
a((dp27914
g2
(lp27915
VYou should not be using : it converts a string to , not a single
p27916
aVHere is what happens: when you see a two-digit number, say, , the first iteration pssses both digits to , gets , and multiplies it by ten, making
p27917
aVThe following iteration picks up , and happily adds it to , for the cumulative result of
p27918
aVIf you would like to convert a single  that represents a digit to an , use subtraction:
p27919
aVMoreover, your code for handling multi-digit numbers is, well, unorthodox, making it hard to understand
p27920
aVInstead of multiplying the current value by ten when you see that the next character is a digit, you should multiply the prior value by ten when you see a digit
p27921
aVThis works even for the first digit, when the prior value is , because ten times zero is still a zero
p27922
aVYou should eliminate the  and its  branch, and modify its  branch as follows:
p27923
as(dp27924
g6
V335858
p27925
stp27926
a((dp27927
g2
(lp27928
VA quick and dirty way of removing duplicates is as follows:
p27929
aVThis eliminates all rows where a duplicate  with a numerically smaller ID exists
p27930
as(dp27931
g6
V335858
p27932
stp27933
a((dp27934
g2
(lp27935
VYour algorithm implements the most primitive version of the classic bucket sort algorithm (its counting sort implementation)
p27936
aVIt is the fastest possible way to sort numbers when their range is known, and is (relatively) small
p27937
aVSince zeros and ones is all you have, you do not need an array of counters that are present in the bucket sort: a single counter is sufficient
p27938
as(dp27939
g6
V335858
p27940
stp27941
a((dp27942
g2
(lp27943
VThe loop with  exhibits undefined behavior, because it assumes that the allocations done by the loop on the third line are contiguous, but in nearly all implementations they are not
p27944
aVYour code with  retrieves the correct result
p27945
aVYou can fix the other code by allocating  elements in a single shot, and then parceling them out into  in a loop
p27946
as(dp27947
g6
V335858
p27948
stp27949
a((dp27950
g2
(lp27951
VI am not familiar with this particular kind of assembly, but printing out a binary is relatively easy in all architectures if you shift values left, and check the carry flag
p27952
aVWhen you shift a register left, its most significant bit ends up in
p27953
aVNow set another register to zero, and rotate it left immediately after shifting the source value left
p27954
aVThe most significant bit of the original value is now in the least significant bit of the register:
p27955
aVOutput the register, set it back to zero, and continue on
p27956
aVThis will output the bits in the correct order
p27957
aVNote that this trick is available only to assembly programmers
p27958
aVIt is inaccessible to C/C++ programmers, because the carry flag  is out of their reach
p27959
as(dp27960
g6
V335858
p27961
stp27962
a((dp27963
g2
(lp27964
VYou can make it work as follows:
p27965
aVThe reasoning is that I will eventually upgrade to SQL Server and don\u2019t want to change my method parameters or code so much
p27966
aVI think this is the key issue that you are trying to solve
p27967
aVRather than programming to the specific class, program to an interface
p27968
aVSpecifically, using  instead of  or  would let you hide the exact type better than encapsulating it in the
p27969
as(dp27970
g6
V335858
p27971
stp27972
a((dp27973
g2
(lp27974
VWhat you call "some prototypes for functions including " is a function pointer
p27975
aVYou can invoke a function pointed to by the pointer as if the pointer represented that function's name
p27976
aVThe inner-most structure has been set up with a pointer to some function; your code snippet invokes that function through its pointer
p27977
aVHere is a short example that illustrates how this works (also on ideone):
p27978
as(dp27979
g6
V335858
p27980
stp27981
a((dp27982
g2
(lp27983
VThere's no "crazy code" required, it's a relatively straightforward:
p27984
aVOn ideone: link
p27985
as(dp27986
g6
V335858
p27987
stp27988
a((dp27989
g2
(lp27990
VThe sets need to be passed as pointers to pointers
p27991
aVSecause regular pointers are passed by value, modifications to  and  do not change the values that you pass to  from the caller
p27992
aVCall this function as follows:
p27993
as(dp27994
g6
V335858
p27995
stp27996
a((dp27997
g2
(lp27998
VThis line in the header file
p27999
aVis missing a close parenthesis
p28000
aVAdding it will fix this error
p28001
aVCompilers are notorious for reporting errors related to unclosed brackets on a wrong line
p28002
as(dp28003
g6
V335858
p28004
stp28005
a((dp28006
g2
(lp28007
VIn the MVC world, everything that you intend to share among multiple view controllers belongs in the model
p28008
aVYour model class is globally available; one controller sets the value; the other reads it
p28009
aVHeader: MyAppModel
p28010
ag1177
aVImplementation: MyAppModel
p28011
ag12457
aVUsage: your view controllers
p28012
as(dp28013
g6
V335858
p28014
stp28015
a((dp28016
g2
(lp28017
VYou need to make an instance variable, set it before making the call to , and grab its value in , like this:
p28018
aVIn the header:
p28019
aVIn the implementation:
p28020
as(dp28021
g6
V335858
p28022
stp28023
a((dp28024
g2
(lp28025
VI think this should be legal, but the compiler doesn't agree with me on this point
p28026
aVGenerally, when humans and compilers disagree, it is safe to take the compiler's side
p28027
aVInstead of tricking the compiler, you should first understand why it does not allow the conversion
p28028
aVConsider this: you make a , like this:
p28029
aVEveryone is happy so far
p28030
aVNow let's do what you think is correct:
p28031
aVAt this point, we have  that is entirely ours
p28032
aVLet's play with it: let's say we have another class  extending
p28033
aVCan we do this
p28034
aVBut wait, do you see what we have done
p28035
aVOur  contains a  now
p28036
aVThis is why the compiler does not allow the conversion; this is also why your code is not safe in cases when you attempt to add anything to the list
p28037
aVTo work around this issue, you can use wildcards:
p28038
aVHowever, this will limit your lists to read-only access
p28039
aVIf you must allow writing (and you know that you are going to set only the right stuff) use the non-generic  instead
p28040
as(dp28041
g6
V335858
p28042
stp28043
a((dp28044
g2
(lp28045
VSplitting into  can be done like this:
p28046
aVConverting to  requires an additional loop:
p28047
aVThe 2D part requires that all strings separated by  be of the same length
p28048
aVThe  array of arrays, on the other hand, can be "jagged", i
p28049
ag630
aVrows could have different lengths
p28050
as(dp28051
g6
V335858
p28052
stp28053
a((dp28054
g2
(lp28055
V-ness of data members needs to be known at compile time
p28056
aVIf you "sometimes" need a reference to a  vector and sometimes non-, you should create a class hierarchy with the base abstract class containing the common functionality, and inherit it in two  classes:  and
p28057
aVThe  would contain a non- vector, and  would contain a  vector
p28058
aVThis way you would not duplicate any logic, while two separate classes would contain two references of different -ness
p28059
aVHere is an example:
p28060
aVNote that this class hierarchy may need a destructor and various copy constructors, depending on the usage
p28061
as(dp28062
g6
V335858
p28063
stp28064
a((dp28065
g2
(lp28066
VYou are facing two separate problems:
p28067
aVInvoking chained methods, and
p28068
aVInvoking methods that take lambdas as parameters
p28069
aVLet's deal with the two separately
p28070
aVLet's say that you have the following information available:
p28071
aVA  representing the first item in the chain (the constructor)
p28072
aVAn array of objects representing constructor's parameters
p28073
aVAn array of  objects - one for each chained function
p28074
aVAn array of object arrays representing parameters of each chained function
p28075
aVThen the process of constructing the result would look like this:
p28076
aVOnce the loop is over, your  contains a configured object
p28077
aVThe code above assumes that there are no generic methods among the chained methods; if some of the methods happen to be generic, you would need an additional step in making a callable instance of a generic method before calling
p28078
aVNow let's look at the lambdas
p28079
aVDepending on the type of the lambda that is passed to the method, you need to pass a delegate with a particular signature
p28080
aVYou should be able to use  class to convert methods into callable delegates
p28081
aVYou may need to create support methods that implement the delegates that you need
p28082
aVIt is hard to say how without seeing the exact methods that you must be able to call through reflection
p28083
aVYou may need to go for expression trees, and get  instances after compiling them
p28084
aVThe call of  would look like this:
p28085
as(dp28086
g6
V335858
p28087
stp28088
a((dp28089
g2
(lp28090
VRather than making  and  instance variables that are set in the constructor, make them parameters passed to your static method, like this:
p28091
aVThis way you would be able to specify  and  independently of the constructor, and call  from anywhere with any combination of words and the desired number of words per line
p28092
aVHere is a link to ideone with this running program
p28093
as(dp28094
g6
V335858
p28095
stp28096
a((dp28097
g2
(lp28098
VThe only way to guarantee it is to make the call in the constructor of the base class
p28099
aVSince all subclasses must call a constructor of the base, your method of interest will be called as well:
p28100
as(dp28101
g6
V335858
p28102
stp28103
a((dp28104
g2
(lp28105
VYou do not need to define  separately, and you need to switch around the namespace and the type, like this:
p28106
as(dp28107
g6
V335858
p28108
stp28109
a((dp28110
g2
(lp28111
VAssuming that this is for the classic RPN programming exercise, the simplest solution is to use a  statement:
p28112
as(dp28113
g6
V335858
p28114
stp28115
a((dp28116
g2
(lp28117
VIn order to preserve the arbitrary precision as long as possible, do the multiplication in , and then convert the result to , like this:
p28118
as(dp28119
g6
V335858
p28120
stp28121
a((dp28122
g2
(lp28123
VAssuming that you are talking decimal digits, you can do this:
p28124
aVInteger division by ten discards ones; obtaining a remainder of the division by ten drops the rest of the number
p28125
as(dp28126
g6
V335858
p28127
stp28128
a((dp28129
g2
(lp28130
VNo, it means that the function returns an pointer of the untyped type -
p28131
aVThis is a "generic" pointer type
p28132
aVAny pointer to data can be cast to , and returned back to the caller
p28133
aVHowever, in order to dereference the pointer, you must cast it to a non-void pointer type (, , , and so on)
p28134
as(dp28135
g6
V335858
p28136
stp28137
a((dp28138
g2
(lp28139
VThis is incorrect:
p28140
aVThis operation adds the value past the end of the array to , triggering an exception
p28141
aVYou need a loop here:
p28142
aVYou can also use the - loop, like this:
p28143
aVYou are also casting  instead of casting the result of the division:
p28144
aVshould be replaced with
p28145
as(dp28146
g6
V335858
p28147
stp28148
a((dp28149
g2
(lp28150
VThe "discrepancy" has nothing to do with passing by value
p28151
aVYou are using a different kind of loop in Java, the one where the list is not modified
p28152
aVThat's why you see the difference
p28153
aVIf you replace the Java loop with a  kind or replace the C# loop with a , there would be no differences between the two programs
p28154
aVIn fact, C# program will not compile, because assigning the loop variable is a very common error:
p28155
as(dp28156
g6
V335858
p28157
stp28158
a((dp28159
g2
(lp28160
VYou are missing a level of indirection:  sends in addresses of elements being sorted, not the elements themselves
p28161
aVIn your case, you are seeing addresses of the addresses of your  elements being passed
p28162
aVYou need to dereference the pointers passed in after casting to  (which is a pointer to a pointer):
p28163
as(dp28164
g6
V335858
p28165
stp28166
a((dp28167
g2
(lp28168
VThe trick is to define a read-only interface to the object, and put the setters only into the class, like this:
p28169
aVAt this point, you can access  as read-only through its interface
p28170
aVIf you need to set properties, cast  to , and call the setters
p28171
as(dp28172
g6
V335858
p28173
stp28174
a((dp28175
g2
(lp28176
VYou misunderstand the way the escape sequences are processed
p28177
aVThey are computed at compile-time, not at run time
p28178
aVOn other words, when you write
p28179
aVit does not become a string of four characters at runtime; compiler converts it to a single-character string before the program is run
p28180
aVYou also misunderstand : if  is not a , static-casting it to string will result in an error; if it is a , static-casting will have no effect
p28181
aVYou can create a single-character string at runtime and put a character code into its only character like this:
p28182
as(dp28183
g6
V335858
p28184
stp28185
a((dp28186
g2
(lp28187
VThe array list is not empty, otherwise you'd get an index out of bounds exception (which is impossible to produce in your code, because your loop checks )
p28188
aVHowever, your array list contains a  object at index
p28189
aVChange your code as follows to fix the error:
p28190
as(dp28191
g6
V335858
p28192
stp28193
a((dp28194
g2
(lp28195
VYou can do that by making your  an
p28196
aVand moving the initialization into its constructor:
p28197
as(dp28198
g6
V335858
p28199
stp28200
a((dp28201
g2
(lp28202
VSearching for a single item in an array is
p28203
aVSearching for a longest run of increasing numbers in an array is  if you use a straightforward algorithm with two nested loops*
p28204
aVNote: This is not Java-specific
p28205
aV* A faster algorithm exists to do this search
p28206
as(dp28207
g6
V335858
p28208
stp28209
a((dp28210
g2
(lp28211
VThe answer depends on your usage: if you do not mind bringing the data set into memory in order to perform the query, then keeping only the  override will be fine
p28212
aVHowever, the inevitable consequence of this decision is that your queries will be forced into memory the moment that you use
p28213
aVThis may or may not be what you want, and might force you into coding patterns that you would rather avoid
p28214
aVFor example,
p28215
aVwill perform a lot worse with a single  than with an  overide availalbe, because all sales orders will be retrieved into memory one-by-one before determining their visibility, rather than checking the condition on the server side
p28216
aVIf filtering by user ID could eliminate the majority of sales orders on the server side, the performance difference of this equivalent query could be orders of magnitude better:
p28217
aVIf you plan to use your code only by yourself and you do not mind being watchful for situations when there is bad performance for no obvious reason, you can keep one overload
p28218
aVIf you plan to let others use your library, I strongly suggest keeping both overrides
p28219
aVEDIT : To speed up your alternative implementation, pre-compile your expression, like this:
p28220
as(dp28221
g6
V335858
p28222
stp28223
a((dp28224
g2
(lp28225
VSwitching from "buy once, use forever" to "buy many times, use while it lasts" makes your purchase a consumable in Apple's terminology
p28226
aVSince Apple does not store the state of consumable purchases for you, the task of keeping track of consuming the resource is entirely up to your application
p28227
aVIn general, there are four places that you could potentially use to store the remaining count:
p28228
aVSince you need to store a tiny amount of data, your ideal candidate is Keychain: it works offline, survives reinstalls, and as an added bonus, it is also encrypted
p28229
aVAlthough there is no built-in  wrapper around the keychain  APIs, Apple has kindly published a nice wrapper for it (scroll to the bottom of the page to see the code)
p28230
aVAdd security framework to your solution, copy-paste the wrapper code into your project (it's only two files)
p28231
aVNow you can use keychain as if it were an
p28232
as(dp28233
g6
V335858
p28234
stp28235
a((dp28236
g2
(lp28237
VThe use of  keywords lets you disambiguate between member variables and locals, such as function parameters:
p28238
aVThe code snippet above assigns the value of local variable  to the member variable of the class with the same name
p28239
aVSome shops adopt coding standards requiring all member accesses to be qualified with
p28240
aVThis is valid, but unnecessary; in cases where no collision exists, removing  does not change the semantic of your program
p28241
as(dp28242
g6
V335858
p28243
stp28244
a((dp28245
g2
(lp28246
VYou can iterate over two nested maps with two nested "foreach" loops, like this:
p28247
as(dp28248
g6
V335858
p28249
stp28250
a((dp28251
g2
(lp28252
VThis is because  does not null-terminate the destination string:
p28253
aVCopies the first num characters of source to destination
p28254
aVIf the end of the source C string (which is signaled by a null-character) is found before num characters have been copied, destination is padded with zeros until a total of num characters have been written to it
p28255
aVNo null-character is implicitly appended at the end of destination if source is longer than num (thus, in this case, destination may not be a null terminated C string)
p28256
aVThis should fix the problem:
p28257
as(dp28258
g6
V335858
p28259
stp28260
a((dp28261
g2
(lp28262
VYou should replace the  of the equality expression with this:
p28263
aVThis expression is true when
p28264
aVBoth  are , or
p28265
aVBoth  are not , and they contain the same elements in the same order
p28266
as(dp28267
g6
V335858
p28268
stp28269
a((dp28270
g2
(lp28271
VIf you are asking about an extra method call, then the answer is yes, there would be a completely unnecessary call in the chain of method invocations leading to the call of the "real"
p28272
aVI would not go so far as to call removal of such methods an elimination of "performance hits": it is rather unlikely that you or your end-users would notice the effects of such micro-optimization
p28273
as(dp28274
g6
V335858
p28275
stp28276
a((dp28277
g2
(lp28278
VWhen multiple method names match, the compiler runs an overload resolution procedure to decide which method is more specific
p28279
aVIn your case, the static overload happens to be the most specific one, because it takes a  rather than
p28280
aVThe compiler complains that you should be calling it using
p28281
as(dp28282
g6
V335858
p28283
stp28284
a((dp28285
g2
(lp28286
VIt looks like the  on the last line should be replaced with
p28287
as(dp28288
g6
V335858
p28289
stp28290
a((dp28291
g2
(lp28292
VYou've got your syntax wrong, and it should be an , not
p28293
aVTry this:
p28294
aVIf you put an  there, your condition is going to be  no matter what the value of ID is, because no number can equal 127 and 112 at the same time
p28295
as(dp28296
g6
V335858
p28297
stp28298
a((dp28299
g2
(lp28300
VYou can define a custom comparator to use a composite sorting key of the kind that you are looking for
p28301
aVIf there is no good reason to have that sorting key in the dictionary, other than  performing the sort, do not add an item to the dictionary
p28302
aVNote: The  method does not sort the array in place; instead, it returns a sorted copy
p28303
aVIf you would like an in-place sorting, use
p28304
as(dp28305
g6
V335858
p28306
stp28307
a((dp28308
g2
(lp28309
VWhen the initializer of your static variable is not a compile-time constant, you need to use another initialization mechanism, such as :
p28310
as(dp28311
g6
V335858
p28312
stp28313
a((dp28314
g2
(lp28315
VIn your common superclass, create a method
p28316
aVthat does nothing
p28317
aVCall this method when you need to trigger an action in a subclass
p28318
aVIn each of your subclasses, implement a method with the same signature
p28319
aVThese methods would be called when superclass calls
p28320
as(dp28321
g6
V335858
p28322
stp28323
a((dp28324
g2
(lp28325
VYou have converted the text to a value called , but you have forgotten to use it
p28326
aVThe line
p28327
aVshould be
p28328
aVThis should fix the problem
p28329
as(dp28330
g6
V335858
p28331
stp28332
a((dp28333
g2
(lp28334
VIf you get the list from an external source, you need to check each element of the list for a value to be in the correct range
p28335
aVIf you make the list yourself, you can inherit  or , and override the mutating members (, , etc
p28336
aVto check the values at insertion points
p28337
as(dp28338
g6
V335858
p28339
stp28340
a((dp28341
g2
(lp28342
VUnlike strings that may consist of multiple characters, s represent a single number
p28343
aVThe trick to solving this problem with s is applying  and  operators: by taking , you get the last digit; by taking , you chop the last digit off
p28344
as(dp28345
g6
V335858
p28346
stp28347
a((dp28348
g2
(lp28349
VFirst, your array needs to be mutable (i
p28350
ag630
aVan instance of , not simply )
p28351
aVWith  you can do this:
p28352
aVIf you have the latest Xcode, you can use the  syntax as well
p28353
as(dp28354
g6
V335858
p28355
stp28356
a((dp28357
g2
(lp28358
VYou need read-only collections when your API returns collection objects to your callers, copying is too expensive, and you would prefer to stay away from returning
p28359
aVThis is commonly desirable in situations when random access is required over the returned collection
p28360
as(dp28361
g6
V335858
p28362
stp28363
a((dp28364
g2
(lp28365
VThere is no back-reference in your first example, it's a reference to a numbered capturing group in the output
p28366
aVThe efficiency of the search in both cases is the same; the difference is only in what is captured
p28367
aVTherefore, the overall difference in performance will boil down to the differences in replacing string content: in the first case, two strings are combined to form a replacement, while in the second case only one string is used
p28368
aVTheoretically, the first case should require slightly more work, but in practice it is unlikely that the difference would be noticeable
p28369
aVEDIT: As the tests by acheong87 show, using positive lookahead is nearly 50% less efficient in Java
p28370
aVMoreover, this inefficiency does not appear to be Java-specific (although its magnitude in Java is overwhelming: a C# program equivalent to 's shows a slowdown of about 24% under Mono and about 21% under Windows)
p28371
aVI guess the take-home lesson of this exercise is that theoretical near-equivalence of expressions does not guarantee equivalent timing in practice: there is no substitution to profiling of the actual implementation
p28372
as(dp28373
g6
V335858
p28374
stp28375
a((dp28376
g2
(lp28377
VOnly  part is correct, but
p28378
aVThis is because  is a copy of the first character from , i
p28379
ag630
aVThe copy is stored at a different place from the original, so its address in memory is different
p28380
as(dp28381
g6
V335858
p28382
stp28383
a((dp28384
g2
(lp28385
VIf  succeeds, the  will not be executed
p28386
aVHowever,  could throw  exception, in which case  will be executed
p28387
as(dp28388
g6
V335858
p28389
stp28390
a((dp28391
g2
(lp28392
VYou can use Regex to do it in a single line:
p28393
aVNOTE: This works fine under Microsoft
p28394
aVNET, but does not work with Mono's implementation of Regex
p28395
as(dp28396
g6
V335858
p28397
stp28398
a((dp28399
g2
(lp28400
VYes, the base class constructor will be called automatically
p28401
aVYou do not need to add an explicit call to  when there is a constructor with no arguments
p28402
aVYou can easily test this by printing out the age of the customer after construction (link to ideone with a demo)
p28403
as(dp28404
g6
V335858
p28405
stp28406
a((dp28407
g2
(lp28408
VIf your string representing  uses space  instead of a decimal point, you can fix it by replacing the space with a dot, like this:
p28409
aVLink to ideone
p28410
as(dp28411
g6
V335858
p28412
stp28413
a((dp28414
g2
(lp28415
VIn this case, the  method will send  object the  message, get the result, and use that for the content of the newly created string
p28416
aVEssentially, the result is identical to
p28417
aVAccording to 's documentation,  returns
p28418
aVAn NSString object that contains a hexadecimal representation of the receiver\u2019s contents in NSData property list format
p28419
as(dp28420
g6
V335858
p28421
stp28422
a((dp28423
g2
(lp28424
VI don't think your instructor wanted you to call  because it's always
p28425
aVThe simplest way of building the result without regexp is using a  and a  statement, like this:
p28426
aVYou can also replace this with an equivalent , like this:
p28427
as(dp28428
g6
V335858
p28429
stp28430
a((dp28431
g2
(lp28432
VThe simplest way to do it is to use  and  in a recursive rule, like this:
p28433
aVThis is the "classic" Prolog solution for list processing, with a fact handling the empty list, and a rule that processes header elements one-by-one
p28434
as(dp28435
g6
V335858
p28436
stp28437
a((dp28438
g2
(lp28439
VThis is not a good way to restart your application, because the initial invocation of your application would still be running
p28440
aVIf you "restart" your application like that enough times, you would get a stack overflow
p28441
aVIf you must restart your application without quitting it (which is unusual), you can set up a / block inside your , put a loop around it, and continue the loop when you get an exception
p28442
aVAdmittedly, this is more of a workaround than anything else, because it uses exceptions to control the "normal" program flow
p28443
as(dp28444
g6
V335858
p28445
stp28446
a((dp28447
g2
(lp28448
VThe keyword here is integer caching
p28449
aVvalues under * are cached, and  returns an interning  result
p28450
aVThere are two fun experiments you can perform to understand how caching of  works:
p28451
aVReplace  with , and observe that  right away
p28452
aVReplace  with , and observe that  and  return different objects
p28453
aV* There is an option to control this:
p28454
as(dp28455
g6
V335858
p28456
stp28457
a((dp28458
g2
(lp28459
VThis is because you are using  instead of  in your
p28460
aVis a static variable that never changes; you should remove it
p28461
aV, on the other hand, is a parameter that you pass to ; its value decreases as you go down the levels of recursive invocations, eventually hitting  and letting you exit:
p28462
as(dp28463
g6
V335858
p28464
stp28465
a((dp28466
g2
(lp28467
VIf blocks are aligned, low-order address bits are always 0
p28468
aVThis is the key to understanding what it going on
p28469
aVMany CPUs require that multibyte primitive values be stored at addresses divisible by the number of bytes in the primitive: 16-bit primitives need to be stored at even addresses; 32-bit s need to be stored at addresses divisible by four, and so on
p28470
aVAn attempt to access an  through a pointer that corresponds to an odd address results in a bus error
p28471
aVIn systems like that  must always return an address suitable for storing any primitive supported by the given CPU
p28472
aVTherefore, if CPU supports 32-bit integers, all addresses returned by  must be divisible by
p28473
aVSuch addresses are said to be aligned
p28474
aVTo comply,  implementations pad sizes blocks requested by the program by 0 to 3 bytes at the end to have length divisible by
p28475
aVAs a consequence of this decision, the last two bits of an address of an aligned block will always be zero
p28476
aVAn implementation of  can use these bits for its own purposes, as long as they are "masked out" before returning the result to callers
p28477
as(dp28478
g6
V335858
p28479
stp28480
a((dp28481
g2
(lp28482
VIn general,  and "empty" can have different semantics:  means "it's not there", while "empty" means "it's there, but there's nothing in it"
p28483
aVIf your class is such that there is no semantic difference between "not there" and "empty", then returning an empty collection is better: it saves an  statement in all of your callers, making their code look cleaner
p28484
aVMoreover, in this case I would initially set  to , and removed an  from the getter
p28485
aVOf course in this case your setter would need to -check its argument
p28486
as(dp28487
g6
V335858
p28488
stp28489
a((dp28490
g2
(lp28491
VSince each of the variables that you declare must be assigned a value, you should combine declaration with initialization
p28492
aVIn other words, instead of
p28493
aVdo this:
p28494
aVThis is pretty much as far as you can push this approach with locals: declaring variables is an essential part of the function body, you cannot (and arguably, should not) move it to a remote location
p28495
aVYou can also move the member function into a nested private class, move the local variables into the class, and do calculations there:
p28496
aVPS: I am deliberately not mentioning preprocessor-based solutions because they would negatively impact readability
p28497
as(dp28498
g6
V335858
p28499
stp28500
a((dp28501
g2
(lp28502
VYou forward-declare  in the header
p28503
aVIt lets you declare _hwlayer instance variable
p28504
aVHowever, it is not sufficient to start using its properties: but you must import the header that contains  into the
p28505
aVm file that references
p28506
aVAlternatively, you can use the square bracket syntax, like this:
p28507
aVThis does not require importing the header
p28508
as(dp28509
g6
V335858
p28510
stp28511
a((dp28512
g2
(lp28513
VOne obvious drawback to converting a  to  is the need to copy: since strings in C# are immutable while arrays are mutable, your code would end up duplicating your gigantic string in its entirety
p28514
aVThis will almost certainly dwarf the potential speed gains, if any, to be had after the conversion
p28515
as(dp28516
g6
V335858
p28517
stp28518
a((dp28519
g2
(lp28520
VYou cannot link two libraries with identical symbols and get access to both
p28521
aVHowever, you can build your own thin wrapper libraries to disambiguate the two versioned libraries:
p28522
aVDefine an abstract class  that exercises the functions of the target library using abstract virtual functions
p28523
aVDefine an implementation of  in a class called  that calls through to the target library from the virtual methods
p28524
aVDefine a free-standing method  returning
p28525
aVCompile  into static libraries several times, linking with different versions of the target library each time
p28526
aVCritical: pass  to the compiler, with , , , and so on, for different versions
p28527
aVYou should end up with multiple libraries
p28528
aVLink your main tester with these multiple libraries
p28529
aVAt this point, your main tester has access to free-standing functions , ,  and so on created through renaming  through the preprocessor
p28530
aVUse these functions to obtain instances of  that call through to different versions of the target library
p28531
as(dp28532
g6
V335858
p28533
stp28534
a((dp28535
g2
(lp28536
VSince this is probably a homework, here are some hints:
p28537
aVInside
p28538
aVis an infinite loop, because  does not change inside loop's body
p28539
aVYou do not need to know the size of
p28540
aVStore  so that you could return its value
p28541
aVMove  to the end of the string using a loop
p28542
aVCopy 's characters into what's pointed to by the new  pointer until you hit
p28543
aVYou are done
p28544
aVOutside
p28545
aVYour  function assumes that  has enough space to store all characters of , all characters of , and a null terminator
p28546
aVYour code s the space enough to hold just the null terminator
p28547
aVYou need to change the logic to provide more space
p28548
aVEverything that you  must be d
p28549
as(dp28550
g6
V335858
p28551
stp28552
a((dp28553
g2
(lp28554
VBehind the scene, block implementation consists of two parts:
p28555
aVThe executable code of the block, and
p28556
aVA data structure containing the values of the variables used in the block
p28557
aVOnly the second part of the block is placed on the stack and copied to the heap memory; the first part is compiled to the code segment of your program, and does not get copied
p28558
aVSince your block implementations do not reference any variable from the surrounding scope, the data portion of their blocks is empty
p28559
aVThat is why your code works: there is simply nothing to copy
p28560
aVHowever, you should add block copy anyway, because otherwise a small change to the code of your block will break your application without the compiler noticing anything
p28561
as(dp28562
g6
V335858
p28563
stp28564
a((dp28565
g2
(lp28566
VTo get registration counts for each day of January, use this :
p28567
as(dp28568
g6
V335858
p28569
stp28570
a((dp28571
g2
(lp28572
VYes, there is: not surprisingly, it is called
p28573
aVIn
p28574
aVNET 4
p28575
aV0 and later, the second parameter could be an
p28576
as(dp28577
g6
V335858
p28578
stp28579
a((dp28580
g2
(lp28581
VThere are two different ways to implement the approach based on class methods:
p28582
aVMake a singleton instance using a class hidden from everybody, and hide its methods behind wrapper class methods with identical signatures, or
p28583
aVMake class methods that do all the work
p28584
aVThe implications of the first implementation are that everything you can do with a singleton, you can do with the hidden singleton:
p28585
aVusing a subclass becomes a possibility
p28586
aVswitching the instance in the middle of the run is easy
p28587
aVthe state lives in instance variables
p28588
aVinitialization follows the familiar pattern
p28589
aVIf you go for an implementation that does not use a singleton, you would be relying on static variables to keep your current state
p28590
aVThat is a legitimate choice, but the initialization pattern becomes different (perhaps even using a ), you cannot switch the implementation in the middle without relying on some ugly  conditions, and using a subclass becomes a lot more tricky
p28591
aVTesting the first implementation is somewhat easier than testing the second one, because you can provide a separate implementation of the singleton for testing, perhaps through the back door; with a static-based implementation, this route cannot be taken
p28592
aVTo summarize, I would use a singleton-based solution, with the singleton optionally hidden behind a "facade" that provides access to singleton's methods
p28593
aVI would not use an implementation where all state must be placed in static variables
p28594
as(dp28595
g6
V335858
p28596
stp28597
a((dp28598
g2
(lp28599
VIf you replace
p28600
aVwith
p28601
aVyour method should work
p28602
aVHowever, a better way is to use bit arithmetic and shifts to perform the rearrangements:
p28603
as(dp28604
g6
V335858
p28605
stp28606
a((dp28607
g2
(lp28608
VYou need to use  instead of :
p28609
aVIt is , not , that is the last parameter that has an explicit name (as opposed to vararg parameters, which have no names)
p28610
aVYou need to pass the last named parameter to  in order for it to figure out the address in memory at which the vararg parameters start
p28611
as(dp28612
g6
V335858
p28613
stp28614
a((dp28615
g2
(lp28616
VThis is because your function modifies the string in place, and you are passing it an address of a string literal; modifying string literals in place is undefined behavior
p28617
aVChange this
p28618
aVto this
p28619
aVand your function will work as expected
p28620
as(dp28621
g6
V335858
p28622
stp28623
a((dp28624
g2
(lp28625
VConsider this deliberately contrived example:
p28626
aVRecall that comma creates a sequence point
p28627
aVTherefore, the assignment  will be completed before  is evaluated
p28628
aVMoreover, since  is , the compiler may not assume that it's  simply because there is no code modifying  between its declaration and the point of access: the compiler must generate an instruction to read
p28629
aVHowever, this leaves an important decision up to the compiler: when exactly should  be read
p28630
aVMore specifically, would it be OK to read  before assigning
p28631
aVThis is where the statement from your question comes in:
p28632
aVA compiler may not move accesses to volatile variables across sequence points
p28633
aVIt explicitly prohibits the compiler from reading  before assigning , because doing so would move the access across the sequence point created by the comma operator
p28634
aVWithout this restriction, the compiler would have been free to read  either before or after assigning
p28635
as(dp28636
g6
V335858
p28637
stp28638
a((dp28639
g2
(lp28640
VYou can use  method from :
p28641
as(dp28642
g6
V335858
p28643
stp28644
a((dp28645
g2
(lp28646
VBy the very definition of inheritance,  is a ; there is no built-in way to "chop off" the  part
p28647
aVHowever, you can make the object serializable again by marking the items that you do not want serialized as :
p28648
aVYou can also remove the  members by constructing a new , like this:
p28649
as(dp28650
g6
V335858
p28651
stp28652
a((dp28653
g2
(lp28654
VThe difference is in thread safety and convenience:
p28655
aVYou can successfully call the first method concurrently from multiple threads; that's not possible with the second method
p28656
aVIt is clear to the caller that  is method's parameter; there is no such clarity for the second method
p28657
as(dp28658
g6
V335858
p28659
stp28660
a((dp28661
g2
(lp28662
VThis has to do primarily with the format of text books: it is hard to fit more than a certain number of characters on a page, because books have no scroll bars
p28663
aVOther than that, the two are identical
p28664
aVOne reason to do it in real life is so that you could set a break point and examine  before calling
p28665
as(dp28666
g6
V335858
p28667
stp28668
a((dp28669
g2
(lp28670
VUnlike C and C++, where  takes integers (among many other types) and interprets zeros as , Java requires boolean expressions in , , etc
p28671
aVSince  is an operation that produces an integer, your first expression is not valid in the condition of the
p28672
aVWhen you re-write C conditions like that in Java, you need to add , not
p28673
aVOtherwise, integers with the most significant bit set to  would fail your check
p28674
as(dp28675
g6
V335858
p28676
stp28677
a((dp28678
g2
(lp28679
VIn the header file, write this:
p28680
aVThis will declare the variables
p28681
aVIn one of the CPP files, write this:
p28682
aVThis will define the variables
p28683
aVIt does not matter in which CPP file you put the definitions, as long as the variables are defined exactly once
p28684
as(dp28685
g6
V335858
p28686
stp28687
a((dp28688
g2
(lp28689
VYou can do it with a regexp and a simple loop:
p28690
aVLink to ideone
p28691
as(dp28692
g6
V335858
p28693
stp28694
a((dp28695
g2
(lp28696
V with no expression works only if your function is declared , in a constructor, or in a destructor
p28697
aVIf you try to return nothing from a function that returns an , a , etc
p28698
aV, your program will not compile:
p28699
aVerror: return-statement with no value, in function returning \u2018int\u2019
p28700
aVAccording to 6
p28701
ag837
aV3/2 of C++11:
p28702
aVA return statement with neither an expression nor a braced-init-list can be used only in functions that do not return a value, that is, a function with the return type void, a constructor (12
p28703
aV1), or a destructor (12
p28704
aV4)
p28705
aV(thanks sftrabbit for the excellent comment)
p28706
as(dp28707
g6
V335858
p28708
stp28709
a((dp28710
g2
(lp28711
VLike this:
p28712
aVThis code assumes that the string is null-terminated, and that it contains only characters  through  or  through , inclusive
p28713
aVTo understand how this works, recall that after conversion  each letter has a code between  and , and that the codes are consecutive
p28714
aVAs the result,  evaluates to a number from  to , inclusive, representing the letter's sequential number in the alphabet
p28715
aVThis code combines  and  to shorten the program
p28716
as(dp28717
g6
V335858
p28718
stp28719
a((dp28720
g2
(lp28721
VIn C++, should my method return an object or a pointer to an object
p28722
aVYou should return an object by default
p28723
aVUsual exceptions are functions that return a subclass of a given class, and when returning nothing is a legal option for a function1
p28724
aVWhat if it's an operator
p28725
aVOperators return references or objects; although it is technically possible to return pointers from overloaded operators, it is not usually done
p28726
aVAnd one more thing - if the pointer turns to be a vector, how can I find out it's size after returned
p28727
aVI think you meant an array rather than a vector, because  has a  member function returning the size of the vector
p28728
aVFinding the size of a variable-length array is indeed not possible
p28729
aVAnd if it's impossible, as I think it is, how should I proceed to correctly return an array without this limitation
p28730
aVYou should use , it does not limit you on the size or the type of elements that go into it
p28731
aV1 In which case you return  or  in C++11
p28732
as(dp28733
g6
V335858
p28734
stp28735
a((dp28736
g2
(lp28737
VCharacter constants must denote exactly one character*: you cannot use  or  as a character constant, because they have two characters
p28738
aVIf you go character-by-character, common solution is to use a single , and then check the prior character to see if it's also  or
p28739
aV* Escaped sequences such as  also denote a single character, even though they consist of two characters
p28740
as(dp28741
g6
V335858
p28742
stp28743
a((dp28744
g2
(lp28745
VIn addition to writing out the strings into a text file, which is the simplest option that should work for small projects, you could use template engines
p28746
aVSeveral options are available in
p28747
aVNET:
p28748
aVText Template Transformation Toolkit (T4) - A template engine from Microsoft
p28749
aVT4 is used throughout Visual Studio for code generation
p28750
aVString Template Engine - A template engine from the designers of ANTLR, a popular parser generator
p28751
as(dp28752
g6
V335858
p28753
stp28754
a((dp28755
g2
(lp28756
VThe compiler analyzes your code, and sees that a return statement will be executed for all values of  between  and , inclusive
p28757
aVHowever, if the  is negative or more than , the code would reach the end of the function without a return statement; that is why the compiler issues a warning
p28758
aVNote that it may not be possible for  to be set to a negative number or a number over  because of constraints in other parts of your code
p28759
aVHowever, the compiler does not know any of that, so it thinks that  could have any value
p28760
aVTo fix this problem, add an unconditional return statement at the end
p28761
as(dp28762
g6
V335858
p28763
stp28764
a((dp28765
g2
(lp28766
VYour program has a classic "off by one" error: you increment  before using it as an index in , so the zeroth element remains uninitialized:
p28767
as(dp28768
g6
V335858
p28769
stp28770
a((dp28771
g2
(lp28772
VTo check if two points are within a  from each other, compute the distance between them
p28773
aVYou can avoid going into the square root territory by using squares, like this:
p28774
as(dp28775
g6
V335858
p28776
stp28777
a((dp28778
g2
(lp28779
VIf I understand your question correctly, you would like to split the string into integer numbers representing the digits, as follows:  becomes
p28780
aVChange your code as follows to interpret each character that represents a digit as a single-digit number:
p28781
aVHere is a link to a demo on ideone
p28782
aVThe reason you see numbers , , and so on is that you see ASCII codes for the corresponding digits
p28783
as(dp28784
g6
V335858
p28785
stp28786
a((dp28787
g2
(lp28788
VConstruct a regular expression of the form
p28789
aVthen use 's  method to split the text by any of the delimiters
p28790
aVIn order to construct the regexp, read each delimiter, and pass it to  before appending to the regex that you build
p28791
aVThis would let your delimiters use regex metacharacters as well
p28792
as(dp28793
g6
V335858
p28794
stp28795
a((dp28796
g2
(lp28797
VImagine that you know what  method prints for
p28798
aVNow trade the two branches of the  statement separately
p28799
aVWhen  is zero, print the "no bottles" message, and return
p28800
aVWhen  is not zero, we do the following three things:
p28801
aVPrint the number of bottles
p28802
aVPrint whatever  method prints for
p28803
aVPrint the recycling message
p28804
aVThe middle line is recursive: it can be expanded into the same three lines, like this:
p28805
aVPrint the number of bottles
p28806
aVPrint the number of bottles
p28807
aVPrint whatever  method prints for
p28808
aVPrint the recycling message
p28809
aVPrint the recycling message
p28810
aVYou can do it again and again, until the middle line becomes the "out of beer" message
p28811
as(dp28812
g6
V335858
p28813
stp28814
a((dp28815
g2
(lp28816
VYou do not need to compare anything to the second array: once you have the index of the matching element in the first array, simply use that index against the second array
p28817
aVThat's all there is to it
p28818
as(dp28819
g6
V335858
p28820
stp28821
a((dp28822
g2
(lp28823
VLike this:
p28824
aVSince  is used as the key in the  map, don't forget to override its  and  methods
p28825
as(dp28826
g6
V335858
p28827
stp28828
a((dp28829
g2
(lp28830
V expects a file as input, but when you build a JAR for your application, the file you are referring to is inside this JAR and not extracted
p28831
aVIn this case, you need to write the data to a file first
p28832
aVCreate an empty temporary file by calling
p28833
aVThe use one of the methods described in the answers to this question to copy the content of the stream returned from  into the temporary file
p28834
aVWhen you program exits, don't forget to delete the temporary file
p28835
aVOne way to ensure that is to call  on the temporary file object returned in the first step
p28836
as(dp28837
g6
V335858
p28838
stp28839
a((dp28840
g2
(lp28841
VYou should extend  and call  instead of , because  calls the method synchronously
p28842
aVwill call  asynchronously, achieving the effect that you are looking for
p28843
aVYou could also construct a  from your  using this constructor:
p28844
as(dp28845
g6
V335858
p28846
stp28847
a((dp28848
g2
(lp28849
VNo, Active Directory does not keep a history of prior user names
p28850
aVUsing the GUID is absolutely the best thing that you can do
p28851
aVIn fact, when our company ran into a similar issue several years ago, we ended up building our own "AD Snapshot Writer" that would poll AD periodically for the changes, calculate deltas, and store the results for the attributes that we needed (user name, e-mail addresses, etc
p28852
aVin a database with temporal attributes
p28853
as(dp28854
g6
V335858
p28855
stp28856
a((dp28857
g2
(lp28858
VYou should make  a local variable in the  method, and pass it to  as a parameter, like this:
p28859
aVAlso, you are assigning  to the variable in the  statement
p28860
aVThis is allowed, but it does not do what you want
p28861
aVYou should either use , or (better) use  to negate the variable:
p28862
as(dp28863
g6
V335858
p28864
stp28865
a((dp28866
g2
(lp28867
VThe answer depends on the type of your constant
p28868
aVIf all you need is an  or a , you can use preprocessor and the  syntax
p28869
aVFor Objective C classes, however, you need to do a lot more work
p28870
aVSpecifically, you would need to hide the constant behind a class method or a free-standing function
p28871
aVYou will also need to add a prototype of that method or function in the header file, provide a function-scoped static variable to store the constant, and add code to initialize it
p28872
aVHere is an example using a simple :
p28873
aVHeader: MyConstants
p28874
ag1177
aVImplementation: MyConstants
p28875
ag12457
aVUsage:
p28876
as(dp28877
g6
V335858
p28878
stp28879
a((dp28880
g2
(lp28881
VThe simplest way to do it would be adding a second loop that goes down from  to :
p28882
aVThis prints a triangle that looks like this:
p28883
as(dp28884
g6
V335858
p28885
stp28886
a((dp28887
g2
(lp28888
VYou can use  for that:
p28889
as(dp28890
g6
V335858
p28891
stp28892
a((dp28893
g2
(lp28894
VTechnically, this is not correct: C# does allow fall-through when the body of the  is empty:
p28895
aVAllowing implicit fall-through after a non-empty body in C/C++ is done by mistake more often than not
p28896
aVThat is why the designers of C# decided against allowing it
p28897
as(dp28898
g6
V335858
p28899
stp28900
a((dp28901
g2
(lp28902
VThe standard C++ library lets you solve this rather elegantly by moving the "magic" of comparing dates to a functor, and using the  overload that takes a custom comparator
p28903
aVHere is how you can do it with very few lines of code (link to a quick test on ideone):
p28904
aVThat's it, really
p28905
aVWith this comparator in hand, you can sort your three dates like this:
p28906
aVNow the nearest date is at the index zero:
p28907
as(dp28908
g6
V335858
p28909
stp28910
a((dp28911
g2
(lp28912
VBut what about  member functions
p28913
aVAre these equally as dangerous in a shared library
p28914
aVNot at all:  member functions should not be avoided: unlike  variables that represent shared state,  member functions represent shared computations
p28915
aVAs long as these computations are stateless, they are not dangerous at all
p28916
as(dp28917
g6
V335858
p28918
stp28919
a((dp28920
g2
(lp28921
VPointers are passed by value, so  will remain  after the call of
p28922
aVYou need to pass a pointer to a pointer in order to make it work:
p28923
as(dp28924
g6
V335858
p28925
stp28926
a((dp28927
g2
(lp28928
VIf your program has sufficient privileges, it can construct a  and examine it frame-by-frame to determine who is the caller
p28929
aVThis will get you the calling method, the calling class, and so on
p28930
as(dp28931
g6
V335858
p28932
stp28933
a((dp28934
g2
(lp28935
VThe meaning of  changes depending on its position in the regexp
p28936
aVWhen the symbol is inside a character class  as the first character, it means negation of the character class; when it is outside a character class, it means the beginning of line
p28937
aVThe easiest way to negate a result of a match is to use a positive pattern in regex, and then to add a  on the Java side to do the negation, like this:
p28938
as(dp28939
g6
V335858
p28940
stp28941
a((dp28942
g2
(lp28943
VRoughly 50% of the calls of the first type end without doing any work, because
p28944
aVThis makes the number of calls with non-trivial work roughly equal
p28945
aVIf you move  and  calls to after the exit condition, you'd get the number of "non-trivial" calls, and they will be equal
p28946
aVOther calls will go faster, too, because on average they would be concatenating shorter strings, making up for the 3x difference
p28947
as(dp28948
g6
V335858
p28949
stp28950
a((dp28951
g2
(lp28952
VThe reason your code does not work is not that  has a wrong type, but because it's out of scope
p28953
aVYou can do this:
p28954
aVThe users would call your  as follows:
p28955
aVThe disadvantage of this pattern is inability to distinguish situations when the object is there but it's  from situations when the object is not there
p28956
aVAn approach more "native" to
p28957
aVNET's dictionary API would be to use  instead of , like this:
p28958
aVThis approach performs the lookup operation only once, saving the CPU (although insisting on using this approach for the alleged speed improvement would be a micro-optimization)
p28959
as(dp28960
g6
V335858
p28961
stp28962
a((dp28963
g2
(lp28964
VDoing this directly is not possible in C# or any other language designed with the idea of a procedure (the way it is understood in structured programming) in mind
p28965
aVUnstructured jumps like that made programs much harder to understand - this is the basic thesis of Dijkstra's famous article on the subject
p28966
aVHowever, you can do something like that by splitting the second function in two, and calling the second part both from the  and the initial portion of
p28967
as(dp28968
g6
V335858
p28969
stp28970
a((dp28971
g2
(lp28972
VReturning a  from the function is the least common of the two ways to return multiple values
p28973
aVUsing pointers is more common:
p28974
aVHere is how you call this function:
p28975
as(dp28976
g6
V335858
p28977
stp28978
a((dp28979
g2
(lp28980
VI would use  to do the formatting:
p28981
as(dp28982
g6
V335858
p28983
stp28984
a((dp28985
g2
(lp28986
VIt appears that the  in the  method is passed with the value of
p28987
aVSince indexes in  are zero-based, you cannot ask for an element beyond
p28988
aVYou need to re-configure your slider, setting the minimum value at  and the maximum value at
p28989
as(dp28990
g6
V335858
p28991
stp28992
a((dp28993
g2
(lp28994
VWhat you are trying to do cannot be done statically:  corresponds to the static type of the expression, while the type of your expression on the right is clearly non-static (it's , where  is not known before the runtime)
p28995
aVThis, however, is legal:
p28996
aVThis would produce an
p28997
as(dp28998
g6
V335858
p28999
stp29000
a((dp29001
g2
(lp29002
VAlthough the answer to your question is "yes", there is a better way to go about what you are trying to do
p29003
aVUse , like this:
p29004
aVThis API is designed for removal of characters from the string; it achieves the same result much more efficiently
p29005
as(dp29006
g6
V335858
p29007
stp29008
a((dp29009
g2
(lp29010
VYou are -ing  with  even if it's equal to
p29011
aVOnce you , it's no longer , so your loop never terminates
p29012
aVMake the loop infinite, and exit from the middle when you see an , like this:
p29013
as(dp29014
g6
V335858
p29015
stp29016
a((dp29017
g2
(lp29018
VThe simplest way to define a value of a card is to add thirteen times the suit to the rank, or to add four times the rank to the suit:
p29019
aVor
p29020
aVBoth ways produce numbers from  to , inclusive
p29021
aVWith  in hand, you can define the difference function as follows:
p29022
as(dp29023
g6
V335858
p29024
stp29025
a((dp29026
g2
(lp29027
VThe idea behind the deprecation is to help the compiler catch errors that would otherwise cause crashes at runtime
p29028
aVas opposed to
p29029
aVThis is a relatively cheap way of catching an entire class of very nasty runtime errors, so deprecation of the conversion is very much in line with the general philosophy of C++ as "a better C"
p29030
aVIn addition, your code segment 2 does not invalidate the fact that the content of the pointer is protected
p29031
aVIt is the pointer itself that gets written over, not its content
p29032
aVThere is a difference between  and : the former protects the content; the later protects the pointer itself
p29033
aVThe two can be combined to protect the pointer and its content as
p29034
as(dp29035
g6
V335858
p29036
stp29037
a((dp29038
g2
(lp29039
VYou do not have a condition on :
p29040
aVI would convert the query to ANSI SQL syntax for joins for better clarity:
p29041
as(dp29042
g6
V335858
p29043
stp29044
a((dp29045
g2
(lp29046
VThere are several ways:
p29047
aVYou can pass through a parameter from the command line, or
p29048
aVYou can pass a bunch of hard-coded arguments, and check the answers
p29049
aVHere is an example:
p29050
aVCommand-line arguments:
p29051
aVHardcoded strings:
p29052
as(dp29053
g6
V335858
p29054
stp29055
a((dp29056
g2
(lp29057
VYou can use  method to expose a thin read-only wrapper of your list
p29058
aVThere will be no additional copying, and the caller will "see" changes to the original array done inside your method instantaneously:
p29059
as(dp29060
g6
V335858
p29061
stp29062
a((dp29063
g2
(lp29064
VThere is a much easier way to find a solution:
p29065
aV(link to ideone)
p29066
aVThe idea is to incrementally build the number of ways to make change by adding coins in progressively larger denomination
p29067
aVEach iteration of the outer loop goes through the results that we already have, and for each amount that can be constructed using the newly added coin adds the number of ways the combination that is smaller by the value of the current coin can be constructed
p29068
aVFor example, if the current coin is  and the current amount is , the algorithm looks up the number of ways that  can be constructed, and adds it to the number of ways that  can be constructed
p29069
aVIf the current coin is  and the current amount is , the algorithm looks up the number of ways to construct  () to the previously found number of ways to construct
p29070
aVIn the end, the number in  represents the number of ways to make one dollar (292 ways)
p29071
as(dp29072
g6
V335858
p29073
stp29074
a((dp29075
g2
(lp29076
VIf the utility class is not subclassed, converting methods that do not access the instance variables to  is a good idea
p29077
aVYou should go through the code and convert invocations to static syntax, i
p29078
ag630
aVshould be converted to
p29079
aVfor clarity
p29080
aVThere will be no noticeable performance impact: although theoretically static invocations are slightly less expensive, the difference is too small to consider important in most scenarios
p29081
as(dp29082
g6
V335858
p29083
stp29084
a((dp29085
g2
(lp29086
VEssentially, you are modeling a 2D data structure with a one-dimension list
p29087
aVAlthough it is somewhat unorthodox, it is commonly done to save on memory
p29088
aVThe easiest solution is to make copies on extending or contracting your list
p29089
aVWhen you need to shorten or to extend your list, create a new list of the target size, and then use two nested loops to do the copying, as if the original list were a 2D data structure
p29090
aVMaking a mapping function that takes a , a , and an , and returns an index into a plain list that corresponds to the  pair may be very helpful:
p29091
aVNow you can translate an index of a pair  in the list of size  to the index of the same pair in a list of size
p29092
aVYou can improve upon this solution by expanding and shrinking in place
p29093
aVThe key issue is the direction in which you go: when shrinking, go front-to-back; when expanding, go back-to-front
p29094
as(dp29095
g6
V335858
p29096
stp29097
a((dp29098
g2
(lp29099
VIn order to be able to change the content of a dictionary, you need to make , not an immutable :
p29100
as(dp29101
g6
V335858
p29102
stp29103
a((dp29104
g2
(lp29105
VYou can use  to do the filtering, like this:
p29106
as(dp29107
g6
V335858
p29108
stp29109
a((dp29110
g2
(lp29111
VYou can do it like this:
p29112
aVThe key step is using the overload of  that supplies the current index to your functor
p29113
as(dp29114
g6
V335858
p29115
stp29116
a((dp29117
g2
(lp29118
VWelcome to the double dispatch land
p29119
aVThe issue that you are seeing is a classic illustration of the shortcomings of languages with virtual dispatch
p29120
aVIdeally, you are looking for a function that is virtual with respect to more than one object, because the algorithm to determine if two shapes overlap or not depends on both shapes
p29121
aVYour second code snippet (with multiple concrete classes) is a start toward one common solution to the double dispatch problem, known as the visitor pattern
p29122
aVIt works better than a chain of --s, but it has a couple of shortcomings:
p29123
aVEvery time you add a new shape, all shapes must be extended with a method to check the overlap with the newly added shape
p29124
aVIt is not clear where to look for the definitive algorithm of, say,  overlapping  - in 's , or in 's
p29125
aVOne common solution is to introduce type IDs, and make a 2D array of delegates that process overlaps of geometric shapes
p29126
aVThis suffers from the first problem of the visitor, but fixes the second by centralizing the decision making
p29127
as(dp29128
g6
V335858
p29129
stp29130
a((dp29131
g2
(lp29132
VThis function is incorrect
p29133
aVIt compiles, but it does not do what you want it to do*
p29134
aVMathematical conditions such as this one
p29135
aVare written as follows in C:
p29136
aVYour condition should look like this:
p29137
aV* The result of comparing  is then compared to
p29138
as(dp29139
g6
V335858
p29140
stp29141
a((dp29142
g2
(lp29143
VA stack of limited size can be modeled using an array and an index for the "stack index"
p29144
aVStart the stack index at
p29145
aVOn push operations, increment the stack index, and store the value at the corresponding index of the array
p29146
aVOn pop operations, use the value at the stack index, and decrement the index after fetching the value
p29147
aVTo access the top of the stack, read the item at the stack index
p29148
as(dp29149
g6
V335858
p29150
stp29151
a((dp29152
g2
(lp29153
VThis is a common trick for the older C compilers (before C99): compilers allowed you to dereference elements past the end of 's declared length when it is the last element of the ; you could then  enough memory for the additional  elements, like this:
p29154
aVThe trick lets you embed arrays of variable size in a structure without a separate dynamic allocation
p29155
aVAn alternative solution would be to declare , but then you'd need to  and  it separately from the , unnecessarily doubling the number of s and potentially increasing memory fragmentation:
p29156
aVHere is how the above fragment would look without the hack:
p29157
aVEDIT (in response to comments by Adam Rosenfield): C99 lets you define arrays with no size, like this:  This is called flexible array member, it is defined in the section 6
p29158
ag838
ag839
ag1340
aV16 of the C99 standard
p29159
as(dp29160
g6
V335858
p29161
stp29162
a((dp29163
g2
(lp29164
VYour number exceeds the limit of , which is , or roughly
p29165
aVYour number is roughly , triggering an error
p29166
as(dp29167
g6
V335858
p29168
stp29169
a((dp29170
g2
(lp29171
VYou need to use , a format used specifically for null-terminated arrays of characters (i
p29172
ag630
aVC strings)
p29173
aVYou do not dereference the array's element when you pass it to , like this:
p29174
as(dp29175
g6
V335858
p29176
stp29177
a((dp29178
g2
(lp29179
V is a  method; you are probably looking for
p29180
aVYou can avoid  altogether by combining it with the initialization:
p29181
aVNote that there is another appending method of  that requires an assignment:
p29182
as(dp29183
g6
V335858
p29184
stp29185
a((dp29186
g2
(lp29187
VThe  keyword is used primarily for variable declarations
p29188
aVWhen you forward-declare a function, the keyword is optional
p29189
aVThe keyword lets the compiler distinguish a forward declaration of a global variable from a definition of a variable:
p29190
aVIf you keep this declaration by itself and then use  in your code, you would trigger an "undefined symbol" error during the linking phase
p29191
aVIf you keep this declaration in a header file and use it from several C/C++ files, you would trigger a "multiple definitions" error during the linking phase
p29192
aVThe solution is to use  in the header, and not use extern in exactly one C or C++ file
p29193
as(dp29194
g6
V335858
p29195
stp29196
a((dp29197
g2
(lp29198
VThe problem is that  expects a pointer to a null-terminated character sequence
p29199
aVIn your case, you are passing an address of a stand-alone  variable
p29200
aVIf the item in memory immediately after the  variable is not zero, you will trigger undefined behavior (appending garbage characters or crashing)
p29201
aVHere is how to do it correctly:
p29202
as(dp29203
g6
V335858
p29204
stp29205
a((dp29206
g2
(lp29207
VOne way to deal with circular references is to restructure your application
p29208
aVCreate project 4, and put the interfaces common to the projects in there
p29209
aVYou can include project 4 from all other projects
p29210
aVNow implement interfaces from that project in one of the three other projects, and use implementations through a factory mechanism of some sort (an inversion of control container is good too, but it may be an overkill for simpler applications)
p29211
as(dp29212
g6
V335858
p29213
stp29214
a((dp29215
g2
(lp29216
VIf you would like to do your filtering in LINQ, you can do it like this:
p29217
aVNow  contains a list of allowed extensions; you can add or remove items as necessary for flexible filtering
p29218
as(dp29219
g6
V335858
p29220
stp29221
a((dp29222
g2
(lp29223
VYou are correct, there is no reason to pass a pointer to pointer unless your function is intended to modify the pointer passed in
p29224
aVIn case of accessing an array of s, a single level of indirection is definitely sufficient
p29225
as(dp29226
g6
V335858
p29227
stp29228
a((dp29229
g2
(lp29230
VYou need  only for ; for  it's a simple :
p29231
as(dp29232
g6
V335858
p29233
stp29234
a((dp29235
g2
(lp29236
VOne way to reduce nesting is to define methods that return the individual blocks
p29237
aVIn order to facilitate the data sharing which is done "auto-magically" by the Objective C compiler through closures, you would need to define a separate class to hold the shared state
p29238
aVHere is a rough sketch of how this can be done:
p29239
aVNote: All of this assumes ARC; if you are compiling without it, you need to use  in the methods returning blocks
p29240
aVYou would also need to do a copy in the calling code below
p29241
aVNow your original function can be re-written without the "Russian doll" nesting, like this:
p29242
as(dp29243
g6
V335858
p29244
stp29245
a((dp29246
g2
(lp29247
VMy basic understanding about native method is that its used to call the method defined in native libraries
p29248
aVThis is correct, native methods represent calls of the code that is part of a natively compiled library
p29249
aVand they execute outside the JVM execution environment
p29250
aVThat is what native methods typically do
p29251
aVThat is, the native methods that Java users write
p29252
aVHowever, native methods are not limited in what they can do: once you're outside of JVM, you can do what you wish
p29253
aVIn fact, Java's built-in classes such as , heavily rely on the ability to do so, with dozens of  method sprinkled around their Java code
p29254
aVOne of these methods is package-private  (yes, with a zero)
p29255
aVThe implementation of  ultimately refer to this method, which queries the internals of JVM to fetch the class loader
p29256
aVNote that  cannot forward the call to , because that would return the 's class loader (because  would be the caller of )
p29257
aVIt is not possible for the  to repeat the "magic" of 's  either, because it is located in a different package (i
p29258
ag630
aVnot in the ), so  is not accessible
p29259
aVThat is why it is forced to move the  into the  territory, where the native code can obtain the calling class and fetch its class loader without restrictions
p29260
as(dp29261
g6
V335858
p29262
stp29263
a((dp29264
g2
(lp29265
VThere is no such feature in C: you have to declare the array using pointers, detect the "array is full" condition manually, call , make a copy into an extended array, and  the original one
p29266
aVEven the variable-length arrays would not work, because they let you set their size only once per the array lifetime
p29267
aVIn C++, you can use  instead of a plain array
p29268
aVYou still need to detect the "array is full" condition, but the  container takes care of all re-allocations and extensions on resizing for you
p29269
as(dp29270
g6
V335858
p29271
stp29272
a((dp29273
g2
(lp29274
VNo, it is not good enough
p29275
aVThe number of disks is particularly useless - although it is the goal of the game to collect as many as possible, the count on any move except for the last one is rather meaningless
p29276
aVHere are a few more things that you should take into consideration:
p29277
aVCounting the number of moves gives you a measure of immediate mobility; everything else being equal, situations when you can make a move that opens up more other moves should be favored
p29278
aVYou need to measure the potential mobility as well - the number of opponent's disks next to an open space
p29279
aVX squares - B2, B7, G2, and G7
p29280
aVPlacing your disk there early almost certainly gives away the adjacent corner, so your heuristic should give them high negative weight, at least in the first 40 moves
p29281
aVC squares - A2, A7, B1, G1, H2, H7, B8, and G8
p29282
aVThey offer the opponent access to corners, so their value should be different from that of other squares, at least when the edge has fewer than five disks
p29283
aVYou can read a relatively short description of the strategy used in building a relatively strong (in the sense of its ability to beat human novices) reversi applet here
p29284
as(dp29285
g6
V335858
p29286
stp29287
a((dp29288
g2
(lp29289
VThis is done because the compiler would not be able to figure out the overload in all contexts
p29290
aVFor example, if you call
p29291
aVthe compiler knows that you are looking for the second overload
p29292
aVHowever, if you call
p29293
aVlike this, the compiler has no idea which one of the two methods you wanted to invoke, because it is OK to call a method returning  and discard the result
p29294
aVTo avoid ambiguities like this, Java prohibits overloads that differ solely on the return type
p29295
as(dp29296
g6
V335858
p29297
stp29298
a((dp29299
g2
(lp29300
VJava does not provide a two-way hash table out-of-the-box
p29301
aVYour solution that relies on two hash tables is as good as it gets, unless you are willing to go with third-party libraries (which would hide the two hash tables for you) or re-implement a significant portion of
p29302
aVThen I can look up in either direction in O(1) time
p29303
aVHowever this seems like I am storing too much data - every name and every phone number is stored twice
p29304
aVNot necessarily: you can use the same object that represents the phone number, in which case there would be a single object for the phone number, with two references to it stored from two hash tables
p29305
as(dp29306
g6
V335858
p29307
stp29308
a((dp29309
g2
(lp29310
VIf you replace  with , you would need to check only for , not for the , and skip the call of :
p29311
as(dp29312
g6
V335858
p29313
stp29314
a((dp29315
g2
(lp29316
VNo, it is not possible: the number of dimensions ofn an array is a property of the array's type, not of the array object, so you cannot do this with built-in Java arrays
p29317
aVIn order to emulate an array that can change the number of dimensions at runtime you would need to build your own class
p29318
aVYou can base that class on an array or an , but there would be one limitation: you would not be able to use subscript operators on your emulated array
p29319
aVThere is also the "ugly" solution: you can store your array without a type - essentially, as a typeless
p29320
aVYou can assign arrays with any number of dimension to a variable of type , like this:
p29321
aVThe catch is that you cannot access elements of such array without performing a cast:
p29322
aVThis will compile and work, but the construct is rather unreadable:
p29323
aVAlso note that the prior content of the array will be lost on reassignment, unless you make a copy of it
p29324
as(dp29325
g6
V335858
p29326
stp29327
a((dp29328
g2
(lp29329
VThere is a difference between an expression being evaluated and completing its side effects
p29330
aVThe  assignment expression will be evaluated ahead of subtraction due to higher precedence of the parentheses
p29331
aVIt will provide the value of  as the result of the evaluation
p29332
aVThe writing of that value into , however, may not complete until the next sequence point, which in this case is the end of the full expression
p29333
aVThe end result of the overall expression is therefore undefined, because the subtraction may take the value of  before or after the assignment
p29334
as(dp29335
g6
V335858
p29336
stp29337
a((dp29338
g2
(lp29339
VYou can use , like this:
p29340
aVThis assumes that  has enough space to fit the string with the appended character
p29341
as(dp29342
g6
V335858
p29343
stp29344
a((dp29345
g2
(lp29346
VMethod group is an expression used in the C# standard to describe a group of one or more overloaded methods identified by their common name
p29347
aVIn this case, the compiler is referring to  and  method groups
p29348
aVYou need to call your method with a parameter in parentheses following the name of the method
p29349
aVIn addition, you need separate  variables for the apples and for the bananas:
p29350
aVRather than composing your strings manually with concatenations, you could use formatting, like this:
p29351
aVThis gives your code additional clarity by keeping the template of the string that you write together in a single string
p29352
as(dp29353
g6
V335858
p29354
stp29355
a((dp29356
g2
(lp29357
VThis is because pointers are passed by value, meaning that when you do
p29358
aVonly the local copy of the pointer that you passed is getting changed
p29359
aVTo fix this, pass start by pointer to pointer:
p29360
as(dp29361
g6
V335858
p29362
stp29363
a((dp29364
g2
(lp29365
VFirst you need to figure out in what order the operations are evaluated
p29366
aVUse associativity column from this table for help
p29367
aVNext, figure out what is the value of
p29368
aVUse  to try it out
p29369
aVFinally, figure out the value of the last expression, and run the program to see if your answer is correct
p29370
as(dp29371
g6
V335858
p29372
stp29373
a((dp29374
g2
(lp29375
VYou should add
p29376
aVkeyword before CGFloat declaration in the header, and define the variables without extern in the
p29377
aVm file to avoid defining your variables in multiple places
p29378
aVIn the header:
p29379
aVIn a
p29380
aVm file (one of them, any one)
p29381
as(dp29382
g6
V335858
p29383
stp29384
a((dp29385
g2
(lp29386
VYou can reduce in half the amount of wrapping reasonably cheaply by using  method to box a pair of coordinates as one  object instead of two
p29387
aVThis should also reduce the memory required to store the pairs
p29388
aVIf this is not enough, you could "bundle" more elements together in a single wrapper
p29389
aVFor example, if you know that your paths are created in groups of, say, 32 points, you can store arrays of 32  objects wrapped in  (use  method)
p29390
aVWhen you need a point at index , grab a group at index  from , unwrap from , and then take element at
p29391
aVIf everything else fails, make a class to represent an array of  structures by hiding calls of  and  behind a nice-looking Objective C interface
p29392
as(dp29393
g6
V335858
p29394
stp29395
a((dp29396
g2
(lp29397
VYou can do it in O(N^2) as follows: create a hash set of your integers so that you could check a presence or absence of an element in
p29398
aVAfter that, make two nested loops over all pairs of set elements
p29399
aVThis is done in
p29400
aVFor each pair , assume that , and calculate two numbers:
p29401
aVA triple  form an arithmetic sequence if
p29402
aVCheck both triples  and
p29403
aVYou can do it in  using a hash set, for a total running time of the algorithm of
p29404
as(dp29405
g6
V335858
p29406
stp29407
a((dp29408
g2
(lp29409
VThis depends on the kind of your map:
p29410
aVKeys of  must provide  and
p29411
aVKeys of  need to provide  by implementing  unless the map is constructed with a , in which case there are no restrictions on the key itself
p29412
as(dp29413
g6
V335858
p29414
stp29415
a((dp29416
g2
(lp29417
VSince on average you get 100 items per person, you can speed things up by processing multiple bytes at a time
p29418
aVI re-arranged the code slightly in order to use pointers instead of indexes, and replaced one loop by two loops:
p29419
aVIn my testing this speeds up your code from 1
p29420
aV515s to 0
p29421
aV855s
p29422
as(dp29423
g6
V335858
p29424
stp29425
a((dp29426
g2
(lp29427
VThe difference between pointers and references is that pointers can point to "nothing", while references cannot
p29428
aVYour second sample should null-check pointers before dereferencing them; there is no need to do so with references
p29429
as(dp29430
g6
V335858
p29431
stp29432
a((dp29433
g2
(lp29434
VA better solution is to use , like this:
p29435
as(dp29436
g6
V335858
p29437
stp29438
a((dp29439
g2
(lp29440
VThe reason that you do not match the second item is that the space between  and  is consumed by the trailing  of the first match
p29441
aVYou should make a non-consuming zero-width regexp for the trailing blank, for example by using the lookahead syntax or a token for zero-width boundary:
p29442
as(dp29443
g6
V335858
p29444
stp29445
a((dp29446
g2
(lp29447
VConsidering the truth table, the last condition is entirely superfluos
p29448
aVIt can be dropped without altering the logic of your program, like this:
p29449
aVNow you have a final catch-all , and your compiler is happy
p29450
aVYou don't have to remove the condition altogether - I often find it a good idea to keep it around in a comment for readability
p29451
as(dp29452
g6
V335858
p29453
stp29454
a((dp29455
g2
(lp29456
VAll characters do have numeric values assigned according to their corresponding codepoints in UNICODE (the initial 127 UNICODE code points match ASCII codes)
p29457
aVSpecifically, the numeric code of the "at" sign  is 64, and the code of the dollar sign '$' is 36
p29458
aVAlso note that digits are characters as well, so they too have numeric values (48 through 57)
p29459
as(dp29460
g6
V335858
p29461
stp29462
a((dp29463
g2
(lp29464
VThe  itself is OK, as long as you are not mutating the arrays stored as its elements
p29465
aVHowever, your usage pattern with  suggests that there is a better solution: if you use , you would be able to avoid doing manual synchronization
p29466
as(dp29467
g6
V335858
p29468
stp29469
a((dp29470
g2
(lp29471
VI think you are using the  object incorrectly: calling
p29472
aVprints
p29473
aV(link to ideone)
p29474
as(dp29475
g6
V335858
p29476
stp29477
a((dp29478
g2
(lp29479
VYou can create a static registry of classes, and populate it from constructors of static members that you insert into classes that you would like to register
p29480
aVIn the header:
p29481
aVIn the CPP file:
p29482
aVWith this class in hand, you can do this:
p29483
aVIn the headers:
p29484
aVIn the CPP files:
p29485
aVThis last part is key: declarations of the static  variables have a side effect - they insert the name into the  of the  class, in no specific order
p29486
aVYou can now retrieve the names, print them out, or do whatever you want with them
p29487
aVI added a member-function for printing, but obviously you are not limited by it
p29488
aVHere is a demo on ideone - it prints
p29489
as(dp29490
g6
V335858
p29491
stp29492
a((dp29493
g2
(lp29494
VYou declared a parameter called  (with an ), but you are referring to  (with an )
p29495
aVFixing this typo will address this particular error
p29496
aVThere may be more errors, though - it's hard to tell, because the snippet does not show essential parts, such as the declaration of  variable
p29497
as(dp29498
g6
V335858
p29499
stp29500
a((dp29501
g2
(lp29502
VStrings are almost definitely a wrong choice: they waste about half the space, if not more, and they make you waste CPU cycles to get the data back into the numeric format suitable for processing
p29503
aVA custom class with three primitive fields is a much better choice
p29504
aVDepending on the range and the type of your points, use , , , , , or
p29505
aVThis helps you avoid parsing the coordinates every time you are about to use your points
p29506
as(dp29507
g6
V335858
p29508
stp29509
a((dp29510
g2
(lp29511
VYou can use  member of the  and  function to copy the data into the arrays:
p29512
aVHowever, you don't have to do that unless you must pass non-constant  arrays around, because s look and feel much like character arrays, except they are much more flexible
p29513
aVUnlike character arrays, strings will grow to the right size as needed, provide methods for safe searching and manipulation, and so on
p29514
as(dp29515
g6
V335858
p29516
stp29517
a((dp29518
g2
(lp29519
VThe  method creates a shallow copy of the array, meaning that references to elements of the original array are copied to the new instance of  returned by
p29520
aVThat is why manipulating (adding/removing elements) the copy of the array does not alter the composition of the original array, while changes to elements of the array that allow mutation become "visible" through both copies of the array
p29521
as(dp29522
g6
V335858
p29523
stp29524
a((dp29525
g2
(lp29526
VSince C++ is a statically typed language with very limited type introspection capabilities, using templates is the best way to pass a type to a class, and the only way to let a class create new instances of a type
p29527
aVAn alternative would be to pass , but it would not work for your example, because it does not let you define new instances
p29528
as(dp29529
g6
V335858
p29530
stp29531
a((dp29532
g2
(lp29533
VThe problem in your code is due to the fact that "plain" C/C++ pointers have no concept of ownership
p29534
aVWhen a pointer gets copied, both copies* "think" that they own the data, leading to double-deletion
p29535
aVIn recognition of this fact, the designers of the C++ standard library introduced a  class that helps you address problems like that
p29536
aV* One copy of the pointer is in the instance of  passed to ; the other copy of the pointer is in the instance entered into the
p29537
as(dp29538
g6
V335858
p29539
stp29540
a((dp29541
g2
(lp29542
VYour code reads and discards the next line inside the loop:
p29543
aVessentially, the output of your program consists of lines that your program discards
p29544
aVYou should go through the "reading" loop without producing any output, and then go through the , and print out the content of lines with the line numbers where they were found
p29545
as(dp29546
g6
V335858
p29547
stp29548
a((dp29549
g2
(lp29550
VThe problem that you see has to do with reading from the elements of the arrays that have not been initialized, and therefore containing garbage values
p29551
aVYour first loop assign values to the top  elements, yet inside the  you have a loop that sorts and outputs the entire array
p29552
aVThis is undefined behavior, because you are reading from unassigned elements of the array
p29553
aVUsing  instead of  would fix this problem:
p29554
as(dp29555
g6
V335858
p29556
stp29557
a((dp29558
g2
(lp29559
VSorting the array simply to find an order statistics is too wasteful
p29560
aVYou can find the second largest element by following an algorithm that resembles the one that you already have, with an additional variable representing the second largest number
p29561
aVCurrently, the next element could be larger than the max or equal to/smaller than the max, hence a single  is sufficient:
p29562
aVWith two variables to consider, the next element could be
p29563
aVGreater than the max - the max becomes second largest, and the next element becomes the max
p29564
aVSmaller than the max but greater than the second largest - the next element becomes second largest
p29565
aVA special care must be taken about the initial state
p29566
aVLook at the first two items, and assign the larger one to the  and the smaller to the second largest; start looping at the element number three, if there is one
p29567
aVHere is how you can code it:
p29568
as(dp29569
g6
V335858
p29570
stp29571
a((dp29572
g2
(lp29573
VYou can avoid the  loop by using  twice:
p29574
as(dp29575
g6
V335858
p29576
stp29577
a((dp29578
g2
(lp29579
VI am not familiar with PHP, but you can concatenate all elements of a string array with :
p29580
aVThe first parameter is the separator; you can pass an empty string if you do not need separators
p29581
as(dp29582
g6
V335858
p29583
stp29584
a((dp29585
g2
(lp29586
VYou get a wrong number because when you prepend zero to an integer literal, Java interprets the number as an octal  (i
p29587
ag630
aVbase-8) constant
p29588
aVIf you want to add a leading zero, use
p29589
aVYou can also use the formated output functionality with the  specifier, like this:
p29590
aVmeans "use six digits"; '0' means "pad with zeros if necessary"
p29591
as(dp29592
g6
V335858
p29593
stp29594
a((dp29595
g2
(lp29596
VThat would be as simple as this:
p29597
aVThe expression requires that the string from the start  to the end  consisted of question marks  (square brackets prevent interpretation as meta-character) repeated one or more times
p29598
as(dp29599
g6
V335858
p29600
stp29601
a((dp29602
g2
(lp29603
VThere are two things you can do to simplify your access:
p29604
aVUse  instead of  as keys of your
p29605
aVUse autoreleased keys to avoid calls of
p29606
aVThis would simplify your code a little:
p29607
aVIf the number of code is relatively small, there is a good chance that there would be no allocation of  in the current implementation: according to this link,  will return the same object for low values of the integer
p29608
aVEDIT : Since property lists do not support keys of type other than , you need to convert the dictionary obtained from plist to a dictionary with  keys like this:
p29609
as(dp29610
g6
V335858
p29611
stp29612
a((dp29613
g2
(lp29614
VIt would be , where  is the number of elements in the sequence 1, and  is the number of elements in the sequence 2
p29615
as(dp29616
g6
V335858
p29617
stp29618
a((dp29619
g2
(lp29620
VUse  method to do this reordering
p29621
aVSupply the beginning of the array as the first parameter, the end of the array (i
p29622
ag630
aV) as the last parameter, and the "midpoint" as the second parameter
p29623
aVMidpoint defines the index of the element to be moved to the initial position
p29624
aVThis prints
p29625
as(dp29626
g6
V335858
p29627
stp29628
a((dp29629
g2
(lp29630
VYou can sort 2D arrays on their initial element using a custom :
p29631
as(dp29632
g6
V335858
p29633
stp29634
a((dp29635
g2
(lp29636
VThe problems with your code are (1) double-counting and (2) skipping the initial element in the nested loop
p29637
aVYou double-count because you ignore situations when ; you skip the initial element because you set
p29638
aVThe shortest solution is to use LINQ, like this:
p29639
aVNow you can print the results like this:
p29640
as(dp29641
g6
V335858
p29642
stp29643
a((dp29644
g2
(lp29645
VThis is because  is a keyword, and keywords in Objective C are case-sensitive*
p29646
aVSame goes for other keywords, such as
p29647
aV* This is not a universal rule: for example, VB
p29648
aVNET will accept both  and
p29649
as(dp29650
g6
V335858
p29651
stp29652
a((dp29653
g2
(lp29654
VIt appears that because the data is created lazily on first access, the pointer or the reference to your singleton is read-write
p29655
aVThis means that you do need a critical section
p29656
aVIn fact, the desire to avoid a critical section while keeping the lazy initialization in this situation has been so universally strong that it lead to the creation of the double-checked locking antipattern
p29657
aVOn the other hand, if you were to initialize your singleton eagerly before the reads, you would be able to avoid a critical section for accessing an immutable object through a constant pointer / reference
p29658
as(dp29659
g6
V335858
p29660
stp29661
a((dp29662
g2
(lp29663
VThis question translates to Prolog almost word-for-word
p29664
aVFirst, add the base case, saying that an empty list translates to an empty list:
p29665
aVNow add the main rule for grabbing the initial items, , , and , in groups of three, and averaging them:
p29666
aVNote the recursive invocation here: the tail  of the original list is converted to  in the call of  at the end of the rule
p29667
aVFinally, add two more cases for one-element list and for two-element list:
p29668
aVThat's it, you are done
p29669
as(dp29670
g6
V335858
p29671
stp29672
a((dp29673
g2
(lp29674
VThe Manhattan distance is easy to implement with
p29675
aVAlthough you can use  method for the Euclidean distance, calculating it is not hard at all:
p29676
aVIf you must expand this to higher dimensions, pass coordinates as arrays, and use a loop to compute the sum of squares
p29677
as(dp29678
g6
V335858
p29679
stp29680
a((dp29681
g2
(lp29682
VYour program has undefined behavior because there is a path that does not return at all
p29683
aVYou should add a  statement at the end:
p29684
as(dp29685
g6
V335858
p29686
stp29687
a((dp29688
g2
(lp29689
VThe reason the first snippet does not work is that the compiler re-interprets the sequence of characters as the value of a pointer, and then ignores the rest of the initializers
p29690
aVIn order for the snippet to work, you need to tell the compiler that you are declaring an array, and that the elements of that array are arrays themselves, like this:
p29691
aVWith this modification in place, your program works and produces the desired output (link to ideone)
p29692
as(dp29693
g6
V335858
p29694
stp29695
a((dp29696
g2
(lp29697
VStore the last time that you have given the user his free coins along with the remaining coins in the user defaults
p29698
aVWhenever you check the remaining "balance" of the coins, look at that additional variable, and compare it to the current time
p29699
aVIf the difference is greater than 24 hours, give the user additional coins, and store the new value in the defaults
p29700
as(dp29701
g6
V335858
p29702
stp29703
a((dp29704
g2
(lp29705
VThis should work:
p29706
aVis the  coordinate between  and  at the distance from  proportional to the value of ;  is the corresponding  coordinate
p29707
as(dp29708
g6
V335858
p29709
stp29710
a((dp29711
g2
(lp29712
VThe  method expects the entire string to match, not just a match to exist somewhere inside the target string
p29713
aVThis, on the other hand, returns , because it lets the string contain anything before or after the match:
p29714
aVAnother way to look for a match anywhere in the string is by using  directly:
p29715
as(dp29716
g6
V335858
p29717
stp29718
a((dp29719
g2
(lp29720
VHere is one way to do it using :
p29721
as(dp29722
g6
V335858
p29723
stp29724
a((dp29725
g2
(lp29726
VThe first way is more "canonical" because it has smaller footprint in memory, and does not require much CPU to do the conversion
p29727
aVThere is also no possibility of the precision loss due to conversion to decimal and back: the floats inside the s are stored in their native format
p29728
aVTo be fair, the differences between the two approaches are negligible, unless you need to deal with tens of thousands of objects
p29729
as(dp29730
g6
V335858
p29731
stp29732
a((dp29733
g2
(lp29734
VThe only way for a thread inside  of the running  to call  is for the  of the  to make the call to
p29735
aVIf this is not happening (i
p29736
ag630
aVmethods in your "mutually locked" group do not call each other), you are safe
p29737
as(dp29738
g6
V335858
p29739
stp29740
a((dp29741
g2
(lp29742
VTry this:
p29743
aVThis solution replaces counting with calculating a sum, and supplying  for matching items and  for non-matching ones
p29744
aVTo filter out the records where the two counts are different, add a  clause:
p29745
as(dp29746
g6
V335858
p29747
stp29748
a((dp29749
g2
(lp29750
VYou can do it with , like this:
p29751
aVLink to ideone
p29752
as(dp29753
g6
V335858
p29754
stp29755
a((dp29756
g2
(lp29757
VSince  implements , this documented behavior applies to it:
p29758
aVimplementations are thread-safe
p29759
aVAll queuing methods achieve their effects atomically using internal locks or other forms of concurrency control
p29760
aVThis means that no additional synchronization is necessary
p29761
as(dp29762
g6
V335858
p29763
stp29764
a((dp29765
g2
(lp29766
VNo, Java does not have anything similar to C#'s indexers or overloaded operators
p29767
aVThat is the most likely reason why the function call syntax is used in , , , and so on
p29768
as(dp29769
g6
V335858
p29770
stp29771
a((dp29772
g2
(lp29773
VThis is not going to work, because the  data is not embedded into the
p29774
aVInstead, it has a couple of pointers to the string content
p29775
aVThat is why  is not going to produce a valid result: the  will point to the place where a saved  once pointed, but it would no longer represent the data of interest
p29776
aVIf you would like to serialize the data like that, embed an entire  array in the , with the obvious limitation that there would be a cap on the number of characters and some wasted space
p29777
as(dp29778
g6
V335858
p29779
stp29780
a((dp29781
g2
(lp29782
VUnlike ,  does not use CPU cycles, so in this sense, the sleep is more efficient
p29783
aVIn general, using Busy Waiting outside of spinlocks is strongly discouraged
p29784
aVIf the thread is sleeping, is there anything that I should not be doing
p29785
aVSince your thread is blocked upon entry to , anything that you wish to do to its resources is a fair game
p29786
as(dp29787
g6
V335858
p29788
stp29789
a((dp29790
g2
(lp29791
VHere is one group of errors:
p29792
aVUnlike Java and C#, you cannot do initialization like that in C++ prior to C++11
p29793
aVIn your case it is also unnecessary: the only constructor that you have sets both  and , so the zeros that you are setting would be overwritten anyway
p29794
aVHere is another error:
p29795
aVYou cannot use identifiers that do not start in a letter or an underscore
p29796
aVThis should probably be
p29797
as(dp29798
g6
V335858
p29799
stp29800
a((dp29801
g2
(lp29802
VConsidering the way that you use your map, you will be better off with a , because the order of checking the lambdas will no longer be arbitrary, as in a hash-based dictionary
p29803
aVThis approach also lets you skip the lookup step:
p29804
as(dp29805
g6
V335858
p29806
stp29807
a((dp29808
g2
(lp29809
VThe language does not  and  for you, but it calls the constructor and destructor
p29810
aVThis is the standard behavior of C++: when you create an object, directly or indirectly, the constructor for the contained object gets called; similarly, when the containing object gets deallocated, the destructors of all contained instances get called as well
p29811
as(dp29812
g6
V335858
p29813
stp29814
a((dp29815
g2
(lp29816
VYou can change your  to return , indicating that the processing has been done
p29817
aVThis way the caller would be able to continue evaluating if necessary:
p29818
aVNow you can call it like this:
p29819
as(dp29820
g6
V335858
p29821
stp29822
a((dp29823
g2
(lp29824
VYou are missing a space between  and
p29825
aVAs the result, the SQL parser interprets  as a single identifier, resulting in a syntax error later on
p29826
as(dp29827
g6
V335858
p29828
stp29829
a((dp29830
g2
(lp29831
VHere is one implementation, take a look
p29832
aVTo be sure, it is a rather complex piece of code, with some 19 special cases
p29833
aVThe time complexity does not appear to be dependent on the values passed in
p29834
aVHere is a short description of the method used to compute :
p29835
aVCompute and return  in two pieces:
p29836
aV,
p29837
aVwhere  has  bit trailing zeros
p29838
aVPerform  by simulating muti-precision
p29839
aVarithmetic, where
p29840
aVReturn
p29841
as(dp29842
g6
V335858
p29843
stp29844
a((dp29845
g2
(lp29846
VYou can use a negative lookbehind to make sure that the quote is not escaped: the expression below
p29847
aVmatches a single quote unless it is immediately preceded by a slash
p29848
aVNote that slashes that go into string constants must be doubled
p29849
aVThe above prints
p29850
aVLink to ideone
p29851
as(dp29852
g6
V335858
p29853
stp29854
a((dp29855
g2
(lp29856
VSemicolon is a legitimate statement called null statement * that means "do nothing"
p29857
aVSince the  loop executes a single operation (which could be a block enclosed in ) semicolon is treated as the body of the loop, resulting in the behavior that you observed
p29858
aVThe following code
p29859
aVis interpreted as follows:
p29860
aVRepeat five times
p29861
aVdo nothing (semicolon)
p29862
aVOpen a new scope for local variables
p29863
aVPrint "hello"
p29864
aVClose the scope
p29865
aVAs you can see, the operation that gets repeated is , not the
p29866
aV* See K&R;, section 1
p29867
ag10442
ag839
as(dp29868
g6
V335858
p29869
stp29870
a((dp29871
g2
(lp29872
VYou should create an array of per-thread parameters, and pass these to the threads one-by-one
p29873
aVIn your case a single pointer to  is sufficient: you pass to the thread its index  from zero to , and the thread passes back the sum for rows such that
p29874
aVHere is how your thread function looks:
p29875
as(dp29876
g6
V335858
p29877
stp29878
a((dp29879
g2
(lp29880
VYou can calculate the percentage by dividing the  by the total, like this:
p29881
aVA more precise way to do it would be to calculate the Edit Distance between the strings, and then express that distance in terms of the percentage of the length of the original string (i
p29882
ag630
aVusing the edit distance instead of )
p29883
as(dp29884
g6
V335858
p29885
stp29886
a((dp29887
g2
(lp29888
VYou can combine the first special case with the last one
p29889
aVYou can also combine the second and third cases by looking at the  value of the coefficient
p29890
as(dp29891
g6
V335858
p29892
stp29893
a((dp29894
g2
(lp29895
V will not be freed upon return from , but it would not be a memory leak either: it's in the static storage, so there is nothing to "leak"
p29896
aVThe object will stay in memory for as long as your program is running
p29897
aVThe biggest downside to this happens when you start multithreading: your static variable runs a risk of being modified from multiple threads concurrently, which is something that you would rather avoid
p29898
aVDestructors for initialized objects of static storage duration (declared at block scope or at namespace scope) are called as a result of returning from main and as a result of calling exit
p29899
as(dp29900
g6
V335858
p29901
stp29902
a((dp29903
g2
(lp29904
VThe most likely reason why your program does not compile is that the  header is not compatible with pre-C11 compilers
p29905
aVAdd
p29906
aVto the flags of your g++ to enable C++11 support
p29907
aVOnce you do, you'd get a different error, because line 28 should be
p29908
aV(EDITED; original answer suggested a missing reference to )
p29909
as(dp29910
g6
V335858
p29911
stp29912
a((dp29913
g2
(lp29914
VAccording to section 8
p29915
ag14884
aV6 of the C++ standard,
p29916
aVIf an expression is specified in a parameter declaration this expression is used as a default argument
p29917
aVDefault arguments will be used in calls where trailing arguments are missing
p29918
aVSince  is not a call of the function, default arguments are ignored
p29919
aVIn fact, they are ignored in all contexts except the calls of the function, for example
p29920
aVwill not compile, and produce the same message that you get when trying to use  as a template parameter:
p29921
aVThis makes sense, because evaluating default arguments is a separate step in the invocation:
p29922
ag20244
ag14884
ag837
aV9: Default arguments will be evaluated each time the function is called
p29923
aVThe presence of default arguments does not alter the signature of your function
p29924
aVFor example, you cannot use a single-argument function with a default argument to override a no-argument virtual member function
p29925
as(dp29926
g6
V335858
p29927
stp29928
a((dp29929
g2
(lp29930
VIn a 24-bit number bit #7 (counting from the left, as you did in your example, not from the right, as is done conventionally) is always going to be in the second byte from the left
p29931
aVYou can solve your problem without converting the entire number to integer by taking that second hex digit, converting it to a number 0
p29932
aV15, setting its bit #3 (again counting from the left), and converting the result back to a hex digit
p29933
aVThis prints '022A05' (link to ideone)
p29934
as(dp29935
g6
V335858
p29936
stp29937
a((dp29938
g2
(lp29939
VYou should stop the timer as soon as you enter the function
p29940
aVOtherwise, the timer is ticking while the user is moving the cursor to the button to dismiss the message box:
p29941
as(dp29942
g6
V335858
p29943
stp29944
a((dp29945
g2
(lp29946
VThe simplest solution is running  twice:
p29947
as(dp29948
g6
V335858
p29949
stp29950
a((dp29951
g2
(lp29952
VYou need two nested loops to delete a 2D array of pointers - to delete individual robots, and to delete rows of robots:
p29953
aVAlthough it is normally a good idea to set a pointer to  after deletion, doing so in the destructor is a waste of CPU cycles; I recommend skipping is
p29954
aVThis is a lot of work (as I'm sure you can see)
p29955
aVUsing the standard C++ library can help you avoid all this work by using a suitable container - say,
p29956
aVNow the tasks related to managing the memory for your robots will be taken care automatically
p29957
as(dp29958
g6
V335858
p29959
stp29960
a((dp29961
g2
(lp29962
VI do not think there is a standard function that does this for you, but you can program a relatively straightforward algorithm for it:
p29963
as(dp29964
g6
V335858
p29965
stp29966
a((dp29967
g2
(lp29968
V executes after  because  is executed before  returns its value to the caller
p29969
aVThe value gets calculated and prepared to be returned, then the  block executes in its entirety, and only then the caller gets to proceed; this is when  gets called
p29970
as(dp29971
g6
V335858
p29972
stp29973
a((dp29974
g2
(lp29975
VUse  function to obtain the last inserted identity in the current scope
p29976
as(dp29977
g6
V335858
p29978
stp29979
a((dp29980
g2
(lp29981
VWhen you construct an array of reference objects, it constructs only an array, not the objects inside it
p29982
aVYou need to initialize the individual objects by calling constructors
p29983
aVYou can take a shortcut using LINQ, like this:
p29984
as(dp29985
g6
V335858
p29986
stp29987
a((dp29988
g2
(lp29989
VFirst, this is not a static array, it is an array allocated in the automatic storage
p29990
aVNext, the
p29991
aVis not a new declaration, it is a discarded read from element #4 of the previously declared 2-element array - an undefined behavior
p29992
aVAssignments that follow
p29993
aVwrite to the memory that is not allocated to your program - an undefined behavior as well
p29994
as(dp29995
g6
V335858
p29996
stp29997
a((dp29998
g2
(lp29999
VYour code is clean except for the part that you use to exchange the two-element arrays
p30000
aVThere are two ways to fix it:
p30001
aVUse an alternative representation of the array -  in which case you'll need to  and  individual elements, or
p30002
aVUse  to exchange two-element arrays in your swap code
p30003
aVWith only two elements to swap, you can exchange two-element arrays one integer at a time without using
p30004
aVThis is one way of doing it:
p30005
as(dp30006
g6
V335858
p30007
stp30008
a((dp30009
g2
(lp30010
VYou need to declare and initialize your static map separately
p30011
aVHere is the declaration piece:
p30012
aVHere is the initialization piece:
p30013
aVUnfortunately, arrays are always writable in Java
p30014
aVYou wouldn't be able to assign , but you would be able to add or remove values from other parts of your program that accesses the map
p30015
as(dp30016
g6
V335858
p30017
stp30018
a((dp30019
g2
(lp30020
VThe problem with your code is that you create a new instance of the , which gets discarded as soon as you are done with it
p30021
aVYou are calling the  method on the instance that is disconnected from the controller that is in control of the zoom screen
p30022
aVThe solution depends on the way that your communicating controllers are connected to each other
p30023
aVFor example, if you bring up  using a segue, you can access the destination controller inside  method
p30024
aVHere is an answer explaining how to do it
p30025
as(dp30026
g6
V335858
p30027
stp30028
a((dp30029
g2
(lp30030
VBoth your functions ( and , that is) make an implicit assumption that the right end of the interval being sorted/merged is included in the range being sorted
p30031
aVThis is unusual: a more typical approach is to include the left side of the interval, but exclude the right side
p30032
aVFor example, the call of  may look like this:
p30033
aVThis will not work with your implementation: it expects a call that looks like this:
p30034
aVPlease check the way that you call ; passing an inclusive right interval should fix the problem
p30035
as(dp30036
g6
V335858
p30037
stp30038
a((dp30039
g2
(lp30040
VThe answer depends a lot on the algorithms that you are planning to apply to your graphs
p30041
aVThere are two common ways to represent a graph - an adjacency list and an adjacency matrix
p30042
aVIn your case, and adjacency matrix is a square array of integers representing weights
p30043
aVYour representation uses an adjacency list
p30044
aVThere are algorithms that work better on adjacency matrixes (e
p30045
ag303
aVFloyd-Warshall algorithm)
p30046
aVOther algorithms work better on adjacency lists (e
p30047
ag303
aVDijkstra's algorithm)
p30048
aVIf your graph is sparse, using adjacency matrix may be prohibitive
p30049
as(dp30050
g6
V335858
p30051
stp30052
a((dp30053
g2
(lp30054
VIs re-defining a non-static method in a subclass with the same everything but as static overriding or hiding it
p30055
aVIt's neither, because doing so triggers a compilation error, rendering your program invalid
p30056
aVHiding happens when both methods in the pair are static methods; overriding happens when both methods in the pair are instance methods
p30057
aVWhen one of the two is a static method and the other one is an instance method, Java considers it an error
p30058
aVIt does not matter if the instance method is final or not; it also does not matter if the static method is in the base or in the derived class: Java calls it an error either way
p30059
aVThe compiler message that says "cannot override" is misleading, though: I think that "name collision" would have been a better name for such conditions, because "overriding" is reserved for situations with two instance methods
p30060
as(dp30061
g6
V335858
p30062
stp30063
a((dp30064
g2
(lp30065
VYou can check all lines at once using  method and LINQ:
p30066
aVThe  produces an enumerable of lines from the file; the  method lets you apply a condition to all lines of the file without a loop, and pick the first line where the condition applies
p30067
as(dp30068
g6
V335858
p30069
stp30070
a((dp30071
g2
(lp30072
VIf you would like to use the standard C++ library to its fullest, use input iterators and a  instead of an array:
p30073
aVUsing  fixes the problem of having to guess how many words would be entered, and living with the consequences of making a wrong guess
p30074
as(dp30075
g6
V335858
p30076
stp30077
a((dp30078
g2
(lp30079
VSet the delegate of your text field to an instance of  implementation, and use the  method to see if the user is attempting to change the  string:
p30080
aVI don't think there is a way to place the cursor directly, but you can make an empty selection after the trailing colon of the initial text as described in this answer
p30081
as(dp30082
g6
V335858
p30083
stp30084
a((dp30085
g2
(lp30086
VHow I can write hashCode() that returns unique hash value using the specified three attributes
p30087
aVIt does not have to be unique, only distinct enough to distinguish among non-equal values
p30088
aVOne common way is to use component hash codes, and combine them as  and so on
p30089
aVHere is how you do it: first, define  for the , like this:
p30090
aVYou need to override 's  as well
p30091
aVThen define the hash code for , like this:
p30092
aVThe code above assumes that the constructor initializes all components of the  to be non-null
p30093
as(dp30094
g6
V335858
p30095
stp30096
a((dp30097
g2
(lp30098
V expects a null-terminated string; you cannot pass a pointer to an individual character and expect it to work correctly
p30099
aVReplace
p30100
aVwith
p30101
aVto make it work
p30102
aVYou also need to set  to zero to avoid undefined behavior due to it not being initialized
p30103
as(dp30104
g6
V335858
p30105
stp30106
a((dp30107
g2
(lp30108
VTry adding a conditional match for the decimal part:
p30109
aVNote the use of non-capturing group for the decimal part
p30110
as(dp30111
g6
V335858
p30112
stp30113
a((dp30114
g2
(lp30115
VYou cannot do what you are trying to do, but there is a relatively easy way of achieving the same result by entering from a different direction
p30116
aVStrings do not identify types uniquely
p30117
aVThis is the basic problem with converting strings to types: when you see a , you have no idea where it came from
p30118
aVThe following is a valid class definition:
p30119
aVTwo overloads of  have parameters that look identical, yet they do not compare as equal
p30120
aVMoreover, there is absolutely no way of getting the  of the generic  without first getting the  for the generic  - a circular dependency
p30121
aVWhat can you do
p30122
aVInstead of going for the impossible -> conversion, you can build a matcher that tells you if an instance of a type, including an unbounded generic type, matches a given string representation:
p30123
aVWith this method in hand, you can walk through all available methods with a particular name, and check the types of their parameter lists one by one against the strings in your array of strings:
p30124
aVHow do you implement the  method
p30125
aVYou can use a technique similar to Recursive Descent Parsing: tokenize your string, and then match elements of your type as you go through the chain of tokens
p30126
aVWhen a class is parameterized, get generic parameters and match them recursively
p30127
aVYou need to pay attention to array types, but that is relatively simple as well
p30128
aVTake a look:
p30129
as(dp30130
g6
V335858
p30131
stp30132
a((dp30133
g2
(lp30134
VYou can use  manipulator to set the width of the output, like this:
p30135
aVThe  header needs to be included in order for this to compile
p30136
as(dp30137
g6
V335858
p30138
stp30139
a((dp30140
g2
(lp30141
VActually, you use  and  to access elements of the  inside an array, because in this case you are using a pointer to refer to a dynamically allocated array
p30142
aVThe  operator is simply a shorthand for
p30143
aVIn order to use it, you need a pointer on the left-hand side:
p30144
aVNote that even for a dynamically allocated array the  operator would have worked:
p30145
aVThis is equivalent to
p30146
aVbecause a pointer to an array is equal to the pointer to its first element
p30147
as(dp30148
g6
V335858
p30149
stp30150
a((dp30151
g2
(lp30152
VLong ago, before the first C++ standard has been published, some compiler implementations allowed you to write the following code inside a constructor:
p30153
aVThe technique served as the only way to control allocation of class of objects
p30154
aVThis practice has been prohibited by the standard, because overloading of the  has solved the problem that used to be tackled by assignments to
p30155
as(dp30156
g6
V335858
p30157
stp30158
a((dp30159
g2
(lp30160
VThe two methods have different semantic:
p30161
aVhas the semantic dictated by the  contract, while
p30162
aVhas the semantic that applies exclusively to  objects
p30163
aVSince the comparison is not apples-to-apples, it is fair that  would require more CPU cycles
p30164
aVIt is unlikely that you would notice the difference, however
p30165
aVIt is far more common for classes like yours to implement
p30166
aVThe semantic there calls for an ordering check, not just for an equality checks, but there is no requirement to take objects of unknown classes, letting you save CPU cycles
p30167
aVYou should have a good reason to provide an alternative to equality (e
p30168
ag303
aVa profiler run that points to  as a bottleneck, a perceived improvement on readability due to the change, or achieving richer semantic due to adopting an interface that does more)
p30169
aVDoing it for the sake of cutting a few CPU cycles would premature optimization
p30170
as(dp30171
g6
V335858
p30172
stp30173
a((dp30174
g2
(lp30175
V and its subclass  cannot contain multiple copies of the same object
p30176
aVis a singleton, hence adding it to a set multiple times results in adding only a single copy
p30177
aVIf you would like to be able to add multiple copies to a set, use  instead:
p30178
as(dp30179
g6
V335858
p30180
stp30181
a((dp30182
g2
(lp30183
VIn order to pretty-print a tree recursively, you need to pass two arguments to your printing function:
p30184
aVThe tree node to be printed, and
p30185
aVThe indentation level
p30186
aVFor example, you can do this:
p30187
aVThe initial call should be
p30188
aVIf you would like to print the tree with the root at the top, move  to the top of the
p30189
as(dp30190
g6
V335858
p30191
stp30192
a((dp30193
g2
(lp30194
VThere are pluses to each way of writing your loop:
p30195
aVThe first way is more debuggable: you can set a breakpoint on the , and inspect
p30196
aVThe second way avoids introducing a name  into the namespace, so you can use the name elsewhere
p30197
aVAs far as performance and readability go, both ways are equally good: the  will be called once before the start of the loop, so there are no performance or memory usage consequences to using the second code snippet
p30198
as(dp30199
g6
V335858
p30200
stp30201
a((dp30202
g2
(lp30203
VIt is not necessary that your code fails before : the call to  may have succeeded, but because the output to console is buffered, the program may have crashed before the output has been written to the screen
p30204
aVAdding  to the output string causes console buffer flush
p30205
aVIf you are looking to debug by s, you should always add  to the end of your format string
p30206
as(dp30207
g6
V335858
p30208
stp30209
a((dp30210
g2
(lp30211
VYes, it is absolutely OK to use these variables
p30212
aVDropping the  requirement altogether was a convenience: the  is now inserted implicitly - that is the only difference
p30213
aVDesigners of the compiler reasoned that since they can unambiguously identify situations when you want to synthesize accessors vs
p30214
aVsituations when you provide custom implementations, it is reasonable to stop asking you for an explicit
p30215
as(dp30216
g6
V335858
p30217
stp30218
a((dp30219
g2
(lp30220
VUsing parser productions in the lexer is not possible: lexer produces tokens ("words") that are later consumed by the parser, while parsers recognize sequences of words ("phrases")
p30221
aVThe lexer layer is below the parser layer; there is no "feedback channel" that would let the lexer "learn" of what the parser is doing
p30222
aVA parser rule like this
p30223
aVis, obviously, fine, because parser rules can refer to both lexer tokens and other parser rules
p30224
aVYou can use the  to match multi-token sequences
p30225
aVI would replace the inlined  with a named token, but that is a matter of preference
p30226
as(dp30227
g6
V335858
p30228
stp30229
a((dp30230
g2
(lp30231
VIt is not possible to construct a "plain" regex to recognize strings with balanced parentheses from strings with unbalanced parentheses, because the underlying programmable system of regex is not powerful enough to do it
p30232
aVFor the same reason, it is theoretically impossible to construct a regular expression that could recognize a well-formed XML*
p30233
aVEven if it were possible theoretically to construct such expression, it would not be practical: the amount of work needed to build a recognizer would be roughly the same as the amount of work needed to build a full-fledged XML parser
p30234
aVLuckily,
p30235
aVNET comes with several XML parsers already
p30236
aVA piece of code like this
p30237
aVwould do the trick
p30238
aV* There are various extensions, such as Perl's recursive regex and
p30239
aVNET balancing groups that let you work around this limitation
p30240
as(dp30241
g6
V335858
p30242
stp30243
a((dp30244
g2
(lp30245
VThere is no "elegant" way to deal with this - two ways of sharing the code of "do something else" are really of varying degree of non-elegance:
p30246
aVYou can put the "do something else" code into a function, or
p30247
aVDefine a flag before entering the  to say if additional processing is needed, and act on the flag upon exit from the  statement
p30248
aVThe first solution is self-explanatory; the second solution looks like this:
p30249
as(dp30250
g6
V335858
p30251
stp30252
a((dp30253
g2
(lp30254
VYou can create an  of dates, iterate your event list, and add only events the date for which you have not encountered before
p30255
as(dp30256
g6
V335858
p30257
stp30258
a((dp30259
g2
(lp30260
VA decent choice would be a list of three pairs of offsets from an origin for each piece (the fourth offset is )
p30261
aVThis would let you encode shapes as follows:
p30262
aVWith these lists in hand you would be able to draw shapes, check the "glass" for space availability for the corresponding shape, apply rotation, and place inside the glass at their final resting place
p30263
aVUnlike 2D structures that would require two nested loops for most operations, this structure would let you do testing with a single loop, or even without a loop if you unroll its trivial four steps
p30264
as(dp30265
g6
V335858
p30266
stp30267
a((dp30268
g2
(lp30269
VThe problem is that unless you call , the  is re-enumerated each time the  goes through the list, creating duplicate s
p30270
aVThe technique is known as the deferred execution
p30271
aVIn general,  does not assume that each time it enumerates a sequence it would get the same sequence, or even a sequence of the same length
p30272
aVIf this effect is not desirable, you can always "materialize" the sequence inside your  method by calling  right away, like this:
p30273
as(dp30274
g6
V335858
p30275
stp30276
a((dp30277
g2
(lp30278
VThe  statement of the C language cannot be used outside a function body to control a global declaration like that
p30279
aVYou can use the preprocessor's  instead:
p30280
aVThis is not too different from using -d constants, though
p30281
aVIf you would like to make the constants settable at runtime, - say, during initialization, - you will need to drop  from the declarations, and put the regular  into an initialization function - for example, the
p30282
as(dp30283
g6
V335858
p30284
stp30285
a((dp30286
g2
(lp30287
VYou are reusing the name that you gave to your array for the image that you are planning to parcel into individual elements
p30288
aVYou should give it a different name to make it work:
p30289
as(dp30290
g6
V335858
p30291
stp30292
a((dp30293
g2
(lp30294
VThere are three places where you can allocate an array in C:
p30295
aVIn the automatic memory (commonly referred to as "on the stack")
p30296
aVIn the dynamic memory (/), or
p30297
aVIn the static memory ( keyword / global space)
p30298
aVOnly the automatic memory has somewhat severe constraints on the amount of allocation (that is, in addition to the limits set by the operating system); dynamic and static allocations could potentially grab nearly as much space as is made available to your process by the operating system
p30299
aVThe simplest way to see if this is the case is to move the declaration outside your function
p30300
aVThis would move your array to static memory
p30301
aVIf crashes continue, they have nothing to do with the size of your array
p30302
as(dp30303
g6
V335858
p30304
stp30305
a((dp30306
g2
(lp30307
VThe problem is not with the accessibility of  but rather with its scope: the unqualified type name does not become in scope through friendship - you should use  instead
p30308
aVSame goes for the  variable: it should be
p30309
aVWith these two changes in place, your code compiles fine on ideone
p30310
as(dp30311
g6
V335858
p30312
stp30313
a((dp30314
g2
(lp30315
VThe easiest way is to use LINQ's  method:
p30316
as(dp30317
g6
V335858
p30318
stp30319
a((dp30320
g2
(lp30321
VYou can output  to the stream to move to the next line, like this:
p30322
as(dp30323
g6
V335858
p30324
stp30325
a((dp30326
g2
(lp30327
VYou can use LINQ on the results of , like this:
p30328
aVHere is what gets printed:
p30329
as(dp30330
g6
V335858
p30331
stp30332
a((dp30333
g2
(lp30334
VYou can use a little macro wizardry and a stringize operator of the preprocessor to do it
p30335
aVTake a look:
p30336
aVThe example is self-explanatory, except for the  macro
p30337
aVIt uses the  operator to produce a string constant that corresponds to its operand, letting you avoid repeating the name of the -d constant twice
p30338
aVHere is a link to ideone with this working example
p30339
as(dp30340
g6
V335858
p30341
stp30342
a((dp30343
g2
(lp30344
VMove the declaration of  inside the loop - put it right after the declaration of
p30345
aVThis would ensure that the word list is re-initialized each time that you go through a new sentence
p30346
as(dp30347
g6
V335858
p30348
stp30349
a((dp30350
g2
(lp30351
VNull termination is a concept that is applicable only to C strings; it does not apply to objects of  - they let you find the size by calling , and do not require null termination
p30352
aVHowever, strings returned from 's  function are null terminated, regardless of where the data for the string came from
p30353
aVC++11 standard describes the prerequisites of the  in the section 21
p30354
ag14885
ag10442
aV2:
p30355
aVReturns:  if
p30356
aVOtherwise, returns a reference to an object of type  with value , where modifying the object leads to unde\ufb01ned behavior
p30357
aVNote the , as opposed to : the standard explicitly allows  objects not to have null termination
p30358
as(dp30359
g6
V335858
p30360
stp30361
a((dp30362
g2
(lp30363
VThe call
p30364
aVdoes not do what you expect: the value passed in to  is a bit mask, not an expression
p30365
aVOnly bitwise ORs are allowed inside the expression
p30366
aVIn other words, you cannot say things that you don't want: you must say which things you do want
p30367
aVSo instead of passing  you should pass
p30368
aVAlternatively, you can get all properties, and then apply LINQ with its rich filtering semantic to remove the items you don't need:
p30369
as(dp30370
g6
V335858
p30371
stp30372
a((dp30373
g2
(lp30374
VThere are several ways to go about doing what you are looking for: you can use a "plain" C array with a count, or you can use an  with wrappers
p30375
aVThe first way would look like this:
p30376
aVThe second way looks similar, except now you need to use  to wrap the data going into :
p30377
as(dp30378
g6
V335858
p30379
stp30380
a((dp30381
g2
(lp30382
VYou are missing a  flag; without it,  is not treated as a regex meta-character:
p30383
aVThe above produces an empty output, as expected
p30384
as(dp30385
g6
V335858
p30386
stp30387
a((dp30388
g2
(lp30389
VFirst, the error is not on the  line, because the stack trace shows that your code entered the  method
p30390
aVThere is absolutely no point in adding  statements: in case  is , there would be no  assignment, but  would remain  because all unassigned positions in  are initially set to
p30391
aVIn order to fix the problem, you should first figure out what objects must be placed in the array instead of  parameters, and then modify the conditions as follows:
p30392
as(dp30393
g6
V335858
p30394
stp30395
a((dp30396
g2
(lp30397
VYou can change the regex as follows:
p30398
aVThe key change is this sub-expression at the end:
p30399
aVIt matches an optional comma character except when it is at the end of the match, in which case there must be no further characters
p30400
aVThis prevents you from matching a sequence that ends in a hanging comma
p30401
aVHere is the corresponding demo on ideone
p30402
as(dp30403
g6
V335858
p30404
stp30405
a((dp30406
g2
(lp30407
VMake your function non-static, add a variable to store the last item that you have displayed so far, use that variable to decide where to start the next listing, and advance that value by three each time that you go through the function
p30408
aVHere is a rough approximation to how you can do it - this will probably not work as a copy-paste replacement of your function, but it should give you an idea of what to do:
p30409
as(dp30410
g6
V335858
p30411
stp30412
a((dp30413
g2
(lp30414
VIt looks like you have both  and  inheriting a common class called *
p30415
aVAlter  to provide a way to differentiate the kinds of visits, for example, like this:
p30416
aVNow modify the constructors of  and  to pass the correct kind to the constructor of their superclass, like this:
p30417
aVNow you can examine the  property common to  and  in order to tell the kind of the visit at runtime:
p30418
aVThis solution is not ideal, because when someone adds a new kind of visit, the code that processes visits would continue compiling as usual
p30419
aVA solution to this problem is a lot harder than adding a property, though: one solution is to employ the Visitor Pattern which is better than a simple  attribute, but it has limitations of its own
p30420
aV* Naming a class with a plural of a noun is unconventional -  would probably be a better name
p30421
as(dp30422
g6
V335858
p30423
stp30424
a((dp30425
g2
(lp30426
Vis the pointer passed by thread-1 will be accessed by thread2
p30427
aVYes: since all threads operate in a common memory space, this is allowed
p30428
aV, , and other memory management functions are thread-safe by default, unless compiled with
p30429
as(dp30430
g6
V335858
p30431
stp30432
a((dp30433
g2
(lp30434
VNo, this is not a good way of doing it, because you pass around copies of :
p30435
aVreturns a copy of the  that it just pushed into the
p30436
aVIt's not in itself a wrong thing to do, but any manipulations the caller may do on the returned toggle would not be reflected on the one you pushed onto the
p30437
aVThe  loop goes through elements of the , creating a copy for use inside the loop body
p30438
aVUnless the  itself has a pointer-like semantic, the  action would not be reflected on  objects inside the
p30439
aVTo fix this issue, make  return a reference to the  object that it just pushed onto the , and use a  object to iterate through the stored toggles
p30440
aVThis would let you operate on the actual objects, rather than on their copies
p30441
as(dp30442
g6
V335858
p30443
stp30444
a((dp30445
g2
(lp30446
VThe only loss-less solution is to store the distance in the native units
p30447
aVAdd a single-character column designating the units in which the distance is expressed, and store a code (say,  for  and  for miles) along with the actual distance
p30448
aVIf adding a column is not an option, you can put the units in the upper bits of the number that you store: since the largest distance in your app is , you can use the remaining 12 bits of the number to encode the units in which the distance is expressed
p30449
aVUse  to extract the actual distance, and  to extract the units code ( for ,  for )
p30450
as(dp30451
g6
V335858
p30452
stp30453
a((dp30454
g2
(lp30455
VYour implementation of operator  may be comparing address components beyond the length:
p30456
aVSince  short-circuits the evaluation, the call of  will be made only when  evaluates to , meaning that
p30457
aVAs the result, the call of  will pass the larger of the two lengths, meaning that when the prefixes of both addresses up to  match,  will compare bytes beyond the valid portion of the address
p30458
aVTo fix this, you should pass  to  instead of
p30459
as(dp30460
g6
V335858
p30461
stp30462
a((dp30463
g2
(lp30464
VYou did not parenthesize your pointer expressions correctly: the  has higher priority, so you should add parentheses around the addition:
p30465
as(dp30466
g6
V335858
p30467
stp30468
a((dp30469
g2
(lp30470
VThe constructor for the object of the static field is called only once, at some point before the field is accessed for the first time
p30471
aVYou should not initialize static fields in a regular instance constructor
p30472
aVIf they need special initialization, you should supply a static initialization block, like this:
p30473
as(dp30474
g6
V335858
p30475
stp30476
a((dp30477
g2
(lp30478
VThis is the form of the forever loop that Kernighan and Ritchie used in their book*
p30479
aVThere is absolutely no other reason to prefer one form over the other
p30480
aV* Section 3
p30481
aV5 on While and For loops, example number four
p30482
as(dp30483
g6
V335858
p30484
stp30485
a((dp30486
g2
(lp30487
VWhy am I getting an error foro the default constructor and not the constructor below
p30488
aVThis is because operator  returns a pointer to , not a  itself
p30489
aVSince you are declaring a  as an object, you should simply remove the whole  part: the  will be initialized correctly by the compiler
p30490
aVA more modern approach is to use  in place of "raw" pointers
p30491
aVThis will ensure proper destruction automatically when the  is destroyed
p30492
as(dp30493
g6
V335858
p30494
stp30495
a((dp30496
g2
(lp30497
VYou need to start the  low enough; currently, you start it at zero - too low to "catch" the lowest element of the array
p30498
aVThere are two ways to deal with this:
p30499
aVUse  and  to start the  and , or
p30500
aVUse the initial element of the array to start both  and , then process the array starting with the second element
p30501
ag1971
ag1972
aVYou would find strange numbers printed, because you used characters instead of integers:
p30502
as(dp30503
g6
V335858
p30504
stp30505
a((dp30506
g2
(lp30507
VIt is a near certainty that the  has not been initialized: since the objects that you are adding are non-nil (you'd see an exception thrown otherwise) the  must be  then
p30508
aVYou need to set  to  in the designated initializer:
p30509
as(dp30510
g6
V335858
p30511
stp30512
a((dp30513
g2
(lp30514
VYou need to do this yourself; however, it is not that difficult:
p30515
aVNote that peeking once will keep the line locked in until you do a full
p30516
as(dp30517
g6
V335858
p30518
stp30519
a((dp30520
g2
(lp30521
VThis is because you are not calling  on the object that you get from the array:
p30522
aVWhat your code gets is an address of , which gets converted to a "junk"  value unrelated to the number that you stored in the array
p30523
as(dp30524
g6
V335858
p30525
stp30526
a((dp30527
g2
(lp30528
VThe reason that you get the error is that  does not implement , a condition that must be met by all classes that you supply as type arguments to  because of a type constraint that you placed on your generic type
p30529
as(dp30530
g6
V335858
p30531
stp30532
a((dp30533
g2
(lp30534
VThe  format specifier lets you scan a single numeric value, not a sequence of three numbers
p30535
aVYou can read a date in the format that you expect like this:
p30536
aVThe text is not parsed as three ints, but stored as a text instead
p30537
aVYou can break it into a month, a day, and a year like this:
p30538
as(dp30539
g6
V335858
p30540
stp30541
a((dp30542
g2
(lp30543
VThe line
p30544
aVgoes in a header file that you must include in order to use the variable ; this provides a declaration of the global variable
p30545
aVThe line
p30546
aVgoes into any of your cpp files to provide a definition for the global variable
p30547
aVThere must be exactly one definition among all cpp files in your program
p30548
as(dp30549
g6
V335858
p30550
stp30551
a((dp30552
g2
(lp30553
VYou should take the second option, i
p30554
ag630
aVpre-calculate a value or a sequence of values, and test with them
p30555
aVTesting a method with a copy of the same method serves no purpose other than increasing the amount of code duplication
p30556
as(dp30557
g6
V335858
p30558
stp30559
a((dp30560
g2
(lp30561
VThe title of the back button is set on the navigation item of the view controller that is pushed onto the stack before the current one, not on the navigation item of the current controller
p30562
aVThis is somewhat non-intuitive
p30563
aVIn the interface builder go to the view to which the back button leads, select its navigation item or add a new one, go to the "Back" button property, and enter the text that you would like to appear on the back button
p30564
aVNow go to the controller where you would like to have no title, and erase the text in the "Title" property of its navigation item
p30565
as(dp30566
g6
V335858
p30567
stp30568
a((dp30569
g2
(lp30570
VThe fractional portion of a  consists of 23 bits
p30571
aVYou need 30 bits to represent 825300160, so the less significant portion of the number is dropped
p30572
aVAdding  does not make a difference - you need to add roughly  for the number to change:
p30573
as(dp30574
g6
V335858
p30575
stp30576
a((dp30577
g2
(lp30578
VSince  is a primitive type, it cannot be used as a key in : you need to wrap it in  in order to do so
p30579
aVThis would work only if you use -wrapped integers as keys in your
p30580
aVIn general, since  is an associative container, you need to use the same key in the calls of  as you used in the calls of
p30581
as(dp30582
g6
V335858
p30583
stp30584
a((dp30585
g2
(lp30586
VDividing a 16-bit number by two is equivalent to shifting the number right by a single bit*
p30587
aVClear the carry flag, rotate the higher byte right through the carry, and then rotate the lower byte right through the carry
p30588
aVYou can find code for it here:
p30589
aV* Of course this is an integer division: when odd numbers are divided by two, the  is truncated
p30590
as(dp30591
g6
V335858
p30592
stp30593
a((dp30594
g2
(lp30595
VYou can use :
p30596
aV(Link to ideone
p30597
as(dp30598
g6
V335858
p30599
stp30600
a((dp30601
g2
(lp30602
VYou can do it like this:
p30603
aVThis approach does not require that the element be a full word (i
p30604
ag630
aVthe above fragment would return , even though the word  is not present there as a single word)
p30605
as(dp30606
g6
V335858
p30607
stp30608
a((dp30609
g2
(lp30610
VThe line
p30611
aVin the  function should be
p30612
aVOtherwise, you conditionally swap the first and the last number, and then quit right away
p30613
as(dp30614
g6
V335858
p30615
stp30616
a((dp30617
g2
(lp30618
VThere is no performance difference, so you should strive for improved readability
p30619
aVFor example, it is often a good idea to put the more "regular" path in the  branch, and put the "exceptional" one in the  branch
p30620
as(dp30621
g6
V335858
p30622
stp30623
a((dp30624
g2
(lp30625
VYou can write a simple and straightforward function to convert a date to a number that is good enough for ordering purposes by using :
p30626
aVCall the above function on both dates, and compare the  results; the returned value will be smaller for the earlier date
p30627
as(dp30628
g6
V335858
p30629
stp30630
a((dp30631
g2
(lp30632
VFor the duration of the program, will the memory every be recovered
p30633
aVNo: unless you magically guess the address of the lost variable and call , it is gone
p30634
aVCan the program write over this memory now, and reach a state where no memory has been lost
p30635
aVNo - again, once you've lost the reference to the address of the allocated memory region, you cannot recover the corresponding memory chunk
p30636
aVCan the Operating System recover it while the program is still running
p30637
aVNo, the operating system does not recover that memory until the process exits
p30638
as(dp30639
g6
V335858
p30640
stp30641
a((dp30642
g2
(lp30643
VYou can re-distribute the probability of the removed event in many ways, for example
p30644
aVProportionally - Replace each number with the value , where  is the sum of remaining probabilities
p30645
aVEqually - Divide the removed value by the number of remaining items, and add the result to each of the remaining probability
p30646
aVThe "correct" answer depends on the specifics of your problem
p30647
as(dp30648
g6
V335858
p30649
stp30650
a((dp30651
g2
(lp30652
VBut what about splitting text into lines
p30653
aVThe answer depends on where the text is initially: if the entire text is in a file, use ; if the text is in a , use
p30654
aVIn both cases, use  in a loop to extract lines from the text one-by-one:
p30655
aVAlso, your  function has an off-by-one error: you should simply add one to the result of , rather than using , like this:
p30656
aVThis will remove the initial space from the word being returned
p30657
as(dp30658
g6
V335858
p30659
stp30660
a((dp30661
g2
(lp30662
VOnce you have several tables in a join, you can continue joining to more tables, like this:
p30663
as(dp30664
g6
V335858
p30665
stp30666
a((dp30667
g2
(lp30668
VYou could make the compare function a  member function of the base class, rather than making it free-standing:
p30669
aVYou can use the function like this:
p30670
as(dp30671
g6
V335858
p30672
stp30673
a((dp30674
g2
(lp30675
VYou should use a string stream: write the string into it; then write the int
p30676
aVFinally, harvest the result through the  method of the stream:
p30677
aVHere is a link to a demo on ideone
p30678
as(dp30679
g6
V335858
p30680
stp30681
a((dp30682
g2
(lp30683
VThis is a type that represents a generic type definition:
p30684
as(dp30685
g6
V335858
p30686
stp30687
a((dp30688
g2
(lp30689
VThe compiler treats as arrays only variables declared as arrays, i
p30690
ag630
aVwith square brackets
p30691
aVPointers are not arrays, though, although you can treat array names as if they were pointers for the purposes of constructing pointer expressions
p30692
as(dp30693
g6
V335858
p30694
stp30695
a((dp30696
g2
(lp30697
VThe  functions are a kind of syntactic sugar - they offer more convenient syntax (no braces) without alter anything else, including performance
p30698
aVThe compiler does the same thing behind the scene, letting you use more convenient syntax
p30699
as(dp30700
g6
V335858
p30701
stp30702
a((dp30703
g2
(lp30704
VThe error suggests that you have a forward declaration of , but not a full definition of its corresponding structure
p30705
aVThat is why you can declare a pointer to , but you are not allowed to dereference its members
p30706
aVMake sure that the compilation unit that contains  has a  at the top for the header file that contains the definition of , this will fix this problem
p30707
as(dp30708
g6
V335858
p30709
stp30710
a((dp30711
g2
(lp30712
VThat's called grouping:
p30713
aVYou can iterate groups as if each element contained a list:
p30714
as(dp30715
g6
V335858
p30716
stp30717
a((dp30718
g2
(lp30719
VThe main difference is that the Strategy Pattern encapsulates a single group of related behaviors, while the Visitor Pattern encapsulates multiple such groups
p30720
aVYou should use the Strategy Pattern when you need to encapsulate a behavior - If you have a family of algorithms and you need to choose among them at run time, you should use Strategy Pattern
p30721
aVThis is very common: it happens every time you program to an interface
p30722
aVYou should use the Visitor Pattern to implement double dispatch - If you have a group of algorithms that need to be virtual in relation to more than one object
p30723
aVThis is far less common, in part because it is much harder to implement
p30724
as(dp30725
g6
V335858
p30726
stp30727
a((dp30728
g2
(lp30729
VThis is because there is a  type (its alias is ) but no : it's called  - its alias is
p30730
as(dp30731
g6
V335858
p30732
stp30733
a((dp30734
g2
(lp30735
VThe  way appears to be significantly slower - roughly 2
p30736
aV7 times in debug mode, and more than seven times in release mode
p30737
aVHere is my quick and dirty benchmark:
p30738
aVRunning this produces the following results:
p30739
aVIn debug mode
p30740
aVIn release mode
p30741
aVappears to be the slowest
p30742
aVThere appears to be little difference between  and
p30743
aVHowever,  appears to be the clear winner
p30744
as(dp30745
g6
V335858
p30746
stp30747
a((dp30748
g2
(lp30749
VThe three objects have the same type, but they are not the same instance
p30750
aVInstances of  could be configured differently; in this case, the three objects are configured to deal with buffering each in its specific way
p30751
aVThis makes sense: if all objects of the same class behaved in the same exact way, there would be no reason to make them separate objects in the first place
p30752
as(dp30753
g6
V335858
p30754
stp30755
a((dp30756
g2
(lp30757
VThese two expressions are different: the first one will take , but the second one wouldn't
p30758
aVThe expression from the book is pretty good at matching integers while disallowing leading zeros
p30759
as(dp30760
g6
V335858
p30761
stp30762
a((dp30763
g2
(lp30764
VThis is a problem of circular data dependency, not a circular destructor dependency
p30765
aVIf the chain of pointers  eventually lead to a , the destructor is going to terminate; if the trail of pointers leads back to the beginning, you will get undefined behavior on deleting the same object twice
p30766
aVThe problem is not much different from deleting a circular linked list: you can come back full circle if you are not careful
p30767
aVYou can use a common technique commonly known as tortoise and hare to detect / loops in your structure, and set the "back pointer" to  before triggering the chain of destructors
p30768
as(dp30769
g6
V335858
p30770
stp30771
a((dp30772
g2
(lp30773
VThis line
p30774
aVshould be
p30775
aVYour current code compares  to an empty string using , and discards the result of comparison
p30776
aVIt looks like you are after getting the first argument into the string , so you need an assignment
p30777
as(dp30778
g6
V335858
p30779
stp30780
a((dp30781
g2
(lp30782
VI want to combine each element of allcats into single string, then map it into one array
p30783
aVTry this:
p30784
as(dp30785
g6
V335858
p30786
stp30787
a((dp30788
g2
(lp30789
VThis should work:
p30790
aVThe inner query selects IDs where all values of  are set to
p30791
aVIt achieves this result by checking that tere are no rows with the same ID and a different status
p30792
aVHere is a demo on sqlfiddle
p30793
as(dp30794
g6
V335858
p30795
stp30796
a((dp30797
g2
(lp30798
VYour operator should return
p30799
aVIn addition, you should implement an implicit conversion operator of  to :
p30800
aVThe problem is that the structure of  is not homogenous: the compiler cannot know what it is going to get from the  operator, yet you must specify the exact type
p30801
aVOne alternative would be to use  in the return, but its use comes with significant performance penalties
p30802
as(dp30803
g6
V335858
p30804
stp30805
a((dp30806
g2
(lp30807
VSince it's not a function or a property, you cannot invoke the member like that
p30808
aVYou should get its value first, cast it as appropriate, and only then invoke the result, like this:
p30809
as(dp30810
g6
V335858
p30811
stp30812
a((dp30813
g2
(lp30814
VIn the first example,  is a parameter
p30815
aVIt will be initialized by the callers with whatever value they choose to pass in
p30816
aVIn the second example,  is an uninitialized variable
p30817
aVReading it before it gets assigned (as you did) is undefined behavior, because it contains garbage at the time
p30818
as(dp30819
g6
V335858
p30820
stp30821
a((dp30822
g2
(lp30823
VInheritance constitutes an is a relation: if  inherits , it means that  can go wherever  is allowed to go
p30824
aVThis is precisely what your code snippet is showing: you can add an instance of , a subclass of  to a  where any subclass of  can go
p30825
as(dp30826
g6
V335858
p30827
stp30828
a((dp30829
g2
(lp30830
VYou are absolutely correct, you can rely on  being called relatively soon after the last reference is released (manually or though ARC, it does not matter)
p30831
aVUnlike GC where the finalizer is called when the system has some free time, or in some cases is never called,  gets called very reliably
p30832
aVApple allows and even encourages using this pattern by suggesting that we should perform all of our resource clean-up tasks inside
p30833
aVThis does not mean, however, that you should rely on  exclusively
p30834
aVFor example, take a look at the  class: it offers you an explicit  method, letting you force closing the stream at will, without waiting for the call of  to happen
p30835
aVThis is a very good pattern to follow in case the resource is very expensive (file handles, semaphores, etc
p30836
aV: the primary mechanism for releasing these resources should be a separate  method
p30837
aVThe  method should release the resource as well, but it should also issue a warning, informing your that you missed a call of
p30838
as(dp30839
g6
V335858
p30840
stp30841
a((dp30842
g2
(lp30843
VThe documentation for the  parameter of the constructor states that
p30844
aV- the comparator used to order this priority queue
p30845
aVIf null then the order depends on the elements' natural ordering
p30846
aVThis means that when a  is specified, the natural ordering established by the  method is ignored
p30847
as(dp30848
g6
V335858
p30849
stp30850
a((dp30851
g2
(lp30852
VThread safety does not depend on whether or not a class has a name
p30853
aVIn the first case, you share an instance of a named class among all threads; you can easily do the same exact thing with your second, anonymous, class
p30854
aVMoreover, you can share  variables declared in the outer scope among instances of an anonymous class
p30855
aVEven though the variable must be final, it does not mean that its instance would be immutable
p30856
aVIn cases like that, anonymous classes would most certainly be non thread-safe
p30857
aVSo the answer from your title question is "no, not all anonymous classes are thread-safe"
p30858
aVYou need to explicitly design your class with thread safety in mind, regardless of whether it is named or not
p30859
as(dp30860
g6
V335858
p30861
stp30862
a((dp30863
g2
(lp30864
VYou should remove parentheses around the table name:
p30865
aVMySQL considers queries like this syntax errors:
p30866
aVYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '(mytable) where id=2' at line 1
p30867
aV(I'll assume that you know everything about SQL injection attacks, and that neither  nor  are constructed from user input in any shape or form)
p30868
as(dp30869
g6
V335858
p30870
stp30871
a((dp30872
g2
(lp30873
VThis is because your base case () does not return right away
p30874
aVYou only assign , but do not return: instead, you go with  again, entering into infinite recursion
p30875
aVFix by replacing with
p30876
aVor adding an :
p30877
as(dp30878
g6
V335858
p30879
stp30880
a((dp30881
g2
(lp30882
VThis is not going to work: two identically composed dictionaries will not compare as equal to each other (link to ideone)
p30883
aVIn general, you should not key your dictionary on anything mutable
p30884
aVMake a method that converts a dictionary to a "canonical  representation", and use that  as a key in your dictionary
p30885
as(dp30886
g6
V335858
p30887
stp30888
a((dp30889
g2
(lp30890
VYou started along the right path when you included  inside
p30891
aVAdd the include guards to your headers, this will help you avoid duplicate inclusions:
p30892
aVNow you can safely include  at the top of , and your problem will be solved
p30893
as(dp30894
g6
V335858
p30895
stp30896
a((dp30897
g2
(lp30898
VYou can try this expression:
p30899
as(dp30900
g6
V335858
p30901
stp30902
a((dp30903
g2
(lp30904
VSince calling  throws an exception when  does not exist, rather than returning , you should call
p30905
aVto see if the field is there:
p30906
aVSince  short-circuits evaluation when  is , the  would not be evaluated
p30907
aVIn case the  could contain s, you could use the  trick to avoid null reference exceptions:
p30908
as(dp30909
g6
V335858
p30910
stp30911
a((dp30912
g2
(lp30913
VYou can use a very simple query that compares counts:
p30914
aVWhat it says is that the number of records in  for the given player must equal the total number of records in
p30915
aVDemo on sqlfiddle
p30916
as(dp30917
g6
V335858
p30918
stp30919
a((dp30920
g2
(lp30921
VThis is simpler in LINQ2SQL than in SQL:
p30922
aVThis will return the list of items with largest values of  in its , together with
p30923
aVIn SQL you would need to join back to the original table, like this:
p30924
as(dp30925
g6
V335858
p30926
stp30927
a((dp30928
g2
(lp30929
VThis is because , a wrapper over the primitive , is immutable, and Java passed object references by value
p30930
aVAny change made to the object reference inside the method has no effect on the object passed in: the reference is replaced with a reference to a new object, yet the original remains intact because it is immutable
p30931
aVTo address this issue, you need another level of indirection - you can use an array, a mutable int from apache commons, or roll your own suitably designed class
p30932
as(dp30933
g6
V335858
p30934
stp30935
a((dp30936
g2
(lp30937
VYou go though that many iterations because there are that many combinations: this is called combinatorial explosion
p30938
aVYou cannot do it more efficiently if you must go through all possible combinations
p30939
aVYou can code it with fewer lines of code or without hard-coding the number of arrays (five in your case) by using recursion
p30940
aVHowever, the number of iterations is not going to change, only the number of lines of code
p30941
as(dp30942
g6
V335858
p30943
stp30944
a((dp30945
g2
(lp30946
VThis is because you keep adding the same object, and you mutate it in each iteration of the loop
p30947
aVYou allocate  only once, then you configure and add it to the list
p30948
aVWhen the item in the list, however, you reconfigure it and add it to the list the second time
p30949
aVNow you have two items configured as the last item
p30950
aVThen you configure it as the third item, and add it again
p30951
aVAll three items are configured the same, though: the previous two parameters and types are gone
p30952
aVOnce the loop finishes, you have  copies of the same last item in your list
p30953
aVMove the  inside the loop to fix the problem:
p30954
aVBetter yet, make your  immutable, and pass it the parameters in the constructor:
p30955
as(dp30956
g6
V335858
p30957
stp30958
a((dp30959
g2
(lp30960
VFrom the documentation of  (the emphasis is mine):
p30961
aV: Field number for get and set indicating the month
p30962
aVThis is a calendar-specific value
p30963
aVThe first month of the year in the Gregorian and Julian calendars is JANUARY which is 0; the last depends on the number of months in a year
p30964
aVHuman calendars start January at one, not at zero
p30965
aVThat is why December ends up at eleven instead of twelve
p30966
as(dp30967
g6
V335858
p30968
stp30969
a((dp30970
g2
(lp30971
VYou should replace double quotes with single quotes around , and use :
p30972
aVA single character enclosed in single quotes means "a character"; a single character enclosed in double quotes means "a one-character C string"
p30973
aVA single  means "assignment"; a double   means "compare"
p30974
as(dp30975
g6
V335858
p30976
stp30977
a((dp30978
g2
(lp30979
VUnlike instance variables that require only a declaration, static member variabs of the class must also be defined
p30980
aVCurrently, your code contains only a declaration
p30981
aVAdd a definition of your static  variable to a cpp file to fix the error:
p30982
as(dp30983
g6
V335858
p30984
stp30985
a((dp30986
g2
(lp30987
VYour merge algorithm makes an assumption that
p30988
aVAlthough it is correct for your program, it is not generally a good thing to make such assumptions
p30989
aVChange the merge algorithm to go through both arrays until you hit the length of the shorter one, then dump the remaining elements of the longer array into the tail of the merged array
p30990
aVYou can do it all in a single loop, like this:
p30991
as(dp30992
g6
V335858
p30993
stp30994
a((dp30995
g2
(lp30996
VAll -d items are straightforward text substitutions: imagine that the  is pasted in instead of the  identifier:
p30997
aVSince  is an integer literal, you should use
p30998
as(dp30999
g6
V335858
p31000
stp31001
a((dp31002
g2
(lp31003
VIt looks like you are missing some square brackets
p31004
aVOther than that minor syntax issue, your program logic is fine:
p31005
aVEDIT: As false commented, the second rule needs to change against consuming a  by mistake, to avoid  from succeeding
p31006
aVLink to a demo on ideone
p31007
as(dp31008
g6
V335858
p31009
stp31010
a((dp31011
g2
(lp31012
VThe  method is intended for use with SQL BLOB types, such as , , and so on
p31013
aVFor the numeric types you need to use , , or a numeric primitive
p31014
aVThe issue with allowing  to be used with non-binary types is system independence: you would need to match the driver's expected layout for a multi-byte number with potentially vey complex structure that JDBC driver writers would need to publish
p31015
aVOnce this layout is published, their driver would have to remain compatible with it for life
p31016
aVMost driver writers, however, would prefer to avoid such tight coupling with the client code
p31017
as(dp31018
g6
V335858
p31019
stp31020
a((dp31021
g2
(lp31022
VThis happens because your first program increments a pointer, while in the second program you apply the  operator to an array
p31023
aVAlthough arrays often behave like pointers, they are not pointers
p31024
aVArrays support pointer arithmetics, but they do not support pointer operators that treat them as  (i
p31025
ag630
aVattempt to modify where they point)
p31026
aVFixing the problem is trivial - simply create a pointer that points to the array, and use that pointer in your loop, like this:
p31027
as(dp31028
g6
V335858
p31029
stp31030
a((dp31031
g2
(lp31032
VStatic methods and fields belong to all objects in a class, as opposed to non-static ones, which belong to a particular instance of a class
p31033
aVIn your example, no matter how many  objects you create, accessing  would produce the same exact result
p31034
aVTo state this fact explicitly,  members (also known as "class members") are used
p31035
aVSame logic applies to static methods: if a method does not access instance variables, its result becomes independent of the state of your object
p31036
aVThe  method is one such example
p31037
aVOther common examples include various factory methods, parsing methods for primitives, and so on
p31038
aVThese methods do not operate on an instance, so they are declared static
p31039
as(dp31040
g6
V335858
p31041
stp31042
a((dp31043
g2
(lp31044
VYou can use LINQ and  methods together to do it in a single line of code:
p31045
as(dp31046
g6
V335858
p31047
stp31048
a((dp31049
g2
(lp31050
VThis is probably not going to work, because all  will be set to point to the same exact location of
p31051
aVYour basic idea, however, is fine: you can "parcel out" a large buffer into smaller "words" by following the same basic idea
p31052
aVYou need to make sure, however, that you do not point to intersecting areas of the buffer, and that the areas to which you point your words are null-terminated
p31053
aVFinally, the idea of walking though  to find the next  every time is suboptimal: you should store the last location to which you have written, increment it on the next write, and remove the  loop
p31054
as(dp31055
g6
V335858
p31056
stp31057
a((dp31058
g2
(lp31059
VThe only thing that gets dropped is name mangling of externally visible names
p31060
aVFunction overloading by parameter types, as well as by parameter count, stop working as the result
p31061
aVEssentially, name resolution during the linking phase goes back to the plain old C mode (i
p31062
ag630
aVone name - one entry)
p31063
aVAs far as the internals of your implementation go, you can continue using the standard library and all the other nice features of C++11
p31064
aVOnly the names of externally visible entities get changed by
p31065
as(dp31066
g6
V335858
p31067
stp31068
a((dp31069
g2
(lp31070
VThere is no way to know the size ahead of reading, so the most common solution is to save the size before saving the data
p31071
aVThe reader than reads the size, allocates enough memory, and procedes with reading the data the regular way
p31072
aVThe other less common way is to save markers in the file to indicate where each row of data ends
p31073
aVIn a way, this is similar to null-terminating your strings in C, where the length of the string is not stored explicitly, but must be recomputed each time
p31074
aVThis method has a disadvantage of not allowing pre-allocation
p31075
aVIn other words, you would either need to allocate enough memory to accommodate the data of any legal size, or re-allocate dynamically as you go
p31076
as(dp31077
g6
V335858
p31078
stp31079
a((dp31080
g2
(lp31081
VThe difference between  and  is that the former preserves the expression the programmer (i
p31082
ag630
aVyou) wrote to present it to the query engine that performs the query (i
p31083
ag630
aVthe RDBMS)
p31084
aVFiguring out that  is a function that needs to be evaluated would work, but that is too much magic compared to a simple and straightforward solution with familiar and easily recognizable syntax:
p31085
aVHaving to guess would rob programmers of the opportunity to pass functions such as  to the RDBMS: it is entirely conceivable that the current database date/time is different from your application server, potentially resulting in a different set of rows
p31086
aVOn the other hand, introducing the  syntax would be pointless, because if you must mark the expression to be evaluated, you might as well do it using the familiar way (see your code that I pasted above)
p31087
as(dp31088
g6
V335858
p31089
stp31090
a((dp31091
g2
(lp31092
VWhen the most significant bit of a 32-character binary number is set to , the resultant value exceeds the range of positive numbers supported by , and can no longer be interpreted as a valid integer number
p31093
aVThis causes the exception according to the documentation:
p31094
aVAn exception of type NumberFormatException is thrown if any of the following situations occurs:
p31095
aVThe first argument is null or is a string of length zero
p31096
aVThe radix is either smaller than Character
p31097
aVMIN_RADIX or larger than Character
p31098
aVMAX_RADIX
p31099
aVAny character of the string is not a digit of the specified radix, except that the first character may be a minus sign '-' ('\u005cu002D') provided that the string is longer than length 1
p31100
aVThe value represented by the string is not a value of type int
p31101
aV(emphasis is mine)
p31102
aVIn order to enter this negative binary value, use  sign in front of your number, and convert the remaining bits to 2-s complement representation
p31103
aVIf you need numbers that are longer than 32 bits, or if you would like the value to continue being interpreted as a positive number, you would need to switch to the 64-bit integer data type
p31104
as(dp31105
g6
V335858
p31106
stp31107
a((dp31108
g2
(lp31109
VYou shouldn't use two nested loops then: two nested loops create a Cartesian product (i
p31110
ag630
aVevery name is paired up with every value)
p31111
aVIf you use a single loop that goes through names and values at the same time, you'd get your expected output
p31112
aVIf you are using
p31113
aVNET 4, you could use  method, like this:
p31114
as(dp31115
g6
V335858
p31116
stp31117
a((dp31118
g2
(lp31119
VYou can fix your query by adding a group by, like this:
p31120
aVHowever, a better approach would be to use a join:
p31121
as(dp31122
g6
V335858
p31123
stp31124
a((dp31125
g2
(lp31126
VAccording to the C99 standard, two s would not have compatible types even if their declarations were identical
p31127
aVFrom the section 6
p31128
ag838
ag838
aV5:
p31129
aVEXAMPLE 2 After the declarations
p31130
aVtype  and the type pointed to by  are compatible
p31131
aVType  is also compatible with type , but not compatible with the types , , the type pointed to by , or
p31132
aVMoreover, two types with different qualifiers are not considered compatible:
p31133
aVFor two qualified types to be compatible, both shall have the identically qualified version
p31134
aVof a compatible type; the order of type qualifiers within a list of specifiers or qualifiers
p31135
aVdoes not affect the specified type
p31136
aVA cleaner approach would be to hide your  altogether, replace it with an obscure handle (a  on top of ) and provide functions for manipulating the elements of the
p31137
aVThis way you would retain full control over the structure of your : you would be able to rename its fields at will, change the layout as much and as often as you wish, change underlying types of the fields, and do other things that you normally avoid when the inner layout of the  is known to your clients
p31138
as(dp31139
g6
V335858
p31140
stp31141
a((dp31142
g2
(lp31143
VYes, ReSharper is right:  enumerates unconditionally, and then if the  or the  is not negative , the  would enumerate  again
p31144
aVIt appears that once ReSharper decides that something is at risk of being enumerated multiple times, it flags every single reference to the item in question with the multiple enumeration warning, even though it's not the code that is responsible for multiple enumeration
p31145
aVThat's why you see the warning on so many lines
p31146
aVA better approach would add a separate call to set the count
p31147
aVYou can do it upfront in a separate statement, like this:
p31148
aVThis way you would be able to leave  in its pre-enumerated state until the final call of
p31149
as(dp31150
g6
V335858
p31151
stp31152
a((dp31153
g2
(lp31154
VYou can use the  function from the standard library instead of writing your own loop:
p31155
aVYou can also use the  function inside your loop:
p31156
as(dp31157
g6
V335858
p31158
stp31159
a((dp31160
g2
(lp31161
VAlthough separate methods will nearly certainly be better in terms of performance, it is highly unlikely that you should notice the difference
p31162
aVHowever, having separate methods should definitely improve readability a lot, which is a lot more important
p31163
as(dp31164
g6
V335858
p31165
stp31166
a((dp31167
g2
(lp31168
VThe  local variable accumulates the value of the decimal number that is passed to this function in the string
p31169
aVThis is an implementation of , without the validity checks
p31170
aVHere is the workings of the loop body:
p31171
aVAssign to  the result of multiplying the prior value of  by ten plus the current character code at the pointer  less the code of zero; increment  after dereferencing
p31172
aVSince digit characters are encoded sequentially, the  expression represents a decimal value of a digit
p31173
aVLet's say that you are parsing the string
p31174
aVAs you go through the loop,  starts at zero; then it gets assigned the following values:
p31175
as(dp31176
g6
V335858
p31177
stp31178
a((dp31179
g2
(lp31180
VYou can get the right text field by calling :
p31181
as(dp31182
g6
V335858
p31183
stp31184
a((dp31185
g2
(lp31186
VYou should not include C++ files in other C++ files
p31187
aVThis leads to doubly-defined symbols
p31188
aVInstead, you should create a header file with a forward declaration, include it in both files sharing the function, and compile the files separately:
p31189
aVnumGen
p31190
aVh:
p31191
aVInclude  in both  files, and remove
p31192
as(dp31193
g6
V335858
p31194
stp31195
a((dp31196
g2
(lp31197
VYou can do it like this:
p31198
aVThere is a little trick there: although you can pass  to , the type that it is going to produce will not be the same as that returned by
p31199
aVHere is an excerpt from the documentation:
p31200
aVThe common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays
p31201
aVA vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension
p31202
aVYou cannot use this method overload to create a vector type; if  is , this method overload returns a multidimensional array type that happens to have one dimension
p31203
aVUse the  method overload to create vector types
p31204
as(dp31205
g6
V335858
p31206
stp31207
a((dp31208
g2
(lp31209
VHere is how you can estimate a quick count of the number of times the collection is enumerated: wrap your collection in a , and increment counter on each , like this --
p31210
aVThen change your array declaration to this,
p31211
aVrun your query, and print the
p31212
aVFor your query, the code prints 30 (link to ideone), meaning that your collection of five items has been enumerated six times
p31213
as(dp31214
g6
V335858
p31215
stp31216
a((dp31217
g2
(lp31218
VYour algorithm decides that a word is an anagram too soon - in fact, as soon as it can match the first letter of the first word to any letter of the second word:
p31219
aVThe easiest algorithm for anagram detection in Java is as follows:
p31220
aVConvert  and  to arrays of characters  and
p31221
aVSort  and
p31222
aVCreate strings  and  from sorted arrays
p31223
aVReturn
p31224
as(dp31225
g6
V335858
p31226
stp31227
a((dp31228
g2
(lp31229
VThe compiler is complaining about this part
p31230
aVinside your  clause
p31231
aVYou should change it so that
p31232
aVthere is a  clause at the end, and
p31233
aVit makes up an expression that evaluates to  for  objects that you would like to keep
p31234
aVHere is my best guess at what you are trying to do (EDIT : attempt number two)
p31235
as(dp31236
g6
V335858
p31237
stp31238
a((dp31239
g2
(lp31240
VThere is a default second parameter of  that tells what value you'd like to insert into the additional space
p31241
aVIf that value is not specified, the default-constructed value is used instead
p31242
aVIf  is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of
p31243
aVIf  is specified, the new elements are initialized as copies of , otherwise, they are value-initialized
p31244
aVYour example is entirely legitimate: your vector of vectors will contain ten empty vectors
p31245
as(dp31246
g6
V335858
p31247
stp31248
a((dp31249
g2
(lp31250
VTry this:
p31251
as(dp31252
g6
V335858
p31253
stp31254
a((dp31255
g2
(lp31256
VIf you must use a fixed-size array, you could find the  values for each coordinate separately, and use these values for the initialization:
p31257
as(dp31258
g6
V335858
p31259
stp31260
a((dp31261
g2
(lp31262
VIt is possible to implement a search of static cells in a table
p31263
aVHowever, since the data source behind your table is hidden in the , you need to put in the "clues" for your search into the cells themselves
p31264
aVI would strongly caution against using the standard cell classes, because they provide no place to store the data on which you search, except for a label or two
p31265
aVUsing labels, however, is not a good choice, because it may hamper your localization efforts
p31266
aVA better approach would be to define a custom class for your , introduce additional properties on which to search, set these properties in the Interface Builder through the User Defined Runtime Attributes section of the Identity Inspector, and use these attributes during the searches initiated by the
p31267
aVHere is an example: define a class for your custom cell
p31268
aVIn the Identity Inspector of each static cell, choose  for the type
p31269
aVIn the User Defined Runtime Attributes panel, click [+], choose "string" for the type, enter  for the name, and set the searchable content into the value
p31270
aVNow your  can take cells from 's , cast them to , and examine their  property to determine if the cell should be included into search results or not
p31271
aVWhen your search is over, you may need to highlight cells that have been found, or to hide cells that do not fit the search criteria
p31272
aVWhile highlighting can be done without altering the data source, hiding requires more significant overrides
p31273
aVHere is a question discussing approaches to hiding static cells in a
p31274
as(dp31275
g6
V335858
p31276
stp31277
a((dp31278
g2
(lp31279
VMaking a copy of your tree in the front end is necessary, because it stands for a different concept: while the tree in the back end represents the model, the tree in the front end represents a view of the model
p31280
aVThis is a very important distinction: the tree in the back end says what to display, while the tree in the front end says how to display it
p31281
aVSpecifically, the front end knows what portions of the tree are expanded: back end should not know it, because the open/close state of the tree nodes will be different for different users
p31282
aVPerhaps what you should do is to make the separation of duties explicit
p31283
aVRather than making a copy of the tree and adding unique identifiers to its resource ID, make a separate class for , encapsulating the ID of the actual item, and having a unique ID of its own (the unique ID would never go to the back end):
p31284
aVOne way to ensure uniqueness of the IDs is to use the  class: it provides a very convenient  method, providing you with a unique identifier
p31285
as(dp31286
g6
V335858
p31287
stp31288
a((dp31289
g2
(lp31290
VYou should start by observing that move 9 is always forced: there is only one empty square on the board
p31291
aVMove can be considered 8 forced as well, because after seven moves there could be exactly three situations:
p31292
aVcan win on the next move, in which case it takes the win
p31293
aVPlacing an  in either one of the two remaining squares wins the game for , in which case  has lost regardless of its next move
p31294
aVhas zero or one path to victory, in which case  blocks to force a draw
p31295
aVThis means that the game is over after at most seven moves
p31296
aVAlso observe that there are only three opening moves: the center, a corner, or a side
p31297
aVIt does not matter which of the four corners or sides you take, because the board can be rotated to match a "canonical" opening (the upper-left corner or the middle of the top side)
p31298
aVYou can now build your state analysis code
p31299
aVStarting with each of the three possible openings, search with backtracking up to six additional moves using all squares that are open by the time you make the move
p31300
aVAfter each move, analyze the position to see if  or  has already won; mark wins by  as Wx, and wins by  as Wo
p31301
aVThe remaining positions are undecided
p31302
aVDo not explore positions after Wx or Wo: simply return to the prior step, reporting the win by the corresponding side
p31303
aVWhen you reach the seventh move, statically analyze the position to decide if it is one of the three situations described above is applicable, marking the position a Wx, Wo, or a Draw
p31304
aVNow to the most important step: when you backtrack to the move  by the player ,
p31305
aVIf one of the moves that you try is such that all position at the next level becomes Wp, declare the current position a Wp as well
p31306
aVIf all of the moves that you try lead to the win of the opponent, declare the current position a win for the opponent
p31307
aVOtherwise, declare the current position a Draw, and return to the prior level
p31308
aVIf you do this right, all three opening positions will be classified as a Draw
p31309
aVYou should see some forcible wins after three moves
p31310
aVRunning this procedure classifies each position as a Wx, Wo, or a Draw
p31311
aVIf your AI gets you a win for the player  in a position classified as Wp, or gets you a draw in a position classified as a Draw, then your AI is perfect
p31312
aVIf, on the other hand, there are positions that are statically classified as Wp in which the AI gets  only a draw, then your AI engine needs an improvement
p31313
aVAdditional reading: you can find additional insights into the game in this article describing methods of counting possible games of Tic-Tac-Toe
p31314
as(dp31315
g6
V335858
p31316
stp31317
a((dp31318
g2
(lp31319
VI am concerned that this is overly complicated
p31320
aVIs there a better way
p31321
aVThe short answer is "No, there isn't" 1
p31322
aVThe long answer: The "overly complicated" captures the essence of the problem: it is NP-hard
p31323
aVHere is a short informal proof relying upon the fact that the satisfiability problem is NP-complete:
p31324
aVSuppose that you have two Boolean formulas,  and
p31325
aVYou need to test if  implies , or equivalently  for all assignments of variables upon which  and  depend
p31326
aVIn other words, you need a proof that  is a tautology
p31327
aVSuppose that the tautology test can be performed in polynomial time
p31328
aVConsider , the inverse of
p31329
aVis satisfiable if and only if  is not a tautology
p31330
aVUse the hypothetical polynomial algorithm to test  for being a tautology
p31331
aVThe answer to "is  satisfiable" is the inverse of the answer to "is  a tautology"
p31332
aVTherefore, an existence of a polynomial tautology checker would imply that the satisfiability problem is in , and that
p31333
aVOf course the fact that the problem is NP-hard does not mean that there would be no solutions for practical cases: in fact, your approach with the conversion to a canonical form may produce OK results in many real-world situations
p31334
aVHowever, an absence of a known "good" algorithm often discourages active development of practical solutions2
p31335
aV1 With the obligatory "unless " disclaimer
p31336
aV2 Unless a "reasonably good" solution would do, which may very well be the case for your problem, if you allow for "false negatives"
p31337
as(dp31338
g6
V335858
p31339
stp31340
a((dp31341
g2
(lp31342
VYou need to implement a breadth-first search or a depth-first search
p31343
aVStart at , and stop when you reach , or when you exhaust all options
p31344
aVIn your case, the depth-first search is somewhat easier to implement, because "plain" C lacks built-in dynamic queues needed for the breadth-first search
p31345
aVIf you do not care about the efficiency and you do not mind updating the matrix, implement the Floyd-Warshall algorithm: it is formulated specifically for adjacency matrices, and takes only five lines to implement:
p31346
aVAfter running this algorithm, the resultant  contains the transitive closure of the original one
p31347
as(dp31348
g6
V335858
p31349
stp31350
a((dp31351
g2
(lp31352
VFirst, lowercase  is not a variable, it's an atom
p31353
aVMake  uppercase to fix the problem:
p31354
aVSecond, you do not type this into the interpreter
p31355
aVRather, you write it into a file , and then read that file into Prolog
p31356
aVAt the command prompt, type this:
p31357
aVPress enter
p31358
aVNow you can use your  rule
p31359
aVFinally, since the assignment talks about lists, I think the instructor wanted you to write , not :
p31360
as(dp31361
g6
V335858
p31362
stp31363
a((dp31364
g2
(lp31365
VThrowing away recursion in an algorithm that is a natural fit for recursion is not a good idea
p31366
aVRather, you need to memoize your recursive solution
p31367
aVThis common trick speeds up recursive solutions with common subproblems by orders of magnitude
p31368
aVConsider these two sequences of moves:
p31369
aVand
p31370
aVThe sequences are different, but they arrive at the same final state:
p31371
aVHere is the root cause of the slowness: when your program arrives at a repeated state for the second time, it evaluates the position exactly as if it's the first time that it has seen it
p31372
aVThis is wasteful: identical positions with three-move look-aheads will be evaluated four times; with four-move look-aheads, they would be evaluated eight times, and so on
p31373
aVThis causes slowness proportional to , where  is the depth of your look-ahead
p31374
aVFixing this requires an addition of a lookup table
p31375
aVGiven a state of the game, this table would give you the score for you or for the opponent, if such score has been calculated before
p31376
aVYour recursive functions would build a position key, and try a lookup in the score table
p31377
aVIf the answer is there, it would be returned immediately
p31378
aVOtherwise, your function would construct the answer, and store it at the position key
p31379
aVNext time the same position occurs through a different series of moves, the answer would be reused
p31380
as(dp31381
g6
V335858
p31382
stp31383
a((dp31384
g2
(lp31385
VThis is a case of so-called "Yoda Conditions" (item #1)
p31386
aVAlthough it is possible to rationalize them in C/C++, there is no reason to use them in Java
p31387
aVIn C/C++, expressions of any type can go into s and s
p31388
aVWriting
p31389
aVinstead of
p31390
aVis a common error among novices
p31391
aVYoda conditions were supposedly a remedy to address this problem, at the cost of "Yodifying" your code: C/C++ would trap assignments to
p31392
aVbut "reversed"  checks are OK:
p31393
aVSince Java considers non-boolean expressions inside control blocks of , , and  to be errors, it would trap  in place of , triggering an error
p31394
aVTherefore, there is no reason to give up readability by "Yodifying" your expressions
p31395
as(dp31396
g6
V335858
p31397
stp31398
a((dp31399
g2
(lp31400
VAlthough it does not look like you can connect s to s (or there are too many restrictions placed on using them), there is a simple solution that works when you use storyboards
p31401
aVThis code goes into your  method:
p31402
as(dp31403
g6
V335858
p31404
stp31405
a((dp31406
g2
(lp31407
VI was wondering the correct way to do this
p31408
aVYou should use the  method; you just need to provide type parameters to use with generics:
p31409
as(dp31410
g6
V335858
p31411
stp31412
a((dp31413
g2
(lp31414
VYou need to remove the  after the  to make it work:
p31415
aVYou do not need  for booleans inside control statements, either
p31416
aVFinally, making single-character substrings is more expensive than using single characters
p31417
aVConsider using  instead:
p31418
as(dp31419
g6
V335858
p31420
stp31421
a((dp31422
g2
(lp31423
VThere is no built-in collection that does what you need, but you can build your own relatively easily:
p31424
aVWrite an implementation of
p31425
aVPut a  and a  inside
p31426
aVWhen adding an element to , also add its key to
p31427
aVWhen iteration is requested, iterate  and then look up entries in the
p31428
aVIf your collection is organized that way, you'd be able to re-order the keys independently of the dictionary entries
p31429
aVYou need to be careful in the implementation because of double "bookkeeping" that should be going on in the operations that change the dictionary
p31430
aVOther than that, the solution should be relatively straightforward
p31431
as(dp31432
g6
V335858
p31433
stp31434
a((dp31435
g2
(lp31436
VYou can do it roughly the same way that you do now - by formatting an  in a loop, but instead of using one insert per the new/old pair, use one statement for all pairs
p31437
aVYou should use column names explicitly to avoid relying on the column order in the table (a big no-no in production) and to avoid creating the second parameter in a loop, even though you always send a  to it
p31438
aVAt this point, you have a SQL string that looks like this:
p31439
aVYou also have a list of  for each of the parameters, so you can do this:
p31440
aVThe advantage of doing it in one go is that you make a single round-trip to your database no matter how many records you must insert
p31441
aVOther than that, the solution follows the same pattern as your current one, so the performance should be comparable
p31442
as(dp31443
g6
V335858
p31444
stp31445
a((dp31446
g2
(lp31447
VWhy does char* take 4 bytes when char takes 1 byte
p31448
aVBecause you are on a 32-bit systems, meaning that pointers take four bytes;  is a pointer
p31449
aValways takes exactly one byte, so you do not need to multiply by :
p31450
aVI am assuming that  is already padded for null termination
p31451
as(dp31452
g6
V335858
p31453
stp31454
a((dp31455
g2
(lp31456
VUsing  is a little unorthodox, but here it is anyway:
p31457
aVFinally, if you do not mind a little helper class, you can do this:
p31458
aVNow you can do this:
p31459
as(dp31460
g6
V335858
p31461
stp31462
a((dp31463
g2
(lp31464
VHere is a link to an excellent post explaining how to use  channels to make copies of streams
p31465
aVIt introduces a helper method  that lets you copy streams like this:
p31466
as(dp31467
g6
V335858
p31468
stp31469
a((dp31470
g2
(lp31471
VYour code does not do anything: the exit condition of the loop is , meaning that  will always pass  to
p31472
aVThis is OK, but it does not de-allocate anything
p31473
aVYou should change your loop to stop when , but you must be extra careful to make sure that you do not dereference  when it is equal to :
p31474
aVEDIT : Your edited code mimics my answer to a large extent, except yours would fail if
p31475
aVIt would also fail if the list has exactly one node, because  would remain unassigned
p31476
as(dp31477
g6
V335858
p31478
stp31479
a((dp31480
g2
(lp31481
VUse Associative References - this is tricky, but that is the mechanism invented specifically for your use case
p31482
aVHere is an example from the link above: first, you define a reference and add it to your object using ; then you can retrieve the value back by calling
p31483
as(dp31484
g6
V335858
p31485
stp31486
a((dp31487
g2
(lp31488
VArrays do not have  and  members
p31489
aVYou can use array name for  and array name plus length for the end:
p31490
aVIn C++11, you can use  and , like this:
p31491
aVIn both cases, it is a good idea to declare your  array file-static or hide it in a namespace, to make sure that its name does not "pollute" the global namespace
p31492
as(dp31493
g6
V335858
p31494
stp31495
a((dp31496
g2
(lp31497
VThere is a built-in way to test if two lines are identical, but there is no built-in way to tell if two lines are similar
p31498
aVYou need to implement an algorithm that measures string similarity, such as the Levenshtein Distance - a very common Edit Distance algorithm
p31499
aVLines with small edit distance can be declared similar depending on some threshold specific to your requirements
p31500
as(dp31501
g6
V335858
p31502
stp31503
a((dp31504
g2
(lp31505
VYou are missing a dot before the asterisk
p31506
aVYour expression will match any number of uppercase s
p31507
aVYou should also add a capturing group unless you want to capture everything, including the  and the
p31508
aVFinally, you should use the right API to search the string, rather than attempting to match the string in its entirety
p31509
aVThis prints
p31510
as(dp31511
g6
V335858
p31512
stp31513
a((dp31514
g2
(lp31515
VThe author makes a simple cost/benefit analysis of a potential feature of operator overloading in a non-static way, and concludes that the benefits do not justify the costs: you can easily mimic the functionality of instance overloading of operators by dispatching to a virtual method from inside of a statically overloaded operator
p31516
aVHowever, the costs of letting you define overloaded operators without an intermediate virtual functions are great:
p31517
aVYou introduce asymmetry in the way your operators work ( may be illegal while  is OK)
p31518
aVYou need to deal with  references on the left-hand side
p31519
aVSingle dispatch would not address your problem anyway, so you'd end up doing additional dispatch work inside the operator
p31520
aVAt the end, the author notes that rather than introducing a feature that introduces much confusion without a significant benefit, they went for a cleaner design that can be extended to provide comparable levels of functionality
p31521
as(dp31522
g6
V335858
p31523
stp31524
a((dp31525
g2
(lp31526
VYou should use
p31527
aVis a protected method, while  is a public event
p31528
as(dp31529
g6
V335858
p31530
stp31531
a((dp31532
g2
(lp31533
VYou have an extra dereference there, the code should be like this:
p31534
aVIdeally, your  function should take , because it does not modify the strings passed in
p31535
as(dp31536
g6
V335858
p31537
stp31538
a((dp31539
g2
(lp31540
VYou should make sure that the variable that backs the property has a different name
p31541
aVIt is common to use camelCase for it:
p31542
aVMoreover, in situations where the getter ans setter are trivial, starting with C# 3
p31543
aV0 you can use automatic properties, like this:
p31544
aVThis lets you remove the backing variable: the compiler will take care of it for you
p31545
as(dp31546
g6
V335858
p31547
stp31548
a((dp31549
g2
(lp31550
VThe runtime type of the object remains  even when you assign it to the variable statically typed as the interface
p31551
aVThe type defines the behavior, while the interface defines which methods you can call without a cast
p31552
as(dp31553
g6
V335858
p31554
stp31555
a((dp31556
g2
(lp31557
VSave the last string in a variable, check the new value against the old one, and skip the operation if the two are equal
p31558
aVWhen the value is different, run the operation, and update the prior value to match the new one:
p31559
as(dp31560
g6
V335858
p31561
stp31562
a((dp31563
g2
(lp31564
VAlthough Objective-C does have an /, it is not going to help you much
p31565
aVBy the time you get to the , the stack frame where the error happens would be gone
p31566
aVWhat you need is to set up a breakpoint that breaks on exception: open the Breakpoint Navigator page (the second button from the right), and click [+] at the bottom of the navigator page
p31567
aVChoose "Add Exception Breakpoint
p31568
aV, then click [Done]
p31569
aVNow the program is going to break in the debugger each time that your program throws an exception
p31570
as(dp31571
g6
V335858
p31572
stp31573
a((dp31574
g2
(lp31575
VYes, you can do that
p31576
aVIn order for an object to be compatible with , it must have a  function:
p31577
aVThe  class must, in turn, implement , like this:
p31578
aVEnd Class
p31579
aVNow you can make  private, and iterate your  as follows:
p31580
aVYou can see a complete example here
p31581
as(dp31582
g6
V335858
p31583
stp31584
a((dp31585
g2
(lp31586
VNo, you cannot do it like that
p31587
aVThe type in C++ must be known at compile time, not at run time
p31588
aVYou can return  from a function, but you cannot use that  to declare variables of the corresponding type
p31589
as(dp31590
g6
V335858
p31591
stp31592
a((dp31593
g2
(lp31594
VThis is not because of the underscore, but because of the way you are sizing your array: you limited the elements to six characters, and the elements with underscores are the only ones that run over that length; the other four strings require only five s, so they fit into the elements of size six
p31595
aVYou should either declare this as an array of pointers, like this
p31596
aVor give your strings more space, like this:
p31597
as(dp31598
g6
V335858
p31599
stp31600
a((dp31601
g2
(lp31602
VYou can use the , like this:
p31603
aVNote the  at the beginning of the character range: it means "all characters not covered by the rest of the list in square brackets"
p31604
aVSince the replacement is an empty string, the characters matching the regex would be removed
p31605
as(dp31606
g6
V335858
p31607
stp31608
a((dp31609
g2
(lp31610
VYou talk about a second array (the result), yet your code declares only one array
p31611
aVAdditionally, you reference , but your  has not be initialized
p31612
aVYou should declare another array , initialize  to zero, and then use this code when you find a square:
p31613
as(dp31614
g6
V335858
p31615
stp31616
a((dp31617
g2
(lp31618
VIf you must use LINQ, you can do this:
p31619
aVHowever, with strings it is much more conventional to use s:
p31620
as(dp31621
g6
V335858
p31622
stp31623
a((dp31624
g2
(lp31625
VI would expand upon your second suggestion a little by adding explicit names for the parts of your product, and using semicolons in place of commas to separate product attributes, since the order does not matter*
p31626
aVNote how  and  are switched around for the second product, because the order of attributes does not matter
p31627
aV* There is a convention to use commas when the order is important, and semicolons when the order is not important
p31628
as(dp31629
g6
V335858
p31630
stp31631
a((dp31632
g2
(lp31633
VMake the decimal separator  optional, and change the description part to "anything but space", like this:
p31634
aVThe rest of your program works fine, and does not require any modifications (link to ideone)
p31635
as(dp31636
g6
V335858
p31637
stp31638
a((dp31639
g2
(lp31640
VThe most common way to do something like that is in a factory method, rather than an initializer:
p31641
as(dp31642
g6
V335858
p31643
stp31644
a((dp31645
g2
(lp31646
VSince you are using a storyboard, you should be opening the detail controller on a segue
p31647
aVLook up the segue identifier (say, it's ) in the story board, then add the following code to your initial controller:
p31648
as(dp31649
g6
V335858
p31650
stp31651
a((dp31652
g2
(lp31653
VYou can use regular expressions, like this:
p31654
aVThe key to the solution is this regular expression:
p31655
aVIt starts the match when it finds a single quote, and continues until it finds the closing quote, capturing everything in between
p31656
aVThe captured group is then retrieved through the  API
p31657
aVNote that the capturing groups that you define start at index ; index zero is reserved to mean "the entire match"
p31658
aVTake a look at the demo on ideone
p31659
as(dp31660
g6
V335858
p31661
stp31662
a((dp31663
g2
(lp31664
VA better solution would be to store the strings that you have read in a
p31665
aVSet lookups are generally faster than lookups in a , because sets in C++ standard library are organized as binary trees
p31666
aVIf you put all your strings in a single long string, your search would remain linear, and you would have one more problem to solve: dealing with word aliasing
p31667
aVYou wouldn't be able to concatenate strings as-is, without a separator, because you wouldn't be able to distinguish between  and
p31668
as(dp31669
g6
V335858
p31670
stp31671
a((dp31672
g2
(lp31673
VYou can use LINQ's , like this:
p31674
as(dp31675
g6
V335858
p31676
stp31677
a((dp31678
g2
(lp31679
VThis is an excellent question - it highlights a rather silly design choice the designers of C++ took:
p31680
aVThe overload with no arguments is pre-increment; the overload with an unused  parameter is post-increment
p31681
aVThat is why the pre-increment version can return a reference, while the post-increment must make a copy of the original before incrementing the value itself
p31682
aVThe  parameter is added for a single reason - distinguishing between the two overloads; it is otherwise meaningless, that is why its value is never used
p31683
as(dp31684
g6
V335858
p31685
stp31686
a((dp31687
g2
(lp31688
VShould I first be putting the values from the text file into an array of strings, and then trying to convert each of those arrays of strings into an array of chars
p31689
aVYes, that is the simplest thing to code: read the data into strings, then call  on each of the array items
p31690
as(dp31691
g6
V335858
p31692
stp31693
a((dp31694
g2
(lp31695
VNET does not supply anything out of the box - you need to implement a an Edit Distance algorithm yourself
p31696
aVFor example, you can use Levenshtein Distance, like this:
p31697
aVCall  for each , then pick the string  for which  returns the smallest value
p31698
as(dp31699
g6
V335858
p31700
stp31701
a((dp31702
g2
(lp31703
VThe best approach in situations like that is to not store the position at all, but imply it instead
p31704
aVKeep the  attribute, and drop the
p31705
aVWhenever you need the position, or a list of all elements paired with their positions, you can use LINQ's  overload that takes the index:
p31706
aVNow you have a list of objects that have two attributes:
p31707
aV- the  element of the list, and the
p31708
aV- the index of the corresponding  in the
p31709
aVYou can re-order the elements of  at will; the implied index is going to change each time that you re-order
p31710
aVEach time you need the index, run the above LINQ expression to pair each  with its new index
p31711
as(dp31712
g6
V335858
p31713
stp31714
a((dp31715
g2
(lp31716
VYou are using  incorrectly: it is not a replacement for  of Java
p31717
aVYou should use  on C strings, such as strings returned by , or  on  objects
p31718
as(dp31719
g6
V335858
p31720
stp31721
a((dp31722
g2
(lp31723
VThere is a simple way to do it recursively: split the string into words, and then do a recursive invocation of this method, like this:
p31724
as(dp31725
g6
V335858
p31726
stp31727
a((dp31728
g2
(lp31729
VReplace this block
p31730
aVwith these two lines:
p31731
aVThis is an equivalent code, but it will work with any number of items, up to the number of elements in the  array
p31732
aVSince the number of elements is fixed, you should change
p31733
aVto
p31734
aVwhere  is the number of elements in
p31735
as(dp31736
g6
V335858
p31737
stp31738
a((dp31739
g2
(lp31740
VYour idea of using an interface was on the right track
p31741
aVHowever, you don't need to make the "special action card" implement a  interface: make a different interface for it (say, ), make the  interface inherit it, and then implement that interface in your "special action card" class
p31742
aVNow you can create a list of , and mix your special cards into it:
p31743
as(dp31744
g6
V335858
p31745
stp31746
a((dp31747
g2
(lp31748
VThe first thing that I would try is MapQuest APIs with OpenStreetMap option:
p31749
aVIt is free of charge for commercial and non-commercial use
p31750
aVIt supports panning and zooming
p31751
aVIt has geocoding, letting you map by ZIP code
p31752
aVIt supports POI markers and InfoWindows, letting you supply annotations to markers on the map
p31753
aVThe biggest limitation that comes with using OpenStreetMap is the lack of routing services, but it is not on your "shopping list" anyway
p31754
as(dp31755
g6
V335858
p31756
stp31757
a((dp31758
g2
(lp31759
VC does not let you return multiple values
p31760
aVIf you need to change a value passed into the function, you need to pass it by pointer:
p31761
aVInside the function, dereference the pointer to change the value:
p31762
aVWhen calling the function, you need to pass pointers to variables, like this:
p31763
as(dp31764
g6
V335858
p31765
stp31766
a((dp31767
g2
(lp31768
VI have problems trying to replicate the inline functions that are widely used in Java
p31769
aVThese are not inline functions, that's anonymous classes implementing a specific interface
p31770
aVC# provides delegates that you can define inline or in a separate function
p31771
aVHere is an example of sorting a  in place using the  delegate:
p31772
aVNote that in order for this to work, the  variable needs to be in scope at the spot where you invoke
p31773
aVIt can be a local variable defined above the invocation point, or a member variable/property of the class enclosing the function that makes the call
p31774
as(dp31775
g6
V335858
p31776
stp31777
a((dp31778
g2
(lp31779
VFile extension does not matter to the C# compiler: as long as it gets the text of your program correctly, the compiler does not look at the name or the extension of the file
p31780
aVThe documentation for the C# compiler does not mention naming requirements*
p31781
aVContrast this with Java, where file names and locations are important
p31782
aVJava compiler expects only  source files, with file names matching the names of public classes inside them:
p31783
aVSource code file names must have
p31784
aVjava suffixes, class file names must have
p31785
aVclass suffixes, and both source and class files must have root names that identify the class
p31786
aV* Even though the compiler does not require it,  remains the commonly accepted naming convention for C# source files
p31787
as(dp31788
g6
V335858
p31789
stp31790
a((dp31791
g2
(lp31792
VYour first sample comes from a pre-ARC tutorial (i
p31793
ag630
aVthe automatic reference counting is disabled)
p31794
aVIn ARC you do not need to call  on re-assignment
p31795
aVThere is absolutely no reason to allocate  like this, ARC or not
p31796
aVWitout ARC, it's a leak; with ARC, it's an unnecessary operation
p31797
aVYour second sample illustrates the fact that s are immutable
p31798
aVSince both calls create empty strings, Cocoa returns the same object, knowing that the object cannot be modified
p31799
as(dp31800
g6
V335858
p31801
stp31802
a((dp31803
g2
(lp31804
VThis happens because  cannot be equal to , even if you assign  to it:
p31805
aVMake  an , and cast it to  only when you concatenate:
p31806
aVBetter yet, use  to build strings at runtime: otherwise, you create lots of temporary string objects in a loop, and these objects get thrown away
p31807
as(dp31808
g6
V335858
p31809
stp31810
a((dp31811
g2
(lp31812
VWith the keys falling in small ranges like this, a simple 2D array of s would be sufficient:
p31813
aVThe first index is the value of ; the second index is the value of
p31814
aVThe values of  are stored as individual bits of the  at
p31815
aVTo access individual bits, use bit operations:
p31816
aVThis data structure is very efficient in space: it needs roughly 10KBytes of memory to store the entire data set
p31817
as(dp31818
g6
V335858
p31819
stp31820
a((dp31821
g2
(lp31822
VYou should add a condition around the line that sets the incoming segue:
p31823
aVThe idea is to call  only on the destination view controller that supports your added method
p31824
aVYou should also change the code in the destination view controller to check string equality with
p31825
as(dp31826
g6
V335858
p31827
stp31828
a((dp31829
g2
(lp31830
VThe closest method in the
p31831
aVNET framework itself after which all  methods should be modeled is the static  method
p31832
aVAccording to the documentation, this method handles s gracefully
p31833
aVI think that this provides enough indication on the intent of the
p31834
aVNET designers:  should handle nulls as well, and it should handle them in a similar way (i
p31835
ag630
aVtreating two s as equal to each other)
p31836
as(dp31837
g6
V335858
p31838
stp31839
a((dp31840
g2
(lp31841
VInformally, argument checking and assertions serve different purposes:
p31842
aVArgument checking is to detect situations when the person calling your method does something incorrectly, while
p31843
aVAssertions are used to detect situations when you do something incorrectly
p31844
aVEssentially, when you assert a condition
p31845
aVthe check conveys the following plain-English thought to the readers of your code: "I checked my code, and according to my reasoning, I am certain that  will always be less than "
p31846
aVWhen you check an argument , on the other hand,
p31847
aVyour code says that "the caller has forgotten to ensure that the  is less than "
p31848
aVThese are two different thoughts, so it is natural to employ two different ways to convey them in your code
p31849
as(dp31850
g6
V335858
p31851
stp31852
a((dp31853
g2
(lp31854
VYou can simplify your first approach:
p31855
aVThis would eliminate multiple splitting, and hide the hash set behind the call of
p31856
aVNote that the  statement is also unnecessary
p31857
as(dp31858
g6
V335858
p31859
stp31860
a((dp31861
g2
(lp31862
VWrap the part of the expression that you would like to capture in a capturing group, and then use  of the matcher to access it:
p31863
aVThe first group will capture everything up to the optional dash:
p31864
aVThe above prints  (link to ideone)
p31865
as(dp31866
g6
V335858
p31867
stp31868
a((dp31869
g2
(lp31870
V keeps the same order every time, but that is an arbitrary order based on the hash codes of the objects that you insert as keys
p31871
aVIf the dictionary is mutable, inserting or removing objects can change the ordering of the keys that are already in the dictionary
p31872
aVAlthough it is not possible to order the dictionary itself, it is certainly possible to order its keys into a separate array, and then walk that array in order, pulling the objects by key from the(unordered) dictionary
p31873
as(dp31874
g6
V335858
p31875
stp31876
a((dp31877
g2
(lp31878
VYou should use the pattern known as the virtual constructor, or a cloning method
p31879
aVAdd a virtual method to  that returns a copy of the current object:
p31880
aVNow implement this method in  to return , and in the  to return
p31881
aVPass whatever parameters necessary to the constructors of  and  to copy what's in the current object
p31882
aVNET has an interface  that is commonly used to implement this pattern
p31883
aVA small disadvantage of that approach is that  must return , not , so if you need , you'd need to cast it
p31884
as(dp31885
g6
V335858
p31886
stp31887
a((dp31888
g2
(lp31889
VYou can use this approach:
p31890
aVPut your reference data into XML files, one per table
p31891
aVAdd XML files with reference data to your database project
p31892
aVUse a Post-Deployment script to extract the data from XML and merge it into your tables
p31893
aVHere is a more detailed description of each step, illustrated with an example
p31894
aVLet's say that you need to initialize a table of countries that has this structure:
p31895
aVCreate a new folder called  under your database project
p31896
aVIt should be a sibling folder of the  and
p31897
aVAdd a new XML file called  to the  folder
p31898
aVPopulate the file as follows:
p31899
aVFind , and add the following code to it:
p31900
aVI tried this solution only in VS 2008, but it should be agnostic to your development environment
p31901
as(dp31902
g6
V335858
p31903
stp31904
a((dp31905
g2
(lp31906
VThere is a general trick often used in programming - paying with memory for operation speedup
p31907
aVIf you have lots of employees, and you are going to query a significant portion of them, one by one (say, 75% will be queried at one time or the other), then query everything, cache it (very important
p31908
aV, and complete the lookup in memory
p31909
aVThe next time you query, skip the trip to RDBMS, go straight to the cache, and do a fast look-up: a roundtrip to a database is very expensive, compared to an in-memory hash lookup
p31910
aVOn the other hand, if you are accessing a small portion of employees, you should query just one employee: data transfer from the RDBMS to your program takes a lot of time, a lot of network bandwidth, a lot of memory on your side, and a lot of memory on the RDBMS side
p31911
aVQuerying lots of rows to throw away all but one never makes sense
p31912
as(dp31913
g6
V335858
p31914
stp31915
a((dp31916
g2
(lp31917
VSince  is unordered, you have two ways of going about sorting your planes:
p31918
aVPut them into a sorted container, or
p31919
aVPut them into an  or an array , and sort that list or array
p31920
aVThe first approach can be achieved with a : put your planes into the set, and iterate them in the "natural" order (i
p31921
ag630
aVthe order consistent with their  method)
p31922
aVThe second approach requires copying the planes into a separate container or an array, and then using the  method (or the  static method if it is an array) to order your planes in accordance with the order set by their  implementation
p31923
aVEDIT : (based on a comment) One way to deal with a problem of storing planes in a specific order inside a hash map is to make a hash map of tree sets, like this:
p31924
aVOnce you add the planes to each airline, they would be maintained in the order based on your  implementation
p31925
aVwith a  in hand, you can easily find the next or the prior  by calling  or
p31926
aVYou should use  rather than  in your  method
p31927
as(dp31928
g6
V335858
p31929
stp31930
a((dp31931
g2
(lp31932
VIf you start  with a , you would be able to remove the  from your  method: the  gets executed exactly once, when the string is empty, so you might as well make it non-empty right away
p31933
aVIn addition, your  makes a copy of the ; this is not necessary, because it does not get modified
p31934
aVAccepting the  by  reference should speed things up for you
p31935
aVFinally, changing your  from  to  should let you append to it in a loop, without the  intermediary that gets created, copied, and thrown away on each iteration of the loop
p31936
as(dp31937
g6
V335858
p31938
stp31939
a((dp31940
g2
(lp31941
VNo  is definitely not the same as a singly linked list
p31942
aVIn fact, it is not a linked list at all: it is a list that uses an array for its backing storage
p31943
aVThis lets you access  in arbitrary order, as opposed to linked lists, that must be accessed sequentially
p31944
aVJava library has a doubly-linked list, but no singly-linked one; you need to write it yourself
p31945
aVThere are several good implementations available on the internet; take a look at this answer on the codereview site to gain some ideas on how to implement a singly linked list of your own
p31946
as(dp31947
g6
V335858
p31948
stp31949
a((dp31950
g2
(lp31951
VPassing all elements in a single  is not going to help, because the format string needs to be created in a loop anyway
p31952
aVSince you cannot escape the loop anyway, you might as well do the printing in the same loop:
p31953
aVHere is a link to a demo on ideone
p31954
as(dp31955
g6
V335858
p31956
stp31957
a((dp31958
g2
(lp31959
VYou can use the  format specifier and a
p31960
aVPass  as the first parameter, and the value to be printed as the last parameter:
p31961
aVLink to ideone
p31962
as(dp31963
g6
V335858
p31964
stp31965
a((dp31966
g2
(lp31967
VYou need to import , and add
p31968
aVOnce you add this import,  would be fully defined
p31969
as(dp31970
g6
V335858
p31971
stp31972
a((dp31973
g2
(lp31974
VAlthough the Hungarian Algorithm is going to work, a much simpler algorithm can be used in your case
p31975
aVYour implicit cost matrix is a symmetric matrix of a special form:
p31976
aVTherefore, you can relatively easily prove that in an optimal assignment {SUBJi, CTRLj} ordered by  the values of  will be ordered as well
p31977
aVProof: Consider an assignment {SUBJi, CTRLj} ordered by  that is not ordered by
p31978
aVThen you have at least one inversion, i
p31979
ag630
aVa pair of assignments {SUBJi1, CTRLj1} and {SUBJi2, CTRLj2} such that
p31980
aVi1 < i2, but
p31981
aVj1 > j2
p31982
aVThen you can replace the inverted pair with a non-inverted one
p31983
aV{SUBJi1, CTRLj2} and {SUBJi2, CTRLj1}
p31984
aVof a cost that is less than or equal to the cost of the inverted assignment for all six relative placements of (i1, i2) and (j1, j2) (link to Wolfram Alpha)
p31985
aV:Proof
p31986
aVWith this observation in hand, it is easy to prove that the dynamic programming algorithm below comes up with the optimal assignment:
p31987
aVMake  duplicates of each subject; order by
p31988
aVOrder controls by
p31989
aVPrepare an empty array  of size
p31990
aVPrepare an empty 2D array  of size  by  for memoization; set all elements to
p31991
aVCall  defined in pseudocode below
p31992
aVThe  table now contains  assignments for each subject  at positions between , inclusive, and , exclusive
p31993
aVHere is an implementation of the above pseudocode using C# on ideone
p31994
aVThis algorithm is ready to be re-written as set-based in SQL
p31995
aVTrying to fit it into the original problem setting (with grouping by locations and making multiple copies of the subject) would add unnecessary layer of complexity to a procedure that is already rather complex, so I am going to simplify things quite a bit by using table-valued parameters of SQL Server
p31996
aVI am not sure if DB2 provides similar capabilities, but if it does not, you should be able to replace them with temporary tables
p31997
aVThe stored procedure below is a nearly direct transcription of the above pseudocode into SQL Server's syntax for stored procedures:
p31998
aVHere is how you call this stored procedure:
p31999
aVThe call above assumes that both  and  have been filtered by location, and that  copies of  has been inserted into the table-valued parameter (or the temp table in case of DB2) before making the call
p32000
aVHere is a running demo on sqlfiddle
p32001
as(dp32002
g6
V335858
p32003
stp32004
a((dp32005
g2
(lp32006
VYou can use 's  method to pre-filter the list of  objects, and produce , like this:
p32007
aVYou can use properties of  in subsequent LINQ filters - the code below will work even if  is available only on  and not on the :
p32008
as(dp32009
g6
V335858
p32010
stp32011
a((dp32012
g2
(lp32013
VNo: reference objects are passed by reference, while value objects are copied byte-for-byte
p32014
aVYou can make your own "copy constructors", but you would be responsible for calling them explicitly
p32015
aVYou cannot overload the assignment operator
p32016
aVIn fairness to C#, none of the intricacies of the C++ copy control are necessary because of the underlying garbage-collected memory model
p32017
aVFor example, you do not need to control the ownership of dynamically allocated objects when copying objects, because you are free to have as many references to dynamic objects as you wish
p32018
as(dp32019
g6
V335858
p32020
stp32021
a((dp32022
g2
(lp32023
VYour code does not check
p32024
aVthat  exists,
p32025
aVthat  exists, and
p32026
aVthat the length of  is at least five
p32027
aVThis would break when  is zero or , or when one of the prior/next lines has less than five characters
p32028
as(dp32029
g6
V335858
p32030
stp32031
a((dp32032
g2
(lp32033
VIt depends on the meaning of
p32034
aVIf  is the number of rows and columns in a square matrix, then the complexity is
p32035
aVIf  is the total number of elements in the matrix (i
p32036
ag630
aV, where  is the number of rows and  is the number of columns) then the complexity is
p32037
as(dp32038
g6
V335858
p32039
stp32040
a((dp32041
g2
(lp32042
VSince your file appears small, you can read the whole file in, remove the line that you must remove, and then write the file back:
p32043
as(dp32044
g6
V335858
p32045
stp32046
a((dp32047
g2
(lp32048
VYou need several things to make it work:
p32049
aVAn ability to count the number an item is repeated in a list
p32050
aVAn ability to remove all elements matching a value from the list
p32051
aVAn ability to conditionally increment a number
p32052
aVHere is how you can count:
p32053
aVDeletion can be done with SWI's  predicate; this is a built predicate
p32054
aVAdding one conditionally requires two rules - one when the count equals one, and another one for when the count does not equal one
p32055
aVFinally, counting pairs could look like this:
p32056
aVAn empty list has no pairs; when an item is counted as part of a pair, its copies are removed from the rest of the list
p32057
aVHere is this running program on ideone
p32058
as(dp32059
g6
V335858
p32060
stp32061
a((dp32062
g2
(lp32063
VAssuming that  takes a single string parameter in addition to the log level, this should be possible:
p32064
aVNote the parentheses around the macro parameter, it is useful when macros are called with composite expressions
p32065
aVAssuming that the logger takes  objects, not C string, you should use the macro like this:
p32066
aVDLog(@"Text");
p32067
aVHowever, in this case it is not clear why would one prefer a macro to a simple function call:
p32068
as(dp32069
g6
V335858
p32070
stp32071
a((dp32072
g2
(lp32073
VThis expression
p32074
aVdoes not create a strict weak ordering: suppose , but
p32075
aVYour expression returns , yet it should be :  should be used to resolve ties only when s are the same, and then s should be used only when s and s are the same
p32076
aVThis leads to the following "staircase" expression:
p32077
aVThis is the long way of writing the expression suggested in Kerrek SB's answer, which I recommend you to use for its far superior readability
p32078
as(dp32079
g6
V335858
p32080
stp32081
a((dp32082
g2
(lp32083
VThe  feature is a syntactic sugar kind of feature, so it cannot have performance implications
p32084
aVIt does have negative consequences to readability and testability, though:
p32085
aVYou dump the content of a potentially large class into your current namespace, making your code harder to read; modern IDEs mitigate this by letting you navigate to the definition of the object by clicking its name in a program
p32086
aVYour code relies upon  objects, making it extremely hard to test
p32087
aVFor example, you cannot easily drop a mock logger, and expect your code start using it
p32088
aVThis is a general limitation of using static objects, though - you get it when you use static objects, with or without the static import
p32089
as(dp32090
g6
V335858
p32091
stp32092
a((dp32093
g2
(lp32094
VThis is a prime case for using the strategy pattern: depending on the parameters passed to the constructor,  should instantiate either a strategy object relying on a , or a strategy object relying on a list of interpolated values
p32095
aVThe call of  should then forward the call to the strategy, and get the result through an implementation of a common virtual function:
p32096
as(dp32097
g6
V335858
p32098
stp32099
a((dp32100
g2
(lp32101
VWill it call the '<' operator on the two objects to figure out the ordering
p32102
aVYes, it will:
p32103
aVMake sure that the "less than" relation defined by your  is transitive, i
p32104
ag630
aVif  and , then  must be less than  as well
p32105
as(dp32106
g6
V335858
p32107
stp32108
a((dp32109
g2
(lp32110
VYou can use the  method:
p32111
as(dp32112
g6
V335858
p32113
stp32114
a((dp32115
g2
(lp32116
VThis compiles after a copule of changes:
p32117
aVYou need to add a semicolon after the class definition, and
p32118
aVYou need to define the constructor that you have declared, i
p32119
ag630
aVthis constructor
p32120
aVshould have a body defined either inline, or in a separate file
p32121
aVAdditionally, you should change the signature of your  to
p32122
as(dp32123
g6
V335858
p32124
stp32125
a((dp32126
g2
(lp32127
VYou should be calling your function like this:
p32128
aVmeans "element at index 5" (past the end of your array, by the way: the largest legal element in  is at index )
p32129
aVYou should also replace
p32130
aVwith
p32131
aVand use it like this:
p32132
as(dp32133
g6
V335858
p32134
stp32135
a((dp32136
g2
(lp32137
VWhat you are trying to build is called Query By Example
p32138
aVIt is OK, but it has limitations: your  class is re-purposed for being a query parameter, rendering some of its code useless or counterproductive
p32139
aVFor example, if you add a validation requiring the name to contain only letters, you would not be able to query for names with wildcards
p32140
aVOne approach to address this is to provide a query builder class designed specifically to handle query parameters
p32141
aVThe query object itself could wrap a  of parameter bindings passed by the user, letting your query API take it apart and pass the corresponding data to a query of the underlying data store
p32142
as(dp32143
g6
V335858
p32144
stp32145
a((dp32146
g2
(lp32147
VYou should replace  with , otherwise the condition is always true (the extension cannot be equal to  and  simultaneously, which is what's required for the OR-ed condition to evaluate to )
p32148
as(dp32149
g6
V335858
p32150
stp32151
a((dp32152
g2
(lp32153
VThis is a classic problem of recursive descent parsers: your grammar does not require that the entire input is consumed
p32154
aVOnce it finishes with the "while isdigit" loop, it considers its job done, ignoring the  portion of the input
p32155
aVAdd a check that the end of line is reached after the call of the top-level expression to address this problem:
p32156
aVYou need to modify  to allow matching  when no additional input is available:
p32157
as(dp32158
g6
V335858
p32159
stp32160
a((dp32161
g2
(lp32162
VYes, it is amortized constant time
p32163
aVSee table 101 on page 716 of this document:
p32164
aVTable 101 lists operations that are provided for some types of sequence containers but not others
p32165
aVAn
p32166
aVimplementation shall provide these operations for all container types shown in the \u201ccontainer\u201d column, and shall implement them so as to take amortized constant time
p32167
as(dp32168
g6
V335858
p32169
stp32170
a((dp32171
g2
(lp32172
VAll this makes perfect sense - when you declare the vehicle as , the two calls to  are resolved differently:
p32173
aVWhen the call to  is made from the  method, it has no idea that there is a  method in the , so it makes the call to the corresponding method of the base
p32174
aVWhen the call to  is made from the  method, the compiler knows that you are calling the  method, because it knows that the exact type of the  variable is
p32175
aVOn the other hand, when the call to  is made from the  method, but the variable is declared to be , the compiler cannot assume that the type is , so it resolves the  to the method of the base class again
p32176
as(dp32177
g6
V335858
p32178
stp32179
a((dp32180
g2
(lp32181
VIs there a way to pass a temporary object to a class that expects a reference and not have the code go bonkers
p32182
aVNo
p32183
aVThe very reason why you do not have to worry that much about ownership when you deal with references is that the ownership is dealt with some place else - specifically, at the level owning the variable being referenced
p32184
aVA reference becomes invalid the moment the object being referenced goes out of scope (yes, references can be dangling too)
p32185
aVThe object being referenced must stay around as long as the reference to it is in active use
p32186
aVThat is why you cannot make temporaries play nicely with references: temporaries go out of scope very quickly, rendering useless the references to them
p32187
as(dp32188
g6
V335858
p32189
stp32190
a((dp32191
g2
(lp32192
VA property is not necessarily related to a field - in fact, a property is a little more than a syntactic sugar on top of a pair of functions
p32193
aVIf your code uses some sort of a convention for naming variables that back properties (such as prepending them with , as in your example) you could rely upon that convention to retrieve the variable name
p32194
aVIn all other cases, there is no direct connection, and no way to retrieve that relationship through the reflection API
p32195
as(dp32196
g6
V335858
p32197
stp32198
a((dp32199
g2
(lp32200
VWhen i execute it, it works perfectly
p32201
aVYou just got (un)lucky: your code exhibits undefined behavior, because it lets the 's  parameter run off the end of the sequence of characters that is not null-terminated
p32202
aVA string in C is a sequence of , which must have an extra character with the value , called the null terminator
p32203
aVHere is a way to make your code work without undefined behavior:
p32204
as(dp32205
g6
V335858
p32206
stp32207
a((dp32208
g2
(lp32209
VYes - you can use System
p32210
aVarraycopy instead of the inner loop:
p32211
as(dp32212
g6
V335858
p32213
stp32214
a((dp32215
g2
(lp32216
VA result of dereferencing a pointer is an L-value, because it has an address; it certainly can be assigned
p32217
aVConsider a simpler example: if  is an array or a pointer, you can certainly assign to , as in
p32218
aVNow recall that  is the same as
p32219
aVNow expand your macro:
p32220
aVThis is equivalent to
p32221
aVwhich is certainly a valid (albeit somewhat unorthodox) assignment of the  itself
p32222
as(dp32223
g6
V335858
p32224
stp32225
a((dp32226
g2
(lp32227
VYou can do it like this:
p32228
aVThis produces the output , because the unicode code point of  (which is ) has been replaced with the code point of  - an
p32229
as(dp32230
g6
V335858
p32231
stp32232
a((dp32233
g2
(lp32234
VThis is the classic "dangling else" problem from the JavaCC lookahead tutorial
p32235
aVYou should replace the two  productions with a single  production that has an optional ; you should also add  in front of the , like this:
p32236
aVbecomes
p32237
as(dp32238
g6
V335858
p32239
stp32240
a((dp32241
g2
(lp32242
VThis is because you are declaring a  variable in a header: when you include the header in a C file, you get a brand-new definition independent of the other definitions
p32243
aVIf you include the header in two files, you get two independent copies; if you include it in three C files, you get three independent copies, and so on
p32244
aVThe copies do not conflict with each other, because the  definition hides them from the linker
p32245
aVA proper way to make use of a shared piece of data allocated in a static memory is to make the declaration  in the header, and then add a non-static definition in exactly one C file
p32246
as(dp32247
g6
V335858
p32248
stp32249
a((dp32250
g2
(lp32251
VYou can remove the  type constraint, and use  instead
p32252
aVInstead of this
p32253
aVwrite this:
p32254
aVThis is likely to be somewhat slower because of going through reflection, and the static checks by the compiler would not be performed
p32255
aVHowever, considering your scenario, it does not look like either of these would present a significant problem in your scenario
p32256
as(dp32257
g6
V335858
p32258
stp32259
a((dp32260
g2
(lp32261
VThe vertices of an -vertex polygon are located at the angles
p32262
aVwhere  goes from 0 to , inclusive
p32263
aVThe vertical coordinate can be calculated as a sine of the angle times the radius of the circumcircle; the horizontal coordinate is calculated the same way, except you need to multiply the radius by the cosine of the angle
p32264
aVIn order to turn your polygon by  degrees, convert  to radians, and add the result to the angle in the formula, like this:
p32265
aVFinally, since the origin of the screen is in one of the corners, only a portion of your polygon is going to be visible
p32266
aVTo avoid this, add an offset equal to the position of the circumcircle's center to each coordinate that you calculate
p32267
as(dp32268
g6
V335858
p32269
stp32270
a((dp32271
g2
(lp32272
VUnlike members of classes that are zeroed out on initialization, local variables are not initialized automatically by pre-ARC compilers
p32273
aVIf you would like your local  to be , you need to initialize it yourself:
p32274
aVThe behavior of not initializing locals unless explicitly directed by the program comes from C: there, too, the locals are not initialized by default
p32275
as(dp32276
g6
V335858
p32277
stp32278
a((dp32279
g2
(lp32280
VSince  by the standard is only eight bits, using the whole map for it is rather wasteful
p32281
aVDeclare an array of 256 s, make your  into an , and count the frequency in the fastest way imaginable:
p32282
as(dp32283
g6
V335858
p32284
stp32285
a((dp32286
g2
(lp32287
VThe  property in C# is accessible through the square brackets operator
p32288
aVFor example, if the documentation for  says that a class exposes property  that takes an  and returns a
p32289
aVYou can use it like this:
p32290
as(dp32291
g6
V335858
p32292
stp32293
a((dp32294
g2
(lp32295
VThe problem happens because you are indexing at the length; you should be indexing from zero to length minus one:
p32296
aVAdditionally, calling  does not change the string (in fact, no method you call on a string can change it: strings in Java are immutable)
p32297
aVIf you are composing a word in reverse, consider using , and append characters to it as you iterate the original word in reverse
p32298
as(dp32299
g6
V335858
p32300
stp32301
a((dp32302
g2
(lp32303
VThe fancy word for this technique is caching: you calculate a two-away reference once, and cache it in the object
p32304
aVIn general, caching lets you "pay" with computer memory for speed-up of your computations
p32305
aVIf a profiler tells you that your code is spending a significant amount of time in the repeated call of , this may be a legitimate optimization, provided that the return values of  and  never change
p32306
aVHowever, doing an optimization like that without profiling first is nearly always a bad sign of a premature optimization
p32307
aVIf performance is not the issue, a good rule is to stay away from storing members that can be calculated from other members stored in your object
p32308
aVIf you would like to improve clarity, you can introduce a nicely named method (a member function) to calculate the two-away reference without storing it
p32309
aVStoring makes sense only in the rare cases when it is critical for the performance
p32310
as(dp32311
g6
V335858
p32312
stp32313
a((dp32314
g2
(lp32315
VFor completeness, here is how you can do it with the C++11 standard library and lambdas:
p32316
aVHere is a link to ideone with a demo
p32317
as(dp32318
g6
V335858
p32319
stp32320
a((dp32321
g2
(lp32322
VI think the only problem with your latest attempt is that it does not weed out combinations of all nulls (i
p32323
ag630
aVfalse positives where all four IDs are null)
p32324
aVYou can fix it by requiring that at least one of the four identifiers mus be non-null, like this:
p32325
as(dp32326
g6
V335858
p32327
stp32328
a((dp32329
g2
(lp32330
VThis kind of join is called outer (as opposed to the default kind of join, which is called inner)
p32331
aVHere is how you tell SQL that you need an outer join:
p32332
aVThis tells SQL that even when a corresponding rows of  or  (or both) are missing, you still want whatever rows that are available
p32333
as(dp32334
g6
V335858
p32335
stp32336
a((dp32337
g2
(lp32338
VThe problem is that you are creating a new counter for each character in the string, rather than creating one for each possible letter
p32339
aVEssentially, your program counts how many times a character occurs in a string in positions after the current character
p32340
aVFixing this issue should be relatively easy: make counters for each letter of the alphabet, and increment them when you see the corresponding letter
p32341
aVAssuming that you do it case-sensitively, you can do it like this:
p32342
as(dp32343
g6
V335858
p32344
stp32345
a((dp32346
g2
(lp32347
VFirst, an "ideal" solution: do not put more than one piece of information in a single tag
p32348
aVRather, put each language in its own tag, like this:
p32349
aVIf this is not possible, retrieve the content of the tag with multiple languages, split using , and obtain the count by checking the length of the resultant array
p32350
as(dp32351
g6
V335858
p32352
stp32353
a((dp32354
g2
(lp32355
VFunctions provide a nice way to simplify repeated tasks:
p32356
aVWith this function in hand, rewrite your code in only six lines:
p32357
as(dp32358
g6
V335858
p32359
stp32360
a((dp32361
g2
(lp32362
VHere is one way to do it with regular expressions:
p32363
aVThe  regular expression is a POSIX pattern representing a single punctuation character
p32364
as(dp32365
g6
V335858
p32366
stp32367
a((dp32368
g2
(lp32369
VYes, you can build an array like that using an array of pointers; you will be able to reference elements in that array as if it were a regular 2D array
p32370
aVHere is an example:
p32371
aVNow you can reference elements of this array like this:
p32372
aVSince you are using C++, using  or  is a preferred way of making collections
p32373
aVYou can use the same trick as above to establish shared collection elements
p32374
as(dp32375
g6
V335858
p32376
stp32377
a((dp32378
g2
(lp32379
VNo, the second query is as secure as the first one, because it is fully parameterized, and therefore does not present a path through which an external data could enter the text of the SQL query itself
p32380
aVThe  expression is calculated by the RDBMS, not by your program*, so it cannot present an opportunity to inject new code into the existing SQL
p32381
aV* and it is not subsequently presented to SQL's  stored procedure for re-interpretation
p32382
as(dp32383
g6
V335858
p32384
stp32385
a((dp32386
g2
(lp32387
VYou can do it with LINQ:
p32388
as(dp32389
g6
V335858
p32390
stp32391
a((dp32392
g2
(lp32393
s(dp32394
g6
V335858
p32395
stp32396
a((dp32397
g2
(lp32398
VYou can drop the constraint, and make the callers pass a  type to your method (i
p32399
ag630
aVcall  instead of )
p32400
aVYou can ensure nullability at runtime, like this:
p32401
as(dp32402
g6
V335858
p32403
stp32404
a((dp32405
g2
(lp32406
VSince you are reading your integer from a text file, you can convert it like this:
p32407
aVThis assumes an encoding that uses one byte per character, which is consistent with the call of  in the code snippet that you provided
p32408
aVIf the number of digits is not known ahead of time, you can do this:
p32409
as(dp32410
g6
V335858
p32411
stp32412
a((dp32413
g2
(lp32414
VYou should either add an , or re-write the  as a conditional, like this:
p32415
aVOtherwise, a cell with a check mark set would keep the accessory forever upon being "recycled"
p32416
as(dp32417
g6
V335858
p32418
stp32419
a((dp32420
g2
(lp32421
VIt does not look like there is a good candidate for an "end marker" in a  structure: every pair of  represents a legal point, at least theoretically
p32422
aVIf you insist on using a fixed array (presumably, for performance reasons), you can also store the number of polygon vertices in a separate variable (continuing your string analogy, that would be a "Pascal string" of points, rather than a "C string" of points)
p32423
aVIf using an array is not essential, you may want to switch to a , a container that is better suited for representing structures of variable size, such as polygons
p32424
aVFinally, you could designate one point as illegal (say, at ), create an instance of that point statically, and use it as an end-of-sequence marker
p32425
aVIn this case, consider expanding your array by one, and use the end marker as a sentinel
p32426
as(dp32427
g6
V335858
p32428
stp32429
a((dp32430
g2
(lp32431
VThe answer to your first question should also clarify the last one: if you need to store large numbers of 16-bit s, you save half the amount of memory required for 32-bit s, with whatever "fringe benefits" that may come along with it, such as using the cache more efficiently
p32432
aVMost CPUs these days have separate instructions for 16-bit vs
p32433
aV32-bit operations, along with instructions to read and write 16-bit values from and to memory
p32434
aVInternally, the ALU may be performing a 32-bit operation, but the result for the upper half does not make it back into the registers
p32435
as(dp32436
g6
V335858
p32437
stp32438
a((dp32439
g2
(lp32440
VYou can solve the problem like this:
p32441
aVAdd court_id to the select list
p32442
aVAdd ordering criteria that put rows that belong to the same court next to each other
p32443
aVWhen iterating through the data coming back, see if you have seen the court id before
p32444
aVIf this is the first time that you see the court id, show both the court and the contact details
p32445
aVIf you have seen this court id before, show only the contact information
p32446
aVHere is an example of how you can do it:
p32447
as(dp32448
g6
V335858
p32449
stp32450
a((dp32451
g2
(lp32452
VI want always to concatenate the new string to start of my old string
p32453
aVThis is very simple, but not very efficient:
p32454
as(dp32455
g6
V335858
p32456
stp32457
a((dp32458
g2
(lp32459
VCreate a  with interval limits mapping to an integer "case label"
p32460
aVUse the  method to obtain the entry for the value nearest to your randomly generated , and use the resultant value in your  statement
p32461
aVThis map sets up fiveintervals:
p32462
aV-inf
p32463
ag1340
ag49
ag1340
ag49
ag14884
ag10442
ag14884
ag10442
ag20244
ag49
ag20244
ag49
aV10
p32464
ag14884
aV10
p32465
ag14884
aV+inf
p32466
aVNow in your code you can do this:
p32467
as(dp32468
g6
V335858
p32469
stp32470
a((dp32471
g2
(lp32472
VThe type of the object reference is defined statically at the point of its declaration:
p32473
aVTherefore, the type of the reference is , so "C" should be the right answer
p32474
as(dp32475
g6
V335858
p32476
stp32477
a((dp32478
g2
(lp32479
VHere is a small but legal hack that you can use:
p32480
aVHere is how it works:
p32481
aVRecall that adding  to a pointer adds  times the size of the type pointed to; hence  adds  to the "raw" value of
p32482
aVis always , so casting to  lets you subtract "raw" values; the result is the  added by the  operation
p32483
as(dp32484
g6
V335858
p32485
stp32486
a((dp32487
g2
(lp32488
VOne solution would be to add  where a whitespace is legal but not required, and  in places where whitespace is required, like this:
p32489
aVOn the other hand, this is precisely an example of why one shouldn't attempt to parse XML or HTML with regex: it is simply a wrong tool for the job
p32490
aVUsing one of several XML parsing techniques available in
p32491
aVNET would provide a much better alternative
p32492
as(dp32493
g6
V335858
p32494
stp32495
a((dp32496
g2
(lp32497
VThis means that your code may enumerate the  and  several times
p32498
aVSince LINQ uses deferred evaluation, this may cause slowness, especially when the  has lots of data, and  clauses are complex (it does not look like any of that applies in your situation, though)
p32499
aVYou can eliminate the warning (and the alleged slowness) by "materializing" the enumerations into lists, like this:
p32500
as(dp32501
g6
V335858
p32502
stp32503
a((dp32504
g2
(lp32505
VThe code does not work because you are not dereferencing your pointers on assignments
p32506
aVIt should be
p32507
aVNote that you are making an assumption that  points to an , which is obviously not always the case
p32508
aVEssentially, you might as well replace  with , and get rid of the casts
p32509
aVA more general case of the API should look like this:
p32510
aVInternally, the API should allocate a buffer of size , make a  into it, and then make a swap, again using
p32511
as(dp32512
g6
V335858
p32513
stp32514
a((dp32515
g2
(lp32516
VI would re-write this to eliminate a few variables, but in general your code is OK:
p32517
as(dp32518
g6
V335858
p32519
stp32520
a((dp32521
g2
(lp32522
VYou are mixing up the levels of inheritance: your system models things that inherit from each other (i
p32523
ag630
aVa project task inherits a  from a project task template); at the same time, you are trying to model it with inheritance in your
p32524
aVNET program
p32525
aVThese are two different inheritances: one is in your data layer, while the other one is in your code layer
p32526
aVI would suggest modeling the inheritance in the data layer with containment in the code layer, rather than using an inheritance
p32527
aVEach  can have an optional instance of  that serves as a task template; when a property is not found in the task itself, try looking it up in the template object
p32528
aVMake properties nullable to allow for situations when a property is not set in either the object or its template
p32529
as(dp32530
g6
V335858
p32531
stp32532
a((dp32533
g2
(lp32534
VThe speed of hash map is constrained by several essential properties of the  and  functions:
p32535
aVHow easy it is to calculate,
p32536
aVHow well is  at distributing values into buckets, and
p32537
aVHow easy it is to compare values for equality
p32538
aVThe  function of a  is very good, and  caches its result to improve performance
p32539
aVHowever, equality check may be longer than with
p32540
aVThe  class has a very hard-to-beat implementation of  in terms of speed, but since the hash codes of similar colors would be close to each other, you may get more collisions with s
p32541
aVis as fast as the , but it is also the most descriptive
p32542
aVI seriously doubt that choosing one of these three representations would hamper performance so significantly as to make a visible difference, so I would suggest going for the most descriptive choice, and then profile if necessary
p32543
as(dp32544
g6
V335858
p32545
stp32546
a((dp32547
g2
(lp32548
VThere is no problem with this code, because every possible path through it inevitably leads to a  statement*
p32549
aVIt does not have to be the last statement textually, as long as it is the last statement logically (Java compiler is smart enough to figure out if it's so, and give you an error if there are paths through your code that do not return a value or throw an exception)
p32550
aVThe fact that there will be code executing after hitting the  (i
p32551
ag630
aVyour  block) does not change anything: as far as the compiler is concerned, your function has provided a return value before exiting the function
p32552
aV* In fact, there is only one path through your function's code, and it terminates at the  statement
p32553
as(dp32554
g6
V335858
p32555
stp32556
a((dp32557
g2
(lp32558
VThis is very easy to verify:
p32559
aVThe above prints
p32560
aVThat is precisely what is expected to happen: Java will try to catch more specific exceptions before continuing up the chain of inheritance
p32561
as(dp32562
g6
V335858
p32563
stp32564
a((dp32565
g2
(lp32566
VIn C++, the easiest way of doing it is like this:
p32567
aVYou need to include  in order for this to compile
p32568
aVUnlike Java generic containers, C++ template containers do not incur the cost of wrapping primitives into objects, so they can stay extremely efficient in terms of performance and memory consumption while providing a great deal of additional flexibility
p32569
aVIn general, you should prefer C++ - style containers (, , , and in C++11, ) to their less flexible built-in alternatives "inherited" from C
p32570
as(dp32571
g6
V335858
p32572
stp32573
a((dp32574
g2
(lp32575
VSince I have no access to the paper, this is my best guess: in Java, classes can be related to each other in more than one way: in addition to inheriting from one another, classes can also be nested inside one another
p32576
aVHere is an example of a class inheriting from the class inside which it is nested:
p32577
aVIn the example above,  inherits from , which serves as its containing class
p32578
as(dp32579
g6
V335858
p32580
stp32581
a((dp32582
g2
(lp32583
VYou should not be performing calculations based on the content of  objects, because they fundamentally belong to the presentation layer; there should be no calculations going on in the presentation layer, only hiding and displaying things
p32584
aVFor calculations, you should go directly to the layer from which your  gets its data (presumably, that would be your model classes) and do the calculations there
p32585
aVBetter yet, move the calculation to the model layer, and put out a method for getting it on demand
p32586
aVIf you are modifying the existing code written by someone else, start by examining the  method in the  to see from where it gets its data
p32587
aVPresumably, that place has all the data available, regardless of whether it is showing on the screen or not
p32588
as(dp32589
g6
V335858
p32590
stp32591
a((dp32592
g2
(lp32593
VJohn Vlissides, one of the GoF, wrote an excellent chapter on the subject in his Patterns Hatching book
p32594
aVHe discusses the very concern that extending the hierarchy is incompatible with maintaining the visitor intact
p32595
aVHis solution is a hybrid between a visitor and an -based (or a type-based) approach, where a visitor is provided with a  method called by all classes outside the "base" hierarchy that the visitor understands out of the box
p32596
aVThis method provides you an escape way to treat the classes added to the hierarchy after the visitor has been finalized
p32597
aVWhen you add this modification, your visitor is no longer in violation of the Open-Close Principle, because it is open to extension without the need to modify its source code
p32598
aVI tried this hybrid method on several projects, and it worked reasonably fine
p32599
aVMy main class hierarchy is defined in a separately compiled library which does not need to change
p32600
aVWhen I add new implementations of , I modify my  implementations to expect these new classes in their  methods
p32601
aVSince both the visitors and the extending classes are located in the same library, this approach works very well
p32602
ag1971
ag1972
aVThere is another article called Visitor Revisited discussing precisely that question
p32603
aVThe author concludes that one can go back to an -based double dispatch, because the original Visitor Pattern does not present a significant improvement over the -based dispatch
p32604
aVI disagree with the author, because in cases when the bulk of your inheritance hierarchy is solid, and the users are expected to provide a few implementations here and there, a hybrid approach provides significant benefits in readability; there is no point in throwing out everything because of a couple of classes that we can fit into the hierarchy with relative ease
p32605
as(dp32606
g6
V335858
p32607
stp32608
a((dp32609
g2
(lp32610
VIn SQL, you are not limited by sorting on values of existing columns: you can specify complex expressions inside your  clause
p32611
aVThis query sorts by the value of a boolean expression: the expression will be true for the rows where , and  in all other rows
p32612
aVAs the result, rows with column = 'b' will come first, because the  clause specifies descending order, and in SQL,  is represented as 1, and  is 0
p32613
as(dp32614
g6
V335858
p32615
stp32616
a((dp32617
g2
(lp32618
VSince  can hold up to 256 values, you can set up a two-dimensional table of [256*256] counters, run through your string once, incrementing the counter that corresponds to each pair of character in the string
p32619
aVThen you can go through the table of 256x256 numbers, pick the largest count, and know to what pair it belongs by looking at its position in the 2D array
p32620
aVSince the size of the counter table is fixed to a constant value independent of the length of the string, that operation is , even though it requires two nested loops
p32621
aVHere is a link to a demo on ideone
p32622
aVKeep in mind that although this is the fastest possible solution asymptotically (i
p32623
ag630
aVit's , and you cannot make it faster than ) the performance is not going to be good for shorter strings
p32624
aVIn fact, your solution will beat it hands-down on inputs shorter than approximately 256 characters, probably even more
p32625
aVThere is a number of optimizations that you can apply to this code, but I decided against adding them on to keep the main idea of the code clearly visible in its purest and simplest form
p32626
as(dp32627
g6
V335858
p32628
stp32629
a((dp32630
g2
(lp32631
VDo they mean direct descendants only
p32632
aVNo - descendents of descendents, descendents of descendents of descendents, and so on, are also eligible
p32633
aVThey all can access protected members of all their base classes, all the way up the chain of inheritance
p32634
aVThe above compiles and prints
p32635
as(dp32636
g6
V335858
p32637
stp32638
a((dp32639
g2
(lp32640
VYou can use the  class introduced in Java 5, like this:
p32641
aVEdit: (in response to the edit of the question) You can use a formatter in the implementation of your own custom method, like this:
p32642
aVYou can now call your  function like this:
p32643
as(dp32644
g6
V335858
p32645
stp32646
a((dp32647
g2
(lp32648
VIf you are in
p32649
aVNET 4 or later, you can use a  class with a custom
p32650
aVThe class lets you add new objects with the  method common to all mutable collections
p32651
aVYou can retrieve the max element using the  property, and then call  to erase the max from the collection
p32652
aVEdit: (in response to an edit of the question) If you need to store duplicates, you can use a , and make a counted set out of it
p32653
aVAgain, you have an option of using a custom
p32654
aVWhen you enqueue an element, check if it exists already, and increment its count
p32655
aVWhen dequeueing, again check the count, decrement it, and remove the key only when the count reaches zero
p32656
as(dp32657
g6
V335858
p32658
stp32659
a((dp32660
g2
(lp32661
VYou need to make sure that you multiply the number of billions by a long long, like this:
p32662
aVOtherwise, you get an integer overflow for  greater than 2
p32663
aVThe above prints  as expected
p32664
aVOf course this is equivalent to obtaining a remainder, like this:
p32665
as(dp32666
g6
V335858
p32667
stp32668
a((dp32669
g2
(lp32670
VTry this:
p32671
aVNote that the products the value of the property for which are not in the list will sort ahead of all other products
p32672
as(dp32673
g6
V335858
p32674
stp32675
a((dp32676
g2
(lp32677
VThe back-of-the-envelope rate for loading the data from an RDBMS server into memory is roughly  10K records per second
p32678
aVIf you have 100M records, and if you must use all data at some point, you are looking at roughly three hours to load the data
p32679
aVThat is before you do any calculations
p32680
aVPlain files can be orders of magnitude faster
p32681
aVYou can get pretty fast with a text-based file; going binary would improve your speed some more at the expense of readability of your data file
p32682
as(dp32683
g6
V335858
p32684
stp32685
a((dp32686
g2
(lp32687
VThe fact that Apple does not supply a mutable subclass does not mean that a malicious user could not build one specifically to trick your class
p32688
aVIf you operate under the assumption that strings can be changed behind your class's back, you need to at least allow for a possibility of an ill-intentioned user extending  into a mutable class:
p32689
aVIf a programmer gives you an object of  and you fail to copy it before the validation, that programmer is now free to change the URL without letting your class know
p32690
as(dp32691
g6
V335858
p32692
stp32693
a((dp32694
g2
(lp32695
VThe destructor calling sequence always goes from the derived to base, like popping the stack
p32696
aVThis allows derived classes to clean up resources allocated by your base class
p32697
aVIn this case, the compiler knows how to construct this sequence, because it knows the exact type of the objects  and  statically
p32698
aVThere are situations, however, when this sequence would be broken
p32699
aVConsider the following modification of your code:
p32700
aVIt produces the following output:
p32701
aVRunning this produces no call of  for ; for , both destructors are called
p32702
aVThis is because you did not declare the destructor  in the base class
p32703
aVWhen the destructor is not virtual, the compiler has no idea that it must call the destructor of the derived class in situations when an object is referred to by a pointer to a base class
p32704
aVThis is why you should always make a destructor virtual in classes that must be inherited and allocate resources dynamically
p32705
as(dp32706
g6
V335858
p32707
stp32708
a((dp32709
g2
(lp32710
VWhen they say "do not use extra space", they do not mean pointers and scalars; they do mean "arrays" and "dynamically allocated structures"
p32711
aVIn your case, the amount of memory is fixed
p32712
aVMerging two ordered lists is simple: first, cut the list in half, and then re-arrange  pointers of its elements to make the list sorted
p32713
aVYou will need three pointers - , , and
p32714
aVInitialize  and  to the  of the original list
p32715
aVAdvance  until you see a break in the sorted sequence (i
p32716
ag630
aVwhen  is less than )
p32717
aVCut the list there by setting  to ; keep the original  - it is your new
p32718
aVAt this point, you have two independently ordered, separate linked lists, and you can apply the classic merge algorithm
p32719
aVSet  to the smaller element of  or , and then move in a loop, setting the  pointer of the current last element to the smaller of  or
p32720
aVOnce you hit  or , assign the head of the other list to the  of the list that ran out of elements first
p32721
aVYou are done -  now points to the beginning of a sorted list
p32722
as(dp32723
g6
V335858
p32724
stp32725
a((dp32726
g2
(lp32727
VYes,  would immediately return , without calling  or , because  is a short-circuiting operator
p32728
aVSame goes for the  operator when its operands return : the chain stops as soon as the result of the evaluation is known
p32729
aVThis is essential in situations when the first part of the expression protects the second part from potential errors, like this:
p32730
aVIf the evaluation did not stop after discovering that the initial part of the expression is , a  pointer would be dereferenced in the second part, resulting in undefined behavior
p32731
as(dp32732
g6
V335858
p32733
stp32734
a((dp32735
g2
(lp32736
VIn C++, this possibility exists only for pointers to objects of polymorphic types (i
p32737
ag630
aVtypes with at least one virtual function)
p32738
aVYou can do it with a
p32739
aVHere is a complete example (also on ideone):
p32740
aVThe first  fails, because  points to an object of a type incompatible with ; the second  succeeds
p32741
as(dp32742
g6
V335858
p32743
stp32744
a((dp32745
g2
(lp32746
VYou can do it like this:
p32747
aVThis produces a  from the file, where each string is the part of the corresponding line of the file taken from between the fifth and the sixth  separator
p32748
as(dp32749
g6
V335858
p32750
stp32751
a((dp32752
g2
(lp32753
VC++ set does not care about your  operator as much as it does about your  operator
p32754
aVIt is your  operator that presents the problem: if you would like to make sure that  is equal to , you should change the implementation of your  to behave like this:
p32755
aVWhat this implementation does is constructing a canonical representation of an edge, where the smaller of the  becomes the "canonical ", and the larger one becomes the "canonical "
p32756
aVWhen edges are compared in their canonical form, the equality of  and  can be implied from the fact that both  and  evaluate to
p32757
as(dp32758
g6
V335858
p32759
stp32760
a((dp32761
g2
(lp32762
VSince  returns a , using a 60-way  would result in about sixty needless allocations per line
p32763
aVgoes through your entire string, and creates sixty new object plus the array object itself
p32764
aVOf these sixty one objects you keep exactly one, and let garbage collector deal with the remaining sixty
p32765
aVIf you are calling this in a tight loop, a substring would definitely be more efficient: it goes through the portion of your string up to the second comma , and then creates one new object that you keep
p32766
aVThe above prints
p32767
aVWhen you run this multiple times, the  wins on time hands down: 1,000,000 iterations of  take 3
p32768
aV36s, while 1,000,000 iterations of  take only 0
p32769
aV05s
p32770
aVAnd that's with only eight components in the string
p32771
aVThe difference for sixty components would be even more drastic
p32772
as(dp32773
g6
V335858
p32774
stp32775
a((dp32776
g2
(lp32777
VThis is because you started  at zero; no matter how many times you double zero, it's going to stay zero :)
p32778
as(dp32779
g6
V335858
p32780
stp32781
a((dp32782
g2
(lp32783
VYou can do it like this:
p32784
as(dp32785
g6
V335858
p32786
stp32787
a((dp32788
g2
(lp32789
VAlthough  can be used everywhere an  can be, the  and  are not covariant
p32790
aVHowever, starting with
p32791
aVNET 4
p32792
aV0 you can use a list of  class in place of
p32793
aVSo if you declare your function to take  rather than , your code will compile
p32794
as(dp32795
g6
V335858
p32796
stp32797
a((dp32798
g2
(lp32799
VFor the purposes of implementing Kruskal's algorithm it does not matter in what way you represent your graph, because you never sort edges that belong to a vertex
p32800
aVRather, you put all edges into a single array, and then sort that array in ascending order
p32801
aVThe representation of your graph does not matter, as long as you can walk it, and collect all edges into a single array (first, you walk the graph to count the edges, then allocate an array of sufficient capacity, and finally you walk the graph again, putting pointers to the edges into the dynamically allocated array)
p32802
aVOnce the pointers to your edges are in an array, sort the array (for example, with ) and run Kruskal's algorithm
p32803
aVYou will need to implement Disjoint Sets in order to merge forests efficiently; as long as you have no trouble implementing linked lists, implementing disjoint sets should give you absolutely no trouble
p32804
as(dp32805
g6
V335858
p32806
stp32807
a((dp32808
g2
(lp32809
VThis is because your did not initialize  variable, and your  statement is missing a  case to assign it
p32810
aVJava compiler reasons that if  is not , then  would remain uninitialized at the time that you pass it to
p32811
aVYou can either set  to some initial value at the point of declaration, or add a  case to the
p32812
as(dp32813
g6
V335858
p32814
stp32815
a((dp32816
g2
(lp32817
VWhen a variable is designated private, it means that only methods of this class and optionally classes and methods designated as friends can access it
p32818
aVAny instance of the class can access private variables of all other instances of the same class
p32819
as(dp32820
g6
V335858
p32821
stp32822
a((dp32823
g2
(lp32824
VAssuming that  is your , you can do it like this:
p32825
aVYou can also do it using LINQ:
p32826
aVBoth fragments above add a single 3x3 array of s to a
p32827
aVIf you need a list of three items, you can do it like this:
p32828
aVor
p32829
aVor even
p32830
as(dp32831
g6
V335858
p32832
stp32833
a((dp32834
g2
(lp32835
VI don't think [that] ranges overlap
p32836
aVThis simplifies the problem a great deal: rather than performing a two-dimensional search, you can sort your list, and perform a one-dimensional binary search, like this:
p32837
aVHere is the  class:
p32838
as(dp32839
g6
V335858
p32840
stp32841
a((dp32842
g2
(lp32843
VSome of it is definitely a matter of preference, but not everything: you are better off with a property for items with external visibility, and items that need different access control inside vs
p32844
aVoutside your class
p32845
aVThe issue has been much less pronounced since the introduction of ARC, because before it you may wanted to use properties for automated calls of retain and release
p32846
aVThe significance of this aspect of properties has been reduced greatly to situations when you need to automatically copy the objects into your property
p32847
as(dp32848
g6
V335858
p32849
stp32850
a((dp32851
g2
(lp32852
VTry this query instead:
p32853
aVThe idea is to get rid of the  by removing a join in the top part of the query, and also eliminate the  by making a coordinated subquery
p32854
aVHere is a link to sqlfiddle
p32855
as(dp32856
g6
V335858
p32857
stp32858
a((dp32859
g2
(lp32860
VNo, nothing od this nature is supposed to happen: buttons have no "default actions", and most certainly these could not be called behind your back in
p32861
aVOn the other hand, you are free to call the corresponding  methods manually
p32862
aVWhen the button gets loaded, I want it to be displayed with a selected state
p32863
aVThe best place to ensure that that happens is  method
p32864
as(dp32865
g6
V335858
p32866
stp32867
a((dp32868
g2
(lp32869
VIt is always much better to go asynchronous when dealing with operations that are expected to take considerable time (my personal rule of thumb for declaring an operation "slow running" is that the operation needs to take roughly the time required for an average user to hit "Reload" on a slow web page, which I guesstimate is about ten seconds; I worked for a company where any operation taking more than half a second was declared "slow")
p32870
aVNumerous issues exist with holding the connection open:
p32871
aVTimeouts -  you would have to set them at eight hours, which is equivalent to disabling them for all practical purposes, at least as far as user interaction is concerned
p32872
aVClient restarts - If your clients are holding on for a synchronous response from the server, reporting the results would not survive a restart of the client
p32873
aVIntermediate progress reports - When an operation runs for several hours, it is likely that it consists of multiple stages
p32874
aVGoing asynchronous lets you report on the percentage complete and on the operation process in general, as your operation goes through its multiple stages
p32875
aVThat is why you should strongly prefer using duplex communications for all your long-running operations
p32876
as(dp32877
g6
V335858
p32878
stp32879
a((dp32880
g2
(lp32881
VThe line
p32882
aVshould be
p32883
aV(no toke pasting )
p32884
aVCurrently, the preprocessor tries to "glue" the asterisk to the names like , making unparseable identifiers
p32885
aVWhen you leave  out, the asterisk gets parsed by the compiler as a separate token, fixing the error
p32886
as(dp32887
g6
V335858
p32888
stp32889
a((dp32890
g2
(lp32891
VYou can set  property of your command, like this:
p32892
as(dp32893
g6
V335858
p32894
stp32895
a((dp32896
g2
(lp32897
VYour program exhibits undefined behavior on input of any length greater than zero, because  adds a null terminator
p32898
aVThe fact that the program does not crash up to 23 characters is an unfortunate coincidence
p32899
aVIf you want the buffer to be allocated dynamically, do not use  or -based input; instead, read your data into a
p32900
as(dp32901
g6
V335858
p32902
stp32903
a((dp32904
g2
(lp32905
VSince  is a pointer,  is the object itself
p32906
aVThe  operator works only on pointers; when you have a , you need to use the regular dot operator  for field access:
p32907
as(dp32908
g6
V335858
p32909
stp32910
a((dp32911
g2
(lp32912
VThis is exponentiation by squaring: the  is a fancy way to write
p32913
aVThe idea behind it is that if  is even, you can take  and square it; when  is odd,  must be even, so you can take , square it, and then multiply the result by  to compensate for the  that you subtracted from  before squaring
p32914
as(dp32915
g6
V335858
p32916
stp32917
a((dp32918
g2
(lp32919
VYou should replace  with a comma  to separate field assignments, otherwise it's a syntax error (or a logical error if the assignment can be interpreted as a comparison):
p32920
aVIt goes without saying that you should be using parameterized SQL to avoid the possibility of SQL injection attacks:
p32921
as(dp32922
g6
V335858
p32923
stp32924
a((dp32925
g2
(lp32926
VThe logic behind not giving a  a  in the API is that if you have retrieved the  from  through the indexer that takes an , then the group is likely not a named one; otherwise, you would probably prefer retrieving it through the indexer taking a
p32927
aVIf, on the other hand, you have retrieved the group through the indexer taking a , then you already know the name of the group
p32928
as(dp32929
g6
V335858
p32930
stp32931
a((dp32932
g2
(lp32933
VA foreign key constraint means that a value of a column or a group of columns must be present in a row of another table, usually as its primary key
p32934
aVHere is an example:
p32935
aVIf you set up a foreign key constraint on  requiring that  be present in the  table, an attempt to insert a  with an invalid  would result in a foreign key constraint violation
p32936
aVIn your case, the API probably takes a set of values, one of which must be an  of some sort (or a secondary key through which an ID can be retrieved)
p32937
aVWhen you pass an invalid  to such an API, the foreign key constraint violation is triggered
p32938
as(dp32939
g6
V335858
p32940
stp32941
a((dp32942
g2
(lp32943
VNo - according to the doc, zero is inclusive, but 1 is not:
p32944
aVA double-precision floating point number greater than or equal to 0
p32945
aV0, and less than 1
p32946
ag49
aVMSDN
p32947
as(dp32948
g6
V335858
p32949
stp32950
a((dp32951
g2
(lp32952
VYou were on the right path subclassing : all you need to do now is to plug it into your application
p32953
aVThe simplest way of doing it is in your application delegate's  method:
p32954
aVMyStoryboard
p32955
ag1177
aVMyStoryboard
p32956
ag12457
aVMyAppDelegate
p32957
ag12457
aVWith this code in place, you will see calls of  every time the  method is called
p32958
as(dp32959
g6
V335858
p32960
stp32961
a((dp32962
g2
(lp32963
VIn C++ there are two distinct concepts - accessibility and scope
p32964
aVFrom your question it appears that you've got these two concepts somewhat mixed up (I do not blame you, because they are very close to each other)
p32965
aVAccessibility is controlled by , ,  and so on, and can be additionally granted through "friendship"
p32966
aVScope, on the other hand, is controlled by the placement of the variables and functions being accessed
p32967
aVIn order for a member of a class to access a member of another class that other member must be in scope; it also must be accessible
p32968
aVIt appears that you are attempting to access  from , a  of the class where  is declared
p32969
aVFriendship solves the accessibility part of the problem, but it does not address the scope part
p32970
aVIn order for  to access , an instance member of the  class, it must have a reference of some sort to a  object
p32971
aVThere are many ways to get a reference - for example, you can pass a reference to the  in the constructor of , store it in a private variable, and access  through it, like this:
p32972
aVThis is only one way to solve the problem of scope; other ways include passing  as a parameter of , making  a pointer, making  static, and so on
p32973
aVThe exact way depends on your requirements
p32974
as(dp32975
g6
V335858
p32976
stp32977
a((dp32978
g2
(lp32979
VYou can use an array with an , but you either (1) need to make the declaration of the size explicit, or (2) put a terminator entry, similar to null terminator in a string, to count the number of entries at runtime
p32980
aVSolution 1:
p32981
aVWith this change,  would be defined correctly
p32982
aVSolution 2:
p32983
aVNow you can run a quick loop through  to get to , which would indicate the last entry
p32984
as(dp32985
g6
V335858
p32986
stp32987
a((dp32988
g2
(lp32989
VYou should add  to your query, and order it in reverse of its natural order to get your last record first
p32990
aVAssuming that the default order is by  in ascending order, the  should do the trick:
p32991
as(dp32992
g6
V335858
p32993
stp32994
a((dp32995
g2
(lp32996
VIf you do not have a "neutral" return result, you should "invent" one, and use it in the null object:
p32997
aVWriting to a null object is nearly inevitably a programming error, so the implementation of  should go like this:
p32998
as(dp32999
g6
V335858
p33000
stp33001
a((dp33002
g2
(lp33003
VAs far as the speed goes, it almost does not matter for a list of 400 items
p33004
aVIf you need to grow your list dynamically,  is better; if the size is fixed,  may be better (and a bit faster, although again, you would probably not notice the difference in most situations)
p33005
as(dp33006
g6
V335858
p33007
stp33008
a((dp33009
g2
(lp33010
VI tried strncpy function but it can copy only specific characters from beggining of the string
p33011
aVfamily of functions will copy from the point that you tell it to copy
p33012
aVFor example, to copy from the fifth character on, you can use
p33013
aVor
p33014
aVNote that  will not null-terminate the string for you, unless you hit the end of the source string:
p33015
aVNo null-character is implicitly appended at the end of destination if source is longer than num (thus, in this case, destination may not be a null terminated C string)
p33016
aVYou need to null-terminate the result yourself:
p33017
as(dp33018
g6
V335858
p33019
stp33020
a((dp33021
g2
(lp33022
VWithout resorting to hacks, such as using preprocessor to define shared portions of your would-be-template classes, you cannot avoid templates without introducing some code duplication
p33023
aVIf  and  do not share a common ancestor, you can introduce non-template classes for  and , and inherit from them, as follows:
p33024
aVHowever, this is unlikely to change the speed of compilation
p33025
aVIf  and  do share a lot of common functionality, consider making a non-template version of  that uses the common ancestor of  and  polymorphically
p33026
aVHowever, this may not always be desirable, because it would force you to use pointers/references where instances of the template argument  were sufficient before
p33027
as(dp33028
g6
V335858
p33029
stp33030
a((dp33031
g2
(lp33032
VCan this be achieved in
p33033
aVYes
p33034
aVObserve that the non-decreasing subsequences would have one of these three forms:
p33035
aVThe first two forms can be easily checked in  by counting all zeros and by counting all ones
p33036
aVThe last one is a bit harder: you need to go through the string keeping the counter of zeros that you've seen so far, along with the length of the longest string of  form that you have discovered so far
p33037
aVAt each step where you see  in the string, the length of the longest subsequence of the third form is the larger of the number of zeros plus one or the longest  sequence that you've seen so far plus one
p33038
aVHere is the implementation of the above approach in C:
p33039
aVis defined as follows:
p33040
aVHere is a link to a demo on ideone
p33041
as(dp33042
g6
V335858
p33043
stp33044
a((dp33045
g2
(lp33046
VIn your project, go to the Breakpoint navigator, click the [+] button and Add Exception Breakpoint
p33047
aVClick Exception > All, and Break > On Throw, click [Done]
p33048
aVWith this setting in place, Xcode should break at the place in your project where the exception is thrown
p33049
aVYou may need to walk down the stack for a frame or two to get to your code
p33050
as(dp33051
g6
V335858
p33052
stp33053
a((dp33054
g2
(lp33055
VYes, you can split once in the first , and pass the result down the chain to the second , like this:
p33056
as(dp33057
g6
V335858
p33058
stp33059
a((dp33060
g2
(lp33061
VThe  will call  if you have an instance of
p33062
aVIt does not matter if the instance is referenced through a pointer or a reference to a base class: regardless of this, 's version is called; this is what makes polymorphic calls possible
p33063
aVThe behavior is not compiler-specific: virtual functions behave this way according to the standard
p33064
as(dp33065
g6
V335858
p33066
stp33067
a((dp33068
g2
(lp33069
VAlthough the reference to  is passed (by value) to , the object itself is immutable
p33070
aVWhen you do , the incremented value is assigned to  which is local to
p33071
aVAs soon as you return, the value goes back to the unchanged copy of  in the caller
p33072
aVYou can make  a  variable, and drop it from the parameter list of  to fix the problem:
p33073
as(dp33074
g6
V335858
p33075
stp33076
a((dp33077
g2
(lp33078
VNo, do not set local variables to  to hasten their collection by the GC: the compiler is smart enough to figure it out without your help; the  assignments will only make your code look dirty
p33079
aVNon-locals are a different story: if you have a member variable that might stay around for longer than necessary, it is a good idea to set it to  and prevent lingerer memory leaks
p33080
as(dp33081
g6
V335858
p33082
stp33083
a((dp33084
g2
(lp33085
VYou have misspelled the name of the description method of the  class: it should be , not
p33086
as(dp33087
g6
V335858
p33088
stp33089
a((dp33090
g2
(lp33091
VYes, your constructor is thread safe, because it accesses only instance variables (specifically, )
p33092
aVIt does exhibit undefined behavior, because it reads from uninitialized  to perform the increment, but that has nothing to do with thread safety
p33093
aVHere is how you can fix undefined behavior:
p33094
aVNow that  is initialized in the initializer list, your program behaves in a predictable way
p33095
as(dp33096
g6
V335858
p33097
stp33098
a((dp33099
g2
(lp33100
V implements the Null Object Design Pattern to address the difference between DB returning a NULL vs
p33101
aVnot returning anything
p33102
aVUnfortunately, the lack of its intuitiveness keeps tripping up programmers for many years
p33103
aVThe best you can do is wrapping it in a generic method, like this:
p33104
aVNow you can call this method like this:
p33105
as(dp33106
g6
V335858
p33107
stp33108
a((dp33109
g2
(lp33110
VThis is one of the simplest regexes to write: put  for each digit,  for each dash, and a  for each dot
p33111
aVLetters correspond to themselves, so  goes in unchanged
p33112
aVWhen you have more time, you can earn some "points for style" by learning about the explicit quantifier notation for repeated groups
p33113
as(dp33114
g6
V335858
p33115
stp33116
a((dp33117
g2
(lp33118
VThe above will never work: it is impossible to make an object of type
p33119
aVThe reason is that  does not represent a type
p33120
aVRather, it is a generic type definition - a  object used to examine structures of other generic types, but not themselves representing a valid
p33121
aVNET type
p33122
aVIf an  is, say, a , then
p33123
aVHere is how you can modify your code:
p33124
as(dp33125
g6
V335858
p33126
stp33127
a((dp33128
g2
(lp33129
VYou can bring the worst case to  by supplying objects that all hash to the same bucket when the set reaches its maximum size
p33130
aVFor example, if you pass a sequence of 17519 s constructed as
p33131
aVfor  between 1 and 17519, inclusive, all numbers will hash to the initial bucket on Microsoft's implementation of , taking  to insert:
p33132
aVSet a brea kpoint, and examine  in the debugger
p33133
aVLook at Raw View / Non-public members / m_buckets
p33134
aVObserve that the initial bucket has 17519 elements, while the remaining 17518 all have zeros
p33135
as(dp33136
g6
V335858
p33137
stp33138
a((dp33139
g2
(lp33140
VIn NUnit's constraint model, you can do this:
p33141
aVBetter yet, make it a function:
p33142
aVEDIT : In MS Unit Test Framework, do this:
p33143
as(dp33144
g6
V335858
p33145
stp33146
a((dp33147
g2
(lp33148
VThe two are exactly the same
p33149
aVThey both are equally safe
p33150
aVThis feature is inherited from C, where comparing to zero is implicit
p33151
as(dp33152
g6
V335858
p33153
stp33154
a((dp33155
g2
(lp33156
VYou can split the string on , and look for strings that represent numbers:
p33157
aVGo through the strings in the  array, and take the first string that represents a number
p33158
as(dp33159
g6
V335858
p33160
stp33161
a((dp33162
g2
(lp33163
VThe reason why you see a problem has to do with the placement of the  function in the : in the call to  below,  represents a pointer to
p33164
aVEssentially, the call below
p33165
aVis a short way to write this:
p33166
aVMoving  to  fixes this problem
p33167
aVAnother alternative is making  a template:
p33168
aVand calling it like this:
p33169
aVThis does not look particularly nice, but may be a work-around to code copy-pasting in situations when the real-world  is large
p33170
aVYet another solution is to make  a template, like this:
p33171
aVThis also works (link to ideone)
p33172
as(dp33173
g6
V335858
p33174
stp33175
a((dp33176
g2
(lp33177
VNo, there is no memory leak in your convenience method under ARC: the compiler is smart enough to deal with releasing the  when the last strong reference to it is gone, employing autorelease behind the scenes if it is necessary
p33178
as(dp33179
g6
V335858
p33180
stp33181
a((dp33182
g2
(lp33183
VYou were on the right track: change the signature of your method to return , allocate the  inside, and put your code in place of  below:
p33184
aVNow this will work:
p33185
as(dp33186
g6
V335858
p33187
stp33188
a((dp33189
g2
(lp33190
VYou are getting this exception because in order to convert to array of strings, the elements themselves must be strings as well
p33191
aVYou can do it with LINQ, though:
p33192
aVTo deal with s, replace  with  or a conditional that checks for s
p33193
as(dp33194
g6
V335858
p33195
stp33196
a((dp33197
g2
(lp33198
VStart by converting the skeleton of the nested loops to LINQ:
p33199
aVThis gives you a list of pairs
p33200
aVNow add filtering by inverting the  condition:
p33201
aVFinally, add a  to call `new:
p33202
aVWith  list in hand, you can call  in a loop
p33203
as(dp33204
g6
V335858
p33205
stp33206
a((dp33207
g2
(lp33208
V"Natural" ordering is the ordering implied by the implementation of the  interface by the objects used as keys in the
p33209
aVEssentially, RBTree must be able to tell which key is smaller than the other key, and there are two ways to supply that logic to the RBTree implementation:
p33210
aVImplement  interface in the class(es) used as keys to , or
p33211
aVSupply an implementation of the  that would do comparing outside the key class itself
p33212
as(dp33213
g6
V335858
p33214
stp33215
a((dp33216
g2
(lp33217
VYou get a linker error because you declared , but you never defined it
p33218
aVis only a declaration; it does not cause allocation of memory for the  variable, only promises that you will do it at some other place
p33219
aVTo fix it, you need to add this line to one of the cpp files, like this:
p33220
as(dp33221
g6
V335858
p33222
stp33223
a((dp33224
g2
(lp33225
V is a wrapper class on top of the primitive
p33226
aVIt can be cast to , but it cannot be cast to  directly
p33227
aVIf you use  instead of , it will compile:
p33228
aVYou can also add a cast to  in the middle, like this:
p33229
as(dp33230
g6
V335858
p33231
stp33232
a((dp33233
g2
(lp33234
VIt does not work because  has  property, not :
p33235
aVSometimes, Xcode lets you pick a wrong method; when you are not certain of the exact name, consult developer documentation available online and through Xcode's Help/Documentation and API Reference
p33236
as(dp33237
g6
V335858
p33238
stp33239
a((dp33240
g2
(lp33241
VTry rewriting the query with , like this:
p33242
as(dp33243
g6
V335858
p33244
stp33245
a((dp33246
g2
(lp33247
VAccording to the C99 Standard, when  format specifier is provided to  with no  length modi\ufb01er,
p33248
aVthe  argument is converted to an , and the resulting character is written
p33249
aVThis means that 400 is converted to an , which is , or
p33250
aVThen, the character that corresponds to  is written out
p33251
aVThis is a UNICODE control sequence, so that  character that you see is system-dependent
p33252
as(dp33253
g6
V335858
p33254
stp33255
a((dp33256
g2
(lp33257
VYou can use , like this:
p33258
aVIf the set of numbers contains a fixed group of numbers, such as in your example, you can make the  a static variable, and initialize it once, rather than doing it every time as in my example above
p33259
as(dp33260
g6
V335858
p33261
stp33262
a((dp33263
g2
(lp33264
VI am getting weird results when I pass Angle as -360 to 360 into a Cos(angle) or Sin(angle)
p33265
aVI think the reason your attempt did not work is that you were passing angles in degrees
p33266
aVThe  and  trigonometric functions expect angles expressed in radians, so the numbers should be from  to
p33267
aVFor  degrees you pass
p33268
aVis a constant defined in  header
p33269
as(dp33270
g6
V335858
p33271
stp33272
a((dp33273
g2
(lp33274
VThe offset of the first member must always be zero by the C standard; that's why your first cast works
p33275
aVThe offset of the second member, however, may not necessarily be equal to the size of the first member of the structure because of padding
p33276
aVMoreover, adding a number to a pointer does not add the number of bytes to the address: instead, the size of the thing being pointed to is added
p33277
aVSo when you add  to ,  gets added
p33278
aVYou can use  operator if you want to do the math yourself, like this
p33279
aVThe reason this works is that  is always one, as required by the C standard
p33280
aVOf course you can use  to avoid doing the math manually
p33281
as(dp33282
g6
V335858
p33283
stp33284
a((dp33285
g2
(lp33286
VThe documentation does not specify the order, but you can always force the order you want by employing LINQ's  function
p33287
aVYou can skip index changes by clearing out references to , rather than actually removing  the items from the array
p33288
aVThe tradeoff here is that you must now check if the item at the given index is
p33289
aVIf you have a more readable data structure in mind that is based on a , consider switching to it, and ignore the efficiency concerns until your profiler tells you that you must optimize this particular part of your code
p33290
as(dp33291
g6
V335858
p33292
stp33293
a((dp33294
g2
(lp33295
VA common reason for this is that your array has not been initialized
p33296
aVWhen this happens, Objective C does not complain or throw excetions: instead, it behaves as if the calls to add elements never happened
p33297
aVIt also returns nil when you try getting items back
p33298
aVAdd this line to your viewDidLoad method:
p33299
aVThis should solve the problem
p33300
as(dp33301
g6
V335858
p33302
stp33303
a((dp33304
g2
(lp33305
VThe easiest approach is to try them all: you have six numbers, meaning that there are up to five spots where you can place an operator, and up to  permutations
p33306
aVGiven that there are only four operators, you need to go through , or 737280 possibilities
p33307
aVThis can be easily done with a recursive function, or even with nested loops
p33308
aVDepending on the language, you could use a library function to deal with permutations
p33309
aVA language-agnostic recursive approach would have you define three functions:
p33310
as(dp33311
g6
V335858
p33312
stp33313
a((dp33314
g2
(lp33315
VAlthough it may not matter in the end because of tail call optimization, iterative approach to linked list processing is more idiomatic, at least as far as C++ is concerned
p33316
aVUnlike recursive approach, iterative one will not result in stack overflow even if your compiler does not apply tail call optimization
p33317
as(dp33318
g6
V335858
p33319
stp33320
a((dp33321
g2
(lp33322
VThe error says that it cannot find a method  is not available in the context of a class method (i
p33323
ag630
aVone denoted with a  sign)
p33324
aVThis may look confusing, because  inside a class method does not correspond to an instance, but to a class; the property , on the other hand, belongs to an instance, meaning that it is not available
p33325
aVTo address this, you should either make  an instance method, or rewrite it as follows:
p33326
as(dp33327
g6
V335858
p33328
stp33329
a((dp33330
g2
(lp33331
VWhen you use  that is synthesized* you can avoid writing "boilerplate" code, such as copying or locking to make access atomic
p33332
aVThe importance of this feature has greatly diminished with the introduction of ARC
p33333
aVWith no need to write  in the latest Xcode, you can use properties with little or no additional coding
p33334
aVSince properties are more "future proof" than variables because you can perform validation in the setter and calculations in the getter, you have almost no reason to use "plain" variables
p33335
aVThe use of  is not necessary in the latest Xcode
p33336
aVIf you see a lot of , chances are that you are reading an "old code" (more than 6 months old)
p33337
aVNo, there is no reason to do that with variables
p33338
aVSome shops require programmers to do that anyway, allegedly for clarity
p33339
aVI would not comment on that, because this is a matter of preference
p33340
aVIf you decide to do it, you should do it consistently across your entire code base
p33341
aV* Either explicitly through  or implicitly with the latest Xcode
p33342
as(dp33343
g6
V335858
p33344
stp33345
a((dp33346
g2
(lp33347
VShould I go for User Defaults or start with Core Data right away
p33348
aVThere are more possibilities here: you can also use plain files or plists, or use sqlite without Core Data
p33349
aVThe answer depends on the number of items that you plan to store:
p33350
aVIf you plan to store 1 to 20 items, user defaults would work fine
p33351
aVIf you plan to store 20 to 200 items, plain files or plists would work
p33352
aVIf you plan to store 200+ items, go for Core Data or sqlite, depending on your level of comfort with one of these technologies
p33353
as(dp33354
g6
V335858
p33355
stp33356
a((dp33357
g2
(lp33358
VIf the code comes to you in a DLL with no source or debug symbols, your debug options are rather limited: you cannot set breakpoints with no source, unless you are comfortable looking at disassembly
p33359
aVOne way to address the issue is to wrap the external code in your own class, like this:
p33360
as(dp33361
g6
V335858
p33362
stp33363
a((dp33364
g2
(lp33365
VAccording to the C++ standard, deleting objects allocated with  using  is undefined behavior
p33366
aVAnything can happen - from "nothing" to corrupting your heap beyond all recognition
p33367
aVIt makes no sense to say what exactly gets deleted in cases like that, because it is heavily system-dependent
p33368
aVDeleting "a wrong thing" is undefined behavior
p33369
aVTypically, this corrupts your heap, because common implementations of allocators expect certain values to be stored just prior to the address that you pass for deallocation
p33370
aVThis is by no means a standard, so again, anything can happen
p33371
aVIt does not delete the element 99 because it never allocated element 99: it allocated an array of 100 items, not a single ; it expects you to deallocate all 100 items at once - you cannot deallocate it in any other way
p33372
as(dp33373
g6
V335858
p33374
stp33375
a((dp33376
g2
(lp33377
VYou can get an element by its tag
p33378
aVIf you are in a view controller code and you need to get a button that you tagged as  in the interface builder, you can use this code:
p33379
aVThe element does not need to be a button - it can be any  descendant: a label, a text view, a stepper, or anything else
p33380
aVPlease note that a more idiomatic way of accessing elements that you create in the interface builder is through s
p33381
aVHere is how you can add an outlet to your view or view controller: open interface builder in a separate window, control-click the element that you want to add as an outlet, find "referencing outlet/new referencing outlet" in the context menu that drops down, and drag from the black circle into the header of your view or view controller
p33382
aVWhen you drop the item into the code, you will be prompted for the name of the outlet
p33383
aVOnce the outlet is created, you can access its corresponding element through the variable that you created
p33384
as(dp33385
g6
V335858
p33386
stp33387
a((dp33388
g2
(lp33389
VI think that you have a misunderstanding of what  means
p33390
aVEssentially, when you tell the compiler that an object's type is , you "promise" that the object at runtime will support whatever methods or properties that you invoke, in exchange for the compiler not complaining at compile time
p33391
aVYou also promise that you will face the consequences if you break your promise
p33392
aVWhen you say that an object is , the compiler cannot make assumptions about the type, so it uses , knowing that anything can be stored as
p33393
aVWhen you make an , it becomes , with one significant difference: you can call any method on its elements, and the compiler will not say a word:
p33394
aVSince  gives a sequence of  objects, the compiler does not complain about your call to
p33395
aVIf the method is indeed not supported at runtime, the program will crash; if the method is actually supported by elements of , there would be no crash, and the method will be invoked
p33396
aVThat's all the  will do for you; statically, the "placeholder" will remain , and  will tell you as much
p33397
aVBut the exact capabilities of the object (its methods and properties) will not be examined until runtime
p33398
as(dp33399
g6
V335858
p33400
stp33401
a((dp33402
g2
(lp33403
VIn the latest Xcode  is optional
p33404
aVBy default, omitting  is the same as writing
p33405
aVThe only reason to use  is to rename the instance variable created to store the value of the property, for example
p33406
aVWhen you use  to access a variable, you go through a property, which is a short method that accesses the instance variable for you
p33407
aVAlthough the method dispatch is very fast, it may perform additional services for you, such as synchronizing the access to the variable (this is the case when you specify  or do not specify  in the property declaration)
p33408
aVIn cases like that, the access through  will be somewhat slower
p33409
aVIf done in a tight loop, this could potentially make a difference
p33410
aVThat is why you sometimes want to access the underlying instance variable directly by using
p33411
as(dp33412
g6
V335858
p33413
stp33414
a((dp33415
g2
(lp33416
VSince you need this only for numbers  through , the easiest approach is to define an array of ordinals, like this:
p33417
aVThis is better than doing it algorithmically, because it is more readable, and is easier to internationalize, should you run into this at some point later on
p33418
as(dp33419
g6
V335858
p33420
stp33421
a((dp33422
g2
(lp33423
VUnfortunately, there is no way to replace all  characters in one shot
p33424
aVBut you can do it in a loop, like this:
p33425
aVThis program prints
p33426
aVIf you need to replace only the first colon, then use the body of the loop by itself, without the loop around it
p33427
as(dp33428
g6
V335858
p33429
stp33430
a((dp33431
g2
(lp33432
VA somewhat expensive and roundabout way to count single-character matches is as follows:
p33433
aVWhen the length of the string with all s removed is subtracted from the length of the original string, you end up with the number of s in the original string
p33434
as(dp33435
g6
V335858
p33436
stp33437
a((dp33438
g2
(lp33439
VYou can do it like this:
p33440
as(dp33441
g6
V335858
p33442
stp33443
a((dp33444
g2
(lp33445
VYou can speed up your search for new primes by storing the primes that you have already found in a private collection inside the
p33446
aVBy trying only them as potential divisors instead of your  loop, you will have to do much fewer divisions
p33447
aVYou can stop the "find divisors" loop well before you reach the : specifically, you can stop when your candidate divisor exceeds the square root of the target number
p33448
aVThis works, because you try the candidate divisors in ascending order: if there were divisors above the square root, the result of the division would have been below the square root, so you would have already found them
p33449
aVYour  method should call  internally before returning the value to the caller
p33450
aVOtherwise, the call of  cannot be said to return the next prime
p33451
as(dp33452
g6
V335858
p33453
stp33454
a((dp33455
g2
(lp33456
VYou can use the  function to try items for  in order, and then take the first non-null one for comparison
p33457
aVYou can also use  to avoid writing out the call twice:
p33458
as(dp33459
g6
V335858
p33460
stp33461
a((dp33462
g2
(lp33463
VYou have lots of choices here:
p33464
aVMake both properties read-only, and add a method that sets them both simultaneously
p33465
aVMake both properties read-write, let them throw an exception when they are not set consistently, and add a method that sets them both simultaneously
p33466
aVMake both properties read-write, and add a method that lets you turn off validation temporarily
p33467
aVMake a "guard" that switches the validation back on upon destruction, and use the guard in a  statement
p33468
aVAdd transactional semantic to your object: pay attention to an ambient transaction, store pending sets in a queue when a transaction is "in progress", and apply all changes at once when the transaction is committed
p33469
as(dp33470
g6
V335858
p33471
stp33472
a((dp33473
g2
(lp33474
VQuotes around identifiers are used only during the query parsing stage - a stage that goes through the SQL statement, and figures out its syntactic elements
p33475
aVCompared to other stages (query optimization, query execution, and passing the results back to the caller) the parsing stage is relatively short
p33476
aVTherefore, you should not expect any measurable speedup or slowdown from using quotes around your identifiers, regardless of your particular RDBMS
p33477
aVAs far as being more or less error prone goes, missing quotes around multipart identifiers become apparent very quickly during the development stage, so the practice of placing quotes everywhere it is not worth the trouble, because the readability to humans suffers significantly
p33478
aVFinally, adding quotes around identifiers would not help you prevent injection attacks; same goes for not placing quotes around all identifiers
p33479
aVMany SQL script generators take this route to avoid  statements all over the script testing if the identifier is multipart or not
p33480
aVThe only situation where quoting all identifiers is a good idea is when you generate SQL programmatically, and the results are not intended for human readers
p33481
as(dp33482
g6
V335858
p33483
stp33484
a((dp33485
g2
(lp33486
Vwhat should I replace  with
p33487
aVYou should replace  with the name of the most specific common ancestor of the classes that you are planning to use with this pointer
p33488
aVIn your example, that would be , because both  and  inherit it, and there are no other common ancestors
p33489
aVIn the worst case, the common ancestor is
p33490
aVIn general, tricks like that should be avoided in most situations, because reusing a pointer for something really different is bad for readability
p33491
as(dp33492
g6
V335858
p33493
stp33494
a((dp33495
g2
(lp33496
VNo, casting has nothing to do with the problem
p33497
aVThe reason you get an excetion is that sometimes the object at index 2 is of a wrong type
p33498
aVThe fact that the error does not happen consistently is an additional clue: look for a situation when the game controller is not at the second index to solve this problem
p33499
aVGenerally, casting helps at telling the compiler more about the type of your object
p33500
aVGiven the dynamic nature of Objective C, this is a lot less important than, say, in C++
p33501
as(dp33502
g6
V335858
p33503
stp33504
a((dp33505
g2
(lp33506
VShort answer: you should prefer  and  for setting foundation properties of type
p33507
aVFor the long answer, let's first see where are these constants defined:
p33508
aVand  are from ; they are -d as  and
p33509
aVand  are from ; they are -d as  and
p33510
aVand  are from
p33511
aVThis is where  is -ed as , and its two values are -d as  and  or / if  is supported
p33512
aVThe foundation classes consistently use , which is a  for , to represent its boolean properties
p33513
aVSince the first two pairs get converted to  constants, using them may result in warnings, though it would probably work correctly anyway
p33514
aVThe  and  constants, however, are defined in the most compatible way for your compiler, regardless of its version
p33515
aVTherefore, I would recommend using  and  consistently throughout your code
p33516
as(dp33517
g6
V335858
p33518
stp33519
a((dp33520
g2
(lp33521
VIn C# you can do it with  or with a recursive lambda
p33522
aVHere is an example of the second approach:
p33523
as(dp33524
g6
V335858
p33525
stp33526
a((dp33527
g2
(lp33528
VYou cannot pass a reference to  into a method expecting
p33529
aVYou can solve this by introducing a temporary variable, like this:
p33530
as(dp33531
g6
V335858
p33532
stp33533
a((dp33534
g2
(lp33535
VTo test the functionality, three unit tests would be sufficient:
p33536
aVPass two figures,  and , where the area of  is greater than the area of
p33537
aVVerify that you get  back;
p33538
aVPass two figures,  and , where the area of  is smaller than the area of
p33539
aVVerify that you get negative  back;
p33540
aVPass the same figure for both parameters
p33541
aVVerify that you get  back
p33542
aVIn addition, consider some failure tests: passing  for one or both figures, and passing a figure that returns "not a number"/"infinity" for its area
p33543
as(dp33544
g6
V335858
p33545
stp33546
a((dp33547
g2
(lp33548
V is a reserved word in SQL, so you need to put square brackets around it
p33549
as(dp33550
g6
V335858
p33551
stp33552
a((dp33553
g2
(lp33554
VYou cannot make an array until you know its exact size: unlike lists, arrays cannot grow*; once you give them a size, they keep that size forever
p33555
aVIf you must have an array for processing, make a  first, populate it, and then convert to an array with  method:
p33556
aVNote, however, that this is premature optimization: lists are very much as fast as arrays, but they offer a lot more flexibility
p33557
aVReplacing lists with arrays does not make sense, at least not before you profile
p33558
aV* Calls of  to change the size of the array do not count as "growing" the array, because you end up with a different array instance, and the one you were trying to "grow" gets thrown away immediately after being copied
p33559
as(dp33560
g6
V335858
p33561
stp33562
a((dp33563
g2
(lp33564
VAccording to the C++ standard, 13
p33565
ag839
ag1340
aVTwo function declarations of the same name refer to the same function if they are in the same scope and have equivalent parameter declarations
p33566
aVThis means that only the name and parameter types are considered; return type is not
p33567
aVThis makes sense, because you can invoke a function with a return value, and disregard its return value
p33568
aVIf language designers allowed overloads on the return type, compilers would not be able to resolve these overloads in some legitimate contexts
p33569
as(dp33570
g6
V335858
p33571
stp33572
a((dp33573
g2
(lp33574
VThis condition starts from the right, evaluates , gets the result (0 or 1), and uses it for join with
p33575
aVAll rows of  with  from the  list are joined to the row in  that has  of one; all other rows of  are joined with the row in  that has  of zero
p33576
aVHere is a small demo on sqlfiddle
p33577
aVcom: link
p33578
aVIt is hard to imagine that that was the intent of the author, however: I think a more likely check was for both items to be in the list, and also being equal to each other
p33579
aVThe equality to each other is important, because it looks like the author wanted to join the two tables
p33580
aVA more modern way of doing joins is with ANSI SQL syntax
p33581
aVHere is the equivalent of your query in ANSI SQL:
p33582
as(dp33583
g6
V335858
p33584
stp33585
a((dp33586
g2
(lp33587
VThe brackets are all wrong
p33588
aVIt should be:
p33589
aVThis is because your  uses
p33590
aVIf you wanted brackets around  to remain in place, replace  with
p33591
aVOf course  has incorrect meaning now, so I would rename it, as follows:
p33592
aVThis would not work for more than two items, however
p33593
aVYour original one rule would work, like this:
p33594
aVThis produces
p33595
aVin the  list
p33596
as(dp33597
g6
V335858
p33598
stp33599
a((dp33600
g2
(lp33601
VBut this does not work
p33602
aVthis does not trim
p33603
aVIt does trim, but since  is immutable, the trimmed string is thrown away, because you do not assign it to anything
p33604
aVThis would work (but do not do it like that
p33605
aVWhat you do is not trimming, it's taking a substring
p33606
aVprovides a much better method for that:
p33607
as(dp33608
g6
V335858
p33609
stp33610
a((dp33611
g2
(lp33612
VYou need to add a loop that checks if a number exists among the items that you have already added
p33613
aVDefine a  variable, set it to , and go through the loop comparing the existing numbers against the newly generated one
p33614
aVIf you see a duplicate, set the  to
p33615
aVOnce the loop is over, check your  to see if the new number has to be added or not
p33616
aVA better solution would involve using a , but that is probably an advanced topic at this stage
p33617
as(dp33618
g6
V335858
p33619
stp33620
a((dp33621
g2
(lp33622
VThese two fragments of code are not equivalent:
p33623
aVthe first one goes through and copies all  characters regardless of the content of the string;
p33624
aVthe second one stops right after copying the null terminator, or upon copying  characters, whichever comes first
p33625
aVNeither first nor the second implementation is equivalent to  from the standard library, which copies up to the terminator, and then continues on to fill the remaining space with zeros
p33626
aVTo make your function standard-compliant, add this line before the  statement:
p33627
aVAnother thing to note is that the intent behind  is often misunderstood: it is there to handle fixed-length strings, not variable-length strings with a fixed limit
p33628
aVThat is why you need to null-terminate the results that you get from : if the  string is longer than  characters, the resultant string would not be null-terminated
p33629
as(dp33630
g6
V335858
p33631
stp33632
a((dp33633
g2
(lp33634
VIn general, the answer is "no":  statements work with a single variable
p33635
aVHowever, in some cases you can do the conversion
p33636
aVFor example, if you have two variables,  and , where  can be 0, 1, or 2, and  that can be , you can do a switch like this:
p33637
as(dp33638
g6
V335858
p33639
stp33640
a((dp33641
g2
(lp33642
VThe keyword  is there specifically to bypass access restrictions imposed by  and  access control
p33643
aVIf you would like to access private variables without using , add public accessors to the class itself: this is the most common and intended way of accessing private variables:
p33644
as(dp33645
g6
V335858
p33646
stp33647
a((dp33648
g2
(lp33649
VWhen Prolog interpreter sees  in front of a clause when loading the program, the clause gets executed right away, rather than becoming part of the program "database"
p33650
aVThe most common use of the  is defining the starting predicate of your program at the end of your program file, so that loading the file with your program causes it to run
p33651
aVSpecifically,  informs the interpreter that the definition of the specified predicate may change at runtime
p33652
aVThis is something the interpeter needs to know before reading the rest of your program, so that it could make special arrangements for uses of the  predicate
p33653
as(dp33654
g6
V335858
p33655
stp33656
a((dp33657
g2
(lp33658
VYour format string should be as follows:
p33659
aVYou need four  before the colon-separated block  for , and your code had only three  in there
p33660
aVAlso, the strings for , , and  should be limited to  characters; otherwise, the entire  gets read into the  string
p33661
aVHere is a link to a demo on ideone
p33662
as(dp33663
g6
V335858
p33664
stp33665
a((dp33666
g2
(lp33667
VNaming Objective C methods takes some time getting used to: the idea is to "glue" the description of the first parameter to the name of the method:
p33668
aVThe idea is to make the name of your selector read as close to English as you think reasonable
p33669
aVIn this case, the name of the selector is , and it reads OK in English
p33670
as(dp33671
g6
V335858
p33672
stp33673
a((dp33674
g2
(lp33675
V is a message that can be sent to Objective C objects
p33676
aVBefore ARC, you needed to do it explicitly, like this:
p33677
aVUnder ARC, the compiler figures out the  part for you, but the message is stil sent to the object; that object gets added to the autorelease pool as a result
p33678
aVWhen autorelease pool gets drained, all objects inside it are sent a  message
p33679
aVIf there are no other references to the object, its reference count drops to zero, and the object get cleaned up
p33680
aVC arrays do not respond to  or  message: they are not Objective C entities, so they do not respond to messages at all
p33681
aVTherefore, you must deal with the memory that you allocate for these arrays manually, by calling 1 and
p33682
aVOf course you can place autoreleased objects inside a C array, and these objects will be cleaned up in the regular course of action
p33683
aVFor example
p33684
aVIf the caller does not   objects inside the  array, these objects will be autoreleased2
p33685
aVThe  object, however, needs to be cleaned up separately:
p33686
aV1 You did not call  in your code, so accessing  is undefined behavior
p33687
aV2 Causing hanging references in the process
p33688
as(dp33689
g6
V335858
p33690
stp33691
a((dp33692
g2
(lp33693
VC and C++ standards treat initialization of objects with  storage duration differently
p33694
aVC++ allows both static initialization (i
p33695
ag630
aVinitialization with a constant) and dynamic initialization (i
p33696
ag630
aVinitialization with non-constant expression), while C allows only static initialization - i
p33697
ag630
aVwith constant expressions
p33698
aVThe relevant portion of the C++ standard is 6
p33699
ag838
aV4:
p33700
aVThe zero-initialization (8
p33701
aV5) of all local objects with static storage duration (3
p33702
ag838
aV1) is performed before any other initialization takes place
p33703
aVA local object of POD type (3
p33704
aV9) with static storage duration initialized with constant-expressions is initialized before its block is \ufb01rst entered
p33705
ag9057
aVOtherwise such an object is initialized the \ufb01rst time control passes through its declaration; such an object is considered initialized upon the completion of its initialization
p33706
aV(emphasis added)
p33707
aVC++ need additional "bookkeeping" in order to run the dynamic portion of your initializer (i
p33708
ag630
aVthe call of ) only once
p33709
aVThere is no similar "dynamic" provision in the C standard:
p33710
aVAll objects with static storage duration shall be initialized (set to their initial values) before program startup
p33711
aVAll the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals
p33712
aVIn the absence of concurrency, you can rewrite the code for use with C like this:
p33713
aVNow your code is responsible for the "bookkeeping": it checks  for  before performing the allocation
p33714
as(dp33715
g6
V335858
p33716
stp33717
a((dp33718
g2
(lp33719
VAlthough the "heap is slower" statement is too broad to be meaningful, certain aspects associated with heap allocations are definitely slower than the heap
p33720
aVUnlike stack, which cannot get fragmented because you cannot remove things from the middle of the stack, heap is subject to fragmentation
p33721
aVYour program can de-allocate objects in arbitrary order, creating "holes" in the heap
p33722
aVWhen you request more memory, the allocator must search for a suitable "hole" to fulfill your request
p33723
aVIn addition, stack-based operations are highly optimized by the computer hardware
p33724
aVFinally, objects allocated in the automatic storage (the official name for "stack") have a higher probability of being cached due to proximity to other locals that your program accesses
p33725
aVAs far as  storage goes, it applies only to data members: static functions and static member functions simply re-use the keyword without re-using its meaning
p33726
aVObjects in static storage are allocated only once, so there is no cause for fragmentation
p33727
aVOnce the allocation is done, the speed of access to the objects in the three kinds of storage (static, dynamic, and automatic) goes at pretty much the same speed
p33728
as(dp33729
g6
V335858
p33730
stp33731
a((dp33732
g2
(lp33733
VThere is a vitally important requirement to non- pointers that you pass to : they must themselves come from a call to ,  or , otherwise the behavior is undefined
p33734
aVIf you allocate a chunk of memory sufficient to store an  and then  for a , you will always get back the same pointer, because  is less than or equal to the :
p33735
aVIf you try it the other way around, you will almost certainly get back the same pointer as well, because memory allocators rarely, if ever, parcel the memory to chunks smaller than
p33736
aVHowever, the result is implementation-dependent, so theoretically you may get back a different address
p33737
aVAs far as the utility of any of the above exercises goes, it is not useful:  has been designed with the intention to help you manage variable-sized arrays, simplifying the code for growing the size of such arrays, and potentially reducing the number of allocations and copying
p33738
aVI do not see a reason for -ing a scalar
p33739
as(dp33740
g6
V335858
p33741
stp33742
a((dp33743
g2
(lp33744
VYou can do all replacements in a single call using regular expressions, like this:
p33745
aVThe idea behind this approach is to construct a regular expression that matches any adjective as a single word (so "bigot" would not be matched, while "big" would be matched), and replace that word with an empty string
p33746
aVHere is a demo on ideone
p33747
as(dp33748
g6
V335858
p33749
stp33750
a((dp33751
g2
(lp33752
VThis is because the assignment
p33753
aVcopies the string constant into a writable memory, while
p33754
aVleaves it in the read-only memory
p33755
aVWhile it is absolutely OK to write to the writable memory (duh
p33756
aVwriting to read-only memory is undefined behavior, and may trigger a crash
p33757
aVNote that you do not need to specify the size of your string explicitly, unless you want to allocate more memory than is required for your string literal:
p33758
as(dp33759
g6
V335858
p33760
stp33761
a((dp33762
g2
(lp33763
VStarting with C99, you can use designated initializers to set fields of structures to values, as follows:
p33764
as(dp33765
g6
V335858
p33766
stp33767
a((dp33768
g2
(lp33769
VYour solution incorrectly decides when to finish the loop
p33770
aVAlso, it unconditionally increments  in the loop header, and never decrements  even when it points to a negative number
p33771
aVHere is how you fix it:
p33772
aVHere is a demo on ideone
p33773
aVYou can rewrite this loop using a more readable identifiers for your  and  pointers, rather than using  and
p33774
aVThis would make your algorithm look more "symmetric" in the code, to recognize the symmetry in its design:
p33775
aVHere is an ideone link to the alternative implementation
p33776
as(dp33777
g6
V335858
p33778
stp33779
a((dp33780
g2
(lp33781
VWhen you allow a collection to be indexable, you take on a contract that constraints your ability to optimize the internals of your collection
p33782
aVIn particular, there is an implicit understanding that if you see a certain item at an index  at some point in time and then add more items to the collection, it would be highly unusual for the item at  to appear at a different index after the additions
p33783
aVThis presents a limitation: if you wanted to implement a hash-based set with an indexer, you wouldn't be able to resize it automatically, and disregard the indexing
p33784
aVYour implementation will have to do more work than if you dropped the indexing requirement
p33785
as(dp33786
g6
V335858
p33787
stp33788
a((dp33789
g2
(lp33790
VSince  returns , you cannot retrieve the from and to indexes that were used to create the sublist
p33791
aVHowever, nothing stops you from storing these indexes yourself: you can easily write a wrapper yourself to keep the indexes, like this:
p33792
as(dp33793
g6
V335858
p33794
stp33795
a((dp33796
g2
(lp33797
VThis is expected: when you make a lambda, compiler creates a closure
p33798
aVIt will capture the value of a temporary variable in there, but it would not capture the value of loop variables and other variables that change after creation of the lambda
p33799
aVThe core of the issue is that the delegate creation and execution times are different
p33800
aVThe delegate object is created while the loop is running, but it is called well after the loop has completed
p33801
aVAt the time the delegate is called, the loop variable has the value that it reached at the time the loop has completed, resulting in the effect that you see (the value does not change, and you see the last value from the loop)
p33802
aVForgetting to create a temporary variable for use in closures is a mistake so common that popular code analyzers (e
p33803
ag303
aVReSharper) warn you about it
p33804
as(dp33805
g6
V335858
p33806
stp33807
a((dp33808
g2
(lp33809
VThe reason you see this behavior is mixing the  reads with getline
p33810
aVWhen you read the count, the input pointer is advanced to the end of the numeric input, i
p33811
ag630
aV4, and stops right before the new line character is read
p33812
aVThis is when you call ; the new line character is read, and the new line is returned right away
p33813
aVTo fix this problem, add a call to  right after the  call, and discard the result
p33814
as(dp33815
g6
V335858
p33816
stp33817
a((dp33818
g2
(lp33819
VA clean way to solve this problem would be to store the view controller with your custom cell, like this:
p33820
aVWhen you create new cells in your "cell for row at index path", pass the view controller to the initializer of the cell
p33821
aVThis way, the cell would be able to "find" the controller, letting you code your action by using  instead of :
p33822
as(dp33823
g6
V335858
p33824
stp33825
a((dp33826
g2
(lp33827
VNo, you did not miss anything
p33828
aVIt is just that the Task Manager is not telling you the whole truth (well, it does not tell you the truth from the perspective that you need)
p33829
aVWhen you program calls , the memory is released for reuse by the program, but it is not returned back to the operating system
p33830
aVFrom your program's point of view, the memory is freed: your next call of  will claim the same memory chunk
p33831
aVBut from the OS's (and Task Manager's) point of view, the program still holds on to the memory
p33832
aVTo see what's going on, run your allocations several times, and deallocations in a loop, and see that the total amount of memory in the Task Manager does not go up from the "high water mark" that you get after the first allocation
p33833
as(dp33834
g6
V335858
p33835
stp33836
a((dp33837
g2
(lp33838
VThe equivalent type is  - a 64-bit numeric type
p33839
aVIt fits numbers in the range from  to  - the same as
p33840
aVNET's  data type
p33841
as(dp33842
g6
V335858
p33843
stp33844
a((dp33845
g2
(lp33846
VIt is easier to use  and check if the index is not negative:
p33847
as(dp33848
g6
V335858
p33849
stp33850
a((dp33851
g2
(lp33852
VIn addition to copying in the wrong direction, you are missing a semicolon at the end of the  loop:
p33853
aVWithout the semicolon, which represents an empty statement, you execute  after copying your first character, which is, of course, incorrect
p33854
aVFinally, you can skip the check for zero in the header of the loop, like this:
p33855
as(dp33856
g6
V335858
p33857
stp33858
a((dp33859
g2
(lp33860
VThis is because you are selecting from four tables without any joins between them, and also because you are joining  twice
p33861
aVAs the result, a Cartesian product is made
p33862
aVHere is how you should fix it: re-write the theta join using the ANSI syntax, and provide proper join conditions:
p33863
aVReplace  with proper join conditions; this should make the results look as expected
p33864
as(dp33865
g6
V335858
p33866
stp33867
a((dp33868
g2
(lp33869
VYou see undefined behavior:  is probably 4 or 8 bytes, depending on the architecture, so  with zeros does not go past the forth byte
p33870
aVYou are reading from the third 32-bit word, which came from  and has not been initialized by the  yet
p33871
aVMoreover, you are allocating 12 bytes ( gets converted to ; it never makes sense to pass a  or a  to , because you cannot allocate fractional bytes) so accessing the 98-th bit goes past the allocated area
p33872
aVYou should fix these undefined behaviors: allocate enough memory by using
p33873
aVThen initialize the data to zero by using the proper size:
p33874
as(dp33875
g6
V335858
p33876
stp33877
a((dp33878
g2
(lp33879
VSince you know the type, you can replace  with , like this:
p33880
aVThis should take care of the error message
p33881
aVThe reason you see the error in the first place is that when you access a static members through an instance syntax, you are sending compiler a mixed message
p33882
aVOn one hand, you're telling it that you think that  is a member property; on the other hand, you have declared it as a  property
p33883
aVInconsistencies like this commonly happen during unsuccessful refactorings, so the compiler triggers an error to have you double-check your code
p33884
as(dp33885
g6
V335858
p33886
stp33887
a((dp33888
g2
(lp33889
VYou can use a loop, or use a LINQ:
p33890
aVThis expression gives you the first employee with the last name "Smith", or  if nobody by this last name is found on your list:
p33891
aVThis loop lets you enumerate all employees with the first name "John":
p33892
aVYou can also make a list of employees passing a given filter:
p33893
aVIf the original list contains no "Smith"s, the resulting list would be empty
p33894
aVIf you must not use LINQ, you can use a plain  loop:
p33895
as(dp33896
g6
V335858
p33897
stp33898
a((dp33899
g2
(lp33900
VYes, it is possible: observe that your target number is ten to the power of Length, minus one:
p33901
as(dp33902
g6
V335858
p33903
stp33904
a((dp33905
g2
(lp33906
VYour loop needs to go for ten iterations (one per line), not fifteen (one per word)
p33907
aVAt each iteration, you have to consider two numbers:
p33908
aVLine number, and
p33909
aVLine number plus ten
p33910
aVThe first number always gets printed; the second number gets printed along with the first only if the second number is fifteen or less:
p33911
as(dp33912
g6
V335858
p33913
stp33914
a((dp33915
g2
(lp33916
VYou can use  method, like this:
p33917
aVNote that the original string does not get changed: instead, a new instance is produced with the replacements that you requested
p33918
as(dp33919
g6
V335858
p33920
stp33921
a((dp33922
g2
(lp33923
VAbsolutely, you can: you can use  to transfer control unconditionally to the end of your method from almost anywhere, with very few restrictions
p33924
aVIf this is the method that implements your thread, it will exit, ending the thread
p33925
aVWhether you should is a different question: with very few exceptions,  makes your program less readable; without exceptions, you can achieve the same result without a , and improve readability at the same time
p33926
aVFor example, you could use  to end the method implementing the logic of your thread
p33927
as(dp33928
g6
V335858
p33929
stp33930
a((dp33931
g2
(lp33932
VThis is because  compares two values, and discards the result of that comparison
p33933
aVAlthough expression-statements like that are perfectly legal in C, they are highly unusual, and often serve as an indicator of you typing something incorrectly
p33934
aVThat's why the compiler warns you about it
p33935
aVEDIT:
p33936
aVI tried the = also, and i get this error then, incompatible types when assigning to type  from type
p33937
aVYou can't assign strings like that: you need to use , like this:
p33938
aVMake sure that  is long enough to fit the  together with its null terminator, i
p33939
ag630
aVgiven that  is , the value of the  must be 59 characters or less
p33940
as(dp33941
g6
V335858
p33942
stp33943
a((dp33944
g2
(lp33945
VI think you can get rid of the chain of s by replacing with
p33946
as(dp33947
g6
V335858
p33948
stp33949
a((dp33950
g2
(lp33951
VThe most likely cause is that you used an implicit  declaration for  in a query that has an
p33952
aVIf you replace it with
p33953
aVthe error should go away
p33954
as(dp33955
g6
V335858
p33956
stp33957
a((dp33958
g2
(lp33959
VThe result of  does not depend on the characters at the end:
p33960
aVproduces  as its result
p33961
aVMost likely this is a display issue: if you are delivering the result of the  over some sort of HTML-enabled display mechanism, the  and  would often be treated as meta-characters, and therefore require escaping
p33962
as(dp33963
g6
V335858
p33964
stp33965
a((dp33966
g2
(lp33967
VA common way of approaching this problem is building expression trees that represent your query criteria, converting them to parameterized SQL (to avoid SQL injection risks), binding parameter values to the generated SQL, and executing the resultant query against your target database
p33968
aVThe exact approach depends on your client programming framework:
p33969
aVNET has Entity Framework and LINQ2SQL that both support expression trees; Java has Hibernate and JPA, and so on
p33970
aVI have seen several different frameworks used to construct customizable queries, with great deal of success
p33971
aVIn situations when these frameworks are not available, you can roll your own, although it requires a lot more work
p33972
as(dp33973
g6
V335858
p33974
stp33975
a((dp33976
g2
(lp33977
VThe question can be re-stated in terms of finding the "point of discontinuity", i
p33978
aVe the index of the  spot in the array
p33979
aVYou can do it iteratively using an approach similar to that of a binary search, like this:
p33980
aVTake an array  and two indexes,  and , initially set to  and
p33981
aVThe spot of discontinuity is between  and
p33982
aVDivide  in half
p33983
aVCall the midpoint
p33984
aVCompare  to  and  to
p33985
aVIf only one pair is ordered correctly, adjust the endpoint: if it's the  pair that's ordered, assign , otherwise assign
p33986
aVIf both intervals are ordered, the answer is
p33987
aVThis runs in  because each step reduces the size of the problem in half
p33988
as(dp33989
g6
V335858
p33990
stp33991
a((dp33992
g2
(lp33993
VOne way is to use the Flood Fill algorithm to detect contiguous areas, like this:
p33994
aVAssuming that the initial matrix has only positive numbers,
p33995
aVPrepare a , set it to
p33996
aVFor each point in the matrix:
p33997
aVIf the cell is zero or negative, skip it; otherwise
p33998
aVFlood fill starting at the cell with the negative value of the
p33999
aVDecrement the counter after the flood fill is over
p34000
aVWhen you reach the end of your matrix,  will have the negative number equal to the number of contiguous numbered areas minus one, i
p34001
ag630
aVthe result that you need is
p34002
as(dp34003
g6
V335858
p34004
stp34005
a((dp34006
g2
(lp34007
VThis is a compile-time error, not a run-time error
p34008
aVIt happens because you are attempting to access  and  on elements of an array of type
p34009
aVIntegers are not s, they do not have fields  and , so compiler tells you it's an error
p34010
aVThe most likely fix should be changing the type of  array parameter of the  function as follows:
p34011
aVNote that since you are using the function before declaring it, you should add a prototype at the top
p34012
as(dp34013
g6
V335858
p34014
stp34015
a((dp34016
g2
(lp34017
VYou read and write too many methods over the course of your career to remember their names
p34018
aVMost programmers would need to look up a name of a function from their language's standard library, let alone names of functions that their or their team developed
p34019
aVThe most memorable function name would be of no use to someone maintaining your code and seeing the call for the first time
p34020
aVMoreover, good chances are that in six months you wouldn't remember it either
p34021
aVThat is why I recommend going for descriptive names first, and not worrying about the ease of memorization: after all, IDEs with intellisense are not going away any time soon (and they were introduced for a good reason - to address our memory limitations)
p34022
as(dp34023
g6
V335858
p34024
stp34025
a((dp34026
g2
(lp34027
VYes, you can do it relatively easily: four octal digits always convert to three hex digits, so you can split your string into groups of three hex digits, and process each group from the back
p34028
aVIf you do not have enough hex digits to complete a group of three, add leading zeros
p34029
aVEach hex digit gives you four bits; take the last three, and convert them to octal
p34030
aVAdd the next four, and take three more bits to octal
p34031
aVAdd the last group of four - now you have six bits in total, so convert them to two octal digits
p34032
aVThis avoids converting the entire number to a binary, although there will be a "sliding" binary window used in the process of converting the number
p34033
aVConsider an example: converting  to octal
p34034
aVDivide into groups of three digits:  and  (note the added zero in front of  to make a group of three digits)
p34035
aVStart from the back:
p34036
aV, or , gets chopped into  and , making octal , and  extra bit for the next step
p34037
aV, or , gets chopped into  for the next step and  for this step
p34038
aVThe  from the previous step is attached on the right of , making an octal
p34039
aV, or , gets chopped into  and
p34040
aVThe  from the previous step is attached on the right, making , or octal
p34041
aVThe  is octal , so we have  so far
p34042
aVbecomes  and  for the next step;
p34043
aVbecomes  and  for the next step;
p34044
aVbecomes  and  (because  from the previous step is added)
p34045
aVThe final result is
p34046
as(dp34047
g6
V335858
p34048
stp34049
a((dp34050
g2
(lp34051
VYou can call it like this:
p34052
aVC# compiler will figure out that you are making a  from the context of the call
p34053
as(dp34054
g6
V335858
p34055
stp34056
a((dp34057
g2
(lp34058
VYour code will try dividing by  two times, so the  will be at least three
p34059
aVYou should start your loop at  instead of , and replace  with a
p34060
aVNote that factorization is not the fastest way to determine if the number is prime
p34061
aVYou do not need to store the prime factors in order to count them
p34062
aVIn addition, once you decided that a number is composite, you can end the loop
p34063
aVFinally, you do not need to try all divisors up to : if you try divisors up to  and none of them divides , then you know with certainty that the  is prime
p34064
as(dp34065
g6
V335858
p34066
stp34067
a((dp34068
g2
(lp34069
VThe second loop has no effect:
p34070
aVThis should be a  not , or better yet, you can drop zero altogether:
p34071
aVSince you are not writing to  or , it's probably a good idea to declare them both
p34072
aVThis would have caught the assignment in the  loop above
p34073
as(dp34074
g6
V335858
p34075
stp34076
a((dp34077
g2
(lp34078
VYou should use the Strategy Design Pattern
p34079
aVGive both classes a common base with an abstract method taking the data, make a pointer to that base class, and then assign the pointer a file-based or a db-based implementation after a single check
p34080
as(dp34081
g6
V335858
p34082
stp34083
a((dp34084
g2
(lp34085
VRecall that  represents a single character,  is an anchor for the beginning of string,  is an anchor for the end of string, and  is any single character from the list between the square brackets
p34086
aVmeans "second letter is  or
p34087
aVmeans "the last character is a letter"
p34088
aVDemo on ideone
p34089
as(dp34090
g6
V335858
p34091
stp34092
a((dp34093
g2
(lp34094
VYes, you can do that: first, create a random permutation of numbers
p34095
aV, and then iterate like this:
p34096
aVLink to Fisher-Yates shuffle
p34097
as(dp34098
g6
V335858
p34099
stp34100
a((dp34101
g2
(lp34102
VIn your  method, when you detect that you are looking at two strings representing integers, make sure they are the same length before comparing them
p34103
aVIf one string is shorter, prepend leading zeros to it until the strings are of equal length
p34104
aVFor example,  and  used to not compare correctly with the default algorithm:  is greater, so  compares as being after
p34105
aVHowever, once you prepend zero, the comparison works again:  is less than
p34106
as(dp34107
g6
V335858
p34108
stp34109
a((dp34110
g2
(lp34111
VThe first one is not a comparison, it is an assignment
p34112
aVThe reason it compiles is that it assigns a boolean value, so the result of the assignment is also a boolean value
p34113
aVThe first statement assigns  a new value, and executes the  according to that new value ( in your case)
p34114
aVThe second statement compares the current value of  to the value on the right, and acts on the result of the comparison
p34115
aVNote that is it never a good idea to compare  in Java or  in C# to  or : you can use  instead of  and  instead of
p34116
aVThis, however, does not hold for nullable types in C#, so comparing  to  or  is often a good idea
p34117
as(dp34118
g6
V335858
p34119
stp34120
a((dp34121
g2
(lp34122
VBFS alone is not going to solve it for you, because you cannot move in all directions at the same time
p34123
aVIt is not a single-source shortest path problem, because once you collect the treasure, you start your path to the next one from your current spot, not from the original spot
p34124
aVThe time that it takes to collect all treasure depends on the order in which you visit the boxes with
p34125
aVSince there are only five of them, you can try all 120 orderings, compute the cost, and pick the best one
p34126
aVNote that if the order is fixed, the solution is trivial: you add up manhattan distances between the cells in order, and pick the smallest result
p34127
as(dp34128
g6
V335858
p34129
stp34130
a((dp34131
g2
(lp34132
VIf the user cannot pick anything in between 30 and 60, then the segmented control
p34133
aVis the most appropriate choice
p34134
aVIf the user can pick from a contiguous range, a slider is a better choice
p34135
aVIf the values are not contiguous, say, 30, 35, 40, 45, 50, 55, and 60, then the stepper and a label may be more appropriate, although a slider with a label would work as well
p34136
aVYou should also take into consideration the amount of real estate the controls are going to take: in general, sliders need more horizontal space than steppers and segmented controls
p34137
as(dp34138
g6
V335858
p34139
stp34140
a((dp34141
g2
(lp34142
VIt depends on what kind of memory you mean: the constant will not be replicated in the data memory, but it will become part of the code memory embedded within the compiled IL code
p34143
as(dp34144
g6
V335858
p34145
stp34146
a((dp34147
g2
(lp34148
VYou can do this:
p34149
aVwill be  unless an exception is caught
p34150
aVYou can use it to decide to call  or not
p34151
as(dp34152
g6
V335858
p34153
stp34154
a((dp34155
g2
(lp34156
VNo, there is no equivalent in Objective C
p34157
aVC++11 introduced the  keyword to do it, but neither C nor Objective C has a similar capability
p34158
aVThe  is closest to C#'s  keyword
p34159
aVIt lets you achieve similar results to , except that it does not let you access properties using the property syntax
p34160
aVIt does let you invoke methods, including methods that implement property accessors
p34161
as(dp34162
g6
V335858
p34163
stp34164
a((dp34165
g2
(lp34166
VYou can create a static constant array of ten elements, and then copy it in place with System
p34167
aVarrayCopy
p34168
aVThe remaining elements of the dest array will remain intact
p34169
as(dp34170
g6
V335858
p34171
stp34172
a((dp34173
g2
(lp34174
VYou need to make an array of indexes, fill it with numbers zero through length minus one, make a random shuffle, and go through the shuffled array to pick the index of the original array
p34175
aVYou can use Fisher-Yates Shuffle algorithm to re-arrange the indexes
p34176
as(dp34177
g6
V335858
p34178
stp34179
a((dp34180
g2
(lp34181
VThe limiting factor of a delete operation is performing the filesystem operation, not the code that connects your C# code to the OS code
p34182
aVYou will see no discernable difference between these two calls
p34183
aVSwitching to calling kernel32 directly in this API would definitely be a premature optimization
p34184
as(dp34185
g6
V335858
p34186
stp34187
a((dp34188
g2
(lp34189
VYour program makes a decision after looking at only a single character; it cannot work like that
p34190
aVWhen you see that the character is alphanumeric, you return  right away, without looking at the remaining characters
p34191
aVTo fix, move the  outside the loop
p34192
as(dp34193
g6
V335858
p34194
stp34195
a((dp34196
g2
(lp34197
VMake a random integer number in the range from  to , where  is the length of your array
p34198
aVTo make a random integer, use an instance of the  class
p34199
as(dp34200
g6
V335858
p34201
stp34202
a((dp34203
g2
(lp34204
VYou do not need header files; instead, your functions need prototypes
p34205
aVWhen you call  passing it , C figures out that you are calling a one-argument function taking , and does everything right
p34206
aVThis will not work, however, if the function takes a float, and you decide to ass it an   (try it, it is very instructive)
p34207
aVFor reasons of backward compatibility C will let you call functions without prototypes, but it is dangerous
p34208
aVFor example, in case of your call of , the compiler thinks that you are calling a function returning an
p34209
aVTechnically, you are invoking undefined behavior, so your program works by accident
p34210
aVHeaders happen to provide the most convenient way to supply prototypes, but you can supply them in the code itself, like this:
p34211
as(dp34212
g6
V335858
p34213
stp34214
a((dp34215
g2
(lp34216
VInstead of Java's s you use class methods in Objective C
p34217
aVSetting this up is more complex than in Java, but the basic idea is to define a method with a plus  instead of a minus, like this:
p34218
aVIn the header:
p34219
aVIn the
p34220
aVm file:
p34221
aVNow you can access it from anywhere, including class methods of other classes, like this:
p34222
as(dp34223
g6
V335858
p34224
stp34225
a((dp34226
g2
(lp34227
VYou can definitely do it wit a regular expression, but you can also do without it just as easily
p34228
aVLocate the initial part of the string that you would like to remove, then search for the closing  starting at the location of the
p34229
aVThis will give you the range of characters that needs to be removed
p34230
as(dp34231
g6
V335858
p34232
stp34233
a((dp34234
g2
(lp34235
VThis usually happens when the object  or one of the objects in the  do not implement the  method correctly
p34236
aVMake sure that 's class has this method
p34237
aVand the method returns  when this object is equal to , and returns  otherwise
p34238
as(dp34239
g6
V335858
p34240
stp34241
a((dp34242
g2
(lp34243
VThis is an instance of so called fluent interfaces (link to wikipedia)
p34244
aVThere is noting special about it: the value returned from the previous call is being used as the target of the subsequent call
p34245
aVAPI like this present a useful alternative to methods with lots of optional parameters, because the resulting code is much easier to read and understand
p34246
aVThe code is somewhat more verbose, but in this case it is a good thing, because the parameters passed to constructors get better "tagging"
p34247
aVThis style is also preferable when you have multiple parameters of the same type (say, strings) next to each other, because it lets the readers avoid parameter counting
p34248
as(dp34249
g6
V335858
p34250
stp34251
a((dp34252
g2
(lp34253
VUnfortunately, the only choice for unrelated structures in C is to pass pointers to the structures untyped (i
p34254
ag630
aVas ), and pass the type "on the side", like this:
p34255
aVThis approach is highly error-prone, though, because the compiler cannot do type checking for you
p34256
as(dp34257
g6
V335858
p34258
stp34259
a((dp34260
g2
(lp34261
VIn addition to the obvious "Bobby Tables" issue that your query has, the problem at hand is that you do not insert a space in front of
p34262
aVThis results in queries that look like this:
p34263
aVNote that there is no space between  and  - a syntax error
p34264
aVYou should look into parametrizing your queries, and modifying it in a way that ignores the parameters that have been set to
p34265
aVThis modification would let you keep the query the same regardless of the number of parameters that were actually set, get you the same results, taking pretty much the same time
p34266
as(dp34267
g6
V335858
p34268
stp34269
a((dp34270
g2
(lp34271
VTo avoid hard-coding something, you should:
p34272
aVSoft-code" it (i
p34273
ag630
aVmake it part of your product's configuration)
p34274
aVYou can use Configuration Settings APIs for that
p34275
aVTake it as a parameter on the command line (read the directory location from one of the s passed to the  method), or
p34276
aVMake a convention as to where it should be located, for example, in the  directory, which is a subdirectory of your current running directory (read from )
p34277
aVYou can always define a combination of these methods, for example, use the "by convention" location when the configuration / command line option has not been specified
p34278
as(dp34279
g6
V335858
p34280
stp34281
a((dp34282
g2
(lp34283
VYou can try parsing with the  that you've got, catch , and throw user-defined exception instead:
p34284
as(dp34285
g6
V335858
p34286
stp34287
a((dp34288
g2
(lp34289
VAre we wasting bits of memory
p34290
aVNo, because you can't get a variable smaller than a : it's always a single byte
p34291
aVYou can pack multiple bits representing boolean flags in a single word, but you have to do it manually - with bit shifts, using bit fields, and so on
p34292
aVDoes this provide a way to return valuable data in a function
p34293
aVNot really: what you did is a hack, although  would definitely make its way through the system to the caller, and would be interpreted as  in a "plain"  statement, e
p34294
ag303
aVHowever, it would fail miserably if used like this:
p34295
aVWould it be correct to use it as a way to return a different values when some unexpected behavior occurs
p34296
aVIt would always be incorrect from the readability point of view; as far as "doing what you meant it to do", your mileage may vary, depending on the way in which your function is used
p34297
as(dp34298
g6
V335858
p34299
stp34300
a((dp34301
g2
(lp34302
VStarting with
p34303
aVNET 2
p34304
aV0 you can use  to implement your priority queue
p34305
aVIt's  property returns an ordered collection
p34306
aVYou can extract its first item to get the key of the entry representing your "next best" edge
p34307
aVThe  needs to be a , where  is the element that you store in your Dijkstra's queue
p34308
as(dp34309
g6
V335858
p34310
stp34311
a((dp34312
g2
(lp34313
VI think the above declaration will be causing memory leak ultimately(or will it
p34314
aVNo, it wouldn't:  is an automatic (AKA "Stack") variable, it will get "deallocated" as soon as it goes out of scope (i
p34315
ag630
aVafter the closing brace)
p34316
aVIs there any better approach without allocating and freeing after every iteration
p34317
aVThere is no actual allocation or deallocation going on: the space in the automatic memory (AKA "on the stack") is allocated by some compile-time bookkeeping around the stack pointer
p34318
aVThe access of automatic variables is a very fast operation heavily assisted by hardware, so there is no loss of efficiency there
p34319
aVDynamic memory allocation (Java-style) is done with // in C
p34320
aVThese are not garbage collected - you need to explicitly  every pointer that you allocated
p34321
as(dp34322
g6
V335858
p34323
stp34324
a((dp34325
g2
(lp34326
VYou can check that  equals , unless of course it is additionally modified inside the loop:
p34327
as(dp34328
g6
V335858
p34329
stp34330
a((dp34331
g2
(lp34332
VYou almost got it right: you are calculating the length that you pass to  incorrectly
p34333
aVYou need to take the position of space into account
p34334
aVInstead of
p34335
aVthe length should be
p34336
aVThe overall expression should look like this:
p34337
aVLink to demo on sqlfiddle
p34338
as(dp34339
g6
V335858
p34340
stp34341
a((dp34342
g2
(lp34343
VNo, it does not evaluate the expression after learning that the answer is going to be
p34344
aVThis is called short-circuiting, and it is an essential part of evaluating boolean expressions in C, C++, Objective C, and other languages with similar syntax
p34345
aVThe conditions are evaluated left to right, making the evaluation scheme predictable
p34346
aVThe same rule applies to the  operator: as soon as the code knows that the value is , the evaluation stops
p34347
aVShort-circuiting lets you guard against invalid evaluation in a single composite expression, rather than opting for an  statement
p34348
aVFor example,
p34349
aVwould have resulted in undefined behavior if it were not for short-circuiting
p34350
aVBut since the evaluation skips evaluation of  when  is invalid, the above expression is legal
p34351
as(dp34352
g6
V335858
p34353
stp34354
a((dp34355
g2
(lp34356
VThis is most likely a call of a function pointed to by a function pointer
p34357
aVA more conventional syntax for it is as follows:
p34358
aVpoints to a function that takes three arguments
p34359
aVThe invocation expression dereferences the pointer, and passes the three arguments to the function the pointer points to
p34360
aVAn alternative could be that  is a pointer to an object that defines an override for a three-argument operator
p34361
aVTo know which one it is you need to supply more context
p34362
as(dp34363
g6
V335858
p34364
stp34365
a((dp34366
g2
(lp34367
VSince arrays decay to pointers, you cannot perform length calculation in a function: the function gets a pointer, not an array
p34368
aVYou need to do the computations inline the way your function does when it prints , or use a macro to compute array length:
p34369
aVHere is a link to a demo on ideone
p34370
as(dp34371
g6
V335858
p34372
stp34373
a((dp34374
g2
(lp34375
VThere is no  function on "plain" C-style arrays
p34376
aVYou need to use  if you want to use , or calculate size through
p34377
aVIn C++11 you can use array initialization syntax to initialize your vectors, like this:
p34378
aVEverything else stays the same (see demo here)
p34379
as(dp34380
g6
V335858
p34381
stp34382
a((dp34383
g2
(lp34384
VThe most likely reason why this happens is because one or more items in the  is
p34385
aVCheck  for , or see why prices contain s in the first place, assuming it's not supposed to have any  values
p34386
as(dp34387
g6
V335858
p34388
stp34389
a((dp34390
g2
(lp34391
VYou can make a wrapper class exposing the properties that you need, and wrapping instances of the actual  and  classes
p34392
aVOne way of doing it would be through delegates:
p34393
aVNow you can do something like this:
p34394
aVAt this point,  and  are both implementing the common  interface, so you can use them without checking their type
p34395
aVTo get fancy, replace the seven-argument constructor with a constructor that takes a single  parameter, obtain its class via reflection, check its properties for the custom attributes that you defined, and create/compile LINQ expressions corresponding to the getters and the setters of the properties , , and
p34396
aVThis would let you construct your  without the ugly lambdas trailing in the call
p34397
aVThe tradeoff here is that now the lambdas would be constructed at run time, so would-be compile errors on missing properties would become run-time exceptions
p34398
as(dp34399
g6
V335858
p34400
stp34401
a((dp34402
g2
(lp34403
VWhy is this not a classifying inheritance
p34404
aVIn general, inheritance provides a natural classification mechanism for kinds of objects, allowing the commonality of objects to be explicitly modeled
p34405
aVWhen class  inherits class  publicly, the relationship between the classes becomes
p34406
aVThis establishes a classification: "all s are s"
p34407
aVHowever, when the inheritance is private or protected,  does not become a , thus failing to establish an additional classification over
p34408
aVEssentially, private or protected inheritance can be thought of as a detail of implementation, not a detail of interface
p34409
as(dp34410
g6
V335858
p34411
stp34412
a((dp34413
g2
(lp34414
VSomeone who commented on the accepted answer claims that one cannot use a simple bool variable as a signal, the code was broken without a memory barrier and using std::atomic would be correct
p34415
aVThe commenter is right: a simple  is insufficient, because non-atomic writes from the thread that sets  to  can be re-ordered
p34416
aVConsider a thread that sets a static variable  to some very important number, and then signals its exit, like this:
p34417
aVWhen your main thread sees  set to , it assumes that the worker thread has finished
p34418
aVHowever, when your main thread examines , it may find it set to a wrong number, because the two writes above have been re-ordered
p34419
aVOf course this is only a simplified example to illustrate the general problem
p34420
aVUsing  for your  variable adds a memory barrier, making sure that all writes before it are done
p34421
aVThis fixes the potential problem of out-of-order writes
p34422
aVAnother issue is that reads to non-volatile variables can be optimized out, so the main thread would never notice the change in the  flag
p34423
aVImportant note: making your  volatile is not going to fix the problem; in fact, volatile should not be used in conjunction with threading - it is intended for working with memory-mapped hardware
p34424
as(dp34425
g6
V335858
p34426
stp34427
a((dp34428
g2
(lp34429
VYou cannot store  values in *, so the answer is "no"
p34430
aVYou need to iterate the array yourself, keeping track of whether you need to add a comma or not
p34431
aV*  values in NS collections are represented with  objects
p34432
as(dp34433
g6
V335858
p34434
stp34435
a((dp34436
g2
(lp34437
VYou are creating a regular non-mutable
p34438
aVYour code should be
p34439
aVObjective C is very dynamic, so it does not catch this mistake at compile time
p34440
as(dp34441
g6
V335858
p34442
stp34443
a((dp34444
g2
(lp34445
VIf reading from lists happens concurrently with writing, constructing a  object for each dictionary entry would be an optimal solution, because multiple readers would be able to proceed concurrently on the same list
p34446
aVIt is only marginally harder than using , and it has a potential of improving performance in cases when a small number of lists is read more often than other lists
p34447
aVIf you go the  route, it is a good idea to wrap the list and a lock in a single class, rather than creating a separate dictionary just for the reader writer locks:
p34448
aVCombining the list and the look would let you look up the dictionary entry once, lock it for reading or for writing as appropriate, and do the work with the associated list
p34449
as(dp34450
g6
V335858
p34451
stp34452
a((dp34453
g2
(lp34454
VThe only danger of forward-declaring something is when you do the forward declaration outside of a header or in a non-shared header, and the signature of the forward declaration differs from the actual signature of whatever being forward-declared
p34455
aVIf you do it in , there would be no name mangling to check the signature at link time, so you may end up with undefined behavior when the signatures do not match
p34456
as(dp34457
g6
V335858
p34458
stp34459
a((dp34460
g2
(lp34461
VThe  on your platform is probably 32 bit
p34462
aVYou may need to use  instead:
p34463
aVThis will fix the warning, but the result of the expression may not necessarily fit in an  (see this answer for details and references to the relevant standard documents)
p34464
as(dp34465
g6
V335858
p34466
stp34467
a((dp34468
g2
(lp34469
VMost modern hardware has built-in instructions for checking the less-than-or-equals consition in a single instruction that executes exactly as fast as the one checking the less-than condition
p34470
aVThe argument that applied to the (much) older hardware no longer applies - choose the alternative that you think is most readable, i
p34471
ag630
aVthe one that better conveys your idea to the readers of your code
p34472
as(dp34473
g6
V335858
p34474
stp34475
a((dp34476
g2
(lp34477
VIt is very hard to do it reliably, but you can try something like this:
p34478
aVThe above regex matches anything that ends in  or , and uses a capturing group in the  to surround it with the  markup
p34479
aVHere is a quick demo on ideone
p34480
aVThe output looks like this:
p34481
as(dp34482
g6
V335858
p34483
stp34484
a((dp34485
g2
(lp34486
VYes, copying local variables into -ed regions of memory works well
p34487
aVYou can replace the loop with a call of  to reduce the code size
p34488
aVWrite
p34489
aVinstead of
p34490
as(dp34491
g6
V335858
p34492
stp34493
a((dp34494
g2
(lp34495
VThis is a valid query - it produces a cartesian product of the two tables
p34496
aVIt is equivalent to this query in the ANSI SQL syntax:
p34497
aVThe usefulness of this query is highly debatable, though
p34498
aVHere is a demo on SQLFiddle
p34499
as(dp34500
g6
V335858
p34501
stp34502
a((dp34503
g2
(lp34504
VYou can use  to parse an integer in base 2:
p34505
aVHere is a link to a demo on ideone
p34506
as(dp34507
g6
V335858
p34508
stp34509
a((dp34510
g2
(lp34511
VEven when I change the name of the variable the memory location (which is what I assume this is) doesn't change
p34512
aVNames of things are compile-time artifacts
p34513
aVOnce the compiler is done, it does not matter whether the variable has been called , , or 1
p34514
aVWhat can I change in the code I have to change the memory location that andy is at
p34515
aVAdd more variables in front of it
p34516
aVThis is not guaranteed to work, because the system can place your variable at any logical address, but it has a decent chance of making your variable move
p34517
aVHowever, I got an error when I tried to run this code ([derefefencing a fixed address])
p34518
aVYou need to cast  to a pointer, like this: ((int*)0x28ff18)
p34519
aVThis will compile, but it may not work
p34520
aVIn general, hard-coding fixed addresses is dangerous except when you are accessing memory-mapped hardware through registers placed at fixed addresses
p34521
aV1 Except for debugging
p34522
aVEven then it's you who cares most about the name of that variable
p34523
as(dp34524
g6
V335858
p34525
stp34526
a((dp34527
g2
(lp34528
VYou need to add parentheses to force the order of evaluation that you need:
p34529
aVSince  has higher precedence than , the expression without the parentheses was true when  was true, or  was in the  list specified by the subquery
p34530
as(dp34531
g6
V335858
p34532
stp34533
a((dp34534
g2
(lp34535
VThis construct has been popularized by Kernighan and Ritchie in their C Programming Language book (section 3
p34536
aV5)
p34537
aVThe for statement
p34538
aVIf expr1 or expr3 is omitted, it is simply dropped from the expansion
p34539
aVIf the test, expr2, is not present, it is taken as permanently true, so
p34540
aVis an "infinite" loop, presumably to be broken by other means, such as a  or
p34541
aVThere is absolutely no difference between  and
p34542
as(dp34543
g6
V335858
p34544
stp34545
a((dp34546
g2
(lp34547
VThis is because in your  branch you are not setting the
p34548
aVWhen a cell gets recycled, the old detailTextLabel stays there
p34549
aVYou need to set all properties of the cell in both branches of the conditionsl, on the chance that it has been recycled
p34550
as(dp34551
g6
V335858
p34552
stp34553
a((dp34554
g2
(lp34555
VSetting the accessory view needs to happen inside the  method
p34556
aVWhen you want to change the accessories from outside, the outside method needs to change the model first to indicate that check marks must be placed in certain cells, and then call  on the
p34557
aVOne way to store what cells are checked is an array of  objects - one index set per section
p34558
aVIn the example below I show code for a single section, but you should get an idea of how to make multiple sections work
p34559
aVNow in the code where you want to set rows selected or unselected you just need to call  or , and call your table's
p34560
as(dp34561
g6
V335858
p34562
stp34563
a((dp34564
g2
(lp34565
VThe  method is an initializer of  classes, not  classes
p34566
aVOn the other hand,  is a  class, so Xcode correctly tells you that  lacks the  method
p34567
aVMoreover, you cannot push views onto the navigation controller's stack
p34568
aVYou need to replace  with the type of the controller of the  nib to make it work
p34569
as(dp34570
g6
V335858
p34571
stp34572
a((dp34573
g2
(lp34574
VYes, you can use :
p34575
aVThe regular expression matches a single digit
p34576
aVreplaces each occurrence of it in the  string with an empty string
p34577
as(dp34578
g6
V335858
p34579
stp34580
a((dp34581
g2
(lp34582
VYou should double the backslashes in front of your s, like this:
p34583
aVBackslash is a special character inside a string literal: the character after it is interpreted differently
p34584
aVIn order for the regex engine to see a backslash, you need two slashes in the literal
p34585
as(dp34586
g6
V335858
p34587
stp34588
a((dp34589
g2
(lp34590
VThere is no memory leak, there is undefined behavior
p34591
aVYou are deallocating the memory that has not been allocated, causing a problem
p34592
aVYou need to call  only on memory that has been allocated with , , or
p34593
aVCalling  on any other memory location is undefined behavior
p34594
aVIn your case,  is allocated in the automatic memory (otherwise known as "the stack")
p34595
aVThis memory gets deallocated automatically as soon as it goes out of scope
p34596
aVThere are two ways to fix your program:
p34597
aVReplace  with , or
p34598
aVRemove
p34599
as(dp34600
g6
V335858
p34601
stp34602
a((dp34603
g2
(lp34604
VAssuming that by relative index you mean a pointer inside the array, you can get its offset using pointer arithmetic:
p34605
aVThe compiler deals with dividing out the  the array element for you, so the result of the subtraction does not change if your array elements are doubles, chars, structs, or anything else
p34606
aVThe pointer types of  and  need to match, though
p34607
as(dp34608
g6
V335858
p34609
stp34610
a((dp34611
g2
(lp34612
VThe reason this does not work is that you are dropping the results of  and
p34613
aVYou need to assign the results back to the string passed into your function:
p34614
aVNote that in order for this to work the  must be modifiable, meaning that a call  would be undefined behavior
p34615
as(dp34616
g6
V335858
p34617
stp34618
a((dp34619
g2
(lp34620
VThe linker error tells you that your code is missing definitions of two member functions that you declared - the constructor and the destructor:
p34621
as(dp34622
g6
V335858
p34623
stp34624
a((dp34625
g2
(lp34626
VNot every set of items can be tweaked to be used in non-comparison sorts in an efficient way
p34627
aVFor example, sorting arbitrary precision numbers would require running the loop inside the bucket sort many times, killing the performance
p34628
aVThe problem with radix sorts of the world is that they must examine every element of every item being sorted
p34629
aVComparison-based sorts, on the other hand, can skip a fair number of sub-elements (digits, characters, etc
p34630
aVFor example, when a comparison function checks two strings, it stops at the first difference, skipping the tails of both strings
p34631
aVBucket sort, on the other hand, must examine all characters in every string*
p34632
aVIn general, chasing the best asymptotic complexity is not always a good strategy: the value of N where using a significantly more complex algorithm pays off is often too high to make the more complex algorithms practical
p34633
aVFor example, quicksort has very bad worse time complexity, yet on average it beats most other algorithms hands down due to its very low overhead, making it a good choice in most practical situations
p34634
aV* In practice implementations of bucket sort avoid the need to look at all sub-elements (digits, characters, etc
p34635
aVby switching to a comparison-based sort as soon as the number of items in a bucket drops below a certain threshold
p34636
aVThis hybrid approach beats both a plain comparison-based sort and a plain bucket sort
p34637
as(dp34638
g6
V335858
p34639
stp34640
a((dp34641
g2
(lp34642
Vwill the proper update function (the one implemented in myObject) be called
p34643
aVYes, it will be called
p34644
aVis it valid to have 2 pure virtual functions with the same name in one "family"
p34645
aVThe second declaration (i
p34646
ag630
aVinside the  class) does not introduce a second pure virtual function into the family: the signatures are identical, so  is a single virtual function
p34647
aVMoreover, declaring it for the second time is not necessary:  would remain abstract, and would have access to the  method even if you removed the second declaration
p34648
as(dp34649
g6
V335858
p34650
stp34651
a((dp34652
g2
(lp34653
VThis is because parentheses in Lua's patterns (quite unfortunately) do not serve as a grouping construct, only as a delimiters of capturing groups
p34654
aVWhen you write a pattern , Lua interprets it as "match ,,,,,,, capture  in a group"
p34655
aVHere is a link to a demo
p34656
aVUnfortunately, the closest you can get to the behavior that you wanted is  , which of course would also match  and , among other wrong captures
p34657
aVthis code
p34658
aVreturns 1 3
p34659
as(dp34660
g6
V335858
p34661
stp34662
a((dp34663
g2
(lp34664
VWhy am I able to free that deleteMe and that gets reflected outside the DeleteElement function
p34665
aVThe only way that the freeing "reflects outside the  function" is that the memory pointed to by the pointer becomes illegal to access
p34666
aVYour function is incorrect, you need to traverse and modify the list in addition to deleting the element itself
p34667
aVThe need to modify the list is the reason behind passing  by pointer to pointer
p34668
as(dp34669
g6
V335858
p34670
stp34671
a((dp34672
g2
(lp34673
VYes, you can do it: all you need to do is overriding :
p34674
aVThis works because  calls  on objects being printed
p34675
as(dp34676
g6
V335858
p34677
stp34678
a((dp34679
g2
(lp34680
VIf your strings are ASCII, you can do it using a counting-sort style algorithm
p34681
aVMake an array of 256 counters, go through the string, and increment a counter for each character's code that you find in the string
p34682
aVNow walk the array from zero, accumulating the counts that you've seen so far
p34683
aVWhen adding a counter for character  causes your accumulated result cross over , you know that  is the -th character if the string were sorted
p34684
aVThis algorithm is , where  is the number of characters in your string
p34685
aVThis is the time that it takes to build the array of counts
p34686
as(dp34687
g6
V335858
p34688
stp34689
a((dp34690
g2
(lp34691
VYes - you should be able to do it using the lambda syntax:
p34692
as(dp34693
g6
V335858
p34694
stp34695
a((dp34696
g2
(lp34697
VYou have several choices here:
p34698
aVMake sure the class of the group object implements GetHashCode and Equals
p34699
aVImplementing these could be as simple as comparing ids inside the groups
p34700
aVGroup by id, and get the group name grom the group of the first user in the grouping
p34701
aVAll grouped users belong to the same group, so the name will be the same
p34702
aVIf you have no access to the source of your group class, group by a wrapper that implements GetHashCode and Equals based on the id of the group that it wraps
p34703
as(dp34704
g6
V335858
p34705
stp34706
a((dp34707
g2
(lp34708
VAssuming that  is stored as a  wrapped in *, you can use this code:
p34709
aV* You wrap a  in  by calling
p34710
as(dp34711
g6
V335858
p34712
stp34713
a((dp34714
g2
(lp34715
VMy xcode ersion is 4
p34716
ag839
aVSupport for the new array literals is not available until Xcode 4
p34717
ag14885
aVYou need to use the equivalent old syntax:
p34718
as(dp34719
g6
V335858
p34720
stp34721
a((dp34722
g2
(lp34723
V needs a comparator on  in order to arrange the elements inside it
p34724
aVYou can cerate a  with a custom comparator that "understands" how to compare s
p34725
aVThis will let the outer tree set decide on the order of the tree sets that you put inside it:
p34726
as(dp34727
g6
V335858
p34728
stp34729
a((dp34730
g2
(lp34731
VAdd a  property of type  to your view controller, and set it in each  method of source view controllers:
p34732
aVIn your destination controller:
p34733
aVIn each  method:
p34734
aVWith this code in place you can examine the  property inside the destination view controller to learn from which segue the controller has opened
p34735
as(dp34736
g6
V335858
p34737
stp34738
a((dp34739
g2
(lp34740
VIf you do not use the class outside a single CPP file, you do not need a header
p34741
aVOtherwise, you can avoid writing a header file at your own risk: the potential losses (inconsistent re-declarations of the base class) far outweigh the potential wins (speeding up the compile time)
p34742
aVThe readability of the overall project is going to suffer as well - other readers of your project will expect to see a header there, and would be surprised to see multiple copies in different files
p34743
as(dp34744
g6
V335858
p34745
stp34746
a((dp34747
g2
(lp34748
VYou can apply this regular expression to each line that you read from the file:
p34749
aVThe regular expression  matches any number of digits at the beginning of the line
p34750
aVmethod replaces the match with an empty string
p34751
as(dp34752
g6
V335858
p34753
stp34754
a((dp34755
g2
(lp34756
VThis snippet will work correctly with both positive and negative numbers:
p34757
as(dp34758
g6
V335858
p34759
stp34760
a((dp34761
g2
(lp34762
VThere is no noticeable performance difference between the two, because rendering of cells is dominated by drawing, not obtaining a class name
p34763
aVYour second code snippet survives refactoring better, so you should continue using it
p34764
as(dp34765
g6
V335858
p34766
stp34767
a((dp34768
g2
(lp34769
VThe bad news is that it cannot be done in C, because C variables are a compile-time concept
p34770
aVVariables serve as "labels" for memory regions containing the data; once the compiler is done, the names of most variables are thrown away
p34771
aVThey may be written to a separate file for the debugger, but that's a convenience for humans
p34772
aVThe good news is that you do not need a new variable to be named a new name
p34773
aVAll you need is a second variable containing a name
p34774
aVA pair of variables - one for the  and one for the  is all you need
p34775
as(dp34776
g6
V335858
p34777
stp34778
a((dp34779
g2
(lp34780
VYou can call  on :
p34781
as(dp34782
g6
V335858
p34783
stp34784
a((dp34785
g2
(lp34786
VCreate  that holds a reference to the superset array, and decides the relative order of strings by comparing the results of calling  on both strings
p34787
aVCall  passing an instance of  to get the desired ordering
p34788
as(dp34789
g6
V335858
p34790
stp34791
a((dp34792
g2
(lp34793
VStarting with
p34794
aVNET 4
p34795
aV0, you can do it using LINQ's  method, like this:
p34796
aV[Zip] method merges each element of the first sequence with an element that has the same index in the second sequence
p34797
as(dp34798
g6
V335858
p34799
stp34800
a((dp34801
g2
(lp34802
VThe  inside character literals and string literals stands for the character with the code zero
p34803
aVThe meaning in C and in Objective C is identical
p34804
aVTo illustrate, you can use  in an array initializer to construct an array equivalent to a null-terminated string:
p34805
aVIn general, you can use  to represent an ASCII character in octal notation, where s stand for up to three octal digits
p34806
as(dp34807
g6
V335858
p34808
stp34809
a((dp34810
g2
(lp34811
VThe decision is up to the compiler: since the automatic variables go out of scope before the next one comes in scope, the compiler can re-use their memory
p34812
aVKeep in mind that "stack" variables are actually variables with automatic storage duration according to the C++ specification, so they may not be on the stack at all
p34813
as(dp34814
g6
V335858
p34815
stp34816
a((dp34817
g2
(lp34818
VIf using the boost library is an option, I would highly recommend using :
p34819
as(dp34820
g6
V335858
p34821
stp34822
a((dp34823
g2
(lp34824
VYou are not overlooking anything: the conditional subtraction at the end of  is a "poor man's modulo" operation
p34825
aVIt works for numbers not exceeding 2x the divisor; the "real" modulo can be implemented by repeated subtraction
p34826
aVAn easier way to get the remaining size is as follows:
p34827
aVIt uses the modulo operator, and avoids conditional execution
p34828
ag1971
ag1972
aVYour implementation can be simplified, too: observe that on the last line  is negative, so -d`
p34829
aVTherefore, you can write
p34830
as(dp34831
g6
V335858
p34832
stp34833
a((dp34834
g2
(lp34835
VYou can simplify the code by removing conditional:
p34836
as(dp34837
g6
V335858
p34838
stp34839
a((dp34840
g2
(lp34841
VThe only reason this could be of help is if you are making a shallow copy: copying would save you the costs of creating new objects
p34842
aVThe flip side of it is that all  objects inside the array would be shared among multiple 2D arrays; if this presents a problem, you should go back to creating arrays from scratch
p34843
as(dp34844
g6
V335858
p34845
stp34846
a((dp34847
g2
(lp34848
VYour code snippet is incorrect: invoking a static method does not require
p34849
as(dp34850
g6
V335858
p34851
stp34852
a((dp34853
g2
(lp34854
VYour guess is right, the second query is likely to be more efficient, because it would parse a GUID once rather than converting a GUID in each row to a string
p34855
aVThe query provider may optimize this, but it does not have to; it is also possible that your query provider would choose to convert GUIDs to strings for comparison, but that would be a rather unfortunate choice
p34856
aVYou are also correct in assuming that it would not matter unless there is a significant number of  objects in the table
p34857
aVThere is one significant difference going in favor of the second query: the  method may not be recognized by the query provider, so your first query would not even execute due to a run-time error
p34858
as(dp34859
g6
V335858
p34860
stp34861
a((dp34862
g2
(lp34863
VWhen you set  to , you copy the reference
p34864
aVThe two variables reference the same object, but they do not become the same variable
p34865
aVSetting  to  does not change  - it references the same  object, so there is no  when you access its  method
p34866
as(dp34867
g6
V335858
p34868
stp34869
a((dp34870
g2
(lp34871
VIf  represents 8 bytes of the 64-bit integer, go through the array of 8-bit integers, and shift them into the result left-to-right:
p34872
aVThe direction of the loop depends on the order in which the bytes of the original  are stored in the  array
p34873
aVThe above snippet shows the MSB-to-LSB order; if the array is LSB-to-MSB, start the loop at 7, and go down to zero
p34874
aVIf the bytes represent individual bits, shift by one rather than eight
p34875
as(dp34876
g6
V335858
p34877
stp34878
a((dp34879
g2
(lp34880
VThis is because 's constructor that takes a  expects ticks, not seconds
p34881
as(dp34882
g6
V335858
p34883
stp34884
a((dp34885
g2
(lp34886
VThis is because you created a button without specifying what selector to call when the button is clicked
p34887
aVAdding this line to your  method will fix the problem:
p34888
aVWhen you try doing the same through the synthesized  property, the code does not work, because you never set
p34889
aVWhen you pass it to the  function, the value gets ignored (you re-assign it right away)
p34890
aVThe assignment never changes the value of , though, because Objective C passes parameters by value
p34891
aVAn alternative way to fix your code is to pass a pointer to , rather than  itself, like this:
p34892
aVI would recommend against this way of fixing your code: using  directly inside  would probably be a better choice
p34893
as(dp34894
g6
V335858
p34895
stp34896
a((dp34897
g2
(lp34898
VBuffered output is the output that your program has already produced, but has not forwarded to its intended destination yet
p34899
aVBuffering is used a lot with I/O operations to avoid the cost of sending/writing the data in small increments: rather than passing the output to its destination as you write, the system collects larger chunks of it in a memory area called "the buffer", and sends/writes the data only when a certain size is reached
p34900
aVThere are two ways a buffered data makes it to its destination:
p34901
aVThe amount of output reaches a certain threshold, or
p34902
aVYou invoke some method to "flush" the buffer explicitly
p34903
aVis one such method: it empties the buffer by sending everything that you have written so far to the client
p34904
as(dp34905
g6
V335858
p34906
stp34907
a((dp34908
g2
(lp34909
VYes, this is correct: the outer loop is , the other two are  each, for the total of
p34910
aVIn the simple cases, yes
p34911
aVIn more complex cases, when loop indexes start at numbers indicated by other indexes, the calculations are more complex
p34912
as(dp34913
g6
V335858
p34914
stp34915
a((dp34916
g2
(lp34917
VYou can use  method of the list to do the check
p34918
aVHowever, this is a linear operation
p34919
aVIf the list is large, you should convert it to  first, and then perform :
p34920
aVIf the length of  is  and the length of two is , this solution has time complexity of ; the "plain"  has the complexity of , which may be significantly worse
p34921
as(dp34922
g6
V335858
p34923
stp34924
a((dp34925
g2
(lp34926
VIf it is OK to make the switch at compile time, a simple  would do:
p34927
aVUse  in your code, and set  if you want  at compile time:
p34928
as(dp34929
g6
V335858
p34930
stp34931
a((dp34932
g2
(lp34933
VAll changes to the visuals of your cells should happen inside your
p34934
aVYou should not do it in the event handler of your gesture recognizer (or anywhere else outside the , for that matter)
p34935
aVThe gesture recognizer needs to alter the model behind your table view, so that your tableView:cellForRowAtIndexPath could make a decision to set the image to  or  the next time the data is reloaded, and also deal with the background changes
p34936
aVThen your gesture recognizer should tell the table view to reload the data
p34937
aVYour current solution operates on cells returned by
p34938
aVWhen you change the visuals from the outside, the table view shows the change while the cell is on screen
p34939
aVHowever, when the cell scrolls off the screen, it gets recycled, meaning that the next time you dequeue a cell with cell identifier you may get an object that used to display as a different cell
p34940
as(dp34941
g6
V335858
p34942
stp34943
a((dp34944
g2
(lp34945
VHash maps store items in "buckets" based on the hash code of the key
p34946
aVThe "plain"  returns entries as it finds them in its "hash buckets"
p34947
aVThere is no discernable pattern to it, and even if you find it, it would be heavily dependent on implementation and unreliable
p34948
aVIf you need a reliable order of iteration, use either a  (you'll get entries sorted by key) or  (you'll get insertion order)
p34949
aVNote that the  has a different mechanism of deciding the equality of its keys, so you would either make the keys comparable, or provide a comparator on the side to deal with the key ordering
p34950
as(dp34951
g6
V335858
p34952
stp34953
a((dp34954
g2
(lp34955
VThis is most likely an issue with the precision of DB's  column: it does not have enough accuracy to store the time up to a millisecond
p34956
aVWhen you use , the time portion is rounded to increments of
p34957
aV000,
p34958
aV003, or
p34959
aV007 seconds
p34960
aVSwitching column's type to  should help, because its resolution is 100 nanoseconds
p34961
as(dp34962
g6
V335858
p34963
stp34964
a((dp34965
g2
(lp34966
VYou misunderstood the meaning of
p34967
aVWhen you ask for , you
p34968
aVGet a value indicating whether the DataSet has [your] changes, including new, deleted, or modified rows
p34969
aVWhen you read from the DB, your data set is unchanged from the DB's perspective: it has exactly what's in the database, i
p34970
ag630
aVit is "clean"
p34971
aVWhen you add, change, or remove data in the data set, the data set gets "dirty", so  starts returning
p34972
as(dp34973
g6
V335858
p34974
stp34975
a((dp34976
g2
(lp34977
VIt is hard to say for us what you are missing, but you can easily find out yourself: go to the header file for your , and examine the methods declared by the class
p34978
aVFor each method that you declare in the header there must be a method implemented in the
p34979
aVm file
p34980
aVOtherwise, you get an "incomplete implementation" warning
p34981
aVNote that the methods of protocols that you adopt count as well: if the declaration has a list of protocol names (inside the
p34982
aVbrackets after the name of the class in the header), all required methods from these protocols must be implemented as well in order to avoid the warning
p34983
as(dp34984
g6
V335858
p34985
stp34986
a((dp34987
g2
(lp34988
V and , of course
p34989
aVwill short-circuit if the first operand is , so the second operand may not be evaluated
p34990
aVwill short-circuit if the first operand is , so the second operand may not be evaluated
p34991
aVevaluates only the alternative that corresponds to the value of the expression before ; the other one is not evaluated
p34992
aVBoth  and , on the other hand, must have both operands in order to compute their results - i
p34993
ag630
aVthe sum or the division remainder
p34994
as(dp34995
g6
V335858
p34996
stp34997
a((dp34998
g2
(lp34999
VYour teacher has been reading some really old books
p35000
aVIt used to be the case with some architectures lacking the  instruction that evaluating  required fewer machine cycles than , but these platforms are rare these days
p35001
aVI suggest going for readability, and using
p35002
as(dp35003
g6
V335858
p35004
stp35005
a((dp35006
g2
(lp35007
VThis is because you copy the value returned by reference into a regular variable: when you store  in an , it is no longer a reference
p35008
aVWhat you should do instead is
p35009
aVNote that the local  needs not be : reference to static data can be stored in automatic variables without a problem
p35010
as(dp35011
g6
V335858
p35012
stp35013
a((dp35014
g2
(lp35015
VIf your character set is reasonably limited, you can use character codes as indexes into an array of counts
p35016
aVLet's say you have 16-bit characters
p35017
aVYou can do this:
p35018
aVWith the array of  in hand, you can easily find the frequency by looking up a code from the  in the  array
p35019
aVThis solution is asymptotically as fast as it could possibly get, but it may not be the most memory-efficient one
p35020
as(dp35021
g6
V335858
p35022
stp35023
a((dp35024
g2
(lp35025
VYou can do it with , like this:
p35026
aVHere is a demo on sqlfiddle
p35027
as(dp35028
g6
V335858
p35029
stp35030
a((dp35031
g2
(lp35032
VYou need to omit the : adjacent string literals get concatenated automatically, so this macro is going to concatenate the strings the way you want:
p35033
aVFor two strings:
p35034
aVHere is a link to a demo on ideone
p35035
as(dp35036
g6
V335858
p35037
stp35038
a((dp35039
g2
(lp35040
VThe problem with 's methods in the  class, including its indexer, is that their explicit implementations are added to  objects of the class at run time:
p35041
aVStarting with the
p35042
aVNET Framework 2
p35043
aV0, the  class implements the , , and  generic interfaces
p35044
aVThe implementations are provided to arrays at run time, and therefore are not visible to the documentation build tools
p35045
aVAs a result, the generic interfaces do not appear in the declaration syntax for the  class, and there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations)
p35046
aVWhen classes implement interfaces explicitly, accessing interface methods requires a cast:
p35047
aVA class that implements an interface can explicitly implement a member of that interface
p35048
aVWhen a member is explicitly implemented, it cannot be accessed through a class instance, but only through an instance of the interface
p35049
aVThe problem with providing a "regular" (as opposed to an "explicit") interface implementation is the fact that the  class is not generic: without a type parameter, you cannot write
p35050
aVsimply because  is undefined
p35051
aVThe environment cannot slap an interface implementation onto the  class until the type of the  parameter becomes known, which may happen only at run time:
p35052
aVAt the same time, the static type of , , and  remains the same - it's
p35053
aVHowever, at run time  will be implementing ,  will be implementing , and  -
p35054
aVNone of it is known at compile time, prevents the compiler from "seeing" the indexer and other methods of
p35055
aVMoreover, not all instances of  implement  - only arrays with a single dimension do:
p35056
aVAll of the above prevents the compiler from accessing  methods, including the indexer, without an explicit cast
p35057
as(dp35058
g6
V335858
p35059
stp35060
a((dp35061
g2
(lp35062
VYour syntax for implementing template functions outside of template body is incorrect
p35063
aVIt should be like this:
p35064
aVYou are also missing a definition of the destructor for :
p35065
aVLink to ideone
p35066
as(dp35067
g6
V335858
p35068
stp35069
a((dp35070
g2
(lp35071
VYou cannot "address" local variables by name (reflection can help you with member member variables, but not with locals)
p35072
aVYou need an associative container for addressing items using a string name - for example, a
p35073
aVAdd pairs , and so on to a , and then use  to retrieve the value by key
p35074
as(dp35075
g6
V335858
p35076
stp35077
a((dp35078
g2
(lp35079
VTheoretically, the first method is faster
p35080
aVPractically, you wouldn't notice any difference
p35081
aVIf your handlers share a good deal of code, using a  is a perfectly acceptable way of reducing code duplication
p35082
as(dp35083
g6
V335858
p35084
stp35085
a((dp35086
g2
(lp35087
VThe initial push of zero is a little confusing
p35088
aVThe key to understanding what's going on there is to observe that  is not incremented
p35089
aVWhen the code sees, say, , which is a first digit in , the  statement pushes zero; then the loop immediately pops it, multiplies by ten, adds , and pushes back
p35090
aVis advanced to the next character (i
p35091
ag630
aV), and then the loop pops , multiplies by ten, adds , and stores back  - the desired result
p35092
aVThere is an error in the code: when the expression ends in a number, you get an index out of bounds exception
p35093
aVFor example,  is a valid postfix expression (having no operators is OK, right
p35094
aVthe inner loop would advance past the end of the string, causing an exception
p35095
as(dp35096
g6
V335858
p35097
stp35098
a((dp35099
g2
(lp35100
VWhen someone supplies a negative index or an index that is out of bounds, it is definitely a programming error
p35101
aVProgramming errors are signaled in Java by throwing unchecked exceptions (i
p35102
ag630
aVones deriving from )
p35103
aVIn this specific case, you should throw
p35104
as(dp35105
g6
V335858
p35106
stp35107
a((dp35108
g2
(lp35109
VAlthough you have established through run-time code that  is in fact , the compiler does not have the same knowledge statically
p35110
aVThe compiler expects you to return an object of type , matching exactly the type parameter of the method
p35111
aVThinks of this situation: someone makes the following call -
p35112
aVNow you're inside , you go through some conditions, and now it's time to return the result
p35113
aVYou call
p35114
aVYou know that this branch in code is impossible to reach, because there is a run-time check guarding you from that:
p35115
aVHowever, the compiler must assume that reaching this return statement is possible, which would be an error in cases when  is not a
p35116
aVYou may want to reconsider the use of generics here: from the code snippet it appears that you  need the generic argument to avoid type-casting the result to the desired type in the caller
p35117
aVHowever, the caller would then need to perform an additional check to see if the conversion inside your  has succeeded
p35118
aVIn this case, a method
p35119
aVmay be equally suited to the task, because it would be free of conversions that trick the compiler, and the structure of the calling code would remain the same
p35120
as(dp35121
g6
V335858
p35122
stp35123
a((dp35124
g2
(lp35125
VWill this cause a memory leak
p35126
aVYes, calling  on the array of pointers without deleting items pointed to by individual elements will cause a memory leak, because "built-in" pointers of C++ do not have ownership semantic
p35127
aVConsider using "smart" pointers, e
p35128
ag303
aVinstead of "plain" ones to avoid calling destructors in a loop
p35129
aVDo I need to call delete [] B if B is an array of integers
p35130
aVYou need to call  on everything that you allocated with , regardless of the element type of the array
p35131
as(dp35132
g6
V335858
p35133
stp35134
a((dp35135
g2
(lp35136
VYou need to pass the stream by reference, because streams are not generally copyable:
p35137
as(dp35138
g6
V335858
p35139
stp35140
a((dp35141
g2
(lp35142
VThere is a good reason why  does not work with  separators: you cannot solve this problem without knowing the full length of the string
p35143
aVOtherwise, when you discover , you have no idea if that's a separator or if the string has already ended
p35144
aVNote that  is not going to help - it would stop as soon as it discovers the first embedded
p35145
aVOther than that "little" problem, all you need to do is discovering the beginning of tokens: they happen to be one character after the  character that you have previously discovered
p35146
as(dp35147
g6
V335858
p35148
stp35149
a((dp35150
g2
(lp35151
VHow can I get the value if I don't get the complex type B from the package
p35152
aVYou can get it as an , and then use reflection to further discover the methods that it exposes
p35153
as(dp35154
g6
V335858
p35155
stp35156
a((dp35157
g2
(lp35158
VYou are not returning a heap variable, you are returning a value of a stack variable that holds a pointer to the heap
p35159
aVThe stack variable goes out of scope; the memory pointed to by the pointer is in the heap - it never goes out of scope
p35160
aVThere will be a memory leak unless you release the memory in the caller
p35161
as(dp35162
g6
V335858
p35163
stp35164
a((dp35165
g2
(lp35166
VThe best (and most C++ - like) approach is to switch from an array to a resizable container, such as
p35167
aVThis container is resized dynamically, letting you delete elements from the end or from any other place in the container
p35168
aVThe container would then resize to the correct size
p35169
as(dp35170
g6
V335858
p35171
stp35172
a((dp35173
g2
(lp35174
VHave I declared the static methods correctly
p35175
aVNo
p35176
aVThere is no such thing as  in Objective C
p35177
aVYou need to declare them as class methods:
p35178
aVIf you need a setter, write one more method:
p35179
aVIs it possible to assign class types or is it better to use an array such as NSMutableArray instead of Bone[]
p35180
aVPlain C arrays are problematic because of the ownership problem
p35181
aVYou will be better served with a  property: it would give you the same flexibility, provide your clients with fast enumeration, and deal with resource cleanup in ways idiomatic to Objective C
p35182
as(dp35183
g6
V335858
p35184
stp35185
a((dp35186
g2
(lp35187
VThis is happening because you declared a local variable with the same name as an instance variable
p35188
aVAs long as the local variable is in scope, assignments to the  variable assign to the local, not to the instance variable
p35189
aVIn fact, it looks like your intention was to assign the instance variable , not a local
p35190
aVIn this case, you need to remove the type in front of the variable name
p35191
aVThis is only a warning, not an error
p35192
aVThe compiler tells you that this area of the code may be confusing to the readers of your code (and to you after enough time passes since the moment that you wrote your code)
p35193
aVIt is a good idea to rename the local variable for better readability of your code
p35194
as(dp35195
g6
V335858
p35196
stp35197
a((dp35198
g2
(lp35199
VIn order to stub out a function you need to provide a function definition, not a function declaration:
p35200
as(dp35201
g6
V335858
p35202
stp35203
a((dp35204
g2
(lp35205
VInstead of checking if the result is in the range, you can force the result to be in the range that you want:
p35206
aVThe value of  is in the range between  and , inclusive
p35207
aVIf you do not want to force the number into range, change your condition to
p35208
aVCurrently, the  belongs to the inner , so the second  does not happen when the number is less than
p35209
as(dp35210
g6
V335858
p35211
stp35212
a((dp35213
g2
(lp35214
VUnless you specify a type of , its type is assumed to be
p35215
aVWhen you pass a pointer to  to  for the  specifier, you get undefined behavior
p35216
aVYou need to specify the type of  to be
p35217
aVNote that this is not going to let you pass the value of  back to the caller: the value will be set in a parameter which is passed by value; it will be discarded as soon as the function exits
p35218
aVIf you need to return the value from the function, you need to pass a pointer to :
p35219
as(dp35220
g6
V335858
p35221
stp35222
a((dp35223
g2
(lp35224
VThis is undefined behavior: you read past the last valid byte of a 6-character string
p35225
aVOnly seven, not eight, bytes are OK to read
p35226
aVIn addition, byte order matters: you may need  on some architectures
p35227
aVIf you know the length of your string, use :
p35228
aVChances are, your optimizer will convert this to a CPU intrinsic for a fastest comparison possible on your platform
p35229
as(dp35230
g6
V335858
p35231
stp35232
a((dp35233
g2
(lp35234
VUnfortunately, you cannot pass an array as a parameter without adding a user-defined type for table-valued parameters
p35235
aVThe simplest way around this restriction is to create individually named parameters for each element of the array in a loop, and then bind the values to each of these elements:
p35236
aVYou can also create a temporary table, insert individual words in it, and then do a query that inner-joins with the temp table of words
p35237
as(dp35238
g6
V335858
p35239
stp35240
a((dp35241
g2
(lp35242
VYou can use  for that:
p35243
as(dp35244
g6
V335858
p35245
stp35246
a((dp35247
g2
(lp35248
VIn C++11 You can use  with a lambda function to detect matching ID, like this:
p35249
aVThis prints , as expected (link to ideone)
p35250
as(dp35251
g6
V335858
p35252
stp35253
a((dp35254
g2
(lp35255
VYou cannot, because the value sets satisfying the two conditions overlap
p35256
aVSpecifically, all even numbers satisfy both parts of your conditions
p35257
aVThat is why you cannot perform different actions without deciding first which part of the condition takes precedence
p35258
aVYou can play a little trick with fall-through inside the  statement, like this:
p35259
as(dp35260
g6
V335858
p35261
stp35262
a((dp35263
g2
(lp35264
VThere are two parts to the answer: you need a way to return one of three values, and a way to pack multiple such values in memory
p35265
aVValues of enumerated types let you solve the first problem: by defining an  you can restrict the declared range of the values returned from a function to just three values
p35266
aVHowever, this would not let you save any memory: s cannot be smaller than eight bits
p35267
aVYou need to pack smaller values into larger ones to save memory
p35268
aVThis works only when you declare arrays of values of sufficient size for the packing to make sense
p35269
aVThe basic approach is to cut out the bits that you need, shift them into position, and  in into their desired location
p35270
aVHere is how you do it with 2-bit numbers: an 8-bit value can store four such numbers
p35271
aVAn array of  2-bit values requires  8-bit values
p35272
aVAn element at position  is in the  byte, in the position  (i
p35273
ag630
aV, , , or )
p35274
aVYou get the desired 2-bit element like this:
p35275
aVSetting the value goes the other way around:
p35276
aVIn cases when you do not need an array, but would like to pack several two-bit values inside a larger  or a , you can use Bit Fields
p35277
aVIn this case the compiler will do all the packing to you, if it is possible to pack the data
p35278
aVNote that the order in which you place your data members becomes significant, and can change the amount of memory that you save
p35279
as(dp35280
g6
V335858
p35281
stp35282
a((dp35283
g2
(lp35284
VThis is because  wants the entire string to be matched, not just any part of it
p35285
aVYou do not need to escape characters inside square brackets
p35286
as(dp35287
g6
V335858
p35288
stp35289
a((dp35290
g2
(lp35291
VRun DFS from the starting vertex, passing the list of vertexes that you found so far down to the next invocation level
p35292
aVPrint the list upon reaching the end vertex, and continue with the DFS until all paths have been enumerated
p35293
as(dp35294
g6
V335858
p35295
stp35296
a((dp35297
g2
(lp35298
VApart from an easy to fix undefined behavior (allocation of  instead of , followed by writing into  - one byte past the allocated space), your program is OK
p35299
aVYou can use a scalar in place of a single-element array
p35300
aVYou can make your program a lot more efficient by reading more than one character at a time, but on inputs of small size it does not matter at all
p35301
as(dp35302
g6
V335858
p35303
stp35304
a((dp35305
g2
(lp35306
VThe problem is your use of  format specifier
p35307
aVWhen letters are entered instead of digits,  returns zero to indicate that nothing is read
p35308
aVIf you would like to allow entering letters along with digits, you should either add a read of a string when  returns zero, or always read into a string buffer, and then use  or  to convert the string to integer
p35309
as(dp35310
g6
V335858
p35311
stp35312
a((dp35313
g2
(lp35314
VThis is relatively straightforward: you need to use a  clause in your query:
p35315
as(dp35316
g6
V335858
p35317
stp35318
a((dp35319
g2
(lp35320
VYou got some of these right, but whoever wrote the questions tricked you on at least one question:
p35321
aVglobal variables -------> data (correct)
p35322
aVstatic variables -------> data (correct)
p35323
aVconstant data types -----> code and/or data
p35324
aVConsider string literals for a situation when a constant itself would be stored in the data segment, and references to it would be embedded in the code
p35325
aVlocal variables(declared and defined in functions) --------> stack (correct)
p35326
aVvariables declared and defined in  function -----> heap also stack (the teacher was trying to trick you)
p35327
aVpointers(ex: , ) -------> heap data or stack, depending on the context
p35328
aVC lets you declare a global or a  pointer, in which case the pointer itself would end up in the data segment
p35329
aVdynamically allocated space(using , , ) --------> stack heap
p35330
aVIt is worth mentioning that "stack" is officially called "automatic storage class"
p35331
as(dp35332
g6
V335858
p35333
stp35334
a((dp35335
g2
(lp35336
VAccording to the Java documentation,
p35337
aVIf two objects are equal according to the  method, then calling the  method on each of the two objects must produce the same integer result
p35338
aVIt appears that in your case two  objects are equal (as per the  method) but their hash codes are different
p35339
aVThis means that you need to fix your  and  functions to be consistent with each other
p35340
as(dp35341
g6
V335858
p35342
stp35343
a((dp35344
g2
(lp35345
VCan you explain why
p35346
aVBecause you cannot assume a specific endianness of your computer architecture
p35347
aVThe natural follow-up question is what do you do about it
p35348
aVFortunately, you can force a specific byte order by calling one of these functions , , , or
p35349
aVThey work regardless of the computer architecture on which you run them:
p35350
aVOn the sending end, you convert from host order to network order; on the receiving end, you convert from network order to host order
p35351
as(dp35352
g6
V335858
p35353
stp35354
a((dp35355
g2
(lp35356
VYou can use  and a conditional, like this:
p35357
as(dp35358
g6
V335858
p35359
stp35360
a((dp35361
g2
(lp35362
VYou can use LINQ to get the answer:
p35363
as(dp35364
g6
V335858
p35365
stp35366
a((dp35367
g2
(lp35368
VStatic classes in Java are one of three kinds of nested classes provided by the language (the other two being non-static nested classes and function-scoped classes)
p35369
aVStatic classes of Java behave the same way that nested classes of C#: they have access to static members of the enclosing class, but cannot access instance members without an additional reference to the enclosing object
p35370
aVIn contrast, non-static nested functions can access instance variables, but you need an enclosing instance in order to be instantiated
p35371
as(dp35372
g6
V335858
p35373
stp35374
a((dp35375
g2
(lp35376
VThis problem is about making permutations of zeros and ones
p35377
aVThe easiest to code solution is to use  and a
p35378
aVPrepare a vector with the earliest permutation in lexicographic order (ones are at the back)
p35379
aVRun  until it returns
p35380
aVHere is a demo code that generates all 8-bit sequences with three bits set:
p35381
aVHere is a link to ideone with a running demo
p35382
aVYour program will need a 32-bit vector with the last eight elements set to
p35383
aVInstead of printing the elements of the sequence, you would need to convert them to a 32-bit , and store them in the output container
p35384
as(dp35385
g6
V335858
p35386
stp35387
a((dp35388
g2
(lp35389
VBut as far as I understand about recursion when it will be big amount of data we run big risk of stack overflow
p35390
aVIt depends on several things:
p35391
aVTail calls are nearly always optimized these days, so you would never hit stack overflow with tail recursion, even if you recurse  times (the algorithm would still be slow, but it wouldn't overflow the stack)
p35392
aVMost sorting algorithms recurse down  times
p35393
aVThis comes up to 40 levels per terabyte of data being sorted - not enough to overflow a stack of anything capable of holding a terabyte of data in its memory
p35394
aVis it reasonable to ignore recursion explanation about sorting algorithms as such that can't be use in real life
p35395
aVNo, it is not reasonable to ignore these explanations: if an algorithm is logically recursive, the best explanation will also be recursive
p35396
aVEven if you implement the algorithm with a loop that uses a dynamically allocated stack to avoid stack overflows, the nature of the algorithm would remain recursive, so the best way to understand what's going on is to pretend that a recursive call is made
p35397
as(dp35398
g6
V335858
p35399
stp35400
a((dp35401
g2
(lp35402
VThe biggest issue is that your program always prints  when it should be printing
p35403
aVAnother issue is that you declared  as  rather than
p35404
aVOther than that, your program is working (link to ideone), but sub-optimal
p35405
aVTo make it optimal, consider these changes (in the order of increasing challenge):
p35406
aVDon't test even numbers for being prime: at the end of the loop print another message saying that  is not prime, and increment  by two
p35407
aVStop when you reach square root of the candidate: in other words, instead of  in the  loop write
p35408
aVStore a list of the primes that you found so far; rather than testing all possible factors from  to , test only the primes that you have already found
p35409
aVConsider switching to a more advanced algorithm for finding primes
p35410
as(dp35411
g6
V335858
p35412
stp35413
a((dp35414
g2
(lp35415
VYou can use a non-equijoin
p35416
aVIf your SQL supports , use
p35417
aVOtherwise, use
p35418
aVHere is a reference to a mysql demo on sqlfiddle
p35419
aVThis query works as you describe only when there are no overlaps in the
p35420
as(dp35421
g6
V335858
p35422
stp35423
a((dp35424
g2
(lp35425
V returns you the number of entries that were read successfully
p35426
aVWhen you try to read a number, but non-numeric value is supplied,  returns zero
p35427
aVYou need to repeatedly prompt the user for the entry until  returns
p35428
aVHere is one way to modify your code to do it:
p35429
as(dp35430
g6
V335858
p35431
stp35432
a((dp35433
g2
(lp35434
VHow can i prevent that the values are set back to 0
p35435
aVYou need to move the creation of the  outside the loop
p35436
aVCurrently, each iteration assigns to its own instane of , which goes out of scope and gets thrown away as soon as the loop iteration is over
p35437
as(dp35438
g6
V335858
p35439
stp35440
a((dp35441
g2
(lp35442
VYou need to group by , then examine each group for containing all values, like this:
p35443
aVThis produces an enumeration of all item IDs that have both "small" and "red" property
p35444
as(dp35445
g6
V335858
p35446
stp35447
a((dp35448
g2
(lp35449
VYour mistake is here:
p35450
aVYou are using assignments to backing variables of properties marked
p35451
aVSwitch to assigning to properties, and your problem will be fixed:
p35452
as(dp35453
g6
V335858
p35454
stp35455
a((dp35456
g2
(lp35457
VWhat is the database doing in a situation like this
p35458
aVThe same as when you specify an ANSI join:
p35459
aVI've noticed everybody writes their queries like this [
p35460
aVIt looks like lots of people in your company got many years of experience in Oracle
p35461
aVI bet they also use  notation for outer joins
p35462
aVThis was the only syntax supported by Oracle prior to the 9i release
p35463
as(dp35464
g6
V335858
p35465
stp35466
a((dp35467
g2
(lp35468
VGenerally speaking, it is not a good idea to mess around with  objects owned by a  from the outside, because the cell that you are going to get may get recycled after being scrolled off the screen, so even if you add an activity indicator, it may get removed
p35469
aVA better approach is to let your  handle the additions and removals of the activity indicator
p35470
aVFor that your model needs to keep a registry of index paths on which the activity indicator should be displayed (the "registry" could be as simple as a single variable, if you never turn on the activity indicator on several cells at the same time)
p35471
aVThe  should read that registry, and decorate the cell accordingly
p35472
aVWhen you want to add an activity indicator, add the corresponding index path to the registry, and call  on the table view
p35473
aVWhen you need to turn off the activity indicator, remove the index path of the cell from the registry, and reload the row again
p35474
aVEssentially, the model needs to be the keeper of the state
p35475
aVEverything that has to do with altering  subclasses needs to happen in
p35476
aVFinally, the controller should give your table view "a tap on the shoulder" when the state needs to change
p35477
as(dp35478
g6
V335858
p35479
stp35480
a((dp35481
g2
(lp35482
VThere are two things that you need to do in order to speed up the insertions:
p35483
aVMove the call of  outside the loop
p35484
aVCurrently, the loop is not shown, so I assume it is outside your code snippet
p35485
aVAdd  and  calls - you need to begin transaction before the insertion loop and end it right after the loop is over
p35486
aVMake  truly parameterized - Currently it appears that you are not using prepared statements to their fullest, because despite using , you have no calls of  in your code
p35487
aVHere is a nice post that shows you how to do all of the above
p35488
aVIt is plain C, but it will work fine as part of an Objective C program
p35489
as(dp35490
g6
V335858
p35491
stp35492
a((dp35493
g2
(lp35494
VI need the method to scan every character in the string
p35495
aVIf you must do it character-by-character, regexp is probably not a good way to go
p35496
aVHowever, since all characters on your "blacklist" have codes less than 128, you can do it with a small  array:
p35497
as(dp35498
g6
V335858
p35499
stp35500
a((dp35501
g2
(lp35502
VAdd  to your
p35503
aVWhen you receive a tap, check your recognizer's
p35504
aVTrigger the action if the tap happened in the area that you would like to make tap-sensitive; otherwise, ignore the tap event
p35505
as(dp35506
g6
V335858
p35507
stp35508
a((dp35509
g2
(lp35510
VYou would still need to mark your variable : since the optimizer is free to inline your functions, especially the short ones, calling your function in a loop without a  mark for accessing hardware-modified memory would place you in danger of not reading the memory after the initial iteration
p35511
as(dp35512
g6
V335858
p35513
stp35514
a((dp35515
g2
(lp35516
VYes - you can do it like this:
p35517
as(dp35518
g6
V335858
p35519
stp35520
a((dp35521
g2
(lp35522
VEach object in Java needs to be able to produce a hash code, not necessarily contain one
p35523
aVHash codes are used for lookups in associative containers, such as hash maps and hash sets
p35524
aVHash codes do not need to be unique, but when objects are used as keys in hash maps, the more unique the hash codes are - the better
p35525
aVWhen two keys are the same, then the objects need to be either (1) logically equal, or (2) override  to distinguish between the two objects
p35526
as(dp35527
g6
V335858
p35528
stp35529
a((dp35530
g2
(lp35531
VThe simplest way is to make a  of some sort of container, for example
p35532
aVor
p35533
as(dp35534
g6
V335858
p35535
stp35536
a((dp35537
g2
(lp35538
VAccording to the documentation, MySQL's Connector/J driver is a JDBC Type-4 Driver:
p35539
aVMySQL Connector/J is a JDBC Type 4 driver
p35540
aVDifferent versions are available that are compatible with the JDBC 3
p35541
aV0 and JDBC 4
p35542
aV0 specifications
p35543
aVThe Type 4 designation means that the driver is a pure Java implementation of the MySQL protocol and does not rely on the MySQL client libraries
p35544
aVYou know that it's Connector/J because the reference manual also states that
p35545
aVThe name of the class that implements  in MySQL Connector/J is
p35546
aVEdit: (in response to the edit of the question) The only way to "recognize" the driver type is to read the documentation that came with the driver
p35547
as(dp35548
g6
V335858
p35549
stp35550
a((dp35551
g2
(lp35552
VThe simplest way would be to type it directly into a string constant in Xcode:
p35553
aVIf you need to convert it to bytes in a specific encoding, use , like this:
p35554
aVWith an instance of  in hand, you can access its  and  to copy into the heartbeat message
p35555
as(dp35556
g6
V335858
p35557
stp35558
a((dp35559
g2
(lp35560
VJust like the SQL where you would use a  and , like this:
p35561
aVin LINQ you would use  and , like this:
p35562
as(dp35563
g6
V335858
p35564
stp35565
a((dp35566
g2
(lp35567
VStart at the end of the array (i
p35568
ag630
ag1783
aVDecrement  rather than incrementing (i
p35569
ag630
aVuse )
p35570
aVStop as soon as you reach zero (i
p35571
ag630
aVadd  after )
p35572
aVMake your stopping condition such that the loop processes element at index zero
p35573
as(dp35574
g6
V335858
p35575
stp35576
a((dp35577
g2
(lp35578
VProperties cannot be of array type, while public instance variables do not provide sufficient encapsulation
p35579
aVA more Objective C - like approach would be defining a private 2D array, and a pair of methods or a method returning a pointer to access it - something along these lines:
p35580
as(dp35581
g6
V335858
p35582
stp35583
a((dp35584
g2
(lp35585
VIt's 1-72 range
p35586
aVI don't have to deal with negatives
p35587
aVPre-create an array/vector of 73  objects, and use an index to get your string
p35588
aVReturning a  reference will let you save on allocations/deallocations, too:
p35589
as(dp35590
g6
V335858
p35591
stp35592
a((dp35593
g2
(lp35594
VThe  and  take a single object, so their performance should be : all they do is appending to the insertion queue, which is either an  or an amortized  for all unordered containers
p35595
aVand , on the other hand, are , where  is the length of the  passed into the method
p35596
as(dp35597
g6
V335858
p35598
stp35599
a((dp35600
g2
(lp35601
VThe problem is in your  method: rather than adding the  object passed in to the array, you add a brand-new object created with  by calling a copy constructor
p35602
aVThis breaks the connection between the variable called  that you passed in and the element at index zero of the  array, explaining the difference in printed values
p35603
aVThe copy semantic that you have in the  is actually a good thing: it saves you from unusual aliasing later on, because the implementation is no longer dependent on the callers to pass distinct objects
p35604
aVChanging the code to
p35605
aVcreates problems, because  is mutable
p35606
aVConsider this call sequence:
p35607
aVOne would expect ten apartments, with rents 100 to 1000 to be added
p35608
aVWith a no-copy change, however, you would end up with ten identical apartments, all with rent set to 1000
p35609
aVThis is because under the hood all ten items in the  array would reference the same  object - the one you created before the  loop
p35610
aVThis causes numerous headaches down the road, so it is better to keep the copying code in place, and know that rent increases should be checked on the objects inside the building, not on the objects that you passed into the  method
p35611
as(dp35612
g6
V335858
p35613
stp35614
a((dp35615
g2
(lp35616
VThe only way around the problem of creating objects is to not create them
p35617
aVOr at least not create them yet
p35618
aVAll 1000 labels are not going to fit on the screen, so you need to create only a group of labels that fit
p35619
aVThen you watch for the scroll events, and create dynamically the labels that become visible
p35620
aVAt the same time, you remove labels as they get scrolled off the screen
p35621
aVKeep these labels around: rather than creating a new one each time, you can reuse an old one from the recycled list
p35622
aVBy now you are probably wondering if you had seen this scheme somewhere
p35623
aVYou are right, it is the same scheme that UITableView uses for its cells
p35624
aVIt is a complex piece of code, so if you could replace a scroll view full of labels with a table, you would save yourself a lot of work
p35625
as(dp35626
g6
V335858
p35627
stp35628
a((dp35629
g2
(lp35630
VWhen you are passing an array of characters to an output stream, the array must be null terminated
p35631
aVYour array is not null terminated; that's why you get extra garbage at the end
p35632
aVHowever, this is not the main problem of your solution: you need to index letters, like this:
p35633
aVFinally, with 26 letters, indexes go zero to 25, so the loop continuation condition should be , , or
p35634
as(dp35635
g6
V335858
p35636
stp35637
a((dp35638
g2
(lp35639
VThe  keyword indeed has special meaning only when it is used with variables
p35640
aVUsing  with function prototypes is entirely optional:
p35641
aVis equivalent to
p35642
aVWhen you declaring/defining a function, you have two options:
p35643
aVProvide only a declaration (i
p35644
ag630
aVa prototype), or
p35645
aVProvide a definition, which also serves as a declaration in the absence of a prototype
p35646
aVWith variables, however, you have three options:
p35647
aVProvide only a declaration,
p35648
aVProvide a definition with the default initializer:  without the  part, or
p35649
aVProvide a definition with a specific initializer:
p35650
aVSince there are only two options for functions, the compiler can distinguish between then without the use of  keyword
p35651
aVAny declaration that does not have a  keywords is considered  by default
p35652
aVTherefore, the  keyword is ignored with all function declarations or definitions
p35653
aVWith variables, however, the keyword is needed to distinguish between the #1 and the #2
p35654
aVWhen you use , it's #1; when you do not use , it's #2
p35655
aVWhen you try to add  to #3, it's a warning, because it remains a definition, and the  is ignored
p35656
aVAll of this is somewhat simplified: you can provide declarations several times in the same compilation unit, and you can provide them at the global scope or at a block scope
p35657
aVFor complete details, check section 6
p35658
ag838
aV9 5 of the C standard
p35659
as(dp35660
g6
V335858
p35661
stp35662
a((dp35663
g2
(lp35664
VOnly difference in C21 and C22 is the implementation of getCaller() which is fixed and can anyways be extracted from parameters of start
p35665
aVSince you have to change only a single method, you will be better off with a single non-abstract implementation  instead of an abstract  and a pair of  and
p35666
aVYou can do something like this:
p35667
aVIn case there are other classes in addition to  and  inheriting , you may want to keep your  abstract, and add a non-abstract  with an above implementation
p35668
as(dp35669
g6
V335858
p35670
stp35671
a((dp35672
g2
(lp35673
VWhen you provide multiple methods with the same name, the method is said to be overloaded
p35674
aVYou cannot overload methods on return type in C#: you need to give them different names or different parameter types
p35675
aVIn your case, changing the name of the  to  will fix the problem:
p35676
as(dp35677
g6
V335858
p35678
stp35679
a((dp35680
g2
(lp35681
VI'm trying to override a property in my program
p35682
aVThe problem is that  is not a property, it is a public field
p35683
aVFields cannot be overriden
p35684
aVHere is an example of overriding a property:
p35685
aVHere is a demo of this code on ideone
p35686
as(dp35687
g6
V335858
p35688
stp35689
a((dp35690
g2
(lp35691
VAn unescaped  in the expression stands for any character
p35692
aVYou need to use either , or  to match a literal dot
p35693
aVThe  after the dot means "one or more occurrences of the prior expression"
p35694
aVAbove, the "prior expression" is a single dot
p35695
aVTo match multiple segments in the e-mail's domain address, you need to add parentheses:
p35696
as(dp35697
g6
V335858
p35698
stp35699
a((dp35700
g2
(lp35701
VYou should define a function to loop through the input for a single array, and call that function for each of your four arrays:
p35702
aVNow you can call these methods from the  passing , , etc
p35703
aV, like this:
p35704
as(dp35705
g6
V335858
p35706
stp35707
a((dp35708
g2
(lp35709
VNo, you cannot overload a public constructor or another member function with a private one: only the name and the parameter types count for the purpose of overload resolution
p35710
aVTo do what you are looking for, define a private constructor that takes an additional  parameter that indicates that the parameter checking needs to be performed:
p35711
aVTo construct an instance and bypass the check, functions that have access to the private constructor call
p35712
aVChecked instances constructed the usual way:
p35713
as(dp35714
g6
V335858
p35715
stp35716
a((dp35717
g2
(lp35718
VIn your view controller override
p35719
aVInside that method check if this is the correct segue, and verify the edit state
p35720
aVIf the editing is on, return ; otherwise, return
p35721
as(dp35722
g6
V335858
p35723
stp35724
a((dp35725
g2
(lp35726
VThe  is indeed not stored together with the : only a pointer to it is stored
p35727
aVThe data is usually allocated dynamically in the area outside the  itself
p35728
aVTo have the name stored together with the  you need to make it an array
p35729
aVThe downside to this approach is that either the string must be fixed length (i
p35730
ag630
aVall s will allocate the amount of memory sufficient for a  of max length, or you need to use a flexible array element by declaring the  array at the end of the
p35731
aVThe downsides to this last approach is that (1) the allocation becomes a lot more complicated, (2) you cannot make an array of such s, and (3) you can have only one flexible array in a structure
p35732
as(dp35733
g6
V335858
p35734
stp35735
a((dp35736
g2
(lp35737
VThis depends a lot on the specific libraries
p35738
aVThere are three kinds of libraries out there:
p35739
aVHeader-only libraries - these dependencies are resolved at compile time
p35740
aVStatic libraries - these dependencies are resolved at link time
p35741
aVShared (dynamic) libraries - these dependencies are resolved at run time
p35742
aVMost Boost libraries are header-only: they require no separately-compiled library binaries or special treatment when linking
p35743
aVOther libraries are static, i
p35744
ag630
aVthey are needed only at build time for linking
p35745
aVThe only libraries that must be available on the target machine are dynamic (shared) libraries; if you have no dynamic library dependencies, copying an executable and setting the appropriate permissions will work fine
p35746
as(dp35747
g6
V335858
p35748
stp35749
a((dp35750
g2
(lp35751
VYou need to escape the dash in
p35752
aVOtherwise, it is interpreted as a range from  to  - a range that includes , ,
p35753
aV, and
p35754
aVAlternatively, you can move the dash to the end of the character class (i
p35755
ag630
aVput it before the closing )
p35756
as(dp35757
g6
V335858
p35758
stp35759
a((dp35760
g2
(lp35761
VHere is the problem:
p35762
aVThis line should be
p35763
aVbecause  contains counters, not pointers
p35764
aVThat is why assigning  to elements of  fails
p35765
aVNow let's discuss your algorithm: your attempted implementation of counting sort will break for arrays with duplicate values, because you set  to  regardless of how many times you found an item
p35766
aVYou should change it to , and use the count to put that many counted values into the resultant array
p35767
aVSee pseudocode in the wikipedia article a the correct implementation
p35768
aVHere is a table comparing performances of various sorting algorithms
p35769
aVLook for the second table with details on non-comparison sorts
p35770
as(dp35771
g6
V335858
p35772
stp35773
a((dp35774
g2
(lp35775
VYou need to use a constructor that takes a  because the value of  constant is rounded by the compiler well before it gets to the 's constructor
p35776
aVIn other words, the compiler sees your  constant, and converts it to
p35777
aVThe  type does not have enough precision to store all the nines, so the value gets rounded to , and that's the value that gets passed to 's constructor
p35778
aVThe precision is gone before the program gets to execute its first instruction
p35779
aVOn the other hand, when you pass a string, you let  do the interpretation of the sequence of nines, making sure that you get the exact precision that you need
p35780
as(dp35781
g6
V335858
p35782
stp35783
a((dp35784
g2
(lp35785
VOne way to do this would be to group by fruit id, and then examine the resultant groups with LINQ expressions:
p35786
aVThis produces the list of s of your desired type
p35787
aVEDIT: (in response to a comment below)
p35788
aVType is only 1 or 2 but never 3
p35789
aVThen you can simplify your query as follows:
p35790
as(dp35791
g6
V335858
p35792
stp35793
a((dp35794
g2
(lp35795
VI think you misunderstand the meaning of preprocessor definitions
p35796
aV-d items only look like variables, but they are not variables in the classical sense of the word: they are text substitutions
p35797
aVThey are interpreted by the preprocessor, before the compiler gets to see the text of your program
p35798
aVBy the time the preprocessor is done, the text of the program has no references to , , or : their occurrences are substituted with , , and
p35799
aVThat is why you cannot access -d variables: there are no variables to access
p35800
as(dp35801
g6
V335858
p35802
stp35803
a((dp35804
g2
(lp35805
VYou are missing an opening  after the second  loop:
p35806
aVIn general, when you see unexpected errors that make little sense, it usually mean a bracketing imbalance or a missing semicolon
p35807
as(dp35808
g6
V335858
p35809
stp35810
a((dp35811
g2
(lp35812
VSince I do not want the class to be instantiated ever, I make the constructor private
p35813
aVIf you have access to a C++11 compiler, you have a better option: you can explicitly delete the "gratuitous" constructor provided by the compiler
p35814
aVThis should address the problem with the destructor, because the compiler would know that it is impossible to construct your class
p35815
aVIf you cannot use the deleted constructor feature, declaring a constructor private should be sufficient to prevent outside instantiations
p35816
aVThe destructor is not necessary, because there is nothing to destruct
p35817
aVIs this a good practice
p35818
aVAnything wrong with my design
p35819
aVThis practice is more common in languages where it is not possible to define free-standing functions/variables
p35820
aVC++, on the other hand, provides free-standing functions and variables
p35821
aVA combination of these two features with namespaces makes classes with only static members unnecessary: such class would be functionally equivalent to a namespace, but would not be idiomatic to C++
p35822
as(dp35823
g6
V335858
p35824
stp35825
a((dp35826
g2
(lp35827
VIf I am introducing a  block at all, I prefer keeping it closer to the code that may throw the corresponding exception, for the same reason why I declare variables closer to the place where they are used - i
p35828
ag630
aVbetter readability
p35829
aVFor that reason, your first example is clearly preferable
p35830
aVCombining / with a sequence of  statements is not as clean, because it requires the reader of your code to have much better understanding of what's going on above the exception handler block: specifically, in your example the reader must know that only one condition will be
p35831
aVAlthough sesting exception handlers as in the cleanup code is sometimes necessary, it is usual to "drop" the second-level exception during cleanup, reporting only the first-level exception
p35832
as(dp35833
g6
V335858
p35834
stp35835
a((dp35836
g2
(lp35837
VThis is definitely not a valid syntax:  queries require specific items; also, because in SQL null never equals anything, including other nulls, it does not make sense to put nulls into an  list
p35838
aVWhat you need instead is an :
p35839
aVEvery time I try to use an OR clause it causes a lot of run time
p35840
aVIn cases when  is introduced to combine non-overlapping results (which is true in this case, because a column is either  or is greater than , but not both) you can use  to potentially speed up the search:
p35841
aVYou need to make sure that  column is indexed
p35842
as(dp35843
g6
V335858
p35844
stp35845
a((dp35846
g2
(lp35847
VYou removed the body of the method, but you forgot to remove the member initialization list:
p35848
aVIn addition, you need to put semicolons after the last closing brace of your class definitions
p35849
as(dp35850
g6
V335858
p35851
stp35852
a((dp35853
g2
(lp35854
VThe answer depends on the scope of the said declaration: in the local scope, the first variable is unassigned, while the second variable is assigned:
p35855
aVvs
p35856
aVAt the class scope, there is no difference:
p35857
aVIn both cases  starts off as
p35858
as(dp35859
g6
V335858
p35860
stp35861
a((dp35862
g2
(lp35863
VSince you need to walk through all characters in the string anyway, why not simply
p35864
aVThis uses fewer classes, much easier to read, and uses less CPU to perform the calculations
p35865
as(dp35866
g6
V335858
p35867
stp35868
a((dp35869
g2
(lp35870
V does not have enough precision for eighteen decimal digits: 64-bit IEEE-754 numbers have at most 17 decimal digits
p35871
aVYou should use  for unlimited precision
p35872
as(dp35873
g6
V335858
p35874
stp35875
a((dp35876
g2
(lp35877
VYou need to pass pointers to  and , not the elements themselves:
p35878
aVIn C++11, you can use  and :
p35879
as(dp35880
g6
V335858
p35881
stp35882
a((dp35883
g2
(lp35884
VMake an array  of 1000 booleans
p35885
aVSet  to  if  is prime, and  otherwise
p35886
aVThen the  algorithm becomes easy: go through numbers  1 through 1000 in the outer loop, then go through all primes  greater than  in an inner loop, and check if there exists a prime such that  is :
p35887
aVI doubt that the check could be performed in constant time for a total running time of  for the 1000 numbers, because computer-aided verification currently proceeds at a rather slow speeds
p35888
as(dp35889
g6
V335858
p35890
stp35891
a((dp35892
g2
(lp35893
VCollections are indeed polymorphic: all collection classes in Java implement one or more interfaces, letting you swap in a new implementation if you program to collection's interface
p35894
aVFor example, if you define and use
p35895
aVyou can replace it with
p35896
aVand the rest of the code would not need to change
p35897
aVOf course there would be consequences in timing if you try accessing elements in the middle of a linked list
p35898
as(dp35899
g6
V335858
p35900
stp35901
a((dp35902
g2
(lp35903
VUse breakpoints
p35904
aVSet a breakpoint at the end of your method by clicking in the "gutter" area
p35905
aVA red circle will appear that looks like this:
p35906
aVNow run your program in debug mode by clicking the button with the green triangle or pressing F5
p35907
aVThe program will run, producing the output in the console (a separate window)
p35908
aVOnce it hits your breakpoint, you can examine the console for the output, like this:
p35909
as(dp35910
g6
V335858
p35911
stp35912
a((dp35913
g2
(lp35914
VYou can use a simpler check:
p35915
aVThe  call removes all digits from the
p35916
aVThe  check would succeed only when there are no digits to remove
p35917
aVNote that throwing  in this case would be misleading, because the exception has a very different meaning
p35918
as(dp35919
g6
V335858
p35920
stp35921
a((dp35922
g2
(lp35923
VFirst, let's simplify your algorithm; then let's informally prove its correctness
p35924
aVModified algorithm
p35925
aVObserve that once you computed the number of elements below each number in the sorted sequence, you have enough information to determine for each group of equal elements  their places in the sorted array
p35926
aVFor example, if  is repeated 7 times and has 21 elements ahead of it, then s will occupy the range  (all indexes are zero-based; the range is inclusive of its ends)
p35927
aVGo through the  in the order of increasing number of swaps
p35928
aVFor each element , find the beginning of its target range ; also note the end of its target range
p35929
aVNow go through the elements of  outside of the  range
p35930
aVIf you see , swap it into the range
p35931
aVAfter swapping, increment
p35932
aVIf you see that  is equal to , continue incrementing: these s are already in the right spot, you wouldn't need to swap them
p35933
aVInformal proof of correctness
p35934
aVNow lets prove the correctness of the above
p35935
aVObserve that once an element is swapped into its place, it is never moved again
p35936
aVWhen you reach an element  in the , all elements with lower number of swaps are already processed
p35937
aVBy construction of the algorithm this means that these elements are already in place
p35938
aVSuppose that  has  number of allowed swaps
p35939
aVWhen you swap it into its place, you move another element out
p35940
aVThis replaced element cannot be , because the algorithm skips s when looking for a destination in the target range
p35941
aVMoreover, the replaced element cannot be one of elements below  in the , because all elements below  are in their places already, and therefore cannot move
p35942
aVThis means that the swap count of the replaced element is necessarily  or more
p35943
aVSince by the time that we finish processing  we have exhausted at most  swaps on any element (which is easy to prove by induction), any element that we swap out to make room for  will have at least one remaining swap that would allow us to swap it in place when we get to it in the order dictated by the
p35944
as(dp35945
g6
V335858
p35946
stp35947
a((dp35948
g2
(lp35949
VYou can use non-void blocks for the same reason you'd use a non-void function pointer - to provide an extra level of indirection when it comes to code execution
p35950
aVs  provides one example of such use:
p35951
aVThe comparator block lets you encapsulate the comparison logic outside the  method that performs the sorting
p35952
as(dp35953
g6
V335858
p35954
stp35955
a((dp35956
g2
(lp35957
VThis is a little confusing: constructors indeed do not return a value; it is operator  that does
p35958
aVHowever, constructors are always used with a *, so it looks like they always return a value
p35959
aV* This is a slight simplification: you can use a constructor without  if you go through reflection
p35960
aVHowever, the same mechanisms will be in play
p35961
as(dp35962
g6
V335858
p35963
stp35964
a((dp35965
g2
(lp35966
VWhat is the utility of having static functions in a file
p35967
aVYou can use these functions to provide shared implementation logic to other functions within the same file
p35968
aVVarious helper functions specific to a file are good candidates to be declared file-static
p35969
aVHow are they different from having global functions in a file
p35970
aVThey are invisible to the linker, allowing other compilation units to define functions with the same signature
p35971
aVUsing namespaces alleviates this problem to a large degree, but file- functions predate namespaces, because they are a feature inherited from the C programming language
p35972
as(dp35973
g6
V335858
p35974
stp35975
a((dp35976
g2
(lp35977
VIt looks like your code is susceptible to chasing its own tail: if a graph contains a cycle, your code will exhaust the stack, because it does not check if a vertex has been explored before pushing it onto the stack
p35978
aVBasic DFS requires you to maintain a set of explored vertices, and explore a vertex only if it is unexplored
p35979
aVAdding this set to your program should address the out-of-memory problem
p35980
as(dp35981
g6
V335858
p35982
stp35983
a((dp35984
g2
(lp35985
VIn order to do this, your superclass needs to expose a designated initializer that takes  as a parameter
p35986
aVSee  for an example of how it is done in the standard library
p35987
as(dp35988
g6
V335858
p35989
stp35990
a((dp35991
g2
(lp35992
VAm I right, that static arrays are stored to the stack
p35993
aVNo,  arrays are stored in the static storage area
p35994
aVThe automatic ones (i
p35995
ag630
aVones declared inside functions, with no  storage specifier) are allocated on the stack
p35996
aVWhich parameters affect my maximum stack size for one C program
p35997
aVThis is system-dependent
p35998
aVOn some operating systems you can change stack size programmatically
p35999
aVRunning out of stack space due to automatic storage allocation is a clear sign that you need to reconsider your memory strategy: you should either allocate the buffer in the static storage area if re-entrancy is not an issue, or use dynamic allocation for the largest of your arrays
p36000
as(dp36001
g6
V335858
p36002
stp36003
a((dp36004
g2
(lp36005
VThis should work:
p36006
aVThe expression to match the input is constructed as follows:
p36007
aVHere is a demo on ideone
p36008
as(dp36009
g6
V335858
p36010
stp36011
a((dp36012
g2
(lp36013
VIf  is defined as the primary key, this should look up  by its  key:
p36014
as(dp36015
g6
V335858
p36016
stp36017
a((dp36018
g2
(lp36019
VThe problem with using the "straight"  is that it does not interpret the dictionaries as dictionaries; it interprets dictionaries as
p36020
aVThat is why you need that final  step
p36021
aVIf your dictionaries do not have duplicate keys, this should work a little faster:
p36022
aVNote that the  method will break too if the two dictionaries contain the same key with different values
p36023
aVwill break if the dictionaries contain the same key even if it corresponds to the same value
p36024
as(dp36025
g6
V335858
p36026
stp36027
a((dp36028
g2
(lp36029
VAccording to the documentation,
p36030
aV[is thrown when] path contains one or more of the invalid characters defined in GetInvalidPathChars
p36031
aVThis means that you can pre-validate your path strings as follows:
p36032
aVThis is the only condition under which  throws an exception
p36033
aVTake a look at Mono source of , line 496, for details on how this is implemented
p36034
as(dp36035
g6
V335858
p36036
stp36037
a((dp36038
g2
(lp36039
VThe "unrecognized selector sent to instance" error always means one thing: you are calling a method on an instance that does not support it
p36040
aVIn this particular case, you have a line in your code that looks like this:
p36041
aVOn this line,  is an instance of string, which does not have an  method
p36042
aVThis problem could be caused by passing an object of a wrong type to some other method:
p36043
aVThe method could be expecting an object that responds to , but you are passing it a string
p36044
aVFinally, you may be trying to invoke a method in a category, but you forgot to import the header file for the category
p36045
as(dp36046
g6
V335858
p36047
stp36048
a((dp36049
g2
(lp36050
VThis is an interesting (and common) puzzle
p36051
aVYou have figured out its first part correctly: in order to store the elements in a single array, the array type must match the common ancestor of all elements that go into the array
p36052
aVOf course, this limits the functionality to only what's offered by that common ancestor, which apparently is not enough in your circumstances
p36053
aVThe second part (namely, what to do with elements once you have them all in the array) is a bit harder
p36054
aVYou need either a type cast, or a multiple dispatch
p36055
aVThe type cast is easy: just add  in front of the element:
p36056
aVFor multiple items, you can use LINQ:
p36057
aVMultiple dispatch is a lot more complex
p36058
aVIt lets you make methods virtual with respect to more than one object
p36059
aVIn return you must sacrifice the simplicity offered by the language: calling methods would require making special objects, rather than calling methods directly
p36060
aVTake a look at the Visitor Pattern for some ideas of how to deal with multiple dispatch
p36061
as(dp36062
g6
V335858
p36063
stp36064
a((dp36065
g2
(lp36066
VThe  operator compares pointers
p36067
aVIt succeeds only when the two  point to the same address in memory
p36068
aVComparing strings' content in C requires a call of  or :
p36069
aVNote the comparison to zero: it is required because  functions compare strings lexicographically, returning zero when the strings are equal
p36070
aVYou need to include  in order to use
p36071
as(dp36072
g6
V335858
p36073
stp36074
a((dp36075
g2
(lp36076
VYou need to make the  nested class :
p36077
aVOtherwise, the nested class remains non-static, which means that it retains a reference to the instance of its outer class
p36078
aVAs a consequence, only instance methods or other places where you have access to an instance of the outer class can instantiate the inner class
p36079
aVIn general, public static classes are good candidates for top-level classes
p36080
aVThe exception is when they are tied to their outer class to the extend that they make no sense outside its context
p36081
aVFor example,  makes no sense outside its outer  interface
p36082
as(dp36083
g6
V335858
p36084
stp36085
a((dp36086
g2
(lp36087
VThe second parameter passed to the constructor is the element of the vector to be repeated  times
p36088
aVYou should use this syntax:
p36089
aVFor example, to make a 50x25 grid of  initially set to , use:
p36090
as(dp36091
g6
V335858
p36092
stp36093
a((dp36094
g2
(lp36095
VTry this approach:
p36096
aVThe above code assumes that  of leaves are empty lists, rather than s
p36097
as(dp36098
g6
V335858
p36099
stp36100
a((dp36101
g2
(lp36102
VSince this is almost certainly a learning exercise, I'll stay away from writing code, letting you have all the fun
p36103
aVCreate a
p36104
aVEvery time that you see a key/value pair, check if the hash map has a value for the key (use 'containsKey(key)')
p36105
aVIf it does, get that old value using , add the new value, and store the result back using
p36106
aVIf the key is not there yet, add a new one - again, using
p36107
aVDon't forget to make an  out if the  (use  for that)
p36108
aVAs far as optimizing goes, any optimization at this point would be premature: it does not even work
p36109
aVHowever, it's hard to get much faster than a single loop that you have, which is also rather straightforward
p36110
as(dp36111
g6
V335858
p36112
stp36113
a((dp36114
g2
(lp36115
VThe error line should be like this:
p36116
aVor just
p36117
as(dp36118
g6
V335858
p36119
stp36120
a((dp36121
g2
(lp36122
VSQL Server 2008 does not support regular expressions; only patterns are supported
p36123
aVYou can use a query like this to find matches of three digits or more:
p36124
aVYou wouldn't get the count, but you would be able to filter
p36125
aVThe downside to this solution is that in order to search for, say, five digits you would need to change the pattern itself
p36126
aVHere is a quick demo on sqlfiddle
p36127
as(dp36128
g6
V335858
p36129
stp36130
a((dp36131
g2
(lp36132
VThere is nothing wrong with your generic class
p36133
aVSomething is wrong with the class that you are passing as its generic parameter
p36134
aVNamely, , the class that you pass in  does not implement
p36135
aVYour  class requires  to be an implementation of
p36136
aVYou need it in order to check element-by-element equality of arrays using the  expression
p36137
aVIf whatever class that you use as 's generic parameter is not equitable to itself, the compiler would complain
p36138
as(dp36139
g6
V335858
p36140
stp36141
a((dp36142
g2
(lp36143
VIf my reading of your question is correct, you are looking to contrast the scope (local, instance, static, etc
p36144
aVwith visibility (public, private, protected, internal)
p36145
aVThese two concepts are nearly independent (I said "nearly", because variables of local scope do not have visibility)
p36146
aVTogether they let you control both the lifetime and the accessibility of your variables
p36147
aVThe scope controls the lifetime of your variable, letting you determine when it comes into existence and when it becomes unavailable
p36148
aVNaturally, the scope constraints "the range within a program's source code in which that variable is recognized by the compiler"
p36149
aVHowever, being recognized by the compiler is not sufficient for your program to access the variable: if the compiler recognizes the variable as private, it wouldn't let your program access it outside the context where the variable is visible (e
p36150
ag303
aVfrom methods of another class)
p36151
aVEssentially, scope and visibility control two different aspects of accessibility that work together to decide the range within a program's source code in which that variable can be used by the code that tries to access it
p36152
as(dp36153
g6
V335858
p36154
stp36155
a((dp36156
g2
(lp36157
VYou can use generics like this:
p36158
aVAll chart types need to implement the common  interface
p36159
aVThe  line provides a constraint that lets you call ; for that, all chart classes must also implement a no-argument constructor
p36160
aVNow you can use your generic code like this:
p36161
as(dp36162
g6
V335858
p36163
stp36164
a((dp36165
g2
(lp36166
VMoving a value in C# is very different from moving, say, an orange from your fridge to your table, in the sense that when you move the orange from one place to another, the old place no longer contains the orange
p36167
aVMoving an item in the array, on the other hand, is, essentially, an act of copying*, so you can write something like this:
p36168
aVNow the item from the old index is moved to its new index
p36169
aVThe old index contains the item as well
p36170
aVIf you do not want that to happen, you need to explicitly "remove" the item by replacing it with something else
p36171
aVIn an array of reference objects you replace it with :
p36172
aVIn an array of value objects, you replace it with some special value that you designate as "nothing", or with  if your value object is nullable
p36173
aV* What you copy depends on the type of the array element: in an array of value types, the item itself gets copied; in an array of reference types, a reference gets copied
p36174
aVContinuing with the orange analogy, when orange is a reference type, an array of oranges is a list of post-it notes defining the locations of all oranges in the array
p36175
aVInstead of moving an orange into the array, you put a post-it note that says "third orange from the right", and leave the orange in place
p36176
aVCopying a reference object simply copies its post-it note
p36177
as(dp36178
g6
V335858
p36179
stp36180
a((dp36181
g2
(lp36182
VWhen you define a property , by default its name is transformed to  to name its backing variable
p36183
aVYou can override it with  or even , but the use of  is no longer required
p36184
aVThe property itself is visible from the outside, but it does not introduce an unqualified name in the scope the same way the variables do
p36185
aVIn other words, you cannot use the property without prefixing it with , but you can use its backing variable
p36186
aVTo make the long story short, replace
p36187
aVwith
p36188
aVor
p36189
aVto make it work
p36190
as(dp36191
g6
V335858
p36192
stp36193
a((dp36194
g2
(lp36195
VSince the dot  operator is evaluated left-to-right (i
p36196
ag630
aVfirst  is called to determine the target of the invocation, and then its  member is invoked), the answer is 54
p36197
as(dp36198
g6
V335858
p36199
stp36200
a((dp36201
g2
(lp36202
VThere is no  in Cocoa; you can create your own
p36203
aVHowever, a more idiomatic approach to the problem is similar to other methods that return errors, namely, passing a pointer to a pointer to an error, and returning :
p36204
aVYou can call this method as follows:
p36205
aVFor an example of how this idiom is used in Cocoa, see the  method of the  class
p36206
as(dp36207
g6
V335858
p36208
stp36209
a((dp36210
g2
(lp36211
VUsing  (and  for doubles) sounds like the right approach
p36212
aVThe implementation that you quoted flows straight from the documentation for :
p36213
aVIt sets  to zero before the call ( does not change  on success)
p36214
aVIt examines  upon return of  to see if an error has been signaled
p36215
aVThe final condition checks that the input is not empty, and that the entire input has been consumed by
p36216
aVAn implementation for s would look the same, except you'd use
p36217
as(dp36218
g6
V335858
p36219
stp36220
a((dp36221
g2
(lp36222
VStrictly speaking, you do not need  All it does is letting you write
p36223
aVinstead of
p36224
aVThe namespace "contains" iostream definitions (among other definitions provided by the standard C++ library) only in the sense that  is implicitly "prefixed" to all names
p36225
aVThis "contains" is different from the "contains" in "the  file contains definitions of input/output functions": the file literally contains the definitions; the  namespace name is only a prefix that lets you avoid name collisions
p36226
as(dp36227
g6
V335858
p36228
stp36229
a((dp36230
g2
(lp36231
VChange
p36232
aVto
p36233
aVto fix the crash (demo on ideone; without , it crashes with SIGSEGV)
p36234
aVThe problem is that you continue iterating the vector even after erasing one of its elements, which is not allowed
p36235
aVSince you are going to delete only one worker (assuming that  is unique), continuing after the element has been erased wasn't a good idea anyway
p36236
as(dp36237
g6
V335858
p36238
stp36239
a((dp36240
g2
(lp36241
VIs there somewhere I can put it so that I write the text once and fetch the same text all over the place
p36242
aVYes, there is a special kind of file specifically for this, called
p36243
aVIt lets you write
p36244
aVinstead of
p36245
aVThe added benefit (in fact, the intended purpose) of using  is that your application becomes easily localizable (see answer to this question): adding proper translations and setting the current locale is all it would take to change all strings that your application displays to users with their proper local translations
p36246
as(dp36247
g6
V335858
p36248
stp36249
a((dp36250
g2
(lp36251
VConsider this example: let's say  (for the simplicity of counting) and the line that you need to fold looks like this:
p36252
aVGo through the characters counting the current position in the line that you are producing
p36253
aVWhen you see a whitespace, go back to find the last non-space char before it, and makr its position
p36254
aVWhen your counter reaches , see where was the last non-blank character preceding a space in the original line, and fold the line
p36255
aVIn the example above, the first space that you see is at the position 3
p36256
aVAt this point you go back one char, mark 2 as the last non-blank preceding the space, and go on
p36257
aVWhen the count reaches 6 (at character ), split the line at position 3, and reset the current position back to zero
p36258
aVContinue with the algorithm to fold at 7, 13, and 20
p36259
as(dp36260
g6
V335858
p36261
stp36262
a((dp36263
g2
(lp36264
VYou cannot find characters using  - it's for getting a character once you know where  it is
p36265
aVIs there a way to implement the for loop to cycle through the String looking for x also
p36266
aVYou need to use  for finding positions of characters
p36267
aVPass the initial position which is the position of the last  that you found so far to get the subsequent position
p36268
aVFor example, the code below
p36269
aVprints  for the three positions of  in the string
p36270
as(dp36271
g6
V335858
p36272
stp36273
a((dp36274
g2
(lp36275
Vwhy is this so even though the console output statement  is before the input statement
p36276
aVBecause the  changes the order of execution, letting the control skip over  once the prime is found
p36277
aVYou need to move the  out of the loop
p36278
aVThere are several things that you can do to optimize things quite a bit: rather than trying to divide by every number  through , you should divide out only the prime numbers that you have found so far
p36279
aVThis would speed things up a lot
p36280
aVYou can also drop the call of  by using  as your exit condition
p36281
as(dp36282
g6
V335858
p36283
stp36284
a((dp36285
g2
(lp36286
VYou need to provide an implementation of , and use the constructor that takes your custom comparer:
p36287
as(dp36288
g6
V335858
p36289
stp36290
a((dp36291
g2
(lp36292
VThis is a "poster child" example for the  query:
p36293
aVAn  condition is  if its  returns one or more row; otherwise, it is
p36294
aVAll you need to do is to correlate the inner subquery with the outer one (the  part), and add the remaining constraints that you need (the  or the ) to your query
p36295
as(dp36296
g6
V335858
p36297
stp36298
a((dp36299
g2
(lp36300
VSince  is an inner class, its name needs to be qualified with the name of the outer class:
p36301
aVEDIT: Removed a suggestion to make class  because the class is nested inside an interface
p36302
aVThe suggestion would have been required for classes nested inside classes; for interfaces,  is optional
p36303
as(dp36304
g6
V335858
p36305
stp36306
a((dp36307
g2
(lp36308
VYou can shorten it by throwing away the unnecessary  (what else could it be
p36309
aVand combining months with the same outcome:
p36310
as(dp36311
g6
V335858
p36312
stp36313
a((dp36314
g2
(lp36315
VThe two major reasons behind using accessor methods (getters and setters) to access variables of other classes are
p36316
aVAn ability to present accessors as members of an interface, and
p36317
aVAn ability to override an accessor in a subclass
p36318
aVA slight drop in readability is a reasonable price to pay for these advantages, because they let you encapsulate the logic of your class, resulting in tighter control on your part
p36319
aVNeither of these advantages applies when it comes to private methods: they cannot implement interface methods, and they cannot be overridden
p36320
aVIn fact, Java compiler would often optimize them out altogether, especially the simpler ones
p36321
aVThat is why I would recommend going straight for the instance variables, rather than adding an extra layer that does not help readability, yet gets optimized out by the compiler
p36322
as(dp36323
g6
V335858
p36324
stp36325
a((dp36326
g2
(lp36327
VThe command line for  needs to include both source files, like this:
p36328
aVOtherwise, the compiler has no idea from where to get the implementation of the  member function
p36329
aV*EDIT: * (from the comment)
p36330
aVI thought that basically the use of header files was so that it would know where to get each implementation of the file
p36331
aVThis part is grossly oversimplified, but it should help you get the picture
p36332
aVRecall that the process of producing an executable from C++ sources consists of two major steps - compilation and linking
p36333
aVThe  program performs them both (it can do just one if you specify  flags, or pass only  files)
p36334
aVThe compiler and the linker stages of  do not "talk" to each other directly
p36335
aVThe compiler produces the inputs for the linker, and that's where the communication ends
p36336
aVHeader files are for the compiler
p36337
aVSpecifically, they are for the first stage of compilation - the preprocessing
p36338
aVOnce the preprocessor has finished, there is no knowledge of where the definitions came from
p36339
aVEven the compiler does not know it, let alone the linker
p36340
aVThat is why you need to "help" the linker by supplying all the relevant sources to
p36341
as(dp36342
g6
V335858
p36343
stp36344
a((dp36345
g2
(lp36346
VThe answer is in the operator that converts  to  (replaced with an operator to convert  to a  in C++11):
p36347
aVA stream object derived from ios can be casted to a pointer
p36348
aVThis pointer is a null pointer if either one of the error flags (failbit or badbit) is set, otherwise it is a non-zero pointer
p36349
aVThis operator gets called when your stream is used in an , , or  condition
p36350
aVThere is also a unary  operator for the cases when you need to write
p36351
as(dp36352
g6
V335858
p36353
stp36354
a((dp36355
g2
(lp36356
VIt is hard to answer this question exactly without seeing the header, but if this is a function, you need to add a return type of  to the definition of your function:
p36357
aVIf this is a constructor, you need to provide its qualified name:
p36358
as(dp36359
g6
V335858
p36360
stp36361
a((dp36362
g2
(lp36363
VIn  loops and in all other situations where  or  are used, evaluation proceeds left to right until the answer is known
p36364
aVAt that point the evaluation stopped
p36365
aVThis is known as short circuiting
p36366
aVThis is a very important feature, because it lets you "guard" subsequent expressions by inserting checks earlier on
p36367
aVFor example,
p36368
aVwill not crash on  only because of short-circuiting
p36369
aVHad it not been for it, programmers would be forced to write much less pleasant
p36370
aVto avoid the crash
p36371
as(dp36372
g6
V335858
p36373
stp36374
a((dp36375
g2
(lp36376
VYou can create  objects dynamically, and add them to the view where you need them
p36377
aVIt should be a
p36378
aVHere is a question and answer that discuss this approach in depth
p36379
aVHowever, this is not the best approach that you can take, because as the number of labels grows, you start to run out of resources
p36380
aVThis slows down your scrolling, among other things, and increases the possibility of running out of memory
p36381
aVThe idiomatic iOS solution to a situation when you need a list of labels that grows dynamically is to use
p36382
aVThis class solves the potential resource issues by reusing the cells as they get scrolled off the screen
p36383
aVAlthough it is possible for you to implement a similar approach with your own scroll view, it would take you considerable effort, but would not look "native" to the users of your application
p36384
as(dp36385
g6
V335858
p36386
stp36387
a((dp36388
g2
(lp36389
Vnot sure how timespan will help in this scenario
p36390
aVproduced by subtracting a later time form an earlier one will be negative
p36391
aVFor example,
p36392
aVprints
p36393
aVYou can check if the interval is negative to detect overlaps
p36394
aVOne way to do it is examining the  property for being negative:
p36395
as(dp36396
g6
V335858
p36397
stp36398
a((dp36399
g2
(lp36400
VThe exercise is about capturing groups
p36401
aVThe requirement is to capture two sequences of digits separately, and skip the , like this:
p36402
aVYour solution, on the other hand, captures the entire input into a single capturing group denoted by parentheses
p36403
aVThe concept of capturing groups is very important when you need to process individual parts of the input captured by your regular expression, as opposed to processing the entire capture
p36404
aVIn the examples at your link, you can grab the first group for the horizontal component of the resolution, and the second group for the vertical component of the resolution
p36405
aVWithout two separate capturing groups you would need to find  in your code, and do an additional split
p36406
as(dp36407
g6
V335858
p36408
stp36409
a((dp36410
g2
(lp36411
VI think the problem is on this line:
p36412
aVYou commented out the semicolon by accident, prompting an unrelated parse error down the road
p36413
aVOn a somewhat related note, when your function returns a , you should not compare the result to  or
p36414
aVJust write  or  instead
p36415
as(dp36416
g6
V335858
p36417
stp36418
a((dp36419
g2
(lp36420
VYou are missing curly braces around the block of
p36421
aVWhen you have multiple statements in a block, you must put curly braces around all statements
p36422
aVUnlike some other programming languages such as Python, the indentation in Objective C is insignificant
p36423
aVAll grouping of statements in related blocks is done by curly braces
p36424
as(dp36425
g6
V335858
p36426
stp36427
a((dp36428
g2
(lp36429
VYou can do it like this:
p36430
aV(demo in SWI Prolog on ideone)
p36431
aVThe process of unification is recursive, you can nest names as deeply as you need for unifying with your facts
p36432
aVIn this case,  is nested inside  call to "extract" only the first element of the  pair
p36433
as(dp36434
g6
V335858
p36435
stp36436
a((dp36437
g2
(lp36438
VUse the  class
p36439
aVSet it to the first date, and then check if the current day of the week is Wednesday by calling
p36440
aVPerform this check in a loop, adding a day to the current date during each iteration
p36441
aVThis will never take more than seven steps, so you don't need to do anything fancier than that
p36442
as(dp36443
g6
V335858
p36444
stp36445
a((dp36446
g2
(lp36447
VBoth snippets that you describe are correct ways of using conditional compilation to enable or disable the debugging through a compile-time switch
p36448
aVHowever, your assertion that checking the debug flags at runtime "can be very inefficient, due to all the 'if' statements I should add to my code" is mostly incorrect: in most practical cases a runtime check does not influence the speed of your program in a detectable way, so if keeping the runtime flag offers you potential advantages (e
p36449
ag303
aVturning the debugging on to diagnose a problem in production without recompiling) you should go for a run-time flag instead
p36450
as(dp36451
g6
V335858
p36452
stp36453
a((dp36454
g2
(lp36455
VThe loop exits because you did not put parentheses around your condition
p36456
aVThis should teach you not to put the unnecessary  in your C/C++ conditions
p36457
aVYou can simplify your code quite a bit, though
p36458
aVFirst, observe that  equals the prior value of , so you can change your loop to
p36459
aVSecond, the interviewer was probably looking to see if you are familiar with this little trick:
p36460
aVUnlike your code that may take up to 1,000,000,000 operations to complete, the above always completes after twelve operations (a decrement, an increment, five shifts, and five s)
p36461
as(dp36462
g6
V335858
p36463
stp36464
a((dp36465
g2
(lp36466
VIt appears that  ignores the sizing requests of the  format specifier
p36467
aVHowever,  specifier works correctly:
p36468
aVThis prints
p36469
as(dp36470
g6
V335858
p36471
stp36472
a((dp36473
g2
(lp36474
VBefore you can start accessing data off a pointer, you need to allocate some memory first; otherwise, it's undefined behavior
p36475
aVYour current structure needs two levels of allocation - one for the pointer to , and another for the  itself
p36476
aVYou also need to add another level of dereference, because  works on pointers to s, not on pointer to pointers to s:
p36477
aVHere is a demo on ideone
p36478
as(dp36479
g6
V335858
p36480
stp36481
a((dp36482
g2
(lp36483
VC strings are not the best material to learn pointers, because they are implemented as pointers to
p36484
aVLet's use  instead:
p36485
aVThis works as expected
p36486
aVModifying strings in place is a lot harder, because you are forced to deal with memory management issues
p36487
aVSpecifically, the string into which you copy must have enough space allocated to fit the new string
p36488
aVThis wouldn't work with "nothing" and "something", because the replacement is longer by two characters
p36489
as(dp36490
g6
V335858
p36491
stp36492
a((dp36493
g2
(lp36494
VFormatting a number in an N-ary system requires two things: an alphabet, and an ability to obtain results of integer division + the remainder
p36495
aVConsider formatting a number in a base-26 system using the Latin alphabet
p36496
aVRepeatedly obtain the remainder  of division by 26, pick letter number , and add it to the front of the number that you are formatting
p36497
aVInteger-divide the number by 26, and use it in the next step of the algorithm
p36498
aVStop when you reach zero
p36499
aVFor example, if you print  in base-26, you can do it like this:
p36500
aV1234 % 26 is 12
p36501
aVAdd ; 1234/26 is 47
p36502
aV47 % 26 is 21
p36503
aVAdd ; 47 / 26 is 1
p36504
aV1 % 26 is 1
p36505
aVAdd
p36506
aV1 / 26 is zero; stop
p36507
aVSo  in base-26 is
p36508
aVTo convert back, start from the front, and sequentially subtract the designated "zero" ( in case of the above example) from each digit, like this:
p36509
aV- is 1
p36510
aVResult is
p36511
aV- is 21
p36512
aVResult is 1*26+21, which is 47
p36513
aV- is 12
p36514
aVResult is 47*26+12, which is 1234
p36515
as(dp36516
g6
V335858
p36517
stp36518
a((dp36519
g2
(lp36520
VBigDecimal decimal = new BigDecimal((9522 * 100 ) / total);
p36521
aVThis is not how you do operations on : by the time the  is constructed, the precision is gone, because the calculation  is done at compile time
p36522
aVThat's why the result is the same as with integers: in fact, the entire calculation is done in integers
p36523
aVHere is how you calculate with  objects:
p36524
as(dp36525
g6
V335858
p36526
stp36527
a((dp36528
g2
(lp36529
VThe right answer would be that this is undefined behavior due to lack of sequence point between expressions with side effects
p36530
as(dp36531
g6
V335858
p36532
stp36533
a((dp36534
g2
(lp36535
VYou're almost there: all you need to do is shifting the individual bytes into position before -ing them together
p36536
aVDon't forget to make your s hex for the desired output of
p36537
as(dp36538
g6
V335858
p36539
stp36540
a((dp36541
g2
(lp36542
VYou can replace a pointer with an integer, and create a single static array for all your  objects, like this:
p36543
aVThis approach is inspired by the Flyweight Pattern, although obviously it's used for a different purpose here
p36544
aVAn obvious downside to this is that you need to count your entries manually to avoid duplication
p36545
aVHowever, there is only one  object, so there's nothing else to create
p36546
as(dp36547
g6
V335858
p36548
stp36549
a((dp36550
g2
(lp36551
VAlthough you can use anonymous types or collections of objects of anonymous type locally with static typing, there is no way to return them from a function without losing the information about their static type
p36552
aVIf you cannot or for some reason prefer not to create a named class to hold the return data, you need to either return , or
p36553
aVBoth these approaches have their drawbacks:  will be slower than a comparable statically-typed object, while  would not let you do much with the data that you get back
p36554
aVThe best solution would be creating a named return type:
p36555
aVNow your query will look like this:
p36556
aVThe return type of your method would change to
p36557
as(dp36558
g6
V335858
p36559
stp36560
a((dp36561
g2
(lp36562
VThe point is that  is just the address of the array so I can assign it to a pointer
p36563
aVThat's not quite right: compiler converts the name of an array to a pointer that points to the array's initial element
p36564
aVThis happens automatically, without requiring a cast or an "address of" operator
p36565
aVHowever,  is not just the address, which is evidenced by taking its size with
p36566
aVThis should explain why the same is not true for  (i
p36567
ag630
aVbecause it is not so for arrays)
p36568
aVFor s, the "address of" operator  is mandatory:
p36569
aVdoo
p36570
aVx = 0; //why can't I use the dot
p36571
aVC has a different syntax for accessing s elements through a pointer: you need to use the  operator instead of a dot  operator
p36572
as(dp36573
g6
V335858
p36574
stp36575
a((dp36576
g2
(lp36577
VArray's elements are stored together in consecutive locations
p36578
aVThat is why knowing the address of the initial element is sufficient to know where the rest of the elements are
p36579
aVThe only trick is knowing how many elements the array has
p36580
aVThis is not passed along with the array, so you need to pass it separately
p36581
aVIt is not a concern for your program because you hard-coded it to eight, but in general if you pass an array as an argument, you also need to pass its size as a separate parameter:
p36582
aVAs far as the  calculation goes, this trick works only in the caller, where  is an array, not a pointer to the initial element of the array
p36583
aVAt this location the compiler knows that the size of the array is eight times the size of an , so dividing out the  gives you the number of elements in the array
p36584
as(dp36585
g6
V335858
p36586
stp36587
a((dp36588
g2
(lp36589
VThis happens because when you call  you get a list with a single instance of , not with four instances of /
p36590
aVIn general, for checking membership in sets of characters you may be better of with a :
p36591
as(dp36592
g6
V335858
p36593
stp36594
a((dp36595
g2
(lp36596
VI figure that this is an easy thing
p36597
aVIt's not easy
p36598
aVAt least not that easy
p36599
aVThe reason this is not allowed is best explained with an example
p36600
aVSuppose it was allowed to do the assignments like you suggest:
p36601
aVSince  is of type  and  is an , the compiler must allow the  call
p36602
aVBut that would put a continuation trigger into , a collection that has been created as a , which is definitely not allowed
p36603
aVYou have several choices as far as overcoming this goes
p36604
aVThe simplest one is treating  objects equally, differentiating only at the time of object creation
p36605
aVThis may be tricky, and in some instances it would require multiple dispatch
p36606
aVAnother option is making generic covers for getting and setting elements of :
p36607
as(dp36608
g6
V335858
p36609
stp36610
a((dp36611
g2
(lp36612
VDoes it make a difference which one I use
p36613
aVYes - in several ways
p36614
aVThe primary consideration is readability: by using an  you convey to the readers of your code your intention to insert and delete only at the ends, and not in the middle, of the container
p36615
aVThis is a very nice thing to know when you read someone else's code
p36616
aVA secondary consideration is the implementation of the container itself: unlike lists, which allocate and store their elements individually,  stores its elements in chunks to save space
p36617
aVThis may reduce the footprint of the container, and/or make it slightly faster
p36618
aVOn the flip side, there are potential inefficiencies when it comes to iterating through the entire queue
p36619
aVThe efficiency considerations, however, should not be a factor during your initial design, because it is a matter of optimization
p36620
aVI think that the best approach is to strive for best readability: use the container that conveys your intentions to the readers of your code in the cleanest possible way
p36621
as(dp36622
g6
V335858
p36623
stp36624
a((dp36625
g2
(lp36626
VThe precision of  and  is fixed by their size and the way the IEEE floating point types are implemented
p36627
aVThe number of decimal digits in the output, on the other hand, is a matter of formatting
p36628
aVYou are correct that typing the same constant over and over is a bad idea
p36629
aVYou should declare a string constant instead, and use its symbolic representation
p36630
aVUsing a symbolic representation would let you change precision in all places the constant is used without searching through your code
p36631
as(dp36632
g6
V335858
p36633
stp36634
a((dp36635
g2
(lp36636
VStarting with Java 5,  type is generic, meaning that it can have a type parameter
p36637
aVBy parameterized invocation of  the documentation means " with any kind of type parameters"
p36638
aVYou can find an example of it in the same document, e
p36639
ag303
aVthe "Example 9
p36640
ag837
aV1-2":
p36641
as(dp36642
g6
V335858
p36643
stp36644
a((dp36645
g2
(lp36646
VWhen you use square brackets  after a name in a function header, you tell the compiler that you are passing an array
p36647
aVmeans an array of integers
p36648
aVmeans an array of integer pointers
p36649
aVSince you pass an array of integers, the function signature should be either
p36650
aVor its equivalent
p36651
aVThe call should look like this:
p36652
aVNext, on the subject of  vs
p36653
aV: ampersand makes a pointer from an value expression that has an address, while an asterisk makes a value from a pointer expression
p36654
aVtakes a pointer, so you need to call it with either
p36655
aVor an equivalent
p36656
as(dp36657
g6
V335858
p36658
stp36659
a((dp36660
g2
(lp36661
VThe regex is rather simple:
p36662
aVThe first part says that  through  could be followed by an optional plus or minus; the second part allows a  by itself
p36663
aVI could loop through the array to accomplish this
p36664
aVYou could also use , to do it without a loop:
p36665
as(dp36666
g6
V335858
p36667
stp36668
a((dp36669
g2
(lp36670
VWhile technically dereferencing a  pointer is simply an undefined behavior, not a guaranteed crash, in practice it would crash with nearly absolute certainty:
p36671
as(dp36672
g6
V335858
p36673
stp36674
a((dp36675
g2
(lp36676
VIt means the same thing as
p36677
as(dp36678
g6
V335858
p36679
stp36680
a((dp36681
g2
(lp36682
VYou can do it like this:
p36683
aVThe idea is to use  creatively: starting with a list consisting of a single , examine the content of the list we've got so far at each stage of aggregation (the  statement in the lambda)
p36684
aVDepending on the last value, either continue the old run, or start a new one
p36685
aVHere is a demo on ideone
p36686
as(dp36687
g6
V335858
p36688
stp36689
a((dp36690
g2
(lp36691
V"Order statistics" is a fancy name for "K-th element of an N-element sequence sorted in ascending order"
p36692
aVThe rest of the slide simply illustrates the idea, explaining that 1-order statistics is the smallest element in a sequence, n-order statistics is the largest element,  order statistics is the median, and so on
p36693
as(dp36694
g6
V335858
p36695
stp36696
a((dp36697
g2
(lp36698
VYou can "borrow" Java's implementation of 's *:
p36699
aVThis function achieves a reasonable separation, and is among the most widely used hash functions out there
p36700
aV* which, as it turns out, Java in turn "borrowed" from Kernighan & Ritchie's book on C programming
p36701
as(dp36702
g6
V335858
p36703
stp36704
a((dp36705
g2
(lp36706
VThe new way is really a new syntax around the old
p36707
aVwhich requires an extra call of ; essentially, we're comparing a solution with a single dispatch and zero allocations to a solution with two dispatches, and possibly an allocation/deallocation
p36708
aVIf you do this comparison outside a tight loop, it wouldn't matter
p36709
aVBut if you do it in a really tight loop, perhaps while drawing something, you may see a slowndown
p36710
aVThat's why I'd stay with the old method of
p36711
as(dp36712
g6
V335858
p36713
stp36714
a((dp36715
g2
(lp36716
VLeaving aside the purpose for which you might want to declare such exotic array, it looks like the way the reflection produces the name of an array is recursive: first, it produces the name of array's element type, and then appends square brackets with the appropriate number of commas
p36717
aVis a 2D array of 1D arrays; the element type of the 2D array is , so the overall result is
p36718
aVHere is another illustration of the way the algorithm works:
p36719
aVis
p36720
aVI don't see a reason behind it other than the efficiency of implementation: as long as it is consistent, it does not matter if the syntax matches C# or not
p36721
aVAfter all, C# is not the only language in the
p36722
aVNET universe
p36723
as(dp36724
g6
V335858
p36725
stp36726
a((dp36727
g2
(lp36728
VNo, you cannot do that with an array
p36729
aVIn fact, inability to make array elements read-only is a major drawback of using arrays in situations when data could be modified externally
p36730
aVThe only approach to protect elements of your array is to encapsulate the array in a class that would check elements and indexes before performing modifications:
p36731
as(dp36732
g6
V335858
p36733
stp36734
a((dp36735
g2
(lp36736
VWhat am I doing wrong
p36737
aVThere are many things that you are doing wrong:
p36738
aVNaming a variable  is wrong, unless you assign a value that is truly a half of something to it
p36739
aVYour loop does not use the previous value of factorial
p36740
aVYou always multiply  by , and never change the
p36741
aVYou do not initialize  to
p36742
ag1971
ag1972
aVThe fact that your loop runs empty is the least of your troubles
p36743
ag1971
ag1971
ag1972
aVTo do it right, consider how you do it on paper: you start with , and then keep multiplying the previous result by numbers from  to
p36744
aVNow write the same algorithm as a C program: use  as your intermediate result, and  from the loop as your "current number between  and
p36745
as(dp36746
g6
V335858
p36747
stp36748
a((dp36749
g2
(lp36750
VI have some dictionary objects which doesn't change during application life time
p36751
aVWhen you mark a variable of Dictionary type , you prevent the replacement of the dictionary that you assign with another dictionary
p36752
aVYou do not make that dictionary read-only, in the sense that as soon as a caller gets his hands on that dictionary, he is free to change in any way that he wants, wiping it clean, or setting incorrect values (by mistake, no doubt)
p36753
aVIf you need to make a Dictionary read-only, consider borrowing an implementation of a read-only wrapper from this answer
p36754
aVIn general, the only advantage of adding a property on top of a variable, or having a  automatic property, over a  is your ability to perform additional checks in the setter, or adding some code in the getter (say, to collect access statistics or for logging)
p36755
aVThere are also implications to accessing the field through reflection
p36756
aVIt does not look like you are doing any of that, so exposing a readonly variable sounds appropriate and does not present additional risks
p36757
aVEDIT: (on using reflection) When you access object data through reflection, you must specify if you are accessing a property  or a field
p36758
aVIn contrast, when you write a C# program, you write , and the compiler figures out if it's a property or a field for you
p36759
aVIf you create a class that exposes a field , and later decide to replace it with a property , recompiling the code that refers to  directly is all it takes
p36760
aVHowever, if you wrote some code that accesses  by through the reflection API, that code would need to be rewritten, because the compiler would not be able to catch the change for you
p36761
as(dp36762
g6
V335858
p36763
stp36764
a((dp36765
g2
(lp36766
VYou can use the  operator:
p36767
aVYou do not need  when you check values of  variables
p36768
as(dp36769
g6
V335858
p36770
stp36771
a((dp36772
g2
(lp36773
VThe only way to persist data in a way that survives app reinstalls is to save it to the keychain
p36774
aVThis works, because keychain data may be shared across multiple applications; the rest of your application's data is removed on uninstall
p36775
aVIf you need a reliable way to tell the current time, the device must be connected to the internet
p36776
aVIn this case you would be able to check the current time using one of the time services through the NTP
p36777
as(dp36778
g6
V335858
p36779
stp36780
a((dp36781
g2
(lp36782
VIt looks like you can simplify your expression by "factoring out" the license type, and observing that the condition boils down to a much simpler
p36783
aVIf there are no license types other than , , and , you can throw away the second clause for the final condition of
p36784
aVEDIT: In general, when you have complex multi-part conditions like that, the best you can do is extracting common sub-expressions, and trying to reduce the number of conditions
p36785
aVThe fundamental issue is that you are trying to express in code which is "linear" a condition which has multiple dimensions; this "folding" results in code that is hard to read
p36786
aVOne way around this problem is "encoding" your condition in a table, like this:
p36787
aVNow you can use it in a condition like this:
p36788
aVThe advantage of this approach is that the conditions are "tabulated" for the reader of your program, and can be easily extended simply by adding new rows
p36789
aVThe disadvantage is that you can no longer run a query like that against an  source without bringing partial results into memory
p36790
as(dp36791
g6
V335858
p36792
stp36793
a((dp36794
g2
(lp36795
VThe first one may not get you the same data in case of multiple quoted strings: if the input data is, say
p36796
aVthe first expression will match the entire string, while the second one will match only the  portion
p36797
aVIn general, the second expression should be faster, because there is no backtracking
p36798
aVHere is a link to an article discussing this issue at length
p36799
as(dp36800
g6
V335858
p36801
stp36802
a((dp36803
g2
(lp36804
VNo, it would not be the same, because the first query may return duplicates, while the second query wouldn't
p36805
aVThis query, on the other hand, will return the same results as the  one:
p36806
aVThe order of the results may be different
p36807
as(dp36808
g6
V335858
p36809
stp36810
a((dp36811
g2
(lp36812
VI would suggest another way to approach this problem: there is absolutely nothing wrong with using string constants that contain Unicode symbols directly, for example
p36813
aVThe advantage is that the human readers of your program are going to see the symbol without looking it up in a table
p36814
aVThe disadvantage is that the program is not going to look correctly when viewed in some older text editors that do not support modern file encoding
p36815
aVFortunately, Xcode's editor is not one of them, so it shouldn't be a concern
p36816
as(dp36817
g6
V335858
p36818
stp36819
a((dp36820
g2
(lp36821
VThis expression means "the integer represents an even number"
p36822
aVHere is the reason why: the binary representation of decimal  is
p36823
aVAll odd numbers end in a  in binary (this is easy to verify: suppose the number's binary representation does not end in ; then it's composed of non-zero powers of two, which is always an even number)
p36824
aVWhen you do a binary  with an odd number, the result is ; when you do a binary  with an even number, the result is
p36825
aVThis used to be the preferred method of deciding odd/even back at the time when optimizers were poor to nonexistent, and  operators required twenty times the number of cycles taken by an  operator
p36826
aVThese days, if you do , the compiler is likely to generate code that executes as quickly as  does
p36827
as(dp36828
g6
V335858
p36829
stp36830
a((dp36831
g2
(lp36832
VWhen you use this list construct in Prolog
p36833
aVyou are splitting the list into a head and a tail
p36834
aVThe head is a single item (could be a list if the original list is a list of lists) and tail is the original list with the initial element removed
p36835
aVThat's why  is incorrect
p36836
aVYou need to do something like this:
p36837
as(dp36838
g6
V335858
p36839
stp36840
a((dp36841
g2
(lp36842
VThe basic approach to covering ranges of characters using regular expressions is to construct an expression of the form , where  is the first letter of the range, and  is the last letter of the range
p36843
aVThe problem is, there is no such thing as "The" Cyrillic alphabet: the alphabet is slightly different depending on the language
p36844
aVIf you would like to cover Russian version of the Cyrillic, use
p36845
aVYou would use a different range, say, for Serbian, because the last letter in their Cyrillic is , not
p36846
aVAnother approach is to list all characters one-by-one
p36847
aVSimply find an authoritative reference for the alphabet that you want to put in a regexp, and put all characters for it into a pair of square brackets:
p36848
as(dp36849
g6
V335858
p36850
stp36851
a((dp36852
g2
(lp36853
VI think the problem has to do with the use of aliases: once I added alias names to the tables of your query, the query ran and returned some values (link to your modified sqlfiddle):
p36854
as(dp36855
g6
V335858
p36856
stp36857
a((dp36858
g2
(lp36859
VNot all binary trees have numbers in them
p36860
aVYou can use a binary tree to represent things that exhibit tree structure, such as expressions
p36861
aVFor example,  can be represented as
p36862
aVIf you represent an expression like that, the in-order traversal would yield your "normal" infix notation of
p36863
aVbut a post-order traversal would yield a Reverse Polish Notation of the expression:
p36864
as(dp36865
g6
V335858
p36866
stp36867
a((dp36868
g2
(lp36869
VIn the Xcode, highlight the project in the Project Navigator, and select the target in the project tree
p36870
aVOpen the Summary page, and go to the Supported Interface Orientations section
p36871
aVUn-click the orientations that you do not want your application to support
p36872
aVIn the story board, choose your first view controller, go to the Attributes inspector, and set orientation to "Portrait" in the Simulated Metrics section
p36873
aVNow choose the second view controller, and set its orientation to "landscape"
p36874
aVIn the view controller code, implement
p36875
aVfor the first view controller, and
p36876
aVfor the second view controller
p36877
aVThis should fix the problem for you
p36878
as(dp36879
g6
V335858
p36880
stp36881
a((dp36882
g2
(lp36883
VI 'm sure I'm missing something super simple
p36884
aVYou are right
p36885
aVYou need to give your s an alias, and use that alias in the  clause
p36886
aVYou are also missing a  - a required part of a  statement that reads from a table:
p36887
aVI gave the results of your  an alias , and used it to "link up" the rows from the inner select to the rows of your outer select
p36888
as(dp36889
g6
V335858
p36890
stp36891
a((dp36892
g2
(lp36893
VThe reason the values are different is that all numbers except the first one cannot be represented exactly as a binary float value
p36894
aVIf you need exact representation of decimals, you need to use a non-standard library
p36895
as(dp36896
g6
V335858
p36897
stp36898
a((dp36899
g2
(lp36900
VThe problem in your code can be generally described as "memory management":
p36901
aVYou do not allocate memory for individual strings
p36902
aVYou are passing addresses of wrong things to
p36903
aVYour use of  allows for buffer overruns
p36904
aVYou declared  as an array of 100 strings, not as a single string
p36905
aVYou are passing  to the search function
p36906
aVTo fix this, you need to allocate the individual string dynamically using
p36907
aVYou can use a temporary buffer and then copy with , or pre-allocate 100 characters, and limit the  to it
p36908
aVHere is a portion of your program that needs changing:
p36909
aVThe rest would be just "points for style":
p36910
aVYou do not need a  after  in the search function
p36911
aVYou do not need to initialize  before the loop and in the loop
p36912
aVPrinting  at the beginning of a line is discouraged
p36913
as(dp36914
g6
V335858
p36915
stp36916
a((dp36917
g2
(lp36918
VYou can go through an array, and convert every element to lower case by calling
p36919
aVon it
p36920
aVHowever, this is grossly suboptimal for implementing case-insensitive search: a better approach would be keeping strings as-is, and employ  method for your search instead
p36921
as(dp36922
g6
V335858
p36923
stp36924
a((dp36925
g2
(lp36926
VI will avoid coding, because this is a valuable learning exercise
p36927
aVTry completing it yourself: once you do, you'll know that you understand recursion
p36928
aVTo be recursive, a method needs to call itself
p36929
aVImagine that a method
p36930
aVis already written for you
p36931
aVThis makes it easier to write the body:
p36932
aVGet all files in the directory, and print their names in the loop
p36933
aVGet all directories in the directory, and show their content at the next indentation level
p36934
aVYou need another loop for that
p36935
aVThe first step is a simple exercise in writing loops
p36936
aVThe second exercise becomes easy, too, because you can think of the  as pre-written
p36937
as(dp36938
g6
V335858
p36939
stp36940
a((dp36941
g2
(lp36942
VA call to sprintf must provide a buffer for the printed data, enough to fit the entire output
p36943
aVYou are passing a pointer to a single char, so the output clearly does not fit
p36944
aVA better way to convert a one-digit number to a string is as follows:
p36945
aVNote the single quotes around the first zero: the idea is to add the code of the zero character to the one-digit number
p36946
as(dp36947
g6
V335858
p36948
stp36949
a((dp36950
g2
(lp36951
VYou can do it in one pass of the original string: make a linked hash map, storing the counts of the character that you found so far
p36952
aVThen go through the map entries (it will be in insertion order, because it's a linked map) and stop when you see a count of one
p36953
as(dp36954
g6
V335858
p36955
stp36956
a((dp36957
g2
(lp36958
VYou cannot dereference the  pointer in a linked list without null-checking its content first
p36959
aVSpecifically, this expression
p36960
aVwill fail when  is
p36961
aVYou did check  for  in the header of the loop, but you also need to check  to avoid the crash:
p36962
as(dp36963
g6
V335858
p36964
stp36965
a((dp36966
g2
(lp36967
VThe instance method  is for encapsulation
p36968
aVIt lets subclasses override the method, providing a different implementation if they need to
p36969
aVFor example, a subclass may want to calculate the age based on the initial date and the current date, rather than storing it
p36970
aVIf you use an instance variable, subclasses would have no option to override ; if you add an instance method, then subclasses would be able to provide new implementation
p36971
aVAnother advantage is that you cannot write to : the users of your class can get the , but they cannot  it
p36972
aVWon't getter and setter for instance variable "age" be created with
p36973
aVThe  requires a property declaration, which is missing from the class
p36974
aVProperties are relatively new to the language, which may explain the reason why they are not used in the code that you found
p36975
aVThe current way of doing the same thing is declaring a property instead of an ivar and an accessor, and skipping the  altogether:
p36976
aVYou can write to  from inside the class by assigning , the backing variable created automatically; the users can read the value by using either  or  syntax
p36977
as(dp36978
g6
V335858
p36979
stp36980
a((dp36981
g2
(lp36982
VHere is what the declaration means:
p36983
aVis a  with a generic type parameter
p36984
aVThe class  must implement
p36985
aVThe type parameter  must implement
p36986
aVThe class for the type parameter  must have a no-argument constructor (that's what the  is for)
p36987
as(dp36988
g6
V335858
p36989
stp36990
a((dp36991
g2
(lp36992
VThis is compiler-dependent: you pass the locations for the headers in angular brackets, and the headers in double quotes are expected to be at the path rooted at the location of the current file; compilers also let you specify additional locations for these files
p36993
aVFor example,  has two options -  and  for specifying locations of headers specified as  and
p36994
aVIf  is not specified, the default locations of
p36995
aVare searched, as specified in the  documentation
p36996
as(dp36997
g6
V335858
p36998
stp36999
a((dp37000
g2
(lp37001
VYou are trying to do the same thing the Cocoa delegates do
p37002
aVDefine a formal protocol with the  method, and make all your  classes (or any other classes that you want to be registerable with the model) adopt that protocol
p37003
aVDefine the protocol:
p37004
aVAdopt the protocol:
p37005
as(dp37006
g6
V335858
p37007
stp37008
a((dp37009
g2
(lp37010
VThat's because they are in the same package:
p37011
aVThe  modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package
p37012
aV(Link to the documentation)
p37013
as(dp37014
g6
V335858
p37015
stp37016
a((dp37017
g2
(lp37018
VYou said that you would like to sort by , yet you compare
p37019
aVAdditionally,  is , so you cannot call methods on it
p37020
aVModify your code as follows to sort on the :
p37021
as(dp37022
g6
V335858
p37023
stp37024
a((dp37025
g2
(lp37026
VNo, you cannot do any checking like that: letting a value-returning function end without  is undefined behavior, the value "returned" in such cases is, well, undefined
p37027
aVYou need to watch out for warnings in Xcode, and fix them all
p37028
aVIn this particular case you should get a message that says
p37029
aVControl reaches end of non-void function
p37030
aVon the line of the closing curly brace of your non-void function
p37031
aVThis should be your signal to add a missing  to your code
p37032
as(dp37033
g6
V335858
p37034
stp37035
a((dp37036
g2
(lp37037
VThere is no "pass by reference" in C: that's C++
p37038
aVThe only option available in C to accomplish this is passing by pointer
p37039
aVYou also need  with these chains of : they compile, but they do not do what you want them to do:
p37040
aVYou need this:
p37041
as(dp37042
g6
V335858
p37043
stp37044
a((dp37045
g2
(lp37046
VThere is no way to implement classes or interfaces with reflection - in a certain sense, reflection is "read-only", letting you examine and manipulate what's already there
p37047
aVYou need to emit Java code in order to build an implementation at run-time
p37048
aVThere are several options available for that - check out this answer for some very good references
p37049
as(dp37050
g6
V335858
p37051
stp37052
a((dp37053
g2
(lp37054
VYou should change the condition to accommodate the minus, like this:
p37055
as(dp37056
g6
V335858
p37057
stp37058
a((dp37059
g2
(lp37060
VYou can use the other overload:
p37061
aVThis way of calling ensures that the invariant culture is being passed as the format provider to the , ensuring that you get dots for numbers, dollars for currency symbols, English for names of the months and days, and so on
p37062
as(dp37063
g6
V335858
p37064
stp37065
a((dp37066
g2
(lp37067
VThink about it this way:
p37068
aVwill increase with  in such a way that for any , no matter how large, you can find a value of  such that  is greater than
p37069
aVwill stay the same, no matter what  is
p37070
aVThis means that  is asymptotically better, i
p37071
ag630
aVfor some (perhaps very high) value of  the  will become slower
p37072
as(dp37073
g6
V335858
p37074
stp37075
a((dp37076
g2
(lp37077
VWhat does  do and why does it have  at the end of it
p37078
aVThe  creates an alias to a type to save you some typing, or to improve readability
p37079
aVIn this particular case, it creates an alias called  for the
p37080
aVWithout a , i
p37081
ag630
aVwith only this
p37082
aVyou would be forced to write  every time you need to declare a variable of that 's type
p37083
aVWith a  in place, you can write simply , and the compiler will interpret it as the  for you
p37084
as(dp37085
g6
V335858
p37086
stp37087
a((dp37088
g2
(lp37089
VOne way to calculate a good step would be to find the value of the most significant digit of the range's length (i
p37090
ag630
aVthe ), and use that as your step
p37091
aVTo calculate the value of the most significant digit use this simple formula:
p37092
aVThis takes a decimal logarithm of the difference, discards the fractional part, if any, and raises ten to the power of that logarithm
p37093
aVFor a difference of 7
p37094
aV2165, the calculation would return 1; for 721
p37095
aV65, it would return 100, and so on
p37096
aVOne shortcoming of this calculation is that the grid step for the  of 9
p37097
aV99 and the  of 1
p37098
aV001 would be the same
p37099
aVOne way to address this would be to calculate the number of grid lines you'd get for the step, and decrease the step ten times if the number of lines is insufficient (say, less than three)
p37100
as(dp37101
g6
V335858
p37102
stp37103
a((dp37104
g2
(lp37105
VWith each employee working exactly one shift, it is easy to prove that the greedy strategy produces an optimal solution
p37106
aVLet's pretend that your algorithm does not produce an optimal solution
p37107
aVThis means that there exists an employee  who could replace at least two employees  and  who were assigned supervisors for two back-to-back intervals
p37108
aVThis means that 's shift started at least as early as s, and ended as late or later that's
p37109
aVIf that were true, however, your greedy algorithm would have picked  over  to be the supervisor, which is a contradiction
p37110
aVThis means that your algorithm finds an optimal solution to the problem
p37111
as(dp37112
g6
V335858
p37113
stp37114
a((dp37115
g2
(lp37116
VYou have an option to define collation order at the time of defining your table
p37117
aVIf you define a case-sensitive order, your  operator will behave in a case-sensitive way; if you define a case-insensitive collation order, the  operator will ignore character case as well:
p37118
aVHere is a quick demo on sqlfiddle showing the results of collation order on searches with
p37119
as(dp37120
g6
V335858
p37121
stp37122
a((dp37123
g2
(lp37124
VI think you have a misunderstanding of how C strings work:
p37125
aVThey do not get initialized on declaration (so  must be assigned separately, or you get undefined behavior)
p37126
aVThey cannot be concatenated with a  operator (so  is invalid)
p37127
aVThe space for C strings needs to be managed explicitly (so you would either need to allocate your  in the automatic storage area, or add a  at the end)
p37128
aVThe easiest way of fixing your program is to guess how long the  is going to be, and use  to append data to it:
p37129
as(dp37130
g6
V335858
p37131
stp37132
a((dp37133
g2
(lp37134
VTo me, it looks like object tries to fit the object to a type at runtime (dynamic)
p37135
aVNot really: it simply exercises
p37136
aVNET's 's ability to store objects of any type
p37137
aVIn order to be , a variable should allow you to call anything without a cast, for example
p37138
aVIf you try to pull off the above trick with a "plain" , you would get an angry message from the compiler
p37139
aVThe use of , however, postpones complaining until runtime, at which point it may happen, or may not happen at all
p37140
aVBut then it allows me to add an "a" to x and now it recognizes it as a string
p37141
aVThat's "a piece of magic" the compiler does: it knows that  has a , and inserts the call for you automatically
p37142
as(dp37143
g6
V335858
p37144
stp37145
a((dp37146
g2
(lp37147
V is not thread-safe, so you need to add synchronization around concurrent writes, as well as around reads that might proceed concurrently with writes
p37148
aVThe fact that you are writing to different keys does not help much: the implementation may resize on adding a new key, invalidating all internal storage that has been allocated before
p37149
aVYou may get lucky if all the keys that you are planning to write to exist in the dictionary already, and no concurrent removals are going on
p37150
aVHowever, I would strongly recommend against this approach
p37151
as(dp37152
g6
V335858
p37153
stp37154
a((dp37155
g2
(lp37156
VI think that you misunderstood the suggestion to "disregard the app delegate
p37157
aVConsidering the application delegate's central location, it sometimes tends to become a "dumping ground" for everything shared
p37158
aVNeed a flag or two
p37159
aVThrow it into the app delegate
p37160
aVNeed a counter
p37161
aVNo problem, put it into the app delegate
p37162
aVThis is precisely the thing you should not be doing: storing the application state is something the model does; keep the app delegate out of it
p37163
aVI do not think that the advice is to throw away the generated code for the app delegate, though: you need it to manage your application's lifecycle
p37164
aVBut managing the lifecycle is the only thing for which you should be using your app delegate: your model classes need to be cleanly separated from it
p37165
as(dp37166
g6
V335858
p37167
stp37168
a((dp37169
g2
(lp37170
VThe problem is that you are trying to set the value of  after checking every single character in the original string
p37171
aVYou should do the conversion "on the side", one character at a time, and only then set the result into the
p37172
aVAs you go through the original string, start composing the output from an empty string
p37173
aVKeep appending the character in the opposite case until you run out of characters
p37174
aVOnce the output is ready, set it into
p37175
aVYou can make an output a , set it to an empty string , and append characters to it as you go
p37176
aVThis will work, but that is an inefficient approach
p37177
aVA better approach would be using a  class, which lets you change the string without throwing away the whole thing
p37178
as(dp37179
g6
V335858
p37180
stp37181
a((dp37182
g2
(lp37183
VI assume that you write to the , and you read at the
p37184
aVWhen the queue is maxed to the capacity, the  is always less than  by one
p37185
aVNow you need to copy the "tail" portion of the old queue to the tail position in the new buffer
p37186
aVLet's say the old size was , the new size is , and
p37187
aVThen you move forward by  positions the data from the  to  indexes, inclusive, and advance the  index by  positions
p37188
as(dp37189
g6
V335858
p37190
stp37191
a((dp37192
g2
(lp37193
VMost likely your program exits before it manages to write everything out to the console
p37194
aVTry adding new line to the output, like this:
p37195
aVWhen you write to , the data is not transfered to the screen right away, out of efficiency considerations
p37196
aVWriting to the screen is relatively slow, so the program prefers to do it in "bursts"
p37197
aVThe text is accumulated in a buffer until a special command is given to flush the buffer, or the buffer fills up
p37198
aVWriting out  forces a flush, so the output will appear on the screen before your program exits
p37199
as(dp37200
g6
V335858
p37201
stp37202
a((dp37203
g2
(lp37204
VI think that you are mixing up the way a singleton is implemented and the way the objects are serialized
p37205
aVWhile the static field which is often used to implement singletons indeed would not be serialized as part of serializing an instance, the instance itself can definitely be serialized
p37206
aVAll you'd need to do is to set its deserialized version back into the static field, which you would need to do manually in your code
p37207
ag1971
ag1972
aVPlease note that I'm not saying that serializing (or even implementing) a singleton is necessarily a good idea, all I'm saying is that it can be done
p37208
as(dp37209
g6
V335858
p37210
stp37211
a((dp37212
g2
(lp37213
VSince  is the same as , you can rewrite your query like this:
p37214
aVIn general, the  clause can be used only in the "projection" part of a ; you need to use the "regular" boolean expressions In the  clause
p37215
as(dp37216
g6
V335858
p37217
stp37218
a((dp37219
g2
(lp37220
VUnlike Java and C# which specify precisely when the side effects would take place, C prohibits the use of an expression with side effects before the next sequence point
p37221
aVNot only does your expression produce a different result in C, but it is also undefined behavior
p37222
as(dp37223
g6
V335858
p37224
stp37225
a((dp37226
g2
(lp37227
VYour regular expression is fine (almost), you are just using a wrong API
p37228
aVRemove the parts of the regexp that match up to the ending anchor , and change the call of  for a call of , and get the matches in a loop, like this:
p37229
as(dp37230
g6
V335858
p37231
stp37232
a((dp37233
g2
(lp37234
VJava's  is stable, meaning that the relative order of equal elements is not going to change
p37235
aVThis sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort
p37236
aVYou can use this property of the sorting algorithm to sort all your elements with a simple comparator:
p37237
aVThis will sort all items with non-empty names ahead of the items with empty names, leaving the relative order of both groups of objects unchanged within their respective group
p37238
aVIf your space constraints allow you to create a new array of , you can go for a simpler algorithm: go through the original array once, and make a count of non-empty items
p37239
aVThen create a new array, and make two indexes: , and
p37240
aVThen go through the original array one more time, writing non-empty objects to , and empty objects to
p37241
as(dp37242
g6
V335858
p37243
stp37244
a((dp37245
g2
(lp37246
VIt looks like you are preparing your view correctly, but you are not adding it to the view hierarchy
p37247
aVin the  code you need to add this line:
p37248
as(dp37249
g6
V335858
p37250
stp37251
a((dp37252
g2
(lp37253
VAny comparison with  is false -  and , , , and so on
p37254
aVYou cannot use  in an  list as well - it would be ignored
p37255
aVMoreover, two s are not even equal to each other
p37256
aVTo get the nulls, you need to ask for them explicitly, like this:
p37257
as(dp37258
g6
V335858
p37259
stp37260
a((dp37261
g2
(lp37262
VThe  lets you move the objects, as opposed to copying them, allowing for a potentially faster execution speed
p37263
aVThe savings may be even greater when you move a range of values
p37264
aVHowever, when you do move a range from a container, the container still holds the places that were once occupied by these values
p37265
aVYou need to resize the container manually to remove these placeholders if you want to get rid of them (you don't have to, in case you would prefer reusing these container spots for other elements)
p37266
aVOne way to do it is to call  on the same range that you moved out of the container
p37267
as(dp37268
g6
V335858
p37269
stp37270
a((dp37271
g2
(lp37272
VThis does not work because, unlike  iterators,  iterators are not random-access - they are sequential
p37273
aVYou need to use  on them:
p37274
aVIn general, it's a good idea to use "not equals" on all iterators when you are looking to cover the entire range, even when these iterators allow comparisons for  and
p37275
aVThere is also an argument in favor of using  in your regular  loops, too, because it gives you the strongest postcondition
p37276
as(dp37277
g6
V335858
p37278
stp37279
a((dp37280
g2
(lp37281
VKeep a reference to the displayed  in your app delegate
p37282
aVWhen you show the alert, set the reference; when the alert is dismissed,  out the reference
p37283
aVIn your app delegate's  or  method, call the  method on the reference to the alert view
p37284
aVThis would take care of dismissing it on pressing the "home" button
p37285
aVKeep in mind that  will be called for things such as phone calls, so you need to decide if you'd like to dismiss the alert in cases like that or if you should keep it up through the phone call
p37286
as(dp37287
g6
V335858
p37288
stp37289
a((dp37290
g2
(lp37291
VThe rules are simple:
p37292
aVDo not  any pointer for which you did not call
p37293
aVUse  for everything that you allocated with
p37294
aVUse  (no brackets) for everything that you allocated with  (no brackets)
p37295
aVBy following these rules you can see that only the deletions of  and  are valid:
p37296
aVand  have not been allocated with a
p37297
aVneeds a
p37298
aVand  are correct
p37299
as(dp37300
g6
V335858
p37301
stp37302
a((dp37303
g2
(lp37304
VThe empty struct is guaranteed to have its own address, but that's about it: you wouldn't spend time building it (after all, it's empty; there's nothing to build)
p37305
aVThe C++ idiomatic way of doing the same thing is using  (available in compilers compliant with the C++11 standard)
p37306
as(dp37307
g6
V335858
p37308
stp37309
a((dp37310
g2
(lp37311
VYour program is very fragile
p37312
aVIt expects the file of exactly 20 books: if fewer than 20 books are entered, you will get a null pointer exception in the printing loop; if more than 20 books are entered, you will get an array index out of bounds exception in the reading loop
p37313
aVYou should change the  loop with a simple , and add a limit to the number of books that you read from the file, like this:
p37314
aVThe program restructured as above is a lot less forgiving: rather than crashing when fewer than 20 books are entered, it would print as many entries as there are in the file
p37315
aVWhen more books are in the file than could fit in your pre-allocated array, books after the 20-th one are quietly ignored
p37316
as(dp37317
g6
V335858
p37318
stp37319
a((dp37320
g2
(lp37321
VCreate a  class, initialize it in the  for each player in the game, and then use  for the current player to do the adjustments
p37322
aVHere is a quick example:
p37323
aVCreate per-player instances of the , and put them into an array
p37324
aVAdd this declaration to your controller:
p37325
aVFrom this point on, you can refer to the current player by its index: zero for player one, one for player two
p37326
aVYou can add more players as needed, without changing the code
p37327
as(dp37328
g6
V335858
p37329
stp37330
a((dp37331
g2
(lp37332
VFor equilateral triangle, coordinates of the triangle's center are the same as the coordinates of the center of its incircle
p37333
aVLook up the formula for the incircle's center on Wikipedia:
p37334
aVSince , it is easy to see that the coordinates of the center of an equilateral triangle are simply
p37335
as(dp37336
g6
V335858
p37337
stp37338
a((dp37339
g2
(lp37340
VThis is absolutely not a bad practice, assuming that you can afford it, i
p37341
ag630
aVthe range of representable integers has enough extra values that you never need to use in real-life situations
p37342
aVFor example, if you needed a full range of unsigned bytes, including the 255, then giving 255 a new meaning of "unknown" would be a problem
p37343
aVIf 255 is never used for the "real" data, then you are free to assign it any meaning that you would like
p37344
aVWhat's wrong, however, is using special numbers throughout the code without assigning them a special name
p37345
aVFor example,
p37346
aVis unquestionably bad
p37347
aVYou should name all your special constants, and use only these names throughout your code:
p37348
as(dp37349
g6
V335858
p37350
stp37351
a((dp37352
g2
(lp37353
VI'm not sure what I need after the "=" in the for loop
p37354
aVThere's also a line missing above it:
p37355
aVNow the line with  would look like this:
p37356
as(dp37357
g6
V335858
p37358
stp37359
a((dp37360
g2
(lp37361
VSince this is most likely a learning assignment, I'll give you a hint: all UNICODE code points for the letters of the Latin alphabet are ordered alphabetically
p37362
aVIf the code of  is some number , then the code of  is , the code of  is , and so on; the code of  is
p37363
aVYou can subtract character code points in the same way that you subtract integers
p37364
aVSince the code points are alphabetized, the following calculation
p37365
aVproduces the sequence number of , i
p37366
ag630
aVIf you perform this calculation in a loop, you would get the result that you need
p37367
aVNote that the above formula works only with characters of the same register
p37368
aVIf your input string is in mixed case, you need to convert each character to lower case before doing the calculation, otherwise it would come out wrong
p37369
as(dp37370
g6
V335858
p37371
stp37372
a((dp37373
g2
(lp37374
VYou cannot meaningfully* add two addresses together in C, or multiply an address by a number or another address
p37375
aVThe two operations that are allowed are subtracting addresses that point to a contiguous block of memory, and adding a positive or a negative integer to an address
p37376
aVMultiplying or adding two addresses together does not make sense, because the result does not produce a meaningful address
p37377
aV* Think about it this way: since addresses are just numbers, and because math lets you multiply and add numbers freely, does not mean that the result of the mathematical operation would produce anything meaningful
p37378
aVFor example, you can certainly add the length of an airport runway, in inches, to the capacity of the fuel tanks of an airplane, in gallons
p37379
aVYou would get a number as a result of this strange calculation, but it would remain just a sequence of digits, devoid of any meaning in the physical world
p37380
as(dp37381
g6
V335858
p37382
stp37383
a((dp37384
g2
(lp37385
VIt looks like the answer is :
p37386
aVIn any language that supports two-dimensional arrays, you do not need to go through the thinking and figuring out the math: it's not worth being fancy where a simple lookup table would do the job:
p37387
as(dp37388
g6
V335858
p37389
stp37390
a((dp37391
g2
(lp37392
VYour syntax is correct, because you are getting a linker error, not a compiler error
p37393
aVThis error means that you are compiling your  without the source of the , or linking without a reference to
p37394
aVCompiling with this command should fix the error:
p37395
aV(I am assuming that the file with your  function is called )
p37396
as(dp37397
g6
V335858
p37398
stp37399
a((dp37400
g2
(lp37401
VThe simplest way would be to use a regular expression replacement of
p37402
aVfor an empty string :
p37403
aVHere is a link to a demo on ideone
p37404
as(dp37405
g6
V335858
p37406
stp37407
a((dp37408
g2
(lp37409
VIn general, you use a  loop in situations when you process a single collection without modifying it
p37410
aVIn situations when you have multiple collections, a loop with an index is more appropriate
p37411
aVIn your case, none of the three loops fits the description above:
p37412
aVThe first loop writes to the array
p37413
aVThe second and third loops process multiple sequences
p37414
aVYou can simplify your code quite a bit, but whenever you use two sets, a  loop is more appropriate (I assume that using LINQ is not an option)
p37415
aVJust to be complete, with LINQ in place you can avoid most loops:
p37416
as(dp37417
g6
V335858
p37418
stp37419
a((dp37420
g2
(lp37421
VA more idiomatic way in Objective-C is using a singleton instead of multiple globals
p37422
aVHere is how:
p37423
aVNow you can use your globals like this:
p37424
as(dp37425
g6
V335858
p37426
stp37427
a((dp37428
g2
(lp37429
VThe idea behind  is to let you skip the  keyword
p37430
aVUnlike C++, C does not let you do this:
p37431
as(dp37432
g6
V335858
p37433
stp37434
a((dp37435
g2
(lp37436
VThis is precisely the behavior of static variables declared inside function blocks
p37437
aVIt has been like that since the introduction of the feature in the C programming language
p37438
aVThe static declaration can also be applied to internal variables
p37439
aVInternal static variables are local to a particular function just as automatic variables are, but unlike automatics, they remain in existence rather than coming and going each time the function is activated
p37440
aV(K&R;, page 61)
p37441
aVThe static initializer is executed before the first invocation of the containing function; the initializer expression must be a compile-time constant
p37442
aVBeing static, the variable retains its last state across the invocations
p37443
as(dp37444
g6
V335858
p37445
stp37446
a((dp37447
g2
(lp37448
VHere is how you can do it:
p37449
aVThere were several small problems in your code:
p37450
aVThe  should be to , not
p37451
aVCasting  to  is prohibited, so you need to use the fact that s are
p37452
aVHere is a quick demo on ideone
p37453
as(dp37454
g6
V335858
p37455
stp37456
a((dp37457
g2
(lp37458
VThe  has been introduced in JDK 1
p37459
aV0, long before variadic functions were introduced into the language in Java 5
p37460
aVIn addition, efficiency is a concern: if you need two elements most of the time, it is much faster to pass them "inline", without creating an intermediate array to hold them
p37461
aVThis also avoids the costs of setting up a loop inside the implementation
p37462
as(dp37463
g6
V335858
p37464
stp37465
a((dp37466
g2
(lp37467
VYou need to go into arrays of higher dimensions - specifically, it appears that you are looking for a 3D array
p37468
aVThe two integers in your design that go into the name (i
p37469
ag630
aVand  in ) should be the first two indexes of your 3D array
p37470
aVNow accessing what has been  of your design would look like
p37471
as(dp37472
g6
V335858
p37473
stp37474
a((dp37475
g2
(lp37476
VYou need to check all elements, not just one:
p37477
as(dp37478
g6
V335858
p37479
stp37480
a((dp37481
g2
(lp37482
VYou can use this code to generate a compiled lambda expression
p37483
aVThis is equivalent to the following manually written code:
p37484
aVThis code also produces IL, but instead of you writing it manually, it lets 's  method do it for your
p37485
aVHere is a working demo on ideone
p37486
as(dp37487
g6
V335858
p37488
stp37489
a((dp37490
g2
(lp37491
VIf you'd like to keep rows from both tables, you do not need a join, you need a :
p37492
aVThe  option will keep duplicates, if any are found in both tables
p37493
aVIf you want duplicates removed, drop  from the
p37494
as(dp37495
g6
V335858
p37496
stp37497
a((dp37498
g2
(lp37499
VThe  method removes leading and trailing whitespace from a string
p37500
aVThe type of  is numeric - the very concept of whitespace does not apply to it
p37501
aVYou do not need to trim a  - it is always implicitly trimmed
p37502
aVIf you read a  that represents a , however, you may need to trim it
p37503
aVThe type of the variable needs to be , not , in order for the  method to apply
p37504
aVObviously, if you need to use the value as a  later on, you need to convert the string to a double, for example by calling the  method:
p37505
as(dp37506
g6
V335858
p37507
stp37508
a((dp37509
g2
(lp37510
VBut is there any case where adding trailing 0's to your floating point value declaration changes things
p37511
aVThe only "thing" that adding a zero would change is readability
p37512
aVThe resultant code would be exactly the same, because compilers do not care, but the constant with a zero in place would be easier to read by the human readers
p37513
as(dp37514
g6
V335858
p37515
stp37516
a((dp37517
g2
(lp37518
VThe most obvious and very common (mis)use of the  operator is deciding on special handling for a subclass:
p37519
aVThe use of  often indicates with near certainty that your design is missing a function in the base class and an override in the derived class
p37520
as(dp37521
g6
V335858
p37522
stp37523
a((dp37524
g2
(lp37525
VWhen you need multiple ways to order the same set of items, you have two choices:
p37526
aVStore both orderings, or
p37527
aVStore one ordering, and figure out the other one on the fly
p37528
aVStoring the second set of orderings is a way to pay with memory to save CPU cycles
p37529
aVIn your case, you have two orderings: the one implemented by the name-to-widget map, and the one for the drawing order
p37530
aVYou have three implementation choices:
p37531
aVStore widgets in the map (i
p37532
ag630
aVordered by name), and run a topological sort each time you need to figure out the drawing order - I assume here that the reason to order for drawing is to make sure that parents are drawn before children, implying the topological sort
p37533
aVStore widgets in a list by the drawing order, and run linear lookups to get widgets by their name - This may be a good option when you draw widgets a lot, but look up by name very infrequently
p37534
aVStore widgets in the map (i
p37535
ag630
aVordered by name), and make a separate list of either widgets or widget names, arranged according to the drawing order - This double-accounting spends memory to buy back the CPU cycles that you would otherwise waste for re-ordering in the drawing order
p37536
as(dp37537
g6
V335858
p37538
stp37539
a((dp37540
g2
(lp37541
VIt is
p37542
aVThe exact formula is
p37543
as(dp37544
g6
V335858
p37545
stp37546
a((dp37547
g2
(lp37548
VThis is because you have
p37549
aVstarts at zero, so it cannot be greater than the length of your string, no matter how short that string is
p37550
aVYou need to change the condition to
p37551
as(dp37552
g6
V335858
p37553
stp37554
a((dp37555
g2
(lp37556
VI know I wont be able to tokenize 2 strings at once
p37557
aVFortunately, you do not need to: make a function that takes a string, and parses it for three integer numbers using  (use a reentrant version, it's a lot safer)
p37558
aVNow you can call  twice, get two  values, and compare them side-by-side
p37559
ag1971
ag1972
aVIf you adopt a convention to always pad the numbers with leading zeros to a specific length, i
p37560
ag630
aVmake sure that you write  and not , you could substitute integer comparison with lexicographic one
p37561
as(dp37562
g6
V335858
p37563
stp37564
a((dp37565
g2
(lp37566
VThere are two observations about your code:
p37567
aVIt has nothing to do with hash tables, because there is no collision resolution
p37568
aVThe complexity of the code is indeed , but your analysis is incorrect: the timing of the second loop is , which is another way of saying , for the overall complexity of
p37569
as(dp37570
g6
V335858
p37571
stp37572
a((dp37573
g2
(lp37574
VThis works but this is undefined behavior because I'm deferencing past the last letter
p37575
aVNo, you are not dereferencing past the last letter
p37576
aVYou are taking an address of "one character past the last letter", but that is explicitly allowed by the standard
p37577
aVThis language is very common in the C++ standard:
p37578
aV24
p37579
ag839
ag1340
aV5: Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence
p37580
aVEssentially, any pointer  pointing one past the end of any array is considered valid
p37581
aVSame goes for iterators
p37582
aVTrying to read or write the  would indeed be wrong, though, but your code is not doing it: the standard library always interprets the ending pointer as "one past the end", so you are absolutely safe with
p37583
as(dp37584
g6
V335858
p37585
stp37586
a((dp37587
g2
(lp37588
VI think you have a slight misunderstanding of the difference between static and non-static classes vs
p37589
aVstatic and non-static members in Java: the difference between a static and non-static classes is that non-static classes have an implicit member holding a reference to the outer class, while a static class has no such implicit reference
p37590
aVBoth kinds of inner classes are shared among all instances; it's instances of inner classes that are tied to instances of their outer classes
p37591
aVThis is precisely what you want for iterators: each iterator is connected to the instance of the collection that it iterates, so it makes perfect sense to hold this reference implicitly by making the inner class non-static
p37592
as(dp37593
g6
V335858
p37594
stp37595
a((dp37596
g2
(lp37597
VThis happens because your method does not do anything in the invocations where you recurse down
p37598
aVYou should do a print in each invocation, but recurse down only when the  is not zero
p37599
aVThe algorithm (in pseudocode) should be as follows:
p37600
aVYou need a special case for , so that calling  would produce some output
p37601
as(dp37602
g6
V335858
p37603
stp37604
a((dp37605
g2
(lp37606
VWhen the value of  is non-zero, your  loop modifies locations beyond what's allocated
p37607
aVThese lines
p37608
aVwrite to locations from  to , but the allocated range is only from zero to
p37609
aVYou need to change the lines to
p37610
aVIn addition, since you increment by two, the last iteration may access a byte past the end of the buffer in case the  is odd
p37611
as(dp37612
g6
V335858
p37613
stp37614
a((dp37615
g2
(lp37616
VThe first rule of Prolog's syntax one needs to remember is that the case of the first letter in things that start in a letter matters: what looks like a variable in many other languages may actually be an atom in Prolog
p37617
aVIf an identifier starts in a lower case letter, it's not a variable, it's a so-called atom
p37618
aVUnlike variables, atoms are constant
p37619
aVThey cannot be bound to other values by means of unification, so  cannot possibly work
p37620
aVYou need
p37621
aVNow your logic works as expected:
p37622
aVwrites , while goals
p37623
aVboth fail
p37624
aVHere is a quick demo on ideone
p37625
as(dp37626
g6
V335858
p37627
stp37628
a((dp37629
g2
(lp37630
VThis error is given when you are trying to use a  that has been forward-declared, but not defined
p37631
aVWhile it is absolutely OK to declare and manipulate pointers to such structs, trying to dereference them is not OK, because the compiler needs to know their size and layout in order to perform the access
p37632
aVSpecifically, in your case the compiler does not know that  has , so
p37633
aVdoes not compile
p37634
aVYou need to include a definition of the  in the compilation unit where you define your  function to fix this problem
p37635
as(dp37636
g6
V335858
p37637
stp37638
a((dp37639
g2
(lp37640
VLeaving the Bobby Tables problem aside, you need to -check your variables before calling method on them:
p37641
aVBut before this code gets into production, you owe it to yourself to fix your SQL injection problem
p37642
aVOtherwise, your database is at grave risk of being wiped out by a "scriptie kid" next door
p37643
aVMake your SQL statement parameterized, and bind values to it, rather than embedding the values into the statement
p37644
aVFinally, it appears that you plan to store passwords in the database
p37645
aVDo not do that, even in a toy database that you do not plan to deploy to the Internet
p37646
aVThat's the worst thing that you can do to your customers, even the internal ones
p37647
aVRead this answer to fix this problem
p37648
as(dp37649
g6
V335858
p37650
stp37651
a((dp37652
g2
(lp37653
VIn general, you need to do manual storage allocation every time that the size of your data is not known at compile time
p37654
aVAlmost all situations fall into two categories:
p37655
aVYour program must read data from files/networks/user inputs etc
p37656
aV, and the exact amount of that data is not known at compile time, or
p37657
aVYour program must produce and store some output, and the exact amount of that output is not known to you at the time when you write your program
p37658
aVMany very common data structures assume an ability to allocate memory of arbitrary size, when the precise size is determined at runtime
p37659
aVDoing so lets the data structure "grow" and "shrink" dynamically, as the storage demands of your program change with the time and the amounts of data that it processes
p37660
as(dp37661
g6
V335858
p37662
stp37663
a((dp37664
g2
(lp37665
VSeveral considerations may apply, depending on whether the conditions are mutually exclusive or not
p37666
aVIf the conditions are mutually exclusive, the simplest solution is to group them by their return value:
p37667
aVIf the conditions are not mutually exclusive, you can group together only the ones that are next to each other in the testing order:
p37668
aVNote that although you do not need an  after a return, it is common in some shops to include an  anyway
p37669
aVThis is a matter of coding standardization which should be decided together by your coding team
p37670
aVIf you would like to get really fancy, you can create an array of blocks, test conditions in order, and return the value returned by the block
p37671
aVThis is by far the trickiest approach
p37672
aVIt would significantly impair readability, unless the conditions are structured in the same way, and the code makes sense to the reader
p37673
aVChains of s always make sense to a reader, so it is very hard to compete on readability with them
p37674
as(dp37675
g6
V335858
p37676
stp37677
a((dp37678
g2
(lp37679
VBut here it looks like the 'header' is a dummy node in the list and it points to the first and last nodes of the list
p37680
aVThat much is true
p37681
aVthus making the LinkedList a circular one
p37682
aVThat's not exactly true: structurally, the list is indeed circular, because the header "loops" it around
p37683
aVThat is only an implementation detail, a common trick that lets you avoid declaring two things ( and ) instead of one
p37684
aVThe fact that the same entry is used for both ends by itself is insufficient to make the list circular: there is no way for you to loop around the last node "from the outside", because the  prevents you from doing so
p37685
as(dp37686
g6
V335858
p37687
stp37688
a((dp37689
g2
(lp37690
VThe only case when having an application source would be a vulnerability is when the application itself has a serious flaw, for example
p37691
aVIs employing a security through obscurity technique,
p37692
aVEmbeds a secret in the body of the program,
p37693
aVMakes a mistake in implementing a well-known algorithm that opens up the implementation to an attack
p37694
aVEssentially, your product becomes more vulnerable when an attacker has its source, because the attacker can more easily spot your coding mistakes
p37695
aVHowever, it's coding mistakes that make your application crackable, not the fact that an attacker has your source code
p37696
as(dp37697
g6
V335858
p37698
stp37699
a((dp37700
g2
(lp37701
VYou need to chain your LINQ expressions, like this:
p37702
aVYou do not need a , because you need a single item, not a list; this is what  does
p37703
aVIf you need the last item, you need to order by the reverse of your original ordering condition
p37704
aVFor example, if you would like the entry with the latest modified date, you need to order by descending (as you did)
p37705
as(dp37706
g6
V335858
p37707
stp37708
a((dp37709
g2
(lp37710
VThis is just a warning, telling you that you are mixing generic and non-generic containers
p37711
aVThis is allowed, but the compiler can do a better job at type checking if you use generics everywhere in your code
p37712
aVTo fix this warning, you need to change
p37713
aVfor
p37714
aVin declarations inside
p37715
as(dp37716
g6
V335858
p37717
stp37718
a((dp37719
g2
(lp37720
VYou are missing a key requirement for the  to work: both ranges that you pass into it must be sorted
p37721
aVFrom the link that you posted:
p37722
aVConstructs a sorted range beginning in the location pointed by result with the set union of the two sorted ranges  and
p37723
aVThe code shown on the page simply performs a merge of two pre-sorted sequences
p37724
as(dp37725
g6
V335858
p37726
stp37727
a((dp37728
g2
(lp37729
VIf  does something non-trivial, calling it three times will be slower than making a single call and storing the result
p37730
aVNote that the two expressions are equivalent only if the function  is a "pure" function, meaning that it is free of side effects, and that it returns the same value for the same set of arguments
p37731
aVDuring the initial design and coding you should strive for the best readability
p37732
aVConsidering the overhead of method calls before profiling is a premature optimization
p37733
as(dp37734
g6
V335858
p37735
stp37736
a((dp37737
g2
(lp37738
VThis is a difference in the implementation: the iterator returned by the array list detects concurrent modifications even when it is positioned at the end, because it checks the length; iterators of the ,  and , on the other hand, do not detect this condition, because they check for being positioned at the end before checking for concurrent modification
p37739
aVThe documentation allows iterators not to throw on concurrent modifications, so both approaches are valid
p37740
aVDemo for the
p37741
aVDemo for the
p37742
as(dp37743
g6
V335858
p37744
stp37745
a((dp37746
g2
(lp37747
VThere is a standard trick for this situations: pass  along with the  into the call, and add a setter for the
p37748
aVThis would let you call a parameterless constructor, like this:
p37749
aVThe  has been modified in Java 5 to let you use it as a factory for the instances of that class
p37750
aVThe call of  is checked statically for type safety
p37751
aVThe addition of the interface  lets you call  method on the instances of  in a way that the compiler can check statically
p37752
aVWhen you construct , you need to pass the class being created, like this:
p37753
as(dp37754
g6
V335858
p37755
stp37756
a((dp37757
g2
(lp37758
VSplit the array on spaces using the , then go through the resultant tokens back-to-front, take the previous suffix, and prepend the current token to its front
p37759
aVIf there is no prior suffix, use an empty string:
p37760
aVThis prints
p37761
aVLink to a demo on ideone
p37762
as(dp37763
g6
V335858
p37764
stp37765
a((dp37766
g2
(lp37767
VThis line
p37768
aVdoes not do what you expect
p37769
aVYou probably meant
p37770
aVThe assignment is valid C, but instead of checking for equality, it sets  equal , and then checks the value of  for being zero
p37771
aVIf it is non-zero, the condition succeeds, regardless of the initial value of
p37772
aVIf the  is zero, then the condition fails, - again, regardless of the initial value of
p37773
aVThis is a very common mistake; many compilers issue warnings to alert you to the situation
p37774
as(dp37775
g6
V335858
p37776
stp37777
a((dp37778
g2
(lp37779
VThe simplest way to find out if the current locale is supported or not would be to add a special "test" string (say, ) to all five localizations that you support
p37780
aVThen a simple check will work:
p37781
as(dp37782
g6
V335858
p37783
stp37784
a((dp37785
g2
(lp37786
VYour lexicographic comparison (i
p37787
ag630
aVwhich word is earlier alphabetically) is correct
p37788
aVYour loop condition is incorrect, though:
p37789
aVwill always be true
p37790
aVYou should change it to
p37791
aVin which case the loop is going to stop upon reaching the word
p37792
aVIf you would like the case-insensitive comparisons, use  instead of , and  instead of
p37793
as(dp37794
g6
V335858
p37795
stp37796
a((dp37797
g2
(lp37798
VThe loops are repeated twice because their bodies are different:
p37799
aVThe loop inside the  constructor initializes the cards
p37800
aVThe loop inside  prints the cards
p37801
aVThe two methods do it in the same order, that's why the headers of the loops are identical
p37802
aVThe numbers are adjusted by one because in Java (as well as in C, C++, C#, and many other languages) array indexes are numbered from zero, rather than being numbered from one
p37803
aVThe constants in the cards program, on the other hand, are one-based, so you must subtract one from them to get the numbers aligned with the way the arrays are indexed
p37804
as(dp37805
g6
V335858
p37806
stp37807
a((dp37808
g2
(lp37809
VYou should use an  instead of an  in your condition
p37810
aVCurrently, your condition is always true, because  can be equal to only one of three constants, but not all three at the same time
p37811
as(dp37812
g6
V335858
p37813
stp37814
a((dp37815
g2
(lp37816
VTo get a position of an element in a vector knowing an iterator pointing to the element, simply subtract  from the iterator:
p37817
aVNow you need to check  against  to see if it is out of bounds or not
p37818
aVVector iterators behave in ways similar to array pointers; most of what you know about pointer arithmetic can be applied to vector iterators as well
p37819
as(dp37820
g6
V335858
p37821
stp37822
a((dp37823
g2
(lp37824
VYou need to switch the definitions around, so that  is known to the compiler at the time you use it in the declaration of
p37825
aVThis will compile:
p37826
as(dp37827
g6
V335858
p37828
stp37829
a((dp37830
g2
(lp37831
VYes, it is safe: the increment is atomic, and the local  cannot be altered by concurrent threads
p37832
aVYou can further simplify your code to eliminate the temporary variable altogether:
p37833
as(dp37834
g6
V335858
p37835
stp37836
a((dp37837
g2
(lp37838
V is reserved word in MySql (as in )
p37839
aVYou need to use quotes around it to use it as an identifier
p37840
aVBetter yet, consider renaming the field to not use a reserved word as an identifier
p37841
as(dp37842
g6
V335858
p37843
stp37844
a((dp37845
g2
(lp37846
VYou need to add an extra parameter  to the functions that refer to , and replace all references to  with
p37847
aVWhen you pass  to , it would heapify on the first four elements:
p37848
as(dp37849
g6
V335858
p37850
stp37851
a((dp37852
g2
(lp37853
VC++ offers a perfect solution for this - it's  (you need to include  to use it)
p37854
aVAn important point to remember about this function is that if you would like to go through all permutations of a range, the range must be sorted before you make the first call to , otherwise you are going to stop before exhausting all permutations
p37855
as(dp37856
g6
V335858
p37857
stp37858
a((dp37859
g2
(lp37860
VIf a certain piece of logic is repeated, you should put it in a separate method
p37861
aVThe placement of the method depends on the structure of your system, but generally you have three main options:
p37862
aVPut the logic into a helper class
p37863
aVPut the logic into a base class
p37864
aVPut the logic into an extension method
p37865
aVThe first option is the simplest, and requires minimal modifications: simply add a class with a static method, like this:
p37866
aVThe second method is the least flexible, because it requires your DTOs to inherit a common class:
p37867
aVThe third option is more flexible, because it uses an interface instead of a type:
p37868
as(dp37869
g6
V335858
p37870
stp37871
a((dp37872
g2
(lp37873
VThere are several things that you need to do:
p37874
aVMake sure that the columns that you search are indexed - You need an index on  and  (if you have other queries that query by date across locations or by locations across dates, you may consider defining separate indexes; otherwise, a single combined index will work)
p37875
aVStop converting the timestamp to a string - use the native data type for  and  in your query, or replace the condition with
p37876
aVThese two changes should make your query faster, especially the second one: currently,  forces the query optimizer into a full scan on everything that matches your location, or even a full table scan if there is no index on
p37877
aVAn indexed search should bring the number of records down to acceptable levels
p37878
aVThe final item to take on is : if the query speed after the first two modifications remains insufficient, change  to , and do the same change for the
p37879
aVThis may or may not work, depending on the types of  and
p37880
as(dp37881
g6
V335858
p37882
stp37883
a((dp37884
g2
(lp37885
VYou can use an array aggregate:
p37886
aVDemo on ideone
p37887
as(dp37888
g6
V335858
p37889
stp37890
a((dp37891
g2
(lp37892
VThe  should be
p37893
aVbecause you need to switch the arguments around
p37894
aVThis gives you the results that you want, yet it is not ideal, because the comparison function is not symmetric
p37895
aVAnyone reading this code would need to pay a lot of attention to what's goes on what side of the comparison to make sense of what you are doing
p37896
aVYour program would be more readable if you use member functions  and  from your , as opposed to range-based  and :
p37897
aVHere are the results of running this:
p37898
aVHere is a demo on ideone
p37899
as(dp37900
g6
V335858
p37901
stp37902
a((dp37903
g2
(lp37904
VIt sounds like a  would be entirely sufficient: it provides , , and an ability to add/remove from both ends (, , , and ), all at  cost
p37905
as(dp37906
g6
V335858
p37907
stp37908
a((dp37909
g2
(lp37910
VAs far as I know, there is no equivalent of , because SSE arithmetic operations are generally register-to-register or memory-to-register, but not register-to-memory
p37911
aVHowever, you can improve on your performance using the advise from the blog post that you linked
p37912
aVThe reason the trick failed to work for you is that you did not eliminate the dependency between the two instructions: the side effects of the  increment in  and  prevent the second pair of operations from starting at the same time
p37913
aVModify your loop as follows to get an improvement:
p37914
aVAfter the change, the operation on  becomes independent of the operation on
p37915
aVAccording to my wall clock estimates, I got about 28% improvement after this simple modification
p37916
as(dp37917
g6
V335858
p37918
stp37919
a((dp37920
g2
(lp37921
VThe  type is not an equivalent of the 3D array type; it is an equivalent of a 1D array type:
p37922
aVThe problem with arrays of higher ranks is that in order to index into a 2D, 3D, etc
p37923
aVarray the compiler must know the size of each dimension except the first one in order to calculate the offsets from the indexes correctly
p37924
aVTo deal with 3D arrays, define a 2D element, like this:
p37925
aVNow you can do this:
p37926
aVDemo on ideone
p37927
as(dp37928
g6
V335858
p37929
stp37930
a((dp37931
g2
(lp37932
VHowever, when I delete a cell, that drawing drops to the cell below it
p37933
aVThis is the key observation: it indicates to me that at the time the redraw is happening, the model (i
p37934
ag630
aVyour ) has not been updated yet
p37935
aVWhen a cell at a certain row is deleted, the  for the corresponding day needs to be updated to remove the corresponding row from the
p37936
aVIf this does not happen, the data for the deleted task would influence the drawing of a cell at the next index, thus the visuals wold appear to "drop" by one row
p37937
aVFrom your description it sounds like this is precisely what is happening
p37938
aVYou need to make sure that by the time the table is refreshed (or the notification of a cell deletion is sent to the ) the model has been updated already to not have the row being deleted
p37939
aVThis way the table visuals would update as you expect them to
p37940
aVNot directly related to the problem, but if you create an array
p37941
aVyou can replace the long chain of s with
p37942
aVThe other problem in your code is that every time that you call , a new  is added
p37943
aVAs you scroll up and down, reused cells accumulate new layers without ever getting rid of the previously added ones
p37944
aVYou need to change your code to add the gradient layer only once, and then reusing the existing one inside your  method
p37945
aVFor example, you can add the layer in the designated initializer of the , assigning it to  instance variable, and adding it to the layer hierarchy once
p37946
aVFrom then on,  would change the existing , rather than creating new ones each time
p37947
as(dp37948
g6
V335858
p37949
stp37950
a((dp37951
g2
(lp37952
VI am assuming that you are not using ARC (the question would not be interesting then)
p37953
aVIn your code, you do need to send  to all of your blocks:: although  retains objects placed into it, and releases objects when the array itself is released, the objects that you add already have a retain count of , because  method gives you an object with a retain count of
p37954
aVThat is why you need to follow  with  before adding your block to the array, like this:
p37955
as(dp37956
g6
V335858
p37957
stp37958
a((dp37959
g2
(lp37960
VWhen you forward-declare a class, you can make pointers and references to it, but you cannot make members of the type of forward-declared class: the full definition of  is needed to decide the layout of the outer class (i
p37961
ag630
aV), otherwise the compiler cannot make a decision on the size and the structure of
p37962
aVThis is allowed, though:
p37963
aVThe reason the pointers and references to forward-declared classes are allowed is that the sizes of pointers and references do not depend on the structure of the class to which they point (or which they reference)
p37964
as(dp37965
g6
V335858
p37966
stp37967
a((dp37968
g2
(lp37969
VThe problem is that for some reason you execute the update in a loop for every record that the reader finds
p37970
aVNaturally, the reader would find every single last name that you have in the table, so the update is going to change every single record
p37971
aVYou need to remove the loop, remove the reader, and change the update command to use the last name from one of the entry boxes on the screen:
p37972
aVOf course this does not let you update the last name: for that you need to supply some sort of an independent student ID, and use it in the  clause of your  instead of the last name
p37973
as(dp37974
g6
V335858
p37975
stp37976
a((dp37977
g2
(lp37978
VThe simplest way would be populating a  with the arguments that you would like to pass, and then calling  on it before the call to your vararg method
p37979
aVcan grow dynamically, letting you accommodate as many params as you need
p37980
aVHere is a hypothetical example that passes an array with seven arguments:
p37981
as(dp37982
g6
V335858
p37983
stp37984
a((dp37985
g2
(lp37986
VYou are almost there: the type of the  should be , not :
p37987
aVTrying to pass  to  causes the error that you see
p37988
as(dp37989
g6
V335858
p37990
stp37991
a((dp37992
g2
(lp37993
VThis is relatively straightforward: you need to determine how many times each of the two nested loops executes, and considering the complexities together
p37994
aVThe outer loop is a trivial  loop; it executes  times
p37995
aVThe inner loop requires a little more attention: it keeps subtracting  from  until it gets to zero or goes negative
p37996
aVIt is easy to see that it takes  iterations of the  loop to subtract  from
p37997
aVSince  is initially set to , the total time taken by the inner loop is
p37998
aVThe total is, therefore, a sum of  squared, for  between  and
p37999
aVWolfram Alpha tells us that the answer to this is
p38000
aVThis expands to  polynomial, which has the complexity of
p38001
as(dp38002
g6
V335858
p38003
stp38004
a((dp38005
g2
(lp38006
VHow do I move backwards in the (singly) linked list
p38007
aVYou don't
p38008
aVThe trick to reversing one list into another is inserting at the head, rather than at the back, of the target list
p38009
aVYou need to traverse your original list in the regular way by following the  pointers, but rather than adding elements to the end of the target list, create a new node, and replace the header of the target with it
p38010
aVHere is a step-by-step illustration:
p38011
as(dp38012
g6
V335858
p38013
stp38014
a((dp38015
g2
(lp38016
VReturning a temporary variable is perfectly fine: it will get copied back to the caller, and the original one will be deallocated
p38017
aVIt becomes an issue only when the class is not managing its resources properly
p38018
aVThe reason your solution has a problem is because it does not return a copy, but returns a reference to a local variable , which is undefined behavior
p38019
aVTo fix the problem, you should change your post-increment/decrement operators to
p38020
aVand
p38021
aVNote that having to copy is a major reason behind a widely circulated advise to prefer pre-increment/decrement operators on iterators to their post-increment/decrement counterparts
p38022
as(dp38023
g6
V335858
p38024
stp38025
a((dp38026
g2
(lp38027
VYou are doing it the other way around: it's not you who should call , it's the implementation of the  method that does it
p38028
aVWhat you need to do in your code is calling
p38029
aVThis would unbundle the NIB, and call your  initializer, and give you back a view with all the outlets connected
p38030
as(dp38031
g6
V335858
p38032
stp38033
a((dp38034
g2
(lp38035
VThe compiler is right: although the enumerations  and  are defined in classes connected through inheritance, the enumerations themselves are not considered related
p38036
aVThey just happen to have the same unqualified name, which means nothing to the compiler: as far as the compiler is concerned, the two enum types are unrelated
p38037
aVIf you think about the way the enums are implemented under the hood, this makes sense: despite being strongly typed, the enums remain small integral constants
p38038
aVSince the two are unrelated,  would have the same value as , and there would be nothing at runtime letting you distinguish between the two values
p38039
aVBesides dumping all enumeration values into the  of the base class (which kills opportunities to extend outside your own library) there is little you can do: C++ enumerations do not support inheritance, and are generally not very flexible
p38040
as(dp38041
g6
V335858
p38042
stp38043
a((dp38044
g2
(lp38045
VSince  is , the expression
p38046
aVis the same as
p38047
aVTherefore you do not need a call of : you can cast to  by casting to , like this:
p38048
as(dp38049
g6
V335858
p38050
stp38051
a((dp38052
g2
(lp38053
VWhy C++ do not understand classes in different files without a header file
p38054
aVWhy should it
p38055
aVThere is no convention requiring file names to be named a certain way, or contain a single public class per file
p38056
aVYou are free to put entire class hierarchies in a single header file, as long as it makes sense logically
p38057
aVFor example, the  header does not contain anything called , but the name is very intuitive
p38058
aVFinally, there is no requirement in C++ for things to be inside classes or class templates
p38059
aVYou can have files full of declarations of namespace-level C-style functions
p38060
aVThere is no reasonable naming convention to put in place in order to support files of this nature
p38061
aVThe  directive solves this problem, and gives you the flexibility to name your files the way you want
p38062
as(dp38063
g6
V335858
p38064
stp38065
a((dp38066
g2
(lp38067
VUnless  is of type of the class that hosts it and returns , there is no way that you could avoid an intermediate variable
p38068
aVOf course you can adopt a fluent syntax, and make your  return the object, but that is not a native idiom to C#
p38069
aVNow you can do this:
p38070
as(dp38071
g6
V335858
p38072
stp38073
a((dp38074
g2
(lp38075
VThere is no standard way of computing a hash on a pair
p38076
aVAdd this definition to your file:
p38077
aVNow you can use it like this:
p38078
aVThis works, because  defines equality
p38079
aVFor custom classes that do not provide a way to test equality you may need to provide a separate function to test if two instances are equal to each other
p38080
aVOf course this solution is limited to a pair of two integers
p38081
aVHere is a link to an answer that helps you define a more general way of making hash for multiple objects
p38082
as(dp38083
g6
V335858
p38084
stp38085
a((dp38086
g2
(lp38087
VThe  branch of your code does not add the  image to the cell
p38088
aVYou should change your code to add the  in the constructor of the cell, so that in the  you'd have to set the image, rather than adding subviews
p38089
aVAdd the  to your , make it private, and provide a property for the  to use:
p38090
aVNow your  would use  instead of allocating the new  all the time
p38091
aVThis would avoid adding the image multiple times:
p38092
as(dp38093
g6
V335858
p38094
stp38095
a((dp38096
g2
(lp38097
VThe  is a , i
p38098
ag630
aVa value type
p38099
aVIt is passed around by value, which is another way of saying "copying"
p38100
aVIf you assign its fields (e
p38101
ag303
aVlongitude) all that would do is modifying a copy; the original  inside your  would remain intact
p38102
aVThat is why the property is not assignable
p38103
aVTo fix this, you should add separate properties for latitude and longitude, and use them instead:
p38104
aVNow your XML parser code can do this:
p38105
as(dp38106
g6
V335858
p38107
stp38108
a((dp38109
g2
(lp38110
VIf you would like to build the markup for HTML table around the list of fruit, you should put the part that does the markup around each individual item into the loop as well:
p38111
as(dp38112
g6
V335858
p38113
stp38114
a((dp38115
g2
(lp38116
VThis program has undefined behavior, because you are returning a pointer to a local
p38117
aVYou need to allocate the  array with  in order to fix the problem:
p38118
aVOf course now you are fully responsible for releasing all that -ed memory in your , to avoid memory leaks (you were already on the hook for that with your implementation; now you simply need to add the third  to the caller)
p38119
aVThe discrepancies that you see are most likely due to the differences of stack management with and without a / block
p38120
aVIt appears that without / the data in the local remains available for you to print, even though it is no longer legal to reference it after the return of the  function
p38121
as(dp38122
g6
V335858
p38123
stp38124
a((dp38125
g2
(lp38126
VThe simplest way of doing this would be a sequence of  statements:
p38127
aVAn advanced way would be to define an interface for your operators, and putting the instances in a  container:
p38128
aVWith a map initialized like this, you can perform calculations as follows:
p38129
as(dp38130
g6
V335858
p38131
stp38132
a((dp38133
g2
(lp38134
VYou can do it like this:
p38135
aVAs you can see, the syntax gets a little heavy at times, so it may make sense to define functions for accessing individual coordinates off a pointer to the structure:
p38136
aVNow your initialization routine would change to more readable
p38137
as(dp38138
g6
V335858
p38139
stp38140
a((dp38141
g2
(lp38142
VNo,  expects a property that can be determined by looking at one instance, and one instance only
p38143
aVHowever, there is a relatively straightforward solution: you can use a Disjoint-Set Data Structure (which is a little more than a glorified linked list), and its associated  algorithm
p38144
aVThe whole algorithm can be coded up in a few dozen lines, and is relatively simple to understand and debug
p38145
aVGive your rectangles sequential numbers, and run your intersection algorithm on each pair of rectangles
p38146
aVWhen you detect an overlap, perform set union on the corresponding disjoint set structures
p38147
aVWhen you are done, each member will point to the "root" number for its set
p38148
aVYou can use these root numbers to group by the list in LINQ
p38149
as(dp38150
g6
V335858
p38151
stp38152
a((dp38153
g2
(lp38154
VThe reason the recursion is infinite is a little obscure: the  cannot be represented exactly in
p38155
aVWhen you add  to  ten times, you do not get a  - you get a number that's close to , but a little greater than it
p38156
aVThat number does not divide your target evenly, so the recursion goes on to , , and so on, with no end
p38157
aVThe reason is the same why this loop never stops (try it
p38158
aV:
p38159
aVUsing  in place of  would fix the problem, because  would be represented exactly
p38160
aVOf course it would still print a wrong message (the  is hard-coded, even though  could be an entirely different number in the invocation when the remainder becomes zero)
p38161
as(dp38162
g6
V335858
p38163
stp38164
a((dp38165
g2
(lp38166
VTo match any number of comma-separated groups, you can use this expression:
p38167
aVThe data portion is matched by this expression:
p38168
aVIt matches zero or more groups of characters that start in comma, and followed by any number of characters other than a comma or an asterisk
p38169
aVOnce a comma or an asterisk is reached, the expression engine checks if it's a new value or the check sum at the end
p38170
aVIf the check sum does not allow lowercase letters, replace  with
p38171
as(dp38172
g6
V335858
p38173
stp38174
a((dp38175
g2
(lp38176
VSince the name of the file is hardcoded to , the file must be in the same folder as your executable
p38177
aVIf the location of the file is not going to change, you can hardcode full path:
p38178
aV(note the doubled backslashes: that's for the C++ compiler to treat them as regular slashes)
p38179
as(dp38180
g6
V335858
p38181
stp38182
a((dp38183
g2
(lp38184
VThe formula raises the differences between the input numbers to the third degree, so if the differences have roughly three digits, you should be careful about overflowing an , which has nine digits, plus the first digit can go up to 2
p38185
aVonce you overflow an , you start seeing negative numbers as a result of multiplying positive ones, so the rest of your calculations becomes incorrect
p38186
aVTo improve the range, use 64-bit integers (i
p38187
ag630
aV) for your intermediate results
p38188
as(dp38189
g6
V335858
p38190
stp38191
a((dp38192
g2
(lp38193
VAlthough  is a ,  is not: it is a single character from the , its initial one
p38194
aVYou cannot compare it to an empty string, but you can compare the entire middle name, like this:
p38195
aVA better way to see if a string is empty is to use the  method of  for it:
p38196
as(dp38197
g6
V335858
p38198
stp38199
a((dp38200
g2
(lp38201
VTemplate parameters do not necessarily need to be type names: they can be numbers as well
p38202
aVFor example,  takes a parameter of type  for the array size
p38203
aVIn your case, the class template takes a parameter of type , which is entirely OK
p38204
aVHere is an example of how you can use such a parameter:
p38205
as(dp38206
g6
V335858
p38207
stp38208
a((dp38209
g2
(lp38210
VTry this instead:
p38211
aVEdit: (in response to the "not supported exception")
p38212
aVYou can try this alternative to see if the backend supports it:
p38213
as(dp38214
g6
V335858
p38215
stp38216
a((dp38217
g2
(lp38218
VYou can do this:
p38219
aVDemo on ideone
p38220
as(dp38221
g6
V335858
p38222
stp38223
a((dp38224
g2
(lp38225
VYou can define a set of integers, add the desired values to it, and then use the find method to see if the value in question is in the set
p38226
as(dp38227
g6
V335858
p38228
stp38229
a((dp38230
g2
(lp38231
VI think that the interviewer was looking for a solution that performs reading/regex checking in parallel with writing the output
p38232
aVIf you set up a work queue that you fill asynchronously by reading and filtering, and put writing in a separate thread, then the combined process would take five seconds per line, starting with the second line
p38233
aVThe assumption here is that reading, parsing, and writing can happen independently of each other
p38234
aVIn this case, you can be reading line 2 while line 1 is being written: you need only four seconds to read and apply your regex, and you've got a whole five seconds before the writer is ready for the second line
p38235
aVThe writing remains your bottleneck, but the whole process gets sped up by some 44%, which isn't bad
p38236
as(dp38237
g6
V335858
p38238
stp38239
a((dp38240
g2
(lp38241
VThe error indicates that the value of  that you pass to  is greater than or is equal to the number of elements in the list
p38242
aVChange your code as follows to avoid the exception:
p38243
aVIn general, the error means that something is wrong with your indexing scheme: list and array indexes in Java start at zero, and end at , inclusive
p38244
aVIf passing  triggers the exception, but passing  is OK, then the list has only two elements - at indexes  and
p38245
as(dp38246
g6
V335858
p38247
stp38248
a((dp38249
g2
(lp38250
VIf you do not want to treat two  strings as equal to each other, your code is optimal
p38251
aVIf, on the other hand, you want to treat  values as equal to each other, you can use
p38252
aVfor a more "symmetric" approach that also handles  values
p38253
as(dp38254
g6
V335858
p38255
stp38256
a((dp38257
g2
(lp38258
VIt looks like you have switched around the line with the loop header and the loop body:
p38259
aVshould be
p38260
aVCurrently, your code uses  before it gets declared, and sorts ten times; neither of these two things makes sense
p38261
aVA very good habit to learn early on is placing curly braces around bodies of all control statements, even when the body is a single line
p38262
aVThis would help you avoid simple errors like that by visually pairing control structures with the code that they control
p38263
as(dp38264
g6
V335858
p38265
stp38266
a((dp38267
g2
(lp38268
VThere is a third alternative supported by Objective C for encapsulating functionality that does not need implicit access to instance variables - it is using "plain" C functions
p38269
aVUnlike class functions, "plain" C functions do not use virtual dispatch, which may be important in vary tight loops
p38270
aVNote that class methods provide more functionality than, say,  methods of Java, C++, and C#: they support overriding, letting class method in base classes use more specific implementations in derived classes
p38271
as(dp38272
g6
V335858
p38273
stp38274
a((dp38275
g2
(lp38276
VI think there is a little problem with your check of collisions in the diagonals: you've got 15 diagonals going each way (including the very short one-square diagonals in the corners), while your code checks only seven of each due to the  and  conditions
p38277
aVHere is how you can simplify the checks and make them faster with the use of three boolean arrays: you've got 8 rows, 15 ascending diagonals, and 15 descending diagonals:
p38278
aVInitially, there are no queens in any of these rows/diagonals
p38279
aVAs you go through the elements of , do this:
p38280
as(dp38281
g6
V335858
p38282
stp38283
a((dp38284
g2
(lp38285
VThe reason why you do not see the  is that you are calling a wrong initializer: this line
p38286
aVdoes not invoke the  initializer that does all the work initializing your  view
p38287
aVYou need to change the call to
p38288
aVand put the desired coordinates of the frame in place of the  above
p38289
as(dp38290
g6
V335858
p38291
stp38292
a((dp38293
g2
(lp38294
VBoth sources are sort of right: on one hand, due to the implementation details of the Interface Builder, the order in which you add items to  will be maintained on retrieval; on the other hand, you should avoid making use of that ordering in your code, because there is no way to check this order
p38295
aVImagine taking over someone else's project
p38296
aVIf you see a loop over an , observe that the order of iteration matters, and decide to check what that order is or force the new order, you would have to remove and re-add the controls to your outlet collection
p38297
aVThat is why you should treat your  elements as unordered
p38298
aVIf it is necessary to maintain a specific order, copy the elements into an , sort them on some known property, and then iterate the copied collection
p38299
as(dp38300
g6
V335858
p38301
stp38302
a((dp38303
g2
(lp38304
VWhen you define variables or constants outside a function, they are placed in the global scope
p38305
aVLinker resolves global references, and it complains when it finds the same name more than once
p38306
aVTo give the constants a scope of their compilation unit (i
p38307
ag630
aVthe file where they are defined) add  in front of their definitions:
p38308
aVThis way all functions and methods inside the same file will have access to , but the name would remain in the scope of the file
p38309
aVEssentially,  "hides" the the name from the linker
p38310
as(dp38311
g6
V335858
p38312
stp38313
a((dp38314
g2
(lp38315
VEach loop requires four actions:
p38316
aVPreparation (once per loop)
p38317
aVChecking of the stopping condition (once per iteration)
p38318
aVExecuting the body of the loop (once per iteration)
p38319
aVAdjusting the values used to determine if the iteration should continue (once per iteration)
p38320
aVwhen you have one loop, you "pay" for items 1, 2 and 4 only once; when you have two loops, you "pay" for everything exactly twice
p38321
aVAssuming that the order of invoking the two functions is not important, the difference will not be noticeable in most common situations
p38322
aVHowever, in very uncommon situations of extremely tight loops a single loop will take less CPU resources
p38323
aVIn fact, a common technique of loop unwinding relies on reducing the share of per-iteration checks and setup operations in the overall CPU load during the loop by repeating the body several times, and reducing the number of iterations by the corresponding factor
p38324
as(dp38325
g6
V335858
p38326
stp38327
a((dp38328
g2
(lp38329
VYour loop assigns the square of the number to the result in a loop, and exits right away
p38330
aVYou need to change it so that the result is repeatedly multiplied by numbers from 1 to N, inclusive
p38331
aVAssign 1 to factorial, and multiply it by counter inthe loop:
p38332
aVDon't forget to start your counter at 1
p38333
as(dp38334
g6
V335858
p38335
stp38336
a((dp38337
g2
(lp38338
VIt appears that you have an extra comma after the last line:
p38339
aVRemoving it should fix the problem (link to a demo on sqlfiddle)
p38340
as(dp38341
g6
V335858
p38342
stp38343
a((dp38344
g2
(lp38345
V and other collections cannot contain  values
p38346
aVWhen  must store a , a special value  is stored
p38347
aVCompare the value at  to  to determine if the corresponding value is  or not
p38348
as(dp38349
g6
V335858
p38350
stp38351
a((dp38352
g2
(lp38353
VIn order for the  method to work,  must override
p38354
aVOtherwise, two different objects with identical information would not be considered the same
p38355
aVWhen you override , you need to also override , because 's contract requires you to override both at the same time
p38356
aVFinally, you may consider using the  collection for your registrations: it gives you a predictable order of iteration, while automatically preventing duplicates
p38357
aVOf course you still need to override  and
p38358
as(dp38359
g6
V335858
p38360
stp38361
a((dp38362
g2
(lp38363
VThere is no way to pass arguments by reference or by pointer in Java, so the only way to achieve the effect that you would like is passing a mutable object, and changing its value inside the method that you call:
p38364
aVWith this class in hand, you can do this:
p38365
as(dp38366
g6
V335858
p38367
stp38368
a((dp38369
g2
(lp38370
VYour code sets up an infinite recursion:  calls , which instantiates a new  from a bundle, thus calling  indirectly, and completing the cycle
p38371
aVYou should not access the NIB in the code that is called when the same NIB is read
p38372
aVYou should read the NIB in the code of the containing object, not in the code of the  object itself
p38373
aVOtherwise, you get an infinite cycle
p38374
aVYou need to remote the  altogether, along with its calls from the  and the
p38375
aVIt appears that the connection that you made in the interface builder by dragging out from object inspector is already causing the NIB file to load correctly, as evidenced by the call of
p38376
aVThe only line that you may need is this:
p38377
aVHowever, it shouldn't be in the 's code: it needs to be moved to the parent controller that has the  property, and it should be modified to
p38378
aVAdd this line to
p38379
aVIt should take care of the problem
p38380
as(dp38381
g6
V335858
p38382
stp38383
a((dp38384
g2
(lp38385
VYou cannot set the  variable in the  method, because this way the value becomes transient: it depends on how the user scrolls through the table, not on what disclosure button the user clicks
p38386
aVMove this line
p38387
aVto the  before the call of  to fix the problem
p38388
aVNow the  is set in response to user's click immediately before the  call, making sure that the correct value is passed to the view controller with the details data
p38389
as(dp38390
g6
V335858
p38391
stp38392
a((dp38393
g2
(lp38394
VUnfortunately, due to the type erasure the only way to initialize  to the type of  is passing the corresponding class in the constructor:
p38395
aVOnce of the reasons why  has been made generic is precisely to support this pattern
p38396
aVSince the  in  must correspond to the  in , the compiler will be able to do the type checking for you
p38397
as(dp38398
g6
V335858
p38399
stp38400
a((dp38401
g2
(lp38402
VUse a lookup table: there are only 16 possible characters in a HEX representation, each corresponding to a four-character binary code group
p38403
aVGo through the HEX character-by-character, obtain a lookup, and put it in the resultant
p38404
aVHere is a copy of the lookup table for you
p38405
aVThere are multiple options as to how to do lookups
p38406
aVThe simplest way would be making a 128-element array, and placing s at the elements corresponding to codes  of the characters (i
p38407
ag630
aVat positions , ,
p38408
aV, , , with single quotes; these are very important)
p38409
as(dp38410
g6
V335858
p38411
stp38412
a((dp38413
g2
(lp38414
VInner classes do not differ from top-level classes in the way you create or return them
p38415
aVThe name of the outer class becomes a part of the fully qualified name of the inner class, so you need to use the scope resolution operator  to build up the name
p38416
as(dp38417
g6
V335858
p38418
stp38419
a((dp38420
g2
(lp38421
VThe syntax error that you are getting is because  is a keyword
p38422
aVYou cannot use it as an identifier
p38423
aVIf you would like to check if a  has an  ready for reading, use  in your condition:
p38424
as(dp38425
g6
V335858
p38426
stp38427
a((dp38428
g2
(lp38429
VYou are calling a wrong method: instead of  you need to call
p38430
aVThe  method is for key-value coding, while  is for retrieving objects through the associative mapping provided by
p38431
as(dp38432
g6
V335858
p38433
stp38434
a((dp38435
g2
(lp38436
VYour  is misplaced: it should be after the  on the next line:
p38437
as(dp38438
g6
V335858
p38439
stp38440
a((dp38441
g2
(lp38442
VDo yourself a favor, use ARC
p38443
aVThis is by far the best addition to the language that has happened in the last five years
p38444
aVIt lets you deal with memory management in a more declarative, rather than a procedural way, freeing you from writing a lot of "boilerplate code"
p38445
aVThis is not to say that learning about manual memory management is unimportant: you should definitely know how it works, and be able to read the code written without ARC
p38446
aVBut as far as your newly developed code is concerned, you should stay with ARC, because manual memory management wastes a lot of your development effort for nothing
p38447
aVBetter yet, get yourself another book: it appears that the authors did not have enough time to rework the examples for ARC, so they inserted a rather lame excuse about "other libraries out there"
p38448
as(dp38449
g6
V335858
p38450
stp38451
a((dp38452
g2
(lp38453
VThe reason that you get these errors is that your functions lack prototypes
p38454
aVEither move all functions to before their first point of use (i
p38455
ag630
aVbefore  function), or provide prototypes for them:
p38456
aVIn the absence of prototypes, C compiler decides that your  function returns , the default return type of functions lacking a prototype
p38457
aVOnce the compiler discovers that  is the actual return type of , an error is issued
p38458
as(dp38459
g6
V335858
p38460
stp38461
a((dp38462
g2
(lp38463
VC++03 does not support inline initialization of member fields
p38464
aVYou need to move this initialization into the constructor, for example (link to a demo):
p38465
aVThe above defines the constructor inline; if you define the constructor separately, move the initialization list (i
p38466
ag630
aVthe code between the colon  and the opening brace ) together with the constructor definition
p38467
as(dp38468
g6
V335858
p38469
stp38470
a((dp38471
g2
(lp38472
VIt looks like you are using a wrong overload, and passing a wrong object:
p38473
aVThe property belongs to , so it should be the invocation target
p38474
aVThere is no idexer for that property, so if you are on
p38475
aVNET 4
p38476
aV5 or later, you can skip the third parameter altogether
p38477
as(dp38478
g6
V335858
p38479
stp38480
a((dp38481
g2
(lp38482
VYou cannot use the "OR" semantics on generic type parameters in a constraint, but you can create a special interface, have your target types implement it, and limit your generic instantiations to classes implementing the special interface:
p38483
aVSo now you can do this:
p38484
as(dp38485
g6
V335858
p38486
stp38487
a((dp38488
g2
(lp38489
VSince conversion is taking too long, you should move it out from your  method into the code that pulls the data out from its data source, do the conversion there, and store it for future use
p38490
aVAdd  to your class, then convert everything into it, and use in your  instead of performing the conversion each time you must display your string:
p38491
aVNow you can replace the slow code with the much faster
p38492
as(dp38493
g6
V335858
p38494
stp38495
a((dp38496
g2
(lp38497
VNULL is just the special memory address 0x0, which is never used for anything but to indicate the occurrence of a special condition
p38498
aVThat is not exactly right: there are computers where  pointer is not a zero internally (link)
p38499
aVare there any other special memory addresses which never will be used for userland applications
p38500
aVEven  is not universal; there are no other universally unused memory addresses, which is not surprising, considering the number of different platforms programmable in C
p38501
aVHowever, nobody stops you from defining your own special address in memory, setting it in a global variable, and treating it as your error indicator
p38502
aVThis will work on all platforms, and would not require a special address location
p38503
aVIn the header:
p38504
aVIn a C file:
p38505
aVAt this point,  points to a globally unique location (i
p38506
ag630
aVthe location of , which is local to the compilation unit where it is defined), which you can use in testing pointers for equality
p38507
as(dp38508
g6
V335858
p38509
stp38510
a((dp38511
g2
(lp38512
VIn cases when only the projection is involved in the outer query, there should be absolutely no difference in execution plans between the two queries
p38513
aVMore complex queries with "where" clauses on both the inner and the outer query, may test the limits of the query optimizer, and might produce inferior query plans for two-level queries, but in your case the plans and the execution speeds should be identical
p38514
as(dp38515
g6
V335858
p38516
stp38517
a((dp38518
g2
(lp38519
VThese are not two declarations, these are two assignment statements
p38520
aVYou are absolutely correct about the way it works, too
p38521
aVThe reason that it works is that an assignment expression is a valid expression that produces a value
p38522
aVThe rightmost assignment gets evaluated first
p38523
aVand then the second assignment:
p38524
aVNote that it's the order of evaluation, not the order of actual assignments: these may happen in any order, because the order of side effects is not specified in the absence of sequence points
p38525
as(dp38526
g6
V335858
p38527
stp38528
a((dp38529
g2
(lp38530
VThis is a forward declaration of a class
p38531
aVIt lets you define pointers and references to the class that you define, without pulling in the entire definition
p38532
aVThe most important reason to do it is when you cannot do it in any other way, due to a circular reference:
p38533
aVAnother reason is speeding up the compile: including a large header simply to declare a pointer may considerably slow down the compilation
p38534
as(dp38535
g6
V335858
p38536
stp38537
a((dp38538
g2
(lp38539
VOne way or the other, you will end up iterating the collection
p38540
aVThe iteration may be hidden from view in some library, but it would necessarily be there
p38541
aVYou can easily write a simple method that does what you need:
p38542
aVDemo on ideone
p38543
as(dp38544
g6
V335858
p38545
stp38546
a((dp38547
g2
(lp38548
VIn Java,  is a type, but it is incompatible with integers
p38549
aVEnum objects are closer to classes than to primitives, in that they can have methods, member variables, and so on
p38550
aVJava lets you get the effect that you wanted by adding an  member to your enumeration, and initializing it differently for different enumeration members, like this:
p38551
aVNow each member of your  has a public method  that returns the integer value associated with the corresponding element of the enumeration
p38552
as(dp38553
g6
V335858
p38554
stp38555
a((dp38556
g2
(lp38557
VThe biggest reason not to use asterisks in production queries is insulating your non-SQL code from changes in the database schema, or making it harder for such changes to go unnoticed
p38558
aVFor example, if your code queries with an asterisk expecting a  in the first column and an  in the second, if the schema changes to add a third column in front of the two that you are already reading, your code would get that new column instead of names, and also put names in place of addresses
p38559
aVThe worst thing is that it would do all that without a crash: the users would simply see garbage data
p38560
aVIn contrast, a query with explicitly named columns would either get the right columns despite the schema change, or break if a required column has been removed or renamed
p38561
aVThis would point to the source of the problem right away, making it easy for you to investigate and fix the problem
p38562
as(dp38563
g6
V335858
p38564
stp38565
a((dp38566
g2
(lp38567
VIn cases when an action is conditioned upon an integer value, you can create a , where  is an interface that you define for this specific purpose
p38568
aVPut implementations of  into the map to correspond to the integer options, and call actions in run-time in response to the values coming in:
p38569
as(dp38570
g6
V335858
p38571
stp38572
a((dp38573
g2
(lp38574
VYou can define a getter that returns  to callers from the outside:
p38575
as(dp38576
g6
V335858
p38577
stp38578
a((dp38579
g2
(lp38580
VSomar measures cyclomatic complexity, which represents the number of linearly independent paths through the source code
p38581
aVThe key to answering your question comes from a research paper of Thomas McCabe, published in December of 1976:
p38582
aVIt can be shown that the cyclomatic complexity of any structured program with only one entrance point and one exit point is equal to the number of decision points (i
p38583
ag630
aV, 'if' statements or conditional loops) contained in that program plus one
p38584
aVThis is precisely what Sonar does: it finds the decision points, which come from loops, conditional statements, and multipart boolean expressions, and counts their number
p38585
as(dp38586
g6
V335858
p38587
stp38588
a((dp38589
g2
(lp38590
VThe  character corresponds to the code point of  - a valid point of the UNICODE-16, the encoding used by the Java source
p38591
aVSince the number of the code point fits in 16 bits, you can simply copy-paste the symbol into your Java source
p38592
aVYou can also use a UNICODE constant directly, like this:
p38593
as(dp38594
g6
V335858
p38595
stp38596
a((dp38597
g2
(lp38598
VThe reason this works is somewhat non-intuitive:  labels of a  statement act very much like regular labels, i
p38599
ag630
aVthe ones designed for use with  statement
p38600
aVYou can place such labels anywhere in your code
p38601
aVIt turns out that the same rule applies to the  label: you can place them anywhere inside their corresponding  statement, which incidentally includes the bodies of any nested loops
p38602
aVThe reasons why you may want to place labels inside control statements within the body of your  statement are even less intuitive: it turns out that you can perform loop unrolling with a cumbersome-looking but very intuitive construct called Duff's Device
p38603
aVIt is this construct that lead to popularizing the idea of embedding case labels inside other control structures within  statements
p38604
as(dp38605
g6
V335858
p38606
stp38607
a((dp38608
g2
(lp38609
VHere is a general approach to making level-by-level hierarchy views with tables and navigation controllers:
p38610
aVCreate a  class that stores your  and an
p38611
aVAdd a  to the screen where you would like to display the hierarchy
p38612
aVCreate a controller that embeds  for your table
p38613
aVAdd an initializer to the above controller that takes a data source defined in step 1
p38614
aVProvide a handler to the table item selection event
p38615
aVIn the event handler from step 5, get the ID of the current row, instantiate a new data source for that ID from step 1, then instantiate a new view controller from step 3 by calling the initializer from step 4, and push the newly created controller onto the stack of the navigation controller from step 2
p38616
as(dp38617
g6
V335858
p38618
stp38619
a((dp38620
g2
(lp38621
VYou need to add an end-of-input anchor  at the end, and prohibit matching of  as part of your non-empty  sequences, like this:
p38622
as(dp38623
g6
V335858
p38624
stp38625
a((dp38626
g2
(lp38627
VSince you use a  and because  objects manage their own memory, you do not need to  the elements of the vector: the strings have copied the content that you passed to them on creation
p38628
aVHowever, you need to delete the C strings that you allocated with
p38629
aVYou should do it right after you created your  object: once the string is created, the character data can be safely deleted:
p38630
aVNote that you picked a rather roundabout way of creating strings: you can accomplish the same exact thing by calling
p38631
as(dp38632
g6
V335858
p38633
stp38634
a((dp38635
g2
(lp38636
VYou do not need a loop: simply call
p38637
as(dp38638
g6
V335858
p38639
stp38640
a((dp38641
g2
(lp38642
VAssuming that I understand the intention behind your merging strategy correctly, you should add a second level of , and total up the corresponding totals, like this:
p38643
aVIf you have a  row in the first result and a  row in the second, you will see a  row in the output (i
p38644
ag630
aVthe first two columns will be used for grouping, and the last one will be totalled up)
p38645
as(dp38646
g6
V335858
p38647
stp38648
a((dp38649
g2
(lp38650
VSince your query returns a sequence of objects of anonymous class, you can enumerate your query, and access  and  from each returned row, like this:
p38651
as(dp38652
g6
V335858
p38653
stp38654
a((dp38655
g2
(lp38656
VYou can use a single query below, but your original query is more readable:
p38657
aVThis will bring back a dictionary of no more than two items: one for the , and one for the first or default item with that property
p38658
aVIf there are no source rows with  or , the result would contain fewer than two items
p38659
aVYou can get the value from the dictionary by looking up using the corresponding constant as the key
p38660
as(dp38661
g6
V335858
p38662
stp38663
a((dp38664
g2
(lp38665
VThis is a fairly common problem:  cannot be represented exactly in a , so  is not equal to the sum of ten  added together
p38666
aVYou need to use  instead of  to stop the loop
p38667
aVNote that your loop would have worked for an increment which is equal to a negative power of 2, say, : the loop below works fine, and stops as expected:
p38668
aVThis works, because  can be represented exactly in a
p38669
aVThis little experiment shows that you need to be extremely cautious when comparing s for equality or inequality
p38670
as(dp38671
g6
V335858
p38672
stp38673
a((dp38674
g2
(lp38675
VYes, this is normal:
p38676
aVis a subclass of
p38677
aVAs of Java 5
p38678
aV0, it is OK for a derived class or an interface implementation method in Java to return a subclass of the return type declared in the superclass or the interface
p38679
aVThis is called return type covariance
p38680
aVBecause  implements the , the return type of  from that interface is used, namely,
p38681
as(dp38682
g6
V335858
p38683
stp38684
a((dp38685
g2
(lp38686
VA very common practice in writing class libraries is storing the parameters passed into your API, say, in a constructor, like this:
p38687
aVWere  mutable, this would lead to a subtle exploit: an attacker would pass a good URL, wait for a few microseconds, and then set the URL to point to an attack site
p38688
aVSince storing without copying is a reasonably common practice, and because strings are among the most commonly used data types, leaving strings mutable would open up many APIs that are not written yet open to a serious security problem
p38689
aVMaking strings immutable closes this particular security hole for all APIs, including the ones that are not written yet
p38690
as(dp38691
g6
V335858
p38692
stp38693
a((dp38694
g2
(lp38695
VThis is because in Lua the  method looks for a pattern, and  represents any character
p38696
aVYou can use character sets to work around the problem:
p38697
aVHere is a link to a small demo
p38698
as(dp38699
g6
V335858
p38700
stp38701
a((dp38702
g2
(lp38703
VAccumulating a list is relatively straightforward: first, observe that if  can call  directly, the list is simply
p38704
aVHence, we can rewrite your first rule as
p38705
aVThe second rule is a bit trickier: you need to unify to a list produced by , and insert  at its head
p38706
aVNote that you do not need to insert  or , because they would be provided by the returned list:
p38707
aVHere is a small demo that uses your data
p38708
aVNote that this code would be chasing its own tail if the data that you present represents a graph with loops, rather than a tree
p38709
aVTo avoid this, you could avoid picking  if it is already part of the  list
p38710
as(dp38711
g6
V335858
p38712
stp38713
a((dp38714
g2
(lp38715
VThis is because you did not put parentheses around your  definition:
p38716
aVWithout parentheses, the code will look like this after the substitution by the preprocessor:
p38717
aVBecause  and  have the same priority and are applied left-to-right, the compiler would generate the code that obtains a remainder of the division by , and then quickly divide the result by , which is certainly not what you'd expect
p38718
aVIn general, it is a good idea to always put parentheses around your entire macro
p38719
aVIn case of function-like macros with parameters, it is also a good idea to parenthesize each parameter as well
p38720
as(dp38721
g6
V335858
p38722
stp38723
a((dp38724
g2
(lp38725
VThis is a relatively new syntax, it is available only with Xcode that includes clang 3
p38726
aV3 or newer
p38727
aVThis
p38728
aVis logically equivalent* to this:
p38729
aVYou can always replace the new syntax with the old one without losing functionality
p38730
aVEDIT (in response to a comment by Nikolai Ruhe)  Apple has a different version scheme than the open source version
p38731
aVThe correct version numbers that introduced the feature are: Apple 4
p38732
aV0, clang 3
p38733
ag1340
aV* Under the hood the array initializer of the new syntax is transformed to a call of
p38734
aVThanks to newacct for the correction
p38735
as(dp38736
g6
V335858
p38737
stp38738
a((dp38739
g2
(lp38740
VIt appears that you do not need a subquery- you can embed the  into the top-level , like this:
p38741
as(dp38742
g6
V335858
p38743
stp38744
a((dp38745
g2
(lp38746
VThe loop is not executing because the loop condition
p38747
aVis  right at the beginning of the loop
p38748
aVSince your loop advances  down, you should change the condition to
p38749
as(dp38750
g6
V335858
p38751
stp38752
a((dp38753
g2
(lp38754
VYou should at least familiarize yourself with the basic concepts of the manual memory management, because ARC uses it under the hood
p38755
aVYou need to learn at least about three things: , , and
p38756
aVThis will help you understand discussions about ARC's inner working
p38757
aVARC is mostly a compiler trick (with some support from the runtime)
p38758
aVYou can write less code, but you cannot get better performance from it
p38759
aVEssentially, ARC lets you deal with memory management declaratively, while the manual management uses imperative style
p38760
aVHowever, both systems call the same methods from the runtime
p38761
as(dp38762
g6
V335858
p38763
stp38764
a((dp38765
g2
(lp38766
VThere is nothing similar to  in Java: Java sorting uses the style that is more similar to the  method of the  class:
p38767
as(dp38768
g6
V335858
p38769
stp38770
a((dp38771
g2
(lp38772
VThe  values appear to be string literals  rather than the  objects typically used to represent s in Cocoa collections
p38773
aVYou can filter them out by using 's  method:
p38774
aVThere are several ways of making the , one of them is
p38775
as(dp38776
g6
V335858
p38777
stp38778
a((dp38779
g2
(lp38780
VThe format specifier for printing void pointers using  in C is
p38781
aVWhat usually gets printed is a hexadecimal representation of the pointer (although the standard says simply that it is an implementation defined character sequence defining a pointer)
p38782
as(dp38783
g6
V335858
p38784
stp38785
a((dp38786
g2
(lp38787
VThis happens when your cell is defined using a storyboard prototype
p38788
aVIn this case the reusable cells are pre-created using the  method, so  never gets hit
p38789
aVSee this question for more information
p38790
aVSince it appears that you would like to use a cell with a standard style, changing the table to not use a storyboard prototype or setting the prototype to "Subtitle" should fix this problem
p38791
as(dp38792
g6
V335858
p38793
stp38794
a((dp38795
g2
(lp38796
VA reference in C++ is not the same as a reference in Java, C#, or other garbage-collected languages: for most practical purposes, you can think of a C++ reference as a pointer that you don't need to dereference*
p38797
aVCreating a reference to an object does not prolong its life time
p38798
aVThat's why it's no more OK to access a deleted object through a reference than it is to access a deleted object through a second pointer: it is undefined behavior
p38799
aV* References are not pointers, though
p38800
as(dp38801
g6
V335858
p38802
stp38803
a((dp38804
g2
(lp38805
VAlthough  has higher precedence than , the side effects of post-increment  are applied after the dereference operator  has used the iterator's value
p38806
aVThat is the behavior of the post-increment, or suffix , (as opposed to the pre-increment, or prefix )
p38807
aVThis rule applies to iterators as well as the "plain" pointers
p38808
as(dp38809
g6
V335858
p38810
stp38811
a((dp38812
g2
(lp38813
VYou cannot do it for properties, but you can do it for property-like getter methods
p38814
aVStarting with C#3
p38815
aV0, you can build delegates implicitly using method groups:
p38816
aVDropping the parentheses after the method name converts an invocation expression into a method group
p38817
aVUnfortunately, this means that there is no comparable syntax for properties, because accessing properties does not require parentheses
p38818
as(dp38819
g6
V335858
p38820
stp38821
a((dp38822
g2
(lp38823
VYou should name the properties in the initializer, like this:
p38824
aVAlternatively, you can provide a two-argument constructor, and call it:
p38825
as(dp38826
g6
V335858
p38827
stp38828
a((dp38829
g2
(lp38830
VSince you did not put anything into  after calling , the call of  leads to undefined behavior, because the allocated memory block may not contain the null terminator at all
p38831
aVIn this case,  would eventually access memory beyond the allocated block during its search for a terminator
p38832
aVThis should make the calls consistent:
p38833
as(dp38834
g6
V335858
p38835
stp38836
a((dp38837
g2
(lp38838
VHere is the problem: this line
p38839
aVshould be
p38840
aVYour current implementation compares the element at  not to the smallest string that you have found so far, but to the string at index
p38841
aVThat is incorrect, because it does not find the smallest remaining string: instead, it finds the last string in the  that is smaller than the current element at index , which is not what you want
p38842
as(dp38843
g6
V335858
p38844
stp38845
a((dp38846
g2
(lp38847
VYou are missing a dereferende: it should be  in the loop condition:
p38848
aVSince  is a pointer, it would never be equal to , so your loop is going past the end of both strings
p38849
as(dp38850
g6
V335858
p38851
stp38852
a((dp38853
g2
(lp38854
VYou should change your code as follows:
p38855
aVOtherwise, the string builder is not that useful: all you do is appending a single value, which is constructed with an implicitly constructed builder created by the compiler for you
p38856
aVThe most important thing is moving the string builder and writing the response outside the loop
p38857
as(dp38858
g6
V335858
p38859
stp38860
a((dp38861
g2
(lp38862
VYou are correct,  is typed statically (i
p38863
ag630
aVat compile time)
p38864
aVThe static type of , however, comes from the context, which lets the compiler derive the type of the
p38865
aVIn case of  which implements , the only type the compiler can derive is , leading to the error that you describe
p38866
aVHad  implemented, say, , the  in the loop would be equivalent to , not to
p38867
as(dp38868
g6
V335858
p38869
stp38870
a((dp38871
g2
(lp38872
VThere are three major memory areas used by C (and by extension, Objective C) programs for storing the data:
p38873
aVThe static area
p38874
aVThe automatic area (also known as "the stack"), and
p38875
aVThe dynamic area (also known as "the heap")
p38876
aVWhen you allocate objects by sending their class a  or  message, the resultant object is allocated in the dynamic storage area, so the object is said to live in the heap
p38877
aVAll Objective-C objects are like that (although the pointers that reference these objects may be in any of the three memory data areas)
p38878
aVIn contrast, primitive local variables and arrays "live" on the stack, while global primitive variables and arrays live in the static data storage
p38879
aVOnly the heap objects are reference counted, although you can allocate memory from the heap using //, in which case the allocation would not be reference-counted: your code would be responsible for deciding when to  the allocated dynamic memory
p38880
as(dp38881
g6
V335858
p38882
stp38883
a((dp38884
g2
(lp38885
VSeveral things are wrong with your code:
p38886
aVYou are passing a wrong parameter for the time interval - negative numbers are interpreted as the 0
p38887
aV1 ms
p38888
aVYou are calling the wrong overload - you are expected to pass an invocation object, yet you are passing a
p38889
aVYou put the code that you want executed on timer together with timer initialization - the code that needs to be executed on timer should go into a separate method
p38890
aVYou should call the overload that takes a selector, and pass  for the interval, rather than
p38891
aVDeclare  and , then add
p38892
aVto the place where you want to start the countdown
p38893
aVThen add the countDown method itself:
p38894
as(dp38895
g6
V335858
p38896
stp38897
a((dp38898
g2
(lp38899
VThe overhead would be exactly one reference per node
p38900
aVAssuming that the node in addition to the payload also has a prior link and a back link, the overhead for an extra reference to the parent would amount to about 33% in additional memory use (1 reference on top of 3 existing ones)
p38901
aVThis is considerable overhead, especially for large node counts and small payloads
p38902
aVOn the other hand, with larger payloads it would not matter much
p38903
aVIn general, though, I would not make an assumption about the payload size, and make the Node class
p38904
as(dp38905
g6
V335858
p38906
stp38907
a((dp38908
g2
(lp38909
VI think the reason is that you've got an assignment that clears out the  at the end of your method:
p38910
aVSetting  to zero needs to be done outside the method - either at initialization, or in the start document event handler
p38911
aVCurrently, because  is reset after each element, the  portion of your condition remains true for every element that you process, so the data for the last element overrides what's been there before
p38912
aVMoving the  assignment into the  method of your NSXMLParserDelegate should fix the problem
p38913
as(dp38914
g6
V335858
p38915
stp38916
a((dp38917
g2
(lp38918
VIt looks like you are doing everything right
p38919
aVMy only guess is that  on your platform is larger than , so providing a correct format specifier ( instead of ) may fix the problem:
p38920
as(dp38921
g6
V335858
p38922
stp38923
a((dp38924
g2
(lp38925
VYou get the error because you allocate the  at the time when the  is still zero:
p38926
aVYou need to remove the initialization from the declaration, and move it to the , after reading the  from
p38927
as(dp38928
g6
V335858
p38929
stp38930
a((dp38931
g2
(lp38932
VIf you want to change an attribute of a non-static object from inside a static method, you need to obtain a reference to that object in one of several ways:
p38933
aVThe object is passed to your method as an argument - This one is most common
p38934
aVThe object is an argument of your method, and you call methods/set properties on it
p38935
aVThe object is set in a static field - This one is OK for single-threaded programs, but it is error-prone when you deal with concurrency
p38936
aVThe object is available through a static reference - This is a generalization of the second way: the object may be a singleton, you may be running a static registry from which you get an object by name or some other ID, etc
p38937
aVIn any case, your static method must get a reference to the object in order to examine its non-static properties or call its non-static methods
p38938
as(dp38939
g6
V335858
p38940
stp38941
a((dp38942
g2
(lp38943
VWhy it shows an error on line 2
p38944
aVBecause a declaration must include a variable name, not only its type:
p38945
as(dp38946
g6
V335858
p38947
stp38948
a((dp38949
g2
(lp38950
VThe reversing starts by copying the -th character of  array into
p38951
aVThe -th character happens to be the null terminator
p38952
aVIt becomes the first character of your new string, so the string looks empty to all standard C routines, including
p38953
aVCalling
p38954
aVfrom the  should fix the problem
p38955
aVThe condition in the  should be changed from  to  as well
p38956
as(dp38957
g6
V335858
p38958
stp38959
a((dp38960
g2
(lp38961
VYou can add the name of the folder in the same way that you add the name of the file:
p38962
aVYou can also use  to compose the path, like this:
p38963
as(dp38964
g6
V335858
p38965
stp38966
a((dp38967
g2
(lp38968
VThe compiler is right: all it knows about the object is that it's a , not an
p38969
aVIf you know for sure that  is an , add an explicit cast
p38970
aVThis may not be the most elegant way to solve the problem, because the cast will fail if  is not an
p38971
aVWhen you run into the need to "downcast" to subclass, you should evaluate your decision to put s and s into the same container: perhaps your code would be better off if the containers for the two subclasses were separate
p38972
as(dp38973
g6
V335858
p38974
stp38975
a((dp38976
g2
(lp38977
VYou cannot (and more importantly, you should not) do that
p38978
aVWhen you are in the constructor of the base class, the subclass portion has not been initialized yet, so there is no way to get to the members of the subclass: quite simply, they do not exist yet
p38979
aVAnother problem is that the  attribute may not be present in a subclass at all, even at the level fo the definition: I can derive  from , and give it  attribute instead of
p38980
aVAll this does not touch on such "insignificant" matters as breaking encapsulation:  is a private member, which may be removed in the future implementations of the
p38981
aVThe only way for the subclass to communicate things to superclass in a constructor is passing parameters
p38982
aVThis would work:
p38983
as(dp38984
g6
V335858
p38985
stp38986
a((dp38987
g2
(lp38988
VOn deserialization  needs to create an object of your class, and then set its attributes one-by-one from the XML
p38989
aVIn order to do so, the serializer must construct the object, and it uses the default parameterless constructor for that
p38990
aVIt cannot use other constructors, because it does not know what attributes it needs to pass to them
p38991
aVAn inability to create instances of objects lacking parameterless constructors has been recognized as a problem, and fixed in the later versions of
p38992
aVNET by providing a backdoor way of creating uninitialized objects with
p38993
aVHowever,  has been left in its current state
p38994
as(dp38995
g6
V335858
p38996
stp38997
a((dp38998
g2
(lp38999
VIt is not "like" a binary search - it is a binary search
p39000
aVUnfortunately, it is , not
p39001
aVTo find the borderline in , start from the other end: try positions  and so on, until you hit a
p39002
aVThen do a binary search on the interval between  and , where  is the first position where you discovered a
p39003
aVFinding the first  takes , because the index is doubled on each iteration
p39004
aVAfter that, the binary search takes another , because the length of the interval  is less than  as well
p39005
as(dp39006
g6
V335858
p39007
stp39008
a((dp39009
g2
(lp39010
VYou need to move the declaration/initialization of  and  into the loop
p39011
aVOtherwise, they are set once, and remain in place through the rest of the program run
p39012
aVNote that the assignment does not ask you to do six throws, it asks you to do as many as you need to get to the desired sum
p39013
aVIn order to ensure that the loop can stop, you should check that the entered number is at least two and at most twelve
p39014
aVIn addition, this is wrong:
p39015
aVit gives you a number from 0 to 6, inclusive, but a real dice throw cannot produce a zero
p39016
aVInstead, you need to write
p39017
aVYour loop should look like this:
p39018
as(dp39019
g6
V335858
p39020
stp39021
a((dp39022
g2
(lp39023
VIt looks like you are running some kind of a sorting algorithm in there, but you skip all elements between 3 and 8
p39024
aVThe reason you see numbers under 3 printed is because your  is after the loop that does swapping: by the time the inner loop is finished, a number that's smaller than  may be inserted at -th position
p39025
aVIf you move  before the loop, the numbers printed will all be from the  range, inclusive of both ends
p39026
as(dp39027
g6
V335858
p39028
stp39029
a((dp39030
g2
(lp39031
VThe way you check a single character to be digit is not with  (that one returns, an , not a )
p39032
aVYou use  instead:
p39033
aVNote that it's checking the character at index 4, which is the fifth character (the initial character is at index zero, not one)
p39034
as(dp39035
g6
V335858
p39036
stp39037
a((dp39038
g2
(lp39039
VThe construct with the empty brackets  is allowed as the last element of the
p39040
aVIt lets you allocate additional space beyond  for the elements of the array, letting you embed the array data with the array itself
p39041
aVPointers, on the other hand, store the data in a separately managed segment of memory, and require an additional call to  at the end
p39042
aVUnlike the  way, pointers let you have more than one variable-length array inside the same , and the element can be placed anywhere in the , not only at the end of the
p39043
as(dp39044
g6
V335858
p39045
stp39046
a((dp39047
g2
(lp39048
VIt depends on what you mean by "better": if passing multiple parameters is better aligned with the logical structure of your program, then it is definitely much better for readability to pass multiple parameters
p39049
aVA good test of whether or not this may be the case is asking if individual elements of the array would benefit from being named individually
p39050
aVIf the answer is "yes", then individual parameters are better
p39051
aVSaving a few bytes here and there when passing parameters does not compensate for even a slight loss of readability
p39052
as(dp39053
g6
V335858
p39054
stp39055
a((dp39056
g2
(lp39057
VThe  (minus) does exactly what it always does - subtracting
p39058
aVWhat happens here is subtracting the character code of zero  from the character at
p39059
aVThis converts a digit character to an integer value of the corresponding digit
p39060
aVFor example, if you calculate
p39061
aVthe value of  is seven
p39062
as(dp39063
g6
V335858
p39064
stp39065
a((dp39066
g2
(lp39067
VYou can do this:
p39068
aVThis would make an element-by-element copy of the list, rather than copying the reference to the list itself
p39069
as(dp39070
g6
V335858
p39071
stp39072
a((dp39073
g2
(lp39074
VUse this algorithm:
p39075
aVObtain the current year
p39076
aVConvert each date from your array to a date in the current year
p39077
aVFor example, "03/02/1990" becomes "03/02/2013"
p39078
aVIf the date from the step 2 is before the current date, advance its year by one (i
p39079
ag630
aV"03/02/2013" becomes "03/02/2014")
p39080
aVUsing a technique from this question, find the number of days till the date from step 3
p39081
aVIt will be less than the number of days in a year
p39082
as(dp39083
g6
V335858
p39084
stp39085
a((dp39086
g2
(lp39087
VThe answer to the "Which one is preferred
p39088
aVquestion depends on a few factors:
p39089
aVHow many items like this you plan to create
p39090
aV- If the answer is "millions",  wins; if the answer is "fifty eight", object wins
p39091
aVDo you need to define methods on it
p39092
aV- If the answer is "yes", object wins; otherwise,  may be OK
p39093
aVDo you plan to define arrays of it
p39094
aV- If the answer is "yes",  may be a better choice
p39095
aVDo you need to create and destroy it often
p39096
aV- If the answer is "yes",  may be a better choice
p39097
aVUltimately, your design constraints help you determine what's best; there is no data structure that is universally "better"
p39098
as(dp39099
g6
V335858
p39100
stp39101
a((dp39102
g2
(lp39103
V[the method] should return false if the name is not Thomas, and true if it is
p39104
aVYou do not need an  at all:
p39105
aVIn general,  expressions are easier to read without s and  /  around them
p39106
aVEvery time you see returning  or  from a branch of an , you should consider rewriting it without the  statement
p39107
as(dp39108
g6
V335858
p39109
stp39110
a((dp39111
g2
(lp39112
VYes, this is easy to do: make a mask with all ones ( in your case), and use it to mask your original number using
p39113
aVAs you shift the mask right, you get the effect below:
p39114
as(dp39115
g6
V335858
p39116
stp39117
a((dp39118
g2
(lp39119
VYour syntax is correct, it's the type of your data that you got wrong
p39120
aVYour  is of type , but your block expects you to return
p39121
aVThis means that you should either wrap  into, say, ,
p39122
aVor change the declaration of the  to expect a return type of
p39123
as(dp39124
g6
V335858
p39125
stp39126
a((dp39127
g2
(lp39128
VFrom the outside, the syntax for accessing getters and setters is indistinguishable from that of accessing variables
p39129
aVAssignments translate into calls of setters, while plain expression uses translate into calls of getters
p39130
aVIn intellisense, the list of getters and setters should open upon placing a dot  after the variable name
p39131
aVProperties should have blue markers to the left of them (as opposed to magenta-colored markers to the left of methods)
p39132
as(dp39133
g6
V335858
p39134
stp39135
a((dp39136
g2
(lp39137
VJDBC batch statements let you reduce the number of roundtrips under a condition that there is no data dependency among the rows that you are inserting or updating
p39138
aVYour scenario fails this condition, because the changes are dependent on each other's data: statements 2 through 4 must pick up an ID from the prior statement 1 through 3
p39139
aVOn the other hand, four round-trips is definitely suboptimal
p39140
aVThat is why scenarios like yours call for stored procedures: you can put all this logic into a , and return the user ID back to the caller
p39141
aVAll insertions from 1 to 4 would happen inside your SQL code, letting you manage ID dependencies in SQL
p39142
aVYou would be able to call this stored procedure in a single roundtrip, which is definitely faster, especially if you process multiple user registrations per minute
p39143
as(dp39144
g6
V335858
p39145
stp39146
a((dp39147
g2
(lp39148
VHow long data reader\u2019s connection will be opened
p39149
aVThe connection will remain open until the  is dismissed, which means that it would be open until the iteration is over
p39150
aVWhen I consider code performance factor only, Is this a good idea to use  instead of adding record into a list and returning the whole list
p39151
aVThis depends on several factors:
p39152
aVIf you are not planning to fetch the entire result,  will help you save on the amount of data transferred on the network
p39153
aVIf you are not planning to convert returned data to objects, or if multiple rows are used to create a single object,   will help you save on the memory used at the peak usage point of your program
p39154
aVIf you plan to iterate the enture result set over a short period of time, there will be no performance penalties for using
p39155
aVIf the iteration is going to last for a significant amount of time on multiple concurrent threads, the number of open cursors on the RDBMS side may become exceeded
p39156
as(dp39157
g6
V335858
p39158
stp39159
a((dp39160
g2
(lp39161
VYou can always make an array out of a set, like this:
p39162
aVAfter that, you can get your string with :
p39163
aVOf course you can achieve the same effect with a simple loop similar to the one in your post:
p39164
as(dp39165
g6
V335858
p39166
stp39167
a((dp39168
g2
(lp39169
VTry making  a generic method:
p39170
aVThis should let you capture the type of
p39171
aVWith  in place, you could construct  object in the regular C# syntax, rather than going through reflection:
p39172
aVNow you can write the  into the property/field with the  call
p39173
aVThis should be sufficient for many, if not all, of your unit tests
p39174
as(dp39175
g6
V335858
p39176
stp39177
a((dp39178
g2
(lp39179
VThere is no way to introduce new local variables in Objective C
p39180
aVWhen you need multiple data objects accessed with an integer index, use arrays or  objects:
p39181
aVor
p39182
as(dp39183
g6
V335858
p39184
stp39185
a((dp39186
g2
(lp39187
VReading bytes from any address is easy: simply cast the pointer to a , subtract the desired number of bytes, and start reading, like this:
p39188
aVYou need to make sure that the memory that you are trying to read is legal for your application to access
p39189
aVThe memory needs to be part of a larger structure that you allocated statically or dynamically
p39190
aVOtherwise, it is undefined behavior, which may lead to a crash
p39191
as(dp39192
g6
V335858
p39193
stp39194
a((dp39195
g2
(lp39196
Vhowever the initial few searches (e
p39197
ag303
aVfor "f" > "fo" > "foo") can take up to 3 or 4 seconds on even a fast machine
p39198
aVThat's the only thing that you need to optimize then
p39199
aVCreate a very simple structure that consists of three hash sets - for single characters, for two characters, and for three characters
p39200
aVEach element of the one-character hash index would contain a list of elements that include the indexed character; each element of the two-character hash index would contain a list of elements that include the indexed pair of characters; three-character index would do likewise
p39201
aVWhen the initial portion of the search is typed, look up using indexes
p39202
aVFor example, when  is typed, you would grab the list of items containing  from the first hash table
p39203
aVAs the user continues typing, you'd grab items from the second index for the  key, and then from the third index for the  key
p39204
aVAs soon as you get four characters or more, you go back to the searches based on , using the last three characters of the search term to look up the initial list in the hash based on three-character substrings
p39205
aVThe number of items that you get from the list would be relatively small, so the searches should go much faster
p39206
aVAnother optimization should be stopping your search as soon as you've got enough items to display to your user
p39207
aVFor example, if the user types  (from ) your three-character index would give you 50000 hits
p39208
aVGrab the first 20 (or as many as you need to display), and skip the remaining ones: the users will refine their search shortly, so the additional items will likely be discarded shortly anyway
p39209
as(dp39210
g6
V335858
p39211
stp39212
a((dp39213
g2
(lp39214
VThe exercise implies changing your  as follows:
p39215
aVYou can keep your database global, but now the  inside it must be allocated dynamically with
p39216
aVOf course in order to do that you need to know how many rows to allocate
p39217
aVThat's what the "accept parameters for  and " is all about: add code to  to interpret the  parameter, store it in  of your , and allocate  based on that number
p39218
aVYour , , and  would need to change to read and write the  to the database file
p39219
aVThe  would be responsible for allocating  with  after reading the size; the  would be responsible for calling  on the
p39220
as(dp39221
g6
V335858
p39222
stp39223
a((dp39224
g2
(lp39225
VWhile  method in itself may be thread safe, prepared statements are not designed to be used concurrently
p39226
aVThis is because each instance stores your parameters until  instructs it to send the parameters to MySQL
p39227
aVMoreover, since transactions are managed through  objects, sharing connections concurrently without synchronization may give you undesired behavior on commits/rollbacks
p39228
aVIn order to make inserts from multiple threads work concurrently, each thread needs to use its own , and make its own
p39229
aVUsing multiple prepared statements concurrently on the same database is thread safe, because the concurrency is managed on the RDBMS side
p39230
as(dp39231
g6
V335858
p39232
stp39233
a((dp39234
g2
(lp39235
VYou cannot use plain  to search with a custom comparator - you need to use  instead
p39236
aVYou have an answer for C++11 already, here's one for use with C++03:
p39237
as(dp39238
g6
V335858
p39239
stp39240
a((dp39241
g2
(lp39242
VThe reason why the method has this signature is because the  API predates generics: the method
p39243
aVhas been introduced as early as Java 1
p39244
ag839
aVThe corresponding generic that replaces  with  has been introduced as a 100% backward-compatible option:
p39245
aVChanging the signature to generic lets callers avoid the cast: prior to Java 5, callers needed to do this:
p39246
aVNow they can do the same call without a cast:
p39247
aVEDIT :
p39248
aVA more "modern" signature for the  method would be a pair of overloads:
p39249
aVThis would provide a more expressive, and equally versatile, alternative to the current method signature
p39250
aVThere is an efficient implementation of this, too, with  method in place
p39251
aVChanging the signature in this way would not be backward-compatible, though
p39252
as(dp39253
g6
V335858
p39254
stp39255
a((dp39256
g2
(lp39257
VThe reason you must provide a declaration in the implementing class is that it is legal for a derived class to override a virtual function using a different return type, as long as the new return type is covariant with the original return type
p39258
aVFor example, your base class could return , but your derived class has an option of returning
p39259
aVWithout a declaration in the derived class the compiler does not know what is the return type of your method
p39260
aVIt cannot assume that it is the same as in the base, so the compiler requires a prototype
p39261
aVSee this question for rules of overriding with covariant return types
p39262
as(dp39263
g6
V335858
p39264
stp39265
a((dp39266
g2
(lp39267
VYes, you can do it: the simplest way is to create a file with a known name in the  directory, and delete that file upon the "normal" exit
p39268
aVIf the file is there on launch, you know the previous exit has not been a "normal" one
p39269
aVYou could update the content of the file periodically, writing the current timestamp on a timer every minute
p39270
aVThis way you would know approximately when the abnormal exit has happened
p39271
as(dp39272
g6
V335858
p39273
stp39274
a((dp39275
g2
(lp39276
VThe rule in question says that if  sees a list that starts with two identical elements, these two elements need to be replaced with a single
p39277
aVThe list  is shorter by one element than the
p39278
aVNote that the rule below
p39279
aVhas a singleton (i
p39280
ag630
aVunused anywhere else) variable
p39281
aVYou should change the rule to
p39282
aVto ensure that  does not equal , preventing this rule from matching the same arguments as the  one
p39283
as(dp39284
g6
V335858
p39285
stp39286
a((dp39287
g2
(lp39288
VIf the format of the input string is fixed, the simplest and the most expedient way of doing this would be with string manipulation:
p39289
aVIt would spare you dealing with dates and calendars
p39290
aVHere is a demo on ideone
p39291
as(dp39292
g6
V335858
p39293
stp39294
a((dp39295
g2
(lp39296
VThe corresponding primitive type is :
p39297
aVThe Class instance representing the primitive type
p39298
aVIf you have an instance of a "wrapper" class, you can get the corresponding primitive through reflection, like this:
p39299
aVHere is a demo on ideone
p39300
as(dp39301
g6
V335858
p39302
stp39303
a((dp39304
g2
(lp39305
VAccording to the C99 standard, section 6
p39306
ag838
ag20244
aV17, only the first member (in declaration order, i
p39307
ag630
aVthe  field) is initialized explicitly in your example:
p39308
aVEach brace-enclosed initializer list has an associated current object
p39309
aVWhen no designations are present, subobjects of the current object are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union
p39310
aVBy "designation" the standard means
p39311
aVThis is a more precise way of letting programmers decide what fields get initialized
p39312
as(dp39313
g6
V335858
p39314
stp39315
a((dp39316
g2
(lp39317
VThe interning pool for Java String constants is something known to the Java compiler, so you cannot mimic the exact behavior by yourself
p39318
aVThe pool itself, however, is nothing more than a hash map
p39319
aVIf your object has a suitable identifier, you can certainly roll a pool for your own objects: simply create a static method that takes a key, looks it up in a static hash map, and builds a new object only if it has not been pooled yet
p39320
aVNote, however, that in orde for this simple scheme to work, it is essential for your object to be immutable
p39321
as(dp39322
g6
V335858
p39323
stp39324
a((dp39325
g2
(lp39326
VYou need to move the bodies of the functions that invoke member functions on the forward-declared classes outside of the headers, to places where definitions are available:
p39327
aVOtherwise, the compiler knows that  is available, but it does not know that  has the  member function that takes no arguments
p39328
as(dp39329
g6
V335858
p39330
stp39331
a((dp39332
g2
(lp39333
VIn your case,  does not need to be  (although it is certainly OK)
p39334
aVUsing  instead would be sufficient, because you do not call anything outside of what  gives you
p39335
aVThis works, because you use reflection
p39336
aVWith , on the other hand, you could specify properties not found on , and the compiler would not complain
p39337
aVFor example, since both  and  have an  parameter, you could write something like this:
p39338
aVThis would work as long as  is ; it would not work with an
p39339
as(dp39340
g6
V335858
p39341
stp39342
a((dp39343
g2
(lp39344
VUnlike  which can be represented exactly as a float* ,  is represented as  (see this calculator if you wish to try other numbers)
p39345
aVMultiplying by one hundred keeps the number at , which correctly rounds to
p39346
aV* An exact representation is possible because its fractional part  is a power of two (i
p39347
ag630
ag1783
as(dp39348
g6
V335858
p39349
stp39350
a((dp39351
g2
(lp39352
VThe simplest way of implementing this would be attaching a long press gesture recognizer to your  button
p39353
aVXcode lets you attach long press gesture recognizer in the interface builder
p39354
aVAdd it to your button, configure the duration of long press, and connect the handler to  in the same way that you connect other UI events
p39355
aVIf you would rather do it in code, this answer shows you how
p39356
as(dp39357
g6
V335858
p39358
stp39359
a((dp39360
g2
(lp39361
VDepending on the  values that you associated with your , I would add a static array of s, or a static  to your  class, and use it to do a lookup in the message from code method
p39362
aVIn your case, an array is more appropriate, because you have values  and  which are small
p39363
aVI would also change the signature to return
p39364
aVThe callers who need the message would obtain it like this:
p39365
as(dp39366
g6
V335858
p39367
stp39368
a((dp39369
g2
(lp39370
VAccording to the SQL syntax specification, a select statement returning multiple rows is a query expression followed by an optional  clause:
p39371
aVIn turn, query expression is defined as
p39372
aVand non-join query expression is where the  is specified:
p39373
aVTherefore, using  in an individual query expression in a  clause is syntactically incorrect; there are no other similar query clauses that must not be used in a
p39374
as(dp39375
g6
V335858
p39376
stp39377
a((dp39378
g2
(lp39379
VIndexing is unlikely to help, because you are applying a function to the value before the search
p39380
aVTypically, this kills the effects of indexing
p39381
aVSorting bitmasks rarely makes sense, because bit positions in bitmaps do not correspond to something that is ordered across the rows (their ordering is associated with something inside the same row, e
p39382
ag303
aVthe vowels in some word)
p39383
as(dp39384
g6
V335858
p39385
stp39386
a((dp39387
g2
(lp39388
VThis is the multiply-assign operator
p39389
aVIt means the same thing as
p39390
aVThis is not a bitwise operator, although there are bitwise operators of the same kind:
p39391
aV- and-assign,
p39392
aV- or-assign,
p39393
aV- xor-assign
p39394
aVOther operators of the family include , , , and
p39395
as(dp39396
g6
V335858
p39397
stp39398
a((dp39399
g2
(lp39400
VThe reason
p39401
aVdoes not work is that  is immutable
p39402
aVYou need to use
p39403
aVinstead
p39404
aVHere is a demo on ideone
p39405
as(dp39406
g6
V335858
p39407
stp39408
a((dp39409
g2
(lp39410
VThe 4
p39411
ag838
aV2 version of g++ provides support of C++11's initializer lists
p39412
aVThis means that you can write the following code to put all your variables in a :
p39413
aVThis is reasonably clean, and should provide you with a simple way of organizing your variables into a vector for the output purposes
p39414
aVHere is a small demo on ideone
p39415
ag1971
ag1972
aVYour third example does not work, because you are pushing back a reference, rather than a pointer
p39416
aVThis should be a compile-time error, though
p39417
as(dp39418
g6
V335858
p39419
stp39420
a((dp39421
g2
(lp39422
VC++ is designed with C compatibility in mind, so it is definitely OK to use libraries written in C from a program written in C++
p39423
aVThe language even provides a syntax for using C headers with C++, so what you are trying to do is definitely possible
p39424
aVIn some cases, it may not be ideal from the readability standpoint, because C code may be using opaque handles to emulate objects: this is idiomatic to C, but not to C++
p39425
aVHowever, this issue can be easily adressed by writing a C++ wrapper around the C library, with very little overhead
p39426
as(dp39427
g6
V335858
p39428
stp39429
a((dp39430
g2
(lp39431
VAlthough you have added a new class, you do not have a new instance of that class
p39432
aVIn order to be able to use the additional methods and fields of a model, you need to have an instance of ; the  returns an instance of the "regular" , causing the problem
p39433
aVTo extend functionality of an object you need to write a wrapper class
p39434
aVA wrapper typically takes an object of the "base" class, delegates the base functionality to it, and adds some methods/variables of its own:
p39435
aVNow you can create an instance of  like this:
p39436
as(dp39437
g6
V335858
p39438
stp39439
a((dp39440
g2
(lp39441
VHere is why:
p39442
aV-  should be
p39443
aV- You need to add an  line at the top
p39444
aV- This will be fixed by the #1 change
p39445
aV-  should be  in the declaration
p39446
aVIn addition, printing pointers should be done with  specifier, not :
p39447
aVHere is your fixed program on ideone: link
p39448
as(dp39449
g6
V335858
p39450
stp39451
a((dp39452
g2
(lp39453
VIn your code  goes from  to , and then attempts to take
p39454
aVWhen  is above , this would cause the out of bounds exception
p39455
aVChanging the loop condition to  should address this problem
p39456
aVThe check for the  to be above  inside the loop does not look correct
p39457
as(dp39458
g6
V335858
p39459
stp39460
a((dp39461
g2
(lp39462
VIdeally, you should use : it lets you decide the size dynamically, like this:
p39463
aVAlternatively, you can use a pointer instead of the array, allocate it in the constructor, and  delete in the destructor:
p39464
aVThis is not as good, because once you define the destructor, you need to deal with the rule of three
p39465
as(dp39466
g6
V335858
p39467
stp39468
a((dp39469
g2
(lp39470
VHow is it possible to create an argument array (which can be of different size) just once
p39471
aVUnfortunately, you cannot do that, because there is no way to make a built-in Java array immutable
p39472
aVIf it were possible to make immutable arrays, the following would work:
p39473
aVAlthough the above would work in fully cooperative environments, hostile users could pass an array, and let the key calculate the hash, and then change array elements to introduce errors into your code
p39474
aVThat's why you are absolutely right when you decided to copy the array passed in
p39475
aVYou can change the function to accept variable number of arguments, like this:
p39476
aVThis would let you create arrays implicitly rather than explicitly:
p39477
as(dp39478
g6
V335858
p39479
stp39480
a((dp39481
g2
(lp39482
VYou can pass a delegate into the method to decide the exact type of the object being created, like this:
p39483
aVNow you can pass a lambda for your  parameter, like this:
p39484
as(dp39485
g6
V335858
p39486
stp39487
a((dp39488
g2
(lp39489
VYou are correct on both counts: the biggest reason why  is even available is to let you override it in your own exceptions where you'd like to save the costs of providing the stack trace information, or where you need to hide the information about the location from which the exception may have been thrown
p39490
aVSee this answer for more details
p39491
as(dp39492
g6
V335858
p39493
stp39494
a((dp39495
g2
(lp39496
VThe leak in  method of  was a known issue in iOS 6
p39497
ag49
aV1, which has been fixed in iOS 6
p39498
ag1340
ag1971
ag1972
aVThe  method is deprecated in iOS 6, but it is not responsible for the leak
p39499
as(dp39500
g6
V335858
p39501
stp39502
a((dp39503
g2
(lp39504
Vwhen i use  it provides me with hex value
p39505
aVThis is because you are trying to output an
p39506
aVWhen this happens,  gets called, producing an arbitrary hex sequence which is tied to your stream, but ultimately is very much useless
p39507
as(dp39508
g6
V335858
p39509
stp39510
a((dp39511
g2
(lp39512
VThe code will execute the  once
p39513
aVThat is the whole point of introducing a new operator into the language
p39514
aVYou can verify this by introducing a condition with a side effect, and verifying that the side effect is applied only once:
p39515
aVAfter executing this code,  is , not
p39516
as(dp39517
g6
V335858
p39518
stp39519
a((dp39520
g2
(lp39521
VYou can use the Trapezoidal Rule for this: sort the intervals by time, then calculate the sum as follows:
p39522
as(dp39523
g6
V335858
p39524
stp39525
a((dp39526
g2
(lp39527
VSince  is defined as zero, the result is the same as passing the  with no :
p39528
as(dp39529
g6
V335858
p39530
stp39531
a((dp39532
g2
(lp39533
VThis happens because you are printing a byte array object itself, rather than printing its content
p39534
aVYou should construct a String from the buffer and a length, and print that String instead
p39535
aVThe constructor to use for this is
p39536
aVAbove, len should be the value returned by the call of the read() method
p39537
aVThe charsetName should represent the encoding used by the underlying file
p39538
as(dp39539
g6
V335858
p39540
stp39541
a((dp39542
g2
(lp39543
VYou can use "poor man's regex" of the  function to skip over the characters prior to the first digit, and then reading the double, like this:
p39544
aVNote the asterisk after the first percentage format: it instructs  to read the string without writing its content into an output buffer
p39545
aVHere is a demo on ideone
p39546
as(dp39547
g6
V335858
p39548
stp39549
a((dp39550
g2
(lp39551
VA straightforward translation from English to SQL should work fine:
p39552
as(dp39553
g6
V335858
p39554
stp39555
a((dp39556
g2
(lp39557
VThe  comes from a category added on top of
p39558
aVIn order to use methods added through categories, you need to include the corresponding header
p39559
aVIn this case, the missing header is probably
p39560
as(dp39561
g6
V335858
p39562
stp39563
a((dp39564
g2
(lp39565
VYou can try optimizing the performance at the expense of readability by switching from a 2D array to a 1D array
p39566
aVInstead of  you can use  or  (row-major or column-major order), depending on your access pattern
p39567
aVThis would let you avoid separate allocations
p39568
aVIf the array is large, you could also try packing your booleans into larger integral types
p39569
aVThis would make access code somewhat slower, but a considerably smaller footprint might more than compensate for the slower access with better cache performance
p39570
as(dp39571
g6
V335858
p39572
stp39573
a((dp39574
g2
(lp39575
VNo, you do not need to reallocate the array of strings to lengthen the string at index zero
p39576
aVAll you need is
p39577
as(dp39578
g6
V335858
p39579
stp39580
a((dp39581
g2
(lp39582
VThis is because you need , not
p39583
aVThe  method is for key-value programming
p39584
aVMoreover, the call should be on the , like this:
p39585
as(dp39586
g6
V335858
p39587
stp39588
a((dp39589
g2
(lp39590
VYour hypothetical  method "encodes" the comparison result with the (not so) special code:
p39591
aVWhen the first circle is smaller, it needs to return ,
p39592
aVWhen the circles are the same, it needs to return
p39593
aVWhen the first circle is greater, it needs to return
p39594
aVThis means that the main method should do a decoding of the same:
p39595
aVwhen it sees , it must print "smaller",
p39596
aVwhen it sees , it must print "the same", and
p39597
aVwhen it sees , it must print "greater"
p39598
aVAll of this can be done with a sequence of -- statements:
p39599
as(dp39600
g6
V335858
p39601
stp39602
a((dp39603
g2
(lp39604
VNo, incrementing values in C is not guaranteed to be atomic
p39605
aVYou need to provide synchronization, or use a system-specific library to perform atomic increments/decrements
p39606
as(dp39607
g6
V335858
p39608
stp39609
a((dp39610
g2
(lp39611
VThe  method of the  should be able to remove all whitespace from both ends of the string:
p39612
aV: Returns a copy of the string, with leading and trailing whitespace omitted
p39613
ag1971
ag1972
aVis not a valid escape sequence in Java
p39614
as(dp39615
g6
V335858
p39616
stp39617
a((dp39618
g2
(lp39619
VYou need to move
p39620
aVlines to after the  condition
p39621
aVOtherwise, the cells get new background only after being recycled, while the newly created ones remain without the background
p39622
as(dp39623
g6
V335858
p39624
stp39625
a((dp39626
g2
(lp39627
VThis is your standard string-to-int conversion algorithm:
p39628
as(dp39629
g6
V335858
p39630
stp39631
a((dp39632
g2
(lp39633
VThis is not efficient, because with all three params missing you will create four string objects
p39634
aVYou would be better off appending to a single  object
p39635
aVHowever, this is error reporting code which gets executed only when your code detects a programming error
p39636
aVEfficiency does not matter much in situations like that, because they are not supposed to happen in the first place
p39637
aVUse whatever you believe to be easier to understand
p39638
as(dp39639
g6
V335858
p39640
stp39641
a((dp39642
g2
(lp39643
VIf it's a parameter, I can use the prototype
p39644
aVWhy is this
p39645
aVYou can use a forward declaration whenever yo do not need access to the inner structure of the declared class, e
p39646
ag303
aVwhen you declare a pointer, a reference, or passed it as parameter
p39647
aVYou cannot use a forward declaration to inherit a class, call any of its member functions or access its members, or declare members of non pointer/reference type: this is because the inner structure of the class must be known to the compiler in order to do any of the above
p39648
aVwhy is so bad to include so many headers in the
p39649
aVh file
p39650
aVThis is not universally "bad" in itself, but with many compilers it may slow down the compilation process, so it is typical to minimize your inclusions
p39651
aVModern compilers have useful features (such as precompiled headers) to minimize the impact, so using forward declarations where you can becomes more an aesthetic choice than a practical matter
p39652
as(dp39653
g6
V335858
p39654
stp39655
a((dp39656
g2
(lp39657
VYou may or may not need it
p39658
aVYou need it if your method has to deal with other objects of the type  that must match the type of  exactly, for example:
p39659
aVAbove, passing  would not be enough, because we wouldn't be able to make the shadow of the exactly same type
p39660
aVIn case when there is no such requirement, a simple  would be sufficient
p39661
as(dp39662
g6
V335858
p39663
stp39664
a((dp39665
g2
(lp39666
VThe reason that you cannot do it is as follows: imagine that  worked
p39667
aVThen the compiler would know that  is a , so the following would be OK:
p39668
aVThat would be a runtime error, because  is actually a
p39669
aVIt is not capable of holding  objects
p39670
aVIf you change your code so that  is a , your code would work:
p39671
as(dp39672
g6
V335858
p39673
stp39674
a((dp39675
g2
(lp39676
VYou can do it programmatically by taking the floor of the decimal logarithm of your number (in case of 1234, it's , which is 3), adding one, and subtracting  - the desired number of decimal digits
p39677
aVThis would give you  such that integer-dividing the original value by  gives you the desired result:
p39678
aVHere is a demo on ideone
p39679
aVConverting the above to assembly would be tricky because of the math functions involved
p39680
aVYou can simplify it by defining a table of powers of ten, searching it for the first item that's greater than or equal to the desired number (giving you  above) and then grabbing the -th entry, giving you :
p39681
aVHere is the modified demo
p39682
as(dp39683
g6
V335858
p39684
stp39685
a((dp39686
g2
(lp39687
VYou can forward the  of your  method to the segue, like this:
p39688
aVThe  of the segue would be the button that triggered the segue, so the code triggered from the segue would know what button has triggered it: your  would have the correct
p39689
aVYou can now add it to the returned dictionary at a predetermined key (say, ) and examine it upon the return from the segue
p39690
as(dp39691
g6
V335858
p39692
stp39693
a((dp39694
g2
(lp39695
VRather than passing a list of strings that represent s, you should pass a list of key-value pairs, construct a parametersized statement from them, and use the list of key-value-pairs to bind parameter values, like this:
p39696
aVNow that  separates names from values, your  code could format the SQL expression as
p39697
aVand then bind , , and  to the values passed in the  list
p39698
as(dp39699
g6
V335858
p39700
stp39701
a((dp39702
g2
(lp39703
VDynamic Programming is the right approach here
p39704
aVYour search space is two-dimensional: the current position is your first dimension, and the current velocity is the second dimension
p39705
aVThis means that you need a 2D array , where  is the number of items in the boolean array
p39706
aVThe value at  represents the smallest number of steps required to reach position of  with the velocity of
p39707
aVExamine each point of the search space to check if a stepping stone can be reached with the current velocity
p39708
aVIf the answer is "yes", set the corresponding spot in the search space
p39709
aVAlso set the points for adjacent speeds
p39710
aVThe answer would be at the position
p39711
as(dp39712
g6
V335858
p39713
stp39714
a((dp39715
g2
(lp39716
VAlthough neither way of timing events is exact, the first method is somewhat more precise: consider a situation where the code that you marked with  takes 100 ms
p39717
aVThen the interval between the invocations of  would be , not  as you expected
p39718
as(dp39719
g6
V335858
p39720
stp39721
a((dp39722
g2
(lp39723
VNo,  does not work with non-null terminated arrays: it stops whenever it discovers zero after the end of the array that you pass in
p39724
aVPassing an array without termination is undefined behavior, because it leads the function to read past the end of the array
p39725
aVIn your example, the function has likely accessed bytes that you have allocated to  (although there is no certainty there, because  does not need to follow  in memory)
p39726
aVThe above prints , pointing out the fact that a read past the end of the array has been made
p39727
as(dp39728
g6
V335858
p39729
stp39730
a((dp39731
g2
(lp39732
VThis happens because  in  expects an unsigned integer, not a pointer
p39733
aVHere is how to fix your program to get the behavior that you want:
p39734
aVHere is a link to ideone; the run produces an expected result:
p39735
as(dp39736
g6
V335858
p39737
stp39738
a((dp39739
g2
(lp39740
VLike any Java array, object fields of array type  default to , regardless of the exact type of :
p39741
aVIn the example above, , , and  will be  until you assign them a value
p39742
as(dp39743
g6
V335858
p39744
stp39745
a((dp39746
g2
(lp39747
VAlthough this is not the fastest option globally, it is the fastest one for which you do not need to code anything
p39748
aVIt should be sufficient for filtering drop-down items
p39749
aVFor longer texts, you may want to go with the KMP Algorithm, which has a linear timing complexity
p39750
aVNote, however, that it would not make any difference for very short search strings
p39751
aVFor searches that have lots of matches (e
p39752
ag303
aVones that you get for the first one to two characters) you may want to precompute a table that maps single letters and letter pairs to the rows in your drop-down list for a much faster look-up at the expense of using more memory (a pretty standard tradeoff in programming in general)
p39753
as(dp39754
g6
V335858
p39755
stp39756
a((dp39757
g2
(lp39758
VThe reason your program does not work on some platforms is that it uses non-portable behavior - casting a C-style array of s to  is not guaranteed to work:
p39759
aVThat is also the reason why the formatting of the primitives, along the  lines, does not work:  cannot contain primitives, so an  is represented by  with an  inside
p39760
aVIn general, C (and by extension, Objective C) do not support dynamic creation of variable-argument lists
p39761
aVThat is why you cannot use the formatting methods that require variable argument lists
p39762
aVUnfortunately, your best option requires a lot of coding
p39763
aVMake a method like this:
p39764
aVThis code assumes that the first argument is an array, not a string
p39765
aVEach element must contain the format for the corresponding argument
p39766
aVFormats for numbers will be passed to , which lets you format non-primitive objects that represent numbers
p39767
aVAll other formats will be passed to
p39768
aVNote that separators must be included with the format string of the corresponding object
p39769
aVIt is up to you to add separators in front of all objects except the initial one, or after all objects except the trailing one
p39770
as(dp39771
g6
V335858
p39772
stp39773
a((dp39774
g2
(lp39775
VHere is an algorithm that you could follow to accomplish the task:
p39776
aVConstruct a union of the two arrays
p39777
aVConstruct the intersection of the two arrays
p39778
aVSubtract the intersection from the union to get your result
p39779
aVJava collections support , , and
p39780
aVUse  to construct unions,  for constructing intersections, and  for subtraction, like this:
p39781
as(dp39782
g6
V335858
p39783
stp39784
a((dp39785
g2
(lp39786
VIf you would like to use a default when the incoming data is , empty, or consists entirely of whitespace characters, you can do it like this:
p39787
aVHowever, this is a "quick and dirty" way of achieving what you need, because the position of each named parameter remains hardcoded
p39788
aVA more robust way would be writing a mini-parser that pays attention to the names of attributes specified in the file, rather than replacing them with an empty string
p39789
as(dp39790
g6
V335858
p39791
stp39792
a((dp39793
g2
(lp39794
VYou can try this code that moves the assignment into the invocation of :
p39795
aVNote that this is not necessarily more readable
p39796
aVIn fact, your version is pretty good in terms of readability
p39797
aVThe only thing I would do is inverting the condition to decrease nesting, but I'd leave everything else in place:
p39798
as(dp39799
g6
V335858
p39800
stp39801
a((dp39802
g2
(lp39803
VThe error happens because your code does not consume invalid input in the  clause
p39804
aVYour program tries to read it again and again, causing another exception
p39805
aVChanging your code as follows should fix the problem:
p39806
aVIf you would like to make your code more readable to others, come up with names that explain their purpose
p39807
aVFor example, variable  is used to decide if the reading should continue or not
p39808
aVRenaming it to  would make your loop easier to understand:
p39809
as(dp39810
g6
V335858
p39811
stp39812
a((dp39813
g2
(lp39814
VIf you make the same  from a header included in multiple translation units, each resultant file would get its own copy of the object, potentially increasing the footprint of your application
p39815
aVMoreover, the objects would reside at different addresses, potentially making equality comparisons slower
p39816
aVLink-time optimization can combine identical constants, but that would be optional
p39817
aVA certain way of avoiding duplicates would be placing your constants in a separate translation unit (i
p39818
ag630
aVa CPP file), and using  in your header file
p39819
aVHeader:
p39820
aVconstants
p39821
aVcpp:
p39822
aVThis would ensure a single definition for each constant
p39823
as(dp39824
g6
V335858
p39825
stp39826
a((dp39827
g2
(lp39828
VYou can do it with reflection:
p39829
aV[EDIT by Matthew Watson]
p39830
aVI've taken the liberty of adding a further code sample, based on the code above
p39831
aVYou could generalise the solution by writing a method that will return an  for any object type:
p39832
aVAnd you can generalise it even further with generics:
p39833
aVUsing this second form, to iterate over all the string properties of an object you could do:
p39834
as(dp39835
g6
V335858
p39836
stp39837
a((dp39838
g2
(lp39839
VUser defaults are generally OK for storing small amounts of data that does not need encryption
p39840
aVThe data which is large or could potentially grow over time should go either into the file system or into Core Data
p39841
aVAnything that needs to be secret (e
p39842
ag303
aVpasswords) must go into keychain
p39843
aVHere is an answer with suggestions on how to choose among the storage models for your app
p39844
as(dp39845
g6
V335858
p39846
stp39847
a((dp39848
g2
(lp39849
VYou cannot determine the class of a  instance, because it does not have one: it can be, quite literally, of any type derived from the type of the variable
p39850
aVFor example,  is perfectly compatible with :
p39851
aVSince the run-time capabilities of different subclasses can vary a lot, it is always up to your program to decide what kind of objects it wants
p39852
as(dp39853
g6
V335858
p39854
stp39855
a((dp39856
g2
(lp39857
VYou need to wrap your function in a binary operator, like this:
p39858
aVNow you can use  in a declaration:
p39859
aVHere is a demo on ideone
p39860
aVIt correctly orders 128 ahead of 3, because 3 has two bits set, while 128 has only one
p39861
as(dp39862
g6
V335858
p39863
stp39864
a((dp39865
g2
(lp39866
VAssuming that you are using ADO
p39867
aVNET to access your database, your access model should be fine, because
p39868
aVNET uses connection pooling to minimize performance impacts of closing and re-opening DB connections
p39869
aVYour overall architecture may be questioned, however: polling for updates on a timer is usually not the best option
p39870
aVA better approach would be maintaining an update sequence in a separate table
p39871
aVThe table would have a single row, with a single  column initially set to zero
p39872
aVEvery time an update to the "real" data is made, this number is bumped up by one
p39873
aVWith this table in place, your program could read just this one number every second, rather than re-reading your entire data set
p39874
aVIf your program detects that the number is the same as it was the previous time, it stops and waits for the next timer interval; otherwise, it re-reads the data set
p39875
as(dp39876
g6
V335858
p39877
stp39878
a((dp39879
g2
(lp39880
VI was thinking of creating an index on date,earnings but feel weird about it since date is already in an index
p39881
aVIt is OK to include the same column in multiple indexes as needed
p39882
aVCreating an index on  is definitely OK, but a single index on  would probably be sufficient as well
p39883
aVYou could also consider indexing  and  separately, and see if the second query executes in roughly the same time (it should)
p39884
as(dp39885
g6
V335858
p39886
stp39887
a((dp39888
g2
(lp39889
VIf the increment method alters the value of y, is the value of z also changed
p39890
aVIt depends on the way  is altered: if the method assigns  a new value,  remains unchanged, because parameters in Java are passed by value, including object references
p39891
aVOn the other hand, if the method alters the  inside the  object, then the  inside  is going to change as well, because that's the same object as
p39892
aV, on the other hand, will be changed to whatever the  method returns
p39893
as(dp39894
g6
V335858
p39895
stp39896
a((dp39897
g2
(lp39898
VThe most optimized way for a fixed  is gong through all arrays five times, picking the highest element not taken so far on each pass
p39899
aVYou need to mark the element that you take in order to skip it on subsequent passes
p39900
aVThis has the complexity of  (you go through all  elements five times), which is as fast as it can get
p39901
as(dp39902
g6
V335858
p39903
stp39904
a((dp39905
g2
(lp39906
VThis is because  takes a ; you need to call , which does take a regular expression
p39907
as(dp39908
g6
V335858
p39909
stp39910
a((dp39911
g2
(lp39912
VThe problem with your code is that it finds the first newline, and uses a substring from zero to its location as the title
p39913
aVTrimming the string before looking for the newline should fix this problem: the first non-empty line, if any, would be selected for the title:
p39914
as(dp39915
g6
V335858
p39916
stp39917
a((dp39918
g2
(lp39919
VHere is what you should do to debug this:
p39920
aVAdd  to see what's inside the
p39921
aVMake sure that the printed value matches the expected file name; if necessary, change the command line to look for an absolute path, i
p39922
ag630
aVor  rather than
p39923
aVCheck that a file with that name exists in the current directory
p39924
aVCheck that the user under which your program runs (usually, that's your user) has access permissions to read the file
p39925
as(dp39926
g6
V335858
p39927
stp39928
a((dp39929
g2
(lp39930
VYour reading of what is going on here is absolutely right: the "special case" that they are talking about is related to null-checking a parameter, not to the iteration of the list
p39931
aVIn fact, you could move the  statement outside the loop for a slightly more efficient but less readable solution:
p39932
as(dp39933
g6
V335858
p39934
stp39935
a((dp39936
g2
(lp39937
VThe most common way of implementing something like this is counting with a : define a  which stores zeros for each element of your enumeration
p39938
aVThen walk through your list, and increment the counter for each element that you find in the list
p39939
aVAt the same time, maintain the current  count
p39940
aVFinally, walk through the counter map entries, and add to the output list the keys of all entries the counts of which matches the value of
p39941
as(dp39942
g6
V335858
p39943
stp39944
a((dp39945
g2
(lp39946
VProtected members are accessible from immediately derived and sub-derived classes without any qualifiers: rather than writing
p39947
aVyou can write
p39948
aVand it will compile fine, as long as it is in a method of a derived class
p39949
aVHowever, in order for this to work, you need to remove members with the same name from the derived class itself: otherwise, the base member is hidden, and cannot be accessed through more than one level of inheritance hierarchy through the normal syntax of the language, i
p39950
ag630
aVwithout using reflection
p39951
as(dp39952
g6
V335858
p39953
stp39954
a((dp39955
g2
(lp39956
VYou can use the  operator, which is standard on all SQL-compliant RDBMS:
p39957
aVThe idea behind this query is self-explanatory: the oldest owner is such an owner  that there are no other owner  such that  is older than
p39958
as(dp39959
g6
V335858
p39960
stp39961
a((dp39962
g2
(lp39963
VIn Java, you use  to find the lower bound of the equal range in a sorted list ( provides a similar capability for arrays)
p39964
aVThen you continue iterating linearly until you hit to the end of the equal range
p39965
aVThese methods work for methods implementing the  interface
p39966
aVFor classes that do not implement the , you can supply an instance of a custom  for comparing the elements of your specific type
p39967
as(dp39968
g6
V335858
p39969
stp39970
a((dp39971
g2
(lp39972
VThere are several ways of handling errors of this kind in Objective C:
p39973
aVReturning the default value - typically, the default value is
p39974
aVSince performing operations on  objects is allowed in Objective C, this is relatively safe
p39975
aVProducing  objects - this is more typical of errors that can be addressed by end users, such as connection and configuration problems
p39976
aVThe unfortunate side effect of this kind of API is the need to set up and pass an extra parameter
p39977
aVUsing an assertion - this is a good way of handling "programming errors", i
p39978
ag630
aVwhen your program's arguments are out of their specified ranges
p39979
aVThrowing an exception - this option is available in the language, but Apple strongly discourages against using it
p39980
aVI mentioned it here for completeness, even though I never use this option myself
p39981
as(dp39982
g6
V335858
p39983
stp39984
a((dp39985
g2
(lp39986
VYou can do it like this:
p39987
aVNote that the  dictionary is unnecessary, because you can do this:
p39988
as(dp39989
g6
V335858
p39990
stp39991
a((dp39992
g2
(lp39993
VJava does not make a guarantee as to which element among the equal ones it is going to return
p39994
aVWhen you have multiple elements in an equal range, you need to walk the list down to find the first element that's equal to what you are looking for, like this:
p39995
aVYou can wrap this logic in a static function to avoid writing an explicit loop each time
p39996
as(dp39997
g6
V335858
p39998
stp39999
a((dp40000
g2
(lp40001
VYou need to declare the variable outside the  statement, and then assign it in the two branches, like this:
p40002
aVBetter yet, you can set the  inside the , and then create  after the conditional:
p40003
as(dp40004
g6
V335858
p40005
stp40006
a((dp40007
g2
(lp40008
VThis is because  has higher precedence than , so you need to use parentheses to force the order of evaluation that you need:
p40009
aVHere is a link to a demo on ideone
p40010
as(dp40011
g6
V335858
p40012
stp40013
a((dp40014
g2
(lp40015
VUnfortunately, searching for strings ending with a particular pattern is difficult on most databases+, because searching for string suffixes cannot use an index
p40016
aVThis results in full table scans, which may be slow on tables with millions of rows
p40017
aVIf your database supports reverse indexes, add one for your string key column; otherwise, you can improve performance by simulating reverse indexes:
p40018
aVAdd a column for storing your string key in reverse
p40019
aVIf your RDBMS supports computed columns, add one for the reversed key
p40020
aVOtherwise, define a trigger that populates the reversed column from the key column
p40021
aVCreate an index on the reversed column
p40022
aVUse the reversed column for your searches by passing in the reversed suffix that you are looking for
p40023
aVFor example, if you have data like this
p40024
aVthen the augmented table would have
p40025
aVand your search for  would ask for
p40026
aVSince string indexes speed up lookups by prefix, the "starts with" lookup would go much faster
p40027
aV+ One notable exception is Oracle, which provides reverse key indexes specifically for situations like this
p40028
as(dp40029
g6
V335858
p40030
stp40031
a((dp40032
g2
(lp40033
VI would use  instead of concatenation for clarity:
p40034
aVWith this method you can change the way the output looks in a way that does not require much "mental reconstruction" from the readers of your code
p40035
aVFor example, should you decide to change the output to, say,  you can simply rewrite your format line as follows:
p40036
as(dp40037
g6
V335858
p40038
stp40039
a((dp40040
g2
(lp40041
VYou can use  or  on all characters to make sure that you catch duplicates that are different only in their case:
p40042
aVAs a side note, a canonical way of assigning  to a  in C++ is
p40043
aValthough both ways work fine
p40044
as(dp40045
g6
V335858
p40046
stp40047
a((dp40048
g2
(lp40049
VThe reason the second print does not work is that you are using a global variable instead of a local one:
p40050
aVWhen you declare a variable outside a function or a class, it becomes global variable
p40051
aVGlobal variables survive function invocations, and retain the value that was last set into them
p40052
aVIn order to be local, a variable needs to be declared inside , initialized to the stack's head, and then discarded upon exiting the function
p40053
aVThe same is true about
p40054
aVThe  and  variables are unused, and can be removed from the source code
p40055
as(dp40056
g6
V335858
p40057
stp40058
a((dp40059
g2
(lp40060
VThe biggest danger of "hidden globals" (in C's world they are called ) comes when you write concurrent programs
p40061
aVOnce you venture into multithreading, having a single blackboard is no longer sufficient: each thread needs its own one
p40062
aVFor situations like that, dynamic allocation is more appropriate
p40063
aVIf you do not worry about multithreading, having a module-scoped "hidden global" variable is perfectly fine
p40064
as(dp40065
g6
V335858
p40066
stp40067
a((dp40068
g2
(lp40069
VRecursion is a step in the right direction
p40070
aVThe trick to applying it right is to think that you work with one line at a time, and pretend that your recursive method is already completed
p40071
aVBy the time you are done, the method will be completed, and so your code would work (it's OK for this to sound a little like magic at first)
p40072
aVTo start, add this method to your  class:
p40073
aVThe  array would contain the list of lines that you've found so far; the caller would pass an initially empty  to your function
p40074
aVThe  object itself would supply the connected lines that you need to try
p40075
aVThere will be a loop over the connected lines
p40076
aVOn each iteration, your code will
p40077
aVCheck that the connected line is not on the  that you found so far
p40078
aVIf it is not, add the connected line to the end of the , and call  on it
p40079
aVThis is where the magic happens: you have not finished writing your method, yet you can call it
p40080
aVIf  returns , your function returns  too
p40081
aVIf  is returned, your loop removes the last line that you added to the , and move on to the next one
p40082
aVOnce all connected lines in the loop are exhausted without returning , the method returns  to its caller
p40083
aVThat's it, really
p40084
aVCall this method on the line from which you would like to create a circuit, pass it an empty , and see if the method returns
p40085
aVIf it does, the array that you passed would contain your circuit
p40086
as(dp40087
g6
V335858
p40088
stp40089
a((dp40090
g2
(lp40091
VYou cannot use  to initialize a member of  array, because  is a variable that is run-time constant, not a compile-time constant
p40092
aVAggregate initializers in C must be compile-time constants, that's why the code from your post does not compile
p40093
aVAs a variable,  has its own place in memory, which is initialized to an array of items
p40094
aVYou can use such variable by a pointer, like this:
p40095
aVAlternatively, you can make it a preprocessor constant:
p40096
aVIf defined in this way, the  would no longer be a variable: it would be a preprocessor definition that vanishes before the compiler is done
p40097
aVI would recommend against the preprocessor method, but it's there in case you must do it
p40098
as(dp40099
g6
V335858
p40100
stp40101
a((dp40102
g2
(lp40103
VThe simplest way would be to walk your string with a loop, and take two-character substrings from the current position:
p40104
aVAn advanced solution would do the same thing with LINQ, and avoid an explicit loop:
p40105
aVThe second solution is somewhat more compact, but it is harder to understand, at least to someone not closely familiar with LINQ
p40106
as(dp40107
g6
V335858
p40108
stp40109
a((dp40110
g2
(lp40111
VIt is unlikely that you would be able to speed up the algorithm by much, because the only "false starts" that  would find along the way to  would be the closing tags, while  is found very close to the beginning of file
p40112
aVOne way to speed up your code is avoid calling  multiple times:
p40113
as(dp40114
g6
V335858
p40115
stp40116
a((dp40117
g2
(lp40118
VThe reason it works with the  in place is a coincidence: your program has undefined behavior, because you are returning a pointer to local
p40119
aVThe memory allocated to local variables gets reused upon return from a function, so referencing that memory outside the function leads to accessing garbage values
p40120
aVSometimes, however, a particular spot does not get reused because of the way the caller is using the stack
p40121
aVIn this case, the program gives an appearance of working, but even a small change to the code could lead to producing incorrect results or even a crash
p40122
aVChange your code as follows:
p40123
aVand call this function like this:
p40124
aVThis will fix the problem
p40125
as(dp40126
g6
V335858
p40127
stp40128
a((dp40129
g2
(lp40130
VThis is because 0
p40131
aV25 is a power of two (i
p40132
ag630
aV2^-2), while 0
p40133
aV8 is not
p40134
aVOnly exact sums of powers of two can be represented exactly; all other numbers, including 0
p40135
aV8, are represented as an approximation, which has a different precision between  and
p40136
aVThe  in  is a , while  is a
p40137
aVTheir representations are different, and so are their values
p40138
as(dp40139
g6
V335858
p40140
stp40141
a((dp40142
g2
(lp40143
VThe code should not use the value of  in the expression, like this:
p40144
aVNote that the above expression is a compile-time constant, i
p40145
ag630
aVthe  computation is performed by the compiler, not by the CPU of the target system
p40146
aVAlternatively, you can do it on several lines, as follows:
p40147
as(dp40148
g6
V335858
p40149
stp40150
a((dp40151
g2
(lp40152
VSince there is no "plain text" mode on iPhone, you need to draw nearly everything manually
p40153
aVThe simplest solution would be to draw everything in your favorite graphics editor, and play a sequence of images as an animation: first, an image with only a prompt, then after a few seconds an image with the prompt and some text, then with some more text, and so on
p40154
aVPlaying a beeping sound would add to the general excitement of it
p40155
aVAs far as the blinking cursor goes, you can use  animation for it: make an image of a small white rectangle, place it in  on top of your image with the text, and then animate its "visibility" property between "Yes" and "No" on a short timer, with the "repeat" flag set to "Yes"
p40156
as(dp40157
g6
V335858
p40158
stp40159
a((dp40160
g2
(lp40161
VAm I right in assuming that any attempt to use SQL transactions ( and  style) is only going to be very confusing and broken, given the potential for the Java threads to interleave
p40162
aVThis is absolutely right
p40163
aVDoes the Connection object 'know' which Java thread is using it to make queries
p40164
aVNo, it does not
p40165
aVShould I have one Connection object per Java thread and use the SQL transactions that way
p40166
aVYes, this is one way of doing it
p40167
aVThe downside to the "connection per thread" allocation is a potential to open more connections than you need, leading to sub-optimal use of resources
p40168
aVYou can also open a connection only when the thread needs it, and close it once thread is done with the RDBMS access
p40169
aVIf you go this route, make sure that you use a connection pool to reduce the overhead of re-opening connections multiple times
p40170
as(dp40171
g6
V335858
p40172
stp40173
a((dp40174
g2
(lp40175
VIn a chain of operations like that, it could mean any of the following:
p40176
aVpDataSet is null
p40177
aVTables for one of the table names is null
p40178
aVRows are empty for one of the tables
p40179
aVOne of the rows is missing the specified column, or
p40180
aVThe value in one of the columns is null
p40181
aVThe last option is the most likely one
p40182
aVTo see if that's the case, replace all the ToString calls with this:
p40183
as(dp40184
g6
V335858
p40185
stp40186
a((dp40187
g2
(lp40188
VYes, this produces not one, but two memory leaks: both allocated s are leaked
p40189
aVMoreover, the first one is leaked irrecoverably: once you assign  a  the second time, the first allocated item is gone forever
p40190
as(dp40191
g6
V335858
p40192
stp40193
a((dp40194
g2
(lp40195
VDivide and conquer algorithms work faster because they end up doing less work
p40196
aVConsider the classic divide-and-conquer algorithm of binary search: rather than looking at  items to find an answer, binary search ends up checking only  of them
p40197
aVNaturally, when you do less work, you can finish faster; that's precisely what's going on with the divide-and-conquer algorithms
p40198
aVOf course the results depend a lot on how well your strategy does at dividing the work: if the division is more or less fair at every step (i
p40199
ag630
aVyou divide the work in half) you get the perfect  speed
p40200
aVIf, however, the dividing is not perfect (e
p40201
ag303
aVthe worst case of quicksort, when it spends  sorting the array because it eliminates only a single element at each iteration) then divide-and-conquer strategy is not helpful, as your algorithm does not reduce the amount of work
p40202
as(dp40203
g6
V335858
p40204
stp40205
a((dp40206
g2
(lp40207
Vallows regular expressions as far as I know
p40208
aVUnfortunately, it does not allow regular expressions: the syntax is misleadingly close, but there is nothing even remotely similar to the regex in the implementation of
p40209
aVAll that's there is a support for character classes of regex, so  is treated implicitly as
p40210
aVThat's why your call of  translates into read a string consisting of characters other than
p40211
aVTo solve your problem at hand, you can set up a loop that read the input character by character
p40212
aVEvery time you get a , check that
p40213
aVYou have at least three characters in the input that you've seen so far,
p40214
aVThat the character immediately before  is an , and
p40215
aVThat the character before the  is another
p40216
aVIf all of the above is true, you have reached the end of your anticipated input sequence; otherwise, your loop should continue
p40217
as(dp40218
g6
V335858
p40219
stp40220
a((dp40221
g2
(lp40222
VOnce you get the declared field, you can call its  method, like this:
p40223
aVIf all objects there are of the same type, you could move the call of  outside the loop to save yourself some CPU cycles
p40224
as(dp40225
g6
V335858
p40226
stp40227
a((dp40228
g2
(lp40229
VThere are two approaches I see to simplify this query:
p40230
aVWrite a script that generates your queries - feed your script the name of the table and the suspected columns, and let it produce a query that checks each pair of columns for equality
p40231
aVThis is the fastest approach to implement in a one-of situation like yours
p40232
aVWrite a query that "normalizes" your data, and search against it - self-join the query to itself, then filter out the duplicates
p40233
aVHere is a quick illustration of the second approach:
p40234
aVThere is a lot of manual work for 100 columns (at least it does not grow as , as in the first approach, but it is still a lot of manual typing)
p40235
aVYou may be better off generating the selects connected with  using a small script
p40236
as(dp40237
g6
V335858
p40238
stp40239
a((dp40240
g2
(lp40241
VThe two reasons behind telling your RDBMS that the two keys are related are
p40242
aVSpeeding up the retrieval - RDBMS may add implicit indexes to speed up joins when you declare a primary-to-foreign key relation
p40243
aVDealing with referential integrity - RDBMS can perform a check on deleting a primary key to see if you are deleting a row referenced from "child" records, and optionally delete child records or throw an error
p40244
aVYour RDBMS would also tell you if you try inserting a record with a foreign key that has no matching primary key in the parent table
p40245
aVOther than that, the keys and the non-key fields can be used in similar ways
p40246
aVIn particular, it is certainly alright to join on columns that are not declared as primary or foreign keys
p40247
as(dp40248
g6
V335858
p40249
stp40250
a((dp40251
g2
(lp40252
VYou can simplify your code as follows:
p40253
as(dp40254
g6
V335858
p40255
stp40256
a((dp40257
g2
(lp40258
VThere are several problems with your code:
p40259
aVYou need only one, not two, loops
p40260
aVYou are using the character representing the digit, i
p40261
ag630
aVor , not the value of the digit
p40262
aVYour math is a little off: in  the  should be replaced with the position of the digit starting from the back
p40263
aVHere is how you can fix your code:
p40264
aVHere is a demo on ideone
p40265
as(dp40266
g6
V335858
p40267
stp40268
a((dp40269
g2
(lp40270
VYou need to pass , not  in the format string of
p40271
aVWhen you pass , the format string has zero format specifiers, leading to the semantic analyzer to produce a warning
p40272
aVThat's also the reason why nothing gets entered into your  variable, so the countdown does not happen either
p40273
as(dp40274
g6
V335858
p40275
stp40276
a((dp40277
g2
(lp40278
VThe idea behind  is producing a  representation of your object
p40279
aVPrinting it or using it in any other way is entirely up to you
p40280
as(dp40281
g6
V335858
p40282
stp40283
a((dp40284
g2
(lp40285
VThe typical approach commonly known as the virtual constructor idiom is to define another virtual method for cloning the concrete class, make it virtual in the abstract base, and call it as needed to produce instances of the desired class without knowing its type:
p40286
as(dp40287
g6
V335858
p40288
stp40289
a((dp40290
g2
(lp40291
VAlthough LINQ2XML by itself lacks the necessary "magic", it offers enough "underpinning" for you to build the code yourself
p40292
aVHere is an example that shows you how to read an  from an element at arbitrary depth (assuming that the path is unique, of course):
p40293
aVYou can use this extension method as follows:
p40294
aVThe method would work even with some nesting, for example if your document looks like this
p40295
aVyou would get the value like this:
p40296
as(dp40297
g6
V335858
p40298
stp40299
a((dp40300
g2
(lp40301
VHere is a query that returns the result that you are looking for:
p40302
aVThe idea is to pick a row in a correlated query such that its ID matches that of the current row, and the date is the highest one prior to your target date of
p40303
aVWhen such row does not exist, the date for the current row is returned
p40304
aVThis date needs to be replaced with a ; this is what the  statement at the top is doing
p40305
aVHere is a demo on sqlfiddle
p40306
as(dp40307
g6
V335858
p40308
stp40309
a((dp40310
g2
(lp40311
VIs it correct to say that everywhere recursion is used a for loop could be used
p40312
aVYes, because recursion in most CPUs is modeled with loops and a stack data structure
p40313
aVAnd if recursion is usually slower what is the technical reason for using it
p40314
aVIt is not "usually slower": it's recursion that is applied incorrectly that's slower
p40315
aVOn top of that, modern compilers are good at converting some recursions to loops without even asking
p40316
aVAnd if it is always possible to convert an recursion into a for loop is there a rule of thumb way to do it
p40317
aVWrite iterative programs for algorithms best understood when explained iteratively; write recursive programs for algorithms best explained recursively
p40318
aVFor example, searching binary trees, running quicksort, and parsing expressions in many programming languages is often explained recursively
p40319
aVThese are best coded recursively as well
p40320
aVOn the other hand, computing factorials and calculating Fibonacci numbers are much easier to explain in terms of iterations
p40321
aVUsing recursion for them is like swatting flies with a sledgehammer: it is not a good idea, even when the sledgehammer does a really good job at it+
p40322
aV+ I borrowed the sledgehammer analogy from Dijkstra's "Discipline of Programming"
p40323
as(dp40324
g6
V335858
p40325
stp40326
a((dp40327
g2
(lp40328
VOne way to do so is passing into your method a mutable object, such as a list, and let the method change its content
p40329
aVFor example, in this case you can pass an empty list of error messages
p40330
aVIf there are no errors, the list would come back empty; otherwise, the method would insert whatever errors it finds into the list, and the caller would be able to retrieve them:
p40331
aVcaller:
p40332
as(dp40333
g6
V335858
p40334
stp40335
a((dp40336
g2
(lp40337
VIn order to stay within the MVC guidelines, your business-level calculations need to happen in your model layer
p40338
aVHowever, not all calculations qualify as "business calculations": very often you must perform calculations to decide on UI matters, such as
p40339
aVVisibility of individual UI elements
p40340
aVSize of individual ui elements,
p40341
aVLocations and direction of touches,
p40342
aVand so on
p40343
aVIf your calculations are of the business kind, then you should move it into the model
p40344
aVOtherwise, keeping it in the view or the controller is preferred
p40345
as(dp40346
g6
V335858
p40347
stp40348
a((dp40349
g2
(lp40350
VIn Java, all objects must be initialized
p40351
aVThe second case  is also an initialization, except that the compiler lets you avoid the explicit call: object creation is still there
p40352
aVStarting with Java 5, the compiler also "knows" about wrappers for Java primitives, letting you use primitive constants in expressions that require a wrapper class (this is called autoboxing)
p40353
aVAll local variables must be initialized explicitly, while member fields can be initialized implicitly to  or the default value of the primitive
p40354
as(dp40355
g6
V335858
p40356
stp40357
a((dp40358
g2
(lp40359
VThe simplest way of making a string from a character array is using a constructor that takes a pointer and the length, like this:
p40360
as(dp40361
g6
V335858
p40362
stp40363
a((dp40364
g2
(lp40365
VThe program skips the initial spaces/tabs in the  string, and then copies all characters into , skipping over the "new line"  characters
p40366
aVIt also looks for the breaks (spaces or tabs) in the  string, makes a note of the last non-blank character that it sees, and marks its position
p40367
aVAt the end, the portion of the  from the first non-blank to the last non-blank is copied back into the , with  characters removed
p40368
aVFor example, if the incoming command string looks like this:
p40369
aVthen the output is going to look like this:
p40370
aVThe purpose behing it may be to "sanitize" a command string before passing it to an external system that does not allow  and leading/trailing blanks
p40371
as(dp40372
g6
V335858
p40373
stp40374
a((dp40375
g2
(lp40376
VYou can always add  to your set, so when the real set is empty, you get no syntax error:
p40377
aVvs
p40378
aVYour generator would be simpler, too, because you can print a  in front of every item that you add, without checking if it's the first one or not
p40379
aVOf course since you are generating your SQL, the standard precautions against SQL Injection apply: do not let user input anywhere near the SQL that you generate
p40380
as(dp40381
g6
V335858
p40382
stp40383
a((dp40384
g2
(lp40385
VAssuming that descendants of  and  are of the same type, you should be able to use LINQ's  like this:
p40386
as(dp40387
g6
V335858
p40388
stp40389
a((dp40390
g2
(lp40391
VWhat you have is perfectly fine: as long as you do not store s in the  vector of pointers, there is no need to null-check the values returned from the iterator
p40392
aVUnfortunately, a vector of pointers is your only option for containers of polymorphic objects
p40393
aVYou can make a vector of shared pointers to simplify dealing with deletions, but the basic idea would remain the same
p40394
as(dp40395
g6
V335858
p40396
stp40397
a((dp40398
g2
(lp40399
VThis happens when
p40400
aVthe first use of the function precedes its definition,
p40401
aVthere is no prototype for the function, or
p40402
aVa required header file is missing
p40403
aVMake sure that there is a prototype in the text or in a header, or move the function to the front of the file, before its first use
p40404
as(dp40405
g6
V335858
p40406
stp40407
a((dp40408
g2
(lp40409
VThe second part of the loop condition tells the code how many elements the loop must skip before the deletion
p40410
aVWhen you need to delete the second element, you need to skip one element ahead of it
p40411
aVIn general, to delete element number N, you need to skip N-1 elements
p40412
as(dp40413
g6
V335858
p40414
stp40415
a((dp40416
g2
(lp40417
VThe function runs a rather simple brute force search with backtracking: at each invocation level it tries adding  to the number, and see if starting from the resultant number gets you to the goal
p40418
aVIf it does, the result is returned; otherwise, the number is multiplied by , and the search for the goal continues from that new number
p40419
aVAs the recursion goes along, the textual representation of the expression producing the number is passed to the next invocation levels
p40420
aVThe search for  goes as follows:
p40421
as(dp40422
g6
V335858
p40423
stp40424
a((dp40425
g2
(lp40426
VThere is no regex solution for this, but you can implement a "distance algorithm" to measure the relative similarity of two words
p40427
aVOne very common algorithm for this is Levenshtein Distance, or Edit Distance: it tells you how many "editing actions" it would take to go from the answer the user typed in to the correctly spelled answer
p40428
aVReplacing, inserting, or deleting a symbol counts as one action
p40429
aVIf the distance is two or less, the answer the user typed in is likely just a spelling error; if the distance is three or more, it's either a very poorly spelled answer, or an incorrect answer (both should be counted as incorrect)
p40430
aVThe wikipedia article linked above has pseudocode implementation for the algorithm
p40431
as(dp40432
g6
V335858
p40433
stp40434
a((dp40435
g2
(lp40436
VThis is because arrays need to be initialized
p40437
aVAdd this to your code:
p40438
aVAlternatively, you can use :
p40439
as(dp40440
g6
V335858
p40441
stp40442
a((dp40443
g2
(lp40444
VThe logic should be as follows:
p40445
aVYour current code does not do the tie breaking correctly: it returns  when scores are equal, but , making the sort order the items incorrectly
p40446
as(dp40447
g6
V335858
p40448
stp40449
a((dp40450
g2
(lp40451
VThis is done for performance reasons: passing data to console is too expensive (in terms of execution speed) to do it character-by-character
p40452
aVThat is why the output is buffered until the newline is printed: characters are collected in an array until it is time to print, at which time the entire string is passed to the console
p40453
aVYou can also force output explicitly, like this:
p40454
as(dp40455
g6
V335858
p40456
stp40457
a((dp40458
g2
(lp40459
VYour thinking is absolutely correct: you can use compiler's help in converting textual representation to binary
p40460
aVRather than using headers, I would put the data in a separate translation unit, and keep a fixed header with forward declarations of the data structures populated by your script:
p40461
aVHeader:
p40462
aVCPP file:
p40463
aVThe biggest difference between the two approaches is that keeping binary representation in a file lets you modify whatever is represented after you have compiled everything
p40464
aVIn fact, you could swap in another binary in production, and it would take effect immediately
p40465
aVIn contrast, the compiler route forces you to recompile your program every time your binary data needs to change: effectively, your binary data becomes "baked into" your program's content
p40466
aVIn environments that support dynamic linking you can make a middle ground solution by isolating the binary data in a separate dynamically linked library, and compiling that library separately from your "main" code
p40467
aVThe binary data remains part of code, but now you can swap in a new piece of data independently of the rest of your program
p40468
as(dp40469
g6
V335858
p40470
stp40471
a((dp40472
g2
(lp40473
VThis converts the first command-line argument to an integer
p40474
aVFor example, if you call your program like this
p40475
aVthen  will be
p40476
aVNote that before accessing  one must check that  is greater than , i
p40477
ag630
aVcheck that at least one argument has been passed to your program on a command line
p40478
as(dp40479
g6
V335858
p40480
stp40481
a((dp40482
g2
(lp40483
VYou are missing a category header for the  method of
p40484
aVIt looks like you are using an extension category defined by the user Karl in the third post on this page (I copied a header below):
p40485
aVYour code needs to import this header in order to avoid the compilation error
p40486
aVYou also need to add the implementation to your project, either as a source or as a library, in order to avoid a linking error
p40487
as(dp40488
g6
V335858
p40489
stp40490
a((dp40491
g2
(lp40492
VThe first argument of  must be modifiable
p40493
aVYour code passes a string literal, which is not modifiable
p40494
aVThis leads to undefined behavior
p40495
aVThe simplest modification that will fix the problem is as follows:
p40496
aVYou should also note that  is an older function which is not reentrant, because it uses static variables to save its state
p40497
aVIn the new code you should use the reentrant version of the function - , which requires you to pass memory for saving the state
p40498
as(dp40499
g6
V335858
p40500
stp40501
a((dp40502
g2
(lp40503
VChange the signature of your selector to accept the gesture recognizer, like this:
p40504
aVYou need to put a colon when adding the recognizer:
p40505
as(dp40506
g6
V335858
p40507
stp40508
a((dp40509
g2
(lp40510
VIf you define a  operator, like this,
p40511
aVyour  will use this operator for sorting its keys
p40512
aVIn your case, this is unnecessary:  already provides the functionality that you are seeking, so
p40513
aVwill be sorted precisely the way that you want
p40514
as(dp40515
g6
V335858
p40516
stp40517
a((dp40518
g2
(lp40519
VIn Cocoa, the  method can be very smart: if an object is immutable, it could return itself without making a copy, because there is no point in copying objects that cannot be changed
p40520
aVIn your example,  is immutable, and  is mutable
p40521
aVThat is why only mutable objects make actual copying
p40522
aVOf course all mutable copies must allocate new memory, too
p40523
as(dp40524
g6
V335858
p40525
stp40526
a((dp40527
g2
(lp40528
VIn your app delegate, you should find code like this:
p40529
aVThis is where you can add some code to choose among the several storyboards that you have depending on the version of iOS:
p40530
as(dp40531
g6
V335858
p40532
stp40533
a((dp40534
g2
(lp40535
VThis is correct:  performs a shallow copy, so the instances of arrays inside the inner dimension get copied by reference
p40536
aVYou can use LINQ to make a copy, like this:
p40537
aVHere is a demo on ideone
p40538
as(dp40539
g6
V335858
p40540
stp40541
a((dp40542
g2
(lp40543
VManaging object-to-object relationships, including bidirectional ones, is where destructors become helpful
p40544
aVYou can eliminate the problem of dangling pointers like this:
p40545
aVOne problem with this approach is concurrency: if a seat and a character can be deleted simultaneously from different threads, you would need to synchronize deletions
p40546
as(dp40547
g6
V335858
p40548
stp40549
a((dp40550
g2
(lp40551
VTake both words, and compare them letter-for-letter
p40552
aVSince identical letters must be in the same position, this requires only a single loop that checks no more than four letters
p40553
aVEvery time you see a difference, increment a counter
p40554
aVIf the counter reaches 2, the words differ in more than one position
p40555
aVIf the counter equals one after the loop through the four characters is over, you have two words that differ in exactly one position:
p40556
as(dp40557
g6
V335858
p40558
stp40559
a((dp40560
g2
(lp40561
VYou are doing it essentially right, except that you should store the words (or the digits) as you go through the original number, and then "play them backwards" as you print them out
p40562
aVThe simplest way to accomplish this would be using an : add words to it as you go through your number, and then iterate the array in reverse order for printing
p40563
aVOne note is about your use of the : in cases when you do the same thing in all cases, and only your data is different, you should use an array or a dictionary for the lookup, like this:
p40564
aVWith this array in place, you could call
p40565
aVand get rid of the  statement
p40566
as(dp40567
g6
V335858
p40568
stp40569
a((dp40570
g2
(lp40571
VThis is a well-known problem of using a modified clause in a call that creates a delegate
p40572
aVAdding a temporary variable should solve it:
p40573
aVThis problem is fixed in C# 5 (see Eric Lippert's blog)
p40574
as(dp40575
g6
V335858
p40576
stp40577
a((dp40578
g2
(lp40579
VThis is the way defined in the C99 standard, section 6
p40580
ag839
aV2, part 2:
p40581
aVIn the set of translation units and libraries that constitutes an entire program, each
p40582
aVdeclaration of a particular identi\ufb01er with external linkage denotes the same object or
p40583
aVfunction
p40584
aVWithin one translation unit, each declaration of an identi\ufb01er with internal
p40585
aVlinkage denotes the same object or function
p40586
aVEach declaration of an identi\ufb01er with no
p40587
aVlinkage denotes a unique entity
p40588
aVThe "global" variables  have external linkage, so they denote the same object
p40589
aVThe local  variables, on the other hand, has no linkage, so there is a collision
p40590
aVReferences: C99 Standard
p40591
as(dp40592
g6
V335858
p40593
stp40594
a((dp40595
g2
(lp40596
VThis is precisely the way the relation databases work: each row must contain all information in itself, with every single field that you request
p40597
aVIn other words, each row needs to make sense in isolation from all other rows
p40598
aVIf you do a single query and you need to get all three levels of information, you need to deal with eliminating duplicates yourself for the desired formatting
p40599
aVAlternatively, you can run three separate queries, and then do in-memory joins in code
p40600
aVAlthough this may be desirable in certain rare situations, it is generally a wrong way of spending your development time, because RDBMS are usually much more efficient at joining relational data
p40601
as(dp40602
g6
V335858
p40603
stp40604
a((dp40605
g2
(lp40606
VThis is secure because having access to the salt does not make the process of hashing any easier to reverse for an attacker
p40607
aVGiven the password, the salt, and the hash, you can quickly check if the triple is right
p40608
aVHowever, you cannot use the knowledge of the salt to help you get the password
p40609
aVRecall that the reason the salt is needed in the first place is to avoid equal passwords produce equal hashes
p40610
aVWithout the salt, attackers would be able to hash the "rainbow table", and check hashes against the encoded dictionary
p40611
as(dp40612
g6
V335858
p40613
stp40614
a((dp40615
g2
(lp40616
VThis is because in this case the  type is signed on your system*
p40617
aVWhen this happens, the data gets sign-extended during the default conversions while passing the data to the function with variable number of arguments
p40618
aVSince 212 is greater than 0x80, it's treated as negative,  interprets the number as a large positive number:
p40619
aVWhen it is sign-extended, s are pre-pended to your number, so it becomes
p40620
aVwhich is the number that gets printed
p40621
aVNote that this behavior is specific to your implementation
p40622
aVAccording to C99 specification, all  types are promoted to (signed) , because an  can represent all values of a , signed or unsigned:
p40623
ag837
ag1340
ag1340
aV2: If an  can represent all values of the original type, the value is converted to an ; otherwise, it is converted to an
p40624
aVThis results in passing an  to a format specifier , which expects an
p40625
aVTo avoid undefined behavior in your program, add explicit type casts as follows:
p40626
aV* In general, the standard leaves the signedness of  up to the implementation
p40627
aVSee this question for more details
p40628
as(dp40629
g6
V335858
p40630
stp40631
a((dp40632
g2
(lp40633
VThe cheapest approach to code (but perhaps not the cheapest in terms of the overall CPU and memory use) is to mark your classes serializable, serialize the list into a memory buffer, and then deserialize it back into an object
p40634
aVIf you do it right, the result is going to be a deep copy of your list of objects
p40635
as(dp40636
g6
V335858
p40637
stp40638
a((dp40639
g2
(lp40640
VJava uses 64-bit IEEE-754 representation, so the closest number smaller than one is theoretically  in hexadecimal representation, which is 0 for sign, -1 for the exponent, and 1
p40641
aV9999999999999997 for the 52-bit significand
p40642
aVThis equals to roughly
p40643
aVReferences: IEEE-754 Calculator
p40644
as(dp40645
g6
V335858
p40646
stp40647
a((dp40648
g2
(lp40649
VBased on the threads Ive read on here, setting a pointer to deadbeef will make the pointer null
p40650
aVNo, that is incorrect
p40651
aVAlthough  is a common "nonsense pattern", it is definitely not equal
p40652
aVA common reason to set pointers (more generally, a memory area) to a known and unusual pattern, such as , is to detect non-initialized areas of memory
p40653
aVA pattern of all zeros, which is commonly used to represent  pointers, is not as good a candidate, because your chances of finding a sequence of zeros in consecutive memory locations is much higher than finding a sequence of s
p40654
aVThe crash that you see in the call of  happens because  is set to an invalid value
p40655
aVYou need to allocate enough memory to fit , along with its terminating zero, in order for  not to exhibit undefined behavior
p40656
as(dp40657
g6
V335858
p40658
stp40659
a((dp40660
g2
(lp40661
VIf you know how many digits a number must have, you can format it to the required number of digits with optional leading zeros by using the  format
p40662
aVThe magic number 14 is the required number of digits, including the leading zeros
p40663
aVHere is a link to a demo in C that uses a  constant to represent your number
p40664
ag1971
ag1972
aVPhone numbers are not really "numbers", they are strings that happen to be composed of digits
p40665
aVYou should not attempt converting them to numbers precisely because of the leading zeros issue
p40666
as(dp40667
g6
V335858
p40668
stp40669
a((dp40670
g2
(lp40671
VNo, the above does not create a jagged array of strings
p40672
aVIt creates an array of characters with two dimensions, capable of storing up to  C strings of up to 49 characters in length (the fiftieth  is used for the  terminator)
p40673
aVA jagged array declaration would look like this:
p40674
aVWith an array of pointers you would need to allocate memory for the individual strings, but the strings could differ in length from one element to the other
p40675
aVYour array, on the other hand, has all memory allocated, but it places a limit on the length of strings, and has a potential of using more memory than you need to store shorter strings
p40676
as(dp40677
g6
V335858
p40678
stp40679
a((dp40680
g2
(lp40681
VIn order to return a different thing each time, your method needs to keep state
p40682
aVIn Java, the state is kept using instance variables or class variables
p40683
aVNot knowing much about your design, here is a short implementation that flip-flops between  and :
p40684
aVNow calling  will alternate between  and :
p40685
aVHere is a demo on ideone
p40686
as(dp40687
g6
V335858
p40688
stp40689
a((dp40690
g2
(lp40691
VThere will be at least four objects:
p40692
aVThe interned string
p40693
aVThe copy of the interned  string
p40694
aVThe interned string
p40695
aVThe result of concatenating the two strings
p40696
as(dp40697
g6
V335858
p40698
stp40699
a((dp40700
g2
(lp40701
VYou need to return two pieces of information - the number, and an indication of whether or not that number is valid
p40702
aVOne way to do it is changing the signature of the function to indicate whether or not it returned anything, and in case when it does, stick that value in a variable
p40703
aVHere is an example of how you can do it:
p40704
aVNow you can use this new function like this:
p40705
aVA less general alternative can be used when you do not need to return a full range of numbers
p40706
aVFor example, if the valid time returned by your function is always positive, you could adopt a convention that uses negative numbers to indicate that there was an error
p40707
aVThis approach is also valid, but it relies more on a convention, so a reader of your code would need to look through your function documentation to see what is going on
p40708
as(dp40709
g6
V335858
p40710
stp40711
a((dp40712
g2
(lp40713
VOne way of doing it would be modifying your data source to return  when the number of rows is zero, and to produce a special-purpose cell (perhaps with a different cell identifier) in the  method
p40714
aVThis may get somewhat complicated if you have multiple table view controllers that you need to maintain, because someone will eventually forget to insert a zero check
p40715
aVA better approach is to create a separate implementation of a  implementation that always returns a single row with a configurable message (let's call it )
p40716
aVWhen the data that is managed by your table view controller changes, the code that manages the change would check if the data is empty
p40717
aVIf it is not empty, set your table view controller with its regular data source; otherwise, set it with an instance of the  that has been configured with the appropriate message
p40718
as(dp40719
g6
V335858
p40720
stp40721
a((dp40722
g2
(lp40723
VThe modulus operator on integers is built in on most platforms
p40724
aVAn instruction with the timing comparable to that of division is performed, producing the modulus
p40725
aVThe compiler can perform an optimization for divisors that are powers of two: instead of performing modulos of, say, , the compiler can use a potentially faster
p40726
as(dp40727
g6
V335858
p40728
stp40729
a((dp40730
g2
(lp40731
VThis is because the C#'s code analyzer detected that there are paths through you program when the 's value would be referenced before any assignments to it are made
p40732
aVSpecifically, this is going to happen during the very first iteration of the nested loop, when both  and  are zero: the  block containing the assignment is not going to execute, so the value of the  is going to get retrieved in the very next  statement
p40733
aVTo fix this problem, change
p40734
aVto
p40735
aVin the declaration
p40736
as(dp40737
g6
V335858
p40738
stp40739
a((dp40740
g2
(lp40741
VYou call a function through a pointer in the same exact way that you call a function directly, as if that pointer was function's name:
p40742
aVStarting with the ANSI C standard, the asterisks and ampersands around function pointers are optional
p40743
as(dp40744
g6
V335858
p40745
stp40746
a((dp40747
g2
(lp40748
VThe loop does not become infinite, it simply becomes very, very slow
p40749
aVThis is because the call of
p40750
aVopens another XML file and parses it
p40751
aVConsidering that the processing goes for 25 seconds when all information is in memory, it is not surprising that opening an additional file for each course that you encounter slows down the process to a crawl
p40752
as(dp40753
g6
V335858
p40754
stp40755
a((dp40756
g2
(lp40757
VTry this:
p40758
aVThe statement
p40759
aVcan be optimized as
p40760
aVYou can also skip temporary variables altogether:
p40761
as(dp40762
g6
V335858
p40763
stp40764
a((dp40765
g2
(lp40766
VHow can a type have no constructors defined
p40767
aVIt can't
p40768
aVBut it can hide all of its constructors by making them non-public - i
p40769
ag630
aVprivate, internal, or protected
p40770
aVMoreover, once a constructor is defined, the default constructor becomes inaccessible
p40771
aVOther classes in the same namespace can access internal constructors, but the classes external to the namespace would not be able to instantiate a class directly
p40772
ag1971
ag1972
aVIf you would like to create an empty match collection, you can always make an expression that matches something, and pass it something else:
p40773
as(dp40774
g6
V335858
p40775
stp40776
a((dp40777
g2
(lp40778
VFinal variables cannot be changed, but if they represent a mutable object, you can change the content of that object
p40779
aVFor example, if you make a  class, and use its instance instead of , you could do this:
p40780
aVNow, use a  instance of  in your code; use  instead of the assignment, and  instead of a direct access:
p40781
as(dp40782
g6
V335858
p40783
stp40784
a((dp40785
g2
(lp40786
VNo, you should not call , at least not right away: if you do, the button would disappear from screen (given the name of the method, this should come as no surprise)
p40787
aVMoreover, you do not need to set your button to
p40788
aVCalling  is needed when you need the control to be dropped from the screen
p40789
aVIf you also release it, the object representing your control would be destroyed
p40790
aVFor example, if you added a button programmatically for a specific task, and have to remove that button once the task has been accomplished, calling  is appropriate
p40791
as(dp40792
g6
V335858
p40793
stp40794
a((dp40795
g2
(lp40796
VYou can do it with several rules:
p40797
aVEmpty lists are syngeneic
p40798
aVLists are syngeneic when their tails are the same except for possibly the last element
p40799
aVEmpty lists are the same
p40800
aVLists with only one element are the same for the purposes of rule 2
p40801
aVLists are the same for the purpose of rule 2 if their heads match and their tails are the same for the purpose of rule 2
p40802
aVThere is no need to check the length explicitly, because the rules above would never match two lists with different number of elements
p40803
aVHere is how the above rules can be coded in Prolog - essentially, there is a line-for-line match:
p40804
aVHere is a demo on ideone
p40805
as(dp40806
g6
V335858
p40807
stp40808
a((dp40809
g2
(lp40810
VThe comparison is incomplete without mentioning that the two containers carry different per-element memory requirements:
p40811
aVOn average, a vector of size  requires  bytes (you may need to trim the memory to get the size to exactly )
p40812
aVA list of size  requires  bytes
p40813
aVSince each element of a list carries two additional pointers, a list of very small objects (say, s) may require three to five times the amount of memory required by a vector of identical size
p40814
aVAs the size of a list element increases, the additional memory requirements become less pronounced, but for small objects the implications are huge
p40815
aVThat is why it is not fair to say that vectors are more likely to fail on memory allocation: although a vector requires a contiguous block of memory, the total amount may be a lot smaller,  letting you have vectors of significantly larger sizes before entering the territory of potential failures
p40816
aVFor objects of sizes significantly (say, ten or more times) larger than two pointers you can safely neglect the additional memory requirements: due to the need of vectors to allocate contiguous space, the possibility of not finding a suitable chunk of memory is significantly higher
p40817
as(dp40818
g6
V335858
p40819
stp40820
a((dp40821
g2
(lp40822
VProlog has a built-in  predicate, which always fails
p40823
aVYou need a cut  in front of it in order to prevent further matching of the same  rule:
p40824
as(dp40825
g6
V335858
p40826
stp40827
a((dp40828
g2
(lp40829
VGenerally, one searches for a node to do something with it
p40830
aVPerhaps you would like to set a new value into an existing node, delete everything after the node, or insert something after that node
p40831
aVIf you maintain a certain order in your list, semantics of your searching function may be expanded to look for the first item greater than a certain value, et cetera
p40832
as(dp40833
g6
V335858
p40834
stp40835
a((dp40836
g2
(lp40837
VDo your iterations with integers, and convert them to strings inside the loop, like this:
p40838
aVThis works for any kind of integers without limitations
p40839
aVHere is a short demo
p40840
as(dp40841
g6
V335858
p40842
stp40843
a((dp40844
g2
(lp40845
VThe difference is that his operator can be used as if the iterator was a pointer, while yours cannot
p40846
aVWith pointers, you can do this:
p40847
aVFor this to work with iterators, the  operator must return the value before (or after) the increment, depending on the pre- or post- position of the operator
p40848
aVYour implementation does not do that
p40849
aVAlthough it is technically OK, the resultant operator is not as functional, so it is a good idea to change your implementation to return a value
p40850
as(dp40851
g6
V335858
p40852
stp40853
a((dp40854
g2
(lp40855
VNo, there is absolutely no difference: a pair of curly braces makes multiple statements into a single one; , , , and so on expect a single statement; if you need to guard only one statement, you do not need braces
p40856
aVHowever, many software shops insist on having braces even for a single statement
p40857
aVThe reason is errors like this:
p40858
aVThe statements above are misleading: the indentation leads you to believe that both assignments are protected, while in reality only the first one is
p40859
aVThe reason for that is that whitespace in Java is insignificant: indenting a statement does not change its placement in the overall flow of the program
p40860
aVErrors like the above are very hard to find, so adopting a rule to prevent them in the first place is a good idea
p40861
as(dp40862
g6
V335858
p40863
stp40864
a((dp40865
g2
(lp40866
VYou can use a  method for that:
p40867
aVGets a string representing the data type of the specified column
p40868
as(dp40869
g6
V335858
p40870
stp40871
a((dp40872
g2
(lp40873
VYou have two problems in your code: first is accessing members of managed classes; second is the names of the members that you access
p40874
aVWhen you use managed types, the members that you access remain the same as in C#
p40875
aVWhen you use a C++ , you can use
p40876
aVWhen you use , you need to use , like this:
p40877
as(dp40878
g6
V335858
p40879
stp40880
a((dp40881
g2
(lp40882
VWhy does the string "I don't get it
p40883
aVget in the string pool
p40884
aVThe  string does not get into the interning pool
p40885
aVOne way to verify it is as follows:
p40886
aVIf 's content is interned, the call of  will return a different ("canonical") object
p40887
aVAs you can see, the above returns the same object, meaning that the object on which you call  just became the "canonical" one (i
p40888
ag630
aVhas been interned)
p40889
aVOn the other hand, if you remove the , you'd get a different result:
p40890
aVNow the string inside  is
p40891
aVIts copy is already interned, because it's the same as the string constant used in creation of the
p40892
aVYou can run the first and the second programs side by side to see the difference for yourself
p40893
aVThe reason why  is  has nothing to do with string pools (the slang word is "string interning")
p40894
aVThe two are equal because  returns the object on which the  is invoked, i
p40895
ag630
aVYou do not have a second object - there's only one  with two references to it
p40896
aVThe content of that  is the concatenation of the  and  strings
p40897
as(dp40898
g6
V335858
p40899
stp40900
a((dp40901
g2
(lp40902
VYes, you can do that in C# with LINQ, like this:
p40903
aVThe way this works in LINQ is that the list of points is traversed, for each point, the requested coordinate is selected, and then the  is computed
p40904
aVThere is also a  function to get you the other corner of the bounding box
p40905
aVThis is somewhat suboptimal, because the list is traversed multiple times
p40906
aVA pair of nested loops would probably do the same thing more efficiently, while remaining just as readable:
p40907
as(dp40908
g6
V335858
p40909
stp40910
a((dp40911
g2
(lp40912
VYou cannot pass information into static initialization blocks - they are supposed to work in isolation
p40913
aVSince the stream that you are planning to pass needs to be known before the program begins execution, presumably your  should be able to find it too
p40914
aVFor example, this could be some sort of configuration utility that provides the stream for you
p40915
aVThen you can write your initializer like this:
p40916
aVPresumably, there is a class in the system that could get your Excel stream from a source that is known to it
p40917
aVThe source does not need to be hard-coded: it could read the location from a configuration file, or receive the data from a predefined network location on your server
p40918
aVIn all cases the process of getting the Excel stream has to "bottom out" somewhere, in the sense that something in your system needs to be able to find it without additional parameters
p40919
as(dp40920
g6
V335858
p40921
stp40922
a((dp40923
g2
(lp40924
VYou can do it in a single line in
p40925
aVNET 4
p40926
aV0, like this:
p40927
as(dp40928
g6
V335858
p40929
stp40930
a((dp40931
g2
(lp40932
VThis would be the code which will result in the infinite loop
p40933
aVThat is correct: if you use setters inside setters, you would get an infinite recursion
p40934
aVThat is why you should set instance variables rather than properties inside your setters+
p40935
aVAnother solution would be checking the current value: if a property is being set to the value that it already holds, the setter should exit
p40936
aVHowever, in your case the problem should be solved differently: rather than storing two attributes, you should store one, and compute the other
p40937
aVKeep the , and provide both a getter and a setter for the  property:
p40938
aVThis is one of very important principles of object-oriented designs (indeed, any data designs): you should not store things that can be easily calculated "on the fly"
p40939
aVThe classic example is the  +  pair: you should store the , and calculate the  to avoid inconsistencies
p40940
aV+ This was not generally true before ARC, and even with ARC you may want to use setters for string attributes marked as
p40941
as(dp40942
g6
V335858
p40943
stp40944
a((dp40945
g2
(lp40946
VYou need to ensure that  always equals the number of elements in the  array:
p40947
aVCurrently you can set  to a value that is higher than the array size
p40948
aVThis is what can lead to the error in the  loop on  limited by the
p40949
as(dp40950
g6
V335858
p40951
stp40952
a((dp40953
g2
(lp40954
VIf you do not care about the order in which the elements of the result come, you can do it with LINQ's :
p40955
aVHere is a demo on ideone
p40956
aVI must admit that your solution is far simpler than mine, so it should be regarded as a mere curiosity, a way to prove that this could be done with LINQ too
p40957
aVHere is how it works: for each element from the first list we add a key-value pair with a ; for each element from the second list we add a key-value pair with
p40958
aVThen we group all elements by their key, total up their ones and negative ones, and produce as many keys as the total, making sure that we do not select anything when the result is negative
p40959
as(dp40960
g6
V335858
p40961
stp40962
a((dp40963
g2
(lp40964
VIn C++ you use  for comparison
p40965
aVThe  is an assignment
p40966
aVIt can be used in the condition of an  statement, but it's going to evaluate to  unless the character is  (not , as it is in your case):
p40967
as(dp40968
g6
V335858
p40969
stp40970
a((dp40971
g2
(lp40972
VYou compute factorial, but you never print it:
p40973
aVshould be
p40974
aVMoreover, your  function does not make use of the  parameter, so you should remove it, and declare a local variable inside the function
p40975
aVFinally, asking for the "do you want another factorial" should be done at the top level, not inside the  function
p40976
aVYour code does not use the character that the user inputs, too: you'll need a loop that checks user's input, and continues while  is entered
p40977
as(dp40978
g6
V335858
p40979
stp40980
a((dp40981
g2
(lp40982
VThis loop never runs, because  is six:
p40983
aVit should be
p40984
aVThere is a way to avoid that inner loop, and solve the problem with a single loop, like this:
p40985
as(dp40986
g6
V335858
p40987
stp40988
a((dp40989
g2
(lp40990
VThe  creates a variable to back the property with the same name as the property, while  gives the variable an alternative name (perhaps the property name prefixed with an underscore)
p40991
aVNote that in the compilers shipped with the most recent version of Xcode using  is no longer necessary: the compiler figures out what properties need synthesizing, and implicitly inserts
p40992
aVfor each property that needs to be synthesized
p40993
as(dp40994
g6
V335858
p40995
stp40996
a((dp40997
g2
(lp40998
VYour second interface would translate to C# as follows:
p40999
aVIn other words, instance variables are similar to C#'s fields, while properties are very similar to C#'s properties
p41000
aVThe biggest difference between "automatic" properties of C# and properties of Objective C is that in C# it's "all or nothing": you either make the property automatic, or declare a variable for it
p41001
aVOn Objective C, you can have an auto-generated getter, and a manually written setter (or the other way around)
p41002
as(dp41003
g6
V335858
p41004
stp41005
a((dp41006
g2
(lp41007
VYou can do it with a loop, like this:
p41008
aVYou can also add strings to an initially empty string, but that's suboptimal, because all the intermediate strings get allocated and released in a loop
p41009
as(dp41010
g6
V335858
p41011
stp41012
a((dp41013
g2
(lp41014
VYou can use regex for that:
p41015
aVThis would throw away all words that are not composed entirely of English characters
p41016
as(dp41017
g6
V335858
p41018
stp41019
a((dp41020
g2
(lp41021
VIt would be very hard to do it with just one regular expression, but two expressions would do much better:
p41022
aVThe first expression finds the tagged area; the second (inside ) finds individual elements, and "frames" them with the  tags
p41023
aVUnfortunately, this does not deal with nesting at all: if you nest multiple s inside each other, the above approach is going to fail
p41024
aVHowever, if you must allow for unlimited nesting of identical tags, regex will not be able to do it: in cases like that, you need to count the nesting level, yet the regex language is not powerful enough to do counting
p41025
aVHere is a demo on ideone
p41026
as(dp41027
g6
V335858
p41028
stp41029
a((dp41030
g2
(lp41031
VThe type of variable  that you have is incorrect: it should be  (yes, with parentheses)
p41032
aVThis line is also incorrect:
p41033
aVyou cannot assign C strings like that, because  is not a pointer: it is an array of 20 characters, so you need to use  instead:
p41034
aVSee the corrected program running here
p41035
aVNote: Unlike C++, C does not require type casting of  pointers
p41036
aVIt is typical for C programs to omit the cast of results returned from , , and , because the type is already known from the type of the variable being assigned
p41037
as(dp41038
g6
V335858
p41039
stp41040
a((dp41041
g2
(lp41042
VI do not know what book you are using, but the authors appear to teach you C before going into the C++ land
p41043
aVWithout discussing their motives, I'll write an answer to be similar to your style of code before discussing an ideal C++ solution
p41044
aVYou need an array to store your numbers:
p41045
aVArray are indexed starting from zero, so change  to start at zero and go to nine (instead of starting at one and going to ten, like you have now)
p41046
aVSince  is an array, use  in the call of
p41047
aVTo print ten numbers you need a loop as well
p41048
aVYou need a flag that tells you whether or not you need a comma after the number that you print
p41049
aVAdd a  after the loop
p41050
aVAs far as an "ideal" C++ solution goes, it should look close to this one:
p41051
aVHowever, discussing it would remain hard until you study the C++ standard library and its use of iterators
p41052
as(dp41053
g6
V335858
p41054
stp41055
a((dp41056
g2
(lp41057
VAlthough there is a way to run code after the return statement, there is no way to return again after a return statement has been executed
p41058
aVHere is how you can make some code to run after a return statement:
p41059
aVThe above program prints
p41060
as(dp41061
g6
V335858
p41062
stp41063
a((dp41064
g2
(lp41065
VAlthough you can create an array of pointers to forward-declared classes, you cannot create an array with an unknown size
p41066
aVIf you want to create the array at runtime, make a pointer to a pointer (which is of course also allowed):
p41067
as(dp41068
g6
V335858
p41069
stp41070
a((dp41071
g2
(lp41072
VYour program goes through the "list of target words" (i
p41073
ag630
aV) file only once
p41074
aVFile streams are "one way": once you exhaust it, you need to rewind it, or it's going to stay at the end
p41075
aVThe inner loop
p41076
aVis going to execute only the first time through, i
p41077
ag630
aVfor the first word of
p41078
aVFor the second and all the subsequent words, the  will already be at the end of file, so the code will not even enter the loop
p41079
aVYou should read your target words in memory, and use that list in the inner loop
p41080
aVBetter yet, put the words in a , and use that set to do your counting
p41081
as(dp41082
g6
V335858
p41083
stp41084
a((dp41085
g2
(lp41086
VThe "classic" bubble sort goes through the entire array on each iteration, so the loops should be
p41087
aVand
p41088
aVBoth loops skip one index: the first loop skips the last index, while the second loop skips the initial one
p41089
aVThis is so that your code could safely compare  to , and  to
p41090
aVEDIT The "optimized" bubble sort skips the initial  elements on -th iteration
p41091
aVSince your bubble sort is bidirectional, you will be able to skip the initial  and the tail  elements, like this:
p41092
as(dp41093
g6
V335858
p41094
stp41095
a((dp41096
g2
(lp41097
VLeaving aside the fact that storing passwords in plain text is the worst idea ever from the security standpoint, and the fact that users can execute a SQL injection attack on your database by entering a "special" password+, the reason your code ignores caps is that your RDBMS has case-insensitive string comparison
p41098
aV+ Imagine (do not try) a password string that looks like this:
p41099
aVDo you know what would happen
p41100
aVIn addition,
p41101
aVwould become your "master password", letting anyone login as anyone else
p41102
as(dp41103
g6
V335858
p41104
stp41105
a((dp41106
g2
(lp41107
VYou need to pass a class of the  array, not an array of classes: replace this
p41108
aVwith this:
p41109
aVIn addition, since the second parameter is , not , you need to replace
p41110
aVwith
p41111
as(dp41112
g6
V335858
p41113
stp41114
a((dp41115
g2
(lp41116
VIn SQL you delimit strings with single, not double quotes
p41117
aVIn addition, you do not alias tables in  statements in the way that you did:
p41118
aVIf you must use an alias, this syntax should work:
p41119
as(dp41120
g6
V335858
p41121
stp41122
a((dp41123
g2
(lp41124
VIf your string is nullable, you need to check the value returned from the  against :
p41125
aVIf the object returned by  is not a , it's , so the  cast is going to set the value of  to  as well
p41126
aVIf you must set the string to a non-null in case the database value is missing, add , like this:
p41127
as(dp41128
g6
V335858
p41129
stp41130
a((dp41131
g2
(lp41132
VStart with a bitmask with bits 0 through 9 set, then clear the bits corresponding to values of each variable
p41133
aVIf the resultant bitmask is a power of two, all values were distinct+; otherwise, there were duplicates
p41134
aVSee this answer for an explanation of the bit trick used in the last condition
p41135
aV+ You have ten possible values and nine variables; in order for the nine values to be distinct, they must clear out nine out of ten bits from the bitmask with all ten bits initially set
p41136
aVRemoving nine out of ten bits leaves you with only one bit set to , meaning that the result is a power of two
p41137
as(dp41138
g6
V335858
p41139
stp41140
a((dp41141
g2
(lp41142
VYou need to read the result into
p41143
aVThis prints
p41144
as(dp41145
g6
V335858
p41146
stp41147
a((dp41148
g2
(lp41149
VYou have switched the expression and alias - the syntax should be as follows:
p41150
aVIn general, when you use an expression in the select statement and would like to give the resultant column a name, you write the expression first, and then its alias, e
p41151
ag303
as(dp41152
g6
V335858
p41153
stp41154
a((dp41155
g2
(lp41156
VRegular expressions are not the right tool for parsing complex structures like this
p41157
aVSince your file looks a lot like XML, it may make sense to add what's missing to make it XML (i
p41158
ag630
aVthe header), and feed the result to an XML parser
p41159
aVXML parsers are optimized for processing large volumes of data quickly (especially the SAX kind)
p41160
aVYou should see a significant improvement in performance if you switch to parsing XML from processing large volumes of text with regular expressions
p41161
as(dp41162
g6
V335858
p41163
stp41164
a((dp41165
g2
(lp41166
VIn Java, the concepts of polymorphism and inheritance are "welded together"; in general, it does not have to be that way:
p41167
aVPolymorphism lets you call methods of a class without knowing the exact type of the class
p41168
aVInheritance lets derived classes share interfaces and code of their base classes
p41169
aVThere are languages where inheritance is decoupled from polymorphism:
p41170
aVIn C++ you can inherit a class without producing polymorphic behavior (i
p41171
ag630
aVdo not mark functions in the base class with )
p41172
aVIn Objective C you can implement a method on an unrelated class, and call it from a place that knows only the signature of the method
p41173
aVGoing back to Java, the reason to use polymorphism is decoupling your code from the details of the implementation of its counter-parties: for example, if you can write a method  that works for all sorts of animals, the method would remain applicable when you add more subclasses or implementations of the
p41174
aVThis is in contrast to a  method, that would be tightly coupled to dogs
p41175
aVAs far as the
p41176
aVdeclaration goes, there is no general reason to avoid this if you know that the rest of your method deals specifically with dogs
p41177
aVHowever, in many cases the later is not the case: for example, your class or your methods would often be insensitive to the exact implementation, for example
p41178
aVIn cases like that, you can replace  with , and know that your code is going to compile
p41179
aVIn contrast, had your  list been declared as , such switchover may not have been a certainty
p41180
aVThis is called "programming to an interface"
p41181
aVThere is a very good answer on Stack Overflow explaining it
p41182
as(dp41183
g6
V335858
p41184
stp41185
a((dp41186
g2
(lp41187
VIf you use
p41188
aVNET 4
p41189
aV0 or newer, you can use  that takes an :
p41190
aVIt is hard to say without seeing the interface of  if it is possible to do this without creating an explicit list
p41191
aVIf there is a way to select all first names from  using LINQ, plug that expression into the last line in place of :
p41192
as(dp41193
g6
V335858
p41194
stp41195
a((dp41196
g2
(lp41197
VThe  expression computes the address by adding  bytes to the value of
p41198
aVIf the size of  is the same as that of , there is no difference between the results of these two expressions
p41199
aVGiven that
p41200
aVis an  pointer
p41201
aVand assuming that  on your system is 32-bit, your two expressions produce the same result
p41202
as(dp41203
g6
V335858
p41204
stp41205
a((dp41206
g2
(lp41207
VThink of generic classes as stencils to make other classes (similarly, generic functions are stencils for making other functions)
p41208
aVType parameters serve as openings in your stencils: by plugging in a concrete type into them, you make the generic class or the generic function into a real class or function
p41209
aVThe type parameters "stick through" the designated holes in the stencil, producing a complete definition
p41210
as(dp41211
g6
V335858
p41212
stp41213
a((dp41214
g2
(lp41215
VThere is nothing wrong with your  loop: a 2D array in Java is a 1D array of 1D arrays; String's  returns one of these 1D arrays
p41216
aVYour  loop puts them together into an array of arrays, so the result is a 2D array
p41217
as(dp41218
g6
V335858
p41219
stp41220
a((dp41221
g2
(lp41222
VThis is because your query selects a name at the end:
p41223
aVThe type parameter  of the generic  corresponds to the type of the object selected in the query
p41224
aVSince you select a  (which is presumably a ), you got an
p41225
aVOnce you select , which is , you'd get  as your result
p41226
as(dp41227
g6
V335858
p41228
stp41229
a((dp41230
g2
(lp41231
VWhat you describe are not constants, they are global variables
p41232
aVYou cannot define getters and setters for them, but you can use their values to back class methods, which is precisely what you have done
p41233
aVHowever, when you send message like this
p41234
aVthe global variable is used directly, bypassing your getter
p41235
aVIf you want to go through a getter, you can write
p41236
aVor inside methods of  you can write
p41237
aVAnother note is that when yo implement accessor methods like that, you should make the backing variables static, rather than
p41238
aVThis will ensure that other modules cannot access these variables bypassing your getters
p41239
as(dp41240
g6
V335858
p41241
stp41242
a((dp41243
g2
(lp41244
VThere is a class that deals with IP address in Java, letting you obtain a proper representation without trying to parse the string yourself:
p41245
as(dp41246
g6
V335858
p41247
stp41248
a((dp41249
g2
(lp41250
VHere is how you can do it:
p41251
aVYou need to  in order for this to compile
p41252
aVThe first pointer must point to a memory block of enough size to fit the number of characters passed in the second pointer
p41253
as(dp41254
g6
V335858
p41255
stp41256
a((dp41257
g2
(lp41258
VOne way to produce a condition like that in standard Prolog is as follows:
p41259
aVHere is a demo on ideone
p41260
as(dp41261
g6
V335858
p41262
stp41263
a((dp41264
g2
(lp41265
VYou cannot assign an array as a data source for a data picker, because arrays do not provide the information the picker needs
p41266
aVIn order to work correctly, the picker needs answers to at least these three questions:
p41267
aVHow many components a picker should have,
p41268
aVHow many rows each component has, and
p41269
aVWhat data to put in each row of each component
p41270
aVThe data source answers the first two questions by implementing the data source protocol: you need
p41271
aVto return the number of components, and
p41272
aVto return the number of rows in a given component
p41273
aVImplement both methods in your class, and then assign
p41274
aVOf course you need to implement methods of the delegate as well, but since you assign  chances are that you have done that already
p41275
as(dp41276
g6
V335858
p41277
stp41278
a((dp41279
g2
(lp41280
VCSV format allows strings with commas, but they must be enclosed in double quotes
p41281
aVTry this:
p41282
as(dp41283
g6
V335858
p41284
stp41285
a((dp41286
g2
(lp41287
VYou can use an easier approach - replace the characters that you do not want with spaces:
p41288
as(dp41289
g6
V335858
p41290
stp41291
a((dp41292
g2
(lp41293
VYour  class does not override the  method
p41294
aVThat's why the default implementation is called, producing what looks like "garbage"
p41295
aVIn your  class add a  method that takes no parameters and returns a  that describes the content of your node in an application-specific way
p41296
aVThis will fix the output
p41297
as(dp41298
g6
V335858
p41299
stp41300
a((dp41301
g2
(lp41302
VYou should not use the moved-from  before replacing its value with some known value:
p41303
aVThe library code is required to leave a valid value in the argument, but unless the type or function documents otherwise, there are no other constraints on the resulting argument value
p41304
aVThis means that it's generally wisest to avoid using a moved from argument again
p41305
aVIf you have to use it again, be sure to re-initialize it with a known value before doing so
p41306
aVThe library can stick anything it wants into the string, but it's very likely that you would end up with an empty string
p41307
aVThat's what running an example from cppreference produces
p41308
aVHowever, one should not expect to find anything in particular inside a moved-from object
p41309
as(dp41310
g6
V335858
p41311
stp41312
a((dp41313
g2
(lp41314
VUsing predicates to filter arrays is probably as "Appleish" as it gets:
p41315
as(dp41316
g6
V335858
p41317
stp41318
a((dp41319
g2
(lp41320
VWhen you do not know the level of nesting at compile time, you need to use recursion: the function should have a single loop representing -th nesting level, and continue calling itself recursively until the -th level is reached:
p41321
aVThe initial call should look like this:
p41322
aVI assume that there is also a function  that takes an array of index items, and produces an object from them
p41323
as(dp41324
g6
V335858
p41325
stp41326
a((dp41327
g2
(lp41328
VThe author refers to the feature of  functions to be expanded at the invocation site, as if you wrote their body in place of the invocation
p41329
aVThis guarantees no loss of efficiency - not even the tiny one associated with invoking a function on modern hardware
p41330
aVIn addition, the compiler could potentially optimize the code better when the indexing operator is expanded inline, because the nature of the code inside the function would be known to the optimizer
p41331
aVAs far as removing the  from the shipping code goes, you would need to do it manually in the current implementation
p41332
aVYou could also use conditional compilation to remove bounds checking in production code
p41333
as(dp41334
g6
V335858
p41335
stp41336
a((dp41337
g2
(lp41338
VYou can use  to avoid reading the entire file into memory, like this:
p41339
aVOnce the  loop is finished, the  list contains up to the last  of text from the file
p41340
aVOf course if the file does not contain as many lines as required, fewer lines will be placed in the  list
p41341
as(dp41342
g6
V335858
p41343
stp41344
a((dp41345
g2
(lp41346
VYes,  has problems with , because it is a , not a key-value compliant Objective-C class
p41347
aVYou can write a predicate with a block instead, like this:
p41348
as(dp41349
g6
V335858
p41350
stp41351
a((dp41352
g2
(lp41353
VYou can skip the elements that you do not want, like this:
p41354
aVor split the loop in two, like this:
p41355
as(dp41356
g6
V335858
p41357
stp41358
a((dp41359
g2
(lp41360
VThis is because when you declare a pointer, the asterisk must follow the type name, not precede it:
p41361
as(dp41362
g6
V335858
p41363
stp41364
a((dp41365
g2
(lp41366
VIt is absolutely legal to define negative constants with
p41367
aVWhat you discovered is most likely a bug in Xcode's code coloring, which will probably be fixed in one of the future revisions
p41368
as(dp41369
g6
V335858
p41370
stp41371
a((dp41372
g2
(lp41373
VYou can get the current time in a  by accessing , like this:
p41374
aVNow  will represent the amount of time that passed since midnight
p41375
as(dp41376
g6
V335858
p41377
stp41378
a((dp41379
g2
(lp41380
VThere are two cases for calling a function in a subclass from the superclass:
p41381
aVWhen the superclass or one of its ancestors has declared the function that you want to call  - simply call that function: the override is going to be called
p41382
aVWhen the function is first introduced in a subclass - you need an explicit cast in your call
p41383
aVThis option almost always indicates a problem in your design, and should be avoided
p41384
as(dp41385
g6
V335858
p41386
stp41387
a((dp41388
g2
(lp41389
VStarting with iOS 6, you can use  in
p41390
aVAn  object manages character strings and associated sets of attributes (for example, font and kerning) that apply to individual characters or ranges of characters in the string
p41391
as(dp41392
g6
V335858
p41393
stp41394
a((dp41395
g2
(lp41396
VYou can  from two s that return columns that "line up", like this:
p41397
aVNote how  is selected from : this is necessary in order to line up the columns of the two select statements
p41398
as(dp41399
g6
V335858
p41400
stp41401
a((dp41402
g2
(lp41403
VLike this:
p41404
aVHere is a demo on ideone
p41405
as(dp41406
g6
V335858
p41407
stp41408
a((dp41409
g2
(lp41410
VThis is a bit field consisting of a four-bit portion of a
p41411
aVYou can define more bit fields to subdivide a larger type into "nibblets", like this:
p41412
aVThis  defines three fields, all "packed" into a single
p41413
aVThe  field can hold sixteen distinct values; fields  and  can hold four values each
p41414
as(dp41415
g6
V335858
p41416
stp41417
a((dp41418
g2
(lp41419
VI think the "model with higher number, model with lower number" in the problem statement is a clue that you need to have a  condition somewhere
p41420
aVJoin's  condition sounds like a fine candidate:
p41421
aVThe  is symmetrical; the  is not
p41422
aVSwitching to  ensures that if  is in, then  will be out for sure
p41423
as(dp41424
g6
V335858
p41425
stp41426
a((dp41427
g2
(lp41428
VIf you need to replace 2+ characters with exactly two, you can slightly modify your expression, like this:
p41429
aVHowever, there is not enough information in a regex to make an exception for  and trim it to , as opposed to
p41430
aVHere is a demo on ideone
p41431
as(dp41432
g6
V335858
p41433
stp41434
a((dp41435
g2
(lp41436
VWhat Xcode is telling you is precisely right:  (which is of type , of course) has neither  nor  property
p41437
aVThis is because you did not declare these properties in your  class, and its base class  does not have them either
p41438
aVThere are two solutions that you could try - using built-in properties directly, or wrapping them in properties with the names that you desire
p41439
aVHere is the first approach:
p41440
aVHere is the second approach:
p41441
aVThe first approach is faster to implement, but it may be less readable
p41442
aVThe second approach requires more typing, but it gives the source and the destination controllers the names that better describe their roles in your application
p41443
aVThe choice is up to you
p41444
as(dp41445
g6
V335858
p41446
stp41447
a((dp41448
g2
(lp41449
VYou cannot use  to check uniqueness
p41450
aVTo ensure that all names are unique, you need to make sure that you select unique names from , and that the names you insert do not already exist in
p41451
aVUse  for , and  for , like this:
p41452
as(dp41453
g6
V335858
p41454
stp41455
a((dp41456
g2
(lp41457
VUse bitwise  and shifts, like this:
p41458
as(dp41459
g6
V335858
p41460
stp41461
a((dp41462
g2
(lp41463
VThe simplest way is to use  in a loop, advancing the starting index each time that you find the word:
p41464
aVThis will find the word multiple times if a word contains self-repetitions
p41465
aVSee the comment above to avoid such "duplicate" finds
p41466
aVDemo on ideone
p41467
as(dp41468
g6
V335858
p41469
stp41470
a((dp41471
g2
(lp41472
VThis is relatively easy to check with a stopwatch:
p41473
aVThis prints numbers that are reasonably close to each other:
p41474
aVThe  always wins, but the margins are not as large as one would expect, given the relative complexity of the two data structures
p41475
as(dp41476
g6
V335858
p41477
stp41478
a((dp41479
g2
(lp41480
VThere is a solution, but I would strongly recommend against it: define an implicit conversion operator from  to , and return  to the caller:
p41481
aVThe  needs to use , not  as the value type in order for the operator to apply
p41482
aVThe same is true about your  code as well
p41483
as(dp41484
g6
V335858
p41485
stp41486
a((dp41487
g2
(lp41488
VYou can definitely pass  to methods called from  as long as these methods do not save the reference for use outside the duration of the  call, your code should be fine
p41489
aVHowever, the context reference that you pass around would be equivalent to the context retrieved through , so I doubt that there is much to gain by adding an extra parameter
p41490
as(dp41491
g6
V335858
p41492
stp41493
a((dp41494
g2
(lp41495
VContinuing with  path, you can do it by setting up a result list, wait for the desired channel ID, start collecting the values, and then end collecting them when the desired channel ID tag ends:
p41496
as(dp41497
g6
V335858
p41498
stp41499
a((dp41500
g2
(lp41501
VMake an array of , where  is the return type of your functions
p41502
aVThen you would be able to call your functions more or less the way you described in your code
p41503
aVFor example, if your functions return , you can do this:
p41504
as(dp41505
g6
V335858
p41506
stp41507
a((dp41508
g2
(lp41509
VThe highest random value that you can get from  is , a library-dependent constant
p41510
aVIn your case, it appears to be set to , the highest positive number that fits in a signed 16-bit integer
p41511
aVWhen you need to generate numbers that are larger than , call  several times, each time multiplying by
p41512
aVFor example, in your case the following code should work (I am assuming that your  has 32 bits):
p41513
aVNote that merely adding three random numbers together to get the desired range will not produce the same random distribution as multiply and add approach
p41514
as(dp41515
g6
V335858
p41516
stp41517
a((dp41518
g2
(lp41519
VFirst, since the methods are class methods, not instance methods, I assume that variables not ivars, but static variables of some sort
p41520
aVIf payments with some, not all, forms of payment are to be allowed (say, only with energy and samples, but not credits) then you should use three different methods
p41521
aVOtherwise, your  method is very idiomatic to Objective C
p41522
aVUsing C  should be reserved for the rare situations where Objective C classes no longer provide adequate performance
p41523
aVConsider making the spaceship a singleton, and use ivars: this may become handy if you decide to introduce more ships in the game, or do something that's easier done with objects (e
p41524
ag303
aVexternalization of object's state)
p41525
as(dp41526
g6
V335858
p41527
stp41528
a((dp41529
g2
(lp41530
VA problem with clearing the file periodically is that if your process crashes after the file has been cleared but before it has been written, you lose data: the old data is gone, but the new data is not there yet
p41531
aVA common approach to this problem is to create a new file, writing it, and then moving the new file to replace the old one
p41532
aVThis way you always have a file, and sometimes (for very brief periods of time) you have two files
p41533
as(dp41534
g6
V335858
p41535
stp41536
a((dp41537
g2
(lp41538
VWhen you store something mutable in a container, you must stop using that mutable object from outside the container
p41539
aVOtherwise, your modifications will be reflected in objects that you have already stored
p41540
aVFor example, if you create a mutable array, populate it with data, store it at some key, and then clear the array, the stored array will be cleared as well
p41541
aVThis is because the stored array and the array that you clear are really the same object: collections store references to objects that you pass
p41542
aVTo avoid this, make an immutable copy before storing your array, for example by using
p41543
as(dp41544
g6
V335858
p41545
stp41546
a((dp41547
g2
(lp41548
VWhen you enclose  in quotes, it becomes a character literal, and ceases to be a variable
p41549
aVIts value is ignored, and the literal  is used instead
p41550
aVThe simplest solution is to use  to add  as a prefix and a suffix, like this:
p41551
aVIf, for example,  is set to , the result becomes
p41552
as(dp41553
g6
V335858
p41554
stp41555
a((dp41556
g2
(lp41557
VYou are missing a  portion of the  clause, and specifying a condition where you could specify a value:
p41558
as(dp41559
g6
V335858
p41560
stp41561
a((dp41562
g2
(lp41563
VOne simple way would be to validate the string using this regular expression:
p41564
aVHere is a sample code that uses the above expression:
p41565
as(dp41566
g6
V335858
p41567
stp41568
a((dp41569
g2
(lp41570
VThe third one is not equivalent to the first two, because it uses a static variable to keep the current state
p41571
aVThis is a bad thing (imagine running this function from multiple threads concurrently to see why)
p41572
aVThe reason this even works is that there is never more than one recursive invocation from each invocation of a function
p41573
aVFor example, trying to keep a static state in a recursive traversal of a binary tree would fail rather miserably
p41574
aVThat is why the current state should be passed through parameters to your recursive functions, without using static or member context
p41575
aVThere should be no performance difference between the first two versions, because their time will be dominated by the output of the data
p41576
aVI would change the signature of the second function like this
p41577
aVbecause you never use  as an array, only as a pointer
p41578
aVTechnically it does not matter because arrays "decay" to pointers anyway, but I think this would slightly improve readability
p41579
as(dp41580
g6
V335858
p41581
stp41582
a((dp41583
g2
(lp41584
VIf you want to make an array of strings, you can do it with a loop:
p41585
aVHere is a demo on ideone
p41586
aVFor  original string, use  (demo):
p41587
as(dp41588
g6
V335858
p41589
stp41590
a((dp41591
g2
(lp41592
VYou are missing a call of : if the main program exits before 's output gets to the console, you see nothing printed
p41593
aVAdding  to your example fixes the output:
p41594
as(dp41595
g6
V335858
p41596
stp41597
a((dp41598
g2
(lp41599
VAmazingly enough, this is a fairly common situation: I have seen it more than once when enabling logging in a seemingly unrelated place would instantly solve a timing issue somewhere else
p41600
aVThe reason for this is that , just like many other output functions, has internal synchronization
p41601
aVThere is a mutex somewhere that protects access to the internal buffers of , either in the  itself or in one of the I/O libraries that it uses
p41602
aVThis synchronization enables callers to use  from multiple threads
p41603
aVIt is this synchronization that changes the timing of your program, affecting a race condition and ultimately solving a crash
p41604
as(dp41605
g6
V335858
p41606
stp41607
a((dp41608
g2
(lp41609
VThis is because  uses the pattern to decide where the sequence must be split
p41610
aVIn other words, the pattern describes separators, not the content that you would like to capture:
p41611
aVSplits an input string into an array of substrings at the positions defined by a regular expression pattern
p41612
aVTo use the expression the way you want you need to call  to obtain a , and retrieve the individual matches from that collection:
p41613
aVHere is a demo on ideone
p41614
as(dp41615
g6
V335858
p41616
stp41617
a((dp41618
g2
(lp41619
VThere are two problems with your  method:
p41620
aVWhen it cannot find a file by name, it returns a value of an uninitialized variable
p41621
aVThis is undefined behavior - you need to set  to  upon initialization
p41622
aVIn fact, you do not need  at all (see the fix below)
p41623
aVWhen it discovers its first subdirectory, it assumes that the file that it is looking for must be inside that subdirectory, even if it is not
p41624
aVWhatever the first-level recursive invocation of  returns, becomes the return result of the top-level invocation
p41625
aVThis is bad: if the file that you are looking for is in the subtree of the second subdirectory, you are never going to find it
p41626
aVHere is how you can fix your method:
p41627
as(dp41628
g6
V335858
p41629
stp41630
a((dp41631
g2
(lp41632
VThis is relatively simple to do recursively:
p41633
aVCheck the node on the left; if there is something there, flatten the left to a list #1
p41634
aVCheck the node on the right; if there is something there, flatten the right to a list #2
p41635
aVCreate a single-node list #3 with the key of the current node
p41636
aVConcatenate the lists in the order #1 -> #3 -> #2
p41637
aVReturn the concatenated list as your result
p41638
aVHere is how you can code it up:
p41639
as(dp41640
g6
V335858
p41641
stp41642
a((dp41643
g2
(lp41644
VYou can do it with LINQ, like this:
p41645
aVThe approach is self-explanatory except for the  part: you need it to decide between finding the result at the initial location of the  array, when zero is returned, and not finding the result at all, when the return is
p41646
aVHere is a demo on ideone
p41647
aVThe complexity of the above is , where  and  are lengths of the  and  arrays
p41648
aVIf the  array is very long, and contains a significant number of "almost right" sub-sequences that match long prefixes of , you may be better off implementing an advanced algorithm for searching sequences, such as the Knuth\u2013Morris\u2013Pratt (KMP) algorithm
p41649
aVThe KMP algorithm speeds up the search by making an observation that when a mismatch occurs, the  sequence contains enough information on how far ahead you can move in the  sequence based on where in the small sequence is the first mismatch
p41650
aVA look-up table is prepared for the  sequence, and then that table is used throughout the search to decide how to advance the search point
p41651
aVThe complexity of KMP is
p41652
aVSee the Wikipedia article linked above for pseudocode of the KMP algorithm
p41653
as(dp41654
g6
V335858
p41655
stp41656
a((dp41657
g2
(lp41658
VThis is not unexpected at all: you add the same object, namely , to the  twice
p41659
aVFirst, you add it when it has , then you clear it, and then you add it with
p41660
aVThe problem is, when you call , the array list that you added to  gets cleared as well
p41661
aVYou need to create a new  instead of clearing the existing one to fix this problem: replace  with , and the problem will go away
p41662
as(dp41663
g6
V335858
p41664
stp41665
a((dp41666
g2
(lp41667
VAssuming that there is a one-to-one correspondence between your labels and the strings in the , you can put these labels in an array, and then set the data in them using a loop, like this:
p41668
as(dp41669
g6
V335858
p41670
stp41671
a((dp41672
g2
(lp41673
VYou can generate a random  into a , and then divide it by , like this:
p41674
aVThe result will be in the range from zero to one, inclusive
p41675
as(dp41676
g6
V335858
p41677
stp41678
a((dp41679
g2
(lp41680
VHere is a link to a great article that explains implementing animated sprites with Core Animation
p41681
aVThe images for sprite frames are loaded from sprite sheets (in fact, zwoptex is mentioned among the recommended software)
p41682
aVThe article gives you step-by-step instructions with code
p41683
aVThe idea behind this approach is to load the entire "sprite atlas", and animate to a new position in it as a way to move to the next frame in the animation
p41684
aVFor example, if you need to animate through six 40x40 frames, you can load a 40*240 atlas, and then animate  from 0 to 40, 80, 120, 160, and 200
p41685
aVYou can use similar approach to "subdivide" the sprite sheet into images for individual sprites
p41686
aVSee implementation of the  at the link for details on how this subdivision can be implemented
p41687
as(dp41688
g6
V335858
p41689
stp41690
a((dp41691
g2
(lp41692
VYou can do it as follows:
p41693
aVConstruct  with a union of all sets
p41694
aVInitialize  difference to the distance between the largest and the smallest elements of the union
p41695
aVFor each element of , go through the original  sets, and find the closest element that is greater than or equal to it
p41696
aVYou will have a set of up to  numbers
p41697
aVFind their  and , and check it against the  difference
p41698
aVUpon completion  will have the answer to your problem
p41699
aVIf the size of the union is  and you use an ordered representation for your  sets, this algorithm finds the answer in  time
p41700
as(dp41701
g6
V335858
p41702
stp41703
a((dp41704
g2
(lp41705
V is a type name, not a variable name
p41706
aVYou cannot invoke instance methods on a type
p41707
aVCreate a variable of type , assign it an instance, and then call methods on the instance using the same notation that you already have:
p41708
as(dp41709
g6
V335858
p41710
stp41711
a((dp41712
g2
(lp41713
VYou can do it with a nested query that uses :
p41714
aVIf multiple counties in a single state have the same , both counties will be returned
p41715
as(dp41716
g6
V335858
p41717
stp41718
a((dp41719
g2
(lp41720
VLike this:
p41721
aVNote that of there is no  character in the string, the entire string will be returned
p41722
aVIf there are multiple  characters present, the first character will be used as the "cutting point", and the remaining ones will be ignored
p41723
aVLink to a demo on ideone
p41724
as(dp41725
g6
V335858
p41726
stp41727
a((dp41728
g2
(lp41729
VThe reason why you see these errors is that  is local to the  method, meaning that no other method can access it unless you explicitly pass the scanner to that method
p41730
aVThere are two ways of resolving it:
p41731
aVPassing the scanner to the  method, or
p41732
aVMaking the scanner  in the class
p41733
aVHere is how you can pass the scanner:
p41734
aVHere is how you can make the  static: replace
p41735
aVin the  with
p41736
aVoutside the  method
p41737
as(dp41738
g6
V335858
p41739
stp41740
a((dp41741
g2
(lp41742
VYou can split the input with a simple regular expression, like this:
p41743
aVThe heart of this solution is a regular expression:
p41744
aVmeans "one or more digit;  means "any of the , , , or "
p41745
aVHere is a demo on ideone
p41746
aVNote that your program would need to be really careful about deciding if a  or a  is a unary "change sign" or a binary operation: when the sign is at the beginning or just after another operator, it's unary; otherwise, it's binary
p41747
as(dp41748
g6
V335858
p41749
stp41750
a((dp41751
g2
(lp41752
VWith most modern optimizers, there is no "proper" way of doing it: your code would be converted to whatever is fastest on your system, which may include
p41753
aVLoading bytes separately into lower and upper partial registers - no transformation is going on, the bytes are loaded directly into their respective places
p41754
aVBit shifting the top byte and OR-ing in the lower byte - something like
p41755
aVBit shifting the top byte and adding the lower byte - same as above, except with a  instead of an
p41756
aVSomething completely different that works fast on your system - Different architectures may have architecture-specific optimizations not described above
p41757
aVIn your source code you should concentrate on making your intentions clear to human readers: if it is multiplying by  that makes the most sense to your readers, then use multiplication; if it is bit shifting, then use bit shifting
p41758
aVThe compiler will take care of making your code as efficient as possible
p41759
as(dp41760
g6
V335858
p41761
stp41762
a((dp41763
g2
(lp41764
VAnd the scope of spinner has been lost
p41765
aVis a local variable
p41766
aVIt disappears as soon as the code reaches the nearest closing curly brace following its declaration
p41767
aVIf you don't want it to happen, make  an instance variable of the class or the class extension
p41768
aVInstance variables are declared inside curly braces following the interface declaration or the class extension declaration, for example:
p41769
aVor
p41770
as(dp41771
g6
V335858
p41772
stp41773
a((dp41774
g2
(lp41775
VYour call of  is allright - I would replace initialization of  with the equivalent
p41776
aVand switched to a re-enterable , but that's not what causing the crash (unless you are in a concurrent environment, in which case the crash should be random and mostly independent of the file being parsed)
p41777
aVThis line is highly suspicious:
p41778
aVYou either do not have enough space allocated to the array pointed to by the  pointer, or the  itself is invalid
p41779
as(dp41780
g6
V335858
p41781
stp41782
a((dp41783
g2
(lp41784
VConnection pooling is not a problem, it is a solution to a problem
p41785
aVIt is connection pooling that enables you write
p41786
aVwithout a fear of exhausting the limited number of RDBMS connections, or slowing down your system to a crawl due to closing and re-opening connections too often
p41787
aVThe only issue that you may run into with the code like that is caching: whatever is cached in  is gone when it goes out of scope, so you may re-read the same info multiple times unnecessarily
p41788
aVHowever, the cache on RDBMS side would help you in most cases, so even the caching is not going to be an issue most of the time
p41789
as(dp41790
g6
V335858
p41791
stp41792
a((dp41793
g2
(lp41794
VYou misunderstood the purpose of the  method: it is there to reset the "metadata" associated with the scanner - its whitespace, delimiter characters, and so on
p41795
aVIt does not change the state of its input, so it would not achieve what you are looking for
p41796
aVWhat you need is a call of , which reads and discards any  from the :
p41797
aVRelying upon exceptions to catch exceptional situations is OK, but an even better approach to the same issue would be using  methods before calling the  methods, like this:
p41798
as(dp41799
g6
V335858
p41800
stp41801
a((dp41802
g2
(lp41803
VOne way to avoid redrawing everything is to call  instead of , and passing only a rectangle containing the image that needs to be redrawn
p41804
aVOf course this means that your  can no longer ignore the rectangle passed in: go through the images, and check if an image overlaps with the rectangle being redrawn
p41805
aVIf there is no overlap, skip the image and save some CPU time on a redraw
p41806
aVNote that this is a very "manual" way of maintaining a view
p41807
aVConsider using some of the components that iOS provides for you, such as , which lets you display lots of stuff on the screen with very little code
p41808
as(dp41809
g6
V335858
p41810
stp41811
a((dp41812
g2
(lp41813
VI got some junk value
p41814
aVIs it because I have not declared q as a double pointer
p41815
aVIn essence, yes: since you declared  as a pointer to , the dereference operation  thinks that the address is an
p41816
aVWhen that  is sent to  as a pointer, you hit undefined behavior
p41817
aVNote that the behavior would remain undefined even on platforms where the representation of a pointer is exactly the same as than of an
p41818
aVThat's the treacherous nature of undefined behavior: sometimes it works "by mistake"
p41819
as(dp41820
g6
V335858
p41821
stp41822
a((dp41823
g2
(lp41824
VIf you would like to find the exact type of the object, you can use a chain of s, like this:
p41825
aVHowever, this sounds like a poor design choice: consider using overloaded methods in place of a "catch all" method that takes  to avoid this issue in the first place;
p41826
as(dp41827
g6
V335858
p41828
stp41829
a((dp41830
g2
(lp41831
VThe final  gets printed outside the  method:  prints what  returns, which happens to be
p41832
aVIf you change the return type of  to , you need to call it as a method, not as an expression
p41833
aVIn other words, you can no longer call  because  expects a value to print
p41834
aVAs a side note, in order to be recursive a method needs to have a code path that calls the same method, directly or indirectly
p41835
aVSince the "calling itself" feature is missing from your  method, consider renaming it to
p41836
as(dp41837
g6
V335858
p41838
stp41839
a((dp41840
g2
(lp41841
VWould it be better form to handle the unchecked exception or throw a checked one
p41842
aVIt would be better to throw a checked exception indicating a problem with user input
p41843
aVUnchecked exceptions should be reserved to indicate programming problems from which you cannot recover without changing code; user input is not one of these problems
p41844
aVIf I do throw a checked exception, should I use IllegalArgumentException
p41845
aVMy understanding is that it is for illegal argument types, not an illegal number of arguments
p41846
aVIf your design constraints allow you to use application-specific exceptions, design one for the case of invalid user input
p41847
aVThis would make the code that uses your API look more explicit about the exceptions that it expects
p41848
as(dp41849
g6
V335858
p41850
stp41851
a((dp41852
g2
(lp41853
VYou can fix it by changing your code to
p41854
aVHowever, it is not a good idea to do it in a setter that supplies the new value, because the current  gets discarded
p41855
aVit's better to do it in a function that adjusts the current value, like this:
p41856
as(dp41857
g6
V335858
p41858
stp41859
a((dp41860
g2
(lp41861
VYou can do it with  and , like this:
p41862
as(dp41863
g6
V335858
p41864
stp41865
a((dp41866
g2
(lp41867
VThis is very likely happening because the variables are of the type : even through they both print as , one of them may be actually slightly smaller than the other (say, )
p41868
aVThis could happen because of the way  is calculated: for example, if you add  fifty times, you would not get exactly a
p41869
aVHere is a link to an example (it is in C, but that part of the language is shared with Objective C)
p41870
aVThis prints
p41871
aVTo fix this, you could compare with an epsilon, for example
p41872
as(dp41873
g6
V335858
p41874
stp41875
a((dp41876
g2
(lp41877
VThere are two general cases when you shouldn't use an interface as a return type:
p41878
aVWhen your callers need functionality of the class that is not also available through an interface, and
p41879
aVWhen your class is part of a framework that puts additional requirements on returning interfaces (e
p41880
ag303
aVclasses used with WCF)
p41881
aVIn all cases when you can use an interface as a return type it is a good idea to use one
p41882
as(dp41883
g6
V335858
p41884
stp41885
a((dp41886
g2
(lp41887
VThe error is here:  The problem is that  has not been previously assigned (i
p41888
ag630
aVan undefined behavior)
p41889
aVSwitching
p41890
aVto
p41891
aVfixes the problem
p41892
aVObviously, the memory leak of  still remains
p41893
as(dp41894
g6
V335858
p41895
stp41896
a((dp41897
g2
(lp41898
VThe function  is defined with a variable number of arguments:
p41899
aVHere is a source of  ; the function  is declared at the bottom using the  macro
p41900
aVNote that part of the reason it works with  is that the function takes other parameters already
p41901
aVIn order for the function to take variable number of arguments, it must take at least one "fixed" argument
p41902
aVThat is why it is not possible to do this trick with your  function
p41903
as(dp41904
g6
V335858
p41905
stp41906
a((dp41907
g2
(lp41908
VAlthough s are not aware of identifiers, they have a property called  which can be used for any purpose that you would like
p41909
aVYou can set the tag to, say,  on cells of one kind, and to  on cells of the other kind, and then use the tag to distinguish the cells in code
p41910
aVMoreover, once your views are tagged, you can call  on the containing view, and get back the view with the  that you want
p41911
as(dp41912
g6
V335858
p41913
stp41914
a((dp41915
g2
(lp41916
VAm I missing something
p41917
aVYes - you are missing the time limits
p41918
aVOftentimes, an algorithm that works fine for small inputs (say, an  algorithm or even a  algorithm) takes too long on larger inputs, requiring a substantially different approach
p41919
aVFor example, an  approach of finding a longest ascending subsequence can be coded in four lines of code with a single array, and it would work fine for inputs of several hundred items
p41920
aVHowever, that approach would fail for hundreds of thousands of items, requiring an advanced approach that uses a tree or a binary search
p41921
aVSince that different approach takes a lot longer to code, it is natural to reward it with a lot more points
p41922
as(dp41923
g6
V335858
p41924
stp41925
a((dp41926
g2
(lp41927
VWhen you need to create objects that all derive from a single class or implement the same interface, one common approach is to use a factory
p41928
aVIn your case, however, a simple factory may not be sufficient, because the factory itself needs to be extensible
p41929
aVOne way to implement it is as follows:
p41930
aVWith these  classes in hand, you can make a registry of makers (a simple ) go through the makers passing them the points, and stopping when you get back a non-null shape
p41931
aVThis system remains extensible, because you can add a pair of  and , and "plug them in" into the existing framework: once  gets in the registry, the rest of the system instantly becomes ready to recognize and use your
p41932
as(dp41933
g6
V335858
p41934
stp41935
a((dp41936
g2
(lp41937
VYou missed a third way of doing it - passing a custom object that encloses the five fields:
p41938
aVThis is the most descriptive and extensible way of doing it: in case you need to extend the list of items passed in, you change the , while the signature of your method stays in place
p41939
aVIf the number of parameters is likely to remain five for a foreseeable future, a method with five separate arguments is equally as good
p41940
aVSpecifically, if the number of arguments corresponds to something fundamental in the world or in the algorithm that is not going to change, a method with individual arguments is a good choice
p41941
aVFor example, if your method takes a left subtree and a right subtree of a binary tree as its inputs, having two arguments is appropriate, because a binary tree cannot get more or fewer arguments without becoming something other than a binary tree
p41942
aVPassing a plain array of unnamed objects is the least readable choice, which is also the hardest to maintain
p41943
aVUnless all objects have the same "meaning" to the program, they should not be put into the same array
p41944
aVFor example, putting a host domain and user subdomain into the same array is a quick way to mislead the readers of your program, substantially complicating the maintenance
p41945
as(dp41946
g6
V335858
p41947
stp41948
a((dp41949
g2
(lp41950
VAccording to the documentation, there are three categories of characters that are recognized as spaces:
p41951
aVSPACE_SEPARATOR
p41952
aVLINE_SEPARATOR
p41953
aVPARAGRAPH_SEPARATOR
p41954
aVTab does not fit any of these categories (it's ), so  correctly returns  for it
p41955
aVMy end goal is to test Java's ability to reckon whitespace
p41956
aVThe  function is a lot more inclusive - in particular, it includes the  category
p41957
aVPerhaps that's the function that you should use then
p41958
as(dp41959
g6
V335858
p41960
stp41961
a((dp41962
g2
(lp41963
VWhen the function declaration is correct (and in your case, it looks correct), this kind of warning happens when the definition is after the first use of the function, and there is no prototype
p41964
aVSolving this problem requires either moving the function to be textually before its fist use, or better yet add a prototype of your function above its first use, like this:
p41965
as(dp41966
g6
V335858
p41967
stp41968
a((dp41969
g2
(lp41970
VThe call of  and  must be done by thread themselves
p41971
aVIn your code, this is done by the main thread in the process of setting up the two threads
p41972
aVMoreover, that needs to be a monitor of the same object, not two different objects like it is in your case
p41973
aVTo fix this, you need to move the / onto the thread into the delegate, and add a common object for the monitor, like this:
p41974
aVNow the  thread would not be able to call  while  is going, and vice versa
p41975
as(dp41976
g6
V335858
p41977
stp41978
a((dp41979
g2
(lp41980
VYou can do it using  and , like this:
p41981
aVThis will put all elements of  after elements of , producing  that looks like
p41982
aVEDIT : (in response to a comment: "how can I also sort either allNumbers and res
p41983
aVOnce your two arrays are merged, you can use  to sort the result, like this:
p41984
as(dp41985
g6
V335858
p41986
stp41987
a((dp41988
g2
(lp41989
VIf the user inputs both  and , you do not need to search; no loops are necessary
p41990
aVAll you need is checking the entered array coordinates against the limits for your array, and returning  when they are correct, or  when they are wrong:
p41991
aVIf you were searching for a value in an array (i
p41992
ag630
aVusers enter , and you tell them the  and ) then you would need two loops, comparing  to , and returning  and  back to the user if you find a match
p41993
as(dp41994
g6
V335858
p41995
stp41996
a((dp41997
g2
(lp41998
VNo, they are different:
p41999
aVThe first loop checks the value of  before the assignment;
p42000
aVThe second loop checks the value of  after the assignment
p42001
aVAs the result, the second loop will copy the content of  into , and stop after copying
p42002
aVThe first loop would stop copying as soon as it encounters the first  in  before performing a copy, disregarding any zeros that it may find in
p42003
as(dp42004
g6
V335858
p42005
stp42006
a((dp42007
g2
(lp42008
VYou can create an array of delegates constructed from the  methods of these classes, like this:
p42009
aVHere is a demo on ideone
p42010
as(dp42011
g6
V335858
p42012
stp42013
a((dp42014
g2
(lp42015
VYou can use a variation of the State Design Pattern to implement a system where an object needs to configure its activities at run time
p42016
aVRather than creating views within a view, you could create a single view that keeps a list of things that know how to draw in a view without themselves being  objects
p42017
aVHere is an example:
p42018
aVNow your  class can keep an  of  objects, configure it with the view draw objects that it needs to draw, and then call upon them to do the drawing
p42019
aVReconfiguring the list of  objects will have the effect of  changing its behavior at run time
p42020
as(dp42021
g6
V335858
p42022
stp42023
a((dp42024
g2
(lp42025
VI want to offer a free version and a premium version
p42026
aVIn this case, you do not need to create two apps in two projects: all you need is a second target for your premium version
p42027
aVHere is a link that explains how to create and manage multiple targets in Xcode
p42028
aVThe process boils down to adding a target to the project, defining a separate properties plist for it, optionally setting up a preprocessor symbol for conditional compile, and using that symbol to  portions of your classes not needed in the free version
p42029
as(dp42030
g6
V335858
p42031
stp42032
a((dp42033
g2
(lp42034
VOnly one of these declarations declares an ivar: the first declaration makes an instance variable , while the second declaration makes a global variable
p42035
aVThe ivar from the first declaration can be used only in instance methods, not in class methods
p42036
aVThe global variable from the second declaration can be used in class methods as well as in instance methods, but all instance methods would share the same value of the  variable
p42037
as(dp42038
g6
V335858
p42039
stp42040
a((dp42041
g2
(lp42042
VTry this:
p42043
aVThere is no way to see if it's a  of  (or any other type for that matter) because of type erasure
p42044
as(dp42045
g6
V335858
p42046
stp42047
a((dp42048
g2
(lp42049
VWhat happens is dereferencing a null pointer, which is undefined behavior: your  is a pointer, which means that it needs to point to a valid location before you can read from it:
p42050
as(dp42051
g6
V335858
p42052
stp42053
a((dp42054
g2
(lp42055
VJava's regexp library provides this functionality:
p42056
aVThe "quoted" string will have all its metacharacters escaped
p42057
aVFirst, escape your string, and then go through it and replace digits by  to make a regular expression
p42058
aVSince regex library uses  and  for quoting, you need to enclose your portion of regex in inverse quotes of  and
p42059
aVOne thing I would change in your implementation is the replacement algorithm: rather than replacing character-by-character, I would replace digits in groups
p42060
aVThis would let an expression produced from  match strings like  and
p42061
aVThis would produce  no matter what page numbers and counts were there originally
p42062
aVThe output needs only one, not two slashes in , because the result is fed directly to regex engine, bypassing the Java compiler
p42063
as(dp42064
g6
V335858
p42065
stp42066
a((dp42067
g2
(lp42068
VThere will be no discernable difference between the two ways of doing it that you describe: since s in Java are immutable, a new object will be created for each suffix
p42069
aVMaking a substring from a  vs
p42070
aVwill not give you much difference in performance, compared to allocations and copying required to set up the new string objects
p42071
aVWhen you are looking for a suffix, passing the end index is not necessary: use the overload that takes a single  instead:
p42072
as(dp42073
g6
V335858
p42074
stp42075
a((dp42076
g2
(lp42077
VAmong other things, regex lets you obtain portions of the input that were matched by various parts of the regular expression
p42078
aVSometimes you need the entire match, but often you need only a part of it
p42079
aVFor example, this regular expression matches  strings:
p42080
aVIf you pass it a string
p42081
aVyou will match the entire string
p42082
aVNow let's say that you want only  and
p42083
aVNo problem - regex library lets you enclose the two  in parentheses, and then retrieve only the  and  strings from the match
p42084
aVThe above expression creates two capturing groups
p42085
aVThe  object obtained by matching the pattern lets you retrieve the content of these groups individually:
p42086
aVThis prints  and
p42087
aVDemo on ideone
p42088
as(dp42089
g6
V335858
p42090
stp42091
a((dp42092
g2
(lp42093
VYou are missing another  (you've got two s in a row)
p42094
aVThis
p42095
aVshould be
p42096
as(dp42097
g6
V335858
p42098
stp42099
a((dp42100
g2
(lp42101
VWhen you set the , you should also set
p42102
aVOtherwise, the two get out of sync:
p42103
aVYou also need to assign  to  before the loop, and remove
p42104
aVat the top of loop
p42105
as(dp42106
g6
V335858
p42107
stp42108
a((dp42109
g2
(lp42110
VThe answer depends on the type of
p42111
aVIf it is a normal type, then its assignment operator will be invoked, which will do a copy in a way that is specific to your class (by default, that's a simple copy for primitives followed by copy constructors for non-primitives)
p42112
aVIf  is a -ed pointer type, then a copy of that pointer will be made
p42113
ag1971
ag1972
aVI am assuming that you assigned  and  some valid pointers to objects before dereferencing them
p42114
as(dp42115
g6
V335858
p42116
stp42117
a((dp42118
g2
(lp42119
VYou need to generate a random index in the second dimension, like this:
p42120
aVThis is OK when all rows have the same size; if they do not, the above code would "favor" items from "shorter" rows
p42121
aVFixing this deficiency would require more preparation: you would need to "flatten" your array, generate a single random up to the number of items, and then pick an item from the flattened array
p42122
as(dp42123
g6
V335858
p42124
stp42125
a((dp42126
g2
(lp42127
VSearching though an array requires a loop:
p42128
aVTo figure out if there are duplicates in  add a similar code snippet inside the outer loop:
p42129
as(dp42130
g6
V335858
p42131
stp42132
a((dp42133
g2
(lp42134
VYou can generate these files yourself - a relatively simple algorithm should be sufficient:
p42135
aVGo through numbers  from 0 to 255 sequentially
p42136
aVFor each number , generate a random number  in the range from 1 to 4, inclusive
p42137
aVAdd  values of  to a list
p42138
aVIf the number of items in the list is less than 500 (this is very unlikely) you can set  back to , and continue with the same algorithm until you cross the 500 count
p42139
aVApply the random shuffle algorithm to the list
p42140
aVWrite the results to a file
p42141
as(dp42142
g6
V335858
p42143
stp42144
a((dp42145
g2
(lp42146
VThis is because  values are copied: when you write
p42147
aVgets a copy of the item at the index of
p42148
aVYou can modify the copy all you want, but unless you assign it back (e
p42149
ag303
aV) the changes are not going to "stick"
p42150
aVUsing a pointer fixes this issue:
p42151
aVNow  points to the  at , so all modifications happen on the  itself, not on its copy
p42152
as(dp42153
g6
V335858
p42154
stp42155
a((dp42156
g2
(lp42157
VYou can calculate the number of zeros that you want to add to the left like this:
p42158
aVIf  is not 8, you can pad the string like this:
p42159
aVHere is a demo on ideone
p42160
as(dp42161
g6
V335858
p42162
stp42163
a((dp42164
g2
(lp42165
VYou can use  to access the  field, but there is no common type that defines
p42166
aVYou cannot put  in a common non-generic interface, because its type is generic
p42167
aVStarting with C# 4
p42168
aV0, you can use  for things like that:
p42169
aVThis may be slightly slower, but it will compile and do what you want
p42170
as(dp42171
g6
V335858
p42172
stp42173
a((dp42174
g2
(lp42175
VThe call would looke like this:
p42176
aVThis would give you the array produced by
p42177
aVThis code makes a new instance of  every time it needs the array; this may or may not be what you want, because you cannot keep any state between invocations
p42178
aVIf keeping state in  is what you need, you would have to implement a singleton (here is a link to a question explaining a very good way of implementing singletons in Objective C)
p42179
as(dp42180
g6
V335858
p42181
stp42182
a((dp42183
g2
(lp42184
VYes, there is: if 's hash code does not fit in an , now or some time in the future, you would be in for a nasty surprise, when unequal objects with identical hash codes start evaluating as equals
p42185
aVIf at a later date someone decides that  should be  or ,  would continue to happily compile, but its behavior would be hopelessly incorrect
p42186
aVOn an unrelated note, if  is a class, you may want to do something about preventing crashes when  or  is : although the contract of  does not explicitly calls for it (unlike  that does) it is a good idea to deal with s in  in situations when you search through containers that may include  objects
p42187
as(dp42188
g6
V335858
p42189
stp42190
a((dp42191
g2
(lp42192
VThis is a relatively straightforward function1 that analyzes an , and produces2 one of two  values:
p42193
aVif the dictionary's element at the key called  contains a string object with the value , and
p42194
aVif there is no element at the key called , or the corresponding collection does not contain the word  among its values
p42195
aV1 This is a C function, not an Objective C method
p42196
aV2 The decision is made using a ternary conditional operator
p42197
as(dp42198
g6
V335858
p42199
stp42200
a((dp42201
g2
(lp42202
VThe reason this does not work is that you are using a "free-standing" parameter expression when compiling your lambda
p42203
aVYou should create  before making your , and use the same instance of  both when you make a member expression and when you are compiling the lambda:
p42204
as(dp42205
g6
V335858
p42206
stp42207
a((dp42208
g2
(lp42209
VYou can combine two string literals by writing them one after the other with no  plus between them:
p42210
aVThe fact that one of the string literals happens to be defined through the preprocessor does not change much: you can do it like this as well:
p42211
aVHere is a demo on ideone
p42212
as(dp42213
g6
V335858
p42214
stp42215
a((dp42216
g2
(lp42217
VThe  operator takes an address of an expression, which must be an lvalue (i
p42218
ag630
aVsomething that can appear on the left side of an assignment)
p42219
aVThe  expression cannot appear on the left side of an assignment, so taking an address of  in  is not allowed
p42220
aVIn order to pass an address of an address you need to create a pointer variable first, assign an address of a thing to that pointer, and then pass an address of a pointer, like this:
p42221
as(dp42222
g6
V335858
p42223
stp42224
a((dp42225
g2
(lp42226
VEclipse takes the safe way out
p42227
aVAlthough the calculation method that uses a prime, a multiplication, and an addition is slower than a single XOR, it gives you an overall better hash code in situations when you have multiple fields
p42228
aVConsider a simple example - a class with two s,  and
p42229
aVYou can use
p42230
aVor
p42231
aVNow consider two objects:
p42232
aVand
p42233
aVThe first method will produce identical hash codes for them, because XOR is symmetric; the second method will produce different hash codes, which is good, because the objects are not equal
p42234
aVIn general, you want non-equal objects to have different hash codes as often as possible, to improve performance of hash-based containers of these objects
p42235
aVThe  method achieves this goal better than XOR
p42236
aVNote that when you are dealing with portions of the same object, as in
p42237
aVthe above argument is much weaker: encountering two timestamps such that the only difference between them is that their upper and lower parts are swapped is harder to imagine than two objects with swapped  and  field values
p42238
as(dp42239
g6
V335858
p42240
stp42241
a((dp42242
g2
(lp42243
Vhis program need all result data for checking
p42244
aVIf a program needs all that data for checking whatever it needs to check, then there is no way around it: you need to download all the data from the RDBMS
p42245
aVHowever, oftentimes you do not need to store all that data in memory: if checking the data can be done by examining one row at a time, you could read the data one row at a time, check it, and then discard the row
p42246
aVThis approach presents a good alternative to paging, because you need to send only one query, non-paged queries are typically simpler to use than their paged counterparts
p42247
as(dp42248
g6
V335858
p42249
stp42250
a((dp42251
g2
(lp42252
VYou can do it like this:
p42253
aVSince the  clauses are mutually exclusive, only one of the -ed queries would return some rows; the other query will return nothing
p42254
as(dp42255
g6
V335858
p42256
stp42257
a((dp42258
g2
(lp42259
VSo the invented prototype would be "int multiply(int)", and hence the errors
p42260
aVIs this correct
p42261
aVAbsolutely
p42262
aVThis is done for backward compatibility with pre-ANSI C that lacked function prototypes, and everything declared without a type was implicitly
p42263
aVThe compiler compiles your , creates an implicit definition of , but when it finds the real definition, it discovers the lie, and tells you about it
p42264
aVHow come when I break the code into 2 files it compiles
p42265
aVThe compiler never discovers the lie about the prototype, because it compiles one file at a time: it assumes that  takes an , and returns an  in your , and does not find any contradictions in
p42266
aVRunning this program produces undefined behavior, though
p42267
aVOnce I run the program above (the version split into 2 files) the result is that 0
p42268
aV0000 is printed on the screen
p42269
aVThat's the result of undefined behavior described above
p42270
aVThe program will compile and link, but because the compiler thinks that  takes an , it would never convert  to , and  will never find out
p42271
aVSimilarly, the incorrect value computed by doubling an  reinterpreted as a  inside your  function will be treated as an  again
p42272
as(dp42273
g6
V335858
p42274
stp42275
a((dp42276
g2
(lp42277
VYes, there is: in C, typecast has higher precedence than division, so the first one will divide in , while the second one will perform an integer division
p42278
as(dp42279
g6
V335858
p42280
stp42281
a((dp42282
g2
(lp42283
VTo check every result of  against some other rule, all you need to do is to write that rule in terms of  and , like this:
p42284
aVand so on
p42285
aVWhen you evaluate , Prolog will unify  and  with the first set of values, and then go on with the rest of the clause (above, it's checking that  and  are greater than zero, and evaluating the two variables with the  rule
p42286
aVOnce the rule comes up with a set of assignments, it gives them to you, and lets you stop or continue
p42287
aVIf you want to always continue until the whole set is exhausted (e
p42288
ag303
aVto print all assignments of  and ), the pattern looks like this:
p42289
aVThe first rule goes through each assignment of , , prints them, and then fail to trigger re-evaluation
p42290
aVThe second rule is a catch-all fact to stop further evaluation
p42291
aVHere is a link to a demo on ideone that prints all pairs of adjacent cells
p42292
as(dp42293
g6
V335858
p42294
stp42295
a((dp42296
g2
(lp42297
VIn this particular case, there is no difference: you will see the output of roughly the same level of detail (i
p42298
ag630
aVit tells you that something that was expected to evaluate to  has evaluated to )
p42299
aVSame goes for
p42300
aVand
p42301
aVYour team should pick one style of assertions, and stick with it throughout all your tests
p42302
aVIf your team prefers the  style, then you should use
p42303
as(dp42304
g6
V335858
p42305
stp42306
a((dp42307
g2
(lp42308
VYou can use the fact that an  can be enumerated as a collection of  objects
p42309
aVTherefore, you can do it like this:
p42310
aVI do not recognize the format of the timestamp value, so you need to build a  function that takes the string and returns the partial timestamp needed for sorting:
p42311
as(dp42312
g6
V335858
p42313
stp42314
a((dp42315
g2
(lp42316
VYour method should check each digit as it goes through the loop, rather than waiting for the loop to complete before making its decision
p42317
aVCurrently, the  loop runs the  down to zero, and only then tries to check the value
p42318
aVNaturally, by the time the loop is over, both values are zero, so the return is
p42319
as(dp42320
g6
V335858
p42321
stp42322
a((dp42323
g2
(lp42324
VThe reason for having instance variables in the first place is to avoid passing them as parameters: your instance method gets to access them "for free", because they are already in the method's scope
p42325
aVThere are two reasons to pass instance variables to methods, though:
p42326
aVThe method is  - class methods cannot access instance variables, so you need to pass them explicitly, or pass the object on which to operate
p42327
aVYou need to use pass-by-value semantic - in other words, you would like to modify the value passed in, and you would like to avoid creating a local variable
p42328
aVThis is often the case when the method is recursive
p42329
aVIf you find yourself writing recursive code that modifies a parameter which started off as an instance variable, in many cases it may be a good idea to make your method , and add a  instance method to start the recursive chain and to harvest the results
p42330
as(dp42331
g6
V335858
p42332
stp42333
a((dp42334
g2
(lp42335
VLeaving aside a generally good advice to not inherit from  containers, preferring composition instead, you are still not doing it right: the method  (and the rest of the methods that they expect you to define) are supposed to operate on the string itself, not on a string passed in:
p42336
aVThe rest of the methods will do the same thing - they will not take a string argument, and use  instead
p42337
aVHow in the world can you do the other methods using this-> instead of loading in a string argument
p42338
aVThe remaining methods are not different - simply take the string inside your own object
p42339
aVI am nearly certain that learning how to do this is the point of the exercise
p42340
aVFor example, to add vowel counter, you do something like this:
p42341
as(dp42342
g6
V335858
p42343
stp42344
a((dp42345
g2
(lp42346
VYou can use  method, like this:
p42347
aVUsing lookbehind should help you preserve the punctuation mark after the sentence
p42348
aVHere is a small demo on ideone
p42349
as(dp42350
g6
V335858
p42351
stp42352
a((dp42353
g2
(lp42354
VAlthough there is no performance difference, the second method presents a far superior API, because Java arrays are always mutable
p42355
aVThe first API lets your users write
p42356
aVand modify internals of your object behind your back
p42357
aVThis is never a good thing: even a non-malicious users could do things you never intended, simply by mistake
p42358
as(dp42359
g6
V335858
p42360
stp42361
a((dp42362
g2
(lp42363
VYou can do this by declaring a specifically named static field in each class, and getting it through reflection}
p42364
aVSuppose your classes look like this:
p42365
aVThen you can obtain their  fields like this:
p42366
aVYou call the method as follows:
p42367
aVHere is a demo on ideone
p42368
as(dp42369
g6
V335858
p42370
stp42371
a((dp42372
g2
(lp42373
VTo display time in milliseconds, multiply the time in seconds by :
p42374
aVThe above code truncates the time to the smallest millisecond
p42375
as(dp42376
g6
V335858
p42377
stp42378
a((dp42379
g2
(lp42380
VThe only technical reason I could think of is overload resolution: you could have
p42381
aVand also
p42382
aVThis is allowed; without  in the call, the compiler wouldn't be able to tell them apart
p42383
as(dp42384
g6
V335858
p42385
stp42386
a((dp42387
g2
(lp42388
VShould I declare and initialize the local (for the block) data inside the block
p42389
aVAbsolutely: this tends to make programs more readable
p42390
aVDoes this have runtime performance cost (due to runtime allocation in the stack)
p42391
aVNo: all allocations are done upfront - the space on the stack is reserved for variables in all branches upon entering a function, not when the branch is entered
p42392
aVMoreover, this could even save you some space, because the space allocated for variables in non-overlapping branches can be reused by the compiler
p42393
aVOr should I declare and/or initialize all variables at function entry, so that is is done in one, possibly faster, operation block
p42394
aVNo, this is not faster, and could be slightly more wasteful
p42395
aVOr should I seperate the if() blocks in different functions, even though they are only a couple of lines long and used only one in the program
p42396
aVThat would probably have a negative impact on readability of your program
p42397
as(dp42398
g6
V335858
p42399
stp42400
a((dp42401
g2
(lp42402
VIf I can still access the instance members after I deleted it how do I know if it was properly deleted
p42403
aVJust trust the runtime library: if you call , the thing is deleted, period
p42404
aVOnce you tell the system that you no longer need the memory, you gave it up - it is no longer yours
p42405
aVThe system counts it with its available memory to redistribute, so it can give it to other parts of your program upon request
p42406
aVYou can still access that memory, and may even find what was there before you gave it up, but that's undefined behavior
p42407
aVIs my code going to cause a memory leak
p42408
aVNo, because you release the memory that you allocated
p42409
aVI guess the ultimate question is: am I doing something wrong
p42410
aVYes - accessing the memory of deallocated object is wrong (undefined behavior)
p42411
aVOther than that, it looks fine
p42412
as(dp42413
g6
V335858
p42414
stp42415
a((dp42416
g2
(lp42417
VTry this:
p42418
aVThis avoids accessing the resources on each iteration
p42419
aVIf this does not help, try writing your own  based on an advanced string searching algorithm, such as the KMP
p42420
as(dp42421
g6
V335858
p42422
stp42423
a((dp42424
g2
(lp42425
VRather than avoiding an update altogether, you could change your  code to add zero when names match:
p42426
as(dp42427
g6
V335858
p42428
stp42429
a((dp42430
g2
(lp42431
VI think you need to indicate to the compiler it's a member implementation by supplying a fully qualified name:
p42432
aVIt would be a good idea to make your operator , and to make the   as well
p42433
aVWithout the scope resolution qualifier, the compiler thinks that you are defining a "free-standing" operator to compare contacts, in which case the operator would indeed need to take two arguments:
p42434
as(dp42435
g6
V335858
p42436
stp42437
a((dp42438
g2
(lp42439
VThat's the "magic" done by the Java compiler: when you write
p42440
aVJava compiler sees it as
p42441
as(dp42442
g6
V335858
p42443
stp42444
a((dp42445
g2
(lp42446
VGenerally, you want your model to operate on the level that is independent of the representation
p42447
aVTherefore, you typically want your parsing done in the view or in the controller; the tasks associated with validation, computation, and persistence should be done in the model
p42448
aVThe data for these operations should be supplied in a way that is independent of representation
p42449
aVFor example, if your RESTful service consumes XML input, the view or the controller should deal with the parsing
p42450
aVThe model should see object representations of the parsed input
p42451
aVThis would let you switch representation simply by providing a different view - for example, you would be able to change your service to process JSON input without touching your model
p42452
aVNote that this is part of MVC division of responsibilities that holds true outside of RESTful architectures
p42453
as(dp42454
g6
V335858
p42455
stp42456
a((dp42457
g2
(lp42458
VThis should work:
p42459
aVSee a demo on ideone
p42460
as(dp42461
g6
V335858
p42462
stp42463
a((dp42464
g2
(lp42465
VBecause of type erasure, there is no way to do that:  is actually a  behind the scene, regardless of its type parameter
p42466
aVOne way around this would be adding a  property to your generic object, like this:
p42467
aVNow you can use  to find the actual class of the type parameter, compare it to , and make a decision based on that
p42468
as(dp42469
g6
V335858
p42470
stp42471
a((dp42472
g2
(lp42473
VA very straightforward regex to match what you need is
p42474
aVIt matches the first digit in the 2
p42475
aV9 range, and the other nine digits in the 0
p42476
aV9 range, ten digits in total
p42477
aVNote that this expression is suitable for validating the entire string, not a partial one
p42478
aVYou cannot use it in  to validate the digits as they become available
p42479
aVIt's not a good idea to validate the format of the input as it's being entered anyway, because users may choose to enter the phone's digits in any order by moving the cursor to the right position before they type
p42480
aVInstead, you should set the  property of your  to , and let users type as many digits as they want
p42481
aVDon't limit their input until they tell you that they are done: they may want to paste data from, say, a notepad, and then erase the separators, or enter a few extra digits at the end before deleting a section at the front of the input
p42482
aVInstead, you should use the above expression in the  method
p42483
aVWhen regex matches, return ; otherwise, return , and give users some visual feedback to indicate that the number needs to be changed
p42484
aVRead the discussion section of the  method in  documentation
p42485
as(dp42486
g6
V335858
p42487
stp42488
a((dp42489
g2
(lp42490
VAbsolutely: even in C // all take the size as their parameter, and they do not care where that size came from; same goes for
p42491
aVFor example, if you would like to allocate a user-specified number of s, you do this:
p42492
as(dp42493
g6
V335858
p42494
stp42495
a((dp42496
g2
(lp42497
VYou need to use  to compare strings:
p42498
aVYou need to compare to zero, because  returns zero when two strings are identical
p42499
aVHowever, it looks like you are not comparing strings: rather, you are looking for a specific character inside the string
p42500
aVIn this case, you need to use a character constant instead of a string literal (with single quotes):
p42501
as(dp42502
g6
V335858
p42503
stp42504
a((dp42505
g2
(lp42506
VThe problem is because you are passing a pointer to a local variable out of a function
p42507
aVDereferencing such pointers is undefined behavior
p42508
aVYou should allocate  with
p42509
aVThis code
p42510
aVcreates a local variable
p42511
aVOnce the function is over, the scope of  ends, and its memory gets destroyed
p42512
aVHowever, you are passing the pointer to that destroyed memory to outside the function
p42513
aVAll references to that memory become invalid as soon as the function exits
p42514
aVThis code, on the other hand
p42515
aVallocates an object on free store
p42516
aVSuch objects remain available until you  them explicitly
p42517
aVThat's why you can use them after the function creating them has exited
p42518
aVOf course since  is a pointer, you need to use  to access its members
p42519
as(dp42520
g6
V335858
p42521
stp42522
a((dp42523
g2
(lp42524
VNot every sequence of bytes represents a valid : you need to know the character encoding in order to interpret a sequence of bytes as a string
p42525
aVSince Java's  is 16-bit, a random sequence of bytes can end up representing a string with invalid code points in it
p42526
aVUsing the Base-64 encoding fixes this problem by ensuring that all elements are valid characters from  range
p42527
as(dp42528
g6
V335858
p42529
stp42530
a((dp42531
g2
(lp42532
VThe fact that you can pass a string to  and get a valid result does not guarantee that passing the same string to  would also be successful
p42533
aVTo find out what algorithms are supported on your system, run this code, and look at the results:
p42534
aVThe output will contain lines that look like this:
p42535
aVThe names prefixed with  (i
p42536
ag630
aV, '"SHA1PRNG"') can be passed to , while the names prefixed with  (i
p42537
ag630
aV, , ) can be passed to
p42538
as(dp42539
g6
V335858
p42540
stp42541
a((dp42542
g2
(lp42543
VYou can use  directly, like this:
p42544
aVAlthough this may be a little faster than using the , it's not an apples-to-apples comparison:  provides more methods for tokenizing the input, while  can split your input into lines, without tokenizing it
p42545
as(dp42546
g6
V335858
p42547
stp42548
a((dp42549
g2
(lp42550
VYour algorithm does not have to reflect this: if you try out all starting positions, you would find that the corners and the center give you more path to win than other cells
p42551
aVWith tic-tac-toe's lack of complexity, the minimax can look ahead all the way through the end of the game, starting with the very first move
p42552
aVThe number of available moves goes down quickly as you progress through the game, so the full search finishes pretty fast
p42553
aVWith more complex games (othello, checkers, chess), the so-called "opening books" become more important
p42554
aVThe number of available moves in the beginning of the game is enormous, so a traditional approach is to pick a move from the "book" of openings, and stay with pre-calculated "book moves" for the first three to six plays
p42555
aVMoves outside the book are not considered, saving a lot of CPU on moves that remain essentially the same
p42556
as(dp42557
g6
V335858
p42558
stp42559
a((dp42560
g2
(lp42561
VThese are GCC extensions operators
p42562
aVhas the same meaning as  ( is the "max" operator), but it evaluates its left-hand side expression only once
p42563
aVThis is not important when  is a variable, but it may make a difference when  represents an expression, especially when the expression has a side effect
p42564
aVFor example, in
p42565
aVthe  in  would be evaluated only once
p42566
aVBoth operators have now been deprecated
p42567
as(dp42568
g6
V335858
p42569
stp42570
a((dp42571
g2
(lp42572
VUsing a join is your best choice
p42573
aVHowever, if you want to avoid joining explicitly, you can do this:
p42574
aVThe requirement for this to work is that the  inside  returned a scalar
p42575
as(dp42576
g6
V335858
p42577
stp42578
a((dp42579
g2
(lp42580
VYou almost got it: instead of  in
p42581
aVuse :
p42582
as(dp42583
g6
V335858
p42584
stp42585
a((dp42586
g2
(lp42587
VYou are missing several things (in the harder-to-fix order, starting with the easier ones):
p42588
aVYour comparator never returns zero, even if the same object is passed to it,
p42589
aVWhen neither object depends on the other one, there is no definitive tie-breaker,
p42590
aVAt the time of object insertion in the tree set, not all items are available; however, insertion of a single new item may change relative ordering of other items
p42591
aVThe ordering considers only immediate dependencies
p42592
aVYou can fix the first two relatively easily by checking the dependency of  on  before returning , and using  for tie-breaking
p42593
aVThe third one could be fixed by switching to an array, and sorting it only after all the insertions have been made
p42594
aVThe last one, however, is very bad: in order to fix it, each item needs to know about the rest of the collection
p42595
aVI do not see a good way out of this, so I suggest using a traditional topological sorting algorithm to order your dependencies, rather than trying to shoehorn that problem in the framework of Java collections
p42596
as(dp42597
g6
V335858
p42598
stp42599
a((dp42600
g2
(lp42601
V has sub-millisecond precision
p42602
aVIf the dates are one day and a millisecond apart, you would charge the 25-th credit
p42603
aVChanging the code to do integer division should deal with the problem:
p42604
as(dp42605
g6
V335858
p42606
stp42607
a((dp42608
g2
(lp42609
VThis regular expression should work:
p42610
aVIf  on this regex returns , you could do further validations to see what's wrong
p42611
aVHow can I improve the code
p42612
aVYou can create a list of pairs of regexes and error messages
p42613
aVEach regex should be more restrictive than the previous one
p42614
aVGo through the list, and try matching the code against the regex
p42615
aVIf there is no match, print the error message and exit the loop
p42616
aVFor example, you can do this:
p42617
aV- "The code must contain six characters"
p42618
aV^[a-zA-Z0-9]{6}$' - "The characters must be alhpanumeric"
p42619
aV^[[a-zA-Z]{3}
p42620
aV{3}$' - "The first three characters must be letters"
p42621
as(dp42622
g6
V335858
p42623
stp42624
a((dp42625
g2
(lp42626
VThe two loops are not even equivalent: in case  is expected to return different values when you call it multiple times, the results are going to be different
p42627
aVWhen  returns the same value no matter how many times you call it, the first option is going to be more efficient when  returns a number greater than or equal to
p42628
aVIn case it returns , there will be no difference
p42629
aVThe difference in timing comes from the fact that the second option calls  repeatedly in the loop to get the limit
p42630
aVEven if the function call is very fast, this code is sub-optimal
p42631
as(dp42632
g6
V335858
p42633
stp42634
a((dp42635
g2
(lp42636
VWhat am I doing wrong
p42637
aVYou are setting up  before calling
p42638
aVWhen you call  to insert at , the  will change, so  will point to the second node
p42639
aVMove  to after the  call to fix the problem:
p42640
as(dp42641
g6
V335858
p42642
stp42643
a((dp42644
g2
(lp42645
VWhen you declare the  the way that you did, there is no memory allocated for the structure
p42646
aVHowever, you can declare a  and define a variable of that type right away, like this:
p42647
aVYou can also define variables in the automatic space (local variable) or in the dynamic space with
p42648
as(dp42649
g6
V335858
p42650
stp42651
a((dp42652
g2
(lp42653
VYes, you can try this for lists:
p42654
aVFor dictionaries, you can use this:
p42655
as(dp42656
g6
V335858
p42657
stp42658
a((dp42659
g2
(lp42660
VMy understanding is that the two pieces of code are not equivalent - in order to do the same thing with  as with , you would have to write significantly more code
p42661
aVAccording to the overview section of documentation,  implementation with  should look something like this:
p42662
aVIf all you need is protection against concurrent modification, using  looks like a much simpler option
p42663
as(dp42664
g6
V335858
p42665
stp42666
a((dp42667
g2
(lp42668
VUnlike  primitive that has two states, namely,  and , a wrapper  has an additional third state of
p42669
aVWhen the  object is , it is neither  nor
p42670
aVWhen you compare the object for equality to , the value gets wrapped as , and gets compared to
p42671
aVThe result is
p42672
aVThe same thing would happen if you compare it to , however: the code below will not print anything
p42673
aVIf you need three states in your flags (, , and "not set") you should use ; in cases when you need only two states ( and ) you should stay with the primitive data type of
p42674
as(dp42675
g6
V335858
p42676
stp42677
a((dp42678
g2
(lp42679
VYes, you can do it: replace  with  to insert leading zeros and make the total number of digits equal 4:
p42680
aVFor more information on the format specifiers, read documentation of : format specifiers of  are for the most part compatible with it
p42681
as(dp42682
g6
V335858
p42683
stp42684
a((dp42685
g2
(lp42686
VPassing  instead of  as the first parameter of  functions may access memory past the allocated region
p42687
aVAccording to at least one source of , the size of  is 16 to 32 bytes;  is not going to be sufficient to hold the structure of a semaphore, potentially resulting in undefined behavior
p42688
aVYou need to change
p42689
aVto
p42690
aVto fix the access past the allocated memory region
p42691
aVAlso, it is generally a good idea to initialize your semaphores before starting the threads that use them
p42692
aVYou should move the initialization call from the  function to the , or whatever function that you use to start your thread
p42693
as(dp42694
g6
V335858
p42695
stp42696
a((dp42697
g2
(lp42698
VYou cannot do that in C: the language does not support overloads or default parameters
p42699
aVThe only thing that you can do to emulate this would be using variable number of parameters, but that would not work here, because you would need to pass an additional parameter indicating the type of the item being searched
p42700
aVA better approach would be defining two functions
p42701
aVor better yet, using the corresponding functions from the standard library -  and
p42702
as(dp42703
g6
V335858
p42704
stp42705
a((dp42706
g2
(lp42707
VYou can use  method, like this:
p42708
aVDropping the last parameter gives you a substring from the specific position to the end of the original string
p42709
as(dp42710
g6
V335858
p42711
stp42712
a((dp42713
g2
(lp42714
VAlthough what you are doing is possible, it is not portable: C99 standard says that bit-field base type must be a , , or , allowing implementation-defined types to be used with bit-fields (C90 requires a signed on an unsigned as bit-field's base type; no other types are allowed)
p42715
aVSee this answer for references to appropriate chapters of the C99 and C90 standards
p42716
aVIf your goal is to define a  of bit-fields of size that is smaller than an , you would be better off using bit shifts for portability
p42717
as(dp42718
g6
V335858
p42719
stp42720
a((dp42721
g2
(lp42722
VYou are doing everything right:  results in a number with binary representation consisting of all ones
p42723
aVSuch number is interpreted as  in two's compliment representation of negative numbers
p42724
as(dp42725
g6
V335858
p42726
stp42727
a((dp42728
g2
(lp42729
VThe base type of the enumeration is implementation defined
p42730
aVIn this case, the base type should be , because the standard requires the compiler to pick a base type that is wide enough to hold all enumeration values
p42731
aVFrom the C99 standard, section 6
p42732
ag838
ag839
ag839
aV4:
p42733
aVEach enumerated type shall be compatible with, a signed integer type, or an unsigned integer type
p42734
aVThe choice of type is implementation-defined,108) but shall be capable of representing the values of all the members of the enumeration
p42735
aVThe enumerated type is incomplete until after thethat terminates the list of enumerator declarations
p42736
aV108) An implementation may delay the choice of which integer type until all enumeration constants have been seen
p42737
as(dp42738
g6
V335858
p42739
stp42740
a((dp42741
g2
(lp42742
VFirst, what's wrong with your solution: the reason it does not work is that it removes the content of the line, but it ignores the  at the end
p42743
aVAdding  should fix that:
p42744
aVNow to doing it a simpler way: all you need to do is finding the first , and taking substring after it, like this:
p42745
aVNote that this code does not crash even when there are no newline characters in the string, i
p42746
ag630
aVwhen  returns  (in which case nothing is removed)
p42747
as(dp42748
g6
V335858
p42749
stp42750
a((dp42751
g2
(lp42752
VBoth of them exhibit undefined behavior: the reason the first one runs is that the pointer that happens to be in  by default points to a region in memory writing to which does not happen to cause a crash (it is still illegal)
p42753
aVYou need to initialize your pointers to fix this problem:
p42754
as(dp42755
g6
V335858
p42756
stp42757
a((dp42758
g2
(lp42759
VYou cannot assign a pointer to  to a , but you can copy the content pointed to by the  into a , like this:
p42760
aVIn cases when the  is untyped, it is more common to use  instead of
p42761
as(dp42762
g6
V335858
p42763
stp42764
a((dp42765
g2
(lp42766
VIt is not necessarily a bad design, but it is an indication that something wrong may be going on
p42767
aVYour specific case looks bad, because it appears that a single method is aware of multiple classes
p42768
aVThis could be an indication that you are missing an overload possibility, or an opportunity to use one of the multiple dispatch patterns:
p42769
aVOne of the common multiple dispatch patterns is visitor pattern, see if it is applicable to the problem you're solving
p42770
as(dp42771
g6
V335858
p42772
stp42773
a((dp42774
g2
(lp42775
VThe "clauses are not together" is the simplest error to fix: simply re-arrange the facts of your program in such a way that all facts with the same name (e
p42776
ag303
aV, , etc
p42777
aVappear together in the source of your program
p42778
aVThe "singleton variables" errors are coming from these lines:
p42779
aVA variable is singleton when it is mentioned only once in the enture rule or a fact
p42780
aVIn case when you do want these variables, they should be replaced with underscores
p42781
aVHowever, in your case you do not want these variables: otherwise, a rule like this
p42782
aVwould assert that anybody is a male, and you do not want that to happen
p42783
aVYou should simply remove these rules to make the singleton errors go away
p42784
aVHowever, the biggest problem with your program appears that you are trying to define facts for things that you have already defined through rules
p42785
aVThe facts that you need are , , and
p42786
aVEverything else can be correctly derived through rules
p42787
as(dp42788
g6
V335858
p42789
stp42790
a((dp42791
g2
(lp42792
VThe numbers  and  only look the same, but they represent different concepts:  is an identifier, while  is a sequence number
p42793
aVIt is OK for sequence numbers to change, but it is not OK for IDs to change
p42794
aVI would recommend using the URI with the ID for identifying the  specific comment resource, and add a UIR with querying capability for searching the comment resource by its sequence number, like this:
p42795
aVThis way there would be no questions about the "canonical" resource URI, yet the clients would be able to query comments without having to supply full identification
p42796
as(dp42797
g6
V335858
p42798
stp42799
a((dp42800
g2
(lp42801
VIt looks like a simple  with  would work:
p42802
as(dp42803
g6
V335858
p42804
stp42805
a((dp42806
g2
(lp42807
V does have , it just happens to be
p42808
aVThis is unlike your other test cases that use non-nullable value types
p42809
aVThat's why you get a  instead of the one that you expect
p42810
aVIf you replace
p42811
aVwith
p42812
aVyou should start getting the expected
p42813
as(dp42814
g6
V335858
p42815
stp42816
a((dp42817
g2
(lp42818
VYes, this code would work for any type of the key, including
p42819
aVThe reason this works is that the non-const  returns a reference to the value at the key, not a copy of that value
p42820
aVIt is that reference to which the  operator gets applied
p42821
aVThe code fragment that you show works as follows:
p42822
aVFor each key  of type  in the  container,
p42823
aVThe map  is searched for the given key
p42824
aVSince the entry is not there, a new one gets inserted into the map
p42825
aVSince the key of the entry is known, but the value is not, a default object for the value gets created
p42826
aVA reference to the newly created object (in this case,  initialized to zero) is returned to the caller
p42827
aVThe  operator is applied to the reference returned from the , which changes  to  (or  to , etc
p42828
as(dp42829
g6
V335858
p42830
stp42831
a((dp42832
g2
(lp42833
VYes, you can do that: run an in-order traversal of the tree, keep the current position of the array, and store the node's value at the then-current position of the array
p42834
aVYou can do in-order traversal recursively, or you can do it with a stack data structure
p42835
aVIf you want to do it recursively, you can do this:
p42836
aVNote that in order for the above recursive procedure to work, the caller must allocate enough space in the  passed into the function
p42837
as(dp42838
g6
V335858
p42839
stp42840
a((dp42841
g2
(lp42842
VThat's done by breadth-first searching your tree:
p42843
aVCreate a queue of tree nodes
p42844
aVEnqueue the tree root
p42845
aVWhile the queue is not empty, repeat the following:
p42846
aVDequeue a node, and print its content
p42847
aVEnqueue the left sub-node of the current node
p42848
aVEnqueue the right sub-node of the current node
p42849
aVWhen you follow this algorithm, all nodes from level  will be printed prior to printing the first node from level , so the tree will be printed level-by-level
p42850
as(dp42851
g6
V335858
p42852
stp42853
a((dp42854
g2
(lp42855
VYes - you can use  method of the :
p42856
as(dp42857
g6
V335858
p42858
stp42859
a((dp42860
g2
(lp42861
VThe  declarations belong at the top of the translation unit where the reference is made
p42862
aVStrictly speaking, you do not have to import anything: importing is a convenience that lets you avoid typing up the full name of the class being used (i
p42863
ag630
aVinstead of )
p42864
aVThe caller does not have to import anything related to the implementation of methods in the classes that it's using
p42865
aVThat's one of the virtues of encapsulation: the caller needs to know what it calls, but it is firmly insulated from the implementation details of the classes that it uses
p42866
as(dp42867
g6
V335858
p42868
stp42869
a((dp42870
g2
(lp42871
VIf the string is short and you do not need to parse anything else from it, you can use regex:
p42872
aVThe two capturing groups would get  and
p42873
aVHere is a demo on ideone
p42874
as(dp42875
g6
V335858
p42876
stp42877
a((dp42878
g2
(lp42879
VYou can make it more concise by not using variables for the parameters that you pass by value, like this:
p42880
aVWhen the compiler sees the above, it does not call  right away
p42881
aVInstead, it creates an object that can be invoked at runtime, such that when you invoke it, the  gets called
p42882
aVIn other words, the  creates a delegate that lets you postpone a call to
p42883
aVHowever, when compiler sees this
p42884
aVit interprets it as an instruction to call  immediately, and use the delegate returned from it as the event handler
p42885
aVOf course it's not possible, because  does not return a delegate
p42886
as(dp42887
g6
V335858
p42888
stp42889
a((dp42890
g2
(lp42891
VYou can do it like this:
p42892
aVThe idea is that  produces a power of two: , , , , and so on
p42893
aVAdding a negative one produces , which is what your pattern represents
p42894
as(dp42895
g6
V335858
p42896
stp42897
a((dp42898
g2
(lp42899
VIt looks like the API is expecting a selector with three parameters, the third one representing
p42900
as(dp42901
g6
V335858
p42902
stp42903
a((dp42904
g2
(lp42905
VThe compiler is right (and the book is wrong, they should have tried compiling their code before publishing): there is a path through the code when  remains uninitialized by the time the code reaches the  line
p42906
aVSpecifically, if  gets thrown in the first outer / block, the  variable will not be assigned
p42907
aVAdding  to the outer  block should fix this problem:
p42908
aVWith the  statement in place, control will never reach the  unless  has been initialized, fixing the compile-time error
p42909
as(dp42910
g6
V335858
p42911
stp42912
a((dp42913
g2
(lp42914
VThrowing an exception in the main thread ends execution without reaching the : that's when you get the "Console application has stopped working, would you like to debug
p42915
aVdialog from the operating system
p42916
aVThe  cannot return anything under these conditions, because there is nothing to return
p42917
aVIf you would like to return something when you get an exception, code your program like this:
p42918
as(dp42919
g6
V335858
p42920
stp42921
a((dp42922
g2
(lp42923
VYou can do it using LINQ, like this:
p42924
aVIf you cannot use LINQ because it's a legacy system, you can rewrite the code like this:
p42925
as(dp42926
g6
V335858
p42927
stp42928
a((dp42929
g2
(lp42930
VThis is going to actually copy theSet into m_currentTransformations, right
p42931
aVAbsolutely, this is going to make a copy
p42932
aVHowever, it is going to do so using the assignment operator of the  class, so you may need to be careful of how it is defined
p42933
aVIf you define a copy constructor, you usually need an assignment operator and a destructor, too (that is commonly known as the rule of three)
p42934
as(dp42935
g6
V335858
p42936
stp42937
a((dp42938
g2
(lp42939
VYou cannot override static members - in Java, neither methods nor fields could be overriden
p42940
aVHowever, in this case it does not look like you need to do any of that: since you have an instance of  in the  variable, a non-static method would do what you need with the regular override
p42941
as(dp42942
g6
V335858
p42943
stp42944
a((dp42945
g2
(lp42946
VYou can turn the condition around, and check if the composite  has the flag, rather than checking the flag for the composite, like this:
p42947
aVHere is an example:
p42948
aVThis prints
p42949
as(dp42950
g6
V335858
p42951
stp42952
a((dp42953
g2
(lp42954
VYes, that's , which is the same as
p42955
aVYou can think about it like this: since the loop repeats a fixed number of times, you can "unroll" it, like this:
p42956
aVThis is definitely
p42957
as(dp42958
g6
V335858
p42959
stp42960
a((dp42961
g2
(lp42962
VThere is a special number, , which is greater than any number representable with
p42963
aVYou can use it as a starting point for searches of a minimum:
p42964
aVAnother common trick is to set  to the first element of a list, and then start searching from the second element
p42965
as(dp42966
g6
V335858
p42967
stp42968
a((dp42969
g2
(lp42970
VIf you need to use LINQ, you can use  and , like this:
p42971
aVIf you need to throw away the first and the last parts, then you can use , like this:
p42972
aVFinally, you can use regular expression, like this:
p42973
as(dp42974
g6
V335858
p42975
stp42976
a((dp42977
g2
(lp42978
VUnfortunately, you cannot do it without a loop, because you need to try all elements of your collection to check their types
p42979
aVIn fact, it does not matter that you have a hash set: it would work the same with a list, or any other enumerable
p42980
aVHowever, LINQ lets you hide the loop, like this:
p42981
as(dp42982
g6
V335858
p42983
stp42984
a((dp42985
g2
(lp42986
VThis is an indexer property, a kind of property that lets your custom class participate in expressions that pass array subscripts in square brackets
p42987
aVThis indexer replaces an indexer property of its base class (likely, a collection), which must also have an indexer property
p42988
aVThe getter forwards the call to the base, while the setter also calls , presumably to notify whomever is watching for modifications in the collection
p42989
as(dp42990
g6
V335858
p42991
stp42992
a((dp42993
g2
(lp42994
VAlthough  would appear to work, that's not what you want: both variables will be pointing to the same calendar instance
p42995
aVAs the result of this assignment, any changes made to  will be in  as well, and vice versa
p42996
aVYou can use  method to make a copy of the  object, like this:
p42997
as(dp42998
g6
V335858
p42999
stp43000
a((dp43001
g2
(lp43002
VAssuming that you store the file in a data column, you can add a  column, and use it in  and  statements, like this:
p43003
aVTable structure:
p43004
aVPerforming an insertion:
p43005
as(dp43006
g6
V335858
p43007
stp43008
a((dp43009
g2
(lp43010
VWould this lead to re-ordering of the element in the set
p43011
aVNo, mutating an element inside a set does not lead to re-ordering of the tree set
p43012
aVYou should never do that, because once you make a mutation that changes the order, your element may get lost in the tree
p43013
aVWhat you should do is removing the element, mutating its properties that change ordering, and then re-inserting it back
p43014
aVConsider this example class:
p43015
aVIf you make a tree set like this
p43016
aVand then decide to change student's name when it's already in the set, you should do it like this:
p43017
aVAs you can see, this is not pretty at all
p43018
aVThat's why as a general rule you should prefer immutable keys for your maps, both hash-based and tree-based
p43019
as(dp43020
g6
V335858
p43021
stp43022
a((dp43023
g2
(lp43024
Vit's my understanding that [using bit fields] will introduce padding into the 32 bit array
p43025
aVUsing bit fields will not introduce padding, unless you explicitly request it: language standard prohibits the compier from padding in between bit fields:
p43026
aVC99 Standard, section 6
p43027
ag838
ag839
ag1340
aV10: If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit
p43028
aVIf insufficient space remains, whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is implementation-defined
p43029
aVThe order of allocation of bit-fields within a unit (high-order to low-order or low-order to high-order) is implementation-defined
p43030
aVYou can force padding to happen by specifying a bit field of zero width, like this:
p43031
aVIn your case, sufficient space remains after the first 12 bits to allocate the next four, so there will be no padding
p43032
aVIf you needed to split the register differently (say, 12-5-7-8), the use of padding would be implementation-defined
p43033
as(dp43034
g6
V335858
p43035
stp43036
a((dp43037
g2
(lp43038
VThe error happens because you override  without overriding
p43039
aVThese two must be overriden together, otherwise  will not work
p43040
aVAdd this code to your class to fix the issue:
p43041
as(dp43042
g6
V335858
p43043
stp43044
a((dp43045
g2
(lp43046
VIn general, when you have a 2D array, you nearly certainly need two nested loops (there are exceptions to this rule, but they are few and far between)
p43047
as(dp43048
g6
V335858
p43049
stp43050
a((dp43051
g2
(lp43052
VYou can use the Monte Carlo Method to estimate the difficulty of a word:
p43053
aVSimulate a game by guessing a random letter each time, weighted by letter's frequency in your target language, and count how many guesses it took your randomized player to arrive at a solution
p43054
aVNote that since each guess eliminates a letter, this process is finite, and it returns a number from 1 to 26, inclusive
p43055
aVRepeat this process  times, where  is the number of unique letters in your word,
p43056
aVCalculate the score by averaging the results of  runs,
p43057
aVDetermine the complexity level: scores less than ten indicate an easy word, and scores above sixteen indicate a hard word; everything else is medium
p43058
as(dp43059
g6
V335858
p43060
stp43061
a((dp43062
g2
(lp43063
VI know this because of what "debug statements" are output"
p43064
aVThe code that you posted looks fine
p43065
aVSince your output statements do not have  at the end, some of the output may still be buffered at the time of segfault
p43066
aVWriting out  blocks until the output is flushed, so adding  is likely to help you get closer to the actual location of the crash
p43067
as(dp43068
g6
V335858
p43069
stp43070
a((dp43071
g2
(lp43072
VYou can compose filters by calling other filters from your current one, like this:
p43073
aVThis prints
p43074
aVDemo on ideone
p43075
aVYou can use the same approach for any predicate-based functions of LINQ, including :
p43076
as(dp43077
g6
V335858
p43078
stp43079
a((dp43080
g2
(lp43081
VThe return statement should return , not
p43082
aVYou also need to select the value, otherwise you get a :
p43083
as(dp43084
g6
V335858
p43085
stp43086
a((dp43087
g2
(lp43088
VThe first solution is better, because it automatically guards you from creating events with zero supervisors and/or events with multiple supervisors: when an event's  column is non-nullable, your RDBMS ensures that there is precisely one supervisor for each event
p43089
aVIf you need to get your results in the form of a table with a  indicator marking the supervisor, you can always get that result by joining to , and comparing  to
p43090
as(dp43091
g6
V335858
p43092
stp43093
a((dp43094
g2
(lp43095
VYes, both are undefined behavior: in the first case,  is undefined; in the second case,  becomes undefined when it is decremented after the iteration when it is equal to
p43096
aVThis is covered by section 6
p43097
ag10442
aV6 of the standard, part 8 (emphasis is mine):
p43098
aVWhen an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand
p43099
aVIf the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression
p43100
aVIn other words, if the expression  points to the i-th element of an array object, the expressions  (equivalently, ) and  (where  has the value ) point to, respectively, the -th and -th elements of the array object, provided they exist
p43101
aVMoreover, if the expression  points to the last element of an array object, the expression  points one past the last element of the array object, and if the expression  points one past the last element of an array object, the expression  points to the last element of the array object
p43102
aVIf both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined
p43103
aVIf the result points one past the last element of the array object, it shall not be used as the operand of a unary  operator that is evaluated
p43104
aVThe standard goes length to cover the element at the position one past the last element of the array object, while the element at the position one prior the first element falls under the "otherwise" clause of the above rule
p43105
as(dp43106
g6
V335858
p43107
stp43108
a((dp43109
g2
(lp43110
VWith JUnit 4
p43111
aV0+ you can use parameterized tests:
p43112
aVAdd  annotation to your test fixture
p43113
aVCreate a  method returning , annotate it with , and put , , , etc
p43114
aVinto that collection
p43115
aVAdd a constructor to your test fixture that takes : , and store the  in an instance variable
p43116
aVIn the setUp method or @Before, use
p43117
aVWith the above setup in place, the parameterized runner will make a new instance of your test fixture  for each subclass that you provide in the  method, letting you exercise the same test logic for every subclass that you need to test
p43118
as(dp43119
g6
V335858
p43120
stp43121
a((dp43122
g2
(lp43123
VThis should work:
p43124
as(dp43125
g6
V335858
p43126
stp43127
a((dp43128
g2
(lp43129
Veverytime I type this: Node
p43130
aVa_v It gives me that error
p43131
aVis a type; types define the structure of a objects, but they do not have fields of their own (except the  fields, which belong to all instances at once; they are accessed differently anyway)
p43132
aVIn order to use a  or  operator, you need an instance of a , like this:
p43133
aVIt is not clear in your case from where the  instances should be coming, though
p43134
aVIn order to access them, you would need to either pass them in as parameters, or make them available statically/globally (not recommended)
p43135
as(dp43136
g6
V335858
p43137
stp43138
a((dp43139
g2
(lp43140
VIt is not working because  is integer: when you divide  or , you get a zero in both cases, because when  is positive, denominator is greater than numerator
p43141
aVZero minus zero is zero,  times zero is zero, so that's what you get
p43142
aVTo fix this problem, declare  as :
p43143
as(dp43144
g6
V335858
p43145
stp43146
a((dp43147
g2
(lp43148
VI know that I get warnings, but the programs runs perfectly
p43149
aVThat is an unfortunate legacy of pre-ANSI C: the language did not require function prototypes, so the standard C allows it to this day (usually, a warning can be produced to find functions called without a prototype)
p43150
aVWhen you call a function with no prototype, C compiler makes assumptions about the function being called:
p43151
aVFunction's return type is assumed to be
p43152
aVAll parameters are assumed to be declared (i
p43153
ag630
aVno  vararg stuff)
p43154
aVAll parameters are assumed to be whatever you pass after default promotions, and so on
p43155
aVIf the function being called with no prototype fits these assumptions, your program will run correctly; otherwise, it's undefined behavior
p43156
as(dp43157
g6
V335858
p43158
stp43159
a((dp43160
g2
(lp43161
VAlthough there are no off-the-shelf collections like that, you can easily emulate them using a  and a custom , like this:
p43162
aVWith this equality comparer in hand, you can do this:
p43163
aVIf you need to have a certain capacity and a specific number of dimensions, you can modify the  to be more strict at validating the data
p43164
aVIf you knew the number of dimensions at compile-time, you could use one of the  classes instead of arrays for potentially better performance
p43165
aVYou could also define extension methods on multi-dimensional, say, , arrays, to take vectors of indexes
p43166
aVNeither of these two approaches offers the same flexibility, though (which is a common trade-off -- better performance can often be gained by reducing flexibility)
p43167
aVEDIT: If you need to pre-allocate the storage and avoid storing your indexes, you could implement a multi-dimensional array yourself - like this:
p43168
aVThis is a straightforward implementation of row-major indexing scheme that uses generics
p43169
as(dp43170
g6
V335858
p43171
stp43172
a((dp43173
g2
(lp43174
VWhat goes in triangular brackets must be a type or a compile-time constant; it cannot be a variable
p43175
aVAlthough 's type is ,  itself is an object of type ; it cannot go in triangular brackets as one of template parameters
p43176
aVIn addition, you cannot use  as a second type parameter of your template function:  is a type which becomes fully known once you know
p43177
aVSince you already have  as your template parameter, you can declare  "for free" inside your function without an additional template parameter
p43178
aVFinally, in C++11 you can get a type of a variable statically using
p43179
aVFor example, if you modify your code to take a single type parameter of , you could do this:
p43180
aVDemo on ideone
p43181
as(dp43182
g6
V335858
p43183
stp43184
a((dp43185
g2
(lp43186
VYou cannot avoid rehashing: the position of the bucket where an element ends up inside your hash table depends on two or three things, depending on your collision resolution strategy:
p43187
aVThe hash code of the element,
p43188
aVThe size of the table, and
p43189
aVWhen you use linear probing, it's also the presence or absence of prior elements with hash codes that put them in the same bucket
p43190
aVIf you change any of these three factors, you need a full rehash: unless you do something really bad, such as picking a non-prime table size, the value of the  exression that determines the position is going to be different when you change the
p43191
aVThe presence or absence of elements that hash to the same bucket in linear probing is going to change as well
p43192
aVThat is why you need a full rehash
p43193
as(dp43194
g6
V335858
p43195
stp43196
a((dp43197
g2
(lp43198
VNo, it does not mean setting the memory to any particular value+
p43199
aVThe memory simply gets back into the heap of values that can be reused
p43200
aVThe runtime often use several bytes of the returned chunk to store "bookkeeping" information, but they do not set the entire chunk to a particular value
p43201
aVOnce a memory chunk is reused, it is your program that sets its new values
p43202
aV+ There are memory profiling tools that let you set released memory to some "junk" values to make sure that you get a crash faster
p43203
as(dp43204
g6
V335858
p43205
stp43206
a((dp43207
g2
(lp43208
VYour class is almost certainly included in a namespace
p43209
aVIn this case you need to qualify the name of the type with its namespace:
p43210
as(dp43211
g6
V335858
p43212
stp43213
a((dp43214
g2
(lp43215
VState refers collectively to the data stored in the object that determines the current properties of the object
p43216
aVFor example, if you have a  object, the owner of the account and the amount of money in it represent the state of the account
p43217
aVHowever, not all state is bad for functional programming, only the mutable+ one is not acceptable
p43218
aVFor example, the characters of which a string is composed is that string's state
p43219
aVIf you cannot change the content of the string, it is said to have an immutable state
p43220
aVThis fits well with functional programming paradigm
p43221
aV+ mutable is a fancy word for "changeable"
p43222
as(dp43223
g6
V335858
p43224
stp43225
a((dp43226
g2
(lp43227
VYou can unify all your "print three items" functions by writing a single one that takes a template string an an array, and prints the content using , like this:
p43228
aVNow you can replace a call of  with a call of
p43229
aVa call of  with
p43230
aVand so on
p43231
aVYou could also put your six arrays into an array of arrays, and address them with an index instead of their name
p43232
aVThis would let you avoid writing repeated code that changes only the name of the array
p43233
as(dp43234
g6
V335858
p43235
stp43236
a((dp43237
g2
(lp43238
VNo, you cannot do what you did: when you declare an array of type , only objects of type  or types derived from it through inheritance can be array elements
p43239
aVThe reason this works with  array is that  is the base class of every Java object
p43240
aVobjects can be converted to type , but they cannot be converted to an unrelated type
p43241
as(dp43242
g6
V335858
p43243
stp43244
a((dp43245
g2
(lp43246
VBug is a programming error - not checking array bounds, ignoring error codes, multiple deletions, memory leaks, etc
p43247
aVfall under this general category
p43248
aVErrors like this require code changes to fix (there may be work-arounds that do not require code changes, though)
p43249
aVFailure is a system error - disconnection of storage, lack of network connectivity, and hardware failures are in this category
p43250
aVFixing failures usually requires configuring other parts of the system, not the program itself
p43251
aVUser errors are mistakes made by users - entering values incorrectly or providing incomplete data are in this category
p43252
aVErrors like that are fixed by the user who uses the program without anyone else's involvement
p43253
as(dp43254
g6
V335858
p43255
stp43256
a((dp43257
g2
(lp43258
VThe second code block is only marginally more efficient, but it is incorrect: consider what happens if one or both vectors are empty
p43259
aVThe only saving here comes from avoiding a call overhead and a loop setup overhead when the strings differ in the first character
p43260
aVThese savings are not worth complicating your program, because they are too small
p43261
aVIf you would like to make your savings more substantial, consider replacing strings with custom classes that implement equality differently: for example, you could pre-compute and store a hash code of your vector, and use element-by-element comparisons only when hash codes are different
p43262
as(dp43263
g6
V335858
p43264
stp43265
a((dp43266
g2
(lp43267
VGenerate a random  in the range , and then do this:
p43268
as(dp43269
g6
V335858
p43270
stp43271
a((dp43272
g2
(lp43273
VYou should not include  and
p43274
aVInstead, you should write  and , and include it:
p43275
aVtest
p43276
ag1177
aVdate
p43277
ag1177
aVmain
p43278
aVcpp
p43279
as(dp43280
g6
V335858
p43281
stp43282
a((dp43283
g2
(lp43284
VThe closest function that does the same thing in Cocoa is 's
p43285
aVUsing :
p43286
aVUsing
p43287
aVNote that  supports printing of Cocoa objects with  format specifier
p43288
as(dp43289
g6
V335858
p43290
stp43291
a((dp43292
g2
(lp43293
VYou can translate your code like this:
p43294
aVJava's  becomes C#'s indexer, so
p43295
aVbecomes
p43296
as(dp43297
g6
V335858
p43298
stp43299
a((dp43300
g2
(lp43301
VThis is not a problem of the scanner, it's a limitation on Java's
p43302
aVBeing a 32-bit number, it does not accept values beyond it's maximum value of
p43303
aVIf you need to have 12 digits, use  instead
p43304
aVIt is a 64-bit number with the upper limit of
p43305
aVUsing a string and validating it to contain only digits may be another acceptable solution for reading and storing card numbers: it works even for 12-digit card numbers that have leading zeros (neither  nor  would preserve leading zeros in your numbers)
p43306
as(dp43307
g6
V335858
p43308
stp43309
a((dp43310
g2
(lp43311
VYou can try modifying the middle part of your expression to use  negative lookahead for matches of the dot  character, like this:
p43312
aVThe  anywhere in an expression says "match a single dot only when the symbol that follows is not a dot"
p43313
aVThe symbol that follows does not get consumed in the process of checking the lookahead
p43314
aVIf you want to prevent dots in the e-mail's initial part as well, modify the part before  in the same way as the middle part:
p43315
as(dp43316
g6
V335858
p43317
stp43318
a((dp43319
g2
(lp43320
VThe variable  is an array, not a pointer
p43321
aVPointer arithmetic operations are defined for pointers, but not for arrays
p43322
aVA name of an array can be used to produce a pointer - for example, in expressions like , but that does not mean that an array itself can be used as a pointer
p43323
aVIn particular, array is not a modifiable , which is a fancy way of saying that you cannot reassign the array itself (although you can assign array's value)
p43324
as(dp43325
g6
V335858
p43326
stp43327
a((dp43328
g2
(lp43329
VThe compiler is right: although  can be used to point to things, it is not an object a pointer to which is expected by the  function
p43330
aVThe reason the function wants a pointer to a pointer is that it wants to modify pointer's content by an assignment of this sort:
p43331
aVIf compiler let you pass a pointer to , this assignment would be invalid
p43332
aVThat's why you need to create a temporary "naked" pointer, pass it to the function, and then assign the result back to
p43333
as(dp43334
g6
V335858
p43335
stp43336
a((dp43337
g2
(lp43338
VWhen you insert in the middle of the array, you need to implement this algorithm:
p43339
aVCheck if you have enough space for the element that you want to insert
p43340
aVIf you do not have enough space, extend the array the way that you do when you add an element at the end
p43341
aVMove the data up by one position using
p43342
aVPlace the element at the position requested by the caller
p43343
aVThe only step that's different from inserting at the end is the third one, where you move the content of your array up by one element
p43344
aVfunction deals with this correctly even when the two areas overlap
p43345
aVEDIT: The  call should look like this:
p43346
aVA few additional notes:
p43347
aVGrowing the array to twice the size is not going to work after freeing the array, because you set the size to zero
p43348
aVUnlike C++ where a cast of  is required, C does not require you to cast the return value of //
p43349
as(dp43350
g6
V335858
p43351
stp43352
a((dp43353
g2
(lp43354
VHere is an explanation of your expression:
p43355
aVThe only part that you got wrong was the  sub-expression: the  character at the beginning alters its meaning to be "exclusive of" rather than "inclusive of" the rest of the characters of the character class
p43356
aVIf you would like to match an empty pair of parentheses, replace the last  with  to change the meaning from "one or more" to "any number, inclusive of zero"
p43357
as(dp43358
g6
V335858
p43359
stp43360
a((dp43361
g2
(lp43362
VThe reason this does not work is that  cannot be represented precisely in a , because its fractional part is not an exact sum of negative powers of two
p43363
aVIf you try it with a different number, say, , the code will work, because  is
p43364
as(dp43365
g6
V335858
p43366
stp43367
a((dp43368
g2
(lp43369
VNo and yes
p43370
aVNo, because you cannot access variables in a running process directly
p43371
aVHowever, you can make your program listen on a port or use another way of interprocess communication, wait for connections from other processes, and change the variable in accordance to the message it receives
p43372
as(dp43373
g6
V335858
p43374
stp43375
a((dp43376
g2
(lp43377
VYou need to use  to create instances of arrays:
p43378
as(dp43379
g6
V335858
p43380
stp43381
a((dp43382
g2
(lp43383
VBrute-force algorithms try every candidate solution that could be tried, see which one fits, and return its findings as the answer
p43384
aVFor example, a brute-force GCD algorithm would start with the smaller of the two numbers, and continue down to , examining every single possibility, one by one, on its way down
p43385
aVIn contrast, Euclidean algorithm does not go one by one: it makes jumps, sometimes pretty significant ones
p43386
aVMoreover, it does not check each possible number to be a solution to the GCD problem at each step: its ending condition is rather different from a typical brute-force solution, which is to check if the current candidate is a solution to the problem, and stop when the answer is "yes"
p43387
aVEuclidean algorithm checks a different condition, namely, , to decide on whether to continue or not
p43388
aVThese two distinctions (large steps and a different stopping condition) make the Euclidean algorithm different from brute-force algorithms
p43389
as(dp43390
g6
V335858
p43391
stp43392
a((dp43393
g2
(lp43394
VRecall that the outer loop iterates , the "intermediate" vertex though which the candidate path from  to  could go:
p43395
aVTherefore, after 0 iterations of the outer loop the partial solution (which at this point is equivalent to the unmodified adjacency matrix) represents a subset of the final solution where all shortest paths that go directly from  to  are represented
p43396
aVAfter one iteration, the shortest paths that go through the first vertex (at index ) are added to the mix
p43397
aVAfter  iterations, the partial solution contains shortest paths that are either (1) direct, or (2) go through one or more vertexes from the set of , inclusive
p43398
aVOf course once  reaches , the solution is complete
p43399
as(dp43400
g6
V335858
p43401
stp43402
a((dp43403
g2
(lp43404
VRecall that deleting  is allowed
p43405
aVTherefore, when you do this
p43406
aVyou throw away the old value of  (thus creating a memory leak), and then call , which is ignored
p43407
aVWhen you do this, however
p43408
aVyou use the old value first (to de-allocate the ), and only then zero it out
p43409
aVThis makes sense, because the old value of  becomes both useless and dangerous as soon as  is executed
p43410
as(dp43411
g6
V335858
p43412
stp43413
a((dp43414
g2
(lp43415
VWhen you use , the output is already buffered
p43416
aVThe system call is made only when you "flush" the buffer - either explicitly by calling  or implicitly by printing  to a console
p43417
aVTherefore, pre-buffering on the application side will make your code more complex without offering any real difference in performance
p43418
aVAs far as a library to help you write s to a string goes, you can use the same  that you are already using: allocate a buffer sufficiently large to hold your integers, use  instead of  to write to it, and then call  with the content of the entire buffer
p43419
aVThis would help you avoid flushing on , should you decide to use them as separators in your output
p43420
as(dp43421
g6
V335858
p43422
stp43423
a((dp43424
g2
(lp43425
VArity is a fancy way of saying "the number of parameters"
p43426
aVThat's the root of words "binary" (taking two parameters), "unary" (taking one parameter), and "ternary" (taking three parameters)
p43427
aVNo, not quite: LINQ is rooted in functional programming, and functional programming hates all state, preferring functions with no side effects
p43428
aVUnfortunately, your counter keeps state: that's the  dictionary that you modify, which is a side effect
p43429
aVIf you want to count things by key, LINQ already offers you adequate facilities to do so
p43430
aVHere is how you can get item counts by key:
p43431
as(dp43432
g6
V335858
p43433
stp43434
a((dp43435
g2
(lp43436
VYou are declaring a dictionary to use  keys, but you are trying to access it with  instead
p43437
aVYou need to decide on one type, and stay with it
p43438
aVSince  is asymmetric, I would use :
p43439
aVThen your assignment would work correctly:
p43440
as(dp43441
g6
V335858
p43442
stp43443
a((dp43444
g2
(lp43445
VYou need to change  to :
p43446
aVOtherwise, the string becomes valid when it is
p43447
as(dp43448
g6
V335858
p43449
stp43450
a((dp43451
g2
(lp43452
VNo, there is no special significance: these are regular identifiers
p43453
aVMy guess as to why the authors decided to add underscores like that is to make the composition of these attributes more legible:
p43454
aVis easier to read than
p43455
aVThe , however, looks suspicious: in C, identifiers that start in an underscore followed by an uppercase letter or another underscore, are reserved for the implementation
p43456
aVIn this case, it's two underscores, so I would expect  to be a system macro
p43457
as(dp43458
g6
V335858
p43459
stp43460
a((dp43461
g2
(lp43462
VWhen regular expression engines use backtracking a lot, the process of matching becomes very slow
p43463
aVBacktracking happens a lot when you let different parts of your expression match overlapping parts of your input, especially when there is no match: the engine tries different possibilities of splitting up the input among the portions of your regular expression
p43464
aVConsider this simple example from your regex: let's use  to match  Note that there are two sub-expressions that can cover all characters starting with the second one: the engine must consider all these possibilities:
p43465
aVGiven that there is no match, that's ten useless repetitions right there
p43466
aVBut that's not the end of it
p43467
aVWhen there are other sub-expressions in the mix that could produce ambiguous coverage, these ten possible matches will be tried for each of the possible matches further on in the string
p43468
aVTo say that the effects of backtracking add up quickly would be an understatement: they multiply in geometric progression, eventually consuming a lot of your CPU
p43469
aVThe moral of this story is to try and reduce the amount of backtracking
p43470
aVFor example, your second expression
p43471
aVcan be rewritten like this:
p43472
aVThe two expressions will match the same set of inputs, but when there is a match, the second expression will have a unique match, while the original expression would have roughly  different ways of splitting the matched string among the three sub-expressions that match word characters
p43473
aVHere is some more reading on a related subject: Performance of Greedy vs
p43474
aVLazy Quantifiers
p43475
as(dp43476
g6
V335858
p43477
stp43478
a((dp43479
g2
(lp43480
VYou should modify the reading code as follows:
p43481
aVnames" is a character array
p43482
aVIt can hold a string
p43483
aVWhen calling scanf, you do not need to use an ampersand, because arrays "decay" to pointers when passed to functions
p43484
aVAdding a subscript [a] was a mistake, too
p43485
aVSame applies to printing as well
p43486
aVSeparately note the format string in scanf: I added 19 to avoid overflowing the 20-character buffer (you need an extra character for null termination)
p43487
as(dp43488
g6
V335858
p43489
stp43490
a((dp43491
g2
(lp43492
VYes, you can do the replacement
p43493
aVThe structure of your current expression looks like this:
p43494
aVthe structure of the new expression will look like this:
p43495
aVYou will need to provide  for the  to the  expression
p43496
aVThe last expression in the block (i
p43497
ag630
aV) will be considered block's return expression
p43498
as(dp43499
g6
V335858
p43500
stp43501
a((dp43502
g2
(lp43503
VTry using positive look-behind, a regex construct that does not capture its input:
p43504
aVThe  construct matches at the point right after , without capturing the  itself, letting you split the text at positions that follow the separator
p43505
aVHere is a demo on ideone
p43506
as(dp43507
g6
V335858
p43508
stp43509
a((dp43510
g2
(lp43511
VYou should not decide on placement of variables based solely on the need to share some code or some variables
p43512
aVIf your abstract class is designed with the idea that everything extending it must have access to , then you put  in the base class
p43513
aVOn the other hand, if some of the intended implementations would have nothing to do with the database, then you should not add  to the abstract base class
p43514
aVOf course you are not limited to just two levels of the inheritance hierarchy: you can always start with  that does not have , and add another level of abstract classes for everything that does need a database:
p43515
as(dp43516
g6
V335858
p43517
stp43518
a((dp43519
g2
(lp43520
VYou cannot tell if a pointer is on the automatic store, in static memory, or in dynamic memory simply by looking at the pointer
p43521
aVYou need to store a flag at the time when you set that pointer - for example, like this:
p43522
as(dp43523
g6
V335858
p43524
stp43525
a((dp43526
g2
(lp43527
VYou need to specify that  belongs to
p43528
aVOtherwise, C++ thinks that this is a free-standing function (despite the fact that you have declared a member function with the same name inside )
p43529
aVYou also need to move the two definitions
p43530
aVfrom the header file to the implementation file
p43531
as(dp43532
g6
V335858
p43533
stp43534
a((dp43535
g2
(lp43536
VOne way or the other, you would need to add a special case to cover , because it is, well, special
p43537
aVFor example, you can rewrite your second solution like this:
p43538
as(dp43539
g6
V335858
p43540
stp43541
a((dp43542
g2
(lp43543
VThis expression works as follows:
p43544
aVEvaluates
p43545
aVCompares the result to zero
p43546
aVIf the result is zero,  is set to ; otherwise, it is set to
p43547
aVThis could also be done with the equivalent expression that uses property syntax:
p43548
aVFinally, you can drop the  variable altogether:
p43549
as(dp43550
g6
V335858
p43551
stp43552
a((dp43553
g2
(lp43554
VThis line
p43555
aVshould be
p43556
aVYour current code iterates the array of weights, and tries to use the weight as an index into the array of weights, causing an index out of range exception
p43557
aVAnother problem is with the first loop: you are setting all values of  to the same number:
p43558
aVIf weights are to be different, they should come from different weight boxes, or the string from a single  should be processed in such a way as to produce multiple numbers (for example, by using )
p43559
as(dp43560
g6
V335858
p43561
stp43562
a((dp43563
g2
(lp43564
VUnlike desktop operating systems which support dynamic libraries, iOS supports only static libraries
p43565
aVThe only way around this would be building two targets - one that uses the library, and the other one that does not
p43566
aVYou can build both targets from the same set of sources by using conditional compilation
p43567
aVIn the version that conditionally compiles out the references to the "big library" there would be no references to it, so the linker would not complain about missing references
p43568
as(dp43569
g6
V335858
p43570
stp43571
a((dp43572
g2
(lp43573
VYou can swap s the same way that you swap integers:
p43574
aVDemo on ideone
p43575
as(dp43576
g6
V335858
p43577
stp43578
a((dp43579
g2
(lp43580
VTry adding this code after obtaining the  dictionary:
p43581
aVThis should let you pull the information from the  and  into separate variables
p43582
as(dp43583
g6
V335858
p43584
stp43585
a((dp43586
g2
(lp43587
VThe difference is in the type of the pointer that you get:
p43588
aVArray name  by itself represents a pointer to the initial element of the array
p43589
aVWhen interpreted in that way, e
p43590
ag303
aVin an expression , the pointer is considered to point to a single character
p43591
aVWhen you take , on the other hand, the pointer points to an array of five characters
p43592
aVWhen you add an integer to a pointer, the number of bytes the pointer is moved is determined by the type of the object pointer to by the pointer
p43593
aVIn case the pointer points to , adding  advances the pointer by  bytes
p43594
aVIn case the pointer points to an array of five s, adding  advances the pointer by  bytes
p43595
aVThat's precisely the difference that you are getting: your first example advances the pointer to the element one past the end of the array (which is legal), and then move it back to the last element
p43596
aVYour second example, on the other hand, advances the pointer to the second element, and then moves it back to point to the initial element of the array
p43597
as(dp43598
g6
V335858
p43599
stp43600
a((dp43601
g2
(lp43602
VSince the items are supplied to your URL-processing delegate in parallel, it may "see" your list indexes out of sequence, i
p43603
ag630
aVitems will higher indexes would be supplied for processing ahead of items with lower indexes
p43604
aVThis is usually not what you want for your  messages
p43605
aVOne way to fix this would be using  on a counter that you set up separately from the  mechanism:
p43606
as(dp43607
g6
V335858
p43608
stp43609
a((dp43610
g2
(lp43611
VSince  goes up to ,  is out of bound
p43612
aVYou need to change it to
p43613
aVDoing so would make sure that  is within bounds
p43614
as(dp43615
g6
V335858
p43616
stp43617
a((dp43618
g2
(lp43619
VThis is because you've got two opening curly braces:
p43620
aVyou need to remove one of them in order for this to compile
p43621
as(dp43622
g6
V335858
p43623
stp43624
a((dp43625
g2
(lp43626
VYou need a  to get the counts that you need
p43627
aVYou also need to apply an aggregate function to , otherwise it is not clear which date to pick:
p43628
aVI picked  to produce the date of last consumption; if you need a different date from , change the aggregating function
p43629
aVI am not sure if sqlite lets you sort by alias; if it does not, replace
p43630
aVwith
p43631
as(dp43632
g6
V335858
p43633
stp43634
a((dp43635
g2
(lp43636
VSince the string ends in a colon, it is easy to use  and  to separate out parts of the string partitioned by , like this:
p43637
aVThis splits the original string into parts
p43638
aVand
p43639
aVSince s take leading plus as well as leading minus, you can parse out the numbers using  operator:
p43640
aVWith these two parts in hand, you can easily total up the individual numbers, and produce the desired output
p43641
aVHere is a quick demo
p43642
as(dp43643
g6
V335858
p43644
stp43645
a((dp43646
g2
(lp43647
VYou can speed up the process by filtering out the words that clearly do not belong, i
p43648
ag630
aVthe words that have letters not found in the phrase
p43649
aVOnce you pre-filter the 1M list, you should end up with much shorter sub-list
p43650
aVRunning your algorithm on that sub-list should be significantly faster, since it's an  algorithm: even if you narrow down the list to ten percent of the words (I expect you to get much fewer words than that) you'd get a 100-fold improvement
p43651
aVIt is OK for list to have "false positives", as long as potential matches are not thrown away
p43652
aVHere is how you can do the pre-filtering: for each word, build its "signature", a 26-bit number with a bit set for each letter present in the word at least once (letters are numbered 0 through 25, ignoring the case)
p43653
aVFor example, the word  would have a signature with bits 4, 13, 16, and 20 set to one
p43654
aVNow construct a signature for your three-word phrase, and use it to filter the list of 1M words: if a bitwise  of the word's signature and the phrase's signature equals the phrase's signature, keep the word; otherwise, throw it away
p43655
aVYour filtered list should be much shorter, so your  algorithm should run much faster
p43656
as(dp43657
g6
V335858
p43658
stp43659
a((dp43660
g2
(lp43661
VProtected is not instance-by-instance access control, it's a class-by-class access control
p43662
aV(which is not in any class) cannot call private or protected methods of any class at all; hence it fails to call
p43663
aVThe implementation of , on the other hand, is inside the class , so it can call its private and protected methods, both on itself and on other instances of the class
p43664
as(dp43665
g6
V335858
p43666
stp43667
a((dp43668
g2
(lp43669
VYou do not need to nullify local variables when you are done with them: Java compiler is smart enough to figure out when to discard the object
p43670
aVClass member variables, on the other hand, need to be considered differently: if a collection holds objects inside another object, it may make sense to clear out the collection once you are done with it
p43671
aVThis is important only when the lifetime of the outer object is significantly longer than the lifetime of the objects inside its collections
p43672
aVOtherwise, garbage collector will deal with collecting the objects without any help from your code
p43673
as(dp43674
g6
V335858
p43675
stp43676
a((dp43677
g2
(lp43678
VThis is because the attributes are not  in your class:
p43679
aVFrom the documentation of  (emphasis is mine):
p43680
aVYou can assign the XmlAttributeAttribute only to public fields or public properties that return a value (or array of values) that can be mapped to one of the XML Schema definition language (XSD) simple types (including all built-in datatypes derived from the XSD anySimpleType type)
p43681
as(dp43682
g6
V335858
p43683
stp43684
a((dp43685
g2
(lp43686
VHere is one way to do it:
p43687
aVEach element of the array returned by  corresponds to a data member
p43688
aVIn addition to getting the count, you can further examine each field - get its name, check its type and so on
p43689
aVYou can also use  objects to get and/or set fields of your target class
p43690
aVDemo on ideone
p43691
as(dp43692
g6
V335858
p43693
stp43694
a((dp43695
g2
(lp43696
VYou can use , like this:
p43697
aVHere is a demo on ideone
p43698
as(dp43699
g6
V335858
p43700
stp43701
a((dp43702
g2
(lp43703
V does not modify its first argument (recall that strings are immutable in
p43704
aVNET) so the call
p43705
aVleaves the  string unchanged
p43706
aVYou need to call it like this:
p43707
aVAll three of your regular expressions would have worked
p43708
aVHowever, the first regex would remove all plus characters as well, which I imagine would be unintentional
p43709
as(dp43710
g6
V335858
p43711
stp43712
a((dp43713
g2
(lp43714
VThe answer depends on the declaration of the property: for example, if  is declared as , these two operations are very different: assignment through a property would make a copy, while assigning to variable directly would not copy
p43715
aVIf the property is  and , though, the action they perform would be the same
p43716
as(dp43717
g6
V335858
p43718
stp43719
a((dp43720
g2
(lp43721
VThe reason behind it is that in order to determine a value produced by a function one needs to execute code, and that there is no code execution done in C when initializing static and global variables
p43722
aVCompiler and linker work together to prepare a byte image of the global memory segment: the compiler provides the values, and the linker performs their final layout
p43723
aVAt runtime, the image of the segment is loaded in memory as is, without further modifications
p43724
aVThis happens before any code gets executed, so no function calls can be made
p43725
aVNote that this does not mean that it is not possible for some technical reason, only that C designers decided against doing it
p43726
aVFor example, C++ compiler generates a code segment that calls constructors of global objects, which gets executed before the control is passed to main()
p43727
as(dp43728
g6
V335858
p43729
stp43730
a((dp43731
g2
(lp43732
VThis is a Prolog implementation of a common dynamic programming technique called memoization
p43733
aVAs you noted correctly, the idea is to calculate a value only the first time: the next time we need to calculate the same value, we retrieve its stored value instead
p43734
aVWhen your second program calls  with , the effect is the same as typing a new fact into Prolog database manually:
p43735
aVThe next time around when your program tries to get , it would be retrieved through the dynamically asserted fact, not through the rule
p43736
aVThis explains both the speedup, and the reason the call stack looks too shallow compared to a non-memoized version
p43737
as(dp43738
g6
V335858
p43739
stp43740
a((dp43741
g2
(lp43742
VReplace an array of arrays with an array of custom objects, like this:
p43743
as(dp43744
g6
V335858
p43745
stp43746
a((dp43747
g2
(lp43748
VThis is because the new syntax expects keys and values to be ordered in reverse, compared to :
p43749
aVAlso, do not forget the  sign in front of  literal
p43750
as(dp43751
g6
V335858
p43752
stp43753
a((dp43754
g2
(lp43755
V provides a pair of convenient functions called  and  which you can use for testing for all kinds of strings that look empty to end users:
p43756
aVThis would disable the button even for string composed entirely of blank characters, which makes sense when you validate a name
p43757
aVThe above is identical to
p43758
aVwhich shorter than a version with an
p43759
as(dp43760
g6
V335858
p43761
stp43762
a((dp43763
g2
(lp43764
VThere are multiple errors in your append function, the biggest ones are using an array as a pointer and using a static buffer to merge strings
p43765
aVWith a static buffer in place, all your merged strings will be in the same space, so merging two strings and then merging the other two would overwrite the results of the first merge
p43766
aVYou can change your function as follows:
p43767
aVOf course the caller is responsible for freeing the results of  now
p43768
as(dp43769
g6
V335858
p43770
stp43771
a((dp43772
g2
(lp43773
VIt does not matter which variable is declared first: if a class has a variable with the same name in it, that variable trumps the global variable
p43774
aVOtherwise you could get existing code in a lot of trouble simply by declaring a global variable with a name of one of its member variables
p43775
aVOf course your class can use scope resolution operator to reference the global  directly:
p43776
aVNow your program will print  instead of
p43777
as(dp43778
g6
V335858
p43779
stp43780
a((dp43781
g2
(lp43782
VIn the past (mid-nineties) some RDBMS engines had very poor implementations of , so a suggestion to switch to  and filter on the client very often paid off
p43783
aVThe performance of  has been optimized, however, so with the modern RDBMSs the decision has to be made case-by-case:
p43784
aVWhen you do a , the database must eliminate duplicates for you
p43785
aVIf the number of records returned from a query is small (say, a few hundred to a thousand) then it does not matter where to eliminate the duplicates, so you might as well do it on the RDBMS side
p43786
aVWhen the number of records gets into tens of thousands, you may be able to do elimination of duplicates in a way that is smarter than that of RDBMS by exploiting specific properties of your data
p43787
aVIn this case you would use
p43788
aVIf the number of rows is large and the share of duplicates is very large (say, you  from five tables, with 70% of rows being duplicates) it may be better to save on the network bandwidth and the client memory by having RDBMS eliminate duplicates, and reduce the size of data to be transfered back to you by 70%
p43789
aVTo summarize, there is no universal scenario
p43790
aVYou need to do some calculations and profile your queries before making a decision one way or the other
p43791
as(dp43792
g6
V335858
p43793
stp43794
a((dp43795
g2
(lp43796
VIn general, you want to avoid situations like that by using only the member functions declared  in the base
p43797
aVIf you must cast a pointer to a derived class, make sure that the base class has at least one  function (any function or a destructor would be enough), and then use :
p43798
aVIf  points to a , dynamic cast succeeds; otherwise, it fails, and returns a null pointer
p43799
aVYou may need to compile with special flags to enable RTTI support
p43800
as(dp43801
g6
V335858
p43802
stp43803
a((dp43804
g2
(lp43805
VYou need to change the signature of your method, otherwise the caller would not be able to tell when the string is "good" (i
p43806
ag630
aVcontains only digits)
p43807
aVOne way would be returning , a wrapper around the  primitive
p43808
aVInside, you can use a simple regex  to match the first non-digit in a
p43809
aVWhen there is no match, return
p43810
aVThis way the callers would be able to call your method like this:
p43811
as(dp43812
g6
V335858
p43813
stp43814
a((dp43815
g2
(lp43816
VCorrect, this is a warning to enforce best practices, which is to put all related clauses together in the source file
p43817
aVOther than that, the proximity of clauses to each other in the source file does not matter, as long as their relative order does not change
p43818
as(dp43819
g6
V335858
p43820
stp43821
a((dp43822
g2
(lp43823
VDeclarations are not executable code, they do not execute anything
p43824
aVThis is merely a convenient notation for inserting initialization of  to zero into every constructor that you define (or into an implicitly defined default constructor, if you do not define any constructors yourself)
p43825
as(dp43826
g6
V335858
p43827
stp43828
a((dp43829
g2
(lp43830
VWhen a parameter is declared as
p43831
aVit means that  is a reference
p43832
aVIn C++ you can pass parameters by reference, which allows the function modify the variable that you pass to it (among other things)
p43833
aVIf you have a pointer, but a function expects a reference, you need to dereference the pointer in the call with an asterisk, rather than taking the address of a pointer with an ampersand:
p43834
aVYou can think of variables, pointers, pointers to pointers, etc
p43835
aVin terms of level of indirection
p43836
aVVariables have a level of indirection of zero; pointers have level of indirection of one; pointers to pointers have level of indirection of two, and so on
p43837
aVAdding an ampersand increases the level of indirection; adding an asterisk decreases it
p43838
aVLike variables, references have level of indirection of zero
p43839
aVIf you have a pointer and you need a variable, you must decrease the level of indirection by prepending an asterisk
p43840
aVAnother problem in your code is that  expects references to , with a "w", but you are passing references to , with an "x"
p43841
aVThe types need to match, otherwise the compiler is not going to take your program
p43842
as(dp43843
g6
V335858
p43844
stp43845
a((dp43846
g2
(lp43847
VSince your code examines the next element, you need to stop when you are at the element one before last, like this:
p43848
aVThe only reason to have the first part of the condition is to trap empty lists
p43849
aVIn addition, you should not advance the pointer when you remove an element
p43850
aVOtherwise, you would not process runs of more than two elements correctly
p43851
as(dp43852
g6
V335858
p43853
stp43854
a((dp43855
g2
(lp43856
VWhen you create an array, you create only the containing structure
p43857
aVIts members are initializeded to their default values, which in case of  is
p43858
aVEssentially, you get seventy  references, each one capable of holding a list of
p43859
aVTo fix this, you should either assign new arrays in a loop
p43860
aVor use LINQ:
p43861
as(dp43862
g6
V335858
p43863
stp43864
a((dp43865
g2
(lp43866
VThe syntax for throwing an exception is very simple:
p43867
aVVery often one of the parameters includes a message explaining what went wrong
p43868
as(dp43869
g6
V335858
p43870
stp43871
a((dp43872
g2
(lp43873
V needs to be a variable, so its name must be without quotes, like this:
p43874
aVThis produces an empty list, because both  and  are in the larger list
p43875
aVIf you switch the lists around,  will be :
p43876
aVHere is a demo on ideone
p43877
as(dp43878
g6
V335858
p43879
stp43880
a((dp43881
g2
(lp43882
VYour second attempt is nearly right
p43883
aVThe only thing that's not quite correct is the way you instantiate a view controller from a storyboard: you use , which is what you use with NIBs but not with storyboards
p43884
aVFor storyboards, you need this:
p43885
aVSee this question for details
p43886
aVOnce you make the replacement, your code should work as expected
p43887
aVEDIT :: Here is how your method would look:
p43888
as(dp43889
g6
V335858
p43890
stp43891
a((dp43892
g2
(lp43893
VYou are passing an array of seven items, not a single number, to the
p43894
aVYou need to calculate the average, and then compare the result to the percentiles:
p43895
as(dp43896
g6
V335858
p43897
stp43898
a((dp43899
g2
(lp43900
VThe reason this does not work is that when compiling your , Java compiler cannot use its knowledge that  always throws an exception
p43901
aVThat's why it must behave as if there were paths to the  where  would remain unassigned
p43902
aVIt is important to understand why the compiler should not cross function boundaries in static code analysis
p43903
aVPretend that the compiler goes through your function , determines that it always throws, and lets your  compile
p43904
aVNext, you change  to throw conditionally, and try compiling again
p43905
aVNow your  fails to compile
p43906
aVThis violates the most basic principle of encapsulating functionality inside a method: suddenly, a change to method's implementation could break compilation of that method's callers
p43907
aVMoreover, every time you change anything, your entire project would need to be recompiled in its entirety, because any of its parts could potentially be dependent on a function that you have just changed
p43908
aVA language with compilation requirements like that would be unusable in practice
p43909
aVYou can fix this problem in several ways:
p43910
aVAssign  a default value, or
p43911
aVMake  return a new exception rather than throwing it, and use  to convince the compiler that the execution is terminating
p43912
aVHereis how to implement the second approach:
p43913
as(dp43914
g6
V335858
p43915
stp43916
a((dp43917
g2
(lp43918
V methods are
p43919
aVThe reason nothing happens is different from what you think: it's not because the method is , it's because the instance on which you call the method is wrong
p43920
aVYour  method creates a new instance of
p43921
aVThat's not the class that has the real  displayed on your screen
p43922
aVYou need to call the method on the same object that owns the label and runs the  method
p43923
aVIn Objective C this object is represented by a special variable called
p43924
aVIf you rewrite the method as follows
p43925
aVit should work
p43926
as(dp43927
g6
V335858
p43928
stp43929
a((dp43930
g2
(lp43931
VOf course you missed something: the assignment
p43932
aVclearly assigns  to
p43933
aVAfter that, you make assignments to , which causes
p43934
aVRewriting the above line as
p43935
aVshould fix the  problem
p43936
aVIt wouldn't fix the infinite loop problem - you need to adjust your  variable for that
p43937
aVCurrently,  does not change, so the loop is infinite
p43938
aVIt looks like your code is trying to parcel out a long array into 33-byte chunks
p43939
aVYou need to take special care of the case when  is not divisible by 33, because the loop condition requires  to be exactly  in order to exit
p43940
as(dp43941
g6
V335858
p43942
stp43943
a((dp43944
g2
(lp43945
VThe program can be built with a single built-in predicate,  and the standard recursion facilities of the language
p43946
aVYou need two rules - one to transform a list item-by-item to another list, and another one to total up the codes from which an atom is composed
p43947
aVEach rule would have two parts - one to process the base case (i
p43948
ag630
aVan empty list), and one to reduce the incoming list by one item
p43949
aVHere is a sample implementation with a demo on ideone:
p43950
aVIf you would like to use  and , built-in predicates for list processing, you can shorten your program like this:
p43951
aVLink to a demo on ideone
p43952
as(dp43953
g6
V335858
p43954
stp43955
a((dp43956
g2
(lp43957
VThe array is accessible, it's just that the index that you are trying to pass is beyond bounds, probably because the number is negative
p43958
aVThe index  looks like a negative 1 re-interpreted as a positive number
p43959
aVMake sure that  is between 0 and 35 before making a call to the  method
p43960
aVSince you use the  method to look for objects in , make sure that your objects properly implement the  method
p43961
aVOtherwise,  will not be able to find your custom objects, unless you pass the exact instance to it
p43962
as(dp43963
g6
V335858
p43964
stp43965
a((dp43966
g2
(lp43967
VIncreasing by ten percent means multiplying by , so all you need to do is a simple update:
p43968
aVLong explanation: recall that 10% means , or
p43969
aVExpanding  gives , or  in decimal notation
p43970
as(dp43971
g6
V335858
p43972
stp43973
a((dp43974
g2
(lp43975
VA typical "find and replace" loop looks like this:
p43976
aVSee comments in the code above to understand what is going on
p43977
as(dp43978
g6
V335858
p43979
stp43980
a((dp43981
g2
(lp43982
VBitwise  is different from logical  in that it performs s of individual bits, and does not short-circuit
p43983
aVIn contrast, the logical  always produces  or , and it stops evaluating its arguments as soon as it is clear what answer it is going to get (i
p43984
ag630
aVas soon as it finds the first non-zero argument in the chain of its arguments)
p43985
aVSpecifically for this case,  is binary , and  is binary , so -ing them together produces a binary , or decimal
p43986
aVIf you were using the logical  instead, you would simply get , because the very first argument, , is non-zero
p43987
as(dp43988
g6
V335858
p43989
stp43990
a((dp43991
g2
(lp43992
VNo, it is not possible: regular expression execution model is not powerful enough for that
p43993
aVIn order for a regular expression string to be valid, all parentheses in the string must be balanced
p43994
aVSince it is not theoretically possible to write a regular expression to verify if all parentheses in a string are balanced, it is also not possible to write a regular expression to check validity of a regular expression string
p43995
as(dp43996
g6
V335858
p43997
stp43998
a((dp43999
g2
(lp44000
VThink about it this way: you have as many binary patterns with the sign bit set to  as the number of binary patterns with the sign bit set to
p44001
aVHowever, you also need to represent zero, which is neither positive nor negative
p44002
aVSince zero is represented as a pattern of all zeros, it deducts from the set of positive numbers representable with the given number of bits, so the count of representable negative numbers is going to be greater by one
p44003
as(dp44004
g6
V335858
p44005
stp44006
a((dp44007
g2
(lp44008
VC defines operations of addition and subtraction of integers and pointers, collectively called pointer arithmetics
p44009
aVThe language specification says that adding  to a pointer is equivalent to advancing the pointer by  units of memory equal to the size of an object pointed to by the pointer
p44010
aVFor example, adding ten to an  pointer is the same as advancing it by ten sizes of ; adding ten to a  pointer is equivalent to advancing the pointer by ten sizes of , and so on
p44011
aVNext, the language defines array subscript operations in terms of pointer arithmetics: when you write , the language treats it as an equivalent of
p44012
aVAt this point, the language has everything necessary to pass arrays as pointers: take , pass it to the function, and let the function use array subscript operator on the pointer
p44013
aVThe effect is the same as if the array itself has been passed, except the size of the array is no longer available
p44014
aVThe structure of your API indirectly acknowledges that by passing the size of the array as a separate parameter
p44015
as(dp44016
g6
V335858
p44017
stp44018
a((dp44019
g2
(lp44020
VSQL Server provides a special merge command for situations like this
p44021
aVYou can use this simple approach:
p44022
aVWrite the content of the entire spreadsheet into a temporary table
p44023
aVExecute a merge of the employee table and the temporary table using SSN match as your merge search condition
p44024
aVUse  for changing the
p44025
aVUse  for adding new employees
p44026
aVUse  for all remaining updates
p44027
as(dp44028
g6
V335858
p44029
stp44030
a((dp44031
g2
(lp44032
VThe "ugly" and "do not use in production" comments refer to this specific use of anonymous classes, not to anonymous classes in general
p44033
aVThis specific use assigns  an anonymous subclass of , an entirely new class created with a single purpose in mind - namely, initializing a list with the content of two specific lists
p44034
aVThis is not very readable (even an experienced reader would spend a few seconds figuring it out), but more importantly, it can be achieved without subclassing in the same number of operations
p44035
aVEssentially, the solution pays for a small convenience with creating a new subclass, which may result in problems down the road, for example, in situations when you try to persist this collection using an automated framework that expects collections to have specific types
p44036
as(dp44037
g6
V335858
p44038
stp44039
a((dp44040
g2
(lp44041
VThe case statement looks redundant: since both sections and s are indexed starting with zero, the same can be achieved with
p44042
aVperhaps with some additional argument checking at the beginning to handle the default
p44043
as(dp44044
g6
V335858
p44045
stp44046
a((dp44047
g2
(lp44048
VHere is a solution that does not change the order of prefixes in the result
p44049
aVSince the elements are pre-sorted, you can take elements until you find a prefix that differs from the last taken element, and add new elements to the result, like this:
p44050
aVHere is a demo on ideone
p44051
as(dp44052
g6
V335858
p44053
stp44054
a((dp44055
g2
(lp44056
VIn this case, you need to return two things from a function, not one
p44057
aVA common way to do so is taking a pointer to the return value, and returning a yes/no flag to indicate the validity of the actual :
p44058
aVNow instead of doing this
p44059
aVthe users of your function would need to do this:
p44060
as(dp44061
g6
V335858
p44062
stp44063
a((dp44064
g2
(lp44065
VSince single quotes are not mandatory,  will not work, because Java's regex engine does not allow variable-length lookbehind expressions
p44066
aVHere is a simple solution that uses regex to match the content, not the delimiters:
p44067
aVDemo on ideone
p44068
aVYou can add syntax for escaping single quotes by altering the "content" portion of the quoted substring (currently, it's , meaning "anything except a single quote repeated zero or more times)
p44069
as(dp44070
g6
V335858
p44071
stp44072
a((dp44073
g2
(lp44074
VJava compiler takes this string  and replaces double slashes with single slashes, so the regexp engine sees this:
p44075
aVThis means a string that starts in a dollar sign  followed by a sequence of zero or more characters in curly braces
p44076
aVA better way to write a similar expression would be as follows:
p44077
aV(you would need to escape your backslashes for the Java compiler)
p44078
aVThis expression will stop after seeing the first closing curly brace, and avoid braktracking
p44079
as(dp44080
g6
V335858
p44081
stp44082
a((dp44083
g2
(lp44084
VYes, there is - assuming that all  implement a common interface  that provides  and , you can do this:
p44085
aVNow you can call this function as follows:
p44086
as(dp44087
g6
V335858
p44088
stp44089
a((dp44090
g2
(lp44091
VThis is a relatively simple  query:
p44092
aVThis would give you all pairs
p44093
aVTo project out the , nest this query inside a , like this:
p44094
aVIf you need only the total count of s with multiple units, replace  with
p44095
as(dp44096
g6
V335858
p44097
stp44098
a((dp44099
g2
(lp44100
VThe  branch should return , not :
p44101
as(dp44102
g6
V335858
p44103
stp44104
a((dp44105
g2
(lp44106
VNo, absolutely not: unlike Java or C# (
p44107
aVNET) , classes in C++ do not have a common root
p44108
aVNote: this does not apply to C++/CLI; however, it is a different language with the syntax loosely based on C++, so the "real" C++ has no "root" object
p44109
as(dp44110
g6
V335858
p44111
stp44112
a((dp44113
g2
(lp44114
VIn C (and by extension, in Objective C) it is allowed to declare local variables in the inner scope that would hide variables of the outer scope
p44115
aVYou can get rid of  and write this:
p44116
aVdemo
p44117
aVC# standard decided against that, probably because it has a high probability of being an error, but C/Objective C does not have a problem with it
p44118
as(dp44119
g6
V335858
p44120
stp44121
a((dp44122
g2
(lp44123
VThis is because you are missing an ampersand in front of :
p44124
aVexpects an address of the item where the value is to be stored, so you need to use the "take address" operator
p44125
as(dp44126
g6
V335858
p44127
stp44128
a((dp44129
g2
(lp44130
VIt will use the  of whatever type that is instantiated, like this:
p44131
as(dp44132
g6
V335858
p44133
stp44134
a((dp44135
g2
(lp44136
VYou need to calculate the correct index from both the  and the
p44137
aVSince you have two pairs of rows per section, you need to multiply  by two, and add , which will be either zero or one
p44138
aVThe end result should look like this:
p44139
as(dp44140
g6
V335858
p44141
stp44142
a((dp44143
g2
(lp44144
VNo, you cannot do that: the closest you can get is a  (you can replace the  with some other type)
p44145
aVUsing this dictionary you would be able to create associations between strings (known as "keys") and values stored in the dictionary
p44146
as(dp44147
g6
V335858
p44148
stp44149
a((dp44150
g2
(lp44151
VThe equivalent of Java's
p44152
aVwould be
p44153
aVMost likely, you would need to do this in a loop
p44154
aVThe  would be read once, and then you would read  and  while more data is available, like this:
p44155
aVAfter this loop your  would contain  characters representing operators, and  would contain  strings representing the operands
p44156
as(dp44157
g6
V335858
p44158
stp44159
a((dp44160
g2
(lp44161
VThe compiler expects you to iterate the list like this:
p44162
as(dp44163
g6
V335858
p44164
stp44165
a((dp44166
g2
(lp44167
VYou are right, you can skip the preparatory step by using this LINQ query:
p44168
aVBeing , this implementation may be somewhat inefficient on very long lists of extensions applied to extremely large directories
p44169
aVIn this case you would be better off constructing a  of enabled extensions, like this:
p44170
as(dp44171
g6
V335858
p44172
stp44173
a((dp44174
g2
(lp44175
VIf what you want is an array of anonymous objects, use this:
p44176
aVThis would produce a list of objects with a single property called
p44177
aVIf you are looking for a list of integers, and  is an  in the original class, use this:
p44178
as(dp44179
g6
V335858
p44180
stp44181
a((dp44182
g2
(lp44183
VAs you go through the loop, your  first becomes this
p44184
aVthen this
p44185
aVthen this
p44186
aVand so on
p44187
aVThe slowness comes from the fact that unless you call , each of the sets of exclusions must perform a new query
p44188
aVThis gets slower and slower with each iteration of the loop, as it does essentially the same query over and over again
p44189
aVfixes that by "materializing" the query in memory
p44190
aVNote that another solution to this problem would be "materializing" the new subset of images, like this:
p44191
aVThis would avoid chaining the "except"s, so you wouldn't have to call  on
p44192
as(dp44193
g6
V335858
p44194
stp44195
a((dp44196
g2
(lp44197
VFiles in C let you overwrite and append, but not "prepend" data
p44198
aVTo insert at the beginning or in the middle, you must copy the "tail" manually
p44199
aVIf you are writing a line-numbering program, it would be much simpler (and faster) to write the result into a separate temporary file, and then copy it in place of the original once the operation is complete
p44200
aVYou can use a simple loop that reads the original file line-by-line, and writes the output file, for example, with :
p44201
as(dp44202
g6
V335858
p44203
stp44204
a((dp44205
g2
(lp44206
VIn general, the biggest problem with combining multiple classes and categories into the same header/implementation is impaired searchability
p44207
aVWhen a class is in a file with another class, the file name will no longer reflect the fact that the header/implementation contains your other class, making it much harder for others to look for your class
p44208
aVIf your project is small and self-contained, however, the searchability is less of an issue
p44209
aVWhen there is only one file to search, there is no question of where each particular piece of code is: it's all in that one file
p44210
aVIt sounds like your project is both small and self-contained, so I see no problem in placing all code in a single source file if you want it that way
p44211
aVAnother alternative could be placing each class and category in a separate header/implementation pair of files, and then defining a header that includes them all
p44212
aVThis would let you keep an ideal project organization, and let your users include a single header to use your component
p44213
as(dp44214
g6
V335858
p44215
stp44216
a((dp44217
g2
(lp44218
VIf  does not have , you need to either use  (see Jon Skeet's answer) or use a little trick with lambdas and overloading:
p44219
aVNow you can do this:
p44220
aVThis shifts the decision on what method to call from the moment the  is called to the moment the  is created, potentially saving you some CPU cycles
p44221
as(dp44222
g6
V335858
p44223
stp44224
a((dp44225
g2
(lp44226
VThe problem that I have is that in the  I have more chars than the 's content
p44227
aVThe most likely reason why you get more bytes than there are characters in the file is the encoding of your file:  reads the file byte-for-byte, so if file's encoding uses multiple bytes for some code points, your buffer is going to contain multiple bytes for one or more characters
p44228
aVTo verify this theory and fix the problem, write a short program that writes the bytes of your intended message, , into a text file using the  API
p44229
aVA file written in this way should read correctly with
p44230
as(dp44231
g6
V335858
p44232
stp44233
a((dp44234
g2
(lp44235
VAssuming that the actual value that you would like to reference is not a constant, and that you would like to save some time by not computing it twice, you can move the common subexpression outside the call, like this:
p44236
as(dp44237
g6
V335858
p44238
stp44239
a((dp44240
g2
(lp44241
VThe  returns the size of the entire structure, while your other two expressions return the offset of the  member, which happens to be two bytes before the end of the
p44242
aVYou can get the same result with the , like this:
p44243
aVDemo on ideone
p44244
as(dp44245
g6
V335858
p44246
stp44247
a((dp44248
g2
(lp44249
VThis is not a tail recursion: returning the result of  is not the last action taken by the function; the multiplication by  is
p44250
aVHowever, the function is easy to convert to a tail-recursive implementation by adding an extra parameter, exp:
p44251
as(dp44252
g6
V335858
p44253
stp44254
a((dp44255
g2
(lp44256
VYou cannot do that: unlike static functions that can be called on their own, the call of a member function requires knowledge of two things - the function being called, and the object on which to call it
p44257
aVThat is why it is not possible to pass a member function to an API expecting a "plain" function pointer
p44258
aVIf you do not have access to the source of the  class, you can create a static function that calls a member function on an object stored at a well-known location (i
p44259
ag630
aVin a static variable)
p44260
aVIf you do, consider changing the API to take a function object, similar to what functions from the standard C++ library do
p44261
aVFinally, there is a common approach used in C libraries that take function pointers - passing an additional  pointer, which will be passed back in a call to your function pointer; pthreads library does that
p44262
aVIf this is the case, you can create a  that wraps the invocation target object, and pass a pointer to this  to be passed back to your static function
p44263
as(dp44264
g6
V335858
p44265
stp44266
a((dp44267
g2
(lp44268
VYou are almost there: in the nested loop where you print , replace  with
p44269
aVAdd a second loop that prints  spaces, then print
p44270
aVFinally, add a statement to print  before entering the first loop
p44271
aVThat would be it
p44272
aVTo optimize your code, consider writing a helper method:
p44273
aVThis way you would be able to "flod" several loops into a single call of
p44274
aVFor example,
p44275
aVwould become
p44276
as(dp44277
g6
V335858
p44278
stp44279
a((dp44280
g2
(lp44281
VThis particular use of  keyword lets you call one  constructor from the other, presumably to supply a default argument
p44282
aVYou can "fold" both constructors into one by applying default parameter values:
p44283
as(dp44284
g6
V335858
p44285
stp44286
a((dp44287
g2
(lp44288
VThe most likely reason why your code does not work is that you are invoking it in the wrong place:  is a rather unlikely candidate for being the right spot, because it's usually called too late to influence anything visible on screen
p44289
aVIn addition, you start your  with a long chain of spaces, so in the end you get exactly ten spaces in the label
p44290
aVShortening the label in the code that sets it should work much better:
p44291
as(dp44292
g6
V335858
p44293
stp44294
a((dp44295
g2
(lp44296
VThe reason this does not work is that you are swapping the actual items, rather than swapping the indexes
p44297
aVThe smallest item is initially at the index 4, then at index 2, then at index 9
p44298
aVAt this point you swap 50 and 30, so 50 ends up at index 9
p44299
aVThen you find 40 item at index 3, and then you find 50 - again, at index 9
p44300
aVThat's why the indexes repeat
p44301
aVTo fix this, change the algorithm to initialize  for the entire range, and then change the algorithm to compare
p44302
aVDo not write to  at all (i
p44303
ag630
aVyou do not need the  index)
p44304
aVInstead of swapping  and , swap  and
p44305
aVThis should take care of the problem: all items of the  would remain in place, only indexes would get sorted
p44306
as(dp44307
g6
V335858
p44308
stp44309
a((dp44310
g2
(lp44311
VMy usual fix for this is to just change the property to strong but I'm not sure if this is correct
p44312
aVThis is 100% correct
p44313
aVThe reason IB-based properties are declared  is that the view created from the NIB object already retains the corresponding UI element, so you do not need a  reference from your code
p44314
as(dp44315
g6
V335858
p44316
stp44317
a((dp44318
g2
(lp44319
V variable declaration is a promise to the compiler that there would be a definition of a global variable some place else
p44320
aVLocal variables do not qualify as fulfillments of the promise to the compiler, because they are invisible to linkers
p44321
aVIn a sense,  declarations are similar to forward declarations of functions: you say to the compiler "I know this function is there, so let me use it now, and let linker take care of locating the actual implementation"
p44322
as(dp44323
g6
V335858
p44324
stp44325
a((dp44326
g2
(lp44327
VThe easiest way to do it in C is to count each character regardless of its presence in the , then use  items as indexes into the array of counts to get the results:
p44328
aVHere is a demo on ideone
p44329
as(dp44330
g6
V335858
p44331
stp44332
a((dp44333
g2
(lp44334
VThe way the getter is coded right now does not need an assignment, because subsequent calls ignore the value set by previous methods
p44335
aVHowever, you could cache the result, like this:
p44336
aVThis implementation avoids reading the  repeatedly by caching the result of the initial retrieval in a private instance variable
p44337
as(dp44338
g6
V335858
p44339
stp44340
a((dp44341
g2
(lp44342
VThe fastest way of dealing with finding an intersection of multiple sets is language-agnostic: create a , initialize it with the data from the shortest list, and then sequentially call  on the remaining lists
p44343
aVYou need to start with the shortest list, because the complexity of the operation is , where  is the number of items in the , and  is the number of items in the other list
p44344
aVSince  will be called four times, and the complexity of setting up the initial  is , the overall complexity will be
p44345
aVSince the total is , the best approach is to pick the shortest list for making your initial set
p44346
as(dp44347
g6
V335858
p44348
stp44349
a((dp44350
g2
(lp44351
VThe first declaration lets you program to interface
p44352
aVIt ensures that later on you can safely replace  with, say, , and the rest of code is going to compile
p44353
aVThe second declaration lets you program to the class, so you could potentially use methods of  which do not implement the  interface
p44354
aVFor example, you can call  on the list declared as , but not on a list declared as
p44355
aVAlthough generally programming to interface should be preferred, there is nothing wrong with doing it if you must call class-specific methods: for example, ability to call  could save some unnecessary reallocations if you know the new target size of your list
p44356
as(dp44357
g6
V335858
p44358
stp44359
a((dp44360
g2
(lp44361
V is an unchecked exception, meaning that it generally signals programming errors, as opposed to conditions outside program's control
p44362
aVThese exceptions should be prevented, rather than handled
p44363
aVIn this specific instance, you should check the value before passing it as an index to the array, like this:
p44364
as(dp44365
g6
V335858
p44366
stp44367
a((dp44368
g2
(lp44369
VBoth of them are good methods - each one is good for its own situation
p44370
aVThe first way of drawing the text is higher-level: it treats your text as a string that needs to be measured, laid out, and clipped to bounds of a rectangle that you pass before being rendered to screen
p44371
aVUnder the hood, the  method probably calls either  or  one or more times, depending on the number of lines that it needs to render
p44372
aVThis high-level functionality does not come for free: predictably, the first method may be considerably slower than the second one, so use it only when you need this high-level functionality
p44373
as(dp44374
g6
V335858
p44375
stp44376
a((dp44377
g2
(lp44378
VIf the  returns  or , you have little choice -  or one of its length-limiting alternatives is what you need
p44379
aVIf  can be changed to return , you could go back to using
p44380
as(dp44381
g6
V335858
p44382
stp44383
a((dp44384
g2
(lp44385
VYou can rewrite this query with  to avoid creating multiple  objects in a loop, like this:
p44386
aVThe number of round-trips to DB will remain the same, but the creation of  and the partially concatenated  objects will be optimized out
p44387
as(dp44388
g6
V335858
p44389
stp44390
a((dp44391
g2
(lp44392
VThe implication is very straightforward: the first implementation converts the would-be "prototype" to a "singleton"
p44393
aVAs you correctly noted, everything that uses such prototypes is bound to use the same instance
p44394
aVThis is not desirable, because the instance is mutable
p44395
aVThe two objects that you have representing the generic false and true states would be very good candidates for singletons, but you should make them immutable, or present them through a read-only interface:
p44396
as(dp44397
g6
V335858
p44398
stp44399
a((dp44400
g2
(lp44401
VFiles  are not linked to  at runtime, they are linked to it at compile time (specifically, during the linking step)
p44402
aVOnce you have an executable, you can safely remove all object files that were linked into it
p44403
aVIt is also OK to remove all static libraries that were statically linked into the , because their content becomes part of the executable
p44404
as(dp44405
g6
V335858
p44406
stp44407
a((dp44408
g2
(lp44409
VAdd an instance variable, set it to the offset that you've seen in the last invocation of , and use it to decide if you would like to animate:
p44410
aVThis would let you animate the image every time the scroll view crosses from below 160 to above 160
p44411
as(dp44412
g6
V335858
p44413
stp44414
a((dp44415
g2
(lp44416
VIn general, repeating a very simple, single-line piece of code similar to  is not perceived "code duplication"
p44417
aVMoreover, repeatedly checking the same simple condition is not generally perceived a performance hazard
p44418
aVBoth ways are equally readable, so either one is fine, depending on your preference
p44419
aVOne possible improvement would be splitting the function in two, and dropping the  flag, like this:
p44420
aVHowever, this may not be acceptable in situations when the type of input is decided at runtime, and must be controlled through a variable
p44421
as(dp44422
g6
V335858
p44423
stp44424
a((dp44425
g2
(lp44426
VI would try this implementation:
p44427
aVThe way this works is that when the  goes past the end of the input, ensuring that  returns , the null-coalescing operator  takes the first record from
p44428
aVThe implementation of  will be a "mirror image" of this, using  instead of
p44429
as(dp44430
g6
V335858
p44431
stp44432
a((dp44433
g2
(lp44434
VIn addition to the obvious error reported by compiler (i
p44435
ag630
aVinitializing a local variable rather than assigning to an instance variable) you have a more serious issue: if a value smaller than  is passed to , your code would exhibit undefined behavior by writing data past the end of the allocated region
p44436
aVYou need to change the code as follows:
p44437
as(dp44438
g6
V335858
p44439
stp44440
a((dp44441
g2
(lp44442
VThis implementation is spot-on, assuming that you're OK with bounds checking exceptions thrown by JVM rather than rolling your own
p44443
aVThis is perfectly acceptable, because Java arrays always do bounds checking for you, so there is no danger of accessing something outside the bounds of the array and not get an exception
p44444
aVThe  inside
p44445
aVand  inside
p44446
aVare not related
p44447
aVFunction parameters are similar to local variables, in the sense that their name means nothing outside the scope of a given function
p44448
aVAlso note that since the array is  you do not need explicit comparisons with  or : using  and  is sufficient
p44449
as(dp44450
g6
V335858
p44451
stp44452
a((dp44453
g2
(lp44454
VSuch operator is not necessary in C++, because there is no built-in type that would be capable of storing both these values in a meaningfully distinguishable way
p44455
aVMoreover,  is not required in C++, because you can replace it with zero  everywhere a  goes
p44456
aVBjarne Stroustrup even suggests avoiding  altogether:
p44457
aVIn C++, the definition of NULL is 0, so there is only an aesthetic difference
p44458
aVI prefer to avoid macros, so I use 0
p44459
aVAnother problem with NULL is that people
p44460
aVsometimes mistakenly believe that it is different from 0 and/or not an integer
p44461
aVIn pre-standard code, NULL was/is sometimes defined to something unsuitable and
p44462
aVtherefore had/has to be avoided
p44463
aVThat's less common these days
p44464
as(dp44465
g6
V335858
p44466
stp44467
a((dp44468
g2
(lp44469
VHere is one way of writing it:
p44470
aVThis means that the first character is not , or when the first character is , then the second character must not be
p44471
as(dp44472
g6
V335858
p44473
stp44474
a((dp44475
g2
(lp44476
VThe  is an output parameter, so you need to pass a pointer to a pointer, like this:
p44477
aVWhen the function returns,  will be set to the output value of the function
p44478
as(dp44479
g6
V335858
p44480
stp44481
a((dp44482
g2
(lp44483
VIn the comment to the article Eric replied to an observation that since the size of a permutation grows exponentially, it would quickly outgrow numbers representable with 32 bits
p44484
aVEric's reply was that he has no intention of indexing permutations, by which he meant defining a numbering scheme to obtain a sequential number of a permutation
p44485
aVThat is why, he said, overflowing 32 bits was not one of his concerns: his approach allowed to enumerate, or simply "produce", all permutations in some order, as opposed to providing a way to get  permutation according to some numbering scheme
p44486
aVContrast this to a problem discussed in a question about producing  permutation without going through all the preceding ones: here, the author wants to index, or give numbers to, permutations, so the size of an integer is of a concern to them
p44487
aVHere is an example of indexing permutations discussed in the question linked above:
p44488
aVThis indexing scheme lets you answer two questions:
p44489
aVWhat is the number of a particular permutation, say,
p44490
aV(it's 4)
p44491
aVWhat is permutation number , say, 5
p44492
aV(it's )
p44493
aVThis problem could be somewhat harder than enumerating all permutations, because you need to produce a numbering scheme
p44494
as(dp44495
g6
V335858
p44496
stp44497
a((dp44498
g2
(lp44499
VOn one hand, Java does not have a concept of pointers; on the other hand, everything other than primitives in Java (i
p44500
ag630
aVall -derived things) could be through of as "pointers", although technically they are not called that
p44501
aVJava calls them references, but since there is such thing as  reference, they behave very much like pointers in C and C++
p44502
aVAnyway, when you create an array of ten non-primitives, you create an array of references, each one set to :
p44503
aVThis is different from creating ten  objects, in that the objects themselves are not created when you create an array, only places through which you could reference these objects later if you need to
p44504
as(dp44505
g6
V335858
p44506
stp44507
a((dp44508
g2
(lp44509
VAlthough your object indeed responds to selector  (because all -derived objects do), the description is not settable
p44510
aVThe selector that you pass is for the getter , not for a setter
p44511
as(dp44512
g6
V335858
p44513
stp44514
a((dp44515
g2
(lp44516
VYou are absolutely right, this style of programming kills maintainability of your code right away
p44517
aVThere are two simple ways of handling this - implementing a visitor, and defining a  based on
p44518
aVHere is an example of the first approach:
p44519
aVWith this structure in hand, you can write your remover as follows:
p44520
aVThe second relies on the ability of Java objects to produce their
p44521
aVNow instead of defining
p44522
aVyou can define
p44523
aVTo access giraffes, you would do
p44524
aVand so on
p44525
aVThen you can implement  like this:
p44526
as(dp44527
g6
V335858
p44528
stp44529
a((dp44530
g2
(lp44531
VI think the problem is with your grayscale factors, : they add up to 103%, so when the source color is while (i
p44532
ag630
aV) you get grayscale that exceeds 255
p44533
aVScaling down the factors should work: use  instead
p44534
as(dp44535
g6
V335858
p44536
stp44537
a((dp44538
g2
(lp44539
VThere are a few mistakes in your code - I'll describe an algorithm without writing the code to avoid spoiling the learning exercise for you:
p44540
aVThe outer loop needs to go from 0 to
p44541
aVThe inner loop needs to check  and
p44542
aVThe inner loop needs to stop as soon as you find a mismatch; set a mismatch flag, and break
p44543
aVIf the inner loop completes without finding a mismatch, then  is the position of the first match
p44544
aVNote that this is the most straightforward algorithm
p44545
aVIt does not perform well when the  is long, and  has lots of "false positives" In general, you can do better than that, for example, by using the KMP algorithm
p44546
as(dp44547
g6
V335858
p44548
stp44549
a((dp44550
g2
(lp44551
VEverything works correctly: the  executes before , so by the time the  is printed its value is already 2, not 1
p44552
aVIf you need  printed, move  so that it comes after printing
p44553
aVThe second if statement is not executing after that because match is "one", not "two"
p44554
as(dp44555
g6
V335858
p44556
stp44557
a((dp44558
g2
(lp44559
VThere could be hundreds of thousands of articles and multiple thousands of users
p44560
aVStoring row for each article/user in 'read articles' join table seems to be inefficient way
p44561
aVThe scheme that stores one row per  pair is correct
p44562
aVThe implication that having lots of rows makes this scheme inefficient is incorrect: modern databases are optimized to handle lots of rows very efficiently
p44563
aVMoreover, the implication that having "hundreds of thousands of articles and multiple thousands of users" would translate into lots of rows is incorrect as well: you will be storing a row per article a user reads, not for every article, so the number of rows that you get would be orders of magnitude short of the worst-case estimate
p44564
as(dp44565
g6
V335858
p44566
stp44567
a((dp44568
g2
(lp44569
VReplace  with , start your thread immediately, and pass it the queue
p44570
aVThe thread should call , which will block until an e-mail becomes available
p44571
aVEssentially, you'll get a dormant thread waiting on the receiving end of the queue, producing the effect that you want: any time an e-mail is inserted into the queue, the reading thread would wake up, grab the new e-mail, process it, and go back to sleep
p44572
as(dp44573
g6
V335858
p44574
stp44575
a((dp44576
g2
(lp44577
VThis implementation is different in that the only way it knows to populate the array is hard-coded:  is the way it populates the array, and it is part of the library that provides the  functionality
p44578
aVEssentially, the two functions are baked together into a single whole (the fancy way of saying the same thing is to say that they are "tightly coupled")
p44579
aVWith the original implementation I can do all of the things below without changing a line in the :
p44580
aVWith your implementation I would have to write a separate  for each of these cases
p44581
aVIf the way of populating an array that I need is not part of the library, I am on the hook for implementing the whole , not only its value-producing generator function
p44582
aVThis may not be that bad in this case, but in cases where callbacks really shine (threads, asynchronous communications) reimplementing the original without callbacks would be prohibitive
p44583
as(dp44584
g6
V335858
p44585
stp44586
a((dp44587
g2
(lp44588
VIt looks like you are trying to make a range query from December of 2012 through February of 2013
p44589
aVIn this case you could use a condition below:
p44590
aVThe trick is to specify different conditions for the month based on  vs , rather than using
p44591
aVOf course a simpler approach would use  as a whole date, like this:
p44592
aVEDIT :
p44593
aVcheck  only for rows where year  and check  only for rows where
p44594
aVThe above translates into this LINQ expression:
p44595
as(dp44596
g6
V335858
p44597
stp44598
a((dp44599
g2
(lp44600
VIs the malloc'd memory automatically 'd at the end of the program
p44601
aVNo, it is not d in the C sense of the word
p44602
aVIt is returned back to the operating system when the program finishes, but unless you call a  explicitly, it's a memory leak
p44603
aVYou can fix the memory leak as follows:
p44604
as(dp44605
g6
V335858
p44606
stp44607
a((dp44608
g2
(lp44609
VIt looks like some of the images are missing on the iPhone, so this line
p44610
aVfilters them out
p44611
aVChange this line as follows to see which images are not present:
p44612
as(dp44613
g6
V335858
p44614
stp44615
a((dp44616
g2
(lp44617
VThis line stores the address of variable  in the memory pointed to by :
p44618
aVThis line stores the value of  into memory pointed to by :
p44619
aVThe two assignment statements are unrelated: the second one makes a copy, while the first one does not
p44620
aVIf you change the value of  and then retrieve , you will see the new value of ; however, retrieving  would give you back the old value of  (i
p44621
ag630
ag1783
as(dp44622
g6
V335858
p44623
stp44624
a((dp44625
g2
(lp44626
VA very simple way of converting octal to hex is through binary: octal digits correspond to three binary digits, while hex digits correspond to four
p44627
aVConvert the number to binary, regroup by four-bit nibbles, and then convert to hex
p44628
aVThe number converted to binary looks like this:
p44629
aVRegroup by nibbles and add leading zeros for conversion to hex:
p44630
aVNow you can easily convert the number using a lookup table
p44631
as(dp44632
g6
V335858
p44633
stp44634
a((dp44635
g2
(lp44636
VThe fact that "the array name is the address of the zeroth element" is true most of the time1 does not mean that you can assign it anything
p44637
aVAlthough this
p44638
aVlooks like an assignment, it is in fact initialization; the concept of lvalue does not apply to it
p44639
aVMoreover, obtaining an address using  operator never produces an lvalue, so there is no way to come up with an  that does not break your first three examples
p44640
aVThe last two, however, can be assigned, with some minor tweaks:
p44641
aV1 One notable exception is  - here, it's not the same as  for arrays of size other than
p44642
as(dp44643
g6
V335858
p44644
stp44645
a((dp44646
g2
(lp44647
VYou can do it by building a class that calls initialization code in its constructor, like this:
p44648
aVNow you can do this:
p44649
aVThe object will be constructed once, executing the  exactly one time
p44650
as(dp44651
g6
V335858
p44652
stp44653
a((dp44654
g2
(lp44655
VThis is because your code decides to stop on finding  only after performing the comparison
p44656
aVThis condition will be  even when the match happens at the end of the string on null terminators, so the  loop would happily proceed beyond the end of both strings past the null terminator, causing undefined behavior
p44657
aVChanging the condition to exit when  is zero should fix the problem:
p44658
as(dp44659
g6
V335858
p44660
stp44661
a((dp44662
g2
(lp44663
VThere are two syntaxes of the  expression - the so-called simple one that compares a single value against a list of other values, and a searched one with generic boolean conditions
p44664
aVYou picked the simple case, but it does not have enough flexibility for what you need; you should switch to the searched syntax, like this:
p44665
as(dp44666
g6
V335858
p44667
stp44668
a((dp44669
g2
(lp44670
VBefore you start your loop, call  to go to the end of file (i
p44671
ag630
aVwith ), and use  to find the current position
p44672
aVThis will let you know where the  will be
p44673
aVThen use  again go back to the beginning of file with , and proceed with the loop
p44674
aVWhen you need to know if you are at , call  and compare the position with the size of the file that you stored before entering the loop
p44675
as(dp44676
g6
V335858
p44677
stp44678
a((dp44679
g2
(lp44680
VThe standard does not require external functions to be called: being referenced is enough to be kept in the results of translation
p44681
aVAccording to the standard's section 5
p44682
ag1340
ag1340
ag839
aV1, during the eights (and last) phase of translation
p44683
aVAll external object and function references are resolved
p44684
aVLibrary components are linked to satisfy external references to functions and objects not defined in the current translation
p44685
aVSince returning a pointer to a function is considered a reference to it, the standard guarantees that  will be linked to whatever implementation that you supply to the linker, which may or may not be the one coming from the standard math library
p44686
as(dp44687
g6
V335858
p44688
stp44689
a((dp44690
g2
(lp44691
VA setter that does not use  anywhere in its body is an indicator of misusing the technology
p44692
aVIf a field is read-only, provide only a getter for it
p44693
aVDo not provide a setter if you plan to discard the value being set
p44694
aVInstead, decide on the value(s) upon which the calculated one is dependent, and move the setting logic for your  into their setters
p44695
aVTaking your class is an example, the only dependency here is the  property
p44696
aVYou can change your class as follows:
p44697
aVNote how  is moved into a separate method
p44698
aVThis is useful in situations when you have multiple dependencies: rather than embedding the logic into the individual setters, it is better to move it into a method, and call it as needed
p44699
as(dp44700
g6
V335858
p44701
stp44702
a((dp44703
g2
(lp44704
VThe sort is incorrect because it interprets  as a string, not as a number
p44705
aVStrings are ordered lexicographically, meaning that  comes in front of , because , the initial digit of , is less than , the initial digit of
p44706
aVYou can fix it by using  in place of  when representing distances, or forcing the same number of digits by padding all values with zeros to achieve the same length
p44707
as(dp44708
g6
V335858
p44709
stp44710
a((dp44711
g2
(lp44712
VYou get a segmentation fault because you are passing the pointer  before making any assignments to it
p44713
aVEither the  need to take  and assign it a dynamically allocated array, or the caller needs to provide an array sufficient to hold the output of the conversion
p44714
aVThe reason why it "works" on another platform is that it exhibits undefined behavior: in arduino, the arbitrary value placed in the uninitialized pointer  happens to point to an unused location in memory
p44715
aVWriting to that location does not trigger segmentation fault, creating an illusion of working code
p44716
as(dp44717
g6
V335858
p44718
stp44719
a((dp44720
g2
(lp44721
VOne way to avoid nesting and the associated duplication is to separate the parts of code that extract the value from parts of code that perform operations on it
p44722
aVHere is a small example that should illustrate the technique:
p44723
aVAdding a new source field now entails adding another  to the first ; adding a new operation to a type would require only one new  in the second , thus reducing the number of "maintenance points" in your code
p44724
as(dp44725
g6
V335858
p44726
stp44727
a((dp44728
g2
(lp44729
VSeveral things are wrong with this approach:
p44730
aVIt requires storing passwords in plain text - This is the worst thing one can do to a user's password: anyone who accidentally gains access to your database would instantly be in possession of all your users' passwords, with is very, very bad
p44731
aVIt is susceptible to SQL Injection attacks - Concatenating strings to produce a SQL command is dangerous, because malicious users could enter strings that break your SQL and turn it into something else
p44732
aVYou should study the answers to this question
p44733
aVThe approaches discussed there are not nearly as simple as what you are implementing, but they make your system a lot more bullet-proof
p44734
as(dp44735
g6
V335858
p44736
stp44737
a((dp44738
g2
(lp44739
VSince you are materializing your query to list anyway, you could do the conversion on the
p44740
aVNET side, rather than in the RDBMS, like this:
p44741
aVSince the  is called on an element from , it will no longer fail
p44742
aVAlso note the use of  operator in place of a null-checking  conditional
p44743
as(dp44744
g6
V335858
p44745
stp44746
a((dp44747
g2
(lp44748
VTo exit a function early in Java, simply place  on the line where you want to exit:
p44749
as(dp44750
g6
V335858
p44751
stp44752
a((dp44753
g2
(lp44754
VWith  variables and properties, comparisons to / or / are unnecessary
p44755
aVby itself is already a valid Boolean expression, which can go into an , a ternary , or a loop construct without additional comparisons
p44756
aVYou can write this:
p44757
as(dp44758
g6
V335858
p44759
stp44760
a((dp44761
g2
(lp44762
VRe-entrant means that the function can be interrupted at any point, and be able to correctly finish executing after the interruption, even in cases when the same function is called one or more times in the interrupted state
p44763
aVThe crucial part here is that the invocation of the function called in the interrupted state must finish before the original call state is restored
p44764
aVThis is the main difference between re-entrancy and thread safety: in order to be thread-safe, a function must be able to proceed even if the interrupting invocation is unfinished before the control gets back to the original call
p44765
aVThat's why the second version of the  is re-entrant: it always leaves  in an unchanged state upon exiting, so entering and exiting  in the middle of an interrupted call will not alter the global state seen by the interrupted invocation
p44766
as(dp44767
g6
V335858
p44768
stp44769
a((dp44770
g2
(lp44771
VMove initialization of the  from a regular constructor to a static initialization block:
p44772
aVor initialize it at the point of declaration:
p44773
aVOtherwise,  would remain  until the first call of 's constructor is made
p44774
as(dp44775
g6
V335858
p44776
stp44777
a((dp44778
g2
(lp44779
VThis is incorrect:
p44780
aVYou check the condition on  repeatedly, without giving user a chance to enter a new value
p44781
aVTo fix the problem, remove the second loop, and replace
p44782
aVinside the first loop with
p44783
as(dp44784
g6
V335858
p44785
stp44786
a((dp44787
g2
(lp44788
VI've read that, although minimal, static methods are slightly more efficient than non-static methods
p44789
aVThat's not unconditionally true: only the methods that could otherwise be  but are not made  by omission would be more efficient
p44790
aVOtherwise, you would need to pass a reference to the object manually, leveling up the playing field
p44791
aVMoreover, CLR is optimized so much that the difference is hard to measure
p44792
aVTo answer your question, there is no reason to make a method non-static if it does not access instance state through properties or variables
p44793
aVHowever, all methods that access per-instance state should be non-static for readability, because there is no performance to gain from making them static and passing the instance manually
p44794
aVTo illustrate the point, you should do this
p44795
aVrather than this:
p44796
as(dp44797
g6
V335858
p44798
stp44799
a((dp44800
g2
(lp44801
VHere is what happens:  and  start off referencing the same object
p44802
aVHowever, since Java  is immutable and thus cannot be modified in-place, this line
p44803
aVresults in assigning  a reference to a brand-new object
p44804
aVThat is why the subsequent comparison  fails
p44805
as(dp44806
g6
V335858
p44807
stp44808
a((dp44809
g2
(lp44810
VThe reason your code does not work is in the content of your  array: it contains a single-letter string
p44811
aVIt is this string that makes
p44812
aVevaluate to  for any input string that contains letter
p44813
aVIn order to fix this problem, you can move the checks for  to the top of the // chain
p44814
aVHowever, the solution would not be overly robust:  would be classified as ,  would become , and so on
p44815
as(dp44816
g6
V335858
p44817
stp44818
a((dp44819
g2
(lp44820
VNo, that code is not going to work, because your second cast is going to fail:  will be a , not a
p44821
aVHere is how you can fix your code:
p44822
aVAlternatively, you can do it like this:
p44823
as(dp44824
g6
V335858
p44825
stp44826
a((dp44827
g2
(lp44828
VThere is no casting going on in this code example:  is a regular Objective C method provided by  to retrieve the value stored inside as an integer
p44829
aVThe fact that you assigned the object to  pointer does not change anything: the object inside remains
p44830
aVYou do not get a crash because Objective C is a dynamically typed language
p44831
aVIt lets you assign objects of wrong types, but if you try calling methods of  on your  object, you are going to get a crash:
p44832
as(dp44833
g6
V335858
p44834
stp44835
a((dp44836
g2
(lp44837
VI declared enum in main
p44838
aVYou need to declare  in a file that is included in all translation units that use the , not only in
p44839
aVFor example, you can define it in  (don't forget to add the inclusion guards), and then include it in both your  and the turn-processing source files:
p44840
aVDirection
p44841
ag1177
aVNow add  to your  and other files using the  to make your sources compile correctly
p44842
as(dp44843
g6
V335858
p44844
stp44845
a((dp44846
g2
(lp44847
VChanging an  does not change the corresponding item in the view:  is a subview of your main view which is added through a storyboard or a nib file, and  has a reference to it
p44848
aVWhen you set that reference to some other label, you disconnect it from the original , so you can no longer update the label on the screen
p44849
aVInstead of setting a new  in the delegate, you should set the properties of the existing  - its text, color, and anything else that you need to update
p44850
aVAssuming that your outlets are connected properly, this will make the updates visible on screen
p44851
aVEDIT 1: When setting the label, don't forget to reference the  property
p44852
aVEDIT 2: Your code creates a new instance of  in the timer callback, and modifies its properties
p44853
aVThat does not work, because you are modifying something that is not on the screen
p44854
aVInstead, you should set  property in the app delegate at the time the real  instance is created
p44855
aVWithout knowing your app it's hard to say when that happens, but you need to get a hold of the right instance of  in order for the code to work
p44856
as(dp44857
g6
V335858
p44858
stp44859
a((dp44860
g2
(lp44861
VFirst, consider the meaning of : the rule has three arguments representing lists
p44862
aVreturns a solution when the last list is a concatenation of the first two:
p44863
aVKnowing this, you can figure the answers to all your questions:
p44864
aVneeds X to unify with 1 and 2 at the same time, which is impossible
p44865
aVunifies 5 with the first Z, and the second Z with Y, for a single solution
p44866
aVunifies Y with the second Z, and the third Z with 5, for a single solution
p44867
as(dp44868
g6
V335858
p44869
stp44870
a((dp44871
g2
(lp44872
VI think you found an inconsistency in pmd's rules, when following one of the rules makes you violate another rule
p44873
aVI think the first loop is fine as is: the second loop works fine, too, but using  there is rather unorthodox
p44874
aVAdding a  there without a good cause+ could trip up even very experienced developers
p44875
aVSince you do not want to make reading your program any harder than it is, I'd recommend skipping the  in  loops
p44876
aV+ Making the loop variable available to an anonymous class is one such good cause
p44877
as(dp44878
g6
V335858
p44879
stp44880
a((dp44881
g2
(lp44882
VOverriding  is required when you override , otherwise hash-based containers might not work correctly
p44883
aVFrom the documentation of :
p44884
aVTypes that override Equals must also override GetHashCode; otherwise, Hashtable might not work correctly
p44885
aVEven though the code may not get exercised in your case, you should keep it anyway
p44886
aVIn addition to being correct, it would help you test equality of collections regardless of their sequence:
p44887
aVOne change I would make to the  implementation is eliminating its symmetry: currently, switching around the first and the last name inside your object would lead to making the same hash code
p44888
aVThis is sub-optimal
p44889
aVYou can combine multiple s int a hash code by multiplying them by a small prime number, e
p44890
ag303
aV31, and adding them up, like this:
p44891
as(dp44892
g6
V335858
p44893
stp44894
a((dp44895
g2
(lp44896
VIf you need to use a regex, you can do this:
p44897
aVThis replaces any text after the tenth character with three dots
p44898
aVThe  is a lookbehind
p44899
aVIt means that  must be matched (but not consumed) in order for the rest of the match to be successful
p44900
aVIf there are fewer than ten characters in the input, no replacement is performed
p44901
aVHere is a demo on ideone
p44902
as(dp44903
g6
V335858
p44904
stp44905
a((dp44906
g2
(lp44907
VYou cannot make variable declarations conditionally, based on runtime conditions: both variables must be declared unconditionally, even though the rest of the code is going to use only one of them
p44908
aVThe only way to make declarations conditional is by using preprocessor's conditional compilation, which does not look applicable, because your condition is based on the header of the file, so it's clearly a runtime one
p44909
aVYou can put processing in two branches of the , like this:
p44910
as(dp44911
g6
V335858
p44912
stp44913
a((dp44914
g2
(lp44915
VYou probably want this:
p44916
aVOtherwise, the call of  reads and discards the value, while  remains uninitialized
p44917
aVYou should probably combine initialization with declaration, too: remove
p44918
aVand replace it with
p44919
aVon the line where you read the int from the
p44920
as(dp44921
g6
V335858
p44922
stp44923
a((dp44924
g2
(lp44925
V is a specification of a template class (as opposed to a template function, which you show above)
p44926
aVThere is a declaration of
p44927
aVsomewhere in your code or in one of the header files that you included
p44928
aVEssentially,  is a class produced using a  template by replacing  with  throughout the template's code
p44929
as(dp44930
g6
V335858
p44931
stp44932
a((dp44933
g2
(lp44934
VYou do not need to chain s - you can use  instead
p44935
aVMoreover, since  takes a condition, you can move the entire clause inside the call, like this:
p44936
as(dp44937
g6
V335858
p44938
stp44939
a((dp44940
g2
(lp44941
VNo, it is not more efficient -- precisely because of the overload that you mentioned
p44942
aVMoreover, a call of  on a  is extremely quick, so even without an overload the difference would not be measurable
p44943
aVHowever, your professor is right about not making the call like , but the reason is different: since the call is unnecessary, the readers of your code may get confused
p44944
as(dp44945
g6
V335858
p44946
stp44947
a((dp44948
g2
(lp44949
VYou need to set  variable to something other than , like this:
p44950
aVOtherwise, this line will trigger the exception:
p44951
aVNote that the  condition is unnecessary:  could return an empty list, but it never returns
p44952
aVIn addition, you do not need to use  with Boolean variables, unless they are nullable
p44953
aVFinally, the  loop can be folded with LINQ's , like this:
p44954
as(dp44955
g6
V335858
p44956
stp44957
a((dp44958
g2
(lp44959
VSo if SIDE1 or SIDE2 is null, nothing is selected
p44960
aVThat's not what the condition says:  in the  clause means that nothing is selected when SIDE1 and SIDE2 are both null; otherwise, one of the  evaluates to , making the overall  condition  as well
p44961
aVIf you would like to treat  the same way that you treat , you can use  condition, like this:
p44962
as(dp44963
g6
V335858
p44964
stp44965
a((dp44966
g2
(lp44967
VIs there any usage for object name colors
p44968
aVYes: if you want a global variable of type , you can define it right after the declaration of the
p44969
aVcould I be able to print out the name of any of these color by using Enumerations or I only can print out the constant number which each of color corresponding to
p44970
aVNo, you would not be able to print the names of  members given an enum value, unless you build a system in your own code through which you would be able to "decode" constants back to string representations
p44971
aVOne common way to do that is creating a parallel array of string literals:
p44972
aVAs you can see, inability to convert an enum to string does not apply to enum constants known at compile time: you can use a preprocessor trick to stringify them
p44973
aVAnother common way of mapping enum values to string is using a
p44974
aVIt is similar to a parallel array in that you need to initialize it manually, though
p44975
aVIt works much better for "flag" enums, i
p44976
ag630
aVenums that do not use sequential values
p44977
as(dp44978
g6
V335858
p44979
stp44980
a((dp44981
g2
(lp44982
VYou use a value when
p44983
aVYour data member is principal, i
p44984
ag630
aVnot a copy of something else or a reference to another value
p44985
aVYou would like an independent copy that you would like to modify
p44986
aVThe object is much smaller than the pointer/reference, and you need many of them
p44987
aVYou use pointers or references when
p44988
aVThe object is too large to copy efficiently
p44989
aVThe object needs to be modifiable in some other part of the code
p44990
aVYou decide between a pointer and a reference using a simple rule: if there are situations where your referenced object does not exist, or the same variable must refer to different objects throughout its lifetime, use a pointer; otherwise, use a reference
p44991
as(dp44992
g6
V335858
p44993
stp44994
a((dp44995
g2
(lp44996
VA common trick to deal with non-compile-time constants is moving the check to runtime, like this:
p44997
aVYou make  the default in the method signature, and then the first thing you check is if the value passed is , in which case you substitute it with
p44998
aVNote that in order for this trick to work,  must not be a valid parameter that one would reasonably want to pass to your method, and your documentation should say that passing  is equivalent to passing
p44999
as(dp45000
g6
V335858
p45001
stp45002
a((dp45003
g2
(lp45004
VThe  method is what gets called by  in the call of
p45005
aVIt is essentially the same as
p45006
aVbut takes less typing and avoids hard-coding the name of the  class
p45007
aVA better way of implementing singleton is using , like this:
p45008
as(dp45009
g6
V335858
p45010
stp45011
a((dp45012
g2
(lp45013
VIs there a method that would allow me to move part of string 1 to string 2
p45014
aVMove, not copy
p45015
aVSince
p45016
aVNET strings are immutable, they cannot support methods with "move" semantic
p45017
aVEvery modification of a string requires creation of a new object, entailing copying
p45018
aVEDIT (in response to the edit of the question) It looks like your problem has to do with splitting the string at 8K characters, not necessarily moving parts of the string
p45019
aVIn this case, you could use this simple code to pass parts of the string to SQL:
p45020
aVHere is a quick demo on ideone
p45021
as(dp45022
g6
V335858
p45023
stp45024
a((dp45025
g2
(lp45026
VOne common way of testing equality to a certain "tolerance level" is using :
p45027
as(dp45028
g6
V335858
p45029
stp45030
a((dp45031
g2
(lp45032
VIf someone could point out where I am wrong
p45033
aVYou are not wrong at all: properly designed hash tables gives you an expected lookup efficiency of  and inserts in amortized , so your algorithm is
p45034
aVLookup in heavily loaded hash tables is indeed a little slower because of possible duplicate resolution, but the expected lookup time remains
p45035
aVThis may not be good enough for real-time systems where "amortized" does not count, but in all practical situations this is enough
p45036
aVOf course you could always use a balanced tree for the items that you've seen for a worst-case  algorithm, or if the numbers have reasonable bounds (say, between 0 and 100,000) you could use a boolean array to test membership in  worst-case, and a potential improvement over a hash table because of a smaller constant multiplier
p45037
as(dp45038
g6
V335858
p45039
stp45040
a((dp45041
g2
(lp45042
VThe result is 5, not 6, because the two threads can sleep simultaneously
p45043
aVGoing to sleep by calling  lets the other thread run, but the remaining sleep interval timer continues ticking for both threads
p45044
aVNote that this applies only to sleeping (which uses nearly zero CPU), but not to doing useful work: in this case the timing on a single-core non-hyperthreaded CPU would indeed be additive
p45045
aVFor example, if one thread needed to do five seconds worth of number crunching, and the other needed to do a second worth of number crunching, the total time for both threads would be six seconds
p45046
as(dp45047
g6
V335858
p45048
stp45049
a((dp45050
g2
(lp45051
VYou do not need to call  on an  in a  loop:  is already declared as , so the type conversion will be performed for you automatically
p45052
aVSometimes you may need to call an array on results of a query to copy the data into memory
p45053
aVOne place where it gives you advantages is copying results of a database query into memory, because you can close the connection sooner
p45054
aVIn addition, calling  could help you in situations when a query would otherwise reference a modified variable, or when  is expensive to produce multiple times
p45055
as(dp45056
g6
V335858
p45057
stp45058
a((dp45059
g2
(lp45060
VAlthough this looks innocent, especially in combination with a  call that executes the code immediately, I would definitely stay away from modifying anything as part of a query: the trick is so unusual that it would trip up readers of your program, even experienced ones, especially if they never saw this before
p45061
aVThere's nothing wrong with  loops - the fact that you can do it with LINQ does not mean that you should be doing it
p45062
as(dp45063
g6
V335858
p45064
stp45065
a((dp45066
g2
(lp45067
VReturning  is undefined behavior: as soon as your function exists, the content of that buffer can be anything
p45068
aVYou should allocate memory dynamically - at the very least, return
p45069
aVSince this is C++, using  is preferred: it will properly manage the memory for you, so even when you do not guess the size of your string correctly, there would be no buffer overruns
p45070
aVYour current solution would fail if the compressed string happens to be longer than 256 characters; a -based solution would be free of this shortcoming
p45071
as(dp45072
g6
V335858
p45073
stp45074
a((dp45075
g2
(lp45076
VYou can use , followed by  to filter out all records that have duplicates:
p45077
aVIn order for this to work, you still need to override  and
p45078
as(dp45079
g6
V335858
p45080
stp45081
a((dp45082
g2
(lp45083
VHere is what is going to happen (see comments below)
p45084
aVIn the end, two objects remain that do not get GCd -  and the former  which is now referenced as
p45085
aVNote: In a special case of  class being a non-static inner class of , keeping a reference to  would also keep  around
p45086
aVThis is because internally the  class has a hidden variable of type , which references the outer object of the inner class
p45087
as(dp45088
g6
V335858
p45089
stp45090
a((dp45091
g2
(lp45092
VGenerally, yes, it is a bad practice, for two reasons:
p45093
aVThings that could be calculated should not be stored (e
p45094
ag303
aVstoring an age and a DOB is a bad practice), and
p45095
aVAn object can belong to multiple collections at once, so it may not be clear which collection it should track
p45096
aVThere are two ways to address this problem:
p45097
aVAvoid it in the first place - rather than passing around objects, pass around their indexes in the collection
p45098
aVWhen you need to access an object, apply the index to the collection
p45099
aVThis way the index remains your "primary reference" to the object, so finding it out never becomes an issue, or
p45100
aVCalculate the positions as needed - Keep a normal collection where objects do not keep an index
p45101
aVWhen you need to pair up objects and indexes, run a LINQ query that pairs them up temporarily; discard the results as soon as they are no longer needed
p45102
aVHere is an example of a LINQ query to pair up objects and their indexes:
p45103
aVNote that this approach does not make the class aware of its position in the collection
p45104
aVRather, an anonymous class pairs up the object with its position in the collection, solving the problem of an object belonging to multiple collections
p45105
as(dp45106
g6
V335858
p45107
stp45108
a((dp45109
g2
(lp45110
VThere is no set limit to how many levels of nesting you can have, with or without , but of course there is a practical limit of how much nesting you can fit on screen without making your eyes hurt
p45111
aVTo that end, it is often a good idea to limit nesting
p45112
aVYou can do it by observing that curly braces after compound statements are optional
p45113
aVTherefore, you can do this:
p45114
aVThe statements remain nested inside each other as before, but they look "flat" on the screen
p45115
aVOne limitation of this approach is that all three variables (, , and ) will be disposed at the end of the same scope
p45116
aVThis is not a problem in this particular case, because you end all three scopes without any statements in between (i
p45117
ag630
aVyou have three closing braces at the end)
p45118
aVHowever, a need to end the scope of one of the variables earlier than others may force you to use an additional level of nesting
p45119
as(dp45120
g6
V335858
p45121
stp45122
a((dp45123
g2
(lp45124
VThere are two kinds of dependencies to consider - project dependencies, and run-time dependencies
p45125
aVRun-time dependencies are the simplest ones: you need JARs for both A and B in order to run C, because without A, B would not be able to run
p45126
aVJava modules are similar to dynamic libraries in other compiled languages (as opposed to static libraries)
p45127
aVWhen you compile B, the compiler does not make copies of A's classes to be included with B: it assumes that A, B's dependency, will be available at run-time
p45128
aVProject dependencies are less straightforward: strictly speaking, you do not need to include A in the list of dependencies of C
p45129
aVMost development environments will figure out transitive dependencies for you, so when A changes, B would recompile, and then C would recompile in response to B's recompile
p45130
as(dp45131
g6
V335858
p45132
stp45133
a((dp45134
g2
(lp45135
VAssuming that you want to name the columns of your result , , and , you are using single quotes instead of double quotes
p45136
aVChange your query to
p45137
aVto fix the problem
p45138
aVNote that since the query string is inside a C# string, double quotes need to be escaped with a backslash
p45139
as(dp45140
g6
V335858
p45141
stp45142
a((dp45143
g2
(lp45144
VThis is a relatively well-known configuration issue: your  is set to a large value, forcing MySql to use BLOBs instead of s for the results of
p45145
aVTo fix, set  to, say,  in your  or  file, and restart MySql
p45146
aVHere is a link to a post with more information
p45147
as(dp45148
g6
V335858
p45149
stp45150
a((dp45151
g2
(lp45152
VHow I can do it using the global variable
p45153
aVThe best thing would be to pass the global variables to your functions explicitly
p45154
aVGlobal variables are a maintenance liability, your code will be easier to understand without them
p45155
aVFor example, you can do this:
p45156
aVIf you need an ability to modify your globals, pass them by reference:
p45157
aVIf your globals are actually constants, declaring them  and put them in a header should fix the problem:
p45158
aVIf for some reason you cannot do that, declare the globals  etc
p45159
aVin the modules that must reference them
p45160
as(dp45161
g6
V335858
p45162
stp45163
a((dp45164
g2
(lp45165
VYou can remove the loop by observing that the number of hours is Log2(Y/X)
p45166
aVTo calculate Log2(A) using the standard functions, calculate
p45167
aVYou may need to address precision issues when going from s to s, because the calculations will be approximate
p45168
aVThe final expression for the hours may look like this:
p45169
aVGoing from hours to days/hours is very simple, too:
p45170
as(dp45171
g6
V335858
p45172
stp45173
a((dp45174
g2
(lp45175
VThis should work:
p45176
as(dp45177
g6
V335858
p45178
stp45179
a((dp45180
g2
(lp45181
VSince JSON is untyped, the parser tries to figure out what's inside the string
p45182
aVWhen the string looks like a number, say, , JSON gives you back an  object, not an
p45183
aVYou can assign it to  variable, and Objective C compiler would not complain, but the value inside would remain
p45184
aVHere is how you can fix it:
p45185
aVYou can also force it into a string, like this:
p45186
aVEven if  was  before the assignment above, it will be an  after it, regardless of its initial type
p45187
aVHowever, keeping the original type is usually a better approach
p45188
as(dp45189
g6
V335858
p45190
stp45191
a((dp45192
g2
(lp45193
VNot only is the second solution "inelegant and unsatisfactory", it is also undefined behavior
p45194
aVSee the answer to this question for more information on the topic
p45195
aVThe first solution lets you work with negative indexes, because  is equivalent to , so as long as the result points to within the array, you will be fine
p45196
aVA solution to  problem could be built by following the approach taken by the designers of : make a template class that wraps an array, and do your index translation inside its subscript operator
p45197
aVIf this does not work, you can go back to a combination of your original two solutions, but without undefined behavior, like this:
p45198
aVHere is a demo of this approach on ideone
p45199
as(dp45200
g6
V335858
p45201
stp45202
a((dp45203
g2
(lp45204
VTry this change that does not use a collection of s in the query:
p45205
aVThe idea is to avoid passing  objects to the query provider, using IDs instead
p45206
as(dp45207
g6
V335858
p45208
stp45209
a((dp45210
g2
(lp45211
VI overloaded the bracket operators so that  returns a
p45212
aVMake sure that the return type of your  is , not
p45213
aVOtherwise, a copy will be created upon return each time you call , so  will never be reached
p45214
aVIf you invoke  once, the way you do in the first code fragment featuring , the problem will not be visible (although a list will be copied two times - once in the , and once more in the assignment operator)
p45215
aVThe second fragment exposes the problem by calling the  operator multiple times
p45216
as(dp45217
g6
V335858
p45218
stp45219
a((dp45220
g2
(lp45221
VIs there any better solution
p45222
aVNo, the solution that you show is the best (and the only) one
p45223
aVs are pretty simplistic, do not "track" what you've assigned to what
p45224
aVAll they do is letting you reuse the same memory range for all their members
p45225
aVThey do not provide anything else beyond that, so enclosing them in a  and using a "type" field for tracking is precisely the correct thing to do
p45226
as(dp45227
g6
V335858
p45228
stp45229
a((dp45230
g2
(lp45231
VIf you do not want to change the property type to something that allows addition ( or ) add a separate method for adding pictures, like this:
p45232
aVThis would let you keep  as the type of your property, and also allow for validation of what the callers put in
p45233
aVFor example, your code would be able to detect if a photo is too big or too small, and throw an exception
p45234
aVThis would be a lot harder to do if you exposed , because you would need to provide your own implementation that overrides
p45235
aVYou should also make the setter of your auto property private, or replace the auto property with a getter + a backing field
p45236
as(dp45237
g6
V335858
p45238
stp45239
a((dp45240
g2
(lp45241
VThis is the new syntax introduced in Objective C relatively recently
p45242
aVIt is documented at this link
p45243
aVScroll down to Object Subscripting syntax for an explanation:
p45244
aVObjective-C object pointer values can now be used with C\u2019s subscripting operator
p45245
aVYour code fragment translates as
p45246
aVTo support the new syntax described there, the Objective-C @-expression grammar has been introduced
p45247
aVThe -expression is explained at the bottom of the document
p45248
as(dp45249
g6
V335858
p45250
stp45251
a((dp45252
g2
(lp45253
VStatic variables are local to the translation unit, so the variables are definitely not modifiable from anywhere
p45254
aVGlobals, which are closely related to statics in that they are allocated in the same memory area, are modifiable from anywhere, and that's their main danger
p45255
aVWhen you need a group of variables to be accessible from anywhere in your project, the common approach is implementing a singleton that holds related data, and contains methods for processing that data
p45256
aVIn MVC apps implemented in Objective C the model is often accessed through a singleton model object
p45257
aVMy scenario involves a number of static variables declared in the
p45258
aVh file & they are assigned values in specific methods declared in those
p45259
aVh files
p45260
aVIf you declare statics in the header, they become "disconnected" from each other: each translation unit (i
p45261
ag630
aVeach
p45262
aVm file) gets its own set of statics from the header
p45263
aVThis is usually not what you want
p45264
aVIf you make these variables global, you end up with a plain C, not an Objective C, solution
p45265
aVYou should put these variables in a class as properties, and move function implementations with them into the methods of your class
p45266
aVThen make the class a singleton as described in the answer linked above to get a solution that is easier to understand than the corresponding solution based on globals
p45267
as(dp45268
g6
V335858
p45269
stp45270
a((dp45271
g2
(lp45272
VSince there are no parentheses, a trivial approach will work:
p45273
aVGo through the list once to process multiplications and divisions
p45274
aVWhen an operator between X and Y is  or , replace  by  or , and remove Y; also remove the operator
p45275
aVNow go through the list again, this time processing additions and subtractions in sequence
p45276
aVTo implement this approach, define two lists - the list of  s, and  operators, and implement the calculation as follows:
p45277
as(dp45278
g6
V335858
p45279
stp45280
a((dp45281
g2
(lp45282
VTechnically, it does not matter: the declared type of  does not guarantee that calls with objects of other types are impossible
p45283
aVThe fitst style lets you access properties of  with the "dot syntax", while the second style lets you reuse the handler for other UI objects without making your readers wonder what is going on
p45284
aVFor example, if you know that your event handler is used only with buttons, you can declare the type of sender as , and then do this:
p45285
aVWith the second declaration you would have to write this:
p45286
aVOn the other hand, if you plan to reuse the handler for different UI objects, the second approach is preferable
p45287
as(dp45288
g6
V335858
p45289
stp45290
a((dp45291
g2
(lp45292
VFrom what I understand, when parameters are declared in a function like this a value is being passed to them, so they must surely be declared somewhere else to have the value passed in
p45293
aVIn this case, the function is being declared and defined at the same time
p45294
aVPre-ANSI C allowed that
p45295
aVThis is considered a bad practice today
p45296
aVYou should add a forward declaration
p45297
aVabove  in order to avoid declaring the function implicitly
p45298
aVWhen this forward declaration is missing, the first use of the function becomes its implicit declaration
p45299
aVThe compiler takes types of the expression parameters that you pass, and assumes that the function takes corresponding types as its parameters
p45300
aVIt also assumes that the function returns an
p45301
aVIn this case the compiler has all the information necessary to figure out the correct signature, so the function is defined correctly
p45302
aVHowever, in more complex cases (say, if  was declared as , not ) it would lead to undefined behavior, so you should always include a forward declaration of your functions
p45303
as(dp45304
g6
V335858
p45305
stp45306
a((dp45307
g2
(lp45308
VHere is why you cannot do this:
p45309
aVThe problem with the above is that it lets you put a  into , a list of
p45310
as(dp45311
g6
V335858
p45312
stp45313
a((dp45314
g2
(lp45315
VThere's absolutely nothing wrong with your program
p45316
aVThe issue has to do with 's inability to represent decimals precisely, without an error
p45317
aVThe problem is that numbers not composed of negative powers of  must be represented approximately
p45318
aVThat's why there is a small error in the 16-th decimal place
p45319
aVFor more information about representation of s take a look at the article on wikipedia
p45320
aVThis is another great article on the same subject
p45321
aVIf you replace  with , the problem will go away, because  is
p45322
as(dp45323
g6
V335858
p45324
stp45325
a((dp45326
g2
(lp45327
VThis is a positive lookbehind
p45328
aVThe overall expression means "after any character, but without capturing anything"
p45329
aVEssentially, if the string looks like
p45330
aVthen the matches would occur at , between the characters
p45331
as(dp45332
g6
V335858
p45333
stp45334
a((dp45335
g2
(lp45336
VYou are not limited to selection of columns in your select list, you can use expressions
p45337
aVFor example, you can use this:
p45338
as(dp45339
g6
V335858
p45340
stp45341
a((dp45342
g2
(lp45343
VIn C and C++ forward declarations are very weak
p45344
aVThey provide a formal "promise" to the compiler that if a function with a specified signature appears at all, it would have the signature that you specify
p45345
aVThe function is not even guaranteed to appear: unless you call or otherwise reference the declared function, the compiler is not going to complain that there is a declaration with no definition
p45346
aVThe standard requires compilers to treat identical forward declarations as a single declaration
p45347
aVUnlike definitions which must be unique according to the single definition rule
p45348
ag14884
aV2 No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template
p45349
aVdeclarations are merely required to refer to the same definition, i
p45350
ag630
aVbe equivalent to each other:
p45351
ag14884
ag14884
aV4 Given a set of declarations in the same declarative region, each of which specifies the same unqualified name, they shall all refer to the same entity, or all refer to functions or function templates, [
p45352
as(dp45353
g6
V335858
p45354
stp45355
a((dp45356
g2
(lp45357
VThis is a Boolean expression
p45358
aVIts meaning is identical to this conditional expression:
p45359
aVIn case of your , the  column will be incremented each time a  is positive
p45360
as(dp45361
g6
V335858
p45362
stp45363
a((dp45364
g2
(lp45365
VIn order to use property syntax with dot, you need to provide the compiler with the exact type, for example by casting the  pointer to the type of your class
p45366
aVIf you do not want to use the exact type or cast, use method call syntax:
p45367
as(dp45368
g6
V335858
p45369
stp45370
a((dp45371
g2
(lp45372
VThe problem is that your  forward-declares these two functions
p45373
aVwithout providing any implementation for them
p45374
aVHowever, it looks like you were trying to reference existing functions of the  class:
p45375
aVIf you want to call member functions of , you need to call them using the member syntax if the function is non-static (i
p45376
ag630
aVneeds to reference non-static member variables), or use  if the corresponding function is static
p45377
aVIn either case, you need to remove the forward declarations of the functions that you inserted in , and replace them with an inclusion of the header that declares the  class
p45378
as(dp45379
g6
V335858
p45380
stp45381
a((dp45382
g2
(lp45383
VWith ten items per list, nobody cares about ten allocations of the enumerator saved by the call of
p45384
aVThis is definitely a micro-optimization, even though the second approach does save you some allocations
p45385
aVI would definitely go for more readability of the first approach, or even add some LINQ, like this:
p45386
as(dp45387
g6
V335858
p45388
stp45389
a((dp45390
g2
(lp45391
VMy guess is that the compiler takes its clues from your actions, and decides that since you find it important to provide an alternative implementation of the equality operator, then you probably want the object equality to remain consistent with your new implementation of
p45392
aVAfter all, you do not want the two equality comparisons to mean drastically different things, otherwise your program would be hard to understand even on a very basic level
p45393
aVTherefore, the compiler thinks that you should redefine  as well
p45394
aVOnce you provide an alternative implementation , however, you need to modify  to stay consistent with the equality implementation
p45395
aVHence the compiler warns you that your implementation might be incomplete, and suggests overriding both  and
p45396
as(dp45397
g6
V335858
p45398
stp45399
a((dp45400
g2
(lp45401
VThe problem is that there are a lot of primes under 2M
p45402
aVThe sum of all primes under 2M is equal to 142,913,828,922, which overflows the 32-bit
p45403
aVSwitching to 64 bit integers should fix the precision issue
p45404
aVIt wouldn't fix the performance issue, though
p45405
aVThe first thing you need to do is improving your stopping condition: once you go past the square root of the candidate prime, you know there's going to be no additional divisors, because if there were, you'd find the result of the division among the numbers smaller than or equal to the square root of the candidate prime
p45406
aVThe next thing is to store the primes that you've found so far, and use only them to test the next candidate
p45407
aVFinally, using a sieve of Eratosthenes could give your program additional performance boost
p45408
as(dp45409
g6
V335858
p45410
stp45411
a((dp45412
g2
(lp45413
VIn C++11 you can use  instead of calling  or  ten times
p45414
aVTo go forward, pass positive ; to go backward, pass a negative :
p45415
as(dp45416
g6
V335858
p45417
stp45418
a((dp45419
g2
(lp45420
VIf you insist on using the "elementary school addition", find the length of both strings, advance to their ends, and then move back until the shorter string's length is exhausted
p45421
aVThen continue moving in only the longer string, assuming that the remaining digits of the shorter string are zeros:
p45422
aVYou need to move all the way to the beginning of the longer string, and process the carry there
p45423
aVNote that you need to allocate a new result anyway, because adding two -digit numbers may result in a -digit number due to the carry
p45424
as(dp45425
g6
V335858
p45426
stp45427
a((dp45428
g2
(lp45429
VOne consequence of using a non-reentrant function basename that returns a string is that your subsequent invocations invalidate the prior results
p45430
aVYou need to make a copy of the return value before making a second call, or stop using the old value after the second call has returned
p45431
aVThis is because basename has only one internal buffer to store its result, assuming that it does not modify its parameter ( which looks to be the case with your program, because it does not crash on a string literal; still, it's undefined behavior)
p45432
aVModify your program as follows to make it portable:
p45433
as(dp45434
g6
V335858
p45435
stp45436
a((dp45437
g2
(lp45438
VYou can do a search with an  operators or an equivalent  expression, group the rows by the item column, and compare row counts
p45439
aVThe row with the highest count has the highest number of keywords from your search list:
p45440
aVTo deal with lots of keywords without exposing your code to SQL injection you need to either generate your SQL dynamically, or use table-valued parameters
p45441
aVIf you take the first approach, the  expression becomes  up to the number of tags in your search string
p45442
aVCreate a SQL command, and add individual tags as parameters
p45443
aVSee this answer for more details on the dynamic query approach
p45444
aVIf the list of tags grows significantly, an alternative approach with a table-valued parameter could improve performance of your query
p45445
aVThis answer explains how to do that
p45446
as(dp45447
g6
V335858
p45448
stp45449
a((dp45450
g2
(lp45451
VSince the formal arguments of your member function for  and  are references, while   and  are pointers, you need to dereference pointers to make them compatible with references:
p45452
aVAlternatively, you can change the signature of the constructor to accept pointers instead of references:
p45453
as(dp45454
g6
V335858
p45455
stp45456
a((dp45457
g2
(lp45458
VAbsolutely -- the address operator is required, otherwise you get a compile-time error:
p45459
as(dp45460
g6
V335858
p45461
stp45462
a((dp45463
g2
(lp45464
VI'm trying to use a conditional statement that does one thing in one condition but does two things if the other condition applies
p45465
aVThat's not a conditional statement, it's a conditional expression+
p45466
aVConditional statement would be a lot more appropriate here from the readability perspective:
p45467
aV+ C++ follows C in allowing use of standalone expressions as statements
p45468
aVThat's why you can eventually "shoehorn" your solution into the right syntax by using parentheses and switching the order of operations
p45469
aVThe readability of that solution suffers a lot compared to that of a plain, familiar
p45470
as(dp45471
g6
V335858
p45472
stp45473
a((dp45474
g2
(lp45475
VYes, you should declare them without asterisks:
p45476
aVAsterisks indicate pointers
p45477
aVAll Objective C classes are declared with asterisks, because instances are referred to through pointers
p45478
aVPrimitives such as floats, ints, etc
p45479
aVare defined as values, i
p45480
ag630
aVwithout asterisks
p45481
aVSame goes for typedef-ed types such as CGFloat and NSInteger: scalar fields of these types should be defined without an asterisk
p45482
as(dp45483
g6
V335858
p45484
stp45485
a((dp45486
g2
(lp45487
VEither BFS or DFS would do fine: you need to traverse the entire subgraph from your starting vertex before potentially declaring some of its nodes unreachable, so it does not matter in what order you discover the nodes that you can reach
p45488
aVSince it is not a big graph, the recursive DFS should not present a problem, because even if the graph is actually a list, 200 nodes should not be nearly enough to threaten a stack overflow
p45489
as(dp45490
g6
V335858
p45491
stp45492
a((dp45493
g2
(lp45494
VThe reason you are not getting a class cast exception is that Java generics are implemented through type erasure
p45495
aVUnlike
p45496
aVNET generics that required significant changes to CLS, Java generics are processed entirely in compile-time
p45497
aVAt runtime, the cast to  is ignored
p45498
aVIn order to check type at runtime, you need to store , and use its methods to check the type of a parameter passed in:
p45499
as(dp45500
g6
V335858
p45501
stp45502
a((dp45503
g2
(lp45504
VThe first style, with a local , is superior, mostly for its readability: the readers of your code will not have to guess (or read the documentation) if  returns the same instance on multiple calls, and be sure that you are making the calls on exactly the same instance
p45505
aVThe performance may or may not be an issue, depending on the implementation of
p45506
aVThe first usage style (with the ) will be at least as fast as the second one, though
p45507
as(dp45508
g6
V335858
p45509
stp45510
a((dp45511
g2
(lp45512
VReading from uninitialized memory is undefined behavior
p45513
aVVariables are not initialized by default, so  can take any value until you assign it
p45514
aVSince the behavior is undefined, the program could run on some machines, and crash on others
p45515
aVMoreover, even initializing the  to zero does not fix undefined behavior, because  remains uninitialized
p45516
aVThis means that the program may not stop upon reaching the end of the array, and access values past the end of the allocated region
p45517
aVOf course in order to do that all values in the array of 1024 items must be non-zero, so the odds are in favor of stopping before reaching the end of the array
p45518
aVHowever, in order to fix this undefined behavior you need to check the index before accessing values
p45519
as(dp45520
g6
V335858
p45521
stp45522
a((dp45523
g2
(lp45524
VA mutex could be implemented via a simple
p45525
aVIt does not look like a possibility, considering that  is a required operation, and  is most likely a non-locking kind
p45526
aVYou could put a  loop around the  call, but that is not the same as , because it wastes the CPU during the entire waiting period
p45527
aVIn general,  is a lot more complex than a simple  with defined multithreaded behavior, explaining its rather larger size, which depends on the compiler: for example, on ideone the  is 24
p45528
as(dp45529
g6
V335858
p45530
stp45531
a((dp45532
g2
(lp45533
VCorrect, both static and instance members of reference type not explicitly initialized are set to  by Java
p45534
aVThe same rule applies to array members
p45535
aVFrom the Java Language Specification, section 4
p45536
aV12
p45537
aV5:
p45538
aVInitial Values of Variables
p45539
aVEvery variable in a program must have a value before its value is used:
p45540
aVEach class variable, instance variable, or array component is initialized with a
p45541
aVdefault value when it is created
p45542
ag9057
aVFor all reference types, the default value is
p45543
aVNote that the above rule excludes local variables: they must be initialized explicitly, otherwise the program will not compile
p45544
as(dp45545
g6
V335858
p45546
stp45547
a((dp45548
g2
(lp45549
VYou do not need to read the number of elements twice, and the type of the  should be , not
p45550
aVUnfortunately, this wouldn't tell you the number of items in the array, so you need to get it from the , for example, like this:
p45551
aVThis is not an optimal C++ solution, though: you would be much better off using  instead of an array, because the vector grows dynamically, and its size is returned along with the container itself
p45552
aVThere would be no need to  the result either, which would significantly simplify your code:
p45553
as(dp45554
g6
V335858
p45555
stp45556
a((dp45557
g2
(lp45558
VStatic variables go into the same segment as global variables
p45559
aVThe only thing that's different between the two is that the compiler "hides" all static variables from the linker: only the names of extern (global) variables get exposed
p45560
aVThat is how compilers allow static variables with the same name to exist in different translation units
p45561
aVNames of static variables remain known during the compilation phase, but then their data is placed into the  segment anonymously
p45562
as(dp45563
g6
V335858
p45564
stp45565
a((dp45566
g2
(lp45567
VYou can use the usual way of comparing  for proximity by calculating the absolute difference, and comparing it to a small value:
p45568
aVFor example, you can use this approach in a LINQ query like this:
p45569
as(dp45570
g6
V335858
p45571
stp45572
a((dp45573
g2
(lp45574
VIf you would like to make sure that your search string is an isolated substring, not a prefix or a suffix of a larger substring, you can use regular expressions
p45575
aVFor example, to see if a string contains  but not  or , you can do this:
p45576
aVHere is an example:
p45577
aVHere is a demo on ideone
p45578
aVRegex is versatile enough to let you adjust the expression to your needs: you can use positive and negative lookahead/lookbehind
p45579
aVFor example, if you need to make sure that  is not followed by another digit, you can write
p45580
as(dp45581
g6
V335858
p45582
stp45583
a((dp45584
g2
(lp45585
VYou can always get the last element by using  or , like this:
p45586
as(dp45587
g6
V335858
p45588
stp45589
a((dp45590
g2
(lp45591
VTo terminate recursion early, you need to pass some sort of a signal up the invocation chain
p45592
aVIn your case, you can change the return type to , and return  to indicate that the search has terminated, and no further processing is needed:
p45593
aVNote that in the above code the recursive invocations go on only while the prior invocations continue returning
p45594
aVThe first  returned from an invocation is sent up the invocation chain, causing the entire call chain to terminate
p45595
as(dp45596
g6
V335858
p45597
stp45598
a((dp45599
g2
(lp45600
VThe "Effective Java" book has been written well before the introduction of s into the language, so I would recommend using the  feature instead
p45601
aVFortunately, Java s are very versatile, so you can follow Joshua's advice pretty closely using the  feature:
p45602
as(dp45603
g6
V335858
p45604
stp45605
a((dp45606
g2
(lp45607
VYou can fold all this into a single statement using :
p45608
as(dp45609
g6
V335858
p45610
stp45611
a((dp45612
g2
(lp45613
VThe prototype cell is set to have the image and the labels
p45614
aVSo I am not sure how to add the "View More" Row in the end
p45615
aVYou are not limited to a single prototype cell per table
p45616
aVAdd a custom cell for the "View More" cell, then add some code to your  method to pick the "main" prototype for the top cells, and the "view more" prototype for the last cell
p45617
aVAm I right in using dynamic prototypes ( I have it working pretty much) or is static cells the right choice
p45618
aVYes, this is the right choice
p45619
as(dp45620
g6
V335858
p45621
stp45622
a((dp45623
g2
(lp45624
VThe reason your expression does not work as expected is that your expression captures the character preceding the  sign, making it part of the replacement target
p45625
aVYou need to change  with  to use the non-capturing negative lookbehind
p45626
aVThe final expression should look like this:
p45627
as(dp45628
g6
V335858
p45629
stp45630
a((dp45631
g2
(lp45632
VYou need to use a method that takes  because it's called by pthread library, and pthread library passes your method a  - the same pointer that you pass  as the last parameter
p45633
aVHere is an example of how you can pass arbitrary parameters to a thread using a single :
p45634
aVEven though your function does not want to take any arguments or return anything, since pthread library passes it parameters and collects its return value, your function needs to have the appropriate signature
p45635
aVPassing a pointer to a  function that takes no parameters in place of a  function that takes one parameter would be undefined behavior
p45636
as(dp45637
g6
V335858
p45638
stp45639
a((dp45640
g2
(lp45641
VThis is a simple  query on a pair of ed tables:
p45642
as(dp45643
g6
V335858
p45644
stp45645
a((dp45646
g2
(lp45647
VThe elements are returned to you in the sorted order only on dequeueing them
p45648
aVWhen you iterate the queue without dequeueing, the order is internal to the implementation of the priority queue
p45649
aVReplacing the loop with the code below gives you the data in the correct order:
p45650
aVSince dequeueing is guaranteed to happen in the correct order, this produces the following output:
p45651
aVHere is a demo on ideone
p45652
as(dp45653
g6
V335858
p45654
stp45655
a((dp45656
g2
(lp45657
VHere is one possibility: inherit from one of the classes (say, ), and embed the other (say, )
p45658
aVImplement the interface of   bu forwarding all calls to the embedded object
p45659
aVAnother possibility is to use two interfaces, and share implementation through extension methods
p45660
as(dp45661
g6
V335858
p45662
stp45663
a((dp45664
g2
(lp45665
VWhat is up with the assigning a default length outside the parenthesis and the rest inside the curly braces
p45666
aVThis is very common and desirable
p45667
aVThe construct is called initialization list
p45668
aVFor example, this
p45669
aVcan be rewritten as this:
p45670
aVUsing this construct instructs the compiler to use copy constructors for items being copied, rather than using default constructors followed by assignment operators
p45671
aVIn case of assigning primitives it hardly matters, but with more complex types initialization lists could save you some CPU cycles
p45672
aVThe reason the author did not put the  and  assignments into the initialization list is to force a particular order of initialization where it matters
p45673
aVThe assignment to  must happen before the assignment to
p45674
aVWhen you use initialization lists, the order of assignments is not controlled by the order of items in the list: instead, it is controlled by the relative order of declaration of the corresponding members in the class
p45675
aVRelying upon it is very confusing to the reader and too fragile to remain in production, so the author correctly decided to move the two assignments into the body of the constructor
p45676
as(dp45677
g6
V335858
p45678
stp45679
a((dp45680
g2
(lp45681
VAbsolutely: since static methods do not need an instance reference, they can be called from both contexts
p45682
aVOnly instance methods have a restriction on being called on an object, because they implicitly take the object as an additional argument
p45683
as(dp45684
g6
V335858
p45685
stp45686
a((dp45687
g2
(lp45688
VThe double hash  is a token pasting operator of the preprocessor
p45689
aVThe  will be re-written like this:
p45690
aVThe double-number-sign or "token-pasting" operator (##), which is sometimes called the "merging" operator, is used in both object-like and function-like macros
p45691
aVIt permits separate tokens to be joined into a single token and therefore cannot be the first or last token in the macro definition
p45692
as(dp45693
g6
V335858
p45694
stp45695
a((dp45696
g2
(lp45697
VThe  of the "sub" view controller is not the , it's the navigation controller
p45698
aVThe  is not accessible - for all you know, it may be deallocated to save memory
p45699
aVIf you need to pass data from the main controller to the sub controller on the segue, add an instance variable to the "sub" view controller, and set it in the prepareForSegue method:
p45700
as(dp45701
g6
V335858
p45702
stp45703
a((dp45704
g2
(lp45705
VUnfortunately, this is not possible: at the time when you catch the exception in the handler, all the stack frames with the method parameters are gone
p45706
aVOnce the control leaves your function, you can no longer access its parameter values
p45707
aVSince you know the specific function where the crash happens, you could set up an exception handler there to collect all the parameters of interest, and re-throw a wrapped exception
p45708
aVOnce the diagnostics is complete, you could revert the code back to normal:
p45709
as(dp45710
g6
V335858
p45711
stp45712
a((dp45713
g2
(lp45714
VMy best guess is that you are allowed to return  so that you could do this:
p45715
aVIf you could declare  only as , then your callers would be forced to replace  with : otherwise, the code would not compile
p45716
aVSame goes for a use case without :
p45717
aVwithout  return type you would have to do an intermediate assignment, or use a cast to
p45718
as(dp45719
g6
V335858
p45720
stp45721
a((dp45722
g2
(lp45723
VCase label needs to be an integer constant, not an integer expression
p45724
aVAlthough the expression  can be evaluated at compile time to , the compiler is not required to do so
p45725
aVC99 standard, section 6
p45726
ag20244
ag14885
aV2, part 3:
p45727
aVThe expression of each case label shall be an integer constant expression and no two of the case constant expressions in the same switch statement shall have the same value after conversion
p45728
as(dp45729
g6
V335858
p45730
stp45731
a((dp45732
g2
(lp45733
VThere is nothing in the standard libraries to compute the distance between words, but there are plenty of examples you can find on the internet: look up "edit distance" or "Levenshtein distance"
p45734
aVThe idea is to measure the similarity in terms of the number of changes to the first string in order to make it a second string
p45735
aVThe distance between "heil" and "hello" is 2, because you need to replace "i" with "l" (first edit), and then append an "o" (the second edit)
p45736
aVWhen looking for an implementation or implementing your own, avoid the trivial implementation with a 2D array, because it's not memory-efficient
p45737
aVUse the modification with  memory requirements instead of the "naive"
p45738
as(dp45739
g6
V335858
p45740
stp45741
a((dp45742
g2
(lp45743
VWhen the type is known only at runtime, you cannot use it in a generic without using reflection
p45744
aVHowever, your task is simpler than that - you can use type equality to achieve the results that you want:
p45745
as(dp45746
g6
V335858
p45747
stp45748
a((dp45749
g2
(lp45750
VThe conversion is almost certainly outside the LINQ statement: if sum is an int, that's where an explicit cast would be needed
p45751
aVDeclaring sum as decimal or inserting an explicit cast would fix the problem:
p45752
aVHere is a link to a quick demo on ideone (it's not possible to use HTML agility pack on ideone, so I copied your data into an array of strings)
p45753
as(dp45754
g6
V335858
p45755
stp45756
a((dp45757
g2
(lp45758
VThe istringstream takes a string, and a string can be made from two char iterators, like this:
p45759
as(dp45760
g6
V335858
p45761
stp45762
a((dp45763
g2
(lp45764
VObjective C standard is based on the C standard
p45765
aVC standard explicitly prohibits a  that returns
p45766
aVOnly these two signatures are allowed:
p45767
aVIn order to comply with this standard, the  must be declared as returning an integer
p45768
aVThe return value does not matter, but it must be present (C99 standard allows omitting the  statement in )
p45769
aVSince  never returns, the following would be valid as well:
p45770
as(dp45771
g6
V335858
p45772
stp45773
a((dp45774
g2
(lp45775
V[] is considered a variable
p45776
aVRight
p45777
aVis an array variable
p45778
aVThe array has two elements with the values that you provided in the initializer
p45779
aV[] is a method
p45780
aVCorrect
p45781
aVCorrect
p45782
aVI've never used [] and {} setting a variable and don't understand what's going on here
p45783
aVThe  after a variable's name indicates that the variable is an array with the number of items provided through the initializer
p45784
aVThe  encloses the initializer values
p45785
aVThe number of array elements will equal the number of values that you supply in the initializer
p45786
aVYou can force a different number of elements by specifying the size explicitly, e
p45787
ag303
aVin the above case the array will be extended with a third element, even though there are only three values in the initializer
p45788
as(dp45789
g6
V335858
p45790
stp45791
a((dp45792
g2
(lp45793
VThe compiler is confused, because  matches both overloads
p45794
aVYou can explicitly cast  to the class that you need to let the compiler know which of the two overloads you are calling:
p45795
as(dp45796
g6
V335858
p45797
stp45798
a((dp45799
g2
(lp45800
VThe console is slow because of the need to scroll the text up the screen
p45801
aVEvery time you write another line to the console, the image of the current content needs to scroll up - an operation that requires a lot of copying to animate smooth scrolling
p45802
aVThat is why there's a slowdown
p45803
aVYou can speed the process up by hiding the console window: the implementation is smart enough to not waste its time on scrolling
p45804
aVAnother trick is reducing the height of the console to fewer lines: the text starts scrolling a lot faster, because less information needs to be copied
p45805
as(dp45806
g6
V335858
p45807
stp45808
a((dp45809
g2
(lp45810
VWhen I am clearing the list object ObjList its clearing the values of dictionary in which I have already added values as a list
p45811
aVThis is because you keep adding the same instance
p45812
aVReplace
p45813
aVwith
p45814
aVto fix the problem
p45815
as(dp45816
g6
V335858
p45817
stp45818
a((dp45819
g2
(lp45820
VYou can use a modified version of C++ branchless signum function for this:
p45821
aVThe expression
p45822
aVevaluates to  when  is less than zero, to  when  is greater than or equal to zero
p45823
as(dp45824
g6
V335858
p45825
stp45826
a((dp45827
g2
(lp45828
VThe  operator lets you treat  and  as 32- and 64-bit unsigned integral types, which are missing from the Java language
p45829
aVThis is useful when you shift something that does not represent a numeric value
p45830
aVFor example, you could represent a black and white bit map image using 32-bit s, where each  encodes 32 pixels on the screen
p45831
aVIf you need to scroll the image to the right, you would prefer the bits on the left of an  to become zeros, so that you could easily put the bits from the adjacent s:
p45832
aVThe code above does not pay attention to the content of the upper three bits, because  operator makes them
p45833
aVThere is no corresponding  operator because left-shift operations on signed and unsigned data types are identical
p45834
as(dp45835
g6
V335858
p45836
stp45837
a((dp45838
g2
(lp45839
VThis happens because  is generally an unordered container*
p45840
aVWhen you put the data into , it becomes unordered again
p45841
aVTo retain the desired order, you need to put the results into a container that explicitly keeps the ordering that you supply
p45842
aVFor example, you could use a list of , like this:
p45843
aV* Due to the way the  is implemented by Microsoft, it happens to retain the insertion order, but that is incidental and undocumented, so it may change in the future versions, and should not be relied upon
p45844
as(dp45845
g6
V335858
p45846
stp45847
a((dp45848
g2
(lp45849
VYes, that's
p45850
aVPair up the iterations of the inner loop in the beginning and at the end of the outer loop, like this:
p45851
aVThe inner loop will execute
p45852
aVtimes on the first iteration of the outer loop, and  time on the last iteration
p45853
aVtimes on the second iteration of the outer loop, and  times on the second to last iteration
p45854
aVtimes on the third iteration of the outer loop, and  times on the third to last iteration
p45855
aVand so on; you will have  pairs like that; when  is odd, the last pair is incomplete
p45856
aVYou can see that each of the pairs executes a total of  times, and you have  such pairs, for a total of  times
p45857
aVThe way the formula is derived comes from the derivation of the formula for the sum of arithmetic progression with the common difference of
p45858
as(dp45859
g6
V335858
p45860
stp45861
a((dp45862
g2
(lp45863
VThe exceptions that you listed are in two different categories - these indicating a coding error, and these indicating a run-time issue
p45864
aVYou are absolutely right that the exceptions in the first category are preventable: you can write code in such a way that they never happen
p45865
aVFor example, if your code -checks the path, you are in no danger of ever getting  in the call of
p45866
aVLet's analyse the remaining exceptions one by one:
p45867
aV, ,  - all three will be caught if you catch
p45868
aV- should be caught separately
p45869
aV- can be prevented by validating the path before making the call
p45870
aV- can be prevented by checking permissions before making the call
p45871
aVIn the end, you can cover all exceptions that indicate run-time issues by catching  and , and preventing the rest of the exceptions from happening by pre-validating the parameters you plan to pass and examining the run-time environment of your code
p45872
as(dp45873
g6
V335858
p45874
stp45875
a((dp45876
g2
(lp45877
VYou cannot request a presence of an attribute statically (i
p45878
ag630
aVat compile time), but inside the code your generic type you can examine  as if it were an actual type name
p45879
aVFor example, you can request its , and pull attributes from it:
p45880
aVNote that I put the check in a static constructor
p45881
aVThis would execute once before any other code that uses  for each particular type
p45882
as(dp45883
g6
V335858
p45884
stp45885
a((dp45886
g2
(lp45887
VThe error is in your , where you pass an uninitialized pointer to
p45888
aVYou should make it point to something, like this:
p45889
aVor
p45890
aVMoreover, you do not need to use  with s - an assignment will work as well:
p45891
as(dp45892
g6
V335858
p45893
stp45894
a((dp45895
g2
(lp45896
VYou can do it like this:
p45897
aVThis would ensure that
p45898
aVThere is at least one digit
p45899
aVThat multi-digit numbers start in a digit other than zero
p45900
aVThat the only allowed three-digit number is 100
p45901
as(dp45902
g6
V335858
p45903
stp45904
a((dp45905
g2
(lp45906
VThis is probably a learning assignment, so I will not write any code
p45907
aVSince you are looking for the first five items, sorting the list may prove too expensive, especially when the list is very long
p45908
aVInstead, you can walk the list, and pick the top five elements
p45909
aVSeed your five-element "top list" with the initial five elements of the original list, then sort the top list
p45910
aVSince its size is fixed, sorting its five elements is
p45911
aVNow walk the remaining  elements of the original list, comparing each item to the smallest element of the sorted "top list"
p45912
aVIf you see a value that's bigger than the smallest item of the top five list, replace one of the top items with the current item, and let the smallest item "fall off" the end of the list
p45913
aVThis whole process is , which may be a significant improvement over a sorting solution, which is
p45914
as(dp45915
g6
V335858
p45916
stp45917
a((dp45918
g2
(lp45919
VWhen the step of the loop depends on  in such a way that the loop ends in  time, we say that the loop ends in
p45920
aVFor example, if the loop divides the input by a factor of , and ignores one of the halves on subsequent iterations, the complexity is said to be
p45921
aVThe classic example of this is the binary search algorithm: each step of the loop discards one half of the remaining input
p45922
aVTherefore, running the loop for  steps covers  input size
p45923
aVAnother way of saying it is that , where  means the logarithm with the base equal to
p45924
as(dp45925
g6
V335858
p45926
stp45927
a((dp45928
g2
(lp45929
VPut buttons into , assign each button a unique  value, and then use the tag to look up the argument in an  that mapps the tag to the parameter
p45930
aVHere is an example:
p45931
aVThe button with the tag zero will get the argument ; the button with the tag  will get , and so on
p45932
as(dp45933
g6
V335858
p45934
stp45935
a((dp45936
g2
(lp45937
VYou are missing a closing doublequote in the line below:
p45938
aVYou also need to remove semicolons after  and
p45939
as(dp45940
g6
V335858
p45941
stp45942
a((dp45943
g2
(lp45944
VNo,  is not a placeholder for a function, it is a token pasting operator
p45945
aVIt is valid only inside preprocessor macros (with or without parameters)
p45946
aVIt produces a concatenation of its left and right sides
p45947
aVFor example, if you pass  a value of
p45948
aVthe result produced by the preprocessor would be equivalent to writing
p45949
aVThe idea behind these macros is to make signed and unsigned constants stand out in the code a little more: a value that looks like  may be a little more readable than the equivalent
p45950
aVIt is definitely a big improvement over its other equivalent , which looks like a completely different number
p45951
as(dp45952
g6
V335858
p45953
stp45954
a((dp45955
g2
(lp45956
VAbsolutely, it is safe to use ARC alongside the compiled non-ARC code
p45957
aVThe compiler is smart enough to insert the retains and releases where necessary
p45958
aVIf other libraries are given to you as source code, you can disable ARC just for these files by adding the  compiler flag, and it is going to work together with your ARC-enabled code
p45959
aVYou can add this flag in the target's build phases
p45960
as(dp45961
g6
V335858
p45962
stp45963
a((dp45964
g2
(lp45965
VThere is no way to handle this elegantly:  takes over the control in Java, letting you do whatever you want, even return normally from a  block that threw an exception
p45966
aVIf you must handle the inner exception, you need to write a lot of potentially fragile code for it:
p45967
aVYour best solution is not to write code like that
p45968
as(dp45969
g6
V335858
p45970
stp45971
a((dp45972
g2
(lp45973
VYour code does not work because it tries using a 32-bit  to hold a number that exceeds the highest value in a 32-bit variable
p45974
aVThe answer to the problem is , which needs 38 bits
p45975
aVChanging the data type of  to  should fix this problem
p45976
as(dp45977
g6
V335858
p45978
stp45979
a((dp45980
g2
(lp45981
VDefine a protected virtual function in the base class
p45982
aVMake it pure virtual to ensure that each subclass  provides an implementation
p45983
aVThe function will know the target of the cast, because it belongs to a
p45984
aVCall that function from the operator  in the base class, and let it perform the comparison, like this:
p45985
aVThe effect of this construct is making the implementation of the  operator virtual
p45986
as(dp45987
g6
V335858
p45988
stp45989
a((dp45990
g2
(lp45991
VYou can do this:
p45992
aVThis would replace the entire array, not its individual elements
p45993
aVIf you need to replace individual elements, use a  loop instead
p45994
as(dp45995
g6
V335858
p45996
stp45997
a((dp45998
g2
(lp45999
VLet's say you have an array of data, and you would like to find its median:
p46000
aVCreate an array of indexes, and initialize each index to its own position, like this:
p46001
aVNow implement the linear median algorithm with the following changes:
p46002
aVWhen the original algorithm compares  to , replace with a comparison of  to
p46003
aVWhen the original algorithm swaps  and , swap  and  instead
p46004
aVSince the elements of  remain in their place all the time, the modified algorithm will produce the position of the median in the unmodified array, rather than its position in the array with some elements moved to different spots
p46005
aVIn C++ you can implement this with pointers instead of indexes, and use  on the container of pointers, like this:
p46006
aVHere is a link to a demo on ideone
p46007
as(dp46008
g6
V335858
p46009
stp46010
a((dp46011
g2
(lp46012
VYour point about using types from the  header of C99 is absolutely valid: these types give you more control over the size of your integral types
p46013
aVThe -prefixed integral types, however, predate the standardization of , hence introducing a parallel set of abstractions
p46014
aVI use -prefixed integral types when interacting with Cocoa methods
p46015
aVFor example, if Cocoa method returns , I declare my variable using  type as well
p46016
aVI use  types for variables in my program when I need precise control over the size of the stored data
p46017
aVItems that end up in Core Data are in this category
p46018
aVWhen the size of an integral type does not matter, for example, when I need a loop control variable in a  loop, I use
p46019
as(dp46020
g6
V335858
p46021
stp46022
a((dp46023
g2
(lp46024
VThe second trick should indeed work with minor modifications
p46025
aVSee comments in the code for explanation of what needs to change:
p46026
aVA better approach to tokenizing sequences of numbers is , which helps you advance the pointer after reading the next integer:
p46027
as(dp46028
g6
V335858
p46029
stp46030
a((dp46031
g2
(lp46032
VThis is definitely a case of premature optimization: 32K characters is not a big deal for finely tuned regex engines running on modern computers, so this optimization task is mostly theoretical
p46033
aVBefore discussing the performance, it's worth pointing out that the expressions are probably not doing what you want, because they allow  characters into the output
p46034
aVYou need to use  and  instead
p46035
aVThe speed of the two regexes will be identical, because the number of characters in a character class hardly makes a difference
p46036
aVHowever, the second combination  call will be called on a potentially shorter string, because all invalid characters will be removed
p46037
aVTherefore, the second option is potentially slightly faster
p46038
aVHowever, if you must optimize this to the last CPU cycle, you can rewrite this without regular expressions to avoid a memory allocation in the : walk through the input string in a loop, and add all valid characters to  as you go
p46039
aVWhen you see a lowercase character, convert it to upper case
p46040
as(dp46041
g6
V335858
p46042
stp46043
a((dp46044
g2
(lp46045
VIt's  only when you do not do additional allocations
p46046
aVHowever, if you allocated the arrays inside the array of arrays, you need to delete them as well:
p46047
as(dp46048
g6
V335858
p46049
stp46050
a((dp46051
g2
(lp46052
VYou define methods in protocols so that your code could call methods implemented by others
p46053
aVThe "contract" between you and developers implementing your protocol looks like this:
p46054
aVYou define the protocol,
p46055
aVSomeone else implements your protocol,
p46056
aVSomeone else creates an object implementing your protocol, and gives it to you, so
p46057
aVYou can call methods of your protocol without knowing their implementation
p46058
aVIn order to call methods of your protocol, you need to have an instance of an object implementing it
p46059
aVThe whole point of defining protocols is removing from your code any knowledge about the class implementing your protocol: if you know which class you are going to get, you might as well skip the protocol, and program to the class directly
p46060
aVHowever, if you want to call your , you have to either know the class, or someone else must pass you an -ed object on which the  has not been called yet
p46061
aVNeither alternative is a good idea - the first one kills the purpose of having protocols, and the second forces your callers deal in partially initialized objects
p46062
aVNote that it does not prevent you from having non- configuration methods in a protocol: if all objects must be configured using certain bits of information, let your users implement whatever  that they want, and add a  method to your protocol, letting you control the process of configuring the object without knowing about its  method
p46063
as(dp46064
g6
V335858
p46065
stp46066
a((dp46067
g2
(lp46068
VYou can get all public properties of each object like this:
p46069
aVHere is a demo on ideone
p46070
aVproduces a list of all public properties of your class
p46071
aVYou can examine the names and the types of these properties using the  variable
p46072
aVYou can also get and set the properties themselves by calling
p46073
as(dp46074
g6
V335858
p46075
stp46076
a((dp46077
g2
(lp46078
VIf the structure of the query form remains the same, you can build a single large condition that ignores restrictions on fields that have not been set:
p46079
as(dp46080
g6
V335858
p46081
stp46082
a((dp46083
g2
(lp46084
VThe problem with your code is that it keeps reusing the same instance of the array  on each level of invocation, rather than making a copy
p46085
aVIf you change the code to
p46086
aVyour code should produce the results that you want (demo on ideone)
p46087
aVHowever, you would be better off iterating all integers from  to , and printing their binary representations:
p46088
aVHere is a demo of iterative method on ideone
p46089
as(dp46090
g6
V335858
p46091
stp46092
a((dp46093
g2
(lp46094
VThe two storage techniques serve different purposes
p46095
aVThe first technique is useful with "homogenous" vectors, where you do not need polymorphic behavior, and object slicing is not an issue
p46096
aVYou get automated resource management in return: you do not need to worry about the ownership of your objects, because the vector makes a copy
p46097
aVA copy is also made internally every time your vector is resized
p46098
aVThis consideration makes the first option less attractive when copying the object is somewhat expensive; you need to profile your code to see if this consideration applies to it
p46099
aVThe second technique puts the responsibility for managing the memory on you: every time you decide to remove an object from your vector of pointers, you need to take the ownership, and eventually  the object explicitly
p46100
aVYou can use smart pointers to address the resource management issue
p46101
aVThis technique lets you avoid copying, but the process of accessing elements inside the container becomes slightly more involved
p46102
as(dp46103
g6
V335858
p46104
stp46105
a((dp46106
g2
(lp46107
VString begins another string is another way of saying that a string is a prefix of another string
p46108
aVHere is an example:  is a prefix of
p46109
aVThe check algorithm is relatively straightforward: start comparing strings character by character, until either (1) the candidate prefix string ends, or (2) you find a difference
p46110
aVIf prefix ends before you find a difference, return ; otherwise, return :
p46111
aVTesting this function should check the two "mainstream" cases (i
p46112
ag630
aVwhen  is a prefix of , and when  is not a prefix of ) and several "corner cases":
p46113
aVThe first string is empty - return , because an empty string is a prefix of any string
p46114
aVThe second string is empty - return  when the first string is also empty, or  otherwise
p46115
aVThe first string is longer than the second string - return  even if you see a full match between the shorter second string and the longer "prefix"
p46116
as(dp46117
g6
V335858
p46118
stp46119
a((dp46120
g2
(lp46121
VYou do not need an array of view controllers
p46122
aVAll you need is one view controller, which gets instantiated when the user clicks the cell to navigate to it, and gets deallocated as soon as the user closes the screen to go back to your main view controller
p46123
aVAll you need to implement this in your storyboard is adding a push segue from a cell or a button in your main view controller to your "detail" view controller
p46124
aVWhen the segue gets triggerred, your code gets a chance to configure the newly created "detail" view controller in the  method, before the controller's view appears on the screen
p46125
aVThis is the place where you customize the data that shows up in the detail view (presumably, depending on the particular row in the table that has triggered the segue)
p46126
aVHere is a link to a good tutorial explaining how to build a master-detail application with Xcode and storyboards
p46127
as(dp46128
g6
V335858
p46129
stp46130
a((dp46131
g2
(lp46132
VWhen you use a compiled language such as C, the size of the pointer is not determined by the platform on which you are running your code: it depends only on the platform for which you have compiled your code
p46133
aVWindows 7 64-bit can run code compiled for 32-bit platforms
p46134
aVJudging by the output of your program, it appears that your code has been compiled for Win-32
p46135
aVIn Visual Studio 2010, to to the properties page of your C/C++ project, and make sure that  is selected in the "Platform" drop-down (it's Win32 by default)
p46136
aVIf  is not available in the dropdown, click , and choose  for the platform of your project
p46137
aVIf a "Copy from
p46138
aVdialog opens, click  to dismiss it
p46139
aVThe program should run in 64-bit mode after a recompile
p46140
as(dp46141
g6
V335858
p46142
stp46143
a((dp46144
g2
(lp46145
VOne way to do it is adding the hash code of the first field to hash code of the second field multiplied by a small prime number, like this:
p46146
as(dp46147
g6
V335858
p46148
stp46149
a((dp46150
g2
(lp46151
VWhat happens when there isn't enough memory depends on your operating system
p46152
aVSome less sophisticated operating systems would display an error asking you to manually close some applications to free up memory
p46153
aVOther operating systems would try "swapping out" one of the running applications to disk to free up space in main memory
p46154
aVIf there is not enough physical memory to fit your application even after swapping out everything else, these operating systems would display an error
p46155
aVNote that the above applies only to the initial load of the application into memory for running
p46156
aVMost applications would request additional memory as they run to store their data
p46157
aVSome applications would also request loading additional executable code through dynamic libraries
p46158
aVIf the OS does not have enough memory to complete any of these operations, it would return an error to the application, which must then handle the situation by freeing up some of the resources it no longer needs, or exiting gracefully if there is no possibility of continuing without acquiring additional memory
p46159
as(dp46160
g6
V335858
p46161
stp46162
a((dp46163
g2
(lp46164
VIn C/C++ macro definitions consist of identifiers on the left side and stuff on the right side with which each occurrence of the macro is replaced in the body of your program
p46165
aVThis mechanism is useful when you need to use a constant in multiple places (C++ provides better mechanisms for situations like that, but since your question asks about preprocessor, let's concentrate on it)
p46166
aVFor example, you can define a type of  to be an , like this:
p46167
aVNow you can define the constants by choosing integer constants for their values, like this:
p46168
aVFinally, you can check the return status for error with this macro:
p46169
aVHere is how you can use these definitions in a real code:
p46170
as(dp46171
g6
V335858
p46172
stp46173
a((dp46174
g2
(lp46175
VIf you do not care that the tables contain objects of different kind, you could put them in a  with the type of their common ancestor
p46176
aVIf there is no suitable common ancestor, you can use , like this:
p46177
aVThe idea is to make the two lists have the same element type
p46178
aVOther potential common types are , or two anonymous types with identical structures
p46179
as(dp46180
g6
V335858
p46181
stp46182
a((dp46183
g2
(lp46184
VConsider this implementation of  method:
p46185
aVEvery time you enuerate its results,  goes back to the database
p46186
aVMethod 1 will go to the database twice; method 2 will go only once
p46187
aVNote that this optimization is in no way a "free lunch": you "pay" for the speed-up with using more memory
p46188
aVThis is a common tradeoff, but you should be aware of it anyway
p46189
as(dp46190
g6
V335858
p46191
stp46192
a((dp46193
g2
(lp46194
VSince text attributes never change, move the code that sets them inside the  statement
p46195
aVKeep only the code that sets the image and the text of your labels outside the  statement
p46196
aVCells are reused, so the attributes such as font etc
p46197
aVwill remain with the cell even after it gets "recycled"
p46198
aVIn the  branch add code that finds existing labels in the cell
p46199
aVOtherwise, you keep adding the same label to the cell multiple times
p46200
as(dp46201
g6
V335858
p46202
stp46203
a((dp46204
g2
(lp46205
VYou can parameterize values in SQL statements, but you cannot parameterize column or table names
p46206
aVYou need to change the column name in the SQL string itself, for example, with :
p46207
aVMake sure that the column name does not come from user's input, otherwise you would open up your code to SQL injection attacks
p46208
aVIn case the column name does come from user's input, you can validate the string against a list of available table columns, which could be made statically or by examining the structure of your table at runtime
p46209
as(dp46210
g6
V335858
p46211
stp46212
a((dp46213
g2
(lp46214
VIt appears that your code sets a string parameter as a constraint for a DB value of numeric type, letting the database do the conversion
p46215
aVThis is not a good idea, because it takes control away from your program: should DBA decide to reconfigure your backend database to "understand" commas instead of dots, your program will stop working
p46216
aVCurrently, your  is in a locale-specific format
p46217
aVYou need to parse it using the locale-specific format provider, and then set the value that you get back from the parser as the parameter of your SQL query
p46218
aVAssuming that the current culture is one that is using commas as decimal separator, you can do this:
p46219
as(dp46220
g6
V335858
p46221
stp46222
a((dp46223
g2
(lp46224
VYou should avoid using mutable keys in hash maps
p46225
aVAt the very least, you need to postpone mutation of a key that has been added to a hash map until after it has been removed from the map
p46226
aVOtherwise, the mutated key would become "unreachable" inside the map
p46227
aVConsider this sequence of events (assume for simplicity that hash code of an  is the  itself):
p46228
aVCreate a mutable integer  with the value of 5
p46229
aVAdd  to a hash map; it would be hashed into the bucket that corresponds to has code of
p46230
aVSet the  to
p46231
aVTry adding  to the map again
p46232
aVAt this point, the key would be hashed to the bucket for hash code of , and added to the map again
p46233
aVCreate a query key , a mutable integer with the value of
p46234
aVTry searching the hash map with it
p46235
aVAt this point, the  of  will no longer "connect" to the old key of , even though they have the same hash code: the instance of  sitting at the hash bucket of  will not compare as equal to the , because 's current value is
p46236
aVEssentially, the old key and its associated map entry became unreachable
p46237
as(dp46238
g6
V335858
p46239
stp46240
a((dp46241
g2
(lp46242
VYou need to escape the double-quotes inside the search string, like this:
p46243
aVNote that the replacement does not occur "in place", because
p46244
aVNET strings are immutable
p46245
aVThe original string will remain the same after the call; only the returned string  will have the replacements
p46246
as(dp46247
g6
V335858
p46248
stp46249
a((dp46250
g2
(lp46251
VI'm questioning if this if the most efficient solution
p46252
aVThe answer depends on the way in which you are measuring the efficiency
p46253
aVIn terms of CPU cycles, this is the most efficient way
p46254
aVIn terms of maintenance efforts, methods based on reflection would prove more efficient
p46255
aVYou may want to built a hybrid LINQ/Reflection solution to get acceptable efficiency and keep maintainability in place: use reflection to get all your properties that you need to compare, build a LINQ expression tree that compares them one by one, compile it as a lambda, and use the resultant functor for CPU-efficient comparisons
p46256
aVHere is a sample implementation of the hybrid approach:
p46257
aVWith this method in hand, you can perform comparisons like this:
p46258
aVHere is a demo of this approach on ideone
p46259
aVNote that this implementation is rather simplistic
p46260
aVIt uses  for all attributes, rather than going for  where appropriate
p46261
aVYou can expand upon it by making line 7 more sophisticated
p46262
as(dp46263
g6
V335858
p46264
stp46265
a((dp46266
g2
(lp46267
VIt's not the  statement: s in Objective C should be compared with the  method, not with the  or  operators, which check reference equality:
p46268
as(dp46269
g6
V335858
p46270
stp46271
a((dp46272
g2
(lp46273
VYou use preprocessor to produce a different flag, which could be tested with a run-time  statement, like this:
p46274
aVNow you can do this:
p46275
as(dp46276
g6
V335858
p46277
stp46278
a((dp46279
g2
(lp46280
VYou need to use an outer join, like this:
p46281
aVIf rows in any of  or  are missing,  will be
p46282
as(dp46283
g6
V335858
p46284
stp46285
a((dp46286
g2
(lp46287
VKeep the current state of the switch in the model
p46288
aVUse the current state of the switch to decide two things:
p46289
aVHow many items  should return - return five when the switch is on; otherwise, return four
p46290
aVWhat cell should be returned at index three in  - if the switch is on, return the row for "Off Grid Est Daily Consumption"; otherwise, return the row for "Calculate"
p46291
aVWhen the state of the switch changes, call  so that the change in state becomes visible
p46292
as(dp46293
g6
V335858
p46294
stp46295
a((dp46296
g2
(lp46297
VTry this:
p46298
as(dp46299
g6
V335858
p46300
stp46301
a((dp46302
g2
(lp46303
VThe first and the second ways of coding the method are identical
p46304
aVThe local variable is defined and used immediately; there are no other places where  is used
p46305
aVThe third way of coding reuses  across multiple invocations of
p46306
aVIt does not call the constructor of  multiple times, and therefore may be more efficient
p46307
aVYou could possibly share  among all instances of class  by making the  variable
p46308
aVUnless you change configuration dynamically, for example by calling , you may be able to reduce the number of invocations of the constructor further
p46309
as(dp46310
g6
V335858
p46311
stp46312
a((dp46313
g2
(lp46314
VOnce you fix the undefined behavior of returning a pointer to local (see Shafik Yaghmour answer) you still have undefined behavior: it appears that the buffer is not null-ternminated, so  format specifier reads past it, and stops only when it finds an unrelated
p46315
aVIf you know that the buffer's length cannot exceed eight, you can copy its content up to  into a char buffer, theninsert a terminator at the end:
p46316
as(dp46317
g6
V335858
p46318
stp46319
a((dp46320
g2
(lp46321
VPlease verify that the global array name declared with  matches the name of the array that you reference in the call of  (i
p46322
ag630
aVthe  in  and  is the same name), and that there is no other variable named  in the scope of the call of  that would "shadow" the global
p46323
aVSince the code works fine in a smaller project, naming collision is the most likely possibility
p46324
as(dp46325
g6
V335858
p46326
stp46327
a((dp46328
g2
(lp46329
VC# language specification, section 7
p46330
ag837
aV10
p46331
aV6, requires the sequence of properties to be the same in order for the anonymous types to be considered identical:
p46332
aVWithin the same program, two anonymous object initializers that specify a sequence of properties of the same names and compile-time types in the same order will produce instances of the same anonymous type
p46333
aVIn your second example, the first anonymous class has the sequence of properties , while the second anonymous class has the sequence
p46334
aVThese sequences are not considered to be the same
p46335
as(dp46336
g6
V335858
p46337
stp46338
a((dp46339
g2
(lp46340
VThe problem is with the  method: it appears that the method adds the item as the number two in the list, rather than adding it to its end
p46341
aVThis does not apply to the initial entry, because the head and the tail are the same for it
p46342
aVTo fix this problem, keep the  element in the , and do the insertion at the , not at the  element
p46343
aVThis makes deletion of the last element a little harder to manage, but the speedup that you gain is worth it
p46344
aVIf you would like to surprise your teacher, you can use a "magic trick":
p46345
aVMake sure that you fully understand this trick
p46346
aVDraw it on a piece of paper to understand it better
p46347
aVYour teacher may ask you about this, because it's not very common
p46348
aVAs far as the printing goes, do not use , use  instead
p46349
aVYou can also avoid the counter by observing that your printing should end when the  reaches  again:
p46350
as(dp46351
g6
V335858
p46352
stp46353
a((dp46354
g2
(lp46355
VThe biggest advantage of boxed primitives over the regular ones is the ability to use them in the standard Java collections
p46356
aVIt is possible to make, say, an , but not
p46357
aVTheir biggest disadvantage is the costs, both in terms of memory and in terms of performance: depending on the architecture and the underlying type, the cost in terms of memory may go as much as nine times (consider boxing a  on a 64-bit platform)
p46358
aVThe cost in performance is twofold: you need extra cycles for unboxing every time you need the value, but more importantly, the memory footprint influence the order in which the actual memory is accessed, which may reduce the efficiency of the CPU data caching
p46359
aVThe other advantages/disadvantages that you have listed apply as well:
p46360
aVBoxed primitives are nullable,
p46361
aVYou do not need to copy a value, only a reference (this saves you time and space only when the size of a reference is smaller than the size of the data, e
p46362
ag303
aVwhen you have a  on a 32-bit platform)
p46363
aVBoxed primitives are harder to compare for equality/inequality
p46364
aVThe "defensive copying" point does not apply, because all boxed primitives in Java are immutable
p46365
as(dp46366
g6
V335858
p46367
stp46368
a((dp46369
g2
(lp46370
VYou are calling  twice - once in the check, and once on the retrieval
p46371
aVIt appears that you find a  followed by
p46372
aVThe check of  succeeds, but the iterator moves on to  right after that, so the following invocation of  returns a , not a
p46373
aVChange your code as follows:
p46374
as(dp46375
g6
V335858
p46376
stp46377
a((dp46378
g2
(lp46379
VIf you want to filter children down to where there's only one child per parent, you need to start with children, select their parents, and do not touch the parents' subitems:
p46380
aVI assume that each sub-item has a link "pointing" back at its parent
p46381
as(dp46382
g6
V335858
p46383
stp46384
a((dp46385
g2
(lp46386
VYour  does not have enough space: you are accessing index , but  has fewer than ten elements
p46387
aVYou need to allocate the array like this:
p46388
aVOnce you fix this problem, change the loop to avoid accessing index  (that's what is going to happen when  reaches zero)
p46389
aVFinally, there is no need to subtract  from : integer division drops the fraction, so you could do this:
p46390
as(dp46391
g6
V335858
p46392
stp46393
a((dp46394
g2
(lp46395
VYou can do it like this:
p46396
aVTo make  ones at position zero, compute ; recall that  is , so the expression becomes
p46397
aVNow you need to add  zeros at the back, so shift the result left by
p46398
as(dp46399
g6
V335858
p46400
stp46401
a((dp46402
g2
(lp46403
VThe reason that you get the error is because the following variables have  access in the  class:
p46404
aVYou cannot access them in the subclass  unless the superclass declares them  or
p46405
aVHowever, in this case it is not necessary: you pass these three variables to the  constructor, so they get set in the base class
p46406
aVAll you need in the constructor of the derived class is to call , and then deal with variables that the derived class has declared, like this:
p46407
as(dp46408
g6
V335858
p46409
stp46410
a((dp46411
g2
(lp46412
VIt appears that your  instance is not initialized: the call of  gives the instance memory, but does not set up the instance itself
p46413
aVReplace  with  in the call that creates , like this:
p46414
as(dp46415
g6
V335858
p46416
stp46417
a((dp46418
g2
(lp46419
VJava offers a handy instrument for writing dynamic programs called Reflection
p46420
aVThe closest thing to it in C++ is RTTI, but reflection is a lot more sophisticated
p46421
aVAmong other things, it lets you access private fields of objects
p46422
aVSuppose the third-party  looks like this:
p46423
aVLet's say that you want to avoid going through the  method for each pixel by accessing  directly, but the field is not public
p46424
aVYou can examine the  class for its private fields through reflection, get its  field by name, and access the array through reflection as if it were public
p46425
aVIt is needless to say that this approach is extremely fragile, especially when you use it with third-party libraries
p46426
as(dp46427
g6
V335858
p46428
stp46429
a((dp46430
g2
(lp46431
VYou can use a  object to create the image off-screen, and then draw the image on the screen using the screen's  object
p46432
aVAt this point you can draw  all at once on the screen's
p46433
aVMicrosoft: How to Draw Images Off-Screen
p46434
as(dp46435
g6
V335858
p46436
stp46437
a((dp46438
g2
(lp46439
VYou do not need a second call of getline: you have the content at your disposal already, it's inside the line variable
p46440
aVAll you need is getting its content out for further tokenization
p46441
aVThat's not difficult to do: all you need is to call c_str on the line variable, like this:
p46442
as(dp46443
g6
V335858
p46444
stp46445
a((dp46446
g2
(lp46447
VNo, object initializer is the only place where assignment syntax like that can be used
p46448
aVIf you need to assign multiple fields at once from many different places in code without duplication, you could define a method that encapsulates all the assignments for you:
p46449
aVUnfortunately, it does not let you set an arbitrary group of properties, like the VB syntax that you show
p46450
as(dp46451
g6
V335858
p46452
stp46453
a((dp46454
g2
(lp46455
VThis is because of object slicing: the abstract class received by value will receive a copy of the object that you are passing; therefore, the derived data members will be sliced off from it, making the object unusable
p46456
aVWhen you pass by reference, you are passing the address of the existing object, which is a member of a derived class, all its data members included
p46457
aVThis is not specific to C++ - this is a property of passing by value in general
p46458
aVThe dynamic binding is implemented in such a way as to not allow sliced instance receive calls as if it were a complete instance
p46459
aVThe vtable pointer is adjusted to dispatch the calls to the member functions of the abstract base class
p46460
as(dp46461
g6
V335858
p46462
stp46463
a((dp46464
g2
(lp46465
VI looked at the logic and the expected output and there is no correlation between them
p46466
aVSurely it is not a logic error if it is running on 2 out of 3 computer
p46467
aVWelcome to Undefined Behavior: unfortunately, the fact that your program produces correct results on two (or on two thousand, for that matter) computers proves nothing
p46468
aVThe language standard tried to give compiler designers as much freedom to optimize as possible, so that the efficiency of C++ programs could stay competitive with programs written in assembly language
p46469
aVUnfortunately, this leaves a lot of room for incompatibility between platforms: different compilers and execution environments can generate drastically different results for programs with bugs
p46470
aVThe worst thing is, programs with bugs may produce behavior that you may reasonably expect on some platforms, and crash miserably on others
p46471
aVThe only way to guard against undefined behavior is to write correct programs
p46472
aVCompilers reasonably aid you by producing warnings in places where they think an undefined behavior may be happening
p46473
aVTurn on all warnings at the finest level, compile your program, and fix all warnings the compiler reports
p46474
aVChances are, some of the warnings would explain the differences between the output on your computer and on the computer of your professor
p46475
aVFor tracking down advanced errors, use valgrind
p46476
aVThis program will help you detect memory-related issues, such as writing past the allocated area, using released memory, freeing the same chunk of memory multiple times, and so on
p46477
as(dp46478
g6
V335858
p46479
stp46480
a((dp46481
g2
(lp46482
VYou cannot do it with variables: the reason it works with string literals is that when you write several literals separated by whitespace, the compiler combines them in a single string literals for you
p46483
aVThe solution that you have (with the format string for three %@ specifiers) is a good one
p46484
aVYou can also format the three values in a similar way
p46485
as(dp46486
g6
V335858
p46487
stp46488
a((dp46489
g2
(lp46490
VYou can change the condition to
p46491
aVIf you have more than two items, the items from the third one on would be ignored by the  method
p46492
as(dp46493
g6
V335858
p46494
stp46495
a((dp46496
g2
(lp46497
VYour C++ code is correct
p46498
aVThe "undefined reference" is a linker error that has to do with the way you are compiling your code
p46499
aVIn order for it to link, use this command line:
p46500
aVHere are the details: the process of compiling C++ code has three major stages - preprocessing, compiling, and linking
p46501
aVPreprocessor deals with  and  statements in your code
p46502
aVCompiler takes the results of preprocessing, and produces binary code for each translation unit (in your case, there are two translation units -  and )
p46503
aVFinally, the linker establishes connections between parts of binary code within translation units
p46504
aVThe preprocessor and the compiler can do their job even when presented with one translation unit at a time
p46505
aVThe linker, however, must "see" all translation units at once
p46506
aVWhen you call  without additional flags, all stages of the compiler are invoked, including the linker
p46507
aVThat's why you need to list all translation units at once
p46508
as(dp46509
g6
V335858
p46510
stp46511
a((dp46512
g2
(lp46513
VThe code crashes because  pointer is uninitialized
p46514
aVYou need to allocate a  to it, or use an automatic variable instead of a pointer, like this:
p46515
aVDemo on ideone
p46516
as(dp46517
g6
V335858
p46518
stp46519
a((dp46520
g2
(lp46521
VThis may not be legal, because  is unassigned on the first iteration
p46522
aVIf the loop does not dereference  during the initial iteration, it may be OK, but it is not possible to tell without seeing the body of the loop
p46523
aVSince you are using , using iterators would save you another line, because you wouldn't need to declare
p46524
aVYou would be able to determine the offset without  by subtracting  from the current iterator:
p46525
as(dp46526
g6
V335858
p46527
stp46528
a((dp46529
g2
(lp46530
VTry this:
p46531
aVThe idea is to group all lines by pairs
p46532
aVEach group will have exactly two items - the key as the first item, and the value as the second item
p46533
aVDemo on ideone
p46534
as(dp46535
g6
V335858
p46536
stp46537
a((dp46538
g2
(lp46539
VThe best way to get rid of the characters that you do not want is to not put them in in the first place:
p46540
aVHowever, if you must remove the punctuation after the fact, you could use :
p46541
as(dp46542
g6
V335858
p46543
stp46544
a((dp46545
g2
(lp46546
VSince you are dealing with , a union can be built by simply adding elements of the two sets together, like this:
p46547
aVHere is a demo on ideone
p46548
as(dp46549
g6
V335858
p46550
stp46551
a((dp46552
g2
(lp46553
VYou can do it without a  expression, like this:
p46554
aVSince  can be equal to only one thing at a time, only one component of the  expression would determine the outcome of the  condition
p46555
as(dp46556
g6
V335858
p46557
stp46558
a((dp46559
g2
(lp46560
VYour syntax is a little off: you need to add  to the  function, and change the order of the functions so that  is the last function in the chain,
p46561
as(dp46562
g6
V335858
p46563
stp46564
a((dp46565
g2
(lp46566
VSince it appears that you store arrays as  elements, you can do this:
p46567
aVor
p46568
as(dp46569
g6
V335858
p46570
stp46571
a((dp46572
g2
(lp46573
VIf you use a pointer, the structure would no longer be of variable length: it will have fixed length, but its data will be stored in a different place
p46574
aVThe idea behind zero-length arrays* is to store the data of the array "in line" with the rest of the data in the structure, so that the array's data follows the structure's data in memory
p46575
aVPointer to a separately allocated region of memory does not let you do that
p46576
aV* Such arrays are also known as flexible arrays; in C99 you declare them as  instead of , i
p46577
ag630
aVyou drop zero
p46578
as(dp46579
g6
V335858
p46580
stp46581
a((dp46582
g2
(lp46583
VThe return value of  is the pointer to the original, unmodified, string at the point of the match
p46584
aVThe reason why the second call displays  is a coincidence:  simply happens to be at the end of the searched string
p46585
aVHad the  been , the output for the second call would be , not simply
p46586
aVTo fix this, you can change your program like this:
p46587
aVThe reason this works is that you know that the only case when  would return a non-null pointer is when it finds the exact match to what you've been searching for
p46588
aVIf all you need is a boolean "found/not found" flag, you can simply test  and  for
p46589
aVYou are using this trick already in your final  statement
p46590
as(dp46591
g6
V335858
p46592
stp46593
a((dp46594
g2
(lp46595
VThis is because  allows duplicates
p46596
aVNote that you are going to have some duplicates, there - for example, numbers 15, 30, 45, and so on, will be added twice
p46597
aVReplace
p46598
aVwith
p46599
aVand it's going to work because a  won't allow duplicate values
p46600
as(dp46601
g6
V335858
p46602
stp46603
a((dp46604
g2
(lp46605
VSince your code uses , it would not check the second part of the condition unless the first one is , i
p46606
ag630
aVonly empty strings would be checked for the initial character being a space, which is an undefined behavior
p46607
aVWhat you need is an , like this:
p46608
aVNote that there is no need to compare a return value of a  function to , because the comparison is going to succeed only when the expression is already
p46609
as(dp46610
g6
V335858
p46611
stp46612
a((dp46613
g2
(lp46614
VThis is because your string contains the newline character
p46615
aVFrom the  documentation:
p46616
aVA newline character makes fgets stop reading, but it is considered a valid character by the function and included in the string copied to str
p46617
aVThis should fix the problem (demo):
p46618
as(dp46619
g6
V335858
p46620
stp46621
a((dp46622
g2
(lp46623
VIn order to perform this operation without iterating the original more than once, you would need to store the content of the subsequence between the indexes that you are swapping
p46624
aVHere is how you can implement the algorithm (I renamed  and  to  and ):
p46625
aVDemo on ideone
p46626
as(dp46627
g6
V335858
p46628
stp46629
a((dp46630
g2
(lp46631
VFirst, note that version  is not bulletproof: it would reject negative numbers, and would not catch numbers that are too large
p46632
aVVersion  is OK, yet it makes the caller change the coding style: rather than catching an error and processing it together with other errors, the caller would need to check for  all the time
p46633
aVThis may be suboptimal in situations where you read multiple integers, but the error processing does not depend on which particular one has failed
p46634
aVIn addition, new coders using your API may forget to check for , and use the error code inadvertently
p46635
aVThat's why I would stay with the first option: the code using version  would look instantly familiar to anyone who knows Java API, without the need to learn what happens inside your function
p46636
as(dp46637
g6
V335858
p46638
stp46639
a((dp46640
g2
(lp46641
VCalling a destructor releases the resources owned by the object, but it does not release the memory allocated to the object itself
p46642
aVThe second code snippet has a memory leak
p46643
as(dp46644
g6
V335858
p46645
stp46646
a((dp46647
g2
(lp46648
VIf  is what I think it is, this should work:
p46649
as(dp46650
g6
V335858
p46651
stp46652
a((dp46653
g2
(lp46654
VIn the Standard C++ Library (formerly known as STL) iterators do not perform range checking in the same way that in C pointers do not perform range checking
p46655
aVAccessing memory through an iterator pointing beyond the allocated bounds is undefined behavior, in the same way that accessing memory through a pointer that points beyond the allocated bounds is undefined behavior
p46656
aVYou should follow the same principle in the design of your iterators, i
p46657
ag630
aVyou should perform no bounds checks on data accesses
p46658
as(dp46659
g6
V335858
p46660
stp46661
a((dp46662
g2
(lp46663
VThis line of code casts  to the  type
p46664
aVThis will let you access properties of  using the dot  syntax
p46665
aVSince Objective C is a dynamically typed language, type casting is less important than in strongly typed languages
p46666
aVYou can call methods and access properties using square bracket syntax even without casting the variable to the  type
p46667
aVHowever, the correct type is necessary for accessing properties using the dot syntax
p46668
as(dp46669
g6
V335858
p46670
stp46671
a((dp46672
g2
(lp46673
VYes, valgrind can definitely help you
p46674
aVIn addition to a lot of heap-based analysis (illegal frees, memory leaks, etc
p46675
aVits memcheck tool detects illegal reads and writes, i
p46676
ag630
aVsituations when your program accesses memory that it should not access
p46677
aVThis analysis does not differentiate between static and dynamic memory: it would report accesses outside of a stack frame, accesses beyond bounds of a static array, and so on
p46678
aVIt also detects access to variables that have not been onitialized previously
p46679
aVBoth situations are undefined behavior, and can lead to crash
p46680
as(dp46681
g6
V335858
p46682
stp46683
a((dp46684
g2
(lp46685
VAssuming that by "with lambda" you mean the "query syntax", you can rewrite your query like this:
p46686
as(dp46687
g6
V335858
p46688
stp46689
a((dp46690
g2
(lp46691
VWhen applied to integers, the  operator in C# is a bitwise , not a logical
p46692
aVAlso  is an assignment, not an equality comparison operator
p46693
aVThe  expression is indeed an expression of boolean type, while the assignment is integer (because  is integer)
p46694
aVWhat you need is
p46695
as(dp46696
g6
V335858
p46697
stp46698
a((dp46699
g2
(lp46700
VYou can use  function to do the conversion of individual bytes
p46701
aVThe function takes a  parameter as its third argument, and reports the new position in the input, letting you decide between skipping the delimiter and reading more data, or finishing the loop:
p46702
aVDemo on ideone
p46703
as(dp46704
g6
V335858
p46705
stp46706
a((dp46707
g2
(lp46708
VSplit using the  method, filter with a LINQ expression, and call  or  on the result to produce a filtered array:
p46709
aVDemo on ideone
p46710
as(dp46711
g6
V335858
p46712
stp46713
a((dp46714
g2
(lp46715
VWhat LINQ is telling you is that it does not implement functionality that pushes the  functionality to the backend
p46716
aVHowever, you can do it in your own code without a problem:
p46717
as(dp46718
g6
V335858
p46719
stp46720
a((dp46721
g2
(lp46722
VBoth shared libraries and shared source let you share the common code among projects
p46723
aVLibraries present a better of the two alternatives, so you should use them if they are available on your platform
p46724
aVThis lets you guard the source of the library from inadvertent modifications, which could happen if the code from source control is changed locally
p46725
aVThe only problem with sharing code through libraries may be lack of support for source-level debugging of library code by some of the tools in your embedded tool chain (e
p46726
ag303
aVdebuggers attached to in-circuit emulators)
p46727
aVIn this case reusing code through the source may be acceptable
p46728
aVIf possible, you should guard the source from modification through the file system access controls
p46729
as(dp46730
g6
V335858
p46731
stp46732
a((dp46733
g2
(lp46734
VYou get an invalid cast exception because the result of  is not
p46735
aVIn order to fix this problem, add a constructor to  that takes an , and return the result of calling that constructor from your  method:
p46736
as(dp46737
g6
V335858
p46738
stp46739
a((dp46740
g2
(lp46741
VThe question is, if I read a file which was written before the definition change, will param1, param2 and param3 always be correctly set
p46742
aVYes, you can be sure of that
p46743
aVcan I be sure that paramA, paramB and paramC will not be assigned any junk
p46744
aVThat is also correct, with one caveat: unless these fields are initialized in the constructor, they would remain uninitialized after the read (i
p46745
ag630
aVcontain "junk")
p46746
aVFinally, note that this trick would work only for reading a single  from the binary file
p46747
aVIf you need to save an array of such s, you would have to store the  that was in effect at the time of writing out the data, otherwise you would not be able to partition the array correctly
p46748
aVObviously, changing to a different compiler or to a different version of the same compiler could also this scheme even without adding new fields to the end of the
p46749
as(dp46750
g6
V335858
p46751
stp46752
a((dp46753
g2
(lp46754
Vit works, but as soon as i scroll the tables they get mixed up
p46755
aVThis indicates a problem with  "recycling"
p46756
aVYou need to change the code of your  in such a way that it sets  unconditionally, not only when the cell is created for the first time
p46757
aVIn addition, you could replace the chain of  statements that check the  for various specific values with a lookup in a dictionary, like this:
p46758
aVNow you can use the image from the dictionary, like this:
p46759
as(dp46760
g6
V335858
p46761
stp46762
a((dp46763
g2
(lp46764
VYou should replace  with an , like this:
p46765
aVIf you need an  for these constants, define an  that maps  values to strings, like this:
p46766
as(dp46767
g6
V335858
p46768
stp46769
a((dp46770
g2
(lp46771
VThere are two ways to solve this problem:
p46772
aVUsing a lock to synchronize access between two threads, or
p46773
aVDoing all access from a single thread
p46774
aVThe first way is simple: add  block around the code that reads or modifies the  list
p46775
aVThe second way is slightly more involved: define two concurrent queues,  and  in your class
p46776
aVInstead of adding or removing users directly from the  list, add them to the  and  queues
p46777
aVWhen the sleeping thread wakes up, it should first empty both queues, performing the modifications as necessary
p46778
aVOnly then it should hand out the currency
p46779
as(dp46780
g6
V335858
p46781
stp46782
a((dp46783
g2
(lp46784
Vsaid we can use indexes to traverse a stack, but I think he's wrong
p46785
aVYou're right, he's wrong
p46786
aVThere is no way [to do two nested loops] right
p46787
aVYou can access element at  if you have enough space for a temporary stack: pop to the index while storing the popped values onto a temp stack, remember the value, and then push the values back:
p46788
aVYes, that's very, very slow
p46789
as(dp46790
g6
V335858
p46791
stp46792
a((dp46793
g2
(lp46794
VYou cannot store results of  in the :  gets invalidated as soon as you make any modifications to the  from which you pulled the
p46795
aVIf you must have a C string, make a copy with ; otherwise, use  to simplify your memory management
p46796
aVIn addition, using  as a destination for  is just wrong
p46797
aVThe fact that you cast const-ness away with  should have been a clear indication to you that what you are doing is not correct
p46798
aVIf you want to copy one string into the other, you can use the assignment operator instead
p46799
as(dp46800
g6
V335858
p46801
stp46802
a((dp46803
g2
(lp46804
Vwhen is appropriate to use  in anonymous classes
p46805
aVNever
p46806
aVKeyword  is appropriate for named classes, which can implement interfaces in addition to extending classes
p46807
aVIn contrast, anonymous classes can either implement an interface or extend a class, but not both
p46808
aVThat is why the syntax has no keyword at all - just put curly braces after a  expression, and provide implementation for the methods of your base class or an interface
p46809
as(dp46810
g6
V335858
p46811
stp46812
a((dp46813
g2
(lp46814
VUse an unwind segue
p46815
aVWhen presenting your application, push  onto the navigation stack
p46816
aVIf this is the first run of your app, disable animation when pushing the tab bar controller, and push the first screen of your wizard on top of it
p46817
aVIf it is not the first run, push the tab bar controller with animation
p46818
aVWhen the user goes through the wizard to completion, use an unwind segue to go back to the tab bar controller
p46819
as(dp46820
g6
V335858
p46821
stp46822
a((dp46823
g2
(lp46824
VThe logic behind validating arguments in public methods and not validating arguments in private ones goes roughly as follows:
p46825
aVWhen a public method is called with invalid arguments, it is a programming error outside your control
p46826
aVWhen a non-public method is called with invalid arguments, it is a logical error within your control
p46827
aVThis logic is reasonable: there is no need to waste cycles on validating the arguments to methods that your module produces internally
p46828
aVPrivate methods, on the other hand, could always assume that their arguments are valid, because you are in control of all calls of private methods
p46829
aVHowever, it is very beneficial to catch situations when these assumptions are violated
p46830
aVTo that end, it is a very good idea to use run-time assertions in place of argument validation inside private methods
p46831
aVThis catches invalid invocations from outside callers with exceptions, and alerts you to invalid invocations from your own methods with asserts
p46832
as(dp46833
g6
V335858
p46834
stp46835
a((dp46836
g2
(lp46837
VThis is because your  inner class is non-static
p46838
aVNon-static classes in Java have an implicit reference to their enclosing class, so they must be instantiated by an instance method of the outer class
p46839
aVInstantiating it like this
p46840
aVis not valid, even though the  class is
p46841
aVDeclare it with the  keyword to fix this compile issue: the class can be logically made , because its methods do not require knowledge of the enclosing  class
p46842
as(dp46843
g6
V335858
p46844
stp46845
a((dp46846
g2
(lp46847
VIn Java, pointers are called references
p46848
aVYou can avoid referencing an object that has not been created like this:
p46849
aVAlternatively, you can make sure that all objects inside the  array have been created
p46850
aVNote that in Java when you create an array, you create only the structure to hold references to objects; you do not create objects themselves - they need to be created separately by calling their constructors and assigning the individual array elements
p46851
as(dp46852
g6
V335858
p46853
stp46854
a((dp46855
g2
(lp46856
VThe computation time is different because of data caching
p46857
aVKnowing about the locality of reference, CPU loads data from adjacent addresses when you read a location in memory
p46858
aVIt predicts that the next read is going to be from the location just a few bytes forward of the address that you just read
p46859
aVWhen the array is allocated as , the elements are indeed stored consecutively, so CPU's predictions come true nearly all the time
p46860
aVThe data that you need is nearly always available from the CPU's cache, which is several times faster than the main memory
p46861
aVCPU continues loading locations forward of where you just read while it performs the computation, so loading the new data and adding up the numbers continues in parallel
p46862
aVWhen you switch dimensions around, the numbers that you add up are no longer in consecutive locations
p46863
aVThis is because consecutive calls to  will not allocate data in consecutive memory regions: memory management libraries adds several bytes for "bookkeeping" purposes, and it always allocates chunks of memory of some minimum size, which is often greater than
p46864
aVWhen you request a chunk that is smaller than the minimum, the allocated region is padded
p46865
aVAs the result, your s could end up being up to twenty bytes apart in the best-case scenario*  - enough to nullify the effects of reading ahead from adjacent memory locations
p46866
aVThat's why the CPU is forced to wait while it loads data from a different location
p46867
aVThis slows down the calculation several times
p46868
aV* In the worst case, the values could be placed arbitrarily far, depending on the allocations and deallocations performed prior to running your code
p46869
as(dp46870
g6
V335858
p46871
stp46872
a((dp46873
g2
(lp46874
VTo understand why this works, first think of how a normal increment functions: given an arbitrary bit pattern, an increment finds a run (which may be empty) of consecutive ones until a zero, clears out all ones, and sets the first zero to one, like this:
p46875
aVNow consider your algorithm: the regular increment detects runs starting at the back of the number; your loop detects runs starting at the front of the number
p46876
aVSince you say the algorithm "adds one in a mirrored manner",  must be the twice the highest power of two that may be present in the
p46877
aVThe  loop tries to find a position in the  where the position of the lone  in the  matches a zero - the first "hole"
p46878
aVThe body of the loop clears out all ones in the target, starting with the highest-order one
p46879
aVAs soon as the loop stops, the  inserts  into the "hole" found by the loop
p46880
as(dp46881
g6
V335858
p46882
stp46883
a((dp46884
g2
(lp46885
VYou need to catch exceptions by pointer, like this:
p46886
aVNote that Apple strongly recommends against using exceptions for handling run-time situations, reserving them for situations when the application is about to close (i
p46887
ag630
aVfor non-recoverable situations)
p46888
aVIf the situation is recoverable, Apple recommends using  (Exceptions Programming Guide)
p46889
as(dp46890
g6
V335858
p46891
stp46892
a((dp46893
g2
(lp46894
VAssuming that you are looking to initialize person's name, you can do this:
p46895
aVThe  property is nested inside the 's  object, so you need to nest initializers as well
p46896
aVYou can also expose  directly, like this:
p46897
aVThis makes the following possible:
p46898
as(dp46899
g6
V335858
p46900
stp46901
a((dp46902
g2
(lp46903
VYou are correct - instead of inheriting from multiple classes, you can inherit from one (or none), and inherit the rest through adapting protocols
p46904
aVIf  and  are at the same level logically, you may want to make both of them protocols, like this:
p46905
aVIf you need to share implementation, define categories on  and , and put implementations there
p46906
aVThis would have an effect similar to adding methods to
p46907
as(dp46908
g6
V335858
p46909
stp46910
a((dp46911
g2
(lp46912
VIt looks like  is an array with one element
p46913
aVYou cannot use a subscript with a string  on an  - it works only on dictionaries
p46914
aVTry this instead -- get the , and pick its initial element
p46915
aVThen apply  to that element, as follows:
p46916
as(dp46917
g6
V335858
p46918
stp46919
a((dp46920
g2
(lp46921
VYou need a negative lookbehind for that:
p46922
aVHere is a demo on ideone
p46923
as(dp46924
g6
V335858
p46925
stp46926
a((dp46927
g2
(lp46928
VYou cannot do it with variables of different type
p46929
aVWhen the variables are of the same type, the simplest way is the "naive" implementation with a :
p46930
aVYou can wrap this into a  method that takes its parameters by reference:
p46931
aVYou cannot change the type of a statically typed variable ( uses a static type determined at compile time)
p46932
aVYou can declare your variable as  or  if the type of a variable must change at runtime
p46933
aVIn case you do it, however, the value types (including s) will be wrapped in reference types
p46934
as(dp46935
g6
V335858
p46936
stp46937
a((dp46938
g2
(lp46939
VThis "technique" is a brain teaser
p46940
aVAs far as the practical use goes, it is about as useless as it gets: all it does is computing negative  in two's complement without using unary minus:
p46941
as(dp46942
g6
V335858
p46943
stp46944
a((dp46945
g2
(lp46946
VYou should not check the return value of  functions for equality to : this line
p46947
aVis equivalent to
p46948
aVFinally, the solution where the count is incremented outside of  counts non-primes together with primes, producing an obviously wrong result
p46949
aVHere are a couple of points "for style" that you should consider:
p46950
aVChecking candidate divisors in  can stop when the candidate divisor is greater than the square root of the number
p46951
aVYou can do much better if you store the primes that you've seen so far, and checking divisibility only by the numbers from the list of primes
p46952
aVWhen you are looking for the first 1000 primes this would hardly matter, but for larger numbers this could be significant
p46953
as(dp46954
g6
V335858
p46955
stp46956
a((dp46957
g2
(lp46958
VYou select two persons, so you need to select two  rows as well, because each person has its own assignment row in the  table
p46959
aVThe idea is to build a link between  and  through a pair of  rows sharing the same
p46960
as(dp46961
g6
V335858
p46962
stp46963
a((dp46964
g2
(lp46965
VYes, you can do it using references, like this:
p46966
aVAt this point, any changes done to the  stored at  will be reflected in :
p46967
aVOf course in order for this to work you need to ensure that the constant  indeed represents a valid address available for reading and writing by your program
p46968
as(dp46969
g6
V335858
p46970
stp46971
a((dp46972
g2
(lp46973
VIf you set the  on your gesture recognizer to , it will no longer accept multi-finger swipes:
p46974
as(dp46975
g6
V335858
p46976
stp46977
a((dp46978
g2
(lp46979
VYes, you can do it with LINQ in a single statement:
p46980
aVIf you do not care that the lists appear in the ascending order of , the way that your method produces them, you can remove the  method call from the chain of method invocations
p46981
as(dp46982
g6
V335858
p46983
stp46984
a((dp46985
g2
(lp46986
VThe  statement by itself lets you break out of a single loop; in most cases this is enough, but there are situations when you must exit from several loops at the same time
p46987
aVAdding a label to a loop from which you want to break out and referencing that label from a  statement lets you end several nested loops at the same time
p46988
aVThe code from your post is not a good illustration; a better use case is a search in multidimensional array
p46989
aVLet's say that you want to find a pair  such that
p46990
aVYou can do it like this:
p46991
as(dp46992
g6
V335858
p46993
stp46994
a((dp46995
g2
(lp46996
VI can't understand why does it need to make that strange cast
p46997
aVThe cast is necessary to avoid truncating the data to a single : if you drop the cast, like this
p46998
aVthe assignment will modify a single
p46999
aVEffectively, it's this:
p47000
aVwhich is not what the author of the code wanted
p47001
aVAs far as adding a byte goes, the answer depends on the use of : most likely, some other piece of data is supposed to go there
p47002
as(dp47003
g6
V335858
p47004
stp47005
a((dp47006
g2
(lp47007
VWhen a non-static inner class is created, it gets a reference to its enclosing class instance
p47008
aVIn order to reference that instance, a special syntax is used: the keyword  is prefixed with the name of the enclosing class
p47009
aVWhen used without a class name prefix,  keyword refers to the instance of the inner class itself
p47010
aVEssentially, the call is made to the  method of the  class
p47011
aVNote that since the method of the inner class is called  as well, the call without  would have been directed to the  inside the inner class, causing infinite recursion
p47012
aVAs correctly stated by Roger Lindsj in a comment below  Technically the idiom is known as qualified this construct
p47013
aV(JLS 15
p47014
ag20244
aV4)
p47015
as(dp47016
g6
V335858
p47017
stp47018
a((dp47019
g2
(lp47020
VThe first program crashes because it tries to write the memory allocated to a string literal, which is an undefined behavior
p47021
aVThe second program copies the string literal into writable memory, fixing the problem
p47022
as(dp47023
g6
V335858
p47024
stp47025
a((dp47026
g2
(lp47027
VThe regex should look like this:
p47028
aVThe delimiters are on both sides, the capturing group is i between them
p47029
aVHere is how:
p47030
aVThe output of the above looks like this:
p47031
aVHere is a demo on ideone
p47032
as(dp47033
g6
V335858
p47034
stp47035
a((dp47036
g2
(lp47037
VAre there any quicker way to pick the minimum number
p47038
aVNo, this is as quick as it gets
p47039
aVYou cannot find the minimum any faster, unless array is sorted, or its elements follow any other special placement strategy: you must examine all elements in order to find the minimum, so any algorithm would do essentially the same thing as your code
p47040
as(dp47041
g6
V335858
p47042
stp47043
a((dp47044
g2
(lp47045
VThe  parameter of the  method is the full name of the font, not its file name
p47046
aVis the file name; the full name of that font is
p47047
aVThis should fix the problem:
p47048
aVFont name and file name are often the same, but that's not always the case
p47049
aVTo look up the name of the font, locate your font in the Font Book application, and press Command+I to view font's information
p47050
as(dp47051
g6
V335858
p47052
stp47053
a((dp47054
g2
(lp47055
VFirst thing to note about loop invariants is that there are many of them
p47056
aVSome of them are more useful, while some are less useful
p47057
aVSince invariants are used in proving correctness of programs, choosing an invariant depends on what you are trying to prove
p47058
aVFor example,  is an invariant of the loop
p47059
aVIf you want to prove that the function returns a positive number, this is all you need
p47060
aVIf you want to prove something more complex, you need a different invariant
p47061
aVSince parameters in Java are passed by value, and because the program modifies values of the parameter , let's use  to denote the initial values of the  parameter
p47062
aVNow you can write the following invariant expression:
p47063
aVYou come up with this invariant by observing that each time that  is increased,  is also decreased by
p47064
aVSo  is decreased by  exactly  times on each iteration of the loop
p47065
aVThis invariant can be used to prove that the loop produces , and that the ending value of  is equal to
p47066
as(dp47067
g6
V335858
p47068
stp47069
a((dp47070
g2
(lp47071
VWhen you create
p47072
aVthe set is capable of storing objects that belong to any subclass of
p47073
aVIn your case, all you need is
p47074
aVYou can do this now:
p47075
aVDoing this will trigger a compile error:
p47076
aVAs far as casts go, you wouldn't need to cast objects on their way into the
p47077
aVHowever, if you need a specific type (i
p47078
ag630
aVnot simply ) on retrieval, you would need a cast
p47079
as(dp47080
g6
V335858
p47081
stp47082
a((dp47083
g2
(lp47084
VUnfortunately, you cannot do it without converting your array to : iterating over arrays with the "foreach" version of the  loop is a "compiler trick", i
p47085
ag630
aVsomething the compiler knows and does internally
p47086
aVAn ability to use primitives in "foreach" loops is an indirect indication that  is not used there, because Java generics cannot be used with primitive types
p47087
as(dp47088
g6
V335858
p47089
stp47090
a((dp47091
g2
(lp47092
VThread-local storage serves the purpose of global variables within a context of a single thread
p47093
aVConsider this example: you write a multithreaded program for processing user requests
p47094
aVMultiple users can initiate requests concurrently; your system uses one thread for each user
p47095
aVWhen a user request arrives, your system figures out the user from which it came, and creates an instance of  object for that user
p47096
aVThere are several ways to make that object available to your running program
p47097
aVOne way is to pass  to each method that may need it, and also to each method that calls, directly or indirectly, a method that may need it
p47098
aVThis may be problematic, especially in contexts where callbacks are used
p47099
aVHad your program not been multithreaded, you'd set  in a global variable
p47100
aVUnfortunately, you cannot do that, because multiple user requests may be active at the same time
p47101
aVThis is where thread-local storage comes in: the process that creates the user permissions sets the  object in thread-local storage, and leaves it there until the processing of the request is over
p47102
aVThis way all methods can grab  as needed, without having to pass them around as method parameters
p47103
as(dp47104
g6
V335858
p47105
stp47106
a((dp47107
g2
(lp47108
VYou should work out the invariants of nested loops starting with the inner one:
p47109
aVyou can observe that
p47110
aVAt the end of the loop, , so using Hoare Tripple for the  loop you can state that at the end of the inner loop
p47111
aVThis is another way of saying that  is
p47112
aVNow you can proceed with the outer loop: since  proceeds from  down to zero, the invariant would be
p47113
aVUsing Hoare Trippe once again, you derive that upon exiting the outer loop the array  is sorted in ascending order:
p47114
as(dp47115
g6
V335858
p47116
stp47117
a((dp47118
g2
(lp47119
VYou can make a  and set it up with implementations of your operators, like this:
p47120
aVNow you can do this:
p47121
aVYou can even do this generically with some "magic" from : instead of using pre-built lambdas defined in C#, you could define your lambdas programmatically, and compile them into
p47122
as(dp47123
g6
V335858
p47124
stp47125
a((dp47126
g2
(lp47127
VThink of it this way:
p47128
aVis a shorthand for
p47129
aVIt is not a shorthand for
p47130
aVNow expand it with your function call:
p47131
aVThe above does not make sense, unless  returns something that you can assign, e
p47132
ag303
aVa reference
p47133
aVTherefore the expression is invalid
p47134
aVHowever, if your function returned by reference, the assignment would be possible:
p47135
aVNow both expressions  and  make perfect sense: it's  inside  that gets modified, so your program would compile
p47136
as(dp47137
g6
V335858
p47138
stp47139
a((dp47140
g2
(lp47141
VYou are missing an  in the chain between  and
p47142
aVNote that this is not the best solution to the problem, because you duplicated the code
p47143
aVRather than having two branches for "under" and "over", make one branch, and use  to compute the difference
p47144
as(dp47145
g6
V335858
p47146
stp47147
a((dp47148
g2
(lp47149
VUnless  inherits ,  its  member function is not considered related in any way to the virtual function with the same signature defined inside
p47150
aVIn this case, C++ compiler will complain about a missing implementation
p47151
aVHowever, inheriting  in  would create multiple paths of inheriting the same member function
p47152
aVThis may be a problem, because functions, even the pure virtual ones, which are inherited through different paths are considered different (this is in sharp contrast to Java and C#'s implementations of interfaces)
p47153
aVYou fix this problem by marking your inheritance , like this:
p47154
aVHere is a demo on ideone
p47155
as(dp47156
g6
V335858
p47157
stp47158
a((dp47159
g2
(lp47160
VYou cannot parameterize queries with names of tables, views, or columns
p47161
aVOnly data members can be parameterized
p47162
aVYou need to make your SQL dynamically, e
p47163
ag303
aVlike this:
p47164
aVThis should be done only if  is controlled by your code, e
p47165
ag303
aVcomes from a pre-defined list or checked for absence of non-alphanumeric characters to avoid SQL injection attacks
p47166
as(dp47167
g6
V335858
p47168
stp47169
a((dp47170
g2
(lp47171
VMove the  loop into , like this:
p47172
aVYour current implementation creates an unnecessary , and runs the loop inside the  function
p47173
aVAn assumption is made that the second argument points to an array of size five
p47174
aVFinally, inside the loop you keep re-assigning the elements of the same temporary  (which points to  inside , which is why the  does not get filled
p47175
aVI changed  to read a single entry at a time
p47176
aVNow  is in charge of where the data is placed: it passes a pointer to each element of  in turn, along with the sequence number of the student for printing purposes
p47177
as(dp47178
g6
V335858
p47179
stp47180
a((dp47181
g2
(lp47182
VYou can try a direct translation of your explanation to LINQ, which would look like this:
p47183
aVThis produces a  that maps the  to the corresponding count computed as the difference between non-negative and negative occurrences
p47184
as(dp47185
g6
V335858
p47186
stp47187
a((dp47188
g2
(lp47189
VThe reason you see a garbage value in the output is that the local  variable of  is uninitialized:
p47190
aVWith this change in place, your program should produce the output that you expect
p47191
aVNote that returning  directly from  is an alternative to calling : you can replace that call with
p47192
as(dp47193
g6
V335858
p47194
stp47195
a((dp47196
g2
(lp47197
VIn C++ when you declare a pointer, the constructor needs to be called manually, like this:
p47198
aVThis is different from objects defined as objects, not as pointers:
p47199
aVIn this case the object is returned by value, so its content gets copied in the process
p47200
aVWhen you create objects dynamically, the object pointed to by the pointer needs to be deleted in order to avoid memory leaks, like this:
p47201
as(dp47202
g6
V335858
p47203
stp47204
a((dp47205
g2
(lp47206
VThe regex is much simpler than that - all you need is to escape parentheses, like this:
p47207
aVYou do not need to use the  class explicitly, because  takes a regular expression
p47208
aVYour pattern replaces everything in a string that contains
p47209
aVHere is a demo on ideone
p47210
as(dp47211
g6
V335858
p47212
stp47213
a((dp47214
g2
(lp47215
VWhen the data on the sender's end is structured as a collection of named fields, you get back a dictionary for each group of named fields
p47216
aVIn this particular case, it looks like the outermost object has one field, which is a collection (i
p47217
ag630
aVa list or an array) of objects that each have a  and
p47218
aVIn other words, the sender sends you something like this:
p47219
as(dp47220
g6
V335858
p47221
stp47222
a((dp47223
g2
(lp47224
VHere is a general description of the algorithm:
p47225
aVOpen each file, and read its first item
p47226
aVGo through all files, and select one file with the smallest current item; if multiple files have the same item, pick the first file that has the item
p47227
aVRemove the smallest item from the file that you identified in step 2, and write it to the output file
p47228
aVIf the file from which you removed the item has ended, close the file, and remove it from the list of files
p47229
aVIf the list of files is not empty, go back to step 2
p47230
aVBefore going through with the algorithm your code needs to check that at least one input file is present; otherwise, your code should exit
p47231
aVEDIT : Your  code does not look much like the algorithm above; here is some code to help you get started:
p47232
as(dp47233
g6
V335858
p47234
stp47235
a((dp47236
g2
(lp47237
VXib files do not represent real code for views, only the structure of the view's data
p47238
aVEach xib (or a storyboard) has enough information to do all of the following:
p47239
aVInstantiate elements of the view
p47240
aVSet properties of individual elements of the view
p47241
aVConnect elements of the view in a hierarchy
p47242
aVConnect "outlets" of objects in the Nib to properties or variables of views in your code
p47243
aVHowever, there is no "real code" there, only the metadata
p47244
aVCocoa has enough smarts to build and connect the objects, but the actual code is always in your
p47245
aVm files
p47246
as(dp47247
g6
V335858
p47248
stp47249
a((dp47250
g2
(lp47251
VGet the source of the JavaDoc from the OpenJDK, and build your own JAR from it with all the relevant JavaDoc classes
p47252
aVWrite a  plugin that relies on your JAR, and call  from it
p47253
aVIt does not look like you need to open up your sources when using OpenJDK's classes, you should be OK to distribute the resultant plug-in without harsh restrictions
p47254
aVEven if the terms do not cover the tools, you could write an Open Source GPL-2 plugin for , and make it a separate product that you distribute under GPL-2
p47255
aVYour product would then download and install the plugin using , thus separating out your JavaDoc plugin from the rest of your code
p47256
aVOf course you should run this suggestion by your legal department before following this advice
p47257
as(dp47258
g6
V335858
p47259
stp47260
a((dp47261
g2
(lp47262
VYes, this is definitely possible:  and its subclass  let you create and manage arrays dynamically, growing and shrinking them as needed
p47263
aVRather than using arrays of arrays of arrays, I would use special-purpose classes that hold arrays, but hide them, and present some functionality that is related to your specific application
p47264
aVFor example, you may want to consider creating a class for  and for
p47265
aVRoutine would have methods like
p47266
aVand so on, with  serving as a storage for exercises
p47267
as(dp47268
g6
V335858
p47269
stp47270
a((dp47271
g2
(lp47272
VOne way to do it is running a Fisher-Yates shuffle on the array, and pick the first two items
p47273
aVYou cab pick up an implementation from here
p47274
aVAll you need is to pass your array to , and pick the two initial items from the shuffled array
p47275
as(dp47276
g6
V335858
p47277
stp47278
a((dp47279
g2
(lp47280
VYou need to bring in the  into the -ed data set, add , and then project the unnecessary column out with another , like this:
p47281
as(dp47282
g6
V335858
p47283
stp47284
a((dp47285
g2
(lp47286
VYou can group by  to get your sums, like this:
p47287
as(dp47288
g6
V335858
p47289
stp47290
a((dp47291
g2
(lp47292
VThis is undefined behavior:
p47293
aVYou are writing into space allocated to a string literal, and
p47294
aVYou are writing past the allocated space
p47295
aVIn order to do the in-place concatenation, the destination must contain enough space to fit the result of the concatenation
p47296
aVHere is how you can fix it:
p47297
aVNote: You may want to change the signature of your function to indicate that the second string does not get modified:
p47298
as(dp47299
g6
V335858
p47300
stp47301
a((dp47302
g2
(lp47303
VThis is not a problem - in fact, it is a common practice to throw an exception in a base class, where the functionality is not implemented, and then override the implementation with something that does not throw
p47304
aVOnce you override a method, the method of the base class does not get called
p47305
aVOne downside to this is that the users would need to catch your exception if it happens to be of a checked (as opposed to "runtime") kind
p47306
aVA common solution is throwing an unchecked exception
p47307
aVOf course if the only purpose to throw an exception is indicating that the functionality is not implemented, it's best to mark the corresponding method , and let Java compiler catch the possible violations
p47308
as(dp47309
g6
V335858
p47310
stp47311
a((dp47312
g2
(lp47313
VAm i correct in thinking it can not override the super method m since it is (A,B)
p47314
aVYes, you are correct: this creates an overload, not an override of the method in the base class
p47315
aVWould it be able to override, if the parameters of the two methods were swapped
p47316
aVNo: to override, the method signatures must match exactly
p47317
aVSince it can neither override or overload, it does nothing and simply uses the method m in B class
p47318
aVNot exactly: the  overloads happens to be more specific than the  overload
p47319
aVDoes the inner class of the object, only work for itself
p47320
aVIs it like an anon class
p47321
aVYou would be able to invoke the method in the inner class, had you passed it a pair of s
p47322
as(dp47323
g6
V335858
p47324
stp47325
a((dp47326
g2
(lp47327
VNo, Java does not let you write a loop like that
p47328
aVWhat you can do is defining a generic method* , and put a call to that method in a body of your loop
p47329
aVThis way you would need to repeat only the loop header, and not the code inside the loop body
p47330
aV* If the two classes are related, a method that takes their common superclass would work as well
p47331
as(dp47332
g6
V335858
p47333
stp47334
a((dp47335
g2
(lp47336
VThis is called compile-time narrowing of constants
p47337
aVIt is described in section 5
p47338
aV2 of the Java Language Specification:
p47339
aVThe compile-time narrowing of constants means that code such as:
p47340
aVis allowed
p47341
aVWithout the narrowing, the fact that the integer literal 42 has type int would
p47342
aVmean that a cast to byte would be required
p47343
aVSame goes for character literals: if its value fits in a , no conversion is required; if the value does not fit, you must put in a cast, or you would get a compile error
p47344
aVFor example, this would not compile:
p47345
aVbut this compiles fine:
p47346
as(dp47347
g6
V335858
p47348
stp47349
a((dp47350
g2
(lp47351
VIf you need to do it only once, then the naive way is also the fastest way: walk the array, and keep the running total
p47352
aVOnce you reach the target sum, return the current index
p47353
aVIf you need to run multiple queries for different sums, create an array and set up sums in it, like this:
p47354
aVIf all values are positive, you can run binary search on  to get to the index in
p47355
as(dp47356
g6
V335858
p47357
stp47358
a((dp47359
g2
(lp47360
VAccording to Javadoc, it seems to be  but Eclipse links with
p47361
aVI couldn't find the place in Javadoc where it would suggest that the  overload would get called in this situation, but Eclipse is right: there is no implicit conversion from  to , but there is an implicit conversion from  to , so  is the correct overload
p47362
aVCalling Double
p47363
aVvalueOf with float round the result
p47364
aVIt does not "round" the result, it changes its representation to fit , which has higher precision
p47365
aVHowever, neither  nor  could represent  exactly, because it cannot be represented as a sum of negative powers of
p47366
aVIf you use  instead of , this would not happen, because  is , and therefore can be represented precisely in both  and
p47367
as(dp47368
g6
V335858
p47369
stp47370
a((dp47371
g2
(lp47372
VYour query string appears to be using double quotes instead of single quotes:
p47373
aVReplacing with single quotes should fix this syntax error:
p47374
aVHowever, unless  is built into your own program, do not use this method of deleting records: if the data comes from the user, you open your app to SQL injection attacks
p47375
as(dp47376
g6
V335858
p47377
stp47378
a((dp47379
g2
(lp47380
VJava provides good support for sorting already: all you need is converting your  to an array of , call  on it, and then convert that array back to
p47381
aVIf you want to have some fun with algorithms, however, you could try going for a linear counting sort: count the letters in the original, then go through the counts in alphabetical order, and write out the  number of characters
p47382
as(dp47383
g6
V335858
p47384
stp47385
a((dp47386
g2
(lp47387
VThis is because the  property is of type , i
p47388
ag630
aVan unsigned number
p47389
aVWhen you subtract  from it and the result becomes negative, it gets interpreted as a very large positive number
p47390
aVWhen you assign that result to an , you re-interpret it as a negative again, fixing the problem
p47391
aVThe best way of addressing this would be moving  to the other side of the expression, changing the sign to a , like this:
p47392
aVThe logic behind the expression would remain the same, but you would no longer see the signed/unsigned side effects caused by subtraction
p47393
as(dp47394
g6
V335858
p47395
stp47396
a((dp47397
g2
(lp47398
VSince this is likely a learning exercise, I would not suggest using a library function, assuming that you would rather fix your code
p47399
aVYour code is close to working:
p47400
aVYou swapped  and  in the code that accesses  - you need to access  with  and  with , not the other way around, because  goes up to  and  goes up to
p47401
aVYou need to reset  to zero when you find a mismatch - The  branch of the  needs to reset  after a partial match has been found
p47402
aVHere is your modified code running on ideone
p47403
ag1971
ag1972
aVLibrary-based solution is better :-)
p47404
as(dp47405
g6
V335858
p47406
stp47407
a((dp47408
g2
(lp47409
VYou could prohibit the number from containing all zeros with a negative lookbehind
p47410
aVThat would also invalidate all entries that consist of zeros and dots, but that's probably a good thing: it is very likely that since you do not want a standalone zero, you do not want , , or  as well:
p47411
aVThe part that I added to your expression checks that the string does not consist entirely of zeros and dots
p47412
aVHere is a demo on ideone
p47413
as(dp47414
g6
V335858
p47415
stp47416
a((dp47417
g2
(lp47418
VYou cannot make a decision that a key is not present until you finish processing the entire dictionary
p47419
aVMake a boolean variable initially set to , and change it to  if you find an item in the dictionary, like this:
p47420
as(dp47421
g6
V335858
p47422
stp47423
a((dp47424
g2
(lp47425
VIt looks like a little hack of retrieving the sequence of 40 alphanumeric characters should do the trick
p47426
aVUse this pattern ; the only match in your test string is going to be the commit number
p47427
aVThis prints
p47428
aVDemo on ideone
p47429
as(dp47430
g6
V335858
p47431
stp47432
a((dp47433
g2
(lp47434
VIf it were not an embedded system, you would probably be correct: I would bet that the programmers were unclear on the concept of the static, and must have meant to write this:
p47435
aVHowever, in an embedded system they could have used  to avoid allocating the variables in the automatic storage (i
p47436
ag630
aVon the stack)
p47437
aVThis could save a few CPU cycles, because the address of the static variable would be "baked into" the binary code of the compiled method
p47438
as(dp47439
g6
V335858
p47440
stp47441
a((dp47442
g2
(lp47443
VYou cannot do a cast: the query returns a  object, which cannot be cast to a  directly
p47444
aVInstead, you need to use  method instead:
p47445
as(dp47446
g6
V335858
p47447
stp47448
a((dp47449
g2
(lp47450
VYou can definitely have non-member functions in your cpp file
p47451
aVHowever, these functions may not be used before they declared or defined
p47452
aVTo declare a function, provide its prototype, like this:
p47453
aVPut this line above the member function that calls
p47454
aVThis should fix the compile problem that you are seeing
p47455
aVWhen you define functions like that, you may want to hide them not only from the header, but also from other modules that link to your library
p47456
aVIn order to do that, declare the function :
p47457
aVNote that when you do that to a free-standing function, the meaning of  is completely different: the function does not become a class function as class-scoped  functions; instead, it becomes a function with the visibility limited to the translation unit (i
p47458
ag630
aVa single cpp file where it is defined)
p47459
as(dp47460
g6
V335858
p47461
stp47462
a((dp47463
g2
(lp47464
VPassing a file through a translation unit - scoped variable (i
p47465
ag630
aVa ) is acceptable
p47466
aVHowever, it leaves some doubts as to who is responsible for calling
p47467
aVA better approach would be to have the function that opens the file return  to the caller, with the assumption that the caller would later call
p47468
aVBetter yet, let the function that calls  also do the : instead of opening the file, the first function could prepare the file name, and store it in a  variable
p47469
aVThen the reading function could call , do s, and call  all in a single function
p47470
as(dp47471
g6
V335858
p47472
stp47473
a((dp47474
g2
(lp47475
VYou can try this with a pair of  and a pair of calls of , like this:
p47476
aVIf you would like to also add the total time per day, you can do this:
p47477
as(dp47478
g6
V335858
p47479
stp47480
a((dp47481
g2
(lp47482
VThese two loops are not equivalent: the second one is similar to a / loop, not a  loop:
p47483
aVThe two should be the same as far as the performance goes; however, the readability of the solution with the  suffers considerably, so I would refrain from using it in any of your projects
p47484
as(dp47485
g6
V335858
p47486
stp47487
a((dp47488
g2
(lp47489
VSince your graph has no cycles* , you can negate the weights of your edges, and run Bellman-Ford's algorithm
p47490
aV*  Shortest path algorithms such as Floyd-Warshall and Bellman-Ford do not work on graphs with negative cycles, because you can build a path of arbitrarily small weight by staying in a negative cycle
p47491
as(dp47492
g6
V335858
p47493
stp47494
a((dp47495
g2
(lp47496
VThis is a relatively straightforward recursion:
p47497
aVThe first rule says that an empty list is already split into pairs; the second requires that the source list has at least two items, pairs them up, and inserts the result of pairing up the tail list behind them
p47498
aVHere is a demo on ideone
p47499
aVYour solution could be fixed as well by adding square brackets in the result, and moving the second part of the rule into the header, like this:
p47500
aVNote that this solution does not consider an empty list a list of pairs, so  would fail
p47501
as(dp47502
g6
V335858
p47503
stp47504
a((dp47505
g2
(lp47506
VSince the common ancestor of your classes is , and because  does not make things any cleaner (after all, everything extends ) it looks like  would be an OK choice
p47507
aVHowever, such list would be a mixed bag: you would need to check run-time type of the object inside, and make decisions based on that; this is definitely not a good thing
p47508
aVA better alternative would be creating your own class that implements operations on elements of the list the uniform way, and make one subclass for each subtype that implements these operations differently
p47509
aVThis would let you treat the list in a uniform way, pushing the per-object differentiation into your wrappers
p47510
aVNow you can make a list of  objects, and  on them without checking their type:
p47511
as(dp47512
g6
V335858
p47513
stp47514
a((dp47515
g2
(lp47516
VThere is a special method for this, called :
p47517
aVYou can do custom comparison of sequences using the  method
p47518
aVFor example, to see if any pair is not within the difference of three, you can do this:
p47519
as(dp47520
g6
V335858
p47521
stp47522
a((dp47523
g2
(lp47524
V and  work because C++ has built-in conversions among numeric types
p47525
aVIn particular, the  can be converted to  and to ; that is what's happening in your program: the conversion of  to  is performed with your user-defined conversion operator, and then the built-in conversion from  to  or  is performed to coerce the type to the desired target type
p47526
as(dp47527
g6
V335858
p47528
stp47529
a((dp47530
g2
(lp47531
VThe problem with your code is that you should not increment  after deletion
p47532
aVThe trick to deleting from the list that you iterate is iterating it backwards:
p47533
aVThis way your next iteration will never come to the index that you have visited already
p47534
as(dp47535
g6
V335858
p47536
stp47537
a((dp47538
g2
(lp47539
VWhat you are trying to do is very different from what the article does: the article teaches how to rewrite conditionals on a single row without the  statement; your task, on the other hand, needs conditions that must work across multiple rows
p47540
aVIn other words, article's conditions are horizontal, while you are looking for a vertical one
p47541
aVOne way to build a query that picks a single row is using
p47542
aVAssuming that  has a primary key called , you can do it like this:
p47543
aVHere is a demo on sqlfiddle
p47544
aVNote that in order for this to work, each individual  must return at most a single row
p47545
aVIn your case, there must be no more than one row for any combination of
p47546
as(dp47547
g6
V335858
p47548
stp47549
a((dp47550
g2
(lp47551
VIn Java,  is a numeric type
p47552
aVWhen you add  to a , you get to the next unicode code point
p47553
aVIn case of , the next code point is
p47554
as(dp47555
g6
V335858
p47556
stp47557
a((dp47558
g2
(lp47559
VIn terms of readability, enumerations make better constants than macros, because related values are grouped together
p47560
aVIn addition,  defines a new type, so the readers of your program would have easier time figuring out what can be passed to the corresponding parameter
p47561
aVCompare
p47562
aVto
p47563
aVIt is much easier to read code like this
p47564
aVthan this
p47565
aVbecause you know which constants it is OK to pass
p47566
as(dp47567
g6
V335858
p47568
stp47569
a((dp47570
g2
(lp47571
VThis will not be a problem functionally, but logically if the function must take an object as an argument, you should make this function
p47572
aVIn addition, since you are not modifying the incoming object, you should make the argument
p47573
aVFinally, since copying the object may be more expensive than copying a reference, you may want to change the argument to be passed by reference
p47574
as(dp47575
g6
V335858
p47576
stp47577
a((dp47578
g2
(lp47579
VIf you wrote a  from a file, you should read a  back; trying to read an  is not going to work
p47580
aVHowever, it rarely, if ever, makes sense two write out as binary a  that contains pointers
p47581
aVYou should either make them arrays of fixed size, or serialize them separately from your
p47582
aVEDIT : (in response to posted code) Most likely the problem has to do with writing an unknown number of characters in the second call of
p47583
aVWhen you serialize a C string, you should write out the number of characters before writing the characters themselves, so that when you read you'd know how much characters to allocate and to read back:
p47584
as(dp47585
g6
V335858
p47586
stp47587
a((dp47588
g2
(lp47589
VYou can do it without a stream: skip the initial spaces, locate the first space after that, walk to the next non-space, and use  to get the rest of the :
p47590
aVHere is a demo on ideone
p47591
as(dp47592
g6
V335858
p47593
stp47594
a((dp47595
g2
(lp47596
VYou can use , like this:
p47597
aVThis is a non-generic version; generic  lets you avoid the cast
p47598
as(dp47599
g6
V335858
p47600
stp47601
a((dp47602
g2
(lp47603
VHow is the div = 7 decided
p47604
aVThe author decided to "hard-code" his knowledge of the number itself to decide that the first three primes are not among the divisors
p47605
aVThe first condition checks whether the number equals 1 or not
p47606
aVFrom there i am not able to understand the rest of the code
p47607
aVThe rest of the code looks like this in "regular" integers:
p47608
aVwhy do we concatenate  here
p47609
aVThat is a short way of making an object a
p47610
aVhas a parameter that takes , so the alternative to this approach would be calling
p47611
aVNote that this is not the most efficient solution: one could speed this up by observing that you could stop trying to divide when you reach the square root of the original number, because you can be sure that the next divisor will be the number itself
p47612
as(dp47613
g6
V335858
p47614
stp47615
a((dp47616
g2
(lp47617
VYou cannot make  static in the base class, because then there would be a single token per all inherited classes
p47618
aVYou need to make it an instance variable
p47619
aVYou cannot even put it in a static method, because  methods in Java are not overridable
p47620
aVIn Java, variables are not overridable
p47621
aVIf you inherit a class and add a variable by the same name, the variable in the derived class will hide, not override the one in the base class
p47622
aVTo fix this, make  an  method in the base, provide an implementation in the derived class, and return the desired value
p47623
aVIf you do this, you could replace the abstract class with an interface, because there would be no variables or implementations in it:
p47624
aVAlternatively, leave it unassigned in the base, add a constructor that takes the value of the token, and assign it there:
p47625
as(dp47626
g6
V335858
p47627
stp47628
a((dp47629
g2
(lp47630
VOne way or the other, you would have to list the names of your  columns
p47631
aVYou can put it in the query, or you could define a special calculated column for the  at the table schema level, like this:
p47632
aVNow you can sum the  in all of your queries
p47633
aVOne advantage of this approach is that if you decide to add or remove another quantity level later on, you would need to change only the definition of the  column; all your queries referencing this calculated column would continue working automatically
p47634
as(dp47635
g6
V335858
p47636
stp47637
a((dp47638
g2
(lp47639
VParsing decimal numbers is locale-specific
p47640
aVYou need to change your statement to substitute the comma character  with a dot character  before giving it to MySQL
p47641
aVOne way to do it is adding a cast to your  statement:
p47642
aVYou need to list all the columns that you are importing
p47643
aVThe columns which you import "as is" need to be listed without an "at" sign ; the columns where you must replace commas with dots need to be listed with an "at" sign
p47644
aVFor each float column you need to add a  call on the last line
p47645
as(dp47646
g6
V335858
p47647
stp47648
a((dp47649
g2
(lp47650
VI think this may have to do with your code not allocating enough space for the pointers: since you are allocating eight pointers, not eight characters, this line
p47651
aVshould be
p47652
aVMaking this change fixes the problem (demo on ideone)
p47653
as(dp47654
g6
V335858
p47655
stp47656
a((dp47657
g2
(lp47658
VYou can make a function that takes two parts, allocates the space, and concatenates them
p47659
aVThis should reduce the code duplication, while keeping your code readable:
p47660
aVNow you can use this function as follows:
p47661
as(dp47662
g6
V335858
p47663
stp47664
a((dp47665
g2
(lp47666
VIn general,  is used to share things among all instances of the class (and optionally its subclasses)
p47667
aVIt does not have to be a state, as in a "singleton" or "shared counter" examples
p47668
aVIt does not need to be "global" either
p47669
aVIn fact, sharing state is less useful than sharing code, and is sometimes regarded as "code smell"
p47670
aVSharing code logic, on the other hand, is considered good, because it helps you increase code reuse
p47671
aVWhen you need to share code among all instances, say, a common implementation detail of some algorithm, you use a  method or an extension method, which must also be
p47672
aVBinary operators are defined with a  modifier, because they do not take an instance implicitly
p47673
aVThread-local variables need to be declared
p47674
as(dp47675
g6
V335858
p47676
stp47677
a((dp47678
g2
(lp47679
VCalling a destructor explicitly is a legal thing to do - in fact, that's what you do when you use placement
p47680
aVInitializing an object "in place", when the memory is already allocated, is also a legal thing do do, but you should do it differently: rather than using the assignment operator, you could use this syntax:
p47681
aVThe way you did it (with an assignment operator) is incorrect, because you are calling a function (i
p47682
ag630
aVthe assignment operator) on an object the destructor of which has completed
p47683
as(dp47684
g6
V335858
p47685
stp47686
a((dp47687
g2
(lp47688
VIn C/C++ it is OK to put a number in place of a boolean condition
p47689
aVWhen this happens, the result is considered  when the number is zero; otherwise, it is considered
p47690
aVNow you can easily see that the loop has an invalid termination condition: it expects to stop when the first zero is found in the array, but the array has no zeros, and so the loop continues beyond the array bounds
p47691
aVIn your case, it finds a zero after seven additional iterations, producing junk values (it could have crashed instead, because it's undefined behavior)
p47692
aVChanging the array initializer to include zero would fix the problem:
p47693
aVOf course, iterating up to the number of elements in the array would have worked as well
p47694
as(dp47695
g6
V335858
p47696
stp47697
a((dp47698
g2
(lp47699
VYou are assigning the result back to , which is
p47700
aVThe result of the cast is not used
p47701
aVHere is how you can fix the function:
p47702
aVA cast is an expression, not a declaration
p47703
aVWhen you do , the compiler calculates the value of the cast, which you can use in further calculations, but the variable itself remains unchanged
p47704
as(dp47705
g6
V335858
p47706
stp47707
a((dp47708
g2
(lp47709
Vgiven that the namespace matches and the interface definition is identical, why should it matter which assembly it is found in
p47710
aVThe choice of treating these interfaces as equivalent would make it harder to compare interfaces: rather than comparing a fixed set of items (i
p47711
ag630
aVthe qualified name and the assembly) CLR would need to compare the qualified name, and the list of all properties and all methods, along with their argument types, which would be recursive
p47712
aVDoing so would be prohibitively slow, especially if you want to do it consistently and include classes and s into a similar comparison scheme
p47713
aVNote: when you share a DLL with the developer in another country, make sure that your assembly has a strong name
p47714
aVThis would ensure that you both link to the same assembly, and detect mismatches early
p47715
aVFor example, if you change your interface, but the other developer sends you a plug-in compiled with an old DLL, the plugin would fail to load
p47716
as(dp47717
g6
V335858
p47718
stp47719
a((dp47720
g2
(lp47721
VHow can I have two instances of Operations
p47722
aVSINGLE with different operation type
p47723
aVThe fundamental idea behind an  is that there is one, and only one, instance of each of its members
p47724
aVThis is what lets you safely compare them for equality, without fear that there's another  or  created in some other place
p47725
aVIf you want multiple instances of , make it a , not an
p47726
aVThe fact that you made your  mutable indirectly points in the same direction: using  is a wrong choice in your situation
p47727
as(dp47728
g6
V335858
p47729
stp47730
a((dp47731
g2
(lp47732
VIf I delete the this-pointer in A* pointer from B, is C going to get destructed
p47733
aVYes, even though the pointer is to the base class, the entire chain of destructors will be invoked, because the destructor in the base class is
p47734
aVWhat if I declare ~B as virtual too
p47735
aVYou already did: since  is , the destructors of all its derived classes will be implicitly  as well
p47736
as(dp47737
g6
V335858
p47738
stp47739
a((dp47740
g2
(lp47741
VYour  function is very wrong: how could it return  when you expect it to reverse a string
p47742
aVThere are several ways to fix it:
p47743
aVRemove the , and make the function
p47744
aVCall it before printing, and then output the original
p47745
aVMake it return , and return
p47746
aVMove  statement out of the loop
p47747
aVDo not reverse in place: make a copy of the string, and reverse it; don't forget to allocate space for null terminator, and delete the copy of the string once you are done
p47748
as(dp47749
g6
V335858
p47750
stp47751
a((dp47752
g2
(lp47753
VI ran it in debug just to see what happens, somehow manner changed from "Hello" to "World"
p47754
aVThat's precisely what your code told it to do, so there's no surprise that it did what you asked for
p47755
aVand also the pointer changed even due I have declared it a
p47756
aVYou declared it a pointer to , not a  pointer (I know, this may sound confusing)
p47757
aVWhen you write , it means that what's pointed to is
p47758
aVIf you want to say that the pointer itself is , you need
p47759
as(dp47760
g6
V335858
p47761
stp47762
a((dp47763
g2
(lp47764
VI think at this point [after ] reference variable  becomes invalid, because the  is just reallocated
p47765
aVAm I correct
p47766
aVYes, you are correct
p47767
aVThe  may or may not be reallocated, but since there is a possibility, you should consider the prior reference invalidated
p47768
aVWhat's the way around of this problem
p47769
aVIf you pre-allocated enough elements upfront, or use a plain C array instead of a vector, the reference would remain valid
p47770
aVYou must ensure that the capacity is sufficient for the worst-case scenario to run without re-allocations
p47771
aVIf you always access the elements sequentially, another solution could be using a linked list, because adding elements to a linked list do not change references to its existing elements
p47772
as(dp47773
g6
V335858
p47774
stp47775
a((dp47776
g2
(lp47777
VSince the  method is , all data members, including the , are treated as constants
p47778
aVHowever, the  operator on a  is not constant
p47779
aVUse the  method instead, it has a  overload:
p47780
as(dp47781
g6
V335858
p47782
stp47783
a((dp47784
g2
(lp47785
VOne should not change the primary key - ever
p47786
aVMoreover, it may be beneficial to think about PKs as non-numeric values
p47787
aVImagine that you use autogenerated GUIDs for your primary keys
p47788
aVIf you want to renumber your items, then the column that you want to change should be a separate numeric column, which you treat explicitly as a sequence number of sorts
p47789
aVThen you can do what you want with three  statements:
p47790
as(dp47791
g6
V335858
p47792
stp47793
a((dp47794
g2
(lp47795
VRead the file on one thread, adding its lines to a blocking queue
p47796
aVStart  tasks reading from that queue
p47797
aVSet max size of the queue to prevent out of memory errors
p47798
as(dp47799
g6
V335858
p47800
stp47801
a((dp47802
g2
(lp47803
VThat's not how you do the separation
p47804
aVThe  (i
p47805
ag630
aVthe declaration) goes into the header; the CPP file should have method implementations, like this:
p47806
aVand so on
p47807
aVNote the  part of the fully qualified name: this is what tells the compiler that the function that you are defining belongs to the  class
p47808
as(dp47809
g6
V335858
p47810
stp47811
a((dp47812
g2
(lp47813
VWhen you build an identity hash map, there is no chance of finding two instances that are equal to each other yet are not the same object
p47814
aVIt also uses , which has a chance of collisions that is known upfront to the designers of , and is known to be very small
p47815
aVUnder these "laboratory" conditions, linear probing appears to be a better choice in terms of performance
p47816
aVI suspect that the reason the designers of the class library used chaining rather than linear probing in "regular" hash maps is their desire to maintain decent performance even when hash functions are suboptimal
p47817
as(dp47818
g6
V335858
p47819
stp47820
a((dp47821
g2
(lp47822
VI\u0441 the same principles for HashSet's
p47823
aVYes,  uses the same exact general principle: the keys inserted into the set are arranged according to their hash codes, using the  method to resolve collisions
p47824
aVObviously, it cannot compute a hashcode from 's key, because it doesn't have one
p47825
aVOf course it has, and it can
p47826
aVIn fact, hash keys is all the  has -- just keys, no values
p47827
aVIn a  the "value" is passive: that's something stored at the key; hash maps never look at values; in particular, maps never check values for equality, or compute their hash code
p47828
aVYou can think of a hash set as a hash map that maps everything to
p47829
as(dp47830
g6
V335858
p47831
stp47832
a((dp47833
g2
(lp47834
VYes, your code is sufficient to clear the inner maps and the vectors they contain
p47835
aVDestructors of the containers will take care of clearing out the resources held in keys and values of the maps
p47836
aVOf course the emptied map itself will not be deallocated until it gets destroyed, either by going out of scope or by virtue of its owner object being deleted
p47837
as(dp47838
g6
V335858
p47839
stp47840
a((dp47841
g2
(lp47842
VVariables behave like that because they lack behavior
p47843
aVIn other words, variables are passive
p47844
aVThere is nothing about a variable's definition that a derived class can reasonably change by overriding:
p47845
aVIt cannot change its type, because doing so may break methods of the base class;
p47846
aVIt cannot reduce its visibility, because that would break the substitution principle
p47847
aVIt cannot make it  without making it useless to the base class
p47848
aVTherefore, member variables declared in derived classes hide variables from the base class
p47849
as(dp47850
g6
V335858
p47851
stp47852
a((dp47853
g2
(lp47854
VSince the "first property" on a generic type is something known to the caller of the method that converts your  to , the caller can pass a lambda that selects the first (second, third) item as needed, like this:
p47855
aVYou can call this method like this:
p47856
aVThis approach lets you stay away from modifying your classes by introducing unnecessary interfaces, and allows working with third-party classes as well
p47857
as(dp47858
g6
V335858
p47859
stp47860
a((dp47861
g2
(lp47862
VYou can use  method to chop off the last two characters, like this:
p47863
aVThis approach would work even for strings that have fewer than two characters
p47864
as(dp47865
g6
V335858
p47866
stp47867
a((dp47868
g2
(lp47869
VYou can do it like this:
p47870
aVYour solution was close - you needed to add a selection of  to complete it
p47871
as(dp47872
g6
V335858
p47873
stp47874
a((dp47875
g2
(lp47876
VWhat you are describing looks very much like extension methods of C#
p47877
aVDefine them in a separate  class, and use them as if they were instance methods
p47878
as(dp47879
g6
V335858
p47880
stp47881
a((dp47882
g2
(lp47883
VThe junk may come from two places:
p47884
aVWhen dynamic RAM is powered up, the cells remain in arbitrary state until initialized; this is a property of most hardware implementations of memory
p47885
aVWhen your program runs, it leaves behind values of variables that have been used before but are no longer in scope
p47886
aVThis property may be used for attacks: analyzing junk left over by your program may give information to unscrupulous writers of plug ins or other libraries that you use
p47887
as(dp47888
g6
V335858
p47889
stp47890
a((dp47891
g2
(lp47892
VUsing default values produced by Java is absolutely OK, you do not need to explicitly initialize instance or  fields of your
p47893
aVJava Language Specification requires this, so any implementation of the language must comply
p47894
aVIn other words, your code would remain 100% portable if you use default values of member variables
p47895
aVThis applies to both primitive and reference types (the later are initialized with )
p47896
aVSee Java Language Specification, page 81, for more details
p47897
ag14885
aV12
p47898
aV5 Initial Values of Variables
p47899
aVEvery variable in a program must have a value before its value is used:
p47900
aV- Each class variable, instance variable, or array component is initialized with a
p47901
aVdefault value when it is created
p47902
aVThe only case where you must provide explicit initialization is when you declare local variables:
p47903
aVA local variable must be explicitly given a value before it is used, by either initialization or assignment, in a way that can be verified using the rules for definite assignment
p47904
aVHowever, since failure to initialize a local is a compile-time error, the compiler will pinpoint every missing initialization before you can run your program
p47905
as(dp47906
g6
V335858
p47907
stp47908
a((dp47909
g2
(lp47910
VThe reason the exception happens is that you pass an index of  for the array that has 100 elements
p47911
aVIn Java, this means that only indexes 0
p47912
aV99 are valid
p47913
aVIf the value of  in  comes from the user, and if you expect the user to enter a number between 1 and 100, then you need to subtract  before using the user-entered value to index the array of students
p47914
as(dp47915
g6
V335858
p47916
stp47917
a((dp47918
g2
(lp47919
VTraversal of structures is not the defining feature of the visitor pattern
p47920
aVIn fact, one could think of your use of visitors to traverse objects with structures as a fancy iterator
p47921
aVWhat differentiates visitors from iterators is that visitors let you do the so-called Double Dispatch, i
p47922
ag630
aVrouting a message to a method that depends both on the runtime type of the object being visited and the visitor object
p47923
aVThe object being visited is external to the visitor, but the executable code of the operation is contained inside the visitor
p47924
aVIn other words, following the visitor pattern lets you perform operations that are external to the object being visited, which could be thought of as defining new operations on the object
p47925
as(dp47926
g6
V335858
p47927
stp47928
a((dp47929
g2
(lp47930
VEven though both your  and  constructor take ,  interprets  differently: it tries to map them one-to-one to the parameters of the method being tested
p47931
aVIn your case, NUnit expects a  with 12 parameters, but your method has only two
p47932
aVThis causes the error that you see
p47933
aVTo fix this problem, you need to change the constructor call as follows:
p47934
aVNow you are passing only two arguments, the second one being an array that must be passed to your
p47935
as(dp47936
g6
V335858
p47937
stp47938
a((dp47939
g2
(lp47940
VPrepend the  in front of the string, and  at the end:
p47941
aVThis tells the regex engine that the string between  and  must be interpreted verbatim, ignoring any metacharacters that it may contain
p47942
as(dp47943
g6
V335858
p47944
stp47945
a((dp47946
g2
(lp47947
VWhat's going on here is undefined behavior: you are telling  to copy the first ten characters of whatever the token is, but when the token is more than ten characters long, it means that the string is not going to be null-terminated
p47948
aVPassing such strings to  is undefined behavior
p47949
aVTo fix this problem, you should either force termination by setting  if you want to stay with fixed-length strings, or use  to allow variable-length strings
p47950
aVFinally, there is a thread-safe alternative to using  - you can use
p47951
as(dp47952
g6
V335858
p47953
stp47954
a((dp47955
g2
(lp47956
VIt appears that the bytes represent unsigned 16-bit integers, with the most significant byte coming second, and the bits above 8-th truncated
p47957
aVYou can do the conversion like this:
p47958
aVWhen I added printing of  in the loop I got these values:
p47959
as(dp47960
g6
V335858
p47961
stp47962
a((dp47963
g2
(lp47964
VYou do not LINQ extension methods for this - you can create a new list explicitly, like this:
p47965
as(dp47966
g6
V335858
p47967
stp47968
a((dp47969
g2
(lp47970
VYou cannot do that: in SQL, table names and column names must be identifiers embedded in the SQL string itself
p47971
aVThey cannot come from values that you query, or even in a query parameter
p47972
aVYou need to select the table name, make the  statement, and then execute it separately
p47973
as(dp47974
g6
V335858
p47975
stp47976
a((dp47977
g2
(lp47978
VIf you can compare instances of  regardless of whether they are  or , then your solution with the  in the superclass alone makes perfect sense
p47979
aVIf the implementation requires knowledge of data specific to the subclasses, add abstract methods that supply this data to , and call them in your comparator
p47980
as(dp47981
g6
V335858
p47982
stp47983
a((dp47984
g2
(lp47985
VRight-click the project in VS 2012, and choose  from the context menu
p47986
aVPublishing to a file lets you create an installer:
p47987
aVChoose a location in the file system to which you would like to save the installer
p47988
aVClick
p47989
aVWait for the publishing operation to complete
p47990
aVA  installer file will be created at the location that you have selected in the first step of the publish wizard
p47991
aVShare the installer with the people to whom you would like to give your application
p47992
as(dp47993
g6
V335858
p47994
stp47995
a((dp47996
g2
(lp47997
VYou can work around this problem by re-formulating your query condition like this:
p47998
aVDemo on sqlfiddle
p47999
aVThe problem is that logic operators are not short-circuited in SQL, so the optimizer treats  as something that it can pre-compute to speed up the query
p48000
aVBy expanding the condition to a  that depends entirely on  you can eliminate the execution of the  branch when  returns "false"
p48001
as(dp48002
g6
V335858
p48003
stp48004
a((dp48005
g2
(lp48006
V adds the newline character by the library specification
p48007
aVYou can use  instead, where you can control what gets printed with a format string:
p48008
as(dp48009
g6
V335858
p48010
stp48011
a((dp48012
g2
(lp48013
VThere are several issues with your implementation:
p48014
aVThe call of  must come from inside a  block
p48015
aVYour implementation creates "lingerers" - a kind of Java memory leak, when objects are prevented from being collected for longer than they should be
p48016
aVTo fix this, set the element that you return from  to
p48017
aVYou do not need to use  and fill it with s; a plain array of  would be sufficient
p48018
aVYou would need to add casting, but it's going to be there anyway, with or without , so you might as well move it into your code
p48019
aVYou should not synchronize on
p48020
aVThis last point allows malicious users of your queue permanently stall the progress by synchronizing on the queue object itself, and not releasing a lock
p48021
as(dp48022
g6
V335858
p48023
stp48024
a((dp48025
g2
(lp48026
VThere is an alternative syntax for accessing items pointed by a pointer - the square brackets
p48027
aVThis syntax lets you access data through pointers as if the pointer were an array (of course, pointers are not arrays)
p48028
aVAn expression  is simply an alternative form of writing *
p48029
aVWhen you allocate dynamic storage and assign it to , you can use the pointer like a dynamic array that can change size at runtime:
p48030
aV*  Incidentally, commutativity of  lets you write  instead of ; don't do that
p48031
as(dp48032
g6
V335858
p48033
stp48034
a((dp48035
g2
(lp48036
VYou can store everything as an , but rather than performing a straight cast, use generics to build an easy to use API:
p48037
aVThe cast remains there, but the API hides it from the user: now the user can safely write
p48038
as(dp48039
g6
V335858
p48040
stp48041
a((dp48042
g2
(lp48043
VCocoa lets you access properties and fields using Key-Value Coding
p48044
aVIf an  (mutable or not) has a name of a property, you can use that string to retrieve a value of the corresponding property from an object:
p48045
as(dp48046
g6
V335858
p48047
stp48048
a((dp48049
g2
(lp48050
VYou cannot initialize references through assignments
p48051
aVThey need to be initialized in the constructor's initializer list, like this:
p48052
as(dp48053
g6
V335858
p48054
stp48055
a((dp48056
g2
(lp48057
VIt appears that you are looking for a custom class:
p48058
aVNow you can initialize your array as follows:
p48059
as(dp48060
g6
V335858
p48061
stp48062
a((dp48063
g2
(lp48064
VThis is because there is something else that can supply the type information in the second case (namely, the type of the variable)
p48065
aVIn cases like that suffixes are not required
p48066
aVHowever, you may need them in other cases, when the type information must be derived from the numeric literal itself
p48067
aVFor example, consider the two expressions below:
p48068
aVvs
p48069
aVYou would get different results with and without the suffix
p48070
as(dp48071
g6
V335858
p48072
stp48073
a((dp48074
g2
(lp48075
VYou can  the unwanted characters from both ends of your string before passing it for splitting using the  method, like this:
p48076
aVnow the result of the  would no longer have the unwanted characters on either end:
p48077
as(dp48078
g6
V335858
p48079
stp48080
a((dp48081
g2
(lp48082
VThis is just wrong:
p48083
aVAs for no segfault part, undefined behavior may not manifest itself right away: for example, when you free a wrong region, the freeing itself may work, but a subsequent allocation could fail
p48084
aVIf you would like to shorten the string, make a copy, and free the original:
p48085
aVIn general, you can free only what you have allocated
p48086
aVThe main reason for this is that // store "bookkeeping" information in the memory associated with the address returned to you, often in a block immediately prior to the allocated address
p48087
aVYou can try faking it, but even if it works, the solution would be fragile and non-portable
p48088
as(dp48089
g6
V335858
p48090
stp48091
a((dp48092
g2
(lp48093
VSince the key does not represent a string in any particular encoding, only a somewhat arbitrary sequence of bytes, only your first method is going to succeed:
p48094
aVBase-64 format is portable, so you can pass that string to other languages for decoding by means of the Base-64 library available on the target platform
p48095
as(dp48096
g6
V335858
p48097
stp48098
a((dp48099
g2
(lp48100
VIs  the same as
p48101
aVYes, it is the same
p48102
aVWithout losing generality, you can say that
p48103
aVTherefore,  is the same as
p48104
aVAt the same time, , so  is the same as , which is in turn the same as
p48105
as(dp48106
g6
V335858
p48107
stp48108
a((dp48109
g2
(lp48110
VYou can use  on , like this:
p48111
aVDemo on sqlfiddle
p48112
as(dp48113
g6
V335858
p48114
stp48115
a((dp48116
g2
(lp48117
VIn Java, you cannot have executable statements, such as invocations of the  method, outside a definition of a method or a constructor
p48118
aVDeclarations are OK, but executable statements are not
p48119
aVYou can add these items to a named constructor, but you can also use an anonymous initialization block, like this:
p48120
aVIf you use a block like that, it would be shared among all named constructors of the class, or it would become part of the implicitly generated constructor for the
p48121
as(dp48122
g6
V335858
p48123
stp48124
a((dp48125
g2
(lp48126
VYou can use  to find the items that two collections have in common, and then apply  to see if the intersection has at least three items:
p48127
aVA couple of notes on your implementation:
p48128
aVRather than using a  and setting values to , use a : you are interested in keys, not values, so a  would be more appropriate
p48129
aVDo not convert numbers to strings until you need to display them; searching for numbers is best done with a collection of numbers
p48130
aVIf you use a set, the selection can be rewritten as follows:
p48131
aVEDIT : (in response to an edit of the question) Your  class contains player's numbers as separate attributes
p48132
aVYou can add a way of retrieving them as a collection by adding a property , like this:
p48133
as(dp48134
g6
V335858
p48135
stp48136
a((dp48137
g2
(lp48138
VAssuming that  defines a  operator in a way similar to , you can change this to
p48139
aVUnlike Java, C++ allows writing custom comparison operators
p48140
aVThat's how C++ lets you write comparisons of custom objects in a more natural way - instead of explicitly invoking the , you can use the  operator
p48141
aVHere is how the operator can be defined:
p48142
as(dp48143
g6
V335858
p48144
stp48145
a((dp48146
g2
(lp48147
VYou can "pay" with memory for CPU cycles
p48148
aVIf you have 256 bytes of ROM available to you, the cheapest way of computing such function would be building a lookup table
p48149
aVMake a program that prints a list of 256 8-bit numbers with the values of your non-linear function
p48150
aVIt does not matter how fast the program is, because you are going to run it only once
p48151
aVCopy the numbers the program prints into your C program as an array initializer, and perform the lookup instead of calculating the function
p48152
as(dp48153
g6
V335858
p48154
stp48155
a((dp48156
g2
(lp48157
VThe  does not need to evaluate the expression that you pass to it, only its type
p48158
aVExternal definition  is sufficient to figure out the type, so  succeeds
p48159
aVMoreover, since the expression inside  does not get evaluated, the program links without an error
p48160
as(dp48161
g6
V335858
p48162
stp48163
a((dp48164
g2
(lp48165
V13 is the decimal value of CR ASCII code (carriage return), 10 is the decimal value of LF ASCII code (line feed), 0 is the terminating zero for the string
p48166
aVThe idea behind this constant is to change to the next line before printing
p48167
aVZero terminator is necessary for the printing subroutine to know when to end printing
p48168
aVThis is similar to null terminating of C strings
p48169
as(dp48170
g6
V335858
p48171
stp48172
a((dp48173
g2
(lp48174
VYou can use s to do the sorting:
p48175
aVYou can read more about sorting with descriptors here
p48176
as(dp48177
g6
V335858
p48178
stp48179
a((dp48180
g2
(lp48181
VIn C,  is not a preprocessor directive: unlike , it is not a textual substitution
p48182
aVIt gives an alternative name to an existing type, so both  and  will be of the same type - namely, , which is an alias for
p48183
aVMoreover, you can write this:
p48184
aVto make  an  and  an
p48185
as(dp48186
g6
V335858
p48187
stp48188
a((dp48189
g2
(lp48190
VIn C, everything is passed as values, including pointers
p48191
aVTherefore, your code that swaps pointers manipulates pointer copies, leaving originals unchanged
p48192
aVIn order to swap pointers, you need to pass pointers to pointers, not simply pointers
p48193
aVOf course inside the function you need to add a level of dereference the same way that you did in :
p48194
as(dp48195
g6
V335858
p48196
stp48197
a((dp48198
g2
(lp48199
VYou can use  method of LINQ, like this:
p48200
aVNote that this would re-create the list, rather than removing the duplicates in place
p48201
as(dp48202
g6
V335858
p48203
stp48204
a((dp48205
g2
(lp48206
VAlthough postfix  changes  before the assignment is done, the value of the expression remains the original value of , which is
p48207
aVThis is what gets assigned to
p48208
aVHere is what's going on:
p48209
aVis assigned
p48210
aVs value is saved before the increment
p48211
aVis incremented, and the new value  is stored in
p48212
aVThe saved value of  is stored back in
p48213
as(dp48214
g6
V335858
p48215
stp48216
a((dp48217
g2
(lp48218
VPackage-private visibility does not violate encapsulation any more than the private visibility does, but on a different level: rather than operating on the fine-grained class-by-class level, package-private visibility lets you control encapsulation at the more coarse-grained package-by-package level
p48219
aVThis may be important in situations when you create helper classes that need to be visible to all other classes in your module, but must not be visible outside it
p48220
aVTo you, the writer of the module, such classes constitute a private implementation detail, so if you move them to a different package, you run no risk of breaking anybody else's code; only your code may need to be refactored
p48221
aVProtected visibility, on the other hand, controls access along the "vertical" lines of inheritance (as opposed to package-private visibility, which is "horizontal")
p48222
as(dp48223
g6
V335858
p48224
stp48225
a((dp48226
g2
(lp48227
VHow can I save the initial valeu of the vector ints
p48228
aVMake a copy of the array, like this:
p48229
aVNote that this makes a shallow copy of the array
p48230
aVIt does not matter for primitives, but for reference types you may need to make more work to make a copy
p48231
as(dp48232
g6
V335858
p48233
stp48234
a((dp48235
g2
(lp48236
VWelcome to undefined behavior: the fact that it does not crash does not mean that it works
p48237
aVAccessing uninitialized pointer is always wrong, yet sometimes it does not crash
p48238
aVcouldn't deference and assign unless you either malloc'd space for it or set it to the address of another variable
p48239
aVThis is correct
p48240
aVIn general, you need to point your pointer to some place that has been allocated to your program
p48241
aVThere are multiple ways of doing that, but they all boil down to one of the two scenarios that you describe - the pointer is pointed either to a dynamically allocated memory (i
p48242
ag630
aV), or to statically allocated memory (i
p48243
ag630
aVa variable)
p48244
as(dp48245
g6
V335858
p48246
stp48247
a((dp48248
g2
(lp48249
VIn cases like this, you need to total up the number of rows in all sections prior to this one rather than using :
p48250
aVNote that the code is somewhat redundant: it repeats the same calculations over and over for each cell
p48251
aVYou can add a new  which has the same number of items as , but rather than containing the individual count, each item should contain the sum of counts in the sections less than the current one
p48252
aVWith an array like that you'd be able to avoid the loop by writing
p48253
as(dp48254
g6
V335858
p48255
stp48256
a((dp48257
g2
(lp48258
VUnfortunately, this is not possible, unless the class "cooperates"
p48259
aVSince the only difference between an indexer and any other method is that indexer offers a special syntax, iterating over all keys is generally not possible for the same reasons why it is not possible to go through all values returned by a function
p48260
aVConsider someone writing an "indexer" that takes a , and returns its reversed value
p48261
aVIn C# this would be a valid indexer; however, it would be unusable for the purposes of enumerating all its possible values
p48262
aVHowever, classes that expose indexers often implement
p48263
aVFor example,  exposes , which lets you enumerate keys along with their corresponding values
p48264
aVOf course classes do not have to do it, but when they do, your code can exploit that to construct whatever output that you need
p48265
as(dp48266
g6
V335858
p48267
stp48268
a((dp48269
g2
(lp48270
VIt looks like you do not want to print  array: it's of little use
p48271
aVYou need to print the primes from the Sieve of Eratosthenes, which can be done by enumerating the indexes, checking if  is , and printing the index if it is
p48272
as(dp48273
g6
V335858
p48274
stp48275
a((dp48276
g2
(lp48277
VThe snippet in your post has two problems with inclusion guards:
p48278
aVdefinition is checked, but  is defined - this is likely a typo - such guard does not "guard" anything
p48279
aVYou should fix this to
p48280
aVDefinition of  inclusion guard is checked outside  - this is a very bad pattern: it is aimed at optimizing inclusions by preventing the opening of the  by looking at its private inclusion guard
p48281
aVThis practice makes your builds very fragile
p48282
aVIf the authors of  decided to guard their includes with  instead of , the guard inside your header would fail
p48283
as(dp48284
g6
V335858
p48285
stp48286
a((dp48287
g2
(lp48288
VAlthough your quote from K&R; is correct, I do not expect this piece of code to generate a warning, because errors like that are very difficult to track in general case
p48289
aVFor example, consider a piece of code where your pointer initially points to a block of modifiable memory, then you manipulate it a little, and then assign it to point to a string literal:
p48290
aVFor a compiler, it would be very tricky to track these assignments and issue a warning
p48291
aVCovering all cases would be impossible, because a pointer to a string literal could come from an externally linked function
p48292
as(dp48293
g6
V335858
p48294
stp48295
a((dp48296
g2
(lp48297
VI have tried iterating through the old and the new arrays using loops and if conditions, but is it getting really messy and buggy
p48298
aVThis is not a simple problem
p48299
aVFirst, note that it may have multiple solutions:
p48300
aVboth  and  are valid solutions
p48301
aVWhat you are probably looking for is a minimal solution
p48302
aVOne way to get a minimal solution is by finding the Longest Common Subsequence (LCS) of the two sequences
p48303
aVThe algorithm for finding LCS will tell you which elements of the two sequences belong to the LCS, and which do not
p48304
aVIndexes of each element of the original array that is not in LCS go into the  array; indexes of elements of the new array that are not in LCS go into the  array
p48305
aVHere are a few examples (I parenthesized the elements of LCS):
p48306
aVThe items of  not in LCS are 1 and 4; the items of  not in LCS are 1, 4, and 5
p48307
aVHere is another example:
p48308
aVNow  is  and  is
p48309
as(dp48310
g6
V335858
p48311
stp48312
a((dp48313
g2
(lp48314
V encodes bytes with non-printable ASCII values
p48315
aVmeans ,  means ,  means , and so on
p48316
aVYour computer stores the data starting with least significant byte
p48317
aVFirst four columns represent your ; the next three are the
p48318
aVFinally, there is a padding of 1 byte between the s
p48319
as(dp48320
g6
V335858
p48321
stp48322
a((dp48323
g2
(lp48324
VAbove function is called in implicit way but wanted to know how it would be called explicit way
p48325
aVLike this:
p48326
aVWhat is difference between implicit and explicit way of dereferencing function pointer
p48327
aVThere is no difference: since all you can do with a function pointer is call a function that it points to, compiler ignores explicit dereferences of function pointers
p48328
as(dp48329
g6
V335858
p48330
stp48331
a((dp48332
g2
(lp48333
VIn order to do this when the table name is the same, you need to give aliases to the tables:
p48334
aVI used  to denote "outer answers" and  to denote "inner answers"
p48335
as(dp48336
g6
V335858
p48337
stp48338
a((dp48339
g2
(lp48340
VThe return value of  is passed as part of the the return status
p48341
aVUse  to retrieve it:
p48342
as(dp48343
g6
V335858
p48344
stp48345
a((dp48346
g2
(lp48347
VI think that this is because the variable Cities is created only once
p48348
aVThis is correct: there will be only one call of ; if it fails, there will be no other calls
p48349
aVTo fix this problem, change  to a read-only property, and cache the results of  when you do get the results
p48350
as(dp48351
g6
V335858
p48352
stp48353
a((dp48354
g2
(lp48355
VThe  method retains the new object, releases the old object, and makes an assignment into the array that backs the 's data
p48356
aVThese operations will not cause memory issues even when the object being assigned is already stored in the array at the same position
p48357
aVThese operations are performed very quickly, so checking equality before the assignment would likely be a waste of time
p48358
as(dp48359
g6
V335858
p48360
stp48361
a((dp48362
g2
(lp48363
VOne solution is to not  the  property, and write the code for it yourself
p48364
aVAdd a private  variable to your class, and write the  and  methods
p48365
aVThe getter should return the "backing" variable; the setter should check the old and the new value to see if the old value is  and the new value is
p48366
aVWhen this is the case, the setter should change the title of the button as appropriate
p48367
as(dp48368
g6
V335858
p48369
stp48370
a((dp48371
g2
(lp48372
VThe message means that the class name is not in scope
p48373
aVshould not include , it should include
p48374
aVSame goes for  inclusion of
p48375
aVIn general, you never want to  a CPP file - from a header or from another CPP file
p48376
aVOnly  header files are designed for inclusion by preprocessor
p48377
aVIn case of circular definitions like this, you should forward-declare the class the pointer to which you are defining, and forego inclusion of that class's header:
p48378
as(dp48379
g6
V335858
p48380
stp48381
a((dp48382
g2
(lp48383
VIt appears that you are providing definitions of  and  in the cpp file
p48384
aVIn this case you should put the functions in the namespace  where they are declared, rather than importing that namespace with :
p48385
aVThe  directive tells the compiler that you want to call functions and refer to classes from the namespace  without qualifying their names explicitly; you can have multiple such directives in your file
p48386
aVIt does not tell the compiler that the definitions that you provide below should belong to the namespace , so the compiler dumps them in the top-level namespace
p48387
aVThe end result is that the compiler sees two s - the  declared in the  namespace, with external definition, and  defined in your cpp file in the default namespace
p48388
as(dp48389
g6
V335858
p48390
stp48391
a((dp48392
g2
(lp48393
VThere regex  is an equivalent of
p48394
aVa regex character class that matches a single character
p48395
aVWhen you put a dash in its definition, as in , the class is expanded to include the ends (i
p48396
ag630
aVand ) along with all characters with code points between the two ends (i
p48397
ag630
aVand )
p48398
aVBoth ends could be the same, as in , in which case the expression is equivalent to
p48399
aVThat's why  is functionally equivalent to
p48400
as(dp48401
g6
V335858
p48402
stp48403
a((dp48404
g2
(lp48405
VAnother option is using 's  method: put your string objects into an , make a string out of them, and write the whole thing to a file:
p48406
as(dp48407
g6
V335858
p48408
stp48409
a((dp48410
g2
(lp48411
VYou should not inherit publicly unless the class that you are writing indeed extends the class from which you are inheriting, i
p48412
ag630
aVis a kind of
p48413
aVThis is known as Liskov substitution principle
p48414
aVViolating it leads to serious readability and maintainability issues in your code
p48415
aVThe rules are less strict with private inheritance, but in general you should prefer composition to private inheritance, except under very specific circumstances
p48416
aVThe upshot of this is that your first code snippet (with the composition) does everything right, you do not need to change it
p48417
as(dp48418
g6
V335858
p48419
stp48420
a((dp48421
g2
(lp48422
VHow do I create two triggerless segues such that I manually choose to execute only one of the two at run time depending on if the user is logged in or not
p48423
aVCreate the first triggerless segue leading to the logon screen; give it an identifier, say,
p48424
aVCreate the second triggerless segue leading to the tab view; give it an identifier, say,
p48425
aVDefine an action in the main view controller, and put this code in its associated method:
p48426
as(dp48427
g6
V335858
p48428
stp48429
a((dp48430
g2
(lp48431
VIn C there is no "strong" built-in type for Boolean values, so integers are used instead
p48432
aVResults of evaluating logical expressions, such as ones using  and , can be assigned to integer variables
p48433
aVWhen a value is used in a logical operator, the Boolean interpretation is very straightforward: zeros are interpreted as , while all non-zero values are interpreted as
p48434
aVNow you should be able to figure out the expressions for yourself:
p48435
aVevaluates as , because  and  are not zeros
p48436
aVevaluates as , because  is zero,
p48437
aVand so on
p48438
as(dp48439
g6
V335858
p48440
stp48441
a((dp48442
g2
(lp48443
VYou can use LINQ for that:
p48444
aVThis would filter out strings that consist entirely of digits, along with empty strings
p48445
as(dp48446
g6
V335858
p48447
stp48448
a((dp48449
g2
(lp48450
VAbsolutely
p48451
aVThat is what Liskov substitution principle is about
p48452
aVIf you properly subclass  from , you will have no problem substituting  with its subclass
p48453
as(dp48454
g6
V335858
p48455
stp48456
a((dp48457
g2
(lp48458
VYou can do this with LINQ's  method, like this:
p48459
aVNote that this would not compute a transitive closure of your graph, i
p48460
ag630
aVonly the direct links will be present
p48461
aVIn
p48462
aVNET 4 and up you can also use  instead of making your own  class
p48463
as(dp48464
g6
V335858
p48465
stp48466
a((dp48467
g2
(lp48468
VThis should do the trick:
p48469
aVThis is nearly self-explanatory: you are looking for all files  in  such that a file name  exists in the  where  is contained anywhere in  as a substring
p48470
aVEDIT : (in response to a comment) To get the  along with , add a , and use an anonymous type, like this:
p48471
as(dp48472
g6
V335858
p48473
stp48474
a((dp48475
g2
(lp48476
VIf you can tolerate a different kind of placeholder (i
p48477
ag630
aVin place of ) you can use  method for that:
p48478
as(dp48479
g6
V335858
p48480
stp48481
a((dp48482
g2
(lp48483
VYour interval is expressed in milliseconds, while the  expects an interval expressed in seconds
p48484
aVDivide the number by 1000 to get the right value:
p48485
as(dp48486
g6
V335858
p48487
stp48488
a((dp48489
g2
(lp48490
VI just don't fundamentally understand why a string wouldn't just end on its last char
p48491
aVThere are several ways of knowing where is the "last char":
p48492
aVStore the number of characters in the string separately from the string's characters,
p48493
aVPut a marker that indicates the last char of the string, or
p48494
aVStore the pointer to the last char of the string separately from the string's characters
p48495
aVC choose the second route; other languages (Pascal, etc
p48496
aVchoose the first route
p48497
aVSome implementations of C++  choose the third route*
p48498
aV* Even  implementations that use the first or the third approach null-terminate their buffers for compatibility with the C portions of the library
p48499
aVThis is necessary to ensure that  returns a valid C string
p48500
as(dp48501
g6
V335858
p48502
stp48503
a((dp48504
g2
(lp48505
VThe syntax goes as follows:
p48506
aVThere is one statement that follows , and one statement that follows the optional
p48507
aVEach statement could be a block statement, in which case you must enclose it in a pair of curly braces
p48508
aVSince you do have curly braces, the nested  is a  in the syntax above; therefore,  belongs to the outer
p48509
aVNote that if you remove the curly braces,  would belong to the inner
p48510
as(dp48511
g6
V335858
p48512
stp48513
a((dp48514
g2
(lp48515
VThe expression
p48516
aVreturns  string
p48517
aVCalling  with that string as the argument will perform the replacement throughout the entire string, so it would replace both occurrences
p48518
aVTo fix your solution, you can replace the call of  with a composition of three substrings:
p48519
aVfrom zero to
p48520
aVfrom  to the end
p48521
aVLike this:
p48522
as(dp48523
g6
V335858
p48524
stp48525
a((dp48526
g2
(lp48527
VI would use this expression:
p48528
aVThe capturing group would match everything after the first underscore  all the way to the second underscore or to the end or the string, whichever comes first
p48529
as(dp48530
g6
V335858
p48531
stp48532
a((dp48533
g2
(lp48534
VIn case when two classes or structs must reference each other, you need to add a forward declaration for one or the other, like this:
p48535
aVNote that  would work as well instead of , letting you skip the forward declaration:
p48536
as(dp48537
g6
V335858
p48538
stp48539
a((dp48540
g2
(lp48541
V is a good start (remember that the function returns zero when the match is found)
p48542
aVNext, you need to check that
p48543
aVcharacter 3 is a digit,
p48544
aVcharacter 4 is a comma, and
p48545
aVcharacter 5 is a digit
p48546
aVThis results in the following expression:
p48547
aVNote the use of  to test that a character is a digit
p48548
aVIf the numbers could span more than a single digit, you could use : this would also let you retrieve the values:
p48549
as(dp48550
g6
V335858
p48551
stp48552
a((dp48553
g2
(lp48554
Vgcc 4
p48555
ag837
aV3 supports many c++11 features
p48556
aVHowever, they are disabled by default
p48557
aVTo enable them, use the following flag:
p48558
aVThis flag also disables GNU extensions; to keep them enabled, use  flag
p48559
as(dp48560
g6
V335858
p48561
stp48562
a((dp48563
g2
(lp48564
VYou can use this bit hack:
p48565
as(dp48566
g6
V335858
p48567
stp48568
a((dp48569
g2
(lp48570
VIf voucher numbers are formatted with a fixed number of digits, this can be solved with a simple  query:
p48571
aVHere is a demo on sqlfiddle
p48572
as(dp48573
g6
V335858
p48574
stp48575
a((dp48576
g2
(lp48577
VIn this context  means that not all  may do something useful in the implementation
p48578
aVAlthough providing an implementation is indeed mandatory, it is OK to throw an exception to indicate that the method is not implemented
p48579
as(dp48580
g6
V335858
p48581
stp48582
a((dp48583
g2
(lp48584
VThere is no performance implications, only the scope ones
p48585
aVYou should always define variables in the innermost scope possible
p48586
aVThis improves readability of your program
p48587
as(dp48588
g6
V335858
p48589
stp48590
a((dp48591
g2
(lp48592
VThis primarily applies to the portions of the standard C++ library that have been "inherited" from C
p48593
aVIn pre-C89 standards of the C language the significant portion of external identifiers has been limited to 6 characters; linkers were allowed to ignore the remaining characters
p48594
aVThat is why the standard C library limited identifier length to 6 characters
p48595
aVC++ incorporated that library "wholesale", along with somewhat cryptic identifiers
p48596
as(dp48597
g6
V335858
p48598
stp48599
a((dp48600
g2
(lp48601
VOne picture is worth thousand words, so here is what is going on:
p48602
aVAs you can see, the two variables  in the caller and  in the  reference the same object initially
p48603
aVAfter the assignment, they reference different objects, explaining the behavior that you see: since  is passed by reference, and because you created a new  rather than modifying the existing one,  becomes unrelated to  after the assignment
p48604
aVNote that if you modified the existing dog, the picture would have been different: if you did  inside , rather than , the results would be different: the diagram would still look like the middle picture, but the dog's name would have been
p48605
as(dp48606
g6
V335858
p48607
stp48608
a((dp48609
g2
(lp48610
VThe interviewer is looking to see if you know a trick that is known officially as , or  unofficially
p48611
aVThe idea is to advance two pointers in a loop, one moving twice per iteration, and the other only once
p48612
aVIf the fast-moving pointer catches up to the slow-moving one from behind, the list has a cycle
p48613
aVThis algorithm detects a cycle in  time and  storage
p48614
aVThe "slow" pointer goes through the list no more than once, so it is fair to say that the algorithm finds an answer in a single traversal
p48615
aVIn my opinion this algorithm makes a poor interview question, because it is somewhat hard to come up with it on the spot, unless you know it ahead of time
p48616
aVAt the same time, this is not a an algorithm that is used so widely that everyone must know it, making me wonder why anyone would ask about it in an interview
p48617
as(dp48618
g6
V335858
p48619
stp48620
a((dp48621
g2
(lp48622
VWhen you convert from an integral type to a floating point one, it is always clear what you want to do: you change number's representation, but you keep the same number
p48623
aVConverting from floating point to integral types, on the other hand, has some ambiguity: it is not clear what you would like to do with the fractional part
p48624
aVYou may want to
p48625
aVTruncate the fractional part,
p48626
aVPerform mathematical rounding, or
p48627
aVRound the number up
p48628
aVThat's why the language asks you to be specific about what you want to do when converting floating-point numbers to integral types
p48629
as(dp48630
g6
V335858
p48631
stp48632
a((dp48633
g2
(lp48634
VYou can define wrapper boolean values, and use the  overload for , like this:
p48635
as(dp48636
g6
V335858
p48637
stp48638
a((dp48639
g2
(lp48640
VIn C++ you can use  to go through permutations one by one
p48641
aVYou need to sort the characters alphabetically before calling  for the first time:
p48642
aVHere is a demo on ideone
p48643
aVIf you must implement permutations yourself, you could borrow the source code of , or choose a simpler way of implementing a permutation algorithm recursively
p48644
as(dp48645
g6
V335858
p48646
stp48647
a((dp48648
g2
(lp48649
VYou can replace the conditional with a  lookup to avoid the warning:
p48650
as(dp48651
g6
V335858
p48652
stp48653
a((dp48654
g2
(lp48655
VI guess the instance get the same reference
p48656
aVso the same iterator
p48657
aVEven if  happens to be such that it returns the same instance of * , you would get a different instance of  in , so you are safe
p48658
aV*  If your  is a , you would get different instances from the calls of
p48659
as(dp48660
g6
V335858
p48661
stp48662
a((dp48663
g2
(lp48664
VThe best way to draw something repeatedly is to avoid drawing it if it is already on the screen
p48665
aVSince audio meters tend to update frequently, but most of their area stay the same, because audio signals are relatively smooth, you should track what's drawn, and draw only the differences
p48666
aVFor example, if you have drawn a signal meter with fifty green squares in a previous update, and now you need to draw forty eight green squares, you should redraw only the two squares that are different from the previous update
p48667
aVThis should save you a lot of quartz calls
p48668
as(dp48669
g6
V335858
p48670
stp48671
a((dp48672
g2
(lp48673
VI think the key word in "whether or not a C++ function will change the value of a particular variable" is "will"
p48674
aVIt is certainly possible to build a compiler that checks whether or not a C++ function is allowed to change the value of a particular variable, you cannot say with certainty that the change is going to happen:
p48675
as(dp48676
g6
V335858
p48677
stp48678
a((dp48679
g2
(lp48680
VNull coalesce operator lets you write code much more succinctly: rather than using a conditional statement or a conditional expression, you write the equivalent expression in a single line
p48681
aVCompare your expression to this
p48682
aVthis
p48683
aVor this:
p48684
aVYour expression is much easier to read than any of the above
p48685
aVIn addition, this operator lets you avoid introducing a temporary variable or even save you a function call in situations when  is not in a variable, but comes from a function instead:
p48686
aVvs
p48687
as(dp48688
g6
V335858
p48689
stp48690
a((dp48691
g2
(lp48692
VSince you are using , not , you need to override  and , not , in your  class:
p48693
as(dp48694
g6
V335858
p48695
stp48696
a((dp48697
g2
(lp48698
VWhen you set a pointer to , the pointer points to a character at a position in memory that is one  before your allocated string
p48699
aVDereferencing such pointer is undefined behavior - the program may print anything, or even crash
p48700
as(dp48701
g6
V335858
p48702
stp48703
a((dp48704
g2
(lp48705
VDeclaring with  lets you shorten the code, but the variable that you declare remains statically typed, and the scope of that variable does not change
p48706
aVIf you need to use a variable outside , declare it before the  statement, like this:
p48707
aVNow you can use  outside the
p48708
aVNote: There are cases where you must use  because the type that you assign to it has no name, but in your first case the type has a name, so you do not need to use
p48709
aVEDIT : Your second case, however, does require a , because you are selecting an anonymous type
p48710
aVIn situations like that there are several ways around this problem:
p48711
aVYou can declare a named type for the "superset" of columns that you select (i
p48712
ag630
aV, , and ), or
p48713
aVIn
p48714
aVNET 4
p48715
aV0 you can use
p48716
aVThis shifts some of compile-time checking into runtime, but if you have to go this route, it is very convenient
p48717
as(dp48718
g6
V335858
p48719
stp48720
a((dp48721
g2
(lp48722
V is a  array
p48723
aVWhen you pass it to  or other functions, it decays to a pointer, so you do not need the  operator:
p48724
aVWhen you read strings with , it is a good idea to pass the size limit: this lets you avoid buffer overruns
p48725
aVSince  is declared as , you pass 19, because one more  needs to be reserved for the null terminator
p48726
as(dp48727
g6
V335858
p48728
stp48729
a((dp48730
g2
(lp48731
VOne would think that since this notation works in C++ source code, the standard library has a way to parse this
p48732
aVThe library and the compiler are unrelated
p48733
aVThe reason this syntax works in C++ is that the language allows you to assign expressions of type  to integer variables:
p48734
aVassigns a  expression (i
p48735
ag630
aVa numeric literal of type ) to an integer variable
p48736
aVKnowing what's going on here you should be able to easily identify the function in the Standard C++ Library that does what you need
p48737
as(dp48738
g6
V335858
p48739
stp48740
a((dp48741
g2
(lp48742
VDefine a  extension method, like this:
p48743
aVNow you can use this method as follows:
p48744
as(dp48745
g6
V335858
p48746
stp48747
a((dp48748
g2
(lp48749
VBefore continuing with the comparison, you should move the condition inside   like this:
p48750
aVAs far as the performance goes, you should see no difference
p48751
aVOn readability, however, the modified LINQ version wins hands down
p48752
as(dp48753
g6
V335858
p48754
stp48755
a((dp48756
g2
(lp48757
VNames of both function-style and constant-style preprocessor definitions must be valid C++ identifiers
p48758
aVThey cannot contain the  symbol, so your trick is impossible to do with the preprocessor
p48759
as(dp48760
g6
V335858
p48761
stp48762
a((dp48763
g2
(lp48764
VIterators in the Standard C++ Library are modeled after pointers, not after indexes
p48765
aVIn the same way that pointers cannot be shared among multiple arrays, iterators cannot be shared among vectors or other collections
p48766
aVIf you need to iterate multiple vectors in parallel, you can use indexes rather than iterators
p48767
aVIf you need to find the position of an iterator, you can use  like this:
p48768
aVIf you need to move an iterator  in vector  to the same position as iterator  in vector , you can do this:
p48769
as(dp48770
g6
V335858
p48771
stp48772
a((dp48773
g2
(lp48774
VThis code is incorrect for two reasons:
p48775
aVYou declare a variable-length array as external
p48776
aVThis is not allowed
p48777
aVEven if the arrays were fixed-length, you would need to define these arrays some place else
p48778
aVTo fix this code, define  and  with the  size that you expect the users to enter (add validation to make sure that the input size does not exceed )
p48779
aVHere is a link to a answer on a related subject: What are  variables in C
p48780
as(dp48781
g6
V335858
p48782
stp48783
a((dp48784
g2
(lp48785
VYou can use a conditional expression using :
p48786
aVHere is a demo on sqlfiddle
p48787
as(dp48788
g6
V335858
p48789
stp48790
a((dp48791
g2
(lp48792
VThe error is in the declaration of :
p48793
aVYour declaration suggests a person with 100 possible names and 100 possible nationalities, which must be dynamically allocated
p48794
aVThis is not the intended use of : it appears that you wanted a single name / nationality, with 99 characters + the null terminator each
p48795
as(dp48796
g6
V335858
p48797
stp48798
a((dp48799
g2
(lp48800
VSince formatting is a display concern independent of data storage, and because the same piece of data may be formatted differently based on the environment, you should store unformatted data in the database, and format it as appropriate in your application
p48801
aVYou may build an application where the same data could be viewed from different locales
p48802
aVThe same amount of money, point in time, or a number may need to be formatted differently for different users, depending on where they are coming from
p48803
aVYour data model should (of which MySQL is a big part) should not deal with formatting at all, otherwise the presentation layer would need to convert the data from one format to another
p48804
aVThis is suboptimal, and may lead to maintainability nightmares
p48805
aVThat is why you should strive to store the data in a way that is independent of the presentation formatting
p48806
as(dp48807
g6
V335858
p48808
stp48809
a((dp48810
g2
(lp48811
VStatic methods do not need an instance reference to the object of their class in order to run, because they do not reference any of the non-static fields, properties, or methods
p48812
aVWhen C# compiler detects you calling  methods on an object reference, it suspects that you wanted to call some other method, and issues the error that you see
p48813
aVReplace
p48814
aVwith
p48815
aVto fix this problem
p48816
as(dp48817
g6
V335858
p48818
stp48819
a((dp48820
g2
(lp48821
VIt seems to me that the two constructors share the same signature although they have different generic type arguments
p48822
aVThey do
p48823
aVThe signature is
p48824
aVWhy
p48825
aVBecause of type erasure implementation of generics in Java: references to generic types are converted to  in all contexts where they are used; the generic type is known only to the compiler
p48826
aVAnd how to work around this problem
p48827
aVUnfortunately, you cannot easily work around this problem in a constructor
p48828
aVYou can replace the overloaded constructors with factory methods, and give different names, say  and :
p48829
as(dp48830
g6
V335858
p48831
stp48832
a((dp48833
g2
(lp48834
VString literal is a special, simple, form of writing an array aggregate: you can write  instead of  (note the terminating zero, which is added automatically)
p48835
aVNote that an array declaration is not only possible, but is sometimes desirable:
p48836
aVlets you modify the string, as opposed to
p48837
aVwhich does not allow modifications
p48838
as(dp48839
g6
V335858
p48840
stp48841
a((dp48842
g2
(lp48843
VBlocks of logic in C# are passed as delegates
p48844
aVThere are several ways of declaring a delegate - you can define a custom one, or use one of predefined types:
p48845
aVYou can use  for delegates that do not return values, or
p48846
aVYou can use  for delegates that return values
p48847
aVHere is one way to define a function that takes a delegate:
p48848
aVCall  with a named or an anonymous delegate which could be defined inline, as a named method, or as a lambda expression:
p48849
as(dp48850
g6
V335858
p48851
stp48852
a((dp48853
g2
(lp48854
VYou can use LINQ, like this:
p48855
as(dp48856
g6
V335858
p48857
stp48858
a((dp48859
g2
(lp48860
VIn pre-ANSI C it was common to have functions with no prototype
p48861
aVIn this case only the default type promotions took place
p48862
aVWhen there is a prototype, each parameter expression is converted to the type expected by the function, as if there were a cast:
p48863
aVThe above call is equivalent to calling
p48864
aVThis is important because of an implicit agreement between the caller and the callee on passing parameters: the way a parameter is passed, as well as the memory footprint of the parameter, depends on the type
p48865
aVIf the caller does not place parameters in memory in the right format, the callee would not be able to use the parameters correctly
p48866
aVThat's why the two must agree on the type of each parameter in some way
p48867
aVThe standard says that the "agreement" comes in the shape of a function prototype
p48868
aVIf the prototype is missing, the standard supplies the "default agreement", i
p48869
ag630
aVand  become , and  becomes
p48870
as(dp48871
g6
V335858
p48872
stp48873
a((dp48874
g2
(lp48875
VAbsolutely - all you need to do is combining the two approaches that you have:
p48876
aVIterate the list using  the way you do it in the second approach;
p48877
aVcheck for the current  to be a  the way you do it in the first approach
p48878
aVThis combination would let you find the , and  it using the iterator
p48879
aVHere is how you can do that:
p48880
as(dp48881
g6
V335858
p48882
stp48883
a((dp48884
g2
(lp48885
VThe reason why  test has failed is that equality considers not only the value of the number, but also its type
p48886
aVobject does not compare as  to a
p48887
aVSince  returns an , Java wraps it into  before passing to
p48888
aVThat's why you could fix the test case by using  instead:
p48889
as(dp48890
g6
V335858
p48891
stp48892
a((dp48893
g2
(lp48894
VSince the memory for the object and its members is allocated before the call of the constructor, the value of  pointer itself is not the issue: it's the members that you might dereference off of it that may be an issue
p48895
aVYour first code fragment is valid, because  is identical to , which is a valid expression
p48896
aVYour second code fragment may or may not be OK, depending on what the constructor of  does:
p48897
aVIf  constructor simply stores the pointer to  for future use, this is OK
p48898
aVIf  constructor calls methods off of the pointer to  passed into it, this is not OK, because the instance to which the  pointer is pointing has not been initialized
p48899
as(dp48900
g6
V335858
p48901
stp48902
a((dp48903
g2
(lp48904
VYou do not need an outer loop: to get the tuition ten years from now, multiply today's tuition by ; that would be your new  10 years from now
p48905
aVAfter that, you can run a single loop to add four numbers - , , , and
p48906
aVHowever, that is not necessary either: all you need is calculating a sum of geometric series using the well-known formula:
p48907
as(dp48908
g6
V335858
p48909
stp48910
a((dp48911
g2
(lp48912
VJava annotations cannot change the way the compiler generates byte code from your classes
p48913
aVYou use annotations to tell the compiler how you think your program should be interpreted, and report errors when compiler's interpretation does not match your intentions
p48914
aVHowever, you cannot use annotations to force the compiler to produce code with different semantics
p48915
aVWhen your subclass declare a method with the same name and parameter count as in its superclass, Java must decide between two possibilities:
p48916
aVYou want the method in the subclass to override the method in the superclass, or
p48917
aVYou want the method in the subclass to overload the method in the superclass
p48918
aVIf Java allowed  to override  the language would have to introduce an alternative syntax for indicating an intent to overload a method
p48919
aVFor example, they could have done it in a way similar to C#'s  and  in method declarations
p48920
aVFor whatever reason, however, the designers decided against this new syntax, leaving the language with the rules specified in JLS 8
p48921
ag14885
ag20244
ag1340
aVNote that the current design lets you implement the functionality of an override by forwarding the call from the overloaded function
p48922
aVIn your case, that would mean calling  from  like this:
p48923
aVHere is a demo on ideone
p48924
as(dp48925
g6
V335858
p48926
stp48927
a((dp48928
g2
(lp48929
VNo, this is not normal practice
p48930
aVExceptions should be used to handle exceptional situations, not the regular code flow
p48931
aVYour code uses / to detect situations that could be handled without introducing exceptions
p48932
aVIt is roughly equivalent to the following method:
p48933
aVThe imaginary  method returns  when  call would not throw , and  otherwise
p48934
aVMaking a method like  and using it instead of catching the exception is a better way of coding methods where exceptions are caught during the normal program flow
p48935
as(dp48936
g6
V335858
p48937
stp48938
a((dp48939
g2
(lp48940
VYou can get as many digits as the string has using  qualifier:
p48941
aVRead the value from the  capture group
p48942
as(dp48943
g6
V335858
p48944
stp48945
a((dp48946
g2
(lp48947
VTo avoid multiple use of escape characters in the regex string (one level of escaping is removed by the Java compiler; the other level is removed by the regex engine) it is possible to "escape" characters by enclosing them in square brackets
p48948
aVFor example,  would become a more readable
p48949
aVIn your case, you could tell Java not to use a dot that is between two digits, because it's a decimal separator:
p48950
aVHere is a demo on ideone
p48951
as(dp48952
g6
V335858
p48953
stp48954
a((dp48955
g2
(lp48956
VThe problem with your approach that leads to the behavior that you see is that your code never copies the data from the buffer
p48957
aVThis line
p48958
aVputs a pointer to the same  from  at all eight locations
p48959
aVSubsequent calls to  override the content of previous reads, so you end up with eight copies of the last line
p48960
aVYou can fix this issue by making a copy, e
p48961
ag303
aVwith  or by allocating memory with  and making a copy
p48962
aVYou need to  everything that you allocate, though
p48963
as(dp48964
g6
V335858
p48965
stp48966
a((dp48967
g2
(lp48968
VBits in a byte are numbered right-to-left, not left-to-right
p48969
aVThat's why setting bits  defines this pattern:
p48970
as(dp48971
g6
V335858
p48972
stp48973
a((dp48974
g2
(lp48975
VThe implementation of  is highly specific to the system in which it is implemented
p48976
aVImplementations are often hardware-assisted
p48977
aVMemory-to-memory mov instructions are not that uncommon - they have been around since at least  times, when you could write something like this:
p48978
aVThe commented line is roughly equivalent to C's
p48979
aVContemporary CPUs have instructions that implement  directly: you load special registers with the source and destination addresses, invoke a memory copy command, and let CPU do the rest
p48980
as(dp48981
g6
V335858
p48982
stp48983
a((dp48984
g2
(lp48985
VJava compiler has special syntax for creating string objects from string literals
p48986
aVWhen you write
p48987
aVJava creates a new  object, ans assigns it to
p48988
aVNote that this is not directly equivalent to , because strings instantiated from string literals are interned
p48989
aVThis means that strings created from the same literal are not only object-equal, but also reference-equal (i
p48990
ag630
aVreference the same object)
p48991
as(dp48992
g6
V335858
p48993
stp48994
a((dp48995
g2
(lp48996
VYou can compare  to  to check if there is more than one specific character in a  without explicit counting:
p48997
as(dp48998
g6
V335858
p48999
stp49000
a((dp49001
g2
(lp49002
VThe first snippet creates one object, and gives it two "names" (references)
p49003
aVThe second snippet creates two objects, but then "forgets" the second one, and replaces it with a reference to the first object:
p49004
aVThe last diagram shows the second object with no references
p49005
aVAt this point the object becomes eligible for garbage collection
p49006
as(dp49007
g6
V335858
p49008
stp49009
a((dp49010
g2
(lp49011
VThe  keyword of C++11 is far less heavyweight than templates - its compile-time "overhead" is comparable to that of , which means it's close to zero
p49012
aVUnlike templates where the compiler needs to perform sizeable amount of computation during the expansion (the template language in C++ is Turing-complete), the  keyword requires the compiler to figure out the type of an expression, which is something the compiler knows anyway
p49013
aVIn fact, it would have to figure out the type of the expression even without the  keyword to decide if type conversions need to be applied
p49014
as(dp49015
g6
V335858
p49016
stp49017
a((dp49018
g2
(lp49019
VTo make instance variables public, use  keyword, like this:
p49020
aVOf course you need to remember all the standard precautions of exposing "raw" variables for public access: you would be better off with properties, because you would retain flexibility of changing their implementation at some later time
p49021
aVFinally, you need to remember that accessing public variables requires a dereference - either with an asterisk or with the  operator:
p49022
as(dp49023
g6
V335858
p49024
stp49025
a((dp49026
g2
(lp49027
VIn order for the  to return the correct object, your  class needs to override the  method
p49028
aVOf course you also need to override  as well: although  of  does not call , the two methods need to be changed together:
p49029
aVTypes that override  must also override ; otherwise, hash tables might not work correctly
p49030
as(dp49031
g6
V335858
p49032
stp49033
a((dp49034
g2
(lp49035
VSQL does not treat  values as zeros when calculating , it ignores them:
p49036
aVReturns the sum of all the values, or only the  values, in the expression
p49037
aVNull values are ignored
p49038
aVThis makes a difference only in one case - when the sequence being totalled up does not contain numeric items, only s: if at least one number is present, the result is going to be numeric
p49039
as(dp49040
g6
V335858
p49041
stp49042
a((dp49043
g2
(lp49044
VThis should work:
p49045
aVThe idea is to use zero-length lookbehind for a lowercase letter, and zero-length lookahead for the uppercase letter
p49046
aVThis construct would match only at the "word breaks" in camel case strings
p49047
aVHere is a demo on ideone
p49048
as(dp49049
g6
V335858
p49050
stp49051
a((dp49052
g2
(lp49053
VYour code exhibits undefined behavior
p49054
aVDestroying memory is not the same as destroying, say, a book or a vase: the memory does not disappear, and some of its content may remain untouched
p49055
aVHowever, accessing such memory makes your program illegal: your program no longer owns that chunk of memory, it belongs to some other code or to another part of your program
p49056
aVAny part of that memory can be overwritten at any time
p49057
aVMoreover, your program can crash when you access such memory
p49058
as(dp49059
g6
V335858
p49060
stp49061
a((dp49062
g2
(lp49063
VNo, not necessarily
p49064
aVMoreover, even the signs of the two numbers may not remain the same
p49065
aVConsider this decimal example: let's say that  is 4 decimal digits, and  is 2 decimal digits
p49066
aVNow consider two numbers -  and
p49067
aVThe second number is larger than the first, but after the conversion which truncates the upper half you would get  and , so the first number would become larger than the second one
p49068
aVOf course  and  use binary, not decimal representation, but the same principle applies: the upper half represents higher-order digits; when they get truncated, the remaining portions of the two numbers may compare to each other in any of the three ways (less than, equal, or greater than)
p49069
as(dp49070
g6
V335858
p49071
stp49072
a((dp49073
g2
(lp49074
VThe first code snippet shares both variables: they get allocated statically, and all threads would use them in concurrent environments
p49075
aVThis is very bad - one should avoid situations like that in production code
p49076
aVThe second and the third code snippets are thread safe
p49077
aVThe third snippet groups variables  and ; the second snippet does not
p49078
aVIn addition, the third snippet needs an extra allocation of an object, and creates an object to be collected upon return (of course it never returns because of the infinite  loop, so it does not really matter)
p49079
aVIf the two variables do not belong together logically, you should avoid making a class for them
p49080
aVIf they do belong together, you should move the code that uses these variables into the class that declares them
p49081
aVAs far as the performance and memory implications go, the third snippet requires an extra chunk of memory compared to the second one, but it is too small to pay attention to
p49082
aVThe performance difference will be nearly impossible to detect, so you should not worry about it much: in most cases, it is best to optimize your code for readability
p49083
as(dp49084
g6
V335858
p49085
stp49086
a((dp49087
g2
(lp49088
VThe problem is on this line:
p49089
aVSince you declare  as a parameter, it remains in scope for the entire forward declaration
p49090
aVTherefore, its name shadows the type name : inside the forward declaration of ,  refers to the first parameter, not to the  type
p49091
aVRename it to  to fix this problem:
p49092
as(dp49093
g6
V335858
p49094
stp49095
a((dp49096
g2
(lp49097
VTo get a value of the five most significant bits in a byte as an integer, shift the byte to the right by  (i
p49098
ag630
aVby ), and set the three upper bits to zero using bitwise  operation, like this:
p49099
aVis the "shift right" operator
p49100
aVIt moves bits 7
p49101
aV3 into positions 4
p49102
aV0, dropping the three lower bits
p49103
aVis the binary number , which has the upper three bits set to zero, and the lower five bits set to one
p49104
aV-ing with this number zeroes out three upper bits
p49105
aVThis technique can be generalized to get other bit patterns and other integral data types
p49106
aVYou shift the bits that you want into the least-significant position, and apply a mask that "cuts out" the number of bits that you want
p49107
aVIn some cases, shifting would not be necessary (e
p49108
ag303
aVwhen you get the least significant group of bits)
p49109
aVIn other cases, such as above, the masking would not be necessary, because you get the most significant group of bits in an unsigned type (if the type is signed, ing would be required)
p49110
as(dp49111
g6
V335858
p49112
stp49113
a((dp49114
g2
(lp49115
VRecursion does not need to be infinite in order to cause stack overflow: all it needs it to be just long enough to overflow the stack
p49116
aVQuicksort may be very slow: under some particularly unfortunate circumstances, it may take up to  invocations, for the worst-case performance of
p49117
aVYou have two choices - rewrite the code without recursion by using an explicit stack data structure, or by increasing the size of stack that JVM allocates to your program's threads
p49118
as(dp49119
g6
V335858
p49120
stp49121
a((dp49122
g2
(lp49123
VThe expression that you are looking to build should be as follows:
p49124
aVYou need to wrap the strings , , etc
p49125
aVin  -  in case the strings contain regex metacharacters
p49126
aVTo fix the addition of leading  use a boolean variable that indicates if this is the first iteration through the loop or not:
p49127
as(dp49128
g6
V335858
p49129
stp49130
a((dp49131
g2
(lp49132
VThe problem with treating values polymorphically boils down to the object slicing issue: since derived objects could use more memory than their base class, declaring a value in the automatic storage (i
p49133
ag630
aVon the stack) leads to allocating memory only for the base, not for the derived object
p49134
aVTherefore, parts of the object that belong to the derived class may be sliced off
p49135
aVThat is why C++ designers made a conscious decision to re-route virtual member-functions to the implementations in the base class, which cannot touch the data members of the derived class
p49136
as(dp49137
g6
V335858
p49138
stp49139
a((dp49140
g2
(lp49141
VOne relatively simple way is to approach this task as a recursive mapping of K-tuples of dimension  to K-tuples of dimension
p49142
aVSince this is language-agnostic, the following facilities need to be available in your target language:
p49143
aVGiven an instance of an -dim array, find
p49144
aVGiven an instance of an -dim array and a , find the number of items in dimension
p49145
aVGiven an instance of an -dim array  and a vector of  integers , get or set the item at a position defined by indexes in the vector
p49146
aVFor example, if the vector is , there needs to be an operation for obtaining  from the 3-D array  and a vector
p49147
aVGiven a vector  of size  defining dimensions, there needs to be an operation for constructing an array of  dimensions, each dimension taking the size of the corresponding item in the vector
p49148
aVFor example, if the vector , there needs to be an operation that creates a 2-D array with dimensions 3 and 4
p49149
aVPreprocess the request by constructing vectors  and  as follows:
p49150
aVFor each  item at position  of the request,  and
p49151
aVFor each numeric item  at position  of the request,  and
p49152
aVCreate an array for the result by taking all non-fixed indexes and passing them to the array constructor (prerequisite number four above)
p49153
aVNow your recursive procedure should look relatively straightforward:
p49154
aVYour  would look like this:
p49155
as(dp49156
g6
V335858
p49157
stp49158
a((dp49159
g2
(lp49160
VYou can build your own collection backed by a dictionary to accomplish this task
p49161
aVThe idea is to store a delegate that takes a Person and returns a string by reading the Name property
p49162
aVHere is a skeletal solution of such a collection:
p49163
aVHere is how to use it:
p49164
as(dp49165
g6
V335858
p49166
stp49167
a((dp49168
g2
(lp49169
V"Stack hog" is an informal name used to describe functions that use significant amounts of automatic storage (AKA "the stack")
p49170
aVWhat exactly counts as "hogging" varies by the execution environment: in general, kernel-level functions have tighter limits on the stack space - just a few kilobytes, so a function considered a "stack hog" in kernel mode may become a "good citizen" in user mode
p49171
aVA common reason for a function to become a stack hog is allocating buffers or other arrays in the automatic memory
p49172
aVThis is more convenient, because you do not need to remember to free the memory and check the results of the allocation
p49173
aVYou could also save some CPU cycles on the allocation itself
p49174
aVThe downside is a possibility of overflowing the stack, wich results in panic for kernel-level programs
p49175
aVThat is why a common remedy of "stack hogging" is moving some of your buffers into dynamic memory
p49176
as(dp49177
g6
V335858
p49178
stp49179
a((dp49180
g2
(lp49181
VWhat is the best practice
p49182
aVShould I leave ARC on or turn it off
p49183
aVBest practice is using ARC for all new development, and selectively turning ARC off only for legacy libraries
p49184
aVPerhaps you have a good example as to when I should make this choice
p49185
aVThe choice is very simple: if you are maintaining a large body of code with manual memory management, turn ARC off; otherwise, keep ARC on
p49186
aVIt is still very beneficial to get a working knowledge on how retain/release work: it would let you understand ARC at a deeper level
p49187
aVAs a side note, consider switching the course to something that has been updated in the last two years: ARC is easily the most important change in the language that has been introduced in the last few years; you definitely do not want to miss out on it
p49188
as(dp49189
g6
V335858
p49190
stp49191
a((dp49192
g2
(lp49193
VComparing multi-line strings is not different from comparing single-line strings: the strings you compare must match character-for-character, including whitespace and line breaks
p49194
aVIf your generated string uses  separator instead of , then the string constant that you expect to get must contain the same separator as well
p49195
aVYou can check the kind of separators that you use by setting a breakpoint, and examining the string that you generate in a debugger
p49196
aVRather than hard-coding the string for unit testing, consider reading it from a resource
p49197
aVThis would let you edit the string in a text editor, and inspect it visually for differences
p49198
aVFinally, if you do not need the whitespace to match, you could define a function that compares strings excluding whitespace:
p49199
as(dp49200
g6
V335858
p49201
stp49202
a((dp49203
g2
(lp49204
VA foreign key in a "child" table must reference a single "parent" table
p49205
aVThe parent must be specified at the time when you define your key
p49206
aVAll rows in your child table must reference the same parent table - there can be no row-by-row differentiation
p49207
aVNote, however, that a column does not need to be a foreign key in order to be used in a join
p49208
aVA foreign key constraint will prevent insertions of incorrect keys into the child table, and deal with deletions in a parent table by cascading into the child or throwing an error
p49209
aVIf you do not care for this functionality, you could store your "foreign key" column normally, and use it in outer joins, like this:
p49210
aVThe above example assumes that your "foreign key" consists of two columns - the  that indicates what row you reference, and  that indicates what table you want
p49211
as(dp49212
g6
V335858
p49213
stp49214
a((dp49215
g2
(lp49216
VShort answer: use the first way, it is faster, because the first method uses a pre-computed result, while the second method needs to recompute it on the fly every time you call it
p49217
aVLong answer: (you need to read C# code to understand this part; MS supplies framework code in C#, but VB programmers should be able to get the general idea of what's going on)
p49218
aVHere is what happens inside the  call of :
p49219
aVThe  performs a quick assertion, and forwards the call to , an internal class:
p49220
aVFinally, here is what  does:
p49221
aVSince  is a , this operation completes very quickly
p49222
aVNow consider what the indexer  does (you call this indexer before passing its result to ):
p49223
aVNote that the first two lines of  method and the indexer are identical
p49224
aVHowever, the three rows that follow need to perform validation, and fetch the value itself
p49225
aVOnly after that your code can start computing its target value - a flag that tells it if the value is  or not
p49226
aVThis requires more computation, but more importantly, it requires some computation every time you perform the check
p49227
aVThis is slower than using a pre-computed value
p49228
as(dp49229
g6
V335858
p49230
stp49231
a((dp49232
g2
(lp49233
VYou do not need an  - in fact, you do not need control statements in your program
p49234
aVAll you need is a lookup table - a  that translates your unit enum to a  conversion factor, such that multiplying the measure in units by the conversion factor you get meters for units of space, and kilos for units of weight
p49235
aVConversely, dividing meters by that factor gives you the desired units
p49236
aVWith this map in hand, you can do conversions for all pairs of units:
p49237
aVLook up the conversion factor  for the source units
p49238
aVLook up the conversion factor  for the destination units
p49239
aVReturn  as your result
p49240
aVFor example, let's say that you want to deal with meters, yards, inches, and feet
p49241
aVYour map would look like this:
p49242
aVm  - 1
p49243
ag49
aVy  - 0
p49244
aV9144
p49245
aVin - 0
p49246
aV0254
p49247
aVft - 0
p49248
aV3048
p49249
aVNow let's say you want to convert  yards to feet:
p49250
aVLook up
p49251
aVLook up
p49252
aVCompute and return
p49253
as(dp49254
g6
V335858
p49255
stp49256
a((dp49257
g2
(lp49258
VWould this be considered bad practice
p49259
aVYes, it would be bad practice, because the  in the  would be unused
p49260
aVIt does not look like  should be deriving from : instead, they should be derived from the same abstract base class, like this:
p49261
aVGeneral principle in use here is that you should try making all your non-leaf classes in your inheritance hierarchy abstract
p49262
as(dp49263
g6
V335858
p49264
stp49265
a((dp49266
g2
(lp49267
VCreate an array of indexes, fill it with numbers 0
p49268
aVN-1, and sort it using a custom comparator
p49269
aVThe comparator should compare items from the original array at indexes  and
p49270
aVSorting the array of indexes this way reorders them as a permutation:
p49271
aVThis prints
p49272
aVHere is a demo on ideone
p49273
aVNote: you can use  to retrieve the  in sorted order:
p49274
as(dp49275
g6
V335858
p49276
stp49277
a((dp49278
g2
(lp49279
VYou need to pass the size of an individual element as the third parameter of , like this:
p49280
aVAlso make sure that  points to an  that holds the number of items to be sorted
p49281
as(dp49282
g6
V335858
p49283
stp49284
a((dp49285
g2
(lp49286
VWhy does assigning to a variable take so long
p49287
aVYour guess was correct: ARC calls  when you assign, and  when you reassign, or when  goes out of scope
p49288
aVWhy does assigning to a weak variable take even longer
p49289
aV(Maybe there is something I don't understand going on here)
p49290
aVRecall that ARC promises to clear your weak reference when the last strong reference is gone
p49291
aVThat is why weak references are more expensive: in order to  out the , ARC registers 's address with the runtime to get a notification of the object being released
p49292
aVThis registration requires writing into a hash table - far slower than just retaining and releasing
p49293
aVConsidering the above how have Apple got the standard fast enumeration to perform so well
p49294
aVFast enumeration uses blocks of the array that backs  directly
p49295
aVEssentially, they grab a block of 30 elements or so, and treat access to it as a plain C array
p49296
aVThen they grab the next block, iterate over it as if it were a C array, and so on
p49297
aVThere is some small overhead, but it is per block, not per element, so you get a pretty impressive performance
p49298
as(dp49299
g6
V335858
p49300
stp49301
a((dp49302
g2
(lp49303
VDeclaring a property  makes compiler generate additional code that prevents concurrent access to the property
p49304
aVThis additional code locks a semaphore, then gets or sets the property, and then unlock the semaphore
p49305
aVCompared to setting or getting a primitive value or a pointer, locking and unlocking a semaphore is expensive (although it is usually negligible if you consider the overall flow of your app)
p49306
aVSince most of your classes under iOS, especially the ones related to UI, will be used in a single-threaded environment, it is safe to drop  (i
p49307
ag630
aVwrite , because properties are  by default): even though the operation is relatively inexpensive, you do not want to pay for things that you do not need
p49308
as(dp49309
g6
V335858
p49310
stp49311
a((dp49312
g2
(lp49313
VThe output of the method will be as before
p49314
aVThe assignment of  made after the return will have no visible effect, i
p49315
ag630
aVthe caller will receive  as the return value
p49316
aVSince the  block does not throw, the last  is actually unreachable
p49317
aVThe  block is executed after the return value has been calculated, but before the receiver has got the value back
p49318
aVThe answer would change if you returned a mutable object instead of a primitive, though: mutations, if any, that you do in a  block, would be visible to the caller of your function:
p49319
aVAbove, an  would be returned, but the caller would get
p49320
aVNote: If you think this is evil, you are probably right
p49321
as(dp49322
g6
V335858
p49323
stp49324
a((dp49325
g2
(lp49326
VYou need to set  and  before drawing the rectangle
p49327
aVOtherwise, the last rectangle is not going to display:
p49328
aVBetter yet, drop  and  altogether, and use calculations directly:
p49329
as(dp49330
g6
V335858
p49331
stp49332
a((dp49333
g2
(lp49334
VPreprocessor's  creates a textual substitution, not a variable
p49335
aVAfter preprocessing, your program looks like this:
p49336
aVThis is obviously invalid: you cannot assign values to constants
p49337
aVIn C-speak, an expression to which you can assign is called  (a value that can appear on the left in an assignment)
p49338
aVThat should explain the error that you see
p49339
aVTo fix the error, introduce two loop variables, call them  and , and use them instead of  and :
p49340
as(dp49341
g6
V335858
p49342
stp49343
a((dp49344
g2
(lp49345
VYou can nest the query that returns  in another , and add  on top of it, like this:
p49346
aVThis way you would not need to copy the query, because its result would be available to the outer
p49347
as(dp49348
g6
V335858
p49349
stp49350
a((dp49351
g2
(lp49352
VYou cannot generate entirely unique s from sufficiently long strings because there are more 10-character strings than 32-bit integers
p49353
aVAs far as non-unique solutions go, you can use the standard  function, its implementation in Java is reasonably good
p49354
aVFor more complex stuff you may consider computing cryptographic hash (SHA-2, MD5, etc
p49355
as(dp49356
g6
V335858
p49357
stp49358
a((dp49359
g2
(lp49360
VYou use  when
p49361
aVYour class is designed for inheritance - You expect the users of your library to inherit from the class that you are designing
p49362
aVVery often the class will be
p49363
aVThe class provides special functionality to its derived classes that must not be visible to other classes - You know that derived classes must have access to information that would otherwise be private, or
p49364
aVThe derived classes must provide functionality to the base class - See Template Method Pattern for information about this use of protected methods
p49365
aVNote that  methods are similar to  methods in the sense that once you put them in, they need to stay in for as long as you support your library
p49366
aVUnlike private methods that you can freely remove,  methods remain a part of the interface of your class
p49367
as(dp49368
g6
V335858
p49369
stp49370
a((dp49371
g2
(lp49372
VIn order for this to compile, your copy constructor must take its parameter by  reference:
p49373
aVAdding  to your constructor signature fixes this problem (demo on ideone)
p49374
aVSince you are defining an assignment operator and a copy constructor, you should strongly consider adding a desctructor  (see the Rule of Three)
p49375
as(dp49376
g6
V335858
p49377
stp49378
a((dp49379
g2
(lp49380
VHow to successfully compile it , considering I want both , the copy constructor as well as the integer constructor in my class
p49381
aVAdding  to the reference argument of the copy constructor fixes this problem:
p49382
aVDemo on ideone
p49383
as(dp49384
g6
V335858
p49385
stp49386
a((dp49387
g2
(lp49388
VThe two problems that I see with this code is that it treats message case-sensitively, and that you missed the  in front of the second  literal, making  a backspace, not an end-of-word marker
p49389
aVTry replacing
p49390
aVwith
p49391
aVthe rest of your code should work fine
p49392
aVYou may want to optimize your code a little by per-compiling your regexes
p49393
aVIn addition, since  is not really a , you may want to use
p49394
as(dp49395
g6
V335858
p49396
stp49397
a((dp49398
g2
(lp49399
VIt is common to use agent nouns or noun phrases for classes and interfaces that do things to other objects:
p49400
as(dp49401
g6
V335858
p49402
stp49403
a((dp49404
g2
(lp49405
VThis is because you outsmarted yourself: your initializers depend on the order of execution
p49406
aVAt the time this line runs
p49407
aVis still , so that's what gets put into your
p49408
aVYou can switch the order of initializers to fix this problem
p49409
aVHowever, you would be better if you put initialization code into a separate initializer, rather than using anonymous classes with custom initializers:
p49410
as(dp49411
g6
V335858
p49412
stp49413
a((dp49414
g2
(lp49415
VEven in cases when the call is a variable-for-variable (it could be expression-for-variable) the two names represent conceptually different things, so you should not be naming them the same unless they really mean the same thing
p49416
aVFormal parameters represent variables with names meaningful inside the function, while variables that you pass represent variables with names meaningful outside the function
p49417
aVHere is an example:
p49418
as(dp49419
g6
V335858
p49420
stp49421
a((dp49422
g2
(lp49423
VIn your case, only one object gets destroyed - namely, the temporary  on the right-hand side of your assignment
p49424
aVThe original  does not get destroyed, because it gets overwritten by the assignment
p49425
aVWhen the time comes for it to get destroyed, it will print  as well
p49426
aVHowever, the modified  (that started off as ) is kept alive by the infinite loop, so it does not get destroyed either
p49427
aVRemoving the infinite loop fixes this (demo)
p49428
as(dp49429
g6
V335858
p49430
stp49431
a((dp49432
g2
(lp49433
VYou should make the property implementation  in the base class, and put  instead of  on the implementations in derived classes
p49434
aVThis should fix the problem
p49435
aVCurrently, the only class that provides the implementation for the property  from the interface  is your
p49436
aVAccording to your code, compiler thinks that the derived class  introduces a new property with the same name, which is legal
p49437
aVSuch property would be accessible only when you use the class directly, not through an interface
p49438
as(dp49439
g6
V335858
p49440
stp49441
a((dp49442
g2
(lp49443
VIf you want to detect a single , you need to use an , not an :
p49444
as(dp49445
g6
V335858
p49446
stp49447
a((dp49448
g2
(lp49449
VYou can  together all numbers from
p49450
aVrange, then  the numbers from the array
p49451
aVThe result will be the missing number
p49452
aVExplanation: ing a number with itself always results in zero
p49453
aVThe algorithm above s each number exactly twice, except for the missing one
p49454
aVThe missing number will be -ed with zero exactly once, so the result is going to equal the missing number
p49455
aVNote: the interviewer is wrong on needing to convert bases in order to do addition: adding binary numbers is easy and fun - in fact, computers do it all the time :-)
p49456
as(dp49457
g6
V335858
p49458
stp49459
a((dp49460
g2
(lp49461
VThe reason you see ReSharper's warnings is that ReSharper's code flow analysis engine is not strong enough to see what is going on: they assume that your code could get to the end of the  clause without  being set, which is not possible due to a  loop:
p49462
aVThe loop will keep printing the  line until  gets called, preventing your code from reaching the end of the  block
p49463
aVSame goes for the other warning
p49464
aVLong story short, this warning can be safely ignored
p49465
aVAdd ReSharper's "ignore this warning" comments, and optionally file a bug report with them
p49466
as(dp49467
g6
V335858
p49468
stp49469
a((dp49470
g2
(lp49471
VI read that while passing an array as argument we must also have to pass its length as argument
p49472
aVThis applies only in situations when the function does not know the size of the array upfront
p49473
aVWhen the function knows that the array must have a certain number of elements, you do not need to pass the size to the function
p49474
aVThis is exactly what is happening in your code: both functions that receive arrays know that  contains exactly  elements, and  contains exactly  elements
p49475
aVThat is why you do not need to pass the size, and nothing is going to happen: the function already knows the size through d constants
p49476
aVOn the other hand, if you needed to pass an array of size unknown to your function, then you would need to do one of the following:
p49477
aVPass the number of elements in your array, or
p49478
aVPass a pointer to the last element (or one past the last element) of your array, or
p49479
aVAgree on a "sentinel" value such as zero or negative one that would indicate the end of the valid range of data in your array
p49480
as(dp49481
g6
V335858
p49482
stp49483
a((dp49484
g2
(lp49485
VYour loop keeps assigning  without changing
p49486
aVSince  stays at zero, all s are going to be  (because  is zero,  is )
p49487
aVIf you would like to assign sequential values, either use the loop index , or change  in the body of the loop:
p49488
aVor
p49489
as(dp49490
g6
V335858
p49491
stp49492
a((dp49493
g2
(lp49494
VYou can insert colons after each group of two digits with a simple regex, like this:
p49495
aVThis expression matches groups of two characters, and inserts a colon in front of each group except the first one
p49496
aVHere is a demo on ideone
p49497
as(dp49498
g6
V335858
p49499
stp49500
a((dp49501
g2
(lp49502
VWithout changing the signature of the existing function, the only solution is adding a "sentinel" element to your array - say, a number that may not be part of the legal portion of your array
p49503
aVScan the array until you get to that sentinel, and count the elements
p49504
aVThis would give you the length of the array
p49505
aVThis approach is similar to what C strings do to determine length by adding null termination
p49506
aVOf course in C++ you have a much better option than plain arrays: using  lets you avoid passing length, because  has  function
p49507
as(dp49508
g6
V335858
p49509
stp49510
a((dp49511
g2
(lp49512
VCSV accepts items enclosed in double-quotes
p49513
aVYou can put double-quotes around each item by modifying your code as follows:
p49514
aVThe above replaces  with a  that checks each item for , and puts double-quotes around strings that have commas
p49515
as(dp49516
g6
V335858
p49517
stp49518
a((dp49519
g2
(lp49520
VThis problem is equivalent to finding the most frequent element in a sorted array - the same algorithm applies:
p49521
aVStart the counter at zero
p49522
aVIncrement the counter while the current element is equal to the prior one
p49523
aVWhen you find a different element, compare the counter to the current best run; replace if necessary
p49524
aVContinue to the next element
p49525
aVThe only difference is that instead of an array traversal with a loop you do a tree traversal with a recursive function
p49526
aVIn both cases the algorithm is linear in time in the number of elements in the tree
p49527
aVIf the tree is balanced, the algorithm requires  space on the invocation stack
p49528
as(dp49529
g6
V335858
p49530
stp49531
a((dp49532
g2
(lp49533
VRecursion is one way of implementing a tree search where you visit elements in depth-first order
p49534
aVYou can implement the same algorithm with a loop instead of recursion by using a stack data structure to store the nodes of your tree that you need to visit
p49535
aVIf you use the same algorithm with a queue instead of a stack, the search would proceed in breath-first order
p49536
aVIn both cases the general algorithm looks like this:
p49537
aVNote that the algorithm is not recursive: it uses an explicit collection of  to save the current state of the search, whereas a recursive implementation uses the call stack for the same purpose
p49538
aVIf  is a , the search proceeds in depth-first order; if  is a , the search proceeds in breadth-first order
p49539
as(dp49540
g6
V335858
p49541
stp49542
a((dp49543
g2
(lp49544
VI assume that you have an array of prices or some other method to look up the price
p49545
aVFor example, if your array of prices looks like this:
p49546
aVthen you can change your code as follows:
p49547
aVOf course the  must contain as many items as , otherwise you will get "index out of range" exceptions
p49548
as(dp49549
g6
V335858
p49550
stp49551
a((dp49552
g2
(lp49553
VPrimary key is better because you are sure what row you are deleting: although technically you can update a primary key column, it is not a normal practice to do so
p49554
aVOther columns, however, are changeable, which could lead to situations like this:
p49555
aVYou have a table with a  and another unique identifier, say,
p49556
aVYou read a row with email , and decide to delete it
p49557
aVThe row gets modified concurrently, with the e-mail updated to
p49558
aVYou execute the
p49559
aVThe  command does not delete anything, because the e-mail has been changed before you managed to run your command
p49560
aVSince  is not supposed to change, this situation would not be possible under normal circumstances
p49561
aVOf course your code can detect that deletion did not happen, redo the read, and re-issue the command, but that is a lot of work compared to using a primary key
p49562
as(dp49563
g6
V335858
p49564
stp49565
a((dp49566
g2
(lp49567
VThe naming style of    for loop indexes goes back to at least FORTRAN times, when variables with names starting in  through  were implicitly considered to be of type  (all other variables were considered to be of type )
p49568
aVAlthough the idea to name indexes with doubled letters sounds neat, it is hard to imagine why anyone would have to search for a loop variable: such variables are typically meaningful within a context of a loop, which is usually pretty narrow
p49569
aVMoreover, modern IDEs provide search features driven by semantic of your code, so searching textually for  becomes far less important
p49570
aVThere is nothing wrong with that naming style as long as it is practiced consistently by everyone on your team
p49571
aVIt is true about all naming guidelines, though: they derive a lot of their value from consistent use
p49572
as(dp49573
g6
V335858
p49574
stp49575
a((dp49576
g2
(lp49577
VYou can use  with lambdas, like this:
p49578
as(dp49579
g6
V335858
p49580
stp49581
a((dp49582
g2
(lp49583
VShould I stick to the method I've described using JNI, and convert the  array type into the appropriate  array
p49584
aVYes, since  and  are different types, this appears to be the only reliable way without triggering undefined behavior
p49585
aVIn practice, it is very likely that the size of  is the same as that of , so you could get by with re-interpreting the pointer of  as , but this is not a portable solution
p49586
aVThe story would have been different if your library took  of , then you would be able to reinterpret the pointer of  as a pointer of  without negative consequences
p49587
as(dp49588
g6
V335858
p49589
stp49590
a((dp49591
g2
(lp49592
VThe reason your cells become slow on reuse is that you keep adding subviews to them even after reusing a cell
p49593
aVEach time a cell gets created or reused, you add seventy subviews to it, but you never remove the subviews
p49594
aVYou do not see the "old" subviews from the reused cells because newly added subviews sit on top of them, but the old subviews are still there
p49595
aVYou need to change your code to create and add subviews only once, when the cell gets allocated
p49596
aVWhen the cell gets reused, you should change the values inside the views, but keep the views themselves unchanged
p49597
aVOne way to achieve this would be giving each  a tag between 0 and 69, like this:
p49598
as(dp49599
g6
V335858
p49600
stp49601
a((dp49602
g2
(lp49603
VThey are not sequence-equal because the objects come in different order
p49604
aVIf you change  like this
p49605
aVwould return
p49606
aVDemo on ideone
p49607
aVGenerally, you should not rely on the order of items in LINQ-generated groups, unless you set the order yourself:
p49608
aVNote: your  class overrides  without overriding
p49609
aVThis will be problematic if you decide to use  in hash sets or as keys of hash-based dictionaries
p49610
as(dp49611
g6
V335858
p49612
stp49613
a((dp49614
g2
(lp49615
VI understand that if I want to return a string literal or an array from a function I should declare it as
p49616
aVThat's not exactly right: although declaring it  would fix the problem, so would allocating it in the dynamic memory, i
p49617
ag630
aV////etc
p49618
aVSo the answer is "yes, returning -ed memory from a function is perfectly safe"
p49619
aVOf course the caller that receives dynamic memory must take care of -ing it when it is no longer needed
p49620
aVEDIT : (in response to comments) In fact, using  may be inferior in some contexts, because the buffer would remain shared
p49621
aVFor example, if you decide to make a list of user-entered strings, you would be forced to make copies in the caller
p49622
aVIn addition, using  would make your function non-reentrant, which is harmful in concurrent environments
p49623
as(dp49624
g6
V335858
p49625
stp49626
a((dp49627
g2
(lp49628
VThis code fragment is identical to this:
p49629
aVwhich is the "classic" , except the outer loop goes from high to low rather than from low to high
p49630
as(dp49631
g6
V335858
p49632
stp49633
a((dp49634
g2
(lp49635
VThe problem happens because your  misuses the buffer: rather than copying the string from the list into it,  assigns it as a pointer
p49636
aVSince  is passed by value, the content of the buffer remains uninitialized, leading to invalid printouts due to undefined behavior
p49637
aVThere are several ways of fixing this problem:
p49638
aVUse  to copy the content of  into the  buffer, or
p49639
aVChange  to take a pointer to a pointer for , and assign it
p49640
aVThe  approach is less safe, unless you take the size of the buffer as well
p49641
aVThe pointer to pointer approach looks like this:
p49642
aVThe call looks like this:
p49643
as(dp49644
g6
V335858
p49645
stp49646
a((dp49647
g2
(lp49648
VThe problem is that although  does validation of the name, the constructor performs a "straight" assignment without validation
p49649
aVChange the constructor as follows:
p49650
aVThis will fix the problem
p49651
aVNote that your code goes against Java naming conventions: rather than calling the setter method , naming conventions suggest
p49652
aVFollowing naming conventions is very important to ensure code readability, so other method names should be changed in a similar way
p49653
as(dp49654
g6
V335858
p49655
stp49656
a((dp49657
g2
(lp49658
VThen I would like to use these modes in if-then statements to make different calculations
p49659
aVAlthough you can certainly do that, I would strongly advice you against going this route: using the content of a label in calculations runs against the grain of the Model View Controller pattern, because label content is part of a visual representation, while calculations are part of the logical model
p49660
aVThis is more than just a theoretical problem - far from it: using label content prevents localization, and impedes future maintenance of your project
p49661
aVHere is how to achieve what you are looking for in an MVS way:
p49662
aVDefine a model class that stores the current mode switchable on the button
p49663
aVDefine methods in the model or in the controller that perform calculations based on the current mode
p49664
aVDefine methods to get the current mode and to toggle the mode as necessary
p49665
aVMake sure the model object is a singleton in your project
p49666
aVIn the view for the "view will appear" method read the mode from the model, and set the label accordingly
p49667
aVIn the code for the button handler, read the current mode, change it as necessary, store back the new value, and update the label accordingly
p49668
aVThis sounds like a lot of work, but the Objective C code for this approach is not much lengthier than the approach that reads from labels directly
p49669
aVHere is a short example of setting up a model as a singleton in Objective C
p49670
as(dp49671
g6
V335858
p49672
stp49673
a((dp49674
g2
(lp49675
VYou (or rather, your comparator) decides
p49676
aVIf your 's  return a negative when  is less than , you get ascending order (demo on ideone)
p49677
aVIf your 's  return a negative when  is greater than , you get descending order (demo on ideone)
p49678
aVAnother way of saying the same thing would be that  assumes that the comparator orders the two items passed into it from smaller () to greater (), and produces an ascending sort consistent with that ordering
p49679
as(dp49680
g6
V335858
p49681
stp49682
a((dp49683
g2
(lp49684
VI think that  analyzes the state of your program at the time it exits, which is likely before the thread finishes its execution: two microseconds may not be enough to write  to console
p49685
aVAdding a call to  should fix this leak:
p49686
as(dp49687
g6
V335858
p49688
stp49689
a((dp49690
g2
(lp49691
VThe placement of  in a pointer declaration matters
p49692
aVYou read it backwards:
p49693
aVmeans "p is a pointer to  which is constant"
p49694
aVmeans "p is a constant pointer to "
p49695
aVmeans "p is a constant pointer to a constant "
p49696
as(dp49697
g6
V335858
p49698
stp49699
a((dp49700
g2
(lp49701
VThe problem is that when you assign ,  does not get assigned
p49702
aVJava passes variables by value, meaning that a copy of the value or a reference gets passed into your method
p49703
aVIn this case, , a formal parameter of your  method, is passed a copy of the  field returned by the  method
p49704
aVTo fix this, you should split the  method in two:
p49705
aVand
p49706
aVThe public method should be used without  parameter (the users of your class inserting in the tree should never need to pass the root, otherwise they would be able to break your tree by passing a node in the middle with numbers that should go in a different branch)
p49707
aVThe private method should return the old or the new node
p49708
aVYou should be using it like this:
p49709
aVThe method itself should return new node if  passed in is
p49710
aVWhen  is not null, the method should return the node passed in
p49711
aVAs far as the  problem goes, you should use  instead of  to construct the output
p49712
aVUnlike  which is immutable,  is mutable
p49713
aVIt lets you change the string inside it (use  instead of )
p49714
as(dp49715
g6
V335858
p49716
stp49717
a((dp49718
g2
(lp49719
VMake an array of  s, initially set to
p49720
aVA string at position  represents a formula of getting to position  from
p49721
aVSet string at position  to
p49722
aVThen walk through the array, looking for non-null entries in it
p49723
aVWhen you find a non-null entry, do the following:
p49724
aVCheck if  is within the bounds of the array
p49725
aVIf it is, make a new formula string, and see if it is shorter than what you may have at
p49726
aVIf the new formula is shorter, or the string at  is , put the new formula at
p49727
aVDo the same thing for the position at
p49728
aVOnce you reach the end of the array, check the formula at
p49729
aVIf it's , you can't generate the number; otherwise, print the formula
p49730
aVHere is a sample implementation in Java:
p49731
aVHere is this program running on ideone
p49732
as(dp49733
g6
V335858
p49734
stp49735
a((dp49736
g2
(lp49737
VI think the distinction behind "dense" vs
p49738
aV"spaced-out" boils down to the uniformity of distribution of data being sorted, with uniformly distributed data considered "dense"
p49739
aVSince bucket sort partitions its input by buckets based on the upper part of the number's value, inputs with uniform distribution would form nice short lists in each bucket
p49740
aVConversely, inputs with big gaps would form lots of empty lists, and a small number of long lists comparable in length to the original input
p49741
aVThis is bad news for the middle step of the radix sort, where individual buckets get sorted, because the "scatter" step does not reduce the original problem all that much
p49742
aVRadix sort, on the other hand, does not care about the distribution of the numbers in the input: the algorithm takes the same time for any inputs of the same size and the same number of digits in its largest member
p49743
aVSteps for each "digit" take exactly  steps; once you are done with the most significant digit, you are done
p49744
aVThe distribution of the values being sorted does not play into the timing of the algorithm
p49745
as(dp49746
g6
V335858
p49747
stp49748
a((dp49749
g2
(lp49750
VYour aggregate shouldn't assign the value, it should return the value of the sum:
p49751
aVI am not sure if this is going to work well in EF (in fact, I'm almost sure that you are going to see a run-time error), but it should help you get past the compile issue
p49752
aVStarting with
p49753
aVNET 4
p49754
aV0 you could use  method with , like this:
p49755
aVThis should work well for in-memory operations
p49756
aVTo get past the runtime error, try this:
p49757
aVThe idea is to bring the formation of the  into memory
p49758
as(dp49759
g6
V335858
p49760
stp49761
a((dp49762
g2
(lp49763
VSince s are value types, and because value types get copied,  ends up with the copy of the cat from the list
p49764
aVYou need to operate on the  itself, not its copy
p49765
aVMoreover, you can modify fields of s directly only when they are single variables or parts of an array
p49766
aV's indexer returns a copy, so C# compiler produces the "Cannot modify a value type" error
p49767
aVThe only solution that I know (short of making  a  or re-assigning a modified copy) is making  an array:
p49768
as(dp49769
g6
V335858
p49770
stp49771
a((dp49772
g2
(lp49773
VIt looks like there is a non-printable end-of-line character at the end of your file
p49774
aVThat's what gets printed first
p49775
aVThen the position is moved in turn to , , and
p49776
aVAt this point, re-positioning by  fails, because the location would become
p49777
aVFile cursor stays where it was, i
p49778
ag630
aVat  which gets printed next
p49779
aVThe following attempt at repositioning fails too, so  gets printed
p49780
aVThe next repositioning succeeds, terminating the loop
p49781
aVTo detect situations when  is ignored, check its return value, like this:
p49782
as(dp49783
g6
V335858
p49784
stp49785
a((dp49786
g2
(lp49787
VSince Objective C, like C, allows integers in conditionals, using  is a common shorthand for
p49788
aVYour statement is equivalent to
p49789
aVSince  returns zero when strings are equal to each other, the condition checks if the content of two C strings is the same
p49790
as(dp49791
g6
V335858
p49792
stp49793
a((dp49794
g2
(lp49795
VC standard allows compiler designers choose if  is signed or unsigned
p49796
aVIt appears that your system uses signed s and 32-bit s
p49797
aVSince the most significant bit of  (binary ) is set, the value gets sign-extended into
p49798
aVShifting signed values right also sign-extends the result, so when you shift out the lower four bits, four ones get shifted in from the left, resulting in the final output of
p49799
aVEDIT : According to C99 specification, hexadecimal integer constants such as  in your example are treated as s of different length depending on their length
p49800
aVTherefore, assigning  to a signed  is out of range: a proper way of assigning the value would be with a hexadecimal character literal, like this:
p49801
as(dp49802
g6
V335858
p49803
stp49804
a((dp49805
g2
(lp49806
VThis is because of the pointer type to which the pointer arithmetic operation  is applied:
p49807
aVIn the first case, you add  to a pointer to , which is the same as indexing an array
p49808
aVSince the pointer to an array is the same as the pointer to its first element, the code works
p49809
aVIn the second case, you add  to a pointer to an array of two s
p49810
aVTherefore, the addition puts you beyond the allocated memory, causing undefined behavior
p49811
aVHere is a quick illustration of this point:
p49812
aVOn a system with 32-bit s this prints addresses separated by eight bytes - the size of :
p49813
as(dp49814
g6
V335858
p49815
stp49816
a((dp49817
g2
(lp49818
VThe key thing is how can we determine when this recursive function actually ends
p49819
aVLike ordinary functions, recursive functions end as soon as the top level of its invocation returns
p49820
aVThe problem with your function is that it tries to both construct a list, and return it; it should do one or the other
p49821
aVConstructing the list is simple - make your function , and change it as follows:
p49822
aVThat's it
p49823
aVThe two changes I made was taking the argument by reference, and returning void
p49824
aVCall your function as follows:
p49825
aVIf you would like to return the list instead, you could modify your function as follows:
p49826
aVNote that the second alternative requires more copying
p49827
as(dp49828
g6
V335858
p49829
stp49830
a((dp49831
g2
(lp49832
VYou should never include cpp file, no matter how few definitions are in them: each definition included in several other cpp files would produce duplicate symbols, causing linking errors
p49833
aVIf you build a class that is used in multiple translation units (that's a fancy name for a cpp files) you should build a header for it
p49834
aVTemplates go without a cpp file - only a header is necessary
p49835
aVAlthough a common practice is to make one cpp/header pair for each class, it is OK to include multiple related classes in a single translation unit, and put all the declarations in a single header
p49836
as(dp49837
g6
V335858
p49838
stp49839
a((dp49840
g2
(lp49841
VI can't really understand the reason why compiler didn't call a function of class instance belong
p49842
aVThat's what the compiler does - makes sure that your program calls the function of the class to which the instance belongs
p49843
aVThe key word here is instance: the knowledge of the instance's class is not available at compile time
p49844
aVConsider this simple example:
p49845
aVNote the tricky line: the compiler has the instance, but it does not know the class
p49846
aVActually, it kind of knows the class, but not the most specific one
p49847
aVThe knowledge the compiler has at compile time is sufficient to know that there is a function called , but not sufficient to decide which one of several possibilities would be the one to call at runtime
p49848
aVThis is where vtables come to the rescue: the compiler knows that subclasses of  will have a pointer to their  function embedded somewhere into their vtable
p49849
aVThat's all they need to know at compile time
p49850
aVThey insert a virtual call that looks up the function pointer at runtime, achieving the behavior that you expect (the fancy word for that kind of behavior is "polymorphism")
p49851
aVHere is a demo of this program running on ideone
p49852
as(dp49853
g6
V335858
p49854
stp49855
a((dp49856
g2
(lp49857
VLike this:
p49858
aVIn the upper branch of your , the  portion of the  clause is missing; in the lower branch it is the check of  to be part of  string
p49859
aVThe  condition makes that same condition true when  is not specified
p49860
as(dp49861
g6
V335858
p49862
stp49863
a((dp49864
g2
(lp49865
VWelcome to multiple dispatch
p49866
aVEssentially, you are asking for a method that is virtual with respect to the runtime type of more than one object - in your case, the types of two shapes being tested for overlap
p49867
aVThere are several common ways of implementing double dispatch in C++: for example, you could use the visitor pattern, or make a map based on RTTI
p49868
aVSelecting one or the other is up to you
p49869
aVIf you decide to go with the visitor pattern, you make the  "visitable" by adding the visit method
p49870
aVHere is an example of the visitor-based approach
p49871
aVIt is admittedly rather verbose, but it also addresses a complex task, so it is fair for it to require lots of code
p49872
aVI stripped the example below to the bare minimum - only two shapes with no data members, and methods that do not do anything except printing
p49873
aVThis should be sufficient to get you started, though:
p49874
aVHere is this running demo on ideone
p49875
aVWith RTTI approach you would make a  where checker is a type of a function that takes two pointers to , and returns  or  depending on whether or not the shapes overlap
p49876
aVYou make one such function for each pair of object types, populate the map with pointers to these functions based on  of their expected parameter types, and use this map at runtime to call the desired function
p49877
aVItem 31 of the More Effective C++ book explains both these approaches in depth, with some great examples
p49878
aVIn fact, the use case discussed in the book, detecting collisions between a pair of game objects, is similar to the one that you are implementing
p49879
as(dp49880
g6
V335858
p49881
stp49882
a((dp49883
g2
(lp49884
VYour code is relatively close to being right
p49885
aVYou are struggling with the declaration of the array (you must specify the size for it)
p49886
aV32-bit  cannot have more than ten digits, so declaring
p49887
aVshould be sufficient
p49888
aVBefore converting the number to an array of digits, check if it is negative, and flip its sign if it is negative:
p49889
aVOtherwise, your  trick is not going to work
p49890
aVWhen you do the conversion, count how many digits you have
p49891
aVPut the result in  variable: chances are that you are not going to use up all the digits in your array, so
p49892
aVshould be
p49893
aVYour argument checking also needs improvement: think what would happen if the user passes five parameters
p49894
aVIf you expect exactly one argument, you should write
p49895
as(dp49896
g6
V335858
p49897
stp49898
a((dp49899
g2
(lp49900
VYou can use this regular expression:
p49901
aVThis expression captures a string between two pairs of equal signs, and then takes everything until the next  or the end of string
p49902
aVThe  becomes the first capturing group; the data becomes the second one
p49903
aVGroups are numbered from one, not from zero (group zero is special - it represents the entire match)
p49904
aVHere is a complete example:
p49905
aVDemo on ideone
p49906
aVOnce you get your  (i
p49907
ag630
aV) you could run a  on the dash to separate out the individual data elements
p49908
as(dp49909
g6
V335858
p49910
stp49911
a((dp49912
g2
(lp49913
VFast enumeration pulls dictionary keys in implementation-defined order (specifically, in the order consistent with hash codes of that dictionary's keys)
p49914
aVIf you need to enforce a specific order, pull the keys out of the dictionary into , sort that array to your liking, and then fast-iterate the array, pulling values from the dictionary for each key in the sorted order:
p49915
as(dp49916
g6
V335858
p49917
stp49918
a((dp49919
g2
(lp49920
VANSI C does not have a syntax for defining array aggregates outside of array initializers
p49921
aVIf you combine initialization with the assignment (which technically is not an assignment, but part of initialization) your code will compile:
p49922
aVSince you cannot reassign arrays, the portion of your program before the second call of  should look like this:
p49923
aVEDIT : (in response to comment by Keith Thompson) C99 introduces array aggregate expressions, but they cannot be assigned to arrays, because the standard does not have array assignments
p49924
as(dp49925
g6
V335858
p49926
stp49927
a((dp49928
g2
(lp49929
Vwhere is my mistake
p49930
aVIt is here:
p49931
aVis a class inside  namespace, not a namespace
p49932
aVIn C# you can apply  directive only to namespaces
p49933
aVAdding  to your program lets you omit the namespace prefix  from classes inside that namespace - for example, to reference class  you can write
p49934
aVThe  directory does not go down to class level, though (this is in contrast to Java's import directories, where  at the end of the name is optional)
p49935
aVFix this by replacing  with
p49936
aVEDIT : (in response to a comment by Karl-Johan Sjgren) There is another  construct in C# that lets you create aliases of types
p49937
aVThis construct takes class names, but requires you to specify a new name for them, like this:
p49938
aVNow you can use  in place of
p49939
as(dp49940
g6
V335858
p49941
stp49942
a((dp49943
g2
(lp49944
VNo, it is not safe to read and write  concurrently: adding an element to a sorted dictionary may involve re-balancing of the tree, which may cause the concurrent read operation to take a wrong turn while navigating to the element of interest
p49945
aVIn order to fix this problem you would need to either wrap an instance of  in a class that performs explicit locking, or roll your own collection compatible with the interfaces implemented by
p49946
as(dp49947
g6
V335858
p49948
stp49949
a((dp49950
g2
(lp49951
V's  operator on  expects C strings, so you need to null-terminate your :
p49952
aVThe extra characters that you see is random data in the memory addresses after the end of your
p49953
aVdoes not know that the string has ended, so it continues printing until it finds the first  byte
p49954
as(dp49955
g6
V335858
p49956
stp49957
a((dp49958
g2
(lp49959
VYou can do it in , where  is the size of your array, and  is the size of the sliding window
p49960
aVUse a binary tree to store the first  numbers
p49961
aVFor the following  steps, get the  value from the tree for your output, add the element at the current position  to the tree, and remove the element at  from the tree
p49962
aVThese operations are all , for the overall timing of :
p49963
aVDemo on ideone
p49964
as(dp49965
g6
V335858
p49966
stp49967
a((dp49968
g2
(lp49969
VThe  will break out of any loop, including the enhanced one
p49970
aVYour solution will work
p49971
aVHowever, since you are returning as soon as you find your item, you could change the loop to return as soon as the item is found, or as soon as you know that you are not going to find it:
p49972
aVMoreover, since the array is sorted, linear search is not your best strategy: implementing Binary Search could make your algorithm significantly faster
p49973
as(dp49974
g6
V335858
p49975
stp49976
a((dp49977
g2
(lp49978
VThere is a problem in the implementation of the  in the tutorial that you linked: the helper treats your application as non-concurrent
p49979
aVHere is what is going on: the shared instance of  has a , which owns  (among other things)
p49980
aVThe  method assigns  a copy of the block that has been passed in
p49981
aVThis is OK for the first request, but if another request is "in flight", the completion block of that other request will be released by ARC due to this reassignment
p49982
aVIf the tab to which you switch starts a concurrent request, the initial request will come back to a released block, causing an undefined behavior, and possibly a crash
p49983
aVTo fix this problem, you need to split the class in two - one part holding items common to all requests (namely,  and ) and the request-specific ones ( and )
p49984
aVThe instance of the first class (let's call it ) remains shared; instances of the second class (let's call it ) are created per-request inside the  method
p49985
aVYou will need to create a block that wraps the , too, like this:
p49986
as(dp49987
g6
V335858
p49988
stp49989
a((dp49990
g2
(lp49991
VYou cannot "append" to an array: although array elements in Java are mutable, the length of the array is set at creation time, and cannot change later on
p49992
aVIf you need a collection that can change in size, use  to append as many elements as you need; after that, you can convert the list to an array
p49993
as(dp49994
g6
V335858
p49995
stp49996
a((dp49997
g2
(lp49998
VOne way to do it is with lookahead and lookbehind anchors: this expression
p49999
aVreturns  (demo)
p50000
aVI took your expression for the date, and added it to a construct that matches everything up to, but not including, your expression from both ends
p50001
aVWhen this construct is used in a call of , both sides end up being replaced
p50002
aVI used empty string as my replacement, so all characters on both sides of your regex end up being removed
p50003
as(dp50004
g6
V335858
p50005
stp50006
a((dp50007
g2
(lp50008
VFrom the design perspective, the controller should control the rules of the sorting, but it should not be performing the sorting itself
p50009
aVRather, it should delegate this task to the model
p50010
aVIn the ideal world, controller should not make any modifications to the data, only tell the model how it wants the data to be modified
p50011
aVUnfortunately, reality often interferes with ideal designs: when users are allowed to control sorting, for example by clicking column headers, a shortcut that allows the view to sort the data is often taken to reduce the number of roundtrips to the model (which is often implemented as a database) thus offloading the RDBMS
p50012
aVAn unfortunate side effect of this decision is lack of consistency with paging: sorting in a view orders the data on the current page, ignoring the data in other pages that should come before or after what's currently displayed
p50013
aVThis shortcoming is often presented to users as a "feature"
p50014
aVIn your case, the ordering appears part of "business rules": the fact that the "XYZ" record must remain on the top, and that there are "other such rules" suggests that sorting is not a purely visual concern
p50015
aVConsider designing a "sort descriptor" of some kind that can hold "metadata" about the sort
p50016
aVYour controller should create an instance of this "sort descriptor", and pass it to the model for processing
p50017
aVThe model should "interpret" the content of the descriptor, and produce the data in the correct order
p50018
as(dp50019
g6
V335858
p50020
stp50021
a((dp50022
g2
(lp50023
VDeclaring a variable influences compile time, not run time
p50024
aVThe space the local variable is going to occupy on the stack is allocated at compile time, so run-time is not going to get influenced
p50025
aVWhat's going to get influenced is readability: generally, it is best to declare your variables close to places where they get used, and keep them in as tight a scope as your program allows
p50026
aVIn this sense, your first code snippet is best
p50027
aVThe only reason to go with snippets 2 or 3 is when you need the value of variables  or  after the loop has finished, for example, to find out when a  statement has been executed
p50028
aVIt is not possible to tell from your examples if this is the case or not
p50029
as(dp50030
g6
V335858
p50031
stp50032
a((dp50033
g2
(lp50034
VYou get a segmentation fault because the pointer has not been assigned:
p50035
aVUnlike objects declared as objects, not as pointers (e
p50036
ag303
aV) pointers need to be initialized: you should either assign them an address of an existing object, or allocate memory for a new object using the operator
p50037
aVDereferencing uninitialized pointers is considered undefined behavior, often causing segmentation faults
p50038
as(dp50039
g6
V335858
p50040
stp50041
a((dp50042
g2
(lp50043
VThe call of  expresses your intentions better, thus improving readability
p50044
aVReaders spend less time understanding what is your intention behind the check: rather than thinking that you are interested in checking string's equality or determining its length, they see that all you want to know is if the string is empty or not
p50045
aVThere is no performance difference, as  is implemented by checking the length
p50046
as(dp50047
g6
V335858
p50048
stp50049
a((dp50050
g2
(lp50051
V means "one or more", so a single space would qualify as a separator
p50052
aVIf you want to require more than once, use :
p50053
aVThe  expression requires the expression immediately prior to it match  to  times, inclusive
p50054
aVOnly one limit is required
p50055
aVIf the upper limit is missing, it means " or more repetitions"
p50056
as(dp50057
g6
V335858
p50058
stp50059
a((dp50060
g2
(lp50061
VCocoa has a very nice data structure called  created specifically for dealing with sets of objects that may repeat
p50062
aVWhen you add a sequence of objects (say, numbers) to it, the structure remembers the number of times each object was added
p50063
aVFor example, if you start with a sequence that looks like this
p50064
aVand add these numbers to a counted set, the structure would be as follows:
p50065
aVWith this set in hand you can construct your array of arrays, or simply keep the coutnted set as a more efficient representation
p50066
aVHere is an example:
p50067
as(dp50068
g6
V335858
p50069
stp50070
a((dp50071
g2
(lp50072
VNET offers many ways of storing constant or nearly constant data: you have a choice among multiple ways of reading XML files, configuration files, resource files with your own format, and so on
p50073
aVIf you would like to define a structure like yours in code, you can use :
p50074
aVThis creates an instance of  that maps  objects to anonymous objects with three properties - , , and
p50075
aVSince objects that go in belong to an anonymous class (note the lack of class name between  and the opening curly brace) the value type of the dictionary is defined as
p50076
aVThis would let you add more attributes in the future without changing anything else
p50077
aVYou can use  like this:
p50078
as(dp50079
g6
V335858
p50080
stp50081
a((dp50082
g2
(lp50083
VDictionary  is shared among all static and non-static methods of the class
p50084
aVThe presence or absence of keys in that dictionary depends only on the timing of their insertion: if the call
p50085
aVis made before the call of , then  should see the value; if the call of  is made after, or the key is deleted before the call of , then lookup of the  is going to fail
p50086
aVNote that passing data through a static member variable is a very fragile approach
p50087
aVIt is much better to pass parameters explicitly - it gives you a lot more control over what to pass:
p50088
as(dp50089
g6
V335858
p50090
stp50091
a((dp50092
g2
(lp50093
VIf the ownership model in your program is that the list "owns" the elements inside it, the second way (i
p50094
ag630
aVwith ) is better
p50095
aVIt lets C++ manage the resources of your list automatically, which is especially important in situations when the list is declared in a local scope, because you do not have to worry about exiting the scope prematurely
p50096
as(dp50097
g6
V335858
p50098
stp50099
a((dp50100
g2
(lp50101
VIn C#  is already an unsigned number ranging from  to
p50102
aVYou can freely assign them to integers, or convert to other numeric types
p50103
as(dp50104
g6
V335858
p50105
stp50106
a((dp50107
g2
(lp50108
VThis is not a function call: you cannot have function calls inside declarations
p50109
aVis a pointer to function that takes no arguments and returns an  declared using a different syntax
p50110
aVConsider this analogy: you can define a new type for a pointer to  and use it in a declaration of a function
p50111
aVor you can say that  is a pointer to  inside the declaration:
p50112
aVIn the same way, you can define the type for your function pointer before using it in a declaration
p50113
aVor you could say that  is a function pointer using the alternative syntax from your post
p50114
aVOne reason to use a  for function pointers is consistency checking when you want to create arrays of function pointers: if your library function uses a function pointer defined inside that function's declaration, you would need to re-create the same declaration in your own code to create an array of pointers that you intend to pass to the library as pointers
p50115
aVThis may lead to inconsistencies that would be visible only at the point of invocation of the library function, instead of the point of array declaration, making potential issues somewhat harder to trace
p50116
as(dp50117
g6
V335858
p50118
stp50119
a((dp50120
g2
(lp50121
VTry using a constructor of  that takes an :
p50122
as(dp50123
g6
V335858
p50124
stp50125
a((dp50126
g2
(lp50127
VIf you know it's the third item that you want to get, one simple approach could be using  method, like this:
p50128
aVThe call of  produces an array of strings like this:
p50129
aVNow you can apply the subscript operator to grab the element that you want
p50130
as(dp50131
g6
V335858
p50132
stp50133
a((dp50134
g2
(lp50135
VIf you can change  to be of type  rather than , you could use :
p50136
aVThis would keep items sorted by  within their own document
p50137
aVNote that using  in a loop may impair the performance
p50138
aVYou would be better off declaring  as , and calling  at the end of each iteration:
p50139
as(dp50140
g6
V335858
p50141
stp50142
a((dp50143
g2
(lp50144
VNeither  nor  are objects - both of them are references to objects *, as indicated by the asterisk in their declarations
p50145
aVThe difference between them and  is that they both are initialized at the time they are declared, while  is initially uninitialized
p50146
aVAfter the assignment  holds a reference to the object allocated inside the  method
p50147
aVUnder ARC, the variable is considered  by default, meaning that the result object will be released when  goes out of scope
p50148
aV* Technically,  and  are pointers, but since in ARC-enabled code they acquire special powers to retain and release the objects to which they point, I called them "object references"
p50149
as(dp50150
g6
V335858
p50151
stp50152
a((dp50153
g2
(lp50154
VSince SQL does not short-circuits s, you can convert an expression tree that looks like this
p50155
aVto an expression tree that looks like this:
p50156
aVThis is only a work-around: ideally, the framework should be able to deal with situations like that
p50157
aVOne way to construct a tree like this is to split your list recursively in halves, construct an "-tree" from each half recursively, and then combine the two "-tree"s with another :
p50158
as(dp50159
g6
V335858
p50160
stp50161
a((dp50162
g2
(lp50163
VIf the grammar is indeed nested like this, writing a very simple top-down parser would be a trivial task: you have very few tokens to recognize, and the nested structure repeats itself very conveniently for a textbook recursive-descent parser
p50164
aVI would not even bother with ANTLR or another parser generator for something this simple, because the learning curve would eat the potential benefits for the project*
p50165
aV*  Potential benefits for you from learning a parser generator are hard to overestimate: if you can spend a day or two learning to build parsers with ANTLR, your view of structured text files will change forever
p50166
as(dp50167
g6
V335858
p50168
stp50169
a((dp50170
g2
(lp50171
VReturning objects allocated in the automatic storage (also known as "stack objects") from a function is undefined behavior
p50172
aVWhen you need to return an array in C, you have three options:
p50173
aVReturn an object allocated in the static storage area,
p50174
aVReturn an object allocated in the dynamic storage area, or
p50175
aVTake a buffer and max size, and return the actual size of the array
p50176
aVThe first option is rarely applicable, because it makes your function non-reentrant
p50177
aVThe third option is widespread, but it has limitations: when you must return more data than fits into the buffer, the API needs to be called multiple times
p50178
aVThis leaves us with option number two: use  to allocate the memory that you are returning, copy the data into it, and return the result to the caller
p50179
aVIt is now caller's responsibility to free the dynamic memory:
p50180
aVNote: you may not have reached the standard library yet, so the solution below may not apply
p50181
aVHowever, you should know that the above solution is not the best C++ can do: you can rewrite this wit dynamic containers, and make the code much easier to read:
p50182
aVIn C++11 you can do even better:
p50183
as(dp50184
g6
V335858
p50185
stp50186
a((dp50187
g2
(lp50188
VYour comparator for  expects C strings, not C++ s
p50189
aVYou should either declare  to be
p50190
aVor (better) use :
p50191
as(dp50192
g6
V335858
p50193
stp50194
a((dp50195
g2
(lp50196
VThe assignment expression  is never true: it is an assignment, not a comparison
p50197
aVThat's why your recursion continues until your program overflows the stack
p50198
aVYou need to change  for  or C's idiomatic , which means the same thing
p50199
aVAlso note that you perform integer division:  is always zero when you use integers
p50200
aVYou need to switch to  or  to get non-zero results
p50201
as(dp50202
g6
V335858
p50203
stp50204
a((dp50205
g2
(lp50206
VSuperclass is not something a subclass instance has, it is something a subclass instance is
p50207
aVYour  "is a"
p50208
aVAll members of  are members of  - the same ones, not copies
p50209
aVThere is no separate  inside the superclass - it is the same  member as in the subclass
p50210
aVYou can refer to it as 's member or as 's member, it's all the same
p50211
as(dp50212
g6
V335858
p50213
stp50214
a((dp50215
g2
(lp50216
VIt looks like the string contains an array with a single  object in it
p50217
aVIf you remove square brackets from both ends of the input, you should be able to deserialize the data as a single object:
p50218
aVYou could also deserialize the array into a list of  objects, and take the object at index zero
p50219
as(dp50220
g6
V335858
p50221
stp50222
a((dp50223
g2
(lp50224
VIf your compiler is compatible with C++11, you can easily do that with lambdas and :
p50225
aVThe idea is to make a map that gives you a function that makes an appropriate subclass
p50226
aVDemo on ideone
p50227
as(dp50228
g6
V335858
p50229
stp50230
a((dp50231
g2
(lp50232
VThis is a common error: i gets evaluated when threads starts, which happens after the loop has ended
p50233
aVMake a temp, assign i to it, and use temp instead of i in your lambda to fix the issue:
p50234
as(dp50235
g6
V335858
p50236
stp50237
a((dp50238
g2
(lp50239
VThe problem with your loops is that the inner loop should iterate the second dimension, not the first
p50240
aVPresently, your code iterates a 2x2 subarray of your 2x3 array; that is why you are getting 24 in place of 39
p50241
as(dp50242
g6
V335858
p50243
stp50244
a((dp50245
g2
(lp50246
VIn Java there are no free-standing functions, you are missing a class declaration outside of your  function
p50247
aVHere is how the structure of your code should look:
p50248
aVAlso watch out for "stray" curly braces throughout your code: it is very important to have your braces balanced, otherwise the program will not compile with very strange errors
p50249
as(dp50250
g6
V335858
p50251
stp50252
a((dp50253
g2
(lp50254
V/ are good when your program needs to access one item at a time, as opposed to iterating over the entire collection
p50255
aVFor example, if you need to collect input from multiple threads, and then examine the state periodically from another thread, these synchronized wrappers are good for the task, because you would not need to write additional code
p50256
aVFor example, if you keep a phone book (name to phone number mapping) in a synchronized map, and the only two operations that you use concurrently are "set new number" and "get current number if available", all you need is wrapping a map of your choice in a
p50257
aVEven in cases when you need to iterate over these synchronized collections, you need to synchronize "manually" only the code around the iterating; the rest of the code remains much simpler and easier to read
p50258
aVFor example, if multiple "producer" threads add data to a synchronized list, and then one "consumer" thread comes along periodically to "harvest" results, only the consumer thread would need explicit synchronization
p50259
as(dp50260
g6
V335858
p50261
stp50262
a((dp50263
g2
(lp50264
VYou can use  as an  instead, then examine its node count
p50265
aVIf the count is zero, say "node not found"; otherwise, grab the attribute, and print it:
p50266
as(dp50267
g6
V335858
p50268
stp50269
a((dp50270
g2
(lp50271
VWhen you pass a pointer by a non- reference, you are telling the compiler that you are going to modify that pointer's value
p50272
aVYour code does not do that, but the compiler thinks that it does, or plans to do it in the future
p50273
aVTo fix this error, either declare  constant
p50274
aVor make a variable to which you assign a pointer to  before calling :
p50275
as(dp50276
g6
V335858
p50277
stp50278
a((dp50279
g2
(lp50280
VYes, you can
p50281
aVThe ability to compare values to zeros implicitly has been inherited from C, and is there in all versions of C++
p50282
aVYou can also use  to check pointers for NULL
p50283
as(dp50284
g6
V335858
p50285
stp50286
a((dp50287
g2
(lp50288
VIn iOS you can put your buttons in a single  in interface builder, or in an  if you create your buttons through code
p50289
aVWith that outlet collection / array in hand, you can use a loop to reference  by their index in the collection:
p50290
aVEdit: OSX does not support s yet, so you would need to put  buttons in an array namually:
p50291
as(dp50292
g6
V335858
p50293
stp50294
a((dp50295
g2
(lp50296
VC#'s class that corresponds to Java's  is
p50297
aVUnlike Java,  is not generic (it does not need to be, because
p50298
aVNET does not use type erasure to implement generics)
p50299
aVYour Java code translates as follows:
p50300
as(dp50301
g6
V335858
p50302
stp50303
a((dp50304
g2
(lp50305
VCan someone explain whatever Joshua called the "view" method
p50306
aVI will continue Jon Skeet's simple example from the answer that you linked in your post:
p50307
aVProviding a view" rather than "extending" would mean designing your class hierarchy like this:
p50308
aVThis frees you up to implement a new  inside the , because there is no requirement to stay compatible with the superclass
p50309
aVIf you need to view your person as a , call  to get a view of the person reduced to a thing with a name
p50310
aVNote that since this is not an is-a relationship, the  is somewhat misleading: you get the named thing inside the person, not the person who happens to be a named thing
p50311
aVThis limits the applicability of : for example, you cannot sort persons among other s
p50312
as(dp50313
g6
V335858
p50314
stp50315
a((dp50316
g2
(lp50317
VWhy don't I get a compile-time error (or at least a warning) when, for my first example, I use a Nullable  rather than a regular  then
p50318
aVIf I understand correctly, using a int
p50319
aVwhen performing my first query will never result in a value of
p50320
aVYour understanding is correct
p50321
aVHowever, the compiler does not interfere with your desire to declare variable  as nullable, because it is a "widening" conversion: even though the assignment from the LINQ query would never return a , you may have other use for the same variable down below:
p50322
as(dp50323
g6
V335858
p50324
stp50325
a((dp50326
g2
(lp50327
VIt breaks because the array  is empty
p50328
aVMake it the size of  (that's allowed in C99) to fix the problem:
p50329
aVThe reason for this is as follows:  makes an array of zero elements, so any dereference  is undefined behavior
p50330
as(dp50331
g6
V335858
p50332
stp50333
a((dp50334
g2
(lp50335
VA pretty neat trick can be used for that:
p50336
aVThe idea is to " in" all ones below the top one after decrementing the value, and then increment the value back at the end
p50337
aVI added a shift right at the end to the standard trick, because the original code was designed to find the smallest  greater than or equal to the given value
p50338
aVEDIT: I also added a special case for , which is another trick from the same list
p50339
aVHere is a demo on ideone
p50340
as(dp50341
g6
V335858
p50342
stp50343
a((dp50344
g2
(lp50345
VIf you need to make  global, add a declaration to a header , like this:
p50346
aVYou need to  in order for this to compile
p50347
as(dp50348
g6
V335858
p50349
stp50350
a((dp50351
g2
(lp50352
Vwhy and how she employs the function map here
p50353
aVThe book shows a dynamic programming technique called memoization
p50354
aVIt is used to avoid calculating the same number again: if the element is not , then it has been computed again, and re-calculating it would mean wasting lots of CPU cycles
p50355
aVDP computes the value once, and then returns it every time the value is needed
p50356
aVmap here is array right
p50357
aVCorrect,  is of an array type
p50358
aVI do not see any line to save an input to the map array but how would it return something
p50359
aVThat would be the assignment on the third line from the bottom:
p50360
aVAnybody has an idea of C++ or C version of this code
p50361
aVIt is hard to understand this code
p50362
aVMaybe not because of the JAVA grammar, but the implicit structure of dynamic programming
p50363
aVRight, DP and memoization take some time to get used to
p50364
aVRun through this algorithm once with paper and pencil for a small number, say, 10
p50365
aVThis will show you how the optimal substructure of the answer helps this algorithm come up with the answer so fast
p50366
aVWhat would be the time complexity of this algorithm
p50367
aVIt should be smaller than O(3^n)
p50368
aVAbsolutely
p50369
aVEach item is computed exactly once, and each item takes amortized  to compute, so the overall complexity of this code is
p50370
aVThis may be counterintuitive, as you observe how the chain of recursive invocations to compute  takes an  recursive invocations
p50371
aVHowever, each invocation finishes the computation of  items of the  (note how  is a one-way street: once you set a non-negative value into a cell, it's going to stay non-negative forever, so re-computing the same value through any other invocation path would take the same  time
p50372
as(dp50373
g6
V335858
p50374
stp50375
a((dp50376
g2
(lp50377
VThis has nothing to do with ANT compilation: the two files are class files compiled from the inner classes of
p50378
aVEven if you compile your program manually you would end up with one file per class, including anonymous classes that your program may have:
p50379
as(dp50380
g6
V335858
p50381
stp50382
a((dp50383
g2
(lp50384
VThe second approach is not going to work, because arrays do not override the  and  in a way that would use the data stored in the array
p50385
aVThe first approach, however, would be slow for collections with high number of cells, because of a linear search
p50386
aVA better approach would be to use  instead of an array:
p50387
as(dp50388
g6
V335858
p50389
stp50390
a((dp50391
g2
(lp50392
VIn Java you need to wrap free-standing C functions in a class
p50393
aVYou need to declare these functions :
p50394
aVNote that since  is a free-standing function in C, its Java version needs to refer to it as a member of the  class
p50395
as(dp50396
g6
V335858
p50397
stp50398
a((dp50399
g2
(lp50400
VThe problem with your code is the use of : each level of invocation has its own , initially set to zero
p50401
aVThe  operator at the bottom has no effect
p50402
aVYou need to compute the result of this invocation based on the result of the previous invocation
p50403
aVYour base case (i
p50404
ag630
aV) is fine; the rest of your code needs to change so that it returns whatever  when the first letter is non-capital; when the first letter is capital, your function should return
p50405
as(dp50406
g6
V335858
p50407
stp50408
a((dp50409
g2
(lp50410
VYes, C allows casting to anonymous structures
p50411
aVHere is a quick demo:
p50412
aVDemo on ideone
p50413
as(dp50414
g6
V335858
p50415
stp50416
a((dp50417
g2
(lp50418
V does not return a value that it calculates
p50419
aVIf you plan to return the count, add
p50420
aVat the end of the function, and declare it :
p50421
aVNote, however, that your computation of percentage is likely to be off because of integer division
p50422
aVYou should either return a , or cast to  before applying division
p50423
aVYou could also change the order of operations
p50424
aVto get an integer result truncated to the highest whole percentage
p50425
as(dp50426
g6
V335858
p50427
stp50428
a((dp50429
g2
(lp50430
VThe scheme that you are trying to set up looks very much like a self-referencing many-to-many scheme:
p50431
aVThere is no separate  entity, only a "friendship link" table called
p50432
aVIt has two attributes - the  for the user entity representing a friend, and the  of the user whose friend it is
p50433
aV"Friendship" may also contain additional attributes, such as the date when friendship has been established, the context in which the friendship exists (college, work, family) and so on
p50434
as(dp50435
g6
V335858
p50436
stp50437
a((dp50438
g2
(lp50439
VYou need to move the anchor inside the lookbehind, like this:
p50440
aVOtherwise, you wouldn't match , because no part of your expression "consumes" the opening square bracket
p50441
as(dp50442
g6
V335858
p50443
stp50444
a((dp50445
g2
(lp50446
VYou need to add a property to the destination view controller to set the desired string
p50447
aVThen you would be able to reference its value from the destination view controller:
p50448
aVNow you can call
p50449
aVor
p50450
aVand then reference  when the destination view shows up
p50451
as(dp50452
g6
V335858
p50453
stp50454
a((dp50455
g2
(lp50456
VSince an array in C is a contiguous region of memory, you cannot "cut out" its parts without making a copy
p50457
aVHere is how to do it with :
p50458
as(dp50459
g6
V335858
p50460
stp50461
a((dp50462
g2
(lp50463
VThis has to do with precedence of the operators: post-increment  has higher precedence than the dereference operator , while  has lower precedence in the table of operator precedences
p50464
aVThat is why in the first example  is applied to the pointer which is dereferenced afterwards, while in the second example  is applied to the result of dereference
p50465
as(dp50466
g6
V335858
p50467
stp50468
a((dp50469
g2
(lp50470
VMaking two storyboards that communicate with each other would go against the intended flow, because storyboards were not intended for grouping parts of an application
p50471
aVAlthough an app may definitely have multiple storyboards, the intention behind allowing multiple storyboards was letting you support different screen paradigms (i
p50472
ag630
aViPhone vs
p50473
aViPad) or different localizations, not grouping related screens together
p50474
aVNote, however, that storyboards are relatively new
p50475
aVYou can define your views in NIB files, and use them instead
p50476
aVAn unfortunate consequence of this choice is that you would need to make all your connections programmatically, but on the other hand you would be able to group your views inside you Xcode project using file groups or folders
p50477
as(dp50478
g6
V335858
p50479
stp50480
a((dp50481
g2
(lp50482
VIf you use generics, your IDE would be able to help:
p50483
aVYou can also use the "for each" syntax, like this:
p50484
as(dp50485
g6
V335858
p50486
stp50487
a((dp50488
g2
(lp50489
VTo start, you do not need the second loop:
p50490
aVNow for the Standard Library solution:
p50491
aVHere is a demo on ideone
p50492
as(dp50493
g6
V335858
p50494
stp50495
a((dp50496
g2
(lp50497
VIf you need to avoid reusing a cell, something is wrong either with your code or the design: the mechanism of reusing cells is very flexible, you should be able to adjust it to your needs
p50498
aVHowever, the effect that you want is relatively easy to achieve: if  returns a cell that you do not want to reuse, do not return that cell from your  method
p50499
aVCreate a new cell in its place, or dequeue another cell
p50500
as(dp50501
g6
V335858
p50502
stp50503
a((dp50504
g2
(lp50505
VConstructor is not just a method: you need to give it the same name as the class, and call it with a  operator, like this:
p50506
as(dp50507
g6
V335858
p50508
stp50509
a((dp50510
g2
(lp50511
VYou can use  to grab the two time strings out of a string:
p50512
as(dp50513
g6
V335858
p50514
stp50515
a((dp50516
g2
(lp50517
VIf you want a global variable,  is what you need
p50518
aVHowever, you should prefer using properties rather than public variables:
p50519
aVYou refer to this global variable using a fully qualified name, like this:
p50520
as(dp50521
g6
V335858
p50522
stp50523
a((dp50524
g2
(lp50525
VYou can expand upon your second approach a little: rather than including a  flag to indicate what property to use, override the getter of your property to return either the value of the  from the superclass, or the value of your own settable  property:
p50526
as(dp50527
g6
V335858
p50528
stp50529
a((dp50530
g2
(lp50531
VOne way to deal with this problem would be setting up a factory method that "understands" different formats, and parses them accordingly
p50532
aVYou can create a chain of --s to deal with this problem, but you can also make a "table-driven" implementation: what you need is an array of delegates that take a string, and tell you two things:
p50533
aVWhether or not this delegate can parse the incoming string, and
p50534
aVIf yes, what is the result of that parse, expressed as
p50535
aVHere is a sample implementation:
p50536
aVNow your factory method could be implemented as follows:
p50537
as(dp50538
g6
V335858
p50539
stp50540
a((dp50541
g2
(lp50542
VThe error says that  is not a valid column name (I'm glad Google translate is there to help)
p50543
aVMsg 207, Level 16, State 1, Line 2 Invalid column name 'rownum'
p50544
aVYou need to fix that error first - make sure that all columns from the 's list are defined in the table
p50545
aVOnce you get that out of your way, you would need to provide an alias for the inner select, like this:
p50546
aVEDIT It appears that you are porting this query from Oracle, so  is not a real column
p50547
aVIn this case you should replace it with a  function, like this:
p50548
as(dp50549
g6
V335858
p50550
stp50551
a((dp50552
g2
(lp50553
VYou would need to put a dashed dependency line, which may be directional or not
p50554
aVIf class  makes use of class , the dependency line should be bidirectional (or directionless)
p50555
aVIf class  does not make use of class  (except possibly through callbacks not tied directly to ) make the dashed line directional from  to
p50556
as(dp50557
g6
V335858
p50558
stp50559
a((dp50560
g2
(lp50561
VI think you misunderstood compiler's message: the complaint is not that you may be accessing properties of the  object, but that you are accessing the variable itself, which does not hold a reference to any object at all - not even a  reference
p50562
aVIn C# local variables are not default-initialized - you must explicitly assign them during or after their initialization before the first use; even comparing them to  is not permitted
p50563
as(dp50564
g6
V335858
p50565
stp50566
a((dp50567
g2
(lp50568
VAlthough you could reuse one of several "pair objects" from the graphics library (you can pick from a  or , or their  equivalents) the s behind these objects are so simple that it would be better to create your own:
p50569
as(dp50570
g6
V335858
p50571
stp50572
a((dp50573
g2
(lp50574
VThe  operator is a shift right; shifting a positive number right by one bit is equivalent to integer-dividing by two (for the same reason why removing the last digit of a decimal number is an equivalent of integer-dividing the number by ten)
p50575
as(dp50576
g6
V335858
p50577
stp50578
a((dp50579
g2
(lp50580
VMy only explanation is that the database is set up to expect the month ahead of the day
p50581
aVThe second query can be interpreted as Nov-04, 2013 in this format, but the first query would have an error because there is no month number 20
p50582
as(dp50583
g6
V335858
p50584
stp50585
a((dp50586
g2
(lp50587
VGiven a freed pointer, what is keeping you from reassiging that pointer to a new memory location
p50588
aVTechnically, nothing
p50589
aVYou do not even need to set  in between of freeing and re-assigning the pointer
p50590
aVWhen freeing and re-assigning are separated by other lines of code, however, setting the pointer to  may improve readability slightly
p50591
aVWhy would writing to a memory block that was previously freed, that still has the original pointer to it, cause the program to crash
p50592
aVSimply holding a pointer to a block of memory accessible through another pointer is absolutely OK, as long as your program does not try dereferencing that pointer
p50593
aVUnfortunately, even if you dereference the freed pointer, it would not necessarily cause your program to crash: more often than not, such behavior would go unnoticed
p50594
aVIt remains an undefined behavior, though
p50595
aVAnother part of your program may have written data incompatible with what you expect, in which case you will see bugs that are extremely hard to find or explain
p50596
as(dp50597
g6
V335858
p50598
stp50599
a((dp50600
g2
(lp50601
VYou need to insert an explicit cast to  for any pointer except , because the standard guarantees that character pointers and void pointers have identical representation:
p50602
ag837
ag839
ag10442
aV27: A pointer to  shall have the same representation and alignment requirements as a pointer to a character type
p50603
aVYour C89 program has the same problem, but the compiler does not catch it
p50604
aVHere is the fix:
p50605
as(dp50606
g6
V335858
p50607
stp50608
a((dp50609
g2
(lp50610
VHere is how you can do it in C (C99 demo):
p50611
aVIn C++ you would need to insert casts (C++ demo):
p50612
as(dp50613
g6
V335858
p50614
stp50615
a((dp50616
g2
(lp50617
VIf the numbers have a small upper limit, you can use a counting sort: count how many times each item appears in the array, then walk through the array, and put in as many items as you counted for each of the values
p50618
aVFor example, in your case you would count 17 zeros, 7 ones, and 4 twos
p50619
aVSet the first 17 items to 0, the following 7 to 1, and the remaining 4 to 2 to get a sorted array
p50620
aVThis approach has linear complexity
p50621
as(dp50622
g6
V335858
p50623
stp50624
a((dp50625
g2
(lp50626
VYour general approach is fine, except for the  part: you keep re-using the same list, and insert its copy at all keys
p50627
aVAs the result, all keys end up with the same list of words as the last key
p50628
aVTo fix this problem, replace  with
p50629
aVand move the line ahead of the  line:
p50630
aVAlso note that since the addition happens upon encountering the first word in a given letter, you need to replace  with  or another letter that cannot start a real word
p50631
as(dp50632
g6
V335858
p50633
stp50634
a((dp50635
g2
(lp50636
VThis should work:
p50637
aVThis code produces a list of objects of anonymous type with two fields - the  field with the item, and the  containing its associated item that has  of
p50638
aVNote that the above code assumes that there is at most one associated item with  of ; otherwise,  would fail
p50639
as(dp50640
g6
V335858
p50641
stp50642
a((dp50643
g2
(lp50644
VThere are two problems with your code:
p50645
aVYou need to remove the argument list in the declaration of the constructor - Unlike C++, this list of type arguments is implied, and
p50646
aVIf  has a  object that does not have type parameters, you need to add a type cast:
p50647
as(dp50648
g6
V335858
p50649
stp50650
a((dp50651
g2
(lp50652
VThis is a specific of using the  command, not of the
p50653
aVThe issue is that the memory freed by data structures is not released back to the operating system, the level at which the  command monitors memory usage
p50654
aVThe memory the OS has given your program remains with your program until the memory manager of C++ decides that it's time to free some memory back to the operating system
p50655
aVThe reason for this is that allocating memory from the operating system is relatively expensive, and it needs to be done in relatively large chunks
p50656
aVThe memory manager of the C++ runtime library obtains memory from the OS "wholesale", and then parcels it out to the parts of your program as needed
p50657
aVIf you would like to verify that the memory does indeed get reclaimed, use a tool that monitors memory usage at a lower level, such as
p50658
as(dp50659
g6
V335858
p50660
stp50661
a((dp50662
g2
(lp50663
VIt does not look like in your situation  represents something that you can enumerate: you are checking the words that start the text, not the text in its entirety
p50664
aVIn cases like this, you should not use a , and go for a chain of --s instead:
p50665
as(dp50666
g6
V335858
p50667
stp50668
a((dp50669
g2
(lp50670
VCreate an array of s, and access them in a loop through an index, like this:
p50671
as(dp50672
g6
V335858
p50673
stp50674
a((dp50675
g2
(lp50676
VYou need to implement a dynamic programming algorithm for the longest ascending subsequence
p50677
aVThe idea is to store a pair of values for each position :
p50678
aVThe length of the longest ascending subsequence that ends at position
p50679
aVThe index of the item preceding the current one in such ascending subsequence, or  if all prior numbers are greater than or equal to the current one
p50680
aVYou can easily build both these arrays by setting the first pair to , walking the array in ascending order, and looking for the "best" predecessor for the current item at index
p50681
aVThe predecessor must fit these two conditions:
p50682
aVIt must have lower index and be smaller than the item at , and
p50683
aVIt must end an ascending subsequence of length greater than the one that you have found so far
p50684
aVHere is how the data would look for your sequence:
p50685
aVOnce you finish the run, find the max value among s array, and chain it back to the beginning using the predecessor's indexes until you hit
p50686
as(dp50687
g6
V335858
p50688
stp50689
a((dp50690
g2
(lp50691
VYou can use an  operator for that:
p50692
aVNote that this would check that both words are there in any order
p50693
aVIf you must ensure that the first word precedes the second, get indexes of each word, and check that the index of the first word is lower than the index of the second one:
p50694
as(dp50695
g6
V335858
p50696
stp50697
a((dp50698
g2
(lp50699
VUnlike other languages such as C or C++, you cannot put variables or other declarations outside of a class or a function:
p50700
aVIn this case, a local variable looks like a better choice
p50701
as(dp50702
g6
V335858
p50703
stp50704
a((dp50705
g2
(lp50706
VYou can use LINQ, like this:
p50707
aVHowever, this is not faster than what you are doing
p50708
aVIf you need a faster way of copying a fixed number of bytes known at compile time, you can eliminate the loop overhead, which is not that big, but should work if you must squeeze the last CPU cycle out of this:
p50709
aVYou can also reduce the overhead by unwinding the loop
p50710
aVFor example, if you know that the number of bytes that you would like to copy is divisible by four, you can do this:
p50711
as(dp50712
g6
V335858
p50713
stp50714
a((dp50715
g2
(lp50716
VThe confusing result is due to the fact that  is an unsigned type
p50717
aVWhen  is converted to , its bit representation becomes  in binary, because two's complement representation is used
p50718
aVThat representation becomes a positive  when converted to decimal - the result you see printed by your program
p50719
as(dp50720
g6
V335858
p50721
stp50722
a((dp50723
g2
(lp50724
VUse unicode character "PLUS-MINUS SIGN"
p50725
aVIts code point is
p50726
as(dp50727
g6
V335858
p50728
stp50729
a((dp50730
g2
(lp50731
VCreating a new enemy does not have any effect because you are assigning the enemy object to a temporary variable with the lifetime limited to a single loop iteration
p50732
aVIf you want to store the enemy object in the list of enemies, you need to add a call of  method, like this:
p50733
aVthis would replace the old object representing an enemy with the one you have just created
p50734
as(dp50735
g6
V335858
p50736
stp50737
a((dp50738
g2
(lp50739
VYour first attempt implies existence of  function that takes a  and a multicharacter  literal and gets the field; there is no such function in C
p50740
aVYour second attempt is much closer: rather than trying to assign the name to an array, assign it to a  pointer, like this:
p50741
as(dp50742
g6
V335858
p50743
stp50744
a((dp50745
g2
(lp50746
VThe first approach is called "passing by pointer"; the second approach is called "passing by reference"
p50747
aVIn the first case, dereference is explicit; in the second case, dereference is implicit
p50748
aVThe biggest difference between the two approaches is that when you pass by pointer, you can pass "nothing" (i
p50749
ag630
aVa null pointer)
p50750
aVWhen you pass by reference, it is not possible to legally pass a reference to nothing: it should be a reference to some variable, an array element, a field of a class or a structure, etc
p50751
aVWhen you need to return a value and modify a variable, passing by reference is more appropriate, because the variable that you need to modify always exists
p50752
aVPassing by pointer becomes more appropriate in situations when you traverse a dynamic data structure connected by pointers, when parts of that data structure may or may not exist
p50753
as(dp50754
g6
V335858
p50755
stp50756
a((dp50757
g2
(lp50758
VYes, you can do that with less code by "folding" the statements into a loop, and using a mutable dictionary:
p50759
as(dp50760
g6
V335858
p50761
stp50762
a((dp50763
g2
(lp50764
VSince properties are methods, you can call them through
p50765
aVTo make a selector from string use
p50766
aVThe  will be wrapped in an  object of type , so you need to pull it back by calling :
p50767
as(dp50768
g6
V335858
p50769
stp50770
a((dp50771
g2
(lp50772
VWhat is wrong with my expectation
p50773
aVEvaluation order of function parameters is not specified - it is left up to the implementation
p50774
aVMoreover, there is no sequence point * between the parameters, so using a modified parameter again before a sequence point cannot give you a predictable result: it is undefined behavior (thanks, Eric, for providing a reference to the standard)
p50775
aVIf you want a particular evaluation order, you need to evaluate your parameters as full expressions (that forces a sequence point between each of them):
p50776
aV* Sequence point is a fancy name for a place in code after which you can count on side effects, such as increments or decrements, of all preceding expressions to have been applied
p50777
as(dp50778
g6
V335858
p50779
stp50780
a((dp50781
g2
(lp50782
VCount how many  1s, 2s, 3s, and 4s you've got, then put the numbers back according to the count:
p50783
aVThis has a linear time complexity despite having two nested loops, because the number of times the innermost assignment is executed equals exactly the number of items in the original array
p50784
as(dp50785
g6
V335858
p50786
stp50787
a((dp50788
g2
(lp50789
VYou can somewhat simplify this by interpreting sets of numbers as sets of bits
p50790
aVConvert a set of small numbers 0
p50791
aV11 to a single  such that if a number  is present in the set, then bit number  is set in the ; otherwise, the corresponding bit is zero
p50792
aVFor example, your illustration would be converted to a number  in binary (spaces are for separating the groups)
p50793
aVNote that the bits are reversed, because cell #1 is on the left, while bit number zero is on the right
p50794
aVThis corresponds to octal number  (octal is convenient when you consider triples of bits)
p50795
aVGiven a mask like that, you can check each triplet of bits for validity
p50796
aVThere are only eight possibilities - , , , , , , , and
p50797
aVOf them only , , and  are valid
p50798
aVHere is one way of implementing this:
p50799
as(dp50800
g6
V335858
p50801
stp50802
a((dp50803
g2
(lp50804
VWhat have I done here
p50805
aVYou created a function object - an object that provides an implementation for the , and supplied its class to instantiate the  template
p50806
aVHow did I overload this operator
p50807
aVYou provided its public implementation (note that  makes its members  by default)
p50808
aVIsn't that unary operator
p50809
aVNo
p50810
aVA unary operator takes one operand; your operator takes two operands, and is, therefore, binary
p50811
as(dp50812
g6
V335858
p50813
stp50814
a((dp50815
g2
(lp50816
VIf you need to reuse a piece of logic in multiple places, defining a function is the best way of reusing the code
p50817
aVCopy-pasting the same logic in another place is not a good idea, because it reduces readability and becomes a maintenance liability in case you must change the logic
p50818
aVThere is little or no performance implications because Java compiler automatically inlines static methods if it finds it beneficial
p50819
as(dp50820
g6
V335858
p50821
stp50822
a((dp50823
g2
(lp50824
VIterators are modeled after pointers; this includes output iterators
p50825
aVWhen you copy data to a region pointed to by a pointer, you dereference the pointer, make an assignment, and then increment the pointer
p50826
aVYou do the same to iterators, including these of the output variety *
p50827
aVIt is customary to combine the increment with the assignment, like this:
p50828
aVWhen an iterator expects to be assigned and incremented, you can mix and match iterators and algorithms expecting them
p50829
aVFor example, you can perform printing of a container by calling  - the same algorithm that you can use to copy one container into another, copy a container into an array, or populate a container from an array
p50830
aV* It is worth to note that both overloads of  do nothing for
p50831
aVThey are included to satisfy the requirements of
p50832
aVSee this link for more details
p50833
as(dp50834
g6
V335858
p50835
stp50836
a((dp50837
g2
(lp50838
VClass file in C# is a text file
p50839
aVIt does not matter how you create it - by adding a new class from a template, adding a blank text file and editing it, copying an existing file, or writing a file in a notepad, and adding it to a VS solution
p50840
aVThe only thing that matters is what you write in your class file
p50841
aVIf you do not like a template, you can edit it, use a different template, or type in a file from scratch
p50842
aVThe end result is going to be the same
p50843
as(dp50844
g6
V335858
p50845
stp50846
a((dp50847
g2
(lp50848
V has a  property, which is a regular
p50849
aVYou are responsible for providing its implementation (typically, that's the original view controller to which the search display controller is attached)
p50850
aVThe data source must implement
p50851
aVThis is where you produce cells that represent results of the search
p50852
aVWhen you create a cell that needs a disclosure indicator, add that indicator in the accessory view before returning the cell from the method
p50853
as(dp50854
g6
V335858
p50855
stp50856
a((dp50857
g2
(lp50858
VThis is because the parameterless  produces an array of s
p50859
aVYou need to call the overload which takes the output array as the parameter, and pass an array of s, like this:
p50860
aVIn Java 5 or newer you can drop the cast
p50861
as(dp50862
g6
V335858
p50863
stp50864
a((dp50865
g2
(lp50866
VWhen  does not find the data that looks like what you would like to read, it does not advance the reading position, so EOF never gets reached
p50867
aVCheck that the  gives you two numbers back, and break when it does not:
p50868
aVYou can drop the  check altogether, because the  is going to happen sooner
p50869
as(dp50870
g6
V335858
p50871
stp50872
a((dp50873
g2
(lp50874
VThe function tells you the next prime after a number that the end-user enters
p50875
aVThe  variable serves as a Boolean "flag" that lets you pass information about a condition that you find inside a loop to the code that runs outside that loop
p50876
aVThe inner  loop tries consecutive odd numbers as divisor candidates
p50877
aVWhen it finds a divisor, it needs to make the fact that the divisor has been found (and therefore the candidate is not prime) known to the outer / loop by setting the  flag to
p50878
aVThe outer loop checks that flag, and exists the loop only when it is remains  after all candidates in the range  have been exhausted
p50879
as(dp50880
g6
V335858
p50881
stp50882
a((dp50883
g2
(lp50884
VThis depends on where that variable is declared:
p50885
aVIf it is a member variable (i
p50886
ag630
aVa field) then its default value is
p50887
aVIf it is a local variable, then it has no default value, and you must assign it before its first use (the compiler throws an error if you try using a variable unassigned)
p50888
as(dp50889
g6
V335858
p50890
stp50891
a((dp50892
g2
(lp50893
VThis is a valid design question, but I think you are approaching it from a wrong angle: rather than thinking about app domains and other things that may make it harder for you to implement the functionality, think where it belongs from the point of view of the logical design
p50894
aVHere are some considerations that may influence your thinking:
p50895
aVYour class library presents a certain interface to its users
p50896
aVDoes it make sense for all users that call your class library to sit behind a layer of an in-memory cache
p50897
aVIf the answer to this question is "yes", then caching functionality belongs in the class library
p50898
aVSince the class library is a separate entity, presumably you would like to hide some implementation details from the library's customers, such as the window's service
p50899
aVIf the service is to cache the data for some period of time, then the service would possess the knowledge that the data changes infrequently
p50900
aVShould this be undesirable, put the caching functionality in the class library
p50901
aVIf the data by its nature can change more frequently than it does for the particular windows service that you are writing, then the caching belongs in the windows service
p50902
aVIf you plan to implement additional functionality in the future that would control the state of the cache, for example, a way to force cache invalidation, then the functionality belongs in the windows service (although you could also put it in the class library, and give its users explicit control over its state)
p50903
as(dp50904
g6
V335858
p50905
stp50906
a((dp50907
g2
(lp50908
VThe difference between
p50909
aVand
p50910
aVis that the first operates on the  object that you have passed in through a reference , while the second one re-assigns a new object to that variable, making the original object inaccessible to your extension method
p50911
aVYou can use  method as a backdoor for filling the original data set with sorted data:
p50912
aVThis will work, because the data would be copied into the original
p50913
as(dp50914
g6
V335858
p50915
stp50916
a((dp50917
g2
(lp50918
VThe problem with which you are wrestling comes from the need to call a different implementation based on the run-time types of both the amo and the weapon
p50919
aVEssentially, the action of reloading needs to be "virtual" with respect to two, not one, object
p50920
aVThis problem is called double dispatch
p50921
aVOne way to address it would be creating a visitor-like construct:
p50922
aVThe magic" happens in the implementations of  of the weapon subclasses: rather than deciding what kind of amo they get, they let the amo itself do "the second leg" of double dispatch, and call whatever method is appropriate, because their  methods know both their own type, and the type of the weapon into which they are being reloaded
p50923
as(dp50924
g6
V335858
p50925
stp50926
a((dp50927
g2
(lp50928
VNumbers , ,  and so on represent negative powers of two, and therefore are representable exactly in IEEE 754 types
p50929
aVUsing these numbers does not result in representation errors
p50930
as(dp50931
g6
V335858
p50932
stp50933
a((dp50934
g2
(lp50935
VYou did not specify the file owner two times: the first time (in the XIB file) you specified the type of the file owner; this is necessary for the Interface Builder to know which outlets it can connect
p50936
aVThe second time (in the Objective C code) you specified the instance of the owner
p50937
aVThis is necessary at runtime to know the object into which the outlets are connected
p50938
as(dp50939
g6
V335858
p50940
stp50941
a((dp50942
g2
(lp50943
VThe easiest way to generate code dynamically in
p50944
aVNET 3
p50945
aV5+ is by converting LINQ Expression Trees to executable code through the  method of the  class
p50946
aVNET 4
p50947
aV0 has greatly expanded the possibilities, adding support for code structures beyond simple expressions of
p50948
aVNET 3
p50949
aV5, letting you construct fully functional methods
p50950
aVThe resultant code gives you the same high performance as regularly compiled code would, assuming that your expression generator has applied the same kinds of optimizations a C# compiler would while generating the code
p50951
aVHere is how you could generate the code from your snippet:
p50952
aVWith this method in place, you should be able to generate compiled s that would do the assignments as needed
p50953
as(dp50954
g6
V335858
p50955
stp50956
a((dp50957
g2
(lp50958
VThere are no reference variables in
p50959
aVNET, only  parameters
p50960
aVYou can pass a reference to a variable into a method, but once the method ends, that reference is gone as well
p50961
aVYou are correct that using a single-item array for its mutability is a hack
p50962
aVYou can build your own "mutable reference" class instead, with  and  operations changing the object inside your reference class
p50963
aVYou can also make that class generic on the type of the object that it holds
p50964
aVHowever, good chances are that the need to use a global variable is a consequence of some poor design choice that you made earlier
p50965
aVIt is hard to tell for sure without seeing the rest of your design, but if you could think of a way to eliminate that global, the problem of needing to store a reference will be solved as well
p50966
aVFor example, knowing that
p50967
aVI'm in a DLL and want the user to pass me the reference of his variable of any type so I can update it each second
p50968
aVyou should change the API that you present to the user from this
p50969
aVto this:
p50970
aVThe users of your code will pass a delegate for you to call when you want to update the value of interest
p50971
aVThen it would be up to them to assign the value that you pass to them to whatever variable they may choose
p50972
aVYou can store the  delegate, and call it each time that you want to update the value
p50973
aVIt will be up to you to update it each second, or skip updates whenever the value does not need to change
p50974
aVOverall, this would achieve a better separation between your code and the code of your callers
p50975
as(dp50976
g6
V335858
p50977
stp50978
a((dp50979
g2
(lp50980
VIf one of the two strings in each pair is unique, as your suggestion to use an  seems to suggest, you may want to expose an API that returns , and use an implementation of your choice for that interface (say, )
p50981
aVThe users of your class would be able to pull the pairs of s from the  by using , rather than calling a  for each key:
p50982
as(dp50983
g6
V335858
p50984
stp50985
a((dp50986
g2
(lp50987
VI think the reason they put  in place of  is that they are short on space: if they put  instead of , the other digits would no longer line up
p50988
aVI think this is a better illustration of what is going on:
p50989
aVSince in the end you add up all the digits, having a single  vs
p50990
aVdoes not make a difference on the final result
p50991
aVTo generate lots of valid SINs you could generate random nine-digit numbers, compute their "check sum", find the remainder of that check sum when divided by ten, and adjust one or more of the digits in positions 1, 3, 5, 7, or 9 to get the correct check sum
p50992
as(dp50993
g6
V335858
p50994
stp50995
a((dp50996
g2
(lp50997
VThere are situations when multiple assignments are definitely inappropriate
p50998
aVFor example, the following should never be done:
p50999
aVThere are situations when multi-assignments provide for better readability - specifically, when you are assigning the same object instance to two variables before going into an algorithm that may or may not leave them "pointing" at the same object:
p51000
aVThough technically it is not the same, a related situation when multi-assignment provides for better readability is when you cache a result:
p51001
aVIn this case the assignment of  to  also changes , unless  is non-null to begin with
p51002
as(dp51003
g6
V335858
p51004
stp51005
a((dp51006
g2
(lp51007
VOne reason why this might not work is because you may be reading fewer characters than eight
p51008
aVSay, the user enters three characters, and presses
p51009
aVIn that case the  at position  will remain unassigned, so reading it would be undefined behavior
p51010
aVWhat you really want to ask is whether or not the eight characters preceding the first  in the string are all non-zero
p51011
aVYou can do that by calling
p51012
aVNote that you cannot get a string of length eight when you pass  for the length, because  will use the last position for :
p51013
as(dp51014
g6
V335858
p51015
stp51016
a((dp51017
g2
(lp51018
VI think the interviewer was trying to see if you understand the purpose of runtime exceptions, which is to signal programmer's errors (as opposed to application exceptions, which signal problems with the execution environment)
p51019
aVYou can and you should create subclasses of  whenever your method needs to signal a condition that amounts to a programming error, and you need to provide additional information regarding the error the exception describes
p51020
aVFor example, consider a class that lets you store data in a sparse multidimensional array
p51021
aVOne of the APIs such class would probably provide is a getter that takes an array of indexes
p51022
aVThe number of indexes needs to equal the number of dimensions in the array, and each index must be within its bounds
p51023
aVSupplying an array parameter that has an incorrect number of elements, or has one or more element outside its bounds, is a programming error
p51024
aVYou need to signal it with a runtime exception
p51025
aVIf you wan to signal this error, and provide a full account of what went wrong, you subclass , a subclass of , to build your own exception
p51026
aVFinally, there is one more situation when you want to subclass : when you should provide a "regular" exception, but you do not want your users to wrap each call of your API in a / block
p51027
aVIn situations like these, you can replace a single method
p51028
aVwith a pair of methods
p51029
aVThe first method tells the caller that it is safe to call the second method in the current state; it never throws an exception
p51030
aVThe second method fail only in the state when the first method returns , making a failure a programming error, thus justifying the use of  to signal such failures
p51031
as(dp51032
g6
V335858
p51033
stp51034
a((dp51035
g2
(lp51036
VWhen you list multiple constrains separated by comma, you tell C# that  must satisfy all* these constraints, not one or the other
p51037
aVYou cannot make a constraint saying that  must be one of two classes
p51038
aVBy constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all the interfaces that you list as the type constraints
p51039
aVThat is the purpose of having type class-based and interface-based constraints in the first place - letting you call operations beyond what's supported by the  class
p51040
aVAs a result, you never put two classes in a list of constraint (but you can put a class and as many interfaces as you wish, of course)
p51041
aVEven when the two classes are related, putting the most derived one in the constraint would be equivalent to putting both of them in
p51042
as(dp51043
g6
V335858
p51044
stp51045
a((dp51046
g2
(lp51047
VPut  in an array, and add a different recognizer to them in a loop
p51048
aVGive each  a tag that corresponds to the number that you want added to the , and use  to find that number at runtime:
p51049
as(dp51050
g6
V335858
p51051
stp51052
a((dp51053
g2
(lp51054
VIf you are asking about the difference between  and , these two are completely different:
p51055
aVBinary zero corresponds to a non-printable character  (also called the null character), with the code of zero
p51056
aVThis character serves as null terminator in C string:
p51057
ag10442
ag839
ag1340
aV2 A byte with all bits set to 0, called the null character, shall exist in the basic execution character set; it is used to terminate a character string
p51058
aVASCII character zero  is printable (not surprisingly, producing a character zero when printed) and has a decimal code of 48
p51059
as(dp51060
g6
V335858
p51061
stp51062
a((dp51063
g2
(lp51064
VEfficiency aside, the second way is preferred, because the exception is not thrown in a non-exceptional situation
p51065
aVThe first way to "dispatch" uses exception throwing in a regular control flow, which makes it harder to read your program
p51066
aVBesides, the two methods are not identical: the first program must be declared as throwing a checked exception, because not all subtypes are handled by the  blocks
p51067
aVIf you are dealing with custom exceptions that your program defines, you have a way to avoid checking the subtype: since  objects are regular classes, you could add a package-visible method to them, and have them implement a package-visible interface holding that method
p51068
aVExceptions would then be able to override that method, letting you use a regular "virtual" dispatch rather than checking for the exact class type at runtime
p51069
aVHere is an illustration of this approach: let's say you want your exceptions to write themselves to a log file
p51070
aVYou can do this as follows:
p51071
as(dp51072
g6
V335858
p51073
stp51074
a((dp51075
g2
(lp51076
VYou do not need a  for that:
p51077
as(dp51078
g6
V335858
p51079
stp51080
a((dp51081
g2
(lp51082
VThe reflection-based approach is cleaner, because it does not require your classes to implement additional methods, and you would not be liable to maintain these methods when new fields are added to existing classes
p51083
aVA -based approach does not buy you much in terms of performance, because primitives must be wrapped in objects to be inserted into the map - the same way they would be wrapped to be returned from the reflection-based calls
p51084
as(dp51085
g6
V335858
p51086
stp51087
a((dp51088
g2
(lp51089
VThere is a difference between string literals and primitive constants
p51090
aVString literals are usually stored with the code in a separate area (for historical reasons this block is often called the "text block")
p51091
aVPrimitive constants, on the other hand, are somewhat special: they can be stored in the "text" block as well, but their values can also be "baked" into the code itself
p51092
aVFor example, when you write
p51093
aVthe return expression could be translated into a piece of code that does not reference  at all
p51094
aVInstead of producing binary code that looks like this
p51095
aVthe compiler may produce something like this:
p51096
aVEssentially, despite being stored with the rest of the constants,  is cut out of the compiled code
p51097
aVAs far as integer literals constants go, they have no address at all: they are always "baked" into the code: when you reference them, instructions that load explicit values are generated, in the same way as shown above
p51098
as(dp51099
g6
V335858
p51100
stp51101
a((dp51102
g2
(lp51103
VFirst of all, this is a Java-specific syntax: there is no comparable syntax in C#, where you must either create an anonymous class extending , or create an instance of a named class
p51104
aVIn Java this syntax lets you create an anonymous subclass of , overriding any methods as you see fit
p51105
aVThis is equivalent to creating a named class that extends , overriding any methods as you do in the curly braces following the  constructor call, and then using the name of that derived class in the call of
p51106
aVThe only difference is that such derived class would have a name, while the anonymous class from your example does not have a name * available to programmers
p51107
aV* Internally anonymous classes do have names: you can see them if you look at the list of class files generated by the Java compiler
p51108
aVFiles with dollar signs and numbers in their names correspond to anonymous classes
p51109
as(dp51110
g6
V335858
p51111
stp51112
a((dp51113
g2
(lp51114
VThe usefulness and applicability of the singleton pattern depends a lot on the environment in which it is applied
p51115
aVThe biggest complaint about it is testability of the code that is based on the singleton
p51116
aVOther complaints include potential problems it may present in concurrent environments, and difficulties one may face trying to reclaim the resources owned by the singleton
p51117
aVHowever, none of these issues presents a major problem in developing apps for iOS:
p51118
aVThere is usually only one singleton for the model in your application; you can make it swappable to ensure testability, for example by reading the name of the class to instantiate from run-time configuration, or deducing it from the run-time environment
p51119
aVAlthough iOS apps use concurrent constructs, they are for the most part single-threaded
p51120
aViOS apps run until end-user kills them, at which point the operating system reclaims the resources automatically; killing the singleton does not present a particular issue
p51121
aVDue to these considerations the singleton pattern became a popular implementation technique of iOS apps
p51122
aVAs long as you know its shortcomings and are willing to work with them, there is absolutely nothing wrong with using the singleton pattern in your app for iOS
p51123
as(dp51124
g6
V335858
p51125
stp51126
a((dp51127
g2
(lp51128
VI am sure that the interviewer was looking for you to extend  anonymously:
p51129
as(dp51130
g6
V335858
p51131
stp51132
a((dp51133
g2
(lp51134
VYou cannot convert a method to a class, but you can move a method to a place from which it would be shared by both  and : create a base class, and make the  and  classes extend it
p51135
aVNow the code of the  method does not need to be repeated, and it uses the implementation of the  method provided in each of the two subclasses of
p51136
as(dp51137
g6
V335858
p51138
stp51139
a((dp51140
g2
(lp51141
VYour  statement contains boolean expressions that are not mutually exclusive
p51142
aVSome of these expressions are stronger than others
p51143
aVA condition  is said to be stronger than a condition  if  implies
p51144
aVIn other words,  is true every time the  is true
p51145
aVFor example, consider two conditions:
p51146
aVand
p51147
aVEvery time condition 2 is satisfied, condition 1 will be satisfied as well, because condition 1 is -ed with some additional criteria to form condition 2
p51148
aVTherefore, condition 2 is stronger than condition 1
p51149
aVWhen you have a case statement with non-mutually exclusive conditions like yours, you need to order them from strongest to weakest
p51150
aVOtherwise, your weaker conditions would "shadow" the stronger ones, never letting them to execute
p51151
as(dp51152
g6
V335858
p51153
stp51154
a((dp51155
g2
(lp51156
VThe number  has the following binary representation as a 64-bit :
p51157
aVshows the position of the sign;  of the exponent, and  of the mantissa (i
p51158
ag630
aVthe value without the exponent)
p51159
aVSince the representation uses binary exponent and mantissa, doubling the number increments the exponent by one
p51160
aVYour program does it precisely 771 times, so the exponent which started at 1075 (decimal representation of ) becomes 1075 + 771 = 1846 at the end; binary representation of 1846 is
p51161
aVThe resultant pattern looks like this:
p51162
aVThis pattern corresponds to the string that you see printed, only backwards
p51163
aVAt the same time, the second element of the array becomes zero, providing null terminator, making the string suitable for passing to
p51164
as(dp51165
g6
V335858
p51166
stp51167
a((dp51168
g2
(lp51169
VI think you mistake the syntax of SQL for the flow of execution performed by the RDBMS engine: this query
p51170
aVwill be optimized to perform a join only to the rows of  filtered by the  condition, not on the entire , by any query optimizer that is worth its salt, despite the fact that the  clause appears textually after the
p51171
aVYou may want to rewrite this without an inner  like this:
p51172
as(dp51173
g6
V335858
p51174
stp51175
a((dp51176
g2
(lp51177
VPerformance of a list is nearly identical to that of an array
p51178
aVIf you know the exact number of items that you are planning to add, you can eliminate the potential memory overhead as well by creating a list with the exact number of elements to avoid re-allocations on :
p51179
aVIn most instances, this turns out to be a premature micro-optimization
p51180
as(dp51181
g6
V335858
p51182
stp51183
a((dp51184
g2
(lp51185
VThe  is a property that returns the controller that is currently visible, not a boolean property returning  or  depending on whether or not the current controller is visible
p51186
aVAs long as there is a visible view controller on the screen - any controller at all - the check of  will return , because any non- value passed to an  is considered a
p51187
aVThe check should be as follows:
p51188
aVThe comparison will return  if the current view controller is the visible view controller of the navigation controller, and  otherwise
p51189
as(dp51190
g6
V335858
p51191
stp51192
a((dp51193
g2
(lp51194
VYour code makes use of  to print
p51195
aVC++ makes  available for input from the console:
p51196
as(dp51197
g6
V335858
p51198
stp51199
a((dp51200
g2
(lp51201
VYou can convert the four booleans into a binary number 0
p51202
aV15, and use an array to look up the parameter, like this:
p51203
aVNow  has a number from 0 to 15, so you can do this:
p51204
as(dp51205
g6
V335858
p51206
stp51207
a((dp51208
g2
(lp51209
VExpressions with logical operators  and  evaluate left to right:
p51210
aVC99, Section 6
p51211
ag10442
aV14-4 Unlike the bitwise  operator, the  operator guarantees left-to-right evaluation; there is a sequence point after the evaluation of the first operand
p51212
aVIf the first operand compares unequal to , the second operand is not evaluated
p51213
aVSince  is not zero, the expression short-circuits evaluation of everything to the right of , including their side effects
p51214
aVThat's why only  is evaluated, so  becomes
p51215
aVThe remaining variables stay at , as they should
p51216
as(dp51217
g6
V335858
p51218
stp51219
a((dp51220
g2
(lp51221
V is a block expecting two s
p51222
aVYou need to put  as the argument type, and do casting inside your block if necessary (in this case, it is not necessary):
p51223
as(dp51224
g6
V335858
p51225
stp51226
a((dp51227
g2
(lp51228
VThe answer depends on whether  is known at compile time or only at runtime
p51229
aVIf  is known at compile time, then partial template specification is the way to go (in the same spirit as the implementation of  is a template specification)
p51230
aVIf  is known only at runtime, you can implement a State Pattern to keep an object internal to your vector that performs the actions, make two implementations of it, and hide a pointer to its instance inside the vector object:
p51231
aVThis example assumes that vectors of two elements and vectors of more than two elements will have the same data members, so I made  and  shared
p51232
aVIf this is not the case, you can allocate new  or  inside the constructor
p51233
as(dp51234
g6
V335858
p51235
stp51236
a((dp51237
g2
(lp51238
VThe only way of getting a return value from a block is to invoke it:
p51239
as(dp51240
g6
V335858
p51241
stp51242
a((dp51243
g2
(lp51244
VThese are just binary numbers
p51245
aVis a binary number with  in the -th position and zeros everywhere else
p51246
aVTo figure out a value of several of them -ed together, write a binary number with ones in the positions corresponding to how many positions was  shifted in their definition, and convert that number to decimal representation
p51247
aVFor example,
p51248
aVhas ones in positions  (era),  (year),  (month) and  (day), and zeros in all remaining positions; positions are numbered from zero starting on the right
p51249
aVIt looks like this:
p51250
aVThis  in binary representation is  in decimal representation
p51251
as(dp51252
g6
V335858
p51253
stp51254
a((dp51255
g2
(lp51256
VFind a position  of the first space in the string
p51257
aVIf there is no space, or if the space is the last character of the string, then return the entire string; otherwise, return substring in the range from zero to , inclusive:
p51258
as(dp51259
g6
V335858
p51260
stp51261
a((dp51262
g2
(lp51263
VYou can speed up the search by employing the Knuth\u2013Morris\u2013Pratt (KMP) algorithm
p51264
aVGo through every dictionary word, and build a search table for it
p51265
aVYou need to do it only once
p51266
aVNow your search for individual words will proceed at faster pace, because the "false starts" will be eliminated
p51267
as(dp51268
g6
V335858
p51269
stp51270
a((dp51271
g2
(lp51272
VThis means a call of another constructor of the  that takes an array of  objects, passing in an array containing the object passed into this constructor
p51273
aVIt makes the call
p51274
aVequivalent to this:
p51275
as(dp51276
g6
V335858
p51277
stp51278
a((dp51279
g2
(lp51280
VOne common reason to employ a sorting algorithm outside of the database is to provide sorting facilities controlled by end-users of your system in the presentation layer
p51281
aVIn situations like that it would be too costly to go back to the database and fetch the information that you already have simply for the sake of having it sorted differently
p51282
aVHowever, it is highly unusual to implement sorting yourself: all popular and most not-so-popular programming environments supply built-in sorting facilities, recognizing their widespread use
p51283
as(dp51284
g6
V335858
p51285
stp51286
a((dp51287
g2
(lp51288
VYou will get this error every time that  is odd, because the number of times the loop sees  is greater than the number of times it sees
p51289
aVNote that your loop will try inserting identical keys and values, because  when  is odd refers to the preceding  that has an even index
p51290
aVHere is how you can fix it:
p51291
as(dp51292
g6
V335858
p51293
stp51294
a((dp51295
g2
(lp51296
VAlthough it is true that  keeps its elements in separately allocated memory locations connected with each other as a linked list, a small area of memory is needed for the header structure of the list itself
p51297
aVIt is this structure that gets allocated when you create an instance of
p51298
aVA vector of  consists of these "header" items for the individual linked lists, allocated in a contiguous region of memory:
p51299
as(dp51300
g6
V335858
p51301
stp51302
a((dp51303
g2
(lp51304
VThe difference between the two is whether you are inside a generic method or you are outside of it
p51305
aVYou got it absolutely right that inside the method  is not known to be an , so operator minus  cannot be applied
p51306
aVHowever, when you are in , outside the generic method, the compiler knows that you've instantiated  with , so it knows very well how to apply the operator
p51307
aVEven though the implementation of the generic has erased the type to produce the code for , the compiler does not think of  and  in terms of : it has enough knowledge to insert an appropriate cast, unbox the results, and apply the minus  operator
p51308
as(dp51309
g6
V335858
p51310
stp51311
a((dp51312
g2
(lp51313
VDesigning an API like that is not a good idea, because it is extremely error-prone
p51314
aVA seemingly similar idea worked fine with output streams for a simple reason: the data that you put into the stream for output is treated uniformly
p51315
aVAnything that you put into  as an argument becomes part of the output, apart from stream manipulators, which control how the output is to be presented
p51316
aVYour API is different: odd items are treated differently from the even ones
p51317
aVMoreover, it is a mistake to send an odd total number of operands
p51318
aVIf for some reason you forget to put a string code on one of the lines, all values would silently become codes on the subsequent lines
p51319
aVSuch API is very fragile, so I would strongly recommend agains it
p51320
aVI think an API that lets your users add items in pairs would work better
p51321
aVIf your compiler is C++11 compliant, you could also use uniform initialization syntax:
p51322
as(dp51323
g6
V335858
p51324
stp51325
a((dp51326
g2
(lp51327
VThe  method is definitely not the right place: it is there for controlling the layout, not to hook up event handlers - not to mention a possibility of hooking up the same handler multiple times
p51328
aVThe right place to add events to standard cells is the  method
p51329
aVFor custom cells drawn using Interface Builder you should be able to connect the events visually
p51330
as(dp51331
g6
V335858
p51332
stp51333
a((dp51334
g2
(lp51335
VIn C there are two separate operators that look somewhat similar - an assignment statement which uses a single equal sign, and an equality comparison, which uses two equal signs
p51336
aVThe two should not be confused (although very often they are)
p51337
aVis a comparison with zero, not an assignment of zero
p51338
aVIt is a valid expression, though, so the compiler does not complain:  loop allows any kind of expression to be in its header, as long as the expression is formed correctly
p51339
aVHowever, your code would not work, because it has undefined behavior:  remains uninitialized throughout the loop, making your program invalid
p51340
as(dp51341
g6
V335858
p51342
stp51343
a((dp51344
g2
(lp51345
VYou can try getting a little better performance by not "paying" for what your program does not use: rather than using a tree structure, which keeps all elements sorted, you can use a heap which does not sort elements, but lets you extract  largest elements in  time
p51346
aVHeaps tend to be faster than balanced trees on insertions and deletions, and they also occupy contiguous regions of memory, which may improve "cache friendliness" in some cases
p51347
aVOf course the speed-up is not free: heaps do not support fast sorting or removal of items other than the ones at the top
p51348
as(dp51349
g6
V335858
p51350
stp51351
a((dp51352
g2
(lp51353
VHasher needs to be updated as well, because the default hash algorithm does not produce identical hash code for strings that differ only in the case of their symbols - an essential property of hash code function intended to work with case-insensitive strings
p51354
aVThis shows different values on ideone:
p51355
as(dp51356
g6
V335858
p51357
stp51358
a((dp51359
g2
(lp51360
VYou can use the  method, or use  in unmanaged code:
p51361
aVThis prints  on ideone
p51362
aVHere is a link to Eric Lippert's blog describing the difference between the two sizeof options
p51363
as(dp51364
g6
V335858
p51365
stp51366
a((dp51367
g2
(lp51368
VStarting with iOS 5
p51369
aV0 it is no longer sufficient to provide a  or a zero-pixel view for the header in the section that you would like to hide: you need to override the  method in your  as well, and return zero height for section zero:
p51370
as(dp51371
g6
V335858
p51372
stp51373
a((dp51374
g2
(lp51375
VThe reason your code appears to skip every other line is that  returns all characters, including end-of-line markers
p51376
aVTo address this, write your own function that wraps , and skip all  and  characters there:
p51377
aVPut  or its prototype before , and replace all calls of  with calls of  to fix the immediate issue
p51378
aVHowever, a larger issue with code duplication will remain: your code repeats itself, which is never a good idea
p51379
aVConsider switching the  loop in favor of /, the same kind I used in  to achieve the effect that you try to achieve by placing another copy of the code before the loop
p51380
aVFinally, there is no point of iterating through all letters to see if  is one of them: you can replace that entire loop with a single :
p51381
as(dp51382
g6
V335858
p51383
stp51384
a((dp51385
g2
(lp51386
VLeaving the standard warnings about SQL injections attacks aside for a moment, the problem with your statement is that you put your quotes incorrectly and don't have spaces before your s:
p51387
aVTo prevent injection attacks you should parameterize your query, and bind values to parameters of a prepared statement:
p51388
as(dp51389
g6
V335858
p51390
stp51391
a((dp51392
g2
(lp51393
VIn general, it is a bad idea to design an API where the caller must routinely "skip a level"
p51394
aVYour example requires the user of your API to know about the inner structure of the credentials - specifically, that credentials feature a user name
p51395
aVThis is an indication of tight coupling - a thing that your API design should strive to avoid
p51396
aVA way around this would be exposing methods that skip that level of indirection for the user of your API, for example, like this:
p51397
aVNow the user of your API can deal only with your API, not with the API of the  object
p51398
aVThe fact that  may not be set is hidden behind the method
p51399
aVYou can even guard against attempts at writing the user name by exposing a read-only version of credentials through your API, while employing a read-write version under the covers
p51400
as(dp51401
g6
V335858
p51402
stp51403
a((dp51404
g2
(lp51405
VThe worst-case number of inversions in an array of size  is
p51406
aVThe highest value that fits in an int is roughly 2 billion, so arrays of size greater than  run a chance of overflowing an , making the result look negative
p51407
aVYou should switch to  to extend the range of values representable by the counter:
p51408
as(dp51409
g6
V335858
p51410
stp51411
a((dp51412
g2
(lp51413
VYou have several good choices for that:
p51414
aVThe simplest solution would be grouping the related files in subfolders: rather than having  file, you could have an  sub-folder, and reference the files out of it
p51415
aVYou would not need to use any additional libraries for this, and you would be able to use the same name for all your image files and all your level files, because they would be in separate folders
p51416
aVYou can make a zip archive with the files that you would like to combine, and unzip it before use
p51417
aVHere is a link to an answer referencing a library to do it
p51418
aVYou can use a  format - here is a list to an answer referencing a library that supports it
p51419
aVYou would be able to use  utility on OS-X to group images with plists on your workstation
p51420
aVFinally, you can define a format of your own: store the length of the first file in the first four bytes, then store the content of the first file, and then the second
p51421
aVYou would need to write a utility for combining the two files into one
p51422
aVThis sounds like the hardest choice to implement
p51423
as(dp51424
g6
V335858
p51425
stp51426
a((dp51427
g2
(lp51428
VIn general, you should not retain your delegates: this lets you avoid retain cycles - situations when two or more objects retain each other in a cycle, preventing the whole group from being deallocated
p51429
aVThis looks to be a pre-ARC code, so you should simply avoid retaining and releasing your delegate
p51430
aVIn ARC code you should declare your delegates  unless you have specific reasons to use strong references (specifically, you retain your delegate when you want to own the delegating object; this is very rare - in fact, it's usually the other way around)
p51431
aVHere is a good discussion of the topic on why delegates are not usually retained
p51432
as(dp51433
g6
V335858
p51434
stp51435
a((dp51436
g2
(lp51437
VHowever, i can store 11 bytes in unsigned char array[10]
p51438
aVNo, you cannot: 10 is not a valid index of
p51439
aVArrays are indexed from zero to size minus one
p51440
aVAccording to C99 Standard
p51441
ag837
ag10442
ag14884
ag14885
aV3 When [ operator is] applied to an operand that has type , , or , (or a qualified version thereof) the result is 1
p51442
aVThat is why the result is going to be ten on all standard-compliant platform
p51443
as(dp51444
g6
V335858
p51445
stp51446
a((dp51447
g2
(lp51448
VYou are right, this is not a good idea to throw  in a situation like that
p51449
aVNormally, you implement an interface is to provide a common set of operations that "unifies" a group of dissimilar classes providing different implementations for a set of common operations
p51450
aVHowever, in your case the dissimilar classes fail to "unify": they retain not only their own implementations, but also their own interfaces
p51451
aVWhen you try using them uniformly, the code throws an exception
p51452
aVThe common interface does not give you all that much compared to keeping them as  - users must know what class is behind the  before making the call, otherwise they risk seeing a
p51453
aVThere are several ways around this problem: one way would be unifying the singular and the plural methods, returning a more complex answer than a simple :
p51454
aVNow the singular implementation will return  with the  value in the , while the plural implementation would return  with one of several plural categories
p51455
aVTrying to set a plural category on a singular subclass of  may still be an error, but you can fix that by moving the setter onto the class, making it impossible to call a setter with a category on a singular subclass of
p51456
as(dp51457
g6
V335858
p51458
stp51459
a((dp51460
g2
(lp51461
VI am not sure it has value equality defined
p51462
aVYou are correct, it does not have value equality defined
p51463
aVOne way to compare  objects for equality is using LINQ:
p51464
aVCasts to  are the most "forgiving" - they would not trigger a cast exception in your tests
p51465
aVIf you know that both arrays contain values of type , you can replace the type in the  to
p51466
as(dp51467
g6
V335858
p51468
stp51469
a((dp51470
g2
(lp51471
VSince regular expression matches must be contiguous (i
p51472
ag630
aVhave no gaps) there is no single expression to match all text outside the tags
p51473
aVHowever, you can still do it if you combine regex with C#'s  facilities, like this:
p51474
aVIf the inside of the tag may not contain percentage characters, you can optimize your regex to avoid backtracking by using this expression instead:
p51475
as(dp51476
g6
V335858
p51477
stp51478
a((dp51479
g2
(lp51480
VThere are many ways of doing it
p51481
aVOne would be as follows:
p51482
aVAt max [my list of strings] can grow to 50 strings which is a rare possibility
p51483
aVThen you should make  a  in your class, like this:
p51484
aVDoing so would ensure that the set is created only once, and is not re-created each time the execution goes through the method that uses it
p51485
as(dp51486
g6
V335858
p51487
stp51488
a((dp51489
g2
(lp51490
VThe logic behind this method is as follows:
p51491
aVThe successor of a  node does not exist
p51492
aVThe successor of any node with a right subtree is the leftmost leaf node of its right subtree (i
p51493
ag630
aV"go right, then walk down and to the left as far as you can; that would be the successor)
p51494
aVThe successor of any node without a right subtree is its first ancestor node of which the current node is located in a left subtree
p51495
aVThis logic is expressed in the three branches of the conditional chain: the first  deals with , the second walks the left subtree of the right branch, and its  walks up the tree structure in search of ancestor such that the current subtree was on its left
p51496
aVHere is how the search may look when the algorithm needs to find a successor, and the right subtree exists: the current node is shown in red, its successor is shown in green
p51497
aVThe algorithm goes one step right, and then proceeds all the way to the left
p51498
aVHere is how the search may look when the algorithm needs to find a successor, but there is no right subtree: the current node is shown in red, its successor is shown in green
p51499
aVThe algorithm goes up, checking if we came from a left subtree
p51500
aVFor the parent of the current node the answer is "no", because the current node is in the right subtree
p51501
aVFor the parent of the parent the answer is "yes", so it is returned as the current node's successor
p51502
as(dp51503
g6
V335858
p51504
stp51505
a((dp51506
g2
(lp51507
VI would not use a  here - a class should do just fine
p51508
aVThere are pre-built data types that you could use for tagging:
p51509
aV, the type used in dictionary iterators, lets you pair a value with a key without defining a new type
p51510
aVStarting with
p51511
aVNET 4
p51512
aV0 you can use  for pairing items of arbitrary types
p51513
aVI would suggest defining an  instead of using  for the type: this should give your program better readability
p51514
as(dp51515
g6
V335858
p51516
stp51517
a((dp51518
g2
(lp51519
VYou can capture the character immediately following the second number in a , and check that the captured character is , like this:
p51520
aVHere is a demo on ideone
p51521
as(dp51522
g6
V335858
p51523
stp51524
a((dp51525
g2
(lp51526
VRank represents the depth of the tree, not the number of nodes in it
p51527
aVWhen you join a tree with a smaller rank with a tree with a larger rank, the overall rank remains the same
p51528
aVConsider adding a tree with rank 4 to the root of the tree of rank 6: since we added a node above the root of the depth-4 tree, that subtree now has a rank of 5
p51529
aVThe subtree to which we've added our depth-4 tree, however, is 6, so the rank does not change
p51530
aVNow consider adding a tree with rank 6 to the root of a second tree of rank 6: since the root of the first depth-6 tree now has an extra node above it, the rank of that subtree (and the tree overall) changes to 7
p51531
aVSince the rank of the tree determines the processing speed, the algorithm tries to keep the rank as low as possible by always attaching a shorter tree to the taller one, keeping the overall rank unchanged
p51532
aVThe rank changes only when the trees have identical ranks, in which case one of them gets attached to the root of the other, bumping up the rank by one
p51533
as(dp51534
g6
V335858
p51535
stp51536
a((dp51537
g2
(lp51538
VHowever, this for loop is only erasing one of them, completely ignoring the other
p51539
aVThis is because you are going front to back
p51540
aVWhen your code erases an item at, say, index 6, the item that was previously at index 7 is at the index 6 now
p51541
aVHowever, the loop is going to skip index 6 after , thinking that it has already processed it
p51542
aVIf you go back-to-front, the problem will be fixed:
p51543
as(dp51544
g6
V335858
p51545
stp51546
a((dp51547
g2
(lp51548
VEach permutation has six segment-to-segment checks, so that's a total of 18 comparisons
p51549
aVYou do not need to check all the segments: it would be sufficient to check that segments  and  (i
p51550
ag630
aVthe two diagonals) intersect
p51551
aVYou need to check that the segments intersect, not the lines to which the segments belong, i
p51552
ag630
aVan intersection outside of the segments does not count
p51553
aVOnce you fix the starting point , you end up with six possible permutations:
p51554
aVTwo of them ( and ) are good; the remaining four are bad
p51555
aVYou can arrive at a good one with only two checks:
p51556
aVCheck the initial permutation; if it is good, keep it; otherwise
p51557
aVSwap points 1 and 2, and check the permutation; if it is good, keep it; otherwise
p51558
aVRevert to the original permutation, swap points 2 and 3, and keep that permutation; it is bound to be "good"
p51559
as(dp51560
g6
V335858
p51561
stp51562
a((dp51563
g2
(lp51564
VYour duplicate checking loop has a flaw: the  is set to the result of checking the last pair of values, rather than the result of checking all the preceding pairs
p51565
aVYou need to set  before the inner loop, then proceed to verifying all items from zero to
p51566
aVIf the check becomes  at any point, stop the loop:
p51567
aVIn addition, you need to fix the , because your current implementation returns values in range :
p51568
as(dp51569
g6
V335858
p51570
stp51571
a((dp51572
g2
(lp51573
VAlthough you need a temporary variable for that, you can hide it by defining an extension method:
p51574
aVNote that the temporary is still there - it's the first argument of the  method
p51575
aVNow you can simplify your code as follows:
p51576
as(dp51577
g6
V335858
p51578
stp51579
a((dp51580
g2
(lp51581
VYou need to  the bytes, because  does not take ownership of it: it cannot know if the array is a temporary or a dynamic, so it makes a copy of it
p51582
aVTo fix this problem, replace
p51583
aVwith
p51584
as(dp51585
g6
V335858
p51586
stp51587
a((dp51588
g2
(lp51589
VSince you've got a  table, it appears that your product may belong to multiple categories
p51590
aVIn cases like that, you want to check if a category that you are looking for is among the categories assigned to your product
p51591
aVOne way of doing it is with an  condition:
p51592
aVI assumed that the  many-to-many table has columns  and  which bring together the IDs of the product and a category to which that product belongs
p51593
as(dp51594
g6
V335858
p51595
stp51596
a((dp51597
g2
(lp51598
VThe output looks correct, because collation order produced by the particular instance of  considers the case of the letter only for tie-breaking
p51599
aVis after  alphabetically, so the return value should be
p51600
aVis before  alphabetically, so the return value should be
p51601
aVis before  alphabetically, so the return value should be
p51602
aVis before  alphabetically, so the return value should be
p51603
aVis the same as  alphabetically, but starts in a capital letter, so the return value should be
p51604
aVis before  alphabetically, so the return value should be
p51605
aVYou can lower collator's strength to make strings that differ only in case evaluate as identical
p51606
as(dp51607
g6
V335858
p51608
stp51609
a((dp51610
g2
(lp51611
VYour fields line up incorrectly:  looks like a credit rating, not like a CUSIP (CUSIPs are nine characters long)
p51612
aVIt looks like you skipped a value, or added a field somewhere in the middle, or both:
p51613
aVTo fix this issue, make sure that your column names "line up" with the values that you are inserting into them
p51614
as(dp51615
g6
V335858
p51616
stp51617
a((dp51618
g2
(lp51619
VThere are three problems with your code:
p51620
aVYou are writing a string into a block of memory allocated for a single character; this is undefined behavior
p51621
aVYou are printing a string from a block of memory allocated for a single character - also an undefined behavior
p51622
aVYou are using  to read a string with spaces;  stops at the first space or end-of-line character
p51623
aVOne way to fix this would be using , like this:
p51624
as(dp51625
g6
V335858
p51626
stp51627
a((dp51628
g2
(lp51629
VYou misunderstood the meaning of : it lets you define a character such that when you put it in front of another character, that other character is interpreted literally, not as a meta-character
p51630
aVYou need only one such escape character: you can use it to escape any meta-character
p51631
aVIn the example below I used  as my escape character:
p51632
aVThis tries to match  strings where both  and  are interpreted literally, not as a sequence of any characters or any single character
p51633
as(dp51634
g6
V335858
p51635
stp51636
a((dp51637
g2
(lp51638
VYou can convert this to dictionary using the  method and LINQ:
p51639
aVConverting back is even easier:
p51640
as(dp51641
g6
V335858
p51642
stp51643
a((dp51644
g2
(lp51645
VUnfortunately, there is no built-in way of doing this with the standard C++
p51646
aVYou can construct a system of classes to help you build a stack tracer utility, but you would need to put a special macro in each of the methods that you would like to trace
p51647
aVI've seen it done (and even implemented parts of it) using the strategy outlined below:
p51648
aVDefine your own class that stores the information about a stack frame
p51649
aVAt the minimum, each node should contain the name of the function being called, file name / line number info being close second
p51650
aVStack frame nodes are stored in a linked list, which is reused if it exists, or created if it does not exist
p51651
aVA stack frame is created and added to the list by instantiating a special object
p51652
aVObject's constructor adds the frame node to the list; object's destructor deletes the node from the list
p51653
aVThe same constructor/destructor pair are responsible for creating the list of frames in thread local storage, and deleting the list that it creates
p51654
aVThe construction of the special object is handled by a macro
p51655
aVThe macro uses special preprocessor tokens to pass function identification and location information to the frame creator object
p51656
aVHere is a rather skeletal proof-of-concept implementation of this approach:
p51657
aVThe above code compiles with C++11 and prints this:
p51658
aVFunctions that do not have that macro would be invisible on the stack
p51659
aVPerformance-critical functions should not have such macros
p51660
aVHere is a demo on ideone
p51661
as(dp51662
g6
V335858
p51663
stp51664
a((dp51665
g2
(lp51666
VConsidering C's pointer a rough equivalent to Java's reference, a rough equivalent to a pointer to pointer would be a mutable class encapsulating a reference
p51667
aVFor example, you can build something like this:
p51668
aVYou can pass  to a function that can get or set it using its get and set methods, much in the same way as C program uses single dereference to get to the actual pointer (double dereference would happen automatically when your code accesses , because it is already a reference object)
p51669
aVKeep in mind that this is a very rough equivalent, not a one-for-one substitution: for example, there is no way to pass back an array of  objects using a
p51670
as(dp51671
g6
V335858
p51672
stp51673
a((dp51674
g2
(lp51675
VConsider how the  string is stored in memory: let's say the address of its  character happens to be
p51676
aVThen the rest of the string would be stored as follows:
p51677
aVNow consider a series of invocations of : the initial invocation passes ; the call of  from inside the reverse passes , so the next level gets ; the next one gets , and so on
p51678
aVNote that each level calls the next level, until the level that sees
p51679
aVBefore we get to zero, the stack is "loaded" like this:
p51680
aVNow when the top invocation calls , the check for  fails, and the function returns right away without printing anything
p51681
aVAt this point the stack starts "unwinding", printing whatever is pointed to by its  argument:
p51682
aVThat's how the reverse of the original  string gets printed
p51683
as(dp51684
g6
V335858
p51685
stp51686
a((dp51687
g2
(lp51688
VYou should either use  or the indexer:
p51689
as(dp51690
g6
V335858
p51691
stp51692
a((dp51693
g2
(lp51694
VThis is not an abuse at all - that is a common scope-handling idiom of C#
p51695
aVFor example, ADO
p51696
aVNET objects (connections, statements, query results) are commonly enclosed in  blocks, even though some of these objects get released back to their pools inside their  methods:
p51697
as(dp51698
g6
V335858
p51699
stp51700
a((dp51701
g2
(lp51702
VThere are two problems in your code: you need to use  to compare Java strings, and you need to repeatedly use the comparison to construct an  expression:
p51703
aVBetter yet, construct a  of the cities that you wish to match, and use  method to check the condition:
p51704
aVHere is a demo of this later approach on ideone
p51705
as(dp51706
g6
V335858
p51707
stp51708
a((dp51709
g2
(lp51710
VSince one button is larger than the other, I assume that you would like the smaller button to "bring down" the larger button with it, including the change in the visual state
p51711
aVIn cases like that you could send your target button a "tap" programmatically, like this:
p51712
as(dp51713
g6
V335858
p51714
stp51715
a((dp51716
g2
(lp51717
VYou are on the right track:
p51718
aVRather than returning , you should create an array of pairs, and populate it in the loop
p51719
aVYou know the length of the result, because you have the length of the source
p51720
aVTo look at an individual word, use
p51721
aVTo chop off the initial letter of the word use
p51722
aVTo get the length of the word use
p51723
aVThe  class needs two data members - a  and an ; they should be set in the constructor
p51724
aVThe data members should have getters -  and  returning their respective members
p51725
aVPrinting should be done in the , in a loop that walks the returned array of pairs
p51726
aVYou should be able to complete the rest
p51727
as(dp51728
g6
V335858
p51729
stp51730
a((dp51731
g2
(lp51732
VNo, this is not a valid implementation of a proxy pattern, because the crucial feature of that pattern implementation is missing: the proxy of an object needs to pretend it's the thing that it is proxying, either by providing the same interface, or by providing implicit conversions to the proxied object
p51733
aVIf  implemented  interface, it would be a proxy for
p51734
aVSimilarly, if  let you obtain a special subclass of  that lets you read the data but not write it, that special class would be a proxy for the
p51735
aVNET uses the proxy pattern in several notable places, such as managing list access through , or the  wrappers of  and
p51736
as(dp51737
g6
V335858
p51738
stp51739
a((dp51740
g2
(lp51741
VThe answer depends on the exact structure of the destination table and its indexes, and on the  nature of the processes that access the  concurrently with your insertion
p51742
aVhas no indexes;  is likely to have several indexes
p51743
aVDepending on the amount of data being inserted and the number of individual inserts, copying from temp is likely to be faster, because a single multi-row check of each index needs to be performed
p51744
aVis invisible to outsiders;  is likely to be accessed concurrently with your program
p51745
aVIn cases like that, the amount of locking and unlocking would be smaller
p51746
aVInserting all rows at once offers a better chance to parallelize the insertion for possibly an even faster insert
p51747
aVNone of that would matter much if  is small (a few thousand rows)
p51748
aVFor larger tables the impact will be more significant, so I would recommend keeping the temp table approach when  is expected to get large
p51749
as(dp51750
g6
V335858
p51751
stp51752
a((dp51753
g2
(lp51754
VPassing a pointer to a single  to  in a position corresponding to  is always an undefined behavior, because  writes at least two characters for a string (at least one character for string's body, and a null terminator)
p51755
aVMoreover, passing a pointer to a single  to  in the position that corresponds to  is undefined behavior, unless that char is set to  (which isn't the case in your program)
p51756
aVTherefore, whatever printout you have is heavily compiler-dependent
p51757
aVThe same program can crash on another computer, or produce an entirely different output
p51758
aVIn case of your particular compiler it appears that  is located in memory one character after , so it prints the content of  starting with the second character
p51759
aVTo fix this, allocate arrays of at least four characters to your string variables (enough to fit three-character variables) and use the size specifier to limit the input:
p51760
as(dp51761
g6
V335858
p51762
stp51763
a((dp51764
g2
(lp51765
VYour code will not find  because it is discarded from the input sequence
p51766
aVFrom the documentation of :
p51767
aVThe delimiting character is the newline character [
p51768
aV: when found in the input sequence, it is extracted from the input sequence, but discarded and not written to s
p51769
aVYou should be searching for :
p51770
as(dp51771
g6
V335858
p51772
stp51773
a((dp51774
g2
(lp51775
VThe problem is likely to do with the way the output stream produces the output for s: if  gets printed in "scientific notation", it would look like
p51776
aVExcel will read this notation just fine, but would put zeros for the digits it does not "see", making the number look like
p51777
aVTo fix this problem, add  manipulator when you output your  to ensure that all digits get printed:
p51778
as(dp51779
g6
V335858
p51780
stp51781
a((dp51782
g2
(lp51783
VYour code incorrectly believes that some full squares of primes are prime as well
p51784
aVIn particular, your  returns
p51785
aVThis should be enough to figure out a fix (ok, one more hint: all you need is adding a single character)
p51786
as(dp51787
g6
V335858
p51788
stp51789
a((dp51790
g2
(lp51791
VSQL's equivalent of  in C is
p51792
aVHowever, in your case you want something else: you need to build a condition that decides between the two choices based on the value of , like this:
p51793
as(dp51794
g6
V335858
p51795
stp51796
a((dp51797
g2
(lp51798
VYou can do it like this:
p51799
aVThe idea is to produce all possible pairs of actors and directors (the cartesian product join in the middle of the query), then filter its results to exclude pairs connected through a movie (the  condition)
p51800
aVHere is a demo on sqlfiddle
p51801
as(dp51802
g6
V335858
p51803
stp51804
a((dp51805
g2
(lp51806
VThe problem is that each of your threads has its own lock
p51807
aVMaking  static should fix the problem: there will be only one object to lock on
p51808
aVYou should also stop re-assigning it in your code
p51809
aVHere is a working demo on ideone
p51810
as(dp51811
g6
V335858
p51812
stp51813
a((dp51814
g2
(lp51815
VTheoretically, declaring a parameter  is not going to make a difference: the compiler is allowed to be smart enough to figure out that your method does not change the  parameter, and optimize the code that it generates as if the parameter were declared  without the actual declaration
p51816
aVThe biggest difference that you are going to get by declaring method parameter  is the ability to reference that parameter in anonymous classes
p51817
aVAnother useful consequence is that people who maintain your code after you would know that keeping that parameter unchanged was your conscious decision, not a coincidence
p51818
as(dp51819
g6
V335858
p51820
stp51821
a((dp51822
g2
(lp51823
VCan anyone list out the other methods how 2D referencing can be done effectively
p51824
aVThe simplest thing is to replace an exercise in pointer arithmetic  with the more conventional :
p51825
aVDemo of this change on ideone produces identical output with your original program (here)
p51826
aVAnd how does the comma separated statements work in the second while loop
p51827
aVComma is a standard C operator; it acts as a sequence point
p51828
aVTo allow for passing arrays of variable size int , you can change the structure of the array for an array of pointers, like this:
p51829
aVOne consequence of this choice is that the row-sizing macro would no longer work (see a demo here); array-sizing macro (i
p51830
ag630
aVthe one determining the number of rows) would continue working, though
p51831
aVAnother consequence is that you would not longer be able to declare more items than you put in the initializer, because the rest would be set to  pointers, breaking the printing loop
p51832
as(dp51833
g6
V335858
p51834
stp51835
a((dp51836
g2
(lp51837
VThe number  is octal number representing the binary pattern below:
p51838
aVWhen you  it using the bitwise operation , the result keeps the bits of the original only in the bits that are set to  in the "mask"; all other bits become zero
p51839
aVThis is because "AND" follows this rule:
p51840
aVFor example, if you   and , you get
p51841
as(dp51842
g6
V335858
p51843
stp51844
a((dp51845
g2
(lp51846
VAlthough the name of a getter must start with  according to the JavaBeans conventions, not all names that start in  must represent "dumb" getters, i
p51847
ag630
aVones backed by a simple variable
p51848
aVIf a method gets something, even a calculated thing that is associated with your object, giving it a name that starts in  is entirely appropriate
p51849
aVHere is an example of a "get" method that does not represent a variable-backed property:
p51850
as(dp51851
g6
V335858
p51852
stp51853
a((dp51854
g2
(lp51855
VThis is because your code never enters the  branch: it is an assignment, not a comparison
p51856
aVYou can add an extra  to make it a comparison (i
p51857
ag630
aVmake it ) but the idiomatic way of checking the opposite of a condition is with the unary operator
p51858
aVChange the condition as follows to make it work:
p51859
aVIn addition, you forgot to close or flush your
p51860
aVYou can unify both branches by using the ternary operator, like this:
p51861
as(dp51862
g6
V335858
p51863
stp51864
a((dp51865
g2
(lp51866
VAny SQL statement with unsanitized user input is vulnerable for the same reason: the user can input a string that would terminate your SQL early, and replace it with a SQL of its own
p51867
aVFor example, entering something like  will drop your user table: the resultant SQL would look like this:
p51868
as(dp51869
g6
V335858
p51870
stp51871
a((dp51872
g2
(lp51873
VOr might there be a better way to approach this problem altogether
p51874
aVSure, there is one: you can make each converter into a lambda, make a dictionary of them, and use them for the conversion, like this:
p51875
as(dp51876
g6
V335858
p51877
stp51878
a((dp51879
g2
(lp51880
VThe code below
p51881
aVcompiles because according to C# standard
p51882
aV13
p51883
ag1340
aV7 A constant-expression (14
p51884
aV16) of type  can be converted to type , , , , , or , provided the value of the constant-expression is within the range of the destination type
p51885
aVThere is no implicit conversion like that defined for conditional expressions, so your first code snippet needs either an explicit cast or a  suffix:
p51886
aVNote that only one conversion/suffix is necessary, because zero can be converted to  based on the rule 13
p51887
ag1340
aV7 above
p51888
as(dp51889
g6
V335858
p51890
stp51891
a((dp51892
g2
(lp51893
VOne general note on the strong vs
p51894
aVweak reference: strong references denote ownership, while  weak references denote association
p51895
aVWhen neither object owns the other, there's usually other objects that own them, or they both have strong references coming from local variables
p51896
aVWouldn't [the  class] lead to a retain cycle
p51897
aVYes, it would, because a  owns his brother, but he shouldn't: this should be a weak property
p51898
aVIt should be OK, because there should be another object (a list of all persons, a dictionary organizing persons by name, or something like it) that owns all of the  objects
p51899
aVAs long as a  object is in that collection of persons, it's not going to be released
p51900
aVWouldn't [ and ] lead to a retain cycle since all the references are strong
p51901
aVCorrect, that is what is going to happen
p51902
aVretains objects that go into it, closing the loop on the retain cycle
p51903
aVNote that you cannot make  weak to break that cycle: it needs to be  that gets weak, not
p51904
aVFinally, consider this scenario: Let's say I change 's  property to
p51905
aVThis may solve the issue for my second (above scenario), but what if I am creating a new appointment and I want to attach a staff member, then pass the object somewhere else for processing
p51906
aVThere's no problem with that: stack variable  has a strong reference on it, so it wouldn't get released
p51907
aVBecause my  property on Appointment is now weak, is there the potential for it to be set to nil when garbage collection runs (as there are no strong references to the staff object)
p51908
aVARC is not a garbage collection system: retains and releases happen at specific, deterministic time points
p51909
aVThe  is not going to be released, because  is strong by default
p51910
aVEDIT : The edited example will indeed release the  object
p51911
aVHowever, such example is unusual, because it is unlikely that your  would make a new instance of
p51912
aVRather, it would grab an existing instance from some registry containing all members of staff, like this:
p51913
aVis a class that manages (and owns) all  objects, keeping them in an array, a dictionary, or some other collection
p51914
aVAll other references to  objects (apart from temporary references by stack variables) should be weak
p51915
aVThis way removing a member from the registry will also release him from all the appointment objects in which he may participate
p51916
aVMy co-workers seem to have handled it by using two properties, one strong and the other weak
p51917
aVIf you are thinking it's a hack, you are 100% right
p51918
aVThe strong vs
p51919
aVweak issue gets straightforward once you make a decision on who knows what; you don't need to come up with code that promises some serious maintenance nightmare to address it
p51920
as(dp51921
g6
V335858
p51922
stp51923
a((dp51924
g2
(lp51925
VThe meaning of  cannot be inferred with certainty from this small code snippet
p51926
aVStructurally, this is a case of class composition, which can be used to make wrappers, decorators, adapters, proxies/surrogates, and so on, depending on the purpose of the class
p51927
aVIf  inherited , it would be a decorator or a wrapper
p51928
aVIf  contained an implicit conversion operator to , it would be a surrogate or a proxy
p51929
aVIf  used  to implement behavior of some other contract, it would be an adapter
p51930
aVNote, however, that all these concepts are higher level than the "construction primitives" of the language, such as inheritance and composition, so you need a wider usage context of  and  among other classes of your system to decide which one it is
p51931
as(dp51932
g6
V335858
p51933
stp51934
a((dp51935
g2
(lp51936
VYou can use  to subtract sets:
p51937
aVHowever, this may not be what you are looking to get, because objects that have "changed" will be treated as simply "not equal" to each other
p51938
aVIt appears that your objects have an  field
p51939
aVYou can order the objects on that , and then traverse both collections as if you were producing a merge
p51940
aVThis would let you detect insertions, updates, and deletions with a straightforward chain of s
p51941
aVYou can also use IDs to decide what's common and what's changed:
p51942
as(dp51943
g6
V335858
p51944
stp51945
a((dp51946
g2
(lp51947
VYou need a streaming JSON parser for that, i
p51948
ag630
aVa parser that produces events to which you listen as it goes through the JSON input, as opposed to document-based parsers, such as  of iOS 5+
p51949
aVOne of such parsers is YAJL: although it is a C library, you can use it from Objective C as well: all you need to do is defining a , put pointers to the handlers for the type of the item that you wish to extract, call the parser, and let the parser do the rest
p51950
as(dp51951
g6
V335858
p51952
stp51953
a((dp51954
g2
(lp51955
VThe reason you are getting this error is that the query is executed in memory, not in RDBMS
p51956
aVThe  function is a marker that Entity Framework provider converts to RDBMS-specific SQL to send to your RDBMS
p51957
aVThe function does not compute its result when applied to an  in memory, throwing an exception instead
p51958
aVIf you want to run this query in memory, replace
p51959
aVwith
p51960
aVSubtraction of two dates produces a  value from which you can take its  property
p51961
as(dp51962
g6
V335858
p51963
stp51964
a((dp51965
g2
(lp51966
VOther than the code readability, nothing changes: your compiler should figure out that the first assignment happens at some other place, and perform the assignment there
p51967
aVIn general, you should prefer combining initialization and assignment, except rare situations when the first assignment should happen in an inner scope to the one where the variable is declared, such as variables assigned inside / loops, and used after the loop's completion:
p51968
as(dp51969
g6
V335858
p51970
stp51971
a((dp51972
g2
(lp51973
VThis is because you forgot to put a semicolon after the forward declaration on the previous line:
p51974
aVNote that array size and parameter names are ignored in function declarations, so the declaration below would be equivalent:
p51975
as(dp51976
g6
V335858
p51977
stp51978
a((dp51979
g2
(lp51980
VAnonymous delegate implementations and lambdas of C# are the closest thing to anonymous interface implementations of Java, but the interface needs to have a single method
p51981
aVBoth your interfaces have a single method, so your code can be converted to C# as follows:
p51982
aVNote that calling the delegates is different, too: in Java you would call them like this:
p51983
aVIn C#, you do not have a method name (because delegates encapsulate a single method), so the same call would look like this:
p51984
as(dp51985
g6
V335858
p51986
stp51987
a((dp51988
g2
(lp51989
VYou should never modify the appearance of  outside the  method, precisely to avoid the issue that you are having
p51990
aVHowever, since you do not have access to the data source, you need to trick the runtime into somehow calling your method in place of the method of the data source
p51991
aVBut that's not all, because you must call that data source to get the cell in the first place
p51992
aVThis is where method swizzling comes in handy: Cocoa runtime lets you do this with a few lines of strategically placed code
p51993
aVFirst, write a new implementation for the  method
p51994
aVPut it in a separate category of , like this:
p51995
aVNext, add the runtime header to your implementation file:
p51996
aVFinally, replace your old method with this:
p51997
aVYou are done
p51998
as(dp51999
g6
V335858
p52000
stp52001
a((dp52002
g2
(lp52003
VYou are not redefining a variable, because your code has only one definition - the one in the CPP file
p52004
aVThe one in the header is a declaration, because it uses an  keyword
p52005
aVThe CPP file provides a definition to the variable declared in the header
p52006
as(dp52007
g6
V335858
p52008
stp52009
a((dp52010
g2
(lp52011
VThis is a range-based loop of C++: you specify a loop variable and a container, and the compiler produces code that iterates the container, and assigns the loop variable each item of the container in turn before executing loop's body
p52012
aVThis loop construct is not available prior to C++11
p52013
aVNote that there is a way to output a container without using loops at all:
p52014
as(dp52015
g6
V335858
p52016
stp52017
a((dp52018
g2
(lp52019
VInclude guards help you avoid including the same file more than once from the same translation unit
p52020
aVHowever, since the translation units are processed independently, both of them will get the included code, and therefore produce duplicate definitions
p52021
aVTo avoid this problem you need to move definitions out of the header and into a CPP file:
p52022
aVGameConfig
p52023
aVcpp:
p52024
as(dp52025
g6
V335858
p52026
stp52027
a((dp52028
g2
(lp52029
VIf you need to use the exception inside the  block, give  a name; otherwise, keep it anonymous
p52030
aVThere are situations when the  block needs to do more than simply show exception's message
p52031
aVFor example, when you catch application-specific exceptions, you may be able to examine additional elements of the exception object
p52032
aVHere is a hypothetical example:
p52033
aVThe above code assumes that the custom exception  has a property called  with the name of the server to which you tried to connect, and an enumeration property  with the names of available servers
p52034
aVThere are also situations when all you need to know is that an exception of a particular type just happened
p52035
aVIn this case, you do not need to provide a named variable for it
p52036
as(dp52037
g6
V335858
p52038
stp52039
a((dp52040
g2
(lp52041
VYou could also use  for the index - the same type as your vector:
p52042
aVReturning a copy is a good idea - in fact, it's the best thing to do if you want to hide the vector from your callers
p52043
aVReturning a pointer or a reference may be more performant, but it opens up your class to backdoor manipulations, in cases when  is mutable
p52044
aVIt also creates an issue if the vector is modified after a reference has been returned, because changing the vector invalidates references to its elements
p52045
aVYou can provide individual functions for manipulating attributes of , but you could also provide a setter that lets users replace an element of your vector
p52046
as(dp52047
g6
V335858
p52048
stp52049
a((dp52050
g2
(lp52051
VWhen you invert zero
p52052
aVyou get negative one
p52053
aVThe  method expects negative numbers to be represented with a minus prefix
p52054
aVWhen you pass 64 1-s to the method, it thinks it's an overflow, and returns an error
p52055
aVOne way to fix this is to check that the length is less than 64 before you parse the value
p52056
aVIf the length is exactly 64, chop off the first digit, and parse the rest of the number
p52057
aVThen check the initial digit
p52058
aVIf it is zero, leave the parsed number as is; otherwise, use binary  to set the most significant bit:
p52059
as(dp52060
g6
V335858
p52061
stp52062
a((dp52063
g2
(lp52064
VThe reason he adds  is that he simplified this expression:
p52065
aVHe observed that  is , and entered the simplified constant into his code
p52066
aVThis is not a very good idea, because it is hard to understand what is going on without looking at the ASCII table
p52067
aVBesides, the compiler simplifies the  expression to the same exact value anyway, so the readability is lost with no particular gains of any kind
p52068
as(dp52069
g6
V335858
p52070
stp52071
a((dp52072
g2
(lp52073
VThis is because the  saves the binary representation of the number, not a decimal one
p52074
aVYou can think of each byte representing a single digit in base-256
p52075
aVThat's why the space required for the representation is more than twice less than the number of decimal digits
p52076
aVIf you need to save each digit to a byte, convert your  to : its length is going to equal the number of digits (plus one character for the minus character  if the number is negative)
p52077
as(dp52078
g6
V335858
p52079
stp52080
a((dp52081
g2
(lp52082
VThis is a notation telling Java that the method or the constructor can take a variable number of parameters
p52083
aVIt can be used only after the last parameter type
p52084
aVThe parameters prior to  are required: callers must specify an expression for each one of them
p52085
aVThe rest of the parameters are, however, optional: callers can specify zero, one, two, three, or as many as they wish
p52086
aVThese parameters will be passed to the method or to the constructor as a single array
p52087
aVIn your example the call can be made with as many instances of  as the caller wishes
p52088
aVThis is a syntactic shorthand for passing an array explicitly:
p52089
as(dp52090
g6
V335858
p52091
stp52092
a((dp52093
g2
(lp52094
VYou need to add the call of the overriden method of the base class in the implementation of the overriding method of the subclass, like this:
p52095
aVNote that your code does not override the method, because it is not declared
p52096
aVYou need to declare it like this:
p52097
as(dp52098
g6
V335858
p52099
stp52100
a((dp52101
g2
(lp52102
VYou are incorrect about s in Java: since they are designed to hold 16-bit UNICODE code points, they take two, not one byte each
p52103
aVIn the end, both representations will take the same amount of memory
p52104
aVYou should pick the data type that makes the most sense to you, the designer of your classes, and to the readers of your code
p52105
aVMemory concerns should not be at the top of your design priorities unless the number of objects that you need threatens to overflow your available memory
p52106
aVEven then you should do careful memory profiling before you optimize
p52107
as(dp52108
g6
V335858
p52109
stp52110
a((dp52111
g2
(lp52112
VYes, this is definitely possible
p52113
aVIn Model-View-Controller systems all information sharing happens through your model class
p52114
aVMake it a singleton object (singleton is similar to global variables, but it has proper initialization)
p52115
aVCreate a class with the data that must be shared
p52116
aVCreate a class method of that class to produce the sole instance of that class
p52117
aVDefine and initialize a static variable holding that instance
p52118
aVUse  to initialize that instance
p52119
aVHere is an answer illustrating this approach
p52120
aVWith a singleton instance in place, all your view controllers can access the model as necessary
p52121
aVOne view controller can set properties of the model, so that when the other view controller comes along, the data is ready for it to process
p52122
as(dp52123
g6
V335858
p52124
stp52125
a((dp52126
g2
(lp52127
VSince  does not preserve insertion order, and because you need the order to be predictable, the first approach does not give you a viable alternative
p52128
aV, on the other hand, is not going to provide the best alternative in terms of memory use because each "link" costs you at least the amount of memory required to store two references
p52129
aVEvery key is going to be unique
p52130
aVThis property of the keys, on the other hand, can be exploited quite nicely:
p52131
aVKeep all pairs in a single
p52132
aVCreate an  to group related keys together
p52133
aVNow you have a rather economical arrangement, with a single  with no links:
p52134
aVTo get all related KVPs of an item at index , do this:
p52135
aVTo get key and value at index  of item , do this:
p52136
aVThe "global" key mapping of  lets you access values by the keys; individual array lists let you access related keys in an ordered way at the "cost" of an added "level of indirection"
p52137
as(dp52138
g6
V335858
p52139
stp52140
a((dp52141
g2
(lp52142
VThis is undefined behavior: once the function finishes, accessing a variable inside it by pointer or reference makes the program invalid, and may cause a crash
p52143
aVIt is perfectly valid, however, to access a variable when you go "back" on the stack:
p52144
aVNote how  has accessed the value of a local variable declared inside another function
p52145
aVThis is legal, because  has not finished at the time the access has happened
p52146
as(dp52147
g6
V335858
p52148
stp52149
a((dp52150
g2
(lp52151
VAdding an empty string to an object is a common idiom that lets you do null-safe  conversion, like this:
p52152
aVWhen  is , this quietly returns an empty
p52153
as(dp52154
g6
V335858
p52155
stp52156
a((dp52157
g2
(lp52158
VUnfortunately,
p52159
aVNET DB libraries do not let you bind a single parameter to SQL's  list
p52160
aVIf the strings that you bind to the  list always come from inside your program and never from the user input, you can build the list directly, like this:
p52161
aVThis would produce a string that looks like this:
p52162
aVHowever, if the strings  come from the user, you need to parameterize your query to avoid SQL injection attacks, like this:
p52163
aVfor the query that looks like this:
p52164
aVand bind the  list parameters individually in a separate loop:
p52165
aVNote the use of  in the queries
p52166
aVThey will never match anything, even in case  contains some s
p52167
aVHowever, adding a  to the list lets you avoid syntax errors when the list of work types is empty: a query like this is valid, and it does not return anything:
p52168
aVThis query, on the other hand, would trigger a syntax error:
p52169
as(dp52170
g6
V335858
p52171
stp52172
a((dp52173
g2
(lp52174
VYou can use  and  expressions for that:
p52175
aVmatches a non-empty sequence of digits, and makes it a capturing group;  wraps the content of that capturing group in single quotes
p52176
aVDemo on ideone
p52177
aVEDIT : (inspired by Servy's comment) For a slightly more robust solution, use lookahead and lookbehind in your expression:
p52178
aVAlternative demo on ideone
p52179
as(dp52180
g6
V335858
p52181
stp52182
a((dp52183
g2
(lp52184
VIt looks like the amounts are stored as  values
p52185
aVYou could fix it the way described in the answer that you linked (i
p52186
ag630
aVby replacing string representations of numbers with numeric ones stored as ), or work around it by adding  to the descriptor:
p52187
as(dp52188
g6
V335858
p52189
stp52190
a((dp52191
g2
(lp52192
VOne way to put initialization of complex objects into a text file is using JSON, XML, or some custom format, and then read them at runtime from the resource, and deserialize it into objects
p52193
aVThis answer suggests libraries to parse JSON into objects; here is a link to an external library that lets you do XML deserialization
p52194
aVA custom format may be as simple as reading a list of key-value pairs from a file in a loop, and calling  as you go
p52195
aVThe problem with this approach is that it forces your program to process strings at runtime, instead of letting the compiler do the parsing
p52196
aVIf the only problem you're having with your current approach is the length of the code, an easy alternative is to move the array initialization into a function, put that function into a separate file, and call that function rather than embedding the lengthy piece of initialization code into your file
p52197
aVThe end result would be similar with most of the "heavy lifting" done by the compiler at compile time
p52198
as(dp52199
g6
V335858
p52200
stp52201
a((dp52202
g2
(lp52203
VSince you are using , naturally there could be times when the conversion fails: the insertion of new data in the vector and consumption of that data are done in unrelated places, and in such a way that the compiler cannot enforce it
p52204
aVHere is an example of an invalid cast:
p52205
aVIn this respect, using  would provide better protection against incorrect usage of the  function
p52206
aVNote that the incorrect usage may not be intentional: any time the compiler cannot check the type for you, and you have a potential type mismatch, you should prefer
p52207
aVHere is a small demo to illustrate how  would offer you a degree of protection
p52208
as(dp52209
g6
V335858
p52210
stp52211
a((dp52212
g2
(lp52213
VThere are several ways to share code - you can do it by
p52214
aVDefining a "helper" class, and adding your  methods to it,
p52215
aVDefining a base class (often an abstract base class) and adding your methods to it,
p52216
aVDefining a non-static class, and embedding an instance of that class in each of the classes that need to share the code; classes could also share a reference to a common instance
p52217
aVIt is hard to say which approach is more appropriate, but from the method names it appears that you are planning to get and set preferences
p52218
aVIn situations like that, the #1 or #3 with a shared instance are often the most appropriate
p52219
as(dp52220
g6
V335858
p52221
stp52222
a((dp52223
g2
(lp52224
VOne way to do it would be as follows:
p52225
aVNote that this algorithm is asymptotically very slow: it has  complexity
p52226
aVTo bring it back to the "normal" , prepare a lookup dictionary for finding indexes, like this:
p52227
as(dp52228
g6
V335858
p52229
stp52230
a((dp52231
g2
(lp52232
VThe items in  are not s, they are objects conforming to the  protocol
p52233
aVThe protocol defines a  property, so you need to do this:
p52234
as(dp52235
g6
V335858
p52236
stp52237
a((dp52238
g2
(lp52239
VYou can use  for that:
p52240
aVAggregate functions ignore s, returning them only when all values on the group are
p52241
as(dp52242
g6
V335858
p52243
stp52244
a((dp52245
g2
(lp52246
VUnlike  which is passed to the  by reference and can be modified,  is fixed, and it is passed by pointer
p52247
aVThe buffer can fit only as much data as you have allocated, and cannot grow with the size of user's input
p52248
aVdoes not know where the buffer's limit is, so it does not check it, possibly writing past the end of the allocated space
p52249
aVThis is undefined behavior, which can be exploited to fill the memory with data that represents executable code for malicious exploits of the heap spraying kind
p52250
aVHad the signature been , the writers of  could require -ed space and use  to expand the buffer; however, given the way the API is currently specified, the overflow could not be fixed even theoretically
p52251
aVThis problem is so serious that the designers of the C library decided to remove  from the standard library in the upcoming standard of the language
p52252
as(dp52253
g6
V335858
p52254
stp52255
a((dp52256
g2
(lp52257
VThe second approach is not going to help you: in order to produce the final output, you need sufficient amount of RAM to hold all keys from the file, along with a single  representing the count
p52258
aVWhether you're going to get to it in one big step or by several iterations of 10K rows at a time does not change the footprint that you would need at the end
p52259
aVWhat would help is partitioning the keys in some way, e
p52260
ag303
aVby the first character of the key
p52261
aVIf the name starts in a letter, process the file 26 times, the first time taking only the weights for keys starting in  and ignoring all other keys, the second time taking only s, and so on
p52262
aVThis will let you end up with 26 files that do not intersect
p52263
aVAnother valid approach would be using an external sorting algorithm to transform an unordered file to an ordered one
p52264
aVThis would let you walk the ordered file, calculate totals as you go, and write them to an output, even without the need for an in-memory table
p52265
aVAs far as optimizing the I/O goes, I would recommend using the  method of the  class: it gives you a  that is optimized for reading efficiency
p52266
as(dp52267
g6
V335858
p52268
stp52269
a((dp52270
g2
(lp52271
VYou can copy the data into new arrays using :
p52272
aVHowever, if you do not need the results to be two independent arrays, and would not mind them being pointers, you can do this:
p52273
aVThese two pointers can be used in ways similar to arrays except for two important differences:
p52274
aVand  will represent the size of the pointer, not of the array
p52275
aVThe memory pointed to by the two pointers would not be independent of the original  array
p52276
aVIf you print the content of memory pointed to by these two pointers, you would get the same results as if they were arrays:
p52277
as(dp52278
g6
V335858
p52279
stp52280
a((dp52281
g2
(lp52282
VThe reason the subview does not get the  event is that it has not received the  event: these two come in pairs - whichever view gets the touches began is going to get the touches ended
p52283
aVYour  could not get  because it wasn't there at the time; it gets  the second time around when you press down and release because it's there for both events
p52284
aVThere are several ways around this problem:
p52285
aVProcess view removal in the same place where you process the addition of  - when you add the subview, store a  reference to it in a separate variable
p52286
aVWhen the view that added the  gets the  event, go to that variable, and remove subview
p52287
aVKeep  there, but control its transparency - rather than adding and removing the subvuew, start it as fully transparent, then make it opaque on touch, then make it transparent again on release
p52288
aVDon't add the temporary  at all, use  instead - it looks like you are adding the image view simply to host an image in it for a short time
p52289
aVThere is a simpler way of doing it that's much lighter-way - using
p52290
aVThis approach should be easier to implement, because the layer does not participate in handling of touch events
p52291
as(dp52292
g6
V335858
p52293
stp52294
a((dp52295
g2
(lp52296
VYour version with pointers is very close - modify it as follows (see comments below):
p52297
as(dp52298
g6
V335858
p52299
stp52300
a((dp52301
g2
(lp52302
V is a set subtraction operator - you use it by supplying elements of the same kind as the original set to request the removal of all elements of the  set from the original set
p52303
aVThis is not what you are trying to achieve here - your task appears to be a simple filtering:
p52304
aVThis excludes all tickets with attachments by requiring the  to be
p52305
aV(Comment) I just want to ignore the o
p52306
aVattachmentFile I don't want to get it if it's null
p52307
aVThat's different: EF does not support lazy loading of individual properties, so unless the attachment is split in its own table (which I would recommend doing if you often query tickets without their attachments) you should select only the fields that you want to get:
p52308
as(dp52309
g6
V335858
p52310
stp52311
a((dp52312
g2
(lp52313
VStart by re-numbering grid positions: instead of a straight-through numbering scheme with a cell number, use a two-number scheme, with a  pair
p52314
aVYou can easily go back and forth between the two schemes by doing simple math
p52315
aVMake the center of the board be
p52316
aVThen your points would be located at positions , , and
p52317
aVWith this numbering scheme in place, observe that the location of the item can be determined by three things:
p52318
aVThe original  pair
p52319
aVThe rotation (0 - 0, 1 - 90, 2 - 180, 3 - 270)
p52320
aVThe flip along the horizontal axis (0 - no flip, 1 - flip)
p52321
aVFlipping along the vertical axis is represented by flipping along the horizontal axis followed by a 180 rotation
p52322
aVFlipping coordinates is easy: change the sign of the , while keeping the row intact
p52323
aVFlipped positions of your points would be , , and
p52324
aVA common way of making rotations is by left-multiplying a column-vector of coordinates by a rotation matrix:
p52325
aVHere is a list of matrices to perform rotations by 90, 180, and 270:
p52326
as(dp52327
g6
V335858
p52328
stp52329
a((dp52330
g2
(lp52331
VEvent handlers do not pass a tag by itself, they pass the entire button:
p52332
aVNow you can get the tag from the button passed in like this:
p52333
as(dp52334
g6
V335858
p52335
stp52336
a((dp52337
g2
(lp52338
VC, C++, and Objective-C let you put arbitrary ASCII codes into a string using so-called escape sequences
p52339
aVEscape sequence start either in  followed by two hex digits, or  followed by three octal digits
p52340
aVASCII  is 29 in decimal or  in hex, so you can put an  in an  like this:
p52341
as(dp52342
g6
V335858
p52343
stp52344
a((dp52345
g2
(lp52346
Vif a new product say  is introduced then we need to make changes to createProduct method
p52347
aVNo, or at least not necessarily: consider  class for a counterexample
p52348
aVIts  is clearly a factory method, yet it handles addition of new drivers with ease, with no changes made to the method itself
p52349
aVThe trick is to make your factory configurable: rather than hardcoding a bunch of --s, you could build a "registry" of classes that maps the key passed into the factory to the name of the class, and use reflection APIs to instantiate the classes that your method needs to return
p52350
as(dp52351
g6
V335858
p52352
stp52353
a((dp52354
g2
(lp52355
VNo, this is neither portable nor well-defined
p52356
aVCompilers are not required to allocate function  parameters in adjacent locations in memory
p52357
aVIn fact, they are not required to place parameters  and  in memory at all, since you are not taking their address
p52358
aVAny access beyond the bounds of the  through  in  is undefined behavior
p52359
as(dp52360
g6
V335858
p52361
stp52362
a((dp52363
g2
(lp52364
VYou can define a category on  to produce a string with decimal data representation, like this:
p52365
aVNow you can use this to  strings in the new format:
p52366
as(dp52367
g6
V335858
p52368
stp52369
a((dp52370
g2
(lp52371
VDoing it the way they did lets you reuse the array without re-allocating its backing storage
p52372
aVIf you wanted to reallocate the array, you could have done it yourself, since the representation of  mostly consists of its backing storage
p52373
aVIf they released the array as a whole, there would be very little difference between calling  and re-assigning the  itself
p52374
aVNow they give you an option to choose between reusing the array or replacing it with a brand-new one
p52375
as(dp52376
g6
V335858
p52377
stp52378
a((dp52379
g2
(lp52380
VThe difference between
p52381
aVand
p52382
aVis roughly the same as between  and :
p52383
aVthe first says that the iterator must remain constant, but what it points to can be changed
p52384
aVthe second says that the iterator itself is changeable, but what it points to is
p52385
aVIf you rewrite the function as
p52386
aVit would compile and run correctly
p52387
as(dp52388
g6
V335858
p52389
stp52390
a((dp52391
g2
(lp52392
VFirst, your query is open to SQL injection attacks
p52393
aVYou need to fix it by parameterizing your query
p52394
aVNext, you do not need the  there: you can express your logic as a composite logical condition
p52395
aVI changed the query from one that uses a dynamic column name defined by the value of the  variable to use  for better readability
p52396
aVI also defined parameters for the values that come from various pickers
p52397
aVYou will need to set them on your prepared command before querying
p52398
aVThe part of most interest is at the bottom: I rewrote your  as a three-part logical condition that evaluates one of three parts based on the settings of  and , which represent the month values from  and
p52399
as(dp52400
g6
V335858
p52401
stp52402
a((dp52403
g2
(lp52404
VArrays are not themselves limited to any fixed size, but arrays that you allocated in the automatic storage (commonly known as "the stack") are limited to the size of the stack
p52405
aVWhen you allocate large arrays in the static storage, you can make much larger arrays
p52406
aVSame goes for dynamic allocations: whatever the size of the vector that you could allocate without triggering a memory overflow, you can make an array of the same size with the  operator
p52407
aVFor example, you can do this without triggering stack overflow:
p52408
aVor this:
p52409
as(dp52410
g6
V335858
p52411
stp52412
a((dp52413
g2
(lp52414
VThis is a lightly camouflaged Longest increasing (decreasing) subsequence problem
p52415
aVThe algorithm to solving your problem is as follows:
p52416
aVFind the longest increasing (decreasing) subsequence in the array
p52417
aVRemove all elements that do not belong to the longest increasing subsequence
p52418
aVSince the increasing/decreasing subsequence is longest, the amount of numbers that you will remove is the smallest
p52419
aVWikipedia article has a nice pseudocode for solving the LIS/LDS problem
p52420
aVYou can substitute binary search for a linear one unless the original sequence is 1000+ elements long
p52421
as(dp52422
g6
V335858
p52423
stp52424
a((dp52425
g2
(lp52426
VWhen  is set , it is not necessary: even if  or  happen to be , the  is not going to match a   to that list
p52427
aVIn other words, the condition
p52428
aVevaluates to
p52429
aVThe only reason to keep an explicit  check there would be if you wanted to return a different number for , say, a negative 1
p52430
as(dp52431
g6
V335858
p52432
stp52433
a((dp52434
g2
(lp52435
VThe reason why the  is undefined on  is because the classes  and  are of different types
p52436
aVAn operator  defined inside one of them is not going to apply
p52437
aVHowever, C++ lets you define "free-standing" operator templates, like this:
p52438
aVThis operator takes references to  objects with different type arguments, so the compiler will be able to call it for
p52439
aVYou may need to declare "friendship" to this operator inside your  template in order to let the operator access private and protected members of the matrix class
p52440
as(dp52441
g6
V335858
p52442
stp52443
a((dp52444
g2
(lp52445
VThe problem that you see has to do with  method not being supported by the  provider
p52446
aVForcing the move of your data to memory should fix this problem - you can use  to do the cast, or bring the data in memory explicitly, like this:
p52447
aVThis shouldn't have much impact on the performance, because  is going to bring both lists into memory anyway
p52448
as(dp52449
g6
V335858
p52450
stp52451
a((dp52452
g2
(lp52453
VIf the source code of  in Mono is any indication, your implementation wins because it performs fewer allocations (scroll down to line 2874 to see the method)
p52454
aVLike many methods of LINQ, the  method contains separate code paths for collections and for other enumerables:
p52455
aVIn your case, this branch is not taken, so the code proceeds to this loop:
p52456
aVAs you can see, LINQ's version may allocate and re-allocate the array several times
p52457
aVYour implementation, on the other hand, does just two allocations - the upfront one of the max size, and the final one, where the data is copied
p52458
aVThat's why your code is faster
p52459
as(dp52460
g6
V335858
p52461
stp52462
a((dp52463
g2
(lp52464
VUse :
p52465
aVThere's also , but it's a legacy function, so it shouldn't be used in new development
p52466
as(dp52467
g6
V335858
p52468
stp52469
a((dp52470
g2
(lp52471
VSince this is the header file, your C branch should use  as well:
p52472
aVOtherwise, you will end up with multiple definitions of the  in every translation unit where the header is included, resulting in errors during the linking phase
p52473
aVThe definition of  should reside in a separate translation unit - either a C file or a CPP file
p52474
aVThe header needs to be included as well, to make sure that you get proper linkage
p52475
as(dp52476
g6
V335858
p52477
stp52478
a((dp52479
g2
(lp52480
VWhen it is a simple property like this, consider replacing it with an "automatic" property, like this:
p52481
aVWith properties this simple, it does not matter which way you access them: although accessing backing variable may seem like a little faster, the optimizer will take care of optimizing out the function call, making both accesses equally fast
p52482
aVWhen the property is more complex, for example, when it has additional validations and/or triggers events, the decision becomes more complex: you need to decide if you want to have the effects associated with accessing the property, or if you wish to avoid them
p52483
aVThen you make a decision based on what you want to happen
p52484
as(dp52485
g6
V335858
p52486
stp52487
a((dp52488
g2
(lp52489
VYou can put  and  into an array of pointers, like this:
p52490
aVAs far as the rest of your program goes, you need to change the outer loop to cover the entire range, like this:
p52491
aVHere is a working demo on ideone
p52492
as(dp52493
g6
V335858
p52494
stp52495
a((dp52496
g2
(lp52497
VAdd buttons 1 through 4 to an  in the interface builder
p52498
aVAdd a property
p52499
aVand drag buttons 1
p52500
aV4 there
p52501
aVHere is an answer explaining how to do it step-by-step
p52502
aVNow you can operate all the buttons in that collection using a loop, rather than referencing them individually:
p52503
as(dp52504
g6
V335858
p52505
stp52506
a((dp52507
g2
(lp52508
VA natural way of processing recursive data structures, for count or any other kind of aggregation, is employing a recursive function:
p52509
aVThe function assumes that parts of lower levels are not shared among parts at the higher level, i
p52510
ag630
aVthat your graph of parts is a tree
p52511
aVOne way to improve the performance of functions like this is to cache the results at the levels below yours in the , to make sure that the recursive computation is done only once
p52512
aVYou could avoid recursion by implementing a queue or a stack, but the implementation wouldn't be that simple
p52513
as(dp52514
g6
V335858
p52515
stp52516
a((dp52517
g2
(lp52518
VThe value 2147483647, or 231-1 overflows a 16-bit integer
p52519
aVIts binary representation is zero in the MSB followed by 31 ones in the remaining bits
p52520
aVIt looks like in your implementation the last 16 bits are taken in the conversion to
p52521
aVWhen this happens, all of them are set to , resulting in a 2's complement representation of :
p52522
aVHowever, neither the 2-compliment representation nor this behavior in general is part of the C++ standard, so this behavior is implementation-defined
p52523
as(dp52524
g6
V335858
p52525
stp52526
a((dp52527
g2
(lp52528
VA single  method returning a  should be sufficient: the code that processes  can put a call to  on top of it:
p52529
as(dp52530
g6
V335858
p52531
stp52532
a((dp52533
g2
(lp52534
VI think the reason why scrolling creates a problem is that un-hiding the progress view is a one-way street: once you set it visible, you never hide it again
p52535
aVReplacing
p52536
aVwith
p52537
aVshould fix the problem
p52538
aVThat would not be enough to make the progress view hide upon completion of the download
p52539
aVYou need to add a call
p52540
aVto the end of the  block
p52541
as(dp52542
g6
V335858
p52543
stp52544
a((dp52545
g2
(lp52546
VThis happens because you initialize your string incorrectly
p52547
aVWhen you call
p52548
aVyou are initializing the string with uninitialized data, and you also create a memory leak, because you never call the  on the
p52549
aVReplace it with
p52550
aVto fix the problem
p52551
as(dp52552
g6
V335858
p52553
stp52554
a((dp52555
g2
(lp52556
VYou can use  to find the smallest element larger than or equal to , check if you've got a  iterator to decide that the value is smaller than the smallest one in the map, and go back one step to go to the key that's the largest one not exceeding :
p52557
aVUnlike a plain loop (that iterates all the keys in order)  knows about the internal structure of  an can take advantage of it during the search, resulting in better performance
p52558
aVHere is a demo on ideone
p52559
as(dp52560
g6
V335858
p52561
stp52562
a((dp52563
g2
(lp52564
VTry disconnecting both touch events from your button, and hook two tap gesture recognizers to it instead
p52565
aVHere is a link to an answer that explains how to set up two gesture recognizers so that one of them recognizes a single tap, and the other one recognizes a double tap:
p52566
as(dp52567
g6
V335858
p52568
stp52569
a((dp52570
g2
(lp52571
VThe obfuscation algorithm that you have selected is based on ing the data and the "key" values together
p52572
aVGenerally, this is not very strong
p52573
aVMoreover, since  is symmetric, the results are very prone to producing duplicates
p52574
aVAlthough your implementation is currently broken, fixing it would not be of much help in preventing the algorithm from producing identical results for different data: it is relatively straightforward to construct key/data pairs that produce the same obfuscated string - for example,
p52575
aVwill produce identical results , even though both the strings and the keys look sufficiently different
p52576
aVIf you would like to "obfuscate" your strings in a cryptographically strong way, use a salted secure hash algorithm: it will produce very different results for even slightly different strings
p52577
as(dp52578
g6
V335858
p52579
stp52580
a((dp52581
g2
(lp52582
VIn the  join, you get all rows from the table on the right; the  clause limits the matching rows from the table on the left, i
p52583
ag630
aVthe  table
p52584
aVIf you want to limit rows of , you need to change the join from  to
p52585
aVcomment: "I want all rows from the  table regardless to whether it has an entry in the "
p52586
aVThen you need to make  part of the  clause, because you want it to filter the rows of the "main" table in the outer join:
p52587
as(dp52588
g6
V335858
p52589
stp52590
a((dp52591
g2
(lp52592
VReplace  with , like this:
p52593
aVThis will produce three columns with counts for each payment status
p52594
as(dp52595
g6
V335858
p52596
stp52597
a((dp52598
g2
(lp52599
V inside the string output stands for the character with the code point of zero
p52600
aVYour string is equivalent to this:
p52601
aVIn Java  is non-printable
p52602
aVHowever, the string preserves it - if you check the length of the string, it's 12, not 10, although only ten characters are printed when you output the string to a console:
p52603
aVprints (demo)
p52604
aVcomment: This does not work with the
p52605
aVThe problem with that parser is that its  method, line 156, expects the length of the printed string to match the number of characters in the  construct
p52606
aVSince the declared  is 12 but the actual length is only 10,  consumes two extra characters from the stream on lines 175
p52607
aV176, breaking everything else
p52608
aVIf you would like to stay with that parser, consider replacing  characters with some other printable character that you do not use, say, an underscore, before encoding the string, and then placing  back on the other side of the parse
p52609
as(dp52610
g6
V335858
p52611
stp52612
a((dp52613
g2
(lp52614
VThe first loop is about twice as fast as the second one, but in terms of the asymptotic time complexity they are the same:
p52615
aVYou can think anout it graphically: imagine a square with N units on each side
p52616
aVThe second loop visits all unit squares;
p52617
aVthe first loop visits the points that belong to a triangle covering half the square:
p52618
as(dp52619
g6
V335858
p52620
stp52621
a((dp52622
g2
(lp52623
VIn the number  written in a positional numeric system each digit has a different value
p52624
aVThe rightmost digit  has unit value of  in all positional notations
p52625
aVThe following digit going left has unit value of the system's base: in decimal system that is ten; in hex it's sixteen, in binary it's two, and so on
p52626
aVThe third digit has unit value of base squared, the forth - base cubed, and so on
p52627
aVAssuming that  is written in decimal system,
p52628
aVs unit value is 100 = 1
p52629
aVs unit value is 101 = 10
p52630
aVs unit value is 102 = 100
p52631
aVs unit value is 103 = 1000
p52632
as(dp52633
g6
V335858
p52634
stp52635
a((dp52636
g2
(lp52637
VThis is because you are assigning zero to
p52638
aVYou need to assign  or , otherwise the integer is interpreted as an address:
p52639
as(dp52640
g6
V335858
p52641
stp52642
a((dp52643
g2
(lp52644
VYour program exhibits undefined behavior: you are setting a pointer to a locally allocated  here:
p52645
aVSince  is on the stack, returning a parent pointing to it leads to undefined behavior
p52646
aVYou need to allocate  dynamically to make it work:
p52647
aVNow that you have dynamically allocated memory, do not forget to call  on each of the dynamically allocated nodes of your linked list to prevent memory leaks
p52648
as(dp52649
g6
V335858
p52650
stp52651
a((dp52652
g2
(lp52653
VYou cannot test for presence or absence of a particular bit in a : if compiler sees a reference to a filed that isn't defined, it will complain even if there is no code path to reach that field
p52654
aVHowever, you can add some "metadata" of your own to make a single macro usable in all contexts:
p52655
aVNow you can rewrite your "magic" macro like this:
p52656
aVFor this to compile you need to add a definition for the static  variable declared at the top of your metadata
p52657
as(dp52658
g6
V335858
p52659
stp52660
a((dp52661
g2
(lp52662
VYour code snippet should work once you fix some obvious errors
p52663
aVYou can speed it up by performing one search of  instead of two:
p52664
as(dp52665
g6
V335858
p52666
stp52667
a((dp52668
g2
(lp52669
VThe log lines that you see (and especially the ones that you do not see) indicate that  is  - it has not been initialized: the only reason the  would not log the unconditional  is that  is invoked on a
p52670
aVIn all other cases there would be at least that additional log line
p52671
aVYou need to add code that assigns an object to your  variable to make it work:
p52672
aVReplace  above with the actual type of
p52673
as(dp52674
g6
V335858
p52675
stp52676
a((dp52677
g2
(lp52678
VFirst, you are talking about collections, not arrays: array is one specific kind of collection, and the most primitive one at that
p52679
aVYou should use arrays directly when the number of elements in a collection is known at the time the collection is created, and never changes after that
p52680
aVIf your requirement is to remove an element from the beginning of a collection and inserting it at the end, then you should either use a  or a , and make an object that represents the pair of numbers its generic type argument
p52681
aVThese data structures are optimized for quick insertion and removal from the ends
p52682
as(dp52683
g6
V335858
p52684
stp52685
a((dp52686
g2
(lp52687
VSince  is shared among all generic  objects, you cannot implement them both in the same class
p52688
aVYou have two options in making it work:
p52689
aVProvide two properties,  and , that produce different iterator objects, the way suggested in this answer, or
p52690
aVMake separate  classes -  and
p52691
aVDo not implement  in  at all, and provide two conversion operator from  to  and to
p52692
aVUsers would be able to decide on what iterator to use by inserting a cast
p52693
as(dp52694
g6
V335858
p52695
stp52696
a((dp52697
g2
(lp52698
VCreate today's date outside the comparator, and change your comparator to compare absolute differences for the dates it compares, like this:
p52699
as(dp52700
g6
V335858
p52701
stp52702
a((dp52703
g2
(lp52704
Vwhen I test the app, the array is still empty
p52705
aVThis is because you did not initialize :
p52706
as(dp52707
g6
V335858
p52708
stp52709
a((dp52710
g2
(lp52711
VThis happens because  did not find any data to put in the  and/or , so they are left uninitialized
p52712
aVYou should initialize them, and add code that ensures that  got both of them set, like this:
p52713
aVTo fix, change the first  for , like this:
p52714
aVThis would make  stop reading the first string when it reaches the  sign
p52715
as(dp52716
g6
V335858
p52717
stp52718
a((dp52719
g2
(lp52720
VThe two are completely different, so the answer depends a lot on the task at hand
p52721
aVIf you use regular expressions without metacharacters, use string-based comparisons instead: they are easier to understand, and do not introduce complexity where it does not belong (here is a link to an article that explores this point in depth)
p52722
aVThe power of regular expressions starts with the use of metacharacters
p52723
aVIf you need to define strings that you want captured rather than enumerating them one by one, then regular expressions should be used
p52724
as(dp52725
g6
V335858
p52726
stp52727
a((dp52728
g2
(lp52729
VThese are not all casting - specifically, only  is a cast; the other two are regular methods
p52730
aVis a method of  inherited by all objects in
p52731
aVNET
p52732
aVThis method lets you provide a string representation of your object suitable for debugging purposes
p52733
aVis a group of more than thirty static method overloads
p52734
aVThey provide  representations for various primitive types
p52735
aVSome overloads take a format provider, while other ones implicitly use the default one
p52736
aVIf you pass a custom object to , the implementation would first try going for  or  implementation in the object, if it has one
p52737
aVIf it does not, the "catch all"  method of the object is called
p52738
aVis a cast: given an instance of a  assigned to a variable of type  or returned from a method with the return type of object, a cast lets you obtain a variable that is statically typed as a
p52739
aVYou can use such a  object to call 's instance methods on it, or to pass it to a method requiring a
p52740
as(dp52741
g6
V335858
p52742
stp52743
a((dp52744
g2
(lp52745
VThe best approach by far is try avoiding this situation: can you make the interface of the  uniform for all subclasses
p52746
aVIf this can be done, choose this design without much hesitation, because what I describe below is a lot more complex, and also much harder to read
p52747
aVSince you cannot access member functions of derived types through a pointer to the base type, you need to work around this in one of several ways:
p52748
aVUse  - This is very simple, but extremely fragile
p52749
aVChanges to the inheritance structure can break an approach based on frequent dynamic casts
p52750
aVUse VisitorPattern - This is a good choice when the class structure is not expected to change (you're in luck here: the list of types that you plan to model has not changed in many centuries)
p52751
aVUse Runtime Type Information and maps of function objects - This approach is very flexible, but it is somewhat hard to read
p52752
aVLambdas of C++11 make it easier, though
p52753
as(dp52754
g6
V335858
p52755
stp52756
a((dp52757
g2
(lp52758
VOne could think of a  loop
p52759
aVas a rough equivalent to this  loop:
p52760
aVThe biggest difference between the  and the rewrite above is the scope of variables declared in the  block, but this is not important for the analysis below
p52761
aVRewriting both loops as a  loop gives you this:
p52762
aVvs
p52763
aVAs you can see, the only difference is that  is decremented before entering the iteration, and the condition is started with  greater by  than in the first loop
p52764
aVThese two adjustments "cancel each other", making your loops equivalent from the technical point of view
p52765
aVAesthetics is a different thing, though: conditions with side effects are harder to understand than "pure" ones, so the first loop is more readable
p52766
as(dp52767
g6
V335858
p52768
stp52769
a((dp52770
g2
(lp52771
VIn order for WPF to react to changes in properties, the class must implement  interface
p52772
aVYou need to send notifications every time a customer is changed, like this:
p52773
as(dp52774
g6
V335858
p52775
stp52776
a((dp52777
g2
(lp52778
VIf you have two independent  properties, you don't need to synchronize at all: the only reason to synchronize is to ensure consistency when more than one memory location is involved
p52779
aVWith independent locations  is sufficient to ensure cross-thread visibility of your changes
p52780
aVFor example, if your  properties are not independent, you need to synchronize
p52781
aVLet's say one property represents the current value, and the other represents the max value
p52782
aVSetting the current value that's greater than the max throws an exception; setting the max value greater than the current value changes the current value to the new max
p52783
aVThe decision for arrays and collections is more complex: if you access array elements, but the array itself stays fixed, and array elements are independent, you can skip synchronization
p52784
aVHowever, if elements are not independent, or if the collection is more complex (say, an array list or a hash table) then you need to synchronize, because collection operations may change the collection structurally, breaking consistency
p52785
as(dp52786
g6
V335858
p52787
stp52788
a((dp52789
g2
(lp52790
VThis could happen when the  string ends up at the beginning of the string after the removal of the square brackets: in this case,  evaluates to zero, so the call of
p52791
aVdoes not change the  string at all, leaving whatever junk that was there for the following call of  to skip before appending
p52792
aVYou get lucky that the junk in the  happens to be a short null-terminated string, such as an  or an
p52793
aVOtherwise, you could get a much longer string of arbitrary characters
p52794
aVIn addition to fixing the above undefined behavior, you should fix a few more things:
p52795
aVYour code does not check the return value of the first
p52796
aVYour code miscalculates the length of the result: you should subtractl the length of the word , because you replace it with the content of , i
p52797
ag630
aVit should be
p52798
aVYou do not need to cast the return value of  in C
p52799
aVYou do not need to multiply the length by  (only one of your two s does that)
p52800
aVYour second early return leaks memory
p52801
as(dp52802
g6
V335858
p52803
stp52804
a((dp52805
g2
(lp52806
VAbsolutely: reading  into a dictionary gives you a dictionary of dictionaries, so you need to access  first:
p52807
aVNew syntax lets you write it with fewer characters:
p52808
as(dp52809
g6
V335858
p52810
stp52811
a((dp52812
g2
(lp52813
VYou should set visibility of the class members according to their place in the design, not according to the size of the class or any other considerations
p52814
aVIf a method or a field represents or does something that is relevant to the way the class does its work, but not to the way the users of the class see what it does, mark the member private
p52815
aVThe fancy name for this is "implementation details": you do not want to have them exposed to ensure that you can change them later on
p52816
aVIf a method or a field is essential to what the class does for its users, make that member public: otherwise, nobody would be able to use that member, rendering the entire class useless
p52817
aVIf your class is designed for inheritance, and a method or a field is prepared for exclusive use by this class and its subclasses, make that method protected
p52818
aVIf a method or a field is an implementation detail that needs to be visible by other classes inside the same assembly, make the member
p52819
aVYou can mix  and , further restricting the access to derived classes inside the same assembly
p52820
aVYou should start doing this classification in your mind as you design your software
p52821
aVIt is much easier to do this classification when you design smaller systems
p52822
aVHowever, the importance of doing it right grows tremendously as the size of your system goes up
p52823
as(dp52824
g6
V335858
p52825
stp52826
a((dp52827
g2
(lp52828
VYou can make a flag that tells you that you saw at least one non-whitespace character after the last , so that you could increment the line counter only when that flag is set to :
p52829
aVDividing the count by two is not reliable, unless you are guaranteed to have double spacing in all your files
p52830
as(dp52831
g6
V335858
p52832
stp52833
a((dp52834
g2
(lp52835
VOne straightforward way to accomplish this is as follows:
p52836
aVThis is pretty much a translation of English description of the problem to SQL syntax
p52837
as(dp52838
g6
V335858
p52839
stp52840
a((dp52841
g2
(lp52842
VAnother solution would be passing your checker an object that provides the current algorithm state in response to parameter names expressed as string names
p52843
aVThis makes it possible to separately compile your conversion strategies, because the interface of this "callback" interface stays the same even if you add more parameters to your algorithm:
p52844
aVThat is all the implementers of the convergence checker need to see: they implement the checker, and get the state
p52845
aVYou can now build a class that is tightly coupled with your algorithm implementation to implement  and get the parameter based on its name
p52846
aVThis tightly coupled class is private to your implementation, though: the callers see only its interface, which never changes:
p52847
as(dp52848
g6
V335858
p52849
stp52850
a((dp52851
g2
(lp52852
VWhen you do a  in most RDBMSs, your selection is limited to the following two things:
p52853
aVColumns mentioned in the  - in your case, that's
p52854
aVAggregate functions - for example,
p52855
aVHowever, the  at the top is neither one of these
p52856
aVYou need to remove it for the statement to work:
p52857
as(dp52858
g6
V335858
p52859
stp52860
a((dp52861
g2
(lp52862
VIn C#  is a 16-bit numeric type, so  means addition, not concatenation
p52863
aVTherefore, when you add  and  you get
p52864
aVMoreover, the result of this addition is an  (see a quick demo)
p52865
aVIf by "adding two characters" you mean "concatenation", converting them to a strings before applying operator  would be one option
p52866
aVAnother option would be using , like this:
p52867
as(dp52868
g6
V335858
p52869
stp52870
a((dp52871
g2
(lp52872
VWhen implementing switches among a diverse set of alternatives, you have several options:
p52873
aVMake several groups of flat lookup arrays
p52874
aVFor example, if you see numbers , you could do a single  to take you to 1-s or to 20,000-s, and then employ two flat lookup arrays
p52875
aVDiscover a pattern
p52876
aVFor example, if you see numbers , divide the number by , and then go for a flat lookup array
p52877
aVMake a hash table
p52878
aVSince all the numbers that you are hashing are known to you, you can play with the load factor of the table to make sure that the lookup is not going to take a lot of probing
p52879
aVYour algorithm is similar to binary search, in the sense that it's from the "divide an conquer" family
p52880
aVSuch algorithms have logarithmic time complexity, which may not be acceptable for switches, because they are expected to be
p52881
as(dp52882
g6
V335858
p52883
stp52884
a((dp52885
g2
(lp52886
VWill the array be copied correctly when I pass a struct S to that function
p52887
aVYes, it will be copied
p52888
aVdo I have to change the function to:
p52889
aVYou may want to do that for three reasons:
p52890
aVYou want to avoid copying - passing a pointer is cheaper
p52891
aVYou want to make changes to the struct inside  - pointers let you do that; passing by value does not
p52892
aVYou want to reduce the risk of stack overflow - if the array is large, passing by value may overflow the stack
p52893
aVPassing by pointer greatly reduces this risk
p52894
aVEDIT : Since this is C++, you have an option of passing the  by reference:
p52895
aVor
p52896
aVPassing by reference avoids copying in a way similar to passing by pointer
p52897
aVUnlike passing by pointer, passing by reference indicates to the reader that the  passed in references some place in memory, while pointers give you an option of passing a
p52898
as(dp52899
g6
V335858
p52900
stp52901
a((dp52902
g2
(lp52903
VThe reason you get undefined behavior is that the subscript operator  takes precedence over the indirection operator
p52904
aVThe value of  is indexed as an array of pointers, which is incorrect, because there's only a single pointer there
p52905
aVSince you are passing a pointer to a pointer, you need to put the asterisk inside parentheses:
p52906
aVDemo on ideone
p52907
as(dp52908
g6
V335858
p52909
stp52910
a((dp52911
g2
(lp52912
VCould I have one separate file for each page
p52913
aVAbsolutely, it is up to you
p52914
aVEach view can have a different view controller behind it, or several views can share one view controller
p52915
aVXcode gives you full control over what you want to do, letting you specify the classes behind your screens
p52916
aVHow would I connect them to each other
p52917
aVPerhaps the easiest way of connecting them would be with storyboard segues, because it lets you write no code at all
p52918
aVAll the connections and interactions would be handled behind the scene by the Cocoa's storyboard infrastructure
p52919
aVAll you'd need to do is connecting your buttons to something that does the actual work
p52920
as(dp52921
g6
V335858
p52922
stp52923
a((dp52924
g2
(lp52925
VIf you have an option of making an immutable class, you would be much better off with your implementation : in-place modifications are significantly harder to implement and maintain
p52926
aVSometimes going the immutable route may not be an option, because of the need to make frequent modifications to a relatively large object
p52927
aVIn this case you may want to reconsider the application of the concurrent hash map to your design, because the fact that it is synchronized does not give you too much an advantage
p52928
as(dp52929
g6
V335858
p52930
stp52931
a((dp52932
g2
(lp52933
VThe error is probably due to the fact that your  class does not have a default constructor either
p52934
aVThere are two ways of fixing this:
p52935
aVAdd a default constructor to , or
p52936
aVAdd  to the initialization list of 's constructor
p52937
as(dp52938
g6
V335858
p52939
stp52940
a((dp52941
g2
(lp52942
VYou can build a simple algorithm by grouping the values, ordering by count, and then taking them until you fill the required 5% array, like this:
p52943
aVEDIT :
p52944
aVThe array may be as big as 1024*1024 in size and the ranges are between 0 and 255
p52945
aVSince the range is very small, you can use counting array instead of a group, like this:
p52946
aVNow you can run the Quick Select Algorithm to choose the fifth item
p52947
aVHere is an answer that provides a C# implementation of
p52948
aVYou may want to replace the quick select algorithm with the median-of-medians algorithm, which has the same linear performance, but is not randomized
p52949
as(dp52950
g6
V335858
p52951
stp52952
a((dp52953
g2
(lp52954
VIt looks like the elements are simply reversed
p52955
aVYou can do this without additional arrays, with whatever implementation of the swap that you feel like using:
p52956
aVFor integers you can use "storageless swap" by computing a sum and subtracting, by XORing, etc
p52957
aVOne would never do that in production, though - it's a useless interview trick invented at the time when hardware engineers doubled as programmers more often than they do now (I saw this problem formulated in terms of hardware logical gates some 25 years ago)
p52958
as(dp52959
g6
V335858
p52960
stp52961
a((dp52962
g2
(lp52963
VScoring is very easy - you add one for every match in the answer and the key, like this:
p52964
aVYou can do it with even less code if you recall that logical operations return zero for "true" and one for "false"
p52965
aVWARNING: This may cost you some readability points among your peers, or even some real points if your professor fails to get impressed by such brevity:
p52966
aVCase sensitivity is another concern: what if the answer key is , and the user enters
p52967
aVThe above code would not give the student his hard-earned points, which is wrong
p52968
aVIf you force the case of both characters to upper, mixed-case comparison would be correct:
p52969
as(dp52970
g6
V335858
p52971
stp52972
a((dp52973
g2
(lp52974
VThis two-loop construct is simple, but it is not performant
p52975
aVThe problem is the number of comparisons: if the first set has  items and the second has , then there would be  comparisons
p52976
aVWith 1,000 items in each set, we're talking about 1,000,000 comparisons
p52977
aVA better approach would be to hash the items of the first set, and then search the hash for the items from the second set
p52978
aVSince hashing is done in amortized constant time, you can do this in  operations, or about 2,000 for two sets of 1,000 items each:
p52979
aVLINQ library lets you do this in even fewer lines of code:
p52980
as(dp52981
g6
V335858
p52982
stp52983
a((dp52984
g2
(lp52985
VYou can use LINQ to parse the numbers from the string, like this:
p52986
aVHere is a demo on ideone
p52987
aVTo do the check, sort the numbers in ascending order, then check that the sum of the first two is strictly greater than the third one:
p52988
aVNote that it is not a sufficient condition for the numbers to define a triangle: you must also check that the numbers are strictly positive
p52989
as(dp52990
g6
V335858
p52991
stp52992
a((dp52993
g2
(lp52994
VA simple expression that lets you grab the substring up to the third  character is as follows:
p52995
aVThe  checks that there are at least three slashes; the  extracts the substring up to and including the third one
p52996
aVWith this expression in hand, writing a  is simple:
p52997
aVDemo on SqlFiddle
p52998
as(dp52999
g6
V335858
p53000
stp53001
a((dp53002
g2
(lp53003
VStrictly speaking, you didn't implemented a removal of a substrng: your code prints the string with a range of characters removed
p53004
aVAnother thing to note is that according to your example, the index  is one-based, not zero-based like it is in C
p53005
aVOtherwise the output for  would have been , not
p53006
aVWith this in mind, let's make some changes
p53007
aVFirst, your math is a little off: the last loop should look like this:
p53008
aVDemo on ideone
p53009
aVIf you would like to use C's zero-based indexing scheme, change your loops as follows:
p53010
aVIn addition, you should return from the  at the top, or add an :
p53011
aVor
p53012
aVor remove the  altogether: it's only an optimization, your code is going to work fine without it, too
p53013
aVCurrently, you code would print the original string twice when  is
p53014
aVIf you would like to make your code remove the substring and return a result, you need to allocate the result, and replace printing with copying, like this:
p53015
aVNote that this new version of your code returns dynamically allocated memory, which needs to be d after use
p53016
aVHere is a demo of this modified version on ideone
p53017
as(dp53018
g6
V335858
p53019
stp53020
a((dp53021
g2
(lp53022
VYou can avoid  like this:
p53023
aVThe type of your block is  - that's what goes into parentheses after the plus
p53024
as(dp53025
g6
V335858
p53026
stp53027
a((dp53028
g2
(lp53029
VYou keep the container and call  when you would like to reduce the load on GC:  nulls out all the references inside the array, but does not make the array eligible for reclaiming by the garbage collector
p53030
aVThis may speed up future inserts, because the array inside  does not need to grow
p53031
aVThis approach is especially advantageous when the data that you plan to add to the container has roughly the same size as you clearing out
p53032
aVIn addition, you may need to use  when other objects hold a reference to the array that you are about to clear
p53033
aVReleasing the container and creating a new one makes sense when the size of the new data may be different from what was there before
p53034
aVOf course you can achieve a similar effect by calling   in combination with
p53035
as(dp53036
g6
V335858
p53037
stp53038
a((dp53039
g2
(lp53040
VAn interface does not have a constructor, but an anonymous class does: like all classes, it extends  implicitly, therefore it can call the 's parameterless constructor
p53041
aVMoreover, 's constructor is the only constructor you could call, because anonymous classes cannot define custom constructors
p53042
aVOf course in addition to extending  your anonymous class implements  - that's why you can pass it to the  method
p53043
as(dp53044
g6
V335858
p53045
stp53046
a((dp53047
g2
(lp53048
V statements without s let you do things like this:
p53049
aVEssentially, it lets you create a set of labels, and have a condition at the top to let you jump to the initial label once
p53050
aVAfter that, the execution continues until a , or reaching the end of the
p53051
aVThis technique is old - it has been around since the assembly times, and by virtue of being included in C has made its way into Java and several other languages
p53052
as(dp53053
g6
V335858
p53054
stp53055
a((dp53056
g2
(lp53057
VThe function stops after catching the exception because the try / catch is outside the loop
p53058
aVMove it into the loop to get the effect that you want:
p53059
aVNote that this function is going to search only one level of directories
p53060
aVIf you want to search recursively, you need to call  for each directory that you find, like this:
p53061
as(dp53062
g6
V335858
p53063
stp53064
a((dp53065
g2
(lp53066
VYou can do it like this:
p53067
as(dp53068
g6
V335858
p53069
stp53070
a((dp53071
g2
(lp53072
VOpen the  header file, and follow the trail of s until you find the  template
p53073
aVThat's where the source of the  will be
p53074
aVFor example, in Visual Studio 2012 the function is located in the  header, and looks as follows:
p53075
as(dp53076
g6
V335858
p53077
stp53078
a((dp53079
g2
(lp53080
VCocoa often detects the presence or absence of implemented delegate methods dynamically, rather than relying on static types
p53081
aVTherefore it is not necessary to formally declare that your view controller conforms to the protocol , unless you wish the compiler to warn you of not implementing required methods of the protocol
p53082
aVInternally,  checks if the  responds to selectors it is about to call before trying to invoke it, essentially eliminating the need to declare the protocol implementation
p53083
aVThis may look unusual to developers coming from statically typed languages, but this is commonplace in Objective C
p53084
as(dp53085
g6
V335858
p53086
stp53087
a((dp53088
g2
(lp53089
VThis is probably due to the fact that  is a boxed , not an
p53090
aVYou can use
p53091
aVto unbox the number
p53092
as(dp53093
g6
V335858
p53094
stp53095
a((dp53096
g2
(lp53097
VMy understanding is that 's behavior is part of the Objective C language, not of any particular library
p53098
aV, on the other hand, is part of a library, with a single very specific purpose:
p53099
aVThe  class defines a singleton object used to represent null values in collection objects (which don\u2019t allow  values)
p53100
aVIt is not intended for use as a "sentinel" object: if you wish to construct such an object, you can always do so, because collections themselves do not assign  any particular significance
p53101
aVIt is provided for programmers' convenience in situations when they wish to store s, so that programmers could avoid reinventing their own null object every time they need it
p53102
aVAlso note that  is a singleton, so you can compare it with  /  operators instead of calling
p53103
as(dp53104
g6
V335858
p53105
stp53106
a((dp53107
g2
(lp53108
VYou have references instead of pointers in Java
p53109
aVThey let you modify an object to which you have a reference
p53110
aVFor example, then you pass a  to , the method could call mutating members of the  object, changing the object that has been passed in:
p53111
aVNote that this would not work if you pass  to : although the object is passed by reference, the reference is passed by value
p53112
as(dp53113
g6
V335858
p53114
stp53115
a((dp53116
g2
(lp53117
VYou do not have to divide the commands into separate  arrays - all you need is replacing s with s within the array of characters that you received, and save the positions of the "breaks" in the string
p53118
aVHere is an illustration:
p53119
aVreplace this with
p53120
aVand store pointers to , , and  as pointers to your individual commands
p53121
aVThis is only a demo: in production code you would need to check the return values of  before making assignments
p53122
as(dp53123
g6
V335858
p53124
stp53125
a((dp53126
g2
(lp53127
g9057
aVthe method I just defined can't be called at all
p53128
aVOr am I wrong
p53129
aVCorrect, you're wrong: Java s can implement interfaces, like this:
p53130
aVNow you have access to  inside
p53131
aVOf course you would be forced to implement this method in other values, or in the  itself
p53132
aVIn addition, you could always access such methods, inaccessible through the language, through reflection
p53133
aVAs far as public variables are concerned, it looks like reflection is the only way here
p53134
aVStill, there's no reason to ban this outright (although it's hard to imagine a useful application for them)
p53135
aVDid you use such a functionality somewhere
p53136
aVI did use an  that implemented an interface, with each constant implementing the methods of the interface in its specific way
p53137
as(dp53138
g6
V335858
p53139
stp53140
a((dp53141
g2
(lp53142
VThe problem is that I do not get the exact precision of the answer
p53143
aVInsignificant leading zeros have no effect on the precision of the answer: the answer  is exactly as precise as  or  - it is the same number
p53144
aVSince I intend to use the result as the key in a hashmap ,the non-uniqueness of the result is a problem
p53145
aVIt would be a problem if you were to use such a string as a key in a sorted map, because the keys would sometimes appear out of order
p53146
aVIn a hash map, it is not a problem, because  will drop leading zeros in all numbers, so you should never see numbers like  produced by your procedure
p53147
aVIf such numbers do come from the outside, you can normalize them by parsing and converting to binary before using them as a hash key
p53148
as(dp53149
g6
V335858
p53150
stp53151
a((dp53152
g2
(lp53153
VThis error is a result of the protection level of 's constructor, not  itself
p53154
aVSince the name of the constructor is the same as the name of the class* , the error may be interpreted incorrectly
p53155
aVSince you did not specify the protection level of your constructor, it is assumed to be  by default
p53156
aVDeclaring the constructor  will fix this problem:
p53157
aV* One could also say that constructors have no name, only a type; this does not change the essence of the problem
p53158
as(dp53159
g6
V335858
p53160
stp53161
a((dp53162
g2
(lp53163
VHere is how you approach this problem:
p53164
aVRecall that  and  need  on both sides
p53165
aVRecall that  inverts the value of a
p53166
aVRecall that binary operations  and  convert pairs of s to s
p53167
aVStart with the right side; decide if it's  or
p53168
aVPut the result from the line above in the expression
p53169
aVCompute the result using the truth table for the corresponding logical operator
p53170
aVLet's use your first couple of exercises as examples:
p53171
aVYou know that  is , so the result of  is known right away: it's  - there's no need to do anything else
p53172
aVYou know that  is , so the result of  is not known right away
p53173
aVCompute  (the value is )
p53174
aVCompute  (the value is , because -ing with  is always )
p53175
as(dp53176
g6
V335858
p53177
stp53178
a((dp53179
g2
(lp53180
VYou can do it with LINQ2XML:
p53181
aVHere is how to do it without LINQ2XML:
p53182
as(dp53183
g6
V335858
p53184
stp53185
a((dp53186
g2
(lp53187
VA function that calls itself, directly or indirectly, is called recursive
p53188
aVYour function calls itself, so it is definitely recursive
p53189
aVHere is an example of recursive functions that calls themselves indirectly:
p53190
as(dp53191
g6
V335858
p53192
stp53193
a((dp53194
g2
(lp53195
VSubclassing would have been a better option if you needed to add new data members to the derived
p53196
aVHowever, since the backing storage always remains the same, I think that using a category would be preferable in this specific case
p53197
aVUsing a category would let your keep the singleton  unchanged, along with the piece of code that sets it up
p53198
aVIf you were to subclass , you would need to make an additional change to the code that instantiates the singleton, so that it uses the  instead of the raw
p53199
aVWith a category, this change would be unnecessary
p53200
as(dp53201
g6
V335858
p53202
stp53203
a((dp53204
g2
(lp53205
VYour code exhibits undefined behavior by writing to read-only storage, and also attempting to write past the end of it
p53206
aVYour  idea was a step in the right direction
p53207
aVHowever, you should use  to copy  into the newly allocated memory
p53208
aVIn addition, you need to consider the size of the string that you are planning to append, and the null terminator when calculating the size of the dynamic allocation
p53209
aVObviously, you also need to free all your allocated memory at the end of your program:
p53210
aVDemo on ideone
p53211
as(dp53212
g6
V335858
p53213
stp53214
a((dp53215
g2
(lp53216
VIn the first program you can "see" variable , but not access it, because it is not declared
p53217
aVOnly member variables and  local variables declared before creating an instance of your anonymous class can be accessed:
p53218
aVDemo on ideone
p53219
aVMaking your variable  would work as well:
p53220
aVDemo
p53221
as(dp53222
g6
V335858
p53223
stp53224
a((dp53225
g2
(lp53226
VThe reason why your script prints zero is that in
p53227
aVNET app domains provide a very high level of isolation: when the same class is loaded in two different app domains, the two copies behave completely independently of each other
p53228
aVAmong other things, each copy gets its own set of static variables, each copy runs its static initialization code, and so on
p53229
aVAs the result, communicating between two app domains cannot be done implicitly through static variables or memory sharing constructs*
p53230
aVIt needs to be done explicitly as if you were communicating with code in a different process
p53231
aVIf the amount of data that you must exchange with the script is small, you can use GetData`]2 methods to avoid setting a more complex system of callbacks
p53232
aV* Although it appears that app domains share the virtual address space, I was not able to find a proof of it in any of the standards
p53233
as(dp53234
g6
V335858
p53235
stp53236
a((dp53237
g2
(lp53238
VWill it cause any memory problems
p53239
aVYes, this is undefined behavior, so it may cause a crash
p53240
aVAs I understand the only problem I can face is a stack overflow, right
p53241
aVNo, the problem here is that  will attempt to write past the end of string literal
p53242
aVYou can fix your program as follows:
p53243
aVAlso, with string literals the compiler will do concatenation for you if you simply put them one after the other:
p53244
as(dp53245
g6
V335858
p53246
stp53247
a((dp53248
g2
(lp53249
VThere are two problems in your code:
p53250
aVThe termination happens too late: you return  when  - that's one element past the end
p53251
aVThere is a missing return when  is false: your function ends without returning
p53252
aVTo fix these two problems, change the check of the termination condition, and add the missing return:
p53253
aVNote that you can save one parameter by starting the search at the end of the array and going backward until you reach index zero
p53254
as(dp53255
g6
V335858
p53256
stp53257
a((dp53258
g2
(lp53259
VThe problem with your code was very likely identified by your compiler's warnings: you should see a lot of them, telling you that you are passing a  to a function expecting a
p53260
aVThe  function expects C strings, not simply , meaning that there should be a null terminator after the last character of the string
p53261
aVThat's why you'd get a failure even if you passed a pointer to an individual character
p53262
aVIf you would like to compare individual characters, all you need is a plain :
p53263
as(dp53264
g6
V335858
p53265
stp53266
a((dp53267
g2
(lp53268
VYes, C allows declarations outside of functions
p53269
aVThese declarations define global or static variables (you need a  modifier for that)
p53270
aVRe-formatting your program produces this:
p53271
aVThere's some serious obfuscation going on here, but syntactically it's valid code
p53272
as(dp53273
g6
V335858
p53274
stp53275
a((dp53276
g2
(lp53277
VI assume that your question is about multiple calls that depend on the sequence of prior calls, not independent ones
p53278
aVIn other words, you would like to know about calls with a conversational state
p53279
aVWhen REST system needs to preserve the conversational state between calls, it does so by transferring additional information to the client
p53280
aVEach call from the client carries the conversational state received in the previous calls, enabling the server to stay stateless
p53281
as(dp53282
g6
V335858
p53283
stp53284
a((dp53285
g2
(lp53286
VHere is how you add an  to a header or a
p53287
aVm file:
p53288
aVOpen your storyboard editor on one window
p53289
aVPosition it in such a way that the button is visible
p53290
aVOpen the header or the
p53291
aVm file in another window
p53292
aVPosition the text in such a way so that the piece of code where you want the outlet added is visible
p53293
aVHighlight the button in the storyboard, and hold the Control key down
p53294
aVDrag the button into the header or the
p53295
aVm file
p53296
aVYou will see a blue line as you drag, and a blue marker where the outlet will be added
p53297
aVWhen the marker is at the place where you want it, release the mouse button
p53298
aVThe outlet will be inserted and connected to the storyboard
p53299
aVHere is a post that illustrates this process with a video
p53300
as(dp53301
g6
V335858
p53302
stp53303
a((dp53304
g2
(lp53305
VChecking the expiration date of the card is part of the process of verifying that the user is in possession of the card
p53306
aVEssentially, the month/year of the card's expiration become four "verification digits" in the card's number that one shouldn't be able to guess without seeing the card itself
p53307
aVOne could think of it as a four-digit "password" assigned to the owner by the credit card company
p53308
aVExpiration date has been part of verification scheme before e-commerce came along, when credit cards where used for placing phone orders
p53309
aVOnce this level of protection has been deemed insufficient, credit cards added a CCV number to tighten the verification process even further
p53310
as(dp53311
g6
V335858
p53312
stp53313
a((dp53314
g2
(lp53315
VYou need to remove parentheses:
p53316
aVDemo on ideone
p53317
aVNote that this does not work prior to C++11
p53318
aVAlso note that although the vector in your example is created on the stack, it's content is still created on the heap
p53319
aVIf you want to have the content stored on the stack as well and the size of the content is known at compile time, use  instead of
p53320
as(dp53321
g6
V335858
p53322
stp53323
a((dp53324
g2
(lp53325
VAn array of 32 s in Java takes about eight times the space of a Java
p53326
aVThis is because in most computer architectures the smallest addressable unit of memory is an eight-bit byte, so making an array of "packed" booleans requires additional overhead
p53327
aVIf you would like to use one bit per boolean, use  class instead of an array of booleans
p53328
aVNote that you would get some overhead in addition to the data itself, so using such data structures for only 32 bits may not be economical enough to justify switching away from a simple array
p53329
as(dp53330
g6
V335858
p53331
stp53332
a((dp53333
g2
(lp53334
VYou can do it like this:
p53335
aVThe sequence of the second digits is stored in the array "creatively" named
p53336
aVThe / loop "increments" this array as if it were a base-5 number stored as five separate digits
p53337
aVHere is a demo on ideone
p53338
as(dp53339
g6
V335858
p53340
stp53341
a((dp53342
g2
(lp53343
VYou can implement the  in the  protocol, check the characters in the replacement, replace the text yourself using the substitution that you want, and return
p53344
as(dp53345
g6
V335858
p53346
stp53347
a((dp53348
g2
(lp53349
VThis code closes over a modified variable, so it's not going to do what you want it to do
p53350
aVYou need to add a temporary variable for the value of , like this:
p53351
aVTo create 100 separate lambdas, you can create LINQ expression to call , build constants one by one, and compile the lambdas
p53352
aVHowever, this is unlikely going to give you much performance improvement
p53353
aVHere is how you do it:
p53354
aVHere is a demo on ideone
p53355
as(dp53356
g6
V335858
p53357
stp53358
a((dp53359
g2
(lp53360
VAbsolutely: if  is an  or an array , and  is between 0 and 9, this expression is valid
p53361
aVThe  expression is the pointer arithmetic equivalent of , which is also a valid expression to pass to
p53362
as(dp53363
g6
V335858
p53364
stp53365
a((dp53366
g2
(lp53367
VYou need an explicit comparison to make an expression
p53368
aVYou do not need an explicit comparison with  on s, so the code should be as follows:
p53369
aVNote that  and  is equivalent to
p53370
as(dp53371
g6
V335858
p53372
stp53373
a((dp53374
g2
(lp53375
VThis syntax is indeed identical to the  as far as the type is concerned
p53376
aVHowever, it allows callers to construct an array implicitly by specifying a variable number of  parameters:
p53377
aVOne limitation on this syntax is that arguments like that may appear only at the end of the method's parameter list
p53378
as(dp53379
g6
V335858
p53380
stp53381
a((dp53382
g2
(lp53383
VUnlike  that re-allocates its internals as new ones get inserted, the  does not generally reallocate its nodes on adding new ones
p53384
aVThe difference can be very loosely illustrated as that between an  and a : the first re-allocates to resize, while the second one does not
p53385
aVThat is why setting the initial size of a  is roughly as meaningless as trying to set the initial size of a
p53386
aVThe speed difference is due to the different time complexity of the two containers: inserting  nodes into a  is , while for the  it's , which for 1000000 nodes is roughly 20 times asymptotic difference
p53387
aVAlthough the difference in asymptotic complexity does not translate directly into the timing difference because of different constants dictated by the individual algorithms, it serves as a good way to decide which algorithm is going to be faster on very large inputs
p53388
as(dp53389
g6
V335858
p53390
stp53391
a((dp53392
g2
(lp53393
VYou are very close: all you need is a cast instead of a call of  -
p53394
as(dp53395
g6
V335858
p53396
stp53397
a((dp53398
g2
(lp53399
VThe  is not treated as a compile-time constant expression
p53400
aVReplacing the second declaration with
p53401
aVshould fix the problem
p53402
aVYou may want to replace  with a :
p53403
as(dp53404
g6
V335858
p53405
stp53406
a((dp53407
g2
(lp53408
VYou can use  and  to extract the numbers in a loop, like this:
p53409
aVDemo on ideone
p53410
as(dp53411
g6
V335858
p53412
stp53413
a((dp53414
g2
(lp53415
VSince the introduction of generics in Java 5, the  class is generic on the type that it represents
p53416
aVThis enables constructing object through their  without a cast, and enables other useful idioms
p53417
aVThat's why the compiler can get too smart, and see that it is able to evaluate the expression entirely at compile time: your expression is always
p53418
aVThe compiler gives you the type compatibility error, but that's a direct result of the expression being compile-time constant
p53419
aVOne way to avoid this is through using  as the type
p53420
aVOnce you do that, the compiler can no longer evaluate the type of 's result precisely, thus avoiding the error
p53421
aVAnother way to fix this problem would be casting the return type to a non-generic
p53422
aVor using an intermediate variable of the non-generic kind:
p53423
as(dp53424
g6
V335858
p53425
stp53426
a((dp53427
g2
(lp53428
VThe only error in your method is that you let  run to  inclusive, causing a crash with  when the total is less than 12
p53429
aVChange your code to
p53430
aVto avoid the crash
p53431
aVAnother "point for style" is that instead of writing  it is more conventional to write
p53432
aVFinally, since the intent is to stop calling  after finding the first index where the running total satisfies the condition, you can rewrite the loop with a  instead of a boolean variable:
p53433
as(dp53434
g6
V335858
p53435
stp53436
a((dp53437
g2
(lp53438
VOne way to compare the outputs would be storing the strings as you go, and then compare the results using
p53439
aVSince the two loops are identical, consider making a static method out of them:
p53440
as(dp53441
g6
V335858
p53442
stp53443
a((dp53444
g2
(lp53445
VThe call of  produces an array of s, i
p53446
ag630
ag2311
aVCalling  on such an array produces  - the value that you see in the output
p53447
aVYou need to split ahead of the loop, and pick an element from the split as you advance through the indexes, then do whatever you need to do with each part
p53448
aVIf all you want is placing the parts into individual elements of the  array, perhaps limiting the number of items to , then  should be sufficient
p53449
aVIt is strange that you are replacing  four times as you go through the loop
p53450
aVTaking a guess at what you are trying to accomplish, here is what you could try doing:
p53451
as(dp53452
g6
V335858
p53453
stp53454
a((dp53455
g2
(lp53456
VYou can do it with the  LINQ method like this:
p53457
as(dp53458
g6
V335858
p53459
stp53460
a((dp53461
g2
(lp53462
VThere are two ways of accessing method of anonymous classes:
p53463
aVBy implementing an interface or extending a class, and later calling methods that you implemented in your anonymous class, or
p53464
aVBy using reflection (I assume you know how it's done, but do not want to do it)
p53465
aVJava does not provide a way of capturing the type of the anonymous class statically, e
p53466
ag303
aVin a way similar to C#'s  keyword
p53467
aVIn your case, you can create an abstract type with the  method, and use that class as the base of your anonymous class, like this:
p53468
as(dp53469
g6
V335858
p53470
stp53471
a((dp53472
g2
(lp53473
VIn the comment you provided the code for your  method as follows:
p53474
aVHowever, your  ignores  when you access
p53475
aVWhen the cell from a section that has more rows is displayed, your code will crash
p53476
aVYou should change your code to something like this:
p53477
aVI do not know what's  in your code was, and why you were using it, but the above should eliminate the crash in the  method
p53478
as(dp53479
g6
V335858
p53480
stp53481
a((dp53482
g2
(lp53483
VThe first way of subscripting dictionaries and s will not work prior to Xcode 4
p53484
aV4; the second one will
p53485
aVOther than that, there's no difference: it's a "compiler trick" that transforms the new syntax into the old method call
p53486
as(dp53487
g6
V335858
p53488
stp53489
a((dp53490
g2
(lp53491
VYou can do it like this:
p53492
aVHere is a demo on sqlfiddle
p53493
as(dp53494
g6
V335858
p53495
stp53496
a((dp53497
g2
(lp53498
VIf you must use , you can cast your number to /, and perform the  on the result
p53499
aVThis is quite inefficient, but since  has a high potential of killing indexes anyway, it may work in your scenario:
p53500
aVIf you are looking to use  to match the beginning or the end of the number, you could use integer division and modulus operators to extract the digits
p53501
aVFor example, if you want all nine-digit numbers starting in , search for
p53502
as(dp53503
g6
V335858
p53504
stp53505
a((dp53506
g2
(lp53507
VWhen you insert an object  into , it does not get copied
p53508
aVWhen you modify it outside the , the stored object is modified, too, because it's the same object
p53509
aVRe-assign a new map to  to fix this problem:
p53510
as(dp53511
g6
V335858
p53512
stp53513
a((dp53514
g2
(lp53515
VIt appears that the code snippet from your question is inside a loop that walks multiple values of the  variable, expecting all the bits that you set before the current iteration to be available during the current iteration as you go through the loop
p53516
aVTo address this problem you need to create the  object prior to entering the loop, and keep re-using it, instead of creating it every time that you go through the  statement
p53517
aVMove this line
p53518
aVto outside the loop that is implied in your snippet, or make it a variable in your class to fix the problem
p53519
as(dp53520
g6
V335858
p53521
stp53522
a((dp53523
g2
(lp53524
VAt runtime, there is no difference: Java generics are implemented through Type Erasure, so the same class is used in all implementations
p53525
aVAt compile time, however, the difference is enormous, because it lets you avoid casting every time that you use an object, making you code look a lot cleaner
p53526
aVConsider this example:
p53527
aVThis compiles and runs well, and it also easy to read
p53528
aVIf you wanted to use  instead, the code would not look as clean:
p53529
aVInternally, though, the two code snippets use the same exact implementation for their  object
p53530
as(dp53531
g6
V335858
p53532
stp53533
a((dp53534
g2
(lp53535
VThere is no such access modifier: the closest modifier is , but the unit of protection is the assembly in which the class resides, not its namespace
p53536
aVOne could argue that it is possible to achieve similar level of control using , because both kinds of restriction keep outsiders from accessing the implementation details of your library
p53537
aVThe only person to whom it makes a difference is you, the writer of the library, and you are in full control of what to expose and what to hide anyway
p53538
aVEssentially, it means that if you do not want to use a class outside its namespace, simply refrain from using it; if the class is , nobody else will be able to use that class either
p53539
as(dp53540
g6
V335858
p53541
stp53542
a((dp53543
g2
(lp53544
VYou can reduce the amount of code that looks like conditional compilation to Xcode by using a conditionally compiled macro, like this:
p53545
aVWith this macro in hand, you can rewrite your  as follows:
p53546
aVThe code would conditionally compile into the same output, but Xcode would think it's a regular
p53547
aVThis also looks cleaner to the reader
p53548
as(dp53549
g6
V335858
p53550
stp53551
a((dp53552
g2
(lp53553
VWill the approach that I have mentioned work to find the minimum sum
p53554
aVYes, it will
p53555
aVYou can re-state the problem of finding the minimum sum as finding a negative sum with the largest absolute value
p53556
aVWhen you switch the signs of your numbers and keep the rest of the algorithm in place, that's the number that the algorithm is going to return back to you
p53557
aVI know there is an issue if all the elements are positive
p53558
aVNo, there's no issue: consider the original Kadane's algorithm when all elements are negative
p53559
aVIn this case the algorithm returns an empty sequence for the sum of zero - the highest one possible under the circumstances
p53560
aVIn other words, when all elements are negative, your best solution is to take none of them
p53561
aVYour modified algorithm is going to do the same in case when all numbers are positive: again, your best solution is to not take numbers at all
p53562
aVIf you add a requirement that the range returned back from the algorithm may not be empty, you could modify the algorithm slightly to find the smallest positive number (or the greatest negative number) in case when Kadane's algorithm returns an empty range as the optimal solution
p53563
as(dp53564
g6
V335858
p53565
stp53566
a((dp53567
g2
(lp53568
VWould something using  work
p53569
aVA slightly modified version of it would work:  (you need an  at the end, and you need a reluctant quantifier  in place of an optional mark )
p53570
aVHowever it could be inefficient because of backtracking
p53571
aVSomething like this would be better:
p53572
aVThis expression starts by finding , taking as many non- characters as it could, and capturing the  before stopping
p53573
aVParentheses denote a capturing group
p53574
aVUse regex API to extract it:
p53575
aVThis prints  (demo)
p53576
as(dp53577
g6
V335858
p53578
stp53579
a((dp53580
g2
(lp53581
VYou do not need an  in this case: you can write the same condition like this:
p53582
aVThis test is successful when the test string  is contained in the list specified in the call to , which conveniently takes a variable number of parameters
p53583
as(dp53584
g6
V335858
p53585
stp53586
a((dp53587
g2
(lp53588
VThe warning is coming from the C compiler
p53589
aVIt is telling you that  is not a known escape sequence in C
p53590
aVSince this string is going to a regex engine, you need to double-escape the slash, like this:
p53591
aVThis regex would match a string with an optional  extension, with  being optional
p53592
aVHowever, the dot  is required
p53593
aVIf you want the dot to be optional as well, put it inside the parentheses, like this:
p53594
aVNote that you can avoid escaping the individual metacharacters by enclosing them in square brackets, like this:
p53595
as(dp53596
g6
V335858
p53597
stp53598
a((dp53599
g2
(lp53600
VIn general, if the object that you are returning is not used anywhere else outside of the return value of your method or a group of similar methods, it is a good indication that you should refactor
p53601
aVWhen you need to create a special class simply to be used as a return value of a method, it means that you are working around C#'s inability to return multiple values from a method, so the  keyword may be a very good option for you
p53602
aVOn the other hand, if you use the multi-part return value in other places, such as storing them in collections or passing as arguments to other methods, there's probably no need to refactor, because the return object is meaningful
p53603
aVCompare these two methods:
p53604
aVor
p53605
aVThe first case introduces a special  class that provides the value and an indicator that the value was found in the dictionary
p53606
aVThere is rarely, if ever, a reason to store or use  objects outside the call to , so the second option is better
p53607
aVNot surprisingly, it is the second option that the designers of the
p53608
aVNET collections library have implemented
p53609
as(dp53610
g6
V335858
p53611
stp53612
a((dp53613
g2
(lp53614
VSuppose I am on the console on a linux machine
p53615
aVWhat would I type into the black box of wonders in order to create a makefile so that I could insert the rules
p53616
aVYou would type the name of your favorite text editor (or an editor installed on your machine, such as )
p53617
aVType , press Enter, and wait for the  to open
p53618
aVIn the  press I to enter the input mode, type up the content of your makefile, press ESC, type , and press Enter again
p53619
aVYou are done
p53620
aVNow that you are back on the command line, type  to double-check that you entered everything correctly
p53621
aVOne thing to keep in mind when typing up your makefile is the tabs: they are optional in your C programs, but in makefiles they are mandatory
p53622
aVYou cannot replace them with several spaces - it must be a  character in the file in order for  to interpret your file properly
p53623
as(dp53624
g6
V335858
p53625
stp53626
a((dp53627
g2
(lp53628
VYou need to add , , or  to it, like this:
p53629
aVYou cannot leave un-aggregated items in a group by query in SQL Server, even though you know that there would be at most one non-null entry for each item
p53630
as(dp53631
g6
V335858
p53632
stp53633
a((dp53634
g2
(lp53635
VAccording to the documentation of the  class,
p53636
aVA keyed archive differs from a non-keyed archive in that all the objects and values encoded into the archive are given names, or keys
p53637
aVIn order to archive elements of a and give keys to them  would need metadata to know where each field of a  is located, and what are the names of these fields
p53638
aVThe  stored with  gives it enough information about the layout of a , but the information about the names of each field is missing
p53639
aVSince there is no metadata about the names of the fields in a , it would be impossible to archive the data in such a way as to ensure proper un-archiving
p53640
aVThat is why  must refuse to archive s with embedded C s
p53641
as(dp53642
g6
V335858
p53643
stp53644
a((dp53645
g2
(lp53646
VDeclare your property without , like this:
p53647
aVWith this definition Xcode would give you the expansion below:
p53648
as(dp53649
g6
V335858
p53650
stp53651
a((dp53652
g2
(lp53653
VOf course you can:  property of the  object lets you access the match in the form of a  by accessing the  property of the corresponding group
p53654
aVFor example, you can do this to capture the value of the expected output from your example:
p53655
aVThe above prints
p53656
aVHere is a demo on ideone
p53657
as(dp53658
g6
V335858
p53659
stp53660
a((dp53661
g2
(lp53662
VHere is one way to do it without conditionals:
p53663
aVDemo on ideone
p53664
aVEDIT : Your attempt was pretty close, too: here it is, modified using the same idea to print s at the end as the approach above:
p53665
aVDemo on ideone
p53666
as(dp53667
g6
V335858
p53668
stp53669
a((dp53670
g2
(lp53671
VYou can use the same exact trick in Objective C:
p53672
as(dp53673
g6
V335858
p53674
stp53675
a((dp53676
g2
(lp53677
VHere is a straightforward solution performing a recursive descent parsing:
p53678
aVThis solution reuses the implementation of  to built the name of the variable that you would like to replace by calling itself with the  flag set to
p53679
aVTop-level invocation does not stop on reaching the  symbol, letting you use it unescaped
p53680
aVHere is a demo on ideone
p53681
as(dp53682
g6
V335858
p53683
stp53684
a((dp53685
g2
(lp53686
VThe reason line 16 does not work is the same why this much simpler example would not work:
p53687
aVWhat this means is that you need to use only compile-time constant expressions in the initializers
p53688
aVC does not consider variables compile-time constants, even the  ones (C++, on the other hand, considers  variables compile-time constants)
p53689
as(dp53690
g6
V335858
p53691
stp53692
a((dp53693
g2
(lp53694
VThe  method of  returns an , not an
p53695
aVPassing an  to a method that takes  is incorrect: the value at the corresponding memory location would not be valid
p53696
aVYou should change the  method as follows:
p53697
as(dp53698
g6
V335858
p53699
stp53700
a((dp53701
g2
(lp53702
VIn SQL  takes precedence over  in the same way as multiplication takes precedence over addition, so you need to use parentheses to force the precedence that you want:
p53703
aVYour original statement will take the long chain of s, and return everything matched by any of its individual condition, along with the row that has the desire  and
p53704
as(dp53705
g6
V335858
p53706
stp53707
a((dp53708
g2
(lp53709
VUsing  is just one half of the puzzle
p53710
aVThe other half is getting the corresponding rows
p53711
aVYou can do it like this:
p53712
as(dp53713
g6
V335858
p53714
stp53715
a((dp53716
g2
(lp53717
VYou are looking for an algorithm to find the cardinality of a set intersection
p53718
aVDepending on your set representation, you could choose different ways of doing it
p53719
aVThe most performant representation for this would be using bits in an integer, but if the number of possible interests exceeds 64 this may not be easy to implement
p53720
aVA straightforward way of implementing it would be with , like this:
p53721
as(dp53722
g6
V335858
p53723
stp53724
a((dp53725
g2
(lp53726
VYou cannot get that structure with a single  - you need an  of  objects
p53727
aVHere is how you can do it:
p53728
as(dp53729
g6
V335858
p53730
stp53731
a((dp53732
g2
(lp53733
VYou can use a simple continuation pattern with a  variable:
p53734
aVThis chain of execution will stop as soon as  returns a
p53735
aVNo further  calls would be performed due to short-circuiting of the  operator
p53736
aVMoreover, optimizing compilers are smart enough to recognize that setting  to  is a one-way street, and insert the missing  for you
p53737
aVAs the result, the performance of the code above would be identical to that of a /, only without a painful blow to its readability
p53738
as(dp53739
g6
V335858
p53740
stp53741
a((dp53742
g2
(lp53743
VYou declare a class  vs
p53744
aVmake its constructor  for different reasons:
p53745
aVYou make class  to indicate that the class is not designed for inheritance
p53746
aVYou make all constructors  to give the class the control over its instantiation
p53747
aVIn other words, using  controls inheritance, while using  constructors control instantiation
p53748
aVNote that declaring constructors  disables inheritance only from the outside
p53749
aVInside the class, you may still inherit it with a named or an anonymous derived class
p53750
aVWhen you make all constructors of the class  you need a  method that is public to make the class usable
p53751
aVOne common kind of the  method is factory method: you can let the users of your class call private constructors indirectly through a public static method
p53752
as(dp53753
g6
V335858
p53754
stp53755
a((dp53756
g2
(lp53757
VJava does not let you define non-final static fields inside function-local inner classes
p53758
aVOnly top-level classes and static nested classes are allowed to have non-final static fields
p53759
aVIf you want a  field in your  class, put it at the  class level, like this:
p53760
as(dp53761
g6
V335858
p53762
stp53763
a((dp53764
g2
(lp53765
VYour algorithm does not work because you need to update  as well:
p53766
aVNote that  is another way of saying , so this looks cleaner:
p53767
as(dp53768
g6
V335858
p53769
stp53770
a((dp53771
g2
(lp53772
Vhow can i fix that to work with non-special characters as well
p53773
aVPut square brackets around your characters, instead of escaping them
p53774
aVMake sure that if  is included in your list of characters, you need to make sure it's not the first character, or escape it separately if it's the only character on the list
p53775
aVDashes also need special treatment - they need to go at the beginning or at the end of the regex
p53776
as(dp53777
g6
V335858
p53778
stp53779
a((dp53780
g2
(lp53781
VThere is no reason to use property declarations with both  and  - according to Apple's documentation, the two are synonyms:
p53782
aVThe keywords  and  are introduced as new declared property attributes, as shown in the following examples
p53783
as(dp53784
g6
V335858
p53785
stp53786
a((dp53787
g2
(lp53788
VYour solution is nice, but it is going to break if another part of the file name, say, part of its directory path, has an underscore
p53789
aVYou should change it slightly to avoid this problem:
p53790
aVWhen your solution is nice, robust, and easy to understand, there's no reason to go for a shorter solution
p53791
aVOf course you can use regular expression, but the resulting one-line solution is far less readable:
p53792
aVHere is a demo of this solution on ideone
p53793
as(dp53794
g6
V335858
p53795
stp53796
a((dp53797
g2
(lp53798
VWith four bits, the sixteen bit combinations are interpreted as follows:
p53799
aVThe numbers that you set correspond to  (1),  (-8) and  (-1)
p53800
as(dp53801
g6
V335858
p53802
stp53803
a((dp53804
g2
(lp53805
VSince you are using , you need to divide it by  to obtain the result expressed in seconds
p53806
aVTo get fractions, cast  to  before the division:
p53807
aVIf you want to measure the time of a single iteration, change the loop as follows:
p53808
as(dp53809
g6
V335858
p53810
stp53811
a((dp53812
g2
(lp53813
VUse of  is somewhat misleading, because the value of  does not play into the answer: you always get the equivalent of , which appears to be 64 bits or 8 bytes on your computer
p53814
aVRecall that  is a compile-time operation; only the type of the parameter matters, but not its value
p53815
aVThe number of digits in a float's representation is often a meaningless value, because in general the representation is imprecise
p53816
aVOnly the number of digits before the decimal separator can be determined reliably; the digits after the separator are usually truncated to the number that you set to your liking
p53817
aVI am needing to know the length of the float because i am trying to make a table table of logarithms like this
p53818
aVRather than finding out the size of your s, force them all to a specific length
p53819
aVSpecify width and precision in your calls of  to make sure that everything is formatted to the same length, and looks good in a table
p53820
as(dp53821
g6
V335858
p53822
stp53823
a((dp53824
g2
(lp53825
VSince the collection returned by  is immutable, the entries in this collection need not be "materialized"
p53826
aVIn other words, all that is needed is a space for a single object of type ; everything else is an implementation of the collection interface that pretends to have a collection of  objects, but in reality has only one object that it returns  times
p53827
aVThis may prove to give you a lot of improvement in space when the collection you are creating is large: in fact, the larger the collection, the bigger is your savings compared to a real collection that you initialize with a  loop
p53828
as(dp53829
g6
V335858
p53830
stp53831
a((dp53832
g2
(lp53833
VCan someone confirm whether this is indeed right
p53834
aVYes, one could construct a very crude benchmark to demonstrate that operations on primitives are at least an order of magnitude faster:
p53835
aVThis produces the following results on ideone:
p53836
aVAs you can see, the primitives are at least ten times faster, even in this very crude test where measuring the time takes a significant portion of the time
p53837
aVwhy does the operation cost done on wrapper classes will be higher than their primitive counterpart
p53838
aVThis is easy to explain: in addition to the operation itself that is performed on the primitive, the operation on the wrapper requires these operations:
p53839
aVAccessing the content of the wrapped type (i
p53840
ag630
aVanother memory read),
p53841
aVConstruction of a new wrapper object, and
p53842
aVImplicitly, unused wrappers from previous runs contribute to the time taken by the garbage collector
p53843
aVThe allocation operation is particularly expensive compared to the arithmetic operation performed on the value inside the primitive
p53844
as(dp53845
g6
V335858
p53846
stp53847
a((dp53848
g2
(lp53849
VHere is what you do (I wouldn't show you any code to avoid spoiling an exercise for you)
p53850
aVFirst, recall that in order to be recursive your function needs to call itself
p53851
aVNext, consider these two points:
p53852
aVWhen the  parameter is equal to zero, the return value of  must be zero
p53853
aVWhen the  parameter is not zero, consider the return value of  for  and ; let's call it
p53854
aVThe return value of the current  will be equal to  if  is equal to , or to  when  is not equal to
p53855
aVWhen you make your code out of this description, observe how you have an  at the beginning of your recursive function
p53856
aVThis  splits your code into the base case () and the recursive step (computing the result based on a recursive call)
p53857
aVThis is a common structure of recursive functions: you will have to reproduce this structure every time you write recursive code
p53858
as(dp53859
g6
V335858
p53860
stp53861
a((dp53862
g2
(lp53863
VYou do not need LINQ for that: rather than creating a sorted copy, you can sort your list in place by calling  method on it:
p53864
aVThe order is implicitly ascending
p53865
aVIf you need to change that, supply a custom comparer
p53866
as(dp53867
g6
V335858
p53868
stp53869
a((dp53870
g2
(lp53871
VTo clear a bit, you need to  with a complement value, i
p53872
ag630
aVthe inversion of , which is
p53873
aVYou can have the compiler compute the value for you by using
p53874
aVNote that you can use  and  for that:
p53875
as(dp53876
g6
V335858
p53877
stp53878
a((dp53879
g2
(lp53880
VIt's there for historical reasons: it's there since JDK 1
p53881
aV0, while the Java class  where this method logically belongs has not been introduced until Java 1
p53882
aV2 release
p53883
as(dp53884
g6
V335858
p53885
stp53886
a((dp53887
g2
(lp53888
VAssuming that your real class  overrides  and , all you need is to add :
p53889
as(dp53890
g6
V335858
p53891
stp53892
a((dp53893
g2
(lp53894
VStart with understanding the code from the answer (see my comments below):
p53895
aVLet's modify it to suit our purposes:
p53896
aVYou can iterate the result now, and print all indexes of :
p53897
as(dp53898
g6
V335858
p53899
stp53900
a((dp53901
g2
(lp53902
VAdd  object to your class, and change your method as follows:
p53903
aVThe idea is to pre-generate the entire list, and store its iterator for future use
p53904
aVBefore entering the method you check if the  iterator has been prepared
p53905
aVIf it has been prepared, grab the next item off of it if it's available; otherwise, return zero
p53906
aVIf the list has not been prepared yet, run your algorithm, and add the results to a temporary list
p53907
aVOnce the list is ready, grab its iterator, and use it for subsequent invocations
p53908
as(dp53909
g6
V335858
p53910
stp53911
a((dp53912
g2
(lp53913
VThis is a hack that lets you emulate the functionality of  when there is no support by the compiler: it exploits the fact that the address of the  equals its offset when the base address is set to zero
p53914
aVConsider this example:
p53915
aVIf  is allocated at the address , then the address of  would be , and the address of  would be
p53916
aVHowever, if the base address is zero (which is not allowed by the standard), then the address of  would be zero, and the address of the count would be
p53917
aVCasting these addresses to  gives you the offset of the corresponding members
p53918
as(dp53919
g6
V335858
p53920
stp53921
a((dp53922
g2
(lp53923
VThen wouldn't it be redundant to implement List as well as extend AbstractList
p53924
aVYes, it is 100% redundant
p53925
aVHowever, Java implementors added interfaces very consistently in all public implementation of the collections library:
p53926
aVand  extend  which implements , and then implement  themselves
p53927
aVand  extend  which implements , and then implement  themselves
p53928
aVand  extend  which implements , and then implement  themselves
p53929
aVMy understanding is that they did so for documentation purposes:  the authors wanted to show that  is primarily a ; the fact that  extends  is a less significant detail of its implementation
p53930
aVSame goes for the other public collection types
p53931
aVNote that  class is not publicly visible, so its authors did not care to include  explicitly
p53932
aVAs far as the failed conversion goes, this should come as no surprise, because the inner class  and the public class  are unrelated to each other
p53933
as(dp53934
g6
V335858
p53935
stp53936
a((dp53937
g2
(lp53938
VThe proof is relatively straightforward: consider set  as a sorted list
p53939
aVWe can prove it with a loop invariant
p53940
aVAfter each iteration of the algorithm,  contains the smallest element of  that ends an ascending subsequence of length  in the sub-array from zero to the last element of  that we have considered so far
p53941
aVWe can prove this by induction:
p53942
aVAfter the first iteration, this statement is true, because  will contain exactly one element, which is a trivial ascending sequence of one element
p53943
aVEach iteration can change the set in one of two ways: it could expand it by one in cases when  is the largest element found so far, or replace an existing element with , which is smaller than the element that has been there before
p53944
aVWhen an extension of the set occurs, it happens because the current element  can be appended to the current LIS
p53945
aVWhen a replacement happens at position , the index of , it happens because  ends an ascending subsequence of length , and is smaller than or is equal to the old  that used to end the previous "best" ascending subsequence of length
p53946
aVWith this invariant in hand, it's easy to see that  contains as many elements as the longest ascending subsequence of  after the entire  has been exhausted
p53947
as(dp53948
g6
V335858
p53949
stp53950
a((dp53951
g2
(lp53952
VYou should not use the label from the cell, because it is part of the view
p53953
aVAlthough the cell is correct, its visuals may be disposed by the time the  is called
p53954
aVThe MVC way of doing this would be querying the underlying data source for the data at the cell's row, and use that data instead of the label
p53955
aVHere is what I mean: somewhere in the implementation of  you have code that looks like this:
p53956
aVYou should replicate that code inside your  method:
p53957
as(dp53958
g6
V335858
p53959
stp53960
a((dp53961
g2
(lp53962
V is a container with the defined order: its order of iteration corresponds to the order in which the items have been added to the list
p53963
aVSince your  loop terminates as soon as it finds an apple of the requested color, the first red apple will be returned
p53964
aVOf course if the list contains no red apples,  will be returned
p53965
aVThe same is true about other kinds of lists (e
p53966
ag303
aVan array list)
p53967
aVHowever, other containers may behave differently
p53968
aVFor example,  would order its elements in a way that may be different from the insertion order;  would return its elements in an arbitrary order, and so on
p53969
as(dp53970
g6
V335858
p53971
stp53972
a((dp53973
g2
(lp53974
VThe results that you get are correct: in C#
p53975
aVNET s are not packed - each one occupies a single byte, so the total is 16515072*5=82MB
p53976
aVIf you would like to pack the booleans into bits, you can use a single  for storing the values, and use bit operations for your getters and setters:
p53977
aVContinue using powers of 2 for bit masks of the remaining properties - , , , and so on
p53978
as(dp53979
g6
V335858
p53980
stp53981
a((dp53982
g2
(lp53983
VJava lets you refer to an outer class without fully specifying its name, like this:
p53984
aVHad nesting of classes allowed the use of identical names at any level of hierarchy, referencing by unqualified name would have been impossible
p53985
aVIt is this ability that the Java compiler is trying to preserve by prohibiting nested declarations to collide with names of their outer classes
p53986
as(dp53987
g6
V335858
p53988
stp53989
a((dp53990
g2
(lp53991
VDesigner's estimate of the likelihood of something needing to change is not a reliable criterion to make a decision, because real-world use of our programs has its peculiar ways of proving us wrong
p53992
aVInstead of asking yourself "how likely is something to change
p53993
aV, ask yourself "does it make sense for an end-user to make a change
p53994
aVIf the answer is "yes", make it user-changeable; otherwise, make it changeable only through your code
p53995
aVA particular mechanism through which you make something changeable (a database, a configuration file, a custom XML file, and so on) does not matter much
p53996
aVAn important thing is to have good defaults for settings that are missing, so that your end-users would have harder time breaking your system by supplying partial configurations
p53997
as(dp53998
g6
V335858
p53999
stp54000
a((dp54001
g2
(lp54002
VSince your set contains s, dereferencing the iterator gives you a , not its first character
p54003
aVUse operator  instead:
p54004
as(dp54005
g6
V335858
p54006
stp54007
a((dp54008
g2
(lp54009
VYou can combine conditions using the usual Boolean operators
p54010
aVYour solution is missing  in the second part of the condition:
p54011
aVYou can simplify this further, because checking for a nullable  to be  or  is equivalent to checking for it not being :
p54012
as(dp54013
g6
V335858
p54014
stp54015
a((dp54016
g2
(lp54017
VYes, this is 100% legal: C standard specifies that the pointer to a  must always equal to the pointer to the initial member of that
p54018
as(dp54019
g6
V335858
p54020
stp54021
a((dp54022
g2
(lp54023
VThere is no way of passing a type to a C function, because a type is a compile-time concept
p54024
aVOnce the compiler is finished, there's no type to talk about: the knowledge of the types is "baked into" the binary code the compiler generates, with no additional metadata to make available to your program
p54025
aVInstead of passing a type, you can pass a size, and do pointer math by yourself
p54026
aVTake  or  functions as an example: they both work on untyped arrays as if they knew the exact type
p54027
aVThe "magic" that lets these functions do it is in the  parameter, and a function pointer taking  arguments
p54028
aVYou can model your API in the same way
p54029
aVYou are taking the  as a parameter already, so what's remains is the pointer math
p54030
aVConvert the pointer to  so that adding  would advance the pointer to the next element of the "type", perform the arithmetics to advance the pointer to your target, and then convert the pointer back to
p54031
as(dp54032
g6
V335858
p54033
stp54034
a((dp54035
g2
(lp54036
VThere's nothing wrong in putting a check like that in your own code to save on an equality check when you know that the comparison is going to fail most of the time, but putting this into the general code has a chance to degrade the overall performance of your system for two reasons:
p54037
aVComputing hash code for the first time takes some CPU cycles; when  method is called outside of the context of a hash container, the CPU cycles needed to compute the hash code would be wasted
p54038
aVWhen s are used as keys in a hash container, the container establishes the equality of hash codes before proceeding with the equality check, so the comparison of hash codes inside the  method becomes redundant
p54039
as(dp54040
g6
V335858
p54041
stp54042
a((dp54043
g2
(lp54044
VThe problem with this code is that it's undefined behavior to write to a pointer that has not been initialized:  has not been assigned a memory block into which you could copy the string, so  writes to memory that your program does not own
p54045
aVFixing this code is straightforward: allocate memory before copying, like this:
p54046
aVOf course you need to  the memory to avoid the memory leak
p54047
as(dp54048
g6
V335858
p54049
stp54050
a((dp54051
g2
(lp54052
VWhat's going on here is a C type cast: you are telling the compiler that you know that your 's  is of type , and that you know that it's OK to invoke methods of  here, even though these methods are not part of the 's interface
p54053
as(dp54054
g6
V335858
p54055
stp54056
a((dp54057
g2
(lp54058
VIf I'm not wrong, for loops make the program "freeze" until its done, so that's probably why this code won't work
p54059
aVYou are absolutely right: if you run your loop on the UI thread, the UI is not going to update until the loop is done, so this approach is not viable
p54060
aVAny suggestions
p54061
aVYou need to do the work in a background thread, and update the  as you go
p54062
aVYou wouldn't be able to set the value directly from a different thread, so you would need to use a delegate and a special dispatch mechanism
p54063
aVHere is an answer that shows how this is done in WPF and Windows Forms
p54064
as(dp54065
g6
V335858
p54066
stp54067
a((dp54068
g2
(lp54069
VYes, there is an elegant solution: use the five-argument overload of  method:
p54070
aVThe first three arguments supply the string, the offset into that string from which to start encoding, and the number of characters to encode
p54071
aVThe last two arguments supply the destination array, and the offset into it from which to start writing
p54072
as(dp54073
g6
V335858
p54074
stp54075
a((dp54076
g2
(lp54077
VLINQ's equivalent of the SQL's  "thingy" is a predicate that always returns true:
p54078
aVChange your default method as follows:
p54079
as(dp54080
g6
V335858
p54081
stp54082
a((dp54083
g2
(lp54084
VThere are two relatively easy solutions:
p54085
aVUse a  to construct  classes, or
p54086
aVUse reflection to locate the class named according to your convention
p54087
aVHere is how you can implement the first solution:
p54088
aVHere is how you can implement the second solution:
p54089
aVThe advantage of the first method is its simplicity; the advantage of the second method is its ability to pick up additional implementations of  as they become available, without requiring any further modifications to your code
p54090
as(dp54091
g6
V335858
p54092
stp54093
a((dp54094
g2
(lp54095
VThere is no point in fighting a naturally occurring data structure prematurely: if your data has five dimensions to it when you think about it in your mind, then modeling it with a 5D array in your code is your best strategy
p54096
aVThe only reason to go for a different data structure is if your 5D array happens to be very sparse: by their nature, arrays pre-allocate space eagerly, resulting in sub-par use of memory on very sparse structures
p54097
aVMoreover, that seemingly sub-par use of space may be more than paid for by better performance: arrays represent an extreme point in space-for-speed tradeof due to their simplicity, so "wasting" a few megabytes of space in return for some trillions of CPU cycles may not be a bad deal
p54098
as(dp54099
g6
V335858
p54100
stp54101
a((dp54102
g2
(lp54103
VSince the size of the data is fixed, one simple way of writing this entire array into a file is using the binary writing mode:
p54104
aVThis writes out the whole 2D array at once, writing over the content of the file that has been there previously
p54105
as(dp54106
g6
V335858
p54107
stp54108
a((dp54109
g2
(lp54110
VYou cannot load 1,000,000 rows quickly, because that's a lot of data to get from the RDBMS's disk through the network into the memory of your application
p54111
aVHowever, it does not mean that your application is bound to be slow: as long as you give end-users a perception that the data is there as soon as they are ready to see it, they would consider your application very fast
p54112
aVThe users would think that you loaded the data quickly if you load the data for the top few thousand rows on the initial page first, then load the remaining data for the initial page, and only then start loading the data for other tabs
p54113
aVAs you go tab-by-tab in the background, load only the top hundred rows in each tab, so that when end-users click the tab, they see that the data is there
p54114
aVYour code should load the rest of the data only when the user opens the tab: chances are, they never will open some of the tabs, helping your application save both on the processing and on the data transfer
p54115
as(dp54116
g6
V335858
p54117
stp54118
a((dp54119
g2
(lp54120
VThere are three errors and an inefficiency in your code
p54121
aVThe first error is that you are trying to print a 2D array in a single statement
p54122
aVYou cannot do that - you need two nested loops for that:
p54123
aVThe second error is that  is not a newline character: you need a backslash
p54124
aVThe third error is that you are trying to print a string using a  format: you should use  without the , and put the space inside the format string:
p54125
aVThe inefficiency is that you are constructing the result string with concatenations called in a loop
p54126
aVThis creates lots of temporary objects
p54127
aVYou should  class instead
p54128
as(dp54129
g6
V335858
p54130
stp54131
a((dp54132
g2
(lp54133
VJava has no  statement (although the  keyword is among the reserved words)
p54134
aVThe only way in Java to go back in code is using loops
p54135
aVWhen you wish to exit the loop, use ; to go back to the loop's header, use
p54136
as(dp54137
g6
V335858
p54138
stp54139
a((dp54140
g2
(lp54141
VThe answer depends on the meaning of :
p54142
aVIf  represents a constant, essentially giving a name to a numeric value, than a public final field is better
p54143
aVIf  represents a value that could change as the result of user's actions (i
p54144
ag630
aVif it is part of configuration) then a private variable with a getter is preferable
p54145
aVThe second approach gives you more flexibility, should you decide to refactor your class in the future: it lets you initialize the private  at a later time, or replace it with some other way of obtaining a value, e
p54146
ag303
aVby computing it from other values, or reading from another object
p54147
as(dp54148
g6
V335858
p54149
stp54150
a((dp54151
g2
(lp54152
VYou should put the code in the  method
p54153
aVFirst, scroll the target cell into the view to make it visible:
p54154
aVThen, get the cell into which you want to direct the input:
p54155
aVNow cast the cell to the cell of your type, grab its , make a selection, and finally give it focus
p54156
as(dp54157
g6
V335858
p54158
stp54159
a((dp54160
g2
(lp54161
VYou can put the  expression into the query, and replace  with a , like this:
p54162
as(dp54163
g6
V335858
p54164
stp54165
a((dp54166
g2
(lp54167
VI can't convert it to anything usable
p54168
aVOf course you can
p54169
aVThe idea behind the  class is to give a common superclass to the built-in numeric types
p54170
aVIt gives you more flexibility in passing the numbers around, so that the decision on what type to use could be postponed until the moment when the numeric value is needed
p54171
aVThis becomes especially useful when the code for the data retrieval is separate from the code that consumes the numeric data, because the retrieval code can operate in terms of untyped numbers, without concerns about the specific type
p54172
as(dp54173
g6
V335858
p54174
stp54175
a((dp54176
g2
(lp54177
VHash codes do not need to be different for different objects
p54178
aVThe only requirement is that they must be the same for equal objects
p54179
aVIf it is a concern that your  inner classes produce identical hash codes, you could override the  method in your inner class to provide hash codes that suit your needs better
p54180
aVOf course you would need to override  as well to supply the matching logic to both methods:
p54181
as(dp54182
g6
V335858
p54183
stp54184
a((dp54185
g2
(lp54186
V is a C# synonym for the  class
p54187
aVAn instance of an  is an instance of the  class
p54188
aVAll classes extend , any instance of a class is an instance of
p54189
as(dp54190
g6
V335858
p54191
stp54192
a((dp54193
g2
(lp54194
VYou should not be removing items from the list as you go, because doing so invalidates the iterator of the  loop
p54195
aVYou can do what you want without a loop:
p54196
aVRecall that  lets you operate on the entire collection as a whole
p54197
aVThe  would be called on every student ID (I tried to follow your example; you do not need to base the selection solely on the ), and all students who pass  would be removed
p54198
aVNote that if  is an EF/LINQ2SQL context, you would need to add  before checking conditions using your C# code:
p54199
as(dp54200
g6
V335858
p54201
stp54202
a((dp54203
g2
(lp54204
VYes, you can make a copy of your  one field at a time
p54205
aVYou can also do it in a single shot:
p54206
aVDoing it that way has the advantage of not having to revisit the copying code each time you modify the structure of
p54207
as(dp54208
g6
V335858
p54209
stp54210
a((dp54211
g2
(lp54212
VIf you need to make a calculation based on a value of , use ternary operator in C#, or the  expression in VB
p54213
aVNET:
p54214
aVExpressions like that make your intentions clear to the reader, which improves readability even in languages that assign Booleans specific numeric values (e
p54215
ag303
aVC or C++)
p54216
as(dp54217
g6
V335858
p54218
stp54219
a((dp54220
g2
(lp54221
VThis design implements a very simple factory method pattern: the users would call , rather than calling  followed by
p54222
aVTo complete the factory method pattern implementation, make the constructor , and return the constructed object by interface:
p54223
as(dp54224
g6
V335858
p54225
stp54226
a((dp54227
g2
(lp54228
VA simple but not necessarily the most optimal way of querying this is using :
p54229
aVDemo on SqlFiddle
p54230
as(dp54231
g6
V335858
p54232
stp54233
a((dp54234
g2
(lp54235
VSince in all three of your conditions you check if a particular location
p54236
aVdoes not exist in  or  or
p54237
aVyou can collect all these locations in a single  for a quick check:
p54238
aVWith  in hand, you can build your condition as follows:
p54239
as(dp54240
g6
V335858
p54241
stp54242
a((dp54243
g2
(lp54244
VThe value of  does get there, but that happens after you have printed the default
p54245
aVThe current value of  is printed in the initializer; by the time you assign the property , the initializer is done
p54246
aVYou can check that the value does get there by adding a method to show the current value of the property:
p54247
aVNow change your code that creates  as follows:
p54248
as(dp54249
g6
V335858
p54250
stp54251
a((dp54252
g2
(lp54253
VMultiplying by  forces the  into a
p54254
aVYou can do the same with an explicit cast
p54255
as(dp54256
g6
V335858
p54257
stp54258
a((dp54259
g2
(lp54260
VThere's not much difference between setting a variable to an existing object vs
p54261
aVsetting it to
p54262
aVIn both cases, the object that has been referenced by that variable before would get one step closer to becoming eligible for garbage collection, regardless of the new value stored in that variable being a  or a different object
p54263
aVThe rest of the assignment goes in the same way, too: CLR does not maintain reference count, so nothing special needs to happen specifically at the point when the assignment is made
p54264
aVIt may be beneficial to store a default object in place of a  to avoid extensive  checking at runtime, though: doing so simplifies the code, and reduces the need for branching at runtime
p54265
as(dp54266
g6
V335858
p54267
stp54268
a((dp54269
g2
(lp54270
VYou have an off by one error, and  is not an index, it's the stored value:
p54271
as(dp54272
g6
V335858
p54273
stp54274
a((dp54275
g2
(lp54276
VGiven that you're asking about  I am assuming that  is defined as
p54277
aVThe  is a token-pasting operator, it connects two tokens to its left and to its right together, producing a single token
p54278
aVWhen you write , preprocessor converts that to , which is a regular function call
p54279
aVsince HE is a enum, should HE translate to 0
p54280
aVThat's a very good question
p54281
aVThe translation does not happen, because preprocessor runs before s are interpreted, so the fact that  and  are  members does not change anything
p54282
as(dp54283
g6
V335858
p54284
stp54285
a((dp54286
g2
(lp54287
VThe  and  are metacharacters that let you define a character class
p54288
aVAnything enclosed in square brackets is interpreted literally
p54289
aVYou can include multiple characters as well:
p54290
aVThere are two specific things you need to know about the  syntax:
p54291
aVThe  symbol at the beginning of the group has a special meaning: it inverts what's matched by the group
p54292
aVFor example,  matches any character except a dot
p54293
aVDash  in between two characters means any code point between the two
p54294
aVFor example,  matches any single uppercase letter
p54295
aVYou can use dash multiple times - for example,  means "any single upper- or lower-case letter or a digit"
p54296
aVThe two constructs above ( and ) are common to nearly all regex engines; some engines  (such as Java's) define additional syntax specific only to these engines
p54297
as(dp54298
g6
V335858
p54299
stp54300
a((dp54301
g2
(lp54302
VThe  class was designed to be a base for both read-write and read-only maps
p54303
aVThe getter must be implemented, so the implementation uses the abstract method
p54304
aVHowever,  may remain unimplemented if the map is read-only
p54305
aVThe documentation says:
p54306
aVTo implement a modifiable map, the programmer must additionally override this class's  method (which otherwise throws an ), and the iterator returned by  must additionally implement its  method
p54307
aVNote that the designers could have left the  method unimplemented, requiring programmers to override it explicitly
p54308
aVHowever, all read-only implementations would have to supply the same implementation (i
p54309
ag630
aVthrowing the ), so the designers opted to place this implementation into the shared code base
p54310
aVThe  method, on the other hand, can be implemented in terms of the existing operations that the derived class must implement, so the implementation in the Java library is non-empty
p54311
aVIt makes an assumption that the  implements its  - if it does not, 's remove would throw whatever exception that the iterator's  throws, presumably the
p54312
as(dp54313
g6
V335858
p54314
stp54315
a((dp54316
g2
(lp54317
V is a string literal
p54318
aVYou need a hex integer literal:
p54319
aVPrefix  tells the compiler that the rest of the numeric literal needs to be interpreted as a numeric hex constant
p54320
as(dp54321
g6
V335858
p54322
stp54323
a((dp54324
g2
(lp54325
VRather than programming this in terms of "s are numbers", program this in terms of "s are smart"
p54326
aVYou can associate numbers with s (after all, s are instances of regular Java classes), but make that number private
p54327
aVThen you can add this method to the :
p54328
aVThen your conditional would look like this:
p54329
aVHere is an explanation of how to associate numbers with enums: link
p54330
as(dp54331
g6
V335858
p54332
stp54333
a((dp54334
g2
(lp54335
VSimple calculations show that the total space required by such objects would be less than 12 MB - not a large amount of memory on most modern computer systems, with the exclusion of embedded Java platforms
p54336
aVTo do the calculations, multiply the number of characters by two (because Java's  is a 16-bit number)
p54337
as(dp54338
g6
V335858
p54339
stp54340
a((dp54341
g2
(lp54342
VIf an  (or any other definition for that matter) is for private use within the implementation of a single class, then it should be defined in the  file with the implementation of that class
p54343
aVPutting it in the header would cause unnecessary recompiles of unrelated files that depend on your class, but do not care about the private  that it uses
p54344
as(dp54345
g6
V335858
p54346
stp54347
a((dp54348
g2
(lp54349
VIf   does not equal , then  evaluates to , so the overall  would evaluate to  as well, because an  evaluates to  if, and only if, one or both of its sides evaluate to
p54350
aVIt looks like your logic should have used the  operator  instead of an , like this:
p54351
aVThe  operator short-circuits the evaluation, so you would not get an exception even when the  is
p54352
as(dp54353
g6
V335858
p54354
stp54355
a((dp54356
g2
(lp54357
VStarting with
p54358
aVNET 4
p54359
aV0,  uses  method to decide what to trim; documentation lists all characters that would be trimmed
p54360
aVSince the documentation for  does not say that it is using the same list of characters, it is a fair question to ask if there's a mismatch
p54361
aVOne way to find out is an exhaustive search:
p54362
aVRunning this code produces no result: none of the 26 characters that  considers whitespace is matched by the  of the regex
p54363
aVTherefore I must conclude that the code protected by the  condition is unreachable
p54364
aVAs a side note,  can never be : according to the documentation,
p54365
aVIf a call to the  or  method fails to find a match, the value of the returned  property is
p54366
aVYou can remove the first , or replace it with comparison to
p54367
as(dp54368
g6
V335858
p54369
stp54370
a((dp54371
g2
(lp54372
VAssembly can save you time, but it cannot save you memory when you are already down to the level of byte arrays
p54373
aVWhat could work is storing the data in a file when its data is not on the screen: save the data to a file, and store the file name in your  object
p54374
aVWhen it is time to show your file on the screen, load it in memory, and keep it there while it's visible
p54375
aVAs soon as the image becomes non-visible, save the data back to the same file, and release the memory
p54376
aVDo the same when the app goes into background
p54377
aVThis would let you use only as much memory as you need at each point in the application's life
p54378
as(dp54379
g6
V335858
p54380
stp54381
a((dp54382
g2
(lp54383
VI think you are missing the difference between a stack and a stack frame
p54384
aVThere is one stack per thread
p54385
aVEach stack consists of frames
p54386
aVWhen  performs the first method call, a new stack frame gets allocated, then  is called, and then the frame gets deallocated
p54387
aVNow it's turn to call
p54388
aVAgain, a new stack frame is allocated, the call is performed, and the frame gets deallocated
p54389
aVIf  makes some method calls of its own, new frames get allocated and deallocated on the same stack to accommodate the call sequence
p54390
aVStack frames get destroyed in the order opposite to their creation order (that's the reason why this structure is called a "stack" in the first place)
p54391
aVNote that allocating and deallocating stack frames is very efficient, because it's often an operation supported directly by the CPU's hardware
p54392
as(dp54393
g6
V335858
p54394
stp54395
a((dp54396
g2
(lp54397
VFor sure it seems to be "better" to avoid the list, but the performances are so bad if I don't use it
p54398
aVThis is a very common tradeoff: you pay with memory for CPU cycles and network bandwidth
p54399
aVIf you think it's a bad thing for the list to stay in memory forever (as a static list certainly would, until you explicitly clear it) you can create a "cache" object, store your list in it, and keep it around only for as long as it is needed
p54400
aVOnce you're done with the list, get rid of your "cache" object, and your list would get garbage collected
p54401
as(dp54402
g6
V335858
p54403
stp54404
a((dp54405
g2
(lp54406
VThere is no difference in time or space complexity of the two
p54407
aVHowever, several decades ago the loop that was counting down was considered slightly preferable when you programmed C with some non-optimizing compilers, because it allowed you to save on a comparison instruction: comparing for equality to zero took fewer cycles than comparing for equality to an arbitrary number
p54408
as(dp54409
g6
V335858
p54410
stp54411
a((dp54412
g2
(lp54413
VThe problem is that the field is non-final: only final fields are allowed to be static in the context of non-static inner classes:
p54414
as(dp54415
g6
V335858
p54416
stp54417
a((dp54418
g2
(lp54419
VI am wondering why do I have to use pointers
p54420
aVYou do not have to, it is your choice
p54421
aVIs there any advantages of pointers to indexes
p54422
aVThere is little, if any, difference between them on the modern hardware
p54423
aVOn older hardware, however, pointers offered some improvement, because you could save on CPU cycles doing pointer arithmetic on indexing
p54424
aVIs there a preference of the use of  and  in s
p54425
aVNo, there is no preference:  is an alternative syntax for , the compiler would produce the same cod for both constructs
p54426
as(dp54427
g6
V335858
p54428
stp54429
a((dp54430
g2
(lp54431
VForward declaration is a promise to define something that you make to a compiler at the point where the definition cannot be made
p54432
aVThe compiler can use your word to interpret other declarations that it would not be able to interpret otherwise
p54433
aVA common example is a  designed to be a node in a linked list: you need to put a pointer to a node into the , but the compiler would not let you do it without either a forward declaration or a tag:
p54434
aVand so it cant be used for forward declaration
p54435
aVI think that author's point was that giving your  a tag would be equivalent to a forward declaration:
p54436
as(dp54437
g6
V335858
p54438
stp54439
a((dp54440
g2
(lp54441
VLook at Dynamic LINQ, it provides extensions that let you pass a  to a  extension, and it builds the predicate dynamically for you:
p54442
as(dp54443
g6
V335858
p54444
stp54445
a((dp54446
g2
(lp54447
VThe error does not say that it cannot convert  to , only that it cannot convert a generic dictionary type based on  to a generic dictionary type based on
p54448
aVThis is expected, because these types are not covariant
p54449
aVYou can fix this by supplying a cast:
p54450
as(dp54451
g6
V335858
p54452
stp54453
a((dp54454
g2
(lp54455
VIf you need  and ,  and , to count the same, you can build a query like this:
p54456
aVDemo on sqlfiddle
p54457
as(dp54458
g6
V335858
p54459
stp54460
a((dp54461
g2
(lp54462
VTo figure out the time complexity of a recursive function you need to calculate the number of recursive calls that is going to be made in terms of some input variable
p54463
aVIn this case, each call makes at most one recursive invocation
p54464
aVThe number of invocations is on the order of O(log2N), because each invocation decreases  in half
p54465
aVThe rest of the body of the recursive function is O(1), because it does not depend on
p54466
aVTherefore, your function has time complexity of O(log2N)
p54467
as(dp54468
g6
V335858
p54469
stp54470
a((dp54471
g2
(lp54472
VThe reason why
p54473
aVdeletes every row is that  cannot be equal two different strings at the same time, therefore at least one of the two "not equals" is going to evaluate to , making the overall  evaluate to  as well
p54474
aVYou are looking for , not  in that condition:
p54475
aVThis one will be  only when both "not equals" evaluate to , i
p54476
ag630
aVthe state is not New York and the state is not Pennsylvania
p54477
as(dp54478
g6
V335858
p54479
stp54480
a((dp54481
g2
(lp54482
VYour solution represents a greedy algorithm with a slight modification, because it counts a character in  as belonging to  on the first pass (or to  on the second pass) as soon as it finds a match
p54483
aVThis will break for the following strings:
p54484
aVThe firs pass that counts a matching character as a member of  will turn  into
p54485
aVThe second pass that counts a matching character as a member of  will turn  into
p54486
aVHere is a simple Java implementation of a memoized solution:
p54487
aVDemo on ideone
p54488
as(dp54489
g6
V335858
p54490
stp54491
a((dp54492
g2
(lp54493
VThe problem is that elements  of the  array all have the length of zero
p54494
aVThat is why the assignment  is always outside of 's range
p54495
aVOne way of fixing this would be using concatenation:
p54496
aVA better approach would be eliminating the loop altogether, and using  member function of  instead: it lets you cut out a portion of  knowing the desired length and the starting position
p54497
aVIn addition, you are returning a pointer to a local array, which is undefined behavior
p54498
aVYou should replace an array with a , and add items to it using
p54499
aVFinally, you need to push the final word when the  does not end in a space
p54500
aVHere is your modified program that uses the above suggestions:
p54501
aVHere is a demo on ideone
p54502
as(dp54503
g6
V335858
p54504
stp54505
a((dp54506
g2
(lp54507
VUnless  is a string literal (which it isn't because you compare it to an int above) you should include it in a string using a format specifier , like this:
p54508
as(dp54509
g6
V335858
p54510
stp54511
a((dp54512
g2
(lp54513
VSince this is a learning exercise, I wouldn't correct your code, but point out what needs to be fixed:
p54514
aVArrays in C are indexed from zero, not from one, so the counter should go from 0 to 4, inclusive
p54515
aVis an , while  is an array, so the assignment  is invalid
p54516
aVshould put the data into , not
p54517
aVIn the way that you coded your loop you do not need an array at all: you need the last number entered
p54518
aVcannot be computed as ; you need to keep a running total, updating it on each iteration
p54519
as(dp54520
g6
V335858
p54521
stp54522
a((dp54523
g2
(lp54524
VYou need to add
p54525
aVand also malloc and copy the array even in case its length is one in mergeSort:
p54526
aVThis would ensure that the caller of mergeSort always owns the array that it gets back, and so he must free it in all cases
p54527
aVThe reason it didn't work when you tried it was that you did not make copies of trivial arrays, which resulted in double-freeing some of them
p54528
as(dp54529
g6
V335858
p54530
stp54531
a((dp54532
g2
(lp54533
VIn general, in order to implement a "straight" numeration (i
p54534
ag630
aVwhen the numbering of cells from section  continues after the cells from section ) you need to add the total number of rows in all preceding sections to the current row number
p54535
aVIf you know that the number of rows per section is one, you can take a shortcut to "straight" numeration, and use section number instead of the row number:
p54536
aVThe exact formula with one row per section is , but  is always zero, and we can drop multiplication by 1
p54537
aVYou should also use
p54538
aVin the replacement of your  statement in the long press handler
p54539
as(dp54540
g6
V335858
p54541
stp54542
a((dp54543
g2
(lp54544
VIn C99 there is a special syntax for this, although it is limited to only one array per  (which is OK in your case) - put the array as the last member, and drop its size, like this:
p54545
aVNow the size of your array is flexible: you can decide what it should be at runtime
p54546
aVMoreover, different  values can have this size set differently (although in such cases it's typical to put  with the specific size as a field in the same )
p54547
aVThe "payment" for using this trick is inability to allocate such s on the stack or in the global or static memory
p54548
aVYou must allocate them dynamically, like this:
p54549
as(dp54550
g6
V335858
p54551
stp54552
a((dp54553
g2
(lp54554
VMatt Austern, the chair of the C++ standardization committee's library working group, explained this decision of the committee in his Dr
p54555
aVDobb's article by historical reasons:
p54556
aVWe discovered, with more testing, that even the [simple] example didn't work with every STL implementation
p54557
aVIn the end, it all seemed too murky and too poorly understood; the standardization committee didn't think there was any choice except to say that STL containers aren't supposed to work with incomplete types
p54558
aVFor good measure, we applied that prohibition to the rest of the standard library too
p54559
aVMy understanding of this is that the committee did not want to invalidate existing implementations of the library by requiring them to support incomplete types retroactively
p54560
aVIn the same article he concedes that
p54561
aVIn a future revision of C++, it might make sense to relax the restriction on instantiating standard library templates with incomplete types
p54562
aVGiven that the article dates back to 2002, and the prohibition remains in place in the current standard, I think that the decision of the boost designers not to wait for the future and build their own containers that allow incomplete types was fully justified
p54563
as(dp54564
g6
V335858
p54565
stp54566
a((dp54567
g2
(lp54568
VBut this is rather cumbersome and wouldn't scale for larger number of parameters
p54569
aVMoreover, this wouldn't compile
p54570
aVYou need to add comparison with  for each parameter, like this:
p54571
aVIf you need to scale to a larger number of parameters, do this:
p54572
as(dp54573
g6
V335858
p54574
stp54575
a((dp54576
g2
(lp54577
VBefore grouping, you need to make  pairs, then group by application:
p54578
aVNow each group would contain anonymous "pair" objects
p54579
aVYou can get projects back by accessing  on the items of the result
p54580
as(dp54581
g6
V335858
p54582
stp54583
a((dp54584
g2
(lp54585
VIf you must improve efficiency on such small scale, consider doing the replacement in two phases:
p54586
aVThe first phase calculates the number of characters in the result after the replacement
p54587
aVGo through the string, and add  to the count for each normal character; for characters such as   or , add
p54588
aVAt this point, you have enough information to allocate the string for the result
p54589
aVMake a string of the length that you counted in the first phase
p54590
aVThe second phase performs the actual replacement: go through the string again, copying the regular characters, and replacing umlauted ones with their corresponding pairs
p54591
as(dp54592
g6
V335858
p54593
stp54594
a((dp54595
g2
(lp54596
VIn Java 6 or later you can use  method that takes the original array, the initial index (inclusive), and the last index (exclusive), and returns a copy of the specified range:
p54597
as(dp54598
g6
V335858
p54599
stp54600
a((dp54601
g2
(lp54602
VCreate a , put the arrays ,  and  in it, and then use this code:
p54603
as(dp54604
g6
V335858
p54605
stp54606
a((dp54607
g2
(lp54608
VWhat you wrote does not make sense:  "shadows" the  outside (which wouldn't be captured anyway, because the square brackets are empty)
p54609
aVIt is calling  on an  that triggers the error that you see
p54610
aVMoreover, if  is , there is nothing to erase from it, so you need some sort of a meaningful logic expression in your lambda
p54611
aVThis should work - it will erase all even numbers from the vector:
p54612
aVHere is a demo on ideone
p54613
as(dp54614
g6
V335858
p54615
stp54616
a((dp54617
g2
(lp54618
VRemoving things from the middle of the queue is a mess: you would end up iterating all items, and re-queueing only the ones that you do not want to erase
p54619
aVSomething like this may work:
p54620
aVHowever, this requires going through the entire queue, so it's
p54621
aVA better approach may be keeping a  of the removed items, and wrap the dequeue method in such a way that  removing items requires a quick , enqueueing requires removal of the  from  in addition to the actual enqueueing, and dequeueing requires an additional check of the item for presence in
p54622
aVOf course you can always implement your own circular buffer, which would let you remove items from the middle simply by walking the buffer back to front, copying the items that you wish to keep onto itself, and adjusting the 'head' pointer when you are done
p54623
as(dp54624
g6
V335858
p54625
stp54626
a((dp54627
g2
(lp54628
VYou can work out the math by observing that one minute is sixty seconds, one second is one thousand milliseconds, so one minute is  milliseconds
p54629
aVIf you divide milliseconds by 60,000, seconds will be truncated
p54630
aVYou should divide the number by 1000 to truncate milliseconds, then take  as the number of seconds and  as the number of minutes:
p54631
as(dp54632
g6
V335858
p54633
stp54634
a((dp54635
g2
(lp54636
VThey use the same number of bytes, but they do not have the same precision
p54637
aVWith , all digits are significant: when you store a number within the 's range in a , you will get back the same number
p54638
aVWith , only the first 16 digits are significant
p54639
aVOnce you get into very high or very small numbers, the precision of the number is going to go down
p54640
aVIn other words, storing a number in a  would not guarantee that you get back the same exact number (but that number will be pretty close to the original)
p54641
aVAnother problem with s is the precision of fractions: you very rarely get what you stored (except for very specific cases of sums of negative powers of two), although again, the value will be very close
p54642
aVThis behavior of  may or may not be of importance to you: if you are performing scientific computations, and follow the standard precautions, s should be fine
p54643
aVOn the other hand, if you are performing computations with money, you would be better off using more precise representations, such as
p54644
as(dp54645
g6
V335858
p54646
stp54647
a((dp54648
g2
(lp54649
VI am assuming a 32-bit  here
p54650
aVThe memory behind  has 24 bytes, and the layout is as follows:
p54651
aVHere is what happens after the first :
p54652
aVHere is what happens after the second :
p54653
aVNote how the terminating zero from the first  gets written over to complete the string
p54654
aVHere is the layout of :
p54655
aVWhen you cast a pointer of  to , you do not copy anything
p54656
aVThe layout of  is aligned with the layout of  like a cookie cutter, and then the content of combined  and  is taken through the  "window":
p54657
aVAs far as printing  goes, that's undefined behavior: you are passing , which is of type , to  in a position of an  parameter, so  "reinterprets" the data as an , chopping off the upper half (undefined behavior)
p54658
aVThe number that you get if you use an appropriate format specifier is
p54659
as(dp54660
g6
V335858
p54661
stp54662
a((dp54663
g2
(lp54664
VYou have several errors in there
p54665
aVSince this is a learning assignment, I would describe errors rather than correcting your code:
p54666
aVYou are printing  for each element; you should print it only when the loop has finished
p54667
aVIn other words, the individual lines should use  format, and then after the loop you should print
p54668
aVYour  is incorrect: you need a loop there, similar to what you have in
p54669
aVYour way of creating a list looks suspicious: rather than reading a file, you count lines, and then create a list of , , ,
p54670
aVbased on the line count
p54671
aVYou should read the data from the file into your list; you can do it in the same loop that does counting, because linked lists do not need to know their length upfront
p54672
as(dp54673
g6
V335858
p54674
stp54675
a((dp54676
g2
(lp54677
VAn array that has 100 rows such that each row is empty is an empty array; your program returns 100 in cases like that
p54678
aVYou do not need a special case for that if you structure your program correctly
p54679
aVSince you have single-digit positive numbers, all you need is an array of ten counts:
p54680
aVAt this point, you've got an array of ten counters
p54681
aVLook for the highest one:
p54682
as(dp54683
g6
V335858
p54684
stp54685
a((dp54686
g2
(lp54687
VI assume that you know what is a palindrome
p54688
aVThe method that they ask you to write is a palindrome detector, with some advanced features
p54689
aVYou are not constructing a palindrome: instead, you detect if a string that they give you is a palindrome or not
p54690
aVThe algorithm is straightforward: you need two indexes - one stars at zero, the other one starts at  (recall that Java arrays are zero-based)
p54691
aVFind the next non-space character at each side, convert to uppercase, and compare
p54692
aVIf the characters are different, return
p54693
aVOtherwise advance the two indexes toward each other
p54694
aVOnce they cross in the middle, return
p54695
aVNote: For some reason they are passing the length of the array on the side
p54696
aVThis would make sense if it were an assignment in C, but in Java it makes zero sense, because the array can report its length to you
p54697
as(dp54698
g6
V335858
p54699
stp54700
a((dp54701
g2
(lp54702
VStarting with Java 6, you can drop the first element by using , like this:
p54703
as(dp54704
g6
V335858
p54705
stp54706
a((dp54707
g2
(lp54708
VYou get this message because the two individual arrays are not set in the constructor of the jagged array
p54709
aVHere is what you can do:
p54710
aVThis would create an array of two elements, each of the elements with  elements of type
p54711
as(dp54712
g6
V335858
p54713
stp54714
a((dp54715
g2
(lp54716
VI think the problem is that you are not storing the initial value of the buffer pointer that you have allocated
p54717
aVYou increment the pointer in a loop as you go, so  points to the end of the buffer after the loop is over
p54718
aVUse a different pointer in your loop to fix this problem:
p54719
as(dp54720
g6
V335858
p54721
stp54722
a((dp54723
g2
(lp54724
VThe absolutely simplest, fastest, and easiest to understand way to make the eight combinations is hard-coding the eight combinations of signs:
p54725
aVIf you prefer a solution with a little more programming, you can do it like this (I am using arrays for vectors; you could use your specific class):
p54726
aVThe combination of pluses and minuses in front of the vector component is modeled with a single three-bit number
p54727
aVWhen bit at position  is set, the -th component is taken with the negative sign; otherwise, it is taken with a positive sign
p54728
as(dp54729
g6
V335858
p54730
stp54731
a((dp54732
g2
(lp54733
VYou implemented selection sort, one of the simplest, but at  it is also one of the slowest sorting algorithms
p54734
aVAlthough it is certainly fine for short strings, long strings will make this algorithm perform much worse
p54735
aVYou could use the built-in sorting algorithm by sorting the string converted to an array of characters for  performance, which should be sufficient in most cases
p54736
aVHowever, strings of characters offer a way to sort in linear time by applying counting sort, which offers a hard-to-beat performance, especially when the set of characters that you encounter in the string is limited
p54737
as(dp54738
g6
V335858
p54739
stp54740
a((dp54741
g2
(lp54742
VYour code follows the same suboptimal pattern in several places: rather than taking everything and grouping by color or category, you deal with a single color or a single category at a time
p54743
aVYou do that in the outer loop when you iterate through , and then you do the same in the nested loop when you iterate
p54744
aVThis goes to  multiple times, each time with a separate query
p54745
aVIn with rare exceptions, querying in a loop is a sure way to kill your performance
p54746
aVIt is better to get everything, group by color/category, and then build the results the way you need
p54747
aVHere is one way to do it:
p54748
aVAt this point you have groups of all items grouped by color and category, retrieved in a single query
p54749
aVWhat's left now is iterating the groups, and adding the data to the structure that you are populating
p54750
as(dp54751
g6
V335858
p54752
stp54753
a((dp54754
g2
(lp54755
VDividing by a constant does not change the
p54756
aVExact divisibility does not matter either
p54757
aVJust like the algorithm where  goes all the way up to , this is an  algorithm
p54758
as(dp54759
g6
V335858
p54760
stp54761
a((dp54762
g2
(lp54763
VMake the two instances , and instantiate them once, and return only them
p54764
aVThis is similar to a Singleton design pattern
p54765
as(dp54766
g6
V335858
p54767
stp54768
a((dp54769
g2
(lp54770
VOne way to deal with this is using nullable s in a collection, and then filter out the s, like this:
p54771
aVThe array created in the assignment of  has three items of type  - one for each flag
p54772
aVThe flags that correspond to an unset property become s; the flags corresponding to set properties become the nullable
p54773
aVThe rest is simple: the  filters out the s, the  drops nullability, and finally  makes the results a list
p54774
as(dp54775
g6
V335858
p54776
stp54777
a((dp54778
g2
(lp54779
VOne way is to turn your points into a C array, then make an  out of it:
p54780
as(dp54781
g6
V335858
p54782
stp54783
a((dp54784
g2
(lp54785
VThere is no such thing in C language as an interface: in addition to primitive types and pointers, the language supports s and functions; that's all you have to work with
p54786
aVYour code shows an example of a forward declaration of a function
p54787
aVInterfaces to C modules consist of multiple such declarations, along with declaration of s that these functions use
p54788
as(dp54789
g6
V335858
p54790
stp54791
a((dp54792
g2
(lp54793
VThe problem is that the statement creates a grouping, but you are trying to return a plain list of users
p54794
aVThere are two ways of fixing this:
p54795
aVYou may want to return an  instead of  (you could use  as the key as well) , or
p54796
aVYou may want to order users by name, instead of grouping, if you want to return a plain list
p54797
aVHere is how you make it an :
p54798
aVEDIT : (in response to this comment: "I want to group so that all names that start with A are under the A header and so on so I am just changing the appearance not really sorting")
p54799
aVIn cases like this, you do not need grouping (although you can certainly make use of it if you wish to do so)
p54800
aVYou could order the data instead, in your LINQ, in your SP, or otherwise, and then provide the headers visually by inserting then at the boundaries between the names that start in different letters
p54801
aVHere is a very crude example of doing it in a program that prints to console
p54802
aVYou should be able to adapt it to your particular visuals with little work:
p54803
as(dp54804
g6
V335858
p54805
stp54806
a((dp54807
g2
(lp54808
VIf you need to store your  objects in an array of s, you need a cast:
p54809
aVHowever, you would be better off declaring your list with  as its type parameters:
p54810
aVIn this case, you would be able to use , and make the call without a cast:
p54811
as(dp54812
g6
V335858
p54813
stp54814
a((dp54815
g2
(lp54816
VIt does not look like that is an option with functions of the  family: your choices there are zeros  or spaces
p54817
aVIf you must pad with another character, you need to perform the conversion yourself
p54818
aVOne way of doing this would be using  to print into a 6-character buffer with space padding, then replacing spaces with dashes , like this:
p54819
as(dp54820
g6
V335858
p54821
stp54822
a((dp54823
g2
(lp54824
VNo, you do not need to explicitly retain the , because your object already does that
p54825
aVSince the dictionary retains the object, the  is safe from being released prematurely
p54826
aVMoreover,  makes a copy of your string key, as a precaution against using a mutable object as a dictionary key (which is very bad)
p54827
aVThat's why you are free to change that key inside the object as you please
p54828
aVOf course that would not change the placement of the object inside the dictionary
p54829
as(dp54830
g6
V335858
p54831
stp54832
a((dp54833
g2
(lp54834
VC does not have a direct equivalent of , but since your radix is hard-coded to 16, you can write one yourself:
p54835
as(dp54836
g6
V335858
p54837
stp54838
a((dp54839
g2
(lp54840
VHowever with  I am setting the pointer to  and destroy it, isn't it
p54841
aVNo, you do not set it to : the expression in the  initializer is computed only once; the second time around the initialization has no effect
p54842
aVThis looks very confusing, but this is the way the function-static facility works in C (and by extension, in Objective-C)
p54843
aVTry this as an example:
p54844
aVThis would produce a sequence of increasing numbers starting at 123, even though the code makes it appear as if  is assigned 123 every time that you go through the function
p54845
as(dp54846
g6
V335858
p54847
stp54848
a((dp54849
g2
(lp54850
VIn SQL Server 2005 or later, you can use the  function for that:
p54851
aVThe function evaluates its arguments one by one, and returns the first non- value
p54852
as(dp54853
g6
V335858
p54854
stp54855
a((dp54856
g2
(lp54857
VGenerally, there are two kinds of constants - ones with the meaning to the implementation, and ones with the meaning to the business logic
p54858
aVIt is OK to hard-code the constants of the first kind: they are private to understanding your algorithm
p54859
aVFor example, if you are using a ternary search and need to divide the interval in three parts, dividing by a hard-coded  is the right approach
p54860
aVConstants with the meaning outside the code of your program, on the other hand, should not be hard-coded: giving them explicit names gives someone who maintains your code after you leave the company non-zero chances of making correct modifications without having to rewrite things from scratch or e-mailing you for help
p54861
as(dp54862
g6
V335858
p54863
stp54864
a((dp54865
g2
(lp54866
VExpression trees look scarier than they are, but you are right, in your situation they are unnecessary: you could use a static condition that is smart enough to ignore dropdowns that have no selection
p54867
aVYou can do it like this:
p54868
as(dp54869
g6
V335858
p54870
stp54871
a((dp54872
g2
(lp54873
VYou can do it like this:
p54874
aVThe  brings together the records with identical s, letting you process them as a group;  takes each group, limits the number of its members to , and puts the results back into one flat list
p54875
as(dp54876
g6
V335858
p54877
stp54878
a((dp54879
g2
(lp54880
VLatitude and longitude do not appear to be of type , it looks like they are s
p54881
aVTry this:
p54882
aVrepresents both latitude and longitude, so you can also do this:
p54883
as(dp54884
g6
V335858
p54885
stp54886
a((dp54887
g2
(lp54888
VSince backslashes are used as escapes inside regex themselves, I find it best to use verbatim strings when working with the regex library:
p54889
aVThe only issue with that is that you must double your double-quotes (which is ironically what you need to do in your case)
p54890
aVDemo on ideone
p54891
as(dp54892
g6
V335858
p54893
stp54894
a((dp54895
g2
(lp54896
VSince this is a learning exercise, I wouldn't try fixing your code, just point out a few things to work on to get it right:
p54897
aVThe  condition inside the loop becomes unnecessary if you change your  loop condition to
p54898
aVComparing individual characters is easier (and faster) than comparing substrings
p54899
aVYou get a character at position  by calling , and compare two characters using  operator, rather than calling  on them
p54900
aVWhen  is zero (your  condition is equivalent to ) you print both the current character and the character after it, in addition to the first character of  followed by the count
p54901
aVThis does not look correct
p54902
aVRather than growing  as you go through the loop, you set it on each iteration
p54903
aVThis does not look correct
p54904
aVA better way of growing  as you go through the loop is using  and , instead of using a plain , and performing concatenations
p54905
as(dp54906
g6
V335858
p54907
stp54908
a((dp54909
g2
(lp54910
VThis is not an overwrite of a previously added object - the reason you see this is that you have added a reference to the same object two times
p54911
aVYour  looks like this:
p54912
aVdoes not make copies of objects that you insert, so you need to take care of making new objects before inserting them
p54913
aVOne way of making a copy is passing  to a method that copies it into a new dictionary, like this:
p54914
as(dp54915
g6
V335858
p54916
stp54917
a((dp54918
g2
(lp54919
VOne way to speed up your search in a massive file is adapting a fast in-memory search algorithm to searching in a file
p54920
aVOne particularly fast algorithm is Knuth\u2013Morris\u2013Pratt: it looks at each character at most twice, and requires a small preprocessing step to construct the "jump table" that tells you to what position you should move to continue your search
p54921
aVThat table is constructed in such a way as to not have you jump too far back, so you can do your search by keeping a small "search window" of your file in memory: since you are looking for a word of only seven characters, it is sufficient to keep only the last six characters in memory as your search progresses through the file
p54922
as(dp54923
g6
V335858
p54924
stp54925
a((dp54926
g2
(lp54927
VThe files are created by the  before running your program, so you have no control over it
p54928
aVThe best you can do is making a batch file that "cleans up" after running your process by deleting  and/or  when they are empty
p54929
aVHere is a link to an answer explaining how to detect and delete empty files
p54930
as(dp54931
g6
V335858
p54932
stp54933
a((dp54934
g2
(lp54935
VThe reason why your code does not work is that  is immutable
p54936
aVThe  method returns a new object:
p54937
as(dp54938
g6
V335858
p54939
stp54940
a((dp54941
g2
(lp54942
VCreating  through the code should neither give your advantages nor disadvantages compared to creating them through NIBs or by using multiple prototype cells
p54943
aVNIB files and prototype cells let you manipulate cell layout visually, but they do not prohibit you from additionally manipulating it in your program
p54944
aVAll three ways of building the cells have one common requirement - the cells of different kind must have different reuse identifiers (see this question for a discussion)
p54945
aVIf it is the proliferation of the 20+ NIB files that you are worried about, consider the prototype cell approach, which lets you stay within a single storyboard file
p54946
as(dp54947
g6
V335858
p54948
stp54949
a((dp54950
g2
(lp54951
VIn your example  is a variable of type "pointer to "
p54952
aVAll Objective C objects are handled through fields and variables of pointer type
p54953
aVWhen they say " returns an object", an expanded version of this statement should be " returns a pointer to an object"
p54954
aVHowever, since all objects are dealt with through pointers, the "pointer to" clarification can be safely dropped
p54955
as(dp54956
g6
V335858
p54957
stp54958
a((dp54959
g2
(lp54960
VHow should I fix this error
p54961
aVRemove the cast, and look for the place where  has been allocated
p54962
aVIf it has been allocated as , replace with
p54963
aVOtherwise (although that would be unlikely) replace with
p54964
aVIn the long run it is best prefer using dynamic containers, such as , to dynamic allocations of arrays of primitives
p54965
aVI understand that this may be beyond the scope of your current refactoring, though
p54966
as(dp54967
g6
V335858
p54968
stp54969
a((dp54970
g2
(lp54971
VI am wondering why each section will load the information from beginning in the
p54972
aVBecause the code of your  method ignores , paying attention to  alone
p54973
aVYou need to decide on the index that you pass to  based on both the  and the ; the exact calculation depends on the structure of your data, i
p54974
ag630
aVhow many rows you have in each section
p54975
aVNote : Using  to share data among view controllers is not a good idea
p54976
aVConsider separating out your data in a separate model class, and make that class a singleton
p54977
as(dp54978
g6
V335858
p54979
stp54980
a((dp54981
g2
(lp54982
VWhen you cast 128 ( in binary) to an eight-bit  type, the sign bit gets set to , so the number becomes interpreted as negative
p54983
aVJava uses Two's Complement representation, so  is  - the smallest negative number representable with 8 bits
p54984
aVUnder this interpretation,  becomes ,  becomes , and so on, all the way to  ( in binary), which becomes
p54985
as(dp54986
g6
V335858
p54987
stp54988
a((dp54989
g2
(lp54990
VYou should use  on one side and  on the other side, and also call  before comparison, like this:
p54991
as(dp54992
g6
V335858
p54993
stp54994
a((dp54995
g2
(lp54996
VFrom the documentation of :
p54997
aV[is thrown when] the value type of the underlying column could not be cast to the type specified by the generic parameter, T
p54998
aVIt looks like in your case the column type is a nullable integer, so you need to do something like this:
p54999
aVThe idea is to retrieve the value as an , but accept data rows where the data is missing
p55000
aVIf you do not mind  of your anonymous class being nullable s instead of s, remove the  part of the expression
p55001
as(dp55002
g6
V335858
p55003
stp55004
a((dp55005
g2
(lp55006
VThe biggest downside to this is the lack of clarity to someone unfamiliar with your code: to me, a call like this
p55007
aVmeans accessing  that is fixed in one way or the other, as opposed to
p55008
aVwhich tells me explicitly that  is being created on demand
p55009
aVConverting  property into a method with an appropriate name, say, , would restore readability:
p55010
aVYou may want to do something like this in order to hide the process of instantiating , the constructor of which may require some parameters that you are unwilling to carry around
p55011
as(dp55012
g6
V335858
p55013
stp55014
a((dp55015
g2
(lp55016
VThe compiler will not complain if you leave out the name tag for the second parameter (try it out to see for yourself to see that it works)
p55017
aVHowever, it is not optional in calls of methods where it is defined
p55018
aVFor example, you cannot call the first method with the  portion of the method name omitted
p55019
aVAlso note that the colon is not optional when making a selector for the second method:
p55020
as(dp55021
g6
V335858
p55022
stp55023
a((dp55024
g2
(lp55025
VYou can construct a combination of "flag" s from a set of s as follows:
p55026
as(dp55027
g6
V335858
p55028
stp55029
a((dp55030
g2
(lp55031
VWhen you pass a non-const pointer to a function, you let that function modify the content to which the pointer points
p55032
aVSo the solution in your case is to pass the same pointer to both functions:
p55033
aVOnly median() is allowed to call selectsort()
p55034
aVIf that is the case, and assuming that you would like to keep the original ordering in place, you could make a copy of your array like this:
p55035
aVThe idea is to preserve the content of the original array by sorting its copy
p55036
as(dp55037
g6
V335858
p55038
stp55039
a((dp55040
g2
(lp55041
VIs it one of those "Implementation defined" things of C-language
p55042
aVNo, that's not implementation-defined - it's plain "undefined"
p55043
aVThe same is true for arrays of all types: the values that you see in them are undefined until explicitly initialized
p55044
aVWhat I understood from above text is that if there is an array of pointers they have explicit out-of-bound value like
p55045
aVThe author wanted to say that there is a value (specifically,  value) that can be used to mark a "no value" in an array of pointer
p55046
aVThe author did not mean to imply that such a no-value marker would be placed into an array of pointers by default
p55047
as(dp55048
g6
V335858
p55049
stp55050
a((dp55051
g2
(lp55052
VThe way to specify a non-empty sequence of characters other than an underscore is
p55053
aVWhen you put a  symbol inside a character class (that's the fancy name for a set of characters which could be defined through the square bracket syntax) the character class gets inverted: it matches everything not included in the class, rather than matching what is included
p55054
aVIn your case, the overall expression would look like this:
p55055
as(dp55056
g6
V335858
p55057
stp55058
a((dp55059
g2
(lp55060
VYour error is in the code that leads to the "payload" palindrome condition check:
p55061
aVThe code before that check is supposed to bring  and  in such a state that both  and  are letters
p55062
aVYour code does not do that: specifically, sequences of multiple non-alphabetic characters would bring you to a state when you compare a letter to a non-letter, or even two non-letters
p55063
aVA simpler way of dealing with this problem would be splitting your program into two stages
p55064
aVThe first stage would eliminate all non-letters from the input string; the second stage would perform the palindrome check
p55065
aVMake a copy of the incoming string, then go through it character-by-character, copying only letters back into the string
p55066
aVYou would end up with a string that is either shorter or the same length as the original
p55067
aVNow palindrome check becomes trivial: start from both ends, and check for equality of  until the two ends meet in the middle
p55068
aVDon't forget to free the copy of your string
p55069
as(dp55070
g6
V335858
p55071
stp55072
a((dp55073
g2
(lp55074
VIf you cannot change the signature of the method, your callers would need to do some casting
p55075
aVThis is not optimal, but you can still do it:
p55076
aVNow the caller would need to know the new type, do a cast, and access the email through it:
p55077
aVThe trickiest part is binding the new property to a data grid
p55078
aVThis answer explains how this can be done
p55079
as(dp55080
g6
V335858
p55081
stp55082
a((dp55083
g2
(lp55084
VEvery time a user adds a number, the delegate of your text field will be notified through this method:
p55085
aVYou can set up your delegate in such a way as to watch the length of the modified content of your text field, and close the field when the expected length is reached
p55086
aVHowever, this has a high potential to frustrate your users a lot: they would make a mistake entering the last character every now and then, and the field is going to close on them, not letting them correct the problem
p55087
aVA better approach is to dismiss the pad when users tap away from your text field, which keeps end-users in control of what is going on:
p55088
as(dp55089
g6
V335858
p55090
stp55091
a((dp55092
g2
(lp55093
VAssuming that there is no additional inheritance hierarchy, there is no difference in this case
p55094
aVThe only way to see a difference is inheriting the same class through multiple ways - for example, as follows:
p55095
aVvs
p55096
aVIn the first case,  would have two regions with separate s - one inherited directly, and one inherited through
p55097
aVIn the second case, there would be only one , inherited through both paths, and shared
p55098
aVHere is an illustration of this:
p55099
as(dp55100
g6
V335858
p55101
stp55102
a((dp55103
g2
(lp55104
VPlus in the  notation is an alternative form of writing
p55105
aVFinding a successor once could take up to  time
p55106
aVTo see why this is true, consider a situation when you are looking for a successor of the rightmost node of the left subtree of the root: its successor is at the bottom of the right subtree, so you must traverse the height of the tree twice
p55107
aVThat's why you need to include  in the calculation: if  is small compared to , then  would dominate the timing of the algorithm
p55108
aVThe point of the exercise is to prove that the time of calling the successor  times in a row is not , as one could imagine after observing that a single call could take up to
p55109
aVYou prove it by showing that the cost of traversing the height of the tree is distributed among the  calls, as you did by noting that each node is visited at most twice
p55110
as(dp55111
g6
V335858
p55112
stp55113
a((dp55114
g2
(lp55115
VThe  that you get from the call of  is of type , not , because Java generics are implemented through type erasure
p55116
aVYou can do this:
p55117
ag1971
ag1972
aVI am going to stay away from the discussion on whether it's a good idea to unit test the private details of the implementation
p55118
as(dp55119
g6
V335858
p55120
stp55121
a((dp55122
g2
(lp55123
VThis often happens because the program exits before the output buffer gets a chance to empty itself onto the console
p55124
aVAdding  to the end of 's format line should fix this problem:
p55125
aVPrinting  to an output stream which is connected to console "flushes" the output unless you change this setting in your program
p55126
aVNote: C provides a shorter way of multiplying by 7: instead of
p55127
aVyou can write
p55128
as(dp55129
g6
V335858
p55130
stp55131
a((dp55132
g2
(lp55133
VIf you know that every object inside your list is of type , you can use LINQ to do the conversion:
p55134
as(dp55135
g6
V335858
p55136
stp55137
a((dp55138
g2
(lp55139
VYou cannot concatenate integers like that: you need to do it through some elementary math
p55140
aVThink of "combining" as multiplication followed by addition:
p55141
aVHere is how it works:
p55142
aVNote that this trick works only when the second number has exactly two digits
p55143
aVWhen the second number has  digits, you need to multiply the first number by the -th power of ten before performing the addition
p55144
as(dp55145
g6
V335858
p55146
stp55147
a((dp55148
g2
(lp55149
VThese two have the same performance both in memory and in EF
p55150
aVIn memory, the first one obtains the results lazily, so it is not materially slower than the second one
p55151
aVIn EF or LINQ2SQL the query gets converted to SQL in its entirety, so only one result gets selected from the database in both instances
p55152
aVTo see what is going on, enable SQL logging in EF, and observe that the generated SQL is identical
p55153
aVThe code with a separate  is more typing, though, so the second form is preferred
p55154
as(dp55155
g6
V335858
p55156
stp55157
a((dp55158
g2
(lp55159
VStoring an array like this in a  is not going to work, even if you could do it syntactically: the array is going to stay in the map even after the real array goes out of scope
p55160
aVStoring vectors of  instead should work:
p55161
aVHere is a demo on ideone
p55162
as(dp55163
g6
V335858
p55164
stp55165
a((dp55166
g2
(lp55167
VYou get an error because reading primitives with  requires pointers:
p55168
aVthinks that an uninitialized  that you pass is a pointer, and tries to write it, which results in an error
p55169
aVIn addition, you need to protect against buffer overruns on reading strings, like this:
p55170
as(dp55171
g6
V335858
p55172
stp55173
a((dp55174
g2
(lp55175
VIn order for the first operation to work,  must point to a writable block of memory at least 7 bytes in size
p55176
aVThe second operation does not require it
p55177
aVAfter the first operation the string remains writable: you can do this on the first string, but not the second:
p55178
aVThe second pointer assignment points  to a memory of a string literal; writing to that memory is undefined behavior
p55179
as(dp55180
g6
V335858
p55181
stp55182
a((dp55183
g2
(lp55184
VWe can not create instance from a class that has constructor because the constructor still needs one parameter, even though it is defaulted
p55185
aVYou can get the default value, though, by calling  and accessing the initial element:
p55186
as(dp55187
g6
V335858
p55188
stp55189
a((dp55190
g2
(lp55191
VThis happens because of time zone: you are in the Indian Standard Time (IST) zone, which lags 5 hours and 30 minutes behind GMT
p55192
aVWhen you set  to  from the components, it uses your time zone, so the result gets adjusted to  so that  has the correct GMT time
p55193
aVIf you would like to set the time to  GMT, set your components'  to GMT:
p55194
as(dp55195
g6
V335858
p55196
stp55197
a((dp55198
g2
(lp55199
VMake  a , not a pointer:
p55200
aVOtherwise, there's no memory allocated to it, so dereferencing it is undefined behavior
p55201
aVOf course you need to replace  with
p55202
as(dp55203
g6
V335858
p55204
stp55205
a((dp55206
g2
(lp55207
VThe parameter that you pass to  must be an object on which the method is invoked, unless the method is
p55208
aVWhat you did through reflection is equivalent to this:
p55209
aVNaturally, there's an NPE
p55210
aVTo fix this problem, pass an object on which to invoke the method, or make the method
p55211
aVHere is one way to make a fix:
p55212
aVDemo on ideone
p55213
as(dp55214
g6
V335858
p55215
stp55216
a((dp55217
g2
(lp55218
VCrossproduct is a number that is not expressed in degrees
p55219
aVYou need to convert the angle to radians before passing it to , but converting the result back to degrees is incorrect
p55220
as(dp55221
g6
V335858
p55222
stp55223
a((dp55224
g2
(lp55225
V does not do memory allocation, so it cannot cause a memory leak by itself 1
p55226
aVYour allocation of  is done in the automatic storage (AKA "on the stack"), so it is not leaked in your method
p55227
aVIn general, you should watch out for memory leaks when you call , , , , and functions that return pointers to memory blocks that have been allocated dynamically
p55228
aV1 Copying data into a memory block of pointers may leak the blocks pointed to by these pointers, but not the argument that you pass to
p55229
as(dp55230
g6
V335858
p55231
stp55232
a((dp55233
g2
(lp55234
VThis is because the division is done in integers before being assigned to a
p55235
aVChange the type of  and  to  to get it fixed:
p55236
aVAlternatively, you can cast  to  in the division, like this:
p55237
as(dp55238
g6
V335858
p55239
stp55240
a((dp55241
g2
(lp55242
VOne useful thing to get right from the start is naming: when a list contains  objects, you should call it some descriptive name, such as  or similar, but not , which would be appropriate to a list of  objects
p55243
aVTo find an object by name, set up a simple loop that goes through each queue in turn, and then an inner loop that checks if the queue contains the desired item
p55244
aVIf searching the queue for a string is a common operation, consider hiding that loop in a method of , like this:
p55245
aVNow your search would go as follows:
p55246
as(dp55247
g6
V335858
p55248
stp55249
a((dp55250
g2
(lp55251
VAlthough lambdas can definitely replace some private member functions, thinking of them as means to uncluttering the interface of a class is taking too narrow a view of both lambdas and private member functions
p55252
aVPrivate member functions (and functions in general) are the basic units of code reuse
p55253
aVThey let you write a piece of logic once, and then hide it behind the name of the function
p55254
aVAlthough lambdas can replace a private member function in certain context, they could replace an object of which that function is a member along with it, which is a whole lot more
p55255
aVDue to lambda's ability to capture the context around them, you get a way of creating code blocks that take not only your object with it, but also the state of your local variables
p55256
aVBefore lambdas you needed to create a special class for that; lambdas let you create such classes on the fly, for much better readability
p55257
as(dp55258
g6
V335858
p55259
stp55260
a((dp55261
g2
(lp55262
VThe expression  is of pointer type; you need to add a dereference to make it a reference:
p55263
aVNote that this may not be safe, because operations that re-allocate  would invalidate the reference obtained through the  function
p55264
as(dp55265
g6
V335858
p55266
stp55267
a((dp55268
g2
(lp55269
VThis is because  and  are characters  and , not integer values
p55270
aVYou need to subtract  from them to obtain numeric values:
p55271
as(dp55272
g6
V335858
p55273
stp55274
a((dp55275
g2
(lp55276
VYou should not be using  here: that's part of the presentation logic, while you are working on the model-level logic here
p55277
aVLook at your  method, and see from where does the text of the cell's labels come
p55278
aVUsually it is an  or some other collection
p55279
aVYour  method should go directly to that same collection, and grab the info from there
p55280
as(dp55281
g6
V335858
p55282
stp55283
a((dp55284
g2
(lp55285
VYour first solution should work once you replace  with :
p55286
aVThe value  represents the resource that you embedded in its entirety given to you as a string, not a path to that resource (hence the "invalid characters in the path" error)
p55287
aVThe  approach should work too, but you need to give the method the right path, which is based, among other things, on the name of the default namespace of your project
p55288
aVIf you add a call to  before trying to get your resource, and look for the exact spelling of your resource name in the debugger, you should be able to fix the null pointer exception issue as well
p55289
as(dp55290
g6
V335858
p55291
stp55292
a((dp55293
g2
(lp55294
VYou can easily adapt the code to your needs: add an offset and the count, and call  to get past the initial  bytes, like this -
p55295
as(dp55296
g6
V335858
p55297
stp55298
a((dp55299
g2
(lp55300
VCompilers generate "symbols" files, providing to debuggers a way to show the name of a symbol that corresponds to a particular address or an offset
p55301
aVThis is highly system-dependent: for example, VS toolchain on Windows places these symbols in separate
p55302
aVpdb files, while on some UNIX flavors these debug symbols are embedded into the executable
p55303
aVEDIT : According to the comments, OllyDbg pulls symbols from the Import Address Table embedded in executable files
p55304
aVWhen symbols are embedded into the executable, compiler vendors provide a tool to remove these symbols
p55305
aVFor example, GNU provides the  utility to work with their toolchain
p55306
as(dp55307
g6
V335858
p55308
stp55309
a((dp55310
g2
(lp55311
VThere is a loop in all three cases - in the first case, it's inside the implementation of  which calls the OS which does looping, while in the other two cases it is in your code
p55312
aVThe last two cases are identical in terms of performance, if not in terms of generated code: both strings and vectors use contiguous storage, so their s are extremely fast
p55313
aVThe first case, where the loop belongs in the implementation of the operator, may be optimized better when the implementation calls through to the underlying operating system
p55314
aVThe most important point, however, is readability: a single line with a simple statement always reads better than even a simple loop
p55315
aVIn general, the biggest difference between strings and vectors of s is the set of primitives supported by the two containers: strings are geared toward conveying string-like semantics (making substrings, simple searches), while vectors are better to convey array-like semantics (sequential collections of items with fast access to an arbitrary index)
p55316
aVIn terms of performance, the two structures are very similar
p55317
as(dp55318
g6
V335858
p55319
stp55320
a((dp55321
g2
(lp55322
V does not mean "use an anonymous type", it means "Compiler, go figure out the type for me
p55323
aVIn the first three cases, the type is actually a "named" type - , , and  (in the last case the type of array's elements is also deduced by the compiler from the type of array elements that you put in the initializer)
p55324
aVThe last case is the only one where an anonymous type is used
p55325
aVIt is by design that C#'s anonymous types are immutable
p55326
aVThe primary case for adding them in the language in the first place has been introduction of LINQ, which does not need mutability in cases when anonymous types are produced
p55327
aVIn general, immutable classes tend to give designers less problems, especially when concurrency is involved, so designers of the language decided to go with immutable anonymous types
p55328
as(dp55329
g6
V335858
p55330
stp55331
a((dp55332
g2
(lp55333
VOne easy way to deal with this problem is assuming that if a digit is missing in the representation, then its value is zero
p55334
aVYou can do it like this:
p55335
aVOf course if you can assume that  (which you should be able to assume if you want your program to finish printing in under a year) you could use  to represent your number, and bit operations to check if a bit is set or not:
p55336
as(dp55337
g6
V335858
p55338
stp55339
a((dp55340
g2
(lp55341
VYou can read both numbers at once using :
p55342
aVThe "magic" is in the format string: it reads a  using , then skips a space or a  using , and finally reads an  using
p55343
aVDo this in a loop, pushing the  and the  variables onto the two vectors as needed
p55344
aVDemo on ideone
p55345
as(dp55346
g6
V335858
p55347
stp55348
a((dp55349
g2
(lp55350
VYou can do it with a single  (I guess this counts as your option #2, but slightly expanded):
p55351
aVWhen you want to schedule a method to be called in the future, calculate the time  when the method needs to run
p55352
aVStart  set at the earlier of  and
p55353
aVWhen the timer fires, compare the current time to
p55354
aVIf we're there, run the target method; otherwise, reschedule the timer at the earlier of  and  again
p55355
as(dp55356
g6
V335858
p55357
stp55358
a((dp55359
g2
(lp55360
VIf the separator is always a single character, you can do it like this:
p55361
aVThis take care of leading and trailing empty tokens, as long as empty tokens in the middle
p55362
aVHere is a demo on ideone
p55363
as(dp55364
g6
V335858
p55365
stp55366
a((dp55367
g2
(lp55368
VYou can do it by adding a second level of :
p55369
as(dp55370
g6
V335858
p55371
stp55372
a((dp55373
g2
(lp55374
VThe loop that counts zeros and ones destroys the value of  by doing
p55375
aVAfter all eight shifts are complete,  is always zero, so the following code increments wrong counts:
p55376
aVYou should save the value of  before the bit-counting loop, and restore it after the loop is over
p55377
aVBetter yet, compute the values of  and  upfront, without waiting for them to occur in the file
p55378
aVThis would make the body of your main loop very short and clean:
p55379
as(dp55380
g6
V335858
p55381
stp55382
a((dp55383
g2
(lp55384
VSince table-valued parameters are off limits to you, you may consider an XML-based approach:
p55385
aVBuild an XML document containing the four columns that you would like to pass
p55386
aVChange the signature of your stored procedure to accept a single XML-valued parameter instead of four scalar parameters
p55387
aVChange the code of your stored procedure to perform the updates based on the XML that you get
p55388
aVCall your new stored procedure once with the XML that you constructed in memory using the four nested loops
p55389
aVThis should reduce the number of round-trips, and speed up the overall execution time
p55390
aVHere is a link to an article explaining how inserting many rows can be done at once using XML; your situation is somewhat similar, so you should be able to use the approach outlined in that article
p55391
as(dp55392
g6
V335858
p55393
stp55394
a((dp55395
g2
(lp55396
VIs array a data type in C
p55397
aVArray" with no further specification is not a separate data type, but once you specify its size and its element type, it becomes a data type
p55398
aVIn other words, you cannot define a type that takes "an array of anything" or "an array of a specific type without a specific size", but you can define a data type that is an array of  items of type
p55399
aVIf yes can we create variables of array type as in s,
p55400
aVYes, it is
p55401
aVYou can tell by examining : it will be ten times the
p55402
as(dp55403
g6
V335858
p55404
stp55405
a((dp55406
g2
(lp55407
VYou can do it like this:
p55408
aVCreate  with the size of the combined arrays
p55409
aVConcatenate the two arrays into the  array by copying the elements of the first array followed by the elements of the second array into the
p55410
aVUse  with a comparator that "understands" both types
p55411
aVHere is a skeletal implementation:
p55412
as(dp55413
g6
V335858
p55414
stp55415
a((dp55416
g2
(lp55417
VYou can do it by following a simple procedure:
p55418
aVStart with an  that represents today
p55419
aVGet the day of the week from it (here is how it is done)
p55420
aVIf the day of the week matches what's in the selected , you are done
p55421
aVOtherwise, add one day to  (here is how it is done), and go back to step 2
p55422
as(dp55423
g6
V335858
p55424
stp55425
a((dp55426
g2
(lp55427
VFinal variables allow at most one assignment in the constructor or the initializer block
p55428
aVThe reason this does not compile is that Java code analyzer sees two assignments to  in branches that do not look mutually exclusive to it
p55429
aVWorking around this problem is simple:
p55430
as(dp55431
g6
V335858
p55432
stp55433
a((dp55434
g2
(lp55435
VYou can do it like this:
p55436
as(dp55437
g6
V335858
p55438
stp55439
a((dp55440
g2
(lp55441
VFirst, you need to compute how many points there are in a given range
p55442
aVTo do that, multiply the three dimensions together (each dimension has the size equal to the difference between its upper and lower bounds, plus one)
p55443
aVFor example, if your 3D range is , then the sizes are , so the total number of points is
p55444
aVThe next task is picking  points at random from the range
p55445
aVThere are many ways of doing it, but one is making a random shuffle of  points, and picking the first
p55446
as(dp55447
g6
V335858
p55448
stp55449
a((dp55450
g2
(lp55451
VYou do not synchronize functions, you synchronize their access to resources
p55452
aVIf any of the functions modifies a common resource * while other functions need to access it, either for reading or for writing, you need to synchronize the access to the resource
p55453
aVOtherwise, there is no need to add synchronization
p55454
aV* A resource could be a member variable, static or non-static, an object in memory, an operating system object such as a file or a socket, a collection, and so on
p55455
as(dp55456
g6
V335858
p55457
stp55458
a((dp55459
g2
(lp55460
VThat's because the three sections of  are separated with semicolons, not commas:
p55461
as(dp55462
g6
V335858
p55463
stp55464
a((dp55465
g2
(lp55466
VTo limit the string to 5 characters, use :
p55467
aVThe call  picks the smaller of  and the length of the title that you want to set
p55468
aVYou need to include  to use  function
p55469
as(dp55470
g6
V335858
p55471
stp55472
a((dp55473
g2
(lp55474
VI would like that the UI show Text3 first than Text2
p55475
aVThis does not happen in your code, because the artificial delay loops inside the setters for
p55476
aVruns synchronously, without letting other tasks having a go
p55477
aVIf you replace these loops with , you will get the desired effect:
p55478
as(dp55479
g6
V335858
p55480
stp55481
a((dp55482
g2
(lp55483
VYou can do it using a WITH clause:
p55484
aVThe  clause at the top makes  available to the remaining parts of your query without having to repeat yourself
p55485
aVHere is a demo on sqlfiddle
p55486
as(dp55487
g6
V335858
p55488
stp55489
a((dp55490
g2
(lp55491
VYou need to do all three levels of sorting inside the objects that you return, like this (I'll show only the , the  needs to be sorted in the same way):
p55492
aVSince you need to select this multiple times, you may want to wrap this code in a method, and use it from several spots, like this:
p55493
as(dp55494
g6
V335858
p55495
stp55496
a((dp55497
g2
(lp55498
VConsider the right triangle  (see the illustration below)
p55499
aVSince the big and the small triangles sharing the  corner are similar, the ratio of the length of the red side  to the length of  is the same as the ratio of  to
p55500
aVSince  is your only unknown, you could figure out the answer by solving the equation
p55501
aVTherefore,
p55502
as(dp55503
g6
V335858
p55504
stp55505
a((dp55506
g2
(lp55507
VI was thinking naming a global variable for  and then
p55508
aVNo, global variable should not be used there (although having a local variable could give you slightly more clarity):
p55509
aVThe trick to this (and any other) recursive function is realizing that there's more than one
p55510
aVSince the function calls itself with a different argument, so each invocation has its own
p55511
aVHere is how the sequence of calls and returns looks:
p55512
aVOnce you see that more than one call to  is active at the same time, this should start to make sense: the chain of calls goes on without returning until it hits the  "no bunny - no ears
p55513
aVclause, at which point the chain starts to unroll, adding the proper number of ears to the return value of the previous invocation
p55514
as(dp55515
g6
V335858
p55516
stp55517
a((dp55518
g2
(lp55519
VAccording to the documentation of the  property, there is no difference:
p55520
aVREMARKS:
p55521
aVYou can use this property to retrieve the value of a specified cache item, or to add an item and a key for it to the cache
p55522
aVAdding a cache item using the Item property is equivalent to calling the  method
p55523
aV(emphasis is mine)
p55524
as(dp55525
g6
V335858
p55526
stp55527
a((dp55528
g2
(lp55529
VYou put  (a pointer to  function) instead of a call to
p55530
aVYou meant to call a function, not to use its name, in comparison expressions:
p55531
as(dp55532
g6
V335858
p55533
stp55534
a((dp55535
g2
(lp55536
VNo, you cannot cast it:  and  are siblings in the inheritance hierarchy, they cannot be cast to one another
p55537
aVIf the method cannot be re-written to take a , you could write the content of the  into a temporary file, and then open a  based on the content of that file
p55538
as(dp55539
g6
V335858
p55540
stp55541
a((dp55542
g2
(lp55543
V is the proper data type to store dates in MySQL
p55544
aVUse  function to output the dates in the format of your choice (you need )
p55545
aVFinding everyone over the age of forty requires constructing a date that is forty years ago from the current date:
p55546
as(dp55547
g6
V335858
p55548
stp55549
a((dp55550
g2
(lp55551
VBuilt-in primitives of C++ all have very simple structure: each one is stored in a single contiguous block of memory
p55552
aVTo initialize or to assign such primitive you need to copy the content of a new value taken in its entirety into the memory region occupied by the primitive
p55553
aVNo other action is necessary
p55554
aVThe old value is always destroyed by this action, be it a previously assigned value or a garbage left in an uninitialized portion of memory
p55555
aVClasses, on the other hand, may have very complex structure
p55556
aVThey may have pointers to other objects, and hold resources that need to be released when a new value is assigned to the object of that class
p55557
aVWhen you perform initialization, you know that the object does not hold other objects or resources yet, so nothing needs to be released
p55558
aVHowever, when you assign an existing object, the resources and objects that it holds may need to be released
p55559
aVThat is why assignment is different from initialization for non-primitives
p55560
as(dp55561
g6
V335858
p55562
stp55563
a((dp55564
g2
(lp55565
VIn your code you use  to access the current element from the beginning of the string, and  to access the current element from the end of the string
p55566
aVYou could create two pointers,  and , and then move them toward each other
p55567
aVTo define pointers, use this:
p55568
aVTo advance the pointers toward each other, use  and
p55569
aVTo see if the pointers have not crossed each other , check that
p55570
aVCurrently, your program checks the string twice; there's no need to do that - you can stop as soon as  becomes less than or equal to the
p55571
aVTo access the character pointed to by the current pointer, use
p55572
aVYou can combine the check with advancing the pointers, like this:
p55573
aVNote: it is not safe to use , because when users enter more characters than fits in your  buffer overrun results
p55574
aVYou should specify the length of the buffer, like this:
p55575
as(dp55576
g6
V335858
p55577
stp55578
a((dp55579
g2
(lp55580
VYou can do it by constructing and compiling a LINQ expression for the specific type, like this:
p55581
aVTo avoid recompiling the expression each time it is used, one could cache it in a dictionary
p55582
aVNote that this approach has certain limitations:
p55583
aVMultiplication of  by  is expected to be defined,
p55584
aVThe output of multiplication is expected to be  without conversion
p55585
aVThis is not true for types smaller than ,
p55586
aVThe type must support conversion from
p55587
aVNone of this is checked at compile time
p55588
as(dp55589
g6
V335858
p55590
stp55591
a((dp55592
g2
(lp55593
VYou can define a method that checks a string for , and updates the status, like this:
p55594
aVNow you can change the main method to call  repeatedly:
p55595
as(dp55596
g6
V335858
p55597
stp55598
a((dp55599
g2
(lp55600
VI thought you cannot instantiate an interface in Java
p55601
aVYou are 100% right, you cannot do that
p55602
aVHowever, you can instantiate classes that implement the said interface, which is precisely what the  method does
p55603
aVThe  class defines an inner class implementing
p55604
aVObjects of this class know about the  object which they iterate, and also provide the methods mandated by the  interface
p55605
aVThis is practice is commonplace in Java: it lets you hide implementation behind interfaces, forcing the users of your library program to interfaces
p55606
aVThe results become more maintainable, because programming to interfaces results in decreased coupling
p55607
as(dp55608
g6
V335858
p55609
stp55610
a((dp55611
g2
(lp55612
Vand  all point to the same memory
p55613
aVTheir  pointers do point to the same memory, but the objects themselves are separate (albeit thay have an identical content)
p55614
aVand if  is deleted, or  is deleted, what will happen
p55615
aVNeither one can be deleted, but they can go out of scope
p55616
aVNothing would happen, because there is no destructor (which is bad)
p55617
aVdoes it will cause the corrupt the other object
p55618
aVor a memory leak
p55619
aVAn object of type  going out of scope or being deleted would cause a memory leak even without an assignment
p55620
aVThat is the fault of the  class, because it does not have a destructor
p55621
aVEvery time you have an allocation in the constructor, you need a destructor to re-allocate the resources the constructor allocates
p55622
aVOnce you add a destructor, The Rule of Three becomes relevant: you need to implement all of the following:
p55623
aVA destructor,
p55624
aVA Copy Constructor, and
p55625
aVAn assignment operator
p55626
aVWith all three functions implemented, your  class becomes safe and leak-free: assignment of  to  cleans up the current  before making an assignment, and copies the string
p55627
aVNow two objects point to separate s, ensuring that these could be destroyed without bringing each other down
p55628
aVNote: Every time you see an explicit allocation in the constructor, ask yourself if that allocation is absolutely necessary, and that the pointer cannot be replaced with an object
p55629
aVIn case of your  class the answer to "is the pointer necessary
p55630
aVquestion is a resounding "no": you can easily make  a , which would immediately free you from the need to add a destructor, a copy constructor, or an assignment operator
p55631
aVEverything would "just work" - without memory leaks, double-deletes, or any other undesirable side effects
p55632
as(dp55633
g6
V335858
p55634
stp55635
a((dp55636
g2
(lp55637
VYou can do it like this:
p55638
aVRead the entire line using
p55639
aVMake an input string stream from that line
p55640
aVRead the content of that string stream into a
p55641
aVIt will grow automatically to accommodate as many inputs as the user enters
p55642
aVExamine the size of the resultant vector to see how many entries the end-user made
p55643
aVHere is how you can do it in code:
p55644
aVHere is a demo on ideone
p55645
as(dp55646
g6
V335858
p55647
stp55648
a((dp55649
g2
(lp55650
VThe namespace has no effect on the memory used: the pointer to  is in the global (static) memory area, while the object to which it points is in the dynamic (heap) memory area
p55651
aVThis is as safe as using a named namespace
p55652
as(dp55653
g6
V335858
p55654
stp55655
a((dp55656
g2
(lp55657
VThere are several ways of ensuring that  is always "in sync" with the left and right:
p55658
aVMaking  immutable, and setting the  in the constructor, or
p55659
aVAdding setter functions for all your variables, and updating  every time  or  is changed, or
p55660
aVReplacing  variable with the  member function, like this:
p55661
aVI prefer this last method, because it is usually more economical, and because it greatly reduces the probability of introducing bugs during maintenance
p55662
as(dp55663
g6
V335858
p55664
stp55665
a((dp55666
g2
(lp55667
VIn your code you create two objects, , and
p55668
aVInitially, your  variable points to the first font object
p55669
aVThen you copy that pointer in the assignments to fonts of the three labels
p55670
aVAt this moment, you have four pointers referencing the same object - namely, the object returned by the  call
p55671
aVNext, you change  to point to
p55672
aVOnce you do that, the  starts pointing to that new object; it no longer points to the old object
p55673
aVHowever, the three labels are still pointing to the old font, so their appearance does not change
p55674
as(dp55675
g6
V335858
p55676
stp55677
a((dp55678
g2
(lp55679
VIf the array has two different types, you could add an  statement, like this:
p55680
aVA slightly better approach would be to cast using the  operator, like this:
p55681
aVFinally, a very good approach would be writing two separate methods for the two types, and using  to perform a dispatch
p55682
aVTo do that, define two functions, like this:
p55683
aVNow change your loop as follows:
p55684
as(dp55685
g6
V335858
p55686
stp55687
a((dp55688
g2
(lp55689
VHere is a little table of VB
p55690
aVNET to C# operators:
p55691
as(dp55692
g6
V335858
p55693
stp55694
a((dp55695
g2
(lp55696
VYou need this:
p55697
aVOf course you must check that 's length is at least 1, otherwise there would be an exception:
p55698
as(dp55699
g6
V335858
p55700
stp55701
a((dp55702
g2
(lp55703
VYou have misplaced the closing quote: this
p55704
aVshould be this:
p55705
aVCurrently, your code does not read any of the digits, so  elements remain uninitialized
p55706
aVThe code that you have expects the input in the following format:
p55707
aVi
p55708
ag630
aVdigits separated by commas
p55709
aVIf you would like to let the user enter all digits at once, you could change the approach to let the user enter six digits into a string, and then subtract  from each character to convert digit characters to their corresponding numeric values:
p55710
as(dp55711
g6
V335858
p55712
stp55713
a((dp55714
g2
(lp55715
VYou need to be aware of an effect of defining a  variable in a header file: when this happens, each translation unit1 that includes your header will get its own copy of the  array, regardless of whether you use it or not
p55716
aVA better approach would be establishing this array as a singleton, or if it is truly a constant, defining it as a global, and adding an  for it in the header2:
p55717
aVThe
p55718
aVh file:
p55719
aVThe
p55720
aVm file:
p55721
aV1 "translation unit" is a fancy name for a  or  file
p55722
aV2 Note how the length of the array needs to be defined separately; otherwise, the trick with dividing the s is not going to work
p55723
as(dp55724
g6
V335858
p55725
stp55726
a((dp55727
g2
(lp55728
Vwhen is  being invoked
p55729
aVBefore  or after that
p55730
aVChances are, it's never going to be invoked: since this is a const-initialized value, it may be initialized by the loader of the executable on your system without running any code
p55731
aVHad it been initialized with some code, e
p55732
ag303
aV, that would complete before the
p55733
aVsince a is a static member, why it can be defined twice with  and \u201cinitialized here"\uff1f
p55734
aVThe second one is an assignment, not a declaration
p55735
as(dp55736
g6
V335858
p55737
stp55738
a((dp55739
g2
(lp55740
VThis expression takes a four-part string separated with three colons, for example
p55741
aVThe only requirement to that string is that three colons must be there, that the items between the colons (or between the colon and the beginning/the end of the string) had at least one non-colon character, and that the content occupied the entire string
p55742
aVThe expression creates four capturing groups - one for each of the colon-separated elements of the string
p55743
aVSince the non-colon character class  is always followed by a colon, the reluctant quantifier can be removed:
p55744
aVA way to accomplish the same thing without a regex would be using , and checking that you get exactly four components back:
p55745
as(dp55746
g6
V335858
p55747
stp55748
a((dp55749
g2
(lp55750
VThis is not as much a problem with the inner list as it is the problem of the generic parameter
p55751
aVAs long as the generic parameter is the same (i
p55752
ag630
aV) the initialization succeeds
p55753
aVOtherwise, Java does not let you make an assignment, because the compiler cannot guarantee type safety
p55754
aVImagine that this is possible:
p55755
aVNow the following must be valid:
p55756
aVHowever, this is invalid, because the object is an  of s, so inserting a linked list into it is clearly invalid
p55757
aVYou can do this, however:
p55758
aVThis should be good enough to program to the interface
p55759
as(dp55760
g6
V335858
p55761
stp55762
a((dp55763
g2
(lp55764
VThere are two problems with this code:
p55765
aVrepresents the number of items the list can contain before resizing is required, not the actual count; you need to use  instead, and
p55766
aVWhen you remove from the list, you should go backwards, otherwise you could skip the second item when two identical items are next to each other
p55767
as(dp55768
g6
V335858
p55769
stp55770
a((dp55771
g2
(lp55772
VYou can add the check for the word boundary  around the word to avoid "false positives":
p55773
aVThis would ensure that words would match only when they come by themselves, not as part of some other word
p55774
aVI want this to ignore what ever is in the parenthesis
p55775
aVThen you should avoid preprocess your string before applying regex to it, like this:
p55776
aVThis code removes everything enclosed in parentheses if parentheses are properly balanced; otherwise, it returns the original string
p55777
as(dp55778
g6
V335858
p55779
stp55780
a((dp55781
g2
(lp55782
VThis is a common extension implemented by C++ compilers, such as GNU's g++
p55783
aVCompile with  flag to treat such declaration as an error
p55784
as(dp55785
g6
V335858
p55786
stp55787
a((dp55788
g2
(lp55789
VThe first syntax is a GNU extension to C language, called Statement Expression
p55790
aVIt is incompatible with any of C standards, so you would be better off avoiding altogether in favor of the second syntax, which is a lot more readable
p55791
as(dp55792
g6
V335858
p55793
stp55794
a((dp55795
g2
(lp55796
VSince  is immutable, you need to add a constructor that lets you initialize it with meaningful data:
p55797
aVWithout such constructor, your  structure would be unusable
p55798
aVIf you would like your  to be modifiable, you should prefer containment in this situation:
p55799
aVIf you would like to make your  usable where  is required, add an implicit conversion operator to the class, returning the  property contained inside the  object
p55800
as(dp55801
g6
V335858
p55802
stp55803
a((dp55804
g2
(lp55805
VIf reading a CSV is an option in your situation, I would definitely go for it, because you can do it in a way that is both system-independent and portable without using external libraries
p55806
aVAs far as the efficiency goes, the timing is very likely going to be I/O dominated, so the smaller the file - the faster you are going to read it in
p55807
aVAdding the missing information and writing the file back may be a bit tricky because of the need to properly handle quotes, but it is still a lot simpler than accessing an Excel file through a special-purpose library
p55808
as(dp55809
g6
V335858
p55810
stp55811
a((dp55812
g2
(lp55813
VAll collections - lists, array lists, linked lists, and so on, - stay in memory
p55814
aVYou are writing a program that manages socket I/O, so in terms of performance it does not really matter what collection you use: the performance of that portion of your system will be dominated by I/O and system calls to manage sockets
p55815
aVThat is why I would stay with , the "more modern" option (strictly speaking,  is more than ten years old, so it is "modern" only in comparison to the )
p55816
as(dp55817
g6
V335858
p55818
stp55819
a((dp55820
g2
(lp55821
VIs it wanting some kind of for loop
p55822
aVThe assignment says that you should not implement your function, so no, they do not want to see a loop
p55823
aVAll they want is a "signature" of the function - something that details the following three things:
p55824
aVThe name of the function
p55825
aVThe type of the value the function returns (if any; use  for "no return value")
p55826
aVThe types and the order of the parameters the function takes (if any)
p55827
aVThe syntax for function headers is as follows:
p55828
aVNote: This is an example, not an answer to your assignment
p55829
as(dp55830
g6
V335858
p55831
stp55832
a((dp55833
g2
(lp55834
VGeneric classes do not support covariance, but interfaces do
p55835
aVIf you define an interface  and mark  as an  parameter, like this,
p55836
aVyou will be able to do this:
p55837
aVHowever, this would limit the ways in which the  parameter could be used inside  and its implementations
p55838
aVDemo on ideone
p55839
as(dp55840
g6
V335858
p55841
stp55842
a((dp55843
g2
(lp55844
Vs are objects
p55845
aVObjects always go on the dynamic storage
p55846
aVStoring one-character string would require at least a dozen of bytes
p55847
aVs (not s) are primitives
p55848
aVThey take fixed amount of space (2 bytes)
p55849
aVIn situations when you need to process a single character, creating one-character string is a waste of resources
p55850
aVMoreover, when you expect to see a single character, using strings would require validation that the data passed in has exactly one character
p55851
aVThis would be unacceptable in situations when you must be extremely fast, such as character-based input and output
p55852
aVTo summarize, you need a  because of
p55853
aVMemory footprint - a  is smaller than a  of one character
p55854
aVSpeed of processing - creating objects carries an overhead
p55855
aVProgram's maintainability - Knowing the type makes it easier for you and for the readers of your code to know what kind of data is expected to be stored in a  variable
p55856
as(dp55857
g6
V335858
p55858
stp55859
a((dp55860
g2
(lp55861
VThe issue I'm having is that , strictly speaking, isn't a
p55862
aVIt's just a file
p55863
aVThat's the only consideration that you need: once you say that logically a  is not a , you should exclude inheritance from your list of choices
p55864
aVThat is not to say that you shouldn't give  a  method, though: if you find it more convenient to have  right on the  class, then it makes perfect sense to add the method
p55865
aVI would like to create a "Path" interface that  and  would both implement, in order to allow generic lists of both  and
p55866
aVThat sounds like a good idea
p55867
aVAn interface is a nice, lightweight alternative to subclassing that makes more sense in your situation
p55868
aVProperly named, such an interface would add clarity to your overall system, without adding confusion associated with doubtful inheritance
p55869
as(dp55870
g6
V335858
p55871
stp55872
a((dp55873
g2
(lp55874
VYou get the error because there is a standard function called  defined in the namespace , which your program allowed the compiler to use without an explicit reference
p55875
aVRemove
p55876
aVand add  qualifier to  where it's missing to fix this problem
p55877
aVDemo of your program compiling on ideone
p55878
as(dp55879
g6
V335858
p55880
stp55881
a((dp55882
g2
(lp55883
VWhen you do not know the keys that are present in the dictionary, for example, because the key-value pairs come from an external source, you can use  method to go through all key-value pairs present in the dictionary:
p55884
as(dp55885
g6
V335858
p55886
stp55887
a((dp55888
g2
(lp55889
VThe operating system has little involvement in this: at the time your threads are running, the memory allocated to  is under control of JVM running your program, so it's your program that is in control
p55890
aVWhen two threads access the same memory location, the last writer wins
p55891
aVWhich particular thread gets to be the last writer, however, is non-deterministic, unless you use synchronization
p55892
aVMoreover, without you taking special care of accessing the shared data, one thread may not even see the results of the other thread writing to the  location
p55893
aVTo avoid synchronization issues, you should use synchronization or one of the  classes
p55894
as(dp55895
g6
V335858
p55896
stp55897
a((dp55898
g2
(lp55899
VOne important issue when dealing with constants defined in code is the need to recompile whenever any of these constants changes
p55900
aVWhen your constants represent strings that may need to be updated in production, such as the code of your stored procedures or user-defined functions that you load into the database at start-up, using a file that you ship with your product and store at a predefined location may provide a more flexible alternative
p55901
aVAs far as the performance goes, accessing string constants defined in code is faster than reading them from an external location
p55902
as(dp55903
g6
V335858
p55904
stp55905
a((dp55906
g2
(lp55907
VHere is a short list of when you may want to use a daemon thread:
p55908
aVCollecting statistics and performing the status monitoring tasks - Sending and receiving network heartbeats, supplying the services to monitoring tools, and so on
p55909
aVPerforming asynchronous I/O tasks - You can create a queue of I/O requests, and set up a group of daemon threads servicing these requests asynchronously
p55910
aVListening for incoming connections - daemon threads are very convenient in situations like this, because they let you program a simple "forever" loop, rather than creating a setup that pays attention to exit requests from the main thread
p55911
as(dp55912
g6
V335858
p55913
stp55914
a((dp55915
g2
(lp55916
VYou need to make your  variable , otherwise the value of  will be cached
p55917
aVAlso, there's no reason to make it  - a primitive would work as well:
p55918
aVYou also need to change the condition of the inner loop to pay attention to :
p55919
aVYou could also add a call to , but since your thread is never more than a second away from checking the flag, this is not necessary
p55920
as(dp55921
g6
V335858
p55922
stp55923
a((dp55924
g2
(lp55925
VAn easy way to understand the difference is to think that an interface defines what an object does, while a class defines how it does it
p55926
aVThe analogy that you are suggesting is incomplete, because Java has a concept that is in the middle of an interface and a class, i
p55927
ag630
aVan abstract class: a specification may be modeled as an abstract class or as an interface
p55928
as(dp55929
g6
V335858
p55930
stp55931
a((dp55932
g2
(lp55933
VThis is because you have violated the rule of three: if you have a destructor, you almost certainly need to have a copy constructor and an assignment operator as well
p55934
aVOf course the best way of dealing with pointers is to find a way of not having pointers at all ("the rule of zero"): in situations like that compiler-generated destructors, constructors, and assignment operators would take care of managing the resources automatically for you
p55935
as(dp55936
g6
V335858
p55937
stp55938
a((dp55939
g2
(lp55940
VWhen you return by pointer, you need to return a dynamically allocated object the way that you show (i
p55941
ag630
aVreturning a pointer to a stack object results in undefined behavior if it is dereferenced later)
p55942
aVThis creates a potential for memory leaks, because, like you have noted, that object needs to be deleted explicitly
p55943
aVReturning by value, on the other hand (i
p55944
ag630
aVthe second snippet) results in copying the object that you return from the stack object that you return into the object that receives the return value:
p55945
aVCompilers can optimize this to avoid copying through return value optimization
p55946
as(dp55947
g6
V335858
p55948
stp55949
a((dp55950
g2
(lp55951
VWhy would any one use macro for defining (declaring variable in C language)
p55952
aVThe macro does not define a variable, it defines a constant
p55953
aVYour C program that uses  that's d is indistinguishable to the compiler from a program that contains the hard-coded value
p55954
aVUnlike  variable, the  macro cannot be changed at run-time, and does not have an address
p55955
aVFinally, it is possible to provide values for macros on the command line when calling the compiler - something impossible to do when you are dealing with C variables
p55956
aVInstead of defining  you could pass the value on the command line, like this:
p55957
as(dp55958
g6
V335858
p55959
stp55960
a((dp55961
g2
(lp55962
VSpecific types such as  and  cannot be cast to , but  can be
p55963
aVThis should work:
p55964
aVHowever, it's a little strange that you need to do this in the first place: rather than jumping through hoops with generics, you could deal with the problem more gracefully with multiple methods:
p55965
aVNow you can call these methods like this:
p55966
aVor like this:
p55967
as(dp55968
g6
V335858
p55969
stp55970
a((dp55971
g2
(lp55972
VYou can change your loop as follows:
p55973
as(dp55974
g6
V335858
p55975
stp55976
a((dp55977
g2
(lp55978
Vis there really something called generic exception handler
p55979
aVYes - that's what they call the handler that logs the exception and stores as much info as possible before quitting the program
p55980
aVOne way to set up a handler like that is adding a handler to the  event of your  object
p55981
aVIt is neither "generic" nor a "handler" in the
p55982
aVNET sense, because no generic types are involved, and because the actions the handler could take are rather limited
p55983
aVUnlike a real handler which could block or re-throw the exceptions that it handles, the last-chance "handler" could see what's been thrown, but cannot cause the execution to continue
p55984
as(dp55985
g6
V335858
p55986
stp55987
a((dp55988
g2
(lp55989
VLeaving the conversation on whether singletons are evil or not, let's consider only the thread safety issues in your  class:
p55990
aVThe shared object is created "lazily" - this needs synchronization to avoid making two instances of ; you have correctly identified and fixed this issue
p55991
aVHowever, since initializing  does not take much time, you might as well make  a trivial getter by initializing  eagerly
p55992
aVThe hash map inside the School - concurrent access to the hash map will result in exceptions
p55993
aVYou need to add synchronization around the code that adds, removes, and iterates students to avoid these exceptions
p55994
aVAccess to individual students - once the callers get a  object, they may start modifying it concurrently
p55995
aVTherefore the  object needs concurrency protection of their own
p55996
as(dp55997
g6
V335858
p55998
stp55999
a((dp56000
g2
(lp56001
VUse Disjoint-Set Forest data structure
p56002
aVThe data structure supports three operations:
p56003
aV- creates a new set with a single item
p56004
aV- Given an item, look up a set
p56005
aV- Given two items, connects together the sets to which they belong
p56006
aVYou can go through each array, and call  on its first element and each element that you find after it
p56007
aVOnce you are done with all arrays in the list, you will be able to retrieve the individual sets by going through all the numbers again, and calling  on them
p56008
aVNumbers the  on which produce the same set should be put into the same array
p56009
aVThis approach finishes the merge in  amortized ( grows very slowly, so for all practical purposes it can be considered a small constant)
p56010
as(dp56011
g6
V335858
p56012
stp56013
a((dp56014
g2
(lp56015
V is a built-in special constant that represents an empty object reference, not a variable
p56016
aVWhen you declare a variable representing an object at the class or at the instance level, its initial value is set to
p56017
aVWhen you declare a local variable, you must set its value explicitly - to  or to some object
p56018
as(dp56019
g6
V335858
p56020
stp56021
a((dp56022
g2
(lp56023
VIs there a memory leak here
p56024
aVWhen the  will be deleted
p56025
aVThe answer depends on the caller: it is up to the caller to receive the result by reference or by pointer, and call the
p56026
aVIf you do it like this, there's no leak
p56027
aVIf you do it like this
p56028
aVthere's a leak of the return value of
p56029
aVIt goes without saying that all of the above is rather unnatural, and should therefore be avoided
p56030
aVNOTE : (in response to a comment about  being function-) Also note that since  is function-static, the allocation happens only once
p56031
aVThe deletion needs to happen only once as well
p56032
aVA typical pattern to follow in this situation is using a smart pointer instead of a regular one, like this:
p56033
aVIf you do it like that, the leak would be eliminated automatically by the smart pointer, and the callers would not need to think about deleting the object
p56034
as(dp56035
g6
V335858
p56036
stp56037
a((dp56038
g2
(lp56039
VUnfortunately, you can't directly access the ivars belonging to your superclass (as far as I can tell)
p56040
aVThat is only in situations when the base class declares ivars
p56041
aVIf it does not, you can access ivars using the  operator on , like this:
p56042
aVBy default, ivars have  access, so you should be able to access them unless the designers of your superclass have specifically withdrew this possibility by specifying private access
p56043
aVAm I misunderstanding something, or do I have no choice but to violate the rule about messaging self in my scenario
p56044
aVAnother choice is passing values to the designated initializer of your base class:
p56045
as(dp56046
g6
V335858
p56047
stp56048
a((dp56049
g2
(lp56050
VYour problem is that you've got three instances of  where you could be setting the instance variable:
p56051
aVLocal  allocated inside ,
p56052
aVFunction-static  allocated inside , and
p56053
aVInstance variable  which you never allocate, so it stays
p56054
aVIt is the third instance on which you try calling your setters
p56055
aVSince it's , the calls have no effect:  does nothing
p56056
aVTo fix this, drop the second and the third variables, along with the  method
p56057
aVUse the regular instance properties, rather than accessing the shared one
p56058
aVYou can harvest the results from the local  variable upon completion of the  call:
p56059
as(dp56060
g6
V335858
p56061
stp56062
a((dp56063
g2
(lp56064
VYou can do it like this:
p56065
aVFirst, add  and  to , like this:
p56066
aVNext, define a class that can compare sets of items for equality, like this:
p56067
aVNow your query can be formulated as follows:
p56068
as(dp56069
g6
V335858
p56070
stp56071
a((dp56072
g2
(lp56073
VThe problem happens because the asynchronous image request finishes after your cell scrolls off the screen and gets reused
p56074
aVDownloads complete "out of order", contributing to a visual confusion
p56075
aVEssentially, some of the cells put up for reuse by scrolling, are still "hot", in the sense that their image load is in progress
p56076
aVReusing such cell creates a race between the old and the new image downloads
p56077
aVYou should change the strategy that you use to load the images: rather than sending a request and "forgetting" it, consider using  method, storing the connection in the cell, and calling  on it when  method is called
p56078
aVThis way your reused cells would be "cold"
p56079
as(dp56080
g6
V335858
p56081
stp56082
a((dp56083
g2
(lp56084
VThere are (at least) two ways of fixing this:
p56085
aVMove the conditions from the  clause into the  clause of the join, or
p56086
aVAdd an explicit  to each condition
p56087
aVConsider this example query:
p56088
aVHere is how to do it using #1:
p56089
aVHere is how to do it using #2:
p56090
as(dp56091
g6
V335858
p56092
stp56093
a((dp56094
g2
(lp56095
VNote that only the initial value of the result is set to , not the final one
p56096
aVThe final value is calculated by combining that initial value with hash codes of other parts of the object, multiplied by a power of a small prime number (i
p56097
ag630
ag1783
aVUsing  rather than an arbitrary prime is definitely right in this context
p56098
aVIn general, there is no advantage to hash code being prime (it's the number of hash buckets that needs to be prime)
p56099
aVUsing an  as its own hash code (in your case, that's  and ) is a valid approach
p56100
as(dp56101
g6
V335858
p56102
stp56103
a((dp56104
g2
(lp56105
VGetters and setters enable you to combine a pair of functions into one property, and let you use a syntax that looks like a member access expression or an assignment in place of syntax that looks like an explicit function call
p56106
aVHere is a small example: instead of this
p56107
aVthey let you do this:
p56108
aVThe syntax of the second code snippet is easier to read, because  looks like a variable
p56109
aVAt the same time, the second snippet provides the same level of encapsulation, letting you hide the implementation behind the property
p56110
as(dp56111
g6
V335858
p56112
stp56113
a((dp56114
g2
(lp56115
VI think you misplaced the closing brace: the second loop should be after the first loop, not inside it
p56116
aVMoreover, converting a list to an array can be done with  method instead of the loop
p56117
as(dp56118
g6
V335858
p56119
stp56120
a((dp56121
g2
(lp56122
VSince  is always one character, you should make it a , not a
p56123
aVThis would help you identify the problem, which is that you are calling  on a wrong target:
p56124
aVYou also need to reverse the call of  and advancing  to the next position in : otherwise, you would always miss the first position, and add  in place of the last position of
p56125
as(dp56126
g6
V335858
p56127
stp56128
a((dp56129
g2
(lp56130
VNow that the other answer has identified the problem in your statement, here is a modernized way to achieve the same result in a single line:
p56131
aVThe idea is to use C++11's lambdas to perform counting in two dimensions:
p56132
aVgoes through the vector one string at a time, and calls the top-level lambda
p56133
aVgoes through your strings character-by-character, computing the number of non-dash characters
p56134
aVHere is a demo on ideone
p56135
as(dp56136
g6
V335858
p56137
stp56138
a((dp56139
g2
(lp56140
VAre there situations where the above would yield unexpected/inefficient results
p56141
aVIn cases when neither  nor  enumerate the entire list of s, and the  are not given to you as a , converting to list would be more expensive
p56142
aVFor example, when  takes the first five elements,  takes ,  come from a non-cached context, and contain thousands of items, the  approach is going to be less efficient
p56143
aVTo avoid Resharper squiggles, the suggested fix is
p56144
aVNot all Resharper warnings must be fixed
p56145
aVThe tool attracts your attention to the problem, and it is up to you to fix it or to ignore the warning
p56146
aVResharper is consistent at looking out for potential trouble, but only you know what's happening inside  and
p56147
aVIf you think that it's more efficient to avoid materializing the list, use the  comments to avoid the squiggles
p56148
as(dp56149
g6
V335858
p56150
stp56151
a((dp56152
g2
(lp56153
VThe problem is on this line:
p56154
aValready includes
p56155
aVHere is a demo on ideone printing
p56156
as(dp56157
g6
V335858
p56158
stp56159
a((dp56160
g2
(lp56161
VIn general, you should aim for your  to be a bridge between the execution environment (the OS) and the system that you implement
p56162
aVThis means that  should "crack" the command-line parameters, and then promptly pass control to the method that instantiates top-level objects and runs your system
p56163
as(dp56164
g6
V335858
p56165
stp56166
a((dp56167
g2
(lp56168
VTo convert a string to  use
p56169
aVTo convert a  to , use  constructor:
p56170
aVHowever, this is not the most performant solution, for several reasons:
p56171
aVYou do not need to construct a  array to check if a string is a palindrome - you can walk the string from both ends, comparing the characters as you go, until you either find a difference or your indexes meet in the middle
p56172
aVRather than constructing a new array in a loop, you could reuse the same array - in case you do want to continue with an array, you could allocate it once for the maximum length of the product , and use it in all iterations of your loop
p56173
aVYou do not need to convert a number to string in order to check if it is a palindrome - you can get its digits by repeatedly taking the remainder of division by ten, and then dividing by ten to go to the next digit
p56174
aVHere is an illustration of the last point:
p56175
as(dp56176
g6
V335858
p56177
stp56178
a((dp56179
g2
(lp56180
VGood chances are that your first query isn't going to work at all, unless you force bringing the data into the memory by calling , , or , because EF provider does not know how to translate your  function to SQL
p56181
aVThe second query, on the other hand, should work fine, because it's a string-to-string comparison
p56182
aVIn addition, the second way of querying lets you implement a potentially more secure scheme when "encrypting" a string cannot be reversed with a , e
p56183
ag303
aVwhen you store a message digest
p56184
as(dp56185
g6
V335858
p56186
stp56187
a((dp56188
g2
(lp56189
VYou are setting the value on a wrong object:  is local to your method, it is not the controller that gets displayed later, when the segue is fired (or whatever is the method through which you open the actual view controllrer)
p56190
aVInstead of placing your code in , place your code in
p56191
aVYou can access the target view controller from there, like this:
p56192
aVFinally, the proper place to display the value of  is , not , because loading of the view happens before you can set  on the controller
p56193
as(dp56194
g6
V335858
p56195
stp56196
a((dp56197
g2
(lp56198
VOne way to do it is to cache the result in the provider, and return it on all subsequent calls, like this:
p56199
aVThis implementation requests the number from the user only the first time the  method is invoked; all subsequent invocations use  read in the first invocation
p56200
aVNote that I made  method non-static, so you need to pass  to the classes that need the number
p56201
as(dp56202
g6
V335858
p56203
stp56204
a((dp56205
g2
(lp56206
VIs there anything i can do to avoid this when compiling my C code
p56207
aVThe only thing you can do is to not hard-code the password or any sensitive information into your C program: even if you encrypt this sensitive information in one way or the other, either the decryption key would need to be provided at runtime by a user running your program, or the info could be decrypted by a sufficiently motivated person
p56208
aVYou might as well prompt the user for the password
p56209
aVNote that any other form of hiding would be a mere obfuscation - a small obstacle on the way of a user who is trying to access your secret information
p56210
aVIt may deter a few "script kiddies", but it would fall to the first knowledgeable user
p56211
as(dp56212
g6
V335858
p56213
stp56214
a((dp56215
g2
(lp56216
VYou are trying to find the size of the function itself not its return value
p56217
aVIn order to find the type of the return value, you need to add a pair of parentheses to tell the compiler that you need the type of the function call expression, like this:
p56218
aVNote that the functions are not going to be called: the sizeof of their return type will be figured out at compile time
p56219
aVDemo on ideone
p56220
as(dp56221
g6
V335858
p56222
stp56223
a((dp56224
g2
(lp56225
V happens when the code that gets executed during the process of loading the type throws an exception
p56226
aVWhen
p56227
aVNET loads the type, it must prepare all its static fields before the first time that you use the type
p56228
aVSometimes, initialization requires running code
p56229
aVIt is when that code fails that you get a
p56230
aVIn your specific case, the following three static fields run some code:
p56231
aVNote that  depends on , but it is declared ahead of its dependency
p56232
aVTherefore, the value of  is  at the time that the  is called, resulting in
p56233
aVSame goes for the  and : they are declared in reverse order to the desired order of initialization
p56234
aVRe-order the lines to fix this problem:
p56235
as(dp56236
g6
V335858
p56237
stp56238
a((dp56239
g2
(lp56240
VThe primary purpose of giving an assembly a strong name is preventing malicious users of someone else's code that uses your assembly from substituting your code with their own
p56241
aVConsider this situation: you make a  assembly that you give to your customers so that they could communicate with your server in a secure way
p56242
aVIf  is not signed, malicious users would be able to write their own module that presents the same interface as yours, wrap your code in their own malicious code, intercept all of "secure" transmissions of your customer, and send a copy to their own server
p56243
aVThey would be able to do it without having access to the source code of your customers, simply by replacing your  with theirs
p56244
aVIf  is signed, however, and your customers' code is linked against it, the trick with swapping the assemblies is not going to work: when your customers' code would try loading ,
p56245
aVNET would notice the change, and stop the program from starting up
p56246
as(dp56247
g6
V335858
p56248
stp56249
a((dp56250
g2
(lp56251
VYou can do it like this:
p56252
aVDemo on sqlfiddle
p56253
aVThe inner query finds all such s that have duplicates, and uses their values to filter the rows of the outer query
p56254
as(dp56255
g6
V335858
p56256
stp56257
a((dp56258
g2
(lp56259
VThis is not a conversion, because construct a  object explicitly:
p56260
aVThis, however, is a conversion:
p56261
aVand so is this:
p56262
aVBoth conversions above would work even if the constructor is explicit, because they invoke conversion,
p56263
aVwell, explicitly
p56264
aVThe other two would not work with an explicit constructor:
p56265
aVHere the conversion is implicit, i
p56266
ag630
aVthe operation is implied by the type of the left-hand side of the assignment, and the presence of a constructor taking an expression on the right-hand side
p56267
aVThe compiler cannot apply the constructor declared  in situations like this, so if you uncomment  in the declaration above, this snippet is not going to compile
p56268
as(dp56269
g6
V335858
p56270
stp56271
a((dp56272
g2
(lp56273
VBecause C allows compilers to add padding between the elements of a  to make the generated code more performant
p56274
aVSome hardware allows accessing multi-byte data faster when such data is placed at memory addresses divisible by the size of the data
p56275
aVFor example, accessing a 32-bit  may go significantly faster when the  is located at address  or  than when the same  is located at an address  or
p56276
aVThe standard allows compilers to adjust offsets of  members to make use of such optimization
p56277
aVMoreover, there are platforms where accessing a multi-byte value not aligned with the memory space results in an error: for example, reading a 16-bit  from an odd address in 68000 architecture triggers bus error
p56278
aVCompilers know this, and they add unused space to your  so that accessing multi-byte fields does not trigger an error
p56279
as(dp56280
g6
V335858
p56281
stp56282
a((dp56283
g2
(lp56284
VThere are two kinds of parameters that your method can modify - the  ones, and the  ones
p56285
aVIn both cases parameter modifications inside your method are passed back to the corresponding variable in the caller, but the important difference is that you must assign the  parameter before you are allowed to make first use of its value inside your method
p56286
aVSince your example uses the  parameters before making assignments, you should declare them as  rather than :
p56287
aVAnother important difference between  and  is that all  variables must be assigned in all code paths through your method, while assigning  parameters is optional
p56288
as(dp56289
g6
V335858
p56290
stp56291
a((dp56292
g2
(lp56293
VThe  call happens before the flipside view controller is loaded
p56294
aVSince Objective C does not mind it when you call methods on a , the call
p56295
aVsucceeds without a warning
p56296
aVRather than trying to "push" the context onto your flipside view controller, try "pulling" it from your  method, like this:
p56297
as(dp56298
g6
V335858
p56299
stp56300
a((dp56301
g2
(lp56302
V"Segmentation fault" is not an output, it's an indication that your program has crashed
p56303
aVThis should come as no surprise, because string literals are , not
p56304
aVTrying to double-derefefence such pointers is undefined behavior, because it re-interprets the content of a string literal as a pointer to
p56305
aVThis is what is causing the crash
p56306
aVYou can modify your program as follows to make it legal:
p56307
as(dp56308
g6
V335858
p56309
stp56310
a((dp56311
g2
(lp56312
VSince  returns a pointer to , there is no reason to use a C++ - style cast on the pointer: you get a chunk of raw memory, with no structure behind it, so the only thing your can tell the compiler by adding a cast is that you plan to use this memory for data of a particular kind
p56313
aVCompiler must agree with you on that, because it has no additional information to double-check your decision
p56314
aVNeither  nor the  offer a particular advantage over the C-style cast, and the C-style cast is shorter
p56315
aVFrom the personal perspective, I looked at a lot of C++ code, but I've never seen a C++ - style cast used with , only the C-style
p56316
as(dp56317
g6
V335858
p56318
stp56319
a((dp56320
g2
(lp56321
VYou do not need to count digits upfront: it's costly, and it does not work for negative numbers
p56322
aVSince you specified that you would like to see a two's complement representation, use  for your  to avoid negatives
p56323
aVChange your loop to continue dividing by  until the number gets to zero, like this:
p56324
as(dp56325
g6
V335858
p56326
stp56327
a((dp56328
g2
(lp56329
VYour  defines a type for a function pointer
p56330
aVTaking a "value" of a function pointer has no meaning: it is a pointer to a piece of executable code; you need to call it to make it useful
p56331
aVYou call a function through a pointer in the same way as if it were a function known to you by name, i
p56332
ag630
aVby appending a parenthesized list of parameters to the pointer
p56333
aVHere is what you can do with  or :
p56334
aVNote how in the last four lines two calls of  perform different tasks based on what you pass: the first call prompts the user for an entry, while the second call returns five right away
p56335
as(dp56336
g6
V335858
p56337
stp56338
a((dp56339
g2
(lp56340
VThis is a common example of a situation when changing the data structure a little could make the logic a lot simple by unifying the cases that otherwise look different *
p56341
aVThe main issue with the logic is that you have lots of conditions to check:
p56342
aVDeleting the first node that has other nodes after it
p56343
aVDeleting the last node that has other nodes preceding it
p56344
aVDeleting the only node
p56345
aVDeleting a node in the middle
p56346
aVYou can make these four conditions identical to the last one by ensuring that there is always a node on the left and a node on the right of any node
p56347
aVHere is how you can do it:
p56348
aVThe  pointer is 's ; the  pointer is its
p56349
aVBoth next and previous point back to itself in an empty list
p56350
aVThis is a little inefficient, because the  of the  is unused
p56351
aVThe list becomes circular, with one node always present
p56352
aVWith this node in place, you can safely remove any node in the middle, and update the prior and the next pointers as if they belonged to different objects
p56353
aV* Here is a link to an excellent reading not directly related to the problem at hand, but very useful to understanding the philosophy of this approach
p56354
as(dp56355
g6
V335858
p56356
stp56357
a((dp56358
g2
(lp56359
VYou need to first order, and then select, like this:
p56360
aVOtherwise, LINQ thinks that you are trying to order the characters of the , which is not a supported operation
p56361
as(dp56362
g6
V335858
p56363
stp56364
a((dp56365
g2
(lp56366
VWhat looks like an assignment here is actually initialization
p56367
aVSuch syntax can be used only as part of a declaration, but not in a stand-alone expression
p56368
aVThe two parts of this syntax (to the left and to the right of the  sign) work together: compiler derives the size of the array  from the number of items in the initializer; it cannot be added to the type of  at a later point, i
p56369
ag630
aVwhen the assignment is made, because the size of a C array must be known at the point of declaration
p56370
as(dp56371
g6
V335858
p56372
stp56373
a((dp56374
g2
(lp56375
VIf you would like to do it in a single loop, you can do it like this:
p56376
aVThe idea is to compute the total size (that's ) and then use conditionals to decide on which side of the midpoint we are
p56377
as(dp56378
g6
V335858
p56379
stp56380
a((dp56381
g2
(lp56382
VThis is not because of the  structure, it's because of the  call: the function starts returning  only after an unsuccessful attempt at reading the next item
p56383
aVChange the loop to an infinite one ( or , it does not matter) and perform the check for  after reading the data
p56384
aVIf you get a , use  to end the loop
p56385
aVOtherwise, proceed to your  statement
p56386
aVThe structure of your loop should be like this:
p56387
as(dp56388
g6
V335858
p56389
stp56390
a((dp56391
g2
(lp56392
VThis is because in C#  means , not "raised to the power of"
p56393
aVTo square a number, use
p56394
aVor simply
p56395
aVAlso dividing integers truncates the fractional part
p56396
aVUse , , or  to get 3
p56397
aV5 as the midpoint of 3 and 4:
p56398
as(dp56399
g6
V335858
p56400
stp56401
a((dp56402
g2
(lp56403
VWhy would this fail on iOS 7
p56404
aVMy only guess as to why this would be different in iOS 7 is that they have fixed a bug: prior to iOS 7, cocoa used to return a mutable character set for the built-in character sets
p56405
aVThe documentation does not say that the  returned from  should be mutable, so the assignment on the first line is invalid, even though the compiler does not complain
p56406
aVThis should fix the problem:
p56407
as(dp56408
g6
V335858
p56409
stp56410
a((dp56411
g2
(lp56412
VAs far as I know, there is no built-in method for that, so you would need to use a loop:
p56413
aVThe above code uses the new array syntax; you can use  if you prefer
p56414
as(dp56415
g6
V335858
p56416
stp56417
a((dp56418
g2
(lp56419
VIf you must have map entries there you need a  from which to harvest these entries
p56420
aVOne way to do this is as follows:
p56421
aVYou could also use  directly, or provide your own anonymous implementation
p56422
aVA better solution would be defining your own class to represent key-value pairs
p56423
as(dp56424
g6
V335858
p56425
stp56426
a((dp56427
g2
(lp56428
Vthen how much is
p56429
aVYou are correct, this is highly dependent on the system, the compiler, and the optimization settings
p56430
aVGenerally speaking, the compiler knows best, at least in theory, what alignment to pick for the 8-byte  member of the structure
p56431
aVMoreover, compiler's decision could be different when you ask it to optimize for a smaller memory footprint compared to when you ask it to optimize for the fastest speed
p56432
aVFinally, there may be systems where reading eight bytes from addresses aligned at four-byte boundary but not at eight-byte boundary may carry no penalty at all
p56433
aVAgain, your compiler is in the best position to know that fact, and avoid padding your  unnecessarily
p56434
aVThe most important thing to remember about the alignment is that you should not assume a particular layout of your , even if you are not intended to port your product to a different platform, because a change as simple as adding an optimization flag to the makefile may be sufficient to invalidate your assumptions
p56435
as(dp56436
g6
V335858
p56437
stp56438
a((dp56439
g2
(lp56440
VYour code is too fast at printing its decision: rather than making one  per item of , you need to call it once per distinct item found in the  array
p56441
aVOne way of doing it would be by using a  to count the items
p56442
aVYou can do it like this:
p56443
aVDemo on ideone
p56444
as(dp56445
g6
V335858
p56446
stp56447
a((dp56448
g2
(lp56449
VIt looks like you are not using the  identifier correctly: when you define the cell, you pass the identifier in the constructor, but when you try dequeueing the cell, you pass :
p56450
aVDocumentation specifically calls for that parameter not to be :
p56451
aVA string identifying the cell object to be reused
p56452
aVThis parameter must not be
p56453
aVIn general, your method looks "to busy": if you need to configure cells differently under different circumstances, consider using different reuse identifiers for cells with different look
p56454
aVThis wold help preventing situations like this, and also help you improve the frame rate when scrolling the table
p56455
as(dp56456
g6
V335858
p56457
stp56458
a((dp56459
g2
(lp56460
VCryptographically secure hashing process is very CPU-intensive, so there's very little you could do to optimize your code further
p56461
aVI assume that is is not possible to make your  arrays significantly shorter
p56462
aVOne thing you could do to have your loop finish faster is parallelizing the process: if your processor has multiple cores, you could distribute the computation among these cores by feeding the data into several worker threads that compute the MD5 hashes and give you back the results
p56463
aVI need the output to be ordered
p56464
aVOne way to achieve this would making a queue of pairs of  that pair up the bytes to be hashed with their respective index in the output list
p56465
aVResizing the list  upfront should let you avoid having to synchronize writing the results back into the list
p56466
as(dp56467
g6
V335858
p56468
stp56469
a((dp56470
g2
(lp56471
VThis is because your format is incorrect: you need  for the month, because  is for minutes:
p56472
aVPrints  (because months are zero-based; demo)
p56473
as(dp56474
g6
V335858
p56475
stp56476
a((dp56477
g2
(lp56478
VYou could cut your string at the first  (if it's present) at the time you construct your
p56479
aVThis would let you simplify the rest of your logic by pretending that the  is never there:
p56480
aVSince you read line-by-line, and because the delimiter is discarded, you can safely skip the check for the  character, too: it's not going to be there
p56481
as(dp56482
g6
V335858
p56483
stp56484
a((dp56485
g2
(lp56486
VSince the query is formulated in a way to guess which field matches the search condition, you may want to try guessing which one has matched in the  as well:
p56487
aVThis assumes, of course, that  stands for something that you pass to your query that is a meaningful parameter of the  operator, i
p56488
ag630
aVhas metacharacters, has been properly formatted, and so on
p56489
as(dp56490
g6
V335858
p56491
stp56492
a((dp56493
g2
(lp56494
VWithout seeing your , I say that the culprit is this line:
p56495
aVYou are passing the values in positions 2 and 3, where indexes are almost certainly expected
p56496
aVThis call should look like this:
p56497
aVOtherwise, the  would interpret the values of the array as indexes to be swapped, reading memory outside the array
p56498
aVTo avoid problems like this in the future, use  instead:
p56499
as(dp56500
g6
V335858
p56501
stp56502
a((dp56503
g2
(lp56504
VYou have several small bugs in there - for example, you have loops that go from  to , inclusive, while they should go to
p56505
aVMost of the errors, however, can be eliminated by picking a more suitable data structure
p56506
aVThink about it: you don't need a full x board to decide the placement of a queen:
p56507
aVThere's one queen per row, so queen's number is its row
p56508
aVThere's one queen per column, so you need an array of  to know which rows are taken
p56509
aVThere's one queen per ascending diagonal, so you need an array of  to know which ascending diagonals are taken
p56510
aVThere's one queen per descending diagonal, so you need an array of  to know which descending diagonals are taken
p56511
aVboolean[] columns = new boolean[N];
p56512
aVboolean[] ascending = new boolean[2*N-1];
p56513
aVboolean[] descending = new boolean[2*N-1];
p56514
aVAt this point you've got all you need: instead of a square  array you need three linear arrays of
p56515
aVThis lets you do your checks much faster, too:
p56516
aVThat's it - no loops required
p56517
aVNow you can code your backtracking algorithm using these three arrays instead of a square board
p56518
as(dp56519
g6
V335858
p56520
stp56521
a((dp56522
g2
(lp56523
VThe key to answering this question is realization of how C treats integers that participate in logical operations:
p56524
aVZero is treated as
p56525
aVAll values other than zero are treated as
p56526
aVHere are the truth tables for the three operators from your code snippet:
p56527
aVWhen multiple operators are used in an expression without parentheses, unary  is applied ahead of the binary  or
p56528
aVNow you have enough information to figure out the output yourself
p56529
as(dp56530
g6
V335858
p56531
stp56532
a((dp56533
g2
(lp56534
VYou cannot do  because designers of the parser for the language decided not to allow you to do that
p56535
aVIn fact, they were rather generous for allowing an empty pair of curly braces: I guess it was easier for them to take that route than explicitly asking for at least one expression
p56536
aVThere is nothing inherent in the structure of the  expression that you are proposing that would prohibit such syntax: modifying a parser to support the third alternative would not take much effort
p56537
aVHowever, doing so would create an inconsistency with calling non-constructor methods that have no arguments
p56538
aVCurrently, omitting parentheses makes them method groups with specific semantic enabled in certain contexts
p56539
aVIt would be hard to modify the parser to allow no-argument method calls without parentheses, because there would be no syntactic marker for it (note that when you call the constructor, the  keyword plays a role of such a marker)
p56540
as(dp56541
g6
V335858
p56542
stp56543
a((dp56544
g2
(lp56545
VWhen you multiply matrices, the number of columns of the matrix on the left side must equal the number of rows of the matrix on the right side
p56546
aVYou need to check that that is true, and use that common number for your size of the  variable:
p56547
as(dp56548
g6
V335858
p56549
stp56550
a((dp56551
g2
(lp56552
VAssign  to  do not set a value to my original  variable
p56553
aVNo, it does not set , and it shouldn't set it: when you do this
p56554
aVyou create a second reference (that happens to be ) to the object referenced by the  variable (say, it's ):
p56555
aVWhen you set  inside the block to , you re-point the reference to a different object, but the  object remains referenced by the  variable:
p56556
aVIf you want to change  variable, set it inside your block
p56557
aVIf it is an ivar, use
p56558
aVIf it is local, add  to its declaration
p56559
as(dp56560
g6
V335858
p56561
stp56562
a((dp56563
g2
(lp56564
VPut the strings from your  into a , delete the line that you want deleted, convert to a single  by joining elements with  string, and then write the string to file, like this:
p56565
as(dp56566
g6
V335858
p56567
stp56568
a((dp56569
g2
(lp56570
VThe compiler says: inconvertible types required: , found:
p56571
aVThis is not a syntax error, your syntax is OK
p56572
aVYour problems are on the lines where you use :
p56573
aVThe call to  gives you a single character, not a  or a  (although you can convert it to a numeric type, the results are not going to be what you expect)
p56574
aVA common way to deal with is is using : initialize a scanner with , then call methods that read items of the correct type:  for an ,  for a ,  for a
p56575
as(dp56576
g6
V335858
p56577
stp56578
a((dp56579
g2
(lp56580
VOne approach would be making a method that wraps all "prohibited" exceptions in an allowed one, while returning all the allowed ones unwrapped, like this:
p56581
aVNow you can use a single  block, and do the wrapping as needed:
p56582
aVOne unpleasant consequence of this is that the stack trace shows the utility method at the top of the newly created , but that's not important, because the real exception is the wrapped one, not the  wrapper
p56583
aVIf the exception that you caught happens to be , the correct stack trace should remain in place
p56584
as(dp56585
g6
V335858
p56586
stp56587
a((dp56588
g2
(lp56589
VStrictly speaking,  is not an option to emulate optional parameters, because it is equivalent to "forget about using default parameters, always pass all the arguments"
p56590
aVThe  option, on the other hand, lets you emulate optional parameters "on the cheap": by adding an overload that passes the optional parameter explicitly you get the functionality that you want
p56591
aVThe ugly part about option  is that the number of required overloads is equal to the number of optional parameters, so if you have three or four optional parameters, you would need two or three overloads
p56592
aVOf course another option that is not truly equivalent is using a function with variable number of parameters
p56593
aVThe problem with that approach is that once the types of your optional parameters start to diverge, you need to drop the compile-time type safety, which is rather undesirable
p56594
as(dp56595
g6
V335858
p56596
stp56597
a((dp56598
g2
(lp56599
VC passes everything by value, including pointers
p56600
aVFunction parameters are similar to local variables that acquire their initial value from the caller
p56601
aVOnce you are inside the function, the value of the parameter can be changed freely without influencing the values passed by the caller
p56602
aVC's way of passing modifiable stuff into a function is passing pointers
p56603
aVIf you want to modify a value of some type , you pass a pointer to ; if you want to modify a pointer to , you must pass a pointer to a pointer to , and so on
p56604
aVIn other words, the level of indirection must be higher by one than that of the value being changed
p56605
aVHow does this apply to your case
p56606
aVYour function  needs to modify a pointer to , hence it needs to take a pointer to a pointer to a char, like this:
p56607
aVInside the function you modify the pointer to which  points by dereferencing  once:
p56608
aVOf course calling  from the  needs to take the address of , like this:
p56609
as(dp56610
g6
V335858
p56611
stp56612
a((dp56613
g2
(lp56614
VThat's because you print each line twice - once through puts, and once through printf
p56615
aVcaptures newline , and  appends a  of its own, so there's an additional line break after the first printout
p56616
aVThe last line in the file () lacks the trailing , so there's no extra blank line in between the two eggplant printouts
p56617
aVTo fix this problem, first stop calling one of the printing functions
p56618
aVNext, make sure that the line you read does not have a  at the end
p56619
aVYou could either strip it off yourself, or use
p56620
aVIt is not advisable to call  with your string in the spot of the formal parameter, because having unexpected format symbols there may lead to undefined behavior
p56621
aVIf you decide to use , use it as follows:
p56622
as(dp56623
g6
V335858
p56624
stp56625
a((dp56626
g2
(lp56627
VYou need to find an item in your list of arrays where  is equal to , and set the  into
p56628
aVYou can do it with a loop, like this
p56629
aVor with LINQ, like this:
p56630
aVNote that your data structures are not particularly object-oriented
p56631
aVYour program would be more readable if you replaced an array of seven  items with a  that has seven string fields, like this:
p56632
as(dp56633
g6
V335858
p56634
stp56635
a((dp56636
g2
(lp56637
VFirst, find the bounding box of your points by going through your list of points, and detecting the  and  points along each axis (i
p56638
ag630
aV, , , and )
p56639
aVThen generate yourself some random points within that bounding box by generating pairs of numbers  such that  and , and check each random point to see if it is inside your user's "circle" (which is technically a polygon) by employing a Point in Polygon algorithm
p56640
aVIf a point is inside the "circle", keep it; otherwise, generate a different random pair
p56641
aVThis should give you  random points
p56642
as(dp56643
g6
V335858
p56644
stp56645
a((dp56646
g2
(lp56647
VJava constructors only look like functions *, but in reality they are very different:
p56648
aVYou invoke a method when the object is fully initialized; you invoke a constructor when the object does not exist yet
p56649
aVMethods cannot alter  variables of the class; for constructors, that's part of their purpose
p56650
aVMethods may return different things; constructors return nothing
p56651
aVMethod invocations may be used in all kinds of expressions; constructors can be invoked only as part of a  expression
p56652
aVConstructors must follow a special naming convention: their name must match the name of the class
p56653
aVIn your case, that would be
p56654
aVUsually, the task of a constructor is to set up member variables of the class
p56655
aVGiven that your  class has no such variables, you do not need a constructor **: a simple call like this is sufficient:
p56656
aV* In Java, the proper term for a "function call" is "method invocation", although programmers with backgrounds in other programming languages often use these two terms interchangeably
p56657
aV** When the class does not define custom constructors, a default one taking no arguments is provided for you
p56658
as(dp56659
g6
V335858
p56660
stp56661
a((dp56662
g2
(lp56663
V takes offset as the number of bytes, not bits:
p56664
aVThe new position, measured in bytes from the beginning of the file, shall be obtained by adding offset to the position specified by whence
p56665
aV(emphasis is mine)
p56666
as(dp56667
g6
V335858
p56668
stp56669
a((dp56670
g2
(lp56671
VIn C a string is a
p56672
aVA dynamic array of type  is represented as a pointer to , so for  that would be , not simply a  the way you declared it
p56673
aVThe compiler, no doubt, has issued some warnings about it
p56674
aVPay attention to these warnings, very often they help you understand what to do
p56675
aVHere is how you can start your testing:
p56676
as(dp56677
g6
V335858
p56678
stp56679
a((dp56680
g2
(lp56681
VYes, you can include other classes along with your main class in the same file
p56682
aVThe only requirement is that at most one class there is , and that the name of that public class matches the name of the file
p56683
aVAs far as your example goes, you need to remove the semicolon between the list of parameters and the body of the constructor
p56684
aVUse an IDE, it should point the problem to you
p56685
as(dp56686
g6
V335858
p56687
stp56688
a((dp56689
g2
(lp56690
VYou free memory that you allocate no matter where the pointer is stored - in a local variable, in a global / static variable, or in a pointer that is allocated on the free store itself
p56691
aVYour function frees several pointers multiple times: you do not need any of the three calls to free at the bottom of your function (although the second call is harmless, because it passes NULL to free, which is always OK)
p56692
as(dp56693
g6
V335858
p56694
stp56695
a((dp56696
g2
(lp56697
VGenerally it is best to not leave your variables exposed to users outside the class
p56698
aVA method offers you more control - for example, if you would like to trigger an event when your Boolean variable gets set to , you can do it in your method, but you cannot do it when the variable is set:
p56699
aVIn addition, C# offers you properties that give you as much control and encapsulation as the method does, and they look like variables on the outside
p56700
aVIt is more idiomatic to use properties instead of single-argument setter methods:
p56701
as(dp56702
g6
V335858
p56703
stp56704
a((dp56705
g2
(lp56706
VSomething like
p56707
aVNo, this is not going to work
p56708
aVYou need to get property , get its type, then get the property of that other type:
p56709
aVOf course for this to work you need to make  and  properties, not fields
p56710
aVHere is a demo on ideone
p56711
aVI have also tried  but it is giving me null as output
p56712
aVThat is because  gives you a type defined inside , like this:
p56713
as(dp56714
g6
V335858
p56715
stp56716
a((dp56717
g2
(lp56718
VYou can change your action to take the event parameter, like this:
p56719
aVAdding a second parameter to your callback will make Cocoa pass the event to you, so that you could check what has triggered the callback
p56720
aVEDIT : Unfortunately, cocoa does not send you a , so figuring out what control event has caused the callback is not as simple as checking the event type
p56721
aVThe  provides you a collection of touches, which you can analyze to see if it's a  touch
p56722
aVThis may not be the most expedient way of doing things, though, so setting up multiple callbacks that channel the correct type to you may work better:
p56723
as(dp56724
g6
V335858
p56725
stp56726
a((dp56727
g2
(lp56728
VA great deal of the abstraction afforded by methods comes from the fact that they do not need to know who is calling them, so the answer to your question is "no"
p56729
aVIt does not mean that you cannot make it work, though: make the callers pass some sort of a token (say, an  value) identifying themselves to the callee
p56730
aVThis would let you dispatch on that identity inside your method's implementation:
p56731
aVThis is not the most Object-Oriented way of doing things, however: very often, a better approach would be letting the callers supply the logic to be executed, rather than supplying a token identifies that logic
p56732
aVSee Visitor Pattern for details on that approach
p56733
as(dp56734
g6
V335858
p56735
stp56736
a((dp56737
g2
(lp56738
VWhen the compiler tells you that something is not accessible, it's talking about the  vs
p56739
aVvs
p56740
aVaccess control
p56741
aVBy default, all members of a class are , so you cannot access any of them from , including the constructor and the method
p56742
aVTo make the constructor , add a  section to your class, and put the constructor and the method there:
p56743
as(dp56744
g6
V335858
p56745
stp56746
a((dp56747
g2
(lp56748
VThis does set the pointer to a specific constant value, which is a bad idea in systems with virtual memory management
p56749
aVOne notable exception is embedded systems with memory-mapped resources
p56750
aVIn systems like that, hardware designers often reserve a range of memory addresses for alternative use, giving the programmer access to hardware registers as if they were part of the regular memory space
p56751
aVHere is an example *:
p56752
aVWith this setup in place, an embedded program can access UART's registers as if they were 's members:
p56753
aV* UART stands for Universal Asynchronous Receiver/Transmitter, a piece of hardware commonly used for asynchronous peer-to-peer communication
p56754
as(dp56755
g6
V335858
p56756
stp56757
a((dp56758
g2
(lp56759
VYour system uses two's complement representation of negative numbers
p56760
aVIn this representation a binary number composed of all ones represent the biggest negative number
p56761
aVSince inverting all bits of a zero gives you a number composed of all ones, you get  when you re-interpret the number as a signed number by printing it with a  which expects a signed number, not an unsigned one
p56762
as(dp56763
g6
V335858
p56764
stp56765
a((dp56766
g2
(lp56767
VYou cannot do this, because you are sending ambiguous information:  could mean any of the following:
p56768
aVAn array of one number
p56769
aVAn array of two numbers  and
p56770
aVAn array of two numbers  and
p56771
aVAn array of two numbers  and
p56772
aVmore of the same
p56773
aVAn array of three numbers ,  and
p56774
aVI think you got the idea
p56775
aVFixing this requires fixing the sender first: make sure that you separate your numbers with a delimiter, and optionally send the number of items in the array to avoid dynamic re-allocation - for example,
p56776
aVis no longer ambiguous: it says that you are sending 5 items, and these items are delimited
p56777
as(dp56778
g6
V335858
p56779
stp56780
a((dp56781
g2
(lp56782
VYou can do it without an explicit loop like this:
p56783
aVreads everything from the string stream created on the third line, and pushes it into the vector created on the second line
p56784
aVHere is a demo on ideone
p56785
as(dp56786
g6
V335858
p56787
stp56788
a((dp56789
g2
(lp56790
VThe  in Java means exclusive OR,  operation, not raising to the power
p56791
aVYou need to use  or simply multiply the expression by itself:
p56792
aVor
p56793
as(dp56794
g6
V335858
p56795
stp56796
a((dp56797
g2
(lp56798
VI don't have direct access to that particular view controller's pointer as i have built them inside of the storyboard
p56799
aVDo you know a way to get a pointer to that view controller
p56800
aVYou can set arbitrary properties of your view controller through the storyboard
p56801
aVHere is how you can choose the index visually:
p56802
aVIn the storyboard, select your view controller, and go to its Identity Inspector (the third tab from the left in Xcode 5)
p56803
aVIn the User Defined Runtime Attributes section, click
p56804
aVIn the "Name" column enter
p56805
aVIn the "Type" column choose "Number"
p56806
aVIn the "Value" column enter the desired value
p56807
as(dp56808
g6
V335858
p56809
stp56810
a((dp56811
g2
(lp56812
VTo avoid repeating the expression, you can use a  clause to simplify your query:
p56813
as(dp56814
g6
V335858
p56815
stp56816
a.