(lp0
((dp1
S'text'
p2
(lp3
VI've been active in a large German VB community for years now and the consensus of all (
p4
aVpeople who have talked about this on our platform was \u201cdon't
p5
aV\u201d
p6
aVSome of the hints in previous answers have been pretty good and I would advise you to follow them and try porting the project but at the same time I advise against premature optimism
p7
aVIn the whole, the conversion assistent seems to do a decent job if the project isn't too big and you don't intend to tread the codebase as an active asset (i
p8
aVe
p9
aVyou intend to extend and change it)
p10
aVAs soon as this isn't the case any more, a complete rewrite will be in order
p11
aVI wouldn't even bother trying to transfer any parts of the old application, because from my experience and all that I've heard this will invariably be more expensive than rewriting from scratch
p12
as(dp13
S'author'
p14
V1968
p15
stp16
a((dp17
g2
(lp18
VThe  class has a generic variant that makes this a bit easier:
p19
as(dp20
g14
V1968
p21
stp22
a((dp23
g2
(lp24
VIn Germany, an engineer (Ingenieur), no matter of what profession, has certain professional \u201cprivileges\u201d
p25
aVFor example, engineers are permitted to install high voltage equipment, something ordinary people aren't allowed to do unless supervised by a certified professional
p26
aVIt is simply assumed that engineers knows what they're doing and can take responsibility for their actions
p27
aVFor that reason, attaining a degree in software engineering is very uncommon in Germany
p28
aVThe \u201cthrowing \u2026 around\u201d of the term can't happen here
p29
aVAny software engineer really is a fully-fledged engineer
p30
as(dp31
g14
V1968
p32
stp33
a((dp34
g2
(lp35
VJust as an advise: the method using strings as indices is actually very slow
p36
aVA much more efficient but otherwise equivalent solution would be to use vectors/arrays
p37
aVThere's absolutely no need to write the indices in a string
p38
aVHowever, using a  isn't actually very efficient because of the implementation in terms of a balanced binary search tree
p39
aVMuch better performing data structures in this case would be a (randomized) hash table
p40
as(dp41
g14
V1968
p42
stp43
a((dp44
g2
(lp45
VCoolest regular expression ever:
p46
aVIt tests if a number is prime
p47
aVAnd it works
p48
aVN
p49
aVB
p50
aV: to make it work, a bit of set-up is needed; the number that we want to test has to be converted into a string of \u201c\u201ds first, then we can apply the expression to test if the string does not contain a prime number of \u201c\u201ds:
p51
aVThere\u2019s a detailled and very approachable explanation over at Avinash Meetoo\u2019s blog
p52
as(dp53
g14
V1968
p54
stp55
a((dp56
g2
(lp57
V@csmba:
p58
aVIt was asked in a followup why or when would anyone use And instead of AndAlso (or & instead of &&): Here is an example:
p59
aVIn this case, I want to init both X and Y
p60
aVY must be initialized in order for y
p61
aVDoDance to be able to execute
p62
aVHowever, in the init() function I am doing also some extra thing like checking a socket is open, and only if that works out ok, for both, I should go ahead and do the x
p63
aVprocess(y)
p64
aVI believe this is rather confusing
p65
aVAlthough your example works, it's not the typical case for using  (and I would probably write this differently to make it clearer)
p66
aV( in most other languages) is actually the bitwise-and operation
p67
aVYou would use it to calculate bit operations, for example deleting a flag bit or masking and testing flags:
p68
as(dp69
g14
V1968
p70
stp71
a((dp72
g2
(lp73
VWhen using a dynamically typed language, I occasionally use Apps Hungarian
p74
aVFor statically typed languages I don't
p75
aVSee my explanation in the other thread
p76
as(dp77
g14
V1968
p78
stp79
a((dp80
g2
(lp81
V@Keith:
p82
aVIDisposable is for managed resources
p83
aVFinalisers are for unmanaged resources
p84
aVSorry but that's just wrong
p85
aVNormally, the finalizer does nothing at all
p86
aVHowever, if the dispose pattern has been correctly implemented, the finalizer tries to invoke
p87
aVhas two jobs:
p88
aVFree unmanaged resources, and
p89
aVfree nested managed resources
p90
aVAnd here your statement comes into play because it's true that while finalizing, an object should never try to free nested managed resources as these may have already been freed
p91
aVIt must still free unmanaged resources though
p92
aVStill, finalizers have no job other than to call  and tell it not to touch managed objects
p93
aV, when called manually (or via ), shall free all unmanaged resources and pass the  message on to nested objects (and base class methods) but this will never free any (managed) memory
p94
as(dp95
g14
V1968
p96
stp97
a((dp98
g2
(lp99
VHow are the Eclipse settings saved
p100
aVPerhaps you could simply adapt this macro and load the resulting file into Eclipse
p101
as(dp102
g14
V1968
p103
stp104
a((dp105
g2
(lp106
VI shun redundant delegate declarations
p107
aVFor non-events, you can use the  delegate or
p108
aVEDIT: Additionally, every event has a corresponding  delegate so there's no need at all to redeclare one
p109
as(dp110
g14
V1968
p111
stp112
a((dp113
g2
(lp114
VPHP has arrays which are actually associative arrays and can also be used as sets
p115
aVLike many interpreted languages, PHP offers all this under one hood instead of providing different explicit data types
p116
aVE
p117
aVg
p118
aV/Edit: Also, take a look in the manual
p119
as(dp120
g14
V1968
p121
stp122
a((dp123
g2
(lp124
VUsing non-greedy quantifiers here is probably the best solution, also because it is more efficient than the greedy alternative: Greedy matches generally go as far as they can (here, until the end of the text
p125
aVand then trace back character after character to try and match the part coming afterwards
p126
aVHower, consider using a negative character class instead:
p127
aVmeans \u201ceverything except a whitespace and this is exactly what you want
p128
as(dp129
g14
V1968
p130
stp131
a((dp132
g2
(lp133
VI've learned never to use  in PHP except inside the core libraries that I use and one central  of these libraries (+ config) in the application
p134
aVEverything else is handled by a global  handler that can be configured to recognize the different classes needed
p135
aVThis can be done easily using appropriate naming conventions for the classes
p136
aVThis is not only flexible but also quite efficient and keeps the architecture clean
p137
as(dp138
g14
V1968
p139
stp140
a((dp141
g2
(lp142
VYou can use the extended syntax:
p143
as(dp144
g14
V1968
p145
stp146
a((dp147
g2
(lp148
VFormatting in Python is done via the string formatting () operator:
p149
aV/Edit: There's also strftime
p150
as(dp151
g14
V1968
p152
stp153
a((dp154
g2
(lp155
V@brendan:
p156
aVThe article you cited is seriously outdated and the information is just plain wrong
p157
aVEspecially the last point (use  instead of ) is misleading and the justification offered in the article no longer applies to modern versions of
p158
aVNET
p159
aVWhile it's true that the  uses virtual calls, these can actually be inlined by a modern compiler
p160
aVFurthermore,
p161
aVNET now knows generics and strongly typed enumerators
p162
aVThere are a lot of performance tests out there that prove conclusively that  is generally no faster than
p163
aVHere's an example
p164
as(dp165
g14
V1968
p166
stp167
a((dp168
g2
(lp169
VI think it's a business logic vs
p170
aVdata logic thing
p171
aVIf there is logic that ensures the consistency of your data, put it in a stored procedure
p172
aVSame for convenience functions for data retrieval/update
p173
aVEverything else should go into the code
p174
aVA friend of mine is developing a host of stored procedures for data analysis algorithms in bioinformatics
p175
aVI think his approach is quite interesting, but not the right way in the long run
p176
aVMy main objections are maintainability and lacking adaptability
p177
as(dp178
g14
V1968
p179
stp180
a((dp181
g2
(lp182
VIs the proliferation of open source licenses just another example of programmers living NYI (Not Invented Here) syndrome
p183
aVIMHO, yes, absolutely
p184
aVTake the Microsoft PL license as an example
p185
aVIt's completely redundant
p186
aVStill, I like that one a lot because it's very clearly worded, much shorter than most other licenses and provides a good amount of freedom
p187
aVOn the other hand, crafting a new license is fraught with risks because until it has proven its worth before an actual court it isn't worth the paper it is written on (if any)
p188
aVIMHO, there are very few licenses that are worth knowing and using, among them GPL (which I personally don't like), LGPL, BSD and Ms-PL, and of course the Creative Commons licenses but these aren't suitable for software
p189
as(dp190
g14
V1968
p191
stp192
a((dp193
g2
(lp194
VI really like Thompson\u2019s \u201cHaskell: The Craft of Functional Programming\u201d because it\u2019s well written and Haskell allows an easier start than other functional languages while being completely pure (unlike Lisp or Scheme)
p195
as(dp196
g14
V1968
p197
stp198
a((dp199
g2
(lp200
VActually, by colllapsing the colums you already summed them, so the dimension doesn't matter at all for your example
p201
aVDid I miss something or did you
p202
as(dp203
g14
V1968
p204
stp205
a((dp206
g2
(lp207
VThese are standard library references
p208
aVMake sure that all libraries (including the standard library) are using the same linkage
p209
ag117
ag118
aVyou can't link statically while linking the standard lib dynamically
p210
aVThe same goes for the threading model used
p211
aVTake special care that you and the 3rd party library use the same linkage options
p212
aVThis can be a real pain in the *ss
p213
as(dp214
g14
V1968
p215
stp216
a((dp217
g2
(lp218
VI find this site helpful: http://www
p219
aVregular-expressions
p220
aVinfo/
p221
aVOther than that, I use the corresponding documentation extensively and I believe, all said and done, there's no way around that
p222
as(dp223
g14
V1968
p224
stp225
a((dp226
g2
(lp227
VBecause the Format method has nothing to do with a string's current value
p228
aVThat's true for all string methods because
p229
aVNET strings are immutable
p230
aVIf it was non-static, you would need a string to begin with
p231
aVIt does: the format string
p232
aVI believe this is just another example of the many design flaws in the
p233
aVNET platform (and I don't mean this as a flame; I still find the
p234
aVNET framework superior to most other frameworks)
p235
as(dp236
g14
V1968
p237
stp238
a((dp239
g2
(lp240
VA functional language (ideally) allows you to write a mathematical function, i
p241
ag9
aVa function that takes n arguments and returns a value
p242
aVIf the program is executed, this function is evaluated
p243
aVA procedural language, on the other hand, performs a series of sequential steps, where the functional program would be nested
p244
aVThere's a way of transforming sequential logic into functional logic called continuation passing style
p245
aVAs a consequence, a purely functional program always yields the same value for an input, and the order of evaluation is not well-defined; which means that uncertain values like user input or random values are hard to model in purely functional languages
p246
as(dp247
g14
V1968
p248
stp249
a((dp250
g2
(lp251
VWell, I know that if I ever did this, I would forget it and thus purposefully introduce a bug into the codebase
p252
aVSo, I'm not sure this is a good idea unless you've got a good memory
p253
as(dp254
g14
V1968
p255
stp256
a((dp257
g2
(lp258
VThis entirely depends on what varies and what stays the same
p259
aVFor example, I am working on a (non-OOP) framework where the find algorithm is different depending both on the type of the needle and the haystack
p260
aVApart from the fact that this would require double-dispatch in an object-oriented environment, it also means that it isn't meaningful to write either  or to write
p261
aVOn the other hand, your application could happily delegate finding to either of both classes, or stick with one algorithm altogether in which case the decision is arbitrary
p262
aVIn that case, I would prefer the  way because it seems more logical to apply the finding to the haystack
p263
as(dp264
g14
V1968
p265
stp266
a((dp267
g2
(lp268
VPut the code in a method and you save a temporary and a  (and you recycle code, as a bonus):
p269
aV\u2026 but of course this method already exists anyway for Lists, even in
p270
aVNET 2
p271
aV0
p272
as(dp273
g14
V1968
p274
stp275
a((dp276
g2
(lp277
V works well if you have a consistent naming convention for your classes that tell the function where they're found inside the directory tree
p278
aVMVC lends itself particularly well for this kind of thing because you can easily split the classes into models, views and controllers
p279
aVAlternatively, keep an associative array of names to file locations for your class and let  query this array
p280
as(dp281
g14
V1968
p282
stp283
a((dp284
g2
(lp285
V@ESRogs:
p286
aVlookup is O(log n) which makes it slow here
p287
aVBetter use a vector
p288
as(dp289
g14
V1968
p290
stp291
a((dp292
g2
(lp293
V@Chris:
p294
aVI gather that you want the most significant three digits of the usec
p295
aVYes
p296
aVThe overall number of digits in  varies and I want to cut those below 1000
p297
aVFor example, if , I want to get the result 100 (not 1, as you propose)
p298
aVTherefore, I can't simply divide by 1000
p299
as(dp300
g14
V1968
p301
stp302
a((dp303
g2
(lp304
VAlso, are they unique to Java, is there a C++ equivalent
p305
aVNo, but VB and C# have attributes which are the same thing
p306
aVTheir use is quite diverse
p307
aVOne typical Java example,  has no effect on the code but it can be used by the compiler to generate a warning (or error) if the decorated method doesn't actually override another method
p308
aVSimilarly, methods can be marked obsolete
p309
aVThen there's reflection
p310
aVWhen you reflect a type of a class in your code, you can access the attributes and act according to the information found there
p311
aVI don't know any examples in Java but in
p312
aVNET this is used by the compiler to generate (de)serialization information for classes, determine the memory layout of structures and declare function imports from legacy libraries (among others)
p313
aVThey also control how the IDE form designer works
p314
aV/EDIT: Attributes on classes are comparable to tag interfaces (like Serializable in Java)
p315
aVHowever, the
p316
aVNET coding guidelines say not to use tag interfaces
p317
aVAlso, they only work on class level, not on method level
p318
as(dp319
g14
V1968
p320
stp321
a((dp322
g2
(lp323
VIn my second year of University we were "taught" Haskell [\u2026]
p324
aVWhat is functional programming [\u2026] and am I correct in thinking that C is a non-functional programming language
p325
aVMan, your course must really have sucked
p326
aVSorry for being so cynical
p327
aVAnyway, have a look at these related questions:
p328
aVWhat's the difference between functional and procedural programming
p329
aVRecursion, Memoization
p330
as(dp331
g14
V1968
p332
stp333
a((dp334
g2
(lp335
VBasically, due to 's defective nature (and I believe that this is uncontroversial), it is only used to compensate for missing features
p336
aVSo the use of  may actually be acceptable, but only if the language doesn't offer a more structured variant to obtain the same goal
p337
aVTake Doubt's example:
p338
aVThe rule with goto that we use is that goto is okay to for jumping forward to a single exit cleanup point in a function
p339
aVThis is true \u2013 but only if the language doesn't allow structured exception handling with cleanup code (such as RAII or ), which does the same job better (as it is specially built for doing it), or when there's a good reason not to employ structured exception handling (but you will never have this case except at a very low level)
p340
aVIn most other languages, the only acceptable use of  is to exit nested loops
p341
aVAnd even there it is almost always better to lift the outer loop into an own method and use  instead
p342
aVOther than that,  is a sign that not enough thought has gone into the particular piece of code
p343
as(dp344
g14
V1968
p345
stp346
a((dp347
g2
(lp348
VDon't do this
p349
aVIt gives away free information to a potential attacker and makes their job easier
p350
aVIf there are exploits known for your given version of the software, there's no need to tell them that
p351
aVThere are actually search engines built on top of Google who use this information incontinence to power massive exploits (e
p352
ag118
aVcDc's Goolag scanner)
p353
aVAlthough this may sound like security by obscurity (because it is) it is still advisable to make an attacker's job as hard as possible
p354
aVNot divulging implementation details is an important step
p355
aVOf course, this can only ever be part of the effort to make a website securer
p356
as(dp357
g14
V1968
p358
stp359
a((dp360
g2
(lp361
VC++ doesn't have an ecosystem in the sense of Java or
p362
aVNET
p363
aVThere's no virtual machine, no runtime environment even, there's only a highly specialized standard library that by design doesn't operate well in a purely functional environment
p364
aVC++ doesn't even have an ABI standard
p365
aVAll things considered, I'm not sure what you mean/expect
p366
as(dp367
g14
V1968
p368
stp369
a((dp370
g2
(lp371
VAs yellow is a mix of red and green, you can probably start with  and then slide green up until you hit , then slide red down to :
p372
as(dp373
g14
V1968
p374
stp375
a((dp376
g2
(lp377
VNo input is not the same as the end of the stream
p378
aVYou can usually simulate the end of the stream in a console by pressing Ctrl+D (AFAIK some systems use Ctrl+Z instead)
p379
aVBut I guess this is not what you want so better test for empty strings additionally to null strings
p380
as(dp381
g14
V1968
p382
stp383
a((dp384
g2
(lp385
VThe problem is that 'display: inline' can't get a height associated because, being inline, it gets its height from its the content
p386
aVAnyway, how do you define the height of a box that is broken at the end of a line
p387
aVYou might try to set 'line-height' instead, or if this doesn't work to your satisfaction, set a padding:
p388
as(dp389
g14
V1968
p390
stp391
a((dp392
g2
(lp393
VYes this is possible
p394
aVI believe there are multiple libraries to accomplish this
p395
aVThe most widely used is probably ImageMagick which is actually not PHP specific but comes with appropriate bindings
p396
aVSee also in the PHP documentation
p397
as(dp398
g14
V1968
p399
stp400
a((dp401
g2
(lp402
VIf using XHTML, it's actually recommended not to use named entities ([citation needed])
p403
aVSome browsers (Firefox \u2026), when parsing this as XML (which they normally don't), don't read the DTD files and thus are unable to handle the entities
p404
aVAs it's best practice anyway to use UTF-8 as encoding if there are no compelling reasons to do otherwise, this only means that the creator of the documents needs a decent editor that can not only handle the documents but also provides a good way of entering the divers glyphs
p405
aVOS X doesn't really have this problem because most needed glyphs can be reached via \u201calt\u201d keys but Windows doesn't have this feature
p406
aV@Konrad: Are you saying that, no, named entities are not needed
p407
aVPrecisely
p408
aVUnless, of course, there are silly restrictions, e
p409
ag118
aVlegacy database drivers that choke on UTF-8 etc
p410
as(dp411
g14
V1968
p412
stp413
a((dp414
g2
(lp415
VThe best way is the builtin way: Use
p416
aVWhy do you need alternatives
p417
as(dp418
g14
V1968
p419
stp420
a((dp421
g2
(lp422
VThere's a (proven
p423
aVworst sorting algorithm called slow sort that uses the \u201cmultiply and surrender\u201d paradigm and runs in exponential time
p424
aVWhile your algorithm is slower, it doesn't progress steadily but instead performs random jumps
p425
aVAdditionally, slow sort's best case is still exponential while yours is constant
p426
as(dp427
g14
V1968
p428
stp429
a((dp430
g2
(lp431
VI don't know a solution but my approach would be as follows
p432
aVDecorate the class (or its methods) with a custom attribute
p433
aVSomewhere else in the program, let an initialization function reflect all types, read the methods decorated with the attributes and inject some IL code into the method
p434
aVIt might actually be more practical to replace the method by a stub that calls , the actual method and then
p435
aVAdditionally, I don't know if you can change methods using reflection so it might be more practical to replace the whole type
p436
as(dp437
g14
V1968
p438
stp439
a((dp440
g2
(lp441
VYou'll need pattern recognition for that
p442
aVTo determine small differences between two images, Hopfield nets work fairly well and are quite easy to implement
p443
aVI don't know any available implementations, though
p444
as(dp445
g14
V1968
p446
stp447
a((dp448
g2
(lp449
VI'm not sure I understand the problem
p450
aVDo you know the  loop
p451
aVWhy not simply nest it
p452
as(dp453
g14
V1968
p454
stp455
a((dp456
g2
(lp457
VI would reccomend sticking to what you know - PHP is more than capable
p458
aVThat's true of course, but:
p459
aVI don't mind, and I would even like to use this as an excuse, learning some new thing like Python or Ruby
p460
aVThen writing a browser game is an excellent opportunity to do this
p461
aVLearning something new is never wrong and learning an alternative to PHP can never hurt (eh, Jeff
p462
aVWhile neither Ruby on Rails nor Django are especially useful for writing games, they're still great
p463
aVWe had to write a small browser game in a matter of weeks for a project once and Rails worked charms
p464
aVOn the other hand, all successful browser games have enormous work loads and if you want to scale well you either have to get good hardware and load balancing or you need a non-interpreted framework (sorry, guys
p465
as(dp466
g14
V1968
p467
stp468
a((dp469
g2
(lp470
VI find it important to make wrong code look wrong to the compiler
p471
aVIn practice (and only when using strongly typed languages), this means omitting any kind of variable prefixes (even Apps Hungarian) in favour of distinct types
p472
aVTo use Joel's example, if there are two distinct types to represent raw strings and sanitized strings, and there's no implicit conversion between the two, then the problem that Apps Hungarian addresses can't even occur
p473
aVThe same goes for the Word document coordinates
p474
aVIn a way, Apps Hungarian is only a workaround for compilers/languages that have no strict enough type checking
p475
as(dp476
g14
V1968
p477
stp478
a((dp479
g2
(lp480
VWhat do you like to use as work around
p481
aVContainer objects or Macros
p482
aVDo you feel its worth it
p483
aVThe canonical way is to use a metafunction like thus:
p484
aVThis is also used in the STL () and in many libraries including Boost
p485
aVWe use it extensively in a bioinformatical library
p486
aVIt's bloated, but it's the best alternative 99% of the time
p487
aVUsing macros here is not worth the many downsides
p488
aV(EDIT: I've amended the code to reflect Boost/STL conventions as pointed out by Daniel in his comment
p489
as(dp490
g14
V1968
p491
stp492
a((dp493
g2
(lp494
VA stack overflow in real code occurs very rarely
p495
aVMost situations in which it occurs are recursions where the termination has been forgotten
p496
aVIt might however rarely occur in highly nested structures, e
p497
ag118
aVparticularly large XML documents
p498
aVThe only real help here is to refactor the code to use an explicit stack object instead of the call stack
p499
as(dp500
g14
V1968
p501
stp502
a((dp503
g2
(lp504
VAs long as there are no nested tags (and no line breaks), the following variant works well:
p505
aVAs soon as nested tags come into play, regular expressions are unfit for parsing
p506
aVHowever, you can still use them by applying more advanced features of modern interpreters (depending on your regex machine)
p507
ag117
ag118
aVNET regular expressions use a stack; I found this:
p508
aVSource: http://weblogs
p509
aVasp
p510
aVnet/scottcate/archive/2004/12/13/281955
p511
aVaspx
p512
as(dp513
g14
V1968
p514
stp515
a((dp516
g2
(lp517
VTools > Options > (Show all settings), then Environment > Keyboard
p518
aVHere, rebind the key \u201cFile
p519
aVClose\u201d to Ctrl+W
p520
as(dp521
g14
V1968
p522
stp523
a((dp524
g2
(lp525
VBasically, each job deserves an own exception
p526
aVWhen you catch exceptions, you don't distinguish different instances, like you would normally do with objects, therefore you need different subtypes
p527
aVUsing too many custom exceptions is a case which I see hardly occurring
p528
aVOne advice would be to create exceptions as needed, and if it becomes apparent that one exception type is a duplicate of another, refactor the code by merging the two
p529
aVOf course it helps if some thought goes into structuring exceptions from the beginning
p530
aVBut generally, use custom exceptions for all cases that have no 1:1 correspondence to existing, situation-specific exceptions
p531
aVOn the other hand, s and s might actually often be appropriate
p532
aVDon't catch these, though (except for logging) as they're a programming error which means that after throwing them, the program is in an undefined state
p533
as(dp534
g14
V1968
p535
stp536
a((dp537
g2
(lp538
V(Incidentally, I also found this form very hard to read in comparison to the normal usage
p539
aVNot necessarily, although that was my first thought, too
p540
aVA code should always emphasize its function, especially if it has side effects
p541
aVIf the writer's intention was to emphasize the assignment to  then hey, roll with it
p542
aVOn the other hand, it could have been clearer that the action taking place here is to disable the object, in which case the conditional block would have been better
p543
as(dp544
g14
V1968
p545
stp546
a((dp547
g2
(lp548
VI have to stick to pure c++ because the framework I'm using forbids any use of generics
p549
aVThere's certainly a rationale behind this decision
p550
aVI'd be interested to hear it because off the top of my head I can't think of any reason to forbid templates completely
p551
as(dp552
g14
V1968
p553
stp554
a((dp555
g2
(lp556
Vyou want an interpolation between the first and the second colour
p557
aVInterpolating colours is easy by calculating the same interpolation for each of its components (R, G, B)
p558
aVThere are many ways to interpolate
p559
aVThe easiest is to use linear interpolation: just take percentage p of the first colour and percentage 1 - p of the second:
p560
aVThere's another question related to this
p561
aVThere are other methods of interpolation that sometimes work better
p562
aVFor example, using a bell-shaped (sigmoidal) interpolation function makes the transition smoother
p563
aV/EDIT: Oops, you mean using a predefined function
p564
aVOK, even easier
p565
aVThe blog post you linked now has an example code in Python
p566
aVIn Java, you could use the
p567
as(dp568
g14
V1968
p569
stp570
a((dp571
g2
(lp572
VThe rule I use is: never use unchecked exceptions
p573
aV(or when you don't see any way around it)
p574
aVThere's a very strong case for the opposite: Never use checked exceptions
p575
aVI'm reluctant to take sides in the debate but there seems to be a broad consensus that introducing checked exceptions was a wrong decision in hindsight
p576
aVPlease don't shoot the messenger and refer to those arguments
p577
as(dp578
g14
V1968
p579
stp580
a((dp581
g2
(lp582
VHowever, the same result will be returned regardless of which copy of the predicate is used (i
p583
ag9
aVthe predicate has no real state), so the original problem with state-keeping predicates is not relevant in this case
p584
aVSo where's the problem
p585
aVFunction objects don't necessarily have to be stateful
p586
aVIt's actually best practice to use function objects instead of function pointers in such situations because compilers are better at inlining them
p587
aVIn your case, the instantiation and call of the function object may have no overhead at all since  is a function template and the compiler will generate an own version for your functor
p588
aVOn the other hand, using a function pointer would incur an indirection
p589
as(dp590
g14
V1968
p591
stp592
a((dp593
g2
(lp594
VOr is it only useful as a transport mechanism for code
p595
aVIt's useful as an execution mechanism for code
p596
aVUsing the interpreter pattern, expression trees can directly be interpreted
p597
aVThis is useful because it's very easy and fast to implement
p598
aVSuch interpreters are ubiquitous and used even in cases that don't seem to \u201cinterpret\u201d anything, e
p599
ag118
aVfor printing nested structures
p600
as(dp601
g14
V1968
p602
stp603
a((dp604
g2
(lp605
VThis is not a direct answer but most web libraries have a function that accomplishes this task
p606
aVThe function is often called something similar to
p607
aVIf such a function exists, use it, it is almost guaranteed to be more reliable and more efficient than any hand-crafted code
p608
as(dp609
g14
V1968
p610
stp611
a((dp612
g2
(lp613
VI' guessing that your class is in a different namespace
p614
aVThe canonical way to solve this would be to use the resources class and a strongly typed resource:
p615
aVUse the IDE's resource manager to add resources
p616
as(dp617
g14
V1968
p618
stp619
a((dp620
g2
(lp621
VUse the  as a workaround
p622
aVAn alternative would be to make the class not serializable but instead pack all the data to be serialized into a nested class and have  use an instance of it
p623
aVThis makes the interface securer; however, it goes at expenses of convenience
p624
as(dp625
g14
V1968
p626
stp627
a((dp628
g2
(lp629
VI think this would be an excellent feature request for Microsoft: Create an abstract base class attribute  that the compiler processes in some manner or that can influence the compiling process
p630
aVThen we could inherit from this attribute and implement different operations, e
p631
ag118
aVemit an error or a warning
p632
as(dp633
g14
V1968
p634
stp635
a((dp636
g2
(lp637
VIf you can't modify the structures then you have no alternative to writing a manual conversion function because overloading conversion operators only works within the class body
p638
aVThere's no other way
p639
as(dp640
g14
V1968
p641
stp642
a((dp643
g2
(lp644
VJust to mention an alternative to VMWare Fusion, I'm using Parallels als a VM
p645
aVPerformance has not been an issue so far when I've given the VM 1 GiB of main memory
p646
aVBefore deciding on one VM, I'd suggest testing them all extensively
p647
aVI am quite happy with Parallels but I'm not sure I wouldn't use VMWare Fusion the next time
p648
aVContrarily to what Mo said, I actually find the Mac keyboard layout much better than the Windows layout, using a Germany key binding
p649
as(dp650
g14
V1968
p651
stp652
a((dp653
g2
(lp654
VVB has the following  statement which the question referred to, I think:
p655
aVThe first is basically C#'s ternary conditional operator and the second is its coalesce operator (return  unless it\u2019s , in which case return )
p656
aVhas thus replaced  and the latter is obsolete
p657
aV/EDIT: Like in C#, VB's conditional  operator is short-circuit so you can now safely write the following, which is not possible using the  function:
p658
as(dp659
g14
V1968
p660
stp661
a((dp662
g2
(lp663
VDamn, I really thought you were talking about the operator all along
p664
aV;-) Anyway \u2026
p665
aVDoes this If function perform better than the IIf function
p666
aVDefinitely
p667
aVRemember, it's built into the language
p668
aVOnly one of the two conditional arguments has to be evaluated, potentially saving a costly operation
p669
aVDoes the If statement trump the If and IIf functions
p670
aVI think you can't compare the two because they do different things
p671
aVIf your code semantically performs an assignment you should emphasize this, instead of the decision-making
p672
aVUse the  operator here instead of the statement
p673
aVThis is especially true if you can use it in the initialization of a variable because otherwise the variable will be default initialized, resulting in slower code:
p674
as(dp675
g14
V1968
p676
stp677
a((dp678
g2
(lp679
VAs a possible alternative to the BSD license you can also use the Ms-PL license (Microsoft public license)
p680
aVPretty much the same but (arguably) better worded
p681
aVAdditionally, It's got \u201cMicrosoft\u201d in its name, which screams \u201ccorprate-friendly\u201d like nothing else does
p682
aV;-)
p683
as(dp684
g14
V1968
p685
stp686
a((dp687
g2
(lp688
VI've actually done this (set up my own server using phpMyID)
p689
aVIt's very easy and works quite well
p690
aVOne thing that annoys me to no end is the use of HTML redirects instead of HTTP
p691
aVI changed that manually, based on some information gotten in the phpMyID forum
p692
aVHowever, I have switched to myOpenId in the meantime
p693
aVRolling an own provider is fun and games but it just isn't secure
p694
aVThere are two issues:
p695
aVMore generally, you have to act on faith
p696
aVphpMyID is great but it's developed in someone's spare time
p697
aVThere could be many undetected security holes in it \u2013 and there have been some, in the past
p698
aVWhile this of course applies to all security-related software, I believe the problem is potentially more severe with software developed in spare time, especially since the code is far from perfect in my humble opinion
p699
aVSecondly, OpenID is highly susceptible to screen scraping and mock interfaces
p700
aVIt's just too easy for an attacker to emulate the phpMyID interface to obtain your credentials for another site
p701
aVmyOpenId offers two very important solutions to the problem
p702
aVThe first is its use of a cookie-stored picture that is embedded in the login page
p703
aVIf anyone screen-scapes the myOpenId login page, this picture will be missing and the fake can easily be identified
p704
aVSecondly, myOpenId supports sign-in using strongly signed certificates that can be installed in the web browser
p705
aVI still have phpMyID set up as an alternative provider using Yadis but I wouldn't use it as a login on sites that I don't trust
p706
aVIn any case, read Sam Ruby's tutorial
p707
as(dp708
g14
V1968
p709
stp710
a((dp711
g2
(lp712
VSome people say that a smaller IDE is better for learning
p713
aVTake a look at Code::Blocks
p714
aVIt's generally true that beginning C in an IDE is hard because not many books explain enough to control the IDE
p715
aVPerhaps starting in a console and a basic text editor with syntax highlighting would be better \u2013 at least under Linux
p716
aVSince Windows' console is far from great, I'd not recommend using it
p717
aV/EDIT: Dev-C++ used to be the best freely available IDE for Windows
p718
aVHowever, it's development has been discontinued years ago and the most recent version unfortunately is full of bugs
p719
as(dp720
g14
V1968
p721
stp722
a((dp723
g2
(lp724
VIn any case, you have to loop through it
p725
aVLinq offers the  method:
p726
as(dp727
g14
V1968
p728
stp729
a((dp730
g2
(lp731
VExpression Studio is basically a design studio
p732
aVIt consists of a bunch of design software that Microsoft has bought for the most part
p733
aVThe audience is designers, not developers
p734
aVThe gist of the software is that Expression Blend enables designers and programmers to work seamlessly together in letting the designer create the graphical user interface
p735
aVIn a normal workflow, the designer would deliver a mockup which the developer would have to implement
p736
aVUsing Expression Blend in combination with WPF, this is no longer necessary
p737
aVThe graphical UI made by the designer is functional
p738
aVAll the developer has to do is write the code for the function behind the design
p739
aVThis in itself is great because developers invariably fail to implement the design as thought out by the designer
p740
aVTechnical limitations, lack of communication \u2026 whatever the reason
p741
aVUIs never look like them mockup done up front
p742
aVExpression Design is basically a vector drawing program that can be used to design smaller components that are then used within Expression Blend as parts of the UI
p743
aVFor example, graphical buttons could be designed that way
p744
aVIt can also be used as a vanilla drawing program
p745
aVI did the graphics in my thesis using Expression Design
p746
as(dp747
g14
V1968
p748
stp749
a((dp750
g2
(lp751
VI was intrigued so I looked it up in the definition of ECMAScript 262 ed
p752
aV3 which is the basis of JavaScript 1
p753
aV8
p754
aVThe relevant definition is found in section 11
p755
aV1
p756
aV4 and unfortunately is not very clear
p757
aVThe section explicitly states that elisions (= omissions) at the beginning or in the middle don't define an element but do contribute to the overall length
p758
aVThere is no explicit statements about redundant commas at the end of the initializer but by omission I conclude that the above statement implies that they do not contribute to the overall length so I conclude that MSIE is wrong
p759
aVThe relevant paragraph reads as follows:
p760
aVArray elements may be elided at the beginning, middle or end of the element list
p761
aVWhenever a comma in the element list is not preceded by an Assignment Expression (i
p762
ag9
aV, a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements
p763
aVElided array elements are not defined
p764
as(dp765
g14
V1968
p766
stp767
a((dp768
g2
(lp769
VYou'll need to instance a  for the :
p770
aVIt might help to look at the generated code in the code-behind files of the resource files that are created by the IDE
p771
aVThese files basically contain readonly properties for each resource that makes a query to an internal resource manager
p772
as(dp773
g14
V1968
p774
stp775
a((dp776
g2
(lp777
VTry this, it should work:
p778
aVExplanation: it matches either a single letter except \u201cp\u201d, followed by an optional whitespace and more characters, or multiple letters (at least two)
p779
aV/EDIT: I've added the ability to handle attributes in  tags
p780
as(dp781
g14
V1968
p782
stp783
a((dp784
g2
(lp785
VIn addition to the other answers:
p786
aVThe C++ language actually has the  keyword to explicitly declare the storage class of an object
p787
aVOf course, it's completely needless because this is the implied storage class for local variables and cannot be used anywhere
p788
aVThe opposite of  is  (both locally and globall)
p789
aVThe following two declarations are equivalent:
p790
aVBecause the keyword is utterly useless, it will actually be recycled in the next C++ standard (\u201cC++0x\u201d) and gets a new meaning, namely, it lets the compiler infer the variable type from its initialization (like  in C#):
p791
as(dp792
g14
V1968
p793
stp794
a((dp795
g2
(lp796
VActually, VB6 implements RAII just like C++ meaning that locally declared references automatically get set to  at the end of a block
p797
aVSimilarly, it should automatically reset member class variables after executing
p798
aVHowever, there have been several reports that this is not done reliably
p799
aVI don't remember any rigorous test but it has always been best practice to reset member variables manually
p800
as(dp801
g14
V1968
p802
stp803
a((dp804
g2
(lp805
V/EDIT: I've rewritten the whole posting
p806
aVBelow is a pretty complete solution to the VB highlighting problem
p807
aVIf SO has got nothing better, please use it
p808
aVVB syntax highlighting is definitely wanted
p809
aVI've also added a code example with some complex code literals that gets highlighted correctly
p810
aVHowever, I haven't even tried to get XLinq right
p811
aVMight still work, though
p812
aVThe keywords list is taken from the MSDN
p813
aVContextual keywords are not included
p814
aVDid you know the  operator
p815
aVThe algorithm knows literal type characters
p816
aVIt should also be able to handle identifier type characters but I haven't tested these
p817
aVNote that the code works on HTML
p818
aVAs a consequence, &, < and > are required to be read as named (
p819
aVentities, not single characters
p820
aVSorry for the long regex
p821
aVCode for testing:
p822
as(dp823
g14
V1968
p824
stp825
a((dp826
g2
(lp827
VC++ rarely uses the \u201cgenerics\u201d terminology
p828
aVInstead, the word \u201ctemplates\u201d is used and is more accurate
p829
aVTemplates describes one technique to achieve a generic design
p830
aVC++ templates is very different from what both C# and Java implement for two main reasons
p831
aVThe first reason is that C++ templates don't only allow compile-time type arguments but also compile-time const-value arguments: templates can be given as integers or even function signatures
p832
aVThis means that you can do some quite funky stuff at compile time, e
p833
ag118
aVcalculations:
p834
aVThis code also uses the other distinguished feature of C++ templates, namely template specialization
p835
aVThe code defines one class template,  that has one value argument
p836
aVIt also defines a specialization for that template that is used whenever the argument evaluates to 1
p837
aVThis allows me to define a recursion over template definitions
p838
aVI believe that this was first discovered by Andrei Alexandrescu
p839
aVTemplate specialization is important for C++ because it allows for structural differences in data structures
p840
aVTemplates as a whole is a means of unifying an interface across types
p841
aVHowever, although this is desirable, all types cannot be treated equally inside the implementation
p842
aVC++ templates takes this into account
p843
aVThis is very much the same difference that OOP makes between interface and implementation with the overriding of virtual methods
p844
aVC++ templates are essential for its algorithmic programming paradigm
p845
aVFor example, almost all algorithms for containers are defined as functions that accept the container type as a template type and treat them uniformly
p846
aVActually, that's not quite right: C++ doesn't work on containers but rather on ranges that are defined by two iterators, pointing to the beginning and behind the end of the container
p847
aVThus, the whole content is circumscribed by the iterators: begin <= elements < end
p848
aVUsing iterators instead of containers is useful because it allows to operate on parts of a container instead of on the whole
p849
aVAnother distinguishing feature of C++ is the possibility of partial specialization for class templates
p850
aVThis is somewhat related to pattern matching on arguments in Haskell and other functional languages
p851
aVFor example, let's consider a class that stores elements:
p852
aVThis works for any element type
p853
aVBut let's say that we can store pointers more effciently than other types by applying some special trick
p854
aVWe can do this by partially specializing for all pointer types:
p855
aVNow, whenever we instance a container template for one type, the appropriate definition is used:
p856
as(dp857
g14
V1968
p858
stp859
a((dp860
g2
(lp861
VFor completeness's sake:
p862
aVit's of course completely possible to write an own implementation of a multimethod pointer table for your objects and calculate the method addresses manually at run time
p863
aVThere's a paper by Stroustrup on the topic of implementing multimethods (albeit in the compiler)
p864
aVI wouldn't really advise anyone to do this
p865
aVGetting the implementation to perform well is quite complicated and the syntax for using it will probably be very awkward and error-prone
p866
aVIf everything else fails, this might still be the way to go, though
p867
as(dp868
g14
V1968
p869
stp870
a((dp871
g2
(lp872
VMost modern languages have native support for some of the design patterns
p873
aVIt has been argued that languages are better the more patterns they support natively without the need to implement them explicitly, and that Lisp is excellent in this regard
p874
aVJeff had something to say about that, too
p875
as(dp876
g14
V1968
p877
stp878
a((dp879
g2
(lp880
VWhat programming language do you use
p881
aVMany languages allow callback functions for regular expression matches
p882
aVThese can be used to propercase the match easily
p883
aVThe regular expression that would be used is quite simple, you just have to match all word characters, like so:
p884
aVAlternatively, you can already extract the first character to be an extra match:
p885
aVNow you can access the first character and successive characters in the match separately
p886
aVThe callback function can then simply return a concatenation of the hits
p887
aVIn pseudo Python (I don't actually know Python):
p888
aVIncidentally, this would also handle the case of \u201cO'Reilly\u201d because \u201cO\u201d and \u201cReilly\u201d would be matched separately and both propercased
p889
aVThere are however other special cases that are not handled well by the algorithm, e
p890
ag118
aV\u201cMcDonald's\u201d or generally any apostrophed word
p891
aVThe algorithm would produce \u201cMcdonald'S\u201d for the latter
p892
aVA special handling for apostrophe could be implemented but that would interfere with the first case
p893
aVFinding a thereotical perfect solution isn't possible
p894
aVIn practice, it might help considering the length of the part after the apostrophe
p895
as(dp896
g14
V1968
p897
stp898
a((dp899
g2
(lp900
VIt's best practice never to use C-style casts for two main reasons:
p901
aVas already mentioned, no checking is performed here
p902
aVThe programmer simply cannot know which of the various casts is used which weakens strong typing
p903
aVthe new casts are intentionally visually striking
p904
aVSince casts often reveal a weakness in the code, it's argued that making casts visible in the code is a good thing
p905
aVthis is especially true if searching for casts with an automated tool
p906
aVFinding C-style casts reliably is nearly impossible
p907
aVAs palm3D noted:
p908
aVI find C++-style cast syntax too verbose
p909
aVThis is intentional, for the reasons given above
p910
aVThe constructor syntax (official name: function-style cast) is semantically the same as the C-style cast and should be avoided as well (except for variable initializations on declaration), for the same reasons
p911
aVIt is debatable whether this should be true even for types that define custom constructors but in Effective C++, Meyers argues that even in those cases you should refrain from using them
p912
aVTo illustrate:
p913
aVThe  here will actually call the  constructor
p914
as(dp915
g14
V1968
p916
stp917
a((dp918
g2
(lp919
VYou must create a new anonymous type:
p920
aVRefer to the official guide
p921
as(dp922
g14
V1968
p923
stp924
a((dp925
g2
(lp926
VHejlsberg has described the reasons for not implementing the feature in an interview with Bruce Eckel
p927
aVI have to admit, though, that I don't know how he thinks his proposed workaround will work
p928
aVHis proposal is to defer arithmetic operations to some other generic class (read the interview
p929
aVHow does this help
p930
aVIMHO, not much
p931
as(dp932
g14
V1968
p933
stp934
a((dp935
g2
(lp936
V\u201cWhen in Rome, do as the Romans do
p937
aV\u201d
p938
aVWhile there is theoretically an advantage in using unsigned values where applicable because it makes the code more expressive, this is simply not done in C#
p939
aVI'm not sure why the developers initially didn't design the interfaces to handle  and make the type CLS compliant but now the train has left the station
p940
aVSince consistency is generally important I'd advise taking the C# road and using s
p941
as(dp942
g14
V1968
p943
stp944
a((dp945
g2
(lp946
VBoth the current version of VC++ and GCC do tail call optimizations fairly well and even for mutually recursive calls
p947
aVI bet the Intel compiler does, too
p948
aVLetting the compiler do the optimization is straightforward: Just switch on optimization for speed
p949
aVBut you do that anyway, right
p950
aV;-)
p951
aVFor MSVC, use /O2 or /Ox
p952
aVFor GCC, use -O3
p953
aVThe easiest way to check if the compiler did the optimization (that I know of) is perform a call that would otherwise result in a stack overflow \u2013 or looking at the assembly output
p954
aVHowever, you cann usually just assume that the compiler did the optimization
p955
aV/EDIT: Tail call optimization for C has been added to the GCC in the course of a diploma thesis by Mark Probst
p956
aVThe thesis describes some interesting caveats in the implementation
p957
aVIt's worth reading
p958
as(dp959
g14
V1968
p960
stp961
a((dp962
g2
(lp963
VI think the first method is easier to read and maintain
p964
aVI've found the opposite to be true
p965
aVBear in mind that sometimes more than one event handler will be bound to a given control
p966
aVDeclaring all events in one central place helps to organize the actions taking place on the site
p967
aVIf you need to change something you don't have to search for all places making a call to a function, you simply have to change it in one place
p968
aVWhen adding more elements that should have the same functionality you don't have to remember to add the handlers to them; instead, it's often enough to let them declare a class, or even not change them at all because they logically belong to a container element of which all child elements get wired to an action
p969
aVFrom an actual code:
p970
aVThis wired an event handler to all column headers in a table to make the table sortable
p971
aVImagine the effort to make all column headers sortable separately
p972
as(dp973
g14
V1968
p974
stp975
a((dp976
g2
(lp977
VYou can simply pass a variable-length array as a parameter
p978
as(dp979
g14
V1968
p980
stp981
a((dp982
g2
(lp983
VIn this case OysterD's code will be the fastest solution (vertex coloring)
p984
aVThat would really surprise me
p985
aVMy solution makes at most two passes through the list (if the last node is linked to the penultimate lode), and in the common case (no loop) will make only one pass
p986
aVWith no hashing, no memory allocation, etc
p987
aVYes
p988
aVI've noticed that the formulation wasn't perfect and have rephrased it
p989
aVI still believe that a clever hashing might perform faster \u2013 by a hair
p990
aVI believe your algorithm is the best solution, though
p991
aVJust to underline my point: the vertec coloring is used to detect cycles in dependencies by modern garbage collectors so there is a very real use case for it
p992
aVThey mostly use bit flags to perform the coloring
p993
as(dp994
g14
V1968
p995
stp996
a((dp997
g2
(lp998
VCookey, your code doesn't do what you apparent think it does
p999
aVPre-allocating the byte buffer in your case is pure waste because it will not be used
p1000
aVRather, your assignment drops the allocated memory and resets the  reference to point to another buffer because  returns a new array
p1001
as(dp1002
g14
V1968
p1003
stp1004
a((dp1005
g2
(lp1006
VRules 1 & 3 are contradictory to me
p1007
aVTo a certain extent, they are
p1008
aVThe reason is simple: if an object is stored in a hash table and, by changing its value, you change its hash then the hash table has lost the value and you can't find it again by querying the hash table
p1009
aVIt is important that while objects are stored in a hash table, they retain their hash value
p1010
aVTo realize this it is often simplest to make hashable objects immutable, thus evading the whole problem
p1011
aVIt is however sufficient to make only those fields immutable that determine the hash value
p1012
aVConsider the following example:
p1013
aVPeople rarely change their birthday and most people never change their name (except when marrying)
p1014
aVHowever, their shoe size may grow arbitrarily, or even shrink
p1015
aVIt is therefore reasonable to identify people using their birthday and name but not their shoe size
p1016
aVThe hash value should reflect this:
p1017
as(dp1018
g14
V1968
p1019
stp1020
a((dp1021
g2
(lp1022
VOnce again, Jeff has the answer
p1023
aV;-)
p1024
as(dp1025
g14
V1968
p1026
stp1027
a((dp1028
g2
(lp1029
VThe only thing that's wrong with this code (at least to me) is that you're not using a loop to process all elements
p1030
aVOther than that, why not to it like that
p1031
aVAnd with loop, I mean grabbing the container element via a JQuery and iterating over all child elements \u2013 basically a one-liner
p1032
as(dp1033
g14
V1968
p1034
stp1035
a((dp1036
g2
(lp1037
VThere's no such thing as a \u201cgood hash function\u201d for universal hashes (ed
p1038
aVyes, I know there's such a thing as \u201cuniversal hashing\u201d but that's not what I meant)
p1039
aVDepending on the context different criteria determine the quality of a hash
p1040
aVTwo people already mentioned SHA
p1041
aVThis is a cryptographic hash and it isn't at all good for hash tables which you probably mean
p1042
aVHash tables have very different requirements
p1043
aVBut still, finding a good hash function universally is hard because different data types expose different information that can be hashed
p1044
aVAs a rule of thumb it is good to consider all information a type holds equally
p1045
aVThis is not always easy or even possible
p1046
aVFor reasons of statistics (and hence collision), it is also important to generate a good spread over the problem space, i
p1047
ag9
aVall possible objects
p1048
aVThis means that when hashing numbers between 100 and 1050 it's no good to let the most significant digit play a big part in the hash because for ~ 90% of the objects, this digit will be 0
p1049
aVIt's far more important to let the last three digits determine the hash
p1050
aVSimilarly, when hashing strings it's important to consider all characters \u2013 except when it's known in advance that the first three characters of all strings will be the same; considering these then is a waste
p1051
aVThis is actually one of the cases where I advise to read what Knuth has to say in The Art of Computer Programming, vol
p1052
aV3
p1053
aVAnother good read is Julienne Walker's The Art of Hashing
p1054
as(dp1055
g14
V1968
p1056
stp1057
a((dp1058
g2
(lp1059
VThere's the IsThemeActive WinAPI function
p1060
as(dp1061
g14
V1968
p1062
stp1063
a((dp1064
g2
(lp1065
VYou can use the  tool from the binutils toolchain
p1066
aVHowever, their source is not always readily available
p1067
aVand I'm not actually even sure that this information can always be retrieved
p1068
aVPerhaps  reveals further information
p1069
aV/EDIT: The tool's name is of course
p1070
aVThe flag  is used to show only exported symbols
p1071
as(dp1072
g14
V1968
p1073
stp1074
a((dp1075
g2
(lp1076
VIf you're using Visual Studio Professional or above, you've got a zip file of icons in your VS path under
p1077
aVSome of the images use the Vista style
p1078
as(dp1079
g14
V1968
p1080
stp1081
a((dp1082
g2
(lp1083
s(dp1084
g14
V1968
p1085
stp1086
a((dp1087
g2
(lp1088
VThere are several things that could be improved in Jeff's solution, though
p1089
aVIMHO, not the place to test this
p1090
aVIf the function gets passed an empty string, something went seriously wrong anyway
p1091
aVThrow an error or don't react at all
p1092
aVTwice the work
p1093
aVConsidering that each operation creates a whole new string, this is bad, even if performance is not an issue
p1094
aVAgain, basically twice the work: First, use regex to replace multiple spaces at once
p1095
aVThen, use regex again to replace multiple dashes at once
p1096
aVTwo expressions to parse, two automata to construct in memory, iterate twice over the string, create two strings: All these operations can be collapsed to a single one
p1097
aVOff the top of my head, without any testing whatsoever, this would be an equivalent solution:
p1098
aVNotice that this method uses string functions instead of regex functions and char functions instead of string functions whenever possible
p1099
as(dp1100
g14
V1968
p1101
stp1102
a((dp1103
g2
(lp1104
VFor the most part, it's good to emulate the behaviour of the framework
p1105
aVMany elementary data types such as s are value types
p1106
aVIf you have types that have similar properties, use value types
p1107
aVFor example, when writing a  data type or a , value types are the logical solution
p1108
aVThe same goes for the other cases where the framework used value types: , , etc
p1109
aVWhen in doubt, use a reference type instead
p1110
as(dp1111
g14
V1968
p1112
stp1113
a((dp1114
g2
(lp1115
VYou can see whether a string has been interned by calling
p1116
aVThe call will return a new string that is either a reference to an interned string equal to the string that was passed as an argument, or  if the string was not interned
p1117
as(dp1118
g14
V1968
p1119
stp1120
a((dp1121
g2
(lp1122
VUsing only :
p1123
aV(Take care to copy the whitespaces correctly
p1124
aV@grom:
p1125
aVtail does not return an empty line
p1126
aVDamn
p1127
aVMy test file didn't end on  but on
p1128
aVApparently  can't create files that don't end on  (
p1129
aVAnyway, as long as the \u201cget last byte\u201d option works, all's well
p1130
as(dp1131
g14
V1968
p1132
stp1133
a((dp1134
g2
(lp1135
VWhy not use the C++ standard exceptions instead of MSFT's proprietary extension
p1136
aVC++ has an exception handling concept
p1137
aVC++ also has a \u201ccatchall\u201d clause so if you want to log exceptions you can use the following wrapper:
p1138
aVHowever, this is not very efficient in C++ because creating such a general wrapper means that handling code has to be inserted in every subsequent stack frame by the compiler (unlike in managed systems like
p1139
aVNET where exception handling comes at no additional cost as long as no exception is actually thrown)
p1140
as(dp1141
g14
V1968
p1142
stp1143
a((dp1144
g2
(lp1145
VSince C isn't a regular language and C function calls can contain arbitrary argument expressions, I fear the answer to your question is \u201cno
p1146
aV\u201d
p1147
as(dp1148
g14
V1968
p1149
stp1150
a((dp1151
g2
(lp1152
VBy using  for export, the function name will get exported mangled, i
p1153
ag9
aVcontain type information to help the C++ compiler resolve overloads
p1154
aVVB6 cannot handle mangled names
p1155
aVAs a workaround, you have to de-mangle the names
p1156
aVThe easiest solution is to link the DLL file using an export definition file in VC++
p1157
aVThe export definition file is very simple and just contains the name of the DLL and a list of exported functions:
p1158
aVAdditionally, you have to specify the  calling convention because that's the only calling convention VB6 can handle
p1159
aVThere's a project using assembly injection to handle C calls but I guess you don't want to use this difficult and error-prone method
p1160
as(dp1161
g14
V1968
p1162
stp1163
a((dp1164
g2
(lp1165
VIntuitively, the keyword returns a value from the function without leaving it, i
p1166
ag9
aVin your code example it returns the current  value and then resumes the loop
p1167
aVMore formally, it is used by the compiler to generate code for an iterator
p1168
aVIterators are functions that return  objects
p1169
aVThe MSDN has several articles about them
p1170
as(dp1171
g14
V1968
p1172
stp1173
a((dp1174
g2
(lp1175
VThere are two aspects
p1176
aVNET readily supports arrays of controls, VB6 just had to use a workaround because otherwise, wiring up events was really hard
p1177
aVIn
p1178
aVNET, wiring up events dynamically is easy
p1179
aVHowever, the
p1180
aVNET form designer does not support control arrays for a simple reason: arrays of controls are created/extended at run time
p1181
aVIf you know how many controls you need at compile time (the reasoning goes) then you give them different names and don't put them in an array
p1182
aVI know it's not very useful code
p1183
aVThat's exactly the point
p1184
aVWhy have a feature if it's useless
p1185
aVIf needed, you can also access a control by name, resulting in something like this:
p1186
as(dp1187
g14
V1968
p1188
stp1189
a((dp1190
g2
(lp1191
VIs a GUID unique 100% of the time
p1192
aVNot guaranteed, since there are several ways of generating one
p1193
aVHowever, you can try to calculate the chance of creating two GUIDs that are identical and you get the idea: a GUID has 128 bits, hence, there are 2128 distinct GUIDs \u2013 much more than there are stars in the known universe
p1194
aVRead the wikipedia article for more details
p1195
as(dp1196
g14
V1968
p1197
stp1198
a((dp1199
g2
(lp1200
VThere's also the legal aspect to consider
p1201
aVI don't know the situation elsewhere but in Germany you're simply not allowed to store credit card numbers1)
p1202
aVPeriod
p1203
aVIt doesn't matter whether you encrypt them or not and in what format you store them
p1204
aVAll you may do (and here I'm referring from memory, without any judicial knowledge) is store a strong hash (SHA-256
p1205
aVof the credit card number, along with the last four digits and the account number
p1206
aVAnd yes, it's trivial to rebuild the complete number from these information alone
p1207
aVLaws aren't always logical
p1208
aV1) Except if you're a federally certified credit card institute
p1209
as(dp1210
g14
V1968
p1211
stp1212
a((dp1213
g2
(lp1214
VLINQ itself must be doing some serious optimization around the Count() method somehow
p1215
aVDoes this surprise you
p1216
aVI imagine that for  implementations,  simply reads the number of elements directly while  has to query the  method, create an instance and call  at least once
p1217
aV/EDIT @Matt:
p1218
aVI can only assume that the Count() extension method for IEnumerable is doing something like this:
p1219
aVYes, of course it does
p1220
aVThis is what I meant
p1221
aVActually, it uses  instead of  but the result is the same
p1222
as(dp1223
g14
V1968
p1224
stp1225
a((dp1226
g2
(lp1227
VAre you using C or C++
p1228
aVThe next C++ version, C++0x, will support variadic templates which provide a solution to that problem
p1229
aVAnother workaround can be achieved by clever operator overloading to achieve a syntax like this:
p1230
aVIn order to get this to work, the class  has to be implemented to override  that returns a proxy object which, in turn, overrides
p1231
aVHowever, making this variant type safe in current C++ isn't possible as far as I know since it would have to work by type erasure
p1232
as(dp1233
g14
V1968
p1234
stp1235
a((dp1236
g2
(lp1237
VYour web server (or your text editor) apparently includes a BOM into the document
p1238
aVI don't see the rogue character in my browser except when I set the site's encoding explicitly to Latin-1
p1239
aVThen, I see two (
p1240
aVUTF-8 BOMs
p1241
aV/EDIT: From the fact that there are two BOMs I conclude that the BOM is actually included by your editor at the beginning of the file
p1242
aVWhat editor do you use
p1243
aVIf you use Visual Studio, you've got to say \u201cSave As \u2026\u201d in the File menu and then choose the button \u201cSave with encoding \u2026\u201d
p1244
aVThere, choose \u201cUTF-8 without BOM\u201d or something similar
p1245
as(dp1246
g14
V1968
p1247
stp1248
a((dp1249
g2
(lp1250
VYou might also want to consider replacing the conventional plugin interface by a scripting interface
p1251
aVThere are some very good bindings for several scripting languages in C/C++ that have already solved your problem
p1252
aVIt might not be a bad idea to build on top of them
p1253
aVFor example, have a look at Boost
p1254
aVPython
p1255
as(dp1256
g14
V1968
p1257
stp1258
a((dp1259
g2
(lp1260
VWhat do you mean by \u201cdynamic\u201d
p1261
aVA new, fixed set of controls for each data row in the data set
p1262
aVThen use a  that contains your controls
p1263
aVOr do you mean that, depending on your data layout, you want to provide the user with a customized set of controls, say, one  for each column
p1264
as(dp1265
g14
V1968
p1266
stp1267
a((dp1268
g2
(lp1269
VBy the way: most programming languages would disagree with Python and give the result
p1270
aVDepending on the interpretation of modulus this is correct
p1271
aVHowever, the most agreed-upon mathematical definition states that the modulus of a and b is the (strictly positive) rest r of the division of a / b
p1272
aVMore precisely, 0 <= r < b by definition
p1273
as(dp1274
g14
V1968
p1275
stp1276
a((dp1277
g2
(lp1278
VBy the way, VB, having the same underlying architecture, allows much more flexible  statements (the above code would work in VB) and still produces efficient code where this is possible so the argument by techical constraint has to be considered carefully
p1279
as(dp1280
g14
V1968
p1281
stp1282
a((dp1283
g2
(lp1284
VWhy doesn't C# support this class level generic type inference
p1285
aVBecause they're generally ambiguous
p1286
aVBy contrast, type inference is trivial for function calls (if all types appear in arguments)
p1287
aVBut in the case of constructor calls (glorified functions, for the sake of discussion), the compiler has to resolve multiple levels at the same time
p1288
aVOne level is the class level and the other is the constructor arguments level
p1289
aVI believe solving this is algorithmically non-trivial
p1290
aVIntuitively, I'd say it's even NP-complete
p1291
aVTo illustrate an extreme case where resolution is impossible, imagine the following class and tell me what the compiler should do:
p1292
as(dp1293
g14
V1968
p1294
stp1295
a((dp1296
g2
(lp1297
VHow long are the strings
p1298
aVIf they are very short, then a unique ID can be generated by considering the characters as digits in base 36 (26 + 10) that form a n-digits number where n is the length of the string
p1299
aVOn the other hand, if the strings are short enough to allow this, direct comparison won't be an issue anyway
p1300
aVOtherwise you'll have to generate a collision-free hash and this can only be done when the complete problem space is known in advance (i
p1301
ag9
aVif you know all strings that can possibly occur)
p1302
aVYou will want to have a look at perfect hashing, although the only feasible algorithm to find a perfect hash function that I know is probabilistic so collisions are still theoretically possible
p1303
aVThere might be other ways to find such a function
p1304
aVKnuth called this a \u201crather amusing \u2026 puzzle\u201d in TAoCP but he doesn't give an algorithm either
p1305
aVIn general, you give way too few information to find an algorithm that doesn't require probing the whole problem space in some manner
p1306
aVThis does invariably mean that the problem has exponential running time but could be solved using machine-learning heuristics
p1307
aVI'm not sure if this is advisable in your case
p1308
as(dp1309
g14
V1968
p1310
stp1311
a((dp1312
g2
(lp1313
VCSS doesn't offer any such thing
p1314
aVThe only solution is to write a preprocessing script that is either run manually to produce static CSS output based on some dynamic pseudo-CSS, or that is hooked up to the web server and preprocesses the CSS prior to sending it to the client
p1315
as(dp1316
g14
V1968
p1317
stp1318
a((dp1319
g2
(lp1320
VThere's a series of MSDN articles on this subject
p1321
aVHowever, I haven't really read the text myself
p1322
aVI believe that the collections framework by
p1323
aVNET has a broken interface and cannot be extended very well
p1324
aVThere's also C5, a libray that I am investigating right now
p1325
aVFor the reason mentioned above, I've had the project to implement my own collections library for
p1326
aVNET but I've stopped this project after the first benchmark revealed that even a straightforward, non-thread-safe generic  implementation is slower than the native
p1327
aVSince I've taken care not to produce any inefficient IL code, this means that
p1328
aVNET is simply not suited (yet) for writing on-par replacements for intrinsic data structures, and that the
p1329
aVNET framework has to use some behind-the-scenes knowledge to optimize the builtin collection classes
p1330
as(dp1331
g14
V1968
p1332
stp1333
a((dp1334
g2
(lp1335
VI can only once again point to Stroustrup and preach: Don't teach the C subset
p1336
aVIt's important, but not for beginners
p1337
aVC++ is complex enough as it is and the standard library classes, especially the STL, is much more important and (at least superficially) easier to understand than the C subset of C++
p1338
aVSame goes for pointers and heap memory allocation, incidentally
p1339
aVOf course they're important but only after having taught the STL containers
p1340
aVAnother important concept that new students have to get their head around is the concept of different compilation units, the One Definition Rule (because if you don't know it you won't be able to decypher error messages) and headers
p1341
aVThis is actually quite a barrier and one that has to be breached early on
p1342
aVApart from the language features the most important thing to be taught is how to understand the C++ compiler and how to get help
p1343
aVGetting help (i
p1344
ag9
aVknowing how to search for the right information) in my experience is the single most important thing that has to be taught about C++
p1345
aVI've had quite good experiences with this order of teaching in the past
p1346
aV/EDIT: If you happen to know any German, take a look at http://madrat
p1347
aVnet/coding/cpp/skript, part of a very short introduction used in one of my courses
p1348
as(dp1349
g14
V1968
p1350
stp1351
a((dp1352
g2
(lp1353
VIt definitely improves your code
p1354
aVYour tentatively formulated claim, that it's obscure and that code would merit from a  block is simply not true in C++ because RAII is an established idiom
p1355
aVResource handling in C++ is done by resource acquisition and garbage collection is done by implicit destructor calls
p1356
aVOn the other hand, explicit  blocks would bloat the code and introduce subtle errors because the code flow gets much more complex and resource handling has to be done explicitly
p1357
aVRAII (including s) isn't an obscure technique in C++ but firmly established best-practice
p1358
as(dp1359
g14
V1968
p1360
stp1361
a((dp1362
g2
(lp1363
VI've tried WordPress recently and am very disappointed
p1364
aVAs long as you don't want to customize anything, all is well
p1365
aVBut imagine you want to install a plugin to handle Markdown editing
p1366
aVThere the trouble begins
p1367
aVThe plugin architecture of WordPress is seriously screwd up
p1368
aVIn the case of Markdown, this means that no good solution exists
p1369
aVThe existing plugin is a series of (quite well-documented) hacks that fall apart at a hard stare
p1370
aVI never intended to write the least bit of code for WordPress but the last few days, I've been knee-deep in PHP the whole time, hacking plugins as well as the WordPress core in order to make it work for my special scenario (which really isn't all that special, I'm just a perfectionist)
p1371
aVWhich is a pity, because the documentation of WordPress is more than just patchy
p1372
aVI don't use it anymore, I  for functions and read the source
p1373
aVAll in all, one of the less enjoyable OpenSource projects
p1374
as(dp1375
g14
V1968
p1376
stp1377
a((dp1378
g2
(lp1379
VIs it possible to redirect clog, cerr, cout, stdin, stdout, and/or stderr
p1380
aVYes
p1381
aVYou want the  function
p1382
aVIs the only difference between clog and cerr the buffering
p1383
aVAs far as I know, yes
p1384
as(dp1385
g14
V1968
p1386
stp1387
a((dp1388
g2
(lp1389
VThere may be a syntax to do this in the upcoming version of C# but at the moment, no such thing exists
p1390
aVHowever, you might want to look at the  method in combination with Linq queries
p1391
as(dp1392
g14
V1968
p1393
stp1394
a((dp1395
g2
(lp1396
VI'm unable find the relevant passage in the standard but I believe Leon is right
p1397
aVIn this case of ambiguity, parenthesises around the expression inside the template argument list are required
p1398
as(dp1399
g14
V1968
p1400
stp1401
a((dp1402
g2
(lp1403
VThe inconsistency is due to use
p1404
aVis a sequence having an ordering over the elements
p1405
aVWhile it's true that the elements in a  are also ordered according to some comparison criterion, this ordering is non-evident from the structure
p1406
aVThere is no efficient way to get from one element to the next (efficient = constant time)
p1407
aVIn fact, to iterate over the map is quite expensive; either the creation of the iterator or the iterator itself involves a walk over the complete tree
p1408
aVThis cannot be done in O(n), unless a stack is used, in which case the space required is no longer constant
p1409
aVAll in all, there simply is no cheap way of returning the \u201cnext\u201d element after erasing
p1410
aVFor sequences, there is a way
p1411
aVAdditionally, Rob is right
p1412
aVThere's no need for the Map to return an iterator
p1413
as(dp1414
g14
V1968
p1415
stp1416
a((dp1417
g2
(lp1418
V considered useless \u2013 a strong, and critical, argument
p1419
as(dp1420
g14
V1968
p1421
stp1422
a((dp1423
g2
(lp1424
VYou can break lines in between parenthesises and braces
p1425
aVAdditionally, you can append the backslash character  to a line to explicitly break it:
p1426
as(dp1427
g14
V1968
p1428
stp1429
a((dp1430
g2
(lp1431
VWhy don't you just use  and deal with the resulting
p1432
aVYou can of course bundle this into a lambda to get your desired signature but this is expensive and should only be done once, not multiple times:
p1433
aV/EDIT: You can of course combine lambdas as follows but this involves redundant compilations and function calls:
p1434
aVDamn, maintainance downtime
p1435
aVHad to type the whole post again
p1436
aV:-/
p1437
aV/EDIT: aku's right, though
p1438
aVYou have to invoke  separately, else the compiler won't find the parameter reference
p1439
as(dp1440
g14
V1968
p1441
stp1442
a((dp1443
g2
(lp1444
V (but not
p1445
aVhas tabs which I find far superior to buffers
p1446
aVYou can say  to open a file in a new tab
p1447
aVCycling between tabs is done by klicking on the tab or by the key combinatons [n] and
p1448
aVGraphical vim even has graphical tabs
p1449
as(dp1450
g14
V1968
p1451
stp1452
a((dp1453
g2
(lp1454
VCompilers are good at optimising code such as yours
p1455
aVAny modern compiler would produce the same code for both cases and additionally replace  by a left shift
p1456
as(dp1457
g14
V1968
p1458
stp1459
a((dp1460
g2
(lp1461
VWe always use maximize for optimal speed but then, all the code I write in C++ is somehow related to bioinformatics algorithms and speed is crucial while the code size is relatively small
p1462
as(dp1463
g14
V1968
p1464
stp1465
a((dp1466
g2
(lp1467
VYour simple case can easily be built using the  method
p1468
aVHowever, take a look at Boost
p1469
aVTokenizer
p1470
aVIt's great
p1471
aVBoost generally has some very cool string tools
p1472
as(dp1473
g14
V1968
p1474
stp1475
a((dp1476
g2
(lp1477
VTake care to notice that the comma operator may be overloaded in C++
p1478
aVThe actual behaviour may thus be very different from the one expected
p1479
aVAs an example, Boost
p1480
aVSpirit uses the comma operator quite cleverly to implement list initializers for symbol tables
p1481
aVThus, it makes the following syntax possible and meaningful:
p1482
aVNotice that due to operator precedence, the code is (intentionally
p1483
aVidentical to
p1484
aVThat is, the first operator called is  which returns a proxy object on which the remaining s are invoked:
p1485
as(dp1486
g14
V1968
p1487
stp1488
a((dp1489
g2
(lp1490
VPerhaps a bit more theoretical
p1491
aVMathematically, collections in C++ can be described as a half-open interval of iterators, namely one iterator pointing to the start of the collection and one iterator pointing just behind the last element
p1492
aVThis convention opens up a host of possibilities
p1493
aVThe way algorithms work in C++, they can all be applied to subsequences of a larger collection
p1494
aVTo make such a thing work in Java, you have to create a wrapper around an existing collection that returns a different iterator
p1495
aVAnother important aspect of iterators has already been mentioned by Frank
p1496
aVThere are different concepts of iterators
p1497
aVJava iterators correspond to C++' input iterators, i
p1498
ag9
aVthey are read-only iterators that can only be incremented one step at a time and can't go backwards
p1499
aVOn the other extreme, you have C pointers which correspond exactly to C++' concept of a random access iterator
p1500
aVAll in all, C++ offers a much richer and purer concept that can be applied to a much wider variety of tasks than either C pointers or Java iterators
p1501
as(dp1502
g14
V1968
p1503
stp1504
a((dp1505
g2
(lp1506
VYour algorithm is nearly correct
p1507
aVHowever, the test should be  instead of :
p1508
aVThis is because 0 is inclusive in the random number while  is exclusive
p1509
aVIn other words, a broker with weight 0 would still have a small chance of being selected \u2013 not at all what you want
p1510
aVThis accounts for broker A having more hits than broker D
p1511
aVOther than that, your algorithm is fine and in fact the canonical way of solving this problem
p1512
as(dp1513
g14
V1968
p1514
stp1515
a((dp1516
g2
(lp1517
VWhile Keith is right, I suppose the example was simply badly chosen
p1518
aVGenerally, it is better to initialize to the \u201cright\u201d object from the beginning and not construct an intermediate, empty object as in your case
p1519
aVTwo reasons:
p1520
aVPerformance
p1521
aVThis should be obvious: Object creation costs time so creating less objects is better
p1522
aVMuch more important however, it better states your intent
p1523
aVYou do generally not intend to create stateless/empty objects
p1524
aVRather, you intend to create objects with some state or content
p1525
aVDo it
p1526
aVNo need to create a useless (because empty) temporary
p1527
as(dp1528
g14
V1968
p1529
stp1530
a((dp1531
g2
(lp1532
VLSP concerns invariants
p1533
aVYour board example is broken at the outset because the interfaces simply don't match
p1534
aVA better example would be the following (implementations omitted):
p1535
aVNow we have a problem although the interface matches
p1536
aVThe reason is that we have violated (implied) invariants
p1537
aVThe way getters and setters work, a  should satisfy the following invariant:
p1538
aVHowever, this invariant must be violated by a correct implementation of , therefore it is not a valid substitute of
p1539
as(dp1540
g14
V1968
p1541
stp1542
a((dp1543
g2
(lp1544
VI find the MB relatively expensive
p1545
aVThe cost-benefit ratio isn't right, unless you're prepared to pay for the fancy design
p1546
aVWhile the MBP is even more expensive, its price is on par with comparable professional notebooks so I find the cost-benefit ratio much better
p1547
aVAdditionally, I find 15" too small for development in Visual Studio but that's just me
p1548
as(dp1549
g14
V1968
p1550
stp1551
a((dp1552
g2
(lp1553
VThe following is no longer language-agnostic (but that doesn't matter for the discussion because the implementation is easily portable to other languages)
p1554
aVI tried to implement Luke's (theretically best) solution in an imperative programming language
p1555
aVTake your pick; mine's C#
p1556
aVNot very elegant at all
p1557
aVHowever, (without any testing whatsoever) I could imagine that its performance is quite decent because the recursion is in fact tail recursive
p1558
aVMy challenge: give a better recursive implementation (in an imperative language)
p1559
aVYou say what \u201cbetter\u201d means: less code, faster, I'm open for suggestions
p1560
as(dp1561
g14
V1968
p1562
stp1563
a((dp1564
g2
(lp1565
VHmm, I think I misunderstand the question but I'm going to risk it
p1566
aVWhat's wrong with the following straightforward method
p1567
aVEDIT Since this posting has garnered an impressive number of downvotes for such a simple answer to an equally simple question, let me add an explanation
p1568
aVPlease read this before downvoting
p1569
aVFirst of all, this code is not intendend as a drop-in replacement to the code in the question
p1570
aVIt is for illustration purpose only
p1571
aVdoes some additional correctness tests (e
p1572
ag118
aVwhether the source and target are valid directories, whether the source is a parent of the target etc
p1573
aVthat are missing from this answer
p1574
aVThat code is probably also more optimized
p1575
aVThat said, the code works well
p1576
aVIt has (almost identically) been used in a mature software for years
p1577
aVApart from the inherent fickleness present with all IO handlings (e
p1578
ag118
aVwhat happens if the user manually unplugs the USB drive while your code is writing to it
p1579
aV, there are no known problems
p1580
aVIn particular, I\u2019d like to point out that the use of recursion here is absolutely not a problem
p1581
aVNeither in theory (conceptually, it\u2019s the most elegant solution) nor in practice: this code will not overflow the stack
p1582
aVThe stack is large enough to handle even deeply nested file hierarchies
p1583
aVLong before stack space becomes a problem, the folder path length limitation kicks in
p1584
aVNotice that a malicious user might be able to break this assumption by using deeply-nested directories of one letter each
p1585
aVI haven\u2019t tried this
p1586
aVBut just to illustrate the point: in order to make this code overflow on a typical computer, the directories would have to be nested a few thousand times
p1587
aVThis is simply not a realistic scenario
p1588
as(dp1589
g14
V1968
p1590
stp1591
a((dp1592
g2
(lp1593
VPer the specs, your specialized function template should never be called outside , unless you  the template definition, which no compiler (except Comeau) currently supports (or has it planned for the forseeable future)
p1594
aVOn the other hand, once the function template is instantiated, there is a function visible to the compiler that is no longer a template
p1595
aVGCC may re-use this definition across different compiler units because the standard states that each template shall only be instantiated once for a given set of type arguments [temp
p1596
aVspec]
p1597
aVStill, since the template is not exported, this should be limited to the compilation unit
p1598
aVI believe that GCC may expose a bug here in sharing its list of instantiated templates across compilation units
p1599
aVNormally, this is a reasonable optimization but it should take function specializations into account which it doesn't seem to do correctly
p1600
as(dp1601
g14
V1968
p1602
stp1603
a((dp1604
g2
(lp1605
VIf it's an active code base, you might still want to upgrade the code base
p1606
aVOf course, performing the changes manually isn't feasible but I believe that this problem could be solved once and for all by one single  command
p1607
aVI haven't tried it, though, so take the following with a grain of salt
p1608
aVThis might not find all places (even not considering function calls) but it would alleviate the problem and make it possible to perform the few remaining changes manually
p1609
as(dp1610
g14
V1968
p1611
stp1612
a((dp1613
g2
(lp1614
VIf you find it hard to insert Javascript into the form elements, consider using a JavaScript framework such as Prototype or jQuery
p1615
aVThere, you can centralize the task of injecting event handling into form controls
p1616
aVBy that, I mean that you won't need to insert event handlers into the HTML form code
p1617
aVInstead, you register those events from somewhere else
p1618
aVFor example, in Prototype you would be able to write something like this:
p1619
aVAlso have a look at the answers to another question
p1620
aV/EDIT: of course, you can also insert custom attributes and thus event handlers into the form elements using HTML_QuickForm
p1621
aVHowever, the above way is superior
p1622
as(dp1623
g14
V1968
p1624
stp1625
a((dp1626
g2
(lp1627
V@aku's links show the proper solution
p1628
aVA simple alternative is to \u201cgo back in time\u201d to the antics of C and C++: declaration before definition
p1629
aVTry the following:
p1630
aVWorks like a charm
p1631
as(dp1632
g14
V1968
p1633
stp1634
a((dp1635
g2
(lp1636
V is indeed the right property to achieve this
p1637
aVHowever, the example given by bmatthews68 can be improved
p1638
aVThe most important thing about floating boxes is that they must specify an explicit width
p1639
aVThis can be rather inconvenient but this is the way CSS works
p1640
aVHowever, notice that  is a unit of measure that has no place in the world of HTML/CSS, at least not to specify widths
p1641
aVAlways resort to measures that will work with different font sizes, i
p1642
ag9
aVeither use  or
p1643
aVNow, if the menu is implemented as a floating body, then this means that the main content floats \u201caround\u201d it
p1644
aVIf the main content is higher than the menu, this might not be what you want:
p1645
aVYou can correct this behaviour by giving the main content a  equal to the width of the menu:
p1646
aVIn most cases you also want to give the main content a  so it doesn't \u201cstick\u201d to the menu too closely
p1647
aVBy the way, it's trivial to change the above so that the menu is on the right side instead of the left: simply change every occurrence of the word \u201cleft\u201d to \u201cright\u201d
p1648
aVAh, one last thing
p1649
aVIf the menu's content is higher than the main content, it will render oddly because  does some odd things
p1650
aVIn that case, you will have to clear the box that comes below the floating body, as in bmatthews68's example
p1651
aV/EDIT: Damn, HTML doesn't work the way the preview showed it
p1652
aVWell, I've included pictures instead
p1653
as(dp1654
g14
V1968
p1655
stp1656
a((dp1657
g2
(lp1658
VThis may be unhelpful but I somehow don't understand all these problems related to CSS
p1659
aVIf a newspaper designer would try to embed a movie in the ad page, everybody would agree that he's a bit crazy
p1660
aVBut still those same people pine after three-column layouts in HTML
p1661
aVHTML is just not apt to handle this kind of layout well at the moment
p1662
aVFurthermore, multi-column layouts are generally not really well-suited for reading on computer monitors
p1663
aVAren't there enough viable alternatives
p1664
aVAnd by the way, even tables don't offer a good way of implementing a fluent column layout so this is no reason at all to resort to such hacks
p1665
aVAssuming a halfway modern browser (i
p1666
ag9
aV> MSIE 6), tables don't offer any advantages over clean HTML + CSS that I know of
p1667
as(dp1668
g14
V1968
p1669
stp1670
a((dp1671
g2
(lp1672
VQuicksort has O(n2) worst-case runtime and O(nlogn) average case runtime
p1673
aVHowever, it\u2019s superior to merge sort in many scenarios because many factors influence an algorithm\u2019s runtime, and, when taking them all together, quicksort wins out
p1674
aVIn particular, the often-quoted runtime of sorting algorithms refers to the number of comparisons or the number of swaps necessary to perform to sort the data
p1675
aVThis is indeed a good measure of performance, especially since it\u2019s independent of the underlying hardware design
p1676
aVHowever, other things \u2013 such as locality of reference (i
p1677
ag9
aVdo we read lots of elements which are probably in cache
p1678
aV\u2013 also play an important role on current hardware
p1679
aVQuicksort in particular requires little additional space and exhibits good cache locality, and this makes it faster than merge sort in many cases
p1680
aVIn addition, it\u2019s very easy to avoid quicksort\u2019s worst-case run time of O(n2) almost entirely by using an appropriate choice of the pivot \u2013 such as picking it at random (this is an excellent strategy)
p1681
aVIn practice, many modern implementations of quicksort (in particular libstdc++\u2019s ) are actually introsort, whose theoretical worst-case is O(nlogn), same as merge sort
p1682
aVIt achieves this by limiting the recursion depth, and switching to a different algorithm (heapsort) once it exceeds logn
p1683
as(dp1684
g14
V1968
p1685
stp1686
a((dp1687
g2
(lp1688
VNo, we can't
p1689
aVRead Joel's excellent article The Laws of Leaky Abstraction, it is an eye-opener for many people
p1690
aVHowever, this isn't necessarily a bad thing, it just is
p1691
aVLeaky abstractions offer great opportunity because they make the underlying platform exploitable
p1692
as(dp1693
g14
V1968
p1694
stp1695
a((dp1696
g2
(lp1697
VThere are plenty of scenarios, for example if you want to create GUIs for more than one environment
p1698
aVLet's say you have classes for controls (\u201cwidgets\u201d) but each environment actually has its own widget set
p1699
aVIt's therefore logical to subclass the creation of these widgets for each environment
p1700
aVThe way to do this (since, as has been unhelpfully pointed out, constructors can't actually be virtual in most languages), is to employ an abstract factory and the above example is actually the standard example used to describe this design pattern
p1701
as(dp1702
g14
V1968
p1703
stp1704
a((dp1705
g2
(lp1706
VUse  instead of
p1707
as(dp1708
g14
V1968
p1709
stp1710
a((dp1711
g2
(lp1712
VEscaping all user input is enough for most sites
p1713
aVAlso make sure that session IDs don't end up in the URL so they can't be stolen from the  link to another site
p1714
aVAdditionally, if you allow your users to submit links, make sure no  protocol links are allowed; these would execute a script as soon as the user clicks on the link
p1715
as(dp1716
g14
V1968
p1717
stp1718
a((dp1719
g2
(lp1720
VI prefer the VB syntax in this case because here, you need to prefix the members inside the with block with a  to avoid ambiguities:
p1721
aVBut really, there's nothing wrong with  in general
p1722
as(dp1723
g14
V1968
p1724
stp1725
a((dp1726
g2
(lp1727
VC++ can't do this either
p1728
aVDid you mix up declaration with definition
p1729
as(dp1730
g14
V1968
p1731
stp1732
a((dp1733
g2
(lp1734
VThe two \u201coverloads\u201d aren't in the same scope
p1735
aVBy default, the compiler only considers the smallest possible name scope until it finds a name match
p1736
aVArgument matching is done afterwards
p1737
aVIn your case this means that the compiler sees
p1738
aVIt then tries to match the argument list, which fails
p1739
aVOne solution would be to pull down the overload from  into 's scope:
p1740
as(dp1741
g14
V1968
p1742
stp1743
a((dp1744
g2
(lp1745
VWhat you want isn't possible directly but you can use Expressions in C# 3
p1746
aV0:
p1747
aVNote that this relies on unspecified behaviour and while it does work in Microsoft\u2019s current C# and VB compilers, and in Mono\u2019s C# compiler, there\u2019s no guarantee that this won\u2019t stop working in future versions
p1748
as(dp1749
g14
V1968
p1750
stp1751
a((dp1752
g2
(lp1753
VThere is no such thing as an ASCII string in C#
p1754
aVStrings always contain UTF-16
p1755
aVNot realizing this leads to a lot of problems
p1756
aVThat said, the methods mentioned before work because they consider the string as UTF-16 encoded and transform the characters to ASCII symbols
p1757
aV/EDIT in response to the clarification: how did the binary data get in the string
p1758
aVStrings aren't supposed to contain binary data (use  for that)
p1759
as(dp1760
g14
V1968
p1761
stp1762
a((dp1763
g2
(lp1764
VWell, it's not an antipattern
p1765
aVThe C++ standard library makes use of this feature and
p1766
aVNET even offers a special  class in the
p1767
aVNET framework
p1768
aVIt's called
p1769
aVYes, this isn't restricted to function results but it can be used for such cases and is actually very useful here
p1770
aVIf
p1771
aVNET 1
p1772
aV0 had already had the  class, it would certainly have been used for the  methods, instead of the  parameter
p1773
as(dp1774
g14
V1968
p1775
stp1776
a((dp1777
g2
(lp1778
VIncidentally, is there a good reason for you not to use the strict doctype
p1779
aVstrict should always be the default
p1780
aVtransitional is only intended for legacy code
p1781
as(dp1782
g14
V1968
p1783
stp1784
a((dp1785
g2
(lp1786
VThe previously accepted answer is nice but it is wrong
p1787
aVThankfully, the error is a small one
p1788
aVChecking for  is not enough if you really want to know about the generic version of the interface; there are a lot of classes that implement only the nongeneric interface
p1789
aVI'll give the answer in a minute
p1790
aVFirst, though, I'd like to point out that the accepted answer is overly complicated, since the following code would achieve the same under the given circumstances:
p1791
aVThis does even more because it works for each item separately (and not on their common subclass, )
p1792
aVNow, for the correct solution
p1793
aVThis is a bit more complicated because we have to take the generic type  (that is, the type  with one type parameter) and inject the right generic argument:
p1794
aVYou can test the correctness of this code easily:
p1795
aVyields:
p1796
aVDon't be overly concerned by the fact that this uses reflection
p1797
aVWhile it's true that this adds runtime overhead, so does the use of the  operator
p1798
aVOf course the above code is awfully constrained and could be expanded into a more generally applicable method,
p1799
aVThe following implementation is slightly incorrect1 and I\u2019ll leave it here for historic purposes only
p1800
aVDo not use it
p1801
aVInstead, James has provided an excellent, correct implementation in his answer
p1802
aV1 It fails when the  is the same as ; for the same reason, it fails for nullable types, i
p1803
ag9
aVI\u2019ve created a gist with a comprehensive suite of test cases
p1804
as(dp1805
g14
V1968
p1806
stp1807
a((dp1808
g2
(lp1809
VIn conclusion, when you use a local variable of a type that implements , always, without exception, use 1
p1810
aVIf you use nonlocal  variables, then always implement the  pattern
p1811
aVTwo simple rules, no exception1
p1812
aVPreventing resource leaks otherwise is a real pain in the *ss
p1813
aV1): The only exception is \u2013 when you're handling exceptions
p1814
aVIt might then be less code to call  explicitly in the  block
p1815
as(dp1816
g14
V1968
p1817
stp1818
a((dp1819
g2
(lp1820
VScott Meyers says don't use protected attributes in Effective C++ (3rd ed
p1821
aV:
p1822
aVItem 22: Declare data members private
p1823
aVThe reason is the same you give: it breaks encapsulations
p1824
aVThe consequence is that otherwise local changes to the layout of the class might break dependent types and result in changes in many other places
p1825
as(dp1826
g14
V1968
p1827
stp1828
a((dp1829
g2
(lp1830
VWow, this problem is popular
p1831
aVIt's based on a misunderstanding in the  property
p1832
aVThis excellent article explains it:
p1833
aVUnderstanding , or "How (Not) To Vertically Center Content" by Gavin Kistner
p1834
aVIn a nutshell (and to prevent link rot):
p1835
aVInline elements (and only inline elements) can be vertically aligned in their context via
p1836
aVHowever, the \u201ccontext\u201d isn\u2019t the whole parent container height, it\u2019s the height of the text line they\u2019re in
p1837
aVjsfiddle example
p1838
aVFor block elements, vertical alignment is harder and strongly depends on the specific situation:
p1839
aVIf the inner element can have a fixed height, you can make its position  and specify its ,  and  position
p1840
aVjsfiddle example
p1841
aVIf the centered element consists of a single line and its parent height is fixed you can simply set the container\u2019s  to fill its height
p1842
aVThis method is quite versatile in my experience
p1843
aVjsfiddle example
p1844
aV\u2026 there are be more such special cases
p1845
as(dp1846
g14
V1968
p1847
stp1848
a((dp1849
g2
(lp1850
VIt works, when done right
p1851
aVcfeduke's solution works
p1852
aVHowever, you don't have to make the  interface generic, in fact, you don't have to change your original definition at all:
p1853
as(dp1854
g14
V1968
p1855
stp1856
a((dp1857
g2
(lp1858
VI would answer, \u201cbecause Java sucks\u201d but then again, perhaps that's too obvious \u2026 ;-)
p1859
as(dp1860
g14
V1968
p1861
stp1862
a((dp1863
g2
(lp1864
VI'm not too clear on your question
p1865
aVDo you want to know the syntax for events
p1866
aVWhy not look at the tutorial in the official documentation
p1867
as(dp1868
g14
V1968
p1869
stp1870
a((dp1871
g2
(lp1872
VKonrad Zuse's PlanKalkül (1940s) - never implemented
p1873
aVThere was actually an implementation of the language published by Rojas et al
p1874
aVsomewhere around the year 2000
p1875
as(dp1876
g14
V1968
p1877
stp1878
a((dp1879
g2
(lp1880
VVisual Basic 9
p1881
aV0 doesn't support this yet
p1882
aVHowever, Visual Basic 10
p1883
aV0 will
p1884
as(dp1885
g14
V1968
p1886
stp1887
a((dp1888
g2
(lp1889
V conditional and coalesce operator
p1890
aVI don't know how hidden you'd call it, but the Iif([expression],[value if true],[value if false]) As Object function could count
p1891
aVIt's not so much hidden as deprecated
p1892
aVVB 9 has the  operator which is much better and works exactly as C#'s conditional and coalesce operator (depending on what you want):
p1893
aVEdited to show another example:
p1894
aVThis will work with , but cause an exception with
p1895
as(dp1896
g14
V1968
p1897
stp1898
a((dp1899
g2
(lp1900
VImplementing equality in
p1901
aVNET correctly and efficiently is really hard
p1902
aVFor instance, you should implement  and should implement all the different operations in a consistent and efficient manner without code duplication
p1903
aVEven following the guidelines, I've found that incredibly hard to remember, therefore I've created a few snippets for C# and VB to fill in all the boilerplate code
p1904
aVThe actual comparison logic then has to be adjusted in just one place
p1905
aVUnfortunately, classes and structures require different handling
p1906
aVAs an example, the following class after inserting the snippet:
p1907
aVThe snippets are available for download
p1908
aVTo use them, type  (for classes) or  for structs inside the class/struct code
p1909
aVThe download is an unsigned VSI community component installer package
p1910
aVIf you don't trust the content, simply change the file extension to  and open/copy the files contained within manually
p1911
aVImportant
p1912
aVThis code intentionally (
p1913
aVtries to equate even objects of a derived class type
p1914
aVOften, this might not be desirable because equality between the base class and derived classes is not well-defined
p1915
aVUnfortunately,
p1916
aVNET and the coding guidelines are not very clear here
p1917
aVThe code that Resharper creates, posted below, is susceptible to undesired behaviour in such cases because  and  will treat this case differently
p1918
aVIn order to change this, an additional type check has to be inserted in the strongly-typed  method above:
p1919
as(dp1920
g14
V1968
p1921
stp1922
a((dp1923
g2
(lp1924
VUsing advanced CSS 2 selectors, another solution would be possible that does not rely on a class  to introduce layout info into the HTML
p1925
aVThe solution uses the adjacent selectors
p1926
aVUnfortunately, MSIE 6 doesn't support it yet so reluctance to use it is understandable
p1927
aVThis way, the first  won't have a top margin while any  that immediately follows a paragraph or a box has a top margin
p1928
as(dp1929
g14
V1968
p1930
stp1931
a((dp1932
g2
(lp1933
VThis code is well-formed
p1934
aVYou only have to pay attention that the definition of the template is visible at the point of instantiation
p1935
aVTo quote the standard, § 14
p1936
aV7
p1937
aV2
p1938
aV4:
p1939
aVThe definition of a non-exported function template, a non-exported member function template, or a non-exported member function or static data member of a class template shall be present in every translation unit in which it is explicitly instantiated
p1940
as(dp1941
g14
V1968
p1942
stp1943
a((dp1944
g2
(lp1945
VAs a general rule, PNG is never worse, and often better than GIF because of superior compression
p1946
aVThere might be some edge cases where GIF is slightly better (because the PNG format may have a slightly larger overhead from metadata) but it's really not worth the worry
p1947
aVIt may just be the tools I'm using, but GIF files usually seem to be a bit smaller than a comparible PNG
p1948
aVThat may indeed be due to the encoding tool you use
p1949
aV/EDIT: Wow, there seem to be a lot of misconceptions about PNG file size
p1950
aVTo quote Matt:
p1951
aVThere's nothing wrong with GIFs for images with few colours, and as you have noticed they tend to be smaller
p1952
aVThis is a typical encoding mistake and not inherent in the format
p1953
aVYou can control the colour depth and make the PNG file as small
p1954
aVPlease refer to the relevant section in the Wikipedia article
p1955
aVAlso, lacking support in MSIE6 is blown out of proportion by Chrono:
p1956
aVIf you need transparency and can get by with GIFs, then I'd recommend them because IE6 supports them
p1957
aVIE6 doesn't do well with transparent PNGs
p1958
aVThat's wrong
p1959
aVMSIE6 does support PNG transparency
p1960
aVIt doesn't support the alpha channel (without a few hacks), though but this is a different matter since GIFs don't have it at all
p1961
aVThe only technical reason to use GIFs instead of PNGs is when use need animation and don't want to rely on other formats
p1962
as(dp1963
g14
V1968
p1964
stp1965
a((dp1966
g2
(lp1967
VThe shortest variant:
p1968
aVNotice the extra parenthesis around the first argument
p1969
aVThey're necessary for disambiguation: else, C++ will handle this as a function declaration
p1970
aVAlso, it requires the header
p1971
aV/EDIT: Don't take this variant too seriously
p1972
aVIt's mainly show and quite slow
p1973
as(dp1974
g14
V1968
p1975
stp1976
a((dp1977
g2
(lp1978
VOne reason many features get delayed in VB is that the development structure is much different than in C# and additionally, that often more thought goes into details
p1979
aVThe same seems to be true in this case, as suggested by Paul Vick's post on the matter
p1980
aVThis is unfortunate because it means a delay in many cases (automatic properties, iterator methods, multiline lambdas, to name but a few) but on the other hand, the VB developers usually get a much more mature feature in the long run (looking at the discussion, this will be especially true for iterator methods)
p1981
aVSo, long story short: VB 10 will (hopefully
p1982
aVsee automatic properties
p1983
as(dp1984
g14
V1968
p1985
stp1986
a((dp1987
g2
(lp1988
V@Josh:
p1989
aVWhile I agree with the shivering, I still believe this is the better course of action
p1990
aVOtherwise, linking troubles are a certainty
p1991
aVI've had the situation before where I had to hack the compiled libraries using  to avoid definition conflicts
p1992
aVIt was a nightmare for platform interoperability reasons because the name mangling works very differently even in different versions of the same compilers (in my case, GCC)
p1993
as(dp1994
g14
V1968
p1995
stp1996
a((dp1997
g2
(lp1998
VCan this be done with HTTP headers
p1999
aVYes, this is the way to go
p2000
aVIf the information is provided, it's in the header as the
p2001
aVNote, however, that this is not necessarily the case
p2002
aVDownloading only the header can be done using a  request instead of
p2003
aVMaybe the following code helps:
p2004
aVNotice the property for the content length on the  object \u2013 no need to parse the  header manually
p2005
as(dp2006
g14
V1968
p2007
stp2008
a((dp2009
g2
(lp2010
VBasically your question boils down to \u201cis it reasonable to have [free library xyz] as a dependency for a C++ open source project
p2011
aV\u201d
p2012
aVNow consider the following quote from Stroustrup and the answer is really a no-brainer:
p2013
aVWithout a good library, most interesting tasks are hard to do in
p2014
aVC++; but given a good library, almost any task can be made easy
p2015
aVAssuming that this is correct (and in my experience, it is) then writing a reasonably-sized C++ project without dependencies is downright unreasonable
p2016
aVDeveloping this argument further, the one C++ dependency (apart from system libraries) that can reasonably be expected on a (developer's) client system is the Boost libraries
p2017
aVI know that they aren't but it's not an unreasonable presumption for a software to make
p2018
aVIf a software can't even rely on Boost, it can't rely on any library
p2019
as(dp2020
g14
V1968
p2021
stp2022
a((dp2023
g2
(lp2024
VApart from using pb's method, this isn't possible for a \u201csimple\u201d reason: the interface method needs to get passed a  pointer as the first argument
p2025
aVWhen you call  on your object, this pointer will be your object
p2026
aVHowever, in order for the invocation to work on the nested list, the pointer would have to be a reference to that list, not your class
p2027
aVTherefore you explicitly have to delegate the method to the other object
p2028
aV(And by the way, the advice in the other reply was right: use , not
p2029
as(dp2030
g14
V1968
p2031
stp2032
a((dp2033
g2
(lp2034
V/EDIT: as Lou said, using  instead of the  value itself might be slightly faster because of the way  implements
p2035
as(dp2036
g14
V1968
p2037
stp2038
a((dp2039
g2
(lp2040
VThe interpreter design pattern is a quite nice example because many people don't spot the recursion
p2041
aVThe example code listed in the Wikipedia article illustrates well how this can be applied
p2042
aVHowever, a much more basic approach that still implements the interpreter pattern is a  function for nested lists:
p2043
aV(Yes, I know it's not easy to spot the interpreter pattern in the above code if you expect a function called  \u2026 but really, the interpreter pattern doesn't tell us what the function is called or even what it does and the GoF book explicitly lists the above as an example of said pattern
p2044
as(dp2045
g14
V1968
p2046
stp2047
a((dp2048
g2
(lp2049
VThe error must be somewhere else because the above code definitely works, the null reference must be something else
p2050
as(dp2051
g14
V1968
p2052
stp2053
a((dp2054
g2
(lp2055
V does not require , contrary to popular belief
p2056
aVAll it requires is a method  that returns any object that has the method  and the get-property  with the appropriate signatures
p2057
aV/EDIT: In your case, however, you're out of luck
p2058
aVYou can trivially wrap your object, however, to make it enumerable:
p2059
aV/EDIT: The following method, proposed by several people, does not work if the method returns an :
p2060
as(dp2061
g14
V1968
p2062
stp2063
a((dp2064
g2
(lp2065
VWow, that's evil
p2066
aVIs this portable across compilers
p2067
aVMost definitely not
p2068
aVConsider the following:
p2069
aVIn order for this to work, foo's destructor must be virtual which it clearly isn't
p2070
aVAs long as you don't use  and as long as the derived objectd don't have custom destructors, though, you could be lucky
p2071
aV/EDIT: On the other hand, if the code is only used as in the question, inheritance has no advantage over composition
p2072
aVJust follow the advice given by m_pGladiator
p2073
as(dp2074
g14
V1968
p2075
stp2076
a((dp2077
g2
(lp2078
VOne fact that I've aways found funny is that Google is in fact run by bioinformatics (\u2019kay, I find that funny because I'm a bioinf\u2026thingy)
p2079
aVLet me explain
p2080
aVBioinformatics early on had the challenge to search small texts in gigantic strings very fast
p2081
aVFor us, the \u201cgigantic string\u201d is of course DNA
p2082
aVOften not a single DNA but a database of several DNAs from different species/individuals
p2083
aVThe small texts are proteins or their genetic counterpart, a gene
p2084
aVMost of the first work of computational biologists was restricted to find homologies between genes
p2085
aVThis is done to establish the function of newly found genes by noting similarities to genes that are already known
p2086
aVNow, these DNA strings get very big indeed and (lossy
p2087
aVsearch has to be done extremely efficiently
p2088
aVMost of the modern theory of string lookup was thus developed in the context of computational biology
p2089
aVHowever, quite some time ago, conventional text search was exhausted
p2090
aVA new approach was needed that allowed searching large strings in sublinear time, that is, without looking at each single character
p2091
aVIt was discovered that this can be solved by pre-processing the large string and building a special index data structure over it
p2092
aVMany different such data structures have been proposed
p2093
aVEach have their strengths and weaknesses but there's one that is especially remarkable because it allows a lookup in constant time
p2094
aVNow, in the orders of magnitude in which Google operates this isn't strictly true anymore because load balancing across servers, preprocessing and some other sophisticated stuff has to be taken into account
p2095
aVBut in the essence, the so-called q-gram index allows a lookup in constant time
p2096
aVThe only disadvantage: The data structure gets ridiculously big
p2097
aVEssentially, to allow for a lookup of strings with up to q characters (hence the name), it requires a table that has one field for each possible combination of q letters (that is, qS, where S is the size of the alphabet, say 36 (= 26 + 10))
p2098
aVAdditionally, there has to be one field for each letter position in the string that was indexed (or in the case of google, for each web site)
p2099
aVTo mitigate the sheer size, Google will probably use multiple indices (in fact, they do, to offer services like spelling correction)
p2100
aVThe topmost ones won't work on character level but on word level instead
p2101
aVThis reduces q but it makes S infinitely bigger so they will have to use hashing and collision tables to cope with the infinite number of different words
p2102
aVOn the next level, these hashed words will point to other index data structures which, in turn, will hash characters pointing to websites
p2103
aVLong story short, these q-gram index data structures are arguably the most central part of Google's search algorithm
p2104
aVUnfortunately, there are no good non-technical papers explaining how q-gram indices work
p2105
aVThe only publication that I know that contains a description of how such an index works is \u2026 alas, my bachelor thesis
p2106
as(dp2107
g14
V1968
p2108
stp2109
a((dp2110
g2
(lp2111
VPerformance
p2112
aVAs has been suggested in previous answers,  can make code faster, often at the expense of increased executables
p2113
aVHowever, modern compilers are very good at inlining automatically without any prompt from the user when set to high optimization
p2114
aVActually, compilers are usually better at determining what to inline for speed gain than humans are
p2115
aVDeclaring functions  explicitly for the sake of performance gain is (almost) always unnecessary
p2116
aVAdditionally, compilers can and will ignore the  request if it suits them
p2117
aVCompilers will do this if the function is hard to inline (i
p2118
ag9
aVusing nontrivial recursion or function pointers) but also if the function is simply too large to be meaningfully inlined
p2119
aVOne Definition Rule
p2120
aVHowever, declaring a function  may actually be necessary for completely different reasons, namely to satistfy the One Definition Rule (ODR)
p2121
aVThis rule in the C++ standard states that a given symbol may be declared multiple times but may only be defined once
p2122
aVIf the link editor (= linker) encounters several identical symbol definitions, it will generate an error
p2123
aVOne solution to this problem is to make sure that a compilation unit doesn't export a given symbol by marking it  ( \u2013 the keyword with the most completely unrelated meanings in C)
p2124
aVHowever, it's often better to mark a function  instead
p2125
aVThus, you allow the compiler to not create the function definition at all
p2126
aVThis is often very useful when working with templates which usually have to be declared in header files
p2127
aVAs an example, consider the following program:
p2128
aVNotice that both  files include the header file and thus the function definition of
p2129
aVAlthough the file is saved with include guards against double inclusion, this will result in two definitions of the same function, albeit in different compilation units
p2130
aVNow, if you try to link those two compilation unit, say, using the following command:
p2131
aVyou'll get an error saying \u201cduplicate definition of \u201d or something similar
p2132
aVIf, however, you unquote the  modifier in front of the function definition, the code compiles and links correctly
p2133
as(dp2134
g14
V1968
p2135
stp2136
a((dp2137
g2
(lp2138
VI don't think it's good to post complete codes for node balancing algorithms here since they get quite big
p2139
aVHowever, the Wikipedia article on red-black trees contains a complete C implementation of the algorithm and the article on AVL trees has several links to high-quality implementations as well
p2140
aVThese two implementations are enough for most general-purpose scenarios
p2141
as(dp2142
g14
V1968
p2143
stp2144
a((dp2145
g2
(lp2146
V@Dan
p2147
aVThis type of code is longer and more expressive, but also more readable
p2148
aVWell yes, it's longer
p2149
aVNot so sure about \u201cmore expressive\u201d and \u201cmore readable\u201d
p2150
aVAt the very least, your claim is disputable
p2151
aVI would even go as far as saying it's downright wrong, for two reasons
p2152
aVFirst, your code emphasizes the decision-making (rather extremely)
p2153
aVOnthe other hand, the conditional operator emphasizes something else, namely the value (resp
p2154
aVthe assignment of said value)
p2155
aVAnd this is exactly what the writer of this code wants
p2156
aVThe decision-making is really rather a by-product of the code
p2157
aVThe important part here is the assignment operation
p2158
aVYour code hides this assignment in a lot of syntactic noise: the branching
p2159
aVYour code is less expressive because it shifts the emphasis from the important part
p2160
aVEven then your code would probably trump some obscure ASCII art like
p2161
aVAn inline- would be preferable
p2162
aVPersonally, I don't like the variant introduced with Python 2
p2163
aV5 because it's backwards
p2164
aVI would prefer something that reads in the same flow (direction) as the C ternary operator but uses words instead of ASCII characters:
p2165
aVThis wins hands down
p2166
aVC and C# unfortunately don't have such an expressive statement
p2167
aVBut (and this is the second argument), the ternary conditional operator of C languages is so long established that it has become an idiom in itself
p2168
aVThe ternary operator is as much part of the language as the \u201cconventional\u201d  statement
p2169
aVBecause it's an idiom, anybody who knows the language immediately reads this code right
p2170
aVFurthermore, it's an extremely short, concise way of expressing these semantics
p2171
aVIn fact, it's the shortest imaginable way
p2172
aVIt's extremely expressive because it doesn't obscure the essence with needless noise
p2173
aVFinally, Jeff Atwood has written the perfect conclusion to this: The best code is no code at all
p2174
as(dp2175
g14
V1968
p2176
stp2177
a((dp2178
g2
(lp2179
VBear in mind that  is (unfortunately) not a reserved word in JavaScript
p2180
aVTherefore, someone (someone else, obviously) could have the grand idea of redefining it, breaking your code
p2181
aVA more robust method is therefore the following:
p2182
aVOn the flip side, this method is much more verbose and also slower
p2183
aV:-/
p2184
aVA common alternative is to ensure that  is actually undefined, e
p2185
ag118
aVby putting the code into a function which accepts an additional parameter, called , that isn\u2019t passed a value
p2186
aVTo ensure that it\u2019s not passed a value, you could just call it yourself immediately, e
p2187
ag118
ag1822
as(dp2188
g14
V1968
p2189
stp2190
a((dp2191
g2
(lp2192
VOne word of warning
p2193
aVThe  has really bad performance characteristics for most operations except insertion and lookup: Both removal and modification of a value may require a linear search of the whole list, resulting in runtime O(n)
p2194
aV(For modification, this depends on whether access occurred by index or by key
p2195
aVFor most operations with reasonable amounts of data, this is completely inacceptable
p2196
aVFurthermore, the data structure stores elements both in a linear vector and in a hash table, resulting in some memory overhead
p2197
aVIf retrieval by index doesn't happen too often, a  or  will have much better performance characteristics (access by index can be achieved through the  extension method)
p2198
aVIf, on the other hand, access by index is the norm, then stop using dictionary data structures alltogether and simply store your values in a
p2199
aVAlthough this means a linear search for access by key, all other operations are very cheap and overall performance is hard to beat in practice
p2200
aV/EDIT: Of course, the latter is also a dictionary data structure in the theoretical sense
p2201
aVYou could even encapsulate it in a class implementing the appropriate interface
p2202
as(dp2203
g14
V1968
p2204
stp2205
a((dp2206
g2
(lp2207
VIt's five oranges faster
p2208
aVOr rather: there can be no (correct) blanket answer
p2209
aVC++ is a statically compiled language (but then, there's profile guided optimization, too), C# runs aided by a JIT compiler
p2210
aVThere are so many differences that questions like \u201chow much faster\u201d cannot be answered, not even by giving orders of magnitude
p2211
as(dp2212
g14
V1968
p2213
stp2214
a((dp2215
g2
(lp2216
VHow about instead defining a  (or alternatively an interface having a single  method without argument) that simply returns a  and letting individual classes decide how they implement it
p2217
aVThis way, you don't confine yourself to premature decisions
p2218
as(dp2219
g14
V1968
p2220
stp2221
a((dp2222
g2
(lp2223
VHmm \u2026 I'm not sure which character you mean
p2224
aVThe caret (\u201c^\u201d, CIRCUMFLEX ACCENT) has the same code in ASCII and Unicode (U+005E)
p2225
aV/EDIT: Damn, my fault
p2226
aV710 (U+02C6) is actually the MODIFIER LETTER CIRCUMFLEX ACCENT
p2227
aVUnfortunately, this character isn't part of ASCII at all
p2228
aVIt might look like the normal caret but it's a different character
p2229
aVSimple conversion won't help here
p2230
aVI'm not sure if
p2231
aVNET supports mapping of similar characters when converting from Unicode
p2232
aVWorth investigating, though
p2233
as(dp2234
g14
V1968
p2235
stp2236
a((dp2237
g2
(lp2238
VThe rule is simple: All script should be external
p2239
aVBoth for maintenance and performance
p2240
aV(Why performance
p2241
aVBecause if the code is separate, it can easier be cached by browsers
p2242
aVJavaScript doesn't belong in the HTML code and if it contains special characters (such as <, >) it even creates problems
p2243
as(dp2244
g14
V1968
p2245
stp2246
a((dp2247
g2
(lp2248
VAlso notice that as part of a URI, the file extension doesn't play any role
p2249
aVIn fact, it isn't even a file extension, it just looks like one
p2250
aVThe type of the resource identified by a URI is not encoded in its name
p2251
aVInstead, it is decided by the  HTTP header field
p2252
aVIt's completely legitimate (but perhaps a bit stupid) to deliver a bitmap picture as  and conversely, to deliver an HTML page as
p2253
aVThis is also the reason why it is argued that file extensions shouldn't be part of URIs at all
p2254
aVSir Tim Berners-Lee elaborates on this in Hypertext Style: Cool URIs Don't Change
p2255
as(dp2256
g14
V1968
p2257
stp2258
a((dp2259
g2
(lp2260
VC++ has the  method from  but this doesn't work for maps
p2261
aVIn fact, algorithm support for associative containers is generally not good
p2262
aVAs a result, you'll have to use an interation or write an appropriate functor to be used with  (but I consider this to be unnecessary overhead):
p2263
as(dp2264
g14
V1968
p2265
stp2266
a((dp2267
g2
(lp2268
VYour question isn't very clear
p2269
aVHowever, I guess you're from a Java background
p2270
aVC#'s and VB's nested classes behave much different from Java's nested classes
p2271
aVIn fact, they behave much like Java's static nested classes, i
p2272
ag9
aVthey don't belong to an instance of the outer class
p2273
aVTherefore, instances of the inner class can't access nonstatic fields in the outer class (at least not without being given an instance explicitly)
p2274
as(dp2275
g14
V1968
p2276
stp2277
a((dp2278
g2
(lp2279
VDon't use an exception in such a case
p2280
aVC++ has a nontrivial performance overhead for such exceptions, even if no exception is thrown, and it additially makes reasoning about the code much harder (cf
p2281
aVexception safety)
p2282
aVBest-practice in C++ is one of the two following ways
p2283
aVBoth get used in the STL:
p2284
aVAs Martin pointed out, return an iterator
p2285
aVActually, your iterator can well be a  for a simple pointer, there's nothing speaking against it; in fact, since this is consistent with the STL, you could even argue that this way is superior to returning a reference
p2286
aVReturn a
p2287
aVThis makes it impossible to modify the value, though, since a copycon of the  is called which doesn't work with referende members
p2288
aV/EDIT:
p2289
aVThis answer has spawned quite some controversy, visible from the comments and not so visible from the many downvotes it got
p2290
aVI've found this rather surprising
p2291
aVThis answer was never meant as the ultimate point of reference
p2292
aVThe \u201ccorrect\u201d answer had already been given by Martin: execeptions reflect the behaviour in this case rather poorly
p2293
aVIt's semantically more meaningful to use some other signalling mechanism than exceptions
p2294
aVFine
p2295
aVI completely endorse this view
p2296
aVNo need to mention it once again
p2297
aVInstead, I wanted to give an additional facet to the answers
p2298
aVWhile minor speed boosts should never be the first rationale for any decision-making, they can provide further arguments and in some (few) cases, they may even be crucial
p2299
aVActually, I've mentioned two facets: performance and exception safety
p2300
aVI believe the latter to be rather uncontroversial
p2301
aVWhile it's extremely hard to give strong exceptions guarantees (the strongest, of course, being \u201cnothrow\u201d), I believe it's essential: any code that is guaranteed to not throw exceptions makes the whole program easier to reason about
p2302
aVMany C++ experts emphasize this (e
p2303
ag118
aVScott Meyers in item 29 of \u201cEffective C++\u201d)
p2304
aVAbout speed
p2305
aVMartin York has pointed out that this no longer applies in modern compilers
p2306
aVI respectfully disagree
p2307
aVThe C++ language makes it necessary for the environment to keep track, at runtime, of code paths that may be unwound in the case of an exception
p2308
aVNow, this overhead isn't really all that big (and it's quite easy to verify this)
p2309
aV\u201cnontrivial\u201d in my above text may have been too strong
p2310
aVHowever, I find it important to draw the distinction between languages like C++ and many modern, \u201cmanaged\u201d languages like C#
p2311
aVThe latter has no additional overhead as long as no exception is thrown because the information necessary to unwind the stack is kept anyway
p2312
aVBy and large, stand by my choice of words
p2313
as(dp2314
g14
V1968
p2315
stp2316
a((dp2317
g2
(lp2318
VThe  variable already contains the char code
p2319
aVyields
p2320
as(dp2321
g14
V1968
p2322
stp2323
a((dp2324
g2
(lp2325
VYou require a kind of compile-time
p2326
aVThis then calls a function depending on which case is
p2327
aVThis way, the compiler won't stumble upon code which it can't compile (because that is safely stored away in another function template that never gets instantiated)
p2328
aVThere are several ways of realizing such a compile-time
p2329
aVThe most common is to employ the SFINAE idiom: substitution failure is not an error
p2330
aVBoost's  ist actually an instance of this idiom
p2331
aVTo employ it correctly, you wouldn't write it in an  expression but rather use it as the return type of your function
p2332
aVUntested code:
p2333
as(dp2334
g14
V1968
p2335
stp2336
a((dp2337
g2
(lp2338
VNo, it isn't:
p2339
aVThis method uses the QuickSort algorithm
p2340
aVThis implementation performs an unstable sort
p2341
as(dp2342
g14
V1968
p2343
stp2344
a((dp2345
g2
(lp2346
V/EDIT: I see, an own iterator is actually necessary here (I misread the question first)
p2347
aVStill, I'm letting the code below stand because it can be useful in similar circumstances
p2348
aVIs an own iterator actually necessary here
p2349
aVPerhaps it's sufficient to forward all required definitions to the container holding the actual Points:
p2350
aVThis is assuming you're using a  internally but the type can easily be adapted
p2351
as(dp2352
g14
V1968
p2353
stp2354
a((dp2355
g2
(lp2356
VI would treat the entities as a unit (since they also can contain numerical character codes), resulting in the following regular expression:
p2357
aVThis matches
p2358
aVeither a word character (including \u201c\u201d), or
p2359
aVan HTML entity consisting of
p2360
aVthe character \u201c\u201d,
p2361
aVthe character \u201c\u201d,
p2362
aVthe character \u201c\u201d followed by at least one hexadecimal digit, or
p2363
aVat least one decimal digit, or
p2364
aVat least one letter (= named entity),
p2365
aVa semicolon
p2366
aVat least once
p2367
aV/EDIT: Thanks to \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5 for pointing out an error
p2368
as(dp2369
g14
V1968
p2370
stp2371
a((dp2372
g2
(lp2373
VYou'll have the same problem using reflection because in order to find the right property in all the type's properties, you'll have to know its name, right
p2374
as(dp2375
g14
V1968
p2376
stp2377
a((dp2378
g2
(lp2379
VExplanation in German but the code is a well-tested in-place implementation:
p2380
aVInvoked like this:
p2381
as(dp2382
g14
V1968
p2383
stp2384
a((dp2385
g2
(lp2386
VThis will largely depend on the used platform and other constraints
p2387
aVAs a general rule, a good (C++) programmer is (or should be) able to learn a platform-specific API in a very short time
p2388
aVFor C++, it's much more important to understand the different tool chains (e
p2389
ag118
aVa Windows programmer should also know the GCC tool chain) and differences in compilers
p2390
aVProgrammer should also understand limitations and platform-dependend behaviour of the language
p2391
aVAs for libraries, C++ programmers absolutely need to know STL and Boost
p2392
aVNo discussion
p2393
as(dp2394
g14
V1968
p2395
stp2396
a((dp2397
g2
(lp2398
VNote: The following examples may be simpler\u2014and thus possibly more readable\u2014but not all languages provide such syntax
p2399
aVThis is no argument for not using them in languages that do provide such a syntax
p2400
aVIncidentally, that includes all current mainstream languages after my last count
p2401
aVand they are not suitable for extending the variable assignment to include more than one statement in the future
p2402
aVThis is true
p2403
aVHowever, it's often certain that such an extension will absolutely never take place because the  will always yield one of two possible cases
p2404
aVIn such situations I will always prefer the expression variant over the statement variant because it reduces syntactic clutter and improves expressiveness
p2405
aVIn other situations I tend to go with the  statement mentioned before \u2013 if the language allows this usage
p2406
aVIf not, fall-back to generic
p2407
as(dp2408
g14
V1968
p2409
stp2410
a((dp2411
g2
(lp2412
VIf using
p2413
aVNET 3
p2414
aV5, why not use lambdas
p2415
aVUsage:
p2416
aVThis is strongly typed and efficient
p2417
aVThere are also extension methods that already do exactly this
p2418
as(dp2419
g14
V1968
p2420
stp2421
a((dp2422
g2
(lp2423
V is the idiomatic form
p2424
aVCasting away  is almost always a bad idea
p2425
aVYou'd have to guarantee that no write operation is performed
p2426
aVWhile this can be reasonably expected of a read access on a map, the specification doesn't say anything about this
p2427
aVIf you know that the value exists you can of course forego the test using  (which is quite inefficient, anyway, since it means traversing the map twice
p2428
aVEven if you don't know whether the element exists I wouldn't use this
p2429
aVUse the following instead:
p2430
aV/EDIT: As Chris has correctly pointed out, default-construction of objects of type  might be expensive, especially since this is done even if this object isn't actually needed (because the entry exists)
p2431
aVIf this is the case, don't use the default value for the  argument in the above case
p2432
as(dp2433
g14
V1968
p2434
stp2435
a((dp2436
g2
(lp2437
VCould Microsoft take legal action against me if I used a stylesheet from their page
p2438
aVAbsolutely, since you infringed their copyright
p2439
aVOn the other hand, it's debatable whether the stylesheet alone constitues a sufficient threshold of originality to justify legal actions1
p2440
aVAt the least, taking without asking is often considered rude
p2441
aV;-)
p2442
aV1) No
p2443
aVIt certainly doesn't
p2444
aVA sophisticated design however will
p2445
as(dp2446
g14
V1968
p2447
stp2448
a((dp2449
g2
(lp2450
VFlex, like Silverlight, is marketed for the creation of something called RIA = rich internet application
p2451
aVThe idea being that (D)HTML isn't really well-suited to create large-scale, well-responding applications on the web
p2452
aVI'm not sure whether this is really (still) true but historically, it fits
p2453
aVFlex and Silverlight attempt to correct this by providing two things: a different, extensible technology along with a large library and an adapted toolset for the creation of applications
p2454
aVThe disadvantage in both cases is the dependency from further (non-free, non-standard) components
p2455
aVThe advantage is a potentially much more productive workflow and better performance
p2456
as(dp2457
g14
V1968
p2458
stp2459
a((dp2460
g2
(lp2461
VI once used the Boyer-Moore algorithm and it was quite fast
p2462
aVBoyer-Moore isn't apt for efficiently searching many words
p2463
aVThere is actually a very efficient algorithm for doing just that, called the Wu-Manber algorithm
p2464
aVI'll post a reference implementation
p2465
aVNotice, however, that I did this some time ago for educational purpose only
p2466
aVHence, the implementation isn't really apt for direct usage and can also be made more efficient
p2467
aVIt also uses the  from the Dinkumware STL
p2468
aVSubsitute with  or an appropriate implementation
p2469
aVThere's an explanation of the algorithm in a lecture script from a lecture at the Freie Universität Berlin, held by Knut Reinert
p2470
aVThe original paper is also online (just found it again) but I don't particularly like the pseudocode presented there
p2471
aVExample of usage:
p2472
as(dp2473
g14
V1968
p2474
stp2475
a((dp2476
g2
(lp2477
VI'm guessing that you use a PNG image
p2478
aVThis is a gamma correction \u201cfeature\u201d
p2479
aVMark Ransom has posted a useful text about this
p2480
aVNotice that the  solution listed somewhere hasn't worked for me
p2481
as(dp2482
g14
V1968
p2483
stp2484
a((dp2485
g2
(lp2486
VYes
p2487
as(dp2488
g14
V1968
p2489
stp2490
a((dp2491
g2
(lp2492
VI'm just trying to gauge if people think there is much benefit from constructs like the above (in the absence of language support)
p2493
aVIMHO, yes
p2494
aVDoesn't something similar already exist
p2495
aVIf not, feel encouraged tp write a lightweight library
p2496
as(dp2497
g14
V1968
p2498
stp2499
a((dp2500
g2
(lp2501
VWhy don't you pass the default value directly
p2502
aVWhat use is the functor
p2503
aVBy the way,  is quite verbose
p2504
aVIt's also possible to just write
p2505
as(dp2506
g14
V1968
p2507
stp2508
a((dp2509
g2
(lp2510
VI'm not familiar with the term \u201cdata area\u201d but memory is often divided into \u201ccode section\u201d and \u201cdata section\u201d
p2511
aVCode resides in the former, data in the latter
p2512
aVI presume this is what's meant here
p2513
aVClassically, there's no distinction between the two
p2514
aVHowever, many modern operating systems can prohibit the execution of code int he data segment (provided the CPU supports this distinction)
p2515
aVThis sometimes goes by the catch phrase of \u201cNX flag\u201d, as in \u201cno execution\u201d and can effectively prevent some cases of malicious code injection
p2516
aV/EDIT: Notice that the C++ standard doesn't mention a \u201cdata area\u201d
p2517
as(dp2518
g14
V1968
p2519
stp2520
a((dp2521
g2
(lp2522
VYou can pass the flag  when opening the file:
p2523
as(dp2524
g14
V1968
p2525
stp2526
a((dp2527
g2
(lp2528
VI'm not a native speaker
p2529
aVIn writing, I always try to use
p2530
aVHowever, in programming I always use  instead of British English for much the same reason that I don't use German or French for my identifiers
p2531
as(dp2532
g14
V1968
p2533
stp2534
a((dp2535
g2
(lp2536
VThe error must be elsewhere
p2537
aVwrites the string, verbatim
p2538
aVNo post-processing is done on any part
p2539
aVThe additional slash is therefore added elsewhere in your code (prior to passing the string to )
p2540
as(dp2541
g14
V1968
p2542
stp2543
a((dp2544
g2
(lp2545
VDelegates have a slight overhead compared to virtual method calls because they're lists of methods and can therefore theoretically invoke multiple handlers
p2546
as(dp2547
g14
V1968
p2548
stp2549
a((dp2550
g2
(lp2551
VYou could use a priority queue that holds the \u201ctopmost\u201d item of each of the 256 linked lists
p2552
aVThis \u201ctopmost\u201d item is the one that is scheduled to be inserted into the resulting list
p2553
aVThis way, you can just take the smallest element from the priority queue, insert it into your resulting queue, and insert its next element into the priority queue:
p2554
as(dp2555
g14
V1968
p2556
stp2557
a((dp2558
g2
(lp2559
VIf you use s in your HTML files, all those files have to keep track of all the CSS files
p2560
aVThis obviously makes changes and additions (both for CSS and HTML files) harder
p2561
aVUsing , you reduce a theoretically infinite number of changes down to one
p2562
as(dp2563
g14
V1968
p2564
stp2565
a((dp2566
g2
(lp2567
V and  are identical
p2568
aVPay attention to pointer precedence, however:
p2569
aVis a pointer to a constant char (array), while  is a constant pointer to a mutable char (array)
p2570
as(dp2571
g14
V1968
p2572
stp2573
a((dp2574
g2
(lp2575
V selects the parent directory from the current
p2576
aVOf course, this can be chained:
p2577
aVThis would be two directories up
p2578
as(dp2579
g14
V1968
p2580
stp2581
a((dp2582
g2
(lp2583
VLet's say you have a class with a Uri property
p2584
aVIs there any way to get that property to accept both a string value and a Uri
p2585
aVNo because this would mean having two getters that vary only in their return type and this isn't allowed in
p2586
aVNET
p2587
aVI would use the  method exclusively and perhaps create a convenienec method to set the  property, given a string
p2588
aVHowever, since the conversion from  to  is straightforward, even this might be unnecessary
p2589
as(dp2590
g14
V1968
p2591
stp2592
a((dp2593
g2
(lp2594
VI use C++\u02da RAII all the time but I've also developed in VB6 for a long time and RAII has always been a widely-used concept there (although I've never heard anyone call it that)
p2595
aVIn fact, many VB6 programs rely on RAII quite heavily
p2596
aVOne of the more curious uses that I've repeatedly seen is the following small class:
p2597
aVUsage:
p2598
aVOnce the time-consuming operation terminates, the original cursor gets restored automatically
p2599
as(dp2600
g14
V1968
p2601
stp2602
a((dp2603
g2
(lp2604
VBasically, value semantics means that assigning one value to another creates a copy:
p2605
aVA special case is a function call which gets passed an argument:
p2606
aVThis is actually the same for Java and C++
p2607
aVHowever, Java knows only a few primitive types, among them , ,  and , along with enums which behave in this manner
p2608
aVAll other types use reference semantics which means that an assignment of one value to another actually redirects a pointer instead of copying the underlying value:
p2609
aVThere are a few caveats however
p2610
aVFor example, many reference types (,  \u2026) are actually immutables
p2611
aVTheir value cannot be changed and any assignment to them overrides the old value
p2612
aVAlso, arguments still get passed by value
p2613
aVThis means that the value of an object passed to a function can be changed but its reference can't:
p2614
as(dp2615
g14
V1968
p2616
stp2617
a((dp2618
g2
(lp2619
VUnfortunately, there is none
p2620
aVYou can use the  in many situations
p2621
aVAlternatively, you can use anonymous types to handle tuples, at least locally:
p2622
aVThe last alternative is to create an own class
p2623
as(dp2624
g14
V1968
p2625
stp2626
a((dp2627
g2
(lp2628
VThis is a trivial case for NRVO \u2013 names return value optimization (a misnomer in this case since there's no name)
p2629
aVStan Lippman hat a blog entry with a nice explanation of the mechanism involved
p2630
as(dp2631
g14
V1968
p2632
stp2633
a((dp2634
g2
(lp2635
VYes, you can control this behaviour through the  directives at the beginning of each file or in the project settings:
p2636
aVIt's best-practice to set  as the default for all your projects (can be done in the options dialog)
p2637
aVThis guarantees the same typing behaviour as in C#
p2638
aVThen, if you need dynamic typing, you can disable the setting selectively on a per-file basis by using the directive mentioned above
p2639
as(dp2640
g14
V1968
p2641
stp2642
a((dp2643
g2
(lp2644
VThis isn't part of the question but why are you using  in your code in place of the subscript operator
p2645
aVThe sense in  is to ensure that no operation on an invalid index occurs
p2646
aVHowever, this will never be the case in your loop since you know from your code what the indices are going to be (always assuming single-threadedness)
p2647
aVEven if your code contained a logical error, causing you to access an invalid element,  in this place would be useless because you don't expect the resulting exception and hence you don't treat it (or do you enclose all of your loops by  blocks
p2648
aVThe use of  here is misleading because it tells the reader that you (as a programmer) don't know what values the index will have \u2013 which is obviously wrong
p2649
aVI agree with Curro, this is a typical case for the use of iterators
p2650
aVAlthough this is more verbose (at least if you don't use constructs like Boost
p2651
aVForeach), it is also much more expressive and safer
p2652
aVBoost
p2653
aVForeach would allow you to write the code as follows:
p2654
aVThis operation is safe, efficient, short and readable
p2655
as(dp2656
g14
V1968
p2657
stp2658
a((dp2659
g2
(lp2660
VWhile the answer is \u201cyes\u201d for all builtin collections and probably any sane collection class out there, the documentation doesn't have any constraints formulated for
p2661
aVTherefore, nothing tells us that every iteration must be stable
p2662
aVI could imagine the following use case:
p2663
aVThis might well be implemented as a class that yields a different ordering for each iteration
p2664
aVSo \u2013 if you also want to consider strange borderline cases, the answer should be \u201cno\u201d
p2665
as(dp2666
g14
V1968
p2667
stp2668
a((dp2669
g2
(lp2670
VIt worked for me \u2013 both in quirks mode and in standards compliance mode
p2671
aVHowever, it does not work when switching to IE8 compatibility mode
p2672
as(dp2673
g14
V1968
p2674
stp2675
a((dp2676
g2
(lp2677
VYou can pass the  function a block that is executed to yield a default value in case the queried value doesn't exist yet:
p2678
aVOf course, this can be done recursively
p2679
aV/EDIT: Wow, there's an article answering this very question
p2680
aVFor the sake of completeness, here's the solution from the article for arbitrary depth hashes:
p2681
aVCredits go to Kent from Data Noise
p2682
as(dp2683
g14
V1968
p2684
stp2685
a((dp2686
g2
(lp2687
VUsing C++ for non performance-critical websites is just like using a fork-lifter to drive in nails or taking an aircraft carrier for a fishing trip
p2688
aVIt's completely overblown for the task although it's theoretically possible
p2689
aVThe points you mention are all right and for larger projects, this could actually form an argument
p2690
aVHowever, for most sites, even of medium size, this is completely irrelevant because there are more important concerns that are poorly addressed by C++
p2691
aVApart from the fact that languages like C++ simply necessitate a lot of boilerplate code that make you write easily five to ten times the amount of code (
p2692
aVfor the same functionality and the overhead of build time (compilation, linking, depolyment, maintenance), C++ also lacks the appropriate libraries for web development
p2693
aVLanguages like Python, Perl, PHP or Ruby are lightweight, easily deployed and offer great libraries for web development
p2694
as(dp2695
g14
V1968
p2696
stp2697
a((dp2698
g2
(lp2699
VExcellent question and one that has bothered me greatly
p2700
aVIt appears that the benefits of RAII are perceived very differently
p2701
aVIn my experience with
p2702
aVNET, the lack of deterministic (or at least reliable) resource collection is one of the major drawbacks
p2703
aVIn fact,
p2704
aVNET has forced me several times to employ whole architectures to deal with unmanaged resources that might (but might not) require explicit collecting
p2705
aVWhich, of course, is a huge drawback because it makes the overall architecture more difficult and directs the client's attention away from the more central aspects
p2706
as(dp2707
g14
V1968
p2708
stp2709
a((dp2710
g2
(lp2711
VThese accuracy problems are due to the internal representation of floating point numbers and there's not much you can do to avoid it
p2712
aVBy the way, printing these values at run-time often still leads to the correct results, at least using modern C++ compilers
p2713
aVFor most operations, this isn't much of an issue
p2714
as(dp2715
g14
V1968
p2716
stp2717
a((dp2718
g2
(lp2719
VThe first rule will fail as soon as there are circular dependencies
p2720
aVSo it cannot be applied strictly
p2721
aV(This can still be made to work but this shifts a whole lot of work from the programmer to the consumer of these libraries which is obviously wrong
p2722
aVI'm all in favour of rule 2 (although it might be good to include \u201cforward declaration headers\u201d instead of the real deal, as in  because this reduces compile time)
p2723
aVGenerally, I believe it's a kind of self-documentation if a header file \u201cdeclares\u201d what dependencies it has \u2013 and what better way to do this than to include the required files
p2724
aVEDIT:
p2725
aVIn the comments, I've been challenged that circular dependencies between headers are a sign of bad design and should be avoided
p2726
aVThat's not correct
p2727
aVIn fact, circular dependencies between classes may be unavoidable and aren't a sign of bad design at all
p2728
aVExamples are abundant, let me just mention the Observer pattern which has a circular reference between the observer and the subject
p2729
aVTo resolve the circularity between classes, you have to employ forward declaration because the order of declaration matters in C++
p2730
aVNow, it is completely acceptable to handle this forward declaration in a circular manner to reduce the number of overall files and to centralize code
p2731
aVAdmittedly, the following case doesn't merit from this scenario because there's only a single forward declaration
p2732
aVHowever, I've worked on a library where this has been much more
p2733
as(dp2734
g14
V1968
p2735
stp2736
a((dp2737
g2
(lp2738
V already gives you the iterator, no need to invoke  (additionally, it's inefficient because it's twice the work)
p2739
aVUse  or the  operator:
p2740
as(dp2741
g14
V1968
p2742
stp2743
a((dp2744
g2
(lp2745
VNET offers the static  method
p2746
aVYou can then use this image and invoke  on the target  object
p2747
as(dp2748
g14
V1968
p2749
stp2750
a((dp2751
g2
(lp2752
VOff the top of my head:
p2753
aVReplace non-generic variants of container classes by their generic counterparts
p2754
aVCut down on boxing/unboxing
p2755
aVSpecifically, use generics where possible and generally avoid passing value types as
p2756
aVFor dialogs using many dynamic controls: suspend drawing until after inserting all controls by using /
p2757
aVThis helps especially when using layout containers
p2758
as(dp2759
g14
V1968
p2760
stp2761
a((dp2762
g2
(lp2763
VYou've got to create a new array of the desired size (in your code, you've already done this) and copy the content
p2764
aVI'm not sure what the \u201cshrinking\u201d operation needs to do in your case
p2765
aVHowever, you cannot modify the dimensions of an existing array
p2766
aVThe function you proposed is defective because it can't know the dimensions of the target array
p2767
aVEither you pass it the dimensions and dimension the new array internally or you pass it the target array and simply copy the contents
p2768
aVEdit:
p2769
aVIn response to your edit: Yes, looping will be the reasonable way to do this and this is also reasonably fast
p2770
aVI'm not aware of a block-copying mechanism in
p2771
aVNET that can be applied to multidimensional arrays
p2772
as(dp2773
g14
V1968
p2774
stp2775
a((dp2776
g2
(lp2777
VThe real important difference is already mentioned in Chris' answer
p2778
aVHowever, the implications won't be obvious for everybody
p2779
aVAs an inline element,  may only contain other inline elements
p2780
aVThe following code is therefore wrong:
p2781
aVThe above code isn't valid
p2782
aVTo wrap block-level elements, another block-level element must be used (such as )
p2783
aVOn the other hand,  may only be used in places where block-level elements are legal
p2784
aVFurthermore, these rules are fixed in (X)HTML and they are not altered by the presence of CSS rules
p2785
aVSo the following codes are also wrong
p2786
as(dp2787
g14
V1968
p2788
stp2789
a((dp2790
g2
(lp2791
VExcept for the more fundamental types, the less-than operation isn't always trivial, and even equality may vary from situation to situation
p2792
aVImagine the situation of an airline that wants to assign all passengers a boarding number
p2793
aVThis number reflects the boarding order (of course)
p2794
aVNow, what determines who comes before who
p2795
aVYou might just take the order in which the customers registered \u2013 in that case, the less-than operation would compare the check-in times
p2796
aVYou might also consider the price customers paid for their tickets \u2013 less-than would now compare ticket prices
p2797
aV\u2026 and so on
p2798
aVAll in all, it's just not meaningful to define an  on the  class although it may be required to have passengers in a sorted container
p2799
aVI think that's what Google warns against
p2800
as(dp2801
g14
V1968
p2802
stp2803
a((dp2804
g2
(lp2805
VThat code needs refactoring
p2806
aVThis is how you write code in Java, not in C#
p2807
aVIn C#, you've got operator overloading
p2808
aVThis is the idiomatic way of doing the comparison
p2809
aVYour way, besides being more verbose, is just unexpected and inconsistent in C#
p2810
aVIf, and only if, there's a chance that these strings are actually  instead of empty, use the following instead:
p2811
as(dp2812
g14
V1968
p2813
stp2814
a((dp2815
g2
(lp2816
VThe accepted answer is kind of wrong, depending on the encoding of the document
p2817
aVIf no encoding is sent by in the HTTP header, the browser has to determine the encoding from the document itself
p2818
aVIf the document uses a  declaration to declare its encoding, then any ASCII-valued character (character code < 128) occurring before this statement must be an ASCII value, as per HTML 4 spec
p2819
aVTherefore, it's important that this  declaration occurs before any other element that may contain non-ASCII characters
p2820
as(dp2821
g14
V1968
p2822
stp2823
a((dp2824
g2
(lp2825
VThis doesn't crash, it just contains a syntax error:
p2826
aVUnfortunately, you cannot treat function return values as arrays in PHP
p2827
aVYou have to assign the value explicitly
p2828
aVUnfortunately, this doesn't work here because  makes a copy of the returned value
p2829
as(dp2830
g14
V1968
p2831
stp2832
a((dp2833
g2
(lp2834
VHave you tried not floating the  elements to the left
p2835
aVWhy are you actually doing this
p2836
aVIt isn't required in the current layout
p2837
as(dp2838
g14
V1968
p2839
stp2840
a((dp2841
g2
(lp2842
VThere's another thread on this subject
p2843
aVMy solutions from this thread (both one-liners):
p2844
aVThe nice (see Milan's second solution):
p2845
aVand the fast:
p2846
as(dp2847
g14
V1968
p2848
stp2849
a((dp2850
g2
(lp2851
VI'm considering building a framework for VB
p2852
aVNET, and using the My namespace to plug it into VB seems like a reasonable idea
p2853
aVIs it
p2854
aVIf it fits, by all means, use it
p2855
aVSince you didn't offer any further information about your framework it's hard to say
p2856
aVI wouldn't put general-purpose stuff into the  namespace (such as the  stuff) because there isn't really any advantage to putting it there
p2857
aVHowever, application-centered helpers fit in well
p2858
as(dp2859
g14
V1968
p2860
stp2861
a((dp2862
g2
(lp2863
VI beliebe Chris is right
p2864
aVHowever, another problem might stem from the fact that you assign to the iterator
p2865
aV\u2013 Are list iterators guaranteed to be assignable
p2866
aVWithout looking at the standard, I don't think so because assignability is nowhere mentioned in the SGI documentation of iterators
p2867
as(dp2868
g14
V1968
p2869
stp2870
a((dp2871
g2
(lp2872
VI believe that it's best-practice is to substitute all uses of  by  unless  meets the requirements better, if you don't mind using Boost
p2873
aVOn the other hand, it was surely intentional that  wasn't included in TR1
p2874
as(dp2875
g14
V1968
p2876
stp2877
a((dp2878
g2
(lp2879
VThis particular problem solves itself over time
p2880
aV;-)
p2881
aVVersion 8 of the Internet Explorer (currently in beta 2) ships with a built-in JavaScript profiler
p2882
aVThe next Safari version will probably also include one since its rendering engine, WebKit, now has one as part of its Web Inspector
p2883
as(dp2884
g14
V1968
p2885
stp2886
a((dp2887
g2
(lp2888
VThere is a very good portable alternative: Boost
p2889
aVForeach
p2890
aVJust dump this header into your project and you can write your loops as follows:
p2891
as(dp2892
g14
V1968
p2893
stp2894
a((dp2895
g2
(lp2896
VC++ is the name of a programming language that has been approved by international standards committees (ANSI/ISO)
p2897
aVVC++ (\u201cVisual C++\u201d) is the product name of Microsoft's C++ compiler and sometimes, but not officially, the IDE it's shipped with (\u201cVisual Studio\u201d)
p2898
as(dp2899
g14
V1968
p2900
stp2901
a((dp2902
g2
(lp2903
VIn addition to Mark's experience, I've found Smarty well-suited for extension
p2904
aVI've built a (corporate) MVC framework with built-in views based on Smarty which was both easy and is flexible
p2905
aVThe host of available template helper functions can also be extended very easily
p2906
as(dp2907
g14
V1968
p2908
stp2909
a((dp2910
g2
(lp2911
VWhat you could do would be to write an own  LINQ provider, as is done for LINQ to SQL to translate LINQ queries to SQL
p2912
aVHowever, one problem that I see with this approach is the fact that LINQ queries are usually evaluated lazily
p2913
aVIn order to benefit from pipelining, this is probably not a viable solution
p2914
aVIt might also be worth investigating how to implement Google\u2019s MapReduce API for C# and CUDA and then use an approach similar to PyCuda to ship the logic to the GPU
p2915
aVIn that context, it might also be useful to take a look at the already existing MapReduce implementation in CUDA
p2916
as(dp2917
g14
V1968
p2918
stp2919
a((dp2920
g2
(lp2921
VWhat makes you think that  isn't reflection
p2922
as(dp2923
g14
V1968
p2924
stp2925
a((dp2926
g2
(lp2927
VI seem to be one of the very few people on earth using this, but I would really love if Microsoft would implement the keywords ,  and  correctly in both their compiler and the IDE \u2013 in fact, all of the ISO 646 but these three are the only ones that are really useful
p2928
aVThey have a lot of \u201cgood\u201d excuses for not implementing them \u2013 not a breaking bug, not many people use them, yadda yadda yadda \u2013 but it's such a small thing and it seems so careless of them not to implement it just out of spite
p2929
aV\u2026 for people who don't know what I'm talking about:
p2930
aVThe keywords are also defined as macros in the standards header  for compilers that don't support the above code right away but standards-compliant compilers must support this code
p2931
as(dp2932
g14
V1968
p2933
stp2934
a((dp2935
g2
(lp2936
VDo you disagree with this
p2937
aVIs HTML and CSS impossible to learn well in a week
p2938
aVYes, I'm almost sure
p2939
aVAlthough I share your experience related to the implementation:
p2940
aVHowever I can take a photo shopped comp and create a pure HTML/CSS web page from it with ease
p2941
aVGiven a good reference or some prior knowledge, this isn't really all that hard, certainly much (
p2942
aVless hard than is often claimed, if the mock is any good
p2943
aVHowever, this:
p2944
aVCrossbrowser coding is not as hard as people make it sound
p2945
aVis wrong, in my experience
p2946
aVIt very much depends on the mock you're working from: If it's designed by a web developer and optimized for web development, implementation might be easy
p2947
aVHowever, graphical designs may be arbitrarily complex and implementing them all meaningfully while paying attention to divers browser quirks is extremely taxing
p2948
as(dp2949
g14
V1968
p2950
stp2951
a((dp2952
g2
(lp2953
VMost regular expression engines use non-deterministic automata since they offer much greater flexibility
p2954
aVDFAs are much more restricted
p2955
aVHave a look at some implementations and you'll see this
p2956
aVMicrosoft even underlines this fact in their documentation of the
p2957
aVNET Regex class:
p2958
aVThe
p2959
aVNET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl
p2960
aVMatching behavior (first paragraph) \u2013 this article also offers a rationale for the employment of an NFA rather than the more efficient DFA
p2961
as(dp2962
g14
V1968
p2963
stp2964
a((dp2965
g2
(lp2966
VThe default answer to this one is probably Refactor
p2967
aVsince this tool is also endorsed by Microsoft as the \u201cofficial\u201d VB refactoring addin
p2968
aVHowever, being a free tool, it comes nowhere near the power of other commercial tools such as ReSharper or Refactor
p2969
aVPro
p2970
aVBy the way: While I would definitely advise trying out all these tools, it must also be said that they make the IDE much, much slower
p2971
aVIf your machine is fast enough to handle it, go ahead and enjoy the added productivity boost
p2972
aVHowever, I'm currently not using any of these tools (despite having spent money on a Refactor
p2973
aVPro subscription) because my (virtual) machine can't handle the load
p2974
as(dp2975
g14
V1968
p2976
stp2977
a((dp2978
g2
(lp2979
VSome transportation protocols only allow alphanumerical characters to be transmitted
p2980
aVJust imagine a situation where control characters are used to trigger special actions and/or that only supports a limited bit width per character
p2981
aVBase64 transforms any input into an encoding that only uses alphanumeric characters, ,  and the  as a padding character
p2982
as(dp2983
g14
V1968
p2984
stp2985
a((dp2986
g2
(lp2987
VHow about removing the  attribute from the  object after rendering the  begin tag
p2988
aVI don't know ASP though so I could be wrong
p2989
as(dp2990
g14
V1968
p2991
stp2992
a((dp2993
g2
(lp2994
VUsually it's best to expose the least powerful interface that the user can still meaningfully work with
p2995
aVIf the user just needs some enumerable data, return
p2996
aVIf that's not enough because the user needs to be able to modify the list (attention
p2997
aVshouldn't often be the case), return an
p2998
aV/EDIT:
p2999
aVJoel asks a valid question in his comment: Why indeed expose the least powerful interface instead of granting the user maximum power
p3000
aV(paraphrased)
p3001
aVThe idea behind this is that the method returning the data might not expect the user to modify its content: Another method of the class might still expect the list to be non-empty after a reference to it was returned
p3002
aVImagine the user removes all data from the list
p3003
aVThe other method now has to make an additional check that ele might have been unnecessary
p3004
aVMore importantly, this exposes parts of the internal implementation through the return type
p3005
aVIf I need to change the implementation in the future so that it no longer uses an  container, I have a problem: I either need to change the method contract, introducing a build-breaking change
p3006
aVOr I need to copy the data into a list container
p3007
aVAs an example, imagine that an efficient implementation uses a Dictionary and just returns the  collection which doesn't implement
p3008
as(dp3009
g14
V1968
p3010
stp3011
a((dp3012
g2
(lp3013
VAn easy solution might be to wrap the  into another type to create a distinct type for overload resolution
p3014
aVIf you use a , this wrapper doesn't have any additional overhead:
p3015
as(dp3016
g14
V1968
p3017
stp3018
a((dp3019
g2
(lp3020
VSuffix Array and q-gram index
p3021
aVIf your strings have a strict upper bound on the size you might consider the use of a suffix array: Simply pad all your strings to the same maximum length using a special character (e
p3022
ag118
aVthe null char)
p3023
aVThen concatenate all strings and build a suffix array index over them
p3024
aVThis gives you a lookup runtime of m * log n where m is the length of your query string and n is the overall length of your combined strings
p3025
aVIf this still isn't good enough and your m has a fixed, small length, and your alphabet \u03a3 is restricted in size (say, \u03a3 < 128 different characters) you can additionally build a q-gram index
p3026
aVThis will allow retrieval in constant time
p3027
aVHowever, the q-gram table requires \u03a3m entries (= 8 MiB in the case of just 3 characters, and 1 GiB for 4 characters
p3028
aVMaking the index smaller
p3029
aVIt might be possible to reduce the size of the q-gram table (exponentially, in the best case) by adjusting the hash function
p3030
aVInstead of assigning a unique number to every possible q-gram you might employ a lossy hash function
p3031
aVThe table then would have to store lists of possible suffix array indices instead of just one suffix array entry corresponding to an exact match
p3032
aVThis would entail that lookup is no longer constant, though, because all entries in the list would have to be considered
p3033
aVBy the way, I'm not sure if you're familiar with how a q-gram index works since the Internet isn't helpful on this topic
p3034
aVI've mentioned this before in another topic
p3035
aVI've therefore included a description and an algorithm for the construction in my bachelor thesis
p3036
aVProof of concept
p3037
aVI've written a very small C# proof of concept (since you stated otherwise that you worked with C#)
p3038
aVIt works, however it is very slow for two reasons
p3039
aVFirst, the suffix array creation simply sorts the suffixes
p3040
aVThis alone has runtime n2 log n
p3041
aVThere are far superior methods
p3042
aVWorse, however, is the fact that I use  to obtain the suffixes
p3043
aVUnfortunately,
p3044
aVNET creates copies of the whole suffix for this
p3045
aVTo use this code in practice, make sure that you use in-place methods which do not copy any data around unnecessarily
p3046
aVThe same is true for retrieving the q-grams from the string
p3047
aVIt would possibly even better to not construct the  string used in my example
p3048
aVInstead, you could save a reference to the original array and simulate all my  accesses by working on this array
p3049
aVStill, it's easy to see that this implementation has essentially expected constant time retrieval (if the dictionary is well-behaved)
p3050
aVThis is quite an achievement that can't possibly be beaten by a search tree/trie
p3051
aVExample of usage:
p3052
as(dp3053
g14
V1968
p3054
stp3055
a((dp3056
g2
(lp3057
VBy the way, your code is a special case that doesn't have to use the conditional operator at all
p3058
aVInstead, the null coalesce operator is more appropriate (but still requires casting):
p3059
as(dp3060
g14
V1968
p3061
stp3062
a((dp3063
g2
(lp3064
VAccording to the MSDN,
p3065
aVNET uses QuickSort
p3066
aVBy the way, the method absolutely doesn't depend on the comparer (as long as it's comparison-based), why should
p3067
aVNET therefore use a different method depending on whether you provide a custom comparer or not
p3068
as(dp3069
g14
V1968
p3070
stp3071
a((dp3072
g2
(lp3073
VIt depends on the framework
p3074
aVBadly implemented frameworks might actually require this
p3075
aVI recall a hack in VB6 where there was no way to determine whether a collection contained an element
p3076
aVThe only way was to try to retrieve the element and swallow the error
p3077
as(dp3078
g14
V1968
p3079
stp3080
a((dp3081
g2
(lp3082
VThe  hack used to be necessary because many compilers didn't support in-place initialization of the value
p3083
aVSince this is no longer an issue, go for the other option
p3084
aVModern compilers are also capable of optimizing this constant so that no storage space is required for it
p3085
aVThe only reason for not using the  variant is if you want to forbid taking the address of the value: you can't take an address of an  value while you can take the address of a constant (and this would prompt the compiler to reserve space for the value after all, but only if its address is really taken)
p3086
aVAdditionally, the taking of the address will yield a link-time error unless the constant is explicitly defined as well
p3087
aVNotice that it can still be initialized at the site of declaration:
p3088
as(dp3089
g14
V1968
p3090
stp3091
a((dp3092
g2
(lp3093
VI think this will be exponential
p3094
aVEach increment to n brings twice as much calculation
p3095
aVNo, it doesn't
p3096
aVQuite on the contrary:
p3097
aVConsider that for n iterations, we get running time R
p3098
aVThen for n + 1 iterations we'll get exactly R + 1
p3099
aVThus, the growth rate is constant and the overall runtime is indeed O(n)
p3100
aVHowever, I think Dima's assumption about the question is right although his solution is overly complicated:
p3101
aVWhat you have to do is to come up with a closed form solution, i
p3102
ag9
aVthe non-recursive formula for T(n), and then determine what the big-O of that expression is
p3103
aVIt's sufficient to examine the relative size of T(n) and T(n + 1) iterations and determine the relative growth rate
p3104
aVThe amount obviously doubles which directly gives the asymptotic growth
p3105
as(dp3106
g14
V1968
p3107
stp3108
a((dp3109
g2
(lp3110
VIn the case of Unit Testing I've heard the answer from a Microsoft official
p3111
aVIn fact, if I recall correctly, Microsoft's feature is even based on the NUnit code base
p3112
aVThe reason for copying this particular OpenSource product (and others, I've been told) is that customers want this
p3113
aVAt first, this might seem like a cheap pretext but I can actually imagine some corporate customers who prefer it this way
p3114
aVAdditionally, the Microsoft employee claimed that it's easier for Microsoft to provide customer support if they implemented the program themselves because they can take an extended responsability for the source
p3115
aVIf that's true, OpenSource adoption has a long way to go
p3116
aV:-(
p3117
as(dp3118
g14
V1968
p3119
stp3120
a((dp3121
g2
(lp3122
VI usually go with  plus a simple generator:
p3123
as(dp3124
g14
V1968
p3125
stp3126
a((dp3127
g2
(lp3128
VThis is not really up to you (the programmer) to decide but to the user: Some browsers have an option for this setting
p3129
aVYou shouldn't try modifying the user's selected browser behaviour
p3130
aVSomeone of my team did this once in an instant messenger application that we were writing, without asking for other opinions first
p3131
aVThe users were super annoyed that our application kept overwriting their opened pages
p3132
as(dp3133
g14
V1968
p3134
stp3135
a((dp3136
g2
(lp3137
VYou've got to invoke the underlying events directly
p3138
aVIn your case, it looks as though this would be:
p3139
aVCommandManager
p3140
aVRequerySuggested(sender, EventArgs
p3141
aV\u2026)
p3142
aV/EDIT: Ok, I didn't notice that  is a framework class
p3143
aVIn this case, you obviously don't want to do what I've proposed
p3144
aVJon's solution is to the point: You've got to keep track of your own event and invoke that (e
p3145
ag118
aVas a delegate)
p3146
aVIn keeping with Jon's example, invocation would look like this:
p3147
as(dp3148
g14
V1968
p3149
stp3150
a((dp3151
g2
(lp3152
VThis works for me:
p3153
as(dp3154
g14
V1968
p3155
stp3156
a((dp3157
g2
(lp3158
VYou might want Boost
p3159
aVVariant or Boost
p3160
aVAny
p3161
aVJust as an additional pointer, you can look for \u201ctype erasure\u201d
p3162
as(dp3163
g14
V1968
p3164
stp3165
a((dp3166
g2
(lp3167
VThe temptation of using RegExp, once you've mastered the basics, is very big
p3168
aVIn fact, RegExp seems so powerful that people naturally want to start using it everywhere
p3169
aVI really suspect that there's a lot of psychology involved here, as demonstrated by Randall's XKCD comic (and yes, it is useful)
p3170
aVI've done an introductory presentation on RegExp once and the most important slide warned against its overuse
p3171
aVIt was the only slide that used bold font
p3172
aVI believe this should be done more often
p3173
as(dp3174
g14
V1968
p3175
stp3176
a((dp3177
g2
(lp3178
VTry this, should be much faster:
p3179
as(dp3180
g14
V1968
p3181
stp3182
a((dp3183
g2
(lp3184
VThe most obvious point where  is a direct optimization is in passing arguments to a function
p3185
aVIt's often important to ensure that the function doesn't modify the data so the only real choices for the function signature are these:
p3186
aVOf course, the real magic here is passing a reference rather than creating an (expensive) copy of the object
p3187
aVBut if the reference weren't marked as , this would weaken the semantics of this function and have negative effects (such as making error-tracking harder)
p3188
aVTherefore,  enables an optimization here
p3189
aV/EDIT: actually, a good compiler can analyze the control flow of the function, determine that it doesn't modify the argument and make the optimization (passing a reference rather than a copy) itself
p3190
aVhere is merely a help for the compiler
p3191
aVHowever, since C++ has some pretty complicated semantics and such control flow analysis can be very expensive for big functions, we probably shouldn't rely on compilers for this
p3192
aVDoes anybody have any data to back me up / prove me wrong
p3193
aV/EDIT2: and yes, as soon as custom copy constructors come into play, it gets even trickier because compilers unfortunately aren't allowed to omit calling them in this situation
p3194
as(dp3195
g14
V1968
p3196
stp3197
a((dp3198
g2
(lp3199
VWhat you want isn't possible in C++ because the (current version of the) language lacks some features that are required here: namely, creating function blocks \u201con the fly\u201d
p3200
aVThe best you can do is pass a function pointer or function object to your function
p3201
aVThe STL offers many examples of this
p3202
aVConsider:
p3203
aVThis passes a pointer to function  to the function
p3204
as(dp3205
g14
V1968
p3206
stp3207
a((dp3208
g2
(lp3209
VThis is in Visual Studio C++ 6
p3210
ag272
aVGut reaction: blech
p3211
aVSeriously
p3212
aVThe C++ compiler shipped with VC++ 6 is known to be buggy and generally performing very badly and it's 10 years old
p3213
aV@Downvoters: consider it
p3214
aVI mean this in all seriousness
p3215
aVVC6 is just comparatively unproductive and should not be used any more
p3216
aVEspecially since Microsoft discontinued its support for the software
p3217
aVThere are cases where this can't be avoided but they are rare
p3218
aVIn most cases, an upgrade of the code base saves money
p3219
aVVC++ 6 just doesn't allow to harness the potential of C++ which makes an objectively inferior tool
p3220
as(dp3221
g14
V1968
p3222
stp3223
a((dp3224
g2
(lp3225
V\u2026 and an old website written in VB
p3226
aVDoes \u201cold\u201d here imply perhaps that you also use an old version of VB here
p3227
aVAnyway, since extension methods are just vanilla static (\u201c\u201d) methods decorated with an attribute, you should be able to call them in any case
p3228
aVIf this isn't possible you either try to call them \u201cextension style\u201d in an old version of VB or you're referencing the wrong version of your C# assembly
p3229
aVEdit: are you sure you're ing the whole namespace, i
p3230
ag9
aVand not just
p3231
aVVB is able to access nested namespaces easier than C# so you can use classes from namespace  using the following code in VB
p3232
aVHowever, for extension methods to work, the full path has to be ed
p3233
as(dp3234
g14
V1968
p3235
stp3236
a((dp3237
g2
(lp3238
VIs it currently possible to translate C# code into an Abstract Syntax Tree
p3239
aVYes, trivially in special circumstances (= using the new Expressions framework):
p3240
aVThis creates an expression tree for the lambda, i
p3241
ag9
aVa function taking an  and returning the double
p3242
aVYou can modify the expression tree by using the Expressions framework (= the classes from in that namespace) and then compile it at run-time:
p3243
aVNotice that all expressions are immutable so they have to be built anew by composition
p3244
aVIn this case, I've prepended an addition of 1
p3245
aVNotice that these expression trees only work on real expressions i
p3246
ag9
aVcontent found in a C# function
p3247
aVYou can't get syntax trees for higher constructs such as classes this way
p3248
aVUse the CodeDom framework for these
p3249
as(dp3250
g14
V1968
p3251
stp3252
a((dp3253
g2
(lp3254
VExtra typing is not the issue here
p3255
aVThe problem with explicitly qualified names is the visual clutter
p3256
aVLet's face it, C++ syntax is untidy
p3257
aVNo need to make this worse by needlessly making names longer and sprinkling the code generously with s
p3258
aVI'm with Jeff Atwood: The Best Code is No Code At All
p3259
aVThis is so true
p3260
aVNamespace imports are a great way of reducing clutter with no drawback: As long as the scope of opened namespaces is reduced to a single compilation unit1, name conflicts, should they appear, can be resolved easily
p3261
aVWhy explicit names should (in general) be more readable has always been a mystery to me
p3262
aVThe readers should generally know the code good enough to be able to deduce semantics
p3263
aVIf they aren't, the code needs fixing anyway
p3264
aV1) Corollary: no  in headers
p3265
as(dp3266
g14
V1968
p3267
stp3268
a((dp3269
g2
(lp3270
VThe
p3271
aVNET classes ( and the likes) take UTF-8 as the default encoding
p3272
aVIf you want to read a different encoding you have to pass this explicitly to the appropriate constructor overload
p3273
aVAlso note that there's not one single encoding called \u201cANSI\u201d
p3274
aVYou're probably referring to the Windows codepage 1252 aka \u201cWestern European\u201d
p3275
aVNotice that this is different from the Windows default encoding in other countries
p3276
aVThis is relevant when you try to use  because this actually differs from system to system
p3277
aV/EDIT: It seems you misunderstood both my answer and my comment:
p3278
aVThe problem in your code is that you need to tell
p3279
aVNET what encoding you're using
p3280
aVThe other remark, saying that \u201cANSI\u201d may refer to different encodings, didn't have anything to do with your problem
p3281
aVIt was just a \u201cby the way\u201d remark to prevent misunderstandings (well, that one backfired)
p3282
aVSo, finally: The solution to your problem should be the following code:
p3283
aVThe important part here is the usage of an appropriate  instance
p3284
aVHowever, this assumes that your encoding is indeed Windows-1252 (but I believe that's what Notepad++ means by \u201cANSI\u201d)
p3285
aVI have no idea why your text gets displayed correctly when read by NUnit
p3286
aVI suppose that NUnit either has some kind of autodiscovery for text encodings or that NUnit uses some weird defaults (i
p3287
ag9
aVnot UTF-8)
p3288
aVOh, and by the way: \u201cANSI\u201d really refers to the \u201cAmerican National Standards Institute\u201d
p3289
aVThere are a lot of completely different standards that have \u201cANSI\u201d as part of their names
p3290
aVFor example, C++ is (among others) also an ANSI standard
p3291
aVOnly in some contexts it's (imprecisely) used to refer to the Windows encodings
p3292
aVBut even there, as I've tried to explain, it usually doesn't refer to a specific encoding but rather to a class of encodings that Windows uses as defaults for different countries
p3293
aVOne of these is Windows-1252
p3294
as(dp3295
g14
V1968
p3296
stp3297
a((dp3298
g2
(lp3299
VThis is certainly not the best way but I usually write output files that can be read by R and use this, along with an appropriate script, to plot the graphs
p3300
as(dp3301
g14
V1968
p3302
stp3303
a((dp3304
g2
(lp3305
VThere's also a pure CSS solution to this problem
p3306
aVHowever, it doesn't work in MSIE 6
p3307
aVTechnically, it works similar to Tomalek's solution but instead of using JavaScript to toggle the element's class, it uses CSS to toggle its style:
p3308
as(dp3309
g14
V1968
p3310
stp3311
a((dp3312
g2
(lp3313
VThere are two limits, both not enforced by C++ but rather by the hardware
p3314
aVThe first limit (should never be reached) is set by the restrictions of the size type used to describe an index in the array (and the size thereof)
p3315
aVIt is given by the maximum value the system's  can take
p3316
aVThis data type should always be the largest integer type of a system
p3317
aVThe other limit is a physical memory limit
p3318
aVThe larger your objects in the array are, the sooner this limit is reached because memory is full
p3319
aVFor example, a  of a given size n typically takes about four times as much memory as an array of type  (minus a small constant value)
p3320
aVTherefore, a  may contain more items than a  before memory is full
p3321
aVThe same counts for the native C-style arrays  and
p3322
aVAdditionally, this upper limit may be influenced by the type of  used to construct the  because an  is free to manage memory any way it wants
p3323
aVA very odd but nontheless conceivable allocator could pool memory in such a way that identical instances of an object share resources
p3324
aVThis way, you could insert a lot of identical objects into a container that would otherwise use up all the available memory
p3325
aVApart from that, C++ doesn't enforce any limits
p3326
as(dp3327
g14
V1968
p3328
stp3329
a((dp3330
g2
(lp3331
VMacros are often used to generate bulk of code
p3332
aVIt's often a pretty localized usage and it's safe to  any helper macros at the end of the particular header in order to avoid name clashes so only the actual generated code gets imported elsewhere and the macros used to generate the code don't
p3333
aV/Edit: As an example, I've used this to generate structs for me
p3334
aVThe following is an excerpt from an actual project:
p3335
as(dp3336
g14
V1968
p3337
stp3338
a((dp3339
g2
(lp3340
VI'd use :
p3341
aVThis probably isn't the most efficient way but it should be efficient enough for most purposes
p3342
aVNotice that some wildcard formats allow character classes which are more difficult to handle
p3343
as(dp3344
g14
V1968
p3345
stp3346
a((dp3347
g2
(lp3348
VAm I reading that right
p3349
aVYes
p3350
aVSimple as that
p3351
as(dp3352
g14
V1968
p3353
stp3354
a((dp3355
g2
(lp3356
VOn the subject of  and : The latter was meant to be used as the base class of all custom exceptions
p3357
aVHowever, this hasn't been enforced consistently from the beginning
p3358
aVConsequently, there's a controversy whether this class should be used at all rather than using  as the base class for all exceptions
p3359
aVWhichever way you decide, never throw an instance of these two classes directly
p3360
aVIt's actually a pity that they aren't
p3361
aVFor what it's worth, always try using the most specific exception possible
p3362
aVIf there is none to meet your requirement, feel free to create your own
p3363
aVIn this case, however, make sure that your exception has a benefit over existing exceptions
p3364
aVIn particular, it should convey its meaning perfectly and provide all the information necessary to handle the situation in a meaningful manner
p3365
aVAvoid to create stub exceptions that don't do anything meaningful
p3366
aVIn the same vein, avoid creating huge exception class hierarchies, they're rarely useful (although I can imagine a situation or two where I would use them \u2026 a parser being one of them)
p3367
as(dp3368
g14
V1968
p3369
stp3370
a((dp3371
g2
(lp3372
VWhy don't you just override the  method of your class to be consistent in meaning with
p3373
aVThis is the simplest way and also the most idiomatic since, as you've noticed,  compares equality rather than using
p3374
aVHowever, this check is done via
p3375
aVIt does not check whether the objects point to the same memory location
p3376
aV/EDIT: Additionally, if you're using
p3377
aVNET 3
p3378
aV5 you can use the  overload that accepts an  argument
p3379
aVYou can use this to provide a class that implements a custom equality relation for your class type
p3380
aVHowever, I think the first method is more appropriate in your case
p3381
as(dp3382
g14
V1968
p3383
stp3384
a((dp3385
g2
(lp3386
VWhy don't you just cache the value of the expression and its compiled value locally if this is such a bottleneck
p3387
aVI imagine a simply Dictionary could do the trick:
p3388
as(dp3389
g14
V1968
p3390
stp3391
a((dp3392
g2
(lp3393
V from  works for strings and  arrays:
p3394
aV/EDIT: This, of course, modifies the original string
p3395
aVBut STL to the rescue
p3396
aVThe following creates a new reversed string
p3397
aVUnfortunately (
p3398
aV, this doesn't work directly on C  arrays without creating an additional (implicit) copy:
p3399
as(dp3400
g14
V1968
p3401
stp3402
a((dp3403
g2
(lp3404
VUse a
p3405
aVEven for very small (= one-file) projects, the effort is probably worth it because you can have several sets of compiler settings to test things
p3406
aVDebugging and deployment works much easier this way
p3407
aVRead the  manual, it seems quite long at first glance but most sections you can just skim over
p3408
aVAll in all it took me a few hours and made me much more productive
p3409
as(dp3410
g14
V1968
p3411
stp3412
a((dp3413
g2
(lp3414
VTry omitting the  protocol prefix
p3415
aVIt works for me without one
p3416
aVI believe
p3417
aVNET will truncate any part after the  if it believes this to be a URL
p3418
aVThis is only a guess based on the error message but it seems logical considering that the part after the  character isn't processed by the server but rather by the client in other scenarios (e
p3419
ag118
aVweb browsers)
p3420
as(dp3421
g14
V1968
p3422
stp3423
a((dp3424
g2
(lp3425
V obviously can't replace good unit testing \u2013 but neither the other way round
p3426
aVWhile unit testing can detect the same errors as , this implies that there's no error in the unit tests, that unit testing is done often and early, etc \u2026
p3427
aVWriting good unit tests isn't always trivial and takes time
p3428
aVHowever, the compiler already implements some of the tests \u2013 in the form of type checking
p3429
aVAt the very least, this saves time
p3430
aVMore likely, this saves a lot of time and money (at least occasionally) because your tests were erroneous / didn't cover all cases / forgot to account for changes in the code
p3431
aVTo sum it up, there's no guarantee that your unit tests are correct
p3432
aVOn the other hand, there's a strong guarantee that the type checking performed by the compiler is correct or at least that its glitches (unchecked array covariance, bugs with circular references \u2026) are well-known and well-documented
p3433
aVAnother sum-up: Yes,  is definitely best practice
p3434
aVIn fact, I've worked for years in online communities like this one
p3435
aVWhenever someone needed help on code that obviously didn't have  enabled, we'd politely point this out and refuse to give any further help until this was fixed
p3436
aVIt saves so much time
p3437
aVOften, the problem was gone after this
p3438
aVThis is somewhat analogous to using correct HTML when asking help in a HTML support forum: invalid HTML might work, but then again, it might not and be the cause of the problems
p3439
aVTherefore, many professionals refuse to help
p3440
as(dp3441
g14
V1968
p3442
stp3443
a((dp3444
g2
(lp3445
V(X)HTML has no special support for tabs: they're just another whitespace character, regardless of whether you escape them or not
p3446
as(dp3447
g14
V1968
p3448
stp3449
a((dp3450
g2
(lp3451
VAs a
p3452
aVNET programmer (for the most part), I actually prefer the Java convention of dropping the  here, for a simple reason: Often, small redesigns require the change from an interface into an abstract base class or vice versa
p3453
aVIf you have to change the name, this might require a lot of unnecessary refactoring
p3454
aVOn the other hand, usage for the client should be transparent so they shouldn't care for this type hint
p3455
aVFurthermore, the \u201cable\u201d suffix in `Thingable\u201d should be enough of a hint
p3456
aVIt works well enough in Java
p3457
aV/EDIT: I'd like to point out that the above reasoning had prompted me to drop the  prefix for private projects
p3458
aVHowever, upon checking one of them against the FxCop rule set, I promptly reverted to the usage of
p3459
aVConsistency wins here, even though a foolish consistency is the hobgoblin of little minds
p3460
as(dp3461
g14
V1968
p3462
stp3463
a((dp3464
g2
(lp3465
VDifferent features inside the  namespace behave very differently and are implemented using different techniques
p3466
aVThere's not \u201cone\u201d documentation for them, unfortunately
p3467
aVMany of the shortcut methods refer to classes within the Microsoft
p3468
aVVisualBasic
p3469
aVdll
p3470
aVYou can of course reference this from C#
p3471
aVSome mappings (by no means complete):
p3472
aV=>
p3473
aVThis class is inherited from to produce the Application Framework of VB
p3474
aV=>
p3475
aV=>
p3476
aV=> Maps directly to C#'s
p3477
aV=> Maps directly to C#'s
p3478
as(dp3479
g14
V1968
p3480
stp3481
a((dp3482
g2
(lp3483
VThe easiest solution would be to employ another image replacement techique, e
p3484
ag118
aVgive the text a very large  value
p3485
aVRefer to Mezzoblue for a comprehensive list of techniques along with their trade-offs
p3486
aVAlternatively, you could provide the  property in the  section of the stylesheet
p3487
aVThis means it shouldn't get applied for screen readers (since these should be of media type )
p3488
aVHowever, I can't verify if current screen readers really have this (expected) behaviour
p3489
as(dp3490
g14
V1968
p3491
stp3492
a((dp3493
g2
(lp3494
V is what you want
p3495
aVResult:
p3496
as(dp3497
g14
V1968
p3498
stp3499
a((dp3500
g2
(lp3501
VGenerally, you look out for the load factor (informally, you already said that) which is formally defined as \u03b1 = n / N, i
p3502
ag9
aVthe ratio of used to total buckets
p3503
aVIn order for a hash table to function properly (or at least to reason about its performance in mathematical terms), it should be \u03b1 < 1
p3504
aVEverything else is really up to empirical tests: If you see that your hash table doesn't perform good starting at \u03b1 > 0
p3505
aV5, then be sure to stay under that value
p3506
aVThis value also depends on your collision resolution techique
p3507
aVHashing with chaining may require other load factors than hashing with open addressing
p3508
aVYet another factor is cache locality
p3509
aVIf your table gets too big, it won't fit into the main memory
p3510
aVSince your access into the array is random, loading from cache may become a bottleneck
p3511
as(dp3512
g14
V1968
p3513
stp3514
a((dp3515
g2
(lp3516
VIn the assignment  you first extract the old value of  to use in evaluating the right-hand side expression, in this case 'x'; then, you increment  by 1
p3517
aVLast, you assign the results of the expression evaluation (10) to  via the assignment statement
p3518
aVPerhaps an equivalent code would make the predicament clear:
p3519
aVThis is the equivalent of your  code in C#
p3520
as(dp3521
g14
V1968
p3522
stp3523
a((dp3524
g2
(lp3525
VAccording to the standard, you cannot be sure
p3526
aVThe exact type depends on your machine
p3527
aVYou can look at the definition in your compiler's header implementations, though
p3528
as(dp3529
g14
V1968
p3530
stp3531
a((dp3532
g2
(lp3533
VWell, try it out yourself: Grab a Gentoo (or other Linux) distro or try out the Singularity project from Microsoft Research
p3534
aVAnother interesting alternative is the ReactOS project
p3535
aVCompiling the kernel alone takes (depending on the machine) about the 15 minutes you've waited for your program
p3536
aVCompiling the whole system takes considerably longer
p3537
as(dp3538
g14
V1968
p3539
stp3540
a((dp3541
g2
(lp3542
VPrefix your output with :
p3543
as(dp3544
g14
V1968
p3545
stp3546
a((dp3547
g2
(lp3548
VIf this is PHP, then the regex must be enclosed in quotes
p3549
aVFurthermore, what's
p3550
aVDid you mean
p3551
aVAnother thing
p3552
aVPHP knows boolean values
p3553
aVThe canonical solution would rather look like this:
p3554
aVEDIT: Or, using :
p3555
aV(Here, the explicit test against  isn't strictly necessary but since  returns a number upon success I feel safer coercing the value into a )
p3556
as(dp3557
g14
V1968
p3558
stp3559
a((dp3560
g2
(lp3561
VAre there any reasons why I should never ever do this
p3562
aVYes, very simple: Because
p3563
aVNET relies on the fact that strings are immutable
p3564
aVSome operations (e
p3565
ag118
aV) actually return a reference to the original string
p3566
aVIf this now gets modified, all other references will as well
p3567
aVBetter use a  to modify a string since this is the default way
p3568
as(dp3569
g14
V1968
p3570
stp3571
a((dp3572
g2
(lp3573
VI've just had a look at the WebKit (Chrome, Safari \u2026) source
p3574
aVDepending on the type of array, different sort methods are used:
p3575
aVNumeric arrays (or arrays of primitive type) are sorted using the C++ standard library function  which implements some variation of quicksort (usually introsort)
p3576
aVContiguous arrays of non-numeric type are stringified and sorted using mergesort, if available (to obtain a stable sorting) or  if no merge sort is available
p3577
aVFor other types (non-contiguous arrays and presumably for associative arrays) WebKit uses either selection sort (which they call \u201cmin\u201d sort) or, in some cases, it sorts via an AVL tree
p3578
aVUnfortunately, the documentation here is rather vague so you\u2019d have to trace the code paths to actually see for which types which sort method is used
p3579
aVAnd then there are gems like this comment:
p3580
aV\u2013 Let\u2019s just hope that whoever actually \u201cfixes\u201d this has a better understanding of asymptotic runtime than the writer of this comment, and realises that radix sort has a slightly more complex runtime description than simply O(N)
p3581
aV(Thanks to phsource for pointing out the error in the original answer
p3582
as(dp3583
g14
V1968
p3584
stp3585
a((dp3586
g2
(lp3587
VThe key lies in
p3588
aVWhich value does this have for you
p3589
aV(The MSDN seems to suggest that it's always  for MSVC
p3590
as(dp3591
g14
V1968
p3592
stp3593
a((dp3594
g2
(lp3595
VA license isn't really coupled to a product but rather to a person acquiring the product by legal means
p3596
aVThe license is a contract between you (as the owner of the product's rights) and that person
p3597
aVThe direct implication here is that you can have different contracts (and thus different licenses) for the same product
p3598
aVIt's actually quite common to attach several licenses to a piece of source code, usually in order to give the user a broader choice (as in your case, where GPL'ed code is probably not something your company wants to use)
p3599
aV(Ah, yes \u2026 IANAL, of course
p3600
as(dp3601
g14
V1968
p3602
stp3603
a((dp3604
g2
(lp3605
Vfriol's approach is good when coupled with yours
p3606
aVFirst, build a vector consisting of the numbers 1\u2026n, along with the elements from the vector dictating the sorting order:
p3607
aVNow you can sort this array using a custom sorter:
p3608
aVNow you've captured the order of rearrangement inside  (more precisely, in the first component of the items)
p3609
aVYou can now use this ordering to sort your other vectors
p3610
aVThere's probably a very clever in-place variant running in the same time, but until someone else comes up with it, here's one variant that isn't in-place
p3611
aVIt uses  as a look-up table for the new index of each element
p3612
as(dp3613
g14
V1968
p3614
stp3615
a((dp3616
g2
(lp3617
VThe best you could get would be a partition into two \u201chemispheres\u201d where one hemisphere is managed and can guarantee the absence of dangling pointers
p3618
aVThe other hemisphere has explicit memory management and gives no guarantees
p3619
aVThese two can coexist, but no, you can't give your strong guarantees to the second hemisphere
p3620
aVAll you could do is to track all pointers
p3621
aVIf one gets deleted, then all other pointers to the same instance could be set to zero
p3622
aVNeedless to say, this is quite expensive
p3623
aVYour table would help, but introduce other costs (double indirection)
p3624
as(dp3625
g14
V1968
p3626
stp3627
a((dp3628
g2
(lp3629
VIs there anyway of using properties in C# with parameters
p3630
aVNo
p3631
aVYou only can provide the default property in C# with an argument, to model indexed access (as in a dictionary):
p3632
aVOther properties can't have arguments
p3633
aVUse a function instead
p3634
aVBy the way, it's recommented to do the same in VB so other
p3635
aVNET languages (C# \u2026) can use your code
p3636
aVBy the way, your code is unnecessarily complicated
p3637
aVFour things:
p3638
aVYou don't need to escape the  identifier
p3639
aVUse the keyword directly
p3640
aVWhy not use
p3641
aVUse , it's faster
p3642
aVYou query the dictionary twice
p3643
aVYour setter doesn't have to test whether the value already exists
p3644
as(dp3645
g14
V1968
p3646
stp3647
a((dp3648
g2
(lp3649
VYou can do this:
p3650
aVThis will not work with nested parens for Y, however
p3651
aVNesting requires recursion which isn't strictly regular any more (but context-free)
p3652
aVModern regexp engines can still handle it, albeit with some difficulties (back-references)
p3653
as(dp3654
g14
V1968
p3655
stp3656
a((dp3657
g2
(lp3658
VC (and C++) comments cannot be nested
p3659
aVRegular expressions work well:
p3660
aVThis requires the \u201cSingle line\u201d flag () because a C comment can span multiple lines
p3661
aVThis code should work
p3662
aV/EDIT: Notice that my above code actually makes an assumption about line endings
p3663
aVThis code won't work on a Mac text file
p3664
aVHowever, this can be amended relatively easily:
p3665
aVThis regular expression should work on all text files, regardless of their line endings (covers Windows, Unix and Mac line endings)
p3666
aV/EDIT: MizardX and Brian (in the comments) made a valid remark about the handling of strings
p3667
aVI completely forgot about that because the above regex is plucked from a parsing module that has additional handling for strings
p3668
aVMizardX's solution should work very well but it only handles double-quoted strings
p3669
as(dp3670
g14
V1968
p3671
stp3672
a((dp3673
g2
(lp3674
VYou need to use an encoding to tell
p3675
aVNET what you expect as the output
p3676
aVFor example, in UTF-16:
p3677
as(dp3678
g14
V1968
p3679
stp3680
a((dp3681
g2
(lp3682
VIf you change the original class name, you could rewrite the dependent code using an import alias as a  substitute:
p3683
aVThis has to go at the top of the file/namespace, just like regular s
p3684
aVI don't know if this is practical in your case, though
p3685
as(dp3686
g14
V1968
p3687
stp3688
a((dp3689
g2
(lp3690
VHmm \u2026 your request is a bit unspecific
p3691
aVWhile there are many recent developments in this general area, they're all quite specialized (naturally, since the field has matured)
p3692
aVThe original parsing approaches haven't really changed, though
p3693
aVYou might want to read up on changes in parser creation tools (Antlr, Gold Parser, to name but a few)
p3694
as(dp3695
g14
V1968
p3696
stp3697
a((dp3698
g2
(lp3699
VErm \u2026 How do you serialize
p3700
aVUsually, the XML serializer should never produce invalid XML
p3701
aV/EDIT in response to your update: Do not display invalid XML to your user to edit
p3702
aVInstead, display the properly escaped XML in the TextBox
p3703
aVRepairing broken XML isn't fun and I actually see no reason not to display/edit the XML in a valid, escaped form
p3704
aVAgain I could ask: how do you display the XML in the TextBox
p3705
aVYou seem to intentionally unescape the XML at some point
p3706
aV/EDIT in response to your latest comment: Well yes, obviously, since the it can contain HTML
p3707
aVYou need to escape your XML properly before writing it out into an HTML page
p3708
aVWith that, I mean the whole XML
p3709
aVSo this:
p3710
aVbecomes this:
p3711
as(dp3712
g14
V1968
p3713
stp3714
a((dp3715
g2
(lp3716
V nearly does what you want; unfortunately, rather than cycling the shorter list, it breaks
p3717
aVPerhaps there's a related function that cycles
p3718
aV/EDIT: Oh, you want a list of dict
p3719
aVThe following works (thanks to Peter, as well):
p3720
as(dp3721
g14
V1968
p3722
stp3723
a((dp3724
g2
(lp3725
VWhat's so dreaded about it
p3726
aVTry finding a common break condition and refactor it to be the head of the loop
p3727
aVIf that's not possible \u2013 fine
p3728
as(dp3729
g14
V1968
p3730
stp3731
a((dp3732
g2
(lp3733
VNotice that  has got a generic version that makes a cast to a base class unnecessary (if such a base class or interface is available):
p3734
as(dp3735
g14
V1968
p3736
stp3737
a((dp3738
g2
(lp3739
V\u201cFirst class\u201d means you can operate on them in the usual manner
p3740
aVMost of the times, this just means you can pass these first-class citizens as arguments to functions, or return them from functions
p3741
aVThis is self-evident for objects but not always so evident for functions, or even classes:
p3742
aVThis is an example in C# where functions actually aren't first-class objects
p3743
aVThe above code therefore uses a small workaround (namely a generic delegate called ) to pass a function as an argument
p3744
aVOther languages, such as Ruby, allow treating even classes and code blocks as normal variables (or in the case of Ruby, constants)
p3745
as(dp3746
g14
V1968
p3747
stp3748
a((dp3749
g2
(lp3750
VSomething else: Omit the parentheses, they\u2019re redundant in VB and as such, constitute syntactic garbage
p3751
aVAlso, I'm slightly bothered by how many people argue by giving technical examples in other languages that simply do not apply in VB
p3752
aVIn VB, the only reasons to use   instead of  is readability and logic
p3753
aVNot that you\u2019d need other reasons
p3754
aVCompletely different reasons apply in C(++), true
p3755
aVEven more true due to the existence of frameworks that really handle this differently
p3756
aVBut misleading in the context of VB
p3757
as(dp3758
g14
V1968
p3759
stp3760
a((dp3761
g2
(lp3762
VYou should generally prefer the second variant
p3763
aVIt's more robust to changes in your code
p3764
aVSuppose you add a constructor
p3765
aVNow you have to remember to initialize your variables there as well, unless you use the second variant
p3766
aVOf course, this only counts if there are no compelling reasons to use in-constructor initialization (as mentioned by discorax)
p3767
as(dp3768
g14
V1968
p3769
stp3770
a((dp3771
g2
(lp3772
V can be omitted in boolean contexts
p3773
aVGenerally, you can use this to replicate the C# code:
p3774
as(dp3775
g14
V1968
p3776
stp3777
a((dp3778
g2
(lp3779
VI don't think comments are a good place to learn, even if you have to emulate this style
p3780
aVComments are often not even correct English and good projects will not have too many comments anyway, hence, not much to learn from
p3781
aVIf, on the other hand, you take a project that is commented extensively you can be almost sure that it's not a great role model since the programmers were incapable of conveying terse meaning
p3782
aVThis is a generalization, of course
p3783
aVHowever, I believe it's (almost
p3784
aValways true
p3785
aVYMMV
p3786
aVInstead, learn English by studying the experts
p3787
aVThere has been a question about this
p3788
aVI recommended \u201cOn Writing Well\u201d by William Zinsser and I will do so again
p3789
aV(By the way, English isn't my mother tongue either
p3790
as(dp3791
g14
V1968
p3792
stp3793
a((dp3794
g2
(lp3795
VA web application will do nicely for this kind of job
p3796
aVInstalling a framework such as Django shouldn't be at all difficult
p3797
aVIn fact, it's a matter of copying the file
p3798
aVSetting up a web server is the main problem and there are already some pretty neat configurations for this (e
p3799
ag118
aVXAMPP for general purpose), some even don't need any installing and can be run from a USB drive
p3800
aVNow, I don't really know Django but I know that Ruby on Rails ships with an own web server that can be launched via a simple script command
p3801
aVInstalling here is really a matter of copying the files and launching one script
p3802
as(dp3803
g14
V1968
p3804
stp3805
a((dp3806
g2
(lp3807
VCustom collections may have advantages when used in interfaces because you have more control over how they can be used than you have using standard collections
p3808
aVBe sure to always return an interface instead of the concrete class, though
p3809
aVThis way, your user doesn't have to care about the type of the collection class and you can change the actual type without breaking the interface
p3810
aVIn most cases, you'll be fine using one of the default collections
p3811
as(dp3812
g14
V1968
p3813
stp3814
a((dp3815
g2
(lp3816
VPersonally, I think that VB's syntax for delegates and lambdas is completely bogus
p3817
aVI mean, come on,
p3818
aVThis was fine in VB6
p3819
aVIt is definitely not fine in a language such as VB
p3820
aVNET where functions should be treated as first-class citizens (although they really aren't, of course) and where conversion from method groups to delegates is more or less transparent
p3821
aVNow the introduction of inline functions is horribly verbose
p3822
aVI actually believe that the C# approach \u2013  would fare very well in VB because it shows exactly what it does
p3823
aVAt the current state, I prefer C# for any functional programming work, which is a pity because I generally favour VB
p3824
aVNow, I really rejoice that VB finally gets multiline lambdas and statement lambdas because they're still useful sometimes (take the case of )
p3825
aVBut the syntax is messed up
p3826
aVThe same goes for iterators, by the way (if they should make it into VB10)
p3827
as(dp3828
g14
V1968
p3829
stp3830
a((dp3831
g2
(lp3832
VBesides the shy hypen as mentioned by nickf, you can always use CSS to hide overshooting words by settings the box's style to
p3833
aVGood news: no scrollbar, ma
p3834
aVBad news: word is cut
p3835
aVFor the shy hypen, I wouldn't go with the entity, though
p3836
aVInstead, use the character directly in your text: its character code is 0xAD (Unicode +00AD)
p3837
aV(Entities are generally deprecated by the use of a correct encoding
p3838
as(dp3839
g14
V1968
p3840
stp3841
a((dp3842
g2
(lp3843
VThe solution shown by Leon is canonical
p3844
aVBit of background knowledge: This is called a \u201c(template) metafunction\u201d because it is basically a \u201cfunction\u201d that gets evaluated at compile time
p3845
aVInstead of values, it deals with types: There's a list of input types (the type arguments) and there's a \u201creturn value\u201d: The typedef that declares the type name \u201ctype\u201d
p3846
aV\u201cInvocation\u201d works analogously to normal function invocation, albeit with a different syntax:
p3847
aVThis code construct is an often-used idiom in libraries such as the Boost libraries and even in the STL at one place:  accomplishes the same thing with the only difference that the typedef  is called
p3848
as(dp3849
g14
V1968
p3850
stp3851
a((dp3852
g2
(lp3853
VDoes the STL priority queue allow duplicate keys
p3854
aVYes
p3855
aVIf it does what should I consider
p3856
aVThat the order between equal elements may change arbitrarily
p3857
aVand which predicate should I use
p3858
aVThat do you mean
p3859
aVThat depends entirely on your semantics
p3860
as(dp3861
g14
V1968
p3862
stp3863
a((dp3864
g2
(lp3865
VWell, how do you determine which type is required
p3866
aVAs Joel said, this is probably a case for generics
p3867
aVThe thing is: since you don't know the type at compile time, you can't treat the value returned anyway so casting doesn't really make sense here
p3868
as(dp3869
g14
V1968
p3870
stp3871
a((dp3872
g2
(lp3873
VJust omit the braces:
p3874
as(dp3875
g14
V1968
p3876
stp3877
a((dp3878
g2
(lp3879
VWhat advantage does a singleton give you
p3880
aVAre you aware of the potential problems of this pattern (e
p3881
ag118
aVmultithreading issues with all obvious implementations)
p3882
aVIn practice, if there's no compelling reason to use it, you might want to avoid using the Singleton
p3883
aVFor the UI, there isn't actually a compelling reason even if it doesn't get instantiated multiple times
p3884
as(dp3885
g14
V1968
p3886
stp3887
a((dp3888
g2
(lp3889
VSorry, I'll try again
p3890
aVYou can use the following aggregation:
p3891
as(dp3892
g14
V1968
p3893
stp3894
a((dp3895
g2
(lp3896
VI had that exact problem today and was knee-deep in  mud and debugging for a straight hour before occurred to me that I simply wrote over array boundaries (where I didn't expect it the least) of a C array
p3897
aVSo, if possible, use s instead because any decend STL implementation will give good compiler messages if you try that in debug mode (whereas C arrays punish you with segfaults)
p3898
as(dp3899
g14
V1968
p3900
stp3901
a((dp3902
g2
(lp3903
VProvide an appropriate element comparer
p3904
aVWhat C# version do you use
p3905
aV3 lets you do this:
p3906
as(dp3907
g14
V1968
p3908
stp3909
a((dp3910
g2
(lp3911
VBesides the semantics mentioned by James (statement of intent), properties play a special role since their value is displayed by the debugger and may be used in visual designers
p3912
aVAs a consequence, make sure that properties' values don't change without some outside action because otherwise, the debugger will screw up your program
p3913
as(dp3914
g14
V1968
p3915
stp3916
a((dp3917
g2
(lp3918
VIf possible, can you limit your suggestions to using either html or javascript
p3919
aVNo
p3920
aVBecause there is no secure way using only these two techniques
p3921
aVEverything that goes on on the client side may be manipulated (trivially easy)
p3922
aVIf you want to be sure, you have to enforce this on the server side by checking for the  (sic
p3923
aVheader
p3924
aVMind, even this can be manipulated
p3925
aVIf you're using Apache with  enabled, the following code will restrict access according to the referring page:
p3926
aVEDIT: I just checked the manual \u2026 unfortunately, giving a 401 status code isn't possible here
p3927
aVSo the above solution isn't perfect because although it blocks access, it doesn't set the HTTP status accordingly
p3928
aV:-/ Leaves a bad taste in my mouth
p3929
as(dp3930
g14
V1968
p3931
stp3932
a((dp3933
g2
(lp3934
V@Atario, not only the accepted answer is wrong, your own edit is as well
p3935
aVImagine the following situation (that actually occurred in one CTP of Visual Studio 2005):
p3936
aVFor drawing graphics, you create pens without disposing them
p3937
aVPens don't require a lot of memory but they use a GDI+ handle internally
p3938
aVIf you don't dispose the pen, the GDI+ handle will not be released
p3939
aVIf your application isn't memory intensive, quite some time can pass without the GC being called
p3940
aVHowever, the number of available GDI+ handles is restricted and soon enough, when you try to create a new pen, the operation will fail
p3941
aVIn fact, in Visual Studio 2005 CTP, if you used the application long enough, all fonts would suddenly switch to \u201cSystem\u201d
p3942
aVThis is precisely why it's not enough to rely on the GC for disposing
p3943
aVThe memory usage doesn't necessarily corelate with the number of unmanaged resources that you acquire (and don't release)
p3944
aVTherefore, these resoures may be exhausted long before the GC is called
p3945
aVAdditionally, there's of course the whole aspects of side-effects that these resources may have (such as access locks) that prevent other applications from working properly
p3946
as(dp3947
g14
V1968
p3948
stp3949
a((dp3950
g2
(lp3951
VThe reason for your confusion is probably that the Visitor is a fatal misnomer
p3952
aVMany (prominent1
p3953
aVprogrammers have stumbled over this problem
p3954
aVWhat it actually does is implement double dispatching in languages that don't support it natively (most of them don't)
p3955
aV1) My favourite example is Scott Meyers, acclaimed author of \u201cEffective C++\u201d, who called this one of his most important C++ aha
p3956
aVmoments ever
p3957
as(dp3958
g14
V1968
p3959
stp3960
a((dp3961
g2
(lp3962
VSome great answers already
p3963
aVFor a slightly different perspective, consider searching a text in a larger string
p3964
aVSomeone has already mentioned regular expressions and this is really just a special case, albeit an important one
p3965
aVConsider the following method call:
p3966
aVHow would you implement
p3967
aVThe easy approach would use a nested loop, something like this:
p3968
aVApart from the fact that this is inefficient, it forms a state machine
p3969
aVThe states here are somewhat hidden; let me rewrite the code slightly to make them more visible:
p3970
aVThe different states here directly represent all different positions in the word we search for
p3971
aVThere are two transitions for each node in the graph: if the letters match, go to the next state; for every other input (i
p3972
ag9
aVevery other letter at the current position), go back to zero
p3973
aVThis slight reformulation has a huge advantage: it can now be tweaked to yield better performance using some basic techniques
p3974
aVIn fact, every advanced string searching algorithm (discounting index data structures for the moment) builds on top of this state machine and improves some aspects of it
p3975
as(dp3976
g14
V1968
p3977
stp3978
a((dp3979
g2
(lp3980
VMotti has a good solution
p3981
aVHowever, I'm pretty sure that for your < 15 elements a map isn't the right way because its overhead will always be greater than that of a simple lookup table with an appropriate hashing scheme
p3982
aVIn your case, it might even be enough to hash by length alone, and if that still produces collisions, use a linear search through all entries of the same length
p3983
aVTo establish if I'm right, a benchmark is of course required but I'm quite sure of its outcome
p3984
as(dp3985
g14
V1968
p3986
stp3987
a((dp3988
g2
(lp3989
VUse the Boost Installer by the Boost consulting group
p3990
as(dp3991
g14
V1968
p3992
stp3993
a((dp3994
g2
(lp3995
VBy the way, your use of the  element is wrong: you are missing the  element
p3996
aVItems in the definition list always consist of one definition term and one or more definitions (which, in your code, are missing)
p3997
aVAlso, rather than using  as suggested by Steve, I'd suggest explicitly stating the height of your  elements
p3998
aVThis way, the floats don't have to be cleared
p3999
as(dp4000
g14
V1968
p4001
stp4002
a((dp4003
g2
(lp4004
VNo, it can't
p4005
as(dp4006
g14
V1968
p4007
stp4008
a((dp4009
g2
(lp4010
V is called function-style cast by the standard and is the same as the C-style cast in every regard (for POD) [5
p4011
ag1938
aV3]:
p4012
aVIf the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5
p4013
aV4)
p4014
as(dp4015
g14
V1968
p4016
stp4017
a((dp4018
g2
(lp4019
VIt is not costly in C#
p4020
aVFor one thing, there is no \u201ccalculation\u201c: querying the length is basically an elementary operation thanks to inlining
p4021
aVAnd secondly, because (according to its developers), the compiler recognizes this pattern of access and will in fact optimize any (redundant) boundary checks for access on array elements
p4022
aVAnd by the way, I believe that something similar is true for modern JavaScript virtual machines, and if it isn't already, it will be very soon since this is a trivial optimization
p4023
as(dp4024
g14
V1968
p4025
stp4026
a((dp4027
g2
(lp4028
V\u201cconvertible to bool\u201d simply means anything which can meaningfully be used in a boolean context (e
p4029
ag118
aVin an  condition)
p4030
aVThis makes sense in implicit conversions
p4031
aVImagine an object which you want to use in a boolean context, e
p4032
ag118
ag1822
aVHere,  is convertible to boolean
p4033
aVWell, actually, it isn't
p4034
aVRather, it is convertible to something that, in turn, is convertible to
p4035
aVThis is to prevent such statements:
p4036
aVThe reasoning is that such a statement is most probably not intended and the compiler should therefore prevent it
p4037
aVBy returning a \u201cconvertible to bool\u201d rather than a , this is achieved because two user-defined implicit conversions can't be chained in one expression
p4038
aVIn this context, you might want to look up the safe bool idiom
p4039
aVChris has already alluded to one possible implementation, using  as a return type
p4040
aVUsually, the  pointer is then used to represent
p4041
aVThis is what gets used by the STL
p4042
aVHowever, this is unfortunately still flawed
p4043
aVSeveral alternatives have been proposed (neatly wrapped up in the article I've linked above) and as far as I know, have also been included into C++0x for consideration
p4044
aVI'm not aware of the current status of these proposals, though
p4045
as(dp4046
g14
V1968
p4047
stp4048
a((dp4049
g2
(lp4050
VOf course, this will fail for the first user who posts a close-up of someone's face (or hand, or foot, or whatnot)
p4051
aVUltimately, all these forms of automated censorship will fail until there's a real paradigm-shift in the way computers do object recognition
p4052
aVI'm not saying that you shouldn't attempt it nontheless; but I want to point to these problems
p4053
aVDo not expect a perfect (or even good) solution
p4054
aVIt doesn't exist
p4055
as(dp4056
g14
V1968
p4057
stp4058
a((dp4059
g2
(lp4060
VAfter my initial discomfort about the fact that I had to create a new  on each modification, I've wholly embraced the concept some years ago
p4061
aVIn fact, I now create every field as  by default and only change it to be mutable if there's a compelling reason \u2013 which there is surprisingly rarely
p4062
aVI don't care very much about cross-threading issues, though (I rarely use code where this is relevant)
p4063
aVI just find it much, much better because of the semantic expressiveness
p4064
aVImmutability is the very epitome of an interface which is hard to use incorrectly
p4065
as(dp4066
g14
V1968
p4067
stp4068
a((dp4069
g2
(lp4070
VIt depends on the level of abstraction that you expect
p4071
aVThe base class method is quite nice
p4072
aVOnly when benchmarks reveal that too much performance is lost this way, I would try to drill deeper, perhaps using a custom-tailored structure with explicit memory layout that acts similar to a C
p4073
aVHow does your code affect usability in a negative way
p4074
as(dp4075
g14
V1968
p4076
stp4077
a((dp4078
g2
(lp4079
VBut there's got to be some way in the IDE to do it
p4080
aVright
p4081
aVNo
p4082
aVThere are some plugins for the IDE, such as the MZ Tools that might help
p4083
aVOtherwise, just use the  tool from the Windows command line
p4084
aVNot nearly as comfortable as using , of course
p4085
as(dp4086
g14
V1968
p4087
stp4088
a((dp4089
g2
(lp4090
VDo the buttons share a common container
p4091
aVThen the following code works:
p4092
aVAlternatively, you can also do this:
p4093
as(dp4094
g14
V1968
p4095
stp4096
a((dp4097
g2
(lp4098
VJohn Resig (jQuery) has a say in that matter
p4099
aVAdditionally, a DocType helps make MSIE6 use the right box model, and it also eases the pain of validating your site (this is a good thing for development; think of it as debugging)
p4100
as(dp4101
g14
V1968
p4102
stp4103
a((dp4104
g2
(lp4105
VLinked lists and BSTs don't really have much in common, except that they're both data structures that act as containers
p4106
aVLinked lists basically allow you to insert and remove elements efficiently at any location in the list, while maintaining the ordering of the list
p4107
aVThis list is implemented using pointers from one element to the next (and often the previous)
p4108
aVA binary search tree on the other hand is a data structure of a higher abstraction (i
p4109
ag9
aVit's not specified how this is implemented internally) that allows for efficient searches (i
p4110
ag9
aVin order to find a specific element you don't have to look at all the elements
p4111
aVNotice that a linked list can be thought of as a degenerated binary tree, i
p4112
ag9
aVa tree where all nodes only have one child
p4113
as(dp4114
g14
V1968
p4115
stp4116
a((dp4117
g2
(lp4118
VOK, so fiveseven people proposed  as the solution
p4119
aVI propose two other solutions that might be more appropriate, depending on the situation;
p4120
aVCreate an overload of the method that only has two arguments, and omit the  when calling:
p4121
aVAlthough you probably don't want to do this since you stated that you wanted to avoid code duplication
p4122
aVUse  instead of :
p4123
aVIncidentally, this is the same as passing the value
p4124
as(dp4125
g14
V1968
p4126
stp4127
a((dp4128
g2
(lp4129
VHow small is the overhead of using bignums in places where a fixnum or integer would had sufficed
p4130
aVShow small can it be at best implementations
p4131
aVThe bad news is that even in the best possible software implementation, BigNum is going to be slower than the builtin arithmetics by orders of magnitude (i
p4132
ag9
aVeverything from factor 10 up to factor 1000)
p4133
aVI don't have exact numbers but I don't think exact numbers will help very much in such a situation: If you need big numbers, use them
p4134
aVIf not, don't
p4135
aVIf your language uses them by default (which language does
p4136
aVsome dynamic languages do \u2026), think whether the disadvantage of switching to another language is compensated for by the gain in performance (which it should rarely be)
p4137
aV(Which could roughly be translated to: there's a huge difference but it shouldn't matter
p4138
aVIf (and only if) it matters, use another language because even with the best possible implementation, this language evidently isn't well-suited for the task
p4139
as(dp4140
g14
V1968
p4141
stp4142
a((dp4143
g2
(lp4144
VThis is most probably an NP-hard problem
p4145
aVIt looks similar to multiple sequence alignment, which is
p4146
aVBasically, you could adapt multidimensional Smith-Waterman (= local sequence alignment) for your needs
p4147
aVThere might be a more efficient algorithm, though
p4148
as(dp4149
g14
V1968
p4150
stp4151
a((dp4152
g2
(lp4153
VOne conventional way to handle this is to sort in multiple passes and use a stable sort
p4154
aVNotice that  is generally not stable
p4155
aVHowever, there\u2019s
p4156
aVThat said, I would write a wrapper around functors that return a tristate (representing less, equals, greater)
p4157
as(dp4158
g14
V1968
p4159
stp4160
a((dp4161
g2
(lp4162
VMultidimensional arrays are not arrays for the purpose of the inheritance hierarchy
p4163
aVThey're a completely separate type
p4164
aVAdditionally, this type has no good support from the framework for two possible reasons:
p4165
aVIt's not really that useful
p4166
aVThe only real use for multidimensional arrays is matrices
p4167
aVFor almost anything else, other data structures (e
p4168
ag118
aVjagged arrays) are better suited
p4169
aVIt's not trivial to devise generic, useful methods for these structures
p4170
aVIn the case of , how should this have been implemented, i
p4171
ag9
aVin which order should the elements be enumerated
p4172
aVThere's no order inherent in multidimensional arrays
p4173
as(dp4174
g14
V1968
p4175
stp4176
a((dp4177
g2
(lp4178
VThe comma simply separates two expressions and is valid anywhere in C where a normal expression is allowed
p4179
aVThese are executed in order from left to right
p4180
aVThe value of the rightmost expression is the value of the overall expression
p4181
aVloops consist of three parts, any of which may also be empty; one (the first) is executed at the beginning, and one (the third) at the end of each iteration
p4182
aVThese parts usually initialize and increment a counter, respectively; but they may do anything
p4183
aVThe second part is a test that is executed at the beginning of each execution
p4184
aVIf the test yields , the loop is aborted
p4185
aVThat's all there is to it
p4186
as(dp4187
g14
V1968
p4188
stp4189
a((dp4190
g2
(lp4191
VIs
p4192
aVnecessary, or should you just use the ternary operator (that most are familiar with)
p4193
aVYou should use what best expresses your intent
p4194
aVSince there is a null coalesce operator, use it
p4195
aVOn the other hand, since it's so specialized, I don't think it has other uses
p4196
aVI would have preferred an appropriate overload of the  operator, as other languages do
p4197
aVThis would be more parsimonious in the language design
p4198
aVBut well \u2026
p4199
as(dp4200
g14
V1968
p4201
stp4202
a((dp4203
g2
(lp4204
Vs can actually be carriers for semantic information in form of  attributes
p4205
aVThis is used by microformats
p4206
as(dp4207
g14
V1968
p4208
stp4209
a((dp4210
g2
(lp4211
V is exactly like  (in the context of
p4212
aVSee RoadWarrior's remark for its semantics as one's complement in bit arithmetic)
p4213
aVThere's a special case in combination with the  operator to test for reference equality:
p4214
aVis equivalent to C#'s
p4215
aVHere, usage of  is preferred
p4216
aVUnfortunately, it doesn't work for  tests
p4217
as(dp4218
g14
V1968
p4219
stp4220
a((dp4221
g2
(lp4222
VIt's been a long time since I've worked with VB6 but as far as I remember, you can just serialize the image into a  and get the contents as a byte array
p4223
aVThe only alternative I know requires heavy use of WinAPI to accomplish the same
p4224
as(dp4225
g14
V1968
p4226
stp4227
a((dp4228
g2
(lp4229
VBecause of the well known "100% div height"-issue \u2026
p4230
aVand which one would that be
p4231
aVThe one solved here
p4232
aVBasically, the important part is
p4233
aVTables as a workaround are a no-go here because as far as I know, they have similar problems concerning the height
p4234
as(dp4235
g14
V1968
p4236
stp4237
a((dp4238
g2
(lp4239
VI'd actually say that the code is pretty OK in most applications although it's theoretically inferior to other methods
p4240
aVIf you don't want to use the , try it like this:
p4241
as(dp4242
g14
V1968
p4243
stp4244
a((dp4245
g2
(lp4246
s(dp4247
g14
V1968
p4248
stp4249
a((dp4250
g2
(lp4251
VAlso, on a related topic, I've heard it said that you should never use the + operator with strings, in favour of string
p4252
aVFormat(), is this true
p4253
aVNo, like all absolute statements it's nonsense
p4254
aVHowever, it is true that using  usually makes formatting code more readable and it's often slightly faster than concatenation \u2013 but speed isn't the deciding factor here
p4255
aVAs for your code \u2026 it results in smaller strings being copied (namely, ) in the concatenation
p4256
aVOf course, in  you copy a larger string but this happens less often
p4257
aVTherefore, you've reduced many large copies to a few large and many small copies
p4258
aVHmm, I've just noticed that your outer loop has the same size in both cases
p4259
aVThis shouldn't be faster, then
p4260
as(dp4261
g14
V1968
p4262
stp4263
a((dp4264
g2
(lp4265
VProfiling basically shows you how often a given line of code is executed and how much time was spent in it (compared to other lines)
p4266
aVThis makes it easy to pinpoint the location where your code spends most of the time
p4267
aVIt also makes it possible to find places where your code spends much time without doing anything: this is the typical sign of a cache miss and this is where you should get active
p4268
aVUsually, programs spend very much time (say, 90%) in one place
p4269
aVUnfortunately, finding this place without profiling isn't possible
p4270
aVGuesswork often goes awry
p4271
aVSo if you optimize in the wrong place, this won't help at all: if the overall time spent in that line is only 10%, your code will only get 10% faster (at best
p4272
aVIf, however, you succeed in removing the call that takes 90% of the time, your programm will get ten times faster
p4273
aVThis, in a nutshell, is profiling
p4274
aVEclipse offers builtin profiling capabilies and I've been told that they're pretty good but since I don't know them, let someone else answer that
p4275
as(dp4276
g14
V1968
p4277
stp4278
a((dp4279
g2
(lp4280
VYes, it is
p4281
aValways creates a new string \u2013  doesn't
p4282
as(dp4283
g14
V1968
p4284
stp4285
a((dp4286
g2
(lp4287
VIn this example it pulls the object, but does not convert it to an integer
p4288
aVBrian, I don't see why your desired effect cannot be achieved using a
p4289
aVThe code you showed us can be made to work
p4290
aVHowever, beware of implicit conversions
p4291
aVThey're generally not a good idea
p4292
as(dp4293
g14
V1968
p4294
stp4295
a((dp4296
g2
(lp4297
VOS X and Windows handle at least  font sizes differently so this is certainly a complete no-go
p4298
aVOn the other hand, is there any good reason not to use relative font sizes
p4299
aVIt's not really as if this were a weighted debate with good arguments on both sides
p4300
aVRather, on one side are several advantages (that might not be apparent all the time)
p4301
aVBut on the other hand there are only apparent advantages that, upon the slightest probing, prove worthless
p4302
ag756
aVActually, I can only think of one argument for absolute font sizes, namely that it makes it easier to implement the CSS for a finished design, by copying the font sizes used in the design software
p4303
aVIn reality, a consistent design will only use a handful of different font sizes that are simple ratios of each other (say, 80%) and can thus trivially be expressed in terms of  or
p4304
aV1) You said:
p4305
aVor whether you want to be able to change a font size somewhere without affecting nested elements
p4306
aVWhat exactly do you mean by that
p4307
aVThe whole point of CSS is that you (generally) change an element\u2019s attributes relative to its parents\u2019
p4308
aVWhy should this ever be a problem
p4309
aVThe whole debate is slightly reminiscent of the \u201cdon\u2019t use layout tables\u201d debates
p4310
aVThe arguments might seem dogmatic to nonprofessionals2 but there\u2019s simply no reason not to follow them anyway
p4311
aVThis isn\u2019t to say that it\u2019s wrong to ask for arguments
p4312
aVBut there are soo many pointless violations of this rule
p4313
aV2) For the record, I\u2019m not a web design professional
p4314
aVTake my technical opinions here with just a grain of salt
p4315
aVBut the argument is really independent of the technology used
p4316
as(dp4317
g14
V1968
p4318
stp4319
a((dp4320
g2
(lp4321
VThat depends on other constraints
p4322
aVYou haven't told us enough about your model
p4323
aVFor example, if different types of customers have different types of information associated with them, a class hierarchy will be better suited that an a mere enum
p4324
aVIn other cases, an enum will be fine or might even be preferred (simpler, reduced overhead \u2026)
p4325
as(dp4326
g14
V1968
p4327
stp4328
a((dp4329
g2
(lp4330
VYou can only invoke the event from within the class where you declared it
p4331
aVIn any other place, you can only add or remove handlers from the event delegate via the operators  and , hence the error message
p4332
as(dp4333
g14
V1968
p4334
stp4335
a((dp4336
g2
(lp4337
VIn VB
p4338
aVNET, they're identical
p4339
aVThe  variant is canonical
p4340
aVIn VB6, their semantics actually differed (apart form the obvious fact that VB6 didn't allow assignments in declarations): the  variant would create an object that could never be
p4341
aVRather, the runtime would ensure that the object was always properly initialized before each access to it
p4342
as(dp4343
g14
V1968
p4344
stp4345
a((dp4346
g2
(lp4347
VYou can iterate over the bytes of the file and use  from  to test whether the character is printable
p4348
aVIf there are nonprintable characters in the file, chances are it's a binary file
p4349
aVNotice that this only works for legacy encodings (e
p4350
ag118
aVASCII mentioned by you), not for Unicode-encoded files
p4351
as(dp4352
g14
V1968
p4353
stp4354
a((dp4355
g2
(lp4356
VTo do this you need to write a setter property
p4357
aVUnfortunately, setters can\u2019t take further arguments in C# so you won't be able to write this code 1:1 in C#
p4358
aVThe closest you can get is a nested class with a default property:
p4359
aVYou can use it like this:
p4360
aVBy the way, since this is so much effort, you probably don't want to do this
p4361
aVAlso, it doesn't feel very C#-y
p4362
aVThe useless indiretion through the nested class here isn't something you'll see very often
p4363
as(dp4364
g14
V1968
p4365
stp4366
a((dp4367
g2
(lp4368
VIn other words, you want to optimize the overall running time while formulating two constraints (strong: earliest point of execution, weak: priority)
p4369
aVThis is called a constraint satisfaction problem
p4370
aVThere are special solvers for this kind of problem
p4371
aVIncidentally, jakber's solution doesn't work
p4372
aVEven without the duration, the following example obviously fails:
p4373
aVThe sorted sequence would be ,  while the wanted outcome is surely ,
p4374
as(dp4375
g14
V1968
p4376
stp4377
a((dp4378
g2
(lp4379
VThere are already two projects who attempt something similar:
p4380
aV, and
p4381
aVCUDPP
p4382
aVIn the meantime, however, I've implemented my allocator and it works really well and was completely straigtforward (> 95% boilerplate code)
p4383
as(dp4384
g14
V1968
p4385
stp4386
a((dp4387
g2
(lp4388
VThis is very confusing code
p4389
aVYou could just write
p4390
aVbut you won't (will you
p4391
aVbecause you've got conventional  for that
p4392
as(dp4393
g14
V1968
p4394
stp4395
a((dp4396
g2
(lp4397
VYou don't have to learn the language to use the visual forms designer from Visual Studio to create mockups
p4398
aVFurthermore, the Express Edition of Visual Studio is freely available in several languages, namely VB, C# and C++
p4399
aVTake your pick
p4400
aVAll ship with the same forms designer that generates backend code in one of the languages
p4401
aVBut if you only need the designer, the code might not be relevant for you
p4402
as(dp4403
g14
V1968
p4404
stp4405
a((dp4406
g2
(lp4407
VBuilding a highlighter for only one language (context free, with regular lexemes such as C++) is actually pretty easy because you basically can wrap all your lexemes into one big regular expression:
p4408
as(dp4409
g14
V1968
p4410
stp4411
a((dp4412
g2
(lp4413
VLook at it the other way
p4414
aVWhat advantage would using a custom interface have over using the standard way that is supported by the language in both syntax and library
p4415
aVGranted, there are cases where it a custom-tailored solution might have advantages, and in such cases you should use it
p4416
aVIn all other cases, use the most canonical solution available
p4417
aVIt's less work, more intuitive (because it's what users expect), has more support from tools (including the IDE) and chances are, the compiler treats them differently, resulting in more efficient code
p4418
aVDon't reinvent the wheel (unless the current version is broken)
p4419
as(dp4420
g14
V1968
p4421
stp4422
a((dp4423
g2
(lp4424
VYou can (and should) create subfolders in the file system to organize your files
p4425
aVHowever, this hierarchy will not be mirrored by the VB6 project explorer, which basically provides a flat hierarchy
p4426
as(dp4427
g14
V1968
p4428
stp4429
a((dp4430
g2
(lp4431
VWhat do you mean by \u201ccfront tool\u201d
p4432
aVCfront was the first C++ compiler
p4433
aVBut since failure to add exception support, it has been discontinued
p4434
aVModern C++ is way beyond the scope of Cfront
p4435
aVFor any other modern languages
p4436
aVAnd what do you mean by that
p4437
aVIf you mean whether other compilers exist that compile a high-level language into C code then the answer is yes, there are plenty
p4438
aVThe Glasgow Haskell Compiler is just one out of many
p4439
as(dp4440
g14
V1968
p4441
stp4442
a((dp4443
g2
(lp4444
VIs tilde a legitimate character in an XML SOAP message
p4445
aVYes
p4446
aVThe error message points to another error source (\u201cprolog\u201d)
p4447
aVIs the HTTP header perhaps part of the code sent to the SAX parser, as in your code sample
p4448
as(dp4449
g14
V1968
p4450
stp4451
a((dp4452
g2
(lp4453
VA randomized data structure might be perfect for your job
p4454
aVTake a look at the skip list \u2013 though I don't know any decend C++ implementation of it
p4455
aVI intended to submit one to Boost but never got around to do it
p4456
as(dp4457
g14
V1968
p4458
stp4459
a((dp4460
g2
(lp4461
VI would do it as follows \u2026 but this solution might actually be very slow so you might want to run a benchmark before deploying it in performance-critical sections
p4462
as(dp4463
g14
V1968
p4464
stp4465
a((dp4466
g2
(lp4467
VBy the way, this sounds like a design flaw
p4468
aVOnce an object is constructed there should never be a need to re-construct it
p4469
aVSuch variable name reuse makes the code rather harder to understand
p4470
aVFor that reason, making constructor-like functionality available through an extra function  or  is often wrong (but sometimes unavoidable)
p4471
aVAs Michael said, placement new could be used here but is really intended for different uses
p4472
aVAlso, before constructing a new object in a memory location, you have to explicitly destroy the old object:
p4473
aVAlso,  can have an averse effect on your memory because overloads might expect that the memory it is passed belongs to the heap
p4474
aVIn conclusion: don\u2019t
p4475
aVdo
p4476
aVthis
p4477
aVEDIT To demonstrate that calling the destructor is really necessary (for non-POD), consider the following example code:
p4478
aVAs expected, the program results in the following output:
p4479
aV\u2026 which means that the destructor for the first object is not called
p4480
aVThe same goes for any resources that  might have acquired
p4481
as(dp4482
g14
V1968
p4483
stp4484
a((dp4485
g2
(lp4486
VAre the formulas represented in an AST then recalculated using a design pattern like the Visitor pattern
p4487
aVYou're thinking interpreter, not visitor
p4488
aVWhile treewalking using a visitor can be employed in conjunction with interpretation, employing an interpreter makes more sense here (hence the name)
p4489
aVWhat this does is basically what friol wrote, i
p4490
ag9
aVtraverse the tree in post-order and execute the function associated with each node
p4491
as(dp4492
g14
V1968
p4493
stp4494
a((dp4495
g2
(lp4496
VI group my utilities by functionality
p4497
aVAs a result, I don't have one utility DLL but rather a folder that contains several such assemblies, each one encapsulating one task (which usually includes more than just one class, in fact it usually includes a whole hierarchy)
p4498
aVIn the extreme case, this means that I have a DLL containing one declaration, namely the following one (plus documentation):
p4499
aVNotice that unlike the  interface, this one has well-defined semantics (deep copy) specified in the documentation
p4500
aVSo why an extra DLL for this tiny declaration
p4501
aVBecause it makes interoperability between other assemblies much easier
p4502
as(dp4503
g14
V1968
p4504
stp4505
a((dp4506
g2
(lp4507
VI won't comment on the general case but in your case, I think that's dangerous
p4508
aVA good metric for interface quality is how easy it is to use the interface correctly and how hard it is to use it wrongly
p4509
aVApplying that metric, your design scores quite low because it's incredibly easy to use it wrongly: just iterate over it twice
p4510
aVI'd actually go further than Jon and say: don't even offer the option
p4511
aVIt might be helpful but the price of potentially using this wrong might be too high
p4512
aVOn the other hand, it could be argued that if the user intentionally makes a choice, (s)he has to deal with the consequences
p4513
as(dp4514
g14
V1968
p4515
stp4516
a((dp4517
g2
(lp4518
VFirst of all, your description is misleading
p4519
aVis a floating point data type
p4520
aVYou presumably want to pad your digits with leading zeros in a string
p4521
aVThe following code does that:
p4522
aVFor more information, refer to the documentation of
p4523
as(dp4524
g14
V1968
p4525
stp4526
a((dp4527
g2
(lp4528
VUntested, but can't you just do this
p4529
as(dp4530
g14
V1968
p4531
stp4532
a((dp4533
g2
(lp4534
VBasically, just put  in front of your expression
p4535
aVAlso, the parentheses are unnecessary here:
p4536
as(dp4537
g14
V1968
p4538
stp4539
a((dp4540
g2
(lp4541
VWell, can't you apply pattern matching to the individual cases
p4542
aVEDIT: Yes, of course \u2026 recursion added
p4543
as(dp4544
g14
V1968
p4545
stp4546
a((dp4547
g2
(lp4548
VThis is just syntactical sugar
p4549
aVThe compiler will infer the type actually necessary here and create code that is equivalent to the explicit construct:
p4550
aVThere's no such thing as  that gets executed at runtime
p4551
as(dp4552
g14
V1968
p4553
stp4554
a((dp4555
g2
(lp4556
VIn an object-oriented approach, think about the objects involved in your game (e
p4557
ag118
aVthe board, the pieces) \u2026 let them each provide a drawing method that takes a  object and draws itself on it
p4558
aVThe drawing itself could be done on a  \u2013 this is the ideal control for such purpose \u2013 but this isn't really all that important because once your drawing logic is in place, it won't depend on the kind of control
p4559
aVIn general, don't use workarounds with different controls
p4560
aVThese might be nice for a conventional GUI
p4561
aVNot so much for games (or any kind of graphics-heavy application)
p4562
as(dp4563
g14
V1968
p4564
stp4565
a((dp4566
g2
(lp4567
VBy definition algorithms are independent from the medium they run on
p4568
aVWhat definition is that
p4569
aVWho made it
p4570
aVAnd did they know about leaky abstraction
p4571
aVGood algorithms must often know about the platform they're using
p4572
aVIf that weren't true, programs would be automatically parallelizable for the GPU, and could be effortlessly rewritten to work on quantum computers
p4573
aVThat said, many fundamental algorithms are indeed platform-agnostic
p4574
aVOddly, I actually feel most comfortable using C++ to fiddle around with algorithms
p4575
aVHowever, when doing this I heavily rely on a high level of abstractions so I don't play around with pointers or the likes
p4576
aVOn the other hand, the STL actually offers a quite rich toolkit to play around with algorithms
p4577
aVAnd, same as Bill, I use my whiteboard quite a lot
p4578
aVI actually have a 1m * 2m whiteboard in my living room
p4579
aVCreepy
p4580
aV;-)
p4581
as(dp4582
g14
V1968
p4583
stp4584
a((dp4585
g2
(lp4586
VAny others that should be done immediately
p4587
aVGenerally, change any mention of  to , where possible
p4588
aVMigration can be greatly helped by switching the whole namespace, i
p4589
ag9
aVun-ing  in every file and instead importing
p4590
aVAlso, search for mentions of  and/or usage of boxing in your code and consider whether this is still appropriate or should be replaced by generics
p4591
aVAs jalf reminded me in the comments, another important change is the switch to the generic version of  where applicable
p4592
as(dp4593
g14
V1968
p4594
stp4595
a((dp4596
g2
(lp4597
VWhat's the reason behind  \u2026
p4598
aVDid you overlook
p4599
as(dp4600
g14
V1968
p4601
stp4602
a((dp4603
g2
(lp4604
VIf you never work with performance-critical code, consider yourself lucky
p4605
aVHowever, I consider this scenario unrealistic
p4606
aVPerformance problems could occur anywhere
p4607
aVAnd then it's necessary to know how to fix that problem
p4608
aVObviously, merely knowing a few algorithm names isn't enough here \u2013 unless you want to implement them all and try them out one after the other
p4609
aVNo, knowing (at least some of) the inner workings of different algorithms is important for gauging their strengths and weaknesses and for analyzing how they would handle your situation
p4610
aVObviously, if there's a library already implementing exactly what you need, you're incredibly lucky
p4611
aVBut let's face it, even if there is such a library, using it is often not completely straightforward (at the very least, interfaces and data representation often have to be adapted) so it's still good to know what to expect
p4612
as(dp4613
g14
V1968
p4614
stp4615
a((dp4616
g2
(lp4617
VNotice that \u201cfilename\u201d is one word in English
p4618
aVThere's no need to capitalize the \u201cn\u201d in the middle of the identifier
p4619
aVThat said, I append  to all my string variables that contain filenames
p4620
aVHowever, I try to avoid this whole scenario in favour of using strongly typed variables in languages that support a type of files and directories
p4621
aVAfter all, this is what extensible type systems are there for
p4622
aVIn strongly typed languages, the need for the descriptive postfix is then often unnecessary (especially in function arguments) because variable type and usage infers its content
p4623
as(dp4624
g14
V1968
p4625
stp4626
a((dp4627
g2
(lp4628
VThe value of using an interface is always the same: you don't have to change client code when switching to another backend implementation
p4629
aVConsider that profiling your code later shows that a hash table implementation (used in the  class) isn't suited for your task and that a binary search tree would perform better
p4630
aVIf you've coded to an interface then switching the implementation is straightforward
p4631
aVIf, however, you've used a concrete class, you've got to change a lot more code in a lot more places
p4632
aV=> This costs time and money
p4633
as(dp4634
g14
V1968
p4635
stp4636
a((dp4637
g2
(lp4638
VI guess the guys that wrote IEnumerable \u2026 had a good feeling after creating [it]
p4639
aVI'm not so sure
p4640
aVwas quite a failure, as interfaces go
p4641
aVThis is evident from the fact that , its generic counterpart, actually offers a completely different interface
p4642
aV(Well, \u201cdifferent\u201d isn't a good word; basically, it adds disposability and de-emphasizes the completely useless  method; however, this method is of course still present
p4643
aVAdditionally, similar languages that have similar constructs (Java comes to mind) have a much better, more extensible construct to fulfill the same needs (and more)
p4644
aVFor example, Java's iterators can be extended to be bidirectional or to allow modifying access (whereas  is always read-only)
p4645
aVEDIT: Since there's so much controversy in the comments, let me clarify
p4646
aVI'm not saying that  (or ) are bad interfaces
p4647
aVThey're adequate
p4648
aVHowever, they could have been made better
p4649
aVIf nothing else, then at least the  method seems like clutter
p4650
aVTerjet said that he \u201cuse[s] it all the time\u201d \u2013 which is precisely my point
p4651
aVis a pivotal interface of the whole
p4652
aVNET framework
p4653
aVIt's ubiquitous
p4654
aVThere'd be no
p4655
aVNET without it
p4656
aVIs it therefore too much to ask for a perfect interface
p4657
aV\u201cAdequate\u201d is just another word for failure
p4658
as(dp4659
g14
V1968
p4660
stp4661
a((dp4662
g2
(lp4663
VYou could use the information provided by  which provides the stack trace in an array
p4664
as(dp4665
g14
V1968
p4666
stp4667
a((dp4668
g2
(lp4669
VThe previous answers are good but let me emphasize the important point here once again
p4670
aVIn particular, you said that
p4671
aVIf I understand correctly the
p4672
aVnet runtime will always clean up after me
p4673
aVThis is only partly correct
p4674
aVIn fact,
p4675
aVNET only offers automatic management for one particular resource: main memory
p4676
aVAll other resources need manual cleanup
p4677
aV1)
p4678
aVOddly, main memory gets special status in almost all discussions about program resources
p4679
aVThere's of course a good reason for this \u2013 main memory is often the scarcest resource
p4680
aVBut it's worth remembering that there are other types of resources as well, that also need managing
p4681
aV1) The usual attempted solution is to couple the lifetime of other resources to the lifetime of memory locations or identifiers in the code \u2013 hence the existence of finalizers
p4682
as(dp4683
g14
V1968
p4684
stp4685
a((dp4686
g2
(lp4687
VDid you add the file as a resource
p4688
aVIn that case you can access its () content by just using
p4689
aVOtherwise, the easiest way to read a text file in VB is to use the following
p4690
as(dp4691
g14
V1968
p4692
stp4693
a((dp4694
g2
(lp4695
VI do it quite similarly
p4696
aVOne point where I differ:
p4697
aVone type per file
p4698
aVI declare delegate types where I need them, i
p4699
ag9
aVnot in their own file but rather in the class that uses them
p4700
as(dp4701
g14
V1968
p4702
stp4703
a((dp4704
g2
(lp4705
VUse UUIDGen
p4706
aVDon't
p4707
aVGUIDs aren't really random
p4708
aVYou can actually generate large amounts of data very fast using the  class in VB
p4709
aVNET
p4710
aV500,000 characters/bytes are no problem:
p4711
aVThis code takes considerably less than one second
p4712
as(dp4713
g14
V1968
p4714
stp4715
a((dp4716
g2
(lp4717
VYou need a pushdown automaton here
p4718
aVRegular expressions aren't powerful enough to capture this concept, since they are equivalent to finite-state automata, so a regex solution is strictly speaking a no-go
p4719
aVThat said,
p4720
aVNET regular expressions do have a pushdown automaton behind them so they can theoretically cope with such cases
p4721
aVIf you really feel you need to do this with regular expressions rather than a formal HTML parser, take a glimpse here
p4722
as(dp4723
g14
V1968
p4724
stp4725
a((dp4726
g2
(lp4727
VDo not use a 2D vector
p4728
aVRather, use a  of s
p4729
aVLikewise for your collision detection
p4730
aVUsing a 2D vector here is just the wrong data structure
p4731
aVDepending on the content of the function, the compiler will be able to perform NRVO (that is, named return value optimization) which means that in the optimal case, returning a vector has no overhead, i
p4732
ag9
aVit's never copied
p4733
aVHowever, this only happens when you use the return value of your function to initialize a new instance, and when the compiler is able to trace the execution paths inside the function and see that for each return path, the same object is returned
p4734
aVConsider the following two:
p4735
aVThe compiler can perform NRVO for calls to , but not for
p4736
as(dp4737
g14
V1968
p4738
stp4739
a((dp4740
g2
(lp4741
VConsider whether the status code is really appropriate
p4742
aVIt's usually superior to create a hierarchy of exception classes
p4743
aVThis way, the caller can better control which exceptions to treat and how and it makes the interface simpler
p4744
aVOf course, sometimes status codes are still appropriate (compilers use them all the time)
p4745
as(dp4746
g14
V1968
p4747
stp4748
a((dp4749
g2
(lp4750
VSeveral things are wrong with the previous comments
p4751
aVJoel's is basically the correct answer, with one small caveat:
p4752
aVWhen you define a form, you get an automatic instance of the form with the same name as the type
p4753
aVYou actually only get the instance when you call it
p4754
aVBefore that, no default instance is created
p4755
aVThus, instance creation is deferred until the time of usage
p4756
aVUsing the name of the form as an instance is actually a shortcut to , which is a compiler-generated list of properties for all forms
p4757
aVThese properties are responsible for the object creation
p4758
aVIt is unfortunate that Microsoft has decided to make these properties implicitly available at global scope (hence the OP's question)
p4759
aVThis feature exists because VB
p4760
aVNET emulates the VB6 method of being able to refer to a default instance of a form through it's name
p4761
aVWell
p4762
aVWhile this feature is inspired by previous versions of VB, it's not a direct descended
p4763
aVVB 7 didn't have it
p4764
aVRather, it was re-introduced with VB 8 (= VB 2005)
p4765
aVA really really stupid "feature"
p4766
aVActually, it's a dead useful feature that plays very well with VB's RAD development philosophy
p4767
aVAs mentioned above, it's unfortunate that such a loose scoping is employed
p4768
aVBut other than that, I'd be very interested in hearing what's so \u201cstupid\u201d about this feature
p4769
as(dp4770
g14
V1968
p4771
stp4772
a((dp4773
g2
(lp4774
VA hash is faster to check than it is to traverse a B-tree
p4775
aVSo if frequent existence checks are made, this method might be useful
p4776
aVOther than that, I don't really understand the situation because hash tables don't preserve ordering or hierarchies
p4777
aVTherefore, storing a directory structure in them doesn't seem feasable if directories need to be traversed individually
p4778
as(dp4779
g14
V1968
p4780
stp4781
a((dp4782
g2
(lp4783
VFor numbers:
p4784
aVSee also: Python: String formatting
p4785
aVEDIT: It's worth noting that as of yesterday December 3rd, 2008, this method of formatting is deprecated in favour of the  string method:
p4786
aVSee PEP 3101 for details
p4787
as(dp4788
g14
V1968
p4789
stp4790
a((dp4791
g2
(lp4792
VKeyValuePair does not itself need to be a handle
p4793
aVDuh
p4794
aVBecause it's a value type, not a reference type (i
p4795
ag9
aVinstead of  in C#)
p4796
as(dp4797
g14
V1968
p4798
stp4799
a((dp4800
g2
(lp4801
VIf you use , I can highly recommend KCacheGrind to visualize performance bottlenecks
p4802
as(dp4803
g14
V1968
p4804
stp4805
a((dp4806
g2
(lp4807
VYou shouldn't put the declarations inside the for loop anyway
p4808
aVIt sucks up additional resources for creating a variable over and over again, when what you should do is just clear the variable with each iteration
p4809
aVNo, it does not
p4810
aVThe exact opposite of your advice should be done
p4811
aVBut even if it were more efficient to reset the variable, it's much clearer to declare the variable in its tightest possible scope
p4812
aVAnd clarity wins over micro-optimization (nearly) any time
p4813
aVFurthermore, one variable, one usage
p4814
aVDon't reuse variables unnecessarily
p4815
aVThat said, variables are not reset nor re-initialized here \u2013 actually, they are not even intialized by C#
p4816
aVTo fix this, just initialize them and be done
p4817
as(dp4818
g14
V1968
p4819
stp4820
a((dp4821
g2
(lp4822
VDivide to get the ratio between the sizes of the two ranges, then subtract the starting value of your inital range, multiply by the ratio and add the starting value of your second range
p4823
aVIn other words,
p4824
aVThis evenly spreads the numbers from the first range in the second range
p4825
as(dp4826
g14
V1968
p4827
stp4828
a((dp4829
g2
(lp4830
VHow does the variable look like that you save the result of that conversion in
p4831
aVI
p4832
ag9
aVwith which type do you declare it
p4833
aVIf you want to have an object variable, make it so
p4834
aVInstead of , use  to create a default instance of the enum:
p4835
as(dp4836
g14
V1968
p4837
stp4838
a((dp4839
g2
(lp4840
VI want to take the opportunity to point to X\u018eTEX which is shipped with the (highly recommendend
p4841
aVTeX Live distribution
p4842
aVAmongst other things, X\u018eTEX directly supports Unicode
p4843
aVIn your case this means that you don\u2019t have to deal with these (sometimes tedious) replacement characters any more: instead of using  you can directly use  in your LATEX code
p4844
aVIMHO, that\u2019s a big and important step
p4845
aVTEX is a great typesetting system but it\u2019s lacking support of modern features such as Unicode has made many tasks arduous
p4846
as(dp4847
g14
V1968
p4848
stp4849
a((dp4850
g2
(lp4851
VThe first part (editing your file) can be done well with the stream editor utility :
p4852
aVThis edits the file in-place () with no backup, using expression  () to replace one expression with another
p4853
as(dp4854
g14
V1968
p4855
stp4856
a((dp4857
g2
(lp4858
VIs there a compelling reason to not use debug_backtrace for the sole purpose of determining the calling method's class, name, and parameter list
p4859
aVYes
p4860
aVThe point is, it's generally a sign of bad design if your code requires such a tight coupling that the callee has to have these information about its caller
p4861
aVTherefore, if you feel the need to use these information, you probably should rethink your design
p4862
aVPut bluntly, the callee should not need to have these information to perform its task
p4863
aVThe exceptions, of course, revolve around debugging, logging and more generally other kinds of code introspection (but even there, beware of it)
p4864
as(dp4865
g14
V1968
p4866
stp4867
a((dp4868
g2
(lp4869
VDue to operator precedence, you need to put parentheses around this:
p4870
as(dp4871
g14
V1968
p4872
stp4873
a((dp4874
g2
(lp4875
VWhat's wrong with this solution
p4876
aVThere's nothing \u201cold fashioned\u201d about this solution
p4877
aVHowever, dynamic memories might sometimes be better suited:
p4878
aVIn both cases, you need to initialize each queue before using it
p4879
aVIn the case of an array, the array has to be initialized as well:
p4880
as(dp4881
g14
V1968
p4882
stp4883
a((dp4884
g2
(lp4885
VCan you create weak references in
p4886
aVNET
p4887
aVYes:
p4888
aVUses
p4889
as(dp4890
g14
V1968
p4891
stp4892
a((dp4893
g2
(lp4894
VYes, there's an excellent paper by Lutz Prechelt on this subject:
p4895
aVAn Empirical Comparison of Seven Programming Languages
p4896
aVOf course, this paper doesn\u2019t \u201cprove\u201d the superiority of any particular language
p4897
aVBut it probably comes as close as any scientific study can come to the truth
p4898
aVOn the other hand, the data of this study is very dated, and in the fast-developing world of software engineering this actually plays an important role since both the languages and the tools have vastly improved over time
p4899
as(dp4900
g14
V1968
p4901
stp4902
a((dp4903
g2
(lp4904
VQuestion 1:
p4905
aVNotice that the latter only works if you specifiy either the  or the  constraint for the generic type
p4906
aVQuestion 2:
p4907
aVFor value types all members of the struct are \u201cnulled\u201d out, i
p4908
ag9
aVall reference type members are set to  () and all value types are in turn nulled out
p4909
aVAnd no, since  is a reference type, it does not result in  for strings as suggested in the other answer
p4910
aVQuestion 3:
p4911
aVNo, there's no way to specify this
p4912
aVThere are some threads about this on Stack Overflow already, e
p4913
ag118
aVhere
p4914
aVJon has posted an excellent explanation why this is
p4915
as(dp4916
g14
V1968
p4917
stp4918
a((dp4919
g2
(lp4920
VThe following works for me:
p4921
aVWhat happens here is that we match any character ( ) 15 times ()
p4922
aVWe capture the text so matched inside parentheses
p4923
aVThe following part () matches all the rest, until the end of the line
p4924
aVWe replace this by whatever we've captured inside the parentheses (), followed by the hyperbolic ellipsis
p4925
aVTo satisfy 's regex dialect (BRE) we have to escape some of the characters
p4926
as(dp4927
g14
V1968
p4928
stp4929
a((dp4930
g2
(lp4931
VIf you\u2019re using Windows, you can use  to retrieve the bitmap data
p4932
as(dp4933
g14
V1968
p4934
stp4935
a((dp4936
g2
(lp4937
VIn terms of coding practice which is the better to use and why
p4938
aVSimple answer: always use the short-circuited versions
p4939
aVThere\u2019s simply no reason not to
p4940
aVAdditionally, you make your code clearer because you express your intent: logical evaluation
p4941
aVUsing the bitwise (logical) operations implies that you want just that: bit operations, not logical evaluation (even though the MSDN calls them \u201clogical operators\u201d as well, when applied to boolean values)
p4942
aVAdditionally, since short-circuiting only evaluates what needs evaluating, it\u2019s often faster, and it allows to write such code as
p4943
aV(Notice that to solve this particular problem a better function already exists, namely  which you also used in your question
p4944
aVThis code wouldn\u2019t be possible with the bitwise logical operations because even if  were , the second expression would get evaluated, resulting in a
p4945
aVEDIT: If you want side-effects to occur in a logical context please still don\u2019t use bitwise operations
p4946
aVThis is a typical example of being too clever
p4947
aVThe next maintainer of the code (or even yourself, after a few weeks) wo sees this code will think \u201chmm, this code can be cleared up to use conditional operators,\u201d thus inadvertedly breaking the code
p4948
aVI pity whoever is in charge of fixing this bug
p4949
aVInstead, if you have to rely on side, effects, make them explicit:
p4950
aVGranted, three lines instead of one
p4951
aVBut a much clearer code as a result
p4952
as(dp4953
g14
V1968
p4954
stp4955
a((dp4956
g2
(lp4957
VYou've tagged your question \u201cC++\u201d
p4958
aVWhy not use appropriate C++ constructs instead
p4959
ag117
ag118
aVa  or even (might I suggest) a
p4960
aVEDIT Oh well, a  is probably not what you want
p4961
aVStill, I strongly suggest a C++-ier solution
p4962
as(dp4963
g14
V1968
p4964
stp4965
a((dp4966
g2
(lp4967
VPut a  before the declaration:
p4968
aVThe point is that due to potential template specialization, the compiler cannot know that the dependent identifier  identifies a type
p4969
as(dp4970
g14
V1968
p4971
stp4972
a((dp4973
g2
(lp4974
VHave a look at Boost
p4975
aVProto, which looks quite promising for the creation of DSEL
p4976
aVI don't have any experience with it, though
p4977
as(dp4978
g14
V1968
p4979
stp4980
a((dp4981
g2
(lp4982
V\u201clazy\u201d is the wrong word here
p4983
aVYou mean non-greedy as opposed to greedy
p4984
aVThere's no disadvantage in using it, that I know of
p4985
aVBut in your special case, neither should it be more efficient
p4986
as(dp4987
g14
V1968
p4988
stp4989
a((dp4990
g2
(lp4991
VAt the moment, it's simply not possible
p4992
aVThe current version of VB does not support multiline (or statement) lambdas
p4993
aVEach lambda can only comprise one single expression
p4994
aVThe next version of VB will fix that (there simply wasn't enough time in the last release)
p4995
aVIn the meantime, you'll have to make do with a delegate:
p4996
as(dp4997
g14
V1968
p4998
stp4999
a((dp5000
g2
(lp5001
VThis obviously begs the question \u2013 why do you use a wrong file extension on a system, where file type is determined by these extensions
p5002
aVSorry, the answer is of course wrong
p5003
aVI was pretty sure I had done it that way already
p5004
aVStill, I think the above comment is still valid, even if not applicable universally
p5005
aVMarking the answer \u201coffensive\u201d is just rude and doesn\u2019t change that
p5006
aVHowever, your problem can be solved relatively easily
p5007
aVInstead of opening the file through double-click, you can right-click it and choose \u201cOpen with
p5008
aV\u201d in its context menu
p5009
aVThere you can select the text editor
p5010
as(dp5011
g14
V1968
p5012
stp5013
a((dp5014
g2
(lp5015
VYou use :
p5016
aV\u2026 this yields:
p5017
aV(Notice that the index remains unchanged
p5018
as(dp5019
g14
V1968
p5020
stp5021
a((dp5022
g2
(lp5023
VIf you're not allowed to use the STL (for whatever reason), the first thing you want to do is actually to implement your own version of it \u2013 at least the parts you need, with the level of customizability you need
p5024
aVFor example, it's probably overkill to make your own  class parametrizable with a custom
p5025
aVBut nevertheless do implement your own lightweight
p5026
aVEverything else will result in a bad, hardly maintainable solution
p5027
as(dp5028
g14
V1968
p5029
stp5030
a((dp5031
g2
(lp5032
VWhy bother using reflector
p5033
aVJust look at the original source code
p5034
aVYou should mention the caveats of looking at the source code, though
p5035
aVAs Frans Bouma writes: Don't look at the sourcecode of
p5036
aVNET licensed under the 'Reference license'
p5037
aVHe cites several risks, all related to the implied acquisition of un-free knowledge which might pose problems when writing own software
p5038
aVThe most serious legal risk is probably related to involuntary patent infringements
p5039
aVAlso, you're specifically forbidden to contribute to certain other projects, such as ReactOS (and probably Mono), after having looked at similar source code
p5040
aVThis might in the future also include the
p5041
aVNET source
p5042
as(dp5043
g14
V1968
p5044
stp5045
a((dp5046
g2
(lp5047
VCan be done using an svn:ignore on rootdir
p5048
aVNo
p5049
aVspecifically are not applied recursively but only on the current folder
p5050
aVSince each folder holds its own versioning information, nothing is propagated to subfolders
p5051
aVSee The Red Book, Chapter 7
p5052
aV, Properties, footnote 29
p5053
aVThis is actually quite unfortunate; I'd rather have a -like property propagation myself
p5054
as(dp5055
g14
V1968
p5056
stp5057
a((dp5058
g2
(lp5059
VAs it is, your question lacks a lot of crucial information
p5060
aVObviously, if everything is done identically, the data will be the same as well
p5061
aVAdditionally, you probably don't mean that there are escape marks in your data (or do you
p5062
aVIn that case, you must have explicitly called a function to convert line breaks into a string containing the characters  and
p5063
aVLacking any code, I assume that you display your data differently; once using a normal  and once using something like
p5064
as(dp5065
g14
V1968
p5066
stp5067
a((dp5068
g2
(lp5069
VTry:
p5070
aVhere matches an alphanumerical character
p5071
aVIf you want to be more specific, you could also use  instead, and pass the  flag (case insensitive):
p5072
as(dp5073
g14
V1968
p5074
stp5075
a((dp5076
g2
(lp5077
VWhat is the best practice for using public fields
p5078
aV\u201cDon\u2019t
p5079
aV\u201d See also:
p5080
aVShould protected attributes always be banned
p5081
aVwhich concerns protected fields but what is said there is even more true for public ones
p5082
as(dp5083
g14
V1968
p5084
stp5085
a((dp5086
g2
(lp5087
VBy the way, cryptographic hashes / hash functions are exceptionally bad for dictionaries
p5088
aVThey\u2019re big and slow
p5089
aVBy solving the one problem  (size) you\u2019ve only introduced another, more severe problem: the function won\u2019t spread the input evenly any longer, thus destroying the single most important property of a good hash for approaching collision-free addressing (as you seem to have noticed yourself)
p5090
aV/EDIT: As Andrew has noted,  is the solution for this problem since that\u2019s its intended use
p5091
aVAnd like in a true dictionary, you will have to work around collisions
p5092
aVOne of the best schemes for that is double hashing
p5093
aVUnfortunately, the only 100% reliable way will be to actually store the original values
p5094
aVElse, you\u2019d have created an infinite compression, which we know can\u2019t exist
p5095
as(dp5096
g14
V1968
p5097
stp5098
a((dp5099
g2
(lp5100
VYou could use a  to store and retrieve your sorting template tokens
p5101
aVHowever, this basically does the same as your enum (only perhaps in a slightly more readable manner), because  here could be confusing
p5102
aVThis uses an appropriate overload of the  method to compare two elements based on their value in the  dictionary
p5103
as(dp5104
g14
V1968
p5105
stp5106
a((dp5107
g2
(lp5108
VHave you confirmed that regular expressions are too expensive
p5109
aVThe cost of regular expressions is greatly exaggerated
p5110
aVFor such a simple pattern performance will be quite good, probably only slightly less good than direct search-and-replace, in fact
p5111
aVAlso, have you experimented with the  flag when constructing the regular expression
p5112
aVThat said, can't you just use the simplest way, i
p5113
ag9
as(dp5114
g14
V1968
p5115
stp5116
a((dp5117
g2
(lp5118
VWell, either:
p5119
aVOr, to create a thumbnail:
p5120
aV\u2026 maybe add some error handling
p5121
aV;-)
p5122
as(dp5123
g14
V1968
p5124
stp5125
a((dp5126
g2
(lp5127
VVyas, I am truly sorry for having posted this useless pile of
p5128
aVIt's been ages since I've actually used  and I simply assumed that it implemented a (more or less) consistent interface
p5129
aVSomeone (Jon
p5130
aVplease tell me which drugs were used during the implementation of this useless struct
p5131
aVFinally, to make a long story short, the best solution is probably to implement your own version of , only doing it right
p5132
aVI don't understand your problem with using
p5133
aVThere's no additional overhead involved here, if that's what you mean, since no copying of the original data is done
p5134
aVRather,  offers a lightweight view on the data
p5135
aVTh make this work, change your (return) type from  to , or, if you need indexed access, to
p5136
aVGenerally prefer using interface types in method signatures, and completely avoid array types
p5137
aVThe rationale is very simple: it makes problems such as yours go away and makes the interface more flexible and future-proof
p5138
aVIt also provides better information hiding since it hides parts of the implementation which aren't relevant for the consumer of this method
p5139
as(dp5140
g14
V1968
p5141
stp5142
a((dp5143
g2
(lp5144
VThe accepted answer here is probably wrong, based on your code
p5145
aVchyne has given the correct clue: lambdas in VB always have return values (unlike in C#), statement lambdas are introduced in the next version though
p5146
aVIn the meantime, you simply can't use this code in VB
p5147
aVUse a regular loop instead:
p5148
aVThe next version of VB (available as a Beta since yesterday) would allow the following code to be written:
p5149
as(dp5150
g14
V1968
p5151
stp5152
a((dp5153
g2
(lp5154
VHopefully, this will be a thing of the past with the upcoming version of VB
p5155
aVSince iterators are actually gaining a lot of importance with new paradigms (especially LINQ in combination with lazy evaluation), this has quite a high priority, as far as I know from Paul Vick's blog
p5156
aVThen again, Paul's no longer the head of the VB team and I haven't yet had time to watch the PCD talks
p5157
aVStill, if you're interested, they're linked in Paul's blog
p5158
as(dp5159
g14
V1968
p5160
stp5161
a((dp5162
g2
(lp5163
ViPods are a good example of tight coupling: once the battery dies you might as well buy a new iPod because the battery is soldered fixed and won't come loose, thus making replacing very expensive
p5164
aVA loosely coupled player would allow effortlessly changing the battery
p5165
aVThe same, 1:1, goes for software development
p5166
as(dp5167
g14
V1968
p5168
stp5169
a((dp5170
g2
(lp5171
VSince no existing tool satisfied my needs, I wrote my own
p5172
aVLo and behold:
p5173
aVHyperlight
p5174
aVUsage is extremely easy: just use
p5175
aVto highlight code
p5176
aVWriting new language definitions is relatively easy, too \u2013 using regular expressions and a powerful but simple state machine
p5177
aVBy the way, I still need a lot of definitions so feel free to contribute
p5178
aVFor now, I've hosted the source code on Google code (see link above) which makes collaboration very easy
p5179
as(dp5180
g14
V1968
p5181
stp5182
a((dp5183
g2
(lp5184
Vcan you get it working with bind
p5185
aVThis is by design
p5186
aVBasically, since  returns a completely different type, there's no way that this will work
p5187
aVBasically, a binder proxy object cannot be converted to a C function pointer (since it isn't one: it's a function object)
p5188
aVThe type returned by  is complicated
p5189
aVThe current C++ standard allows no good way of doing what you want
p5190
aVC++0x will be fitted with a  expression which could be used here to achieve something like this:
p5191
aVNotice that this might or might not work
p5192
aVI have no way of testing it
p5193
as(dp5194
g14
V1968
p5195
stp5196
a((dp5197
g2
(lp5198
VAfter asking a similar question I\u2019ve created another package which uses Pygments, and offers quite a few more options than
p5199
aVIt\u2019s called  and is quite stable and usable
p5200
aVJust to show it off, here\u2019s a code highlighted with minted:
p5201
as(dp5202
g14
V1968
p5203
stp5204
a((dp5205
g2
(lp5206
VFirst of all, Java actually has great enums that can be used polymorphically
p5207
aVI'm no Java programmer so someone else can certainly give a good example (I can't)
p5208
aVAlso, consider that polymorphism is often just overkill
p5209
aVI've also just seen the talk, and it's great, but it only provides guidelines, no silver bullet
p5210
aVIt's especially not true that all  statements can be replaced
p5211
aVState machines is actually one case where enums make a lot of sense
p5212
aVI use state machines a lot in parsing
p5213
aVSure, this can be done with a design pattern and class polymorphism
p5214
aVBut it's much (much) more code, it performs the same job, only slower, it's not a jot more readable and it's a solution that's only needed in one single place, without any code recycling
p5215
aVUsing subclassing here simply has no advantage
p5216
aVThen again, this is an exception
p5217
aVIn general, subclassing is often the better solution in languages that support it well
p5218
aVEDIT: I notice that this might raise controversy
p5219
aVOf course there are a lot of good solutions that encapsulate parsing, from regular expressions to parser generator frameworks such as Antlr
p5220
aVNothing wrong with them and in all but the trivial cases these are the better solution
p5221
aVHowever, I work a lot with low-level code (not in Java, obviously), where regular expressions aren't supported and parser generators also incur an overhead
p5222
as(dp5223
g14
V1968
p5224
stp5225
a((dp5226
g2
(lp5227
VIs this a bottleneck
p5228
aVHow long does it take
p5229
aV5 MiB isn't actually a lot of data to search in
p5230
aVRegular expressions might do just fine, especially if you encode all the search strings into one pattern using alternations
p5231
aVThis basically amortizes the overall cost of the search to O(n + m) where n is the length of your text and m is the length of all patterns, combined
p5232
aVNotice that this is a very good performance
p5233
aVAn alternative that's well suited for many patterns is the Wu Manber algorithm
p5234
aVI've already posted a very simplistic C++ implementation of the algorithm
p5235
as(dp5236
g14
V1968
p5237
stp5238
a((dp5239
g2
(lp5240
VYou're trying to create an instance of  via
p5241
aVThis doesn't work because the compiler doesn't know that your generic type has a parameterless constructor (remember: this is no requirement)
p5242
aVTo rectify this, you've got to create a constructor constraint, which looks like this:
p5243
aVor, in your specific case:
p5244
as(dp5245
g14
V1968
p5246
stp5247
a((dp5248
g2
(lp5249
VIgnoring the algorithm for a moment (yes, I know, bad idea), the running time of this can be decreased hugely just by switching from  to
p5250
aV(Hope this doesn't have an off-by-one error
p5251
aVI'm prone to make these
p5252
aVAnother thing that I would try is to look if the step width can be incremented
p5253
as(dp5254
g14
V1968
p5255
stp5256
a((dp5257
g2
(lp5258
VWhatever the reason, this has nothing to do with method calls
p5259
aVFor one thing, such method calls are efficient
p5260
aVFor another, your first example also calls a method
p5261
aVThirdly, the second method call will be inlined and since nothing happens there, the second loop will actually be completely empty
p5262
aVThe compiler could even optimize away the entire loop
p5263
aVFinally, I can't reproduce your result, neither in debug nor in release mode
p5264
as(dp5265
g14
V1968
p5266
stp5267
a((dp5268
g2
(lp5269
VI've never seen any coding convention in C# that distinguished between public and private methods
p5270
aVI don't suggest doing it, since I don't see the benefit
p5271
as(dp5272
g14
V1968
p5273
stp5274
a((dp5275
g2
(lp5276
VYou're re-setting your reference (i
p5277
ag9
aV) but this doesn't change the value of the  property
p5278
aVThis is always true for such assignments
p5279
aVOnly changes to the content (i
p5280
ag9
aVyour  calls) are carried across references for the same object
p5281
aVTo make it so, you need to assign a new  instance to the original property and your  variable
p5282
aVThen you can manipulate either with the desired result
p5283
aVBy the way, I presume  is an extension method
p5284
as(dp5285
g14
V1968
p5286
stp5287
a((dp5288
g2
(lp5289
VThe key is forward declaration
p5290
aVTake the stuff from  that is required in  (or vice-versa) and forward-declare it in yet another header, e
p5291
ag118
aVAs an example, consider the following:
p5292
aVClearly, for this to work, it's important to separate interface and implementation
p5293
as(dp5294
g14
V1968
p5295
stp5296
a((dp5297
g2
(lp5298
VTheir semantics differ so you can't just interchange  and
p5299
aVThe one folds the elements up from the left, the other from the right
p5300
aVThat way, the operator gets applied in a different order
p5301
aVThis matters for all non-commuative operations, such as subtraction
p5302
aVHaskell
p5303
aVorg has an interesting article on the subject
p5304
as(dp5305
g14
V1968
p5306
stp5307
a((dp5308
g2
(lp5309
VNot that I know of
p5310
aVHowever, is there a proven need
p5311
aVHash tables don't have a large overhead, even for very small N it should be faster just to use the normal hash table than to search linearly
p5312
aVEDIT I don't have a benchmark to prove it but just by comparing the algorithms I conclude that hash tables should be faster than linear search as soon as N > 6 on average (for string keys or similar nontrivial hashes) so there is really no reason for a hybrid implementation
p5313
aVThe argument is as follows
p5314
aVIn linear search, on average half the elements have to be compared to your input, i
p5315
ag9
aVN / 2
p5316
aVIn a hash table, it is known that the expected number of comparisons is 2, regardless of input size (for very small hash tables with a load factor of less than 0
p5317
aV1 this is actually approaching 1)
p5318
aVAdditionally, the hash has to be calculated
p5319
aVThis results in 3 operations on your input, plus a very small overhead that can be neglected
p5320
aVThus, we search for which N it is true that 3 > N / 2, which is trivially N > 6
p5321
aVNote that the above calculation is actually wrong because for this small number of elements, the load factor of
p5322
aVNET's  will be much less than 0
p5323
ag756
aVThe tipping point is therefore actually even lower
p5324
as(dp5325
g14
V1968
p5326
stp5327
a((dp5328
g2
(lp5329
VIn other words, why is there no baked-in way to do value equality for generic collections
p5330
aVProbably because it's hard to formulate in generic terms, since this would only be possible if the value type (and key type) of the dictionary also implemented
p5331
aVHowever, requiring this would be too strong, making  unusable with a lot of types that don't implement this interface
p5332
aVThis is an inherent problem with constrained generics
p5333
aVHaskell provides a solution for this problem but this requires a much more powerful and complicated generics mechanism
p5334
aVNotice that something similar is true for  in comparison with containers, yet there is support for this, using  if necessary
p5335
as(dp5336
g14
V1968
p5337
stp5338
a((dp5339
g2
(lp5340
VI haven't read the book but I've never heard of this \u201ccontainment tree\u201d
p5341
aVIn context, it sounds as if this merely means all fields (of a given class) that also implement  and consequently have to be disposed in the class\u2019  method (if the  argument is ) \u2013 or rather, in your case, since there are no such fields you don\u2019t have to take any further action
p5342
as(dp5343
g14
V1968
p5344
stp5345
a((dp5346
g2
(lp5347
VUse a  data structure
p5348
aVMost programming languages / standard libraries come with one flavour or another
p5349
aVIf they don't, use a hash table (or generally, dictionary) implementation and just omit the value field
p5350
aVUse your characters as keys
p5351
aVThese data structures generally filter out duplicate entries (hence the name , from its mathematical usage: sets don't have a particular order and only unique values)
p5352
as(dp5353
g14
V1968
p5354
stp5355
a((dp5356
g2
(lp5357
VDoes this mean that I cant use FogBugz for estimates when doing pair programming
p5358
aVI don't have any FogBogz experience but I'd say \u201cgive it a try\u201d
p5359
aVThe whole point of the time estimates in FogBogz is that the software learns from experience and automatically corrects estimates based on this
p5360
aVThis is an incredibly strong mechanism because in practice, most people's estimates are worth squat
p5361
aVIt'd be interesting to see if FogBugs can also cope with pair estimates
p5362
aVI expect the error margin to be quite a bit higher but perhaps the estimtates are still usable
p5363
as(dp5364
g14
V1968
p5365
stp5366
a((dp5367
g2
(lp5368
VI can't say for certain but as far as I'm aware, there's no such possibility
p5369
aVHowever, optimization should never alter semantics of a well-defined code
p5370
aVThe only thing that could happen here is that a variable gets inlined or that order of read/write gets changed
p5371
aVThe first, and probably both problems can be addressed by declaring the variable(s) involved as , thus showing the compiler that no assumptions about its content should be made, based solely on the program flow
p5372
as(dp5373
g14
V1968
p5374
stp5375
a((dp5376
g2
(lp5377
VAnd just to be clear, in general, where should #include statements go
p5378
aVInside the include guards, for the reason you mentioned
p5379
aVFor your other problem: you need to forward-declare at least one of the classes, e
p5380
ag118
aVlike this:
p5381
aVThis only works for declarations though: as soon as you really use an instance of , you need to have defined it as well
p5382
aVBy the way, what Nathan says is true: you can't put class instances into each other recursively
p5383
aVThis only works with pointers (or, in your case, references) to instances
p5384
as(dp5385
g14
V1968
p5386
stp5387
a((dp5388
g2
(lp5389
VThe  profiler for Unix offers a decent leak detection
p5390
aVHowever, this is only one part of a successful approach
p5391
aVThe other part is to prevent (i
p5392
ag9
aVminimize) explicit memory handling
p5393
aVSmart pointers and allocators can help a great deal in preventing memory leaks
p5394
aVAlso, do use the STL classes: a leak-free linked list implementation is already provided by
p5395
as(dp5396
g14
V1968
p5397
stp5398
a((dp5399
g2
(lp5400
VThe best way is to use menu mnemonics, i
p5401
ag9
aVto have menu entries in your main form that get assigned the keyboard shortcut you want
p5402
aVThen everything else is handled internally and all you have to do is to implement the appropriate action that gets executed in the  event handler of that menu entry
p5403
as(dp5404
g14
V1968
p5405
stp5406
a((dp5407
g2
(lp5408
VUse any element \u2013 e
p5409
ag118
aVa , make sure it's displayed as a block-level element (i
p5410
ag9
aV) and give it a border
p5411
aVWorks well
p5412
as(dp5413
g14
V1968
p5414
stp5415
a((dp5416
g2
(lp5417
VJust use the Open Source GLIBC implementation, as found by Google Code
p5418
aVYou might want to change the GLIBC specific data types to something more generic
p5419
aVThis code uses the Fisher-Yates shuffle which is actually quite easy to implement by yourself, and very efficient
p5420
as(dp5421
g14
V1968
p5422
stp5423
a((dp5424
g2
(lp5425
VThe problem with OOP is that nobody bothered to give a proper, concise, agreed-upon definition
p5426
aVEspecially, I'd like to point out that all the aspects you mentioned can well be put into action without the use of object orientation
p5427
aVTwo type systems that do this are the Haskell type system, which, by consense, is generally not regarded to be object-oriented, and C++ templates with template subclassing
p5428
aVHowever, it could perhaps be argued that template subclassing emulates OOP
p5429
aVSince template subclassing is not a widely known mechanism, let me give an example from the SeqAn library where it was invented
p5430
aVHere,  and  are inherited of the \u201cabstract class\u201d
p5431
aVThey encapsulate the concept of a string, using completely different methods
p5432
aVThey share the polymorphic  method, implemented differently for both concrete types
p5433
as(dp5434
g14
V1968
p5435
stp5436
a((dp5437
g2
(lp5438
VHave you tried a template typename parameter
p5439
aVThe syntax is a bit weird because it emulates the syntax used to declare such a container
p5440
aVThere's a good InformIT article explaining this in more detail
p5441
aVNotice that you also should declare the argument as a reference
p5442
aVBy the way: this comment
p5443
aVis a dead giveaway that you're doing something wrong
p5444
aVYou do not want to check the type of the container
p5445
aVUser more sophisticated overloading instead, as shown in sep's answer
p5446
as(dp5447
g14
V1968
p5448
stp5449
a((dp5450
g2
(lp5451
VYou may also use these as a strict C++-only solution
p5452
aVThey don't really offer more than the OP's solution except added security through use of type traits and perhaps the tiniest speed boost in the case of
p5453
aV(beware of self-made )
p5454
as(dp5455
g14
V1968
p5456
stp5457
a((dp5458
g2
(lp5459
VThe best version is certainly to use the builtin way:
p5460
aVOf the other solutions, prefer the easiest; only if this is proving too slow, strive for a more efficient solution
p5461
aVIf you use a  and know its resulting length in advance, then also use an appropriate constructor, this is much more efficient because it means that only one time-consuming allocation takes place, and no unnecessary copying of data
p5462
aVNonsense: of course the above code is more efficient
p5463
as(dp5464
g14
V1968
p5465
stp5466
a((dp5467
g2
(lp5468
VFor the final, compiled code of your application, the short answer is \u201cno\u201d
p5469
aVDifferent tools are able to extract different information from the code (e
p5470
ag118
aVthe forms setups) and there are P code decompilers (see Edgar's excellent link for such tools)
p5471
aVHowever, up to this day, there is no decompiler for native code
p5472
aVI'm not aware of anything similar for other high-level languages either
p5473
as(dp5474
g14
V1968
p5475
stp5476
a((dp5477
g2
(lp5478
VUsing jQuery, this effect can be built very easily:
p5479
aVIf you execute this code on loading the page then it will work with any markup that looks like the following:
p5480
aVNotice that this code will work for any number of elements, so even for a whole table/list full of those items, the JavaScript code does not have to be repeated or adapted in any way
p5481
aVThe tag names (here  and ) don't matter either
p5482
aVUse what best suits you
p5483
as(dp5484
g14
V1968
p5485
stp5486
a((dp5487
g2
(lp5488
VThis is the culprit
p5489
aVYou probably mean:
p5490
aV(Notice the position of the last closing bracket
p5491
as(dp5492
g14
V1968
p5493
stp5494
a((dp5495
g2
(lp5496
VNo, this is not possible
p5497
aVUse  instead
p5498
aVAutoboxing takes care of the rest (i
p5499
ag9
aVfor most purposes you can program as if you had actually used  because Java converts to and from  automatically for you)
p5500
as(dp5501
g14
V1968
p5502
stp5503
a((dp5504
g2
(lp5505
VThere are two issues that I see:
p5506
aVRepeated use of
p5507
aVWhy not offer extension methods for each tag name
p5508
aVAdmittedly, this bloats the interface and is quite a lot to write (=> code generation
p5509
aVThe compiler/IDE doesn't assist you
p5510
aVIn particular, it doesn't check indentation (it will even destroy it when you indent your automatically)
p5511
aVBoth problems could perhaps be solved by using a Lambda approach:
p5512
aVThis is just one basic approach
p5513
aVThe API certainly would need a lot more work
p5514
aVIn particular, nesting the same tag name won't work because of argument name conflicts
p5515
aVAlso, this interface wouldn't work well (or at all) with VB
p5516
aVBut then, the same is unfortunately true for other modern
p5517
aVNET APIs, even the PLINQ interface from Microsoft
p5518
aVAnother approach that I've thought about some time ago actually tries to emulate Markaby, like sambo's code
p5519
aVThe main difference is that I'm using  blocks instead of , thus making use of RAII:
p5520
aVThis code doesn't have the problems of the other approach
p5521
aVOn the other hand, it provides less type safety for the attributes and a less elegant interface (for a given definition of \u201celegant\u201d)
p5522
aVI get both codes to compile and even produce some more or less meaningful output (i
p5523
ag9
aV: HTML
p5524
as(dp5525
g14
V1968
p5526
stp5527
a((dp5528
g2
(lp5529
Vmay I use the application I created in my company without contribute it to the GNU society (without sharing my Ruby code
p5530
aVYes
p5531
aVThe GPL license gouverns only how you use the GPL'ed source code, not the data that you use it with
p5532
aVSo, if you were to write an extension to the original program, or modified its source, you would be obliged to publish that modification
p5533
aVBut the GPL never obliges you to observe any rules concerning your data that are used/produced by the program under GPL
p5534
aVIn your case, this data happens to be code as well \u2013 but for the purpose of the GPL, it is just any old data
p5535
as(dp5536
g14
V1968
p5537
stp5538
a((dp5539
g2
(lp5540
VMy favourites in German are \u201cwilde\u201d and \u201cwutz\u201d, in conjunction, which could be translated as \u201cwild\u201d and \u201cpiglet\u201d
p5541
aVAlso, there's \u201cbarfoos\u201d, which, when spoken, sounds like \u201cbarfuß\u201d, German for \u201cbarefoot\u201d
p5542
as(dp5543
g14
V1968
p5544
stp5545
a((dp5546
g2
(lp5547
VApparently you may only use explicit template specialization at namespace scope although I can't find this in the standard (but GCC says as much)
p5548
aVThe following works for me (on GCC):
p5549
aVEDIT It is in the standard:
p5550
aV14
p5551
ag1937
ag1938
aV5:
p5552
aVAn explicit instantiation of a class or function template specialization is placed in the namespace in which the template is defined
p5553
aVAn explicit instantiation for a member of a class template is placed in the namespace where the enclosing class is defined
p5554
aVAn explicit instantiation for a member template is placed in the namespace where the enclosing class or class template is defined
p5555
aV(All emphasis added by me
p5556
as(dp5557
g14
V1968
p5558
stp5559
a((dp5560
g2
(lp5561
VIs it a best practice to use this constructor
p5562
aVDefinitely
p5563
aVWhen juggling large quantities of data, this may make the application much more efficient because it effectively prevents repeated allocation and copying of large data batches when filling the container continuously
p5564
aVTo give an example using the  data structure:
p5565
aVIn both cases, insertion actually has the same amortized constant runtime
p5566
aVThis means that regardless of the container size, an  operation will take a constant time
p5567
aVHowever, this is only true on average
p5568
aVIf the container has to be resized internally because it would otherwise overflow, this one  operation actually takes O(n), i
p5569
ag9
aVits time is proportional to the container's size
p5570
aVOver the course of many added elements this won't really matter, but for large n a single insert operation can be perceivable for the user, if the UI freezes during that time
p5571
aVThis will never happen if you've already reserved a sufficiently large capacity from the beginning
p5572
aVIf so, is there a rule of them as to some kind of "Magic Number" you should use
p5573
aVNo
p5574
aVIf you know the (even approximate) size, use it
p5575
aVIf you don't, don't bother
p5576
aVThe automatic enlargement strategy for these containers is actually pretty good and guesswork will fare much poorer in most cases (unless you have an informed guess, but then it's not really guessing at all, is it
p5577
as(dp5578
g14
V1968
p5579
stp5580
a((dp5581
g2
(lp5582
VGraph algorithms like Dijkstra's algorithm will not work because the graph is enormous
p5583
aVThis argument doesn't necessarily hold because Dijkstra will not usually look at the complete graph but rather just a very small subset (the better interconnected the graph, the smaller this subset)
p5584
aVDijkstra may actually perform rather well for well-behaved graphs
p5585
aVOn the other hand, with careful parametrization A* will always perform just as good, or better
p5586
aVHave you already tried how it would perform on your data
p5587
aVThat said, I'd also be very interested to hear about other peoples' experiences
p5588
aVOf course, prominent examples like Google Map's search are particularly interesting
p5589
aVI could imagine something like a directed nearest neighbour heuristic
p5590
as(dp5591
g14
V1968
p5592
stp5593
a((dp5594
g2
(lp5595
VUsually, you use a special placeholder element to indicate empty values
p5596
aVIn the simplest case, this could be a null pointer but that would of course mean that you introduce an indirection; you can't store your values directly
p5597
aVIn all other cases you would have to make allowance for the type actually stored
p5598
aVFor example, if you stored 32 bit integers, you would have to reserve at least one predefined value (e
p5599
ag118
aV0) as a sentinel element, thus reducing the range of values that may be stored in your hash table
p5600
aVAn additional array with flags is quite a good solution
p5601
aVConsider that this array could be reduced by a factor of at least 8 by storing bit flags instead of whole-byte variables (or even bools, which would require 4 bytes each on most architectures)
p5602
as(dp5603
g14
V1968
p5604
stp5605
a((dp5606
g2
(lp5607
VI would argue that the namespace hierarchy should only be gouverned by considerations of design and the hierarchy of the model/API
p5608
aVIf one namespace sports huge number of unrelated classes, rethink your design
p5609
aVContrary to what Andrew said, I would not worry about namespaces containing few classes \u2013 although it's of course true that the hierarchy should only be as fine-grained as needed to express the design
p5610
aVOn the other hand, I find it completely reasonable for a namespace to contain only one highly special class, or perhaps just a very small set of types, of which one encodes the task and the others provide an API (exceptions, enums for arguments \u2026)
p5611
aVAs an example, take  (in
p5612
aVNET)
p5613
aVGranted, slightly more than one class, but only just
p5614
as(dp5615
g14
V1968
p5616
stp5617
a((dp5618
g2
(lp5619
VAm I right about this behavior
p5620
aVYes
p5621
aVThe names exist only in the block where you have defined them, though
p5622
aVIn your case, this means the logical unit that your  clause is applied to, i
p5623
ag9
aVthe expression inside
p5624
as(dp5625
g14
V1968
p5626
stp5627
a((dp5628
g2
(lp5629
VThe usual way is to do it like this:
p5630
aVAFAIR, quite a few server-side languages actually support this out of the box and will produce a nice dictionary for these values
p5631
as(dp5632
g14
V1968
p5633
stp5634
a((dp5635
g2
(lp5636
VGiven this, does it make any sense to limit ones HTML 5 to that which will validate, and what practical benefit will we get from doing so
p5637
aVYes, of course
p5638
aVYou forget that the future is not fixed
p5639
aVIn particular, you implicitly assume that HTML 5 specs will never change, and never deprecate any features
p5640
aVThis, of course, only cements the status quo
p5641
aVIt is definitely desirable to remove support for some features in long term, to make it easier for new developments to take place (in particular if these might conflict each other)
p5642
aVThere may be no immediate benefit in producing valid HTML 5 (except that it still makes validation and thus development easier)
p5643
aVBut there may be a long-range benefit if most websites improve in quality because it makes moving on beyond the current technologies and standards much easier
p5644
as(dp5645
g14
V1968
p5646
stp5647
a((dp5648
g2
(lp5649
VWhy its not possible to create Derived object with base pointer
p5650
aVBecause the base is
p5651
aVThis explicitly forbids treating your class as a  instance from the outside
p5652
aVSeen from the outside, your class  is not a subclass of , only from inside the class itself
p5653
aVThe same counts for  inheritance, with the only difference that the base class now isn't private to the own class any more but rather to any derived class as well
p5654
aVTo the outside though, it behaves just like private inheritance
p5655
as(dp5656
g14
V1968
p5657
stp5658
a((dp5659
g2
(lp5660
VWhen you're writing code for someone else
p5661
aVFor example, I was once involved in the creation of a rigid web application framework that should be customizable for our customers
p5662
aVOne important request was that the customer could hire a designer to modify the templates without having to be able to program
p5663
aVEven more important, he might not be authorized to change the code
p5664
aVSmarty for example allows to implement quite rigid restrictions on what the template may do
p5665
aVBasically, our application disabled all but the most basic code constructs and a selected set of modifier functions
p5666
aVSo we had two goals that were served well by a template engine: simplicity and security
p5667
as(dp5668
g14
V1968
p5669
stp5670
a((dp5671
g2
(lp5672
VSome people here have a strange notion of what an \u201cobject\u201d in object-oriented programming is
p5673
aVIn order for something to be an object it does not have to be a reference type or, more generally, follow any formal implementation
p5674
aVAll that means is that you can operate on it as a first-class citizen in an object-oriented world
p5675
aVSince you can do this on values in C# (thanks to autoboxing), everything is indeed an object
p5676
aVTo some extend, this is even true for functions (but arguably not for classes)
p5677
aVWhether this is relevant in practice is another question but this is a general problem with OOP that I notice once again
p5678
aVNobody is clear on the definition of OOP (yes, most people agree that it has something to do with polymorphism, inheritance and encapsulation, some throw in \u201cabstraction\u201d for good measure)
p5679
aVFrom a usage point of view, every value in C# handles like an object
p5680
aVThat said, I like the currently accepted answer
p5681
aVIt offers both technically important aspects
p5682
aVNotice that in other contexts, e
p5683
ag118
aVC++, other aspects are stressed since C++ isn't necessarily object-oriented and furthermore is much more focused on low-level aspects
p5684
aVTherefore, the distinction between objects, POD and builtin primitives makes sometimes sense (then again, sometimes not)
p5685
as(dp5686
g14
V1968
p5687
stp5688
a((dp5689
g2
(lp5690
VI was kind of shocked by this
p5691
aVCould someone explain why this works
p5692
aVA good example of when to use it would also be nice
p5693
aVThis concept is pretty much analogous to C#'s explicit interface implementation
p5694
aVThere, too, you can only access the interface's member if you cast the type explicitly to that interface
p5695
aVI can't comment on why the
p5696
aVNET framework team felt this feature was really necessary though
p5697
aVIt might sometimes strengthen encapsulation but I'm not sure of this
p5698
aVIn any case, something extremely similar would always be possible using composition instead of (interface) inheritance
p5699
as(dp5700
g14
V1968
p5701
stp5702
a((dp5703
g2
(lp5704
VI can't reference to this module but if i put my code in a class
p5705
aVI can reference to it without any problem
p5706
aVDoes anyone know why
p5707
aVBecause Modules in VB aren't classes and can't be used to instantiate objects
p5708
aVRather, they're something similar to namespaces, with the difference that namespaces can't contain functions directly
p5709
aVSo the reason for modules is to provide a way to group functions logically that don't belong to a class
p5710
aVThis makes a lot of sense when you consider that not everything logically belongs to a class
p5711
aVConsider
p5712
aVThere is absolutely no reason to make that a class, other than a weird OOP purism
p5713
aVBy the way, you can't reference static classes in C# either, at least not if I understand correctly what you mean by \u201creference\u201d
p5714
aVPerhaps you can clarify this
p5715
as(dp5716
g14
V1968
p5717
stp5718
a((dp5719
g2
(lp5720
VA lambda forms a method group (basically this is a method identified by name (and scope) only
p5721
aVSince methods with the same name can be overloaded, a method group comprises several different members)
p5722
aVThis cannot always implicitly be converted to a delegate because a delegate is actually bound to a single method from within a method group
p5723
aVThis plays a role with overloading
p5724
aVUnfortunately, the same applies in your case
p5725
aVThe remedy is to make an explicit delegate:
p5726
as(dp5727
g14
V1968
p5728
stp5729
a((dp5730
g2
(lp5731
VI wouldn't say evil but mutability is often a sign of overeagerness on the part of the programmer to provide a maximum of functionality
p5732
aVIn reality, this is often not needed and that, in turn, makes the interface smaller, easier to use and harder to use wrong (= more robust)
p5733
aVOne example of this is read/write and write/write conflicts in race conditions
p5734
aVThese simply can't occur in immutable structures, since a write is not a valid operation
p5735
aVAlso, I claim that mutability is almost never actually needed, the programmer just thinks that it might be in the future
p5736
aVFor example, it simply doesn't make sense to change a date
p5737
aVRather, create a new date based off the old one
p5738
aVThis is a cheap operation, so performance is not a consideration
p5739
as(dp5740
g14
V1968
p5741
stp5742
a((dp5743
g2
(lp5744
VIn order to do this in C#, use  which takes a callback
p5745
as(dp5746
g14
V1968
p5747
stp5748
a((dp5749
g2
(lp5750
VThis declares a function prototype for a function named , returning an
p5751
aVYou are not declaring and initializing a variable here
p5752
as(dp5753
g14
V1968
p5754
stp5755
a((dp5756
g2
(lp5757
VOf course, one may declare "i" outside of the try/catch statement (and this is what I'm doing)
p5758
aVWell \u2026 if you really need to know the value of  then this seems like a logging vehicle \u2013 structured exception handling probably isn't the best way then
p5759
aVIf you want to handle the exception conditionally  (i
p5760
ag9
aVonly when debugging), put the  block inside the loop
p5761
aVSince this may hurt performance (depending on your environment), only do this in debug mode
p5762
as(dp5763
g14
V1968
p5764
stp5765
a((dp5766
g2
(lp5767
VOn the off chance that you know German (yes, sorry \u2026), a friend and I have written an introduction with code about this subject which I myself find quite passable
p5768
aVThe text and code uses the example of TSP to introduce the concept
p5769
aVEven if you don't know German, take a look at the code and the formulas in the text, this might still serve
p5770
as(dp5771
g14
V1968
p5772
stp5773
a((dp5774
g2
(lp5775
VIt actually used to be a quite common solution to pass the length in the first element of the array
p5776
aVThis kind of structure is often called  (for \u201cBASIC string\u201d), even though this also denoted different (but similar) types
p5777
aVThe advantage over the accepted solution is that determining the length using a sentinel is slow for large strings
p5778
aVThe disadvantage is obviously that this is a rather low-level hack that respects neither types nor structure
p5779
aVIn the form given below it also only works for strings of length <= 255
p5780
aVHowever, this can easily be expanded by storing the length in more than one byte
p5781
as(dp5782
g14
V1968
p5783
stp5784
a((dp5785
g2
(lp5786
VIf you just want to implement a pattern matching engine, a State Design Pattern might be unnecessary since the patter is unlikely to change
p5787
aVAs Chad has pointed out, using a  to encode the transition function is completely acceptable in such cases
p5788
aVHere's an example of a nondeterministic pattern matching automaton that uses sets:
p5789
aVThis automaton recognizes input words of the regular language described by the pattern ", i
p5790
ag9
aVan \u201ca\u201d followed by either a multiple of two or a multiple of three many \u201cb\u201ds
p5791
as(dp5792
g14
V1968
p5793
stp5794
a((dp5795
g2
(lp5796
VThe compiler can build jump tables where applicable
p5797
aVFor example, when you use the reflector to look at the code produced, you will see that for huge switches on strings, the compiler will actually generate code that uses a hash table to dispatch these
p5798
aVThe hash table uses the strings as keys and delegates to the  codes as values
p5799
aVThis has asymptotic better runtime than lots of chained  tests and is actually faster even for relatively few strings
p5800
as(dp5801
g14
V1968
p5802
stp5803
a((dp5804
g2
(lp5805
VHow do you determine the memory usage
p5806
aVHave you tried using  to locate potential memory leaks
p5807
aVIt's really easy
p5808
aVJust start your application with , run it, and look at the well-structured output
p5809
as(dp5810
g14
V1968
p5811
stp5812
a((dp5813
g2
(lp5814
VIn C#, lower-case type names are aliases for the  type names, e
p5815
ag118
aVequals  and  equals
p5816
aVIt's best practice to use these language alieses for the type names instead of their framework equivalent, for the sake of consistency
p5817
aVSo you're doing it wrong
p5818
aV;-)
p5819
aVAs for a reason why they both exist, the
p5820
aVNET types exist because they are defined in a language-independet standard for the
p5821
aVNET libraries called CTS (common type system)
p5822
aVWhy C# defines these aliases is beyond me (VB does something quite similar)
p5823
aVI guess the two reasons are
p5824
aVHabit
p5825
aVGet all these C and Java programmers to use C# by providing the same type names for some fundamental types
p5826
aVLaziness: You don't have to import the  namespace to use them
p5827
aVEDIT Since many people seem to prefer the other notation let me point out that this is by no means unreasonable
p5828
aVA good case can actually be made for the usage of the CTS type names rather than C#'s keywords and some superficially good arguments are offered in the other answers
p5829
aVFrom a purity/style point of view I would probaly concur
p5830
aVHowever, consider if this is worth breaking a well-established convention that helps to unify code across projects
p5831
as(dp5832
g14
V1968
p5833
stp5834
a((dp5835
g2
(lp5836
VI looked into the AppleEvent reference on the offhand I needed to create an AppleEvent but I didn't see one for hide application
p5837
aVAny thoughts
p5838
aVI'm no expert but you can just use AppleEvent to set the  property of a process to  \u2013 at least it works with an AppleScript
p5839
aVOn the other hand, your API seems to be the most direct way and the above code probably just uses it as well
p5840
as(dp5841
g14
V1968
p5842
stp5843
a((dp5844
g2
(lp5845
VIt sounds like Dan Horn's article \u201cStream Reduction Operations for GPGPU Applications\u201d in GPU Gems 2 is exactly what you want
p5846
aVLike all chapters, it's freely available online
p5847
as(dp5848
g14
V1968
p5849
stp5850
a((dp5851
g2
(lp5852
VC++/CLI allows you to override  in custom event handlers so you don't have to test for  or copy when raising the event
p5853
aVOf course, inside your custom  you still have to do this
p5854
aVExample, adapted from the MSDN for correctness:
p5855
as(dp5856
g14
V1968
p5857
stp5858
a((dp5859
g2
(lp5860
VYour code seems rather complicated; do you require the specific error checking
p5861
aVOtherwise, you could just use the following code which shouldn't be slower, in fact, it's mostly the same:
p5862
as(dp5863
g14
V1968
p5864
stp5865
a((dp5866
g2
(lp5867
VBased on dsimcha's code, I've implemented a more generic version that fits well into the framework we use (SeqAn)
p5868
aVActually, porting the code was completely straightforward
p5869
aVOnly afterwards did I find that there are actually publications concerning this very topic
p5870
aVThe great thing is: they basically say the same as you guys
p5871
aVA paper by Andersson and Nilsson on Implementing Radixsort is definitely worth the read
p5872
aVIf you happen to know German, be sure to also read David Weese's diploma thesis where he implements a generic substring index
p5873
aVMost of the thesis is devoted to a detailed analysis of the cost of building the index, considering secondary memory and extremely large files
p5874
aVThe results of his work have actually been implemented in SeqAn, only not in those parts where i needed it
p5875
aVJust for fun, here's the code I've written (I don't think anyone not using SeqAn will have any use for it)
p5876
aVNotice that it still doesn't consider radixes greater 4
p5877
aVI expect that this would have a huge impact on performance but unfortunately I simply don't have the time right now to implement this
p5878
aVThe code performs more than twice as fast as Introsort for short strings
p5879
aVThe break-even point is at a length of about 12\u201313
p5880
aVThe type of string (e
p5881
ag118
aVwhether it has 4, 5, or 16 different values) is comparatively unimportant
p5882
aVSorting > 6,000,000 DNA reads from chromosome 2 of the human genome takes just over 2 seconds on my PC
p5883
aVJust for the record, that's fast
p5884
aVEspecially considering that I don't use SIMD or any other hardware acceleration
p5885
aVFurthermore, valgrind shows me that the main bottleneck is  in the string assignments
p5886
aVIt gets called about 65,000,000 times \u2013 ten times for each string
p5887
aVThis is a dead giveaway that  could be optimized for these strings: instead of making copies, it could just swap all characters
p5888
aVI didn't try this but I'm convinced that it would make a hell of a difference
p5889
aVAnd, just to say it again, in case someone wasn't listening: the radix size has nearly no influence on runtime \u2013 which means that I should definitely try to implement the suggestion made by FryGuy, Stephan and EvilTeach
p5890
aVAh yes, by the way: cache locality is a noticeable factor: Starting at 1M strings, the runtime no longer increases linearly
p5891
aVHowever, this could be fixed quite easily: I use insertion sort for small subsets (<= 20 strings) \u2013 instead of mergesort as suggested by the random hacker
p5892
aVApparently, this performs even better than mergesort for such small lists (see the first paper I linked)
p5893
as(dp5894
g14
V1968
p5895
stp5896
a((dp5897
g2
(lp5898
VWhen I was new to C++, I found that it helped to read this construct as follows:
p5899
aV(Notice that this isn't valid code
p5900
aVIt's just what I trained myself to read in my head
p5901
as(dp5902
g14
V1968
p5903
stp5904
a((dp5905
g2
(lp5906
VOh, also, for various reasons, I don't want to use boost
p5907
aVValid decision, but most likely the wrong one
p5908
aVConsider Boost as an extension to the STL
p5909
aVC++ is a library-driven language
p5910
aVIf you don't take this into account, your code will be qualitatively inferior
p5911
aVWhile  can be used here, the absence of lambda expressions in C++ until C++0x makes this tedious
p5912
aVI advocate using Boost
p5913
aVForEach
p5914
aVIt makes this much easier:
p5915
as(dp5916
g14
V1968
p5917
stp5918
a((dp5919
g2
(lp5920
VYour API function declaration is wrong
p5921
aVThe function returns a pointer which is not reflected in your code
p5922
aVThe signature translates to VB as follows:
p5923
aVOf course, using an  directly is not easy
p5924
aVIn fact, quite some marshalling is involved:
p5925
aV(More or less important) side note: since your DLL apparently creates a new object in memory, it also needs to release/destroy it
p5926
aVBe sure to call the appropriate function after using the structure
p5927
as(dp5928
g14
V1968
p5929
stp5930
a((dp5931
g2
(lp5932
VShouldn't it be exactly the other way round
p5933
aVNot necessarily
p5934
aVI don't know the internals of Python well enough to comment specifically but some common observations are that your first loop uses a simple operator  which is probly implemented as a primitive by the runtime
p5935
aVIn contrast, the other loops first have to resolve a module name, resolve the variable/class found there and then call a member function on that
p5936
aVAnother note is that your loop might simply be too small to yield significant numbers
p5937
aVConsidering your low overall running time, this probably makes your tests useless
p5938
aVAlso, your test case is highly specialized on two short strings
p5939
aVSuch cases never give a clear picture of edge case performance
p5940
as(dp5941
g14
V1968
p5942
stp5943
a((dp5944
g2
(lp5945
VYou might exploit the fact that the sign of the calculation  depends on which number is greater
p5946
aVThis is used in many implementations of comparison
p5947
aVBut I believe you'll never be able to completely avoid comparison
p5948
aVIn this case, you still at least need to evaluate the contents of the sign flag on the processor
p5949
aVIf you just need to display the lower number you can also use arithmetic tricks:
p5950
aVEDIT erm \u2026 you're allowed to use
p5951
aVI should use switch statements and arithmetic operators
p5952
aVis basically the same as chained  and as such it also uses comparison
p5953
aVThis sounds as if you should indeed just compare to zero to see what sign  has
p5954
as(dp5955
g14
V1968
p5956
stp5957
a((dp5958
g2
(lp5959
V\u2026 Are all but const since they all call (if necessary):
p5960
aVThat updates the cached ,  and
p5961
aVThe same stands for  that call  and also sets
p5962
aVThis causes problem with the:
p5963
aVtechnique
p5964
aVPlease explain how that causes problems
p5965
aVIt should't, usually
p5966
aVAdditionally, if you use member variables to cache temporary results, make them
p5967
aVThen you can modify them even in  objects
p5968
as(dp5969
g14
V1968
p5970
stp5971
a((dp5972
g2
(lp5973
VYou can use Pythagoras to measure the distance between your point and the centre and see if it's lower than the radius:
p5974
aVEDIT (hat tip to Paul)
p5975
aVIn practice, squaring is often much cheaper than taking the square root and since we're only interested in an ordering, we can of course forego taking the square root:
p5976
aVAlso, Jason noted that  should be replaced by  and depending on usage this may actually make sense even though I believe that it's not true in the strict mathematical sense
p5977
aVI stand corrected
p5978
as(dp5979
g14
V1968
p5980
stp5981
a((dp5982
g2
(lp5983
VI'm not really opposed to empty loops, I use them relatively often in C++ \u2013 albeit qualifying the body as  which is much clearer IMHO
p5984
aVHowever, I don't get your code which seems to indicate that there's indeed code smell or at least that it could be formulated in a clearer way
p5985
aVWhat I don't get in particular is the fact that  returns a single boolean value, once
p5986
aVHow does this tie together with a loop
p5987
aVThe side-effect here is really non-obvious (you modify the contents of
p5988
aV\u2026 seems too clever, somehow
p5989
as(dp5990
g14
V1968
p5991
stp5992
a((dp5993
g2
(lp5994
VAs I've said elsewhere, Boyer-Moore isn't really apt for this
p5995
aVSince you want to search for multiple stings simultanously, the algorithm of Wu and Manber should be more to your liking
p5996
aVI've posted a proof of concept C++ code in answer to another question
p5997
aVHeed the caveats mentioned there
p5998
as(dp5999
g14
V1968
p6000
stp6001
a((dp6002
g2
(lp6003
VUsing a  loop in C++ is broken because the loop will never be exited when the stream goes into an error state
p6004
aVRather, you should test the stream's state directly
p6005
aVAdapted to your code, this could look like this:
p6006
aVHowever, you already have a stream
p6007
aVWhy put it into a string stream as well
p6008
aVOr do you need to do this line by line for any reason
p6009
aVYou can directly initialize your vector with the input iterators
p6010
aVNo need to build a string stream, and no need to use the  algorithm either because there's an appropriate constructor overload
p6011
aVNotice the extra parentheses around the first argument which are necessary to disambiguate this from a function declaration
p6012
aVEDIT A small explanation what this code does:
p6013
aVC++ offers a unified way of specifying ranges
p6014
aVA range is just a collection of typed values, without going into details about how these values are stored
p6015
aVIn C++, these ranges are denoted as half-open intervals [, [
p6016
aVThat means that a range is delimited by two iterators (which are kind of like pointers but more general; pointers are a special kind of iterator)
p6017
aVThe first iterator, , points to the first element of the range
p6018
aVThe second, , points behind the last element
p6019
aVWhy behind
p6020
aVBecause this allows to iterate over the elements very easily:
p6021
aVLike pointers, iterators are dereferenced by applying  to them
p6022
aVThis returns their value
p6023
aVContainer classes in C++ (e
p6024
ag118
aV, ) have a special constructor which allows easy copying of values from another range into the new container
p6025
aVConsequently, this constructor expects two iterators
p6026
aVFor example, the following copies the C-style array into the vector:
p6027
aVHere,  is synonymous with  which means that it points to the array's first element
p6028
aV, thanks to pointer arithmetic, is nearly equivalent to  (but this is invalid C++
p6029
aVand points to the virtual element behind the array
p6030
aVNow, my code above does the exact same as in this last example
p6031
aVThe only difference is the type of iterator I use
p6032
aVInstead of using a plain pointer, I use a special iterator class that C++ provides
p6033
aVThis iterator class wraps an input stream in such a way that  advances the input stream and  reads the next element from the stream
p6034
aVThe kind of element is specified by the type argument (hence  in this case)
p6035
aVTo make this work as a range, we need to specify a beginning and an end
p6036
aVAlas, we don't know the end of the input (this is logical, since the end of the stream may actually move over time as the user enters more input into a console
p6037
aVTherefore, to create a virtual end iterator, we pass no argument to the constructor of
p6038
aVConversely, to create a begin iterator, we pass an input stream
p6039
aVThis then creates an iterator that points to the current position in the stream (here, )
p6040
aVMy above code is functionally equivalent to the following:
p6041
aVand this, in turn, is equivalent to using the following loop:
p6042
as(dp6043
g14
V1968
p6044
stp6045
a((dp6046
g2
(lp6047
VHave a look at Boost's  which provides exactly this kind of functionality:
p6048
aVNow you can iterate over the values, e
p6049
ag118
aVlike this:
p6050
as(dp6051
g14
V1968
p6052
stp6053
a((dp6054
g2
(lp6055
VSimple answer in your case: don't use an , use an inline-defined :
p6056
aVIn this special case, that's equivalent and all compilers of the last few years should treat it so (I know for a fact that all the major ones do)
p6057
aVSee also: static const Member Value vs
p6058
aVMember enum : Which Method is Better & Why
p6059
as(dp6060
g14
V1968
p6061
stp6062
a((dp6063
g2
(lp6064
VUnrelated to your problem (which has been explained already), why is this a static function rather than residing globally in a namespace
p6065
aVThis would be somewhat C++-ier
p6066
as(dp6067
g14
V1968
p6068
stp6069
a((dp6070
g2
(lp6071
VThe syntax is similar to C#'s, in other words,  is overloaded to make this possible:
p6072
aVAnalogously for removal
p6073
aVUnlike C#, however, you may not omit the explicit instantiation of the event handler delegate so this produces quite long-winded code
p6074
as(dp6075
g14
V1968
p6076
stp6077
a((dp6078
g2
(lp6079
VWell, I think that it's not acceptable
p6080
aVYou've already alluded to potential future problems yourself
p6081
aVDon't think they're necessarily easy to solve
p6082
aVThings like \u201c\u2026 given that I expect the entire computation to consume less \u2026\u201d are famous last phrases
p6083
aVSimilarly, refitting code with some feature is one of these things they all talk of and never do
p6084
aVNot deallocating memory might sound good in the short run but can potentially create a huge load of problems in the long run
p6085
aVPersonally, I just don't think that's worth it
p6086
aVThere are two strategies
p6087
aVEither you build in the GC design from the very beginning
p6088
aVIt's more work but it will pay off
p6089
aVFor a lot of small objects it might pay to use a pool allocator and just keep track of the memory pool
p6090
aVThat way, you can keep track of the memory consumption and simply avoid a lot of problems that similar code, but without allocation pool, would create
p6091
aVOr you use smart pointers throughout the program from the beginning
p6092
aVI actually prefer this method even though it clutters the code
p6093
aVOne solution is to rely heavily on templates, which takes out a lot of redundancy when referring to types
p6094
aVTake a look at projects such as WebKit
p6095
aVTheir computation phase resembles yours since they build parse trees for HTML
p6096
aVThey use smart pointers throughout their program
p6097
aVFinally: \u201cIt\u2019s a question of style \u2026 Sloppy work tends to be habit-forming
p6098
aV\u201d
p6099
aV\u2013 Silk in Castle of Wizardry by David Eddings
p6100
as(dp6101
g14
V1968
p6102
stp6103
a((dp6104
g2
(lp6105
VWell, the problem with doing this is that you allocate a lot of memory when doing this on large files
p6106
aVI would rather read the file line by line and manually increment a counter
p6107
aVThis may not be a one-liner but it's much more memory-efficient
p6108
aVAlternatively, you may load the data in even-sized chunks and count the line breaks in these
p6109
aVThis is probably the fastest way
p6110
as(dp6111
g14
V1968
p6112
stp6113
a((dp6114
g2
(lp6115
VIf you're really using arrays, the best way is probably just to use the conventional  loop with indices
p6116
aVNot as nice, granted, but as far as I know
p6117
aVNET doesn't offer a better way of doing this
p6118
aVYou could also encapsulate your code into a method called  \u2013 this is a common higher-order list function
p6119
aVHowever, C# lacking a suitable Tuple type, this is quite crufty
p6120
aVYou'd end up returning an  which isn't very nice
p6121
aVBy the way, are you really using  instead of  or why do you cast the  value
p6122
as(dp6123
g14
V1968
p6124
stp6125
a((dp6126
g2
(lp6127
VNo, you cannot extend classes with properties
p6128
aVAdditionally,  is  so you can't extend it by inheriting
p6129
aVThe only recourse is to composition: encapsulate  in your own class
p6130
as(dp6131
g14
V1968
p6132
stp6133
a((dp6134
g2
(lp6135
VThe STL has basically aimed for small interfaces, so in your case, if and only if  can be implemented more efficiently than a combination of  and  it would be implemented as a member function
p6136
aVThis technique may not be applicable anywhere but it's a good rule of thumbs to prevent clutter in interfaces
p6137
as(dp6138
g14
V1968
p6139
stp6140
a((dp6141
g2
(lp6142
VAssignment of one struct to another, for all intents and purposes, works exactly like  in C++ on POD objects
p6143
aVIf you feel that this doesn't apply in your situation then I can assure you that your C++ code was not standard-conforming (i
p6144
ag9
aV, contained bugs in the form of undefined behaviour)
p6145
aVPlease specify (in the question) what effect you want to achieve
p6146
aVThis will be more useful than talking about replicating undefined behaviour in another language
p6147
as(dp6148
g14
V1968
p6149
stp6150
a((dp6151
g2
(lp6152
VYes, in that case enumeration is thread safe since at the beginning of a  loop a new instance of the enumerator is created with an implicit call to
p6153
as(dp6154
g14
V1968
p6155
stp6156
a((dp6157
g2
(lp6158
VWhy does Visual Studio by default create a private static method when refactoring code and selecting extract method
p6159
aVIt does this only if your method doesn't access any member variables/methods/properties
p6160
aVThis is good because it basically operates on the principle of least assumptions: since you don't access instance-specific data, might as well make the method
p6161
aVIs there some performance benefit by calling a private static method within a non-static class compared to a non-static method within a non-static class
p6162
aVTheoretically, there might be but I doubt it
p6163
aVHowever, making the method static makes it clear that it will not access or modify instance data, which I find a useful hint
p6164
as(dp6165
g14
V1968
p6166
stp6167
a((dp6168
g2
(lp6169
VYou can use the  method to invoke a constructor for a class via its type name (as a string) or an instance of
p6170
as(dp6171
g14
V1968
p6172
stp6173
a((dp6174
g2
(lp6175
VHow do I implement the functionality of "this" keyword in VB
p6176
aVNET
p6177
aVis called  in VB
p6178
aVHowever, this has got nothing to do with your code and refers to the containing class, in your case most probably the current
p6179
aVYou need to access the  object parameter, after casting it to :
p6180
as(dp6181
g14
V1968
p6182
stp6183
a((dp6184
g2
(lp6185
VThis may be a dumb question - but why are shared methods availible on types and instances in VB
p6186
aVnet - am I wrong to assume they are the equivalent to C# static methods
p6187
aVThey are the same
p6188
aVVB will warn if you try to use them on instances but it's not forbidden
p6189
aVThis has probably got to do with dynamic typing and late binding
p6190
aVImagine that you've got a late-bound object () without knowing its exact type
p6191
aVHow would you go about calling a static method of its class
p6192
aVAs far as I know, this wouldn't be possible in C# (without resorting to reflection)
p6193
aVIn VB with , you could simply call it as an instance method of the object
p6194
as(dp6195
g14
V1968
p6196
stp6197
a((dp6198
g2
(lp6199
VI'm not versed in ASP
p6200
aVNET but I'll give it a shot:
p6201
aVWhy does throwing the exception from the user control only result in the javascript dialog and not the Global
p6202
aVasax error handling kicking in
p6203
aVThe error is raised on the client side, your error handling takes place on the server side
p6204
aVUnless you implement an AJAX-y callback that kicks in upon errors, the server isn't notified of any client-side errors
p6205
aVThis doesn't seem to be the default behaviour in ASP
p6206
aVNET
p6207
aVYou might check out Microsoft's AJAX library, surely they already have a mechanism for such things in place
p6208
aVIs there a way to force consumers of the control to handle my custom error event
p6209
aVSimialr to a "MustImplement" -----a "MustHandle" kind of affair
p6210
aVSimple answer: no
p6211
as(dp6212
g14
V1968
p6213
stp6214
a((dp6215
g2
(lp6216
VI'm usually opposed to all such redirects as harmful to usability
p6217
aVHowever, in this case a basic content-type negotiation takes place and this might be acceptable
p6218
aVHowever, make sure that this doesn't break downloads of the PDF documents for users who might have disabled their referers in the browser (I do this, for one)
p6219
as(dp6220
g14
V1968
p6221
stp6222
a((dp6223
g2
(lp6224
VYou need to implement  appropriately for your class
p6225
aVThe general pattern looks like this:
p6226
aVNotice that this deals with (non-) references since the operation modifies your logger
p6227
aVAlso notice that you need to return the  parameter in order for chaining to work:
p6228
aVIf the innermost operation didn't return the current  instance, all other operations would either fail at compile-time (wrong method signature) or would be swallowed at run-time
p6229
as(dp6230
g14
V1968
p6231
stp6232
a((dp6233
g2
(lp6234
VYour example is a perfect illustration why warnings shouldn't be ignored
p6235
aVis an invalid prototype (but  works
p6236
aVand your code may break on some compilers
p6237
aVYour compiler was nice enough to point this out
p6238
aVI've found that almost every warning actually pointed to a real problem, even if I failed to understand the cause at the time
p6239
aVBasically, I always did something and intended something else
p6240
aVThe effect might have been achieved anyway, but only by pure coincidence
p6241
aVTreat warnings as errors
p6242
aVExceptions exist (there's one in the VB
p6243
aVNET compiler concerning uninitialized value types) but are exceedingly rare
p6244
aVAnd if you ever stumble upon one of these exceptions, you'll know it
p6245
as(dp6246
g14
V1968
p6247
stp6248
a((dp6249
g2
(lp6250
VJust omit the argument, i
p6251
ag9
aVuse this:
p6252
aVHere's an example: http://ejohn
p6253
aVorg/blog/search-and-dont-replace/
p6254
as(dp6255
g14
V1968
p6256
stp6257
a((dp6258
g2
(lp6259
VNotice that before invoking placement , you need to call the destructor on the memory \u2013 at least if the object either has a nontrivial destructor or contains members which have
p6260
aVFor an object pointer  of class  the destructor can explicitly be called as follows:
p6261
as(dp6262
g14
V1968
p6263
stp6264
a((dp6265
g2
(lp6266
VI agree with Jon and Kent but, like Scott Myers (in Effective C++), I go much further
p6267
aVI believe that every class should be either , or
p6268
aVThat is, only leaf classes in any hierarchy are really apt for direct instantiation
p6269
aVAll other classes (i
p6270
ag9
aVinner nodes in the inheritance) are \u201cunfinished\u201d and should consequently be
p6271
aVIt simply makes no sense for usual classes to be further extended
p6272
aVIf an aspect of the class is worth extending and/or modifying, the cleaner way would be to take that one class and separate it into one  base class and one concrete interchangeable implementation
p6273
as(dp6274
g14
V1968
p6275
stp6276
a((dp6277
g2
(lp6278
VI don't know where this problem comes from but I am pretty sure that it's a form of combinatorial optimization, and more specifically one that can be solved using (integer) linear programming
p6279
as(dp6280
g14
V1968
p6281
stp6282
a((dp6283
g2
(lp6284
VIronPython's performance is really quite good
p6285
aVThe startup performance penalty that you get has got to do with the
p6286
aVNET runtime
p6287
aVNET applications generally have a slow startup time because a lot of assemblies get loaded and some of them (at least some classes) get compiled on the fly
p6288
aVThis is expected behaviour in
p6289
aVNET
p6290
aVActual runtime performance is much better
p6291
aVEven startup performance can be improved by pre-compiling the IronPython assembly and putting a copy in the GAC: global assembly cache of your machine
p6292
aVThis can be done using the
p6293
as(dp6294
g14
V1968
p6295
stp6296
a((dp6297
g2
(lp6298
VThe real question should be \u201cwhy not
p6299
aV\u201d \u2026 an unordered dictionary is most probably implemented as a hash table (in fact, the Python documentation states this outright) where the order of elements is well-defined but not immediately obvious
p6300
aVYour observations match the rules of a hash table perfectly: apparent arbitrary, but constant order
p6301
as(dp6302
g14
V1968
p6303
stp6304
a((dp6305
g2
(lp6306
VWell, in the first iteration,  is set to
p6307
aVAfter that, each iteration basically executes the same two instructions:
p6308
aVfirst, test whether , and
p6309
aVsecond, decrement  ()
p6310
aVThis is done nine times (from  inclusively to  inclusively)
p6311
aVIn the very last iteration, we test again whether  and since this is false, we exit the loop
p6312
aVWe therefore get 1 + 9 * 2 + 1 = 20 iterations
p6313
as(dp6314
g14
V1968
p6315
stp6316
a((dp6317
g2
(lp6318
VNotice that the following two are also valid web addresses
p6319
aVDo you want to allow them
p6320
as(dp6321
g14
V1968
p6322
stp6323
a((dp6324
g2
(lp6325
VUnboxing only works if the type is identical
p6326
aVYou can't unbox an  that does not contain the target value
p6327
aVWhat you need is something along the lines of
p6328
aVThis looks whether the value is parsable as a
p6329
aVIf yes, then assign it to ; else assign
p6330
aVThe following code does approximately the same and might be easier to understand for people not familiar with the conditional operator :
p6331
as(dp6332
g14
V1968
p6333
stp6334
a((dp6335
g2
(lp6336
VThe first part of the question is relatively easy: delegates store a list of function pointers
p6337
aVIf you invoke a delegate, it calls all the function pointers in that internal list
p6338
aVAdding and removing a receiver (via  and ) amounts to adding to and removing from that list
p6339
aVFor more low-level information, refer to ECMA-335 (the CLI standard), section II
p6340
aV14
p6341
aV5 (Method pointers) and II
p6342
aV14
p6343
aV6 (Delegates)
p6344
aVIn particular, note that a delegate consists of an instance pointer (of type ) and a method pointer (of type )
p6345
aVA method pointer can be obtained (in CIL) via the  or  (for virtual function calls) instructions
p6346
aVThese two pieces of information identify any method
p6347
aVhow can they be used efficiently
p6348
aVWhat do you mean by that
p6349
aVDo you know about events or is your question more specialized
p6350
as(dp6351
g14
V1968
p6352
stp6353
a((dp6354
g2
(lp6355
VI do this whenever it makes sense
p6356
aVCompare with How do you make wrong code look wrong
p6357
aVWhat patterns do you use to avoid semantic errors
p6358
aVIn the example of Joel's article he discusses two cases:
p6359
aVThe case of a web application that needs to sanitize strings before output
p6360
aVHe proposes type prefixes to distinguish the types
p6361
aVHowever, I argue that it's much better to simply define two different string types
p6362
aVThe easiest way to do this is just to introduce a  type
p6363
aVOnly this type can be directly sent to the client
p6364
aVThe normal string type has to be converted (either explicitly or implicitly; it doesn't matter in this case, because the implicit conversion can still sanitize the string)
p6365
aVThe example of Microsoft Word where the programmers needed to distinguish between screen coordinates and document coordinates
p6366
aVThis is the classical case where two distinct types offer a lot of advantages, even though these types are nearly identical (they both describe 2D points)
p6367
aVTo address your disadvantages:
p6368
aVDisadvantage 1, verbose and unexpected syntax
p6369
aVMost languages actually allow to overload functions/operators in a way that make classes use expected syntax
p6370
aVIn C++, this is even best practice: \u201cmake your own types behave like s
p6371
aV\u201d Usually, this doesn't necessitate implicit casts in the presence of appropriate overloads
p6372
aVDisadvantage 2, too many classes for every single thing, where do you draw the line
p6373
aVMake as many custom types as you need (but not more)
p6374
aVSome languages, such as Haskell, actually encourage the proliferation of types
p6375
aVThe only thing that makes us hesitate in languages like C++ is lazyness because we've got to write a lot of boilerplate code
p6376
aVC++0x makes this slightly easier by introducing type-safe type aliases
p6377
aVOf course, there's always a trade-off involved
p6378
aVHowever, I believe that as soon as any one of the advantages apply for you, this disadvantage is simply balanced
p6379
as(dp6380
g14
V1968
p6381
stp6382
a((dp6383
g2
(lp6384
VIt shouldn't be necessary to force a redraw here (under normal circumstances) since that redraw is automatically forced as soon as your control gets nudged
p6385
aVHowever, what you need to do is clearing the background of your control before painting anything else: otherwise, your painting operation will mingle with previous painting processes
p6386
aVJust add an
p6387
aVbefore your other drawing operations in the  event handler
p6388
aVAlso, consider using the  method rather than the  event since you subclass the control and don't need to resort to the  event handler
p6389
aVFor the record,  forces a synchronous redraw which is usually not desired
p6390
aVRather, use  which enqueues the redraw request into the default window message queue
p6391
as(dp6392
g14
V1968
p6393
stp6394
a((dp6395
g2
(lp6396
VI have been told recently that using C++ style initialisation is better than traditional (and more common) assignment
p6397
aVThis is simply wrong
p6398
aVI understand the reason for this - the first example causes default construction and initialisation then subsequent assignment rather than specific construction and direct assignment in the second example
p6399
aVHowever, on modern processors / compilers, does it really make a difference
p6400
aVNo, it doesn't make a difference
p6401
aVThe C++ standard explicitly allows the assignment in that case to be omitted so that the same code will be produced
p6402
aVIn practice, all modern C++ compilers do this
p6403
aVAdditionally, Charles is right: this would never call the assignment operator but rather the copy constructor
p6404
aVBut as I've said, even this doesn't happen
p6405
as(dp6406
g14
V1968
p6407
stp6408
a((dp6409
g2
(lp6410
VSave the C
p6411
aVTo those people that advise learning C, please give arguments for that
p6412
aVI claim that it has absolutely no benefit to learn C rather than C++
p6413
aVI, unlike them, have arguments to back this claim up
p6414
aVIn a nutshell: C is already a subset of C++ for all intents and purposes, but it's far from the most interesting subset
p6415
aVIt only offers a very limited insight into new proramming paradigsm
p6416
aVC++, on the other hand, defines a few very interesting new paradigms which, furthermore, are a generalization of all that C has to offer (i
p6417
ag9
aViterators which are a generalization of pointers)
p6418
aVTo reiterate: if the choice is between C and C++, choose C++
p6419
as(dp6420
g14
V1968
p6421
stp6422
a((dp6423
g2
(lp6424
VI don't have a ready made code but it should be fairly simple
p6425
aVNamely, determine the GCD and work with it:
p6426
aVAnd a very basic function for calculating the GCD, using the Euclidean algorithm:
p6427
as(dp6428
g14
V1968
p6429
stp6430
a((dp6431
g2
(lp6432
VThere are no performance implications
p6433
aVis basically the same as any old argument passing, from a technical point of view
p6434
aVWhile it might sound plausible that huge amounds of data are copied (e
p6435
ag118
aVfor large structs), this is actually the same as for return values
p6436
aVIn fact, return values for all types > 32 bit are handled similar to  arguments on the machine level anyway
p6437
aVPlease note that the last statement doesn't suggest that returning a value ==  parameter in
p6438
aVNET
p6439
aVJon's benchmark shows that this is obviously (and regrettably) not the case
p6440
aVIn fact, to make it identical, named return value optimization is employed in C++ compilers
p6441
aVSomething similar could potentially be done in future versions of the JIT to improve performance of returning large structures (however, since large structures are quite rare in
p6442
aVNET, this might be an unnecessary optimization)
p6443
aVHowever, (and with my very limited knowledge of x86 assembly), returning objects from function calls generally entails allocating sufficient space at the call site, pushing the address on the stack and filling it by copying the return value into it
p6444
aVThis is basically the same that  does, only omitting an unnecessary temporary copy of the value since the target memory location can be accessed directly
p6445
as(dp6446
g14
V1968
p6447
stp6448
a((dp6449
g2
(lp6450
VCan I use C-style casting for built-in types like long x=(long)y; or it's still considered bad and dangerous
p6451
aVDon't use them, ever
p6452
aVThe reasons against using them applies here as well
p6453
aVBasically, once you use them, all bets are off because the compiler won't help you any more
p6454
aVWhile this is more dangerous for pointers than for other types, it's potentially still dangerous and gives poor compiler diagnostics in the case of errors, whereas new style casts offer richer error messages since their usage is more constrained: Meyers cites the example of casting away ness: using any cast other than  won't compile, thus making it clear what happens here
p6455
aVAlso, some other disadvantages apply regardless of the types, namely syntactic considerations: A C-style cast is very unobtrusive
p6456
aVThis isn't good: C++ casts stand out clearly in the code and point to potentially dangerous code
p6457
aVThey can also easily be searched for in IDEs and text editors
p6458
aVTry searching for a C-style cast in a large code and you'll see how hard this is
p6459
aVOn the other hand, C-style casts offer no advantages over C++ casts so there's not even a trade-off to consider
p6460
aVMore generally, Scott Meyers advises to \u201cMinimize casts\u201d in Effective C++ (item 27), because \u201ccasts subvert the type system
p6461
aV\u201d
p6462
as(dp6463
g14
V1968
p6464
stp6465
a((dp6466
g2
(lp6467
V in the function signature tells the compiler that the object's members may not be modified
p6468
aVYet you return a non- pointer to a member, thus allowing a violation of that promise
p6469
aVIn your class , you make/break no promise since you don't return a pointer to a member, you return a copy of it (and the member happens to be a pointer)
p6470
as(dp6471
g14
V1968
p6472
stp6473
a((dp6474
g2
(lp6475
VAm I using DateTime Compare correctly
p6476
aVNo
p6477
aVonly offers information about the relative position of two dates: less, equal or greater
p6478
aVWhat you want is something like this:
p6479
aVThis subtracts two s
p6480
aVThe result is a  object which has a  property
p6481
aVAdditionally, the conditional can be written directly as:
p6482
aVNo  needed
p6483
as(dp6484
g14
V1968
p6485
stp6486
a((dp6487
g2
(lp6488
VIn the simplest case you just copy the newly created executable into the  path
p6489
aVOf course, it's usually more complicated than that
p6490
aVNotice that most of these operations require special rights, which is why  is usually invoked using
p6491
as(dp6492
g14
V1968
p6493
stp6494
a((dp6495
g2
(lp6496
VYes, there is: you can capture the ed text using :
p6497
as(dp6498
g14
V1968
p6499
stp6500
a((dp6501
g2
(lp6502
VBy the way (completely unrelated to the question), your code operates on strings
p6503
aVThis isn't only less efficient, it actually doesn't really make sense since you're interested in individual characters rather than strings, and these are distinct data types in
p6504
aVNET
p6505
aVTo get a single-character literal rather than a string literal, append  to your literal:
p6506
as(dp6507
g14
V1968
p6508
stp6509
a((dp6510
g2
(lp6511
VI claim that it isn't a style issue but rather a readability/maintainability issue
p6512
aVOne variable should have one use, and one use only
p6513
aV\u201cRecycling\u201d variables for different purposes just because they happen to require the same type doesn't make any sense
p6514
aVFrom your description it sounds as if the other person's code you worked on does exactly this, since all other uses are basically covered by your list
p6515
aVPut simply, it uses private member variables to act as temporaries depending on situation
p6516
aVAm I right to assume this
p6517
aVIf so, the code is horrible
p6518
aVThe smaller the lexical scope and lifetime of any given variable, the less possiblity of erroneous use and the better for resource disposal
p6519
as(dp6520
g14
V1968
p6521
stp6522
a((dp6523
g2
(lp6524
VWell, since you're apparently already working with/on C++, have you considered using Boost
p6525
aVSpirit
p6526
aVThis allows you to hard-code the grammar inline in C++ as a domain-specific language and program against it in normal C++ code
p6527
as(dp6528
g14
V1968
p6529
stp6530
a((dp6531
g2
(lp6532
VExuberant ctags has a mode for C# and is easy to use
p6533
aVThat said, I would just reflect the assembly
p6534
as(dp6535
g14
V1968
p6536
stp6537
a((dp6538
g2
(lp6539
VTo answer the question in the title: no, not a priori
p6540
aVFor example, reflection can be extremely handy when implementing factories to create objects of different (but related) types
p6541
aVHowever, these are all implementation details and they should generally be hidden behind a general interface
p6542
aVReflection also tends to be quite slow so overuse is discouraged
p6543
aVBasically, use it when there's no other (good) solution, and nowhere else
p6544
aVOOP doesn't really contest with reflection in general
p6545
aVBut don't try to implement dynamic dispatching or listeners/callbacks using reflection when OOP would be adequate
p6546
as(dp6547
g14
V1968
p6548
stp6549
a((dp6550
g2
(lp6551
VMake  a , float it to the left and specify widths for all three containers
p6552
aVAlso, you migth make the surrounding  , else it will collapse on itself
p6553
as(dp6554
g14
V1968
p6555
stp6556
a((dp6557
g2
(lp6558
VSimple answer: no
p6559
aVThe array cannot be made
p6560
as(dp6561
g14
V1968
p6562
stp6563
a((dp6564
g2
(lp6565
VFirst off, why do you use  if you've got only one case
p6566
aVSecond, what \u201cdoesn't seem to work\u201d
p6567
aVAre you aware that you produce an infinite list
p6568
aV/Edit: For completeness\u2019 sake, here\u2019s the correct solution, which the OP found himself and posted as a comment:
p6569
as(dp6570
g14
V1968
p6571
stp6572
a((dp6573
g2
(lp6574
VIs there a specific reason why you constantly use assignment instead of intialization
p6575
aVThat is, why don't you write
p6576
aVetc
p6577
aVThis avoids a default construction and just makes more sense semantically
p6578
aVCreating a pointer to a string just for the sake of allocating it on the heap is never meaningful, i
p6579
ag9
aVyour case 2 doesn't make sense and is slightly less efficient
p6580
aVAs to your last question, yes, strings in C++ are mutable unless declared
p6581
as(dp6582
g14
V1968
p6583
stp6584
a((dp6585
g2
(lp6586
VAll these good examples aside, in C++ you would normally override the  for your point type to achieve something like this:
p6587
aVor even:
p6588
aVThe relevant implementation of the operator could look very much like the code by j_random_hacker
p6589
as(dp6590
g14
V1968
p6591
stp6592
a((dp6593
g2
(lp6594
VHave you tried registering the COM DLL using
p6595
aVI don't know if  does this automatically but apparently it doesn't
p6596
as(dp6597
g14
V1968
p6598
stp6599
a((dp6600
g2
(lp6601
VI dont know why this dialog shown
p6602
aVBecause you don't handle the exception in your program, indicating a bug
p6603
aVWindows' default resort is the shown dialog
p6604
aVYour job is to either prevent or handle all potential exceptions in your code, Windows doesn't do this for you (or rather, it does; only not to your liking)
p6605
as(dp6606
g14
V1968
p6607
stp6608
a((dp6609
g2
(lp6610
VYou are right about the memory consumption
p6611
aVHowever, I think that's a fairly premature optimization
p6612
aVLoading an array of a few thousand strings is no problem at all, neither for performance nor for memory consumption
p6613
aVReading a directoy containing that many files, however, is \u2013 no matter how you store/filter the file names: it will always be relatively slow
p6614
as(dp6615
g14
V1968
p6616
stp6617
a((dp6618
g2
(lp6619
VDoes c# have its own version of the java "synchronized" keyword
p6620
aVNo
p6621
aVIn C#, you explicitly  resources that you want to work on synchronously across asynchronous threads
p6622
aVopens a block; it doesn't work on method level
p6623
aVHowever, the underlying mechanism is similar since  works by invoking  (and subsequently ) on the runtime
p6624
aVJava works the same way, according to the Sun documentation
p6625
as(dp6626
g14
V1968
p6627
stp6628
a((dp6629
g2
(lp6630
VThis code contains a logic error, if at all
p6631
aVSince a logic error constitues a bug, don't swallow the exception \u2013 fix the error
p6632
aVOf course, this is specific to the particular code
p6633
aVOthers have offered more general advice
p6634
aVHowever, I've found that a lot of people actually do prefer catching exceptions over fixing logic errors and this is simply unacceptable
p6635
as(dp6636
g14
V1968
p6637
stp6638
a((dp6639
g2
(lp6640
VAre you sure you don't get the exception as a result of  being
p6641
aVYou're not calling any function in the above code, you pass a delegate to the method
p6642
as(dp6643
g14
V1968
p6644
stp6645
a((dp6646
g2
(lp6647
VAn alternative to using  is the declarative events syntax in VB
p6648
aVTo use it, you declare the control (as a private member), using the  keyword
p6649
aVThen, the  keyword can be used on methods to handle the appropriate events:
p6650
aVThere are mainly two advantages to this method:
p6651
aVNo need for ,
p6652
aVNo need to wire all event handlers manually: this is done automatically
p6653
as(dp6654
g14
V1968
p6655
stp6656
a((dp6657
g2
(lp6658
VHowever
p6659
aVthe problem I have is i need the exact value of the bytes with no encoding just the pure value for each byte
p6660
aVThen use this:
p6661
aVIt returns the bytes as stored internally by
p6662
aVNET strings
p6663
aVBut all this is codswallop: A string is always linked to a particular encoding and there's no way around it
p6664
aVThe above will fail e
p6665
ag118
aVif the file contains invalid Unicode code sequences (which may happen) or through normalization
p6666
aVSince you obviously don't want a , don't read one
p6667
aVRead the file as binary data instead
p6668
as(dp6669
g14
V1968
p6670
stp6671
a((dp6672
g2
(lp6673
VThat's the offender
p6674
aVTry concatenation:
p6675
aVYou mistakenly used  instead of  for concatenation
p6676
aVThis triggered PHP to convert the values to numbers (resulting in ) and adding them
p6677
as(dp6678
g14
V1968
p6679
stp6680
a((dp6681
g2
(lp6682
VIs this because they need to be implemented differently depending on the Driver I'm using
p6683
aVFor example
p6684
aVIt's general best practice to code to an interface instead of an implementation (= class, in this context), for multiple reasons
p6685
aVOne of them has been mentioned by you: related but different implementations can share a common interface
p6686
aVAnother point is that one particular implementation can be changed behind the scenes without requiring changing the interface as well: let's say the next implementation of the driver needs to use another class
p6687
aVIt's enough to implement the existing interface
p6688
aVNow imagine that instead of interfaces, the code dealt with class types
p6689
aVNow, if the implementation changed, these interfaces would need to be changed as well
p6690
aVThis would mean that every user (including you) of the API had to change their code as well
p6691
as(dp6692
g14
V1968
p6693
stp6694
a((dp6695
g2
(lp6696
VSimple solution
p6697
aVAs others have pointed out, directly printing a file to a stream does't work
p6698
aVPrinting the file contents would require opening another stream that reads from the file, or re-setting your stream's read pointer to the beginning and then reading the whole file again (as others have shown)
p6699
aVC++ doesn't do this automatically but you can do it manually (here, opening a new stream):
p6700
aVNow, writing the file contents to another stream is a trivial addition
p6701
aVInstead of writing the file, simply write the file buffer:
p6702
aVThat's all
p6703
aVNo loop needed to read the file line by line
p6704
aVTesting for valid streams
p6705
aVWhile we're on the subject of loops, beware of code that reads files in a loop in the following manner:
p6706
aVThis code produces an endless loop when there's a reading error
p6707
aVThis an happen in many, many situations
p6708
aVConsider e
p6709
ag118
aVthat the file is deleted while you read it, or that someone removes the USB device containing the file or that the file is wrongly formatted
p6710
aVAll these cases would create an infinity loop here
p6711
aVNever only test for  in a stream
p6712
aVLuckily, the solution to this problem is also quite simple
p6713
aVFurthermore, it explains why your original code yielded such a weird result
p6714
aVIn fact, streams in C++ have an implicit conversion to a -like type
p6715
aVFor reasons explained elsewhere (cue: safe bool idiom), it is actually converted to
p6716
aVThis makes it easy to test whether a stream is in a valid, not-at-end state and can safely be read from
p6717
aVTherefore, we can reformulate the loop appropriately:
p6718
aVThe above code relies on the conversion to  taking place
p6719
aVAny non pointer indicates a valid stream
p6720
aVNow, the same happens in your code:
p6721
aVSince there's no appropriate overload for  that takes a stream, C++ looks for other overloads and finds an overload for pointers
p6722
aVSo it implicitly calls something like this:
p6723
aVBetter solution
p6724
aVI've explained a simple, working solution above
p6725
aVHowever, this solution requires re-opening the file and reading it to memory again
p6726
aVThis doubles the work required
p6727
aVWe can make this better by introducing a new class that acts like a stream and that actually sends each output to two streams at once
p6728
aVThis way, you can write your data both to the file and to the standard stream at the same time
p6729
aVNo need to re-read the file
p6730
aVThe class in itself is quite simple
p6731
aVThe following complete code demonstrates the general principle:
p6732
as(dp6733
g14
V1968
p6734
stp6735
a((dp6736
g2
(lp6737
VIn an implementation file, I have:
p6738
aVThat's the problem
p6739
aVYou can't split template definitions between header and implementation files
p6740
aVDue to the nature of templates, C++ compilers are finicky here
p6741
aVDefine all the code in the header to make it work
p6742
aVIn fact, the problem here is that all template definitions must reside within the same compilation unit because the C++ standard doesn't define how template information are shared across different units
p6743
aVThese units are stitched together by the linker, but generics are resolved at compile time (which is earlier), not at link time
p6744
aVTheoretically, the C++ standard defines a keyword, , to handle these cases
p6745
aVIn practice, no compiler implements this (with one exception
p6746
aV, and there is no intention to change this because the cost/usefulness trade-off is not considered good enough
p6747
as(dp6748
g14
V1968
p6749
stp6750
a((dp6751
g2
(lp6752
VYou can extend CRTP to handle this
p6753
aVmonjardin's solution goes in the right direction
p6754
aVAll you need now is a default  implementation to use it as a leaf class
p6755
aVThat said, consider whether such an effort is worth the small added syntax bonus
p6756
aVConsider alternative solutions
p6757
as(dp6758
g14
V1968
p6759
stp6760
a((dp6761
g2
(lp6762
VSince you explicitly asked for VB as well, let me just add that this verbatim string syntax doesn't exist in VB, only in C#
p6763
aVRather, all strings are verbatim in VB (except for the fact that they cannot contain line breaks, unlike C# verbatim strings):
p6764
aVEscape sequences don't exist in VB (except for the doubling of the quote character, like in C# verbatim strings) which makes a few things more complicated
p6765
aVFor example, to write the following code in VB you need to use concatenation (or any of the other ways to construct a string)
p6766
aVIn VB this would be written as follows:
p6767
aV( is the VB string concatenation operator
p6768
aVcould equally be used
p6769
as(dp6770
g14
V1968
p6771
stp6772
a((dp6773
g2
(lp6774
VThe  algorithm shifts all characters not to be deleted to the beginning, overwriting deleted characters but it doesn't modify the container's length (since it works on iterators and doesn't know the underlying container)
p6775
aVTo achieve this, call :
p6776
as(dp6777
g14
V1968
p6778
stp6779
a((dp6780
g2
(lp6781
VThree things:
p6782
aVFix the indentation (but then I guess this was not done on purpose)
p6783
aVUse formatting instead of concatenation in constructing
p6784
aVRemove the  variable
p6785
aVRather, do the following:
p6786
as(dp6787
g14
V1968
p6788
stp6789
a((dp6790
g2
(lp6791
VWhere is the memory of fn() locate
p6792
aVSince it's a normal function, somewhere in the code section of your program
p6793
aVThis location is the same for all instances of the class
p6794
aVIn fact, it has got nothing to do with the instantiation of  via
p6795
aVIs there a pointer in object that pointing at the memory loaction of fn()
p6796
aVNo
p6797
aVFor a normal member function this isn't required since the address is known at compile time (or, at the latest, at link time); it therefore doesn't have to be stored separately at runtime
p6798
aVFor virtual functions, the situation is different
p6799
aVVirtual function pointers are stored in an array (called \u201cvirtual function-pointer table\u201d or \u201cvtable\u201d for short)
p6800
aVEach class has one such vtable and each instance to a class stores a pointer to that vtable
p6801
aVThis is necessary because if a pointer/reference of type  points to a sub-class , the compiler has no way of knowing which function to call; rather, the correct function is calculated at runtime by looking it up in the associated vtable
p6802
aVThe vtable pointer is also evident in the  the object
p6803
as(dp6804
g14
V1968
p6805
stp6806
a((dp6807
g2
(lp6808
VWell, one practical difference would be that  doesn't exist on my platform
p6809
aVFor Windows only (and with no intention of ever porting the program to another platform) and with the necessary headers included, it's the same (since  is just a )
p6810
as(dp6811
g14
V1968
p6812
stp6813
a((dp6814
g2
(lp6815
VCan I change the value of Environment
p6816
aVNewLine
p6817
aVNo
p6818
aVIf you know which platform to write for, create classes for each of these platforms and let them have their own implementation
p6819
aVIn the simplest case, this would look as follows:
p6820
aVetc
p6821
aV, and then just use an instance of the appropriate class
p6822
as(dp6823
g14
V1968
p6824
stp6825
a((dp6826
g2
(lp6827
VDoes null inherit from Object as well in C#
p6828
aVUnlike in some other systems,  is not defined in terms of a class or an instance
p6829
aVOn the contrary, it signifies the absence of any instance, and it doesn't have a type
p6830
aVIt is implicitly converted to whatever reference type fits the context
p6831
aVThe widest conversion (i
p6832
ag9
aVwhen no other can be inferred) is to
p6833
aVBut still,  is not generally of type
p6834
as(dp6835
g14
V1968
p6836
stp6837
a((dp6838
g2
(lp6839
VC++ has no idiomatic way of doing this
p6840
aVUse a separate data file instead
p6841
aVDepending on your platform, you might want to use resources to achieve a similar result but this is beyond the scope of C++
p6842
aVIn particular, to store the resources in the binary file you need to use external tools and to read these resources in your code you need to invoke platform API
p6843
aVFor example under Windows, there's the  function (and related)
p6844
as(dp6845
g14
V1968
p6846
stp6847
a((dp6848
g2
(lp6849
Vin the 1) init will be executed and then it pointer assegned to String
p6850
aVprototype
p6851
aVadd
p6852
aVNo it won't
p6853
aVThe function will simply be executed and its return value () will be assigned to
p6854
aVNo function pointer will be assigned
p6855
aVTo do this, you need to return a function
p6856
as(dp6857
g14
V1968
p6858
stp6859
a((dp6860
g2
(lp6861
VWhat version of Windows are you using
p6862
aVAs far as I know, starting with Windows XP, forward-slashes do actually work as path delimiters
p6863
as(dp6864
g14
V1968
p6865
stp6866
a((dp6867
g2
(lp6868
VConstruct a , you can then load a resource (even in a jar file) using the  method
p6869
as(dp6870
g14
V1968
p6871
stp6872
a((dp6873
g2
(lp6874
VYou can actually download a free version of the new IDE, the Express Edition
p6875
aVIt has a few limitations compared to the non-free versions (e
p6876
ag118
aVno plugin support) but for most applications it's still vastly superior to VS6
p6877
as(dp6878
g14
V1968
p6879
stp6880
a((dp6881
g2
(lp6882
VYour  are redundant, the framework already offers the  class \u2013 consider using it
p6883
as(dp6884
g14
V1968
p6885
stp6886
a((dp6887
g2
(lp6888
VYour code should definitely work
p6889
aVIn fact, the  example uses multiple class names
p6890
as(dp6891
g14
V1968
p6892
stp6893
a((dp6894
g2
(lp6895
VThe sole difference is that a console application always spawns a console if it isn't started from one (or the console is actively suppressed on startup)
p6896
aVA windows application, on the other hand, does not spawn a console
p6897
aVIt can still attach to an existant console or create a new one using
p6898
aVThis makes Windows applications better suited for GUI applications or background applications because you usually don't want to have a terminal window created for those
p6899
aVOn a more technical note, the only difference between a Console and a Windows executable is one byte in the PE header of the  file
p6900
aVToggling this byte manually (e
p6901
ag118
aVusing a hex editor) converts the application type
p6902
aVThis is a well-published hack that is used to create console applications in VB6 (where this type of application was not explicitly supported)
p6903
aVTo determine and change the subsystem type of an application, you need to read parts of the PE header
p6904
aVThe address of the subsystem data is not fixed though, because it's part of the optional file header whose position is determined by an address stored in the DOS file header (in the member )
p6905
aVThis address actually points to the  record which, in turn, includes the  structure
p6906
aVThis has an 1) member called
p6907
aVThe member's value is 2 for a Windows application and 3 for a console application
p6908
aVOther subsystems exist (in particular, POSIX and kernel)
p6909
aVI've written a small VB6 application to change the subsystem of an application, which can be downloaded from ActiveVB as source code
p6910
aVThe PE format isn't very well documented but this document may serve as an introduction: Peering Inside the PE: A Tour of the Win32 Portable Executable File Format
p6911
aV1) This doesn't really contradict my claim that only one byte differs: the most significant byte of this member is always 0
p6912
aVOnly the least significant byte changes
p6913
as(dp6914
g14
V1968
p6915
stp6916
a((dp6917
g2
(lp6918
Vwhich means I cannot use STL, boost, etc
p6919
aVlibraries, can I
p6920
aVWhy not
p6921
aVThey don't use any magic (as it were), only plain C++
p6922
aVSo if your compiler knows all of C++, this shouldn't be a problem
p6923
aVWhich is of course completely ludicrous, considering that C++ is probably the hardest to parse programming language in existence today, and that building a compiler from scratch would probably take hundreds (
p6924
aVof man-years
p6925
aV(I didn't actually invent this number \u2013 I read it somewhere
p6926
aVUnfortunately, I'm unable to find the source now
p6927
aVBut then, I guess the question was completely hypothetical so the hypothetical answer is: no, you can use existing libraries
p6928
aVSo why is C++ so hard to compile
p6929
aVFirst off, C++ is a context sensitive language
p6930
aVProducing a parser for such a grammar is much harder
p6931
aVHowever, this is still one of the simplest aspects
p6932
aVWhat makes C++ really hard are certain rules relating to declarations/definitions, name lookup (consider argument-dependent name lookup) implicit conversion rules, and of course the resolution of templates
p6933
aVI think no existing compiler gets templates right in all circumstances
p6934
aVConsider Andrej Alexandrescu's efford to write template-function versions of  and  that behave as correctly as the macro version
p6935
aVHe claims that no compiler succeeds in compiling his (theoretically correct) code:
p6936
aVIt would all be so nice, but there's a little detail worth mentioning
p6937
aVSadly, Min doesn't work with any compiler I have access to
p6938
aVIn fairness, each compiler chokes on a different piece of code
p6939
as(dp6940
g14
V1968
p6941
stp6942
a((dp6943
g2
(lp6944
VDon't use , you don't need to (ever)
p6945
aVThen all memory gets freed properly
p6946
aVEven using , memory should be freed automatically
p6947
aVThere was a rumor that some class instances are forgotten and don't get terminated correctly, despite reference counting
p6948
aVThus, it's been established as best practice to set all object instances to  explicitly (especially, but not limited to instances allocated in modules)
p6949
aVI've never seen any confirmation that this is actually true (it might still be, though
p6950
as(dp6951
g14
V1968
p6952
stp6953
a((dp6954
g2
(lp6955
V doesn't actually alter the value of  (which is always the same reference to an instance of a list)
p6956
aVRather, it alters the contents of this list
p6957
aVIn both cases, a copy is passed to the function
p6958
aVBut since  is a reference to a list instance, only the reference is copied, not the contents of the list
p6959
aVIn case you are familiar with C, the following approaches the semantics of the Python code:
p6960
aVHere,  is an  and  is an  but both are passed as a copy to the function
p6961
aVNontheless, the memory pointed to by  is the same at the sides of the caller and the callee
p6962
as(dp6963
g14
V1968
p6964
stp6965
a((dp6966
g2
(lp6967
VHow do you choose between implementing a value object (the canonical example being an address) as an immutable object or a struct
p6968
aVI think your options are wrong
p6969
aVImmutable object and struct are not opposites, nor are they the only options
p6970
aVRather, you've got four options:
p6971
aVClass
p6972
aVmutable
p6973
aVimmutable
p6974
aVStruct
p6975
aVmutable
p6976
aVimmutable
p6977
aVI argue that in
p6978
aVNET, the default choice should be a mutable class to represent logic and an immutable class to represent an entity
p6979
aVI actually tend to choose immutable classes even for logic implementations, if at all feasible
p6980
aVStructs should be reserved for small types that emulate value semantics, e
p6981
ag118
aVa custom  type, a  number type similar entities
p6982
aVThe emphasis here is on small since you don't want to copy large blobs of data, and indirection through references is actually cheap (so we don't gain much by using structs)
p6983
aVI tend to make structs always immutable (I can't think of a single exception at the moment)
p6984
aVSince this best fits the semantics of the intrinsic value types I find it a good rule to follow
p6985
as(dp6986
g14
V1968
p6987
stp6988
a((dp6989
g2
(lp6990
VIs there any compiler setting or other way to force an int to be initialized to 0
p6991
aVUnfortunately, there is no way in the language and if the compiler offers such a setting it goes against the standard and therefore should not be used
p6992
aVMay I ask why you need this
p6993
aVIs explicit initialization not enough
p6994
aVOr would you like to be warned when uninitialized memory i used
p6995
aVThe latter can be achieved using 's memory profiler
p6996
as(dp6997
g14
V1968
p6998
stp6999
a((dp7000
g2
(lp7001
VDownward funargs are local functions that are not returned or otherwise leave their declaration scope
p7002
aVThey only can be passed downwards to other functions from the current scope
p7003
aVTwo examples
p7004
aVThis is a downward funarg:
p7005
aVWhile this is not:
p7006
as(dp7007
g14
V1968
p7008
stp7009
a((dp7010
g2
(lp7011
VInclude the standard header  and go crazy
p7012
aVSpecifically, the  manipulator sets the output width
p7013
aVsets the filling character
p7014
as(dp7015
g14
V1968
p7016
stp7017
a((dp7018
g2
(lp7019
VI generally try to avoid the  class (meaning: I don't use it) because I find it very confusing: the code gives too few hints on what exactly happens here since  allows a lot of semantically very different conversions to occur with the same code
p7020
aVThis makes it hard to control for the programmer what exactly is happening
p7021
aVMy advice, therefore, is never to use this class
p7022
aVIt's not really necessary either (except for binary formatting of a number, because the normal  method of number classes doesn't offer an appropriate method to do this)
p7023
as(dp7024
g14
V1968
p7025
stp7026
a((dp7027
g2
(lp7028
VIf you can't use "Me
p7029
aVin a non-instance method, how would you use properties/functions from a base class in a Shared method
p7030
aVYou can't
p7031
aVShared methods (and  in C#) don't work well together with OOP
p7032
aVThis (i
p7033
ag9
aVthe fact that static/shared methods cannot be virtual/overridable) is arguably a design flaw in the
p7034
aVNET system that was \u201cinherited\u201d from Java
p7035
aVShared methods aren't actually object methods, rather they are global methods with a name scope
p7036
aVAdditionally, and perhaps even more related to your problem, you always need an instance to access a non-shared method (which, being shared, does not belong to any particular instance)
p7037
as(dp7038
g14
V1968
p7039
stp7040
a((dp7041
g2
(lp7042
VThe advantage of using either vim or emacs as an editor is precisely that it's available on virtually any decently configured Unix platform (and this includes more esoteric systems as well, e
p7043
ag118
aVDarwin/OS X)
p7044
aVCombined with the fact that you can store your configuration online (e
p7045
ag118
aVDotfiles) this makes for a very strong argument, because the problem you described simply doesn't exist
p7046
as(dp7047
g14
V1968
p7048
stp7049
a((dp7050
g2
(lp7051
VWell, look at it this way: using a minimizing algorithm, you can compact any non-satisfiable expression to the literal , right
p7052
aVThis effectively solves SAT
p7053
aVSo at least a complete minimizing algorithm is bound to be NP-complete NP hard
p7054
as(dp7055
g14
V1968
p7056
stp7057
a((dp7058
g2
(lp7059
VSingle quotes encode a single character (data type ), while double quotes encode a string of multiple characters
p7060
aVThe difference is similar to the difference between a single integer and an array of integers
p7061
as(dp7062
g14
V1968
p7063
stp7064
a((dp7065
g2
(lp7066
VAn often-used pattern is to create a policy class which is passed as a template type to your class and then inherited from privately:
p7067
aVOne famous example of this is the  class which is often inherited in that manner:
p7068
as(dp7069
g14
V1968
p7070
stp7071
a((dp7072
g2
(lp7073
VDon't let your instances fall into an invalid state: validate right in the setter, that's what it's there for
p7074
as(dp7075
g14
V1968
p7076
stp7077
a((dp7078
g2
(lp7079
VThe  class is basically a mutable string, a helper class to construct an immutable string
p7080
aVThe  is built on top to add more convenience functions for string formatting
p7081
as(dp7082
g14
V1968
p7083
stp7084
a((dp7085
g2
(lp7086
VI believe the following should work in Excel:
p7087
aV/EDIT: if you've pasted the email addresses over several cells, you can count the cells with the following function:
p7088
aVcounts non-empty cells in a given range
p7089
aVYou can specify the range by typing  into a cell and then selecting your cell range with the mouse cursor
p7090
as(dp7091
g14
V1968
p7092
stp7093
a((dp7094
g2
(lp7095
VIt sounds like you only use Assembler because you seem to think that this is necessary
p7096
aVThis isn't the case
p7097
aVIf you don't have any other reason for it (i
p7098
ag9
aVwanting to learn it), don't use Assembler here, unless you know exactly what you're doing
p7099
aVFor your average graphics engine, Assembler programming is completely unnecessary
p7100
aVEspecially when it comes to a Super Mario style 2D sprite engine
p7101
aVEven \u201cslow\u201d scripting languages like Python are fast enough for such things nowadays
p7102
aVAdding to that, if you don't know very precisely what you're doing, Assembler will not be faster than C (in fact, chances are it will be slower because you'll re-implement existing C functions less efficiently)
p7103
as(dp7104
g14
V1968
p7105
stp7106
a((dp7107
g2
(lp7108
VI don't see any harm in using Windows command keys in GVim
p7109
aVAlternatively, you can also use the hotkey  for yanking (copying) and  for pasting to and from the system clipboard
p7110
aVThis works on most platforms (Vim instances that are not directly attached to an X server on unix are a bit more difficult)
p7111
as(dp7112
g14
V1968
p7113
stp7114
a((dp7115
g2
(lp7116
VI recently did an internship in England and used this opportunity to switch to the English keyboard layout
p7117
aVThe switch was nearly completely straightforward and I can heartily recommend it, especially since you can still type the German umlauts very well on the English keyboard layout (Alt+u, then a/o/u types the corresponding umlaut; Alt+s types \u201cß\u201d)
p7118
aVThe keys used for programming are much easier reachable, especially \u201c\u201d and \u201c\u201d (which are both on \u201c\u201d and \u201c\u201d)
p7119
aVAlso, \u201c\u201d and \u201c\u201d better placed
p7120
aVThe only think I absolutely hate is the placement of the \u201c\u201d key because it requires the shift key
p7121
as(dp7122
g14
V1968
p7123
stp7124
a((dp7125
g2
(lp7126
VI've got a counter-example of how not to do it: Will o\u2019 the Wisp (since this is my own code I feel confident criticizing it)
p7127
aVWhat's good about the Code
p7128
aVIt uses a design pattern consequently: The interpreter pattern
p7129
aVIt has a rather clean design
p7130
aVIt uses attributes in a nice way
p7131
aVIt produces nice graphics
p7132
aV;-)
p7133
aVWhat's bad about the code
p7134
aVIt's slow
p7135
aVThe language is ill-defined with regards to lists (data vs
p7136
aVcode)
p7137
as(dp7138
g14
V1968
p7139
stp7140
a((dp7141
g2
(lp7142
VKeep track of the predecessor nodes
p7143
aVIn the easiest implementation, this is a dictionary, and usually denoted as \u03c0 in pseudo-codes:
p7144
aVThen you can iterate through these predecessors to backtrack the path from any node, say :
p7145
as(dp7146
g14
V1968
p7147
stp7148
a((dp7149
g2
(lp7150
VThe man pages are divided into sections, e
p7151
ag118
aVfor system calls, commands, macros etc
p7152
aVmainly to prevent name conflicts, e
p7153
ag118
aVwhen a system call has the same name as a command
p7154
aVOne example for this is :
p7155
aVversus
p7156
aVSection 1 is reserved for user commands
p7157
as(dp7158
g14
V1968
p7159
stp7160
a((dp7161
g2
(lp7162
VThis would be very bad, but since  can be overloaded a sloppy programmer might have omitted the test for null pointers, thus requiring the client to check for it
p7163
aVThis might be a reason for it here
p7164
aVAnother point, setting the pointer explicitly to null after deleting might actually make sense depending on the architecture of the code, precisely to prevent double-deletes
p7165
aVSince this only saves double-deletes on the same pointer though, it's highly questionable whether this is a good design
p7166
aVI wouldn't ever rely on it
p7167
aVAn explanation of overloaded :
p7168
aVis (despite its name) a function that may be overloaded like any other function
p7169
aVThis function gets called internally for every call of  with matching arguments
p7170
aVThe same is true for
p7171
aVOverloading  (and then also ) makes sense in some situations when you want to control precisely how memory is allocated
p7172
aVDoing this isn't even very hard, but a few precautions must be made to ensure correct behaviour
p7173
aVScott Meyers describes this in great detail Effective C++
p7174
aVFor now, let's just say that we want to overload the global version of  for debugging
p7175
aVBefore we do this, one short notice about what happens in the following code:
p7176
aVWhat actually happens here
p7177
aVWell the above can be roughly translated to the following code:
p7178
aVNotice step 2 where we call  with a slightly odd syntax
p7179
aVThis is a call to so-called placement  which takes an address and constructs an object at that address
p7180
aVThis operator can be overloaded as well
p7181
aVIn this case, it just serves to call the constructor of the class
p7182
aVNow, without further ado here's the code for an overloaded version of the operators:
p7183
aVThis code just uses / internally, much as most default implementations
p7184
aVIt also creates a debugging output
p7185
aVConsider the following code:
p7186
aVIt yielded the following output:
p7187
aVNow, this code does something fundamentally different than the standard implementation of : It didn't test for null pointers
p7188
aVThe compiler doesn't check this so the above code compiles but it may give nasty errors at run-time when you try to delete null pointers
p7189
aVHowever, as I said before, this behaviour is actually unexpected and a library writer should take care to check for null pointers in the
p7190
aVThis version is much improved:
p7191
aVIn conclusion, although a sloppy implementation of  may require explicit null checks in the client code, this is non-standard behaviour and should only be tolerated in legacy support (if at all)
p7192
as(dp7193
g14
V1968
p7194
stp7195
a((dp7196
g2
(lp7197
VOption Strict
p7198
aVThe most important thing to do in VB, in my (absolutely not humble) opinion is to use  at all times (except, on a per-file basis, when non-strict typing makes sense, e
p7199
ag118
aVbecause you use PIA to interoperate with MS Office) and to enable it in the VS options
p7200
aV, together with , gives roughly the same behaviour as C#
p7201
aVSwitched off, it removes a lot of type checks at compile-time and allows spurious, unnecessary and hard-to-debug implicit conversions between completely unrelated types
p7202
aVmakes sense when working with COM API
p7203
aVnever makes sense
p7204
aVIt's stupid (and mainly there for VB6 compatibility)
p7205
aVComparison:  versus
p7206
aVAnother thing to look out for: equality vs
p7207
aVreference testing
p7208
aVIn C#, you use  for both
p7209
aVIn VB, you've got distinct operators:
p7210
aVNow depending on the user input,  may be ;  will always be
p7211
aVBeware that  here is semantically equivalent to the following C# code (which nobody ever writes, usually):
p7212
aVI actually think this is an advantage in VB over C#, but one rarely needed
p7213
aVThe opposite of  is
p7214
aVAnother thing to pay attention to here is that the string comparison via the  operator actually calls a VB runtime method:
p7215
aVThis takes into account several other settings, especially the  setting which may be  (default, behaviour like in C#) or  (case-insensitive comparison)
p7216
aVversus  and
p7217
aVThe VB runtime is called in some other cases as well, one of them notably  which is a general-purpose conversion operator in VB
p7218
aVI tend to avoid using the operator and I strongly advise anyone doing the same, in favour of other, more explicit conversions
p7219
aVThe reasons for this is that  tries several semantically very different conversions, when applied
p7220
aVThis makes it hard to track what exactly is going on in the code, potentially introducing typing errors
p7221
aVFor one thing,  allows parsing of strings for numbers
p7222
aVThis is a concept better expressed through the  operation, as in C#
p7223
aVInstead of , I advise usage of  which is the equivalent of the C# cast, or  which is the same as C#'s  conversion
p7224
aVAnother gotcha
p7225
aVWhen checking whether an object  has a certain type , the following syntax has to be used:
p7226
aVNotice that this doesn't invoke the normal reference comparison operator
p7227
aVRather, it uses an own operator construct
p7228
aVYou cannot write , though
p7229
aVThis is probably a bug in the specs
p7230
aVMisc
p7231
aV\u2026
p7232
aVThere are a lot more differences, some useful (e
p7233
ag118
aVthe differences in the  statement) and some less (e
p7234
ag118
aVthe  operator for basic wildcard matching \u2026 just use regular expressions instead)
p7235
aVSome other questions relating to this:
p7236
aVWhat are the most important functional differences between C# and VB
p7237
aVNET
p7238
aVWhat are the differences between C#
p7239
aVnet and Visual Basic
p7240
aVnet
p7241
as(dp7242
g14
V1968
p7243
stp7244
a((dp7245
g2
(lp7246
VBe fault-tolerant, if possible
p7247
aVFor example, would it work to use whatever is provided
p7248
aVThe following two inputs could result in the same, if parsed nicely:
p7249
aVBoth would result in three obvious tags
p7250
aVI realize that this would it make hard to parse the following input unambiguously:
p7251
aVIn that case, I'd probably read two distinct tags
p7252
as(dp7253
g14
V1968
p7254
stp7255
a((dp7256
g2
(lp7257
VThe compiler is right
p7258
aVIn order for you to be able to access a method, this method must be declared in the type that the compiler sees (this is called the static type of a variable)
p7259
aVIn your case, this type is  and the compiler has no clue that it's something else
p7260
as(dp7261
g14
V1968
p7262
stp7263
a((dp7264
g2
(lp7265
VYou want the  method
p7266
as(dp7267
g14
V1968
p7268
stp7269
a((dp7270
g2
(lp7271
VAnd it seems that the fastest solutions are still C/C++ using just a single core of the 4 core machine that runs the tests
p7272
aVNo, that's not true for all codes
p7273
aVIn fact, of the codes I've looked at, all use multiple parallel threads, and thus multiple cores
p7274
aVIn fact, some (e
p7275
ag118
aVk-nucleotide) use fancy architecture like OpenMP (or, also interesting, SSE parallelization) to help parallelization
p7276
aVEDIT In fact, the fastest C++ solution for every problem uses parallel threads, with three exceptions:
p7277
aVfasta benchmark, hard (but altogether possible) to parallelize due to random generator usage
p7278
aVpidigits, uses the GMP library
p7279
aVn-body, could be parallelized
p7280
aV\u2026 and most other solutions also use SSE2 support
p7281
as(dp7282
g14
V1968
p7283
stp7284
a((dp7285
g2
(lp7286
VAssuming that your data indeed consists of DNA strings of length 3 (or more general length N where N is quite small), you can make this very efficient by using a q-gram table which is a specialized hash table with a table size of 4N and the following hashing function:
p7287
aVYou can now index your array very efficiently
p7288
aVAlternatively, use a library such as SeqAn for such tasks
p7289
as(dp7290
g14
V1968
p7291
stp7292
a((dp7293
g2
(lp7294
VA function interface has two parts:
p7295
aVinput, conferred via arguments
p7296
aVoutput, conferred via return values
p7297
aVThis schema is certainly not an absolute law but it's a very good rule, both for consistency (code aesthetics) and for usability
p7298
aVDon't break this schema unless you've got a very good reason
p7299
aVEfficiency
p7300
aVGenerally not a good reason
p7301
aVReturning a value via out parameter for efficiency is a pretty low-level hack, and it has got no place in the public interface of an API
p7302
aVDon't use it
p7303
aVIn particular since it's an extremely premature optimization
p7304
aVModern C++ compilers perform named return value optimization routinely
p7305
aVFew situations cannot be optimized in that manner and I doubt whether these situations benefit from out arguments in general
p7306
aVAnd in the few cases where such an out argument would be crucial, refactor the method into a public API method and a private implementation like so:
p7307
aVThat way, the client still profits from a clean interface and reaps the performance benefits (and, by the way, the outer method will be inlined anyway so there is no performance loss in using this pattern)
p7308
as(dp7309
g14
V1968
p7310
stp7311
a((dp7312
g2
(lp7313
VUse Linq/extension methods:
p7314
as(dp7315
g14
V1968
p7316
stp7317
a((dp7318
g2
(lp7319
VThe first and the last, at least, are possible using the following syntax:
p7320
as(dp7321
g14
V1968
p7322
stp7323
a((dp7324
g2
(lp7325
VThere is no implicit way to do the translation
p7326
aVYou have to wrap your existing delegate inside a lambda that creates a new type from the argument type:
p7327
aVWhere  creates the  instance from the  argument
p7328
as(dp7329
g14
V1968
p7330
stp7331
a((dp7332
g2
(lp7333
VI can heartily recommend  in combination with KCachegrind
p7334
as(dp7335
g14
V1968
p7336
stp7337
a((dp7338
g2
(lp7339
VVim enters the insert mode using i (or a for append), regardless of platform
p7340
aVOverwrite mode is only rarely entered using Shift+r
p7341
aVI've never used the Insert key here
p7342
as(dp7343
g14
V1968
p7344
stp7345
a((dp7346
g2
(lp7347
VI think there are three major, coherent schools of thought:
p7348
aVPeople that don't care either way and use  and  interchangeably
p7349
aVPeople that use s only to represent small POD
p7350
aVPeople who use s as records
p7351
aVI can't make a conclusive argument for either of these strategies
p7352
aVI tend to follow path 2 but I also use structs for non-POD types when I see it fitting, especially for function objects (even if these may not fulfil POD requirements)
p7353
aV(Incidentally, the C++ FAQ lite has a pretty good definition of POD)
p7354
aVEDIT I didn't touch template metaprogramming techniques, such as using  for placeholders (type tags) or to implement metafunctions
p7355
aVI guess there's absolutely no controversy in these cases: since they never contain methods (or even data), always use )
p7356
as(dp7357
g14
V1968
p7358
stp7359
a((dp7360
g2
(lp7361
VFunctors are not a priori object-oriented (in C++, the term \u201cfunctor\u201d usually means a struct defining an  with arbitrary arguments and return value that can be used as syntactical drop-in replacements to real functions or function pointers)
p7362
aVHowever, their object-oriented problem has a lot of issues, first and foremost usability
p7363
aVIt's just a whole lot of complicated boilerplate code
p7364
aVIn order for a decent signalling framework as in most dialog frameworks, a whole lot of inheritance mess becomes necessary
p7365
aVInstance-bound function pointers would be very beneficial here (
p7366
aVNET demonstrates this amply with delegates)
p7367
aVHowever, C++ member function pointers satisfy another need still
p7368
aVImagine, for example, that you've got a lot of values in a list of which you want to execute one method, say its
p7369
aVA function pointer to  helps here because it lets you write such code:
p7370
as(dp7371
g14
V1968
p7372
stp7373
a((dp7374
g2
(lp7375
VWell, what are the runtime constraints of  and
p7376
aVIf they are not required to be constant, then just calculate the minimum value in those two operations (making them O(n))
p7377
aVOtherwise, I don't see how this can be done with constant additional space
p7378
as(dp7379
g14
V1968
p7380
stp7381
a((dp7382
g2
(lp7383
VWithout seeing the code there's really no helping you
p7384
aVThe compiler clearly claims the opposite of you (there is at least one duplicate definition)
p7385
aVTry reproducing the error with a minimum example
p7386
aVHave you tried compiling the code outside Eclipse in the command line
p7387
aVWith what result
p7388
as(dp7389
g14
V1968
p7390
stp7391
a((dp7392
g2
(lp7393
VThis is a special case where the compiler is allowed to optimize out the copy: this is called named return value optimization (NRVO)
p7394
aVBasically, the compiler allocates memory for the return object on the call site and lets the function fill in that memory directly instead of creating the object at the called site and copying it back
p7395
aVModern compilers do this routinely whenever possible (there are some situations where this isn't easy since there are several return paths in the function that return different instances)
p7396
as(dp7397
g14
V1968
p7398
stp7399
a((dp7400
g2
(lp7401
VThis actually sets two properties and is equivalent to:
p7402
aVTo quote the official documentation:
p7403
aVThe syntax of this property is based on a traditional typographical shorthand notation to set multiple properties related to fonts
p7404
aVAs David M said in the comments, it mirrors the typesetting tradition of specifying typeface sizes as \u201cx\u2009pt on y\u2009pt\u201d to denote the glyph size on line height
p7405
aVBut the example in your question is actually wrong and would be ignored by the browser: you can only combine these two properties in the  shorthand notation, and you must specify at least both the font size and family
p7406
aVSimply writing  is therefore not enough; you could add a generic family name to make it valid though, e
p7407
ag118
ag1822
as(dp7408
g14
V1968
p7409
stp7410
a((dp7411
g2
(lp7412
VWhy use a  array at all
p7413
aVIt's not only useless \u2013 it complicates the code substantially (the usage of your function is more difficult, and you've forgotten to free the memory allocated by
p7414
aVWhy not just have the following function:
p7415
aV(Passing the argument by const reference instead of by value saves you a copy
p7416
aVIn fact, implementing the function only takes a single line using the features of the  class (one of its constructors takes two iterators):
p7417
as(dp7418
g14
V1968
p7419
stp7420
a((dp7421
g2
(lp7422
VUse  instead of
p7423
aVreturns to the head of the loop, only skipping the current iteration, while  leaves the loop for good
p7424
aVOn an unrelated note, your code has a bug that causes it to hang up if the file cannot be read for any reason (e
p7425
ag118
aVthe user deletes it while your program tries to access it, the user removes the USB stick the file is on, etc
p7426
aVThis is because a loop condition such as:
p7427
aVis dangerous
p7428
aVIf the file stream goes into an error state,  will never be  and the loop will go on and on and on \u2026
p7429
aVYou need to test whether the file is in any readable state
p7430
aVThis is simply done by using the implicit conversion to a boolean value:
p7431
aVThis will cause the loop to run only as long as the file isn't finished reading and there is no error
p7432
as(dp7433
g14
V1968
p7434
stp7435
a((dp7436
g2
(lp7437
VYou reuse  in your loop so you append to the current values
p7438
aVYou need to use a fresh array:
p7439
as(dp7440
g14
V1968
p7441
stp7442
a((dp7443
g2
(lp7444
VBreadth-first search traverses a graph and in fact finds all paths from a starting node
p7445
aVUsually, BFS doesn't keep all paths, however
p7446
aVInstead, it updates a prededecessor function \u03c0 to save the shortest path
p7447
aVYou can easily modify the algorithm so that  doesn't only store one predecessor but a list of possible predecessors
p7448
aVThen all possible paths are encoded in this function, and by traversing \u03c0 recursively you get all possible path combinations
p7449
aVOne good pseudocode which uses this notation can be found in Introduction to Algorithms by Cormen et al
p7450
aVand has subsequently been used in many University scripts on the subject
p7451
aVA Google search for \u201c\u201d uproots this first hit
p7452
as(dp7453
g14
V1968
p7454
stp7455
a((dp7456
g2
(lp7457
VIf you're looking to reduce clutter, consider
p7458
aVThis uses two features of C# 3
p7459
aV0: type inference (the  keyword) and the collection initializer for lists
p7460
aVAlternatively, if you can make do with an array, this is even shorter (by a small amount):
p7461
as(dp7462
g14
V1968
p7463
stp7464
a((dp7465
g2
(lp7466
VSince you formulated a hypothesis you should also cite corroborating evidence/reasons
p7467
aVName one reason why your code is superior to a much shorter, self-documenting  statement
p7468
as(dp7469
g14
V1968
p7470
stp7471
a((dp7472
g2
(lp7473
VYou miss the parentheses:
p7474
as(dp7475
g14
V1968
p7476
stp7477
a((dp7478
g2
(lp7479
VThere's at least one hard advantage to this guideline when working on a terminal emulator: All Unix tools expect this convention and work with it
p7480
aVFor instance, when concatenating files with , a file terminated by newline will have a different effect than one without:
p7481
aVAnd, as the previous example also demonstrates, when displaying the file on the command line (e
p7482
ag118
aVvia ), a newline-terminated file results in a correct display
p7483
aVAn improperly terminated file might be garbled (second line)
p7484
aVFor consistency, it\u2019s very helpful to follow this rule \u2013 doing otherwise will incur extra work when dealing with the default Unix tools
p7485
as(dp7486
g14
V1968
p7487
stp7488
a((dp7489
g2
(lp7490
VAny reason why you can't simply use SharpBits in VB
p7491
aVThe advantage of
p7492
aVNET is precisely that libraries written in the different
p7493
aVNET languages can interoperate seamlessly so you can simply use SharpBits in VB, no matter what
p7494
aVNET-compliant language it was written in
p7495
as(dp7496
g14
V1968
p7497
stp7498
a((dp7499
g2
(lp7500
VI'm not sure what you are trying to achieve because the code still doesn't make much sense
p7501
aVHowever, I believe the following should approximate what you're trying to do
p7502
aVNote that I don't use heap memory: it's not necessary and it would leak memory
p7503
aVThis works because you pass a (polymorphic) pointer to  to the  method of
p7504
aVThen you could call the code like this:
p7505
aVHowever, this code still smells because it's no idiomatic C++: In C++, you would usually write a copy constructor instead
p7506
aVLate-bound  methods do exist but they are very rarely needed, and the above is not late bound (but neither is your C# code)
p7507
as(dp7508
g14
V1968
p7509
stp7510
a((dp7511
g2
(lp7512
VI always felt the articles dirtied up the names with meaningless information
p7513
aVExactly
p7514
aVAnd this is all the reason necessary to drop articles: they clutter the code needlessly and provide no extra information
p7515
aVI don\u2019t know Smalltalk and can't talk about the reasons for \u201ctheir\u201d conventions but everywhere else, the above holds
p7516
aVThere might be a simple technical reason behind the Smalltalk convention (such as  in Ruby, which is a constant not only by convention but because of the language semantics)
p7517
as(dp7518
g14
V1968
p7519
stp7520
a((dp7521
g2
(lp7522
VWithout specific examples this is hard to decide
p7523
aVWhile  isn't strictly necessary it does have its uses
p7524
aVIf, as you claim, there are better alternatives then obviously use them, by simple definition of the word \u201cbetter\u201d
p7525
aVOr maybe the decision which solution is better isn't that clean-cut after all
p7526
aVPersonally, I prefer to avoid it when possible but I prefer to use it over method duplication: for example, I do not like to write a  method just to avoid making  a  because I don't see the benefit of the duplicate method
p7527
as(dp7528
g14
V1968
p7529
stp7530
a((dp7531
g2
(lp7532
VWill the next C++ standard define fixed-width integers
p7533
aVYes
p7534
aVAs Mehrdad said, you can use  for now
p7535
aVAn alternative would be some elaborate template magic
p7536
aVBoost has got something in this direction, the Boost Integer library
p7537
as(dp7538
g14
V1968
p7539
stp7540
a((dp7541
g2
(lp7542
VThe  equivalent in extension methods for Linq is called
p7543
as(dp7544
g14
V1968
p7545
stp7546
a((dp7547
g2
(lp7548
VIs there extra overhead in using the object
p7549
aVReferenceEquals method
p7550
aVNo
p7551
aVThe method directly contains the minimal IL description to perform the reference equality check (for the record: it's equivalent to VB's  operator) and will often be inlined by the JIT (especially when targeting x64) so there's no overhead
p7552
aVAbout readability: I personally think that  is potentially more readable (even in the negated form) because it explicitly expresses its semantics
p7553
aVThe cast to  may be confusing to some programmers
p7554
aVI've just found an article discussing this
p7555
aVIt prefers  because the IL footprint is smaller
p7556
aVIt argues that this might facilitate inlining of method  using this comparison
p7557
aVHowever (without any detailed knowledge of the JIT but logically and intuitively) I believe this is wrong: if the JIT behaves anything like an optimizing C++ compiler, it will consider the method after inlining the call to , so (for the sake of inlining method ) the memory footprint will be exactly the same either way
p7558
aVThat is to say: choosing one way over the other will have no impact whatsoever on the JIT and consequently on performance
p7559
as(dp7560
g14
V1968
p7561
stp7562
a((dp7563
g2
(lp7564
VDo you know about loops
p7565
aVThis runs the code within the loop once from 1 to , setting the variable  to the current value
p7566
as(dp7567
g14
V1968
p7568
stp7569
a((dp7570
g2
(lp7571
VWe've had this subject before but I can't find anything now
p7572
aVIn brief: your needs might change: where there's no sanity check now, one might be required in the future
p7573
aVHowever, if you change your public fields to properties, this breaks binary compatiblity: every client who uses your code/library would have to re-compile
p7574
aVThis is bad because it potentially costs a lot of money
p7575
aVUsing properties from the beginning avoids this problem
p7576
aVThis even counts for code that is not part of a library
p7577
aVWhy
p7578
aVBecause you never know: the code (even if highly domain-specific
p7579
aVmight prove useful so you want to refactor it to a library
p7580
aVThis refactoring process is obviously made much easier if you are already using properties in place of public/protected fields
p7581
aVAdditionally, writing public properties is easy in C# 3
p7582
aV0 because you can just use the auto-implemented properties, saving you quite a bit of code:
p7583
aVWill implement the necessary backing field and getter/setter code for you
p7584
aVI will add a personal note:
p7585
aVNET's behaviour in this regard is somewhat lazy
p7586
aVThe compiler could just change public fields to properties on the fly, thus avoiding the problem
p7587
aVVB6 already did this for COM-exposed classes and I see absolutely no reason for VB
p7588
aVNET and C# not to do the same
p7589
aVPerhaps someone on the compiler teams (Jared
p7590
aVcould comment on this
p7591
as(dp7592
g14
V1968
p7593
stp7594
a((dp7595
g2
(lp7596
V won't help you here; you need to use regular expressions:
p7597
aVYields your results
p7598
as(dp7599
g14
V1968
p7600
stp7601
a((dp7602
g2
(lp7603
VA priori, they've got nothing in common
p7604
aVMost answers here focus on OOP but encapsulation begins much earlier; every method is an encapsulation:
p7605
aVHere,  encapsulates the calculation of the (euclidean) distance between two points in a plane: it hides implementation details
p7606
aVThis is encapsulation, pure and simple
p7607
aVAbstraction is the process of generalization: taking a concrete implementation and making it applicable to different, albeit somewhat related, types of data
p7608
aVThe classical example of abstraction is C's  function which sorts data
p7609
aVThe thing about  is that it doesn't care about the data it sorts \u2013 in fact, it doesn't know what data it sorts
p7610
aVRather, its input type is a typeless pointer () which is just C's way of saying \u201cI don't care about the type of data\u201d (this is also called type erasure)
p7611
aVThe important point is that the implementation of  always stays the same, regardless of data type
p7612
aVThe only thing that has to change is the compare function, which differs from data type to data type
p7613
aVtherefore expects the user to provide said compare function as a function argument
p7614
as(dp7615
g14
V1968
p7616
stp7617
a((dp7618
g2
(lp7619
VEdit
p7620
aVSorry for sprouting such nonsense
p7621
aVI relied on a posting by Paul Vick (then head of the VB team) rather than the MSDN and don't have Windows installed to test the code
p7622
aVI'll still leave my posting \u2013 heavily modified (refer to the edit history to read the wrong original text) \u2013 because I find the points still have some merit
p7623
aVSo, once again, three things to recap:
p7624
aVFor reference types, C#'s  is directly modelled by  in VB
p7625
aVHowever, C# adds a little extra for the handling of value types via unboxing (namely the possibilities to unbox value types to their  counterpart via )
p7626
aVVB 9 provides the  operator to implement two distinct C# operators:  coalescing () and conditional (), as follows:
p7627
aVUnlike the previous  function these are real short-circuited operators, i
p7628
ag9
aVonly the necessary part will be executed
p7629
aVIn particular, the following code will compile and run just fine (it wouldn't, with the  function, since we could divide by zero):
p7630
aVDon't use VB6 style error handling ( or )
p7631
aVThat's backwards compatibility stuff for easy VB6 conversion
p7632
aVInstead, use
p7633
aVNET's exception handling mechanisms like you would in C#
p7634
as(dp7635
g14
V1968
p7636
stp7637
a((dp7638
g2
(lp7639
VTypedefs are resolved at compile time \u2013 making them overridable would be meaningless, since overriding is a feature of runtime polymorphism
p7640
aVSimply redeclaring the typedef will work \u2013 though I'm not sure why you think templates would be a bad idea here \u2013 recursive templates are actually feasible
p7641
as(dp7642
g14
V1968
p7643
stp7644
a((dp7645
g2
(lp7646
VI havent' tried this but Have tried it, works: how about changing the general pattern to use a positive lookahead instead
p7647
aVThat way, it should work:
p7648
aVBasically, this finds any (alphanumeric) character followed by up to four other alphanumeric characters and a period
p7649
aVThis might just work to match the last five characters in front of the period consecutively
p7650
aVIt's hellishly inefficient though, and it only works with engines that allow variable-width lookahead patterns
p7651
as(dp7652
g14
V1968
p7653
stp7654
a((dp7655
g2
(lp7656
VJust try to create the folder and catch the ensuing exception: everything else isn't safe because since Windows is (more or less) a real-time systen, between the moment where you test for the rights and the moment of folder creation, the rights might have been changed
p7657
aVConsider the following potential, critical event chain:
p7658
aVUser is about to change the folder rights
p7659
aVApplication tests for folder creation rights: test for rights successful
p7660
aVUser commits the changes
p7661
aVApplication tries to create the folder
p7662
as(dp7663
g14
V1968
p7664
stp7665
a((dp7666
g2
(lp7667
VAdd a  to your  that is the width of the image (or a bit more)
p7668
as(dp7669
g14
V1968
p7670
stp7671
a((dp7672
g2
(lp7673
VC# can't do this but it is actually possible in IL using  instead of
p7674
aVYou can thus work around C#'s limitation by using  in combination with a
p7675
aVHere's a very simple example to illustrate how this works
p7676
aVIf you really intend to use this, wrap it inside a nice function strive to make it work with different delegate types
p7677
aVPrints:
p7678
as(dp7679
g14
V1968
p7680
stp7681
a((dp7682
g2
(lp7683
VWhat do you want to achieve
p7684
aVThe version of  that you are trying to call doesn't exist \u2013 as the compiler is telling you
p7685
aVWhich of these versions do you mean
p7686
as(dp7687
g14
V1968
p7688
stp7689
a((dp7690
g2
(lp7691
VAnthony has given the correct answer
p7692
aVHowever, for the record: the  construct can be expressed in VB as follows:
p7693
as(dp7694
g14
V1968
p7695
stp7696
a((dp7697
g2
(lp7698
Voperator delete accepts a void*
p7699
aVAs part of a test program I overloaded operator delete and found that operator delete doesn't accept const pointer
p7700
aVHow did you try this
p7701
aVIt certainly does accept const pointers:
p7702
aVThis code is correct, compiles (albeit with a justified warning) and executes
p7703
aVEDIT: Reading the original article \u2013 you aren't talking about a const pointer but a pointer to , which is something else
p7704
aVThe reason why this has to work is described there
p7705
aVAs for why it's working: others have said this
p7706
as(dp7707
g14
V1968
p7708
stp7709
a((dp7710
g2
(lp7711
VIf  is set at the module level, is there any difference
p7712
aVNo
p7713
aVIt simply offers a finer grained control (no module-level strategy commitments)
p7714
aVHowever, if you can make such a commitment, go for the  option: less code is always better code
p7715
as(dp7716
g14
V1968
p7717
stp7718
a((dp7719
g2
(lp7720
VI am assuming I cannot access these events the same as other inherited members
p7721
aVPrecisely
p7722
aVIt's customary to provide a protected function  or  for each event in the base class to enable raising from inherited classes
p7723
aVFor example:
p7724
aVCalled in the inherited class:
p7725
as(dp7726
g14
V1968
p7727
stp7728
a((dp7729
g2
(lp7730
VBad example \u2013 the decision whether to use  or  doesn't involve any kind of trade-off
p7731
aVhas (may have) a net benefit without any downsides
p7732
aVThere are many similar scenarios and any discussion in these realms are a waste of time
p7733
aVThat said, I believe it's very important to know to what extent the target compiler is capable of optimizing small code fragments
p7734
aVThe truth is: modern compilers are (sometimes surprisingly
p7735
aVgood at it
p7736
aVJason has an incredible story concerning an optimized (non-tail recursive) factorial function
p7737
aVOn the other hand, compilers can be surprisingly stupid as well
p7738
aVThe key is that many optimizations require a control flow analysis which becomes NP complete
p7739
aVEver optimization thus becomes a trade-off between compilation time and usefulness
p7740
aVOften, the locality of an optimization plays a crucial role because the computation time required to perform the optimization increases just too much when the code size regarded by the compiler increases by just a few statements
p7741
aVAnd as others have said, these minute details are still relevant and always will be (for the forseeable future)
p7742
aVAlthough compilers get smarter all the time and machines get faster, so does the size of our data grow \u2013 in fact, we're losing this particular battle; in many fields, the amount of data grows much faster than computers get better
p7743
as(dp7744
g14
V1968
p7745
stp7746
a((dp7747
g2
(lp7748
V uses a  in the current directory to apply a set of rules to its input arguments
p7749
aVMake also knows some default rules so that it executes even if it doesn't find a  (or similar) file in the current directory
p7750
aVThe rule to execute for  files so happens to call  on many systems
p7751
aVNotice that you don't call  with the input file names but rather with rule names which reflect the output
p7752
aVSo calling  will strive to execute rule  which by default builds a file  (for example based on a source code file
p7753
as(dp7754
g14
V1968
p7755
stp7756
a((dp7757
g2
(lp7758
VAm I doing something wrong, or is this just native behavior
p7759
aVThat's native behaviour
p7760
aVIt's basically not the job of  to interpret string input
p7761
aVassumes that the user supplies the right data \u2013 in your case, numeric data
p7762
aVA string isn't numeric, even if it represents a number (this is the all-important distinction in CS between a value/semantics and its representation/syntax
p7763
as(dp7764
g14
V1968
p7765
stp7766
a((dp7767
g2
(lp7768
VHave you tried calling  in your program to get the output redirected to the calling terminal
p7769
as(dp7770
g14
V1968
p7771
stp7772
a((dp7773
g2
(lp7774
VUse  instead, that returns all properties
p7775
aVNotice that this returns a  instead of a
p7776
as(dp7777
g14
V1968
p7778
stp7779
a((dp7780
g2
(lp7781
VHow does your class know that this is a freestore pointer
p7782
ag117
ag118
aVwhat speaks against the following code
p7783
aVThis is an entirely sensible piece of code but your destructor will crash when trying to delete either of the pointers
p7784
aVLong story short: reclaiming resources is the job of whoever has allocated the resources in the first place
p7785
aVIf your class gets passed a pointer, the class cannot know and does not care about deallocation
p7786
aVThis is strictly the responsability of the caller
p7787
aVElegant ways to solve this dilemma without making the client to a lot of work are smart pointers, as mentioned before
p7788
as(dp7789
g14
V1968
p7790
stp7791
a((dp7792
g2
(lp7793
VIs the function late bound / has a  return value
p7794
aVIf so, the  function will check whether it contains an array type
p7795
as(dp7796
g14
V1968
p7797
stp7798
a((dp7799
g2
(lp7800
VWhy don't you lock on the whole posting instead just on its ID
p7801
as(dp7802
g14
V1968
p7803
stp7804
a((dp7805
g2
(lp7806
VFirst, to answer your question
p7807
aVThis is actually very easy and you don't need to change much in your code:
p7808
aVThis code basically checks whether the input was validly parsed as a floating point number \u2013 if that didn't happen, it signals an error
p7809
aVSecondly, the return type of  must always be , never
p7810
as(dp7811
g14
V1968
p7812
stp7813
a((dp7814
g2
(lp7815
VThere are no restrictions on escaped parameter names in the URI specs
p7816
aVThere might be restrictions in the server-side software that you use, though
p7817
aVThis is especially true if you use \u201chomemade\u201d scripts to interpret URIs
p7818
as(dp7819
g14
V1968
p7820
stp7821
a((dp7822
g2
(lp7823
VFor the case if ,  doesn't really make sense: it's always
p7824
aVtherefore implements the  (and the ) interface explicitly, thus making the interface \u201cprivate\u201d for normal use
p7825
aVIf you need to access it anyway, you can through an explicit cast to the interface:
p7826
as(dp7827
g14
V1968
p7828
stp7829
a((dp7830
g2
(lp7831
V is an instance of  and therefore you can use all of those methods to lexicographically compare string
p7832
aVAs Andrew said, that's essentially  but also the comparison operators,  among others
p7833
aVThis works for all types implementing  (and is really just a crude wrapper for ), including
p7834
as(dp7835
g14
V1968
p7836
stp7837
a((dp7838
g2
(lp7839
VFirst off, VS 2008 is quite powerful and probably one of the best IDEs for C++ programming (at least with a supporting plugin such as Visual Assist X)
p7840
aVBeware, however, that C++ is a hard language to get right for the compilers and that the default warning level is quite lenient to boot
p7841
aVSo it will tolerate bad/wrong code quite often
p7842
aVIt is always advisable to check the code on other compilers as well \u2013 at the very least in  with high warning level in strict mode
p7843
aVAlso setting the warning level higher in Visual Studio is encouraged
p7844
as(dp7845
g14
V1968
p7846
stp7847
a((dp7848
g2
(lp7849
VVisual Studio is an IDE (= an embellished editor), not a programming language
p7850
aVWhat language/environment do you use
p7851
aVThe above causes the file  to be streamed into the standard input stream of a program
p7852
aVAll languages offer different mechanisms of accessing this stream and reading from it
p7853
as(dp7854
g14
V1968
p7855
stp7856
a.