(lp0
((dp1
S'text'
p2
(lp3
VUpdate 3: I've uploaded my complete program to github
p4
aVOK, based on the replies so far, here's a naive suggestion for a tool that tries to get all applications back into physical memory:
p5
aVAllocate a small chunk of memory X, maybe 4MB
p6
aV(Should it be non-pageable
p7
aVIterate over all processes:
p8
aVFor each process, copy chunks of its memory to X
p9
aV(Possibly suspending the process first
p10
aVSuppose you have 2GB of RAM, and only 1GB is actually required by processes
p11
aVIf everything is in physical memory, you'd only copy 256 chunks, not the end of the world
p12
aVAt the end of the day, there's a good chance that all processes are now entirely in the physical memory
p13
aVPossible convenience and optimisation options:
p14
aVCheck first that the total required space is no more than, say, 50% of the total physical space
p15
aVOptionally only run on processes owned by the current user, or on a user-specified list
p16
aVCheck first whether each chunk of memory is actually paged to disk or not
p17
aVI can iterate over all processes using EnumProcesses(); I'd be grateful for any suggestions how to copy an entire process's memory chunk-wise
p18
aVUpdate: Here is my sample function
p19
aVIt takes the process ID as its argument and copies one byte from each good page of the process
p20
aV(The second argument is the maximal process memory size, obtainable via GetSystemInfo()
p21
aVQuestion: Does the region by whose size I increment consist of at most one page, or am I missing pages
p22
aVShould I try to find out the page size as well and only increment by the minimum of region size and page size
p23
aVUpdate 2: Page size is only 4kiB
p24
aVI changed the above code to increment only in 4kiB steps
p25
aVIn the final code we'd get rid of the fprintf's inside the loop
p26
as(dp27
S'author'
p28
V596781
p29
stp30
a((dp31
g2
(lp32
VThe leading "::" refers to the global namespace
p33
aVSuppose you say
p34
aVThen  refers to , while  refers to , which is probably what the user meant
p35
aVSo always including the initial "::" can protect you against referring to the wrong namespace, if you're not sure which namespace you're currently in
p36
as(dp37
g28
V596781
p38
stp39
a((dp40
g2
(lp41
VTo follow up Howard's fine answer, let me just state that in the end I conclude that making the sendBarToID function templated doesn't really improve the logic of the setup in the way I had hoped
p42
aVSince we have to bind() anyway, there's no reason to first bind and then unbind placeholders, we might as well just bind everything right in place
p43
aVHere's the non-templated version:
p44
aVI was hoping that the variadic template solution could somehow make the client code simpler, but now I don't see how it can get any simpler than this
p45
aVVariadic #define macros take care of the rest
p46
aVThank you for the contributions
p47
aVUpdate: OK, here's what I finally came up with, thanks to preprocessor macros:
p48
aVThere is one inconvenience: I need to define two separate functions and macros for constant and non-constant member functions
p49
aVAlso, I can't handle the empty argument list (Foo::bar(int))
p50
as(dp51
g28
V596781
p52
stp53
a((dp54
g2
(lp55
VOK, after having several inconsistent and unsurmountable problems with Boost
p56
aVTR1, especially when trying to use GCC's native TR1 libraries, I decided to ditch Boost entirely and use a small #define workaround
p57
aVHere is my "tr1
p58
aVh":
p59
aVNow I can just write my programs like this:
p60
as(dp61
g28
V596781
p62
stp63
a((dp64
g2
(lp65
VCombining a few ideas from previous posts, here's a solution that works even for nested constructions (tested in GCC4
p66
aV6):
p67
aVStrangely, can cannot make the return value an rvalue reference, that would not work for nested constructions
p68
aVAnyway, here's a test:
p69
aV(For the last output I'm using my pretty-printer
p70
aVActually, let us improve the type safety of this construction
p71
aVWe definitely need all types to be the same
p72
aVOne way is to add a static assertion, which I've edited in above
p73
aVThe other way is to only enable  when the types are the same, like so:
p74
aVEither way, you will need the variadic  type trait
p75
aVHere it is, generalizing from  (note that decaying is important to allow mixing of , ,  etc
p76
aV:
p77
aVNote that  returns by copy-of-temporary, which the compiler (with sufficient optimisation flags
p78
aVis allowed to treat as an rvalue or otherwise optimize away, and  is an aggregate type, so the compiler is free to pick the best possible construction method
p79
aVFinally, note that you cannot avoid copy/move construction when  sets up the initializer
p80
aVSo  has no copy/move, but  has two copy/moves as the arguments are forwarded to
p81
aVI don't think you can improve on that, because you can't pass a variadic initializer list lexically to the helper and deduce type and size -- if the preprocessor had a  function for variadic arguments, perhaps that could be done, but not within the core language
p82
as(dp83
g28
V596781
p84
stp85
a((dp86
g2
(lp87
VHere's an example how you can make the map keyed on  but still use different implementations in the derived classes:
p88
aVThe dynamic cast is valid because you promise only to compare pointers of the same derived type
p89
aVIf you wanted to be cleaner, you could probably specialise  and :
p90
as(dp91
g28
V596781
p92
stp93
a((dp94
g2
(lp95
VAccording to the new standard, clause 8
p96
aV5
p97
aV1 (Aggretates), a sufficiently simple type (e
p98
aVg
p99
aVno user-defined constructors) qualifies as an aggregate
p100
aVFor such an aggregate , writing  will construct the members from the list items
p101
aVSimple example:
p102
aVThe object  is constructed with all the relevant constructors executed in place
p103
aVNo maps or strings or MyClasses ever get copied or moved around
p104
aVNote that both variants at at the bottom do the same thing
p105
aVYou can even make MyClass's copy and move constructors private if you like
p106
as(dp107
g28
V596781
p108
stp109
a((dp110
g2
(lp111
VCall me naive, but why wouldn't the following suffice
p112
aVOK, forget that above, that was nonsense
p113
aVHere's a way to do it, which is just Luc's correct answer from above, for C++0x:
p114
as(dp115
g28
V596781
p116
stp117
a((dp118
g2
(lp119
VAs others already said, you're just lucky that the undefined behaviour that you trigger happens to look like what you thought you want (essentially because your Test::bla() is almost like a global free function)
p120
aVTo see your example crash and burn, just add some non-trivial class members:
p121
aVYou can think of your original example as a free function
p122
aVwhich you just happen to call with a garbage parameter, but since you don't use the parameter, nothing bad happens
p123
aVIn my modified example, we try to access  and die
p124
as(dp125
g28
V596781
p126
stp127
a((dp128
g2
(lp129
VPlease allow me to follow up on Bo's answer with a modified case, again in GCC 4
p130
aV6:
p131
aVWhy is the first form of in-place construction OK even without accessible copy/move constructors (note that  is patently not POD or aggregate), but the latter two (functionally identical) forms aren't
p132
aVWhich part of the standard says that the compiler has to check for an accessible constructor in the latter two cases but not in the first case
p133
as(dp134
g28
V596781
p135
stp136
a((dp137
g2
(lp138
VAlright, I think I managed to take the expression SFINAE approach and add type deduction
p139
aVHere is a very crudely hacked-together answer that appears to be doing something useful (see the usage example at the bottom)
p140
aV(The presentation could probably made a lot more succinct and clean, but this way you see it broken down into steps
p141
aVUsage:  is true if and only if both  and  have a member called  and the type of this member differs (strictly, not decayed)
p142
aVIntermediate questions such as whether the member is defined for both classes can be decided with  and
p143
as(dp144
g28
V596781
p145
stp146
a((dp147
g2
(lp148
VWhile the standard doesn't mandate any particular implementation (only constant-time random access), a deque is usually implemented as a collection of contiguous memory "pages"
p149
aVNew pages are allocated as needed, but you still have random access
p150
aVUnlike , you're not promised that data is stored contiguously, but like vector, insertions in the middle require lots of relocating
p151
as(dp152
g28
V596781
p153
stp154
a((dp155
g2
(lp156
VPreprocessor macros ("'s") are a lexical replacement tool a la "search and replace"
p157
aVThey are entirely agnostic of the programming language and have no understanding what you're trying to do
p158
aVYou can think of them as a glorified copy/paste mechanic -- occasionally that's useful, but you should use it with care
p159
aVTypedefs are a C language feature that lets you create aliases for types
p160
aVThis is extremely useful to make complicated compound types (like structs and function pointers) readable and handlable (in C++ there are even situations where you must typedef a type)
p161
aVFor (3): You should always prefer language features over preprocessor macros when that's possible
p162
aVSo always use typedefs for types, and constant values for constants
p163
aVThat way, the compiler can actually interact with you meaningfully
p164
aVRemember that the compiler is your friend, so you should tell it as much as possible
p165
aVPreprocessor macros do the exact opposite by hiding your semantics from the compiler
p166
as(dp167
g28
V596781
p168
stp169
a((dp170
g2
(lp171
VIf you open your file in Emacs and set-buffer-file-coding-system to something like "unix" or some ascii variety, then when you try to save, it'll warn you that the buffer contains unrepresentable characters and points you to them so you can fix them
p172
as(dp173
g28
V596781
p174
stp175
a((dp176
g2
(lp177
VThe way you have written it, you are simply constructing a two-dimensional array  (with dynamic storage)
p178
aVCalling  means that every object gets constructed, so there are no "missing values" or "empty spaces"
p179
aVWhen you say , precisely one of two things can happen:
p180
aVEither  and , and you obtain a reference to a valid  object, or
p181
aVyou incur undefined behaviour
p182
aVNothing else can happen
p183
as(dp184
g28
V596781
p185
stp186
a((dp187
g2
(lp188
VI'm not sure I understand your question fully, but the literal specifiers  and  only serve to specify the integral data type -- nothing is being said about what constitutes a character (or let alone which encoding is presumed)
p189
aVTo summarize:
p190
aVWhat you ultimately end up doing with those types is entirely up to you
p191
aVThe literal specifiers ,  and  simply allow you to put literal constants in your code, and they've been around for some time (though I think the  and  string syntax is only official in C++0x, and so are the types  and , which are genuinely new types, not just aliases)
p192
as(dp193
g28
V596781
p194
stp195
a((dp196
g2
(lp197
VThere's a fundamental difference between a shared library and a static library
p198
aVFirst off, do search this site for previous discussions, and check out this question too (and the answers therein)
p199
aVBasically, a static library is just a collection of objects, and the linker resolves the symbol names into fixed addresses -- this is required for static linking
p200
aVOn the other hand, a shared library is much more like an independent executable, which is loaded into memory by the loader and has entry point addresses to which the program jumps
p201
aVHowever, relocation tables that static libraries have are generally not preserved when a shared library is being linked, so it's in general not possible to extract linkable object code from inside a linked shared library
p202
as(dp203
g28
V596781
p204
stp205
a((dp206
g2
(lp207
VThis depends very much on the particular compiler version
p208
aVFor instance, GCC 4
p209
aV4 basically just had some macro switches for your  option to do the namespace labelling appropriately, but would always end up pulling the actual code from , while GCC 4
p210
aV6 has two entirely separate implementations, one in  and one in  -- and the respective base class implementations in  do in fact differ; the C++0x version has s everywhere etc
p211
aVShort answer: It depends
p212
as(dp213
g28
V596781
p214
stp215
a((dp216
g2
(lp217
VIt's a bit tricky, you have to know what your internal s mean
p218
aV(See here for a little discussion
p219
aVBasically you should communicate with the environment via /, and with data with known encoding via  (converting from and to WCHAR_T)
p220
aV(The exception here is Windows, where you can't really communicate with the environment meaningfully, but you can access it in a wide version directly with Windows API functions, and you can write wide strings directly into message boxes etc
p221
aVThat said, once you have your internal wide string, you can convert it to the environment's multibyte string with , or you can just use  which performs the conversion for you
p222
aVJust don't forget to call  at the very beginning of your program
p223
as(dp224
g28
V596781
p225
stp226
a((dp227
g2
(lp228
VIf you are simply troubled by ill-formed XML, you might consider the tidy tool which can turn your HTML into well-formed XML
p229
aVIn general, you'll need an XML parser that lets you access the raw content of the CDATA marked sections and then put that raw data to whatever use you have in mind
p230
as(dp231
g28
V596781
p232
stp233
a((dp234
g2
(lp235
VYou already have your answer, but since you have "initializer list" in the title, you may want to consider writing a (C++0x) initializer-list constructor, e
p236
ag99
aVlike so:
p237
aVThen you're no longer an aggregate, but you can construct it like so:
p238
aVYou even pass  as const-reference if you prefer
p239
as(dp240
g28
V596781
p241
stp242
a((dp243
g2
(lp244
VThere've been some answers already, but let me summarize
p245
aVPay attention to the mapped type (which is a pointer
p246
aVAnd is it 1D or 2D
p247
aV-- or even better, use typedefs to deconfuse yourself:
p248
aVAttention to detail is the key
p249
aVA few notes:
p250
aVHaving a raw pointer as the mapped type is terrible; what if the element already exists and you just overwrite it with a  pointer
p251
aVMemory leak
p252
aVYou should seriously consider making your map a
p253
aVA string makes for a poor key type if you have lots of entries
p254
aVConsider  instead
p255
aV(If you're in C++0x or MSVC10, omit the
p256
as(dp257
g28
V596781
p258
stp259
a((dp260
g2
(lp261
VI've just tested this again with GCC 4
p262
aV6
p263
aVIn the standard settings, this works as expected, giving 101 for all the lengths
p264
aVHowever, with your option  I also get unexpected results (51 in my case, and 251 for the final conversion after using setlocale())
p265
aVSo I looked up the man entry for the option:
p266
aVWarning: the -fshort-wchar switch causes GCC to generate code that is not binary compatible with code generated without that switch
p267
aVUse it to conform to a non-default application binary interface
p268
aVI think that explains it: When you're linking to the standard library, you are expected to use the correct ABI and type conventions, which you are overriding with that option
p269
as(dp270
g28
V596781
p271
stp272
a((dp273
g2
(lp274
VIf you want to avoid any coding at all and just need a quick-and-cheap solution, you can use our magic container printer -- just include the header and bingo
p275
aV(If you're not in C++0x, you may have to remove the tuple stuff and put a space between angled brackets
p276
as(dp277
g28
V596781
p278
stp279
a((dp280
g2
(lp281
VAs for the preprocessor, see Pete Wilson's answer
p282
aVAs for the  directive, Wikipedia has this to say:
p283
aVThe #pragma directive is a compiler specific directive which compiler vendors may use for their own purposes
p284
as(dp285
g28
V596781
p286
stp287
a((dp288
g2
(lp289
VSupposing you have , it looks like you want
p290
aV(Edited, sorry for the earlier min/max confusion
p291
as(dp292
g28
V596781
p293
stp294
a((dp295
g2
(lp296
VIt seems that the compilation linking order matters:
p297
aVgives
p298
aVbut
p299
aVgives
p300
aVand reversing  and  in the last case causes  and
p301
aVInteresting
p302
as(dp303
g28
V596781
p304
stp305
a((dp306
g2
(lp307
VAlright, given your additional description of the problem, perhaps something variadic like this will do:
p308
aVThe obvious restrictions here are that  has to work on all the value-types of the iterators, and that the ranges have to be equal
p309
aVThe function object is passed by reference, you can modify that to taste
p310
aVUpdate: If I misunderstood and you want  to operate on all values simultaneously, then you should get rid of  and just call  and make a function  that takes all those iterators
p311
as(dp312
g28
V596781
p313
stp314
a((dp315
g2
(lp316
VFirst off, your private variable should be declared as  and  needs parentheses
p317
aVNext, it's hard to give specific advice given how general and vague the question is, but in principle you could do something with inheritance:
p318
as(dp319
g28
V596781
p320
stp321
a((dp322
g2
(lp323
VIn general the answer is "you cannot"
p324
aVIn PDFs, for instance, you might have an embedded character map that lets you look up the characters corresponding to the glyphs (e
p325
ag99
aVif you used the cmap package with pdfLaTeX to make the the PDF), but glyphs are private to a font, and there may be many glyphs that get used for the same character and vice versa, thanks to the magic of the GSUB tables
p326
aVIf you're really desperate and have access to the font in question, you could try to build a character map yourself from the font file, but you better know which font you are currently looking at
p327
aVEdit: I think your question is tagged poorly; are you referring to this function
p328
aVPerhaps the FONTOBJ structure that you already own exposes some sort of character map of the font, I wouldn't know
p329
as(dp330
g28
V596781
p331
stp332
a((dp333
g2
(lp334
VYou could do something like this:
p335
aVIf  has non-trivial properties (custom constructors, pointers to heap variables, etc
p336
aV, this has lots of potential to cause trouble, but you can certainly access the raw data via those pointers
p337
aV(Doing this in general may be fun for instance if you want to look at the binary representation of a   or something like that, but in production code this should rarely come up
p338
aVIf your original object is , use the size
p339
aVEdit: Do you mean that you want this to work for an arbitrary type or for an unknown type
p340
aVIf you don't know the size of  (e
p341
ag99
aVif you are only handed the pointer), then of course you cannot do it because you don't know how much memory is occupied
p342
aVThere are no "field delimiters" or anything like that stored in memory that you could inspect at runtime
p343
as(dp344
g28
V596781
p345
stp346
a((dp347
g2
(lp348
VIgnoring that fact that the original design is insane, you could use  (or soon  to get a little bit of predictability:
p349
aVYou're still not guaranteed that  will be tightly packed, since there are no alignment guarantees for non- members
p350
aVYou could make a  and type-pun your way around, like  and  if you must, but that too would be extremely ugly
p351
aVIf you are in C++0x, I would definitely throw in a static assertion somewhere for
p352
as(dp353
g28
V596781
p354
stp355
a((dp356
g2
(lp357
VYou have to declare  before using it
p358
aVThe following might work
p359
aVUpdate: Ignoring a usable demonstration as requested, here's a way of structuring this (minus the definitions of member functions) that could work, but bear in mind that everything is private as it stands
p360
aVThen define the getter functions elsewhere:
p361
aVAlternative: forward-declare the nested class  and save one external definition:
p362
as(dp363
g28
V596781
p364
stp365
a((dp366
g2
(lp367
VJust say:
p368
aVSame for ,  etc
p369
as(dp370
g28
V596781
p371
stp372
a((dp373
g2
(lp374
VIf I understand correctly, you are given a finite range of values x, say , ,
p375
aV, , and a function , and you want to find the index  for which  is the largest possible
p376
aVIn that case, a simple search will do:
p377
aVHere  is the type such that  is
p378
as(dp379
g28
V596781
p380
stp381
a((dp382
g2
(lp383
VEverything you do currently results in a memory leak, since you never  anything
p384
aVFirst off, yes, make the dimensions variable
p385
aVSecond, either return a pointer to the newly allocated heap storage and remember to delete it in the caller, or return a smart container object
p386
aVA  would do nicely:
p387
as(dp388
g28
V596781
p389
stp390
a((dp391
g2
(lp392
VThere is a header  which defines a convenient complex number data type for you, all part of the standard library
p393
aVHere is the documentation
p394
as(dp395
g28
V596781
p396
stp397
a((dp398
g2
(lp399
VThe C standard library contains  (e
p400
ag99
aVsee here), with which you can register a signal handler for SIGINT (Ctrl-C)
p401
aVThat should do the trick, supposing your platform supports signals
p402
aVYou might also want to register a handler for SIGTERM to respond gracefully to being kill(1)ed
p403
aVAs suggested by Sam Miller, suppose your main loop is a single-threaded boost
p404
aVasio loop with some
p405
aVThen instead of the global flags you could (assuming  is visible) post a stop handler to the io service from within the signal handlers
p406
as(dp407
g28
V596781
p408
stp409
a((dp410
g2
(lp411
VTry something like this:
p412
aVIn general:
p413
aVCompile single source files with :
p414
aVThis creates object files
p415
aVLink all the object files to an executable (or shared library):
p416
aVYou can combine object files into a static library, which you treat just like a single object file when linking:Alternatively:The latter syntax (automatic library linking with ) requires either  or  to be findable in the library path (which you can amend with  at linktime)
p417
as(dp418
g28
V596781
p419
stp420
a((dp421
g2
(lp422
VIt is not a directed cycle
p423
aVHowever, if you permit consideration of the underlying undirected graph (by forgetting the orientations of the edges), then there is an undirected cycle
p424
aVIt all depends on which category you're interested in
p425
as(dp426
g28
V596781
p427
stp428
a((dp429
g2
(lp430
VIt should be
p431
aVYou have to take care of deletion manually, e
p432
ag99
aVcheck if  isn't already occupied (and delete if it is)
p433
aVFurther, the  function signature should read:
p434
aVBy the way, the STL comes with a nice  ;-)
p435
aVIt's hard to tell what you're actually asking, but going by the question title perhaps you have in mind a node structure like this:
p436
aVSuch a node would store its successor "by reference"; but you would have to initialize it with an existing node
p437
aV(There is no such thing as a "null" reference
p438
aVBy the Poultry-Oval Impasse, you cannot do this
p439
aVAlright, while you continue to refuse to post your full code, here is my almost literal copy/paste of your code which works fine with me:
p440
aVUpdate: I'm adding a feature to add a node at the end, which you might want
p441
aVCompile with
p442
aVFinally, here's the STL way of achieving the same thing:
p443
as(dp444
g28
V596781
p445
stp446
a((dp447
g2
(lp448
VAre you sure it's a textarea and not just an
p449
aVIf it's the latter, you can achieve the effect quite easily with padding:
p450
aVEdit: If it's a text area (say with one row), styling via padding works the same:
p451
as(dp452
g28
V596781
p453
stp454
a((dp455
g2
(lp456
VChange your loop:
p457
aVThere are probably better ways than reading byte by byte (e
p458
ag99
aVread the entire file, or read in chunks of 64kB)
p459
as(dp460
g28
V596781
p461
stp462
a((dp463
g2
(lp464
VHere's your set of four characters:
p465
aVNow we assemble a 32-bit unsigned integer:
p466
aVHere I assume that  is the least significant one; if you want to go the other way round, just swap the indices around
p467
aVLet's confirm:
p468
aVImportant: Make sure your original byte buffer is unsigned, or otherwise add explicit casts like ; otherwise the shift operations are not well defined
p469
aVWord of warning: I would strongly prefer this algebraic solution over the possibly tempting , which is machine-endianness dependent and will make your compiler angry if you're using strict aliasing assumptions
p470
aVAs was helpfully pointed out below, you can try and be even more portable by not making assumptions on the bit size of a byte:
p471
aVFeel free to write your own generalizations as needed
p472
aV(Good luck figuring out the appropriate  format string ;-)
p473
as(dp474
g28
V596781
p475
stp476
a((dp477
g2
(lp478
VLet's try:
p479
aVObserve that the map's  is always , so in your case it's  -- a pair whose first member is itself a pair
p480
aVWith that in mind you can alternatively use :
p481
aVFinally, as Sven points out, there may or may not be a comparison operator for pairs (I think there is, though); so if there isn't, you have to write one yourself
p482
aVLexicographic comparison on the two elements should do
p483
aVSophie awaits :-)
p484
aV(Here's the lexicographic pair comparison; you don't need to write this, it's already there:)
p485
as(dp486
g28
V596781
p487
stp488
a((dp489
g2
(lp490
VTry , which gives you a list of OpenSSL functions
p491
aVSomething like  might suit your needs; it depends if the certificate is in a file on disk or already in memory
p492
aVThere are lots of helper functions, one of them will do the trick
p493
aVAlso check out  for PEM handling routines
p494
aVEdit: Hm, maybe a combination of  and  (both available from ) lets you read a certificate from file and parse it
p495
as(dp496
g28
V596781
p497
stp498
a((dp499
g2
(lp500
VIf you're interested in the magic of Boost, check out Boost's stream filters which can be arbitrarily combined and cascaded; there's built-in support for gzip, DEFLATE (that's GZip minus the header) and bzip2
p501
aVVery handy
p502
as(dp503
g28
V596781
p504
stp505
a((dp506
g2
(lp507
VThe problem is that your s are floating, hence they're outside the normal flow
p508
aVYou need to make the subsequent elements
p509
aVA nice way to achieve this is by adding an invisible clearing block after the ambient element using CSS:
p510
as(dp511
g28
V596781
p512
stp513
a((dp514
g2
(lp515
VHow is T important
p516
aVEach server should generate 200/X messages per second, uniformly
p517
aVTo generate a schedule, draw 200/X samples from a uniform distribution on [0, 1) and time the messages accordingly (and repeat every second, or draw 200T/X samples from [0,T) right away)
p518
as(dp519
g28
V596781
p520
stp521
a((dp522
g2
(lp523
VThe special characters in reference SGML (hence HTML) are (as far as you need to know) ,  and
p524
aVIf you start with real-world text that you want to include in your mark-up, you have to replace precisely all of those by their entity or character references ( etc
p525
aVand you will be fine
p526
aV(Exceptions are if you are inside an CDATA marked section or an element with content type CDATA, but let us just assume that that's never the case
p527
as(dp528
g28
V596781
p529
stp530
a((dp531
g2
(lp532
VI believe that  can only be applied to an element node, but the result of  is surely going to be a list of nodes
p533
aVYou'll either have to pick one (
p534
aVor iterate over the collection (make sure it's not empty
p535
as(dp536
g28
V596781
p537
stp538
a((dp539
g2
(lp540
VWhy not make a , where  is a predicate that returns
p541
aVThen you can retrieve an  of all words of a given length
p542
as(dp543
g28
V596781
p544
stp545
a((dp546
g2
(lp547
VThis isn't the nicest way of doing it, but since you're asking: The return type of the template function  is , where the argument of the function is a (reference to an) array of size N of type
p548
aVTemplate argument deduction instantiates this template with the matching number N, and so  is just N, which is what you get
p549
aVA nicer version could be written as follows
p550
aV(You need C++0x for ; if you omit it, this will not be a constant expression
p551
aVUsage:
p552
aVUpdate: If you are in C++0x, here is another solution that gives a constexpr, thanks to decltype:
p553
as(dp554
g28
V596781
p555
stp556
a((dp557
g2
(lp558
VYou are currently saying this:
p559
aVTo use polymorphism, make the feeding function a virtual member of :
p560
as(dp561
g28
V596781
p562
stp563
a((dp564
g2
(lp565
VIf you are writing a binary file, you should think of a good way to serialize the actual binary data (64bit) of your
p566
aVThis could go from directly writing the content of the double to the file (minding endianness) to some more elaborate normalizing serialization schemes (e
p567
ag99
aVwith a well-defined representation of NaN)
p568
aVThat's up to you really
p569
aVIf you expect to be basically among homogeneous architectures, a direct memory dump would probably suffice
p570
aVIf you want to write to a text file and a are looking for an ASCII representation, I would strongly discourage a decimal numerical representation
p571
aVInstead, you could convert the 64-bit raw data to ASCII using base64 or something like that
p572
aVYou really want to keep all the precision that you have in your
p573
as(dp574
g28
V596781
p575
stp576
a((dp577
g2
(lp578
VI'm sure those font metrics are widely available
p579
aVFor instance, in my Ubuntu they're in  -- maybe you don't recognize some of the font names, but they're metrically compatible to Helvetica etc
p580
as(dp581
g28
V596781
p582
stp583
a((dp584
g2
(lp585
VIt's a bit like this:
p586
aVWhen Process 2 comes to life, the program exists twice, and the second process starts with the return of fork()
p587
aVSince the program is the same in both processes, the only way to distinguish which process you're in is by the return value of fork()
p588
as(dp589
g28
V596781
p590
stp591
a((dp592
g2
(lp593
VIf the built-in data types in C/C++ aren't sufficiently precise or have sufficient range for you for some reason, you may like to look at arbitrary precision numbers
p594
aVThose are data types which manage an arbitrary amount of memory to store numbers of, well, arbitrary precision
p595
aVFor integers that means numbers with arbitrarily many digits
p596
aVTypically this is extended to arbitrary rational numbers, i
p597
aVe
p598
aVquotients of integers
p599
aVMoreover, there are also arbitrary-precision floating point numbers (you specify the amount of memory you'd like to use) should you need those
p600
aVThe standard choice of library for C is GMP, which has all of those features, but if you have specific correctness requirements for floats, you may need the additional MPFR library, and finally there is also MPC to do the same for complex numbers
p601
as(dp602
g28
V596781
p603
stp604
a((dp605
g2
(lp606
VIf you have a reliable way to identify users when they cast votes (e
p607
ag99
aVusers must be registered to participate), then simply store in your database the information which user has voted for which images and don't accept any further votes (or just overwrite the results with the last vote)
p608
aVIf you don't identify users you will probably never get a reliable system, since a malevolent user might use multiple proxies etc
p609
aVto create votes for a particular image
p610
aVYou could also try to obfuscate the vote counting process by issuing a unique transaction identifier for each vote which is usable only once, but for which you keep the user and image association secret
p611
aVThen at least you cannot replay or fabricate a vote (though it doesn't prevent someone from just reloading the page loads and voting over and over again)
p612
as(dp613
g28
V596781
p614
stp615
a((dp616
g2
(lp617
VStrictly speaking you have to check the return value of the "insert" operation and ensure that  and  don't compare equal; otherwise  and erasing  invalidates
p618
aVBut in general see the previous answer, erasing an iterator invalidates only that iterator and no others
p619
aVExample:
p620
as(dp621
g28
V596781
p622
stp623
a((dp624
g2
(lp625
VYou need virtual inheritance to overcome the diamond-ambiguity:
p626
aVLong-winded explanation: Suppose you have this:
p627
aVThe inheritance of the virtual function  is ambiguous because it comes in three ways: from , from  and from
p628
aVThe inheritance diagram forms a "diamond":
p629
aVBy making the inheritance virtual,  etc
p630
aV, you allow any baseclass of  to call the correct member:
p631
aVWe must also define  for this to make sense, as otherwise  would not have a well-defined member
p632
aVSome more details: Suppose we now have a properly virtually-inheriting class  as above
p633
aVWe can access all the various virtual members as desired:
p634
aV 
p635
aVUpdate: As David says in the comment, the important point here is that the intermediate classes  and  inherit virtually so that further classes (in this case ) can inherit from them while simultaneously keeping the inheritance from  unambiguous
p636
aVSorry for the initial mistake and thanks for the correction
p637
as(dp638
g28
V596781
p639
stp640
a((dp641
g2
(lp642
VYou can simply move a stream position relative to the current position by using the  position argument:
p643
aVNegative values are also permitted
p644
aVSee e
p645
ag99
aVhere
p646
as(dp647
g28
V596781
p648
stp649
a((dp650
g2
(lp651
VYou are sorting the pointer values, not the myclass values
p652
aVYou have to write your own predicate to compare pointers by dereference:
p653
aVBy the way, I think you cannot sort  with  from  because it is not random access
p654
aVUse the member function  instead as MerickOWA says
p655
aV(But that's generally less efficient than sorting a random-access container
p656
aVAlternatively, you can immediately store your objects in a sorted container like , where  is the functor version of the predicate:
p657
as(dp658
g28
V596781
p659
stp660
a((dp661
g2
(lp662
VIf you are using MingW to compile C++ code on Windows, you may like to add the options  and  to link the C and C++ standard libraries statically and thus remove the need to carry around any separate copies of those
p663
aVVersion management of libraries is a pain in Windows, so I've found this approach the quickest and cleanest solution to creating Windows binaries
p664
as(dp665
g28
V596781
p666
stp667
a((dp668
g2
(lp669
VIf a preprocessor macro is already defined and you are sure that you don't need whatever it was originally, just redefine it conditionally:
p670
as(dp671
g28
V596781
p672
stp673
a((dp674
g2
(lp675
VEdit: Sorry, never mind this answer -- if you are certain only to be removing at most one element, then your loop is fine
p676
aVNever mind whether comparing by memory address is sensible, but to use  in a loop you have to write it a little differently to avoid incrementing an invalidated iterator:
p677
aVIf you have no other requirements than look-up by address, you could always just make a  or  of elements and implement  as pointer comparison
p678
aVEither way, there are certain conditions on types for them to be eligible as STL container members; as was asked in the comments, do those conditions apply to your  class
p679
aVOtherwise you could just make a container of  and use its inbuilt comparators, and for example make an
p680
as(dp681
g28
V596781
p682
stp683
a((dp684
g2
(lp685
VI'd say you just need  nanoseconds, this is at most 0
p686
aV1s and at least 0s
p687
aVAlternatively, try  with argument
p688
aV(I think  requires fewer CPU resources
p689
aV(Edit: Added "unsigned long long" literal specifier to ensure that the number fits
p690
aVSee comments below, and thanks to caf for pointing this out
p691
as(dp692
g28
V596781
p693
stp694
a((dp695
g2
(lp696
VJust spelling out Tomalak's answer:
p697
aVThe function object's work has to be accessed via the
p698
as(dp699
g28
V596781
p700
stp701
a((dp702
g2
(lp703
VIf you have five student names, you should declare an array of five:
p704
aVRemember that an array of N, , has valid members  up to
p705
as(dp706
g28
V596781
p707
stp708
a((dp709
g2
(lp710
VRemember that in C, the three types ,  and  are all distinct, and  expects a
p711
aVIf your  is defined as , you have conflicting types
p712
aVBest to use an actual , non
p713
as(dp714
g28
V596781
p715
stp716
a((dp717
g2
(lp718
VIn GCC you can try , see here and here, e
p719
ag99
aVThe results depend on your platform, though
p720
as(dp721
g28
V596781
p722
stp723
a((dp724
g2
(lp725
VThe copy constructor is a constructor, it creates an object
p726
aVIn particular, the copy constructor creates an object which is semantically identical to another, already existing object, of which it makes a "copy":
p727
aVThe assignment operator isn't a constructor at all, but an ordinary member funcion that can only be invoked on an existing object
p728
aVIts purpose is to assign to your object the semantics of another object, so that after the assignment the two are semantically identical
p729
aVYou are not usually "overloading" the assignment operator, you are just defining it
p730
aVNote that if it makes sense to compare to objects (with ), then both copy construction and assignment should behave so that we have equality afterwards:
p731
aVYou are not forced to guarantee this, but users of your class will usually assume this behaviour
p732
aVIn fact, the compiler assumes that  entails
p733
aVLastly, as a final aside and as said elsewhere, note that  literally means  (copy construction), and never
p734
aVThat's syntactic sugar to allow you to write naturally-looking code without compromising efficiency (or even correctness, as your class may not even be default-constructible)
p735
as(dp736
g28
V596781
p737
stp738
a((dp739
g2
(lp740
VIf you are specifying a literal constant, you must use the appropriate type specifier:
p741
as(dp742
g28
V596781
p743
stp744
a((dp745
g2
(lp746
VThere is no template typedef in C++98, but you can wrap the genericity into a helper struct
p747
aVThe example code shows both your own version and my generic version side by side
p748
as(dp749
g28
V596781
p750
stp751
a((dp752
g2
(lp753
VMargin describes the space between your box and adjacent boxes
p754
aVBoxes that are positioned relatively (i
p755
ag598
aVthat are part of the normal flow) will keep the sufficient space between them that each one's "margin" requirements are met (called "margin collapsing")
p756
aVand  on the other hand are positional attributes that specify where your box is located; for absolutely positioned boxes the values are taken relative to the nearest containing box which is itself absolutely positioned
p757
aVThe top/left/bottom/right attributes specify the location of the respective edge of your box including its margin
p758
aVIn short, the two are entirely different concepts
p759
aVFor normally flowed boxes you should use  to control the spacing between neighbouring boxes
p760
as(dp761
g28
V596781
p762
stp763
a((dp764
g2
(lp765
VHow about string comparison
p766
aVstrncmp only compares the first n characters; we pass the count via
p767
as(dp768
g28
V596781
p769
stp770
a((dp771
g2
(lp772
VYou appear to be linking against libraries in a custom library directory,
p773
aVCheck where your loader looks for the executable's libraries:
p774
aVIf any of them are in non-standard directories (and  indicates that a particular library couldn't be found), append those to the LD_LIBRARY_PATH:
p775
aVIf you like, you can hardcode the library path into the executable with the  linker option, e
p776
ag99
as(dp777
g28
V596781
p778
stp779
a((dp780
g2
(lp781
VYour entire loop is totally redundant
p782
aVWhy not just this:
p783
aVYou can use  directly as a counter in the loop
p784
as(dp785
g28
V596781
p786
stp787
a((dp788
g2
(lp789
VYou cannot magically extend the file from the middle
p790
aVPerhaps easiest to write to a new file: First copy the initial segment, then write your new data, then copy the remaining segment
p791
aVWhen all is done, you can overwrite the original file
p792
as(dp793
g28
V596781
p794
stp795
a((dp796
g2
(lp797
VI think your problem is that  is uninitialized in your
p798
aVI'm reluctant to give a partial answer, since I took the code and fiddled with it a bit, so here's my version which appears to work (and also prints "0" correctly):
p799
aVUpdate: I couldn't resist making several structural improvements
p800
aVI didn't touch your multiplication routine, so you should still be able to extract the bugfix even if you don't care for the rest
p801
aVThe string assignment is still broken for strings with more than one digit, but that wasn't your question I suppose
p802
as(dp803
g28
V596781
p804
stp805
a((dp806
g2
(lp807
VCheck out this website
p808
as(dp809
g28
V596781
p810
stp811
a((dp812
g2
(lp813
VA linked list would be a good approach since you don't need to move all the intermediate elements around
p814
aVworks just fine, combined with
p815
aVYou will need an iterator to the element you want to move to the front:
p816
aV(Using the pretty printer for a quick demo
p817
aVAs others have said, whether that's more efficient that a random-access container depends on how you are tracking the element that you want to move
p818
aVUpdate: In light of Steve's remarks I should like to offer a raw C-array solution, too
p819
aVIt has the benefit that you can access it by position in O(1) time and that it requires minimum space:
p820
aVThe  call could be wrapped in a function:
p821
as(dp822
g28
V596781
p823
stp824
a((dp825
g2
(lp826
VYou cannot initialize members of structs like that, but you can initialize them at instantiation time, or write an initializing function:
p827
aV(If this were C++0x, you could initialize struct members in the default constructor's base initializer list, even arrays
p828
as(dp829
g28
V596781
p830
stp831
a((dp832
g2
(lp833
VInheritance is a property of types, not of objects
p834
aVThe type "Derived" inherits from the type "Base"
p835
aVYou can make objects of type "Derived" (), and you can also make objects of type "Base" (, unless that's forbidden), but each of those objects are complete, fully-fledged objects with no "replaceable parts"
p836
aVThe point of type inheritance is that you may treat an object of type "Derived" as if it was an object of type "Base" (as long as you refer to it by reference or pointer), that is, if you have a function , then you may call
p837
aVBut  can only access those parts of  which are inherited from "Base"
p838
as(dp839
g28
V596781
p840
stp841
a((dp842
g2
(lp843
VIf you have a class that contains a member that is a pointer,
p844
aVthen upon destruction of a  object, nothing happens other than that the pointer, along with its containing object, goes out of scope
p845
aVIt's the same as what happens to  at the end of the following function:
p846
aVWhat you may have meant to ask about is "what happens to the object to which the pointer points"
p847
aVThat's an entirely different question, and the answer is "nothing"
p848
aV(So usually when you have a class that contains a pointer member you should think carefully about who owns any resources that may need to be cleaned up
p849
aVSince you mention the word "destructor" in your question, let us spell out once and for all:
p850
aVA pointer type object has no destructor
p851
aVWhen a pointer goes out of scope, there is no automatic invocation of
p852
as(dp853
g28
V596781
p854
stp855
a((dp856
g2
(lp857
VTo answer your literal question from the title: You cannot write a new copy constructor for the existing class template
p858
aVNext, are you sure that you really want to implement the entire (binary tree) structure of a map with O(log n) lookup again for your container with the added memory management considerations of a  (think about objects with custom deleters)
p859
aVWhy not simply put s into your map
p860
aVUpdate: Could you use Boost's pointer containers
p861
aVOr do you need your values to be pointers, too
p862
aVHow about a  with values
p863
as(dp864
g28
V596781
p865
stp866
a((dp867
g2
(lp868
VYou don't create any objects of type "Base" -- by giving Base a pure-virtual member, you are explicitly saying that this class cannot exist by itself, but only through derived classes
p869
aVWhat you do want to create are pointers or references to Base:
p870
aVThen you can use polymorphism by treating  and  uniformly without needing to know the concrete type of  and
p871
as(dp872
g28
V596781
p873
stp874
a((dp875
g2
(lp876
VPersonally, I'd prefer using static class members over functions for this sort of thing:
p877
aVUpdate: Using ildjarn's suggestion, here's the less verbose version:
p878
as(dp879
g28
V596781
p880
stp881
a((dp882
g2
(lp883
VArguably if your entire class hierarchy is POD or has nothing for the destructors to do, you might get away with not having a virtual destructor
p884
aVHowever, as soon as you want to derive other classes from your class and want to use them polymorphically through pointer/reference-to-base, you will have virtual functions anyway, so there is little overhead adding a virtual destructor, and you never know who will be inheriting from you
p885
aVAs soon as any derived class requires a non-trivial destructor and may be refered to via pointer-to-base, you must have a virtual destructor
p886
aVRule of thumb: if you have any virtual functions, add a virtual destructor
p887
aV(The point here is that if you have no virtual functions, then there will be no way to use derived classes polymorphically, so it will be less likely that an illegitimate child class that requires non-trivial destruction will be deleted via a base class pointer
p888
aVIt could still be done, it's just less likely
p889
as(dp890
g28
V596781
p891
stp892
a((dp893
g2
(lp894
VIf you want to save yourself writing all those classes yourself (and violating the double-underscore rule
p895
aV, you could consider just using a
p896
aVand using
p897
aVPairs are by default lexicographically compared (which is what you asked for), so you don't need any extra code
p898
as(dp899
g28
V596781
p900
stp901
a((dp902
g2
(lp903
VThe direct casts  and  don't really work differently at all: They both read as many characters from the string as they can interpret as a number of the respective type
p904
aVFor "0x4B0", the int-conversion reads "0" (OK), then "x" and stops, because it cannot convert "x" into an integer
p905
aVLikewise for the float-conversion
p906
aVFor "1
p907
aV2e3", the int-conversion reads "1" (OK), then "
p908
aVand stops
p909
aVThe float-conversion recognises the entire string as valid float notation
p910
aVThe automatic type recognition for an expression like  is simply more flexible than the explicit casts
p911
aVThe explicit casts require the integers and floats to be in the format produced by  and  in , essentially
p912
aVPerhaps you can use intval and floatval rather than explicit casts-to-int for more flexibility, though
p913
aVFinally, your question "is hexidecimal data supposed to be valid or invalid numeric data
p914
aVis awkward
p915
aVThere is no such thing as "hexadecimal data"
p916
aVHexadecimal is just a number base
p917
aVWhat you can do is take a string like "4B0" and use  etc
p918
aVto parse it as an integer in any number base between 2 and 36
p919
aV[Sorry, that was BS
p920
aVThere's no  in PHP
p921
aVBut  has the equivalent functionality, see above
p922
as(dp923
g28
V596781
p924
stp925
a((dp926
g2
(lp927
VYou should add a test of the kind  to catch this
p928
aVApparently  with second argument 0 always matches, e
p929
ag99
aVtranslates into SQL , rather than , and  is short-hand for  -- the opposite of what you wanted :-)
p930
aVRunning this test at the beginning saves you a full database query when you're passed an argument that will necessarily result in
p931
as(dp932
g28
V596781
p933
stp934
a((dp935
g2
(lp936
VIn short: you cannot
p937
aVMuch like you cannot "load an HTML page in a browser" without making the browser load all the linked resources (images, stylesheets)
p938
aVIt's up to the browser how it implements its s, but most browsers treat them like embedded separate websites that are treated just like ordinary websites in terms of loading linked resources
p939
aVWhat is it you are actually trying to do
p940
as(dp941
g28
V596781
p942
stp943
a((dp944
g2
(lp945
VYou are allocating memory in your insert operation, does that ever get deallocated properly
p946
aVI should recommend using STL containers which minimize the amount of code you have to write:
p947
aVThis should have all the functionality you need with built-in memory safety
p948
aVIn C++98, use  and  etc
p949
as(dp950
g28
V596781
p951
stp952
a((dp953
g2
(lp954
VOn x86/x64 architectures it is common for compilers to promote all 32-bit floats to 64-bit doubles for computations; check the output assembly to see if the two variants produce the same instructions
p955
aVThe only difference between the types is the storage
p956
as(dp957
g28
V596781
p958
stp959
a((dp960
g2
(lp961
VGCC with option  already covers a pretty good subset of C++0x
p962
aVVersion 4
p963
aV4 is already pretty usable, 4
p964
aV6 even moreso
p965
aVIt's missing template aliases, but many extremely useful language features as well as a very large part of the library is there and fully functional
p966
aVHere is the full feature list
p967
as(dp968
g28
V596781
p969
stp970
a((dp971
g2
(lp972
VYou never throw a C++ exception by accessing invalid memory
p973
aVYou are just giving an example of the general idea of referencing an arbitrary memory location
p974
aVI could do the same like this:
p975
aVHere I am simply treating 123456 as the address of a double and write to it
p976
aVAny number of things could happen: 1)  might in fact genuinely be a valid address of a double, e
p977
ag99
aV2)  might point somewhere inside allocated memory and I just overwrite 8 bytes in there
p978
aV3)  points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it
p979
aV4) You win the lottery
p980
aVThe way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion
p981
aVNobody will automatically check the semantic validity of memory addresses like that for you during normal program execution
p982
aVHowever, a memory debugger such as  will happily do this, so you should run your program through it and witness the errors
p983
as(dp984
g28
V596781
p985
stp986
a((dp987
g2
(lp988
VThe point is that most filesystems other than NTFS store their filenames in byte-strings
p989
aVThere is usually no explicit notion of encoding, but the filenames have to be strings of non-zero bytes terminated by a zero
p990
aVSo on all such systems, filesystem functions just take  arguments for filenames, and you have to figure our yourself how to handle encoding issues (should there be any)
p991
aVWindows is special because filenames in NTFS are null-terminated strings of 16-bit units
p992
aVThis goes hand-in-hand with the 16-bit  type on Windows and various  filesystem functions
p993
as(dp994
g28
V596781
p995
stp996
a((dp997
g2
(lp998
VAgreed with Armen that it's generally OK
p999
aVI would probably make a map with triples as keys and a set of indices as values:
p1000
aVAnd then:
p1001
aVThen every  in  is such that  equals
p1002
as(dp1003
g28
V596781
p1004
stp1005
a((dp1006
g2
(lp1007
VYou cannot turn a string into PHP source code
p1008
aV(At least you shouldn't
p1009
aVTry this:
p1010
as(dp1011
g28
V596781
p1012
stp1013
a((dp1014
g2
(lp1015
VThe  directive is a preprocessor directive; the preprocessor replaces those macros by their body before the compiler even sees it
p1016
aVThink of it as an automatic search and replace of your source code
p1017
aVA const variable declaration declares an actual variable in the language, which you can use
p1018
aVwell, like a real variable: take its address, pass it around, use cast it, convert it, etc
p1019
aVOh, performance: Perhaps you're thinking that avoiding the declaration of a variable saves time and space, but with any sensible compiler optimisation levels there will be no difference, as constant values are already substituted and folded at compile time
p1020
aVBut you gain the huge advantage of type checking and making your code known to the debugger, so there's really no reason not to use const variables
p1021
as(dp1022
g28
V596781
p1023
stp1024
a((dp1025
g2
(lp1026
VTake a look at the  part of the standard library (e
p1027
ag99
aVsee here
p1028
as(dp1029
g28
V596781
p1030
stp1031
a((dp1032
g2
(lp1033
VYou might find useful resources on the ConceptsGCC website
p1034
aVThat's the compiler (forked off GCC) which they were building to see if the concept (pardon the pun) was feasible
p1035
aVI imagine the expense comes from having to perform thorough and ubiquitous and recursive validity checks on all sorts of language constructs, and given that you could specify a pretty rich set of constraints, checking for those can get very expensive
p1036
aVA bit like a nightmare version of exception specifications
p1037
as(dp1038
g28
V596781
p1039
stp1040
a((dp1041
g2
(lp1042
V is a pointer, as others have said, but it's much better and more correct to use the base initializer list:
p1043
aVThat way,  gets initialized to the right value, rather than first default-initalized and then assigned
p1044
aVFor more general member objects this may in fact be the only legitimate way to initialize them
p1045
as(dp1046
g28
V596781
p1047
stp1048
a((dp1049
g2
(lp1050
VOn your platform,  is only 8 bits wide, so  shifts the 1 out the left end when you assign it back to the narrow
p1051
aVIn the  call, on the other hand,  is first promoted to an integer (which is wider than 8 bits on your platform) and thus the bit survives
p1052
as(dp1053
g28
V596781
p1054
stp1055
a((dp1056
g2
(lp1057
VMany good answers, but I feel that there's something missing regarding "why we need to allocate memory"
p1058
aVI think it is important to know how the control flow of a computer program works at the lowest level, since C and C++ are relatively thin layers of abstraction over the hardware
p1059
aVWhile it is possible to write a program in one huge global scope with ifs and gotos alone, most real-world programs are split into functions, which are separate, movable modules which can call each other at will
p1060
aVTo keep track of all the data (arguments, return value, local variables), all this data is put on a one-dimensional, contiguous area of memory called the stack
p1061
aVCalling a function puts stuff on the stack, and returning from a function pops the data back off, and the same area of memory is overwritten by the next function call
p1062
aVThat way, all function code can be stored abstractly by just remembering offsets to local data relative to its entry point, and the same function can be called from many different contexts -- the function's local variables may be at different absolute addresses, but they're always at the same relative position relative to the function's entry address
p1063
aVThe fact that the stack memory is constantly overwritten as functions get called and return means that you cannot place any persistent data on the stack, i
p1064
ag598
aVin a local variable, because the memory for the local variables is not kept intact after the function returns
p1065
aVIf your function needs to store persistent data somewhere, it must store that data somewhere else
p1066
aVThis other location is the so-called heap, on which you manually (also called "dynamically") request persistent storage via  or
p1067
aVThat area of memory lies elsewhere and will not be recycled or overwritten by anyone, and you may safely pass a pointer to that memory around for as long as you like
p1068
aVThe only downside is that unless you manually tell the system that you're done, it won't be able to use the memory for anything else, which is why you must manually clean up this dynamically allocated memory
p1069
aVBut the need for functions to store persistent information is the reason we need to allocate memory
p1070
aV(Just to complete the picture: local variables on the stack are said to be "automatically allocated"
p1071
aVThere is also "static allocation", which happens at compile time and is where global variables live
p1072
aVIf you have a global , you may happily read from and write to that from anywhere in your program
p1073
as(dp1074
g28
V596781
p1075
stp1076
a((dp1077
g2
(lp1078
VAs you say, your operating system frees all the memory your program had used when the program terminates, so in principle you don't have to worry about that
p1079
aVOne might even argue that the OS does the job faster in one go than you could do it piece by piece
p1080
aVIf you know exactly which global objects you leave dangling at the end, then that's absolutely fine
p1081
aVIt might just be good practice to always write code that terminates completely cleanly to avoid overlooking actual leaks; it just depends on your confidence in your code
p1082
as(dp1083
g28
V596781
p1084
stp1085
a((dp1086
g2
(lp1087
VA scheduled task like this should be set up as a separate  or  job
p1088
aVYou can still write everything in PHP, just make a script that runs from the command line and does the updating
p1089
aVCheckout "man crontab" for details, and/or check which scheduling services your server is running
p1090
as(dp1091
g28
V596781
p1092
stp1093
a((dp1094
g2
(lp1095
VWhat is a meaningful semantic of "remember me" if "logout" cannot undo it
p1096
aVUsually "remember me" means that the user comes back without needing to authenticate again, so an explicit "logout" should definitely destroy the "remembered" session and require authentication again
p1097
as(dp1098
g28
V596781
p1099
stp1100
a((dp1101
g2
(lp1102
VAny number of things can happen to the three standard file descriptors 0, 1 and 2
p1103
aVAnyone can launch a new process with the file descriptors attached to anything they like
p1104
aVFor instance, GNU screen puts the output into a pipe and allows dynamic reattaching of a session
p1105
aVSSH takes the output and returns it to the other end
p1106
aVAnd of course all the numerous shell redirectors regularly make use of manipulating the file descriptors
p1107
as(dp1108
g28
V596781
p1109
stp1110
a((dp1111
g2
(lp1112
VYou're not allowed to do that, and your compiler shouldn't let you
p1113
aVYou can have multiple definitions of a non-static inlined function only if all the definitions are identical (but never more than one definition per TU)
p1114
aVThis will necessarily happen for inlined functions defined in header files
p1115
aVFor static linkage each TU can have a different definition, but you can still only have one definition per TU
p1116
aV(Sorry for the multiple edits
p1117
as(dp1118
g28
V596781
p1119
stp1120
a((dp1121
g2
(lp1122
VSounds like you need an expression like this:
p1123
aVPosix allows for the more self-descriptive version:
p1124
aVIf you're willing to admit underscores, too, search for entire words ():
p1125
aV(Thanks to Alan for pointing out several of my failings
p1126
as(dp1127
g28
V596781
p1128
stp1129
a((dp1130
g2
(lp1131
VFloating point numbers on your platform cannot exactly represent numbers which do not have a finite binary expansion, so you will naturally have uncertainty when using those numbers
p1132
aVUse rationals instead and keep "0
p1133
aV1" as "1/10" when possible
p1134
aV("Finite binary expansion" means "finite sum of powers of two"
p1135
aV1/5 is not a finite sum of powers of 2, and neither is 1/3 nor 1/10
p1136
as(dp1137
g28
V596781
p1138
stp1139
a((dp1140
g2
(lp1141
VFloating point numbers in most architectures (which use IEEE754 representation) can only represent numbers extactly which have a finite binary expansion, i
p1142
ag598
aVwhich are exactly represented by a number like  (and the length of the string is limited by the size of the floating point type, e
p1143
ag99
aV53 for )
p1144
aVAny number which is not of this form, i
p1145
ag598
aVwhich is not a finite sum of powers of two, such as 1/3 or 1/5 or 1/10, can never be expressed exactly by a such floating point variable
p1146
aVSince users often enter values like , rather than the more apt , this loss of exactness is often encountered quite early on in settings such as yours
p1147
aVMultiplying by that constant of yours is one way that the author on his platform found to get closer to what he thought the user intended
p1148
aVIt's all subjective, though
p1149
aVIf you just print with short precision, , you shouldn't notice the lack of exactness
p1150
as(dp1151
g28
V596781
p1152
stp1153
a((dp1154
g2
(lp1155
VMost likely you're not using the correct encoding
p1156
aVIf you already know your output encoding, use the  argument of the  function
p1157
aVIf you haven't settled on an internal encoding yet, take a look at the iconv functions;  might be a good start
p1158
as(dp1159
g28
V596781
p1160
stp1161
a((dp1162
g2
(lp1163
VTo answer your question why it is "undetected": Most C compilers do not analyse at compile time what you are doing with pointers and with memory, and so nobody notices at compile time that you've written something dangerous
p1164
aVAt runtime, there is also no controlled, managed environment that babysits your memory references, so nobody stops you from reading memory that you aren't entitled to
p1165
aVThe memory happens to be allocated to you at that point (because its just part of the stack not far from your function), so the OS doesn't have a problem with that either
p1166
aVIf you want hand-holding while you access your memory, you need a managed environment like Java or CLI, where your entire program is run by another, managing program that looks out for those transgressions
p1167
as(dp1168
g28
V596781
p1169
stp1170
a((dp1171
g2
(lp1172
VYou could try something like this (but note that  isn't strictly portable):
p1173
aVI don't know , but if it's like a  then you can append null-terminated C-strings simply with the  operator
p1174
as(dp1175
g28
V596781
p1176
stp1177
a((dp1178
g2
(lp1179
VYou can probably leverage the Windows API function  to give you the short name
p1180
aVYou cannot "compute" the name algorithmically as there is no one-to-one correspondence between an arbitrary long name and a short name, and I don't think you can avoid using the Windows API for the translation
p1181
as(dp1182
g28
V596781
p1183
stp1184
a((dp1185
g2
(lp1186
VYou are not incrementing your iterator
p1187
aVChange your  loop to a  loop like so:
p1188
aV(Also  dereferences to a pointer, like the other answers have pointed out
p1189
as(dp1190
g28
V596781
p1191
stp1192
a((dp1193
g2
(lp1194
VEdit: Sorry, old answer was BS
p1195
aVJust say:
p1196
aVThe point of the default constructor is that it's invoked by default, so you don't need to specify it
p1197
aVBut even if you had a non-default constructor, what you did is inefficient; don't use the copy constructor but construct directly:
p1198
as(dp1199
g28
V596781
p1200
stp1201
a((dp1202
g2
(lp1203
VIf you know your target encoding, you can use the Posix-standardized  library (which is available for Windows, too) and convert from WCHAR_T or UTF-16 to your target encoding; iconv has a "transliterate" option which might turn all those special-needs characters of yours into their ASCII transliterates
p1204
aVIconv is a bit lighter-weight than ICU and pretty widely available
p1205
as(dp1206
g28
V596781
p1207
stp1208
a((dp1209
g2
(lp1210
VThere is always just one constructor call, and always of the actual, concrete class that you instantiate
p1211
aVIt is your responsibility to endow each derived class with a constructor which calls the base classes' constructors if and as necessary, as you did in 's constructor
p1212
aVUpdate: Sorry for missing your main point
p1213
aVThanks to ildjarn
p1214
aVHowever, your  inherits virtually from
p1215
aVAccording to the standard (10
p1216
aV1
p1217
aV4 in the FIDS), "for each distinct baseclass that is specified virtual, the most derived object shall contain a single base class subobject of that type"
p1218
aVIn your case this means that when constructing the base, your class  immediately calls 's default constructor, not 's
p1219
as(dp1220
g28
V596781
p1221
stp1222
a((dp1223
g2
(lp1224
VI think you are looking for
p1225
as(dp1226
g28
V596781
p1227
stp1228
a((dp1229
g2
(lp1230
VHave you tried the Wikipedia article
p1231
aVThere are only two C++ ISO standards to date, C++98 and C++03
p1232
aVEverything beyond that is not yet finalized and collectively referred to as "C++0x"
p1233
aVIt is expected to become a standard in 2011 or 2012, which is why some people already call it "C++11", but that's premature
p1234
aVThere are also two ISO C standards, C90 and C99
p1235
aVC90 is essentially equivalent to ANSI C89
p1236
as(dp1237
g28
V596781
p1238
stp1239
a((dp1240
g2
(lp1241
VThis is one attempt to mitigate the security issues you get from allowing arbitrary foreign code to run in your browser: The script (which we assume could come from a malicious attacker) does not get to see (and possibly communicate back via AJAX) information about your local files
p1242
aVImagine what could happen if a script could just freely set file uploads and submit forms
p1243
aVThis behaviour concerning file upload controls and scripting is mandated by some sort of standard (I believe part of the DOM specification) for this very reason
p1244
as(dp1245
g28
V596781
p1246
stp1247
a((dp1248
g2
(lp1249
VYou could essentially rewrite C++ in C, to whichever level of detail you need
p1250
aVYou could start with making the linked list's data type a  to some wrapper structure which itself could contain a type identifier and a void pointer to the actual data
p1251
aVYou could write your own vtable to allow for polymorphism, and you could add reference counting and memory management
p1252
aVnone of that is magic, so if you really need that sort of generality, you could certainly write it all in C
p1253
aVOr just use C++ :-)
p1254
as(dp1255
g28
V596781
p1256
stp1257
a((dp1258
g2
(lp1259
VFilenames do not have a notion of encoding
p1260
aVYou have to figure out the filename by other means
p1261
aVThe only important point for your situation is that in most filesystems a filename is a null-terminated *byte*string, but in NTFS it is a null-terminated 16-bit-string
p1262
aVConsequently, you cannot use the standard -type functions to access all possible NTFS filenames
p1263
aVHowever, if you have obtained the NTFS filename of an existing file by other means, you can use the Windows API function  to obtain the short name of the file, which you can use in
p1264
aVI don't know if PHP lets you access Windows API functions, though, but perhaps someone has written a module or plugin for that
p1265
as(dp1266
g28
V596781
p1267
stp1268
a((dp1269
g2
(lp1270
VI strongly recommend using  or  for fine-grained access to high-quality PRNG classes which you can instantiate one in each thread with full control over their seeds and thus their resulting sequence of random numbers
p1271
as(dp1272
g28
V596781
p1273
stp1274
a((dp1275
g2
(lp1276
VI don't know why you'd think the number of loop iterations would matter
p1277
aVLet's see
p1278
aVSuppose you write this:
p1279
aVIf  gets inlined, then essentially the compiler treats your code as though you had written:
p1280
aVSo the code only gets replaced at the call site, once
p1281
aV(It's a separate matter entirely whether loop unrolling is happening
p1282
as(dp1283
g28
V596781
p1284
stp1285
a((dp1286
g2
(lp1287
VHere is a little discussion I started a while ago on this subject
p1288
aVBasically, I would personally distinguish two separate paths on encoding handling:
p1289
aVOne is an encoding-agnostic, "internally portable" path that using  to convert the external multibyte data from  and convert it into an internal, fixed-width wide string, all without ever talking about encodings
p1290
aVThe other is a fixed-encoding, serializable path that deals with data that ships in deterministic encodings
p1291
aVTo translate among those, the Posix  library does the trick
p1292
aVYou can bridge between the two paths by using 's special WCHAR_T encoding
p1293
aVSince the situation that you describe requires you to read serialized, deterministic data, I would suggest using iconv to convert FROM UTF8 (which you know you have) and convert TO WCHAR_T, which you can then treat with your standard C wide string functions (but don't make assumptions about the actual encoding)
p1294
aVIf you need to print data to the console, you can always  from your internal wide strings to a multibyte representation (the details of which are again not of your concern) that the console told you it wants
p1295
as(dp1296
g28
V596781
p1297
stp1298
a((dp1299
g2
(lp1300
VThe test functions need a hyphen in front of the option:
p1301
aVNote that  is just an ordinary command, usually in , and it has to be treated as such
p1302
as(dp1303
g28
V596781
p1304
stp1305
a((dp1306
g2
(lp1307
VVS10's version uses rvalue references and move semantics when possible, so in principle it has the upper hand over the Boost C++98 implementation
p1308
aVYou'd probably have to work fairly hard to create a program that would show a significant practical difference, though
p1309
aVbut do give it a try
p1310
aVAlso don't forget about , which is new in C++0x thanks to forwarding
p1311
aVUpdate: Dereferencing and copying are going to be practically identical in any case
p1312
aVPerhaps there are some interesting differences in the way custom deleters and allocators are stored, and in how make_shared is implemented
p1313
aVLet me check the source
p1314
aVUpdate 2: Funnily enough, the Boost version that uses variadic templates and rvalue references definitely looks better than the VS10 version, since VS10 doesn't have variadic templates and has to employ horrible black arts to fake that behaviour
p1315
aVBut that's entirely a compile-time issue so it's not relevant
p1316
as(dp1317
g28
V596781
p1318
stp1319
a((dp1320
g2
(lp1321
VIf you have an array like this,
p1322
aVthen you can just scrape off the first n bits into an integer like so:
p1323
aVI'm assuming that , feel free to generalize the code if you like
p1324
aVAlso the size of the array times 8 must be at least
p1325
as(dp1326
g28
V596781
p1327
stp1328
a((dp1329
g2
(lp1330
VTechnically,  is a function pointer pointing to "foo", but you don't really see this in Javascript
p1331
aVYou should really just write:
p1332
aVAs others have pointed out, your assignment makes the  function "live" only in the scope of , so when  goes out of scope, the function object could in principle be cleaned up
p1333
aVIf you have a really compelling reason to do that then use the function pointer, but otherwise you can just keep the function global
p1334
as(dp1335
g28
V596781
p1336
stp1337
a((dp1338
g2
(lp1339
VErr
p1340
aVone at a time
p1341
aVThe '&' is not part of the name of the  function, but rather the return type of the function is , i
p1342
ag598
aVa reference to a set
p1343
aVHaving a reference return type allows you "concatenate" function calls:
p1344
aVIn the implementation of , the return statement is usually  to make this possible
p1345
aVActually, (3) is sort of in the same vein
p1346
aVTo use the  operator, you add an overload to the global :
p1347
aVAgain, by returning a reference, the result of a  operation is again an object of the same type so you can call the  operator again
p1348
as(dp1349
g28
V596781
p1350
stp1351
a((dp1352
g2
(lp1353
VYou should add a unique key for the pair , e
p1354
ag99
aVsee here
p1355
as(dp1356
g28
V596781
p1357
stp1358
a((dp1359
g2
(lp1360
VThe  directive is scoped, so it'll be in effect only within the scope in which it appears
p1361
aVUse it wherever it is most appropriate for your situation
p1362
as(dp1363
g28
V596781
p1364
stp1365
a((dp1366
g2
(lp1367
VYou have to implement the constructor of
p1368
aVTry  instead of the current
p1369
as(dp1370
g28
V596781
p1371
stp1372
a((dp1373
g2
(lp1374
VProbably not
p1375
aVyou need to escape your raw text for each purpose separately for which you are going to use it:
p1376
aVFor GET requests, use
p1377
aVFor HTML output, use
p1378
aVFor calling as a command via , use
p1379
aVFor passing arguments to a command via : use
p1380
aVFor passing a database parameter: use
p1381
aVThere's no "universal" solution for magically escaping text
p1382
aVKeep raw text internally, and escape it for the appropriate purpose
p1383
as(dp1384
g28
V596781
p1385
stp1386
a((dp1387
g2
(lp1388
VPerhaps something like this:
p1389
aVYou still have to define your  class to do something useful with the variadic parameters, e
p1390
ag99
aVimplement your tuple of vectors
p1391
aV(why not a vector of tuples, though
p1392
aVCredits to brunocodutra for the tuple trick
p1393
as(dp1394
g28
V596781
p1395
stp1396
a((dp1397
g2
(lp1398
VQuoting from the deprecated Opera website:
p1399
aVInternational text and fonts
p1400
aVOpera Mini supports internationalization, including the full range of character sets supported by Opera in addition to Unicode
p1401
aVHowever this is dependent on font support in the phone which commonly is limited
p1402
aVBidirectional text is not supported in Opera Mini
p1403
aVSo it looks like boils down to font support for Indic scripts, but for your Hebrew and Arabic needs you will probably be disappointed
p1404
aVEdit: According to a quick internet search, there is an option  in  which allows some sort of server-side rendering of complex scripts
p1405
as(dp1406
g28
V596781
p1407
stp1408
a((dp1409
g2
(lp1410
VAs Dagon says, all session data typically resides on the server
p1411
aVHowever, there are still a few pitfalls
p1412
aVFirst off, in many configurations session variables are stored in  and owned by the web server process's owner
p1413
aVIn a shared hosting situation, it is conceivable that other users on the shared host manage to access the session data
p1414
aVSecond, you can configure your own session handler, e
p1415
ag99
aVto store session data in a database
p1416
aVIn that case, all the security concerns of that implementation have to be taken into account as well
p1417
aVBest not to store credit card data in the session data; just write it to a safe location and retrieve it by some sensible mechanism (e
p1418
ag99
aVdatabase lookup) when actually needed
p1419
as(dp1420
g28
V596781
p1421
stp1422
a((dp1423
g2
(lp1424
VUse the  SQL function
p1425
aVInstead of , say
p1426
aVYou can configure the date formatting freely in analogy to  on Linux
p1427
aVThe inverse function is
p1428
as(dp1429
g28
V596781
p1430
stp1431
a((dp1432
g2
(lp1433
VThere is no such thing as you propose
p1434
aVIt is up to the client (i
p1435
ag598
aVthe web browser) how to handle HTTP responses, and in particular how to deal with non-displayable content (such as your )
p1436
aVMost browsers will offer a download option, but there is no requirement that this be of any particular form
p1437
aVPassing a suggested file name as you do is about as much as current browsers will interpret
p1438
aVOf course there could always be a custom-made browser somewhere that will accept additional header information, but no widespread browsers currently do
p1439
aVBear in mind that in general we do not want to expose any information about the client's environment to the internet, so even suggesting something like a download path could be seen as a violation of that
p1440
aVImagine I suggest  as the desired location
p1441
aVIf you really like to sniff around your visitors' hard disks, use an ActiveX or Java applet :-)
p1442
as(dp1443
g28
V596781
p1444
stp1445
a((dp1446
g2
(lp1447
VAs Chris says, your  should return the actual function:
p1448
aVFurther, if you only store the function pointer to a member function, you lose track of the actual object (so you could just make your map static
p1449
aVPerhaps you should also store the  pointer of the object, i
p1450
ag598
aVmake your map like this:
p1451
aVIn  you would say
p1452
aVUsage: Suppose
p1453
aVThen you could say:
p1454
as(dp1455
g28
V596781
p1456
stp1457
a((dp1458
g2
(lp1459
VInternally, your database will presumably keep all data in a fixed-with, raw format, usually UCS-4 (i
p1460
ag598
aVraw strings of 32-bit integers holding one codepoint each)
p1461
aVUTF8 is an encoding, and encodings are only used when serializing data (e
p1462
ag99
aVin a file or database)
p1463
aVDeserializing, i
p1464
ag598
aVreading, means to decode the encoded data and retrieve the raw codepoint string
p1465
aVJust because you happen to use the same encoding for all your serialization needs doesn't prevent you from decoding when loading and encoding when writing
p1466
as(dp1467
g28
V596781
p1468
stp1469
a((dp1470
g2
(lp1471
VHow about something like this:
p1472
aVUsage:
p1473
as(dp1474
g28
V596781
p1475
stp1476
a((dp1477
g2
(lp1478
VWould the following work
p1479
aVYou bind  to the first and  to the second parameter
p1480
as(dp1481
g28
V596781
p1482
stp1483
a((dp1484
g2
(lp1485
VYou cannot loop through your container and say  when  is potentially no longer valid (because you erased it)
p1486
aVA typical erase loop goes like this:
p1487
aVRewrite your code in this spirit
p1488
aVTo spell out your problem: In , you call  which invalidates the iterator , and then you call , which is undefined behaviour
p1489
as(dp1490
g28
V596781
p1491
stp1492
a((dp1493
g2
(lp1494
V and  refer to how changes you make in the key table propagate to the dependent table
p1495
aVUPDATE means that the key values get changed in the dependent table to maintain the relation, and DELETE means that dependent records get deleted to maintain the integrity
p1496
aVExample: Say you have
p1497
aVand
p1498
aVNow if you change the deparments table to modify the first record to read , then with "UPDATE" you would also change the first two records to read  -- and without "UPDATE" you wouldn't be allowed to make the change
p1499
aVSimilarly, if you deleted Department 2, then with "DELETE" you would also delete the record for Roy
p1500
aVAnd without "DELETE" you wouldn't be allowed to remove the department without first removing Roy
p1501
as(dp1502
g28
V596781
p1503
stp1504
a((dp1505
g2
(lp1506
VI'd not burden the runtime with this decision at all
p1507
aVInstead, I'd build two libraries:
p1508
aVThen I'd have my  script determine whether or not we have exceptions, and set the Makefile like this:
p1509
aVTo determine whether or not you have exceptions you could simply try to build a tiny test program with a trivial try/catch block as suggested in the comments
p1510
aVTo actually build your library, just write conditional code:
p1511
aVAnd then build two libraries, one with  and one with  or something like that
p1512
aVThat way you have no runtime overhead, and your clients can use whichever library they prefer
p1513
as(dp1514
g28
V596781
p1515
stp1516
a((dp1517
g2
(lp1518
VYou can always construct one from the other:
p1519
aVUsing that you should be able to write your in-stream operator, e
p1520
ag99
as(dp1521
g28
V596781
p1522
stp1523
a((dp1524
g2
(lp1525
VUse  in
p1526
as(dp1527
g28
V596781
p1528
stp1529
a((dp1530
g2
(lp1531
VI think you are confusing a couple of things, let's see
p1532
aVSpanning-tree oriented network architecture is a property of the link layer and the link broadcast domain
p1533
aVMore specifically, it often comes up in the context of Ethernet
p1534
aVAn Ethernet segment must topologically be a tree, for otherwise you would immediately create broadcast cascades that would kill the medium
p1535
aVThe problem at hand is that if you have several switches and connect them with lots of cables, you may have loops in your segment
p1536
aVA dedicated switching protocol such as STP can be used to disable ports such that only a tree-shaped topology remains open, and on loss of connectivity it can reopen one of the blocked ports
p1537
aVThus by combining a redundant, loop-containing wiring with a spanning tree protocol one can achieve a level of physical redundancy
p1538
aVThe theoretical capacity loss refers to the fact that the layout I described above is forced to shut off some ports and thus isn't using all available wires
p1539
aVBut that isn't a disadvantage per se, just a limitation of the architecture
p1540
aVEthernet was never designed as a reliable network (in the spirit of SDH/SONET), but rather as a cheap enterprise-size medium
p1541
as(dp1542
g28
V596781
p1543
stp1544
a((dp1545
g2
(lp1546
V is for batch files only, and it waits for the callee to return
p1547
aVYou should use the  command to start programs backgrounded
p1548
aVAs an added bonus you can specify a priority for the process
p1549
aVIf you need to run something as another user, use
p1550
as(dp1551
g28
V596781
p1552
stp1553
a((dp1554
g2
(lp1555
VNot all data types are classes in C++
p1556
aVThe primitive C data types are not (they're called scalars)
p1557
aVThey're not "implemented" at all, but rather they form a core feature of the language that has a direct translation to machine code
p1558
aVThe syntax  is equivalent to C's  and initializes the variable at declaration time
p1559
as(dp1560
g28
V596781
p1561
stp1562
a((dp1563
g2
(lp1564
VYou probably don't need a compiler for assembler since you intend to execute the code directly on the machine, so you just need an
p1565
aVassembler
p1566
aVIf you're in Linux, use
p1567
as(dp1568
g28
V596781
p1569
stp1570
a((dp1571
g2
(lp1572
VPlease help
p1573
aVDon't use external functions for this, but instead use built-in PHP directory functions
p1574
as(dp1575
g28
V596781
p1576
stp1577
a((dp1578
g2
(lp1579
VIn general, a browser's JavaScript engine does not have access to any of the system's clipboard features for security reasons, so if you are asking for a portable, pure-JavaScript answer, then I'm afraid you can't do it
p1580
aV(If you must, you can search around the site for "javascript" and "clipboard", I think there are some approaches using Flash
p1581
aVBut best not to do it at all
p1582
as(dp1583
g28
V596781
p1584
stp1585
a((dp1586
g2
(lp1587
VConditional evaluation is lazy, i
p1588
ag598
aVit stops as soon as the result has been determined
p1589
aVThat is,  will not evaluate  if  is false, because the conjunction will have to be false already, and similarly  will not evaluate  if  is true because the disjunction is already true
p1590
as(dp1591
g28
V596781
p1592
stp1593
a((dp1594
g2
(lp1595
VTry  to start the program without a new window
p1596
as(dp1597
g28
V596781
p1598
stp1599
a((dp1600
g2
(lp1601
VHere's a little helper function to do the trick:
p1602
aVThis requires your encoding to store the numeral characters contiguously and N less than 10
p1603
as(dp1604
g28
V596781
p1605
stp1606
a((dp1607
g2
(lp1608
VThe regular expression should be:
p1609
aV(In words: The literal string "[Art
p1610
aV, followed by one or more numerals in the range 0-9, followed by the literal string "]"
p1611
aVIn PHP:
p1612
as(dp1613
g28
V596781
p1614
stp1615
a((dp1616
g2
(lp1617
VIf the question is how to sum up the series, you could just update the term one by one:
p1618
as(dp1619
g28
V596781
p1620
stp1621
a((dp1622
g2
(lp1623
VNow just implement  in each derived class
p1624
as(dp1625
g28
V596781
p1626
stp1627
a((dp1628
g2
(lp1629
VHere is a generic situation:
p1630
aVNow you can use  to discover whether a given position is already covered by a range in the cache
p1631
aVNote that the loop at  is rather efficient as it only starts at the first element where  could possibly be and stops once  can no longer be in range
p1632
aVFor non-overlapping ranges this will cover at most one range
p1633
as(dp1634
g28
V596781
p1635
stp1636
a((dp1637
g2
(lp1638
VYour  needs to also take a pointer to an object of class :
p1639
as(dp1640
g28
V596781
p1641
stp1642
a((dp1643
g2
(lp1644
VWell, if you insist, but the answer will neither be the best nor the easiest, and correctness is very much your burden now
p1645
aVFor the constructor, use the base initializer list:
p1646
aVWe also make  an unsigned type, since it represents a size
p1647
aVBut now you also have to take care to deallocate the memory on destruction
p1648
aVA simple  won't do because you first have to traverse all the children and recursively deallocate their memory
p1649
aVAll in all, a vector of shared pointers would save you about 90% of the code
p1650
as(dp1651
g28
V596781
p1652
stp1653
a((dp1654
g2
(lp1655
VHTTP is not a secure protocol and anyone can intercept the transmitted data in cleartext (e
p1656
ag99
aVsession cookies, passwords, credit card numbers, sexual fetishes)
p1657
aVIf you can, you should provide consistent HTTPS service throughout
p1658
aVThat said, by the design of the public/private key security, you can only use HTTPS on a server where you have complete and sole control over the IP address, since the client first looks up the IP address, then requests the secure protocol, and only then makes the HTTP query
p1659
aVThat means that you cannot deploy HTTPS on virtual hosts (shared hosting)
p1660
aV(Since you already have a partial HTTPS solution, I imagine that's not a problem for you, though
p1661
aVThe other downside is that the secure handshake and later encryption require computing resources, so that if you have bazillions of connections, you may feel quite a hit on your server performance
p1662
aVThat's for you to consider, though
p1663
aVShort form: If you have a dedicated IP address and enough computing resources, always and exclusively use HTTPS
p1664
as(dp1665
g28
V596781
p1666
stp1667
a((dp1668
g2
(lp1669
VI hear that clang can compile C++ into C
p1670
aVI doubt that would "simplify" anything, though
p1671
as(dp1672
g28
V596781
p1673
stp1674
a((dp1675
g2
(lp1676
VHere's a little generic disguiser:
p1677
aVNow you can say
p1678
aVImproved version according to Xeo:
p1679
as(dp1680
g28
V596781
p1681
stp1682
a((dp1683
g2
(lp1684
VEndianness is not immediately an issue, because no pointer casting is involved
p1685
aVSuppose we have:
p1686
aVThen the following algebraic expression is completely portable and representation-independent:
p1687
aVThe result will always be
p1688
aV(Let's assume that we have
p1689
aVIt is an entirely different matter how this is layed out in memory, which does depend on the machine endianness
p1690
aVThis information is accessible through type punning:
p1691
aVNow in memory  is layed out as , whatever that means: 0xABEF on big- and 0xEFAB on little-endian systems
p1692
as(dp1693
g28
V596781
p1694
stp1695
a((dp1696
g2
(lp1697
VUse ImageMagick or GraphicsMagick, both available as PHP modules (and very similar); in Ruby use the RMagick interface
p1698
as(dp1699
g28
V596781
p1700
stp1701
a((dp1702
g2
(lp1703
VThis is a new C++0x feature that tells the compiler to create the default version of the respective constructor or assignment operator, i
p1704
ag598
aVthe one which just performs the copy or move action for each member
p1705
aVThis is useful because the move constructor isn't always generated by default (e
p1706
ag99
aVif you have a custom destructor), unlike the copy constructor (and likewise for assignment), but if there's nothing non-trivial to write, it's better to let the compiler handle it than to spell it out yourself each time
p1707
aVAlso notice that a default constructor would not be generated if you provide any other non-default constructor
p1708
aVIf you still want the default constructor, too, you can use this syntax to have the compiler make one
p1709
aVAs another use case, there are several situations in which a copy constructor would not be generated implicitly (e
p1710
ag99
aVif you provide a custom move constructor)
p1711
aVIf you still want the default version, you can request it with this syntax
p1712
aVSee Section 12
p1713
aV8 of the standard for details
p1714
as(dp1715
g28
V596781
p1716
stp1717
a((dp1718
g2
(lp1719
VIn the inheriting situation, you can treat the derived class like its base class
p1720
aVThat is, you can keep a collection of base class references around and call their methods without needing to know whether the actual objects are of any derived type, and if yes which
p1721
aVThis an important semantic concept
p1722
aVIn the member class case, the inner class is just an implementation detail of the outer class and not even visible to the consumer
p1723
aVEven it it were visible, it would just be one feature of the  class
p1724
aVYou can see that the two situations are semantically very different, and you have to pick the one which represents your actual data model most accurately
p1725
aVTechnically, the derived class probably weighs a tiny bit heavier because of various virtual function calls, but the details depend on your language and the concrete situation
p1726
as(dp1727
g28
V596781
p1728
stp1729
a((dp1730
g2
(lp1731
VPerhaps you're thinking about this a bit wrongly
p1732
aVUTF-8 is an encoding which is useful for serializing data, e
p1733
ag99
aVwriting it to a file or the network
p1734
aVIt is a very non-trivial encoding, though, and a raw string of Unicode codepoints can end up in any number of encoded bytes
p1735
aVWhat you should probably do, if you want to handle text (given your description), is to store raw, fixed-width strings internally
p1736
aVIf you're going for Unicode (which you should), then you need 21 bits per codepoint, so the nearest integral type is
p1737
aVIn short, store all your strings internally as arrays of integers
p1738
aVThen you can random-access each codepoint
p1739
aVOnly encode to UTF-8 when you are writing to a file or console, and decode from UTF-8 when reading
p1740
aVBy the way, a Unicode codepoint is still a long way from a character
p1741
aVThe concept of a character is just far to high-level to have a simple general mechanic
p1742
aV(E
p1743
ag99
aV"a" + "accent grave" -- two codepoints, how many characters
p1744
as(dp1745
g28
V596781
p1746
stp1747
a((dp1748
g2
(lp1749
VThe asterisk  is more general than the hat
p1750
aVAs a type modifier,  means C++-pointer, and  means CLI-reference
p1751
aVHowever, the other use of the symbol for the dereference operator applies to both types, and the indirect-call operator  does likewise:
p1752
aVThe idea is that dereferencing is a general concept that's independent of the particular type of reference, so the same symbol can be used to minimize syntax proliferation
p1753
as(dp1754
g28
V596781
p1755
stp1756
a((dp1757
g2
(lp1758
VFor escaping echo arguments, you can use the alternative syntax :
p1759
as(dp1760
g28
V596781
p1761
stp1762
a((dp1763
g2
(lp1764
VIf you are thinking whether the first version always calls  but the second version calls it only if the first condition is true, then the answer is that both versions are equivalent because the AND operator is lazy and will not evaluate its second argument if the first is already false
p1765
aVThe standard guarantees this behaviour
p1766
aVThis makes it legal to say:
p1767
aVThis would be broken code without the laziness guarantee
p1768
as(dp1769
g28
V596781
p1770
stp1771
a((dp1772
g2
(lp1773
VIf you have C++0x (e
p1774
ag99
aVMSVC10, GCC >= 4
p1775
aV3), I'd strongly advise to use either a  or a  as your base object type (depending on whether the size is fixed or variable), and if you allocate this guy on the heap and need to pass it around, put it in a :
p1776
as(dp1777
g28
V596781
p1778
stp1779
a((dp1780
g2
(lp1781
VHere's a moderately unintrusive idea:
p1782
aVUsage:
p1783
as(dp1784
g28
V596781
p1785
stp1786
a((dp1787
g2
(lp1788
VDon't know about people smarter than you, but I would say that you should call  in advance if you are going to perform lots in insertion operations and you already know or can estimate the total number of elements, at least the order of magnitude
p1789
aVIt can save you a lot of reallocations in good circumstances
p1790
as(dp1791
g28
V596781
p1792
stp1793
a((dp1794
g2
(lp1795
VIf you look up the actual implementation of the  (e
p1796
ag99
aVin  or something like that) for the primitive types, you will see that for most of the integral types it is simply the identity function
p1797
aVSince the hash function is purely for mathematical and not for cryptographic purposes, there is no requirement that it be a "random" map to the range, so the identity is indeed perfectly appropriate
p1798
as(dp1799
g28
V596781
p1800
stp1801
a((dp1802
g2
(lp1803
VUnfortunately that's impossible by the very nature that automatic variables are laid out in memory
p1804
aV(They do not reside in a stable, permanent memory location
p1805
aVThe only thing you could do is allocate a global variable and copy the local variable into the global at some opportune point
p1806
aVBut in that case you might just use the global variable throughout
p1807
aVThere is no such thing as a particular point in time where a variable "becomes global"
p1808
aVGlobal variables must be known to the program at load time and exist for the entirety of the program's life
p1809
as(dp1810
g28
V596781
p1811
stp1812
a((dp1813
g2
(lp1814
VThere seem to be two orthogonal notions of "portability":
p1815
aVMy code compiles everywhere out of the box
p1816
aVIts general behaviour is the same on all platforms, but details of available features vary depending on the platform's characteristics
p1817
aVMy code contains a folder for architecture-dependent stuff
p1818
aVI guarantee that MYINT32 is always 32 bit no matter what
p1819
aVI successfully ported the notion of 32 bits to the nine-fingered furry lummoxes of Mars
p1820
aVIn the first approach, we write  and  and we know that the code always works, but details like the numeric range of  are up to the platform and not of our concern
p1821
aV(Wchar_t comes in here, too
p1822
aVThis is what I would call the genuinely portable style
p1823
aVIn the second approach, we typedef everything and use types like
p1824
aVFormatted output with  triggers tons of warnings, and we must resort to monsters like
p1825
aVIn this approach we derive a strange sense of power and control from knowing that our integer is always 32 bits wide, but I hesitate to call this "portable" -- it's just stubborn
p1826
aVThe fundamental concept that requires a specific representation is serialization: The document you write on one platform should be readable on all other platforms
p1827
aVSerialization is naturally where we forgo the type system, must worry about endianness and need to decide on a fixed representation (including things like text encoding)
p1828
aVThe upshot is this:
p1829
aVWrite your main program core in portable style using standard language primitives
p1830
aVWrite well-defined, clean I/O interfaces for serialization
p1831
aVIf you stick to that, you should never even have to think about whether your platform is 32 or 64 bit, big or little endian, Mac or PC, Windows or Linux
p1832
aVStick to the standard, and the standard will stick with you
p1833
as(dp1834
g28
V596781
p1835
stp1836
a((dp1837
g2
(lp1838
VGetters and setters are really only an important design choice if they get/set an abstract value that you may have implemented in any number of ways
p1839
aVBut if your class is so straight-forward and the data members so fundamental that you need to expose them directly, then just make them public
p1840
aVYou get a nice, cheap aggregate type without any frills and it's completely self-documenting
p1841
aVIf you really do want to make a data member private but still give full access to it, just make a single accessor function overloaded once as  and once as
p1842
aVEdit: In a recent project I simply used tuples for coordinates, with global accessor functions
p1843
aVPerhaps this could be useful:
p1844
as(dp1845
g28
V596781
p1846
stp1847
a((dp1848
g2
(lp1849
VSlightly more verbosely, the code does something like this:
p1850
aVI suppose  acts as a container for functions that can be looked up by name via
p1851
as(dp1852
g28
V596781
p1853
stp1854
a((dp1855
g2
(lp1856
VI'm not sure if this is standardized (as Nicol says, all optimizations are up to the compiler), but I heard STL talk about this and (at least in MSVC), RVO happens before anything else
p1857
aVSo if there's a chance to apply RVO, then that'll happen without any action on your part
p1858
aVSecond, when you return a temporary, you don't have to write  (I think this is actually in the standard), since the return value will implicitly be treated as an rvalue
p1859
aVThe upshot is: Don't second-guess the compiler, just write the most natural-looking code and it'll give you the best-possible result
p1860
as(dp1861
g28
V596781
p1862
stp1863
a((dp1864
g2
(lp1865
VMake sure that the database uses UTF-8 (as you say it does) and that the PHP script has its internal encoding set to UTF-8, which you can achieve with iconv_set_encoding
p1866
aVIf you're reading data from an HTTP request that should be all you need, as long as the request tags its own encoding correctly
p1867
as(dp1868
g28
V596781
p1869
stp1870
a((dp1871
g2
(lp1872
VYou will want to do string matching against a regular expression
p1873
aVThe expression should be:
p1874
aVHere n and m are the number of digits to want
p1875
aVYou can build a regular expression from a string, so just make the pattern string from your parameters and then construct the regex; it's all in  on C++0x compilers (or  otherwise)
p1876
aVBe careful to either match the entire input string or surround the expression by word boundaries to avoid 12345
p1877
aV67890 matching against m=2, n=2 as "45
p1878
aV67"
p1879
aVEdit: Here's one approach:
p1880
as(dp1881
g28
V596781
p1882
stp1883
a((dp1884
g2
(lp1885
VFirst rotate your image so that its aspect ratio is at least 1
p1886
aVNow if your aspect ratio is larger than 4/3, keep the height and crop the width; if the aspect ratio is smaller, keep the width and crop the height
p1887
as(dp1888
g28
V596781
p1889
stp1890
a((dp1891
g2
(lp1892
VUsing ncurses for the interface sounds like a good idea
p1893
aVYou can do a single-threaded select-based network and terminal client -- check out Beej's guide
p1894
aVAlternatively, Boost
p1895
aVasio, single-or-multithreaded, should be a solid choice, too
p1896
as(dp1897
g28
V596781
p1898
stp1899
a((dp1900
g2
(lp1901
VMake sure that you set your php internal encoding ot UTF8 using iconv_set_encoding, and that you call  with the encoding information as EdoDodo said
p1902
aVAlso make sure that you're database stores with UTF8-encoding, though you say that's already the case
p1903
as(dp1904
g28
V596781
p1905
stp1906
a((dp1907
g2
(lp1908
VThe third argument of  can be anything that behaves like a function, i
p1909
ag598
aVthat can be invoked like
p1910
aVSince your struct overloads , it has precisely this behaviour
p1911
aVClasses which overload the ()-operator are called "functors" or "function objects"
p1912
aVTheir power lies in the fact that you can store additional data (e
p1913
ag99
aVaccumulators or inital values) in the class members while still behaving like an ordinary function
p1914
as(dp1915
g28
V596781
p1916
stp1917
a((dp1918
g2
(lp1919
V(Sorry, I had missed your additional requirement
p1920
aVSort the array by employer name first:
p1921
aVOr even better, using a lambda:
p1922
aVThen use foreach:
p1923
as(dp1924
g28
V596781
p1925
stp1926
a((dp1927
g2
(lp1928
VI'm not sure that I am answering your question, but let me make a few remarks that hopefully shed some light
p1929
aVAt the core, general-purpose programming languages like the ones we are talking about (C, C++, C#, Java, PHP) do not have a notion of "text", merely of "data"
p1930
aVData consists of sequences of integral values (i
p1931
ag598
aVnumbers)
p1932
aVThere is no inherent meaning behind those numbers
p1933
aVThe process of turning a stream of numbers into a text is one of semantics, and it is usually left to the consumer to assign the relevant semantics to a data stream
p1934
aVWarning: I will now use the word "encoding", which unfortunately has multiple inequivalent meanings
p1935
aVThe first meaning of "encoding" is the assignment of meaning to a number
p1936
aVThe semantic interpretation of a number is also called a "character"
p1937
aVFor example, in the ASCII encoding, 32 means "space" and 65 means "captial A"
p1938
aVASCII only assigns meanings to 128 numbers, so every ASCII character can be conveniently represented by a single 8-bit byte (with the top bit always 0)
p1939
aVThere are many encodings with assign characters to 256 numbers, thus all using one byte per character
p1940
aVIn these fixed-width encodings, a text string has as many characters as it takes bytes to represent
p1941
aVThere are also other encodings in which characters take a variable amount of bytes to represent
p1942
aVNow, Unicode is also an encoding, i
p1943
ag598
aVan assignment of meaning to numbers
p1944
aVOn the first 128 numbers it is the same as ASCII, but it assigns meanings to (theoretically) 2^21 numbers
p1945
aVBecause there are lots of meanings which aren't strictly "characters" in the sense of writing (such as zero-width joiners or diacritic modifiers), the term "codepoint" is preferred over "character"
p1946
aVNonetheless, any integral data type that is at least 21 bits wide can represent one codepoint
p1947
aVTypically one picks a 32-bit type, and this encoding, in which every element stands for one codepoint, is called UTF-32 or UCS-4
p1948
aVNow we have a second meaning of "encoding": I can take a string of Unicode codepoints and transform it into a string of 8-bit or 16-bit values, thus further "encoding" the information
p1949
aVIn this new, transformed form (called "unicode transformation format", or "UTF"), we now have strings of 8-bit or 16-bit values (called "code units"), but each individual value does not in general correspond to anything meaningful -- it first has to be decoded into a sequence of Unicode codepoints
p1950
aVThus, from a programming perspective, if you want to modify text (not bytes), then you should store your text as a sequence of Unicode codepoints
p1951
aVPractically that means that you need a 32-bit data type
p1952
aVThe  data type in C and C++ is usually 8 bits wide (though that's only a minimum), while on C# and Java it is always 16 bits wide
p1953
aVAn 8-bit char could conceivably be used to store a transformed UTF-8 string, and a 16-bit char could store a transformed UTF-16 string, but in order to get at the raw, meaningful Unicode codepoints (and in particular at the length of the string in codepoints) you will always have to perform decoding
p1954
aVTypically your text processing libraries will be able to do the decoding and encoding for you, so they will happily accept UTF8 and UTF16 strings (but at a price), but if you want to spare yourself this extra indirection, store your strings as raw Unicode codepoints in a sufficiently wide type
p1955
as(dp1956
g28
V596781
p1957
stp1958
a((dp1959
g2
(lp1960
VYou've opened the "message" string with an apostrophe  but tried to close it with a quotation mark
p1961
aVThe SO syntax highlighter gives it away
p1962
as(dp1963
g28
V596781
p1964
stp1965
a((dp1966
g2
(lp1967
VThat has nothing to do with any standard, it's up to your runtime what to write to stdin
p1968
aVYour runtime makes the standard input available to your program, which reads some bytes from it and quits, and then the remaining bytes are processed by the runtime itself -- if you can configure it to clear all the file descriptors after forking a process, you could maybe prevent this behaviour, but that would seriously impede most of the standard command line workflows which rely on attaching one process's input to another process's output
p1969
as(dp1970
g28
V596781
p1971
stp1972
a((dp1973
g2
(lp1974
VFirst off, have you looked at Boost
p1975
aVmulti_array
p1976
aVAlways good to take something ready-made rather than reinventing the wheel
p1977
aVThat said, I'm not sure if this is helpful, but here's how I would implement the basic data structure, and it'd be fairly easy to serialize:
p1978
aVYou can serialize the data buffer directly:
p1979
as(dp1980
g28
V596781
p1981
stp1982
a((dp1983
g2
(lp1984
VDon't forget to set PHP's internal encoding to UTF8 using iconv_set_encoding
p1985
aVYour php
p1986
aVini preferences only affect the HTTP headers that are sent with your document
p1987
aVFinally, make sure you pass the encoding to mangling functions like
p1988
as(dp1989
g28
V596781
p1990
stp1991
a((dp1992
g2
(lp1993
VSort both arrays according to a strict ordering and compare them term-by-term
p1994
aVUpdate: Summarizing some of the points that have been raised, here the efficiency you can generally expect:
p1995
aVstrict ordering available: O(log N) for sorting plus comparing term-by-term
p1996
aVequality and hash function available: compare hash counts term-by-term, plus actual object comparisons in the event of hash collisions
p1997
aVonly equality, no hashing available: must count each element or copy one container and remove (efficiency depends on the container)
p1998
aVThe complexity of comparison term-by-term is linear in the position of the first mismatch
p1999
as(dp2000
g28
V596781
p2001
stp2002
a((dp2003
g2
(lp2004
VMake sure you set your internal encoding to UTF8 with iconv_set_encoding
p2005
as(dp2006
g28
V596781
p2007
stp2008
a((dp2009
g2
(lp2010
VTake a look at this answer and the code link therein
p2011
aVApparently there's a built-in Java/AWT function (in ) that can access a font's glyph (by codepoint)
p2012
as(dp2013
g28
V596781
p2014
stp2015
a((dp2016
g2
(lp2017
VCheck out the VMime library
p2018
as(dp2019
g28
V596781
p2020
stp2021
a((dp2022
g2
(lp2023
VHow about using a FOR loop
p2024
aVIt'll execute lots of copy commands, but give it a try:
p2025
as(dp2026
g28
V596781
p2027
stp2028
a((dp2029
g2
(lp2030
VThe class contains no data members, so it's empty
p2031
aVThe standard demands that every class have at least size 1, so that's what you get
p2032
aV(Member functions aren't physically "inside" a class, they're really just free functions with a hidden argument and a namespace and access control
p2033
as(dp2034
g28
V596781
p2035
stp2036
a((dp2037
g2
(lp2038
VYou can achieve this by using , available in PHP, and requesting an encoding conversion with transliteration
p2039
aV(This actually works for many different scripts
p2040
aVIf you only want basic European characters, make the target Latin-1, or even ASCII
p2041
aVFrom the manual page:
p2042
as(dp2043
g28
V596781
p2044
stp2045
a((dp2046
g2
(lp2047
VGood answer already, I'm just chipping in another take on this for fun
p2048
aVUTF-8 uses a general scheme by Prosser and Thompson to encode large numbers in single-byte sequences
p2049
aVThis scheme can actually represent 2^36 values, but for Unicode we only need 2^21
p2050
aVHere's how it works
p2051
aVLet N be the number you want to encode (e
p2052
ag99
aVa Unicode codepoint):
p2053
aVIf N < 128, just one byte
p2054
aVThe highest bit is zero
p2055
aVOtherwise, several bytes
p2056
aVThe first byte starts with as many ones as there are bytes in the sequence, followed by a zero, and then the data bits; successive bytes start with  followed by six data bits
p2057
aVExamples:
p2058
aV3 byte sequence:
p2059
aV5 byte sequence:
p2060
aV7 byte sequence:
p2061
aVA k-byte sequence fits 5 k + 1 bits (when k > 1), so you can determine how many bytes you need given N
p2062
aVFor decoding, read one byte; if its top bit is zero, store its value as is, otherwise use the first byte to figure out how many bytes are in the sequence and process all those
p2063
aVFor Unicode as of today we only need at most k = 4 bytes
p2064
as(dp2065
g28
V596781
p2066
stp2067
a((dp2068
g2
(lp2069
VAuthorization refers to rules that determine who is allowed to do what
p2070
aVE
p2071
ag99
aVAdam may be authorized to create and delete databases, while Usama is only authorised to read
p2072
aVAuthentication is the process of ascertaining that somebody really is who he claims to be
p2073
aVThe two concepts are completely orthogonal and independent, but both are central to security design, and the failure to get either one correct opens up the avenue to compromise
p2074
aVIn terms of web apps, very crudely speaking, authentication is when you check login credentials to see if you recognize a user as logged in, and authorization is when you look up in your access control whether you allow the user to edit, delete or create content
p2075
as(dp2076
g28
V596781
p2077
stp2078
a((dp2079
g2
(lp2080
VThe orphaned angle bracket is actually in your page source, between the second and third image
p2081
as(dp2082
g28
V596781
p2083
stp2084
a((dp2085
g2
(lp2086
VA classical case for a JOIN:
p2087
aVThen to print, we only print the header if it has changed (thanks, Rajasur
p2088
ag77
as(dp2089
g28
V596781
p2090
stp2091
a((dp2092
g2
(lp2093
VIt looks like rather than independent uniform random numbers you rather want a random permutation of the set {1, 2, 3,
p2094
aV, N}
p2095
aVI think there's a  method for arrays that will do that for you
p2096
aVAs requested, here's the code example:
p2097
as(dp2098
g28
V596781
p2099
stp2100
a((dp2101
g2
(lp2102
VYou will get a compile-time error if your templated code makes reference to members that the actual parameter doesn't provide when you try to instantiate the template
p2103
aVSo don't worry, you won't be able to break anything
p2104
aVThink of templates as a code-generation mechanism
p2105
aVWhether the generated code actually makes sense can sometimes only be determined when you actually try it
p2106
as(dp2107
g28
V596781
p2108
stp2109
a((dp2110
g2
(lp2111
VA set would work, but you could just make a vector, reserve enough capacity, and then use sorted inserts using
p2112
aVSince strings are cheap to swap, this should be fine (and in any case 450 is a tiny number)
p2113
aVA vector has constant-time lookup and random access, so if you don't need to insert and erase a lot, it's a better choice
p2114
as(dp2115
g28
V596781
p2116
stp2117
a((dp2118
g2
(lp2119
VIt depends on how your maps are "independently created", but if it's an option, I'd make just one global map (or multimap) object and pass that to all your creators
p2120
aVIf you have lots of small maps all over the place, you can just call  on the global one to merge your maps into it
p2121
aVThat way you have only a single object in which to perform lookup, which is reasonably efficient (O(log n) for multimap, expected O(1) for unordered_multimap)
p2122
aVThis also saves you from having to pass raw pointers to containers around and having to clean up
p2123
as(dp2124
g28
V596781
p2125
stp2126
a((dp2127
g2
(lp2128
VAs it says in the documentation, write a function to handle the writing:
p2129
aVUsage:
p2130
as(dp2131
g28
V596781
p2132
stp2133
a((dp2134
g2
(lp2135
VText is also a form of binary data
p2136
aVI suppose what you want to check is whether there are any characters in your input that are < 32
p2137
aVIf you can safely assume that your text is multi-byte encoded, then you could just scan through the entire file and abort if you hit a byte in the range [0, 32) (excluding 9, 10, 13, and whatever else you may except in "text" -- or worst-case only check for null bytes [thanks, tdammers
p2138
aVIf you could plausibly expect to receive UTF-16 or UTF-32 encoded text, you'll have to work harder
p2139
as(dp2140
g28
V596781
p2141
stp2142
a((dp2143
g2
(lp2144
VUse  rather than , see the example
p2145
aVAssociativeHash arrays have no well-defined element order
p2146
as(dp2147
g28
V596781
p2148
stp2149
a((dp2150
g2
(lp2151
VIf you say this:
p2152
aVThen at least you can make the following work:
p2153
aVUpdate: Voila:
p2154
as(dp2155
g28
V596781
p2156
stp2157
a((dp2158
g2
(lp2159
V takes a space-separated list of class names as its argument, so there's no dot:
p2160
aVSee here for details
p2161
aVThe "dot"-syntax is the selector mechanism that picks out the element
p2162
as(dp2163
g28
V596781
p2164
stp2165
a((dp2166
g2
(lp2167
VTry saying:
p2168
aVWith the quotes
p2169
aVYour JS engine should have complained
p2170
aVAlways check the error console
p2171
aVFor Part 2, you could write a little helper:
p2172
aVOriginally you'd say , but you can later call it again with different parameters
p2173
aVIf you only need to change the filename, perhaps something like this:
p2174
as(dp2175
g28
V596781
p2176
stp2177
a((dp2178
g2
(lp2179
VThere are no "template typedef"s in C++
p2180
aVIn C++0x you can use template aliases, but support for that is limited at the moment
p2181
aVWhy not simply add a virtual function to your base class:
p2182
aVThen let each derived class implement it:
p2183
aVThen you can store pointers-to-base-class in your stack and just call
p2184
as(dp2185
g28
V596781
p2186
stp2187
a((dp2188
g2
(lp2189
VYour  member is just a pointer to the variable  in , so when you print  you just see the value of the counter during that round of the loop
p2190
aVAll your nodes have the same data value
p2191
as(dp2192
g28
V596781
p2193
stp2194
a((dp2195
g2
(lp2196
VThe  option for gcc passes a comma-separated list of tokens as a space-separated list of arguments to the linker
p2197
aVSo
p2198
aVeventually becomes a linker call
p2199
aVIn your case, you want to say "", so you pass this to gcc as  Alternatively, you can specify repeat instances of :
p2200
aVOr, in your case,
p2201
as(dp2202
g28
V596781
p2203
stp2204
a((dp2205
g2
(lp2206
VYes, libcurl
p2207
as(dp2208
g28
V596781
p2209
stp2210
a((dp2211
g2
(lp2212
VJust say , or whatever position you need
p2213
as(dp2214
g28
V596781
p2215
stp2216
a((dp2217
g2
(lp2218
VYou would use the "remove and erase idiom":
p2219
aVThe point is that  is a sequence container and not geared towards manipulation by value
p2220
aVDepending on your design needs, a different standard library container may be more appropriate
p2221
aVNote that the  algorithm merely reorders elements of the range, it does not erase anything from the container
p2222
aVThat's because iterators don't carry information about their container with them, and this is fully intentional: By separating iterators from their containers, one can write generic algorithms that work on any sensible container
p2223
aVIdiomatic modern C++ would try to follow that pattern whenever applicable: Expose your data through iterators and use generic algorithms to manipulate it
p2224
as(dp2225
g28
V596781
p2226
stp2227
a((dp2228
g2
(lp2229
VI believe you mean to ask whether there exists a "command" in HTML which allows you to include a file
p2230
aVIn pure HTML by itself there does not, but the Apache server-side includes does provide such a directive:
p2231
aVYou will need to enable SSI processing by your webserver
p2232
aVIn Apache, you'd typically call your file  or something like that
p2233
as(dp2234
g28
V596781
p2235
stp2236
a((dp2237
g2
(lp2238
VJust say
p2239
aVIt'll return immediately and it won't start an unnecessary instance of the shell
p2240
as(dp2241
g28
V596781
p2242
stp2243
a((dp2244
g2
(lp2245
VI don't know, it must be something about Visual Studio, or something else you're not telling us
p2246
aVThe following compiles fine with me in GCC 4
p2247
aV6:
p2248
aVI extracted  into  and invoked the compiler like this:
p2249
aVIt also works if I append
p2250
as(dp2251
g28
V596781
p2252
stp2253
a((dp2254
g2
(lp2255
VDefault arguments are just a code-generation tool and not part of the function signature, so you can't really get around that
p2256
aVYou could wrap your function in a function object, but that's precisely what  already does for you
p2257
aVHowever, in C++0x you can conveniently store the result (and use ) to maybe make the code a bit more readable:
p2258
aV(The reason you don't want to do that in C++98/03 is that the return type of  is something rather unsightly, and you wouldn't be doing anyone a favour by spelling it out
p2259
aVAlternatively, again in C++0x, you could use a lambda:
p2260
as(dp2261
g28
V596781
p2262
stp2263
a((dp2264
g2
(lp2265
VIf you were to rename your ID fields so they are both called , you can do even better:
p2266
aVIf you want to include issues for which no attachment record exists at all (rather than one with empty "Filename" field), say  instead of
p2267
as(dp2268
g28
V596781
p2269
stp2270
a((dp2271
g2
(lp2272
VSolve it by not using the terrible idea of storing raw pointers in a container
p2273
aVInstead, use a container of smart pointers:
p2274
aVIf you don't have C++0x, use the TR1 library:
p2275
aV(You don't have  in that case, because that's a new gimmick using rvalue references and forwarding
p2276
as(dp2277
g28
V596781
p2278
stp2279
a((dp2280
g2
(lp2281
V made a copy of your  pointer (when you said )
p2282
aVThe copy didn't get set to null
p2283
aV(But it's still pointing to a now invalidated address, so don't dereference it
p2284
as(dp2285
g28
V596781
p2286
stp2287
a((dp2288
g2
(lp2289
VUse  and :
p2290
as(dp2291
g28
V596781
p2292
stp2293
a((dp2294
g2
(lp2295
VSame as for : The class must have a strict ordering in the spirit of "less than"
p2296
aVEither overload an appropriate , or provide a custom predicate
p2297
aVAny two objects  and  for which  will be considered equal
p2298
aVThe map container will actually keep all the elements in the order provided by that ordering, which is how you can achieve O(log n) lookup and insertion time by key value
p2299
as(dp2300
g28
V596781
p2301
stp2302
a((dp2303
g2
(lp2304
VThis works for me (GCC 4
p2305
aV6, ):
p2306
as(dp2307
g28
V596781
p2308
stp2309
a((dp2310
g2
(lp2311
VIf you make that line  then it prints the binary representation of the floating point number
p2312
aVSee here for details
p2313
as(dp2314
g28
V596781
p2315
stp2316
a((dp2317
g2
(lp2318
VIf the code runs on the client's machine, then in principle you can never prevent the data from becoming known, because it has to be on the client's machine
p2319
aVYou can try to obfuscate, but ultimately the client will have to be able to read the data, so it has to know it
p2320
aVIf you were to simply embed an encryption key in your program, the client could just scan through the file and extract the key
p2321
aVIf you work a bit harder you can make Skype, but even that has been deconstructed
p2322
aVIt all depends on the seriousness of your need to protect the data
p2323
aVIf it's absolute, then you cannot do it, but if you just want to keep the casual visitor out, you could try and make it a bit harder
p2324
aVtell us some details if you're serious about this
p2325
as(dp2326
g28
V596781
p2327
stp2328
a((dp2329
g2
(lp2330
VI'd say it sounds like bad practice to use your table's primary key column for a second, unrelated purpose of file naming
p2331
aVThat breaks modularity and locality, since you will now always have to remember that the two things are related
p2332
aVIt would probably better to write a scheme to derive a unique (and safe) filename from the username once when you create the user record, and store that filename in a separate, dedicated column
p2333
aVThat way you can still look it up efficiently, but you now have a token with only one purpose
p2334
as(dp2335
g28
V596781
p2336
stp2337
a((dp2338
g2
(lp2339
VIn response to:
p2340
aVNow, how can I traverse this list so I
p2341
aVcan find a sum of all these ints
p2342
aVIs
p2343
aVthat possible, or does my current
p2344
aVfunctionality prevent that
p2345
aVI would
p2346
aVhave to implement some sort of
p2347
aViterator to my List Class
p2348
aVNo matter how you design a linked list, you must have some sort of pointer to the beginning of the list, and you have to have a way of knowing when you are at the end (e
p2349
ag99
aVwhen "next" is null, or by having a pointer to the end)
p2350
aVBy exposing those data one way or another, you can always set up a list traversal:
p2351
aVStart at the beginning
p2352
aV(In your case, get a hold of
p2353
aVIf you are not at the end, move to the next element
p2354
aV(In your case, get
p2355
aVUsing that pattern to accumulate a value as you visit each element you should be able to handle your task with ease
p2356
aVIf your list does not give you public access to its beginning, then it is certainly not a general-purpose list
p2357
as(dp2358
g28
V596781
p2359
stp2360
a((dp2361
g2
(lp2362
VA stack is designed to expose only its top
p2363
aVIt has no "bottom" as far as you are concerned
p2364
aVDon't use a stack if you want to access both ends of a collection
p2365
aV(Perhaps you'd prefer a double-ended queue or a list
p2366
as(dp2367
g28
V596781
p2368
stp2369
a((dp2370
g2
(lp2371
VExactly what the compiler tells you -- you end up defining  in all three translation units
p2372
aVYou want it the other way around: The repeatedly included declaration should be extern, and there must only be one definition
p2373
aVFor instance:
p2374
as(dp2375
g28
V596781
p2376
stp2377
a((dp2378
g2
(lp2379
VThere is no such thing as an "empty reference"
p2380
aVYou have to provide a reference at object initialization
p2381
aVPut it in the constructor's base initializer list:
p2382
aVAn alternative would be , but that'd be terrible
p2383
aVEdit: To maybe answer your question, you probably just want  to be a member object, not a reference, so just say , and write the constructor either as  or as
p2384
as(dp2385
g28
V596781
p2386
stp2387
a((dp2388
g2
(lp2389
VJust to post a safe version that works independently of whether the array content has been maliciously prepared:
p2390
aVProbably best to include the encoding as well, after all your array could contain all sorts of characters
p2391
as(dp2392
g28
V596781
p2393
stp2394
a((dp2395
g2
(lp2396
VYou could always just use the existing type , which is a typedef for
p2397
aVFeel free to make other string classes based on your favourite integral types, too
p2398
aVNote that there are corresponding stream objects  etc
p2399
as(dp2400
g28
V596781
p2401
stp2402
a((dp2403
g2
(lp2404
VThe Boost library has a container called multi_array which provides and n-dimensional dynamic array which can be accessed and manipulated along each dimension
p2405
aVThis seems to be very similar to what you are trying to build, perhaps you could use it instead
p2406
as(dp2407
g28
V596781
p2408
stp2409
a((dp2410
g2
(lp2411
VIf I understand correctly, it's like this: if the user has never been to your site, then you are starting a new session and  will not be set (so you set it to 1)
p2412
aVOn the other hand if the user's request comes with a session ID of a valid session, then the variable will be set to whatever it was last stored as
p2413
as(dp2414
g28
V596781
p2415
stp2416
a((dp2417
g2
(lp2418
VSay , not
p2419
as(dp2420
g28
V596781
p2421
stp2422
a((dp2423
g2
(lp2424
VYour class selector returns a collection of matches
p2425
aVYou could try  to iterate over them:
p2426
as(dp2427
g28
V596781
p2428
stp2429
a((dp2430
g2
(lp2431
VA linear search would of course work, but if you need many lookups with the same key, you could try sorting the range first according to
p2432
aVIf you only have a few, fixed keys, you could try using a boost
p2433
aVmulti_index, with one index for each key value
p2434
as(dp2435
g28
V596781
p2436
stp2437
a((dp2438
g2
(lp2439
VThe  tool shows you a summary of files that were modified
p2440
aVBy itself it lists all commits, but you can also limit it to just the recent n commits:
p2441
aVTo count files:
p2442
aVSee  for details
p2443
as(dp2444
g28
V596781
p2445
stp2446
a((dp2447
g2
(lp2448
V is your answer:
p2449
as(dp2450
g28
V596781
p2451
stp2452
a((dp2453
g2
(lp2454
VIn any class ,  is a cast operator which lets you cast  to :
p2455
aVFor example, an  has a cast-to-bool operator so you can use it in expressions like
p2456
aVIn response to your need to use unordered containers: You will need to implement a hash function or function object, which matches the signature
p2457
aVIf you want to do it with least visible impact on the user code, specialize :
p2458
aVNow we can use  directly, provided  provides
p2459
as(dp2460
g28
V596781
p2461
stp2462
a((dp2463
g2
(lp2464
VIf you're tracking a user's sessions in a somewhat systematic fashion, e
p2465
ag99
aVin a database, then you could just search for all the user's open sessions and remove the server-side session data
p2466
aVThat way the user would no longer be considered "logged in" next time he reloads a page
p2467
aVYou will probably have to define your own session handler for this to work, though (or use an existing framework)
p2468
aVOtherwise by default you just have a ton of  files on your disk and you may not easily be able to figure out which one belongs to which user
p2469
as(dp2470
g28
V596781
p2471
stp2472
a((dp2473
g2
(lp2474
VWhy so roundabout
p2475
aVHow about a straight-forward trait class:
p2476
as(dp2477
g28
V596781
p2478
stp2479
a((dp2480
g2
(lp2481
VThe second form will almost surely never do what you want
p2482
aVIn Bash, you have a built-in numeric expression handler, though:
p2483
as(dp2484
g28
V596781
p2485
stp2486
a((dp2487
g2
(lp2488
VAlmost:
p2489
aVThe  variables contain the arguments that are passed to the compiler and linker invocartion, respectively
p2490
aV(In your case you're compiling and linking in one go
p2491
aVMake sure to add libraries after your own object files
p2492
as(dp2493
g28
V596781
p2494
stp2495
a((dp2496
g2
(lp2497
VThis may not be totally on topic, but I wrote a couple of generic helper functions for my proposed wmain framework, so perhaps they're useful for someone
p2498
aVMake sure to call  in your  before doing any stringy stuff
p2499
aVYou could provide "dummy" overloads:
p2500
aVNow, if you have an , you can always call  to get a -string
p2501
aVIf you're curious, here's the rest of the framework:
p2502
aVNow the  -- your new entry point is always :
p2503
as(dp2504
g28
V596781
p2505
stp2506
a((dp2507
g2
(lp2508
s(dp2509
g28
V596781
p2510
stp2511
a((dp2512
g2
(lp2513
VThe correct function  is called because  is virtual
p2514
aVThis tells the compiler that when a call to  is requested, the actual address of the callee is looked up in the vtable of the actual object whose member you invoke
p2515
aVThe type of the  in question is , which is why , but its vtable belongs to a derived object and hence the function call to  goes to the override
p2516
as(dp2517
g28
V596781
p2518
stp2519
a((dp2520
g2
(lp2521
VThe idea of exception handling is that you can handle errors at points in your program flow where you can deal with them meaningfully
p2522
aVRather than checking every function's return value like in C, where most of the time you can't do anything sensible other than passing the error further up, you install a try/catch block at sensible points in your program:
p2523
aVBasically, whenever there is a point where you can react meaningfully to an error, then catch that error, and pass everything else on
p2524
aVThat way, error handling is only invoked when there is a plausible recovery from the error
p2525
aVFor example, worst case if any error stops your program from executing meaningfully, then you might almost not catch anything at all and just let the OS handle the situation (well, perhaps one single try/catch to produce a friendly error message)
p2526
aVExample (in C++, sorry, I'm can't type Java blind):
p2527
aVIn this example, we may try to process an image and fail for some anticipable reasons (out of memory, or failure to read the image)
p2528
aVIn that case we just return without doing work and let the program continue gracefully
p2529
aVAll other errors are propagated up to a higher point
p2530
aVMost importantly, we do not need to litter the actual image processing function with error checks and responses all the time, it suffices for any code there to throw one of our two good exceptions and not worry any further
p2531
aVMoral: If you have try/catch blocks absolutely everywhere, you're doing it wrong
p2532
as(dp2533
g28
V596781
p2534
stp2535
a((dp2536
g2
(lp2537
VYou've already suggested a possible answer, but let's spell out some options:
p2538
aV1) Make the base default-constructible
p2539
aVEasiest to do by providing default arguments:
p2540
aV(Note that we say  to avoid tacit conversions from
p2541
aV2) Call the constructor in the derived class's constructor's base initializer list:
p2542
aV2a) Give  an appropriate constructor and pass it on:
p2543
aV(Note that (1) is a declaration, while (2) and (2a) are the definitions
p2544
as(dp2545
g28
V596781
p2546
stp2547
a((dp2548
g2
(lp2549
VYou're not creating an instance of , you are creating an instance of an anonymous class inheriting from
p2550
aVMore verbosely, this could have been written:
p2551
as(dp2552
g28
V596781
p2553
stp2554
a((dp2555
g2
(lp2556
VJust to add yet another reply, here's how I would implement  to be strictly ordered
p2557
aVWe just use lexicographic ordering:
p2558
aVAlternatively, we could have spared ourselves the pain and said:
p2559
aVAlways best not to reinvent the wheel
p2560
aVPost a comment if you also want pair hashing using  to use unordered containers
p2561
as(dp2562
g28
V596781
p2563
stp2564
a((dp2565
g2
(lp2566
VThis is a classic JOIN operation:
p2567
aVI'm assuming that your first table is called  and that the name lookup table is called , and I also removed the spaces from column names
p2568
aVWhenever you need to replace a foreign unique identifier by values from the corresponding lookup table, it's time for a JOIN on that lookup table
p2569
aVIf you do it multiple times from the same table, you can use aliases () to disambiguate which instance you are referring to
p2570
as(dp2571
g28
V596781
p2572
stp2573
a((dp2574
g2
(lp2575
VGive VMime a try
p2576
aV(Sending mail is not a language built-in feature, you will have to use some sort of library
p2577
as(dp2578
g28
V596781
p2579
stp2580
a((dp2581
g2
(lp2582
VHow do you think any session-specific information will get from the browser to you if the client doesn't send any information
p2583
aVThe traditional way would be to pass a session identifier in GET and POST requests, though that suffers from serious security risks
p2584
aVBest to just tell the client they need to allow session cookies
p2585
aV(I could think of a more roundabout way of using AJAX and client-side storage to request session-specific bits of data from the client's runtime, but it'd all boil down to URL parameters in a GET/POST request
p2586
as(dp2587
g28
V596781
p2588
stp2589
a((dp2590
g2
(lp2591
VI think the error is exactly what the compiler says: your call  doesn't make sense
p2592
aVis a type, not a variable
p2593
aVYour lambda only takes a function pointer as an argument, but no actual object to call the function with
p2594
aVAlso, what's the lambda supposed to return
p2595
aVIf its only purpose is to return , shouldn't its return type just be
p2596
aVMaybe something like this (but I don't understand your requirements fully):
p2597
aVI'm also getting rid of the "capture everything by reference" () because you don't seem to be using any non-local variables
p2598
aVEdit: Oh wait, I see, you want to add  to the vector
p2599
aVSo you want to bind your given pointer to a lambda whose body consists of calling the function
p2600
aVOK, let's see:
p2601
aVBut I doubt that you can do that, because lambdas that capture from the environment are not convertible to naked function pointers, I believe
p2602
aVWe really need a proper function object for your situation, methinks
p2603
as(dp2604
g28
V596781
p2605
stp2606
a((dp2607
g2
(lp2608
VYou cannot - the string's char buffer is not writeable, and you shouldn't do it
p2609
aVYou can always use an intermediate buffer:
p2610
as(dp2611
g28
V596781
p2612
stp2613
a((dp2614
g2
(lp2615
VYou definitely expose your clients to session theft if your connection is not encrypted at all times
p2616
aVHTTP is a stateless protocol, so the only way to fake a stateful interaction is for client and server to send a session identifier with every transaction
p2617
aVIf this isn't protected, it can trivially be stolen
p2618
aVSince the session identifier is the only authentication token during the open session, this is catastrophic
p2619
aVThe usual way to make a "remember me" feature would be to set a cookie whose lifetime is not limited to the browser's program lifetime (i
p2620
ag598
aVby setting an explicit expiration date), and storing some unique data in the cookie which you match against some remembering data (including the IP perhaps) in your database
p2621
aVBut that does not absolve you from the need to encrypt all communication
p2622
as(dp2623
g28
V596781
p2624
stp2625
a((dp2626
g2
(lp2627
VThe spinlock is a "busy waiting" lock
p2628
aVIt's main advantage is that it keeps the thread active and won't cause a context switch, so if you know that you will only be waiting for a very short time (because your critical operation is very quick), then this may give better performance than a mutex
p2629
aVConversely a mutex will cause less demand on the system if the critical section takes a long time and a context switch is desirable
p2630
aVTL;DR: It depends
p2631
as(dp2632
g28
V596781
p2633
stp2634
a((dp2635
g2
(lp2636
VNothing to do with threads, this is just "how do I obtain a pointer to a member function"
p2637
aVDo what the compiler says, say
p2638
aVBut you may also need to pass the instance pointer along
p2639
aVUpdate: Yes, use  like Xeo says
p2640
aVRegarding your title: Note that the function does not "belong to the thread"
p2641
aVClasses are not part of threads
p2642
aVAll threads access the same memory -- each thread has its own space for automatic storage, but there's nothing in a class definition that says "this goes in a separate thread"
p2643
as(dp2644
g28
V596781
p2645
stp2646
a((dp2647
g2
(lp2648
VYour (reduced) example code is equivalent to this:
p2649
aVOr even:
p2650
aVBy closing off the  tag, you appear to get an "empty statement" for free
p2651
aVYour real example could be one-lined like so:
p2652
aVBut note that an  makes this ambigous
p2653
aVWe'd have to disambiguate this:
p2654
aVNow it's clear, but now we could have spared ourselves the colon syntax altogether
p2655
aVThanks to Lekensteyn for pointing this out
p2656
aVSee the discussion below for further oddities
p2657
as(dp2658
g28
V596781
p2659
stp2660
a((dp2661
g2
(lp2662
VLet me give it a shot
p2663
aVI will assume you have only two tables,  and
p2664
aVFirst off, the score subquery:
p2665
aVNow the main query:
p2666
aVPaste the entire subquery into the indicated position
p2667
aVTip: Views
p2668
aVIf you like, you can make the sub-query a permanent view, and use that in the main query:
p2669
aVTip (again): The above tip was stupid, we should use the built-in :
p2670
aVLet's guess what your complete query might look like:
p2671
as(dp2672
g28
V596781
p2673
stp2674
a((dp2675
g2
(lp2676
VWho really cares whether it's "valid", it will have zero impact on anything
p2677
aVThat said, the SGML declaration used by HTML 4
p2678
aV01 allows attribute minimization, whereas the XML SGML declaration (used by XHTML) does not ()
p2679
aVSo take your pick
p2680
aVIf you're one of these modern HTML5-Web2
p2681
aV0 people, then none of the above will be relevant to you and you probably just write
p2682
as(dp2683
g28
V596781
p2684
stp2685
a((dp2686
g2
(lp2687
VFurther to 's answer, your array has size , but you are looping over values , which depending on the values may just run out of bounds (plus it makes no sense)
p2688
as(dp2689
g28
V596781
p2690
stp2691
a((dp2692
g2
(lp2693
VDo you have  available in your
p2694
aVIt's C99
p2695
aVAnd C++0x should also have  to work directly on strings
p2696
as(dp2697
g28
V596781
p2698
stp2699
a((dp2700
g2
(lp2701
VAs a work-around, you could just try and use the regex and see if an error occurs:
p2702
aVThe function  returns  on error, and  when executing without error
p2703
aVBackground: I don't know if regular expressions themselves form a regular grammar, i
p2704
ag598
aVwhether it's even possible in principle to verify a regex with a regex
p2705
aVThe generic approach is to start parsing and checking if an error occurs, which is what the workaround does
p2706
as(dp2707
g28
V596781
p2708
stp2709
a((dp2710
g2
(lp2711
VIf you are confident that you want an array, do it the C++ way, and don't listen to anyone who says "malloc", "for" or "free candy":
p2712
aVIf you don't know for sure that you need an array, use a vector like Konrad says
p2713
as(dp2714
g28
V596781
p2715
stp2716
a((dp2717
g2
(lp2718
VWarning: Serious database design is a non-trivial art
p2719
aVYou may spend a long time just figuring out the correct model for your data
p2720
aVDo that
p2721
aVIt's time well spent
p2722
aVEvery mistake or omission now will cost you manifold later
p2723
aVStore as much information as you have, organized relationally so that there is no redundancy
p2724
aVSo one table for all individual items, and each item has a part type; one table of part types, each type has a vendor and a category (switches, cables, monitors,
p2725
aV; one table for vendors; one table for categories, etc
p2726
aVIf you find that any particular unit of information has to be entered twice, then the relational model is wrong
p2727
aVFinally, make the database present you whichever information you should care to know about, such as counts, tallies, averages, etc
p2728
as(dp2729
g28
V596781
p2730
stp2731
a((dp2732
g2
(lp2733
VYes, begin and rbegin (not end
p2734
aVare the minimum and maximum key value, respectively
p2735
aVIf your key is simple, e
p2736
ag99
aVan integer, you could just create a random integer in the range [min, max) (using ) and get the map's  for that
p2737
as(dp2738
g28
V596781
p2739
stp2740
a((dp2741
g2
(lp2742
VSomething like this:
p2743
as(dp2744
g28
V596781
p2745
stp2746
a((dp2747
g2
(lp2748
VThere will probably not be a complete solution to your problem, since whatever you do, the other party might always take your program, run it in a monitored environment, manipulate the runtime data and let it use its "secure" network protocol
p2749
aVSince the client application is in uncontrollable hands, you can never be sure that it is your own program
p2750
aVBaby example: My application runs your application and plays back the data to your server, and forwards your response back to the application
p2751
aVHow can you tell
p2752
aVThat said, it might be a very promising "99%" approach to use SSL and hardcode the client's private key into the application -- with some trickery you can try and make it hard to find (e
p2753
ag99
aVsee how Skype does it)
p2754
aVIf you then also build integrity checks into your program that figure out whether anyone is manipulating the memory or debugging into your program, you can try and make it a bit harder for a potential adversary
p2755
aV(But note that you will always have to ship the private key with your application, so it isn't really safe from discovery
p2756
as(dp2757
g28
V596781
p2758
stp2759
a((dp2760
g2
(lp2761
VC++0x/TR1 also provides the  which is usually implemented as a hash map
p2762
aVThe differences are twofold:
p2763
aVThe key type
p2764
aVIn the ordered map, the key type must obey a strict weak ordering, and entries are maintained in that order
p2765
aVIn the unordered map, the key type must be equality-comparable and you must provide a hash function  such that  returns  [thanks to Steve Jessop for the clarification]
p2766
aVAccess complexity: Insert/delete/find in an ordered map is O(log n) in the map size n
p2767
aVIn the unordered map, it is "usually" O(1), but worst-case behaviour is O(n) (e
p2768
ag99
aVif all keys map to the same hash value)
p2769
aVSo the ordered map provides a total complexity guarantee, while the unordered map provides a (better) complexity in good cases, depending on the quality of your hash function
p2770
aVThe internal implementation complexity of the unordered map is greater than of the ordered map, but you can imagine that you get the better access complexity because you get fewer features, i
p2771
ag598
aVyou don't get sorting for free
p2772
aVIt's a classical trade-off
p2773
aVAnother point: Practically, if the weak ordering operator is expensive to compute, like for strings, the unordered map may actually be quite a bit faster, because comparisons on the hash type are very fast
p2774
aVOn the other hand, if your key type is one with trivial hash function (like any built-in integral type) and if you don't need the ordering, consider using an unordered container
p2775
as(dp2776
g28
V596781
p2777
stp2778
a((dp2779
g2
(lp2780
VYou didn't initialize , so it's free to contain anything it wants
p2781
aVSet it to zero before you start:
p2782
aV(You need to  for
p2783
aVIn fact, what you're doing is terribly dangerous because there's no guarantee that the string you pass to  is null-terminated
p2784
aVAlways zero the array before use and copy at most 9 non-null characters into it
p2785
as(dp2786
g28
V596781
p2787
stp2788
a((dp2789
g2
(lp2790
VIf your  class for some reason stores the pointer to the , then you open the doors to all sorts of trouble -- when the original  array goes out of scope, you're left with a dangling pointer; you cannot easily copy your class; you have to think about exception safety; etc etc
p2791
aVMuch preferable to use a standard library container that takes care of your problems, like Steve suggests
p2792
aVReferring to the title of your question, if you really just pass the array to "some free function" then perhaps this may be excusable, but you explicitly say that you're using it in the constructor of a dynamically allocated object
p2793
aVThat just reeks of trouble
p2794
as(dp2795
g28
V596781
p2796
stp2797
a((dp2798
g2
(lp2799
VIt's not so much that you're "not allowed to access" the address space of the other function, but rather that that space is a totally different and unrelated address space
p2800
aVEach process has its own virtual address space, so the numeric value of your pointer has no meaning inside another functions address space, even if you were able to exchange it somehow
p2801
aVFor general inter-process communication you usually request shared memory explicitly from the system, but I'm not sure if FreeBasic exposes such functionality
p2802
aVWhy not look up some existing remote procedure call libraries
p2803
as(dp2804
g28
V596781
p2805
stp2806
a((dp2807
g2
(lp2808
VEdit: Here's something offering an improvement based on Marek's answer below
p2809
aVPlease see the comments regarding the practice of putting variables directly into queries and consider using prepared statements
p2810
aVAnyway, here it goes
p2811
aVPHP substitutes variables inside doubly-quoted strings, but not inside singly-quoted strings
p2812
aVOne quote character is just treated as an ordinary character within a string delimited by the other
p2813
aVPutting that together, you can write:
p2814
aVYou cannot write:
p2815
aVworks because it's a doubly-quoted string, and the apostrophes are just ordinary characters
p2816
aVdoes not work because it's a singly-quoted string
p2817
aVAs pointed out by GoodFather below, you can also say  to avoid ambiguities with the ambient string, e
p2818
ag99
as(dp2819
g28
V596781
p2820
stp2821
a((dp2822
g2
(lp2823
VIn the broadest sense, HTML is a document markup language and serves to structure data into a document
p2824
aVThe database on the other hand should contain raw data organized along its logical relations
p2825
aVDocuments use formatting and may present data redundantly, but the true, underlying data is always fixed
p2826
aVThus you should store the most immediate, raw form of data that you possibly can, and retrieve it in meaningful ways using both the query language itself to create suitable views for your purposes, and other, output-specific data processing to generate documents
p2827
aVOf course you may like to cache the result of an output formatting operation, and you may choose to store the cache in a database, too
p2828
aVThat's fine of course
p2829
aVBut concerning the raw payload data, I would always go for the above
p2830
as(dp2831
g28
V596781
p2832
stp2833
a((dp2834
g2
(lp2835
VYou could just access the output array in strides
p2836
aVCompute how many rows you need as the number of results divided by 5, and use the row count as the stride
p2837
aVYou'll have to transfer your query results into an array  first
p2838
aVSince you'll have to know the total number of results, this is sort of mandatory, though I'd be curious if anyone has a solution that can work while fetching the results
p2839
aVUpdate: See Justin's answer for a cool solution that grows the output while fetching the query results line by line
p2840
aVSince it's currently being worked on, here's a summary (credits to Justin):
p2841
as(dp2842
g28
V596781
p2843
stp2844
a((dp2845
g2
(lp2846
VI'm not sure I get your question correctly, but if you just want to execute a lot of system commands from your script, then it doesn't really matter who calls them - you still end up having to spawn new processes and pay the price for that
p2847
aVIf you don't want to run the commands asynchronously, e
p2848
ag99
aVif you always need one result to proceed to the next step, then just keep using
p2849
aVUnless I'm misunderstanding and you are actually compiling C++ code from within your PHP script
p2850
aVThat'd be something else
p2851
as(dp2852
g28
V596781
p2853
stp2854
a((dp2855
g2
(lp2856
VNo, your account is not the same as a server
p2857
aVYour  variable should be set to a suitable hostname or IP address of an SMTP server, like
p2858
aVCheck your email client to find out your own mail server, or ask your ISP
p2859
as(dp2860
g28
V596781
p2861
stp2862
a((dp2863
g2
(lp2864
VYou don't pay for what you don't need
p2865
aVIf you never delete through base pointer, you may not want the overhead of the indirected destructor call
p2866
aVPerhaps you were thinking that the mere existence of the vtable is the only overhead
p2867
aVBut each individual function dispatch has to be considered, too, and if I want to make my destructor call dispatch directly, I should be allowed to do so
p2868
aVIt would be nice of your compiler to warn you if you do ever delete a base pointer and that class has virtual methods, I suppose
p2869
aVEdit: Let me pull Simon's excellent comment in here: Check out this SO question on the code generated for destructors
p2870
aVAs you can see, there's also code-bloat overhead to be considered
p2871
as(dp2872
g28
V596781
p2873
stp2874
a((dp2875
g2
(lp2876
VAdd a forward declaration at the top of your code:
p2877
aV(Make sure to compile that code with full optimizations
p2878
aV:-) )
p2879
as(dp2880
g28
V596781
p2881
stp2882
a((dp2883
g2
(lp2884
VAlternatively, you can use static const members:
p2885
as(dp2886
g28
V596781
p2887
stp2888
a((dp2889
g2
(lp2890
VIf you're just sitting at the command line and want to play around, give Perl a shot:
p2891
aV(**) marks an example of using the capture groups
p2892
as(dp2893
g28
V596781
p2894
stp2895
a((dp2896
g2
(lp2897
VFor a general subset I don't know, but if you can guarantee that  is of the form , then this may do:
p2898
aV(Sorry,  is a terrible name
p2899
aVIt should be called something more appropriate, like
p2900
aVUpdate: Here is the general solution, worked out in detail by Luc Danton (see here for his beautifully styled code):
p2901
aVTest case:
p2902
as(dp2903
g28
V596781
p2904
stp2905
a((dp2906
g2
(lp2907
VMaybe like this:
p2908
as(dp2909
g28
V596781
p2910
stp2911
a((dp2912
g2
(lp2913
VHere's a solution: Instead of truncating  from the back, I just truncate  from the front:
p2914
as(dp2915
g28
V596781
p2916
stp2917
a((dp2918
g2
(lp2919
VThis is a tall order, and you'll have to develop some of the logic yourself
p2920
aVHowever, here's a skeleton solution:
p2921
aV1) Write a function that ranks rules according to their relevance for a given set of data:
p2922
aV2) For each piece of data, create a sorted ranking of the rules
p2923
aVFor instance, you could keep a bunch of iterators around
p2924
aVThen find the service that matches the most relevant rule set
p2925
aVI'm supposing that all your rules are kept in , some container of value type
p2926
aVEdit: Fixed multimap element insertion -- multimap does not have a  access operator for obvious reasons
p2927
as(dp2928
g28
V596781
p2929
stp2930
a((dp2931
g2
(lp2932
VCryptography and security are complex subjects with many subtle challenges, so if you don't feel comfortable and conversant with those, I should warn you against deploying your own security-critical application
p2933
aVThat said, let me just address the issue of encryption and authentication, as provided by SSL: Encryption prevents third parties from learning the content of your conversation
p2934
aV"Third parties" in your context would be anyone from other people in the same internet cafe to anyone along the route between your user and your server
p2935
aVYou should essentially consider all unencrypted communication to be publicly posted on a wall
p2936
aVBut encryption alone does not guarantee that the person you are conversing with is in fact the intended partner
p2937
aVAn attacker could, with relative ease, link himself into the conversation and pretend to the user to be the server and to the server that he's the user, thus reading everything that's said, encrypting and decrypting each channel as appropriate
p2938
aVTo avoid this man-in-the-middle attack, authentication is crucial
p2939
aVThis is made possible in one direction by the use of certificates
p2940
aVThat is, if your server has a certificate, then the user can be sure to be talking to the right server
p2941
aV(The client doesn't usually get a certificate, as authentication in that direction is rather performed higher up in the flow
p2942
aVBut it all boils down to whether your users know your certificate
p2943
aVIn principle, you have to supply your server certificate to the user "by reliable means", but there's no general recipe for doing so
p2944
aV(A phone call would be fairly good
p2945
aVInstead, a "hierarchy of trust" can be invoked by which users trust certificates which are recursively trusted by higher and higher authorities
p2946
aVSince a collection of such trusted root authorities is shipped with most browsers, a purchased certificate with their signature will make your own certificate appear as "trusted" to the user
p2947
aVPractically, the question is whether users will care about the trustedness of certificates
p2948
aVIn the ideal world they would decline all untrusted ones, and you would be forced to obtain a signed certificate
p2949
aVBut many contemporary legitimate bodies do use unsigned certificates, so that many users are totally trained to ignore this problem
p2950
aVThat said, you might get away with an unsigned certificate, but by requiring users to trust an untrusted certificate, you are training people to do the Wrong Thing, which may eventually backfire on all of us
p2951
aVYour call
p2952
as(dp2953
g28
V596781
p2954
stp2955
a((dp2956
g2
(lp2957
VUse :
p2958
aVmeans "give me b rows, starting at row a", and  is zero-based
p2959
aVOK, I misunderstood
p2960
aVNow
p2961
aVSuppose your server has 27 votes
p2962
aVYour server's rank will be 1 plus the result; ties are possible (i
p2963
ag598
aVranks will be like 1, 2, 3, 3, 3, 6, 7, 7, 9 etc
p2964
as(dp2965
g28
V596781
p2966
stp2967
a((dp2968
g2
(lp2969
VI think you have it the wrong way round: On unsigned data types, bit shifting does exactly what it says on the tin, and unoccupied bits are filled with zeros
p2970
aVThis causes the correct modular arithmetic operations on the types's values for left-shift, which is multiplication
p2971
aVRight-shift has no arithmetic analogue because Z/nZ is not a division ring in general and there is no notion of division; right-shift is just truncating division
p2972
aVOn the other hand, signed types suffer from an ambiguity, because there are different ways of interpreting a bit pattern as a signed integer
p2973
aVWith left-shift on 2's-complement you will get the expected "wrap-around" for multiplication, but there's no canonical choice of right-shift behaviour
p2974
aVIn the old C standard I believe that was fully implementation defined, but I think C99 made that behaviour specific
p2975
as(dp2976
g28
V596781
p2977
stp2978
a((dp2979
g2
(lp2980
VOK, since you're asking what's "easiest" despite two good answers, perhaps you mean "what's easiest to read" -- a great point, so let's try a rewrite:
p2981
aVIf you really do want to use named variables in the loop, use references:
p2982
as(dp2983
g28
V596781
p2984
stp2985
a((dp2986
g2
(lp2987
VWhy not just write
p2988
aVThat performs about as few operations as necessary
p2989
aVIf you have atomicity requirements, I suppose one would have to think a bit harder and use temporaries
p2990
as(dp2991
g28
V596781
p2992
stp2993
a((dp2994
g2
(lp2995
VAn integral type is "like" an integer, i
p2996
ag598
aVits values are whole numbers
p2997
aVThe standard C integral types are all the flavours of  and , and also pointers (because pointers are just numbers, namely memory addresses)
p2998
aVAt machine level, integral values are typically handles in the CPU's main general purpose registers
p2999
aVContrast this to "floating point" values, which are typically handled in a different set of registers, and whose binary expression is not directly related to its value
p3000
aVI guess in total you have four sorts of types: integral, floating point and compound (structs etc
p3001
aV, and arrays
p3002
as(dp3003
g28
V596781
p3004
stp3005
a((dp3006
g2
(lp3007
VUse  and the  aggregate:
p3008
as(dp3009
g28
V596781
p3010
stp3011
a((dp3012
g2
(lp3013
VYou don't reset your  after the inner loop
p3014
aVBut why such a horribly verbose code
p3015
aVTry this:
p3016
aV(If you want strict ANSI C89, you have to pull the declarations of  and  out of the loops of course
p3017
aVAlso note that  is a -literal of value 0, so you might just as well, and more correctly, say
p3018
aVAnd instead of  you can just say , which is what I did in the for loops
p3019
as(dp3020
g28
V596781
p3021
stp3022
a((dp3023
g2
(lp3024
VThat's terribly roundabout and obscure
p3025
aVIf you already have an active session, why don't you just store this kind of data (which the client never needs to know, mind you) in your server-side session data
p3026
aVAll you should ever need to exchange with the client is the session ID, really
p3027
as(dp3028
g28
V596781
p3029
stp3030
a((dp3031
g2
(lp3032
VEven though the languages of this family are all related, that does not mean that you can casually move from one to the other and expect to write beautiful code
p3033
aVYou have to learn the language's idioms and idiosyncrasies, and experience its strengths and way of thinking
p3034
aVI would recommend reading Stroustrup's original book (a modern edition, of course)
p3035
aVIt's the most definitive reference (short of the actual standard) and it is very clearly written
p3036
aVThe benefit of this approach is that you will be taught to think "how would I do this in C++", rather than "how do I transliterate this piece of Java code to make it compile"
p3037
aV(Also this approach does away with any risk you might have of thinking you should "learn C first"
p3038
aVDon't
p3039
aVOn MacOSX, either download and build the free GCC, or get XCode (which comes with GCC)
p3040
aVFor iOS I don't know, I have a suspicion that you cannot deploy native code on it
p3041
as(dp3042
g28
V596781
p3043
stp3044
a((dp3045
g2
(lp3046
VYour  string is not null-terminated
p3047
aVAlso, the delimiters are matched character-by-character, so there is no use repeating the space six times, nor will your call to  match a run of six spaces
p3048
aVPerhaps you need something like
p3049
as(dp3050
g28
V596781
p3051
stp3052
a((dp3053
g2
(lp3054
VIf you guarantee that  is an ordered subsequence of , you could write this yourself:
p3055
aVOK, for the general case, where  isn't necessarily in the correct order
p3056
aVUsing predicates is no good, because the predicate must have a const call, and we need to manipulate the object (or some other state variable)
p3057
aVSo let's try a variation of the above instead:
p3058
as(dp3059
g28
V596781
p3060
stp3061
a((dp3062
g2
(lp3063
VYou can use the  option to pass one statement to the database:
p3064
as(dp3065
g28
V596781
p3066
stp3067
a((dp3068
g2
(lp3069
VSort your data by date (add  to the query) and then just display
p3070
aVKeep track of when the date changes so that you only need to print the date when it changes
p3071
as(dp3072
g28
V596781
p3073
stp3074
a((dp3075
g2
(lp3076
V will occupy N times  contiguous bytes in memory
p3077
as(dp3078
g28
V596781
p3079
stp3080
a((dp3081
g2
(lp3082
VIf you are just working on one single system, you could write the actual binary data out to the file, that'll give you an exact copy
p3083
aVIf you want to write to a text file, convert the binary to Base64 or something like that
p3084
aVOptionally, encode the bytestream as base64
p3085
aVIf you want to store long doubles and you are going for base64-encoding, note that the long double is usually only 10 bytes, so you can ignore the padding that it usually gets when you serialize
p3086
aVIf you plan to exchange data between different platforms, but all of which use IEEE floats, you should probably be more careful and document the endianness of the file format
p3087
aVIn that case, writing an ASCII string with base64-encoding would be more portable
p3088
aVTo exchange data between platforms that do not all use the same binary float representation, you'd have to work even harder
p3089
as(dp3090
g28
V596781
p3091
stp3092
a((dp3093
g2
(lp3094
VDefine the function templated and use explicit template instantiation:
p3095
aVNote that I would strongly recommend putting that in the header and inlining it
p3096
as(dp3097
g28
V596781
p3098
stp3099
a((dp3100
g2
(lp3101
VTry Do not do this:
p3102
aVNo C++ needed :-)
p3103
aVPS Save all your open documents before using
p3104
aVOK, here's a more benign version:
p3105
aVNow you just need to write a program  that takes PIDs as arguments and prints out those PIDs which you determine as bad
p3106
aVOr even  if you write a program that determines if a PID is bad and immediately calls  as MKP says above
p3107
as(dp3108
g28
V596781
p3109
stp3110
a((dp3111
g2
(lp3112
VI think you make a bare repository on the remote side, , add the remote side as the push/pull tracker for your local repository (), and then locally you just say
p3113
aVNow any other repository can  from the remote repository
p3114
as(dp3115
g28
V596781
p3116
stp3117
a((dp3118
g2
(lp3119
VTry the direct, normalized approach: One table with this schema:
p3120
aVYou have one row for every key->value relation
p3121
aVAdd an index for each column, and lookup should be reasonably efficient
p3122
aVHave you profiled any of this to exhibit a bottleneck
p3123
as(dp3124
g28
V596781
p3125
stp3126
a((dp3127
g2
(lp3128
VThe browser will never transmit any information about the client's directory structure, so such a general solution as you envision it is not possible in terms of directories
p3129
aVWhat you can hope for is that clients will offer a facility to turn a user's directory selection into a list of contained files, but in any event this would not be of any concern to you on the server side
p3130
as(dp3131
g28
V596781
p3132
stp3133
a((dp3134
g2
(lp3135
VThe following works for me in GCC 4
p3136
ag263
aV1:
p3137
aVHere's a wrapper using lambdas, but it's not automagic yet
p3138
aVForget the middle part
p3139
aVOK, since  is type-erasing, it's hard to get at the underlying types
p3140
aVHowever, if you go for the function reference directly, you can avoid these problems entirely:
p3141
as(dp3142
g28
V596781
p3143
stp3144
a((dp3145
g2
(lp3146
VIf you are already on Posix, you should have access to , so you essentially get those features for free
p3147
aVI don't think it's too heavy-weight, either
p3148
aVWriting a converter yourself isn't hard, either (leave a comment if you want the code), just remember to abort with error as soon as you find an error in the UTF input sequence
p3149
as(dp3150
g28
V596781
p3151
stp3152
a((dp3153
g2
(lp3154
VTry this:
p3155
aVAggregate queries like  are the key for this sort of data processing
p3156
as(dp3157
g28
V596781
p3158
stp3159
a((dp3160
g2
(lp3161
VRead it out aloud: "BB, or not B, not B"
p3162
aVOr, "Two B, or not two B"
p3163
aVHmm
p3164
aVnot sure, somebody wants to check for the letter B I guess
p3165
as(dp3166
g28
V596781
p3167
stp3168
a((dp3169
g2
(lp3170
VHappily, ASCII, ISO-8859-1 and Unicode all agree on codepoints in the range 0
p3171
aV127
p3172
aVThus your character  will be encoded identically in ASCII, ISO-8859-1 and UTF-8
p3173
aVIf your program assigns special semantics to the zero byte, you have to take care of that appropriately
p3174
as(dp3175
g28
V596781
p3176
stp3177
a((dp3178
g2
(lp3179
VOut of curiosity, I had a look at the GCC sources:
p3180
aVLater
p3181
aVIt seems that they were indeed worried that an ambiguity could arise, so an explicit use of typetraits and overloading is used to check whether the template matched an integral type or not
p3182
as(dp3183
g28
V596781
p3184
stp3185
a((dp3186
g2
(lp3187
VHard to see through the code, but in your "real" code you say , which is synonymous to , and later I think you are accessing a member of the (now empty) string:
p3188
as(dp3189
g28
V596781
p3190
stp3191
a((dp3192
g2
(lp3193
VHere's a solution in Perl:
p3194
as(dp3195
g28
V596781
p3196
stp3197
a((dp3198
g2
(lp3199
VYou can get the number of posts per month like this:
p3200
aVNow we need the number of days in a month:
p3201
aVThis will get the average number of posts per day during the calendar month of the post
p3202
aVThat is, averages during the current month will continue to rise until the end of the month
p3203
aVIf you want real averages during the current month, you have to put in a conditional to get the true number of elapsed days
p3204
as(dp3205
g28
V596781
p3206
stp3207
a((dp3208
g2
(lp3209
VEveryone is being so negative, and while I share the sentiment that you personally should probably not be doing this, let me make some general remarks:
p3210
aVFor a secure channel you need three things:
p3211
aVline encryption
p3212
aVkey exchange
p3213
aVauthentication
p3214
aVFor encryption, you need to implement a cipher
p3215
aVThat's doable
p3216
aVKey exchange is the crucial point: Both peers need to know that they know a common key without anyone else being able to know the common key
p3217
aVThere exist protocols for that, and it should be possible to implement that
p3218
aVSSL is doing that, for example
p3219
aVThe fact that you can sniff an SSL connection and not learn anything shows that it can be done
p3220
aVAuthentication is necessary to stop man-in-the-middle attacks, and this requires some sort of out-of-band information exchange (like a phone call or PKI infrastructure)
p3221
aVWhether any of this really works practically is highly debatable, even for SSL
p3222
aVSo basically if you can implement all those components over HTTP, then in principle it should be possible to run secure communication over HTTP
p3223
aVAfter all, SSL is doing the same thing, it's running a secure channel over an insecure medium
p3224
aVBasically what you want is to implement SSL in JavaScript
p3225
aVCheck out aSSL, they've tried something like that
p3226
as(dp3227
g28
V596781
p3228
stp3229
a((dp3230
g2
(lp3231
VFirst off, spell you column names correctly --  or , what shall it be
p3232
aVSecond, this is just a plain inner join:
p3233
as(dp3234
g28
V596781
p3235
stp3236
a((dp3237
g2
(lp3238
VYour  function incurs undefined behaviour since it is not returning a value in all execution paths
p3239
aVYou may want to say  in the last part (or just  in one go)
p3240
as(dp3241
g28
V596781
p3242
stp3243
a((dp3244
g2
(lp3245
VIf the positions are fixed, you can use Bash's substring parameter expansion:
p3246
aVThis prints
p3247
aVYou can use this for example in a  loop:
p3248
as(dp3249
g28
V596781
p3250
stp3251
a((dp3252
g2
(lp3253
VYou cannot put templates in a library in the way you might think
p3254
aVYou can only put actual, instantiated class definitions in a library
p3255
aVTemplates are essentially a code generation tool, and you can only put generated code into the library
p3256
aVYou might want to use explicit template instantiation to make the compiler generate the code, and take the static member definition out of the header:
p3257
aVNow compile the source file into the library; this will contain the instance of the static member variable
p3258
aVNote that your consumers will only be able to use instances of your class with  since they don't have access to the static member otherwise (i
p3259
ag598
aVthey'd have to provide their own)
p3260
as(dp3261
g28
V596781
p3262
stp3263
a((dp3264
g2
(lp3265
VYou should activate name-based virtual hosting and only show your real website for the desired domain names
p3266
aVFor all other names, you can display a suitable error message
p3267
aVDetails: Your webserver is contacted by its IP address
p3268
aVThere is nothing you can do to stop that
p3269
aVAnyone can say, "connect to that IP address"
p3270
aVFor instance, anyone can register new domain names to point to your server's IP address
p3271
aVHowever, inside the request, there is a field  with a name like
p3272
aVUpon receiving the request, your server may choose to inspect the  field and deliver different content depending on that value
p3273
aVIn the simplest case, the server ignores the field entirely and always prints out the same content
p3274
aVBut in a more sophisticated set-up, so called "name-based (virtual) hosting", the server chooses the content depending on the hostname
p3275
aVThis is how shared webhosts work: There's a single server, but depending on the requested hostname it spits out a different website for each name
p3276
aVTherefore, if you want to tie your server content to your hostname, you have to tell your server to produce your website only for your desired name, and to produce a different (error) website for all other cases
p3277
aVIn Apache this is trivial to configure, just check their documentation; for IIS I wouldn't know but I imagine it's equally simple
p3278
as(dp3279
g28
V596781
p3280
stp3281
a((dp3282
g2
(lp3283
VYou can try grouping by 10 units of price:
p3284
as(dp3285
g28
V596781
p3286
stp3287
a((dp3288
g2
(lp3289
VYou can certainly do it (see GMan's answer for the correct parametrization of the derived type), but bear in mind that you will get entirely independent class hierarchies for every type
p3290
aVYou are not magically creating a super class that has an arbitrary number of member types
p3291
aVConsider templates as a code generation tool
p3292
aVThey do not create a "type-generic type", rather they create lots of parallel instances of concrete, static types at compile time following a generic pattern
p3293
aVIf you truly want one single common base type, perhaps you can make the type of  polymorphic:
p3294
aVThen all your derived classes can access the states' common interface
p3295
as(dp3296
g28
V596781
p3297
stp3298
a((dp3299
g2
(lp3300
VIn your first case you lose no precision, PHP is just formatting the larger number as a float
p3301
aV(Internally the number is kept as a float
p3302
aVTry this go get the "precise" output:
p3303
aVNext up, in the case of , your two numbers individually already exceed the capacity of a standard IEEE-64-bit float (which is 53 bit, while you need at least 55), so precision is already lost when you store those numbers
p3304
aVThe problem of losing precision during addition/subtraction is called "cancellation": All the most-significant bits on which you spent all your storage canceled out, and you end up with not enough accurate bits to fill up the manitssa
p3305
aVC'est la vie
p3306
aVImagine you're sitting on the moon and you take two measurements of your brother's beard hair length in Worcester, UK
p3307
aVComparing the two measurements suffers from your requirement to store a very large amount of precision
p3308
as(dp3309
g28
V596781
p3310
stp3311
a((dp3312
g2
(lp3313
Vand  are equivalent, so use whichever you prefer
p3314
aVHoisting the  out of the loop may or may not be something the compiler would do anyway, in any event, it makes it explicit that the container end isn't changing
p3315
aVUse const-iterators if you aren't going to modify the elements, because that's what they mean
p3316
aVIn C++0x, use +:
p3317
aV(Perhaps you'd like to use a ready-made container pretty-printer
p3318
as(dp3319
g28
V596781
p3320
stp3321
a((dp3322
g2
(lp3323
VFrom the manual:
p3324
aVPHP only supports a 256-character set, and hence does not offer native Unicode support
p3325
aVYou could enter a manually-encoded UTF-8 sequence, I suppose
p3326
aVYou can also type out UCS4 as byte sequence and use  to convert it into UTF-8 for further processing
p3327
aVYou just can't input the codepoint as a 32-bit code unit in one go
p3328
as(dp3329
g28
V596781
p3330
stp3331
a((dp3332
g2
(lp3333
VHow is the webserver supposed to identify itself if it cannot read the private key
p3334
aVIt has to be readable to the webserver's process, but it should also be 0400
p3335
aVAlternatively use suexec or something like that to let the login process be done by some other user
p3336
aVThat said, if there is any way in which the webserver can be commanded to perform some remote admin activity, you'll have to think carefully about the security implications anyway
p3337
aVNo matter how safe you keep the key, if anyway can coax the server into performing a remote action you're still in trouble
p3338
as(dp3339
g28
V596781
p3340
stp3341
a((dp3342
g2
(lp3343
VI'm just describing an idea for the algorithm, no full solution:
p3344
aVBasically, you have three numbers , ,  and you are looking for three new numbers , ,  and a multiplier  in the range [0,1] such that:
p3345
aVThis is written in units where the channels also take values in the range [0,1]
p3346
aVIn 8bit discrete values, it'd be something like this:
p3347
aVMoreover, you want the largest possible value
p3348
aVYou can solve:
p3349
aVEtc
p3350
aVIn real values this has infinitely many solutions, just plug in any real number , but the problem is to find a number for which the discretization error is minimal
p3351
as(dp3352
g28
V596781
p3353
stp3354
a((dp3355
g2
(lp3356
VIn modern operating systems (which include Linux, Win2K+ and MacOSX), every process can only access an area of "virtual memory" which is managed by the OS and cleaned up entirely after the process's lifetime finishes
p3357
aVA memory access error on part of the process that causes the process to be terminated simply means that the process has tried to access part of its virtual address space which it has not informed the OS about and which the OS did not want to process to access, but this does not affect anything outside that one process
p3358
aVThere is no direct access to "real" memory for userspace processes, and thus you cannot really do a huge amount of harm
p3359
aV(OK, I'm glossing over things, if you accidentally triggered an API call to "kill" and you had admin privileges, I suppose you could cause some harm
p3360
aVBut you know what I mean
p3361
as(dp3362
g28
V596781
p3363
stp3364
a((dp3365
g2
(lp3366
VYou cannot directly template a lambda, but perhaps you can make a templated lambda factory:
p3367
aVOr even:
p3368
aVThen you can create a couple of instances:
p3369
aVNot sure if you would need to create lambdas in that way, but if you find you do, then templating can be achieved by such a wrapper
p3370
as(dp3371
g28
V596781
p3372
stp3373
a((dp3374
g2
(lp3375
VYou need a library that implements SMTP
p3376
aVFor C++, I suggest you take a look at VMime, though I'm not entirely sure whether it's supported on Windows (there's a section on compiling with MingW, though, so I imagine that there's native Winsock support)
p3377
aVAlternatively, the C library libcurl handles many protocols, including SMTP
p3378
as(dp3379
g28
V596781
p3380
stp3381
a((dp3382
g2
(lp3383
VJavascript has only one numeric data type, which is the standard 64-bit double-precision float
p3384
aVEverything is a double
p3385
aVNaN is a special value of double, but it's a double nonetheless
p3386
aVAll that  does is to "cast" your string into a numeric data type, so the result is always "number"; only if the original string wasn't parseable, its value will be NaN
p3387
as(dp3388
g28
V596781
p3389
stp3390
a((dp3391
g2
(lp3392
VThat's not how predicates work
p3393
aVYou have to supply either a free function , or build a function object, a class that overloads :
p3394
aVIn C++0x:
p3395
aVThis captureless lambda is in fact equivalent to a free function
p3396
aVHere is a capturing version that mimics the predicate object:
p3397
as(dp3398
g28
V596781
p3399
stp3400
a((dp3401
g2
(lp3402
VTo initialize a GMP integer from a string in C++, you can use  and directly use a constructor:
p3403
aVIf you still need the raw  type, say
p3404
aVIn C, you have to spell it out like this:
p3405
aVSee the documentation for further ways to initialize integers
p3406
as(dp3407
g28
V596781
p3408
stp3409
a((dp3410
g2
(lp3411
VI read an FAQ about this the other day
p3412
aVfirst off, write the correct headers, i
p3413
ag598
aVinclude all headers that you use and don't depend on undocumented dependencies (which may and will change)
p3414
aVSecond, compilers usually recognize include guards these days, so they're fairly efficient
p3415
aVHowever, you still need to open a lot of files, which may become a burden in large projects
p3416
aVOne suggestion was to do this:
p3417
aVHeader file:
p3418
aVNow to use the header in your source file, add an extra :
p3419
aVIt'll be noisier in the source file, and you require predictable include guard names, but you could potentially avoid a lot of include-directives like that
p3420
as(dp3421
g28
V596781
p3422
stp3423
a((dp3424
g2
(lp3425
VYou need to add the contributions to the running tally:
p3426
aVPerhaps even better to divide by , and even better to leave the division to the end
p3427
aVFinally, be careful with integer division, which might not do what you think it does
p3428
as(dp3429
g28
V596781
p3430
stp3431
a((dp3432
g2
(lp3433
VThere are many different steps in what you just said:
p3434
aVis a shell script that sets up the build environment
p3435
aVis a tool that invokes various instances of the compiler (and many other things) depending on file dependencies (whether dependent files are newer than target files)
p3436
aVThe actual "compiler" invocation is perhaps what you're most interested in: Preproccessing, compiling, assembling, you seem to be happy with those
p3437
aVFinally, linking: All the object files have to be turned into an executable: The linker will look for one entry point (typically )
p3438
aVAll symbols (i
p3439
ag598
aVfunctions and global variables) that appear have to be filled in with the address of actual code that's supplied in other object files
p3440
aVOnce all the symbols from your local object files have been used, you may still have "undefined symbols" which need to be fed from libraries
p3441
aVSo the result of a complete linking typically is a binary where all the names of functions (may) have been removed and replaced by the actual addresses (never mind PIC) of code or references to load-time shared libraries
p3442
aVEssentially, your initial collection of objects is no longer visible in the linked binary
p3443
aV(Modern link-time optimization may in fact mix up and prune your code very severely
p3444
aVOn the other hand, a static library created with  is just a collection of raw, unlinked objects with all their symbols intact which may be used for linking
p3445
aVHm, this was a very hectic overview of a vast subject, so naturally this is nowhere near complete or representative, and probably only partially correct
p3446
aVPost a comment if you have a specific concern
p3447
as(dp3448
g28
V596781
p3449
stp3450
a((dp3451
g2
(lp3452
VThis is a bit muddled
p3453
aVWhat you say are not "things that you can do to speed things up"; rather, they are mandatory requirements of your type to be eligible as the element type of an unordered map, and also for an unordered set (which you might rather want)
p3454
aVYou need to provide an equality operator that compares objects, not hash values
p3455
aVThe whole point of the equality is to distinguish elements with the same hash
p3456
aVis an unsigned integral type, 32 bits on x86 and 64 bits on x64
p3457
aVSince you want "billions of elements", which means many gigabytes of data, I assume you have a solid x64 machine anyway
p3458
aVWhat's crucial is that your hash function is good, i
p3459
ag598
aVhas few collisions
p3460
aVYou want a set, not a map
p3461
aVPut the objects directly in the set:
p3462
aVUse a map if you are mapping to something, i
p3463
ag598
aVstates to something else
p3464
aVOh, use C++0x, not boost, if you can
p3465
aVUsing  is good
p3466
aVBaby example:
p3467
as(dp3468
g28
V596781
p3469
stp3470
a((dp3471
g2
(lp3472
VIt's about exception safety
p3473
aVSince  is already constructed when the operator is called, we know there's no exception, and  doesn't throw
p3474
aVIf you did the member assignments manually, you'd risk that each of those might throw an exception, and then you'd have to deal with having partially move-assigned something but having to bail out
p3475
aVMaybe in this trivial example this doesn't show, but it's a general design principle:
p3476
aVCopy-assign by copy-construct and swap
p3477
aVMove-assign by move-construct and swap
p3478
aVWrite  in terms of construct and , etc
p3479
aVBasically, you try to minimize the amount of "real" code and try to express as many other features in terms of the core features as you can
p3480
aV(The  takes an explicit rvalue reference in the assignment because it does not permit copy construction/assignment, so it's not the best example of this design principle
p3481
as(dp3482
g28
V596781
p3483
stp3484
a((dp3485
g2
(lp3486
VLeaving the burden of matching the endianness with your other function to you, here's one way:
p3487
aVJust to be safe, here's the corresponding other direction:
p3488
aVGoing from  to long and back is entirely reversible; going from long to  and back is reversible for values up to 2^32-1
p3489
aVNote that all this is only well-defined for unsigned types
p3490
aV(My example is little endian if you read  from left to right
p3491
aVAddendum: I'm also assuming that
p3492
aVIn general, substitute multiples of 8 by multiples of  in the code
p3493
as(dp3494
g28
V596781
p3495
stp3496
a((dp3497
g2
(lp3498
VHere's a hex dump, about as general as you can get:
p3499
aVNote that the result of this is entirely implementation-defined; presumably there'll be plenty of padding, and you won't know what any of the printed values mean
p3500
aV(Most of them will probably just be pointers to some other part of space
p3501
aVAs Etienne says, C is a statically typed language and does not have reflection, so you have to know the declaration of  in order to interpret the content of
p3502
as(dp3503
g28
V596781
p3504
stp3505
a((dp3506
g2
(lp3507
VIf your  is const, you could use a little helper class:
p3508
as(dp3509
g28
V596781
p3510
stp3511
a((dp3512
g2
(lp3513
VThis will work:
p3514
aVGCC 4
p3515
ag263
aV1 actually gave a very helpful warning:
p3516
as(dp3517
g28
V596781
p3518
stp3519
a((dp3520
g2
(lp3521
VTalking about C++0x here, make the suitable adaptations for TR1 if you please
p3522
aVdiffers from  in that it does not provide convenience overloads for operators
p3523
aVUsing the documentation, we can build the standard replacement:
p3524
as(dp3525
g28
V596781
p3526
stp3527
a((dp3528
g2
(lp3529
VYou could start with a counting query for visits:
p3530
aVThen you can base further queries off this one by joining
p3531
as(dp3532
g28
V596781
p3533
stp3534
a((dp3535
g2
(lp3536
VGenerically:
p3537
aVIf you want the diagonal entries , start at
p3538
as(dp3539
g28
V596781
p3540
stp3541
a((dp3542
g2
(lp3543
VTry this:
p3544
aVIt's only hours for now, though you could replace it by MINUTEs
p3545
as(dp3546
g28
V596781
p3547
stp3548
a((dp3549
g2
(lp3550
VSay
p3551
aVThe  means "pad with zeros", the  means "at least four characters wide"
p3552
aVFor integers, one doesn't use the term "precision" (because integers are precise), but rather "field width" or something like that
p3553
aVPrecision is the number of digits in scientific notation when printing floats
p3554
as(dp3555
g28
V596781
p3556
stp3557
a((dp3558
g2
(lp3559
V refers to an entire function
p3560
aVYou can call , with any number of arguments, too
p3561
aVThis is a typical call-back pattern: Whoever is in charge of the  object wants to call you back when she's ready, so you pass this function to her
p3562
aVYou can't really control how many variables (of any type
p3563
aVwill be passed to your function, but presumably the documentation will have told you that you'll receive at least one
p3564
as(dp3565
g28
V596781
p3566
stp3567
a((dp3568
g2
(lp3569
VPerhaps some additions to Steve's nice answer:
p3570
aVIndeed, internal allocation is done by allocators, which serve two separate purposes: Allocating and releasing memory, and constructing and destroying objects
p3571
aVObjects are always (copy or move) constructed on  and destroyed on , however, the interna vary
p3572
aVNode-based containers will typically allocate and construct an entire internal node, which contains both the actual object and bookkeeping data (like the next/prev pointers in a doubly-linked list)
p3573
aVWhen you erase one of those, the container will destroy the object and release the memory
p3574
aVSequence containers like vector will strictly separate allocation and construction; the amount of memory that's been allocated will typically only grow, but when you erase (after the erased object's destructor has been called), the other elements have to be moved to maintain contiguous memory layout
p3575
aVThe internal allocator work may look quite different from your usual  work if you haven't seen it before, but ultimately there's always a construction and a destruction somewhere
p3576
as(dp3577
g28
V596781
p3578
stp3579
a((dp3580
g2
(lp3581
VIf you have a  or  string, use the / functions to read a double
p3582
ag2071
ag99
aVusing @Steve's suggestion:
p3583
aVApparently  has implicit conversion operators both to  and , so you can use them directly in the float parsing functions
p3584
as(dp3585
g28
V596781
p3586
stp3587
a((dp3588
g2
(lp3589
VUse the  function to return the difference between then and  in days
p3590
as(dp3591
g28
V596781
p3592
stp3593
a((dp3594
g2
(lp3595
VOK, I don't know what you're really trying to do, but here's a skeleton idea:
p3596
as(dp3597
g28
V596781
p3598
stp3599
a((dp3600
g2
(lp3601
VIf you really care, you can find out: Just make a single source file with one function with that loop and look at the optimized assembly:
p3602
aVYou can directly see the differences
p3603
aVI bet there are none
p3604
aVThat said, you should use the iterator pattern because it's idomatic, generic C++ and it gets you in the right mood -- plus, it works in far more general cases than just vectors
p3605
aVWrite it like this:
p3606
aVIn case you're curious, a vector iterator is most likely just going to be a native, raw pointer, so there's really nothing to fear in terms of efficiency, and a lot to be enjoyed from the self-explanatory, algorithmic style
p3607
aVPS If you have C++0x, say it like this:
p3608
as(dp3609
g28
V596781
p3610
stp3611
a((dp3612
g2
(lp3613
VI think a useful definition for "non-trivial" to keep in mind is a "general case which does not suffer degeneracies and includes 'typical' features"
p3614
aVFor example, a non-trivial configuration of two lines in a plane would be two crossing lines, but not two lines on top of each other
p3615
aVFor database purposes, suppose you want to test your new "DISTINCT" query
p3616
aVA non-trivial dataset would include repeated values, since you typically expect to encounter those
p3617
aVA table with all unique values would be a legal dataset, but you couldn't tell a DISTINCT query from a non-distinct one by its result set on such a table
p3618
aVSo your dataset should have examples of all the features that you are expecting and writing a handler for
p3619
as(dp3620
g28
V596781
p3621
stp3622
a((dp3623
g2
(lp3624
VMost modern operating systems employ a memory manager, and all userland processes only see so-called virtual memory, which is not related to actual system memory in a way that the program could inspect
p3625
aVThis means that programs cannot simply read another process's memory or kernel memory
p3626
aVIt also means that the memory manager will completely "free" all memory that has been assigned to a process when that process terminates, so that memory leaks within the program do not usually "affect" the rest of the system (other than perhaps forcing a huge amount of disk swapping and perhaps some "out of memory" behaviour)
p3627
aVThis doesn't mean that it's in any way OK to treat memory leaks light-heartedly, it only means that no single program can casually corrupt other processes on modern multi-tasking operating systems (deliberate abuse of administrative privileges notwithstanding, of course)
p3628
as(dp3629
g28
V596781
p3630
stp3631
a((dp3632
g2
(lp3633
VTo address the last point first: Strict XHTML 1
p3634
aV1 suffers from the fact that the W3C recommendation really requires you to deliver the document as MIME type  or something like that, and that's virtually impossible to set up on a web server in a way that satisfies most, if not all, current clients
p3635
aVSo if you cannot do it right anyway you might as well just use HTML 4
p3636
aV01, which is grammatically nearly equivalent and arguably more powerful (e
p3637
ag99
aVHTML 4
p3638
aV01 can validably prohibit nested anchors, while XHTML has to add that as a textual extra clause)
p3639
aVYou'll get the same job done, and it'll actually be understood by nearly all existing clients
p3640
aV(Since I trust you'll only be using DOM methods to manipulate the document client-side, there won't be a problem with AJAX backends sending other forms of XML, either
p3641
aVFor the first question: There is nothing that forces any client to do anything specific
p3642
aVThe  attribute is a hint for the client what your server will probably accept or reject, but it doesn't have to act on this in any defined manner
p3643
aVIf you like, you can add some optional additional verification on the client with scripting, but of course you always must validate input data on the server, too
p3644
as(dp3645
g28
V596781
p3646
stp3647
a((dp3648
g2
(lp3649
VCheck if you have "content-negotiation" enables
p3650
aVThat's a feature that lets the server deduce the file name from just the un-suffixed name depending on the requested client preferences, which can cause the behaviour you describe
p3651
as(dp3652
g28
V596781
p3653
stp3654
a((dp3655
g2
(lp3656
VSince your SQL script doesn't contain any character set configuration directives,  just runs in its default character set Latin1
p3657
aVTo change the default character set, start  like this:
p3658
as(dp3659
g28
V596781
p3660
stp3661
a((dp3662
g2
(lp3663
VA simple approach would be to send the thread to sleep for a variable amount of time:
p3664
aVYou'll need a suitable steady clock function for  and a sleep function - try the  or  header
p3665
aVIn this example I've assumed that you have a timer callback (like in boost
p3666
aVASIO), but you could also make an infinite loop or something like that
p3667
aVThis function will work if the function body never exceeds 20ms, though it'll do a quick catch-up if your function ever takes longer
p3668
aVIf you want to synchronize to a global 20ms rhythm, you'd have to add another global step counter or something like that
p3669
as(dp3670
g28
V596781
p3671
stp3672
a((dp3673
g2
(lp3674
VMemory that you allocated on the heap will remain allocated until you deallocate (usually  or /) it explicitly
p3675
aVAll you are doing in your loop is using the memory, by writing data to it
p3676
as(dp3677
g28
V596781
p3678
stp3679
a((dp3680
g2
(lp3681
VYou can use  to provide your own sorting function
p3682
as(dp3683
g28
V596781
p3684
stp3685
a((dp3686
g2
(lp3687
VIn any reasonable way passing by reference will probably result in code involving addresses of objects
p3688
aVHowever, the main issue is that using references is more idiomatic C++ and should be the preferred style; you should really not be seeing raw pointers a lot at all in your own code
p3689
aVAlso note that passing by value and by reference is fundamentally different in the sense that passing by reference allows the callee to modify the argument
p3690
aVIf anything, you should be comparing  with
p3691
as(dp3692
g28
V596781
p3693
stp3694
a((dp3695
g2
(lp3696
VHere is a Sh+Perl solution, I'm afraid I don't know Python:
p3697
aVThe key is the regex that finds  and replaces it by , globally
p3698
as(dp3699
g28
V596781
p3700
stp3701
a((dp3702
g2
(lp3703
VI'd do it like this:
p3704
aVMatch all file names against  and extract  as the base name,  as the optional resolution, and  as the suffix;
p3705
aVWalk over the unique base names and check whether your desired resolution exists
p3706
as(dp3707
g28
V596781
p3708
stp3709
a((dp3710
g2
(lp3711
VYou'll need some type of aggregate:
p3712
as(dp3713
g28
V596781
p3714
stp3715
a((dp3716
g2
(lp3717
VAlgorithm:
p3718
aVExample: For , we have  and , yielding
p3719
aVHere's a free-standing formulation of this in SQL, but you have to hook it up to your function yourself with a subquery or a join or something:
p3720
as(dp3721
g28
V596781
p3722
stp3723
a((dp3724
g2
(lp3725
VIf your segment uses reasonably decent switch, you can discover the link-layer neighbours by inspecting the forwarding database of one of the switches
p3726
aVYou should be able to obtain this fairly automatically via SNMP, check your switch's documentation
p3727
aVOnce you have a list of link neighbours, you can try and find out their IP addresses, but remember that they may have many or none at all
p3728
aVFor this you'd need some sort of reverse-ARP
p3729
aVPerhaps your router maintains a list of MAC-to-IP associations and you can query it (again SNMP would be the most convenient solution)
p3730
as(dp3731
g28
V596781
p3732
stp3733
a((dp3734
g2
(lp3735
VUndefined behaviour is not a compilation error, it's just not a well-formed C++ program
p3736
aVNot every ill-formed program is incompilable, it's just un-predictable
p3737
aVI'd wager a bet that it's not even possible in principle for a computer to decide whether a given program text is a well-formed C++ program
p3738
aVYou can always add  to gcc to make warnings terminate compilation with an error
p3739
aVTo add another favourite SO topic: Would you like  to cause a compile error, too
p3740
as(dp3741
g28
V596781
p3742
stp3743
a((dp3744
g2
(lp3745
VAdd  to the top of your program text (and be nice and say  while you're at it)
p3746
as(dp3747
g28
V596781
p3748
stp3749
a((dp3750
g2
(lp3751
VYou have to say  at the top of every script that needs to know the session data
p3752
aVThe session cookie is really none of your concern, you should consider that an "implementation detail"
p3753
aV(The cookie will usually live in the user's browser until the browser exits
p3754
as(dp3755
g28
V596781
p3756
stp3757
a((dp3758
g2
(lp3759
VYou could just use  and check the result for , and close the connection right away on success
p3760
aVYou can make a dummy account with no privileges for that if you like
p3761
aVThat's really the only reliable way, especially if you want to distinguish a running MySQL server from any other random process listening on port 3306
p3762
as(dp3763
g28
V596781
p3764
stp3765
a((dp3766
g2
(lp3767
VYou can use a :
p3768
aVAs discussed in the comments, you can vary this with / if you want to discard duplicates from among the different tables
p3769
aVThanks to the commenters
p3770
as(dp3771
g28
V596781
p3772
stp3773
a((dp3774
g2
(lp3775
VCheck the manual,  is not identical to  because the former is a string and the latter is null, and  checks for equal types as well as equal values
p3776
as(dp3777
g28
V596781
p3778
stp3779
a((dp3780
g2
(lp3781
VThere are two questions here:
p3782
aVWhy isn't this rendering correctly
p3783
aVIs this valid HTML/XHTML/WhatNotML
p3784
aVFor question 1, the answer is simple:  isn't recognized tag soup, so if your browser is in tag soup mode, it won't handle it correctly
p3785
aVServe your document as XML and you'll be fine, if you must use such constructions
p3786
aVFor question 2, the answer depends
p3787
aVIn HTML 4
p3788
aV01 this is certainly not valid
p3789
aVFor XHTML, new features were added to SGML to allow empty elements to use the "null end tag" (NET), but only when it follows the null-end-start-tag-closer immediately
p3790
aVThe null-end start tag is , and the null end tag is , and letting the latter follow the former immediately yields , which is fine
p3791
aVAny language using the XML SGML delcaration can express elements with no content as , whether or not  has declared content EMPTY or not
p3792
as(dp3793
g28
V596781
p3794
stp3795
a((dp3796
g2
(lp3797
VThe way to invoke a function pointer is to also provide its object's instance pointer
p3798
aVThis will take care of all virtuality issues:
p3799
aVOK, interesting syntax challenge question: Suppose I have this
p3800
aVNow if I have  or a , I can invoke the  member via
p3801
aVHow could I do the same if I was given a
p3802
aVAnswer: It cannot be done
p3803
aVThe PMF  alone does not know whether it points to a virtual function, let alone which one, and it cannot be used to look up a base class function at runtime
p3804
aV[Thanks to Steve and Luc
p3805
as(dp3806
g28
V596781
p3807
stp3808
a((dp3809
g2
(lp3810
VIt looks like another process is already running that's bound to port 22
p3811
aVFind out which:
p3812
aVThen kill it and try again
p3813
as(dp3814
g28
V596781
p3815
stp3816
a((dp3817
g2
(lp3818
VIf the cplusplus documentation is to be trusted, then  essentially calls , so you cannot use s
p3819
aV(I suppose one might ask for a specialized version of  for lists that operates on const_iterators
p3820
aVI think you can build one fairly easily, though
p3821
as(dp3822
g28
V596781
p3823
stp3824
a((dp3825
g2
(lp3826
VSince you must know:
p3827
aV(Fixed
p3828
aVAgain
p3829
aVUpdate: I've been informed by Johannes Schraub and Luc Danton that this syntax is in fact not valid, and that you really must use a typedef
p3830
aVSince you say that typedefs aren't an option, here's a helper class that can wrap your typedef:
p3831
as(dp3832
g28
V596781
p3833
stp3834
a((dp3835
g2
(lp3836
VI dispute that anything is wrong with
p3837
aVI am very certain, though, that something is wrong with your Makefile
p3838
aVAccording to some random internet searching, try something like this:
p3839
aVThis is assuming that your Makefile resides in
p3840
as(dp3841
g28
V596781
p3842
stp3843
a((dp3844
g2
(lp3845
VThe fundamental guarantee that you get is that
p3846
aVFor signed values, there is no reason either sign should be the preferred outcome of a modulo or divide operation
p3847
aVSome languages fix one form, others leave it up to the implementation, so that the implementation can use whichever way the hardware happens to provide
p3848
aVThe hardware instruction, in turn, may have been chosen to operate efficiently the hardware's representation of signed integers
p3849
aVGenerally, be very careful when using signed integers together with division, remainder and bit shift operations
p3850
as(dp3851
g28
V596781
p3852
stp3853
a((dp3854
g2
(lp3855
VIf you like to find out whether a tuple as a specific last member, here's a type trait for that:
p3856
aVEdit: Oh, I didn't see that Matthieu had already written the exact same thing
p3857
aVNever mind
p3858
as(dp3859
g28
V596781
p3860
stp3861
a((dp3862
g2
(lp3863
VYou have to configure your table schema for  to handle foreign key changes with : Either "set to null", or "set to default", or "set to specific value", or "delete"
p3864
aVNot sure if you can do this variably, though, but if you think about it that'd be insane: You have referential integrity precisely because you want your relations to be strictly enforced
p3865
aVRandomly changing them if you delete a category row would go completely counter to that
p3866
aVMuch better to handle this correctly yourself by first ing the to-be-modified rows
p3867
aV(I don't know the appropriate Symfony/Doctrine method to affect this
p3868
aVYour available options depend on your database
p3869
aVYou can always say  to delete all dependent rows; other options may or may not be available to you
p3870
as(dp3871
g28
V596781
p3872
stp3873
a((dp3874
g2
(lp3875
VThis should really be a comment, but I prefer some room to type this out
p3876
aVSo, lets say we have two types:
p3877
aVNow I want to assign one to the other:
p3878
aVSince  doesn't have an explicit assigment operator, we can only use the default assignment
p3879
aVThus we invoke the implicit conversion constructor, which is equivalent to:
p3880
aVHowever, has has been pointed out, this conversion constructor calls the explicit member constructors:
p3881
aVThus for each member individually we do use explicit conversion
p3882
as(dp3883
g28
V596781
p3884
stp3885
a((dp3886
g2
(lp3887
VI've been finding that the typographic quality of just about any PDF creation library is utterly gutterly
p3888
aVIf it's an option at all, you might consider pasting your data into a LaTeX template and running  on that (or ) to get a nice-looking, high-quality document
p3889
aVThis will require a certain amount of setup and development on your part, but there's a chance that it'll look infinitely better than any direct PDF creation results
p3890
as(dp3891
g28
V596781
p3892
stp3893
a((dp3894
g2
(lp3895
VYou'll want to aggregate over :
p3896
as(dp3897
g28
V596781
p3898
stp3899
a((dp3900
g2
(lp3901
VHow about this: Your class  outputs s through the  functions, but only stores s internally
p3902
aVThe update loop can check whether the weak pointer is still valid and remove it if not
p3903
aVYour final requirement that deleting the base will also kill existing objects is a bit trickier
p3904
aVYou could go through the weak pointers in 's destructor and send a self-destruct signal to all live objects, but that wouldn't stop existing shared pointers
p3905
as(dp3906
g28
V596781
p3907
stp3908
a((dp3909
g2
(lp3910
VAggregate over the maximum of :
p3911
as(dp3912
g28
V596781
p3913
stp3914
a((dp3915
g2
(lp3916
VYou have to keep calling :
p3917
as(dp3918
g28
V596781
p3919
stp3920
a((dp3921
g2
(lp3922
VYou can enable  to get a heap of ridiculous warnings, including every single non-ctor-initialized member
p3923
aVTo check for actual UB, use valgrind
p3924
as(dp3925
g28
V596781
p3926
stp3927
a((dp3928
g2
(lp3929
VThe whole point of this pattern is, as far as I understand, that you can pass arguments simply as  and your interface is defined by (non-virtual) functions in
p3930
aVIf you don't have an interface that you want to define (as you are suggesting in the second part of your question), then there's no need for any of this in the first place
p3931
aVNote that you are not "imposing" an interface like with pure virtual functions, but rather you are providing an interface
p3932
aVSince everything is resolved at compile time, "imposing" isn't such a strong requirement
p3933
as(dp3934
g28
V596781
p3935
stp3936
a((dp3937
g2
(lp3938
VGitHub is the entire site
p3939
aVGists are a particular service offered on that site, namely code snippets akin to pastebin
p3940
aVHowever, everything is driven by git revision control, so gists also have complete revision histories
p3941
as(dp3942
g28
V596781
p3943
stp3944
a((dp3945
g2
(lp3946
VDifferent languages can definitely use the same libraries
p3947
aVOn the old Windows Visual Basic it was quite common to dynamically load Windows API functions, for instance
p3948
aVAll you need for inter-language linking is an agreement on the function's calling conventions, along with knowledge of the function names
p3949
aVThe former has to be done by looking up the documentation; the latter has to be looked up in the compiler that created the objects or libraries
p3950
aVFor example,  will compile C without mangling names, so you can refer directly to the function names as they are in your C source, while  will compile C++ code with mangled names and you're best off exposing C functions via  declarations
p3951
aVBasically, as long as your objects or libraries expose only the C ABI, there should be widespread support for binding to other languages
p3952
aVIt's a lot more difficult if you want to use a native C++ library, for instance, since in that case your foreign languages have to implement the correct C++ ABI
p3953
aVIt's similar for exporting code from, say, Fortran, but I believe that one can be made to just uses the C ABI
p3954
as(dp3955
g28
V596781
p3956
stp3957
a((dp3958
g2
(lp3959
VYou're conflating two issues, dynamic allocation and resizable containers
p3960
aVYou don't need to worry about dynamic allocation, since your container does that for you already, so just say it like this:
p3961
aVThis will make  an object with automatic storage duration, and you can access its members via
p3962
as(dp3963
g28
V596781
p3964
stp3965
a((dp3966
g2
(lp3967
VNo, that's not good practice
p3968
aVprecisely those fields which you need
p3969
as(dp3970
g28
V596781
p3971
stp3972
a((dp3973
g2
(lp3974
VYour approach does not help at all:
p3975
aVYou are still just allocating the object dynamically and have to take care of it manually
p3976
aVIn fact, my first usage makes a copy of the reference and then forgets the reference, creating an instant leak
p3977
aVAnd even if you did still somehow retain the reference, as in the second example, it becomes entirely unmanageable
p3978
aV(See Soap's comment
p3979
aVSo please just forget about this entire idea quickly and look at resource managing containers instead
p3980
aVFor example:
p3981
as(dp3982
g28
V596781
p3983
stp3984
a((dp3985
g2
(lp3986
VThere are two separate notions in C++:
p3987
aVThe new/delete operators
p3988
aVNew/Delete expressions
p3989
aVThe operators allocate and deallocate memory
p3990
aVThe  expression constructs objects
p3991
aVThe  expression sometimes destroys an object and calls the operator
p3992
aVWhy "sometimes"
p3993
aVBecause it depends on the expression
p3994
aVThe naked, global  first calls operator-new to allocate memory and then constructs the object; the global  calls the destructor and deallocates the memory
p3995
aVBut all other overloads of  and  are different:
p3996
aVAn overloaded new expression calls an overloaded new operator to allocate memory and then proceeds to construct the object
p3997
aVHowever, there is no such thing as an overloaded delete expression, in particular there is no "placement-delete": Instead, you have to call the destructor manually
p3998
aVNew/Delete operators still have to be overloaded in matching pairs, because the matching delete operator is called when an object constructor throws an exception
p3999
aVHowever, there is no automatic way to invoke the destructor for an object that has been allocated with an overloaded  operator, so you have to do that yourself
p4000
aVAs the first and most basic example, consider the placement-new operator, which is mandated to take the form
p4001
aVThe matching  operator is thus mandated to do nothing:
p4002
aVUsage:
p4003
as(dp4004
g28
V596781
p4005
stp4006
a((dp4007
g2
(lp4008
VI'm assuming that since you say  you also want to pull in the  table
p4009
aVFor that, you have to  all three tables:
p4010
as(dp4011
g28
V596781
p4012
stp4013
a((dp4014
g2
(lp4015
VYou cannot say , i
p4016
ag598
aVhave one template parameter be itself a parameter of another parameter
p4017
aVDo it like the standard library does it and use default parameters:
p4018
aVAlso,  is going to be an object that you need to instantiate at some point
p4019
aVAgain, default arguments are the key:
p4020
as(dp4021
g28
V596781
p4022
stp4023
a((dp4024
g2
(lp4025
VSupposing that your field is called , a simple  query will do:
p4026
as(dp4027
g28
V596781
p4028
stp4029
a((dp4030
g2
(lp4031
VNot everything is a union -- in this case it's a join on the subqueries:
p4032
as(dp4033
g28
V596781
p4034
stp4035
a((dp4036
g2
(lp4037
VYou should really really not have such a class in the first place
p4038
aVInstead, use a resource managing container like  or  to hold the pointer to a dynamically allocated object
p4039
aVAs you can easily see, there's no way you'll manage to keep track of who's responsible for what if you randomly allocate dynamic objects all over the place
p4040
aVWhat about copying and assignment of your class
p4041
aVWhat about exceptions in the constructor
p4042
aVDon't do it
p4043
as(dp4044
g28
V596781
p4045
stp4046
a((dp4047
g2
(lp4048
VI think there isn't a really elegant way in MySQL, basically because  doesn't return anything
p4049
aVPostgreSQL does allow for an  clause, but that's an extension
p4050
aVThat said, if you're using the  functions in PHP, you can use mysql_insert_id, which might suffice for your needs (i
p4051
ag598
aVif your primary key is an  integer)
p4052
as(dp4053
g28
V596781
p4054
stp4055
a((dp4056
g2
(lp4057
VWhen you aggregate with , you don't have control over the representative row that you're getting which isn't being aggregated or gouped by, namely your status ID
p4058
aVSo make two queries and join them:
p4059
aVThe subquery makes an intermediate table , and we join that again the  table again to retrieve the status at that date
p4060
as(dp4061
g28
V596781
p4062
stp4063
a((dp4064
g2
(lp4065
VYou're misreading the table: You have to add the column head to the row head:
p4066
aVThe table rows are labelled in multiples of 32, and the columns are the remainder modulo 32
p4067
as(dp4068
g28
V596781
p4069
stp4070
a((dp4071
g2
(lp4072
VI think you are misunderstanding what "testing a pointer" means
p4073
aVThe condition  is identical to , so all you are testing is whether the pointer is null or not
p4074
aVThere is nothing that tells you whether it's OK to dereference any given pointer
p4075
aVIn particular,  will just continue incrementing the pointer forever; if you dereference  in the body, you will almost certainly cause an access violation eventually
p4076
aVYou are responsible yourself for knowing by how much you can increment the pointer
p4077
aV(Silly aside: If you are not dereferencing  at all, this might loop around until  overflows and is 0 again, but this may never happen depending on the initial value of  and on
p4078
as(dp4079
g28
V596781
p4080
stp4081
a((dp4082
g2
(lp4083
VThere's generally nothing wrong with passing read-only arguments as const-references, and for any sort of heavy-weight class that's surely the most efficient way to do it
p4084
aVYou might want to consider passing primitive types by copy, though, because there making the reference might actually incur more cost than just copying (e
p4085
ag99
aVcopying would just fit into one register, while a reference might be implemented with a pointer, etc
p4086
aVAlso, you can probably pass  and iterators by value, they're made for that
p4087
aVAs for passing by const-value, that's an implementation detail
p4088
aVUse it like this:
p4089
aVIn the implementation, you may or may not choose to use the argument variables directly and modify them (like ), or you may choose to treat them as read-only (like ), and you declare the arguments appropriately
p4090
as(dp4091
g28
V596781
p4092
stp4093
a((dp4094
g2
(lp4095
VTry an aggregate:
p4096
as(dp4097
g28
V596781
p4098
stp4099
a((dp4100
g2
(lp4101
V is for formatted input
p4102
aVIt'll read  as an integer if you stream it into an , and it'll eat whitespace between tokens
p4103
aVon the other hand is for unformatted, byte-wise input
p4104
as(dp4105
g28
V596781
p4106
stp4107
a((dp4108
g2
(lp4109
VYou can't do it directly, but you can compute  and  and compare those
p4110
aVGiven that lists don't have random access, you expect to have to pay the price for such a query by having to traverse the entire list
p4111
aVEdit: This will perform poorly if both iterators are near the end of the list
p4112
aVIf you want to get more fancy, you could write some exploring algorithm that moves outwards from both iterators:
p4113
aVYou would basically keep two copies for each, / and /, and you decrement the  iterators until you hit  and advance the  iterators until you hit
p4114
aVIf your iterator pairs are uniformly distributed, this probably has better expected runtime
p4115
as(dp4116
g28
V596781
p4117
stp4118
a((dp4119
g2
(lp4120
V doesn't make sense for non-link anchors (not sure about this actually,  might be triggered on any visible element)
p4121
aVUse this:
p4122
aVAlso available, but less specific:
p4123
aVThe latter two will have their properties overridden by the more specific ones above if the anchor actually has the  attribute set
p4124
as(dp4125
g28
V596781
p4126
stp4127
a((dp4128
g2
(lp4129
VIt's just modular arithmetic
p4130
aVYou're multiplying and adding to a number which is taken modulo 2^32 (for example), and returning the upper 16 bit as your "random" number
p4131
aVBecause you're multiplying and adding numbers which are coprime to the modulus, this creates sort of uniformly distributed numbers
p4132
aVThe careful choice of the two numbers is very important
p4133
aVFor example, if you had used "* 4" and "+ 8", you would probably not experience a lot of randomness
p4134
aVThis scheme is called linear congruential
p4135
as(dp4136
g28
V596781
p4137
stp4138
a((dp4139
g2
(lp4140
VYou should take a look whether the standard algorithm  could be used
p4141
aVIt's defined in
p4142
aVIt does "the right thing" for any suitable iterator
p4143
as(dp4144
g28
V596781
p4145
stp4146
a((dp4147
g2
(lp4148
VYou don't need quotation marks for associative array field names if you are already inside a doubly-quoted string:
p4149
as(dp4150
g28
V596781
p4151
stp4152
a((dp4153
g2
(lp4154
VIn GCC, use :
p4155
aVSet the input character set, used for translation from the character set of the input file to the source character set used by GCC
p4156
aVIf the locale does not specify, or GCC cannot get this information from the locale, the default is UTF-8
p4157
aVThis can be overridden by either the locale or this command line option
p4158
aVCurrently the command line option takes precedence if there's a conflict
p4159
aVcharset can be any encoding supported by the system's "iconv" library routine
p4160
aVAlso check out the options  and
p4161
aVFinally, about string literals:
p4162
aVThe size modifier of the string literal (, , ) merely determines the type of the literal
p4163
as(dp4164
g28
V596781
p4165
stp4166
a((dp4167
g2
(lp4168
VYour class  doesn't contain any members
p4169
aV(Just a typedef
p4170
aVDefine a member, too:
p4171
aVAlso, in C++ there is no need to say , just say
p4172
aVTo add an element:
p4173
aVEdit: Sorry, I misrepresented your actual data structure
p4174
aVHere's an example with a :
p4175
aVIn your case, you could say , or you could make a new vector:
p4176
as(dp4177
g28
V596781
p4178
stp4179
a((dp4180
g2
(lp4181
VUse :
p4182
aVoutputs
p4183
aVThis will fail if there are fewer than 2 arguments, use  to check
p4184
aVHere is a fairly comprehensive documentation of shift
p4185
as(dp4186
g28
V596781
p4187
stp4188
a((dp4189
g2
(lp4190
VIostreams are fickle, and you cannot really rely on the various formatting flags to persist
p4191
aVHowever, you can use  to write things a bit more concisely:
p4192
aVModifiers like  and  usually persist, while precision and field width modifiers don't
p4193
aVNot sure about the fill character
p4194
as(dp4195
g28
V596781
p4196
stp4197
a((dp4198
g2
(lp4199
VI understand the OP's question as why Dijkstra's algorithm fails in this case
p4200
aVLet's see
p4201
aVFirst off, the correct statement is that "Dijkstra's algorithm fails if there are negative directed edges"
p4202
aVIf there are negative undirected edges, then every negative edge immediately constitutes a negative cycle (), and the graph does not have a shortest path and the question is moot
p4203
aVSo to make this non-trivial, let's suppose the graph is directed:
p4204
aVSuppose further our source is
p4205
aVThe true shortest path from A to B is  with weight 1
p4206
aVBut Dijkstra's algorithm starts by selecting , and then removes that edge from future consideration because it assumes that it cannot be improved upon
p4207
aVThis is crucial: Under the non-negativity hypothesis, we can be sure once and for all that the shortest path from A to B is
p4208
aVBecause the algorithm assumes this, it never checks again later whether there is an even shorter path, because with non-negative edges there cannot be on
p4209
aVThis hypothesis allows the algorithm to proceed with fewer steps, but it precludes it from correctly identifying the shortest path in the presence of negative edges
p4210
aVThe negative edges make the problem "non-local" in the sense that you cannot tell if you're doing well just by looking at your immediate neighbours - there might always be an extremely negative edge just past this very expensive edge next to you
p4211
as(dp4212
g28
V596781
p4213
stp4214
a((dp4215
g2
(lp4216
VThe total credit is just the sum as the credit-by-upload and the foreign credit
p4217
aVSince credit-by-upload is easy, here is just the foreign credit
p4218
aVHold your breath for two-fold subquery
p4219
aVThis becomes more palpable with a view
p4220
aVWe make a view that selects only pairs  of people credited in videos which they did not upload themselves
p4221
aVLet's call the view
p4222
aVNow we can happily paste this into the main query that aggregates foreign credits:
p4223
aVNow let's put it all together
p4224
aVWe make two more views, one to count own credits and one to count foreign credits:
p4225
aVFinally, the complete selection:
p4226
as(dp4227
g28
V596781
p4228
stp4229
a((dp4230
g2
(lp4231
VYou can fake C++-style optional arguments (i
p4232
ag598
aVall optional arguments are at the end) by checking for set variables:
p4233
aVIt'll trigger a warning, which I'm suppressing with
p4234
aVNot the most elegant solution, but syntactically close to what you wanted
p4235
aVEdit
p4236
aVThat was a silly idea
p4237
aVUse variadic arguments instead:
p4238
as(dp4239
g28
V596781
p4240
stp4241
a((dp4242
g2
(lp4243
VThe two problems are quite different
p4244
aVThink of the minimum spanning tree as the problem of connecting places where you only have to pay once to build the road, but you can use it as many times as you like
p4245
aVIt's easy to come up with the cheapest configuration of roads (e
p4246
ag99
aVby Kruskal's algorithm) that allows you to travel from any place to any other
p4247
aVThe Hamiltonian cycle, on the other hand, wants you to minimize the actual travel distance, i
p4248
ag598
aVevery move from one place to another counts
p4249
aV(It also asks you never to visit a place twice, but that's a minor detail
p4250
aVThis problem is fundamentally non-local, in the sense that you cannot tell whether you're doing the right thing just by locally exploring the options for the next step
p4251
aVBy comparison, the greedy MST algorithm is guaranteed to pick the right next edge to add to the tree at every step
p4252
aVBy the way, nobody says that "we cannot have efficient algorithms for HP"
p4253
aVIt might be that we just haven't found one yet :-)
p4254
as(dp4255
g28
V596781
p4256
stp4257
a((dp4258
g2
(lp4259
VFormatted input eats whitespaces
p4260
aVYou can just count tokens directly:
p4261
as(dp4262
g28
V596781
p4263
stp4264
a((dp4265
g2
(lp4266
VSupposing you want to express , where  and  are as close to  as possible:
p4267
aVThat's pseudo code, you have to find out the actual functions for floor and ceiling from your library
p4268
aVMake sure the division is performed as floating point numbers
p4269
aVAs pure integers:
p4270
aV(This may be a bit fishy for negative numbers, because it'll depend on the behaviour of division and modulo for negative numbers
p4271
as(dp4272
g28
V596781
p4273
stp4274
a((dp4275
g2
(lp4276
VMaybe something like this
p4277
aVIt loops until it finds a number that's not in the array
p4278
aVIf you need lots of random numbers, you can put the whole thing into another loop that runs for as many rounds as you need distinct numbers
p4279
as(dp4280
g28
V596781
p4281
stp4282
a((dp4283
g2
(lp4284
VThe HTTP header is never compressed -- there's just no protocol for HTTP header compression
p4285
aVI suppose there's no need, it's not like the header is a very large part of your 100kB+ website
p4286
aVFor individual HTTP requests, the behaviour depends on the server configuration and on the client
p4287
aVIf the client doesn't say that it is happy to accept gzip/deflated content, the server won't compress
p4288
aVIf the client does say so, then the the server may choose to compress depending on its configuration
p4289
aV(E
p4290
ag99
aVfor Apache, you need so set up )
p4291
aVFor example, it'd be perfectly reasonable for the server not to compress JPEGs and PNGs, on account of them already being compressed
p4292
aVThe server may also not choose to compress anything handled by the PHP handler and prefer to leave it up to the handler to compress or not
p4293
aV(So for example if the handler delivers a PDF, it can compress, but if it delivers an MP3, it won't
p4294
aVShort answer: It all depends
p4295
as(dp4296
g28
V596781
p4297
stp4298
a((dp4299
g2
(lp4300
VThe  clause restricts the joined results which are being aggregated over, so while you're trying do an outer join, only those rows with  survive, but that excludes all the unmatched rows
p4301
aVOn the other hand, when you change  to , you now have  -- but this is still an outer join, i
p4302
ag598
aVrecords on the left which have no match on the right will be included
p4303
as(dp4304
g28
V596781
p4305
stp4306
a((dp4307
g2
(lp4308
VIf you can just concatenate all files in one wash, that'd be best
p4309
aVBut a generic answer for your Bash question:
p4310
aVHere  is two less than your total number of input files
p4311
as(dp4312
g28
V596781
p4313
stp4314
a((dp4315
g2
(lp4316
VYour  is a pointer, not an array
p4317
aVCurly braces are for aggregate initialization:
p4318
aVPointers are not arrays, and you cannot fill memory with the aggregate initialization syntax
p4319
aVHere is the closest construct that would work:
p4320
aVNote that each element of the brace-list must itself initialize the base type of the aggregate
p4321
as(dp4322
g28
V596781
p4323
stp4324
a((dp4325
g2
(lp4326
VInclude guards don't protect you against defining an object multiple times if you include the definition in multiple translation units
p4327
aVAs a solution, never define things in headers, but only declare them:
p4328
aV(There are exceptions, of course; e
p4329
ag99
aVclass definitions are fine (but class member function definitions are not (but inlined ones are)) -- beware
p4330
aVI should add that alternatively you can say  in your header file to make the definition private to each TU:
p4331
aV(In C++0x you cannot use objects of static linkage as template parameters, though
p4332
as(dp4333
g28
V596781
p4334
stp4335
a((dp4336
g2
(lp4337
VRevised Answer (The previous answer was nonsense
p4338
aVSorry for that
p4339
aVAlso, your previous question should have covered this problem already entirely
p4340
aVHeader:
p4341
aVYou need one TU to define :
p4342
aVYou can use the template anywhere:
p4343
as(dp4344
g28
V596781
p4345
stp4346
a((dp4347
g2
(lp4348
VHow about sorting the original vector with a custom predicate that puts all the evens before all the odds
p4349
aVThen you just have to find the largest even number, which you can do e
p4350
ag99
aVwith  for a very large even number or something like that
p4351
aVOnce you found that, you can make very cheap copies of the ranges
p4352
aVUpdate: As @Blastfurnace commented, it's much more efficient to use  rather than , since we don't actually need the elements ordered within each partition:
p4353
as(dp4354
g28
V596781
p4355
stp4356
a((dp4357
g2
(lp4358
VI suppose it could, but it doesn't
p4359
aVThe default versions of the constructors and assignments just construct/assign member-by-member
p4360
aVIf you already need to write your own copy constructor (which apparently is a warning sign and should only happen in rare cases), your class has something non-trivial going on, and that most likely won't do the right thing
p4361
aVAlso, if the copy-constructor has to be written by hand and isn't just copying of members, then chances are that the  function is non-trivial, too, so you'd have to provide that manually as well
p4362
aVIn C++0x, you can use  to make the compiler generate constructors automatically and assignment operators automatically, but those will just operate member-by-member and not use the copy+swap idiom
p4363
aVFor most classes, however, you should be using resource managing containers for your members, which themselves implement the all the correct functionality, and your class itself should be able to use the default copy/move constructors and assignments
p4364
aVEdit
p4365
aVTo put it another way: Copy/Move+Swap is an idiom that you may choose, but it isn't the default way to recursively build larger types from smaller ones
p4366
aVThere is no automatically implied  (here is a previous discussion on the matter) because it's left to the user's design choices which way round to implement copy, move and swap
p4367
as(dp4368
g28
V596781
p4369
stp4370
a((dp4371
g2
(lp4372
VYou should basically use session management to track whether a user is in an authenticated session or not
p4373
aVIf not, you (re)direct them to the index page; if yes, you grant them access to whichever resource they requested
p4374
aVTo use sessions, put your session setup functions at the top of every PHP script inside your application (setup functions include session handler, cookie domain and cookie name), and say
p4375
aVThen, check if a login flag has been defined in the current session like
p4376
aVIn the authentication page, you would of course define  at some stage
p4377
as(dp4378
g28
V596781
p4379
stp4380
a((dp4381
g2
(lp4382
VWhenever you have a value  somewhere and you want some other function to modify it, you pass a pointer to :
p4383
aVNow just apply this mechanic to
p4384
aVThe values that you want to modify are themselves pointers
p4385
aV(Maybe using a typedef would make things look less confusing:
p4386
aVAlso note that your linked list is broken because you never set the "next" pointer of the new element to point to the old head, and similarly for the "previous" pointer if the list is doubly-linked
p4387
as(dp4388
g28
V596781
p4389
stp4390
a((dp4391
g2
(lp4392
VCheck out Beej's Network Programming Guide first of all
p4393
aVThe basic screenplay of a server/client connection goes like this:
p4394
aVServer s on a fixed port, with a given socket
p4395
aVClient s to a the server port; client obtains a socket
p4396
aVServer s the connection, and  returns a new socket for the connection
p4397
aV(Server continues listening on the original port with the original socket
p4398
aVFor the specific connection with the client, the server s to the new socket it obtained when ing the incoming connection
p4399
aVA busy server will have many, many sockets, but it will only ever need to  to one port
p4400
aVAll connections come in to that one port, but the OS's networking protocol stack separates the data and makes it available at the connection-specific socket
p4401
as(dp4402
g28
V596781
p4403
stp4404
a((dp4405
g2
(lp4406
VTyping the columns out is faster for the database, typing  is faster for you to type
p4407
aVPick whichever is more important :-)
p4408
as(dp4409
g28
V596781
p4410
stp4411
a((dp4412
g2
(lp4413
VMap:  has guaranteed logarithmic lookup complexity
p4414
aVIt's usually implemented by experts and will be of high quality (e
p4415
ag99
aVexception safety)
p4416
aVYou can use custom allocators for custom memory requirements
p4417
aVYour solution: It'll be written by you
p4418
aVA vector is for contiguous storage with random access by position, so how will you implement lookup by value
p4419
aVCan you do it with guaranteed logarithmic complexity or better
p4420
aVDo you have specific memory requirements
p4421
aVAre you sure you can implement a the lookup algorithm correctly and efficiently
p4422
aV3rd option: If you key type is  (or something that's expensive to compare), do also consider , which has constant-time lookup by value in typical situations (but not quite guaranteed)
p4423
as(dp4424
g28
V596781
p4425
stp4426
a((dp4427
g2
(lp4428
VSounds like this pattern:
p4429
as(dp4430
g28
V596781
p4431
stp4432
a((dp4433
g2
(lp4434
VYou use  to launch a program as a specific user:
p4435
as(dp4436
g28
V596781
p4437
stp4438
a((dp4439
g2
(lp4440
VIf you are using a compile-time array, you can do this with a template:
p4441
aVIf all you need is to print arrays, also check out the pretty printer, which uses this sort of stuff internally
p4442
as(dp4443
g28
V596781
p4444
stp4445
a((dp4446
g2
(lp4447
VThere are two notions of  in C++: One is the operator, declared as , which basically only frees up the memory and isn't usually thought about by most programmers
p4448
aVThe other is the delete expression, , where  is a
p4449
aVThe expression invokes the destructor of the object pointed to by  (and then frees the memory), which is a crucial language feature of C++ that has no analogue in C
p4450
aVAs a rule of thumb, you pair  expressions with  expressions, and  function calls with  function calls:
p4451
aVAdvanced part (not in response to the OP's question)
p4452
aVDynamic object lifetime in C++ follows this general pattern: Allocate, construct, destroy, deallocate
p4453
aVThe standard  expression performs allocation and construction, while the standard  expression performs destruction and deallocation
p4454
aVYou could write out the process manually:
p4455
aVIn fact, if you really wanted to implement Baby's First C++, you could define the operators as just as /:
p4456
aVThe real C++ magic happens by virtue of the  and  expressions: The standard  expression invokes the constructor (a  expression is the only way to call a constructor in C++
p4457
aVafter allocation, while the standard delete expression invokes the destructor before deallocation
p4458
aVWhy "standard expression"
p4459
aVWell, you can also define and overload many other versions of  and  operators
p4460
aVHowever, there is an important asymmetry: While you can use a custom  operator in a custom  expression (generally dubbed "placement new"), there is no equivalent "placement-delete" expression
p4461
aVSo whenever you use a custom  expression, you have to manually invoke the destructor before calling the matching custom delete operator:
p4462
aVNote that there does not exist a custom delete expression
p4463
aVFor completeness, the standard placement new operator, whose only purpose is to call a constructor, is mandated by the standard to take the following form:
p4464
aVIt's matching  operator is also mandated, name to do nothing:
p4465
aVYou can see in the above general example why this is necessary
p4466
aVIt is important always to overload custom versions of  and  in pairs
p4467
aVThe reason is that if the object construction fails with an exception inside the constructor, then the memory is released by a call to the  operator that matches the offending  expression
p4468
aVSecond update: To be exception-safe, we have to consider that the constructor of  might throw:
p4469
aVVersion 1:
p4470
aVVersion 2:
p4471
as(dp4472
g28
V596781
p4473
stp4474
a((dp4475
g2
(lp4476
VHow about this:
p4477
aVThe  matches any non-whitespace character
p4478
as(dp4479
g28
V596781
p4480
stp4481
a((dp4482
g2
(lp4483
VGoing by the documentation,  means that you set the display width to "at least 8", but:
p4484
aVThe display width does not constrain the range of values that can be stored in the column
p4485
aVNor does it prevent values wider than the column display width from being displayed correctly
p4486
as(dp4487
g28
V596781
p4488
stp4489
a((dp4490
g2
(lp4491
VStrictly speaking, anything could happen unless you include all the correct headers
p4492
aVThere is no mandatory inclusion of one standard header into any other
p4493
aVSo to be portable and correct, you have to say this:
p4494
aVIn any real implementation you can almost always get away with omitting some of the headers (e
p4495
ag99
aVwould probably have been included in ), but the above is the standard-compliant way
p4496
as(dp4497
g28
V596781
p4498
stp4499
a((dp4500
g2
(lp4501
VYou got it all wrong
p4502
aVAssuming that you have several typos in your code and mean , you are currently saying:
p4503
aVThe last line treats  as an array of lists, which you never created
p4504
aVThe way to access list elements is by iteration
p4505
aVHere is a skeleton rewrite, hopefully you'll be able to extract the fixes from that:
p4506
as(dp4507
g28
V596781
p4508
stp4509
a((dp4510
g2
(lp4511
VThis should generally work, provided you get the basic syntax and idioms right:
p4512
aVNote that erasing from the container invalidates iterators, so we can only erase one element
p4513
aVWe can't use the usual  here, because all iterators beyond the erased one are invalidated by the erase
p4514
aVIn order to efficiently remove all matching elements from a vector, and you should instead use the remove+erase idiom:
p4515
aVThis first reorders the elements of the vector so that all those that match  are at the end (), and then (efficiently) erases that end from the vector ()
p4516
as(dp4517
g28
V596781
p4518
stp4519
a((dp4520
g2
(lp4521
VDeclare  as
p4522
aVBecause  is const, it cannot access a non-const function on a member of
p4523
as(dp4524
g28
V596781
p4525
stp4526
a((dp4527
g2
(lp4528
VYour casts are wrong
p4529
aVYou can only do arithmetic on pointers to complete types
p4530
aVTry it like this:
p4531
aVSpeaking of, why not implement a single  accessor for both reading and writing
p4532
as(dp4533
g28
V596781
p4534
stp4535
a((dp4536
g2
(lp4537
VYou can try this:
p4538
aVCredits to STL for the "index into char array" trick
p4539
aVAlso beware when printing s, which are signed on some platforms
p4540
aVIf you want  to print as  rather than , you have to prevent it from being treated as  by converting to unsigned char first:
p4541
as(dp4542
g28
V596781
p4543
stp4544
a((dp4545
g2
(lp4546
VThe backslash needs to be escaped:
p4547
aVThat's because  gives you a literal apostrophe, which you couldn't otherwise get inside a singly quoted string
p4548
as(dp4549
g28
V596781
p4550
stp4551
a((dp4552
g2
(lp4553
VYou're comparing apples and pears
p4554
aVSAX is a parser that parses serialized DOM structures
p4555
aVThere are many different parsers, and "event-based" refers to the parsing method
p4556
aVMaybe a small recap is in order:
p4557
aVThe document object model (DOM) is an abstract data model that describes a hierarchical, tree-based document structure; a document tree consists of nodes, namely element, attribute and text nodes (and some others)
p4558
aVNodes have parents and children and can be traversed, etc
p4559
aV, all the stuff you're used to from doing JavaScript (which incidentally has nothing to do with the DOM)
p4560
aVA DOM structure may be serialized, i
p4561
ag598
aVwritten to a file, using a markup language like HTML or XML
p4562
aVAn HTML or XML file thus contains a "written out" or "flattened out" version of an abstract document tree
p4563
aVFor a computer to manipulate, or even display, a DOM tree from a file, it has to deserialize, or parse, the file and reconstruct the abstract tree in memory
p4564
aVThis is where parsing comes in
p4565
aVNow we come to the nature of parsers
p4566
aVOne way to parse would be to read in the entire document and recursively build up a tree structure in memory, and finally expose the entire result to the user
p4567
aV(I suppose you could call these parsers "DOM parsers"
p4568
aVThat would be very handy for the user (I think that's what PHP's XML parser does), but it suffers from scalability problems and becomes very expensive for large documents
p4569
aVOn the other hand, event-based parsing, as done by SAX, looks at the file linearly and simply makes call-backs to the user whenever it encounters a structural piece of data, like "this element started", "that element ended", "some text here", etc
p4570
aVThis has the benefit that it can go on forever without concern for the input file size, but it's a lot more low-level because it requires the user to do all the actual processing work (by providing call-backs)
p4571
aVTo return to your original question, the term "event-based" refers to those parsing events that the parser raises as it traverses the XML file
p4572
aVThe Wikipedia article has many details on the stages of SAX parsing
p4573
as(dp4574
g28
V596781
p4575
stp4576
a((dp4577
g2
(lp4578
VTo use the  member, you have to make  a template parameter and use that in the member:
p4579
aVThen to use it, say
p4580
aVIn view of your question for alternatives, you could use a runtime-dynamic array instead of a static one:
p4581
as(dp4582
g28
V596781
p4583
stp4584
a((dp4585
g2
(lp4586
VA sensible way to serialize custom objects is to overload your own output stream operator:
p4587
aVThis is still platform-dependent, so to be a bit safer, you should probably use fixed-width data types like  etc
p4588
aVIt might also not be the best idea semantically to use  for binary output, since it's often used for formatted output
p4589
aVPerhaps a slightly safer method would be to write a function
p4590
as(dp4591
g28
V596781
p4592
stp4593
a((dp4594
g2
(lp4595
VIn general this is not possible within the language, since C++ is not a reflective language and it is statically typed
p4596
aVAs an alternative, you could consider hardcoding a collection of related, polymorphic types with a common base class into the program and writing a factory method that creates the desired concrete instance based on a runtime parameter
p4597
as(dp4598
g28
V596781
p4599
stp4600
a((dp4601
g2
(lp4602
VYes, just use plain aggregates:
p4603
aVUsage:
p4604
aVAn aggregate has no custom constructors, destructor and assignment operator, and it allows for plenty of optimisations
p4605
aVAggregate initialization with the brace syntax for example usually constructs the members in place without even a copy
p4606
aVAlso you get the best possible copy and move constructors and assignment operators defined for you by the compiler
p4607
as(dp4608
g28
V596781
p4609
stp4610
a((dp4611
g2
(lp4612
VIndividual translation units can be compiled with separate optimization flags, that's generally not a problem
p4613
aVCompile-time optimizations usually only affect the visible code within one TU
p4614
aVAn exception to that rule is the flag , which indicates that your source code constitutes the entire program and allows for more aggressive optimization:
p4615
aVThat said, GCC has recently introduced another layer of optimisations at link time; to use this, compile everything with  (GCC 4
p4616
aV6)
p4617
aVHowever, this is also independent of the optimization flags for each TU:
p4618
aVFinally, you can also specify an independent  option at link stage, but I don't know if that makes any difference
p4619
aVAlso note that precompiled header files cannot be independently optmizied; a PCH is only eligible if it was compiled with the same optimization settings as the TU
p4620
as(dp4621
g28
V596781
p4622
stp4623
a((dp4624
g2
(lp4625
VYou will need some formatted output operation like  (or even better its safe twin ):
p4626
as(dp4627
g28
V596781
p4628
stp4629
a((dp4630
g2
(lp4631
VYou need to dereference the pointers, and then construct a new object with that value:
p4632
aVHowever, just don't do this at all
p4633
aVYou probably don't need these variables to be dynamically allocated, so just allocate them automatically:
p4634
as(dp4635
g28
V596781
p4636
stp4637
a((dp4638
g2
(lp4639
VIn modern operating systems with separated kernel and user space and a memory manager, in which every user process only sees virtual memory (as you said), it is generally indeed not possible for any given user process to hurt the OS (excluding of course things like privileged users deliberately messing with the system memory)
p4640
aVThat's the entire idea of multi-process multi-tasking operating systems: Having many simultaneous processes managed by the OS, and not having to rely on the processes being cooperative
p4641
aV(That said, if memory leaks are due to invalid access bugs, you are still susceptible to code injection, which can be further aggravated by privilege elevation vulnerabilities in other parts of your system, so the insulation of a process only goes so far
p4642
as(dp4643
g28
V596781
p4644
stp4645
a((dp4646
g2
(lp4647
VWhy reinvent the wheel (for the umpteenth time)
p4648
aVUse a ready-made HTTP client library, such as
p4649
aVFor that matter, perhaps you can even just write your entire solution as a shell script using the  command line program:
p4650
as(dp4651
g28
V596781
p4652
stp4653
a((dp4654
g2
(lp4655
VWhen you compare the values as strings, both sides are , so you get
p4656
aVSo far so easy
p4657
aVComparing by numerical value leads you into the land of binary floating point value representations
p4658
aVSince numbers are stored base-2, any real number that is not expressible in a finite binary expansion cannot be precisely represented by a floating point number
p4659
aVIn other words, every number that cannot be written as a fraction of integers where the denominator is a power of 2 cannot be thus represented
p4660
aVThis includes 1/5 and 1/10 and 597/20 (which is 29
p4661
aV85)
p4662
aVBecause these numbers cannot be precisely represented, the outcome of operations involving such numbers depends on the order of the operations and on rounding and truncation errors, and so for example  is not the same as , and similar for your computation
p4663
as(dp4664
g28
V596781
p4665
stp4666
a((dp4667
g2
(lp4668
V"Cross-platform" is a subjective term
p4669
aVDo you mean "any platform" (you might encounter in the future) or "every platform" (on your list of supported platforms)
p4670
aVHere's a pragmatic approach that I usually take:
p4671
aVCheck if you have ; if yes, seed from there
p4672
aVOn Windows, use
p4673
aVIf all else fails, seed from
p4674
as(dp4675
g28
V596781
p4676
stp4677
a((dp4678
g2
(lp4679
V is probably constant
p4680
aVWhy don't you say:
p4681
as(dp4682
g28
V596781
p4683
stp4684
a((dp4685
g2
(lp4686
VYes you can, simply wrap column names in backticks:
p4687
aVAlternatively, depending on your DB, you might use square brackets:
p4688
aVEdit: I see you said "MS SQL"
p4689
aVI think that one works with the square brackets
p4690
aVMySQL accepts the backtick syntax
p4691
as(dp4692
g28
V596781
p4693
stp4694
a((dp4695
g2
(lp4696
VTo find if two sets (given as ) are disjoint, you can simply compute their intersection:
p4697
aVIf your containers aren't s, you have to make sure the ranges are ordered
p4698
aVIf you want to be more efficient, you can implement the algorithm for  and stop once you have a common element:
p4699
as(dp4700
g28
V596781
p4701
stp4702
a((dp4703
g2
(lp4704
VI believe the  function should be able to parse binary scientific notation
p4705
as(dp4706
g28
V596781
p4707
stp4708
a((dp4709
g2
(lp4710
VThe GCC preprocessor allows for a special syntax that elides the final comma in a variadic macro argument list if the list is empty:
p4711
aVThis exapands:
p4712
aVYou can use this for your  macro to cover all cases at once
p4713
aVUpdate: As @Dennis says, you can use your original syntax in MSVC++ and it won't even produce a trailing comma
p4714
as(dp4715
g28
V596781
p4716
stp4717
a((dp4718
g2
(lp4719
VMany things: First off, you cannot modify (erase/insert) a container and expect iterators to remain valid
p4720
aVLet's see
p4721
aVI want to modify  as well:
p4722
aVNext, the big one:
p4723
aVBasically  is just the index in the vector, so we can use that directly
p4724
aVTo erase an element from the middle, we just call  on the corresponding iterator
p4725
aVSince vector has random access iterators, we can say  in constant time
p4726
aVUpdate: Actually I think your code is broken: After you erase an element from the vector, the other elements move up, so you will lose the association between  and the container element
p4727
aVWhat's needed is, you guessed it, an associative container:
p4728
as(dp4729
g28
V596781
p4730
stp4731
a((dp4732
g2
(lp4733
VI would avoid the crutch of  followed by  to find the inserted record altogether and use MySQL's ability to return the ID of the most recently inserted row (provided your table as an  primary key) via PHP's , also available through PDO via
p4734
as(dp4735
g28
V596781
p4736
stp4737
a((dp4738
g2
(lp4739
VYou can add "beginning of line or space" and "space or end of line" around your match:
p4740
aVYou'll now need to refer to the middle capture group for the match string
p4741
as(dp4742
g28
V596781
p4743
stp4744
a((dp4745
g2
(lp4746
VMost succinctly, it means that the type of  is  inside const member functions, where  is your class, while in unqualified functions it is
p4747
aVYour method  does not change , so it can be qualified as const
p4748
aVIn other words,  is accessed as  and is of type
p4749
as(dp4750
g28
V596781
p4751
stp4752
a((dp4753
g2
(lp4754
VYou need double indirection magic:
p4755
as(dp4756
g28
V596781
p4757
stp4758
a((dp4759
g2
(lp4760
VYou could try , but presumably you'll get much greater savings from converting to JPEG with quality slightly less than 100 (I usually find 92 pretty good)
p4761
aVImageMagick would be the tool of choice for bulk processing
p4762
aVI never managed to create paletted PNGs, but in principle those should be pretty efficient when you're dealing with illustrations that only use a few colours
p4763
as(dp4764
g28
V596781
p4765
stp4766
a((dp4767
g2
(lp4768
V takes void pointers as its arguments, yet you're casting the second argument to a
p4769
aVTo fix this:
p4770
aVFor that matter, why don't you declare  as  (i
p4771
ag598
aVsay )
p4772
aVAlso, why all the excessive casting
p4773
aVYou don't need to cast the result of  or of the  assignment, as they're already the correct type
p4774
aVFinally,  should probably be of type , because it's a size type (i
p4775
ag598
aVunsigned)
p4776
as(dp4777
g28
V596781
p4778
stp4779
a((dp4780
g2
(lp4781
VRather, your code is always assigning  to , and it is moreover checking whether the value of  (and thus also ) is equal to
p4782
aVThere's nothing "legacy" about this, this is generally a pretty handy idiom if you need the result of an operation but also want to check for errors:
p4783
as(dp4784
g28
V596781
p4785
stp4786
a((dp4787
g2
(lp4788
VThere is a special rule which allows returning a temporary as an rvalue, namely, the following are equivalent - the explicit "I don't need this anymore" version:
p4789
aVand the implicit version:
p4790
aVAll this happens after return-value optimization
p4791
aVThis means that returning by value is actually pretty efficient in many situations
p4792
as(dp4793
g28
V596781
p4794
stp4795
a((dp4796
g2
(lp4797
VRead up about operator precedence, and note that you are saying
p4798
aVor should I say,
p4799
as(dp4800
g28
V596781
p4801
stp4802
a((dp4803
g2
(lp4804
VUse an arbitrary precision library
p4805
aVA very popular one that comes to mind is GMP
p4806
aVIt is a C library, but it has a nice C++ interface, too
p4807
aVIt is optimized for performance, and since it is widely used, it is probably pretty robust
p4808
as(dp4809
g28
V596781
p4810
stp4811
a((dp4812
g2
(lp4813
VYour  class is inheriting from a non-copyable class, yet you are not implementing the copy constructor
p4814
aVYou are bound to get into trouble when you pass instances of  by value, as you do in the getter functions
p4815
aVThe reason that  works might be that return-value optimization is eliding the copy construction, but this doesn't mean that you're allowed to do this
p4816
as(dp4817
g28
V596781
p4818
stp4819
a((dp4820
g2
(lp4821
VYou can send any sort of data through ASIO, just like you can write any sort of data to a file:
p4822
aVOr simply write to a file:
p4823
aVCasting any variable to  is expressly allowed by the standard, presumably precisely for the reason that you have to be able to serialize binary data to files and sockets etc
p4824
as(dp4825
g28
V596781
p4826
stp4827
a((dp4828
g2
(lp4829
VThere are tons of reasons you might like objects to be default constructible
p4830
aVFirst and foremost you'd like the smart pointer to be as similar as possible to a raw pointer, and since you can say  (and get an undefined, uninitialized pointer), you can also say  and get a pointer that doesn't point anywhere (but you get to test it with )
p4831
aVOne of the most compelling reasons is possibly that you can make containers with s, and you can fill the containers without assigning pointees right there and then
p4832
as(dp4833
g28
V596781
p4834
stp4835
a((dp4836
g2
(lp4837
VIn Bash, you use parameter expansion:
p4838
aVIn your case, say
p4839
aVNo need to go overboard and cry for regexes at the slightest provocation -- Bash has plenty of power
p4840
as(dp4841
g28
V596781
p4842
stp4843
a((dp4844
g2
(lp4845
VIn my Ubuntu 10
p4846
aV4 I have , which "converts RTF to HTML, LaTeX, Postscript"
p4847
aVFrom Postscript it should be a trivial application of  to get PDFs
p4848
as(dp4849
g28
V596781
p4850
stp4851
a((dp4852
g2
(lp4853
V is a variable-length array (VLA), which has automatic storage duration (i
p4854
ag598
aV"on the stack")
p4855
aVIt is not valid in C89 or C++98/03, but it was introduced in C99 and is commonly available as an extension, e
p4856
ag99
aVin GCC
p4857
aVThe functionality can also be mimicked on some platforms with the non-standard  function, which was used before VLAs became common
p4858
as(dp4859
g28
V596781
p4860
stp4861
a((dp4862
g2
(lp4863
VThis is way too much code for me to read, but if you just want to create a byte array for serializing, you don't need any special functions at all, you can just write it algebraically:
p4864
aVNote that this code is independent of your system's endianness
p4865
aVSince you asked, the / functions are for dealing with  integers directly, without explicit char arrays:
p4866
aV(More typically you'd be writing to a socket rather than a file, I suppose
p4867
as(dp4868
g28
V596781
p4869
stp4870
a((dp4871
g2
(lp4872
VYou can either ask your browser to log its HTTP traffic (e
p4873
ag99
aVin Firefox, the Live HTTP Headers addon provides very convenient logging of the headers), or you can just capture your network traffic (with /) and evaluate that, e
p4874
ag99
aVwith Wireshark
p4875
as(dp4876
g28
V596781
p4877
stp4878
a((dp4879
g2
(lp4880
VThere are lots of problems with your code
p4881
aVLet's take it apart, shall we:
p4882
aVAs you can see, you are both causing a memory leak with a gratuitious and reckless , and you are also returning the address of a local object past its lifetime
p4883
aVI would strongly recommmend
p4884
aVreading the documentation for  and understanding "source" and "destination",
p4885
aVnot using , but a safer version like ,
p4886
aVnot using , but instead
p4887
as(dp4888
g28
V596781
p4889
stp4890
a((dp4891
g2
(lp4892
VNo regular expression at all, just use :
p4893
aVAll you're doing is looking for a space
p4894
as(dp4895
g28
V596781
p4896
stp4897
a((dp4898
g2
(lp4899
VThat doesn't work: Your types are pointers, and you cannot overload the operator for built-in types
p4900
aVSo, first off, you compare by dereference:
p4901
aVNext up, to make this work, you must implement 's operator:
p4902
aVNote that the operator should be const and take the right-hand-side argument by const reference
p4903
aVTo refer to your last sentence: If you both cannot change  and you also cannot change the type of , then you are stuck comparing pointers
p4904
as(dp4905
g28
V596781
p4906
stp4907
a((dp4908
g2
(lp4909
VStandard C++ does not prescribe any details about floating point types other than range constraints, and possibly that some of the maths functions (like sine and exponential) have to be correct up to a certain level of accuracy
p4910
aVOther than that, at that level of generality, there's really nothing else you can rely on
p4911
aVThat said, it is quite possible that you will not actually require binarily identical computations on every platform, and that the precision and accuracy guarantees of the  or  types will in fact be sufficient for simulation purposes
p4912
aVNote that you cannot even produce a reliable result of an algebraic expression inside your own program when you modify the order of evaluation of subexpressions, so asking for the sort of reproducibility that you want may be a bit unrealistic anyway
p4913
aVIf you need real floating point precision and accuracy guarantees, you might be better off with an arbitrary precision library with correct rounding, like MPFR - but that seems unrealistic for a game
p4914
aVSerializing floats is an entirely different story, and you'll have to have some idea of the representations used by your target platforms
p4915
aVIf all platforms were in fact to use IEEE 754 floats of 32 or 64 bit size, you could probably just exchange the binary representation directly (modulo endianness)
p4916
aVIf you have other platforms, you'll have to think up your own serialization scheme
p4917
as(dp4918
g28
V596781
p4919
stp4920
a((dp4921
g2
(lp4922
VIf your floating point types use IEEE 754 representation (most likely this is the case), then you should use the fact that the ordering of the binary representation of floats is the same as the ordering by value
p4923
aVThat is, if you increment the binary representation of a float by one bit, you get the next larger number
p4924
aVUsing this fact, we can compare floats by counting their binary difference
p4925
aVThis is called "comparison by unit-in-last-place (ULP)"
p4926
aVThere are some subtleties involving signs, zeros, infinities and NaNs, but that's the gist of it
p4927
aVHere is a comprehensive article explaining this
p4928
aVBasically, we consider two floats equal if they differ in some small number of units in last place
p4929
aVTogether with your compiler's documentation of its math functions' accuracies in last place and your own code you can determine which cut-off suits your needs
p4930
aVIn pseudo code:
p4931
aVThe above code is just a crude example which won't work, you have to take care of lots of special cases before this final comparison
p4932
aVSee the article for details
p4933
as(dp4934
g28
V596781
p4935
stp4936
a((dp4937
g2
(lp4938
VFor fast lookup, there are basically two options: , which has O(log n) lookup, or , which has expected O(1) lookup (but possibly worse)
p4939
aVIf your key type is literally an integer (which by the sound of it is the case), you have perfect hashing for free, so an unordered map would be available with minimal additional cost, so I'd try that one
p4940
aVBut just make a typedef and try both and compare
p4941
aVIf you don't actually need to associate any data to the keys, i
p4942
ag598
aVif you don't need a value type, then replace "map" by "set" everywhere
p4943
aVIf you need multiple records with the same key, replace "map" by "multimap" everywhere
p4944
as(dp4945
g28
V596781
p4946
stp4947
a((dp4948
g2
(lp4949
VYou should probably use fixed point numbers:
p4950
as(dp4951
g28
V596781
p4952
stp4953
a((dp4954
g2
(lp4955
VIf you are using GCC, you may have access to dedicated decimal float routines: http://gcc
p4956
aVgnu
p4957
aVorg/onlinedocs/gccint/Decimal-float-library-routines
p4958
aVhtml
p4959
aVYou should deserialize your binary data into one of the decimal float types and then apply the conversion function to standard floating point types
p4960
as(dp4961
g28
V596781
p4962
stp4963
a((dp4964
g2
(lp4965
VYou want to find all subsets of size K of a set of N elements, say
p4966
aVYou can easily express this recursively:
p4967
aVA subset of size K of S is either a subset of size K of , or it is the union of  and a subset of size K-1 of
p4968
aV(This is precisely the recurrence relation for the binomial coefficients
p4969
aVOnce the subset size is bigger than the ambient set size there are no subsets, so that branch of the recursion stops
p4970
as(dp4971
g28
V596781
p4972
stp4973
a((dp4974
g2
(lp4975
V is the light-weight smart pointer of choice if you just have a dynamic object somewhere for which one consumer has sole (hence "unique") responsibility -- maybe a wrapper class that needs to maintain some dynamically allocated object
p4976
aVhas very little overhead
p4977
aVIt is not copyable, but movable
p4978
aVIts type is , so it depends on two template parameters
p4979
aVis also what  wanted to be in the old C++ but couldn't because of that language's limitations
p4980
aVon the other hand is a very different animal
p4981
aVThe obvious difference is that you can have many consumers sharing responsibility for a dynamic object (hence "shared"), and the object will only be destroyed when all shared pointers have gone away
p4982
aVAdditionally you can have observing weak pointers which will intelligently be informed if the shared pointer they're following has disappeared
p4983
aVInternally,  has a lot more going on: There is a reference count, which is updated atomically to allow the use in concurrent code
p4984
aVAlso, there's plenty of allocation going on, one for an internal bookkeeping "reference control block", and another (often) for the actual member object
p4985
aVBut there's another big difference: The shared pointers type is always , and this is despite the fact that you can initialize it with custom deleters and with custom allocators
p4986
aVThe deleter and allocator are tracked using type erasure and virtual function dispatch, which adds to the internal weight of the class, but has the enormous advantage that different sorts of shared pointers of type  are all compatible, no matter the deletion and allocation details
p4987
aVThus they truly express the concept of "shared responsibility for " without burdening the consumer with the details
p4988
aVBoth  and  are designed to be passed by value (with the obvious movability requirement for the unique pointer)
p4989
aVNeither should make you worried about the overhead, since their power is truly astounding, but if you have a choice, prefer , and only use  if you really need shared responsibility
p4990
as(dp4991
g28
V596781
p4992
stp4993
a((dp4994
g2
(lp4995
VStatic linkage means that the symbol is not visible outside the TU
p4996
aVChange  to  (because global constants are implicitly static):
p4997
aVCorrection: I didn't see that  was a member variable, apologies
p4998
aVIn that case the answer is, as ildjarn already said, to add the definition of the variable outside the class definition
p4999
aVTo be sure, both the declaration and the initialization go inside, but the definition goes outside:
p5000
as(dp5001
g28
V596781
p5002
stp5003
a((dp5004
g2
(lp5005
VThe query should be:
p5006
aVHowever, you may have to rethink your data model and make sure it is normalized, so that you can express this construction directly in the databse without echoing into a comma-separated string
p5007
aVWhy do you have two databases
p5008
aVDo you mean two tables
p5009
as(dp5010
g28
V596781
p5011
stp5012
a((dp5013
g2
(lp5014
VWhile you are linking against  only, the linker looks for , but cannot find it, because it isn't in a findable path for the linker/loader
p5015
aVYou have to set  (and/or ) during the linking stage, or otherwise link  with
p5016
aVJust pretend for a minute that  is itself an executable, let's call it
p5017
aVYou couldn't just say  at the command line because wouldn't be found (check  to examine the loader paths)
p5018
aVInstead, you need
p5019
aVor you need to compile with
p5020
aV(In , you'd say  to pass the option to the linker
p5021
aVThe same load-time resolution process applies to dynamic libraries themselves
p5022
as(dp5023
g28
V596781
p5024
stp5025
a((dp5026
g2
(lp5027
VYou have to use the same type in the definition as you do in the declaration:
p5028
aVThe type is , not
p5029
as(dp5030
g28
V596781
p5031
stp5032
a((dp5033
g2
(lp5034
VAdding the signature alone lets you compile the main translation unit, but you still have to compile the implementation of the function separately and link the two:
p5035
aVmain
p5036
aVcpp
p5037
aVdisplay
p5038
aVcpp
p5039
aVCompile:
p5040
aVLink:
p5041
as(dp5042
g28
V596781
p5043
stp5044
a((dp5045
g2
(lp5046
VJust forward declare the relevant types - and you can make the function pointer part of the typedef:
p5047
as(dp5048
g28
V596781
p5049
stp5050
a((dp5051
g2
(lp5052
VI might recommend graphviz -- I don't know if it has an ascii-art output, but it does support a heap of other useful formats, and perhaps you can find a converter to ascii art from one of those formats
p5053
as(dp5054
g28
V596781
p5055
stp5056
a((dp5057
g2
(lp5058
VI'm not sure if this applies to your OO language, but in you can easily have  contain a reference to  and  a reference to :
p5059
aVThe key is that it's possible to have pointers and references to incomplete types
p5060
aVSince you don't need actual mutually nested members (which wouldn't make sense anyway), but only references, you can easily have circular references like this
p5061
as(dp5062
g28
V596781
p5063
stp5064
a((dp5065
g2
(lp5066
VThe program works fine, it's just that you have to provide an end-of-file in your input:
p5067
aVIf you're literally typing on the console, send  to signal the end of the input
p5068
aV(Unrelatedly, your conditional should probably read  for clarity and semanticity; also, do compile with and heed compiler warnings
p5069
as(dp5070
g28
V596781
p5071
stp5072
a((dp5073
g2
(lp5074
VA quick internet search revealed Monolith, a dedicated open-source program for the purpose of XORing two files
p5075
aVI found it because Bruce Schneier blogged about it, and the purposes of this seem to be of legal nature
p5076
as(dp5077
g28
V596781
p5078
stp5079
a((dp5080
g2
(lp5081
VYou didn't declare the type of
p5082
aVOn Posix systems, you would have said,
p5083
aVHowever, on Windows, you don't have these features
p5084
aVInstead, you could use the Windows API filesystem functions
p5085
as(dp5086
g28
V596781
p5087
stp5088
a((dp5089
g2
(lp5090
VNo, there are no iterators for tuples
p5091
aVIterators are a run-time concept, while tuples are a compile-time construct
p5092
aVAs you rightly remarked, there isn't even a way to make sense of a generic tuple iterator
p5093
aVIf you need a type-erasing runtime container, you could use a vector of s
p5094
as(dp5095
g28
V596781
p5096
stp5097
a((dp5098
g2
(lp5099
VSGML is (in)famously lacking a type system, so there is no mechanized way to infer the correct type for any sort of element
p5100
aVNote that  doesn't mean "mixed data", but "parsed character data" -- an element with content  mustn't contain any other elements, but it can contain entity references (and in SGML it is subject to inclusion/exclusion exceptions, but those are not present in XML)
p5101
aV"Mixed content" is something like , which would be a lot harder to translate into a database schema
p5102
aVYour best bet is to either deduce the content type from the element type names or from helpful comments in the DTD, and/or to inspect a series of documents in observe their usage pattern
p5103
as(dp5104
g28
V596781
p5105
stp5106
a((dp5107
g2
(lp5108
VNo, this is complicated
p5109
aVC++ is a statically-typed and non-reflective language: you cannot create actual C++ code at runtime
p5110
aVThe next-best thing to do is to write a small parser that matches the input against a list of recognized functions that you choose to provide
p5111
aVIt's not that hard to do, but you'll need to write some code
p5112
aVBoost contains some libraries to help you with this (Spirit), I believe, but it's also not terribly difficult to do by hand
p5113
aVYou just need to lex the input into tokens and build up a parse tree
p5114
as(dp5115
g28
V596781
p5116
stp5117
a((dp5118
g2
(lp5119
VWhat do you mean by "valid"
p5120
aVYou're explicitly requesting a cast, and the language or the compiler won't stop you
p5121
aVWhether it's useful is an entirely different matter
p5122
aVIndeed, as you say,  isn't a pointer and it's not pointing to anything useful
p5123
aVThe recipient of the return value will have to know what to do with it (e
p5124
ag99
aVcast it back to , though it's not guaranteed that that gives you back the original value)
p5125
aVIf you never need the value, you might just return
p5126
aVIt's simply that  expects as an argument a function pointer of type , so your function has to return a
p5127
aVIf you don't need it, you can ignore it and just return any old value
p5128
aV(In other situations, your thread function might have chosen to  some memory, fill it with result data and return a pointer to that address, which is why  is in some sense the "most general" return type for a C function that needs to be as flexible as possible without knowing how it's going to be used
p5129
as(dp5130
g28
V596781
p5131
stp5132
a((dp5133
g2
(lp5134
VYou cannot assign arrays in C++ (and a string literal is a  array)
p5135
aVYou have to copy them element-by-element, and for null-terminated char arrays the way to do that is with
p5136
aVA much better, C++-style way to do this would be to make  and  into s, though, which you can assign with the obvious syntax
p5137
as(dp5138
g28
V596781
p5139
stp5140
a((dp5141
g2
(lp5142
VUsing variadic function arguments is a dangerous and tricky business, and almost surely there is a better way - for example, you might pass an  to your function
p5143
aVOK, that said, here's how to use variadic arguments
p5144
aVThe key point is that it is your responsibility to know the number and types of the arguments
p5145
aVJust for completeness, I would redefine the function as this:
p5146
as(dp5147
g28
V596781
p5148
stp5149
a((dp5150
g2
(lp5151
VA naive approach could look like this:
p5152
aVNow you can access each option value from the global  map anywhere in your program
p5153
aVIf you want castability, you could make the mapped type a
p5154
as(dp5155
g28
V596781
p5156
stp5157
a((dp5158
g2
(lp5159
VOnce you have the ASCII representation, you can just build up the result digit by digit, using the fact that the numerals are encoded in order
p5160
aVIn pseudo-code, reading from left to right (i
p5161
ag598
aVstarting with the most significant digit):
p5162
aVinitialize  to 0
p5163
aVfor each digit ,
p5164
aVholds the numeric value of the string
p5165
as(dp5166
g28
V596781
p5167
stp5168
a((dp5169
g2
(lp5170
VFirst off, why do you have a list of pointers
p5171
aVYou might as well keep indices into the vector, which you can compute as
p5172
aVSo, let's build a vector of indices first, but you can easily adapt that to use your list directly:
p5173
aV(There's probably a way to use  and , or lambdas, to do this in one line
p5174
aVNow to do the work
p5175
aVWe simply use the cycle-decomposition of the permutation, and we modify the  vector as we go along:
p5176
aVI'm using the auxiliary set  to track which indices have already been permuted
p5177
aVIn C++0x you would add  everywhere to make this work with movable containers
p5178
as(dp5179
g28
V596781
p5180
stp5181
a((dp5182
g2
(lp5183
VThe compiler is your friend; don't cheat on it by using explicit typecasts, especially between compound types
p5184
aVStick with the first method, if you forward-declare the implementation struct you'll never have to reveal its contents
p5185
as(dp5186
g28
V596781
p5187
stp5188
a((dp5189
g2
(lp5190
VLike this:
p5191
aVWrite sizes  and
p5192
as(dp5193
g28
V596781
p5194
stp5195
a((dp5196
g2
(lp5197
VAs James says, code generation is not part of the language standard, so there's no answer within the context of the language
p5198
aVPractically, though, and especially if you have any sort of optimization, it is entirely possible and to be expected that variables with automatic storage don't actually cause any assembly output at all, for numerous reasons - either a value can be inferred by the compiler, or a pointer-like value (like a reference) refers to something within the same scope and the compiler already knows how to access that datum, and so there's no need to make multiple copies of the same address value at the machine level
p5199
aVTypical examples which would almost certainly not cause additional code to be generated:
p5200
as(dp5201
g28
V596781
p5202
stp5203
a((dp5204
g2
(lp5205
VYou got your types wrong
p5206
aV, alias , is a function pointer, but  is a pointer-to-member-function (PTMF)
p5207
aVThose two are entirely unrelated and incompatible types
p5208
aVYou cannot treat a member function as a free function
p5209
aVSince you only have one single instance of your class (Note: "one instance", not "one class"; you always only have one class), why bother with member functions at all
p5210
aVJust make the function global (inside a namespace) and you're done
p5211
aVThough perhaps I'm misunderstanding your requirements
p5212
aVAnother note: You don't need to pass function pointers by reference to the DLL function, just pass them by value
p5213
aVThey're just pointers, so they're light-weight
p5214
as(dp5215
g28
V596781
p5216
stp5217
a((dp5218
g2
(lp5219
VYou have to call your program with one command-line argument:
p5220
aVOtherwise you're trying to shift into a non-existent variable
p5221
aVAn alternative would be to refer to the argument directly and add a check:
p5222
as(dp5223
g28
V596781
p5224
stp5225
a((dp5226
g2
(lp5227
VFor the client (TCP) or sender (UDP), calling  is optional; it is a way to specify the interface
p5228
aVSuppose you have two interfaces, which are both routable to your destination:
p5229
aVNow if you just say  to , you don't know which local interface furnishes the local side of the connection
p5230
aVBy calling  first, you make this specific
p5231
aVThe same is true for UDP traffic: Without ing, your  will use a random source address and port, but with  you make the source specific
p5232
as(dp5233
g28
V596781
p5234
stp5235
a((dp5236
g2
(lp5237
VWe can get an answer by mimicking Boost and combining hashes
p5238
aVWarning:  Combining hashes, i
p5239
ag598
aVcomputing a hash of many things from many hashes of the things, is not a good idea generally, since the resulting hash function is not "good" in the statistical sense
p5240
aVA proper hash of many things should be build from the entire raw data of all the constituents, not from intermediate hashes
p5241
aVBut there currently isn't a good standard way of doing this
p5242
aVAnyway:
p5243
aVFirst off, we need the  function
p5244
aVFor reasons beyond my understanding it's not been included in the standard library, but it's the centrepiece for everything else:
p5245
aVUsing this, we can hash everything that's made up from hashable elements, in particular pairs and tuples (exercise for the reader)
p5246
aVHowever, we can also use this to hash containers by hashing their elements
p5247
aVThis is precisely what Boost's "range hash" does, but it's straight-forward to make that yourself by using the combine function
p5248
aVOnce you're done writing your range hasher, just specialize  and you're good to go:
p5249
aVIf you want to mimic the pretty printer, you could even do something more extreme and specialize  for all containers, but I'd probably be more careful with that and make an explicit hash object for containers:
p5250
aVUsage:
p5251
as(dp5252
g28
V596781
p5253
stp5254
a((dp5255
g2
(lp5256
VSure, it's called :
p5257
aVNow  consists of unicode codepoints, encoded in the popular UTF8 encoding
p5258
aVNote that this assumes that  consists only of legal ASCII characters (i
p5259
ag598
aVin the range 0-127)
p5260
aVAn alternative to this is
p5261
as(dp5262
g28
V596781
p5263
stp5264
a((dp5265
g2
(lp5266
VI'm not entirely sure what you're trying to achieve, but here's a naive wrapper that stores a list of actions:
p5267
aVUsage:
p5268
as(dp5269
g28
V596781
p5270
stp5271
a((dp5272
g2
(lp5273
VWhat's the problem
p5274
aVThe constructor is just an ordinary function for your purposes, so all you are doing is declaring a local object  of type  which gets deleted at the end of the function scope
p5275
aVNote that your class  is probably very dangerously designed (think of copying, assignment and exceptions), and it's probably entirely unnecessary to allocate dynamic storage for 's members
p5276
aVUpdate: Here's an example of something you might have had in mind:
p5277
as(dp5278
g28
V596781
p5279
stp5280
a((dp5281
g2
(lp5282
VYou have to overload two versions for the []-operator, a const one and a non-const one:
p5283
aVYour constant  function is only allowed to use the second, constant version
p5284
as(dp5285
g28
V596781
p5286
stp5287
a((dp5288
g2
(lp5289
V and  are different types, and so are  and
p5290
aVThe assignment cannot work
p5291
aV(Your  is a different type from the type of
p5292
aVThe entire construction seems very dubious to me -- is this really necessary
p5293
aVWhat are you trying to achieve
p5294
aVHave you looked at
p5295
aVUpdate: It works if you supply the template parameters explicitly:
p5296
aVI'm not entirely sure why the parameters cannot be deduced from the arguments, and I am looking forward to a good explanation -- in the meantime, I put the full code on Ideone, though it doesn't compile there, but it does with my GCC 4
p5297
ag263
ag1217
as(dp5298
g28
V596781
p5299
stp5300
a((dp5301
g2
(lp5302
VSince you want to automate the naming of identifiers, you're basically down to using the preprocessor
p5303
aVYou could try something like this:
p5304
as(dp5305
g28
V596781
p5306
stp5307
a((dp5308
g2
(lp5309
VNo
p5310
aVA member function is not a free function
p5311
aVThe type is entirely different, and a pointer to a member function (PTMF) is a completely different, incompatible object from a function pointer
p5312
aV(A PTMF is usually much bigger, for example
p5313
aVMost importantly a pointer-to-member must always be used together with an instance pointer to the object whose member you want to call, so you cannot even use a PTMF the same way you use a function pointer
p5314
aVThe easiest solution for interacting with C code is to write a global wrapper function that dispatches your call, or to make your member function static (in which case it becomes essentially a free function):
p5315
aVThe conceptual problem here is that you have an engine class, although you will practically only have one single instance of it
p5316
aVFor a genuine class with many objects, a PTMF wouldn't make sense because you'd have to specify which object to use for the call, whereas your engine class perhaps is essentially a singleton class which could be entirely static (i
p5317
ag598
aVa glorified namespace)
p5318
as(dp5319
g28
V596781
p5320
stp5321
a((dp5322
g2
(lp5323
VBoth calls are identical
p5324
aVAll the operators can be called with an explicit  syntax, where  stands for the actual operator symbol
p5325
aVIt is the literal operators like  that are just syntactic sugar for  when it comes to classes
p5326
aV(Though of course for primitive types that is not the case
p5327
aVNote that your []-operator is not very typical, since it is usually used to return a reference to something -- but it's up to you how to implement it
p5328
aVYou're restricted to one single argument, though, unlike
p5329
as(dp5330
g28
V596781
p5331
stp5332
a((dp5333
g2
(lp5334
VToken concatenation:
p5335
as(dp5336
g28
V596781
p5337
stp5338
a((dp5339
g2
(lp5340
VYou can join a table to itself:
p5341
aVIf you use the convention that  is acutally  rather than blank, which is the more idiomatic way to use a database, then you could use  to print a pretty error message in case there's no replacement item:
p5342
aVNote that in the second case I'm using a left outer join to include rows which have no replacement specified
p5343
aVComing to think of it, the  column should have a  foreign-key constraint to the  column, in which case you shouldn't even be allowed to put an empty string as a value
p5344
as(dp5345
g28
V596781
p5346
stp5347
a((dp5348
g2
(lp5349
VIf you have reason to believe that the index is not in your control, or if the control flow is particularly complicated and you're tracing bugs, then you might want to use  during the debug phase, but never inside loops or any situation where you know that the index is safe
p5350
aVEven in other situations you should either prevalidate the index (e
p5351
ag99
aVif it's user input), or if you are just getting the value from a complicated algorithm, use  and fix the bug if there is one
p5352
aV[Edit
p5353
aVOr perhaps if you are writing a very complicated algorithm and you aren't sure that all your indices are always valid, you could use  inside that algorithm and put the call into a try block -- but even here it is preferable to be offensive and use with assertions
p5354
aV[/]
p5355
aVPersonally, I can't see any good reasons for  to survive into release code
p5356
aVYou could possibly contrive some examples where you want to use exception handling as a convenient way to direct your control flow, but any such use case would be very situational
p5357
as(dp5358
g28
V596781
p5359
stp5360
a((dp5361
g2
(lp5362
VIn modern C, and modern C++:
p5363
aVis always either  or
p5364
aVIn C89, you have to  from main explicitly
p5365
aVIn C99 and C++, if you don't return explicitly, you implicitly
p5366
aV[(I've checked the C99 standard now and edited this paragraph
p5367
aVFor your second question, in C99 you must have precisely one of the two  functions
p5368
aVIn C++ the standard says that a program is well-formed if it has a  function that returns , and that every conforming implementation must accept the two listed versions as an entry point (for a "hosted program", e
p5369
ag99
aVnot for the Linux kernel); see 3
p5370
ag263
ag1217
aV[/edit] To the best of my knowledge, calling conventions are also not part of the standard
p5371
aVI don't understand your question about memory, but do note that neither C99 nor C++03 have anything but a rudimentary memory model, whereas the new C++0x explicitly adds a memory model in order to enable well-defined concurrent and atomic operations
p5372
as(dp5373
g28
V596781
p5374
stp5375
a((dp5376
g2
(lp5377
VYou can use logical operators to multiple conditions, e
p5378
ag99
aVfor :
p5379
as(dp5380
g28
V596781
p5381
stp5382
a((dp5383
g2
(lp5384
VThe address in the third invocation should be:
p5385
aVNote that for ,  the expression  is identical to
p5386
aVYou don't want to dereference, you want the address, so you just add to the pointer
p5387
aV(It is also true that  is identical to  as long as  is a valid index
p5388
aVAlso mind @Nobody's observation that your first line is incorrect and you should just say  (or equivalently )
p5389
as(dp5390
g28
V596781
p5391
stp5392
a((dp5393
g2
(lp5394
VSimilarly, but you have to declare the function correctly:
p5395
as(dp5396
g28
V596781
p5397
stp5398
a((dp5399
g2
(lp5400
V[Complete rewrite; disregard the comments]
p5401
aVThe wording has been changed from C++03 to C++0x
p5402
aVIn the latter, there is no more requirement for  to be less-than comparable, presumably to alleviate this unnecessary restriction
p5403
aVThe new standard only requires that  implies
p5404
aVSo as long as your comparator implements both directions, you should be able to legally search a  as the value with a comparator functor that implements both asymmetric comparisons (i
p5405
ag598
aVyour "Attempt 3")
p5406
as(dp5407
g28
V596781
p5408
stp5409
a((dp5410
g2
(lp5411
VThe logical OR is short-circuited, meaning that if the left-hand side is "true", or non-nil, then the value of the entire expression is the left-hand side, and the right-hand side is never considered
p5412
aVSo if  is non-nil, it is the value of the expression
p5413
aVIf it is nil, though, then the value of the expression is the value of the right-hand side, i
p5414
ag598
aVthe value of
p5415
aVYou can even write things like , in which case  only gets reassigned if it was nil to begin with, but won't be touched if it is non-nil
p5416
aVAs for the function, it just takes a string, and it doesn't care what you plug in to the argument
p5417
as(dp5418
g28
V596781
p5419
stp5420
a((dp5421
g2
(lp5422
VString literals are of type , which decays to  in the function call, so you should make the signature of your function
p5423
aVSecond, when you dereference , you only get one char, not the entire string
p5424
aVAnd then you're trying to compare that char to an array (which again decays to a pointer) -- that doesn't work
p5425
aVWhat you need is  (or a variant version thereof):
p5426
aVIf you prefer, you can say  and only compare the initial 12 characters, which is the length of "short_value" including its terminating null byte - not strictly necessary, but it's good to be aware of one's string lengths when using string manipulation functions
p5427
as(dp5428
g28
V596781
p5429
stp5430
a((dp5431
g2
(lp5432
VThat's not terribly hard
p5433
aVKeep dividing by 10 and use the remainder mod 10 as an index into "0123455679"
p5434
aVYou build this up from right to left, so you have to buffer the result and return it in reverse:
p5435
as(dp5436
g28
V596781
p5437
stp5438
a((dp5439
g2
(lp5440
VHere's a simple dynamic 2D array with runtime-configurable column number:
p5441
aVUsage:
p5442
aVThis is just a completely arbitrary and random example
p5443
aVYour real class would obviously have to contain interface methods that are suitable to what you're doing; or you might decide not to have a wrapping class at all and address the naked vector directly
p5444
aVThe key feature is the two-dimensional accessor operator via , which replaces the nested vectors'
p5445
as(dp5446
g28
V596781
p5447
stp5448
a((dp5449
g2
(lp5450
VReferences any day, if you're designing everything yourself
p5451
aVIdiomatic modern C++ should almost never have raw pointers sticking out anywhere
p5452
aVDynamically allocated objects should travel in resource managing containers ( or , or  if applicable), but for most operations passing by (const) reference is the primary way to pass arguments that need to be modified or that are of a heavy-weight type
p5453
aVDon't forget that passing by value may be a viable option if you have movable types
p5454
as(dp5455
g28
V596781
p5456
stp5457
a((dp5458
g2
(lp5459
VTemplate parameters must be compile-time constants
p5460
aVThink of a template as a code generator: The code has to be generated before you start compiling
p5461
aVYou cannot use templates "at runtime"
p5462
aVAs a first step you should say  as much as possible in your code; it's possible that you actually do have compile-time constants but aren't declaring them as such
p5463
aVIf you really need a data structure with dynamic size, you need to use something else (e
p5464
ag99
aVa vector of unsigned chars along with a bitwise accessor function)
p5465
aVHere's a very simple implementation of a bit set as a vector of chars
p5466
aVI'm not wrapping this in a class, you can do that if that's needed:
p5467
as(dp5468
g28
V596781
p5469
stp5470
a((dp5471
g2
(lp5472
VWith a :
p5473
as(dp5474
g28
V596781
p5475
stp5476
a((dp5477
g2
(lp5478
VPutting it to the test, I made three source files:
p5479
aVAfter compiling with , GCC 4
p5480
ag263
aV1, I find that version 2 and 3 produce identical assembly, and version 1 differs only in one instruction,  vs
p5481
aVSo, take your pick and use whatever suits your style
p5482
aVPrefix increment  is probably best because it expresses your requirements most accurately, but don't get hung up about it
p5483
as(dp5484
g28
V596781
p5485
stp5486
a((dp5487
g2
(lp5488
VJust some small errors in your code:
p5489
aVGet the base initializers right:  There is no initialization of , which isn't a direct base; but[Sorry, that was wrong -- you do have to call the virtual base constructor because of the virtual inheritance
p5490
aVyou do have to say the round parentheses
p5491
aVDeclare pure virtual functions without definition:
p5492
aVDouble-check that you want  to inherit virtually from  but non-virtually from  (but that's fine)
p5493
aVDouble-check that all your s have the same constness
p5494
aVIf you already have one pure virtual function in your abstract base class, you should not make the destructor pure
p5495
aVInstead, say,
p5496
aVOtherwise you should still provide a definition of the pure virtual destructor (because the destructor always needs to be callable):
p5497
as(dp5498
g28
V596781
p5499
stp5500
a((dp5501
g2
(lp5502
VMy CUDA experience is only in its infancy, but I believe the error is like this:
p5503
aVis a host function that wants to write the pointer into host memory
p5504
aVHowever, you are passing to it a pointer in device memory
p5505
aVTo fix this, you should first create the device pointers and fill them into your host object structure, and only then copy the whole thing over to the device, and also copy the individual pairs over to the device as well
p5506
aVSchematically:
p5507
aVOn the return, don't forget that the  are device pointers that you still need to copy back one by one
p5508
aVIt would probably be easier to just have one self-contained class that you can move in one go, but that may not be practical, or desirable for reasons of memory locality
p5509
aVYou have to thing carefully about this
p5510
aVIf the member is just a pair, why not put the two items in the main class directly
p5511
as(dp5512
g28
V596781
p5513
stp5514
a((dp5515
g2
(lp5516
VIn very abstract terms, the one and only time when you must be endian-aware and endian-specific is when you serialize data
p5517
aVThis has a very precise meaning which is actually covered by the language standard in C++ to some extent:
p5518
aVInside the main part of your program, data comes in variables of a certain type, written
p5519
aVSo far so portable; your program always does what you want and you don't need to know how  is represented internally
p5520
aVYou know that the memory for  starts at  and is  bytes long, but you don't know anything else
p5521
aVIf you did want to find out, you would have to cast  from  to
p5522
aVWhile casting pointers in general is forbidden (it's called "type punning"), this particular cast is expressly permitted by the standard
p5523
aVCasting to char-pointer is the only way you can serialize your data from an opaque type  into a stream of actual bytes
p5524
aVIt is precisely at this moment that you must know about endianness (or more generally, representation), because you must know in which order the byte stream makes up the internal representation of
p5525
aVFor integral types you can do without casting pointers, but the interface is still at the conversion from byte stream to value:
p5526
aVYou will find the need to convert values into bytestreams and vice versa when using operations like  and , usually associated to files, streams or sockets
p5527
aVNote that for integral values we never need to know about the endianness of the program itself - we only need to know the endianness that is used by the byte stream
p5528
as(dp5529
g28
V596781
p5530
stp5531
a((dp5532
g2
(lp5533
VHow about making a little trait class for your string template parameter:
p5534
aVUsage:
p5535
as(dp5536
g28
V596781
p5537
stp5538
a((dp5539
g2
(lp5540
VAlmost
p5541
aVThe functor must be a binary operator taking the return value type as the first and the range type as the second argument:
p5542
aVSo you don't need a stateful functor at all, a simple function will do:
p5543
as(dp5544
g28
V596781
p5545
stp5546
a((dp5547
g2
(lp5548
VUse  to compute
p5549
aV(If  is a key, this counts the number of elements strictly before
p5550
as(dp5551
g28
V596781
p5552
stp5553
a((dp5554
g2
(lp5555
VHow about a small helper class:
p5556
aVThen you can put the following in your client code:
p5557
as(dp5558
g28
V596781
p5559
stp5560
a((dp5561
g2
(lp5562
VAn easy solution for constant integers is to use enums:
p5563
aVYou won't be able to take the address of , but in turn you get this at zero memory cost
p5564
as(dp5565
g28
V596781
p5566
stp5567
a((dp5568
g2
(lp5569
VI'm not really sure what you're asking, but there isn't any such thing like "acutal SQL"
p5570
aVThe PDO binding translates into an SQL prepared statement, which also looks like you code, directly in the database:
p5571
aVBinding the parameters to variables is done directly at the SQL level, and the database merely exposes an interface to that functionality via PDO
p5572
as(dp5573
g28
V596781
p5574
stp5575
a((dp5576
g2
(lp5577
V[Correction:] It is not
p5578
aVAn exception in your constructor won't leak resources because the only place an exception could occur is inside the  expression, and if a  expression fails, the resources that were allocated by it are freed
p5579
aVYour situation is special because you only make one single allocation in the constructor -- in general this is not safe
p5580
aVYour quoted phrase refers to is the delete operator for the failed-object whose constructor threw:
p5581
aVIn the last line, memory is allocated before the constructor is invoked
p5582
aVThat memory is released in the event of an exception, by an automatic call to
p5583
aV(In general, the matching delete-operator (not "expression"
p5584
aVmatching the new expression is called
p5585
aVIt goes like this:
p5586
aVSuccessful construction: 1
p5587
aVAllocation
p5588
aV2
p5589
aVConstruction
p5590
aV3
p5591
aVDestruction
p5592
aV4
p5593
aVDeallocation
p5594
aVUnsuccessful construction: 1
p5595
aVAllocation
p5596
ag5589
aVDeallocation
p5597
aVNote that we only have an object after the constructor has completed -- so in the event of an exception in the constructor, we do not even have an object
p5598
aVThat's why I said "failed-object" above with a hyphen, because it's not an object at all (like the Douglas-fir isn't a fir at all)
p5599
aVYour code is potentially entirely leak unsafe, if you are making more than one allocation which could throw - i
p5600
ag598
aVa leak occurs whenever one object has been successfully constructed but another, subsequent one fails
p5601
aVYou should probably just not call  in the initializer list and instead put it in the body:
p5602
aVOr, by the principle of single responsibility, don't use raw pointers but use resource managing containers that clean up after themselves
p5603
as(dp5604
g28
V596781
p5605
stp5606
a((dp5607
g2
(lp5608
VYou are defining a type  which is an array of ten structs
p5609
aVTo use this type you have to instatiate a variable of that type:
p5610
aVMaybe a slightly cleaner way would be to have two separate typedefs:
p5611
as(dp5612
g28
V596781
p5613
stp5614
a((dp5615
g2
(lp5616
VThe delete expression calls the destructor of the object to be deleted before releasing the memory
p5617
aVReleasing the memory probably works in either case (but it's still UB), but if you use  where you needed , then you aren't calling all the destructors
p5618
aVSince your complex object itself allocates memory which it in turn releases in its own destructor, you are failing to make all those deletions when you use the wrong expression
p5619
as(dp5620
g28
V596781
p5621
stp5622
a((dp5623
g2
(lp5624
VYou are asking for  to execute arbitrary code
p5625
aVThat doesn't work
p5626
aVIt operates on data, not code, and so whatever you decode has to be a data string
p5627
aVCan't you just encode  directly
p5628
aVOtherwise, you'll have to run  again to turn data into code:
p5629
as(dp5630
g28
V596781
p5631
stp5632
a((dp5633
g2
(lp5634
VIf you have only a single thread, seed once
p5635
aVIf you reseed often, you might actually break some of the statistical properties of the random numbers
p5636
aVIf you have multiple threads, don't use  at all, but rather something threadsafe like , which lets you maintain a per-thread state (so you can seed once per thread)
p5637
as(dp5638
g28
V596781
p5639
stp5640
a((dp5641
g2
(lp5642
VIn general, you use bitwise-AND to check if a certain bit is set:
p5643
aVHowever, don't rely on the physical bit values
p5644
aVInstead, the API defines USEFUL_CONSTANTS that describe the meaning of the flags:
p5645
aVCheck the API documentation of the relevant message to find out which values are defined
p5646
aVUpdate: I see that in your case you might actually want values rather than just flags
p5647
aVSo, to get the value of the lowest 16 bits, you just bitwise-AND the value with the corresponding bitmask:  Note that 0xFFFF is 1111111111111111 in binary
p5648
as(dp5649
g28
V596781
p5650
stp5651
a((dp5652
g2
(lp5653
VMost iterators don't have any global special values in the same way that all pointers can be NULL
p5654
aVTypically, though, you'll be working with specific containers, and if you keep one iterator per container, then you can use  as the sentinel value:
p5655
aVI'm not sure if insertion/deletion invalidates the  iterator, though, so if you're planning on modifying your container, maybe save a copy of the original end, too:
p5656
aVThough again I'm actually not sure if it's well-defined to compare two invalid iterators (in the event that the two do get invalidated)
p5657
as(dp5658
g28
V596781
p5659
stp5660
a((dp5661
g2
(lp5662
V(Un)fortunately, the asterisk  has many different meanings depending on context
p5663
aVSo, let's look at the relevant ones
p5664
aVLet us write  for some arbitrary type (say ):
p5665
aVSo far so good
p5666
aVWe have used the asterisk to designate a new type, namely , which is a "pointer to "
p5667
aVBut what do we do with a pointer
p5668
aVWe can dereference it to get to the value of the variable at the address pointed to by the pointer:
p5669
aVSo, if the asterisk is part of the typename, then it designates a pointer type
p5670
aVIf it comes before a variable name (which is itself of pointer type), then it dereferences the pointer
p5671
aV[Clarification:] In C, pointers naturally go hand-in-hand with the "address-of" operator , which is used to actually obtain a pointer to something
p5672
aVIn Obj-C, a pointer is obtained as the result of object allocation (+ initailization):
p5673
aVBeware that Obj-C offers an alternative syntax to the traditional C and C++ pointer syntax, so you may encounter pointers in other guises
p5674
aV[/Clarification]
p5675
aV(The asterisk can also be used as a binary operator of course, so you can have something like this:
p5676
as(dp5677
g28
V596781
p5678
stp5679
a((dp5680
g2
(lp5681
VSo you say that you have many handlers, each of which can handle an arbitrary number of job IDs, and you want to register an arbitrary number of handlers and let all of them which apply handle a given job
p5682
aVTo that end, let every handler implement this interface:
p5683
aVTo register a handler, simply store a pointer in a container:
p5684
aVThen, if you need to do a job, iterate the container and dispatch:
p5685
as(dp5686
g28
V596781
p5687
stp5688
a((dp5689
g2
(lp5690
VYou don't really have an ordering as much as a certain sequence
p5691
aVHow would you even specify this
p5692
aVIf we think of the collection of rows as an indexed array, then you could make a auxiliary index table:
p5693
aVThen you can join the tables
p5694
as(dp5695
g28
V596781
p5696
stp5697
a((dp5698
g2
(lp5699
VGiven your size estimates for the problem, I would suggest a vector of vectors: The outer vector contains one inner vector for each level, so it contains about 1 million entries; the inner vectors (which contain about 1000 entries each
p5700
aVshould be kept in sorted order and use sorted inserts using  etc
p5701
aVYou can reclaim memory by the copy/swap trick to replace old, unused inner vectors by empty ones
p5702
as(dp5703
g28
V596781
p5704
stp5705
a((dp5706
g2
(lp5707
VIf you don't mind the typing, a trait class comes to mind:
p5708
aVUsage:
p5709
aVUpdate: Even simpler, you could just make a bunch of overloads:
p5710
aV2nd update: You should probably say  rather than  if you want to be even more C++-like
p5711
as(dp5712
g28
V596781
p5713
stp5714
a((dp5715
g2
(lp5716
V really wants a character as the value to fill the memory with -- note that it fills bytewise
p5717
aVSo just say
p5718
aVYou can put that in your  macro if you want
p5719
aVAlternatively, use
p5720
aV(Also, the return type of your  call should be
p5721
as(dp5722
g28
V596781
p5723
stp5724
a((dp5725
g2
(lp5726
VThere's not truely standardized way of aligning a struct, but the rule of thumb goes like this: The entire struct is aligned at a 4 or 8 byte boundary (depending on the platform)
p5727
aVWithin the struct, each member is aligned by its size
p5728
aVSo the following packs with no padding:
p5729
aVThis will have a total size of 12
p5730
aVHowever, this next one will cause padding:
p5731
aVNow the structure takes up 16 bytes
p5732
aVThis is just a typical example, the details will depend on your platform
p5733
aVSometimes you can tell a compiler to never add any padding -- this cause more expensive memory access (possibly introducing concurrency problems) but will save space
p5734
aVTo lay out aggregates as efficiently as possible, order the members by size, starting with the biggest
p5735
as(dp5736
g28
V596781
p5737
stp5738
a((dp5739
g2
(lp5740
VYou are causing undefined behaviour
p5741
aVThis means that anything can happen
p5742
aVSince something did indeed happen, everything behaves as documented
p5743
aV(Sometimes "something" looks very similar to something else that you might erroneously expect
p5744
aVDoing exactly what you think you were trying to achieve is one of the possible allowed instances of "undefined behaviour"
p5745
aVNote also that a "memory leak" is sort of the opposite of what you're trying to do - in a memory leak you forget to free memory, whereas you already freed the memory and are now accessing invalid memory
p5746
aVHere's a real memory leak, which also does not cause undefined behaviour -- don't confuse "bad but correct" with "incorrect" programming
p5747
as(dp5748
g28
V596781
p5749
stp5750
a((dp5751
g2
(lp5752
VYou can use IO manipulators:
p5753
aVAlternatively, you can change the formatting flags separately on  with  etc
p5754
aV, e
p5755
ag99
aVsee here ("Formatting")
p5756
aVBeware that the field width has to be set every time, as it only affects the next output operation and then reverts to its default
p5757
aVTo get the true number of hex digits in a platform independent way, you could say something like  as the argument for
p5758
as(dp5759
g28
V596781
p5760
stp5761
a((dp5762
g2
(lp5763
VYou cannot return a non-constant reference to a member in a constant function
p5764
aVThe usual two overloads for direct member accessors are like this:
p5765
aVInside a constant function, the type of  is  (where  is your class)
p5766
aVThinking of your class as a dumb C struct for a minute, you are returning , but that's constant when  is a pointer-to-constant, so you cannot make a non-constant reference to that
p5767
aVReturning by value is fine because you invoke the copy constructor of , which has signature  -- so it can copy from constant references:
p5768
as(dp5769
g28
V596781
p5770
stp5771
a((dp5772
g2
(lp5773
VYou are creating the string "013", which is evaluated as a JavaScript integer literal
p5774
aVInteger literals starting with  are interpreted base 8 (octal), so your number is 8 + 3, which is 11
p5775
aVOnly integer literals starting with a non-zero digit are interpreted base 10
p5776
as(dp5777
g28
V596781
p5778
stp5779
a((dp5780
g2
(lp5781
VConfigure your server to allow s; see the documentation for details
p5782
as(dp5783
g28
V596781
p5784
stp5785
a((dp5786
g2
(lp5787
VYou can combine  with :
p5788
as(dp5789
g28
V596781
p5790
stp5791
a((dp5792
g2
(lp5793
VI'd say the difference is a conceptual one
p5794
aVA multidimensional array
p5795
aVdenotes a contiguous area of memory of size $\u005cprod_i d_i$, if you pardon the TeX, and it's addressed in strides: x[i_1]
p5796
aV[i_N] is the element at position $i_N + i_{N-1} d_N + i_{n-2} d_{N-1} d_N +
p5797
aV+ i_1 d_2
p5798
aVd_N$
p5799
aVIntermediate indexes can be taken as pointers to the respective subarrays
p5800
aVA ragged array on the other hand decouples the inner "dimension" from the outer one in memory:
p5801
aVWhether the sizes actually vary or not is immaterial here, but the conceptual difference is that a ragged array is an array of arrays, whereas a multidimensional array is a far more rigid and coherent object
p5802
as(dp5803
g28
V596781
p5804
stp5805
a((dp5806
g2
(lp5807
VIn modern C++, you would use a dynamic container for the inner "array":
p5808
aVThis is by far safer and more modular than anything you could try with manually allocated storage
p5809
aVUsage:
p5810
as(dp5811
g28
V596781
p5812
stp5813
a((dp5814
g2
(lp5815
VYou can't do that
p5816
aVtl;dr: Member functions are not free functions
p5817
aVYour callback has to be a free function
p5818
aVLonger answer: The set-callback function requires a function pointer as its callback argument
p5819
aVOnly free functions can be turned into a function pointer
p5820
aVNon-static member functions are not free functions, and they cannot be turned into function pointers
p5821
aVThe expression  is a pointer-to-member-function (PTFM), which is an entirely different, incompatible, usually much larger type
p5822
aVIf your client function is fixed by a C API, then you have two possible solutions:
p5823
aVMake a static member function
p5824
aVStatic member functions are essentially just free functions, so they do produce function pointers
p5825
aVIn that case you're not really using the class structure and there's no statefulness (which is why you can do this)
p5826
aVWrite a global wrapper function
p5827
as(dp5828
g28
V596781
p5829
stp5830
a((dp5831
g2
(lp5832
VIn C++0x you can, using type traits and :
p5833
aVIn C++98/03 you don't have , but now you'd have to explain how you could possibly have a variable without knowing its type
p5834
aVIf you do have its type, you can use the same type trait:
p5835
aVYou can also just define your own trait class if you don't have or want to use TR1:
p5836
as(dp5837
g28
V596781
p5838
stp5839
a((dp5840
g2
(lp5841
VJust specify your namespaces correctly and carefully:
p5842
as(dp5843
g28
V596781
p5844
stp5845
a((dp5846
g2
(lp5847
VTurn on all your compiler warnings
p5848
aVYou are using the same template parameter names in your  declarations as in the template class itself, which is not good; rename them
p5849
aVHere's one solution: Remove the out-of-line operator definition and make the inline definition this:
p5850
aVNow, since your RHS is an arbitrary type, you have to mention the type:
p5851
aVThis is because there is no way to deduce parameters  from the integer  so that an appropriate conversion to  could be performed (see Nawaz's answer)
p5852
aVTo take advantage of your conversion constructor from , you can only operate on the same type, not a templated other type
p5853
aVTo this end, add a non-template operator:
p5854
aVNow you can say , using the  constructor
p5855
aVUpdate: As the OP suggests, to allow for symmetric invocation (), and in order to only allow operations within a fixed type as David suggests, we should remove both the unary operator and the templated friend binary operator and instead just have a non-templated binary friend:
p5856
aVThat's a matter of design choice; I would personally favour the final version
p5857
as(dp5858
g28
V596781
p5859
stp5860
a((dp5861
g2
(lp5862
VA bit off-topic, in C++ with variadic templates you can avoid the recursive instantiation thanks to a recursive definition:
p5863
aVNow you can say  and inherit from all those
p5864
aVIf you want to inherit also from multiply nested other instances of , you should make all the inheritances virtual
p5865
aVThe final specialization in my example also shows how you can specialize  to not derive from anything
p5866
aVIf you write , you have an object of a class that does not derive from anything
p5867
as(dp5868
g28
V596781
p5869
stp5870
a((dp5871
g2
(lp5872
VThis isn't really about function pointers, but about casting in general
p5873
aVSuppose  is of type
p5874
aVThen  is of type
p5875
aVThis gets cast to  by the cast expression (the stuff in the parentheses)
p5876
aVFinally, this gets dereferenced, yielding a
p5877
aVAll in all this just means you're treating  as if it were of type  and assign a value to it
p5878
aVHere's a generic example:
p5879
as(dp5880
g28
V596781
p5881
stp5882
a((dp5883
g2
(lp5884
VWhat you're doing is generally terrible (much better would be for instance to expose a logging output stream, or any number of Boost logging facilities), but if you really must go through with it, let's see how to fix this
p5885
aVFirst off,  prints to the standard output, not to a string, so first of all do read up the documentation of your basic building block functions
p5886
aVThe closest thing to something useful would be , which prints to a wide string
p5887
aVWe still need to impose an arbitrary size limit:
p5888
aVYou'd still have to add some sort of error handling in the event that your buffer is too short
p5889
as(dp5890
g28
V596781
p5891
stp5892
a((dp5893
g2
(lp5894
VI have a suspicion that you're not actually trying to ask what you asked
p5895
aVThe
p5896
aVdll file in your example is just a shared library
p5897
aVYou can link against shared libraries with GCC
p5898
aVThe only question is what you call your library:
p5899
aVThe naming convention is really just a convention
p5900
aVNow to link your program:
p5901
aVSo if the code is entirely in your hands, you just build the library first and then link against your project
p5902
aVIf you really mean that the library source code is unavailable and you only have a Windows binary, then the situation is a lot trickier
p5903
aVFor instance, the binary formats aren't even compatible
p5904
as(dp5905
g28
V596781
p5906
stp5907
a((dp5908
g2
(lp5909
VYou are printing out something broken
p5910
aVWe only need 32 bits, which are:
p5911
aVYour variable in binary:
p5912
aVLogical value accounting for little endian:
p5913
aVAccording to IEEE:
p5914
aVSo now it's clear:
p5915
aVthe sign is +1 ()
p5916
aVthe exponent is 124 - 127 = -3
p5917
aVthe mantissaa is 1
p5918
aV01b, which is 5/4
p5919
aVSo the value is 5/4 / 8 = 5/32 = 0
p5920
aV15625
p5921
as(dp5922
g28
V596781
p5923
stp5924
a((dp5925
g2
(lp5926
VThe very first page of the Thrust user guide gives an example to do exactly that:
p5927
aVInstead of  you can use your own POD structure, and you can pass a comparator to the sort algorithm
p5928
as(dp5929
g28
V596781
p5930
stp5931
a((dp5932
g2
(lp5933
VClass  is not identical to class
p5934
aVThat's why members of class  cannot access non-public members of class
p5935
aVOn the other hand, class  derives publicly from class , so class  now has a (protected) member  which any member of class  can access
p5936
as(dp5937
g28
V596781
p5938
stp5939
a((dp5940
g2
(lp5941
VWhat you've written isn't C++, and it's definitely not allowed
p5942
aVCorrect way:
p5943
aVYou can only read the values  to , but never change them
p5944
aVYou can change the values  for i in 0 to 5, but be sure not to set  to anything but zero
p5945
aVAny access, read or write, to  or  with  greater than five is undefined behaviour and almost definitely suicidal
p5946
aVIn the case of , the string literal usually lives in a global, read-only part of memory
p5947
aVOn the other hand,  is just an automatic array in the local scope that's initialized to the given six characters (including terminal zero)
p5948
aVConversely, if by some mysterious ways you have already come at the address of some valid area of memory, you could wreak all sorts of havoc:
p5949
aVIndeed C and C++ let you freely roam about your process's virtual memory space, but you may get shot at any point
p5950
aV(For you second question, writing  is fine, but it will set  to point to a different string and not modify the original one (and  should still be of type )
p5951
as(dp5952
g28
V596781
p5953
stp5954
a((dp5955
g2
(lp5956
VYou can avoid the exception check entirely by simply checking the return value of  first:
p5957
aVIn the first case, , the search string wasn't found, and in the second case it is right at the beginning of the ambient string so you cannot look at the character before it
p5958
aV(This is called "offensive programming": Don't check for errors at runtime, but construct your algorithm so that you know that your access is correct
p5959
aVIf you will, you can add an assertion  to express your certainty that you are holding a correct value, which will not weigh down your release version
p5960
aVUpdate: Replaces  by  since we're sure of ourselves
p5961
as(dp5962
g28
V596781
p5963
stp5964
a((dp5965
g2
(lp5966
VI made a mess of this; it should be OK now, but credit is due to @UncleBens below who got it right (and should get the "accept")
p5967
aVWithout the  in your third version, you have two partial specializations which are equally specific when you instantiate :
p5968
aVFirst PS: , ,
p5969
aVSecond PS without : ,
p5970
aVSecond PS with : , ,
p5971
aVThis does not establish comparable elements in the partial specialisation ordering
p5972
aVNote that you can say  and  and the second one is more specific than the first because it has more non-variadic parameters
p5973
aVBut on the other hand, without the , when you say , then the first argument matches better in the second PS, but the remaining arguments match better in the first PS
p5974
aVWith the  in place, though, the second PS is more specific
p5975
aVCompare this to the partial specialization that is actually more specific:
p5976
aVNow it is clear how whether a given instance matches the specialization, or only the general form
p5977
aVThe specialization has a fixed number of parameters (3), so it wins over another specialization with a variable number of arguments
p5978
as(dp5979
g28
V596781
p5980
stp5981
a((dp5982
g2
(lp5983
VA template can have only one base definition
p5984
aVIf you need a variable number of arguments and you don't want to use "null type" constructions as @awoodland suggests, and if you have a C++0x compiler, then you can use variadic templates:
p5985
as(dp5986
g28
V596781
p5987
stp5988
a((dp5989
g2
(lp5990
VYou have to ensure that the full definition of the class  is visible at the point where you define the class
p5991
aV(So check your inclusions
p5992
aVThis is because you can only inherit from fully defined classes, but not from just forward-declared ones
p5993
aVThe only time you can get away with forward-declarations in place of full definitions is when you make pointers or references to a type, but only if you never access any of its members, or (thanks to @Alf) when declaring a function with incomplete return type
p5994
as(dp5995
g28
V596781
p5996
stp5997
a((dp5998
g2
(lp5999
VReally, you have to use the identifier  three times for three different things
p6000
aV:-S
p6001
aVJust write it readbly:
p6002
aVNo more confusion, no more shadowing, no more uninitialized variables
p6003
aVWho are you trying to trick
p6004
aVThink about your replacement who will have to learn and understand your code
p6005
aVTip: Turn on compiler warnings
p6006
aVPS: Before anyone talks about efficiency and starts counting CPU cycles: a) don't
p6007
aVb) hug your wife
p6008
aVc) compare the assembly of this code and your code
p6009
as(dp6010
g28
V596781
p6011
stp6012
a((dp6013
g2
(lp6014
VYour linked question already answers this
p6015
aVLet's define
p6016
aVWhen you say , you would like to call the constructor
p6017
aVHowever, the constructor  matches better, because it takes  and thus resolves to , which is a better match due to the absence of
p6018
aVTo resolve this, you should essentially get rid of the  constructor, as Howard suggested already
p6019
aVSince you only intend that constructor for values anyway, my first suggestion would be to change the signature to , which would already solve your problem
p6020
aVAnother solution would be to add a constructor with signature  (non-const)
p6021
aVThat's ugly, though
p6022
aVFinally, you could call the constructor explicity at the call site: , or  or even , if that's an option
p6023
aVFinally note that if you are only dealing with primitive members, there's nothing to be gained from explicit moves, so you might as well not bother defining all those constructors separately
p6024
as(dp6025
g28
V596781
p6026
stp6027
a((dp6028
g2
(lp6029
VStringification with slingshot should do the trick:
p6030
aVIt'll expand to , which is the same as
p6031
as(dp6032
g28
V596781
p6033
stp6034
a((dp6035
g2
(lp6036
VYou need :
p6037
aV(This is for C++0x; Boost should work similarly
p6038
aVJust making a shared pointer from  is tricky because you might shoot your own foot off
p6039
aVInheriting from  makes this easier
p6040
aVWord of warning: Your construction with the naked  pointer seems to defeat the purpose of using resource-managing classes
p6041
aVWhy not make  into a smart pointer, too
p6042
aVMaybe a
p6043
as(dp6044
g28
V596781
p6045
stp6046
a((dp6047
g2
(lp6048
VYou don't need a synchronized variable, but rather an atomic variable
p6049
aVLuckily, you can just use
p6050
aVThe key issue is that if more than one thread accesses the same memory simultaneously, then unless the access is atomic, your entire program ceases to be in a well-defined state
p6051
aVPerhaps you're lucky with a bool, which is possibly getting updated atomically in any case, but the only way to be offensively certain that you're doing it right is to use atomic variables
p6052
aVSeeing codebases you work in" is probably not a very good measure when it comes to learning concurrent programming
p6053
aVConcurrent programming is fiendishly difficult and very few people understand it fully, and I'm willing to bet that the vast majority of homebrew code (i
p6054
ag598
aVnot using dedicated concurrent libraries throughout) is incorrect in some way
p6055
aVThe problem is that those errors may be extremely hard to observe or reproduce, so you might never know
p6056
aVEdit: You aren't saying in your question how the bool is getting updated, so I am assuming the worst
p6057
aVIf you wrap your entire update operation in a global lock, for instance, then of course there's no concurrent memory access
p6058
as(dp6059
g28
V596781
p6060
stp6061
a((dp6062
g2
(lp6063
VHere is a template unraveller that uses variadic typenames
p6064
aVYou can probably make it work in VS2010 with the usual macro tricks (e
p6065
ag99
aVlike in the pretty-printer
p6066
aVIt won't print anything exciting, so at the moment you just get one line per inheritance, but if you partially-specialize  you can print specific information for your types
p6067
as(dp6068
g28
V596781
p6069
stp6070
a((dp6071
g2
(lp6072
VYour very first line is shady:
p6073
aVHow is that supposed to work
p6074
aVThe factory method cannot return a reference to a temporary, so the only sensible reference it could return is to a dynamically created object - but now who is responsible for this object
p6075
aV(Unless you are just returning a reference to an existing object, that is
p6076
aVBut I'm assuming that your factory is genuinely creating new objects
p6077
aVThis code is a memory-leak car crash; I don't see any way to write anything sensible like that
p6078
aVA far better way is to return the newly created object in a responsible container, e
p6079
ag99
aVa  or a :
p6080
aVThat way, if nobody picks up the factory product, or if an exception occurs, the dynamically allocated object will get properly disposed of
p6081
aVThis also makes it trivial to assign different pointers depending on a conditional:
p6082
as(dp6083
g28
V596781
p6084
stp6085
a((dp6086
g2
(lp6087
VThe only purpose of the complicated expression  is to avoid compiler warnings
p6088
aVIf you just had a naked, useless expression, the compiler might warn about an expression that has no effect
p6089
aVBut by explicitly casting something to  you indicate that you mean to do this
p6090
aV(Think about how confusing it would be to the user if the compiler suddenly said, "Warning: expression  has no effect
p6091
aV, when all you've done is switched to release mode
p6092
aVThis was also common practice in C, where you'd say  to tell the compiler that you intentionally chose to ignore the return value of the function
p6093
aVThe  cast is not merely a choice by a particular implementation; it's required by the C standard
p6094
aVQuoting the 2011 ISO C standard (similar wording appears in the 1990 and 1999 editions):
p6095
aVIf  is defined as a macro name at the point in the source file
p6096
aVwhere  is included, the  macro is defined simply as
p6097
aVThe C++ standard requires the contents of the  header to be the same as the Standard C  header
p6098
as(dp6099
g28
V596781
p6100
stp6101
a((dp6102
g2
(lp6103
VYour  is an 8-bit integer, but each bit individually is assigned some independent meaning
p6104
aVIn your case, you only want to know its second bit
p6105
aVTo do so, you perform bitwise-and with 00000100b, which is 4:
p6106
aVNow  is  if the second bit is set (), and  otherwise ()
p6107
aVThus  is eiter 4 or 0 accordingly
p6108
aVIt's customary to just use hexadecimal notation for the individual bits:
p6109
as(dp6110
g28
V596781
p6111
stp6112
a((dp6113
g2
(lp6114
V"With other sequence containers" is your error -  is an associative container
p6115
aVIn associative containers, elements are defined by their key (as opposed to their insertion order in sequence containers), and you erase elements by key:
p6116
aVErasing by key value has the same complexity as lookup (e
p6117
ag99
aVO(log n) for map, O(1) for unordered map, etc
p6118
aVAlternatively, you can erase by iterator in constant time
p6119
aVErasing an iterator invalidates that iterator, but no others (again unlike in sequence containers), so if you want to iterate over a map, the typical idiom is this:
p6120
as(dp6121
g28
V596781
p6122
stp6123
a((dp6124
g2
(lp6125
VYour typical spinlock:
p6126
aVSee Herb Sutter's wait-free queue for a real-world application
p6127
as(dp6128
g28
V596781
p6129
stp6130
a((dp6131
g2
(lp6132
VTo make an exe, use the linker:
p6133
aVTo make a compressed archive, use tar:
p6134
aVTo make an axe, use two sticks and three diamonds
p6135
as(dp6136
g28
V596781
p6137
stp6138
a((dp6139
g2
(lp6140
VIf you only append at the back and erase from the back,  is fine
p6141
aVIf you append and erase from both front and back, but never from the middle, use
p6142
aVIf you frequently must insert into and erase from the middle, use
p6143
aVDepending on your lookup and traversal requirements,  might be an alternative
p6144
aVIn any case, you should profile the performance; use a typedef for your main container so you can quickly switch and test the different options
p6145
aVThere may be other requirements which you aren't telling us but which are important for the choice of container:
p6146
aVvector and deque are random-access containers; list and set are node-based
p6147
aVThis affects iterator invalidation
p6148
aVvector, deque and list are sequence containers, while set is associative; this affects lookup by value
p6149
as(dp6150
g28
V596781
p6151
stp6152
a((dp6153
g2
(lp6154
VIf your shape is convex, you can go in winding order around the barycentre of your points (i
p6155
ag598
aVthe centre of gravity, or "average"):
p6156
aVBoth coordinates of each vertex will be either above or below the corresponding coordinate of the barycentre:
p6157
aVSo starting at any point, just move to one point for which only one of the two signs changes, but not both
p6158
aVIf your shape is not convex, you could first triangulate it with an interior edge, apply the vertex ordering with consistent orientation for each triangle, and then merge the edges by cancelling out the pairwise-opposite interiors
p6159
aVNote that for a non-convex set of points (i
p6160
ag598
aVa set where one point is contained in the open interior of the convex hull of the set), there may be more than one quadrilateral with those points as vertices (think of all the ways of joining the inner vertex to two of the outer ones)
p6161
as(dp6162
g28
V596781
p6163
stp6164
a((dp6165
g2
(lp6166
VSure, use typedefs:
p6167
as(dp6168
g28
V596781
p6169
stp6170
a((dp6171
g2
(lp6172
VThe compiler already tells you the answer
p6173
aVThe class  is a template with one parameter, and the member function  is a template member function, and you have to define it in the same way:
p6174
aVIf you define the function at the declaration site, you'll implicitly declare it ; that's about the only difference practically
p6175
aVThere may be stylistic considerations, of course, e
p6176
ag99
aVnever to put function definitions inside class definitions
p6177
aVAs you rightly observe, you will still have to provide the definition in the header file, since you will need to instantiate the template whenever you use it, and thus you need access to all the definitions
p6178
as(dp6179
g28
V596781
p6180
stp6181
a((dp6182
g2
(lp6183
VIf you are not linking against the standard library for some reason (as may well be the case in an embedded scenario), you have to provide your own operators  and
p6184
aVIn the simplest case, you could simply wrap , or allocate memory from your own favourite source:
p6185
aVYou should never have to do this if you are compiling for an ordinary, hosted platform, so if you do need to do this, you better be familiar with the intricacies of memory management on your platform
p6186
as(dp6187
g28
V596781
p6188
stp6189
a((dp6190
g2
(lp6191
VThis is an instance of the common code reuse technique to implement one operator in terms of another
p6192
aVSuppose we have already defined a compound-plus operator:
p6193
aVThis unary operator allows us to write , it modifies  and returns a reference to itself
p6194
aVThis is all fine and good
p6195
aVNow if we also want to provide a copying, binary plus opearator , which returns a the new value by value and leaves both  and  unchanged, then we want to take advantage of the code we've already written for the compound operator
p6196
aVWe do so by calling the unary operator on a temporary copy of :
p6197
aVThis is exactly what your code does, only a bit more verbosely
p6198
aVYou could as well have written
p6199
aVThere are other idioms with follow a similar spirit, such as implementing non-const access in terms of const access, copy-assign in terms of copy-construct and swap, and move-assign in terms of move-construct and swap
p6200
aVIt always boils down to avoiding code duplication
p6201
as(dp6202
g28
V596781
p6203
stp6204
a((dp6205
g2
(lp6206
VYou just have to store the numbers that you read from the file in some permanent storage
p6207
aVAlso, you probably want to parse the individual numbers and obtain their numerical representation
p6208
aVSo, three steps:
p6209
aVAllocate some memory to hold the numbers
p6210
aVAn array of arrays looks like a useful concept, one array for each block of numbers
p6211
aVTokenize each line into strings corresponding to one number each, using
p6212
aVParse each number into an integer using  or
p6213
aVHere's some example code to get you started:
p6214
aVIn the end, you need to free the memory:
p6215
as(dp6216
g28
V596781
p6217
stp6218
a((dp6219
g2
(lp6220
VC doesn't work like that - a global variable is allocated at load time and exists for the entire duration of the program, independent of the runtime behaviour
p6221
aVIf you really must know whether the variable has been "set", you could include a separate flag:
p6222
aVIf you know that your variable can only be non-negative, then you could alternatively use a special sentinel value like  to indicate that the variable hasn't been "set" yet
p6223
aVMost likely though is that you should rework your design so that you already know by other means whether or not you need the variable
p6224
as(dp6225
g28
V596781
p6226
stp6227
a((dp6228
g2
(lp6229
VI think deriving your class from a base class is not relevant to the question here, that's a mere implementation detail
p6230
aVWhat you really seem to be after is if there's a way to partially specialize member functions, like the constructor
p6231
aVDo you want something like this
p6232
aVThis doesn't work
p6233
aVYou always have to specialize the entire class
p6234
aVThe reason is simple: You have to know the full type of the class first before you even know which member functions exist
p6235
aVConsider the following simple situation:
p6236
aVNow  depends on , but the function only exists when  is not , because  is an entirely different class
p6237
aVOr consider even another specialization  -- even the polymorphic nature of a class can be entirely different in a specialization
p6238
aVSo the only way you can provide specializations new declarations of members, including constructors, is by specializing the entire class
p6239
aV(You can specialize the definition of existing functions, see @Alf's answer
p6240
as(dp6241
g28
V596781
p6242
stp6243
a((dp6244
g2
(lp6245
VThe C standard doesn't make any specific width requirements for integral types other than minimal ranges of values that the type needs to be able to represent, and that the widths are non-decreasing:  (similarly for the unsigned types)
p6246
aVonly became part of the standard in C99 and C++0x, by the way
p6247
aVThe minimum required ranges can be found in this Wikipedia article
p6248
as(dp6249
g28
V596781
p6250
stp6251
a((dp6252
g2
(lp6253
V is the type of the function;  is the type of the function pointer
p6254
aVIn other words, if you define
p6255
aVthen  is the same as
p6256
aVThe  template captures the return and argument types via (variadic) templates:
p6257
as(dp6258
g28
V596781
p6259
stp6260
a((dp6261
g2
(lp6262
VI don't think it can be done directly like that, because  creates a new object that takes the function object and the arguments by reference, and you can't rebind references
p6263
aVHowever, you can easily enough write your own templated functor wrapper with a reassignable function pointer:
p6264
aV[Edit:] Do check the comments below; holding references taken by const reference in the constructor can be dangerously abused, so be careful, or save  and  by value if you prefer
p6265
aV[/]
p6266
aVNow you can initialize the functor with the arguments early:
p6267
aVThen assign a function pointer and call:
p6268
aVYou could even replace the call operator by this:
p6269
aVAnd then invoke the functor with the function pointer as the argument:
p6270
aVIn that case you don't need the return type as a fixed parameter any longer, but now you don't get a nullary call operator
p6271
aVTake your pick
p6272
as(dp6273
g28
V596781
p6274
stp6275
a((dp6276
g2
(lp6277
VIn each case, the character gets promoted to  before the shift
p6278
aVOn your platform,  is signed, so  is , but  is 255
p6279
aVSo you are seeing:
p6280
aVNote that the latter overflows and wraps (on your platform)
p6281
aVIt is different from , which is 4278190080
p6282
aVTo achieve that, you have to say
p6283
as(dp6284
g28
V596781
p6285
stp6286
a((dp6287
g2
(lp6288
VIn some way, deleting existing object files defeats the purpose of having separate translation units in the first place
p6289
aVYour standard build environment should normally only rebuild those object files which are older than the corresponding source file
p6290
aV(You don't need to delete, you can just overwrite
p6291
aVIf you have a decent revision control system, then even checking out an older version of a modified file will make the actual file on disk have a current timestamp, but indeed, if you're worried that something might be inconsistent, you can always clean up the entire build tree and start over
p6292
aVBut as a matter of normal code writing, it would appear terribly wasteful to delete object files
p6293
aVYou should of course keep one set of object files for each set of build options (e
p6294
ag99
aVdebug vs release)
p6295
aVSome build environments allow you to have multiple output directories, others (like cmake) will just automatically rebuild everything if you change the global build settings, but that's something to watch out for, especially if you just add some #defines to the compiler flags in the middle of a build process
p6296
as(dp6297
g28
V596781
p6298
stp6299
a((dp6300
g2
(lp6301
VQ1) If you don't write a copy constructor, the compiler will generate one for you, which wouldn't be what you want
p6302
aVTemplated conversion constructors don't count
p6303
aVQ2) Remember that  is like a , convertibility must be checked at the level of pointers
p6304
aVIf  is convertible to  then you should be able to assign one to the other
p6305
aVThink of pointers-to-base
p6306
aV[Sorry, that wasn't what you asked
p6307
aVThe final argument type just needs to exist, but also we don't want to have to specify the argument itself
p6308
aVA universal way of making up a type for which we can also provide a default argument is a pointer
p6309
aVIn short, we need to make the function depend on a type that may or may not exist, but without actually requiring the user to know about this
p6310
as(dp6311
g28
V596781
p6312
stp6313
a((dp6314
g2
(lp6315
VThe other answers already correctly stated the problem with your approach, here's an idea for a solution
p6316
aVSince the first string is your key, change your main data structure to a  keyed on the first string and carrying the rest of the data as the payload:
p6317
aVIn some sense the second string is a bit redundant, and you might be able to redesign this to do away with it entirely: Instead of  use , and if the key already exists, you append your second string to the set
p6318
as(dp6319
g28
V596781
p6320
stp6321
a((dp6322
g2
(lp6323
VThis is a classic JOIN query
p6324
aVWhose picture do you want, the sender's or the receiver's
p6325
aVLet's get the picture for the receiver:
p6326
aVIf you want a specific user only, add the condition  or something like that to the query
p6327
aVYou can also JOIN a table twice
p6328
aVSuppose you want to get the picture of both the sender and the receiver:
p6329
as(dp6330
g28
V596781
p6331
stp6332
a((dp6333
g2
(lp6334
VNo
p6335
aVMacros aren't even visible to the compiler
p6336
aVThey get replaced by their substitution text during preprocessing, which happens at the very beginning
p6337
aVMacros are dumb, they know nothing about you or your motives
p6338
aVThey don't even know what language you're writing
p6339
aVBeware
p6340
as(dp6341
g28
V596781
p6342
stp6343
a((dp6344
g2
(lp6345
VYou aren't showing the relevant code and compiler invocation, but know that  has an unimplemented virtual member function  that you're expected to override, so don't go throwing naked s if you want to call
p6346
aVAny of the derived, specific exceptions in  will implement  and allow you to store a message when you're constructing the exception object
p6347
as(dp6348
g28
V596781
p6349
stp6350
a((dp6351
g2
(lp6352
VWhile nothing stops you from writing your own helper, I believe that the main reason for providing  in the library is that it actually creates a different internal type of shared pointer than , which is differently allocated, and there's no way to achieve this without the dedicated helper
p6353
aVYour  wrapper on the other hand is mere syntactic sugar around a  expression, so while it might look pleasing to the eye, it doesn't bring anything  to the table
p6354
aVCorrection: this isn't in fact true: Having a function call to wrap the  expression provides exception safety, for example in the case where you call a function
p6355
aVHaving two raw s that are unsequenced with respect to one another means that if one new expression fails with an exception, the other may leak resources
p6356
aVAs for why there's no  in the standard: It was just forgotten
p6357
aV(This happens occasionally
p6358
aVThere's also no global  in the standard even though there should be one
p6359
aVAlso note that  takes a second template parameter which you should somehow allow for; this is different from , which uses type erasure to store custom deleters without making them part of the type
p6360
as(dp6361
g28
V596781
p6362
stp6363
a((dp6364
g2
(lp6365
VThe scope is not restricted to a file, but to a translation unit
p6366
aVSince you include  into , this is all one TU -- you might as well have pasted the content of  into the source file
p6367
as(dp6368
g28
V596781
p6369
stp6370
a((dp6371
g2
(lp6372
VHow about a conditional:
p6373
aVThis would have to be extended to encompass all desired types, in order; at the final stage you could use  rather than  to have an instantiation error right there if the value is too large
p6374
as(dp6375
g28
V596781
p6376
stp6377
a((dp6378
g2
(lp6379
VI'm not sure that what you're doing is at all a good design, but to answer your question about placement-new: You provide the constructor arguments just like in any other  expression:
p6380
aVConstruct new string:
p6381
aVCopy-construct:
p6382
aVAssign:
p6383
as(dp6384
g28
V596781
p6385
stp6386
a((dp6387
g2
(lp6388
VLike this
p6389
aVHere  can be  or
p6390
aVFor  you can modify the characters, for  you cannot
p6391
aVNote that assigning a string literal to a  is deprecated
p6392
as(dp6393
g28
V596781
p6394
stp6395
a((dp6396
g2
(lp6397
VYou can only have expressions* as the operands of the ternary conditional, not statements
p6398
aVThe usual way to say this is:
p6399
aVor even better,
p6400
aVor even better,
p6401
aV*) Since you tagged this as both C and C++, know that there is a subtle difference between the admissible expressions in the two languages
p6402
as(dp6403
g28
V596781
p6404
stp6405
a((dp6406
g2
(lp6407
VWell, when you try to get , you have to instantiate , but you cannot instantiate the template on an incomplete type because it contains a member object  which mustn't be incomplete -- the compiler doesn't know that you only want to get at the member typedef of
p6408
aVIn , you only use  as a return type, which is allowed to be incomplete -- we don't need to instantiate  in order to allow it as a return type
p6409
aVBut to access the member (typedef) we do need to instantiate
p6410
aVFurhtermore,  is fine because  is a complete type
p6411
aVThe solution is simple, just resolve the typedef by hand and make the return type of  into
p6412
as(dp6413
g28
V596781
p6414
stp6415
a((dp6416
g2
(lp6417
VAt some point the cryptographic primitives in your code will need to access and use the actual value of the key
p6418
aVThere's simply no way around that
p6419
aVIn a simple analogy, you cannot compute  if you don't know
p6420
aVThe big question concerning secure software design thus boils down to how long sensitive information will persist in an unprotected state
p6421
aVAny sort of password caching is your enemy here, but even if neither the password nor the decrypted key are explicitly cached, they're still in memory at some point
p6422
aVFreezing a computer with liquid nitrogen can keep the memory content intact for a considerable amount of time, and forcing a swap-to-disk is another problem
p6423
aVGood cryptographic programs should take care to overwrite the memory content as promptly as feasible and minimize the amount of time that sensitive information is retained in readable form
p6424
aVThis requires careful analysis of which information is critical (e
p6425
ag99
aVthe user's password input), and platform-specific knowledge of memory management (e
p6426
ag99
aVcan you request non-pageable memory
p6427
aVIt all depends on your threat model - which sort of attack do you need to protect against
p6428
aVIf a rootkit monitors all your memory, you might be in trouble, though that rootkit would probably just read the user's password entry from the keyboard anyway
p6429
aVThis is a complicated issue, and there's extensive research into secure hardware design
p6430
aVIn general, the more access an attacker has to your machine, the more likely it is that she'll be able to read sensitive data
p6431
aVGood design can only strive to minimize the surface of attack
p6432
as(dp6433
g28
V596781
p6434
stp6435
a((dp6436
g2
(lp6437
VWithout going for virtual inheritance, you can massage the type a bit to convince the compiler to pick the correct base class:
p6438
as(dp6439
g28
V596781
p6440
stp6441
a((dp6442
g2
(lp6443
VAdd an assignment operator:
p6444
aVDepending on what you want to return you could also define it like this:
p6445
aVOr even, in C++0x:
p6446
aVThe former lets you write:
p6447
aVThe latter lets you write:
p6448
aVTake your pick
p6449
as(dp6450
g28
V596781
p6451
stp6452
a((dp6453
g2
(lp6454
VOn Linux (Posix
p6455
aVyou have a symbolic link  which links to the full path of the executable
p6456
aVOn Windows, use
p6457
aVNever rely on , which is not guaranteed to be anything useful
p6458
aVNote that paths and file systems are not part of the language and thus necessarily a platform-dependent feature
p6459
as(dp6460
g28
V596781
p6461
stp6462
a((dp6463
g2
(lp6464
VI can't really see through your question or your code, but in general, the containers in the standard C++ library offer you a loose guarantee that concurrent access at different elements is thread-safe
p6465
aVBe sure to understand the implications and limitations of that, though: If you have a random-access container, or iterators to elements, and you only use those to read or change an element value, then as long as you're doing that at different elements, the result should be well-defined
p6466
aVWhat isn't OK is changing the container itself, so any erase or insert operations have to be serialized (e
p6467
ag99
aVby locking access to the entire container), and be sure to understand your container's iterator and reference invalidation rules when you do that
p6468
aVFor individual containers you might be able to say a bit more - for example, insert/erase in a tree-based container, and insert/erase in the middle of a random-access container almost certainly requires a global lock
p6469
aVIn a vector/deque you'll need to reacquire iterators
p6470
aVIn a list, you might get away with performing insertions concurrently at distinct locations
p6471
aVAny global operations like  and  need to be serialized as well
p6472
as(dp6473
g28
V596781
p6474
stp6475
a((dp6476
g2
(lp6477
VA combination of  and  should do the trick
p6478
aVDon't forget to send appropriate headers first
p6479
aVAlternatively
p6480
as(dp6481
g28
V596781
p6482
stp6483
a((dp6484
g2
(lp6485
VThe compiler will not define an implicit default constructor (not just "declare", the definition is the key here) for the derived class if there is no default constructor for the base class
p6486
aV(Any constructor that can be called with no arguments is a default constructor, no matter the actual signature, as long as default arguments are provided
p6487
aVSo we can summarize the requirements for any class to have a well-formed implicitly defined constructor:
p6488
aVNo const members
p6489
aVNo reference members
p6490
aVAll base classes must have accessible default constructors
p6491
aVAll non-static members must have accessible default constructors
p6492
as(dp6493
g28
V596781
p6494
stp6495
a((dp6496
g2
(lp6497
VOverriding functions in derived classes are implicitly declared "virtual" if the corresponding function in the base class is virtual
p6498
aVJust make sure you got the exact same signature, or you might inadvertently hide the original function and declare a new one
p6499
aVIn C++0x, feel free to make liberal use of the  specifier
p6500
aVYour two "Why
p6501
aVquestions are because of slicing; you're making new, copy-sliced objects of type
p6502
aVNote that in  the cast is the same as saying
p6503
as(dp6504
g28
V596781
p6505
stp6506
a((dp6507
g2
(lp6508
VThe  environment usually does a good job at that:
p6509
aVThe environment also prevents special treatment of any TeX commands
p6510
as(dp6511
g28
V596781
p6512
stp6513
a((dp6514
g2
(lp6515
VAfter a little discussion, and in full agreement that this may be entirely useless, and with the warning that older compilers may get this wrong, I would nevertheless like to paste a little trait class I rigged up which I believe will give you  only when a class has a move constructor:
p6516
aVUsage:
p6517
aVNote that the compiler-trait  isn't actually shipped with GCC 4
p6518
ag263
aV1 and has to be provided separately, see my complete code
p6519
as(dp6520
g28
V596781
p6521
stp6522
a((dp6523
g2
(lp6524
VA portable C++ solution would be to use  to measure time
p6525
aVThis is available in C++11 in the header , but may well be available to older compilers in TR1 in  or boost
p6526
aVchrono
p6527
aVThe steady clock always advances at a rate "as uniform as possible", which is an important consideration on a multi-tasking multi-threaded platform
p6528
aVThe steady clock is also independent of any sort of "wall clock", like the system clock (which may be arbitrarily manipulated at any time)
p6529
aV(Note: if  isn't in your implementation, look for
p6530
aVThe  types are a bit fiddly to use, so here is a sample piece of code that returns a steady timestamp (or rather, a timestamp from whichever clock you like, e
p6531
ag99
aVthe ):
p6532
aVUsage:
p6533
as(dp6534
g28
V596781
p6535
stp6536
a((dp6537
g2
(lp6538
VHow did you know that  existed in the first place
p6539
aVBecause you've read the friendly manual, the language standard, a good book, or an online reference
p6540
aVThe same applies to everything: Your documentation or reference will tell you the namespace in which you find your types
p6541
aVGenerally, everything that's part of the C++ standard library is in the  namespace, but some things may well be in a namespace nested within
p6542
aVNotable examples of nested namespaces are  and
p6543
aVBut you will be told the correct namespaces if you read a good reference
p6544
aVThanks to @Potatoswatter: Other constructions that use the same scope resolution syntax are static constants of classes
p6545
aVFor example, the class  contains a static member type  with static constant values ,  and ; those can be accessed via  etc
p6546
aVOr, since the type  inherits from , via  etc
p6547
aVIn many ways, a class with only static members is just a glorified namespace, and in the early days of C++ people often used nested classes to "simulate" nested namespaces, which weren't available at the time
p6548
aVThe scope resolution syntax is the same
p6549
as(dp6550
g28
V596781
p6551
stp6552
a((dp6553
g2
(lp6554
VIf you only ever serve one single website in your client's life, then yes, because you only have one HTTP request instead of two
p6555
aVIf you are going to serve multiple sites which all link to the same javascript source file, then you're duplicating all this redundant data and not giving the client a chance to cache the file
p6556
as(dp6557
g28
V596781
p6558
stp6559
a((dp6560
g2
(lp6561
VTemplate parameter deduction from arguments only works for functions, never for classes
p6562
aVUntil you know the type of the class, i
p6563
ag598
aVall its template parameters, you don't even know which member functions the class has
p6564
aVSo, you always have to say the template parameters if you want to construct an object directly:
p6565
aVHere's a little thought experiment to expand on the above
p6566
aVSuppose we have
p6567
aVand we are calling , where  is some type
p6568
aVYou think, well, I declared  like this:
p6569
aVso it should be obvious that  is the same type as the type of
p6570
aVBut now imagine I have a specialization:
p6571
aVThe class  doesn't even have a function , so the expression  doesn't even get to the stage where I could look up the argument
p6572
aVThe usual way around this is to make a free helper function that constructs your object:
p6573
aVSince this is a function template, its parameters can be deduced:
p6574
as(dp6575
g28
V596781
p6576
stp6577
a((dp6578
g2
(lp6579
VTypically the arguments just go on the call stack, so in a single threaded application, your main limitation is the size of the stack
p6580
aVOn Posix, you can use  to discover that size, or the Bash built-in
p6581
aVA more interesting question might be how much memory  has for the resulting string, and whether or not it has to perform allocations
p6582
as(dp6583
g28
V596781
p6584
stp6585
a((dp6586
g2
(lp6587
VThink of templates as code generation akin to copy/paste where you replace  by a concrete type
p6588
aV"Instantiation" is the process of copy-pasting the code into your program
p6589
aVImplicit instantiation happens whenever you use the template
p6590
aVFor function templates, the concrete type is deduced from the function arguments and the template is instantiated for that type
p6591
aVSo, your code effectively becomes:
p6592
aVExplicit instantiation, on the other hand, just explicitly forces the compiler to generate code
p6593
aVFor example, if we add the explicit instantiation
p6594
aVto your code, the compiler would generate the corresponding code,
p6595
aVThis would happen no matter whether or not you actually use that code
p6596
aVIf you don't know about classes yet, then you're missing 92% of the fun, because class template instantiation is far more subtle
p6597
aVOnly member functions that are actually used are implicitly instantiated, while an explicit instantiation creates code for all class members
p6598
aVAlso, class member functions aren't checked for correctness to some degree until they actually get instantiated, so you can write templates that don't actually make sense for all possible types
p6599
as(dp6600
g28
V596781
p6601
stp6602
a((dp6603
g2
(lp6604
VHard to tell your compilation error without code, but if you have a header that declares a static global, then you just create that global variable independently and separately in each translation unit that includes the header
p6605
aVExample:
p6606
aVheader
p6607
aVh:
p6608
aVfile1
p6609
aVcpp:
p6610
aVfile2
p6611
aVcpp:
p6612
aVThe two files both have access to a global variable called , but each file has its own separate copy, private to its translation unit, which is not visible outside
p6613
aVFor a practical example, I think  is declared as a static global, so everyone who uses  gets their own copy
p6614
as(dp6615
g28
V596781
p6616
stp6617
a((dp6618
g2
(lp6619
VNo
p6620
aVThere is no placement-delete expression
p6621
aVTypical scenario:
p6622
aVNote that the placement-new operator does have a corresponding delete operator which is mandated to be precisely , a no-op; this is what gets called if the constructor of  throws an exception
p6623
as(dp6624
g28
V596781
p6625
stp6626
a((dp6627
g2
(lp6628
VThere are three nearly identical, high-quality "standard" random number generation libraries that you should try to find in descending order:
p6629
aVC++11's
p6630
aVThe TR1's
p6631
aVBoost's
p6632
aVThey're all conceptually identical and even practically near-identical, apart from the namespace (,  and , respectively)
p6633
aVEach library defines a set of engines, such as
p6634
aVPick one (for each thread) and seed it
p6635
aVOnce you have an engine, you can use a wide variety of distributions to generate numbers, using your engine
p6636
aVFrequently used distributions are uniform integers in a range [a, b], uniform floats in the range [0,1), and several well-known probability distributions like the normal distribution
p6637
as(dp6638
g28
V596781
p6639
stp6640
a((dp6641
g2
(lp6642
VDon't use naked C arrays
p6643
aVThis is C++, we can do a lot better:
p6644
aVYou can also put the array into your matrix structure:
p6645
aVYou should be able to just assign variables of type  to each other directly
p6646
as(dp6647
g28
V596781
p6648
stp6649
a((dp6650
g2
(lp6651
VI think you're worrying about unrelated things
p6652
aVThe new handler is a detail that specifies how  operates in the event that it cannot find enough memory to allocate
p6653
aVA smart pointer is a library-provided container class
p6654
aVMost C++ standard library containers need to allocate memory, which they do in a modular fashion by means of an allocator class
p6655
aVThe default allocator may (and usually does) use  to obtain memory, but the process of memory allocation and object construction is decoupled, and there's nothing in any library class that needs to know any details of how the  operator works, and vice versa
p6656
aVSo whatever you do to your  operator (e
p6657
ag99
aVby installing handlers) will transparently work for standard library constructions, and there is nothing either side has to know about the other
p6658
as(dp6659
g28
V596781
p6660
stp6661
a((dp6662
g2
(lp6663
VThe backtick operator replaces the escaped backslash by a backslash
p6664
aVYou need to escape twice:
p6665
aVYou may also escape the first backslash if you like
p6666
as(dp6667
g28
V596781
p6668
stp6669
a((dp6670
g2
(lp6671
VIn C++03, 15
p6672
ag5593
aV6:
p6673
aVAn exception-specification can include the same type more than once [
p6674
aVeven though doing so is redundant
p6675
aVThe standard always speaks of the set of types in an exception specification, surely that's deliberate
p6676
aVI would be negligent to omit pointing out Herb Sutter's article, which is best summarized as,
p6677
aV# Don't use exception specifications
p6678
as(dp6679
g28
V596781
p6680
stp6681
a((dp6682
g2
(lp6683
VYou're never using the result of the database query
p6684
aVIn particular, the line
p6685
aVis not getting the value from the database, but rather from the HTTP POST parameters
p6686
aVYou have to use  or something like that at some point:
p6687
aV(This is just conceptually
p6688
aVYou should do the check for the number of results first and make sure that there is a result
p6689
as(dp6690
g28
V596781
p6691
stp6692
a((dp6693
g2
(lp6694
VOne very striking reason for why we need function pointers is that they allow us to call a function that the author of the calling code (that's us) does not know
p6695
aVA call-back is a classic example; the author of  doesn't know or care about how you compare elements, she just writes the generic algorithm, and it's up to you to provide the comparison function
p6696
aVBut for another important, widely used scenario, think about dynamic loading of libraries - by this I mean loading at run time
p6697
aVWhen you write your program, you have no idea which functions exist in some run-time loaded library
p6698
aVYou might read a text string from the user input and then open a user-specified library and execute a user-specified function
p6699
aVThe only way you could refer to such function is via a pointer
p6700
aVHere's a simple example; I hope it convinces you that you could not do away with the pointers
p6701
as(dp6702
g28
V596781
p6703
stp6704
a((dp6705
g2
(lp6706
VThis isn't quite as much an answer as an attempt to reconstruct what you're doing
p6707
aVI'm making a simple circular buffer initialized from a string, and I traverse regex matches through that buffer and print the matched ranges
p6708
aVAll seems to work fine
p6709
aVI would not recommend storing the ranges themselves in a circular buffer; or at the very least the ranges should be stored in pairs
p6710
aVHere's my test code:
p6711
aV(This uses the pretty printer to print the raw circular buffer; you can remove the line marked
p6712
aVUpdate: Here's a possible way to store the matches:
p6713
as(dp6714
g28
V596781
p6715
stp6716
a((dp6717
g2
(lp6718
VString literals are possibly located in a read-only area of memory; it is not allowed to assign a pointer to one to a pointer to non-const char, and thus your manipulations of  cause undefined behaviour
p6719
aVYou either say
p6720
aVand don't modify the string, or you create an automatic array of chars that you can modify:
p6721
aVThe latter is what you need in your case
p6722
aVAlso, as a point of style, writing  in one line is possibly misleading; it is equivalent to, and should always be replaced by,
p6723
as(dp6724
g28
V596781
p6725
stp6726
a((dp6727
g2
(lp6728
VYou can simply not define the base case:
p6729
as(dp6730
g28
V596781
p6731
stp6732
a((dp6733
g2
(lp6734
VLet's leave out CUDA for now
p6735
aVLet's just make a function that writes data to a user-provided array
p6736
aVThe user passes the array via a pointer:
p6737
aVNow, what you're doing with the local variable doesn't make sense, because you want to use the address of a local variable, which becomes invalid after you leave the function scope
p6738
aVThe next best thing you could do is , or some equivalent C++ algorithm:
p6739
aVOK, now on to calling that function: We first must provide the target memory, and then pass a pointer:
p6740
aV(In C++ you would probably have uses  and  instead, but by using C  the connection to CUDA hopefully becomes clear
p6741
aVWhen you're moving  to the CUDA device, you have to give it a device pointer rather than a host pointer, so you have to set that one up first and afterwards copy the results back out, but that's about the only change
p6742
as(dp6743
g28
V596781
p6744
stp6745
a((dp6746
g2
(lp6747
VPractically, on Windows, this is probably going to work, since  and  have the same size
p6748
aVIn general though this is undefined behaviour, and there's no reason why pointers of different types should be of the same size -- the only pointer that's guaranteed to fit any other pointer is
p6749
as(dp6750
g28
V596781
p6751
stp6752
a((dp6753
g2
(lp6754
VIf I understand correctly, you just want to make a new tuple whose contents are the results of a function applied to the contents of an old tuple
p6755
aVLike so:
p6756
aVIs this right
p6757
aVTo answer that, I am stealing @Luc Danton's excellent tuple indexer
p6758
aVAt the very heart, this construction allows us to write:
p6759
aVHere's how it works: First, the  helper:
p6760
aVNow for the application: We just make a simple, fixed function  that doubles its input
p6761
aVLet's apply that to a tuple
p6762
aVHere's a hardwired function, but you can easily template that on :
p6763
aVFinally, the test case:
p6764
aVAll credits for this should go to Luc, who came up with the self-indexing tuple indexer
p6765
as(dp6766
g28
V596781
p6767
stp6768
a((dp6769
g2
(lp6770
VYou could just repeatedly call  to find occurrences of your boundary string and split along the results
p6771
aVAfter you found a result, advance the pointer by the length of the substring and search again
p6772
as(dp6773
g28
V596781
p6774
stp6775
a((dp6776
g2
(lp6777
VYou could use :
p6778
as(dp6779
g28
V596781
p6780
stp6781
a((dp6782
g2
(lp6783
VOK, let's find out
p6784
aVThis is GCC 4
p6785
ag263
aV1 on x86 with , and  is of type :
p6786
ag77
ag77
aVHere  is the variable , and  designates the jump destination of the conditional
p6787
aVUpdate: As @yi_H suggests, now let's compare  and , where  is some function
p6788
aVWe have:
p6789
as(dp6790
g28
V596781
p6791
stp6792
a((dp6793
g2
(lp6794
VYou cannot implement  like that; it really has to go in the namespace:
p6795
aVThe  directive is only for lookup, not for definitions - imagine what  would do to all your function definitions otherwise
p6796
as(dp6797
g28
V596781
p6798
stp6799
a((dp6800
g2
(lp6801
VYou make it stop by not writing an arcane Frankenstein language mix of C and C++, but instead using real C++ string types:
p6802
aVNote that  is almost guaranteed not to be what you think
p6803
aVWhat you want is something like  or , but that only works for single digits
p6804
aVProbably much simpler to just stream into an integer, which performs an actual text-to-integer conversion:
p6805
as(dp6806
g28
V596781
p6807
stp6808
a((dp6809
g2
(lp6810
VYour code causes undefined behaviour, because your  does not point to an object, so you may not use the accessor operator  on it
p6811
aVAn object only commences its life after its constructor has completed
p6812
aVSince you don't call any constructor, you do not have an object
p6813
aV(If your struct were a POD, i
p6814
ag598
aVjust consisting of primitive types and PODs, then this would be OK, because PODs have trivial constructors, which do nothing
p6815
aVThe concrete problem you're facing is that the string and vector members of your struct didn't get to call their constructors, so those members don't exists, and hence the entire object doesn't
p6816
aVIf you want to decouple memory management from object construction, you can use placement syntax:
p6817
aV(You have to destroy those objects manually,  etc
p6818
aV, when you're done with them
p6819
as(dp6820
g28
V596781
p6821
stp6822
a((dp6823
g2
(lp6824
V is just a pointer to a , but it has no initalized, sensible value
p6825
aVis equivalent to , but you cannot dereference a garbage value -- you first have to make  points somewhere useful, e
p6826
ag99
aVby allocating memory for it
p6827
aVIf you want to store some s with automatic storage, then declare an array of char pointers instead:
p6828
as(dp6829
g28
V596781
p6830
stp6831
a((dp6832
g2
(lp6833
VThis answer is probably wrong; see Tomalak's answer and the comments
p6834
aVI'll leave it for historic reasons, but you're probably OK calling member functions during the constructor
p6835
aVMost definitely not
p6836
aVIf you have any , say , then you may only invoke member functions via  if  points to an object
p6837
aVBut an object only begins its life when its constructor has finished
p6838
aVSo while you're in the middle of the constructor,  does not point to an object
p6839
aVTherefore, you can most certainly not invoke any member functions like the assignment operator on this not-yet object
p6840
aV[Curiosum: It is legit to say  in certain situations, you just have to make sure that the destructor does not refer to  in any way
p6841
aVIt is also OK to pass  to some other place during the constructor, as long as it is not dereferenced, much like you can pass any garbage pointer around as long as you don't use it
p6842
as(dp6843
g28
V596781
p6844
stp6845
a((dp6846
g2
(lp6847
VVery straightforward:
p6848
aV(Put  before the  first for a dry run
p6849
as(dp6850
g28
V596781
p6851
stp6852
a((dp6853
g2
(lp6854
VWhy both work: If you call , the first one matches , the second one matches
p6855
aV: that just says that you're not modifying any members, but since your structs are empty, this makes no difference
p6856
aVSome algorithms may take their functors as const and hence allow only access to constant member functions (but not in )
p6857
aVIn any event, your member function might as well be static, since the there's no state
p6858
aVinlining is just a compiler hint; chances are that construction would be inlined no matter what
p6859
aVMember definitions inside class definitions are implicitly inline anyway
p6860
as(dp6861
g28
V596781
p6862
stp6863
a((dp6864
g2
(lp6865
VIn your initialization expression ,  is a pointer
p6866
aVYou can only initialize it to another pointer
p6867
aVPerhaps you mean to initialize it to a pointer to a new node constructed on those arguments
p6868
aVThis could be done like this: (updated after your edit)
p6869
aVHowever, this is very dangerous (think about an exception in the allocation), and you should probably avoid using raw pointers in your class design and instead use smart managing pointers
p6870
aVSimilarly, the initializer  does the wrong thing, you might want:
p6871
aV(Also note that you should initialize members in their order of declaration
p6872
aVUpdate: I changed the first constructor call following your edit, but as @Luc says, your constructors take non-const arguments but  only provides a const reference, so you still need to fix that
p6873
as(dp6874
g28
V596781
p6875
stp6876
a((dp6877
g2
(lp6878
VThere's a difference between a constant variable and a compile-time constant
p6879
aVCompare:
p6880
aVThis variable  is constant with the function scope, but its value is unknown at compile time
p6881
aVOn the other hand, the following two are compile-time constants:
p6882
aVBoth  and  are known at compile time
p6883
aVOnly compile-time constants can be used as array sizes or template parameters
p6884
aV(Templates are essentially code generation machines, so the code has to be generated before the final program can be compiled
p6885
aVNote that in C++98/03,  is not actually formally recognized as a compile-time constant
p6886
aVC++11 fixes this by allowing  to be declared , meaning it's allowed to compute compile-time constant expressions (if all its arguments are themselves constant)
p6887
as(dp6888
g28
V596781
p6889
stp6890
a((dp6891
g2
(lp6892
VHere's my code using DEFLATE compression in the boost
p6893
aViostreams library; I'm sure you can hook in the corresponding BZip2 compressor instead:
p6894
aVThe bzip2 compressor is called
p6895
aVIf you want a byte buffer rather than a file, use a string stream:
p6896
aVThanks to @ildjarn, here's how to make a stringstream from an existing memory buffer:
p6897
as(dp6898
g28
V596781
p6899
stp6900
a((dp6901
g2
(lp6902
VUse  indexing: , , etc
p6903
aVIf the  is , you can omit it:
p6904
as(dp6905
g28
V596781
p6906
stp6907
a((dp6908
g2
(lp6909
VYou shouldn't use built-in types for serialization; instead, when you need to know the exact size of a type, you need fixed-width types:
p6910
aVSimilarly for 32-bit values, use  there
p6911
aVMake sure your source buffer uses unsigned chars
p6912
as(dp6913
g28
V596781
p6914
stp6915
a((dp6916
g2
(lp6917
VBest not to use raw C arrays at all
p6918
aVHere's a version, using modern C++:
p6919
as(dp6920
g28
V596781
p6921
stp6922
a((dp6923
g2
(lp6924
VHere's a basic enumeration of running processes in Windows:
p6925
aVYou can use the final name look-up with  to make a decision
p6926
aVHere's the code for :
p6927
as(dp6928
g28
V596781
p6929
stp6930
a((dp6931
g2
(lp6932
VKeep doing modulo-10 and divide-by-10:
p6933
aVThis spits out the digits from least-significant to most-significant
p6934
aVYou can clearly generalise this to any number base
p6935
as(dp6936
g28
V596781
p6937
stp6938
a((dp6939
g2
(lp6940
VThe lambda can "capture" variables from the ambient scope:
p6941
aVYou can capture by value or by reference, and you can use the special syntax  and  to capture anything from the ambient scope, i
p6942
ag598
aVanything you actually end up using
p6943
as(dp6944
g28
V596781
p6945
stp6946
a((dp6947
g2
(lp6948
VWhy would you expect it to be sorted by
p6949
aVAny  is sorted by , and sorting requires that there be a less-than comparison for
p6950
aVNow for , there is an , defined as lexicographic ordering, but this requires comparability of both  and :
p6951
aVMoving down recursively, you need  to be less-than comparable
p6952
aVDo check, any bet that you didn't implement a comparison operator for that type
p6953
aVEdit: According to your update that is precisely your problem
p6954
aVRemark: You might wonder why lexicographic compare is the default: It's the only sensible comparison for which  is identical to , provided the same holds for both sub-types individually
p6955
aVUpdate: If you only want ordering by the first member, you should write a custom comparator predicate, or use a multi-map instead
p6956
aVCustom comparator:
p6957
aVNote that  may rearrange elements with the same key
p6958
aVIf you want those to maintain their relative ordering, use  instead
p6959
aVMultimap:
p6960
aVThe multimap is a more complicated structure than the vector, and its elements are always kept in sorted order by key value, i
p6961
ag598
aVyour
p6962
aVWhich one is preferable depends on what you're doing
p6963
as(dp6964
g28
V596781
p6965
stp6966
a((dp6967
g2
(lp6968
VIn C++, this sounds like the perfect fit for  (that's  or  to you if you have an older compiler)
p6969
aVIt's implemented as a hash set, which has the characteristics you describe
p6970
aVHere's the interface documentation
p6971
aVNote that the hash containers actually offer two sets of iterators, the usual ones and local ones which only go through one bucket
p6972
aVMany other languages have "hash sets" as well, certainly Java and C#
p6973
as(dp6974
g28
V596781
p6975
stp6976
a((dp6977
g2
(lp6978
VA bit roundabout: If you only use this to check for array members, you could pass the key separately:
p6979
aVIf the variable could be set but null (Edit: which it cannot, thanks @deceze), add another check:
p6980
aVAs pointed out,  only succeeds on non-null values, so the above doesn't add anything
p6981
aVWe can write a non-trivial check with , though:
p6982
as(dp6983
g28
V596781
p6984
stp6985
a((dp6986
g2
(lp6987
VI think you're describing exactly the situation in this example:
p6988
as(dp6989
g28
V596781
p6990
stp6991
a((dp6992
g2
(lp6993
VYou can join a table multiple times:
p6994
as(dp6995
g28
V596781
p6996
stp6997
a((dp6998
g2
(lp6999
VI'm assuming that you want the function to allocate memory for an array and passing the result via a pointer parameter
p7000
aVSo, you want to write , and assign the result to a pointer argument, :
p7001
aVSo the correct invocation should be, all rolled into one line,
p7002
as(dp7003
g28
V596781
p7004
stp7005
a((dp7006
g2
(lp7007
VYou can explicitly construct a  object so the first overload will be preferred:
p7008
aVRegarding your question title, are you wondering how overload resolution works
p7009
aVWhen the overload is being chosen, an untemplated type is a better match than a templated one, but a templated type that matches directly () is a better match than an an implictit conversion (), so the second overload matches better in your original case
p7010
aV(Thanks to @David for pointing out a glaring error in my original formulation
p7011
as(dp7012
g28
V596781
p7013
stp7014
a((dp7015
g2
(lp7016
VSuppose your algorithm actually executes  computations when run on  elements
p7017
aVNow for  you need 1001 computations, and for  you need 2004
p7018
aVThe difference from linear growth is tiny, and you can hardly spot the quadratic contribution
p7019
aVAsymptotically, however, your algorithm takes O(n^2) steps, so asymptotically (as n gets large) doubling the input size quadruples your runtime
p7020
aVBut for our small value, doubling from 1 to 2 did not quadruple the runtime
p7021
aVThe lower-order term is , and its coefficient (1000) is large compared to the coefficient of the leading-order term (which is 1)
p7022
aVThis shows how the asymptotic complexity does not say anything about particular, especially small values
p7023
aVIt's merely a limiting statement about the behaviour as  gets large
p7024
as(dp7025
g28
V596781
p7026
stp7027
a((dp7028
g2
(lp7029
VYou have to release resources in reverse order of their acquisition:
p7030
aVThe deeper nested constructions depend on the outer ones and may lock up resources, so you can only release the prerequisite resources after you've released the dependent ones
p7031
aVSince you tagged this C++, I would be remiss to mention that those sort of things should be handled with RIAA, and you should make a class that takes responsibility for the resource
p7032
aVAs you can see even in this simple example, writing the correct error checking paths very quickly become onerous, so it'd be much better and more modular to have a class that cleans up after itself, which automatically happens in the correct order
p7033
as(dp7034
g28
V596781
p7035
stp7036
a((dp7037
g2
(lp7038
VKonrad's answer should get you going, but I think the more idiomatic way such things are usually expressed is with static member constants, so I just wanted to present that solution:
p7039
aVThen you get your argument pack size via
p7040
as(dp7041
g28
V596781
p7042
stp7043
a((dp7044
g2
(lp7045
VFrom N3290, 14
p7046
aV6:
p7047
aVA [
p7048
aVstatic data member of a class template shall be defined in
p7049
aVevery translation unit in which it is implicitly instantiated [
p7050
aV, unless the corresponding specialization is explicitly instantiated [
p7051
aVTypically, you put the static member definition in the header file, along with the template class definition:
p7052
aVTo expand on the concession: If you plan on using explicit instantiations in your code, like:
p7053
aVthen you must not put the templated definition in the header if  is also used in other TUs other than the one containing the explicit instantiation, since you'd then get multiple definitions
p7054
aVHowever, if you do need to set an initial value for all possible parameters without using explicit instantiation, you have to put that in the header, e
p7055
ag99
aVwith TMP:
p7056
as(dp7057
g28
V596781
p7058
stp7059
a((dp7060
g2
(lp7061
VLook up how  works - you have to pass it the original pointer:
p7062
as(dp7063
g28
V596781
p7064
stp7065
a((dp7066
g2
(lp7067
VThe question is way too broad for a complete answer, but let me cherry-pick a couple of interesting points:
p7068
aVWhy "equally likely"
p7069
aVSuppose you have a simple random number generator that generate the numbers 0, 1,
p7070
aV, 10 each with equal probability (think of this as the classic )
p7071
aVNow you want a random number in the range 0, 1, 2, each with equal probability
p7072
aVYour knee-jerk reaction would be to take
p7073
aVBut wait, the remainers 0 and 1 occur more often than the remainder 2, so this isn't correct
p7074
aVThis is why we need proper distributions, which take a source of uniform random integers and turn them into our desired distribution, like  in the example
p7075
aVBest to leave this to a good library
p7076
aVEngines
p7077
aVThus at the heart of all randomness is a good pseudo-random number generator that generates a sequence of numbers that uniformly distributed over a certain interval, and which ideally have a very long period
p7078
aVThe standard implementation of  isn't often the best, and thus it's good to have a choice
p7079
aVLinear-congruential and the Mersenne twister are two good choices (LG is actually often used by , too); again, it's good to let the library handle that
p7080
aVHow it works
p7081
aVEasy: first, set up an engine and seed it
p7082
aVThe seed fully determines the entire sequence of "random" numbers, so a) use a different one (e
p7083
ag99
aVtaken from ) each time, and b) store the seed if you wish to recreate a sequence of random choices
p7084
aVNow we can create distributions:
p7085
aVAnd use the engine to create random numbers
p7086
aVConcurrency
p7087
aVOne more important reason to prefer  over the traditional  is that it is now very clear and obvious how to make random number generation threadsafe: Either provide each thread with its own, thread-local engine, seeded on a thread-local seed, or synchronize access to the engine object
p7088
aVMisc
p7089
aVAn interesting article on TR1 random on codeguru
p7090
aVWikipedia has a good summary (thanks, @Justin)
p7091
aVIn principle, each engine should typedef a , which is the correct integral type to use for the seed
p7092
aVI think I had a buggy implementation once which forced me to force the seed for  to  on x64, eventually this should be fixed and you can say  and thus make the engine very easily replaceable
p7093
as(dp7094
g28
V596781
p7095
stp7096
a((dp7097
g2
(lp7098
VI dispute that "it's not possible" to do the correct thing:
p7099
aVNow you can say,  etc
p7100
as(dp7101
g28
V596781
p7102
stp7103
a((dp7104
g2
(lp7105
VAs an alternative to non-existing partial specialization for functions, you can use overloading on a typifier class:
p7106
as(dp7107
g28
V596781
p7108
stp7109
a((dp7110
g2
(lp7111
VI like @inflagranti's idea - so, without claim to utility, here's a for-each template that iterates over everything
p7112
aVIt uses the  trait from the pretty printer, which I don't replicate here
p7113
aVUpdate: Now fully worked out to deal with both with naked value types and with pair value types
p7114
aVUpdate 2: Simplified the implementation class, thanks to @Luc Danton
p7115
aVUsage:
p7116
as(dp7117
g28
V596781
p7118
stp7119
a((dp7120
g2
(lp7121
VIn a nutshell, you need to have the entire body (the definition) of a template function visible to the translation unit that instantiates the template
p7122
aVSo when you say , that translation unit should have access to the definition of
p7123
aVUsually you achieve this by including the definitions of function templates in the header file itself
p7124
aVThe reason for this is that templates aren't ordinary code that gets compiled and can later be linked at will
p7125
aVRather, templates are a code generation tool that generates the necessary code on demand - an automatic version of copy/paste followed by search-and-replace, if you will
p7126
aVTherefore, the actual compilable code for your function  doesn't come into existence until you write that line
p7127
aVIf only the declaration of the function template is visible, then the template only produces the declaration of the concrete function, but not its body, and so at link time you notice that the function is missing
p7128
aVTo recap, templates themselves cannot be compiled, it is only their concrete instances that can, and you have to pay attention to ensure that the concrete instances are always available when you instantiate them
p7129
aVExplicit instantiation as you have it works and allows you to package a few specific instances into a separate TU, but generally that's hard to maintain and not scalable, and there are other drawbacks to explicit instantiation that you avoid when you let the compiler instantiate implicitly
p7130
aVSo usually it's best to package your entire definitions into the header file
p7131
as(dp7132
g28
V596781
p7133
stp7134
a((dp7135
g2
(lp7136
VMost platforms, including yours, can only represent those floating point numbers exactly which have a short, finite binary expansion, i
p7137
ag598
aVwhich are finite sums of powers of two
p7138
ag5593
aV7 is not such a number, so it cannot be represented precisely on your platform, and if you demand excessive precision (20 is too much as your mantissa has 64 bits, and log_10(64) is 19
p7139
aV27), then you will inevitably face small errors
p7140
aV(However, as @Henning says, you are already losing precision when assigning from a (non-long) double; you should write your literal constant as a long double:
p7141
aVThen you should only see an error in the 20th digit
p7142
as(dp7143
g28
V596781
p7144
stp7145
a((dp7146
g2
(lp7147
VThe loop  will never execute, and that's what you have when there are no rows
p7148
aVYou have to put the check for  outside the while-loop:
p7149
as(dp7150
g28
V596781
p7151
stp7152
a((dp7153
g2
(lp7154
VSuppose you have , , :
p7155
aVThis creates (upon removal of ) , ,
p7156
as(dp7157
g28
V596781
p7158
stp7159
a((dp7160
g2
(lp7161
VDon't do that
p7162
aVInstead, normalize your data model: Make a new table "Symptoms", constrained with foreign key "Disease", and make one record for each symptom
p7163
aVWhenever you start thinking about putting collections of data into a single field, you're effectively trying to build your own mini database inside the database
p7164
aVThinking that you can outperform and outwit your RDBMS is optimistic at best and most likely leads to unmaintainable code later on
p7165
aVBy the way, does  really have to be looked up in a separate table
p7166
aVFor micro-categories like that you might like to consider some sort of enum type
p7167
as(dp7168
g28
V596781
p7169
stp7170
a((dp7171
g2
(lp7172
VAs it's written, there's no difference since your function  literally does nothing: In two local blocks local variables get declared which immediately go out of scope, and there is no net effect of this function at all
p7173
aVPerhaps you mean to modify some private class member instead
p7174
aVSuggestion: here's an idea on passing the state change through a private member:
p7175
as(dp7176
g28
V596781
p7177
stp7178
a((dp7179
g2
(lp7180
VNothing is being subclassed
p7181
aVI recommend you pick up a good C++ book and read up a bit
p7182
aVA class (or struct) in C++ has access specifiers ,  and , which control the access level to everything following the specifier:
p7183
aVYour class  simply contains a private member  which is initialized to  by the constructor and then printed
p7184
aVThe syntax for inheritance is a colon in the class declaration:
p7185
as(dp7186
g28
V596781
p7187
stp7188
a((dp7189
g2
(lp7190
VDepending on where your string comes from, you may not have any control over what it means, i
p7191
ag598
aVhow it is encoded
p7192
aVTo turn your string into something definite semantics, you may have to perform the following steps:
p7193
aVRead byte string from the environment via  or
p7194
aVThis is a byte string with platform and locale-dependent encoding
p7195
aVTurn the byte string into an internal, fixed width (there are caveats) wide string by means of
p7196
aVYou still don't know the encoding of the result
p7197
aVAll you know is that each wide character is big enough to hold any of the "platform's character values", whatever that means
p7198
aV(In Windows, it means something broken)
p7199
aVObtain a sequence of Unicode code points (i
p7200
ag598
aVdefinitive data that you can manipulate codepoint-wise) by using ICU or  to translate WCHAR into UCS-4/UTF-32
p7201
aVNow you know what you're dealing with
p7202
aVIf you are reading data from a file with a documented encoding, or from the network, you would instead convert from the documented file encoding to UCS-4
p7203
aVOnce you have obtained a sequence of code points, the low-level language support for text processing ends
p7204
aVA sequence of code points is the best you can get at the binary level to represent a text
p7205
aVAny higher-level textual manipulation and processing is complicated and  subtle and depends deeply on a proper definition of "text", so this is best left to a dedicated Unicode library (such as ICU)
p7206
aVAt the programming language level, "characters" are code points, but in any serious application that's probably not what you want and you want to know about graphemes and normalization and a hundred other little things
p7207
as(dp7208
g28
V596781
p7209
stp7210
a((dp7211
g2
(lp7212
VJavaScript strings are encoded with UTF-16, as you can see in the URL-encoded string (0xD182 is a UTF-16 code unit, etc
p7213
aVYou should probably encode the string as an explicit UTF-8 string in your AJAX request
p7214
as(dp7215
g28
V596781
p7216
stp7217
a((dp7218
g2
(lp7219
VWhen in your inner loop  is , you are accessing the object at index , which is out of bounds
p7220
aVMake the loop one shorter, and get rid off the  just after the loop
p7221
aV(You are not moving anything into the final slot
p7222
aVAn alternative implementation of a ring buffer would avoid moving elements around and just keep a pointer to the current end of the buffer, so you would dynamically compute your indexes dynamically (in constant time), rather than move the objects around
p7223
as(dp7224
g28
V596781
p7225
stp7226
a((dp7227
g2
(lp7228
VPassing by value in the copy constructor only helps when the argument is movable, otherwise you could end up with up to two copies (one for the argument passing, one for the member construction)
p7229
aVSo I'd say it's better to write a copy and a move constructor separately
p7230
aVPassing by value makes sense for the assignment operator if you have a properly implemented  function, though:
p7231
aVNow if  is moveable, 's move constructor comes in during argument construction, and if  is merely copyable, then the one necessary copy is made during argument construction, but in both cases you get to use the moving version of , which ought to be cheap
p7232
aVBut this relies on the existence of a move constructor
p7233
aVSo note that out of "construction", "swap" and "assigment" you will have to implement two properly, and only the third can take advantage of the other two
p7234
aVSince  should be no-throw, using the swap trick in the assigment operator is basically the only option
p7235
as(dp7236
g28
V596781
p7237
stp7238
a((dp7239
g2
(lp7240
V is not typesafe
p7241
aVIt prints whatever you ask it to, and  says "signed integer"
p7242
aVIt is your responsibility to provide a varibale of matching type
p7243
aVSince the  is only 8 bits wide, the literal -250 wraps around to +6, which remains +6 when interpreted as a signed integer
p7244
aVNote that  and  (and their signed/unsigned counterparts) all get promoted to -types when passed via variadic arguments
p7245
as(dp7246
g28
V596781
p7247
stp7248
a((dp7249
g2
(lp7250
VYou can join a table multiple times by giving it separate aliases:
p7251
as(dp7252
g28
V596781
p7253
stp7254
a((dp7255
g2
(lp7256
VThe typeid of  is no use, because that's just a template class, and a template class isn't a real type at all, it only becomes one after instantiation
p7257
aVSo what you really want is the type of  for the value type, and the type of  for the type of the instantiated container
p7258
aVEven better, of course, is to take  as the value type
p7259
aVNote that most containers take more than one template parameter, so you'd be better off writing this with variadic templates:
p7260
as(dp7261
g28
V596781
p7262
stp7263
a((dp7264
g2
(lp7265
VHere's an idea
p7266
aVThe crude version involves modifying the library, which may break stuff in the future, but let's begin with that:
p7267
aVWe already have these two functions:
p7268
aVWe also know that  is either  or
p7269
aVSo all we need in order to call the conversion function on  is an overload, which you may add to your headers:
p7270
aVNow you can write this:
p7271
aVThis will work in both compiler settings thanks to the overload, and if  is already , then this will be optimized out entirely (assuming of course that the encoding was already UTF-8, and not any other 8-bit encoding
p7272
aV(You should also provide the overloads that take  and  arguments to support the same magic for
p7273
aVIf you worry about polluting the library, write your own wrapper:
p7274
as(dp7275
g28
V596781
p7276
stp7277
a((dp7278
g2
(lp7279
VSince you asked, here's my standard conversion functions from string to wide string, implemented using C++  and  classes
p7280
aVFirst off, make sure to start your program with :
p7281
aVNow for the functions
p7282
aVFirst off, getting a wide string from a narrow string:
p7283
aVAnd going back, making a narrow string from a wide string
p7284
aVI call the narrow string "locale string", because it is in a platform-dependent encoding depending on the current locale:
p7285
aVSome notes:
p7286
aVIf you don't have , you can say  instead
p7287
aVI've found that the -style conversion functions  and  don't work properly on Windows
p7288
aVThere, you can use the  and  instead: ,
p7289
aVIn response to your question, if you want to compare two strings, you can convert both of them to wide string and then compare those
p7290
aVIf you are reading a file from disk which has a known encoding, you should use  to convert the file from your known encoding to WCHAR and then compare with the wide string
p7291
aVBeware, though, that complex Unicode text may have multiple different representations as code point sequences which you may want to consider equal
p7292
aVIf that is a possibility, you need to use a higher-level Unicode processing library (such as ICU) and normalize your strings to some common, comparable form
p7293
as(dp7294
g28
V596781
p7295
stp7296
a((dp7297
g2
(lp7298
VIf the strings that you want to compare are in a specific, definite encoding already, then don't use  and don't use  literals -- those are not for Unicode, but for implementation-defined, opaque encodings only
p7299
aVIf your strings are in UTF-8, use a string of s
p7300
aVIf you want to convert them to raw Unicode codepoints (UCS-4/UTF-32), or if you already have them in that form, store them in a string of s, or s if you have a modern compiler
p7301
aVIf you have C++11, your literal can be  or
p7302
aVSee this topic for some more on this
p7303
aVIf you want to interact with command line arguments or the environment, use  to convert from WCHAR to UTF-32 or UTF-8
p7304
as(dp7305
g28
V596781
p7306
stp7307
a((dp7308
g2
(lp7309
VIn your loop you have to say  to skip a round, rather than your  which aborts the entire loop
p7310
aVDesign-wise, your algorithm is extremely inefficient, as you can convince yourself by doing a basic complexity analysis
p7311
aVIndexing your data suitably would almost certainly be necessary
p7312
aVThis is exactly what databases are for
p7313
aVI recommend you rig up a small database (e
p7314
ag99
aVMySQL), make two tables and run a JOIN query on the data, which should be a lot more efficient than your manual loop
p7315
aVAlternatively, if you like to give it a try yourself, you could build your own micro-database in C++ with a structure like  and then use  to do targetted matching
p7316
as(dp7317
g28
V596781
p7318
stp7319
a((dp7320
g2
(lp7321
VYou cannot have a single class  with "any" member object, because  has to be a well-defined class, and  is a different type for different types
p7322
aVYou can either make  a template itself:
p7323
aVor you can take a look at , which is type-erasing container for arbitrary types (but making use of it requires a certain amount of extra work)
p7324
aVThe  class only works for value types, though, it's not completely arbitrary
p7325
as(dp7326
g28
V596781
p7327
stp7328
a((dp7329
g2
(lp7330
VYour conception that it "should be 14" is mistaken
p7331
aVStructs are usually padded to the members' alignment
p7332
aVTo achieve efficient packing with correct alignment, you should order the members by size
p7333
aVHere's how your struct probably ends up in memory:
p7334
aVEven if you rearranged this to , you might still end up with 16 rather than 14 since the struct may get padded to a multiple of the largest member's size
p7335
as(dp7336
g28
V596781
p7337
stp7338
a((dp7339
g2
(lp7340
VThe destructor call does just that, it calls the destructor
p7341
aVNothing more and nothing less
p7342
aVAllocation is separate from construction, and deallocation from destruction
p7343
aVThe typical sequence is this:
p7344
aVIn fact, if you run this manually, you will have to call the destructor yourself:
p7345
aVThe automatic way of writing this is of course
p7346
aVThe  expression invokes allocation and construction for you, and the  expression calls the destructor and deallocates the memory
p7347
as(dp7348
g28
V596781
p7349
stp7350
a((dp7351
g2
(lp7352
VHow about
p7353
aVIf everything is just a variable and reading has no side effects, then that should have the same result
p7354
as(dp7355
g28
V596781
p7356
stp7357
a((dp7358
g2
(lp7359
VEvery named object in C++ has an address
p7360
aVThere is even a specific requirement that the size of every type be at least 1 so that  and  are different, or so that in  both variables have distinct addresses
p7361
aVIn your case,  is a named object of type , so it has an address
p7362
aVThe fact that you constructed  from a particular value is immaterial
p7363
aVWhat matters is that  has been constructed, so it is an object, so it has an address
p7364
as(dp7365
g28
V596781
p7366
stp7367
a((dp7368
g2
(lp7369
VI'm not sure I fully understand your question, but if , ,
p7370
aV,  are all "parallel" tables, then perhaps a UNION does the trick:
p7371
as(dp7372
g28
V596781
p7373
stp7374
a((dp7375
g2
(lp7376
VTake a look at the curl option  (especially with value ) and
p7377
aVTo send data as a cookie, use
p7378
aVFor completeness, the analogous options in  are ,  and
p7379
as(dp7380
g28
V596781
p7381
stp7382
a((dp7383
g2
(lp7384
VTwo things spring to mind:
p7385
aVHere you should allocate one more byte for the null terminator, or you'll create an unterminated string when you call
p7386
aV(Also, the local  in  should be declared as
p7387
aVYou never initialize  to zero
p7388
aVSo if you just call  on a newly minted struct, you may very well be calling an invalid
p7389
as(dp7390
g28
V596781
p7391
stp7392
a((dp7393
g2
(lp7394
VWhy should it, what good would a pointer be
p7395
aVReturning a reference allows you to say  which a pointer wouldn't, and generally lets you use  as an lvalue of the same type as
p7396
aVYou're free to overload any assignment operator you like, but the standard practice of returning a reference to the object itself is very useful
p7397
as(dp7398
g28
V596781
p7399
stp7400
a((dp7401
g2
(lp7402
VUse  to force deletion of read-only files and directories and not ask to confirm when deleting via wildcard
p7403
as(dp7404
g28
V596781
p7405
stp7406
a((dp7407
g2
(lp7408
VWhat you wrote is merely an exception specification, which tells everyone which exceptions you may possibly throw
p7409
aVThat doesn't mean that you will actually end up throwing any exceptions
p7410
aVOn the other hand, / is about exception handling: You surround code in a try block which may throw an exception and then handle the exceptions as they come in
p7411
aVFrom inside your class  you are only allowed to throw exceptions which are listed in the exception specification; if  derives from another class or interface, s specification must be at least as restrictive as that of the base
p7412
as(dp7413
g28
V596781
p7414
stp7415
a((dp7416
g2
(lp7417
V is a reserved word in C++, you cannot use it as the name of your variables
p7418
aVMoreover, there's no need to allocate the object dynamically unless you explicitly require that
p7419
aVIf possible, just allocate it automatically:
p7420
as(dp7421
g28
V596781
p7422
stp7423
a((dp7424
g2
(lp7425
VHere's a solution based solely on overloads, using C++11-style variadic templates:
p7426
aVIf you want to be fancy and if you have access to an  type trait (e
p7427
ag99
aVtaken from the pretty printer), you can make the container overload specific to containers, using :
p7428
as(dp7429
g28
V596781
p7430
stp7431
a((dp7432
g2
(lp7433
VWrite a loop:
p7434
aVYou should first check that  is at least 1, and it'd be better to use the lenght-limited functions  and  instead, and track the lengths of each argument
p7435
as(dp7436
g28
V596781
p7437
stp7438
a((dp7439
g2
(lp7440
VWell, I don't want to say that this is in any way recommendable, but you could hijack some lesser-used operator for a quick hack:
p7441
aVYou could even rig up a moderately safe templated version for statically sized arrays:
p7442
as(dp7443
g28
V596781
p7444
stp7445
a((dp7446
g2
(lp7447
VUse:
p7448
aVPlease forget entirely about  and , etc
p7449
aVThose were crutches in the old C++ because of the lack of lambdas and variadic templates
p7450
aVIn C++11, use  and
p7451
as(dp7452
g28
V596781
p7453
stp7454
a((dp7455
g2
(lp7456
VHow should the compiler be able to deduce this
p7457
aVImagine the following setup:
p7458
aVNow when you say , there's no way to match this unambiguously
p7459
aVThe point is that you are not deducing a template parameter from a given class template, but rather just an arbitrary, free-standing type
p7460
aVThe fact that that type was defined inside another class is not relevant for that
p7461
as(dp7462
g28
V596781
p7463
stp7464
a((dp7465
g2
(lp7466
VYour  is a local copy
p7467
aVWhat you should do is pass the pointer by reference:
p7468
as(dp7469
g28
V596781
p7470
stp7471
a((dp7472
g2
(lp7473
VVery abstractly speaking, endianness is a property of the reinterpretation of a variable as a char-array
p7474
aVPractically, this matters precisely when you  from and  to an external byte stream (like a file or a socket)
p7475
aVOr, speaking abstractly again, endianness matters when you serialize data (essentially because serialized data has no type system and just consists of dumb bytes); and endianness does not matter within your programming language, because the language only operates on values, not on representations
p7476
aVGoing from one to the other is where you need to dig into the details
p7477
aVTo wit - writing:
p7478
aVHere we could just have said, , and the result would have depended on the endianness of the system
p7479
aVAnd reading:
p7480
aVAgain, here we could have said, , and the result would have depended on the machine endianness
p7481
aVAs you can see, with integral types you never have to know the endianness of your own system, only of the data stream, if you use algebraic input and output operations
p7482
aVWith other data types such as , the issue is more complicated
p7483
as(dp7484
g28
V596781
p7485
stp7486
a((dp7487
g2
(lp7488
VThis is untested, just a shot from the hip
p7489
aVIf you don't mind the dynamic cast, how about this:
p7490
aVThat way, you've built the dynamic type checking into the intermediate class, and your clients only ever derive from
p7491
as(dp7492
g28
V596781
p7493
stp7494
a((dp7495
g2
(lp7496
VFor the last decimal digit of , try
p7497
aVTo get the textual numeral character for that digit, use
p7498
aVFor any other number base, replace  with that base
p7499
aVThe "because I can" way:
p7500
aVOr even:
p7501
as(dp7502
g28
V596781
p7503
stp7504
a((dp7505
g2
(lp7506
VThe classes  and  are entirely unrelated, different classes
p7507
aVPointers to them are not convertible in either direction
p7508
aVIf you need runtime-polymorphic behaviour, your class template  could derive from a common (non-templated) base class:
p7509
as(dp7510
g28
V596781
p7511
stp7512
a((dp7513
g2
(lp7514
VJust call  in the loop body
p7515
as(dp7516
g28
V596781
p7517
stp7518
a((dp7519
g2
(lp7520
VYou need to provide your own memory for
p7521
aVAlso, don't use , but rather :
p7522
aVAlternatively you can allocate memory dynamically:
p7523
as(dp7524
g28
V596781
p7525
stp7526
a((dp7527
g2
(lp7528
VFirst off, your  operations copy six bytes each, since both  and  are , and the result is
p7529
aVThat's why you don't copy strings with , but rather with the cleverly named
p7530
aVNext, "how would you print network packets"
p7531
aVI have a utility function  that prints arbitrary memory in lines of sixteen, maybe you'll find it useful:
p7532
aVUsage:
p7533
as(dp7534
g28
V596781
p7535
stp7536
a((dp7537
g2
(lp7538
VAssuming that  points to valid memory which contains a null-terminated string:
p7539
as(dp7540
g28
V596781
p7541
stp7542
a((dp7543
g2
(lp7544
VTemplate parameter deduction for function templates only works based on function arguments, nothing else
p7545
aVThe function definition is never looked at for the purpose of determining the template parameters, so your parameter  cannot possibly be deduced
p7546
aVYou could remedy your situation by incorporating the type into the function signature: Since you expect the outer function to be called with a function itself, make that explicit:
p7547
as(dp7548
g28
V596781
p7549
stp7550
a((dp7551
g2
(lp7552
VNo, bitshift, like any other part of C, is defined in terms of values, not representations
p7553
aVLeft-shift by 1 is mutliplication by 2, right-shift is division
p7554
aV(As always when using bitwise operations, beware of signedness
p7555
aVEverything is most well-defined for unsigned integral types
p7556
as(dp7557
g28
V596781
p7558
stp7559
a((dp7560
g2
(lp7561
VAs @David already said, as far as your question is concerned, there's no such thing as "making assumptions"
p7562
aVThe literals simply have types, which are the types that a function template may use for type deduction
p7563
aVRemember that conversions considered as part of the template matching, though
p7564
aVSo, let's say you have this function template:
p7565
aVThen if you call , this will be called with
p7566
aVIf you say , the deduction is
p7567
aVIf you say anything mixed like , there is no preferred match and the compiler will report an error
p7568
aVSince there is no  literal in C or C++, if you want to explicitly call the function , you can either say so, or create temporary explicit arguments:
p7569
aVUpdate: In light of your edit, note that since you're only matching one argument per template parameter, you won't have any trouble with ambiguous matching
p7570
as(dp7571
g28
V596781
p7572
stp7573
a((dp7574
g2
(lp7575
VScott Meyers has a nice answer for that situation: Add a size check
p7576
aVYou can customize the behaviour to taste, e
p7577
ag99
aVabort if there's a wrong size, etc
p7578
aVThis way, you have a default solution for any derived class you may not know about but still have your own operator kick in only for the base class itself
p7579
aVBeware that the above code may not behave as expected if any of the classes in the hierarchy are empty
p7580
as(dp7581
g28
V596781
p7582
stp7583
a((dp7584
g2
(lp7585
VThere's nothing odd
p7586
aVPolymorphisms works both for pointers and references:
p7587
aVYou're conflating this with another issue, namely creating a reference to a dynamic object:
p7588
aVNote that it's generally very bad style to track a dynamic object only by reference, because the only way to delete it is via , and it's very hard to see that  needs cleaning up
p7589
aVThere are two immediate alternatives for your design: 1) make  a member object in , or 2) make  a  or  and change the initalizer to
p7590
aVIt all depends on whether you actually need the polymorphic behaviour, i
p7591
ag598
aVif you have other constructors for  which assign a different derived class to  other than
p7592
as(dp7593
g28
V596781
p7594
stp7595
a((dp7596
g2
(lp7597
VYou didn't add a rule for making  from
p7598
aVHowever, you don't actually need to specify the  extension on Windows, this will be handled automatically
p7599
aVSo just say it like this:
p7600
as(dp7601
g28
V596781
p7602
stp7603
a((dp7604
g2
(lp7605
VYou can JOIN a table multiple times:
p7606
as(dp7607
g28
V596781
p7608
stp7609
a((dp7610
g2
(lp7611
VSimply convert each digit one by one: , , , etc
p7612
aVA little lookup table could make this very concise
p7613
aVThe beauty of number bases that are powers of another base :-)
p7614
as(dp7615
g28
V596781
p7616
stp7617
a((dp7618
g2
(lp7619
VSay this:
p7620
as(dp7621
g28
V596781
p7622
stp7623
a((dp7624
g2
(lp7625
VUse non-greedy matching with , and also escape the brackets, which are special characters:
p7626
as(dp7627
g28
V596781
p7628
stp7629
a((dp7630
g2
(lp7631
VThat has nothing to do with your server-side language
p7632
aVWhat happens is that the user submitted a form and the browser sent a POST request
p7633
aVIf you display such a website in your browser and press "refresh", Firefox will not just redisplay the page, but actually want to sent the complete POST request again
p7634
aVBecause that request may have been to transfer $1000 to your ex-wife (read: have side effects), the browser asks for confirmation
p7635
aVA possible solution would be to follow a successful login with a redirect to another page, so that the most recent HTTP request is a GET, not a POST request
p7636
as(dp7637
g28
V596781
p7638
stp7639
a((dp7640
g2
(lp7641
VOK, based on your comment, here's a tidbit of reasoning:
p7642
aVSuppose you have a template:
p7643
aVNow we know that to say ,  has to be (a type that's) known at compile-time
p7644
aVSo far no problem
p7645
aVNow suppose we want to build some class:
p7646
aVThat's also fine, because  is a valid type
p7647
aVAgain, no problem
p7648
aVBut now let's generalize MyClass and make it a template:
p7649
aVNow again to say ,  has to be known at compile time
p7650
aVBecause of this, the dependent type  is substituted to become  in , and because  is known, this member type is now also known
p7651
aVThe boldfaced text that you quote is just saying that this reasoning works and you get something valid
p7652
aVFor typenames, this isn't terribly exciting, because all type names are known at compile time, but template arguments can also be non-typenames, namely integral values
p7653
aVNow those also have to be known at compile time, and you can propagate them in the same way
p7654
as(dp7655
g28
V596781
p7656
stp7657
a((dp7658
g2
(lp7659
VMember functions aren't free functions, and pointers-to-member-function (PTMF) are not function pointers
p7660
aVThey're entirely incompatible
p7661
aV(Typically they are much bigger
p7662
aVMuch more importantly, you can only call a member function if you have both a PTMF and an instance pointer
p7663
aVSo, you have to say:
p7664
aV(Not that there's any reason for this amount of indirection if all you want is to branch on one local conditional
p7665
as(dp7666
g28
V596781
p7667
stp7668
a((dp7669
g2
(lp7670
VYou should run your program through a memory debugger to witness the nightmare you've created
p7671
aVYou are using manual memory management in your class, yet you forgot to obey the Rule of Three: You didn't implement the copy constructor, assignment operator and destructor
p7672
aVThus the temporary does allocate memory, copies the pointer (shallowly), and then probably invalidates the memory when it goes out of scope
p7673
aVThe immediate "fix my code" answer is that you have to implement a proper assignment operator and copy constructor to make a deep copy of the char array
p7674
aVThe "this is C++" answer is not to use pointers,  and arrays, and instead
p7675
as(dp7676
g28
V596781
p7677
stp7678
a((dp7679
g2
(lp7680
VSince you asked "What is the best way", let me go out on a limb here and suggest a more C++-like alternative
p7681
aVSince your  is already returning objects by value, the following should work:
p7682
aVNow you don't need to do any memory management at all, as allocation and clean-up is done by the vector class
p7683
aVUse it like this:
p7684
aVDo say if you have a genuine requirement for manual memory management and for pointers, though, but preferably with a usage example
p7685
as(dp7686
g28
V596781
p7687
stp7688
a((dp7689
g2
(lp7690
VThe same as you initialize ordinary arrays:
p7691
aVMissing elements will be set to zero
p7692
as(dp7693
g28
V596781
p7694
stp7695
a((dp7696
g2
(lp7697
VWhen a template parameter is itself a template, then its own template parameters are not used or relevant in the context of the outer template other than to define the "template signature" of the template-template parameter
p7698
aVTherefore, you don't need neither parameter names, as they are not usable or necessary
p7699
aVYou can simply say this:
p7700
aVHere  is just the template signature of the  template class that you expect
p7701
aVIn C++11 you can do better and allow more general containers by using variadic templates:
p7702
aV[For completeness:] Putting default types in the template parameter's parameter list also works, and it means you can omit those types later (as you already do):
p7703
aVTo answer your question: You want to specify a default type in
p7704
aVbut  isn't a type -- it's not even legal syntax
p7705
aVYou could either have a template parameter which once again is a template, i
p7706
ag598
aV, but that wouldn't be matched by , or you have an actual type:
p7707
as(dp7708
g28
V596781
p7709
stp7710
a((dp7711
g2
(lp7712
VOK, a shot into the dark: Let's say your ingress stream is , and you want to turn this into a byte stream
p7713
aVThen we can just assemble the bytes from the character literals as follows, schematically:
p7714
aVHere we use a little helper function:
p7715
as(dp7716
g28
V596781
p7717
stp7718
a((dp7719
g2
(lp7720
VAccess restrictions don't affect inheritance
p7721
aVYou always inherit everything from all base classes
p7722
aVIn your case that may seem unnecessary, but consider a slightly modified version where the private function is virtual:
p7723
aVNow for any  you can always call the non-virtual public interface , but your derived classes provide the implementation by means of a private virtual
p7724
as(dp7725
g28
V596781
p7726
stp7727
a((dp7728
g2
(lp7729
VC++ has three allocation classes: automatic, dynamic, and static, connected to object lifetime (respectively scoped, manual and permanent)
p7730
aVTypically, automatically allocated objects are implemented as being placed on the stack, while dynamically allocated objects go onto the heap; together, stack and heap comprise the "stack segment" of the program
p7731
aVThe program also (typically) has a "data segment", which is where statically allocated objects go -- think of static allocation as happening at load time, so that memory is set aside before the program proper even begins
p7732
aVThe data segment may contain read-only parts, which is where you might find some of your string constants (so don't write to them)
p7733
aVAll these are implementation details, of course, and none of this is mandated by the language
p7734
aVIt's just a popular implementation on desktop platforms
p7735
aVSo whether something is a class or a struct or an int, that's irrelevant, what matters is how you allocate it
p7736
as(dp7737
g28
V596781
p7738
stp7739
a((dp7740
g2
(lp7741
VA combination of ,  and  typetraits should do the job:
p7742
aVThe type traits are available from  in modern compilers, or  or Boost otherwise
p7743
as(dp7744
g28
V596781
p7745
stp7746
a((dp7747
g2
(lp7748
VVariadic function arguments a la  are not typesafe, and they're not a good idea in C++
p7749
aVIf you have C++11, you can use variadic templates for much better results
p7750
aVBe that as it may, if you want to go with variadic function arguments, you have to tell the function which arguments there are and how big they are
p7751
aVTraditionally, you would pass that information in one of the arguments (like  does)
p7752
aVIf you wanted to, you could use the template parameter for that effect, but since you have to have at least one non-variadic argument anyway, there's really no need
p7753
aVMost importantly, making the function a template will instantiate a different piece of code for every
p7754
aVSo, to summarize: Don't use variadic functions
p7755
aVIf you have to use variadic functions, don't use templates with them
p7756
as(dp7757
g28
V596781
p7758
stp7759
a((dp7760
g2
(lp7761
VPointers count bytes, so yes, an increment by one moves the pointer to point at the next byte
p7762
aVA  has by definition size 1, so to do byte-wise pointer arithmetic, cast to char:
p7763
aVCasting pointers to and from char types does not constitute type punning and is explicitly allowed by the standard
p7764
as(dp7765
g28
V596781
p7766
stp7767
a((dp7768
g2
(lp7769
VUnfortunately, the words "static" and "dynamic" are way too overused, especially in C and C++
p7770
aVSo, I prefer the following terminology:
p7771
aVLink-time linking, a
p7772
aVk
p7773
aVa "static linking": All symbols are resolved at link time from static libraries
p7774
aVThe result is a monolithic, statically linked executable with no load-time dependencies
p7775
aVLoad-time linking: This is the standard practice on modern platforms, unresolved symbols are looked up in shared libraries (Unix) or the unfortunately named dynamic link libraries (DLLS) on Windows and only references are recorded at link time, the actual resolution of the symbols and code loading happens at load time
p7776
aVThis results in a "dynamically linked" executable which must be loaded with a loader (e
p7777
ag99
aVon Linux)
p7778
aVLoading is part of the OS and usually transparent to the user, though it's open to inspection (e
p7779
ag99
aVwith  on Linux)
p7780
aVAll shared libraries must be available at load time, or the program will not launch
p7781
aVRun-time linking, a
p7782
ag7773
aVa
p7783
aV"dynamic linking": There are no unresolved symbols; rather, the runtime dynamically decides to look up symbols in a shared/dynamic library using  or
p7784
aVFailure to find symbols is a handlable runtime condition that is not an error
p7785
aVThis technique is used commonly for plug-in architecture, and on Windows for code injection
p7786
aVNote however that there is a fundamental technical difference between Linux's shared objects and Windows's DLLs, they're not just the same thing with a different name
p7787
aVBoth can however be used both for load-time and run-time linking
p7788
as(dp7789
g28
V596781
p7790
stp7791
a((dp7792
g2
(lp7793
VWhen you declare ,  is just an uninitialized pointer that doesn't point to a valid memory location
p7794
aVLater, when you say , you dereference that pointer, which results in undefined behaviour
p7795
aVYou have to assign a meaningful location to , like so:
p7796
as(dp7797
g28
V596781
p7798
stp7799
a((dp7800
g2
(lp7801
VLibraries that you link at run-time should really not be too central to your program flow; rather, they should be at the "leaf ends", if you will
p7802
aVEspecially general purpose libraries usually exhibit only functions that accomplish one particular task (e
p7803
ag99
aVencrypt something)
p7804
aVThink about it, all you can import from a library at runtime is a single function
p7805
aVThe library cannot possibly know your entire program state and interact with it meaningfully
p7806
aVIt all boils down to design
p7807
aVIf you design the library yourself, and you want integral parts of your program to be loaded at runtime, then you have to supply a thorough amount of callback interfaces
p7808
aVBut if the library is that tightly coupled, you might consider linking it into your main program directly
p7809
aVFinally, since the -style interface only handles C-style function pointers, you're essentially limited to a C-style interface
p7810
aVYou could pass function pointers through, if you like, but see above on considerations whether this leads to good design
p7811
aVHaving a C++ interface (e
p7812
ag99
aVexporting functions that take classes by references) is a lot trickier because you'll have to ensure that the library (and all future incarnations of 3rd-party supplied libraries) conform to the same ABI, and the C++ ABI is a lot more complex and subject to change than the C ABI
p7813
aVThink about it like this: Use run-time loading if you want a plugin architecture for which third parties can at later times write code that can be used by your program
p7814
aVIf that doesn't make sense, use normal linking at compile time
p7815
as(dp7816
g28
V596781
p7817
stp7818
a((dp7819
g2
(lp7820
VThis has nothing to do with the delete operator
p7821
aVRather, the problem is that the destructor is private, and when you call the delete expression , this is equivalent to  It is this first call to the destructor that fails, rather than the call of the delete operator
p7822
aVEven if you overloaded member new/delete operators, that wouldn't change a thing, because it's the delete expression which first calls the destructor and then the (member) operator, so the destructor must be available as a public function
p7823
as(dp7824
g28
V596781
p7825
stp7826
a((dp7827
g2
(lp7828
VIf not all the fields are necessary because they depend on some choice, you could only display the relevant fields once the choice has been made
p7829
aVYou could also visually distinguish non-mandatory fields so that it's clear from the outset how much work has to be done by the user and how much is optional
p7830
aVIf everything is mandatory, then you could either go the Windows way and show tons of small windows in sequence and annoy everyone who just wants to get it done, but you'd not scare people who get scared by seeing lots of forms - a page counter is crucial, though
p7831
aVHowever, you could start with a small wizard view, but immediately offer an "advanced" option that would allow those who want to show everything at once, while still offering a guided tour as the default
p7832
as(dp7833
g28
V596781
p7834
stp7835
a((dp7836
g2
(lp7837
VYou can always just write your own conversion function
p7838
aVThe following idea is stolen from heavily inspired by this fine answer:
p7839
aVThis will return a pointer to a null-terminated string containing the base36-representation of , placed in a buffer that you provide
p7840
aVUsage:
p7841
aVIf you want and you're single-threaded, you can also make the char buffer static -- I guess you can figure out a suitable maximal length:
p7842
as(dp7843
g28
V596781
p7844
stp7845
a((dp7846
g2
(lp7847
VI think the problem boils down to the type of initialization that the container performs on elements
p7848
aVCompare:
p7849
aVThe problem with the standard containers is that they take the default argument to be value initialized, as in
p7850
aVThis means that there's no elegant way to avoid value-initialization or copying
p7851
aV(Similarly for the constructor
p7852
aVEven using the standard allocators doesn't work, because their central  function takes an argument that becomes value-initialized
p7853
aVWhat you would rather need is a  that uses default-initialization:
p7854
aVSuch a thing wouldn't be a conforming standard allocator any more, but you could build your own container around that idea
p7855
as(dp7856
g28
V596781
p7857
stp7858
a((dp7859
g2
(lp7860
VVirtual functions are the standard solution here:
p7861
aVNow you can call  and get the correct function
p7862
aV(The term here is "overriding", not "overloading", which is something different
p7863
aVEdit: Seeing Owen's fine answer, another idea that requires changing the constructors is to make the filename a member variable:
p7864
as(dp7865
g28
V596781
p7866
stp7867
a((dp7868
g2
(lp7869
VYou aren't using polymorphism
p7870
aVPolymorphic behaviour only affects pointers and references to base classes, like so:
p7871
aVNow accessing member functions of , ,  is subject to polymorphism and virtual dispatch
p7872
aVHowever, you must declare the first function at the top of the inheritance hierarchy virtual, i
p7873
ag598
aVin
p7874
aVIn your example, without , there's no polymorphism and you always call the member function of the corresponding static type of the object
p7875
aVTo test this, add another few lines:
p7876
as(dp7877
g28
V596781
p7878
stp7879
a((dp7880
g2
(lp7881
V0x20 is 32, so  takes  modulo 32, so that you never shift by 32 bits
p7882
aVThis is a safeguard because shifting by anything that isn't strictly less than the size of the type is undefined behaviour
p7883
as(dp7884
g28
V596781
p7885
stp7886
a((dp7887
g2
(lp7888
VYes, that's possible
p7889
aVHowever, that means that the derived class itself is still abstract and cannot be instantiated, and you need to derive further from it until you've defined all the virtual functions
p7890
as(dp7891
g28
V596781
p7892
stp7893
a((dp7894
g2
(lp7895
VI don't really know what else to do than look up , which you should keep in mind for future questions pertaining to gcc invocation
p7896
aVSo:
p7897
aVAs you can se, the only difference is that  allows you to specify multiple arguments by means of a comma, like , which you cannot do with ; on the other hand,  is maybe a bit more self-descriptive
p7898
aVTake your pick
p7899
aVAlso check other compilers ( comes to mind, and ) to see if any of them agree on the syntax, and then use that for portability if that's important to you
p7900
as(dp7901
g28
V596781
p7902
stp7903
a((dp7904
g2
(lp7905
VThis is an unfortunate omission in C++11; Boost has the answer in terms of
p7906
aVFeel free to just paste it from them
p7907
aVHere's how I hash pairs:
p7908
aVYou can use  as the basis for many other things, like tuples and ranges, so you could hash an entire (ordered) container, for example, as long as each member is individually hashable
p7909
aVNow you can just declare a new map:
p7910
aVIf you want to use your homebrew hasher (which hasn't got good statistical properties), you have to specify the template parameters explicitly:
p7911
aVNote that there's no need to specify a copy of a hasher object, as the default is to default-construct one for you
p7912
as(dp7913
g28
V596781
p7914
stp7915
a((dp7916
g2
(lp7917
VNever mind what your vector contains - the deletion of managed resources can indeed be left to smart pointers, but the more pressing issue is how to manipulate the container itself
p7918
aVindeed has very poor iterator invalidation: erasing or inserting invalidates all iterators from the erasee/insertee onwards, so you cannot even use the standard  idiom
p7919
aVBut neither should you, since erasing from a vector is expensive
p7920
aVThe better solution is to use remove/erase and supply a functor that checks the condition for erasure, and then erase everything in one wash:
p7921
aVHere  is a predicate that implements your criterion
p7922
aVIn C++11 this could be a handy lambda
p7923
aVIf your existing algorithm is too involved, perhaps you can adapt the idea of  in your own algorithm and move the to-be-erased object to the back of the vector with , and return the iterator past the last good element at the end of the algorithm
p7924
aVThen you can have your own optional clean-up loop on the range of objects to be deleted, and then call  on that range
p7925
as(dp7926
g28
V596781
p7927
stp7928
a((dp7929
g2
(lp7930
VYou probably want to say
p7931
aVor even just:
p7932
aVYour  points to , which is beyond the allocated memory
p7933
as(dp7934
g28
V596781
p7935
stp7936
a((dp7937
g2
(lp7938
VThe member version reads into a , the free version reads into a
p7939
aVSo prefer the free version
p7940
aVUse it like this:
p7941
as(dp7942
g28
V596781
p7943
stp7944
a((dp7945
g2
(lp7946
VChange the second line to:
p7947
aVOtherwise your output is main
p7948
aVo and you're missing it in the input
p7949
aVEven better than manual maintenance martyrdom is to use special macros:
p7950
aVSo even when you expand your program, you won't have to edit that command again
p7951
as(dp7952
g28
V596781
p7953
stp7954
a((dp7955
g2
(lp7956
VI'd say you have a circular dependency in your CRTP (as one would have, by its very nature), but that means that the base template class isn't allowed to use any of its parameter class, because that very parameter class isn't defined yet - it's still an incomplete type at the time where  is instantiated
p7957
aVSo, this is OK:
p7958
aVBut this isn't:
p7959
as(dp7960
g28
V596781
p7961
stp7962
a((dp7963
g2
(lp7964
VMaybe this clause from 8
p7965
ag97
ag5593
aV5 explains it (my emphasis):
p7966
aVAn object of type std::initializer_list is constructed from an
p7967
aVinitializer list as if the implementation allocated an array of N
p7968
aVelements of type E, where N is the number of elements in the
p7969
aVinitializer list
p7970
aVEach element of that array is copy-initialized
p7971
aVwith the corresponding element of the initializer list, and the
p7972
aVstd::initializer_list object is constructed to refer to that array
p7973
aVSo you can only initialize from lists if the objects are copyable
p7974
aVUpdate: As Johannes points out, copy-initialization can be realized by both copy and move constructors, so that alone isn't enough to answer the question
p7975
aVHere is, however, an excerpt of the specification of the  class as described in 18
p7976
aV9:
p7977
aVNote how there are no non-constant typedefs
p7978
aVI just tried making an IL constructor which would traverse the initializer list via , which failed because  cannot be converted to
p7979
aVSo the answer is: You cannot move from the IL, because the standard says so
p7980
as(dp7981
g28
V596781
p7982
stp7983
a((dp7984
g2
(lp7985
VThe scaffold could look like this:
p7986
aVWe need the helper:
p7987
aVNow all we need is a type-trait to check for a member typedef:
p7988
aVUsage:
p7989
as(dp7990
g28
V596781
p7991
stp7992
a((dp7993
g2
(lp7994
VYour question is not very concrete, so here's an answer in the same spirit:
p7995
aVGenerally, your classes should be designed to express a particular concept and functionality
p7996
aVThey should not just hand through another member class
p7997
aVIf you find yourself replicating all the interface functions of a member object, something is wrong
p7998
aVMaybe sometimes you really just need a collection of other things
p7999
aVIn that case, consider a plain old aggregate, or even a tuple
p8000
aVBut if you're designing a proper class, make the interface meaningful to the task at hand, and hide the implementation
p8001
aVSo the main question here is, why do you need to expose the vector itself
p8002
aVWhat is its role in the class
p8003
aVWhat does its emptiness signify in terms of the semantics of your class
p8004
aVFind the appropriate idioms and ideas to design a minimal, modular interface for your class, and the question might just go away by itself
p8005
aV(One more idea: If for example you have some range-based needs, consider exposing a template member function accepting a pair of iterators
p8006
aVThat way you leverage the power of generic algorithms without depending on the choice of container
p8007
as(dp8008
g28
V596781
p8009
stp8010
a((dp8011
g2
(lp8012
VSince you've now added that you actually want to write your own allocator, the answer is straight-forward: Simply ensure that your allocator returns a pointer whose value is a multiple of the requested size
p8013
aVThe object's size itself will already come suitably adjusted (via internal padding) so that all member objects themselves are properly aligned, so if you request  bytes, all your allocator needs to do is to return a pointer whose value is divisible by
p8014
aVIf your object does indeed have size 20 (as reported by ), then you have nothing further to worry about
p8015
aV(On a 64-bit platform, the object would probably be padded to 24 bytes
p8016
aVUpdate: In fact, as I only now came to realize, strictly speaking you only need to ensure that the pointer is aligned, recursively, for the largest member of your type
p8017
aVThat may be more efficient, but aligning to the size of the entire type is definitely not getting it wrong
p8018
as(dp8019
g28
V596781
p8020
stp8021
a((dp8022
g2
(lp8023
VYou can just trivially write that yourself:
p8024
aVIn fact, you can do that to obtain the binary representation of any (standard-layout*) variable
p8025
aV*) thanks, @R
p8026
aVMartinho Fernandes
p8027
aVIf you decide to try this on a  (or rather, an 80-bit extended precision float), beware that that has only 10 bytes, but is padded to 12 or 16 on x86/x64, respectively
p8028
as(dp8029
g28
V596781
p8030
stp8031
a((dp8032
g2
(lp8033
VIf you are sure that  does not participate in the "logical state" of your class and is merely an implementation detail, then you could declare it :
p8034
aVNow you ought to be able to change :
p8035
as(dp8036
g28
V596781
p8037
stp8038
a((dp8039
g2
(lp8040
VYou could split your project into different TUs:
p8041
as(dp8042
g28
V596781
p8043
stp8044
a((dp8045
g2
(lp8046
VThat fails because you're using single quotes
p8047
aVThere's no variable substitution inside single quotes
p8048
aVInstead, use double quoted:
p8049
as(dp8050
g28
V596781
p8051
stp8052
a((dp8053
g2
(lp8054
VThe function requires its argument by non-const reference, which cannot bind to a temporary
p8055
aVObserve:
p8056
aVIn your case,
p8057
aVSo, you have provide a non-temporary:
p8058
aVNote that the purpose of this is presumably to fill  with some meaningful value, so be sure to incorporate that apporpriately
p8059
as(dp8060
g28
V596781
p8061
stp8062
a((dp8063
g2
(lp8064
VYou said you don't want to wrap each call, but let me just show you how I handle timer calls so they can be removed at compile time, and maybe that can be wrapped up in another macro later:
p8065
aVNow you can use it like this:
p8066
aVWith variadic macros you might even be able to wrap up the function call:
p8067
as(dp8068
g28
V596781
p8069
stp8070
a((dp8071
g2
(lp8072
VThe GNU Coding Standards have a section on command line programs
p8073
aVFor a posixy feel, you shouldn't only provide the standard command line options, both short and long, but also, if possible, adhere to reading from the standard input (or the command line) and writing to the standard output, and only overriding the output with an option (like /)
p8074
aVThat's what one expects of most GNU command line tools
p8075
as(dp8076
g28
V596781
p8077
stp8078
a((dp8079
g2
(lp8080
VYour  function should return  on success
p8081
aVIf you call , you can call it with either  or the macro
p8082
aVFrom the FDIS, 18
p8083
ag97
aV8, concerning :
p8084
aVIf status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned
p8085
aVTo explain returning zero from , here is 3
p8086
ag263
ag1217
aV5:
p8087
aVA return statement in main has the effect of leaving the main function (destroying any objects with automatic storage duration) and calling std::exit with the return value as the argument
p8088
aVIf control reaches the end of main without encountering a return statement, the effect is that of executing
p8089
as(dp8090
g28
V596781
p8091
stp8092
a((dp8093
g2
(lp8094
VA simple, universal rule I like to apply is this:
p8095
aVAlways store data raw, and escape it for the appropriate application when needed
p8096
aVThis means, get rid of nebulous , and:
p8097
aVfor string values in SQL statements, use the database's appropriate escape function, e
p8098
ag99
aV,
p8099
aVfor -type command names, use , for arguments use ,
p8100
aVfor manually assembling GET request URLs, use , and finally
p8101
aVfor printing content in an HTML structure, use
p8102
aVThere's no point in blindly using some sort of mangling and hoping it'll filter out bad things
p8103
aVBe conscious of what you're doing, and do the appropriate thing at every step
p8104
aVExample: To print a link with a user-provided GET parameter, you'd do
p8105
aVImportant note: For SQL queries, it is generally preferable to use prepared statements rather than building queries by hand
p8106
aVThis is a different technology from what you're used to, so it's not the straight "how do I fix this" answer, but it is by far the better solution
p8107
as(dp8108
g28
V596781
p8109
stp8110
a((dp8111
g2
(lp8112
VUse it like your first example:
p8113
aVThat's because of the reference collapsing rules: If , then , but if , then , so you always end up with the correct type inside the function body
p8114
aVFinally, you need  to turn the lvalue-turned  (because it has a name now
p8115
aVback into an rvalue reference if it was one initially
p8116
aVYou cannot forward something more than once, though, because that makes no sense
p8117
aVForwarding means that you're potentially moving the argument all the way through to the final caller, and once it's moved it's gone, so you cannot then use it again
p8118
as(dp8119
g28
V596781
p8120
stp8121
a((dp8122
g2
(lp8123
VWell, as the error says, you're trying to convert between pointers to  and to , which is not allowed
p8124
aVYou have to add an explicit cast, e
p8125
ag99
as(dp8126
g28
V596781
p8127
stp8128
a((dp8129
g2
(lp8130
VI think the following are different:
p8131
as(dp8132
g28
V596781
p8133
stp8134
a((dp8135
g2
(lp8136
VThe way I see it is that templates and inheritance are literally orthogonal concepts: Inheritance is "vertical" and goes down, from the abstract to the more and more concrete
p8137
aVA shape, a triange, an equilateral triangle
p8138
aVTemplates on the other hand are "horizontal" and define parallel instances of code that knowns nothing of each other
p8139
aVSorting integers is formally the same as sorting doubles and sorting strings, but those are three entirely different functions
p8140
aVThey all "look" the same from afar, but they have nothing to do with each other
p8141
aVInheritance provides runtime abstraction
p8142
aVTemplates are code generation tools
p8143
aVBecause the concepts are orthogonal, they may happily be used together to work towards a common goal
p8144
aVMy favourite example of this is type erasure, in which the type-erasing container contains a virtual base pointer to an implementation class, but there are arbitrarily many concrete implementations that are generated by a template derived class
p8145
aVTemplate code generation serves to fill an inheritance hierarchy
p8146
aVMagic
p8147
as(dp8148
g28
V596781
p8149
stp8150
a((dp8151
g2
(lp8152
VYour function expects a pointer to modifiable data, i
p8153
ag598
aV, but the standard string class only exposes a pointer to constant
p8154
aVAssuming that your function may actually write to the memory, we need to provide it with a valid pointer
p8155
aVAn easy way to obtain a modifiable buffer is, as always, a :
p8156
as(dp8157
g28
V596781
p8158
stp8159
a((dp8160
g2
(lp8161
VThere is no stack
p8162
aVDon't think about a stack
p8163
aVWhat matters is whether a given container class performs any dynamic allocation or not
p8164
aVdoesn't use any dynamic allocation, it is a very thing wrapper around an automatically allocated
p8165
aVAnything you put in a vector will however be allocated by the vector's own allocator, which in the default case (usually) performs dynamic allocation with
p8166
aVSo in short,  is very simiar to : The allocator simply allocates memory for as many units of  (or ) as it needs to hold and constructs the elements in that memory
p8167
aVRinse and repeat for nested vectors
p8168
aVFor your "additional questions":  is definitely not contiguous for  at all
p8169
aVIt is merely contiguous for , but that only contains the small book-keeping part of the inner vector
p8170
aVThe actual content of the inner vector is allocated by the inner vector's allocator, and separately for each inner vector
p8171
aVIn general,  is contiguous for the type , and nothing else
p8172
aVI'm not actually sure about  -- it might be contiguous for , because the array has no reason to contain any data besides the contained , but I'm not sure if that's mandatory
p8173
aVYou might want to ask that as a separate question, it's a good question
p8174
as(dp8175
g28
V596781
p8176
stp8177
a((dp8178
g2
(lp8179
VYou don't have to add much at all, because inside a template, the class name itself refers to the current template parameter
p8180
aVSo the following are equivalent:
p8181
aVSo all your operations just go through without change
p8182
aVWhat you should add is a constructor that converts one matrix type into another:
p8183
aVUsing that conversion constructor, you can mix matrices in your operators, as  will use the conversion to create an argument of type , and then you use your already implemented operator
p8184
aVIn C++11 you can add  to your converting constructor to give you a useful compile-time diagnostic if you call it with an incompatible type
p8185
as(dp8186
g28
V596781
p8187
stp8188
a((dp8189
g2
(lp8190
V requires a modifiable buffer, because it replaces the delimiter by a null byte
p8191
aVSo you cannot say , because that should really have been  and points to read-only memory
p8192
aVInstead, you have several options:
p8193
as(dp8194
g28
V596781
p8195
stp8196
a((dp8197
g2
(lp8198
VIt's a non-standard GNU extension, as the manual and the suffix  will tell you, so include the header like this:
p8199
as(dp8200
g28
V596781
p8201
stp8202
a((dp8203
g2
(lp8204
VIf you really can't infer the correct types from class typedefs (which I doubt, double check the documentation), the you can specify the template parameters a bit more explicitly:
p8205
aVIf you don't have variadic templates, you'll have to specify as many arguments as your container takes, or specify default arguments if you only want the template to match those
p8206
aVHere's a defaulting version that works for two-parameter containers:
p8207
aVThis will only match
p8208
aVHere's a general version for two-parameter containers:
p8209
aVConcretely, your function should be a variation of this:
p8210
as(dp8211
g28
V596781
p8212
stp8213
a((dp8214
g2
(lp8215
VSince the functions may have side effects, the conditional cannot be "optimized" in any way, since all the functions will have to be called (conditionally) in a well-defined manner
p8216
aVIf you do want optimization, you can assign the result to variables first:
p8217
aVIt's possible that  functions introduced in C++11 will allow for optimization if they yield a constant expression, though, but I'm not sure
p8218
aVYou can even condense this down: In the following code,  has to be called twice:
p8219
as(dp8220
g28
V596781
p8221
stp8222
a((dp8223
g2
(lp8224
VInteger literals starting with  are interpreted base 8
p8225
aVYour second  has the value 83
p8226
aVSee the manual on integers for details
p8227
aVThe  function lets you specify the base if you're reading a user string
p8228
aVIf we're talking about literals, in PHP the literal  is decimal, while in C and C++ it is octal
p8229
aVIt's the little differences that make life fun
p8230
as(dp8231
g28
V596781
p8232
stp8233
a((dp8234
g2
(lp8235
VYou have to add all the dependencies to your Makefile:
p8236
aVIf you already have a generic pattern matching command line, you don't have to say the command again, you can just list the dependencies:
p8237
aVIn general, this is a terrible and unscalable mess
p8238
aVYou'll almost definitely want a higher-level build system to generate the Makefile for you
p8239
aVEven for very small projects keeping the header dependencies up to date in the Makefile is such a pain that it is simply not worth it
p8240
aVThere are several popular portable build environments
p8241
aVI personally like  a lot, which includes discovery if you changed the build settings (say from Debug to Release) and will always build all the necessary files (for example, if you change the cmake master file and type "make" it'll automatically run cmake again for you first)
p8242
aVFor a Unix-only solution you could try , or the infamous , though that's a whole other headache
p8243
as(dp8244
g28
V596781
p8245
stp8246
a((dp8247
g2
(lp8248
VOK, crazy idea
p8249
aVDon't use this:
p8250
aVThe container requires no dynamic allocation itself, you must only ensure that  is big enough to hold any derived class
p8251
as(dp8252
g28
V596781
p8253
stp8254
a((dp8255
g2
(lp8256
VThere isn't a general mechanism in the language that'll tell you all the base classes, though you're free to add a suitable typedef to all members of your class hierarchy that will make this information available (e
p8257
ag99
aVtypedef a tuple whose argument types are the ancestor plus the ancestor's ancestors) -- you could probably write a little mixin for that
p8258
aVAs for checking whether something is a base of another, that's already part of the standard in the shape of the  type trait
p8259
as(dp8260
g28
V596781
p8261
stp8262
a((dp8263
g2
(lp8264
VI think the answers are missing an important point
p8265
aVThe size of memory is a relatively specific technical detail which isn't of primary interest
p8266
aVThe crucial difference is that between automatic and dynamic storage, and the associated lifetime:
p8267
aVAutomatic storage ends at the end of the scope
p8268
aVDynamic storage begins with  and ends with , entirely at the discretion (and responsibility) of the user
p8269
aVIf you can and if it makes sense, everything should be automatic
p8270
aVThis entails locality and well-defined interfaces
p8271
aVHowever, in C (not so much in C++) there comes a time when you need to talk about objects that aren't local to the scope
p8272
aVThat's when we need dynamic allocation
p8273
aVThe prime example is your typical linked list
p8274
aVThe list consists of nodes:
p8275
aVNow to talk about such a list boils down to talking about any of its nodes and brachiate along the prev/next pointers
p8276
aVHowever, the actual nodes cannot sensibly be part of any local scope, so they are usually dynamically allocated:
p8277
aVHere the list nodes exist outside any scope, and you have to bring them to life manually using , and clean them up when you're done
p8278
aVYou can use linked lists even in the tiniest of programs, but there's no real way around the manual allocation
p8279
aVEdit: I thought of another example that should really convince you: You might think that you can just make the list with automatically allocated nodes:
p8280
aVBut note that you cannot do this dynamically
p8281
aV"Dynamic" means "at runtime", but automatic variables have to be determined entirely at compile time
p8282
aVSuppose you wanted a program that reads integers from the user
p8283
aVIf it's even, you add it to the list, if it's odd you ignore it, and if it's zero you stop
p8284
aVYou cannot possibly realize such a program with automatic allocation, because the allocation needs are only determined at runtime
p8285
aVIt is in such a scenario that you require
p8286
as(dp8287
g28
V596781
p8288
stp8289
a((dp8290
g2
(lp8291
VHere's a standard solution idiom:
p8292
aVYou'll get a compile-time error if you call either construction with a non-floating type
p8293
aVBeware though that this might erroneously work for long doubles, which require the  format specifier; and also recall that floats get promoted to doubles when passed through variadic function arguments
p8294
as(dp8295
g28
V596781
p8296
stp8297
a((dp8298
g2
(lp8299
V is an integer equal to
p8300
aVYou should write  (or ) to get a floating point value
p8301
as(dp8302
g28
V596781
p8303
stp8304
a((dp8305
g2
(lp8306
VThe cleanest solution is to make a predicate and use :
p8307
aVIf you have C++11 you can use a lambda instead
p8308
as(dp8309
g28
V596781
p8310
stp8311
a((dp8312
g2
(lp8313
VThis
p8314
aVshould be
p8315
aVYou're overstepping the array bound
p8316
as(dp8317
g28
V596781
p8318
stp8319
a((dp8320
g2
(lp8321
VThis is the standard design rationale for the entire library: Separate containers from algorithms
p8322
aVIf you did it your way, you'd have to implement every feature X for every container Y, leading you to M * N implementations if you have M features and N containers
p8323
aVBy using iterators and make algorithms work on iterators rather than containers, you only have to implement M algorithms plus N iterator interfaces
p8324
aVThis separation also means that you have infinitely wider scope of application: the algorithms cannot just be used for every library container, but for any container, present or future, that anyone decides to write and equip with iterators
p8325
aVFinite vs infinite reuse is quite a strong argument
p8326
aVAnd calling the algorithms through the generic, free interface doesn't add any cost
p8327
as(dp8328
g28
V596781
p8329
stp8330
a((dp8331
g2
(lp8332
VSee here for a previous rant of mine on this subject
p8333
aVAssuming that your platform is capable of handling Tamil characters, I suggest the following sequence of events:
p8334
aVI
p8335
aVGet the input string into a wide string:
p8336
aVII
p8337
aVConvert the wide string into a string with definite encoding:
p8338
aVFinally, you have in  an array of Unicode codepoints that made up your input text
p8339
aVYou can now process this array, e
p8340
ag99
aVby looking each codepoint up in a list and checking whether it comes from the Tamil script, and do with it whatever you see fit
p8341
as(dp8342
g28
V596781
p8343
stp8344
a((dp8345
g2
(lp8346
Vprintf() is not typesafe
p8347
aVThe arguments that you pass to  are treated according to what you promise the compiler
p8348
aVAlso, s are promoted to s when passed through variadic arguments
p8349
aVSo when you promise the compiler  the first time (for ), the compiler gobbles up an entire  (usually 8 byte) from the arguments, swallowing your float in the process
p8350
aVThen the second  cuts right into the zero mantissa of the second double
p8351
aVHere's a picture of your arguments:
p8352
aVBut  looks like this (having been promoted to ):
p8353
aVLet's draw it again with values, and speculating about your machine endianness:
p8354
aVNote that 1073217536 is 0x3FF80000
p8355
as(dp8356
g28
V596781
p8357
stp8358
a((dp8359
g2
(lp8360
VLet's cut the PHP stuff, which isn't relevant
p8361
aVYour said,
p8362
aVThat's not quite right, that's not how JOINs work
p8363
aVIt should be,
p8364
as(dp8365
g28
V596781
p8366
stp8367
a((dp8368
g2
(lp8369
VMaybe try something like this:
p8370
as(dp8371
g28
V596781
p8372
stp8373
a((dp8374
g2
(lp8375
VYou can fork the original project, write the unit tests, then use the "Fork Queue" feature to selectively incorporate the changes by the third party into your own repository, and finally issue a pull request to your own repository, unit tests inclusive, to the original repository
p8376
as(dp8377
g28
V596781
p8378
stp8379
a((dp8380
g2
(lp8381
VYou're deceiving yourself: A single default construction of the derived object calls both constructors
p8382
aVNow, what you are not seeing is the copy constructor, which does in fact get called twice in both cases
p8383
aVThe constructor of  that you're calling makes one default construction of its value type, and then copies that into each element:
p8384
as(dp8385
g28
V596781
p8386
stp8387
a((dp8388
g2
(lp8389
VDepending on your notion of "character", this question can get more or less involved
p8390
aVFirst off, you should transform your byte string into a string of unicode codepoints
p8391
aVYou can do this with  of ICU, though if this is the only thing you do,  is a lot easier, and it's part of POSIX
p8392
aVYour string of unicode codepoints could be something like a null-terminated , or if you have C1x, an array of
p8393
aVThe size of that array (i
p8394
ag598
aVits number of elements, not its size in bytes) is the number of codepoints (plus the terminator), and that should give you a very good start
p8395
aVHowever, the notion of a "printable character" is fairly complex, and you may prefer to count graphemes rather than codepoints - for instance, an  with an accent  can be expressed as two unicode codepoints, or as a combined legacy codepoint  - both are valid, and both are required by the unicode standard to be treated equally
p8396
aVThere is a process called "normalization" which turns your string into a definite version, but there are many graphemes which are not expressible as a single codepoint, and in general there is no way around a proper library that understands this and counts graphemes for you
p8397
aVThat said, it's up to you to decide how complex your scripts are and how thoroughly you want to treat them
p8398
aVTransforming into unicode codepoints is a must, everything beyond that is at your discretion
p8399
aVDon't hesitate to ask questions about ICU if you decide that you need it, but feel free to explore the vastly simpler  first
p8400
as(dp8401
g28
V596781
p8402
stp8403
a((dp8404
g2
(lp8405
VGCC has the option  which enables aliasing optimizations globally and expects you to ensure that nothing gets illegally aliased
p8406
aVThis optimization is enabled for  and  I believe
p8407
aVC++ has well defined aliasing rules, though, and standard-compliant code will not conflict with strict aliasing
p8408
aVIn particular this means you're not allowed to access one variable through a pointer to a different type:
p8409
aVThe crucial exception to this rule is that you can always access any variable through a pointer to
p8410
aV(This is necessary for serializing through IO operations
p8411
aVThe aliasing rules do not help the compiler to know whether any pointers of the same type alias each other
p8412
aVConsider this:
p8413
aVHere the compiler cannot know whether  points to different memory than  or  and has to be careful
p8414
aVI think this is where  makes a difference, essentially by promising that  means that nobody aliases
p8415
as(dp8416
g28
V596781
p8417
stp8418
a((dp8419
g2
(lp8420
VI should recommend the fine VMime library
p8421
aVIt's a true C++ library and handles everything email
p8422
aVI'm also told that cURL has SMTP support
p8423
as(dp8424
g28
V596781
p8425
stp8426
a((dp8427
g2
(lp8428
VIt's just a matter of convention
p8429
aV"Input" and "output" are understood as "from"/"to" with  respect to the environment, not with respect to your program; or in the other direction, as "into/out of" with respect to your program, not the environment
p8430
aVSo "input" gets something from the environment and makes it available to your program, like  or
p8431
aV"Output" puts something from your program back out into the environment, like  and
p8432
aVThe iterators follow the same direction, an input iterator makes the data from a range available to your program, while the output iterator puts data from your program into a range
p8433
aVThe way you may be thinking is that "input" is somebody else's input that your program should want to write to
p8434
aVBut I guess the wording presumes an egocentric programmer for whom their own program is the point of reference, not anyone (or everyone) in the environment
p8435
as(dp8436
g28
V596781
p8437
stp8438
a((dp8439
g2
(lp8440
VMulti-index isn't what you want, you seem to want a single index whose type is a triple
p8441
aV(Unless you actually do want three independent indexes; if I misunderstood, leave a comment
p8442
aVDon't use strings, heavens no
p8443
aVJust use the triple as a key:
p8444
aVIf you use an , you get logarithmic lookup, which may be sufficient, and I think you don't even have to do any more work (not sure if lexicographic comparison is defined by default for tuples)
p8445
aVIf you want to use an  (or the boost version), you have to define a hash function
p8446
aVBoost already has one for tuples, I think, but C++11 doesn't; but it's very easy to implement yourself based on  which you can just crop out off the Boost code
p8447
as(dp8448
g28
V596781
p8449
stp8450
a((dp8451
g2
(lp8452
VEven though there's no way to give a comprehensive answer or anything near that, maybe think about it like this: classes are types
p8453
aVConsider this:
p8454
aVHere "int" is the name of a type, and "x" is a variable of type "int"
p8455
aVThere are basic types in C++, like "int", "char", "double"
p8456
aVNow we can also make new, compound types from old types:
p8457
aVThis defines a new type called "Foo", and  makes a new variable of that type
p8458
aVNow we can add some magic to the type "Foo":
p8459
aVThe keywords  and  almost mean the same thing, so we still have a compound type that has two member variables,  and
p8460
aVHowever, this type also has a member function, and this one gets called every time you create a new Foo object
p8461
aVSo when you say, , then this variable's member value  will be set to 20 and  will be set to 0
p8462
ag97
aVSo that's that in a nutshell: Classes are types with built-in magic
p8463
aVAnd you are the magician
p8464
as(dp8465
g28
V596781
p8466
stp8467
a((dp8468
g2
(lp8469
VYou are overwriting the  variable that controls the loop within the loop
p8470
aVThat's not good
p8471
aVThe database resource contains a cursor that you must consume fully or otherwise dispose of, just overwriting it with a new result may not get you the expected results (or indeed get you a runtime error)
p8472
aVJust use a different variable for the query inside the loop
p8473
as(dp8474
g28
V596781
p8475
stp8476
a((dp8477
g2
(lp8478
VDon't trouble yourself with any such worries and return an :
p8479
aVThen, in your C interface, use:
p8480
aVI would even make the argument of the function  and extract the C-string only when calling the API function
p8481
aVThe  version includes all characters, the  version treats the buffer as a null-terminated string
p8482
aVPick whichever is most appropriate
p8483
as(dp8484
g28
V596781
p8485
stp8486
a((dp8487
g2
(lp8488
VThey're certainly not synonymous, and if you've been reading that, it's time to change the book
p8489
aV:-)
p8490
aVClasses are types, while objects are instances
p8491
aVA simple example is an integer
p8492
aV"Integer" denotes the type, but an integer  is an instance of that type
p8493
aVIn PHP there isn't a strong type system, so this may not be entirely apparent, but I hope you get the idea
p8494
aVSimilarly,  is a type, but  creates an instance (called ) of array type
p8495
aVWith classes, you cannot just say  as you do with arrays, instead, you have to use :
p8496
as(dp8497
g28
V596781
p8498
stp8499
a((dp8500
g2
(lp8501
VA map comes to mind
p8502
aVYou can store the scores directly, or you can make one map to look up the card type and other maps to associate other information (like score) to each card
p8503
aVHere's the baby example:
p8504
aVOftentimes when your heart says "switch", your brain should say "map" :-)
p8505
aVPersonnally I'd define an  and have one map be , and then other maps from card type to secondary information like scores
p8506
as(dp8507
g28
V596781
p8508
stp8509
a((dp8510
g2
(lp8511
V is an rvalue (of type ), because it's a temporary
p8512
aVIt's a pointer, but you cannot modify it, because it's just created on the fly
p8513
aVYour function  however requires a non-const reference, so you cannot pass it a temporary
p8514
aVBy contrast,  is a named variable, thus an lvalue, so it can be passed as a non-constant reference
p8515
as(dp8516
g28
V596781
p8517
stp8518
a((dp8519
g2
(lp8520
VDon't put apostrophes around the field name:
p8521
aVInside quoted strings, you cannot use additional quotation marks for array field names
p8522
aVThere's an alternative, more elaborate syntax involving braces if you have a very complicated array expression, but you don't need that here
p8523
as(dp8524
g28
V596781
p8525
stp8526
a((dp8527
g2
(lp8528
VRemember that there are different types of containers: Contiguous vs node-based, and sequential vs associative
p8529
aVNode-based containers allow efficient erase/insert
p8530
aVSequential containers organize elements by insertion order (i
p8531
ag598
aVposition), while associative containers arrange them by (key) value
p8532
aVAll current associative containers (map/set/unordered) are node-based, and with them you can erase elements directly, and you should use the element-wise member  function directly
p8533
aVLists are node-based sequence containers, so you can erase individual elements efficiently, but finding an element by value takes linear time, which is why lists offer a member  function
p8534
aVOnly sequence containers (vector and deque) have no easy way to erase elements by value, and that's where the free  algorithm comes in, which first rearranges the sequence to then allow the container's member  to perform an efficient erasure at the end of the container
p8535
aVUnlike the many generic aspects of the standard library which work without any knowledge of the underlying container, the copy/erase idiom is one of those things which require a bit of detail knowledge about the differences between the containers
p8536
as(dp8537
g28
V596781
p8538
stp8539
a((dp8540
g2
(lp8541
VYour description sounds like you need :
p8542
as(dp8543
g28
V596781
p8544
stp8545
a((dp8546
g2
(lp8547
VMy standard seeding technique:
p8548
aVIf  exists, read a seed from there
p8549
aVIf you're in Windows, use
p8550
aVIf all else fails, use
p8551
aV(Not sure where your Mersenne twister comes from, but there new standard library has one in  which integrates very elegantly
p8552
aVI'm happy to hear suggestions for platforms that aren't covered by the first two steps
p8553
as(dp8554
g28
V596781
p8555
stp8556
a((dp8557
g2
(lp8558
VThis is too convoluted
p8559
aVYou can simply destroy the object when you don't need it any more
p8560
aVAlso, the placement-new argument is already a void pointer, no need to cast
p8561
aVThis is very similar to what the standard library allocators do:
p8562
aVThere's no such thing as "restore"; you can create a new object in the memory that was erstwhile used by another object if you've properly destroyed that object
p8563
aVEdit: I added another construction method that makes a copy of a given object, in case your class isn't default-constructible
p8564
as(dp8565
g28
V596781
p8566
stp8567
a((dp8568
g2
(lp8569
VThe template parameter list doesn't work like that
p8570
aVTemplate parameters must be one of: type names, types (with restrictions), or templates
p8571
aVMaybe you mean to have a default type, like so
p8572
aVHere  defaults to a pointer-to-member-function, but you have to provide the complete signature including return type
p8573
aVOr do you mean for  to be a member typedef
p8574
aVOr as @jmihalicza suggests, you want a value parameter of type
p8575
as(dp8576
g28
V596781
p8577
stp8578
a((dp8579
g2
(lp8580
VIf the behaviour functions have no state and only take one  argument, then I'd go with a container of function objects:
p8581
aVNow you just need to load all your functions into the collection
p8582
as(dp8583
g28
V596781
p8584
stp8585
a((dp8586
g2
(lp8587
VThis can easily be answered by typing :
p8588
aVThe  child inherits copies of the parent's set of open file descriptors
p8589
aVThe entire virtual address space of the parent is replicated in the child"
p8590
aVBasically, the child process will be in the exact same state as the parent (but see the man page for a long list of exceptions to this vastly oversimplified statement)
p8591
aVHow is it implemented
p8592
aVWhat level of detail do you want
p8593
aVThe memory might be implemented as copy-on-write
p8594
aVBut that's not of your concern, the child process simply gets an exact copy of the entire memory
p8595
as(dp8596
g28
V596781
p8597
stp8598
a((dp8599
g2
(lp8600
VI had written this answer earlier but then reconsidered, since I hadn't heard of the DPAPI before
p8601
aVHowever, upon some further consideration, I'd like to offer the following opinion
p8602
aVThe important preface here is that it all depends on your needs, though
p8603
aVTwo conflicting possibilities come to mind:
p8604
aVYou want to offer your user complete protection and encryption that the user can trust only she will be able to decrypt, no matter the circumstances
p8605
aVYou're an enterprise IT manager and have all employees on a tight leash
p8606
aVYou want them to encrypt business data as part of their workflow so that they cannot see each other's data, but the admins can happily read everyone's data
p8607
aVIf you're in situation (2), then stop reading now and go with DPAPI, which is well suited to that case
p8608
aVIf you prefer scenario (1), then read my original answer below
p8609
aVThat's probably not a good idea
p8610
aVHere's why:
p8611
aVThe actual password will not be stored on the system (unless you have Windows 3
p8612
aV11 or something like that)
p8613
aVInstead, only a hash of the password will be stored, and at login time the password that the user enters is hashed and compared to the stored hash
p8614
aVSo at best you could retrieve the stored hash from the system (if you have admin rights, say)
p8615
aVHowever, if that's the only datum you can go on, then any encryption key you make will be derived from that hash, rather than from the actual password
p8616
aVThus anyone with access to the system could get to the stored hash, and from there derive the encryption key with relative ease
p8617
aVIn short, don't
p8618
aVAsk the user for a dedicated, fresh password for your data and use it for only that
p8619
as(dp8620
g28
V596781
p8621
stp8622
a((dp8623
g2
(lp8624
VYou're misunderstanding
p8625
aVWhat you do need is some valid set of credentials for the SMTP server that tells the server that you are in fact authorized to use it
p8626
aVOnce you're authenticated and authorized, you can use the SMTP server to send email to anyone
p8627
aVSMTP servers used to be completely freely available to anyone, but because of rampant abuse for sending unsolicited emails, many big SMTP servers have started admitting only registered users
p8628
aVFor GMail, you would supply your own account details
p8629
aVOr, you could just look for a different SMTP server that doesn't require authentication
p8630
aVYour web host would typically provide you with one
p8631
as(dp8632
g28
V596781
p8633
stp8634
a((dp8635
g2
(lp8636
VA simple aggregate query:
p8637
as(dp8638
g28
V596781
p8639
stp8640
a((dp8641
g2
(lp8642
VSince you're in C++, do it the C++ way:
p8643
as(dp8644
g28
V596781
p8645
stp8646
a((dp8647
g2
(lp8648
VThat depends on a million different factors and is entirely platform and compiler and settings dependent
p8649
aVThe object file has to contain all the assembly for function bodies for functions with external linkage, as well as all the global variables with external linkage
p8650
aVAnything with internal linkage may or may not warrant a separate entry in the object file, as those may have been optimized out and integrated directly into their call site
p8651
aVThis depends heavily on the optimization settings
p8652
aVGCC also has an option for "link time optimizations" which essentially adds a copy of the entire source code to the object file and increases its size dramatically
p8653
aVDebug symbols also add a lot of extra data
p8654
aVFor your C++-specific question: A class definition itself isn't really visible in the assembly
p8655
aVNon-inlined member functions are just more functions that have to be compiled, while data members are just treated the same as primitive data members - they'll be on the call stack if you declare instances of that type, but they don't directly impact the assembly code
p8656
aVunless you're initializing things with constants; constants do go into the code, of course
p8657
as(dp8658
g28
V596781
p8659
stp8660
a((dp8661
g2
(lp8662
VOne important reason for using pools is that they make for a much simpler allocation scheme than a general-purpose allocator
p8663
aVSince all objects have the same size, there's no fragmentation, and you just need to maintain a free list
p8664
aVFor a new allocation, you try to pop off the top of the free list, or if the list is empty you increment the high watermark, done
p8665
aV(You can implement the free list in O(1) space inside the pool memory itself
p8666
aVHowever, the use of pools is highly situational, and whether there's any benefit depends very much on your actual code path and allocation requirements
p8667
aVThe modern standard allocator is already very good with many short-lived fixed-size allocations, so you really need to profile and check
p8668
as(dp8669
g28
V596781
p8670
stp8671
a((dp8672
g2
(lp8673
VOnly seed the PRNG once
p8674
aVThe statistical properties of the generated sequence are only guaranteed after the seed
p8675
aVIf you reseed every time, the resulting sequence may not have any predictable statistical properties
p8676
aVFor instance, consider a PRNG which always returns the seed value itself as the first number in the sequence, but which is perfectly uniform over its range
p8677
aVThis constitutes a great PRNG, as long as you don't use the first number
p8678
aVHowever, if you reseed it before every use, say to an incrementing counter value, you have no randomness at all
p8679
as(dp8680
g28
V596781
p8681
stp8682
a((dp8683
g2
(lp8684
VStep 1: Create an alphabet,
p8685
aVStep 2: Create a random number, , or use
p8686
aVStep 3: Get the appropriate index in the alphabet:
p8687
aVRinse and repeat steps 2 and 3 for as many times as you need characters
p8688
aVIf you want strong statistical properties (like uniformness), you should work a little harder with the random number, but this should get you started
p8689
aV(I think the statistical properties of that should be sufficient
p8690
aVOK, might as well spell it out:
p8691
aVAnd here's the version that takes a custom alphabet:
p8692
aVExample: 10 random odd digits:
p8693
as(dp8694
g28
V596781
p8695
stp8696
a((dp8697
g2
(lp8698
VThere's no "ranking" among the two conversions; both are equally good and hence the overload is ambiguous
p8699
aVThat's a core part of the language that you cannot change
p8700
aVHowever, you can just specify which overload you want by making the conversion explicit:
p8701
as(dp8702
g28
V596781
p8703
stp8704
a((dp8705
g2
(lp8706
VThe singleton patterns is commonly considered Bad Practice, so empirical evidence (what you "see most") is of little value in this case
p8707
aVThe first version uses dynamic allocation, while the second one uses static allocation
p8708
aVThat is, the second allocation cannot fail, while the first one could possibly throw an exception
p8709
aVThere are pros and cons to both versions, but generally you should try for a different design that doesn't require singletons at all
p8710
as(dp8711
g28
V596781
p8712
stp8713
a((dp8714
g2
(lp8715
VUse a simple recursive algorithm: For the set of all subsets of size  from a set of size ,
p8716
aVif , return a set containing the entire set;
p8717
aVif  return the set of all singletons;
p8718
aVotherwise remove an element  from the set: now you need all the subsets of size  of the remaining set (i
p8719
ag598
aVthose subsets which include ), as well as all the subsets of size  of the remaining set (those which don't include )
p8720
aVIn PHP pseudo-code:
p8721
aVHere  adds  to each array in the collection:
p8722
as(dp8723
g28
V596781
p8724
stp8725
a((dp8726
g2
(lp8727
VYou have to define the static data members as well as declaring them
p8728
aVIn your implementation Student
p8729
aVcpp, add the following definitions:
p8730
as(dp8731
g28
V596781
p8732
stp8733
a((dp8734
g2
(lp8735
VOnly compile-time constants can be used as array sizes
p8736
aVDeclare your integer as
p8737
aVAlso, the (default) value needs to go in the declaration, not the definition:
p8738
aVBased on your comment, consider this: At the moment, you are effectively using a global variable to communicate some dynamic quantity
p8739
aVThis should ring alarm bells:
p8740
aVThis is terrible design, for a whole range of reasons
p8741
aVInstead, you should make the relevant size part of the class:
p8742
aVNow you can communicate the desired size locally:
p8743
as(dp8744
g28
V596781
p8745
stp8746
a((dp8747
g2
(lp8748
VYes, in  you have  and
p8749
aVI've previously posted some code on how to use this, maybe that's helpful
p8750
aVMake sure you run the function twice, once to get the length and once to do the actual conversion
p8751
aV(Here's a little discussion of what the functions mean
p8752
aVInstead of the manual char array, I would probably prefer a  or , coming to think of it
p8753
aVNote that  has nothing to do with Unicode
p8754
aVIf you need Unicode, you need to further convert from  to Unicode using a separate library (like ), and don't use  as the data type for Unicode codepoints
p8755
aVInstead, use  on legacy systems or  on modern ones
p8756
as(dp8757
g28
V596781
p8758
stp8759
a((dp8760
g2
(lp8761
VI'm not sure if all this talk of "heap" and "stack" is cutting to the core of the language, so let me try something more language-intrinsic
p8762
aVYour first version uses only automatic allocation, which means that all variables have automatic lifetime
p8763
aVThat is, all variables end their life at the end of their enclosing scope:  creates a local variable of type  and returns a copy of that variable; the  function declares a local variable of the same type and assigns to it the result of the function call
p8764
aVAt the end of each scope, the local variables end as well
p8765
aVThe second version uses dynamic or manual allocation
p8766
aVYou explicitly allocate storage for a  variable with the  call, and that storage will remain allocated until someone deallocates is (via )
p8767
aVSince you never deallocate it, this is in effect a memory leak
p8768
aVThe fundamental difference is one of lifetime and responsibility
p8769
aVA few pros and cons: Automatic allocation means that responsibility is local, and you generally don't have to worry about anything
p8770
aVHowever, it comes at the price of having to copy arguments and return values by value, which may be expensive or undesirable
p8771
aVManual allocation allows you to refer to large amounts of memory via a simple, cheap pointer, and is often the only way to implement certain constructions, but carries the burden of having the author remember who's responsible for which resource
p8772
as(dp8773
g28
V596781
p8774
stp8775
a((dp8776
g2
(lp8777
VWhen you say "initialize" you really mean two separate things: Allocation and construction
p8778
aVAllocation is the process of obtaining memory for the object; construction is the process of putting bringing the object itself to life
p8779
aVAs you observe rightly, your interface class requires no memory
p8780
aVBut that's not the point
p8781
aVAn abstract class cannot be constructed because it is
p8782
aVwell, abstract
p8783
aVThere is no object of abstract type
p8784
aVAnd interfaces are abstract
p8785
aVThink of a Mercedes being an abstract Car
p8786
aVYou can buy a Mercedes, but you cannot buy an abstract car - it doesn't make semantic sense
p8787
aVAny car you could conceivably have has to be of a concrete type
p8788
aVEdit: It might be useful to contemplate why a class may be abstract:
p8789
aVBecause it is declared
p8790
aVThis makes it abstract flat-out by decree, no reason given
p8791
aVBecause it has abstract member functions: The member function isn't implemented, and a concrete, derived class must provide the implementation
p8792
aVBecause it is declared : This is morally equivalent to "all member functions are abstract, and there are no member objects"
p8793
aV(Having a separate keyword for this allows interfaces to circumvent the limitations of single inheritance
p8794
as(dp8795
g28
V596781
p8796
stp8797
a((dp8798
g2
(lp8799
VWith a lambda:
p8800
aV(If the value is fixed you can put it directly inside the lambda body
p8801
aVWith a predicate:
p8802
as(dp8803
g28
V596781
p8804
stp8805
a((dp8806
g2
(lp8807
VMy original answer seems to be completely wrong
p8808
aVCheck that you have include guards in all your header files so you don't end up with an infinite inclusion chain
p8809
aVThen include the headers in each implementation:
p8810
aVPlease note that such a construction creates the curious design situation where any consumer of either  or  who wished to call the operator must always include both  and , which is very granular, but also a bit unexpected
p8811
aVIt might be worthwhile adding an intermediate header file for use by the client which includes both header files, or to add mutual inclusions (with guards
p8812
aVto the header files themselves
p8813
aVYou cannot resolve this in the way you wrote it, because you have a flat-out recursive infinite dependence
p8814
aVThe way you usually do this is to pass the arguments by reference rather than by copy, since passing by reference does not require knowledge of the complete type:
p8815
as(dp8816
g28
V596781
p8817
stp8818
a((dp8819
g2
(lp8820
VYou can preface your output function with  to skip unset variables and empty strings
p8821
as(dp8822
g28
V596781
p8823
stp8824
a((dp8825
g2
(lp8826
VLike this:
p8827
aVThe comma separates the dimensions,  means "entire range", and square brackets make a list
p8828
as(dp8829
g28
V596781
p8830
stp8831
a((dp8832
g2
(lp8833
VIf I understand your needs right, then maybe having a little success flag makes the code more readable:
p8834
as(dp8835
g28
V596781
p8836
stp8837
a((dp8838
g2
(lp8839
VAll of this can be summarized by saying that "a subclass has to behave as if it was a superclass"
p8840
aVSo if  extends  and I have an object  of type , then I want it to behave exactly as if it were of type
p8841
aVSo if  returns some type , and  returns a type , then I want to be able to treat  as an , so  better be the same as or a subclass of
p8842
aVSimilarly,  should only throw exceptions that  promises
p8843
aVIt can't start throwing new, unexpected exceptions
p8844
aVIf  is public, then so should  be
p8845
aVYou can't suddenly have a tighter restriction on the derived class, because the base class promised me that it was public
p8846
aVAlways think of inheritance as "behaves like the super class", or "can be treated like the superclass", and all this should be clear
p8847
as(dp8848
g28
V596781
p8849
stp8850
a((dp8851
g2
(lp8852
VWell, as it says in the description, the first version adds a predictive element to the construction, telling the compiler that the  branch is the more likely one - that is, it's the branch that will be taken more often by your program
p8853
aVWith that in mind, the compiler can optimize the conditional so that it requires the least amount of work when the expected condition holds, at the expense of maybe having to do more work in case of the unexpected condition
p8854
aVTake a look at how conditionals are implemented during the compilation phase, and also in the resulting assembly, to see how one branch may be less work than the other
p8855
aVHowever, I would only expect this optimization to have noticeable effect if the conditional in question is part of a tight inner loop that gets called a lot, since the difference in the resulting code is relatively small
p8856
aVAnd if you optimize it the wrong way round, you may well decrease your performance
p8857
as(dp8858
g28
V596781
p8859
stp8860
a((dp8861
g2
(lp8862
VAre you asking how to use
p8863
aVHere's a basic skeleton:
p8864
aVYou have to check the actual key size and IV size with  and  and provide suitable key and IV data
p8865
aVEdit: Because it's so simple, here's an algorithm to add and strip PCKS7 padding:
p8866
aV(Library-grade code would of course test that  can be represented by a , and that during stripping the input string is non-empty and the padding is valid
p8867
as(dp8868
g28
V596781
p8869
stp8870
a((dp8871
g2
(lp8872
VNo difference
p8873
aVThe latter is the correct C++ syntax; the former is permissible as a legacy variant for recovering C programmers
p8874
aVNote that  and  are essentially the same and both define a class, so there's no special treatment for C-style POD structs in C++
p8875
aV[Edit: Apparently there is a small difference, see Mark B's excellent answer
p8876
as(dp8877
g28
V596781
p8878
stp8879
a((dp8880
g2
(lp8881
VYou got your types mixed up in your inexplicable attempt to create this monster under the pretence of writing "C++"
p8882
aVAnyway
p8883
aVwhat you're mallocing is nothing but a , so you need to cast  back to :
p8884
as(dp8885
g28
V596781
p8886
stp8887
a((dp8888
g2
(lp8889
VFrom the standard: If you do not write any constructors, a default constructor will be provided for you, and this default constructor is defined inline and equivalent to an empty constructor
p8890
aVI'm pretty sure that [edit]your thus inlined constructor will not actually result in any machine code at all
p8891
as(dp8892
g28
V596781
p8893
stp8894
a((dp8895
g2
(lp8896
VThe translation unit consists of everything that comes out of the preprocessor
p8897
aVIn gcc, try  to see what that is
p8898
aVStatic globals have, well, static linkage, so their name does not spill outside the TU
p8899
aVIn each separate TU, the static global (whether of the same name or not) will be a separate object, local to that TU only
p8900
as(dp8901
g28
V596781
p8902
stp8903
a((dp8904
g2
(lp8905
VThe  loops should go like this:
p8906
aVThe  and input operations return the stream object, which itself has a specialized conversion to bool that indicates whether the operation succeeded, and it will fail precisely when you've reached the end of the respective stream
p8907
as(dp8908
g28
V596781
p8909
stp8910
a((dp8911
g2
(lp8912
VYou call it ike this:
p8913
aVThe first set of parentheses are needed because of the precedence of "apply function call" over the dereference-PTM  operator
p8914
aVYou can also use :
p8915
as(dp8916
g28
V596781
p8917
stp8918
a((dp8919
g2
(lp8920
VYour abortive attempt to write a clean constructor  in the second part of the question highlights the awkwardness of a design that takes too much responsibility in one class
p8921
aVIf you use only single-responsibility components, you can often get away with not writing any explicit error checks at all and let the exception handling mechanism do its work, recursively
p8922
aVConsider this:
p8923
aVAs you can see, writing a correct constructor for a class that has even just three different responsibilities is a maintenance nightmare
p8924
aVThe correct solution is to make each resource owned by a wrapper class whose only responsibility is to own that resource, and clean-up happens automagically even in the face of the most exceptional exception
p8925
aVAlso note that you have to be extremely careful when calling member functions from within any constructor
p8926
aVAn object's lifetime doesn't begin until after a constructor has finished, so while you're in the constructor you're working with an "object under construction" - a bit like open-heart surgery
p8927
aVon yourself
p8928
aVIn particular, you mustn't call the destructor, because you are only allowed to destroy complete objects
p8929
as(dp8930
g28
V596781
p8931
stp8932
a((dp8933
g2
(lp8934
VYou can just return such an object by copy, unless you have good reason do avoid this design:
p8935
aVIf you'd rather handle the object by pointer, use  instead:
p8936
aVOr, if you just need one handler object, use
p8937
aVA bit of explanation: Having a constant member in your object essentially means that the object itself has the semantics of a constant object
p8938
aVIt is OK to copy constants, but not to reassign them, so in your typical use case you would only create an object of this class once and not reassign it
p8939
aVA copy constructor is automatically defined for you, so you can go straight ahead and say:
p8940
aVClearly you cannot and would not say , because your  is semantically a constant thing for which reassignment doesn't make sense
p8941
as(dp8942
g28
V596781
p8943
stp8944
a((dp8945
g2
(lp8946
VThere's no loop in your function
p8947
aVIt should be something like:
p8948
aVI'm surprised your current version only takes the last number, it should only take the first number, since  is the same as
p8949
aVA better solution uses idiomatic C++:
p8950
as(dp8951
g28
V596781
p8952
stp8953
a((dp8954
g2
(lp8955
VCheck out the Bash variable : if it is set, the timestamp will be saved with the history entry
p8956
aVIf you unset this variable (e
p8957
ag99
aVin your  or ), the timestamp should disappear entirely
p8958
as(dp8959
g28
V596781
p8960
stp8961
a((dp8962
g2
(lp8963
VYou should invoke  with a , not a  as you do:
p8964
aVAlso, the length is wrong, as  is just be the size of the pointer, not the string; if anything you need
p8965
aVBut this is still going to be wrong in general because you need your message to be a multiple of the block size
p8966
aVUse the padding function:
p8967
aVBy the way, your plaintext should be declared like this:
p8968
aVBut why so clumsy, it's better to just use a string:
p8969
aVI think you might benefit from picking up a good C++ book and familiarizing yourself with the basics of the language a bit - it's good to have a project to work on, but most of your problems aren't really related to encryption or mcrypt, but just general C++ programming
p8970
as(dp8971
g28
V596781
p8972
stp8973
a((dp8974
g2
(lp8975
VAn array in C is a very fragile type
p8976
aVThere are many situations in which an array decays to a pointer to the first element, and passing an array as an argument of a function is such a situation
p8977
aVBehold:
p8978
aVArrays are peculiar in C in the sense that they cannot be passed as function arguments or returned from functions, so you will frequently see pointers when you expect arrays
p8979
aVIt is the responsibility of the caller (you
p8980
aVto provide enough information to interpret a pointer as an array correctly
p8981
aVNote that a common C idiom creates an "array" dynamically entirely without ever mentioning an array type:  Here  is never anything but a pointer, and it is entirely up to you to remember that you can treat it as an array
p8982
aV(The situation is a little better in C++, where you can pass actual arrays by reference
p8983
as(dp8984
g28
V596781
p8985
stp8986
a((dp8987
g2
(lp8988
VNot sure I want to dig through this code, but since you tagged this as C++, I recommend The C++ Way of doing this:
p8989
aVThere's no manual memory allocation, no forgetting to clean up, and it's fairly self-descriptive
p8990
aV(If the array  comes as a pointer without size information, you have to pass the size information separately and use that in place of
p8991
as(dp8992
g28
V596781
p8993
stp8994
a((dp8995
g2
(lp8996
VYour  is an array, not a pointer
p8997
aVSince you want it to track dynamically allocated memory, it has to be a pointer:
p8998
aVJust don't forget to initialize it with  (or by setting it to zero before ) and to clean up after yourself
p8999
aVBy the way, do not cast the result of  and co
p9000
as(dp9001
g28
V596781
p9002
stp9003
a((dp9004
g2
(lp9005
VThe way you use , you remove objects by value, not by position
p9006
aVSay your list consists of values , and you remove  and  the first two times
p9007
aVNow you have , whose size is 2, so you will never remove  now
p9008
aVTo remove by position rather than value, say
p9009
aV(Notice that  is an integer, while  is an object of the type contained in the list container
p9010
aV(Alternatively, for different behaviour, you could continue removing by value, but you should now draw the random number from the range , where you have to determine the extremal values of the list elements separately
p9011
aVThis may take a lot longer, of course, since you will have a lot of "misses" where you don't remove anything
p9012
as(dp9013
g28
V596781
p9014
stp9015
a((dp9016
g2
(lp9017
VYour  will write an  into the memory location you give it
p9018
aVTypically, an unsigned int is 4 or 8 bytes long, while you only intend to provide 1 byte
p9019
aVSo at the end you're running flat-out over the end of your dynamic array
p9020
aVBy the way, your code is very far removed from modern, idiomatic C++ - it's essentially just a glorified C mess
p9021
aVI strongly suggest rewriting it in the spirit of C++
p9022
as(dp9023
g28
V596781
p9024
stp9025
a((dp9026
g2
(lp9027
VYour  is a pointer to a constant, immutable, read-only array
p9028
aVYou cannot  into it, because the  functions want to write into the destination buffer, appending data at the end
p9029
aVInstead, create a mutable recipient buffer:
p9030
aV(Update: Apparently there's also a templated overload of this function that recognizes static arrays:
p9031
aVNeat
p9032
as(dp9033
g28
V596781
p9034
stp9035
a((dp9036
g2
(lp9037
VLike this:
p9038
aVBe sure that everything is properly escaped for the SQL query
p9039
as(dp9040
g28
V596781
p9041
stp9042
a((dp9043
g2
(lp9044
VLet's break it down
p9045
aVSuppose there's some  somewhere
p9046
aVNow we make this a static member of our class,
p9047
aVNow in essence that declares a global object  -- so how does this get instantiated
p9048
aVThe standard tells you: it gets default-constructed
p9049
aVBut remember that you have to provide the actual object instance in one of your translation units:
p9050
aVNow suppose that  doesn't actually have a default constructor:
p9051
aVNow there's a problem: How do we construct
p9052
aVThe answer is "just like above", but now we have to call a specific constructor:
p9053
aVThe standard actually has two distinct notions of "initialization" (a grammatical concept) and "construction" (a function call), but I don't think we need to go into this just now
p9054
as(dp9055
g28
V596781
p9056
stp9057
a((dp9058
g2
(lp9059
VI'd simply add the month to the query, order the query by date, and then track the month during the output phase and insert a new heading every time the month changes:
p9060
aVIn the PHP:
p9061
as(dp9062
g28
V596781
p9063
stp9064
a((dp9065
g2
(lp9066
VScott Meyers explains it this way:
p9067
aV:  " provides the interface "
p9068
aV: " is implemented using "
p9069
aV(Protected inheritance isn't all that useful
p9070
aVA protected constructor/destructor are useful for classes that you wish to use only in the second way, i
p9071
ag598
aVin order to provide implementations for other classes
p9072
aVIn that case, only the derived class needs to call the constructor and destructor, which may thus be protected
p9073
aVA private constructor means that only the class itself can create instances of itself, which is popular for factory or creator patterns, where a static member function returns a pointer to an instance, but direct construction of class instances is not desired
p9074
as(dp9075
g28
V596781
p9076
stp9077
a((dp9078
g2
(lp9079
VYou're not saying how your  class is defined, but you may be confused about one thing: In your second, "inelegant" version,  is not necessarily a const string -- rather,  is a reference to a const string, and you assign the value of that to your member variable
p9080
aVNow, on to initializer lists: The entire point of those is that you get to specify which constructors of the member objects are called
p9081
aVWithout the list, all member objects have their default constructors called (or more accurately, they are default-initialized)
p9082
aVHowever, any object that you mention in the initializer list will have that constructor (or rather "initializer") called instead
p9083
aVThe initializer list isn't just mere decoration
p9084
aVIt is essential, because member objects and subobjects may not even be default-constructible, and so an initializer must be provided
p9085
aVThe const member is actually a very good example:
p9086
aVHere's another example, this time deriving from a base class that has no default constructor:
p9087
as(dp9088
g28
V596781
p9089
stp9090
a((dp9091
g2
(lp9092
VSure, just use a container and a loop:
p9093
aVI assume that  is a type that's convertible to a floating point number
p9094
aVYou pass a collection of positions as the second argument to the function
p9095
aVis the prototypical container in C++, but there are others to choose from if you have specific needs
p9096
as(dp9097
g28
V596781
p9098
stp9099
a((dp9100
g2
(lp9101
VYou can use ICU, but you may find  sufficient, which is a lot simpler to set up and operate (and it's part of Posix, and easily available for Windows)
p9102
aVWith either library, you have to convert your unicode string to a wide string
p9103
aVIn  that target is called
p9104
aVOnce you have a wide char, you can use it directly in Windows
p9105
aVIn Linux, you can either proceed to use  to transform the wide character into the system's (and locale's) narrow character multibyte encoding (don't forget ), or, alternatively, if you are sure that you want UTF-8 rather than the system's encoding, you can transform from your original string to UTF-8 directly (also with either library)
p9106
aVMaybe you'll find this post of mine to provide some background
p9107
as(dp9108
g28
V596781
p9109
stp9110
a((dp9111
g2
(lp9112
VPreferably:
p9113
aVArguably,  works as well and allows you to change the actual type of  without requiring you to modify two separate locations, but using the type rather than an expression in the initial allocation feels more readable and expressive
p9114
aVthat's subjective, though
p9115
aVIf you you want to keep your options open to change the type, I'd personally prefer factoring that change into the typedef rather than the variable declaration/initialization
p9116
as(dp9117
g28
V596781
p9118
stp9119
a.