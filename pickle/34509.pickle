(lp0
((dp1
S'text'
p2
(lp3
VThe  keyword has a number of good uses
p4
aVHere are the two uses immediately visible to me:
p5
aVFriend Definition
p6
aVFriend definition allows to define a function in class-scope, but the function will not be defined as a member function, but as a free function of the enclosing namespace, and won't be visible normally except for argument dependent lookup
p7
aVThat makes it especially useful for operator overloading:
p8
aVPrivate CRTP Base Class
p9
aVSometimes, you find the need that a policy needs access to the derived class:
p10
aVYou will find a non-contrived example for that in this answer
p11
aVAnother code using that is in this answer
p12
aVThe CRTP base casts its this pointer, to be able to access data-fields of the derived class using data-member-pointers
p13
as(dp14
S'author'
p15
V34509
p16
stp17
a((dp18
g2
(lp19
Vstd::bitset will give you extra points when you need to serialize / deserialize it
p20
aVYou can just write it to a stream or read from a stream with it
p21
aVBut certainly, the separate bools are going to be faster
p22
aVThey are optimized for this kind of use after all, while a bitset is optimized for space, and has still function calls involved
p23
aVIt will never be faster than separate bools
p24
aVBitset
p25
aVVery space efficient
p26
aVLess efficient due to bit fiddling
p27
aVProvides serialize / de-serialize with  and
p28
aVAll bits packed together: You will have the flags at one place
p29
aVSeparate bools
p30
aVVery fast
p31
aVBools are not packed together
p32
aVThey will be members somewhere
p33
aVDecide on the facts
p34
aVI, personally, would use  for some not-performance critical, and would use bools if I either have only a few bools (and thus it's quite overview-able), or if I need the extra performance
p35
as(dp36
g15
V34509
p37
stp38
a((dp39
g2
(lp40
VThere is a very rare use case of protected inheritance
p41
aVIt is where you want to make use of covariance:
p42
aVThe previous snippet tried to hide it's base class, and provide controlled visibility of bases and their functions, for whatever reason, by providing a "getBase" function
p43
aVHowever, it will fail in struct , since  does not know that  is derived from
p44
aVThus,  will not work
p45
aVA way out of this is deriving them protected, so that the inheritance is visible in d2
p46
aVA similar example of using this is when you derive from , but don't want random people to write into your stream
p47
aVYou can provide a virtual  function that returns
p48
aVThat function could do some preparing of the stream for the next operation
p49
aVFor example putting certain manipulators in
p50
as(dp51
g15
V34509
p52
stp53
a((dp54
g2
(lp55
VThere are two kinds of  swimming around
p56
aVInspection by iterating over members of a type, enumerating its methods and so on
p57
aVThis is not possible with C++
p58
aVInspection by checking whether a class-type (class, struct, union) has a method or nested type, is derived from another particular type
p59
aVThis kind of thing is possible with C++ using
p60
aVUse  for many things (like checking whether a type is integral)
p61
aVFor checking for the existance of a member function, use http://stackoverflow
p62
aVcom/questions/257288/possible-for-c-template-to-check-for-a-functions-existence#264088
p63
aVFor checking whether a certain nested type exists, use plain SFINAE
p64
aVIf you are rather looking for ways to accomplish 1), like looking how many methods a class has, or like getting the string representation of a class id, then i'm afraid there is no Standard C++ way of doing this
p65
aVYou have to use either
p66
aVA Meta Compiler like the Qt Meta Object Compiler which translates your code adding additional meta informations
p67
aVA Framework constisting of macros that allow you to add the required meta-informations
p68
aVYou would need to tell the framework all methods, the class-names, base-classes and everything it needs
p69
aVC++ is made with speed in mind
p70
aVIf you want high-level inspection, like C# or Java has, then I'm afraid i have to tell you there is no way without some effort
p71
as(dp72
g15
V34509
p73
stp74
a((dp75
g2
(lp76
Vhere is how you do it:
p77
aVYou can get  from my other answer where i told them how to check for a member function's existance in a class using templates
p78
aVor you can use boost, but remember to change  to  then
p79
as(dp80
g15
V34509
p81
stp82
a((dp83
g2
(lp84
VOthers have told you how to do it correctly
p85
aVBut I'm surprised no-one told you this code is actually dangerous:
p86
aVSince ButtonFunc is a parameter, it will go out of scope when the function returns
p87
aVYou are taking its address
p88
aVYou will get a value of type  (pointer to a pointer to a member function) and assign it to this->ButtonFunc
p89
aVAt the time you would try to use this->ButtonFunc you would try to access the storage of the (now not existing anymore) local parameter, and your program would probably crash
p90
aVI agree with Commodore's solution
p91
aVBut you have to change his line to
p92
aVsince ButtonObj is a pointer to object
p93
as(dp94
g15
V34509
p95
stp96
a((dp97
g2
(lp98
VI like to code with Emacs
p99
aVIt has a nice gui also for gdb
p100
aVI recently made a snapshot while i worked on some code snippet (see below, it doesn't look like 1980 at all :)
p101
aVThat said, there are a lot of other fine IDEs
p102
aVI like Eclipse for Java development, and heard it has a nice C++ plugin too (CDT)
p103
aVNetbeans also works for C++ since recently
p104
aVKDevelop, an IDE for KDE supporting many languages, is currently being rewritten for KDE4: KDevelop Blog
p105
aVLooks promising
p106
aVThen there are some others where i cannot tell you how they are since i've not tested them, including Anjuta (for the Gnome desktop) and Code::Blocks (written with wxWidgets it's quite cross-platform)
p107
aVIf all you want is a GUI for the compiler and a symbol browser, you could also use geany, which is very fast and includes an embedded terminal like KDevelop
p108
aVAll of these have their ups and downs
p109
aVBest try each out and then decide
p110
aVFrom the stability point of view, i've found Emacs is very stable and never crashes, Eclipse is also very mature
p111
aVNetbeans gets the third place
p112
aVIt sometimes hangs but overall it's also quite mature
p113
aVKDevelop likes(ed) to crash from time to time, but big progress was made in this regard
p114
aVEspecially version 3
p115
aV5 did make a big step forward and felt more mature than any version before
p116
aVEmacs editing some code:
p117
aVEmacs debug session:
p118
as(dp119
g15
V34509
p120
stp121
a((dp122
g2
(lp123
VI've done a turing machine in C++11
p124
aVFeatures that C++11 adds are not significant for the turing machine indeed
p125
aVIt just provides for arbitrary length rule lists using variadic templates, instead of using pervert macro metaprogramming :)
p126
aVThe names for the conditions are used to output a diagram on stdout
p127
aVi've removed that code to keep the sample short
p128
as(dp129
g15
V34509
p130
stp131
a((dp132
g2
(lp133
VThere seems to be confusion among the stackoverflow crowd concerning this
p134
aVis defined in the backward compatibility header
p135
aVIt's been part of  and  since their very beginning
p136
aVEvery C++ implementation has to ship with  (compatibility) and  where only the latter defines  and not necessarily
p137
aVSee Annex D of the C++ Standard
p138
as(dp139
g15
V34509
p140
stp141
a((dp142
g2
(lp143
VAnother interpretation of that term "true object orientation" is, that you can take some language that doesn't support OOP on its own, and stick an OOP way of doing things on-top of it
p144
aVFor example you can model encapsulation in C like
p145
aVTechniques for implementing inheritance and polymorphism has been in use a long time
p146
aVOne example is the  framework used as a basis for gtk+
p147
aVNow, while you can program in an object oriented manner, C doesn't support object orientation, but merely allows you to simulate it up to some degree
p148
aVSo you don't have true object orientation
p149
aVLooking at C++/Java/C#, you have support for all these kinds of things like inheritance/data encapsulation and stuff first hand
p150
as(dp151
g15
V34509
p152
stp153
a((dp154
g2
(lp155
VThe matter is easy
p156
aVIf the  does have invariants to guarantee, you should never make the members constraining the invariant public
p157
aVIf your  is merely an aggregate of different objects, and doesn't have an invariant to hold, you are indeed free and encouraged to put its members
p158
aVThat's the way  in C++ does it
p159
aVWhat's that invariant stuff
p160
aVSimple example: Consider you have a  class whose  members must always be
p161
aVYou can make an invariant stating
p162
aV/* x >= 0 && y >= 0 for this classes' objects
p163
aV*/
p164
aVIf you now make those members public, clients could simply change x and y, and your invariant could break easily
p165
aVIf the members, however, are allowed to contain all possible values fitting their own invariants respectively, you could of course just make those members public: You wouldn't add any protection to them anyway
p166
as(dp167
g15
V34509
p168
stp169
a((dp170
g2
(lp171
VC++ allows SFINAE to be used for this (notice that with C++11 features this is simplier because it supports extended SFINAE on nearly arbitrary expressions - the below was crafted to work with common C++03 compilers):
p172
aVthe above template and macro tries to instantiate a template, giving it a member function pointer type, and the actual member function pointer
p173
aVIf the types to not fit, SFINAE causes the template to be ignored
p174
aVUsage like this:
p175
aVBut note that you cannot just call that  function in that if branch
p176
aVsince the compiler will check for validity in both branches, that would fail for cases the function doesnt exist
p177
aVOne way is to use SFINAE once again (enable_if can be gotten from boost too):
p178
aVHave fun using it
p179
aVThe advantage of it is that it also works for overloaded member functions, and also for const member functions (remember using   as the member function pointer type then
p180
as(dp181
g15
V34509
p182
stp183
a((dp184
g2
(lp185
VWell, the answer is that passing a function by value yields a function pointer, the same way as passing an array by value yields a pointer to its first element
p186
aVone says that the array and the function "decay"
p187
aVthere are only a few occasions where that decay doesn't happen
p188
aVfor example sizeof(array) yields the sizeof the array, not the one of its first element pointer
p189
aVsizeof(function) is invalid (functions are no objects), you have to do sizeof(&function;)
p190
aVOther occasions are binding to references:
p191
aVThis, btw all is the reason you can do
p192
aVsince the array does not decay yet when considering reference parameters
p193
as(dp194
g15
V34509
p195
stp196
a((dp197
g2
(lp198
VHere is it:
p199
aVA reentrant function can be called simultaneously by multiple threads provided that each invocation of the function references unique data
p200
aVA thread-safe function can be called simultaneously by multiple threads when each invocation references shared data
p201
aVAll access to the shared data is serialized
p202
aVShamelessly stolen from the Qt manual
p203
aVBut it's a short and concise definition
p204
aVBasicially, a non-reentrant function is also not
p205
aVNow, what is a  function
p206
aVIt's a kind of definition of a function
p207
aVRecursive function are defined in terms of themself
p208
aVThey reduce input, call theirself, until a basic case can be figured out without the need of calling theirself again
p209
aVSo we have two things
p210
aVrecursive functions are a kind of definition
p211
aVreentrant functions are functions that guarantee multiple threads can call them, provided each time unique data is accessed
p212
aVNow, the multiple-threads vehicle above serves only the purpose of having multiple activations of the function at the same time
p213
aVBut if you have a recursive function, you also have multiple activations of that functions at the same time
p214
aVMost recursive functions therefor must be re-entrant too
p215
as(dp216
g15
V34509
p217
stp218
a((dp219
g2
(lp220
VIt's wrong to think that an unsigned char ranges from 0 to 255
p221
aVthat's only its minimal range
p222
aVa char must have at least 8 bits, and signed char, unsigned char and char itself can have indeed more that just 8 bits
p223
aVso then that means that unsigned char could go beyond 255
p224
aVthough admittedly, i haven't got an implementation where it had more than 8 bits, it theoretically is possible
p225
aVthat's specified in the c89 standard (on which c++03 bases), documenting file limits
p226
aVh (CHAR_BIT, UCHAR_MAX, CHAR_MAX)
p227
as(dp228
g15
V34509
p229
stp230
a((dp231
g2
(lp232
VYes, Evan Teran pointed out most things already
p233
aVOne thing i want to add (since i cannot comment his comment yet :)) is that you must put the call to istream::clear before the call to istream::ignore
p234
aVThe reason is that istream::ignore likewise will just refuse to do anything if the stream is still in the fail state
p235
as(dp236
g15
V34509
p237
stp238
a((dp239
g2
(lp240
VCode
p241
aVKeep the divisor variable
p242
as(dp243
g15
V34509
p244
stp245
a((dp246
g2
(lp247
VEdit: New article by Dave Abrahams on cpp-next: Want speed
p248
aVPass by value
p249
aVPass by value for structs where the copying is cheap has the additional advantage that the compiler may assume that the objects don't alias (are not the same objects)
p250
aVUsing pass-by-reference the compiler cannot assume that always
p251
aVSimple example:
p252
aVthe compiler can optimize it into
p253
aVsince it knows that f and g doesn't share the same location
p254
aVif g was a reference (foo &), the compiler couldn't have assumed that
p255
aVsince g
p256
aVi could then be aliased by f->i and have to have a value of 7
p257
aVso the compiler would have to re-fetch the new value of g
p258
aVi from memory
p259
aVFor more pratical rules, here is a good set of rules found in Move Constructors article (highly recommended reading)
p260
aVIf the function intends to change the argument as a side effect, take it by non-const reference
p261
aVIf the function doesn't modify its argument and the argument is of primitive type, take it by value
p262
aVOtherwise take it by const reference, except in the following cases
p263
aVIf the function would then need to make a copy of the const reference anyway, take it by value
p264
aVPrimitive" above means basically small data types that are a few bytes long and aren't polymorphic (iterators, function objects, etc
p265
aVor expensive to copy
p266
aVIn that paper, there is one other rule
p267
aVThe idea is that sometimes one wants to make a copy (in case the argument can't be modified), and sometimes one doesn't want (in case one wants to use the argument itself in the function if the argument was a temporary anyway, for example)
p268
aVThe paper explains in detail how that can be done
p269
aVIn C++1x that technique can be used natively with language support
p270
aVUntil then, i would go with the above rules
p271
aVExamples: To make a string uppercase and return the uppercase version, one should always pass by value: One has to take a copy of it anyway (one couldn't change the const reference directly) - so better make it as transparent as possible to the caller and make that copy early so that the caller can optimize as much as possible - as detailed in that paper:
p272
aVHowever, if you don't need to change the parameter anyway, take it by reference to const:
p273
aVHowever, if you the purpose of the parameter is to write something into the argument, then pass it by non-const reference
p274
as(dp275
g15
V34509
p276
stp277
a((dp278
g2
(lp279
VThe answer to your question is often, but not always
p280
aVIf your abstract class forbids clients to call delete on a pointer to it (or if it says so in its documentation), you are free to not declare a virtual destructor
p281
aVYou can forbid clients to call delete on a pointer to it by making its destructor protected
p282
aVWorking like this, it is perfectly safe and reasonable to omit a virtual destructor
p283
aVYou will eventually end up with no virtual method table, and end up signalling your clients your intention on making it non-deleteable through a pointer to it, so you have indeed reason not to declare it virtual in those cases
p284
aV[See item 4 in this article: http://www
p285
aVgotw
p286
aVca/publications/mill18
p287
aVhtm]
p288
as(dp289
g15
V34509
p290
stp291
a((dp292
g2
(lp293
VAs Kevin Haines points out, ints have the natural size suggested by the execution environment, which has to fit within INT_MIN and INT_MAX
p294
aVThe C89 standard states that  should be at least 2^16-1,  2^16-1 and  2^32-1
p295
aVThat makes a bit-count of at least 16 for short and int, and 32 for long
p296
aVFor char it states explicitly that it should have at least 8 bits ()
p297
aVC++ inherits those rules for the limits
p298
aVh file, so in C++ we have the same fundamental requirements for those values
p299
aVYou should however not derive from that that int is at least 2 byte
p300
aVTheoretically, char, int and long could all be 1 byte, in which case  must be at least 32
p301
aVJust remember that "byte" is always the size of a char, so if char is bigger, a byte is not only 8 bits any more
p302
as(dp303
g15
V34509
p304
stp305
a((dp306
g2
(lp307
VYou can do something like this:
p308
aVi hope it's helpful
p309
aVLine can be like this:
p310
aVnow that works only if the delimiter is a space
p311
aVyou can make it work with other delimiters too
p312
aVchange
p313
aVinto for example the following, if you want to have a semicolon:
p314
aVactually, it looks like you have only integers as values, and whitespace as delimiters
p315
aVyou might want to change
p316
aVinto this then:
p317
aVjust eats whitespace
p318
aVyou should change the type of props to
p319
aVthen too, and make Line accept int instead of std::string's
p320
aVi hope this is not too much information at once
p321
as(dp322
g15
V34509
p323
stp324
a((dp325
g2
(lp326
VThis is easy using awk
p327
aVReplace
p328
aVStart it using
p329
aVAppend
p330
aVInserts at the given position
p331
aVBy default, it appends at the end
p332
aVStart it using
p333
aVRemove duplicates
p334
aVThis one keeps the first occurences
p335
aVStart it like this:
p336
aVValidate whether all elements exist
p337
aVThe following will print an error message for all entries that are not existing in the filesystem, and return a nonzero value
p338
aVTo simply check whether all elements are paths and get a return code, you can also use :
p339
as(dp340
g15
V34509
p341
stp342
a((dp343
g2
(lp344
VShort answer
p345
aVGiven userMask is declared as
p346
aVthen  has type
p347
aVIt's a 2d array of pointers to int
p348
aVThe size of the outer dimension is 3, the size of the inner dimension is 4
p349
aVReally that is nothing more than a 3-element 1d array which element type is another 4-element 1d array which element type is
p350
aVSteps explained
p351
aVSo if you do
p352
aVthen essentially with the first two indices you pick the particular pointer out of the 2d array:
p353
aVthen you pick an int somewhere offset from that pointer by doing
p354
aVnow that code is all in
p355
aVValid C Code
p356
aVTo do it step by step with valid c code (don't worry if you don't understand everything yet in the following):
p357
aVDifference between Arrays and Pointers
p358
aVSo i think i show you something important
p359
aVThe array above does not contain pointers to arrays
p360
aVLets look how different they behave, which many c programmers don't expect:
p361
aVNow, what will happen if we do  and
p362
aVThe first will advance parray by  bytes (), the second will advance by only  bytes
p363
aVSo actually while the first gives you the correct array , the second will give you , which is somewhere we don't really want it to be
p364
aVBut grabbing the wrong offset is not all about it
p365
aVBecause it doesn't know an array is accessed, it will try to interpret what is at  as an
p366
aVSay your array was initialized with
p367
aVThen it will do the next index step based off address 0x00 (Doing  for example)
p368
aVOh noes - utterly undefined behavior
p369
aVSo it's really important to stress the difference
p370
aVConclusion
p371
aVThis was more than you asked for, but i think it's quite important to know these details
p372
aVEspecially if you want to pass 2d arrays to functions then this knowledge is really useful
p373
as(dp374
g15
V34509
p375
stp376
a((dp377
g2
(lp378
VThat's not possible
p379
aVYour code example
p380
aVis interpreted in the following way:
p381
aVIt does nothing
p382
aVThe comma operator makes it return the value of a (the right most operand)
p383
aVBecause assignment binds tighter, b = b is in parens
p384
aVThe proper way doing this is just
p385
aVBoost includes a tuple class with which you can do
p386
aVIt internally creates a tuple of references to a and b, and then assigned to them a tuple of b and a
p387
as(dp388
g15
V34509
p389
stp390
a((dp391
g2
(lp392
VRegarding your Question
p393
aVis a so-called cast operator
p394
aVif there is a need for conversion to , then that operator function is used to do the conversion
p395
aVin your example, cout uses your  to convert your x1 object using a user defined implicit conversion to a pointer, which is then output by ostream's (cout is of class std::ostream)  which takes a void*
p396
aVOther Problems
p397
aVTo help you figure out other problems, change the header file name from  to
p398
aVStandard C++ does not know
p399
aVThose files were called like that before C++ was made a Standard
p400
aVAlso, all C headers you use, like  are still valid in C++, but they are so-called backward-compatibility header files
p401
aVYou should include for example  and  instead
p402
aVThat will put all names that are not macros in C into the
p403
aVInstead of using  , you use
p404
aVLikewise for other identifiers too
p405
as(dp406
g15
V34509
p407
stp408
a((dp409
g2
(lp410
VAll at once
p411
as(dp412
g15
V34509
p413
stp414
a((dp415
g2
(lp416
VI don't know why you think  is bad
p417
aVYou can still recognize newlines
p418
as(dp419
g15
V34509
p420
stp421
a((dp422
g2
(lp423
VRepeat last command
p424
aVC-xz
p425
aVOnce you pressed it, just press only
p426
aVz
p427
aVafter that and it will repeat (without having to press C-x again)
p428
as(dp429
g15
V34509
p430
stp431
a((dp432
g2
(lp433
VSort the items according the group value (if it's a pointer, then you can use its address, otherwise lexicographical sort the string)
p434
aVThen loop through that sorted list, taking the first item of each group always
p435
aVThis takes approximately n + n * log(n)
p436
aVI think this is a reasonable alternative between the size of your executable and speed
p437
as(dp438
g15
V34509
p439
stp440
a((dp441
g2
(lp442
VIn C++ you basicially have the choice between iterating using iterators, or indices
p443
aVDepending on whether you have a plain array, or a std::vector, you use different techniques
p444
aVUsing std::vector
p445
aVUsing iterators
p446
aVC++ allows you to do this using
p447
aVUsing indices
p448
aVThe unsigned integral type returned by std::vector::size is not always std::size_t
p449
aVIt can be greater or less
p450
aVThis is crucial for the loop to work
p451
aVIt works, since unsigned integral types values are defined by means of modulo their count of bits
p452
aVThus, if you are setting , you end up at
p453
aVUsing Arrays
p454
aVUsing iterators
p455
aVWe are using std::reverse_iterator to do the iterating
p456
aVUsing indices
p457
aVWe can safely use std::size_t here, as opposed to above, since sizeof always returns std::size_t by definition
p458
aVAvoiding pitfalls with sizeof applied to pointers
p459
aVActually the above way of determining the size of an array sucks
p460
aVIf a is actually a pointer instead of an array (which happens quite often, and beginners will confuse it), it will silently fail
p461
aVA better way is to use the following, which will fail at compile time, if given a pointer:
p462
aVIt works by getting the size of the passed array first, and then declaring to return a reference to an array of type char of the same size
p463
aVchar is defined to have sizeof 1
p464
aVSo the returned array will have a sizeof of N * 1, which is what we are looking for, with only compile time evaluation and zero runtime overhead
p465
aVInstead of doing
p466
aVChange your code so that it now does
p467
as(dp468
g15
V34509
p469
stp470
a((dp471
g2
(lp472
VType-safe printf
p473
aVForwarding of arbitrary many constructor arguments in factory methods
p474
aVHaving arbitrary base-classes allows for putting and removing useful policies
p475
aVInitializing by moving heterogenous typed objects directly into a container by having a variadic template'd constructor
p476
aVHaving a literal operator that can calculate a value for a user defined literal (like "10110b")
p477
aVSample to 3:
p478
aVSample to 4:
p479
aVSample to 5:
p480
aVSee this example code: here
p481
as(dp482
g15
V34509
p483
stp484
a((dp485
g2
(lp486
VYou refer to the C++ Standard, chapter 3
p487
aV6
p488
aV1 paragraph 5:
p489
aVA return statement in main has the
p490
aVeffect of leaving the main function
p491
aV(destroying any objects with auto-
p492
aVmatic storage duration) and calling
p493
aVexit with the return value as the
p494
aVargument
p495
aVIf control reaches the end
p496
aVof main without encountering a return
p497
aVstatement, the effect is that of
p498
aVexecuting
p499
aVIf you haven't got the Standard at hand, you can show then the paragraph in a Working Draft
p500
aVHere is one for c++98, which already had this defined
p501
aVhttp://www
p502
aVkuzbass
p503
aVru:8086/docs/isocpp/basic
p504
aVhtml#basic
p505
aVstart
p506
aVmain
p507
as(dp508
g15
V34509
p509
stp510
a((dp511
g2
(lp512
VIn C (prior to C99), you don't have to declare functions in order to use them
p513
aVThe compiler will assume the function takes the promoted parameter types you pass to it, and assume the function returns an
p514
aVThis, however can be quite problematic, and behavior is undefined if the function doesn't
p515
aVLet's look at this:
p516
aVBecause the types are being promoted () if there is no declaration of the function at the time you call it, the arguments could not be passed at the right places in memory anymore
p517
aVAccessing b can yield to a curious value of the parameter
p518
aVAs a side node, the same problem occurs when you pass arguments to  like , or functions having no prototype (like , where there is no information about the parameters types and count)
p519
aVThis is the reason that you always have to access variadic arguments with  using their promoted type
p520
aVGCC will warn you if you don't
p521
aVAlways include the proper header files, so you don't run into this problems
p522
aVEdit: thanks to Chris for pointing out that  (like ) are always of type  in C
p523
as(dp524
g15
V34509
p525
stp526
a((dp527
g2
(lp528
VI've programmed a GCC backend for a toy processor of my professor (eco32)
p529
aVWhile trying to make  work, i uncovered a bug in my implementation of the NOT instruction, which GCC uses to implement C's ~ operator
p530
aVActually, one thing in that line of newlib really caught my attention, and i've not forgotten it yet:
p531
aV#define DETECTNULL(X) (((X) - 0x01010101) & ~(X) & 0x80808080)
p532
aVI hadn't known this works
p533
aVThey are checking for 4 possible null bytes in one word at the same time
p534
aVAmazing
p535
as(dp536
g15
V34509
p537
stp538
a((dp539
g2
(lp540
VI've learned the "method of least surprise"
p541
aVInstinctively, using enum is the right thing
p542
aVSo i would go for it
p543
aVI'm sure the Java makers think alike
p544
aVEdit: Excellent explanation of POLS: http://benpryor
p545
aVcom/blog/2006/06/29/api-design-the-principle-of-least-surprise/
p546
as(dp547
g15
V34509
p548
stp549
a((dp550
g2
(lp551
VIf you want to use C++ style comments merely because you want to comment out blocks, and get a headache about nesting /*
p552
aV*/, you can use this technique:
p553
aVwhich will actually also do the job
p554
as(dp555
g15
V34509
p556
stp557
a((dp558
g2
(lp559
VYou iterate through it using a normal loop with stream
p560
aVget(), and check whether the byte values you read are
p561
aVOne way of many ways to do it:
p562
aVHowever, as someone mentioned, all files are binary files after all
p563
aVAdditionally, it's not clear what you mean by "ascii"
p564
aVIf you mean the character code, then indeed this is the way you go
p565
aVBut if you mean only alphanumeric values, you would need for another way to go
p566
as(dp567
g15
V34509
p568
stp569
a((dp570
g2
(lp571
VYou calc the modulo of  12345600 to 97 and add (97 - that + 1) to that number
p572
aVSo you get what RoBorg explained whay cleaner above :)
p573
as(dp574
g15
V34509
p575
stp576
a((dp577
g2
(lp578
VA process cannot protect or watch itself
p579
aVYour only possibility is to start up a second process as a kind of watchdog, which regularly checks the health of the decrypting other process
p580
aVIf the other process crashes, the watchdog will notice and delete the file itself
p581
aVYou can do that using hearth-beats (regular polling of the other process to see whether it's still alive), or using interrupts sent from the other process itself, which will trigger a timeout if it has crashed
p582
aVYou could use sockets to make the connection between the watchdog and your app work, for example
p583
aVIt's becoming clear that you need some locking mechanism to prevent swapping to the pagefile / swap-partition
p584
aVOn Posix Systems, this can be done by the
p585
as(dp586
g15
V34509
p587
stp588
a((dp589
g2
(lp590
VAs it crashes only sometimes, i bet it's a threading issue
p591
aVCheck all references to 'obj':
p592
aVgrep -R 'obj
p593
aV*='
p594
as(dp595
g15
V34509
p596
stp597
a((dp598
g2
(lp599
VDefinitely GCC Trunk
p600
aVConceptGCC misses many features GCC trunk has
p601
aVIt is being merged into GCC currently though
p602
aVIt has all these features, including the new -typed variables (no new function declaration syntax yet though): http://gcc
p603
aVgnu
p604
aVorg/projects/cxx0x
p605
aVhtml
p606
aVThere is a GCC branch containing partial lambda support, which also contains other C++0x features
p607
aVI would recommend you to try that one out too
p608
aVIt's in use on , you can experiment with it there
p609
as(dp610
g15
V34509
p611
stp612
a((dp613
g2
(lp614
VYou can use boost like this:
p615
aVI don't know a standard way to do this equally short and concise, but you can grab  it's all consisting of headers
p616
as(dp617
g15
V34509
p618
stp619
a((dp620
g2
(lp621
VFirst, you should not put anything into headers that is not needed to be visible by any other file, other than the one that needs it
p622
aVThen, let's define something we need below
p623
aVTranslation Unit
p624
aVA Translation Unit is the current code being compiled, and all the code included
p625
aVby it, directly or indirectly
p626
aVOne Translation unit translates to one
p627
aVo /
p628
aVobj file
p629
aVProgram
p630
aVThat's all your
p631
aVo /
p632
aVobj files linked together into one binary file that can be
p633
aVexecuted to form a process
p634
aVWhat are the main points of having different translation units
p635
aVReduce dependencies, so that if you change one method of one class, you don't have to recompile all the code of your program, but only the affected translation unit
p636
aVAn
p637
aVReduce possible name clashes by having translation unit local names, that are not visible by other translation unit when linking them together
p638
aVNow, how can you split your code into different translation units
p639
aVThe answer is there is no "so you do it
p640
aV, but you have to consider it on a case-by-case basis
p641
aVIt's often clear, since you have different classes, which can and should be put in different translation units:
p642
aVDeclare some free functions and objects:
p643
aVPlease note that names within an anonymous namespace (as above) do not clash since they appear to be translation unit local
p644
aVin reality they are not, they just have unique names so that they do not clash
p645
aVif you really want (there is little reason to) translation unit local names (for example because of compatibility with c so C code can call your function) you can do it like this:
p646
aVThe ODR also says that you cannot have more than one definition of any object or non-inline function in one program (classes are types, not objects, so it doesn't apply to them)
p647
aVSo you have to watch out not to put non-inline functions into headers, or not putting objects like "int foo;" in headers
p648
aVThat will cause linker errors then when the linker tries to link the translation units including those headers together
p649
aVI hope i could help you a bit
p650
aVNow that was a long answer, there are indeed errors somewhere
p651
aVI know that a translation unit strictly is defined another way (output of the pre-processor)
p652
aVBut i think it would not add big value to include that into the above, and it would confuse the matter
p653
aVPlease feel free to slap me if you find real bugs :)
p654
as(dp655
g15
V34509
p656
stp657
a((dp658
g2
(lp659
VHmm, that's an interesting Question
p660
aVMy bet is that this is not possible
p661
aVI think you have to continue using macros, and go with , or  in c++0x
p662
aVThe reason i think this is because the endian'nes is a property if your execution environment
p663
aVHowever, static_assert is considered at compile time
p664
aVI suggest you look into the code of the new GNU gold ELF linker
p665
aVIan Lance Taylor, its author, used templates to select the right endianness at compile time, to ensure optimal performance at run time
p666
aVHe explicitely instantiates all possible endians, so that he still has separate compilation (not all templates in headers) of the template definition and declaration
p667
aVHis code is excellent
p668
as(dp669
g15
V34509
p670
stp671
a((dp672
g2
(lp673
VThere is another point you have to consider:
p674
aVUsing inline functions, the compiler is able to see where variables of the caller are going to be used as variables in the callee
p675
aVThe compiler can optimize out (often this is really many assembler lines that can be omitted
p676
aVlook out for the so called "aliasing problem") redundant code based on that knowledge
p677
aVSo your "code bloat" is often not all that big, especially if you have smaller functions it can even reduce bloat as Jim stated above
p678
aVSomeone made a good point: Better make the compiler decide whether it inlines the function in question or not, since it knows the code it generates better than you ever would
p679
as(dp680
g15
V34509
p681
stp682
a((dp683
g2
(lp684
Vhttp://www
p685
aVboost
p686
aVorg/doc/libs/1_37_0/doc/html/thread
p687
aVhtml
p688
as(dp689
g15
V34509
p690
stp691
a((dp692
g2
(lp693
Vutf-8 and utf-16 are both "unicode" character encodings
p694
aVWhat you probably talk about is utf-32 which is a fixed-size character encoding
p695
aVMaybe searching for
p696
aVprovides you some results or other papers on this
p697
as(dp698
g15
V34509
p699
stp700
a((dp701
g2
(lp702
VThe  return  value from popen() is a normal standard I/O stream in all
p703
aVrespects save that it must be closed with pclose() rather than
p704
aVfclose(3)
p705
aVWriting to such a stream writes to the standard input of
p706
aVthe command; the command's standard output is the same as  that of the
p707
aVprocess that called popen(), unless this is altered by the command
p708
aVitself
p709
aVConversely, reading from a "popened" stream reads the
p710
aVcommand's standard output, and the command's standard input is the
p711
aVsame as that  of  the  process  that  called popen()
p712
aVFrom its manpage, so it allows you to read the commands standard output or write into its standard input
p713
aVIt doesn't say anything about stderr
p714
aVThus that is not redirected
p715
aVIf you provide "w", you will send your stuff to the stdin of the shell that is executed
p716
aVThus, doing
p717
aVWill make the shell execute /bin/cat, and pass it the string  as its standard input stream
p718
aVIf you want to redirect, for example stderr to the file  do this first, before you execute the code above:
p719
aVIt will open the file, and duplicate its file-descriptor to 2, closing the original file descriptor afterwards
p720
aVNow, if you have your stdout closed in your parent, then if the child calls  it will get 1, since that's (if stdin is already opened) the next free file-descriptor
p721
aVOnly solution i see is to just use dup2 and duplicate something into that in the parent, like the above code
p722
aVNote that if the child opens , it will not make  open in the parent too
p723
aVIt stays closed there
p724
as(dp725
g15
V34509
p726
stp727
a((dp728
g2
(lp729
VYou need to put  in front of that line, since the type you do ::iterator upon is dependant on the template-parameter T
p730
aVLike this:
p731
aVConsider the line
p732
aVwhich could mean a multiplication, or a pointer
p733
aVThat's why you need  to make your intention clear
p734
aVWithout it, the compiler assumes not a type, and thus it requires an operator there or a semicolon syntactically
p735
aVAlso consult the new C++ FAQ entry Where to put template and typename on dependent names
p736
as(dp737
g15
V34509
p738
stp739
a((dp740
g2
(lp741
VYes, you created a memory leak by that
p742
aVstd::vector and other containers will just remove the pointer, they won't free the memory the pointer points to
p743
aVIt's not unusual to put a pointer into a standard library container
p744
aVThe problem, however, is that you have to keep track of deleting it when removing it from the container
p745
aVA better, yet simple, way to do the above, is to use boost::shared_ptr:
p746
aVThe next C++ standard (called C++1x and C++0x commonly) will include
p747
aVThere, you will also be able to use  which is faster, as it doesn't allow copying
p748
aVUsing  with containers in c++0x is similar to the  library in boost
p749
as(dp750
g15
V34509
p751
stp752
a((dp753
g2
(lp754
VWell, the article in the answer above appeared in February 2002
p755
aVWhile it works, today we know there are better ways
p756
aVAlternatively, you can use :
p757
as(dp758
g15
V34509
p759
stp760
a((dp761
g2
(lp762
VBoost has a serialization library that can serialize into text files
p763
aVYou will, however, not be able to get around with now knowing what members the class contains
p764
aVYou would need reflection, which C++ does not have
p765
as(dp766
g15
V34509
p767
stp768
a((dp769
g2
(lp770
VHere, take a look at type_strings
p771
aVcpp it contains a function that does what you want
p772
aVIf you just look for a demangling tool, which you e
p773
aVg
p774
aVcould use to mangle stuff shown in a log file, take a look at , which comes with binutils
p775
aVIt can demangle C++ and Java symbol names
p776
as(dp777
g15
V34509
p778
stp779
a((dp780
g2
(lp781
VSwingWorker is an implementation of a common pattern (in
p782
aVNet i read there is GuiWorker BackgroundWorker for this), where you have to do some work in a GUI program, but keep the GUI responsive
p783
aVThe problem is that often GUI libraries are not multi thread safe, so the common way to implement such workers is to use the message loop of the library to transfer messages into the event loop of the application
p784
aVThese classes allow you to easily update your GUI
p785
aVUsually, they have a  method that is called by the thread, dispatched by the class, and handled by the GUI, while the thread continues its work
p786
aVUsing normal threads, you would need to code your own events or some other messaging mechanism for this task, which can be a pain if you need this functionality often
p787
aVUsing invokeLater in Java for example, you would intermix the code for updating the gui into the code for doing the work
p788
aVThe SwingWorker allows you to keep things separate
p789
as(dp790
g15
V34509
p791
stp792
a((dp793
g2
(lp794
VSolution: Use  to run in parallel (don't forget the  option
p795
as(dp796
g15
V34509
p797
stp798
a((dp799
g2
(lp800
VDon't use  on a stream in a -condition
p801
aVThe condition will evaluate to true only after an attempt to read past the end of the file has been made
p802
aVa better way is to do
p803
aVYour use of  is flawed
p804
aVI have no idea what it is used for
p805
aVOne time it is used as a type, but then another time you pass it to the  function as a value
p806
as(dp807
g15
V34509
p808
stp809
a((dp810
g2
(lp811
VYou can start objdump using the  option (like )
p812
aVIt will display the sourcecode intermixxed with the assembler code, if the source-files the code was compiled from are available
p813
aVAlternatively, you can use the following way:
p814
aVbecomes
p815
as(dp816
g15
V34509
p817
stp818
a((dp819
g2
(lp820
VI'm a fan of not initializing local variables
p821
aVThey should be set when needed
p822
aVOtherwise, programmers reading your code could be confused as in
p823
aVIf you don't initialize it, it's clear it's not used yet
p824
as(dp825
g15
V34509
p826
stp827
a((dp828
g2
(lp829
VThere is no definitive answer for me on this
p830
aVI do it on a case by case basis
p831
aVIf the function name is long, i definitely don't indent the other arguments to the same column as the previous arguments
p832
aVIf the function name is short, i usually indent following arguments to the same column, collecting as many arguments i can on one line (not one argument = one line)
p833
aVBut if there is some pleasing symmetry, like in
p834
aVi would probably break that rule, and have the same number of arguments on each line
p835
as(dp836
g15
V34509
p837
stp838
a((dp839
g2
(lp840
VThis is not possible in C++
p841
aVYou cannot directly initialize the array
p842
aVInstead you have to give it the size it will have (4 in your case), and you have to initialize the array in the constructor of DataProvider:
p843
aVNote that you have to give up on the const-ness of the pointers in the array, since you cannot directly initialize the array
p844
aVBut you need to later set the pointers to the right values, and thus the pointers need to be modifiable
p845
aVIf your values in the array are const nevertheless, the only way is to use a static array:
p846
aVHaving the static array means all objects will share that array
p847
aVThus you will have saved memory too
p848
as(dp849
g15
V34509
p850
stp851
a((dp852
g2
(lp853
VThe issue is that your printings are buffered
p854
aVimmediately before sleeping, call fflush(stdout); to flush the buffer
p855
as(dp856
g15
V34509
p857
stp858
a((dp859
g2
(lp860
VI've written some little code that allows you to initialize fields, without having to worry too much about whether your fields are going out of order with the initialization
p861
aVHere is how you use it in your own code:
p862
aVThe framework is below
p863
aVIt works using the lesser known data-member-pointers, which you can take from a class using the syntax
p864
as(dp865
g15
V34509
p866
stp867
a((dp868
g2
(lp869
VYou could also iterate through the components, comparing getText() to the key pressed
p870
aVAs someone else mentioned, anonymous classes can also access members of the outer class as well as local finals
p871
as(dp872
g15
V34509
p873
stp874
a((dp875
g2
(lp876
VRegular Expressions come to mind
p877
aVSomething like  with
p878
aVSubmatches will provide you with the digit values
p879
aVShouldn't be difficult to adopt to your other format with colons between numbers (see sep61
p880
aVmyopenid
p881
aVcom's answer)
p882
aVis among the fastest regex parsers out there
p883
as(dp884
g15
V34509
p885
stp886
a((dp887
g2
(lp888
VWhile i don't know a function that does this, you can surround each of your arguments with , and replace any  in the original argument by
p889
aVlike
p890
aVwill give a single argument to mplayer which is ' and which is allowed to contain strange things like  or
p891
aVNote the escaping before  above () is only to make it valid C++
p892
aVYou should consider using a function that accepts the arguments each separate, thus avoiding such issues
p893
aVWikipedia has a good article on this about the famous fork-and-exec pattern
p894
aVhttp://en
p895
aVwikipedia
p896
aVorg/wiki/Fork-exec
p897
as(dp898
g15
V34509
p899
stp900
a((dp901
g2
(lp902
VLambda Powa
p903
aVNot sure whether this is right (No C# programmer
p904
aVJust liking its lambda stuff)
p905
aVOk, so i think while the code is C++, why not keep it C++ and get lambda in
p906
aVHere it is how it looks for c++0x, being hopefully released as a Standard very soon :
p907
as(dp908
g15
V34509
p909
stp910
a((dp911
g2
(lp912
VThe order of destruction of automatic variables (that include "normal" local variables that you use in functions) is in the reverse order of their creation
p913
aVSo place the controllerSupervisor at the top
p914
aVOrder of destruction of globals is also in the reverse of their creation, which in turn depends on the order in which they are defined: Later defined objects are created later
p915
aVBut beware: Objects defined in different
p916
aVcpp files (translation units) are not guaranteed to created in any defined order
p917
aVI think you should consider using it how Mike recommended:
p918
aVCreation is done by using the singleton pattern (since initialization order of objects in different translation units are not defined) on first use, by returning a pointer to a function-static supervisor object
p919
aVThe supervisor is normally destructed (using the rules about destruction of statics in functions)
p920
aVcontrollers deregister using a static function of the supervisor
p921
aVThat one checks whether the supervisor is already destructed (checking a pointer for )
p922
aVIf it is, then nothing is done
p923
aVOtherwise the supervisor is notified
p924
aVSince i imagine there could be a supervisor without a controller being connected (and if only temporary), a smart pointer could not be used to destruct the supervisor automatically
p925
as(dp926
g15
V34509
p927
stp928
a((dp929
g2
(lp930
VHere is the analysis for the time complexity of them (n is the item count in the map), which is guaranteed to do the lookup for find with logarithmic or better time complexity:
p931
aV8 * log2 n  for 8 times find
p932
aVn for the iterate through all
p933
aVThe first one is bigger for smaller numbers (8 for n=2 for example), but at around 43, the first one will become better than the second one and stays so
p934
aVSo, you will want to use the first method, given that it also is more convenient to code
p935
as(dp936
g15
V34509
p937
stp938
a((dp939
g2
(lp940
VThe type of void is deliberately left incomplete
p941
aVFrom this, it follows you cannot dereference void pointers, and neither you can take the sizeof of it
p942
aVThis means you cannot use the subscript operator using it like an array
p943
aVThe moment you assign something to a void pointer, any type information of the original pointed to type is lost, so you can only dereference if you first cast it back to the original pointer type
p944
aVFirst and the most important, you pass  to the function, but you try to typecast (and dereference) that to  in your function
p945
aVThis is not valid and undefined behavior
p946
aVYou need a function printCommonStatistics for each type of array elements
p947
aVSo, have a
p948
aV, ,  which all differ by their first argument (one taking , the other taking , and so on)
p949
aVYou might create them using macros, to avoid redundant code
p950
aVPassing the struct itself is not a good idea, since then you have to define a new function for each different size of the contained array within the struct (since they are all different types)
p951
aVSo better pass the contained array directly (, call the function for each index)
p952
as(dp953
g15
V34509
p954
stp955
a((dp956
g2
(lp957
VYou are never supposed to link objects created by different compilers
p958
aVEven if what you talk about is changed, you would still have far more issues that prevent you to link against another compilers' generated files
p959
aV(aligning, name mangling, calling conventions to only name a few of them)
p960
aVOne reason the compiler is free to order access sections around might be so the compiler could establish an order for the access sections: members with lower addresses are more protected than members with higher addresses, for example
p961
aVYou would not gain anything if that reordering wasn't allowed: Only PODs provide C compatibility and a way to give you byte offsets of members inside a class/struct (using the macro ) or allows you to memcpy them
p962
aVA type will become non-POD if you define a custom constructor, copy constructor, a private member or some other stuff
p963
aVIn particular, deriving from a class currently breaks PODness
p964
aVC++1x lowers the requirements for PODs
p965
aVFor example, in C++1x  is actually a POD, even though it provides its own constructor (which has to fit certain rules though)
p966
as(dp967
g15
V34509
p968
stp969
a((dp970
g2
(lp971
VAnd no, i think he is NOT trying to spam
p972
aVThis is a valid question and quite interesting i think
p973
aVOk now i think compilers can do that
p974
aVThe standard says in 9
p975
aV2
p976
aVp12:
p977
as(dp978
g15
V34509
p979
stp980
a((dp981
g2
(lp982
VThere is a paragraph in the standard that states there shall be no padding before the first member of a struct
p983
aVBut it does not say explicitly so about unions
p984
aVThe difference in size could come because it wants to align the union at 2 byte boundaries, but as it cannot pad before the first member of a struct, the struct will have one byte aligning
p985
aVAlso note that an union could have more members with different types, which could widen the required alignment of your union
p986
aVThere could be reasons for the compiler to give them at least 2 bytes alignment, for example to ease code that has to handle according the required aligment of an union
p987
aVAnyway, there is no requirement that your union should be one byte exactly
p988
aVIt just has to have place for all its members
p989
aVHere is what the C standard has to say about your second question:
p990
aVSo your best bet is to use your way using the int
p991
aVyou may put braces around the code, so the temporary variable is kept local:
p992
as(dp993
g15
V34509
p994
stp995
a((dp996
g2
(lp997
VNormal functions do not include the return type in their signature
p998
aV(note: i've rewritten this answer, and the comments below don't apply to this revision - see the edit-history for details)
p999
aVIntroduction
p1000
aVHowever, the matter about functions and function declarations in the Standard is complicated
p1001
aVThere are two layers that have to be considered:
p1002
aVDeclarations
p1003
aVEntities
p1004
aVThe so-called function declaration may declare a function entity or a template entity
p1005
aVIf a function entity is declared, then you either have to do with an explicit specialization of a function template (with all arguments specified), or a declaration of an ordinary function
p1006
aVIf a template entity is declared, then you are declaring a primary function template, or an explicit specialization where some arguments are not specified
p1007
aV(This is very similar to the relation of "object declaration" and objects or references: The former may declare either an object or a reference
p1008
aVSo an object declaration may not necessarily declare an object
p1009
aVThe Standard defines the signature of a function to include the following at :
p1010
aVThe types of its parameters and, if the function is a class member, the cv- qualifiers (if any) on the function itself and the class in which the member function is declared
p1011
aVThe signature of a function template specialization includes the types of its template arguments
p1012
aV(14
p1013
aV5
p1014
ag1014
aV1)
p1015
aVIt's missing the return type in this definition, which is part of the signature of a function template specialization (i
p1016
aVe a function declaration that declares a function which is a specialization of a template), as pointed out by  (recent C++0x working papers fixed that already to mention the return type in  too):
p1017
aVThe signature of a function template specialization consists of the signature of the function template and of the actual template arguments (whether explicitly specified or deduced)
p1018
aVThe signature of a function template consists of its function signature, its return type and its template parameter list
p1019
aVSo what exactly does a signature contain, again
p1020
aVSo, when we ask about the signature of a function, we have to give two answers:
p1021
aVFor functions that are specializations of function templates, the signature includes the return type
p1022
aVFor functions that are not specializations, the return type is not part of the signature
p1023
aVNotice, however, that the return type, in any case, is a significant part of the type of a function
p1024
aVThat is, the following is not valid:
p1025
aVWhen is an overload invalid if only the return type differs
p1026
aVMajor compilers currently reject the following code:
p1027
aVBut accept the following code:
p1028
aVHowever, the Standard does forbid a function declaration that only differs in the return type (when defining when an overload is valid, and when not)
p1029
aVIt does not define precisely what "differs only by return type" means, though
p1030
aVStandard paragraph references:
p1031
aVWhen can a function declaration be overloaded:
p1032
aVWhat is a function declaration:  and
p1033
aVWhat is the signature of a function template/specialization:
p1034
aVFor reference, here is what the most recent C++0x draft n3000 says about "signature" in , which is much more complete in its coverage of the different type of entities:
p1035
aVthe name and the parameter type list (8
p1036
aV3
p1037
aV5) of a function, as well as the class or namespace of which it is a member
p1038
aVIf a function or function template is a class member its signature additionally includes the cv-quali\ufb01ers (if any) and the ref-quali\ufb01er (if any) on the function or function template itself
p1039
aVThe signature of a function template additionally includes its return type and its template parameter list
p1040
aVThe signature of a function template specialization includes the signature of the template of which it is a specialization and its template arguments (whether explicitly speci\ufb01ed or deduced)
p1041
aV[ Note: Signatures are used as a basis for name mangling and linking
p1042
aV\u2014 end note ]
p1043
as(dp1044
g15
V34509
p1045
stp1046
a((dp1047
g2
(lp1048
VA very common technique is to use function pointers, or boost::function, indexed by the item name, or by having a vector of them and indexing by the item index for this job
p1049
aVSimple example using the item name:
p1050
aVC++ doesn't have a lambda feature yet, so you really have to use functions for this task, sadly
p1051
aVYou can use boost::lambda, but note it is just simulating lambdas, and nowhere near as powerful as a native solution:
p1052
aVNote the use of constant(
p1053
aV, since otherwise boost::lambda wouldn't notice that this is supposed to be a lambda expression: The compiler would try to output the string using std::cout, and assign the result (an std::ostream reference) to menu["help"]
p1054
aVYou can still use boost::function, since it will accept everything returning void and taking no arguments - including function objects, which is what boost::lambda creates
p1055
aVIf you really don't want separate functions or boost::lambda, you can just take print out a vector of the item names, and then  on the item number given by the user
p1056
aVThis is probably the easiest and most straight forward way of doing it
p1057
as(dp1058
g15
V34509
p1059
stp1060
a((dp1061
g2
(lp1062
VYou can use friend definition, which will define the operator in the surrounding namespace of the class, and make it only visible to operator overloading resolution (not callable manually using the ::operator<<
p1063
aVsyntax):
p1064
aVThe alternative, to keep your code as it is and just make the operator<< template a friend, you add this line into your class definition:
p1065
aVFor the manipulator problem, i will just give you my code i write some time ago:
p1066
aV};
p1067
aVNote that it is std::hex , but not std::ios::hex
p1068
aVThe latter is used as a manipulator flag for the  function of streams
p1069
aVNote that for your example, tho, no special treatment of manipulators is required
p1070
aVThe above special treatment of std::endl is only needed because i do stream the time in addition when std::endl is used
p1071
as(dp1072
g15
V34509
p1073
stp1074
a((dp1075
g2
(lp1076
VC++ doesn't notice the function inherited from Base already implements : The function has to be implemented explicitly in a class derived from
p1077
aVChange it this way:
p1078
aVIf you want to be able to get away with only implementing one of them, split  up into two interfaces:
p1079
aVNote: main must return int
p1080
aVNote: it's good practise to keep  in front of member functions in the derived that were virtual in the base, even if it's not strictly required
p1081
as(dp1082
g15
V34509
p1083
stp1084
a((dp1085
g2
(lp1086
VUse -E :
p1087
aVThe internals above are line-markers for gcc which are kinda confusing when you read the output
p1088
aVstrips them
p1089
aV-E  Stop after the preprocessing stage; do not run the compiler proper
p1090
aVThe output is in the form of preprocessed source code, which is sent to the
p1091
aVstandard output
p1092
aVInput files which don't require preprocessing are ignored
p1093
aVNote: comments correctly complain this is only a partial solution
p1094
aVIt won't tell you when a macro will be replaced
p1095
aVIt shows you the preprocessed source, which can be helpful anyway
p1096
as(dp1097
g15
V34509
p1098
stp1099
a((dp1100
g2
(lp1101
VYou won't be able to work around it having the C++ look, since a = b; has other semantics in C++ than in C#
p1102
aVIn C#, a = b; makes a point to the same object like b
p1103
aVIn C++, a = b changes the content of a
p1104
aVBoth has their ups and downs
p1105
aVIt's like you do
p1106
aVIn C++ (it will lose the reference to the first object, and create a memory leak
p1107
aVBut let's ignore that here)
p1108
aVYou cannot overload the assign operator in C++ for that either
p1109
aVThe workaround is easy:
p1110
aVDisclaimer: I'm not a C# developer
p1111
aVYou could create a write-only-property like this
p1112
aVthen do a
p1113
aVSelf = b; above
p1114
aVNow, this is not good
p1115
aVSince it violates the principle-of-least-surprise (POLS)
p1116
aVOne wouldn't expect a to change if one does a
p1117
aVSelf = b;
p1118
as(dp1119
g15
V34509
p1120
stp1121
a((dp1122
g2
(lp1123
VChange
p1124
aVto
p1125
aVOtherwise you will get one additional empty line at the end
p1126
aVwill return true only once you tried to read past the end of the file, and not if only the next read would be past the end of the file
p1127
aVIt sets the  because  tries to extract characters from the stream
p1128
aVIf there are no characters left (and no  has been seen yet),  to a character will set the
p1129
aVThen  will set the  and then  will return true, and your loop exits
p1130
aVIf you don't want  set, then change your condition from  to  (and make sure there is a trailing newline in your file)
p1131
aVThis now is also the solution to your problem:  doesn't  your stream, so the  still is set if you reopen your file
p1132
aVcall  after reading your stuff in, and then it works
p1133
as(dp1134
g15
V34509
p1135
stp1136
a((dp1137
g2
(lp1138
VNo
p1139
aVThere is no such function in wx by all i know
p1140
aVStart up a timer (say 50ms) checking the global mouse position
p1141
aVIf the mouse is outside the region, then set it into again
p1142
aVIf you want to restrict the mouse for some certain reason, for example to make some sort of game, then you can capture the mouse (see )
p1143
aVYou will get mouse events even if the pointer is outside your window
p1144
aVThen you could react to mouse-motion events and do the check for the position there, without a timer
p1145
aVDownside of this is that the mouse won't be able to be used somewhere else for other programs since they won't receive events
p1146
aVwxWidgets manual states that OSX guidelines forbid the programs to set the mouse pointer to a certain position programmatically
p1147
aVThat might contribute to the reason there is not much support for such stuff in wx, especially since wx tries really hard to be compatible to everything possible
p1148
aVSmall sample
p1149
aVClick on the button to restrict the mouse to area 0,0,100,100
p1150
aVClick somewhere to release it
p1151
as(dp1152
g15
V34509
p1153
stp1154
a((dp1155
g2
(lp1156
V has a style called
p1157
aVUse that to make it read-only
p1158
aVAs a sidenode, you can use the C++ wxWidgets Manual for wxPython aswell
p1159
aVWhere special handling for wxPython or other ports is required, the manual often points out the difference
p1160
as(dp1161
g15
V34509
p1162
stp1163
a((dp1164
g2
(lp1165
VFirst, you should really return a reference from your operator+=, since you can later use them to implement operator+, operator- and so on
p1166
aVI will change that accordingly
p1167
aVAlso, your do_for_each has to be a template, since it has to know the precise type of the function object, as binary function objects are not polymorph classes
p1168
aVFor the actual operation, you want to use :
p1169
aVstd::transform will just pass each element to the function object, and assigns the result back to the iterator given as the third argument
p1170
as(dp1171
g15
V34509
p1172
stp1173
a((dp1174
g2
(lp1175
VFrom the Standard point of view, there is nothing that prevents this
p1176
aVHowever, in reality, most 32bit implementations use 32bit for
p1177
aVNow, the C++ standard mandates that the standard allocator in the C++ Standard Library uses std::size_t as the size quantity
p1178
aVThus, you are limited to 2^32 bytes of storage for containers, strings and stuff
p1179
aVThe situation could be another for , i don't know exactly what is going on there
p1180
aVYou have to use the native API of the OS directly, or some library wrapping it, to be able to do that, without having to trust the Standard Library implementations, which are largely implementation-dependent
p1181
as(dp1182
g15
V34509
p1183
stp1184
a((dp1185
g2
(lp1186
VChange it to this:
p1187
aVThe binder requires the int argument
p1188
aVSo you have to give it a placeholder which stands for the integer argument that the generated function object needs
p1189
aVBtw: I'm not sure whether you already know this or not
p1190
aVBut you don't need that mem_fn for this
p1191
aVJust change it to
p1192
as(dp1193
g15
V34509
p1194
stp1195
a((dp1196
g2
(lp1197
VThe time required should not be a reason not to put something into a constructor
p1198
aVYou could put the code itself into a private function, and call that out of your constructor, just to keep the code in the constructor clear
p1199
aVHowever, if the stuff you want to do is not required to give the object a defined condition, and you could do that stuff later on first use, this would be a reasonable argument to put it out and do it later
p1200
aVBut don't make it dependant on the users of your class: These things (on-demand initialization) must be completely transparent to users of your class
p1201
aVOtherwise, important invariants of your object might easily break
p1202
as(dp1203
g15
V34509
p1204
stp1205
a((dp1206
g2
(lp1207
VYou want to have template-typedefs
p1208
aVThat is not yet supported in the current C++
p1209
aVA workaround is to do
p1210
aVIn the next C++ (called c++0x, c++1x due to 2010), this would be possible:
p1211
as(dp1212
g15
V34509
p1213
stp1214
a((dp1215
g2
(lp1216
VI've liked this since the time i've discovered it in some code:
p1217
aVor if you don't have a condition at hand, you can just do
p1218
aVThe following is attributed to @Josh (see comments)
p1219
aVIt uses the comma operator instead:
p1220
as(dp1221
g15
V34509
p1222
stp1223
a((dp1224
g2
(lp1225
VThe reason is that any default arguments do not change the function type of a function
p1226
aVhas no way to know the function only requires 1 argument, or that the functions' second argument is optional, since all the knowledge it gets is given to it by the type of  (which stays )
p1227
aVIt therefor requires an integer as the second argument
p1228
aVIf you want to pass the address of a member function overloaded, you have to cast to the right member function pointer type:
p1229
aVinstead of just , so the compiler has a context to figure out which address is to be taken
p1230
aVEdit: coppro has a nicer solution how to provide context:
p1231
as(dp1232
g15
V34509
p1233
stp1234
a((dp1235
g2
(lp1236
VThere seems to be the general gist in this thread that you cannot initialize members of an array other than using the default constructor
p1237
aVOne answer even creates another type, just to call another constructor
p1238
aVEven though you can (if the array is not part as a member of a class
p1239
aV:
p1240
aVThe type, however, needs to be copy-able: The items given are copy-initialized into the members of the array
p1241
aVFor arrays as members in classes, it's the best to use containers currently:
p1242
aVUsing the  technique described by andy
p1243
aVgurin is an option too
p1244
aVBut note it will complicate things
p1245
aVYou will have to call destructors yourself
p1246
aVAnd if any constructor throws, while you are still building up the array, then you need to figure where you stopped
p1247
aVAltogether, if you want to have arrays in your class, and want to initialize them, use of a  is a simple bet
p1248
as(dp1249
g15
V34509
p1250
stp1251
a((dp1252
g2
(lp1253
VYou can ask the  guys on  over irc
p1254
aVTheir program  is able to open RTF files, and is indeed also written in Qt
p1255
aVI'm sure they would be glad to tell you about how they do it
p1256
as(dp1257
g15
V34509
p1258
stp1259
a((dp1260
g2
(lp1261
VM-x customize-face RET default will allow you to set the face  face, on which all other faces base on
p1262
aVThere you can set the font-size
p1263
aVHere is what is in my
p1264
aVemacs
p1265
aVactually, color-theme will set the basics, then my custom face setting will override some stuff
p1266
aVthe custom-set-faces is written by emacs's customize-face mechanism:
p1267
as(dp1268
g15
V34509
p1269
stp1270
a((dp1271
g2
(lp1272
VAll you need is a finished study and capability to learn new things easily
p1273
aVThey can't expect you know everything they tell you to do
p1274
aVBut if you can learn well, that's going to be fine
p1275
aVThat's what i have been told in university
p1276
aVI think it holds true
p1277
as(dp1278
g15
V34509
p1279
stp1280
a((dp1281
g2
(lp1282
VOr without tail:
p1283
aVUsing awk with bc to have arbitrary long results (credits to ):
p1284
as(dp1285
g15
V34509
p1286
stp1287
a((dp1288
g2
(lp1289
VYou should
p1290
aVLearn the bash shell (especially , )
p1291
aVBasic commandos (, , , , , , )
p1292
aVKnowing about  and its main uses
p1293
aVLearn an editor ( is always installed
p1294
aVIf you want you can learn  too)
p1295
aVBasic sed replacement (), a little awk
p1296
aVHow to work with ,  and
p1297
aVHow to get informations (,  and )
p1298
aVHow to install a package ( for archlinux,  for debian based), remove and update your system
p1299
aVKnowing how to start/stop services in your distribution (, )
p1300
aVHow in general a unix file-system works (, what is
p1301
aVUnderstanding for example
p1302
aVKnowing about
p1303
aVUnderstanding how to manage users and groups (, )
p1304
aVKnowing the format of  and
p1305
aVWhere you look out for log-files for  and the  daemon
p1306
aVKnowing about some lowlevel stuff like  and
p1307
as(dp1308
g15
V34509
p1309
stp1310
a((dp1311
g2
(lp1312
VThis library is quite popular and used by abiword (gnome) and kword (kde): wvWare
p1313
as(dp1314
g15
V34509
p1315
stp1316
a((dp1317
g2
(lp1318
VIf you have a header that is included in all others (like that stdafx
p1319
aVh), you should put that there
p1320
aVThe compiler command line switch is used usually for build options, that are not always set, like NDEBUG, UNICODE and such things
p1321
aVWhile your macro would essential always be set
p1322
aVThat might sound arbitrary
p1323
aVAnd indeed, some might say other things
p1324
aVAt the end, though, you have to decide what fits your situation
p1325
as(dp1326
g15
V34509
p1327
stp1328
a((dp1329
g2
(lp1330
VCreate a logoff
p1331
aVh file with only the function declaration of logoff, like
p1332
aVThen, in main
p1333
aVc include it with
p1334
aVDon't include logoff
p1335
aVc, as the compiler will compile the function two times, and the linker will see two functions of that name then
p1336
aVIt appears to work if you change it to log_off, and then only recompile one of them
p1337
aVThe other object-file will still have the old logoff function compiled in
p1338
aVThus the linker sees one log_off and one logoff
p1339
aVThat's the reason it appeared to work for you with that name
p1340
as(dp1341
g15
V34509
p1342
stp1343
a((dp1344
g2
(lp1345
VC or C++ itself do not define those identifiers
p1346
aVThey are compiler extensions and stand for certain calling conventions
p1347
aVThat determines where to put arguments, in what order, where the called function will find the return address, and so on
p1348
aVFor example, __fastcall means that arguments of functions are passed over registers
p1349
aVThe Wikipedia Article provides an overview of the different calling conventions found out there
p1350
as(dp1351
g15
V34509
p1352
stp1353
a((dp1354
g2
(lp1355
VStandard C way:
p1356
aVUsually you also want to connect SIGTERM, which is sent when a request to close the program is made
p1357
aVBut the above suffices to handle Ctrl+C
p1358
aVYou should take care not to do something time consuming in the handler
p1359
aVThere is a race-condition: Whether or not the handler is set back to default is different among systems
p1360
aVThus, if in your handler the user interrupts the program again, it will interrupt your handler and exit
p1361
aVBetter to use  (that is however not Standard C), which doesn't have this problem
p1362
as(dp1363
g15
V34509
p1364
stp1365
a((dp1366
g2
(lp1367
VThe correct way to do this is to have the variable only in the base class
p1368
aVAs the derived class knows it must be of dynamic type , this is totally reasonable:
p1369
aVSince MyVar is derived from MyVarBase, the different return-types of  would still work if GetVar was virtual (as is the case here)
p1370
aVNote that with that method, there must be no function in  that can reset the pointer to something different, obviously
p1371
aVNote that  is the right cast in that case
p1372
aVUsing , as proposed by one commenter, will tell the readers and users of GetVar that  could return a pointer to an object not of type MyVar
p1373
aVBut that doesn't reflect our intention, as you only ever pass MyVar
p1374
aVTo be consequent is the most important thing in software development
p1375
aVWhat you could do is to assert it is non-null
p1376
aVIt will abort at runtime with an error-message in debug-builds of your project:
p1377
as(dp1378
g15
V34509
p1379
stp1380
a((dp1381
g2
(lp1382
VDo you want an event when your menu is opened
p1383
aVUse  ()
p1384
aVBut it's not in particular precise
p1385
aVAs the documentation says, it is only sent once if you open a menu
p1386
aVFor another event you have to close it and open another menu again
p1387
aVI
p1388
aVe in between, you can open other menus (by hovering other items in the menubar), and the event won't be sent again
p1389
aVWhat do you need this for
p1390
aVProbably there is another way to do it, instead of listening for this kind of event
p1391
aVIf you want an event for all items of a menu, use  (it's using )
p1392
aVAll IDs starting from  up to and including  will be connected to the given event handler
p1393
aVUsing a range instead of connecting each item separate will provide for better performance, as there are fewer items in the event-handler list
p1394
as(dp1395
g15
V34509
p1396
stp1397
a((dp1398
g2
(lp1399
VI would decline the first (edit : question changed, the first is what i prefer too now)
p1400
aVSince it is not clear where Bar refers to from only looking at the function definition
p1401
aVAlso, with your first method, slippy errors could show up:
p1402
aVBecause it looks in the current scope (there it is the global scope), it finds two foo's, and tells you the reference to it is ambiguous
p1403
aVPersonally i would do it like this:
p1404
aVIt's also not clear from only looking at the definition of SomeMethod to which namespace it belongs, but you have a namespace scope around it and you can easily look it up
p1405
aVAdditionally, it is clear now that Bar refers to namespace foo
p1406
aVThe second way you show would be too much typing for me actually
p1407
aVIn addition, the second way can cause confusion among new readers of your code: Is foo the class, and Bar a nested class of it
p1408
aVOr is foo a namespace and Bar the class
p1409
as(dp1410
g15
V34509
p1411
stp1412
a((dp1413
g2
(lp1414
V will insert '10' at the end, given your definition of the 'reverse' iterator
p1415
aVActually,
p1416
as(dp1417
g15
V34509
p1418
stp1419
a((dp1420
g2
(lp1421
VWell, you are widening the char into a short value
p1422
aVWhat you want is to interpret two bytes as an short
p1423
aVcannot cast from  to
p1424
aVYou have to cast to , then to :
p1425
aVNow, you can dereference p and get the short value
p1426
aVBut the problem with this approach is that you cast from unsigned char*, to void* and then to some different type
p1427
aVThe Standard doesn't guarantee the address remains the same (and in addition, dereferencing that pointer would be undefined behavior)
p1428
aVA better approach is to use bit-shifting, which will always work:
p1429
as(dp1430
g15
V34509
p1431
stp1432
a((dp1433
g2
(lp1434
VHowever, doesn't work if the file-name contains newlines
p1435
aVThe above is the only solution i know of when you actually want to have the directory name in a variable
p1436
aVIf you just want to execute some command, use xargs
p1437
as(dp1438
g15
V34509
p1439
stp1440
a((dp1441
g2
(lp1442
VIt's not possible
p1443
aVThe usual way you do it is this:
p1444
aVand for types
p1445
aVYou can access it then as  or
p1446
aVIf you have a particular type, you can use partial template specialization:
p1447
aVThe same principle is possible for type parameters too, indeed
p1448
aVNow you can pass any bitset to it, like  (note to use size_t, not int
p1449
aVBecause we have no variadic many template paramters yet, we have to limit ourself to a particular parameter count, and repeat the steal_it template specializations for count from 1 up to N
p1450
aVAnother difficulty is to scan types that have mixed parameters (types and non-types parameters)
p1451
aVThis is probably nontrivial to solve
p1452
aVIf you have not the type, but only an object of it, you can use a trick, to still get a value at compile time:
p1453
aVThe trick is to make the function template auto-deduce the type, and then return a reference to a character array
p1454
aVThe function doesn't need to be defined, the only thing needed is its type
p1455
as(dp1456
g15
V34509
p1457
stp1458
a((dp1459
g2
(lp1460
VFrom here
p1461
aVlsof stands for \u201cLiSt Open Files\u201d
p1462
aVThis shell command seems deceptively simple: It lists information about files opened by processes on a UNIX box
p1463
aVDespite its (apparent) modest mission statement, lsof is actually one of the most powerful and useful UNIX commands
p1464
aVIts raw power comes from one of UNIX\u2019s design principle often described as \u201din UNIX everything is a file\u201d
p1465
aVWhat this means is that the lsof concept of an open file not only covers regular files but also the following:
p1466
aVDirectories
p1467
aVStreams or network files (for example, Internet or UNIX domain sockets and NFS files)
p1468
aVNative libraries (for example,
p1469
aVsoor
p1470
aVdylibdynamic libraries linked to a process)
p1471
aVBlock and character special files (for example, disk volume, external hard drive, console, or mouse)
p1472
aVPipes
p1473
aVWait, I Cannot Find lsof on My System
p1474
aVlsof is such a popular tool that it has been ported to pretty much all UNIX dialects (Linux, Mac OS X, BSD, Solaris, and so on)
p1475
aVIf it is unavailable on your box, use your usual package management system to install it
p1476
aVYou can find lsof packages for Solaris on Sun Freeware
p1477
as(dp1478
g15
V34509
p1479
stp1480
a((dp1481
g2
(lp1482
VIndeed, templates can do that, with partial template specialization:
p1483
aVIf in the function you do things only valid to pointers, you better use the method of a separate function though, since the compiler type-checks the function as a whole
p1484
aVYou should, however, use boost for this, it includes that too: http://www
p1485
aVboost
p1486
aVorg/doc/libs/1_37_0/libs/type_traits/doc/html/boost_typetraits/reference/is_pointer
p1487
aVhtml
p1488
as(dp1489
g15
V34509
p1490
stp1491
a((dp1492
g2
(lp1493
VC++ only include-files not found in the C standard never used
p1494
aVSince the very first C++ Standard came out (1998) they have used  for their own headers
p1495
aVFiles inherited by the C Standard became  instead of
p1496
aVThe C files inherited used like  are deprecated, but still part of the C++ standard
p1497
aVThe difference is that names not defined as macros in C are found within namespace  in  in C++, while names in  are within the global namespace scope
p1498
aVSo you will find  in stddef
p1499
aVh, and  in cstddef
p1500
aVBoth are Standard C++, but use of ::size_t is deprecated (See Annex D of the C++ Standard)
p1501
aVNow those were the difference
p1502
aVWhy would you use `filename
p1503
aVh`
p1504
aVCompatibility with C compilers
p1505
aVCompatibility with very old C++ compilers
p1506
aVWhy should you use `cfilename`
p1507
aVNames are within namespace
p1508
aVNo name-clashes anymore
p1509
aVNew C++ features (e
p1510
ag774
aVoverloaded math functions for float, long)
p1511
aVC Compatibility Headers () could disappear in future
p1512
as(dp1513
g15
V34509
p1514
stp1515
a((dp1516
g2
(lp1517
VI've tried that before
p1518
aVThe problem is that  is already reserved to stringize a macro parameter
p1519
aVIt isn't parsed as a preprocessor token like the one in define
p1520
as(dp1521
g15
V34509
p1522
stp1523
a((dp1524
g2
(lp1525
Vi think
p1526
aVshould do it
p1527
aVString concatenation in awk is just put one after another
p1528
as(dp1529
g15
V34509
p1530
stp1531
a((dp1532
g2
(lp1533
VAs others stated you cannot do it for reasons they stated too :) You then said you don't want to care about the member construction / destruction in the class containing them
p1534
aVYou can use templates for this
p1535
aVI think the code is self explanatory
p1536
aVIf any questions arise, bug me please
p1537
as(dp1538
g15
V34509
p1539
stp1540
a((dp1541
g2
(lp1542
VStandard C++ doesn't provide a way to do this
p1543
aVBut  can do that: http://www
p1544
aVboost
p1545
aVorg/doc/libs/1_37_0/libs/filesystem/example/simple_ls
p1546
aVcpp
p1547
as(dp1548
g15
V34509
p1549
stp1550
a((dp1551
g2
(lp1552
VAs you updated your concerns in the comment sections, here the answer
p1553
aVJust getting the return type of a function is possible:
p1554
aVI guess you see what this comes down to :) You can use boost function types which already has solved it: http://www
p1555
aVboost
p1556
aVorg/doc/libs/1_37_0/libs/function_types/doc/html/index
p1557
aVhtml
p1558
as(dp1559
g15
V34509
p1560
stp1561
a((dp1562
g2
(lp1563
VFor  use:
p1564
aVFor  use:
p1565
aVNot sure why i took  instead of  for  above
p1566
aVI guess it's the feeling that it's faster
p1567
aVBut actually both are constant time :)
p1568
aVAnyway wrap it into a function and have fun:
p1569
as(dp1570
g15
V34509
p1571
stp1572
a((dp1573
g2
(lp1574
VLet's look into it (for the following, note  and  are the same in C++):
p1575
aVString literals and char *
p1576
aVis an array of 6 const characters:
p1577
aVAs every array, it can convert implicitly to a pointer to its first element:  For compatibility with C code, C++ allows one other conversion, which would be otherwise ill-formed:  it removes the const
p1578
aVThis is an exception, to allow that C-ish code to compile, but it is deprecated to make a  point to a string literal
p1579
aVSo what do we have for
p1580
aV->  ->  ->  ->
p1581
aVA string literal is read-only, and won't be allocated on the stack
p1582
aVYou can freely make a pointer point to them, and return that one from a function, without crashing :)
p1583
aVInitialization of an array using a String literal
p1584
aVNow, what is
p1585
aVIt's a whole other thing
p1586
aVThat will create an array of characters, and fill it with the String
p1587
aVThe literal isn't pointed to
p1588
aVInstead it is copied to the character-array
p1589
aVAnd the array is created on the stack
p1590
aVYou cannot validly return a pointer to it from a function
p1591
aVArray Parameter types
p1592
aVHow can you make your function accept an array as parameter
p1593
aVYou just declare your parameter to be an array:
p1594
aVbut you omit the size
p1595
aVActually, any size would do it, as it is just ignored: The Standard says that parameters declared in that way will be transformed to be the same as
p1596
aVExcursion: Multi Dimensional Arrays
p1597
aVSubstitute  by any type, including arrays itself:
p1598
aVaccepts a two-dimensional array, whose last dimension has size 10
p1599
aVThe first element of a multi-dimensional array is its first sub-array of the next dimension
p1600
aVNow, let's transform it
p1601
aVIt will be a pointer to its first element again
p1602
aVSo, actually it will accept a pointer to an array of 10 chars: (remove the  in head, and then just make a pointer to the type you see in your head then):
p1603
aVAs arrays implicitly convert to a pointer to their first element, you can just pass an two-dimensional array in it (whose last dimension size is 10), and it will work
p1604
aVIndeed, that's the case for any n-dimensional array, including the special-case of ;
p1605
aVConclusion
p1606
aVand
p1607
aVare the same, as the first is just a pointer to char
p1608
aVBut note if you want to pass a String-literal to that (say it doesn't change its argument), then you should change the parameter to  so you don't do deprecated things
p1609
as(dp1610
g15
V34509
p1611
stp1612
a((dp1613
g2
(lp1614
VIt is valid because the first will call the operator
p1615
aV= of std::string, which will accept a const char* as an argument
p1616
aVThat, however, doesn't mean that std::string also has an operator some_integral_type() that will return a integral expression which switch needs
p1617
aVUsing operators in C++ does not necassary invoke the builtin meaning
p1618
aVYour code, for example, doesn't compare pointer values
p1619
aVIt might invoke a user defined (in this case, the one of std::string) operator function
p1620
as(dp1621
g15
V34509
p1622
stp1623
a((dp1624
g2
(lp1625
VAs others stated, make a private parameter-less constructor
p1626
aVNo-one can create an instance of it, apart from the class itself
p1627
aVAs others have shown how it is done with other languages, here comes how you do it in the next C++ version, how to make a class non-instantiable:
p1628
as(dp1629
g15
V34509
p1630
stp1631
a((dp1632
g2
(lp1633
VYou should not use
p1634
aVCasting some pointer from  is not allowed using reinterpret_cast (5
p1635
ag976
aV10/7 since  is not an object type
p1636
aVIMHO that's a valid way to read it, even if some compilers do not diagnose it)
p1637
aVcan be used to cast between some unrelated pointer types when writing platform dependent code when necessary
p1638
aVA pointer to an object can be explicitly converted to a pointer to an object of different type
p1639
aVExcept that converting an rvalue of type "pointer to T1" to the type "pointer to T2" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified
p1640
aVWhen you want to cast from  to something else, you can use
p1641
aVThe Standard explicitly allows this
p1642
aVConverting from one type to another (not the same) type using  in between will yield to an unspecified pointer value
p1643
aVHowever, sometimes when you need to write platform dependent code, this can't be avoided
p1644
aVAn rvalue of type "pointer to cv void" can be explicitly converted to a pointer to object type
p1645
aVA value of type pointer to object converted to \u201cpointer to cv void\u201d and back to the original pointer type will have its original value
p1646
aVUpdate: The committee is going to allow  from and to  for C++0x
p1647
aVSee Issue #1120
p1648
as(dp1649
g15
V34509
p1650
stp1651
a((dp1652
g2
(lp1653
VIf you find that gcc changes the order of execution in your code, you should consider using a memory barrier
p1654
aVJust don't assume that volatile variables will protect you from that issue
p1655
aVThey will only make sure that in a single thread, the behavior is what the language guarantees, and will always read variables from their memory location to account for changes "invisible" to the executing code
p1656
aV(e
p1657
aVg changes to a variable done by a signal handler)
p1658
aVGCC supports OpenMP since version 4
p1659
ag976
aVYou can use it to create a memory barrier with a special  directive
p1660
aVA very good insight about locking free code is this PDF by Herb Sutter and Andrei Alexandrescu: C++ and the Perils of Double-Checked Locking
p1661
as(dp1662
g15
V34509
p1663
stp1664
a((dp1665
g2
(lp1666
VYou can use  to cast to an integral type and back to the pointer type
p1667
aVIf the integral type is large enough to store the pointer value, then that conversion will not change the pointer value
p1668
aVAs others already say, it is not defined behavior to use dynamic_cast on a non-polymorphic class (except when you do an upcast, which is implicit anyway and be ignored here), and it also only works on pointers or references
p1669
aVNot on integral types
p1670
aVYou better use  found in  on various posix systems
p1671
aVYou can use that type as your intermediate type you cast to
p1672
aVRegarding your check whether the conversion will succeed, you can use sizeof:
p1673
aVwill fail at compile time if the conversion couldn't be done
p1674
aVOr continue to use assert with that condition, and it will assert at run-time instead
p1675
aVWarning: This won't prevent you from casting  to  back to  with U another type than T
p1676
aVThus, this only guarantees you the cast won't change the value of the pointer if you cast from  to  and back to
p1677
aV(Thanks to Nicola pointing out you may expect another protection)
p1678
as(dp1679
g15
V34509
p1680
stp1681
a((dp1682
g2
(lp1683
Vi think you show him how
p1684
aVto open and save files
p1685
aVto kill/switch buffers
p1686
aVto switch/kill/split windows
p1687
aVto select a range
p1688
aVAnd tell him about M-x
p1689
aVTell him he write those steps down somewhere
p1690
aVI think basic navigation can be done using arrow keys
p1691
aVNow this is all he needs
p1692
aVIf he knows about  , he can easily find search, replace and other stuff
p1693
as(dp1694
g15
V34509
p1695
stp1696
a((dp1697
g2
(lp1698
VOptimization is Compiler specific
p1699
aVConsult the documentation for the various optimization flags for them
p1700
aVYou will find that in the Compilers documentation too
p1701
aVIf you are curious, you can write a tail recursive function and pass it a big argument, and lookout for a stack-overflow
p1702
aV(tho checking the generated assembler might be a better choice, if you understand the code generated
p1703
aVYou just use the debugger, and look out the address of function arguments/local variables
p1704
aVIf they increase/decrease on each logical frame that the debugger shows (or if it actually only shows one frame, even though you did several calls), you know whether TCO was done or wasn't done
p1705
as(dp1706
g15
V34509
p1707
stp1708
a((dp1709
g2
(lp1710
VAll numbers are being added to a result
p1711
aVNo need to comment each number separately
p1712
aVA comment "these numbers are added together" will do it
p1713
aVI'm going to do it like this:
p1714
aVbut if those numbers carry some meaning on their own, each number could stand for something entirely different, for example if  denotes the type for an inventory item
p1715
aVI would go with
p1716
as(dp1717
g15
V34509
p1718
stp1719
a((dp1720
g2
(lp1721
VI don't understand yet what your question is about
p1722
aVIf it is whether or not you can be sure that casting to a long and back will yield the same value, view http://stackoverflow
p1723
aVcom/questions/311102/safely-checking-the-type-of-a-variable#311189
p1724
aVGiven the "Rules for using Pointers" MS-Site the other Answerer linked to, the right type to cast to is
p1725
aVSo you do  to cast to a integral type, and do the reverse to cast it back to the pointer again
p1726
aVThe C++ Standard guarantees that the original value is restored
p1727
aV(see the link i gave above for my explanation of that)
p1728
aVThat Microsoft site by the way also says that WPARAM and LPARAM change their size depending on the platform
p1729
aVSo you could just use that variable  and  it
p1730
aVIf it is how you can check on the other side whether or not the pointer (converted to some pointer type) points to some object, the answer is you can't
p1731
aVSince you are apparently not sure which pointer type was used to send it, you cannot check on the receiving side what the dynamic type the pointer points to is
p1732
aVIf you know the type the pointer had on the sender side, your check would be not required in the first place
p1733
as(dp1734
g15
V34509
p1735
stp1736
a((dp1737
g2
(lp1738
VAssuming you only want to be notified for specific functions, you can do it like this:
p1739
aVcompile with debug informations (as you already have symbol informations, you probably also have enough debugs in)
p1740
aVgiven
p1741
aVUse gdb to trace:
p1742
aVHere is what i do to collect all function's addresses:
p1743
aVNote that instead of just printing the current frame(), you can do anything you like, printing the value of some global, executing some shell command or mailing something if it hits the  function :) Sadly, gcc outputs some "Current Language changed" messages in between
p1744
aVBut that's easily grepped out
p1745
aVNo big deal
p1746
as(dp1747
g15
V34509
p1748
stp1749
a((dp1750
g2
(lp1751
VWhen you define your template in a
p1752
aVcpp file, you have to explicitly instantiate it with all the types / template parameters known the template will be used beforehand like this (put it in the
p1753
aVcpp file):
p1754
aVIf you don't know with which template parameters the template will be used, you have to put all the definitions into the header
p1755
aVlike
p1756
aVThe reason is that when you are going to use the template from somewhere, the compiler has to be able to generate the code for that specific instantiation of the template
p1757
aVBut if you place the code into a
p1758
aVcpp file and compile it, there is no way for the compiler to get its hands on the code to generate the instantiation (except when using the infamous  keyword, which is only supported by very few compilers)
p1759
aVThis is also an entry in my C++ Pitfalls answer: http://stackoverflow
p1760
aVcom/questions/30373/what-c-pitfalls-should-i-avoid#293047
p1761
as(dp1762
g15
V34509
p1763
stp1764
a((dp1765
g2
(lp1766
VWhile this answer does not precisely give tips for implementation, it answers how you can often protect yourself from certain bugs like buffer-overflows
p1767
aVGCC has a flag for this:
p1768
aVFor front-ends that support it (C and C++), instrument all risky pointer/array dereferencing operations, some standard
p1769
aVlibrary string/heap functions, and some other associated constructs with range/validity tests
p1770
aVModules so instrumented
p1771
aVshould be immune to buffer overflows, invalid heap use, and some other classes of C/C++ programming errors
p1772
aVThe instrumen\u2010
p1773
aVtation relies on a separate runtime library (libmudflap), which will be linked into a program if -fmudflap is given at link
p1774
aVtime
p1775
aVRun-time behavior of the instrumented program is controlled by the MUDFLAP_OPTIONS environment variable
p1776
aVSee "env
p1777
aVMUDFLAP_OPTIONS=-help a
p1778
aVout" for its options
p1779
aVGenerally, this requires compiler support, since cannot overload the subscript operator  for a native array like , or a pointer like
p1780
as(dp1781
g15
V34509
p1782
stp1783
a((dp1784
g2
(lp1785
VIf you have a pointer  of type  and you add , then the pointer will be advanced by  or equivalent  bytes
p1786
aVYou simply forgot to dereference
p1787
aVSo what you got with  was the sizeof of the , but not the sizeof of a
p1788
aVYour line was equivalent to  Pointers on your platform are 4 bytes big
p1789
aVThus in effect you did
p1790
aVWrite  if you want to increment 2 times
p1791
aVNote that  has an sizeof of 1 by definition
p1792
aVYou don't need to do , it is always 1
p1793
as(dp1794
g15
V34509
p1795
stp1796
a((dp1797
g2
(lp1798
VGNU Bash
p1799
as(dp1800
g15
V34509
p1801
stp1802
a((dp1803
g2
(lp1804
VI've looked around and found
p1805
aVI've come up with this code
p1806
aVSurprising how well it works:
p1807
aVIt's printing  to the standard output
p1808
as(dp1809
g15
V34509
p1810
stp1811
a((dp1812
g2
(lp1813
VI think one can describe signals and slots best when you are looking at them as a possible implementation vehicle for the Observer Pattern or Publish/Subscriber Pattern
p1814
aVThere is one , for example  on the Publisher Side
p1815
aVWhenever the button is pressed, all slots that are connected to that signal are called
p1816
aVSlots are on the Subscriber Side
p1817
aVA slot could for example be
p1818
aVAlong with the event "button pressed", the slot would know which button was pressed, since the id would have been handed over
p1819
aVrepresents the type of the data sent over the connection between the Publisher and the Subscriber
p1820
aVAn operation possible for the Subscriber would be  which could connect  with , so that if the button is pressed, that particular slot is called
p1821
aVThe good thing about this is that the subscriber (the slot side) doesn't need to care about details of the signal
p1822
aVIt just needs to connect
p1823
aVThus, here we have a great deal of loose coupling
p1824
aVYou can change the buttons implementation, but the interface for the slots would still be the same
p1825
aVLook at Qt Signals/Slots or Boost Signals for more informations
p1826
as(dp1827
g15
V34509
p1828
stp1829
a((dp1830
g2
(lp1831
VIndeed that can be done, if the library or your code provides the overloads for  and  for it to work
p1832
aVSimple example on how one could do it:
p1833
aVThe problem with using a pure  is that you would read, but then you wouldn't have a way to put the transformed data back for the next step in the pipeline
p1834
aVThus i'm using  here
p1835
aVThis approach doesn't seem to be efficient, as every operator>> call would extract the whole data, and put into again
p1836
aVTo have a more performant way to stream this would be to create an
p1837
aVThis means, while  is called, you don't do the transforming yet, but you return expression types that will record the chain of operations within its type:
p1838
aVwould be an example of such a type
p1839
aVThe pipelines' structure is decoded into the type itself
p1840
aVTherefore, no virtual functions are needed anymore in the pipeline
p1841
aVIt's not constructed on-demand, but using typedef here, to show the principle
p1842
aVProgramming such a system is not easy
p1843
aVSo you probably should look into existing systems, like Boost
p1844
aVIostreams (see below)
p1845
aVTo give you an idea how it would look like, here is an example i just coded up for you :) :
p1846
aVEntering 0 yields the ASCII code 48 here, which is added 1, and multiplied by 2, yielding a value of 98, which is also finally output
p1847
aVI think you agree this is not some code a starter would want to write
p1848
aVSo maybe look into boost
p1849
aVBoost has an sophisticated iostreams library, which can do many things
p1850
aVI'm sure you would find something fitting to this
p1851
aVBoost
p1852
aVIostreams
p1853
as(dp1854
g15
V34509
p1855
stp1856
a((dp1857
g2
(lp1858
VSadly, there is no portable wx method to do that scaling faster
p1859
aVBut there is a Scale method in the Gtk port in wxBitmap
p1860
aVYou can use that for wxGTK
p1861
aVFor wxMSW, you can use StretchBlt of the win32 API
p1862
aVThere are methods in wxDC that will provide you with the native HDC handle for Windows
p1863
aVYou can make it somewhat more straight forward if you draw directly:
p1864
aVAlso, don't recreate the bitmap in each paint event
p1865
aVStore it as a member, and recreate it only when you get a
p1866
aVIt will probably considerably speed up your program
p1867
aVAnother way is to drop the scaling altogether and use wxGraphicsContext
p1868
aVIt uses Cairo on wxGTK, and gdi+ on wxMSW
p1869
aVIt's relatively new, but can draw antialiased
p1870
as(dp1871
g15
V34509
p1872
stp1873
a((dp1874
g2
(lp1875
VIt's absolutely right
p1876
aVWhat would you expect instead
p1877
aVThe compiler first evaluates the right side, and then implicitly converts to the int
p1878
aVThus,  becomes
p1879
aVWhen you cast before you add, then you are going to add  and , which results in  :)
p1880
as(dp1881
g15
V34509
p1882
stp1883
a((dp1884
g2
(lp1885
VThis is not possible
p1886
aVNote that this is a common misunderstanding:  is not a class template anymore
p1887
aVSo it would not fit to a template-template parameter, but would have to be accepted using a type-parameter:
p1888
aVYour way of using a separate parameter is alright
p1889
aVIf you want to accept  but want to re-bind it to another parameter, you can use this pattern, also used by standard-allocators:
p1890
aVNow,  is of type
p1891
aVThe  before  tells the compiler the  at the end is a type and not a static non-type member
p1892
aVThe  after  tells the compiler the  is a template instantiation, and not a comparision
p1893
as(dp1894
g15
V34509
p1895
stp1896
a((dp1897
g2
(lp1898
VAwk power can be used too:
p1899
as(dp1900
g15
V34509
p1901
stp1902
a((dp1903
g2
(lp1904
VYou need dynamic memory management, and use the  function to read your line
p1905
aVHowever, there seems to be no way to see how many characters it read
p1906
aVSo you use fgetc:
p1907
aVNote: Never use gets
p1908
aVIt does not do bounds checking and can overflow your buffer
p1909
as(dp1910
g15
V34509
p1911
stp1912
a((dp1913
g2
(lp1914
V can do it:
p1915
aVEdit: The strings are not null-terminated:
p1916
as(dp1917
g15
V34509
p1918
stp1919
a((dp1920
g2
(lp1921
VI would use that
p1922
aVIt's the most straight-forward
p1923
aVAnother way is to use an enumeration
p1924
aVMaybe that's even better and faster, since no boxing is required:
p1925
aVThere is the advantage of the first that users of your class doesn't need to care about your three-state boolean
p1926
aVThey can still pass  and
p1927
aVIf you don't like the , since it's telling rather little about its meaning here, you can still make a  in your class
p1928
as(dp1929
g15
V34509
p1930
stp1931
a((dp1932
g2
(lp1933
VPersonally, i just use the filename FOO_HPP
p1934
aVGoogle uses the whole path like SRC_ENGINE_FAST_HPP
p1935
aVCertain sets of names and function
p1936
aVsignatures are always reserved to the
p1937
aVimplementation:
p1938
aVEach name that contains a double underscore (_ _) or begins with an
p1939
aVunderscore followed by an uppercase
p1940
aVletter (2
p1941
aV11) is reserved to the
p1942
aVimplementation for any use
p1943
aVEach name that begins with an underscore is reserved to the
p1944
aVimplementation for use as a name in
p1945
aVthe global namespace
p1946
aV()
p1947
as(dp1948
g15
V34509
p1949
stp1950
a((dp1951
g2
(lp1952
VStroustrup has an item on this in his FAQ:
p1953
aVWhy can't I assign a  to a
p1954
aVYou can solve it in two ways:
p1955
aVMake the List contain pointers to
p1956
aVThen accept
p1957
aVMake your function a template
p1958
aVYou can still use  and  then, but it's more boilerplate code, and not necassary most of the time
p1959
aVHere is code for the second alternative
p1960
aVThe first alternative is already explained by other answers:
p1961
aVTo restrict  only for , some more code is needed (look for  if you want to know)
p1962
aVNote that this kind of code (looking what type you have) is rather to avoid
p1963
aVYou should handle such things with virtual functions
p1964
aVAdd a function  to Control, and override it in Button
p1965
as(dp1966
g15
V34509
p1967
stp1968
a((dp1969
g2
(lp1970
V in itself is not slow
p1971
aVSlowness is always relative i bet for my life that you haven't ever felt the "overhead" of an if-statement
p1972
aVIf you are going to make a high-performance code, you migh want to avoid branches anyway
p1973
aVWhat makes  slow is that the processor is preloading code from after the  based on some heuristic and whatnot
p1974
aVIt will also stop pipelines from executing code directly after the  branch instruction in the machine code, since the processor doesn't know yet what path will be taken (in a pipelined processor, multiple instructions are interleaved and executed)
p1975
aVCode executed could have to be executed in reverse (if the other branch was taken
p1976
aVit's called ), or 's be filled at those places so that this doesn't happen
p1977
aVIf  is evil, then  is evil too, and ,  too
p1978
aVDon't worry about it
p1979
as(dp1980
g15
V34509
p1981
stp1982
a((dp1983
g2
(lp1984
VWhen possible use  or  instead of calls through function pointers
p1985
aVClarification:  instead of  can inline the calls
p1986
aVWhen possible and not harm causing, prefer CRTP to virtual functions
p1987
aVWhen possible, avoid C Strings and use a String class
p1988
aVIt will be faster most often
p1989
aV(constant time length "measure", appending amortized constant time,
p1990
aVAlways pass user defined typed values (apart from where it doesn't make sense
p1991
aVe
p1992
aVg iterators) by reference to const (T const&) instead of copying value
p1993
aVFor user defined types, always prefer  instead of
p1994
aVUse  early, often
p1995
aVMost important to improve readability
p1996
aVTry keeping  to a minimum
p1997
aVAlways prefer automatic variables (on the stack) if possible
p1998
aVInstead of filling arrays yourself, prefer initialization with an empty initializer list like  if you want zeros
p1999
aVUse the constructor initializer list as often as possible, especially when initializing user defined typed members
p2000
aVMake use of functors (types with  overloaded)
p2001
aVThey inline better than calls through function pointers
p2002
aVDon't use classes like  or  if you have a fixed sized quantity not growing
p2003
aVUse  or a naked array and use it properly
p2004
aVAnd indeed, i almost forgot it:
p2005
aVPremature optimization is the root of all evil
p2006
as(dp2007
g15
V34509
p2008
stp2009
a((dp2010
g2
(lp2011
VIf  is overloaded, you need to cast the null explicitly to  so the right overload is chosen:
p2012
aVA non-contrived situation where you need to cast is when you call a varargs function:
p2013
aVThe last line will produce the following warning:
p2014
aVExample
p2015
aVjava:26: warning: non-varargs
p2016
aVcall of varargs method with inexact
p2017
aVargument type for last parameter;
p2018
aVcast to  for a varargs
p2019
aVcallcast to  for a
p2020
aVnon-varargs call and to suppress this
p2021
aVwarning
p2022
as(dp2023
g15
V34509
p2024
stp2025
a((dp2026
g2
(lp2027
Vis going to tar all not hidden files/directories of the current directory to stdout, then piping that into a new subshells' stdin
p2028
aVThat shell first changes the current working directory to , and then untars it to that directory
p2029
as(dp2030
g15
V34509
p2031
stp2032
a((dp2033
g2
(lp2034
VThe tool of choice is rsync
p2035
aVIt will synchronize your files/folders between your laptop and your PC
p2036
aVTo synchronize your source files, however, i would recommend a version control system
p2037
aVgit (especially recently
p2038
aVmanaging the linux kernel, freedesktop
p2039
aVorg repositories for example) and Subversion (managing KDE for example) are quite popular
p2040
as(dp2041
g15
V34509
p2042
stp2043
a((dp2044
g2
(lp2045
VFirst, the cause of this issue: C++ Standard  defines an order for conversion sequences
p2046
aVIt says that a user defined conversion sequence is worse than a standard conversion sequence
p2047
aVWhat happens in your case is that the string literal undergoes a boolean-conversion (defined at
p2048
aVThis is a standard conversion)
p2049
aVIt does not use the user defined conversion to  which would be needed if it took the other overload
p2050
aVI would recommend to simply change the name of one of the overloads or adding an overload that accepts the string literal directly (using parameter type )
p2051
as(dp2052
g15
V34509
p2053
stp2054
a((dp2055
g2
(lp2056
VThere are not always addresses involved
p2057
aVThe compiler can put variables into registers if it finds that their address is never taken by the programmer
p2058
aVSo you wouldn't need any access to the main memory
p2059
aVFor example in your code above, what the compiler could generate could be as simple as
p2060
aVto put value 3 into register 2
p2061
aVAs soon as you create a pointer and make it point to that variable, then you have an address, actually
p2062
aVAnd then the variable cannot be in a register only anymore
p2063
as(dp2064
g15
V34509
p2065
stp2066
a((dp2067
g2
(lp2068
Vtransform(test
p2069
aVbegin(),test
p2070
aVend(),test
p2071
aVbegin(),
p2072
aV(_1+=var(a),++var(a)));
p2073
aVThis will translate to
p2074
aVStarting with a=0 will result in 1 in the first run
p2075
aVWe are incrementing a 10 times, so we will get 10 in the last run
p2076
aVfor_each(test
p2077
aVbegin(),test
p2078
aVend(),(_1+=var(a),++var(a)));
p2079
aVThis will translate to
p2080
aVStarting with a=0, we will get 0 in the first run
p2081
aVWe increment a 10 times, but assign it just before incrementing
p2082
aVThus the last number is 9
p2083
aVI hope it's clear now with the translation to ordinary functions what those two do
p2084
as(dp2085
g15
V34509
p2086
stp2087
a((dp2088
g2
(lp2089
VI would use the default OS colors
p2090
aVBut actually if i could, i wouldn't put any color/themes at all there
p2091
aVI would put some information/controls in that area (assuming you talk about the background of an MDI/SDI application)
p2092
aVSimilar to what the most recent openoffice 3 version has done
p2093
aVFor example, put "What do you want me to do
p2094
aVOpen / Exit / Tutorial /
p2095
aVinto it
p2096
as(dp2097
g15
V34509
p2098
stp2099
a((dp2100
g2
(lp2101
VWell, dwarf2 builds up tables for every function, that contain what the callee saved registers are and where in the stack they are saved, and where the frame pointer/return address in the callstack is, and some other stuff
p2102
aVIf you use dwarf2, the compiler can use those information and effectively restore registers, and jump back to callers in the event of an exception
p2103
aVThe backends need to provide information in their implementations' prologue generating code, to tell GCC which registers are callee-saved, and when the frame pointer was saved and such stuff
p2104
aVUsing setjmp/longjmp is just a hack
p2105
aVSince setjmp/longjmp does not know about the structure of the function throwing, it will restore all registers saved in the jump-buffer by setjmp, even if they were not overridden by the throwing function
p2106
aVI'm not really an expert for this, but i think it's obvious that this will not be efficient
p2107
aVAlso, every time you start a try block, setjmp has to be called to set up the buffer containing the saved registers, while when using dwarf2, the compiler already provides all necessary information at compile time
p2108
aVIf the backends do not provide the necessary information, GCC will automatically fall-back to setjmp/longjmp based exception handling
p2109
aVNote i'm not a GCC expert
p2110
aVI just ported the toolchain to some easy processor of my professor, including GCC
p2111
aVI hope i could help you a bit
p2112
as(dp2113
g15
V34509
p2114
stp2115
a((dp2116
g2
(lp2117
VAdd the function to the struct:
p2118
aVNote the typedef struct {
p2119
aV} name; pattern is not needed in C++
p2120
aVIf you for some reason have to use a free function for this, use reference:
p2121
as(dp2122
g15
V34509
p2123
stp2124
a((dp2125
g2
(lp2126
VStructures cannot be extern or static
p2127
aVIf you want to have a structure used in more than two translation units, put the structure definition into a header:
p2128
aVfoo
p2129
aVhpp
p2130
aVThen include that header file into all source files using that struct
p2131
aVHaving a struct/class/union defined in multiple source-files is perfectly valid, as long as each one is same defined
p2132
aVYou can put a Include Guard around the definition of  to prevent that foo is included twice into the same sourcefile being compiled
p2133
aV(So, having multiple  in the same program is valid, but having multiple  in the same source (note: meaning translation unit) is not valid
p2134
aVSee 3
p2135
aV2 One Definition Rule in the C++ Standard or a Draft
p2136
aVWhen you see this:
p2137
aVNot the  is extern, but the  (the object) is extern
p2138
aVIt's saying that  is not defined, but merely declared, so you can refer to it
p2139
as(dp2140
g15
V34509
p2141
stp2142
a((dp2143
g2
(lp2144
VSounds like you are trying to use it to store a list
p2145
aVWhy not use
p2146
aVHaving a  in a String is bad
p2147
aVConsider using a byte array
p2148
aVAs you say its for saving something in the eclipse settings, i wouldn't use embedded NULs, since the files seem to be user-readable (in my ~/
p2149
aVeclipse at least)
p2150
aVWhat do you want to save
p2151
aVYou could stringize the items ("item 2" "item 2") for example
p2152
aVJust don't complicate it too much
p2153
as(dp2154
g15
V34509
p2155
stp2156
a((dp2157
g2
(lp2158
VWell you can't do it
p2159
aVThe  mechanism works like this:
p2160
aVI hope it's clear what the above does
p2161
aVThere is no way you could do what you are looking for i think
p2162
aVThe reason is that there is no information about the type kept that could prove useful here
p2163
aVRTTI doesn't provide it
p2164
as(dp2165
g15
V34509
p2166
stp2167
a((dp2168
g2
(lp2169
Vwill shrink  again: http://www
p2170
aVgotw
p2171
aVca/gotw/054
p2172
aVhtm (Herb Sutter)
p2173
aVIf you want to clear it anyway, swap with an empty vector:
p2174
aVwhich of course is way more efficient
p2175
aV(Note that swapping vectors basicially means just swapping two pointers
p2176
aVNothing really time consuming going on)
p2177
as(dp2178
g15
V34509
p2179
stp2180
a((dp2181
g2
(lp2182
VHow can I make an array which points
p2183
aVto objects
p2184
aVIf I want to return a pointer to an
p2185
aVarray, which points to objects (like
p2186
aV(1)) how can I do this in a method
p2187
aVTechnically, you write this function:
p2188
aVThat returns a pointer to that array
p2189
aVHowever, you don't want to do that
p2190
aVYou wanted to return a pointer to the first element of the array:
p2191
aVThat way, you can now access items as you want like
p2192
as(dp2193
g15
V34509
p2194
stp2195
a((dp2196
g2
(lp2197
VMacros are not evil
p2198
aVLike anything, if you abuse them, they will be evil and bite you
p2199
aVThey are still state of the art for header guards, for example
p2200
aVAnd they have proven to be quite useful for repeating tasks for me
p2201
as(dp2202
g15
V34509
p2203
stp2204
a((dp2205
g2
(lp2206
VI don't like TODOs that don't explain the problem, but only say what should be done instead, like
p2207
as(dp2208
g15
V34509
p2209
stp2210
a((dp2211
g2
(lp2212
VRead the answer given here about the difference of  and  in a parameter list: Difference between  and
p2213
aVI've really put so much love into that answer
p2214
aV:)
p2215
aVRegarding your question about your  and  functions, James Curran provided an excellent answer
p2216
as(dp2217
g15
V34509
p2218
stp2219
a((dp2220
g2
(lp2221
VI recommend
p2222
aVDo not do a MDI application with sub-frames like those found in the old Windows days
p2223
aVThey suck as they make the matter confusing
p2224
aVDo design a tabbed interface
p2225
aVThe welcome page/menu will be displayed on a first tab that is always created on the start
p2226
aVAll cool kids do that nowadays:
p2227
aVVisual Studio
p2228
aVEclipse
p2229
aVFirefox
p2230
as(dp2231
g15
V34509
p2232
stp2233
a((dp2234
g2
(lp2235
Vgdb will automatically debug functions in the library when they are called
p2236
aVjust call it like
p2237
aV:)
p2238
aVBe sure you build foo with debugging flags ( will enable all debugging stuffs for gcc :)
p2239
aVYou should not optimize when debugging (pass at most  to gcc, do not optimize further)
p2240
aVIt can confuse the debugger
p2241
as(dp2242
g15
V34509
p2243
stp2244
a((dp2245
g2
(lp2246
VBecause you link the startup files to your program, which contains (usually) assembler code that calls your main
p2247
aVIf main were static, that code wouldn't be able to call main
p2248
aVmeans that other so-called  can see your symbol declared extern in its own translation-unit
p2249
aVSo, your main is extern, and it will have an entry in its translation-units symbol table that states its address
p2250
aVOther translation-units will then be able to jump to that address when they want to call main
p2251
aVmeans your symbol is strictly translation-unit local
p2252
aVThis means other  will not be able to see that symbol
p2253
aVThus, symbols with static linkage can occur in different translation units multiple times, and they won't clash with each other because they are local
p2254
aVEdit: Generally, files generated by the compiler from translation units are specific to that particular compiler
p2255
aVFor gcc on linux, often the ELF object format is used
p2256
aVYou can view its symbol table using  (simple test-file below):
p2257
aVtest
p2258
aVc
p2259
aVHere is the output of readelf:
p2260
aVYou see the main function, and a static foo function, called by main
p2261
aVAlso there is a function called which is not defined in the file, but which is defined in another object file
p2262
aVAs the object file wasn't finally linked yet, the functions don't have final addresses assigned yet
p2263
aVAfter the final link, these will be arranged into the executable and will have addresses assigned
p2264
aVThe object file has entries for calls to not-yet defined functions, so that when the file is linked, those call instructions can have the final addresses stored ():
p2265
as(dp2266
g15
V34509
p2267
stp2268
a((dp2269
g2
(lp2270
VIn C++, it is not possible to have an array on the stack with a size determined at runtime
p2271
aVHere you use std::vector to do that:
p2272
aVIf the size is known at compile-time, you can just go ahead with a plain array:
p2273
aVIf you are allowed to use boost, it is better to use boost::array , since it provides iterators like containers do, and you will be able to get its size using
p2274
aVsize():
p2275
as(dp2276
g15
V34509
p2277
stp2278
a((dp2279
g2
(lp2280
VYou can use the technique described here: http://augustss
p2281
aVblogspot
p2282
aVcom/2007/04/overloading-haskell-numbers-part-2
p2283
aVhtml
p2284
aVMake your type be of the necassary type-classes (Num, Fractional, Floating) so that -, +, * and so on works for your type
p2285
aVThen if the expression tree is finally built, you can operate on it to see what you can simplify
p2286
as(dp2287
g15
V34509
p2288
stp2289
a((dp2290
g2
(lp2291
VThe problem is that it first looks in the scope of your class, and finds a foo function
p2292
aVThe lookup will stop then, and the compiler tries to match arguments
p2293
aVSince it only has the one foo function in that scope in your class, calling the function fails
p2294
aVYou need to explicitly state that you want to call the free function:
p2295
aVAnother solution is to declare the function within baz:
p2296
aVThe scope that the foo function is assumed to be defined in is the surrounding namespace of your class
p2297
as(dp2298
g15
V34509
p2299
stp2300
a((dp2301
g2
(lp2302
VI would discourage from /FI  (MSDN says it's called /FI
p2303
aVNot sure whether i looked at the right page though), simply because people or yourself reading the files don't notice a header is magically included anyway
p2304
aVYou can be sure this will cause much debugging time for someone that wants to figure out where specific macros come from, even though there are no  lines at the top of the file
p2305
as(dp2306
g15
V34509
p2307
stp2308
a((dp2309
g2
(lp2310
VOnly specializations are allowed
p2311
aVSo for example, you are allowed to specialize  for your type
p2312
aVAnd this of course must happen in namespace
p2313
aVBut your typedef isn't a specialization so that's causing undefined behavior
p2314
as(dp2315
g15
V34509
p2316
stp2317
a((dp2318
g2
(lp2319
VSee how i hate this:
p2320
aVAlways put them like this:
p2321
as(dp2322
g15
V34509
p2323
stp2324
a((dp2325
g2
(lp2326
VI researched, and this is quite hairy:
p2327
aVis deprecated, thus isn't listed in the manpage for  anymore, but still in the one for bash
p2328
aVUse
p2329
aVFor single '[', the bash builtin behaves the same as the  bash builtin, which behaves the same as  and  (the one is a symlink to the other)
p2330
aVNote the effect of  depends on its position: If it's at the start, it means
p2331
aVIf it's in the middle of two expressions, it means logical
p2332
aVdoesn't work, as the bash manual points out that  is considered a binary operator there, and so the above isn't parsed as a  but as a  (non-empty)
p2333
aVThus, your script always outputs  (which actually tests for files), and  which actually is a binary  here
p2334
aVFor ,  isn't used as a binary  anymore ( is used there), so its unique purpose is to check for a file there (although being deprecated)
p2335
aVSo, negation actually does what you expect
p2336
as(dp2337
g15
V34509
p2338
stp2339
a((dp2340
g2
(lp2341
VAnd here is the rounding way which doesn't truncate
p2342
aVHurried to look it up in the Java API Manual:
p2343
as(dp2344
g15
V34509
p2345
stp2346
a((dp2347
g2
(lp2348
VI think they are global to all requests made with that specific thread only
p2349
aVOther threads get other copies of the thread-local data
p2350
aVThis is the key point of thread-local storage:
p2351
aVhttp://en
p2352
aVwikipedia
p2353
aVorg/wiki/Thread-local_storage#Java
p2354
aVUnless you check the appropriate option in the servlets config, the servlet container will use your servlet with multiple threads to handle requests in parallel
p2355
aVSo effectively you would have separate data for each thread that's up serving clients
p2356
aVIf your WebApplication isn't distributed (runs on multiple Java Virtual Machines), you can use the  object to store shared data across requests and threads (be sure to do proper locking then)
p2357
as(dp2358
g15
V34509
p2359
stp2360
a((dp2361
g2
(lp2362
VI'm afraid there isn't any in Standard C / C++
p2363
aVThere is the POSIX function  which can convert to , which can then be converted to  using
p2364
aVIf you are aiming for cross platform compatibility, better use , which has sophisticated functions for this
p2365
as(dp2366
g15
V34509
p2367
stp2368
a((dp2369
g2
(lp2370
VHere is everything you need to know for this: http://augustss
p2371
aVblogspot
p2372
aVcom/2007/04/overloading-haskell-numbers-part-1
p2373
aVhtml
p2374
as(dp2375
g15
V34509
p2376
stp2377
a((dp2378
g2
(lp2379
Vwill only work if  has an overloaded  that can output your struct
p2380
aVYou can output individual members of the struct instead like this:
p2381
aVAlternatively, the following is equivalent to that:
p2382
aVYou have to put parentheses around *Iter, since the member-access operator binds thighter otherwise
p2383
aVOn a side-node, make your main function return int instead of void
p2384
aVmaking it return void is not valid in C++
p2385
aVYou declare the vector like this:
p2386
aVThe second argument to  should be another thing
p2387
aVIt's not needed for your code to give the vector a second argument at all
p2388
aVJust use this:
p2389
aVAnother thing i noticed is you increment the iterator using  (called )
p2390
aVFor iterators, always prefer , which is called
p2391
as(dp2392
g15
V34509
p2393
stp2394
a((dp2395
g2
(lp2396
VHere is how i do it:
p2397
as(dp2398
g15
V34509
p2399
stp2400
a((dp2401
g2
(lp2402
VWell, you can theoretical build a regex that matches the opposite
p2403
aVBut for longer strings, that regex would become big
p2404
aVThe way you would do that systematically is (greatly simplified):
p2405
aVConvert the regular expression into a deterministic finite automaton
p2406
aVConvert the end conditions of the automaton, so that it accepts the inverted regular language
p2407
aVConvert the automaton back to a regular expression by successively removing nodes from the automaton, yet keeping the behavior of it the same
p2408
aVRemoving one node will require putting two or more regular expressions together, so that they will account for the removed node
p2409
aVIf you happen to have one start node, and one end node, you are finished: The regular expression labeling the edge between them is your searched regular expression
p2410
aVPractically, you can just match for the string you want not have in it, and invert the result
p2411
aVHere is what it would look like in awk:
p2412
aVIf you are interested into this, i recommend the book "Introduction to the Theory of Computation" by Michael Sipser
p2413
as(dp2414
g15
V34509
p2415
stp2416
a((dp2417
g2
(lp2418
V and  are actually hard links in filesystems
p2419
aVThey are needed so that you can specify relative paths, based on some reference path (consider )
p2420
aVSince these hard links are actually existing in the filesystem, it makes sense for  to tell you about them
p2421
aV(actually the term  just means some name that is indistinguishable from the actual directory referred to: they both point to the same  in the filesystem)
p2422
aVBest way is to just  and ignore them, if you don't want to list them
p2423
as(dp2424
g15
V34509
p2425
stp2426
a((dp2427
g2
(lp2428
VIt generally escapes the following character:
p2429
aVIn a string literal or character literal, it means escape the next character
p2430
aVmeans 'alert' (flashing the terminal, beeping or whatever),  means 'linefeed',  means an hexadecimal number for example
p2431
aVIf it appears as the last visible character before a newline, whether within a string or not (and even within a line-wide comment
p2432
aV, it acts as a line-continuation: The following newline character is ignored, and the next line is merged with the current line
p2433
as(dp2434
g15
V34509
p2435
stp2436
a((dp2437
g2
(lp2438
VWhat unwind and ckarmann say
p2439
aVHere is a hint, i implement listcontains for you to give you the idea how the assignment could be meant:
p2440
aVSo, you only have the head of the list, which links to the next node in turn
p2441
aVThe tail will have ;
p2442
as(dp2443
g15
V34509
p2444
stp2445
a((dp2446
g2
(lp2447
VThe getopt function is very common for C programming
p2448
aVIt can parse parameters for you
p2449
aVHere is a question (and answer) where to get it for C#: http://stackoverflow
p2450
aVcom/questions/172443/getopt-library-for-c
p2451
aVEspecially lappies implementation looks like rather modern C# with attributes and such
p2452
as(dp2453
g15
V34509
p2454
stp2455
a((dp2456
g2
(lp2457
VYou should never expect them outperform assignments
p2458
aVThe reason is, the compiler will use memcpy anyway when it thinks it would be faster (if you use optimize flags)
p2459
aVIf not and if the structure is reasonable small that it fits into registers, direct register manipulation could be used which wouldn't require any memory access at all
p2460
aVGCC has special block-move patterns internally that figure out when to directly change registers / memory cells, or when to use the memcpy function
p2461
aVNote when assigning the struct, the compiler knows at compile time how big the move is going to be, so it can unroll small copies (do a move n-times in row instead of looping) for instance
p2462
aVNote :
p2463
aVWho knows it better when to use memcpy than the compiler itself
p2464
as(dp2465
g15
V34509
p2466
stp2467
a((dp2468
g2
(lp2469
VSome points (but note: these are not evil indeed
p2470
aVIf you want to change to non-template code, though, this can help out):
p2471
aVLookup your static interfaces
p2472
aVWhere do templates depend on what functions exist
p2473
aVWhere do they need typedefs
p2474
aVPut the common parts in an abstract base class
p2475
aVA good example is when you happen to stumble over the CRTP idiom
p2476
aVYou can just replace it with an abstract base class having virtual functions
p2477
aVLookup integer lists
p2478
aVIf you find your code uses integral lists like , you can replace them with , if all the codes using them can live with working with runtime values instead of constant expressions
p2479
aVLookup type traits
p2480
aVThere is much code involved checking whether some typedef exists, or whether some method exists in typical templated code
p2481
aVAbstract baseclasses solve these two issues by using pure virtual methods, and by inheriting typedefs to the base
p2482
aVOften, typedefs are only needed to trigger hideous features like SFINAE, which would then be superfluous too
p2483
aVLookup expression templates
p2484
aVIf your code uses expression templates to avoid creating temporaries, you will have to eliminate them and use the traditional way of returning / passing temporaries to the operators involved
p2485
aVLookup function objects
p2486
aVIf you find your code uses function objects, you can change them to use abstract base classes too, and have something like  to call them (or if you want to keep using , better so
p2487
aVIt can be virtual too)
p2488
as(dp2489
g15
V34509
p2490
stp2491
a((dp2492
g2
(lp2493
VThe base class constructor taking no arguments is automatically run if you don't call any other base class constructor taking arguments explicitly
p2494
as(dp2495
g15
V34509
p2496
stp2497
a((dp2498
g2
(lp2499
VYou can do this, which doesn't need to create the string
p2500
aVIt makes the output stream read out the contents of the stream on the right side (usable with any streams)
p2501
as(dp2502
g15
V34509
p2503
stp2504
a((dp2505
g2
(lp2506
VThis is best done using  and  when you want to use the C++ Standard Library:
p2507
aVConsider putting it into an own struct:
p2508
as(dp2509
g15
V34509
p2510
stp2511
a((dp2512
g2
(lp2513
VMy favourite is
p2514
aVYes, all of a sudden, that's magically faster
p2515
as(dp2516
g15
V34509
p2517
stp2518
a((dp2519
g2
(lp2520
VQuick & Dirty Answer
p2521
aVCorrect Way
p2522
aVFirst, calling a member variable  probably isn't wise
p2523
aVSince the class is already called like that, it will confuse readers
p2524
aVNaming conventions in Java state member variables are like  for example
p2525
aV(note: original question changed)
p2526
aVUser defined format
p2527
aVNote you can convert any number to a string by simply doing  too
p2528
aVIf you have many strings, consider using a string builder, as that's faster and won't update the GUI element multiple times: (also fixes the initial  before the first item, which happens above)
p2529
aVCanonical array representation
p2530
aVAlternatively, you can use this:
p2531
aVIt will look like
p2532
as(dp2533
g15
V34509
p2534
stp2535
a((dp2536
g2
(lp2537
VLook at its API Manual
p2538
aVIf it is a C API, you probably have to  it
p2539
aVIf it doesn't provide its own function like sqlite3_free (pcre does this for example), you have to use that function
p2540
aVWhat you can't do is delete it using C++'s delete operator, since you have got a void pointer
p2541
aVYou cannot delete a void pointer, since the compiler has to know about its type
p2542
aV(and void is an incomplete type
p2543
aVyou can't delete incomplete types either)
p2544
as(dp2545
g15
V34509
p2546
stp2547
a((dp2548
g2
(lp2549
Vstatic methods can be called also using an object of the class, just like it can be done in Java
p2550
aVNevertheless, you shouldn't do this
p2551
aVUse the scope operator like  Maybe you think of namespaces:
p2552
aVwhich can only be called by  from outside that namespace if the function is not imported explicitly using a  into the scope of the caller
p2553
as(dp2554
g15
V34509
p2555
stp2556
a((dp2557
g2
(lp2558
VI would recommend  and  (generic image libray)
p2559
aVBecause there are quite much templates involved, I'm not sure whether the code-size will still be acceptable for you
p2560
aVBut it's part of boost, so it is probably worth a look
p2561
as(dp2562
g15
V34509
p2563
stp2564
a((dp2565
g2
(lp2566
VRather than applying a work around each time again, you can fix the problem once and for all by writing a function object, and using that like strager proposed (though his implementation is rather not C++):
p2567
aVAs i don't know your column type, i've left it templated
p2568
aVNow, whenever you want to build a query, just do
p2569
as(dp2570
g15
V34509
p2571
stp2572
a((dp2573
g2
(lp2574
VIf you have many clients, then it may be a good idea to put calculations on the clients with JavaScript
p2575
aVIf you do everything on the server, you are just going to waste the many processing powers provided by the client's browsers, and the speed advantage of Java would be for naught if too many clients make the server busy
p2576
aV(Thanks to @Subtenante in the comments for pointing this out
p2577
aVBut on the other side, Java running on the server is faster than JavaScript on the client, and it won't suffer from redundant code on the client, for testing which browser the client runs
p2578
aVJavaScript has its uses as trex pointed out, though
p2579
aVSince it runs on the client, it can for example validate form fields before sending it to the server
p2580
as(dp2581
g15
V34509
p2582
stp2583
a((dp2584
g2
(lp2585
VFrom a language point of view, you can improve performance by reserving 26 (or 27 depending on what number you mean :)) items in the vector:
p2586
aVthis will make the internal array large enough and avoids reallocation of the vector
p2587
aVWhether returning the vector, or passing a vector by reference and writing to that is more performant will only be figured out by doing tests
p2588
aVCompilers can optimize away return value copies
p2589
aVGenerally though, you will get more performance boost, if you optimize the algorithm itself (or by chosing another one), than trying to optimize its implementation
p2590
as(dp2591
g15
V34509
p2592
stp2593
a((dp2594
g2
(lp2595
VYes, taking a reference is fine there
p2596
aVYou don't intend to give the method shared ownership; it only wants to work with it
p2597
aVYou could take a reference for the first case too, since you copy it anyway
p2598
aVBut for first case, it takes ownership
p2599
aVThere is this trick to still copy it only once:
p2600
aVYou should also copy when you return it (i
p2601
aVe not return a reference)
p2602
aVBecause your class doesn't know what the client is doing with it (it could store a pointer to it and then big bang happens)
p2603
aVIf it later turns out it's a bottleneck (first profile
p2604
aV, then you can still return a reference
p2605
aVEdit: Of course, as others point out, this only is true if you know your code and know that you don't reset the passed shared pointer in some way
p2606
aVIf in doubt, just pass by value
p2607
as(dp2608
g15
V34509
p2609
stp2610
a((dp2611
g2
(lp2612
Vefotinis found a good way using from_stream
p2613
aVI've looked into the manual of  and found it supports facets:
p2614
aVYou could also go with that
p2615
aVI've looked up how date facets work:
p2616
aVThe  template implements a facet
p2617
aVFacets are derived from  and every one has an unique id
p2618
aVYou can imbue a new locale into a stream, replacing its old locale
p2619
aVThe locale of a stream will be used for all sorts of parsing and conversions
p2620
aVWhen you create a new  using the form i showed, you give it an existing locale, and a pointer to facet
p2621
aVThe given facet will replace any existing facet of the same type in the locale given
p2622
aV(so, it would replace any other date_input_facet used)
p2623
aVAll facets are associated with the locale somehow, so that you can use  to check whether the given locale has some given facet type
p2624
aVYou can use a facet from one locale by doing
p2625
aVdate_input_facet has a function get, which can be used like this:
p2626
aVThe below is essentially done by  by boost::date_type :
p2627
as(dp2628
g15
V34509
p2629
stp2630
a((dp2631
g2
(lp2632
VThey are not really comparable
p2633
aVApache Tomcat is not a J2EE Server
p2634
aVIt's merely a Servlet Container for Web-Applications
p2635
aVNothing more
p2636
aVIf you need J2EE API implementations, you have to take those from elsewhere
p2637
aVFor example by using the Apache Geronimo Server which uses Tomcat as its container, or by taking the JAR files from Glassfish
p2638
aVGlassfish is a complete Java Application Server with implementation for APIs like JPA, EJBs and more
p2639
aVGlassfish contains a Servlet Engine initially used by Tomcat, but they improved it (don't know what exactly)
p2640
aVMore recent glassfish servers use another container using  which uses the NIO API for input/output and scales quite well
p2641
aVAs far as i know, the Glassfish Servlet Engine is more performant
p2642
aVHere i've found a nice benchmark (it's a bit old though):
p2643
aVhttp://weblogs
p2644
aVjava
p2645
aVnet/blog/sdo/archive/2007/05/how_to_test_con
p2646
aVhtml
p2647
as(dp2648
g15
V34509
p2649
stp2650
a((dp2651
g2
(lp2652
VI only know what the C Standard says about this (C99):
p2653
aVThe value of an integer character
p2654
aVconstant containing more than one
p2655
aVcharacter (e
p2656
ag774
aV, 'ab'), or containing
p2657
aVa character or escape sequence that
p2658
aVdoes not map to a single-byte
p2659
aVexecution character, is
p2660
aVimplementation-de\ufb01ned
p2661
aVIf an integer
p2662
aVcharacter constant contains a single
p2663
aVcharacter or escape sequence, its
p2664
aVvalue is the one that results when an
p2665
aVobject with type char whose value is
p2666
aVthat of the single character or escape
p2667
aVsequence is converted to type int
p2668
aV(6
p2669
aV4
p2670
ag2670
aV4/10 taken from a draft)
p2671
aVSo it's implementation defined
p2672
aVMeaning it is not guaranteed it works the same everywhere, but the behavior must be documented by the implementation
p2673
aVFor example if  is only 16 bits wide in a particular implementation, then  can't be represented anymore like you intend it ( must be at least 8 bits, while a character literal is always of type )
p2674
as(dp2675
g15
V34509
p2676
stp2677
a((dp2678
g2
(lp2679
VI don't know what is wrong with it, but one little point i noticed:
p2680
aVChange  into
p2681
aVBecause if files have embedded spaces, you are now on the safe way
p2682
aVIt will expand into  then, instead of  (and note everywhere you use $FILE too remember to  it)
p2683
aVAnd what others say, you don't need to initialize  before you enter the loop
p2684
aVIt will be set to each of the filenames of the expanded positional parameters in the for loop automatically
p2685
aVHowever, i would go with an awk script like this:
p2686
aVNote that when a file contains multiple "^Count" lines, you would indeed say you read more files than you actually read if you rely on  to tell you the number of files read
p2687
as(dp2688
g15
V34509
p2689
stp2690
a((dp2691
g2
(lp2692
VYou can use the portable  (The standard C++ library can't do this):
p2693
as(dp2694
g15
V34509
p2695
stp2696
a((dp2697
g2
(lp2698
VIn C++, you can use functors like  which do this job nicely:
p2699
aVIf you need to do this many times, you can also solve the problem by making a function object which accepts member pointers and does the sort
p2700
aVYou can reuse it for any kind of object and members
p2701
aVFirst how you use it:
p2702
aVHere is the code for make_cmp
p2703
aVFeel free to rip it (using ):
p2704
as(dp2705
g15
V34509
p2706
stp2707
a((dp2708
g2
(lp2709
VException handling is included in free standing implementations
p2710
aVThe reason of this is that you possibly use  to compile your code
p2711
aVIf you compile with the option  you will notice it is missing the linker-option  when it invokes the linker process
p2712
aVCompiling with  will include that library, and thus the symbols defined in it
p2713
as(dp2714
g15
V34509
p2715
stp2716
a((dp2717
g2
(lp2718
VYes, you are right
p2719
aVWe can have pointers to pointers:
p2720
aVRead it from right to left: ppa is a pointer to a pointer to an int
p2721
aVIt's not limited to
p2722
aVYou can have as many levels as you want
p2723
aVwould be a pointer to pointer to pointer to int
p2724
aVI answered a similar question regarding whether primitive variables have addresses here:
p2725
aVhttp://stackoverflow
p2726
aVcom/questions/316194/is-primitive-assigned-a-memory-address#316310, the same applies to pointers too
p2727
aVIn short, if you never take the address of an object, the compiler doesn't have to assign it an address: It can keep its value in a register
p2728
as(dp2729
g15
V34509
p2730
stp2731
a((dp2732
g2
(lp2733
VTake boost
p2734
aVregex friend
p2735
aVif you are not allowed to use boost (sadly, there are still companies doing this), you could look into , which is a C++ binding developed by google for the famous PCRE library
p2736
as(dp2737
g15
V34509
p2738
stp2739
a((dp2740
g2
(lp2741
VFor copying you need to write a clone function, since a constructor cannot be virtual:
p2742
aVWhich each Packet implementation implement like this:
p2743
aVfor example for StatePacket
p2744
aVPacket classes should be immutable
p2745
aVOnce a packet is received, its data can either be copied out, or thrown away
p2746
aVSo a assignment operator is not required
p2747
aVMake the assignment operator private and don't define it, which will effectively forbid assigning packages
p2748
aVFor de-serialization, you use the factory pattern: create a class which creates the right message type given the message id
p2749
aVFor this, you can either use a switch statement over the known message IDs,  or a map like this:
p2750
aVIndeed, you should add check like whether the id is really known and such stuff
p2751
aVThat's only the rough idea
p2752
as(dp2753
g15
V34509
p2754
stp2755
a((dp2756
g2
(lp2757
VC++ Standard, 3
p2758
ag488
aV2/1 :
p2759
aVZero-initialization and
p2760
aVinitialization with a constant
p2761
aVexpression are collectively called
p2762
aVstatic initialization; all other
p2763
aVinitialization is dynamic
p2764
aVinitialization
p2765
aVObjects of POD types
p2766
aV(3
p2767
aV9) with static storage duration
p2768
aVinitialized with constant expressions
p2769
aV(5
p2770
aV19) shall be initialized before any
p2771
aVdynamic initialization takes place
p2772
aVObjects with static storage duration
p2773
aVdefined in namespace scope in the same
p2774
aVtranslation unit and dynamically
p2775
aVinitialized shall be initialized in
p2776
aVthe order in which their definition
p2777
aVappears in the translation unit
p2778
aVThis effectively means, even when another translation unit calls your SomeFunc function from outside, your SOME_VALUE constant will always be correctly initialized, because it's initialized with a constant expression
p2779
aVThe only way for your function being called early (before main) is while initializing an object with dynamic initialiation
p2780
aVBut by that time, according to the standard quote, the initialization of your POD variable is already done
p2781
as(dp2782
g15
V34509
p2783
stp2784
a((dp2785
g2
(lp2786
VIt's ill-formed in C++
p2787
aVMeaning that it doesn't compile with a standard conforming compiler
p2788
aVParagraph 7
p2789
aV1
p2790
aV5/4 in Annex C of the Standard explains the change "Banning implicit int"
p2791
as(dp2792
g15
V34509
p2793
stp2794
a((dp2795
g2
(lp2796
VThere is no answer possible
p2797
aVstatements like  might require zero asm lines
p2798
aVwhile statements like  might require 20+ asm lines
p2799
aVYou can see yourself by compiling a c program, and then starting
p2800
aVIt will display asm and C code intermixed, so you can see how many asm lines are generated for one C line
p2801
aVExample:
p2802
aVtest
p2803
ag2259
aV$
p2804
ag2804
as(dp2805
g15
V34509
p2806
stp2807
a((dp2808
g2
(lp2809
Vwill execute  locally when you press Ctrl+C
p2810
aVwill tell you about its other options
p2811
aVRegarding the  issue, i don't know much about ssh
p2812
aVMaybe you can make it call  instead of  to kill the remote command
p2813
as(dp2814
g15
V34509
p2815
stp2816
a((dp2817
g2
(lp2818
VEncoding in C++ is quite a bit complicated
p2819
aVHere is my understanding of it
p2820
aVEvery implementation has to support characters from the basic source character set
p2821
aVThese include common characters listed in 2
p2822
aV2/1 (2
p2823
aV3/1 in C++11)
p2824
aVThese characters should all fit into one
p2825
aVIn addition implementations have to support a way to name other characters using a way called  and look like  or  and can be used to refer to Unicode characters
p2826
aVA subset of them are usable in identifiers (listed in Annex E)
p2827
aVThis is all nice, but the mapping from characters in the file, to source characters (used at compile time) is implementation defined
p2828
aVThis constitutes the encoding used
p2829
aVHere is what it says literally (C++98 version):
p2830
aVPhysical source file characters are
p2831
aVmapped, in an implementation-defined
p2832
aVmanner, to the basic source character
p2833
aVset (introducing new-line characters
p2834
aVfor end-of-line indicators) if
p2835
aVnecessary
p2836
aVTrigraph sequences (2
p2837
aV3)
p2838
aVare replaced by corresponding
p2839
aVsingle-character internal
p2840
aVrepresentations
p2841
aVAny source file
p2842
aVcharacter not in the basic source
p2843
aVcharacter set (2
p2844
aV2) is replaced by the
p2845
aVuniversal-character-name that des-
p2846
aVignates that character
p2847
aV(An
p2848
aVimplementation may use any internal
p2849
aVencoding, so long as an actual
p2850
aVextended character encountered in the
p2851
aVsource file, and the same extended
p2852
aVcharacter expressed in the source file
p2853
aVas a universal-character-name (i
p2854
ag1992
aVusing the \u005cuXXXX notation), are
p2855
aVhandled equivalently
p2856
aVFor gcc, you can change it using the option
p2857
aVAdditionally, you can change the execution character used to represet values at runtime
p2858
aVThe proper option for this is  for char (it defaults to ) and  (which defaults to either  or  depending on the size of )
p2859
as(dp2860
g15
V34509
p2861
stp2862
a((dp2863
g2
(lp2864
VThe boost (tm) way:
p2865
aVThe Standard C++ way:
p2866
as(dp2867
g15
V34509
p2868
stp2869
a((dp2870
g2
(lp2871
VPersonally, i like the extensibility of free functions
p2872
aVA  function is an excellent example for this:
p2873
aVConsider now code that uses the free size function:
p2874
aVAs you see, you can just use  without needing to care about the namespace the type is in (depending on the argument type, the compiler figures out the namespace itself), and without caring what is going on behind the scenes
p2875
aVConsider also uses like  and  as free function
p2876
aVThis is exactly what  does too
p2877
as(dp2878
g15
V34509
p2879
stp2880
a((dp2881
g2
(lp2882
VWell
p2883
aVWhen you include  the compiler will read the file that contains declarations of the functions and macros that can be used
p2884
aVIf you call a function declared in that file (header), then the compiler inserts a call instruction into that place in your object file that will be made from the file you compile (let's call it  and the object file created )
p2885
aVIt also adds an entry into the relocation table of that object-file:
p2886
aVThis would be a relocation entry for a function bar
p2887
aVAn entry in the symbol table will be made noting the function is yet undefined:
p2888
aVWhen you link the  object file into a program, you need to link against the math library called
p2889
aVThe  extension is similar to the  extension for windows
p2890
aVIt means it is a shared object file
p2891
aVThe compiler, when linking, will fix-up all the places that appear in the relocation table of , replacing its entries with the proper address of the bar function
p2892
aVDepending on whether you use the shared version of the library or the static one (it's called  then), the compiler will do that fix-up after compiling, or later, at runtime when you actually start your program
p2893
aVWhen finished, it will inject an entry in the table of shared libraries needed for that program
p2894
aV(can be shown with ):
p2895
aVNow, if you start your program, the dynamic linker will lookup that library, and will link that library to your executable image
p2896
aVIn Linux, the program doing this is called
p2897
aVStatic libraries don't have a place in the dynamic section, as they are just linked to the other object files and then they are forgotten about; they are part of the executable from then on
p2898
aVIn reality it is actually much more complex and i also don't understand this in detail
p2899
aVThat's the rough plan, though
p2900
as(dp2901
g15
V34509
p2902
stp2903
a((dp2904
g2
(lp2905
VAs others suggested, the file probably is still opened by other processes
p2906
aVTo find out by which ones, you can do
p2907
aVwhich lists you the processes
p2908
aVProbably you will find tomcat in that list
p2909
as(dp2910
g15
V34509
p2911
stp2912
a((dp2913
g2
(lp2914
VSafe C++ Way
p2915
aVYou can define a function for this using :
p2916
aVTo assist you in figuring out what it does (some points are simplified):
p2917
aVCreation of a input-stringstream initialized with the string given
p2918
aVReading a double value out of it using
p2919
aVThis means skipping whitespace and trying to read a double
p2920
aVIf no double could be read, as in  the stream sets the fail-bit
p2921
aVNote that cases like  will succeed and will not set the fail-bit
p2922
aVIf the fail-bit is set,  evaluates to a zero value, which means false
p2923
aVIf an double was read, we skip trailing whitespace
p2924
aVIf we then are at the end of the stream (note that  will return true if we tried to read past the end
p2925
aVdoes exactly that),  will return true
p2926
aVNote this check makes sure that  will not pass our check
p2927
aVIf both cases, right and left of the  evaluate to true, we return true to the caller, signaling the given string is a double
p2928
aVSimilar, you check for  and other types
p2929
aVIf you know how to work with templates, you know how to generalize this for other types as well
p2930
aVIncidentally, this is exactly what  provides to you
p2931
aVCheck it out: http://www
p2932
aVboost
p2933
aVorg/doc/libs/1_37_0/libs/conversion/lexical_cast
p2934
aVhtm
p2935
aVC Way One
p2936
aVThis way has advantages (being fast) but also major disadvantages (can't generalized using a template, need to work with raw pointers):
p2937
aVwill set  to the last character processed
p2938
aVWhich is in our case the terminating null character
p2939
aVIf no conversion was performed, endptr is set to the value of the string given to
p2940
aVC Way Two
p2941
aVOne might thing that  does the trick
p2942
aVBut it's easy to oversee something
p2943
aVHere is the correct way to do it:
p2944
aVwill return the items converted
p2945
aVAlthough the Standard specifies that  is not included in that count, several sources contradict each other
p2946
aVIt's the best to compare  to get it right (see the manpage of )
p2947
aVwill be set to the amount of the processed characters
p2948
aVIt is compared to the size of the string
p2949
aVThe space between the two format specifiers accounts for optional trailing whitespace
p2950
aVConclusion
p2951
aVIf you are a beginner, read into  and do it the C++ way
p2952
aVBest not mess with pointers until you feel good with the general concept of C++
p2953
as(dp2954
g15
V34509
p2955
stp2956
a((dp2957
g2
(lp2958
VAs others has noted, you should neither use the , nor the  operator to get the dynamic type of what your pointer points to
p2959
aVvirtual functions were created to avoid this kind of nastiness
p2960
aVAnyway here is what you do if you really want to do it (note that dereferencing an iterator will give you
p2961
aVSo if you do  you will get an ):
p2962
aVNote you can apply the  operator to types itself too, as shown above
p2963
aVYou don't need to create an object for this
p2964
aVAlso note the typeid way doesn't work if you pass it a pointer like
p2965
aVUsing it like that will give you just  which isn't useful
p2966
aVSimilar,  can be used:
p2967
aVNote that in both cases, your Animal type should be polymorph
p2968
aVThat means it must have or inherited at least one virtual function
p2969
as(dp2970
g15
V34509
p2971
stp2972
a((dp2973
g2
(lp2974
VAs the first part of the question is already answered by others, here is the second part:
p2975
aVI assume by  you mean
p2976
aVAs haskell is a functional language, and functions behave as normal identifiers in any case, you can do that like this:
p2977
aVwhich would define an alias  for the function
p2978
aVNote that everything is a function
p2979
aVEven if it looks like a "variable", it's just a nullary function taking no arguments
p2980
aVAliases for types look like this:
p2981
aVwhich would define an alias  for the type
p2982
as(dp2983
g15
V34509
p2984
stp2985
a((dp2986
g2
(lp2987
VPassing by pointer
p2988
aVCaller has to take the address -> not transparent
p2989
aVA 0 value can be provided to mean
p2990
aVThis can be used to provide optional arguments
p2991
aVPass by reference
p2992
aVCaller just passes the object -> transparent
p2993
aVHas to be used for operator overloading, since overloading for pointer types is not possible (pointers are builtin types)
p2994
aVSo you can't do   using pointers
p2995
aVNo 0 values possible -> Called function doesn't have to check for them
p2996
aVReference to const also accepts temporaries: , pointers cannot be used like that since you cannot take the address of a temporary
p2997
aVLast but not least, references are easier to use -> less chance for bugs
p2998
as(dp2999
g15
V34509
p3000
stp3001
a((dp3002
g2
(lp3003
VOne possible solution is to ship boost::shared_ptr with your project
p3004
aVAs it all consists of headers, this would free your clients from having to install the boost libraries manually
p3005
aVYou can use bcp to get all files needed by a particular boost library, including the libraries itself
p3006
aVI did that when i worked for a company back then and needed  and it actually worked greatly
p3007
as(dp3008
g15
V34509
p3009
stp3010
a((dp3011
g2
(lp3012
VYou should write that this way (knowing little javascript myself, but i think this is right):
p3013
aVis only needed the first time you declare the variable
p3014
aVW3C DOM
p3015
aVIf you build up the string that you append / insert into your document like that, it will soon become quite confusing
p3016
aVFor example, if you want to change something, you have to fiddle with the strings
p3017
aVBetter you use the  API, which is standardized and provides a clean way to build up a element tree which can be appended to any child element into the document tree
p3018
aVHere you will find a nice introduction into the matter: W3C DOM Introduction
p3019
aVAfter you read this, you can start looking at the methods of W3C DOM
p3020
aVHere is a good reference: DOM2 Reference
p3021
aVStart with  and work your way through
p3022
as(dp3023
g15
V34509
p3024
stp3025
a((dp3026
g2
(lp3027
VYes, that is valid C++
p3028
aVOne purpose i've found for it is to translate exceptions into return values, and have the code translating the exceptions in return values separate from the other code in the function
p3029
aVYes, you can  from a catch block like the one you showed (i've only recently discovered that, actually)
p3030
aVBut i would probably just use another level of braces and put the try/catch inside the function in that case
p3031
aVIt will be more familiar to most C++ programmers
p3032
aVAnother purpose is to catch exceptions thrown by an constructor initializer list, which uses a similar syntax:
p3033
as(dp3034
g15
V34509
p3035
stp3036
a((dp3037
g2
(lp3038
VThere is a technique to remember how to build such type
p3039
aVFirst try to read pointers starting from their name and read from right to left
p3040
aVHow to declare that stuff without help
p3041
aVArrays
p3042
aVis an array of 5 T
p3043
aVTo make T a function type, you write the return-type to the left, and the parameters to the right:
p3044
aVwould be an array of 5 functions returning void and taking no parameters
p3045
aVBut functions itself can't be stuffed in arrays
p3046
aVThey are not objects
p3047
aVOnly pointers to them can
p3048
aVWhat about
p3049
aVThat's still wrong as it would just change the return-type to be a pointer to void
p3050
aVYou have to use parentheses:
p3051
aVand this will actually work
p3052
aVt is an array of 5 pointers to functions returning void and taking no parameters
p3053
aVGreat
p3054
aVWhat about an array of pointers to arras
p3055
aVThat's very similar
p3056
aVThe element type appears at the left, and the dimension at the right
p3057
aVAgain, parentheses are needed because otherwise the array would become a multidimensional array of integer pointers:
p3058
aVThat's it
p3059
aVAn array of 5 pointers to arrays of 3 int
p3060
aVWhat about functions
p3061
aVWhat we have just learned is true about functions too
p3062
aVLet's declare a function taking an int that returns a pointer to another function taking no parameter and returning void:
p3063
aVwe need parentheses again for he same reason as above
p3064
aVWe could now call it, and call the returned function pointed to again
p3065
aVReturning a pointer to function returning another pointer to function
p3066
aVWhat about this
p3067
aVIn other words, how would a function taking int returning a pointer to a function taking bool returning a pointer to a function taking double and returning void would look like
p3068
aVThe answer is that you just nest them:
p3069
aVYou could do so endless times
p3070
aVIndeed, you can also return a pointer to an array just like you can a pointer to a function:
p3071
aVThis is a function taking int returning a pointer to a function taking bool returning a pointer to an array of 3 int
p3072
aVWhat does it have to do with const
p3073
aVNow that the above explained how to build up complexer types from fundamental types, you can put  at places where you now know where they belong to
p3074
aVJust consider:
p3075
aVThe  is the basic type that we end up pointing to at the end
p3076
aVThe  stands for either const or not const
p3077
aVFor example
p3078
aVwill declare name to have the type pointer to a constant pointer to a constant int
p3079
aVYou can change , but you cannot change , which would be of type
p3080
aVand neither , which would be of type
p3081
aVLet's apply this to a function pointer of above:
p3082
aVThis would actually declare the array to contain constant pointers
p3083
aVSo after creating (and initializing) the array, the pointers are const, because the  appeared after the star
p3084
aVNote that we cannot put a  before the star in this case, since there are no pointers to constant functions
p3085
aVFunctions simply can't be const as that would not make sense
p3086
aVSo the following is not valid:
p3087
aVConclusion
p3088
aVThe C++ and C way of declaring functions and arrays actually is actually a bit confusing
p3089
aVYou have to get your head around it first, but if you understand it, you can write very compact function declarations using it
p3090
as(dp3091
g15
V34509
p3092
stp3093
a((dp3094
g2
(lp3095
VHere is the short answer:
p3096
aVHere's what it does:
p3097
aVYou might be interested in manpages
p3098
aVThat's where all people in here get their nice answers from
p3099
aVrefer to online man pages
p3100
as(dp3101
g15
V34509
p3102
stp3103
a((dp3104
g2
(lp3105
VThere doesn't seem to be a way
p3106
aVYou can, however, use
p3107
aVThis is C++ code, but can be easily adapted to wxPython:
p3108
aVThis is, you take the size of a reasonable width character (fonts may have variable width characters) and multiply it properly, adding some small value to account for native padding (say, 10px)
p3109
as(dp3110
g15
V34509
p3111
stp3112
a((dp3113
g2
(lp3114
VIt's like this if i'm not mistaken:
p3115
aVwill call
p3116
aVand that will go on until you got a base or nothing
p3117
aVIf you have  then that constructor having that will call the base constructor with the parameters (if any) given, which in turn can delegate to its own constructors (same game)
p3118
aVIf you have nothing, then the parameter-less constructor of the base-class is called automatically
p3119
aVAfter you have used , then the constructor matching the parameters will be used and its body will be executed - additionally to the body of the constructor having used
p3120
as(dp3121
g15
V34509
p3122
stp3123
a((dp3124
g2
(lp3125
VHere is a Visual C++ 2008 Express Edition Introdution: Introduction to Visual C++ 2008 Express (Video)
p3126
aVYou will find a good book-list about Standard C++ here: http://jcatki
p3127
aVno-ip
p3128
aVorg:8080/fncpp/Resources#books (that's the website of the ##c++ irc channel on irc
p3129
aVfreenode
p3130
aVorg)
p3131
aVFor an explanation of the difference between C++ and Visual C++ you can read this: http://www
p3132
aVcomeaucomputing
p3133
aVcom/techtalk/#vc
p3134
as(dp3135
g15
V34509
p3136
stp3137
a((dp3138
g2
(lp3139
VFrom  documentation:
p3140
aVTo bind a NULL value, use a null
p3141
aVQVariant; for example, use
p3142
aVQVariant(QVariant::String) if you are
p3143
aVbinding a string
p3144
as(dp3145
g15
V34509
p3146
stp3147
a((dp3148
g2
(lp3149
VThere doesn't seem to be a way to access the outer class from outside
p3150
aVBut you can do it like this:
p3151
aVwill be the instance of the outerclass associated with the instance of an inner class
p3152
as(dp3153
g15
V34509
p3154
stp3155
a((dp3156
g2
(lp3157
VWell, first note that a cast is an explicit request to convert a value of one type to a value of another type
p3158
aVA cast will also always produce a new object, which is a temporary returned by the cast operator
p3159
aVCasting to a reference type, however, will not create a new object
p3160
aVThe object referenced by the value is reinterpreted as a reference of a different type
p3161
aVNow to your question
p3162
aVNote that there are two major types of conversions:
p3163
aVPromotions: This type can be thought of casting from a possibly more narrow type to a wider type
p3164
aVCasting from char to int, short to int, float to double are all promotions
p3165
aVConversions: These allow casting from long to int, int to unsigned int and so forth
p3166
aVThey can in principle cause loss of information
p3167
aVThere are rules for what happens if you assign a  to an unsigned typed object for example
p3168
aVIn some cases, a wrong conversion can result in undefined behavior
p3169
aVIf you assign a double larger than what a float can store to a float, the behavior is not defined
p3170
aVLet's look at your casts:
p3171
aVThis cast causes a conversion to happen
p3172
aVNo loss of data happens, since 10 is guaranteed to be stored by an
p3173
aVIf the integer were negative, the value would basically wrap around the maximal value of an unsigned int (see 4
p3174
aV7/2)
p3175
aVThe value  is truncated to 10
p3176
aVHere, it does cause lost of information, obviously
p3177
aVAs 10 fits into an unsigned int, the behavior is defined
p3178
aVThis actually requires more attention
p3179
aVFirst, there is a deprecated conversion from a string literal to
p3180
aVBut let's ignore that here
p3181
aV(see here)
p3182
aVMore importantly, what does happen if you cast to an unsigned type
p3183
aVActually, the result of that is unspecified per 5
p3184
ag976
aV10/7 (note the semantics of that cast is the same as using reinterpret_cast in this case, since that is the only C++ cast being able to do that):
p3185
aVA pointer to an object can be explicitly converted to a pointer to
p3186
aVan object of different type
p3187
aVExcept that converting an rvalue of type \u201cpointer to T1\u201d to the type "pointer to T2" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified
p3188
aVSo you are only safe to use the pointer after you cast back to  again
p3189
as(dp3190
g15
V34509
p3191
stp3192
a((dp3193
g2
(lp3194
VIf you know the size of nested dimensions already, you can also literally allocate a multi dimensional array using new:
p3195
aVinstead of , a runtime determined value can be passed
p3196
aVSince it's not part of the type operator new returns, that's allowed
p3197
aVThis is nice if you know the number of columns, but want to keep the number of rows variable, for example
p3198
aVThe typedef makes it easier to read the code
p3199
as(dp3200
g15
V34509
p3201
stp3202
a((dp3203
g2
(lp3204
VIt depends on the implementation
p3205
aVfor example has a minimal required size
p3206
aVBut there is no upper limit
p3207
aVTo avoid these kind of situations, always use the proper typedef:
p3208
aVYou will be always on the safe side then
p3209
as(dp3210
g15
V34509
p3211
stp3212
a((dp3213
g2
(lp3214
VThe kernel tries to read from address , which your kernel apparently treats specially (good thing
p3215
aVAs the kernel has no way to just kill itself like we know from user mode applications (those would have received a Segmentation Fault), this error is fatal
p3216
aVIt will have probably panic'ed and displayed that message to you
p3217
aVhttp://en
p3218
aVwikipedia
p3219
aVorg/wiki/Null_pointer#The_null_pointer
p3220
as(dp3221
g15
V34509
p3222
stp3223
a((dp3224
g2
(lp3225
VYou definitely want to use : http://www
p3226
aVjdom
p3227
aVorg/docs/apidocs/
p3228
aVIt can be used as you described as many methods return a reference to
p3229
aVHere is some code our teacher showed us for this XML document
p3230
aVHaven't tested it, but the teacher is great i believe in him:
p3231
aVCode:
p3232
aVFrom the API manual, it looks like the casts he did aren't necassary
p3233
aVMaybe he just did it for documentation purposes
p3234
as(dp3235
g15
V34509
p3236
stp3237
a((dp3238
g2
(lp3239
VThere is nothing in the C++ Standard library for these purposes
p3240
aVThe library you could use is , which abstracts the view of programs to the hardware, collecting various informations from ,  and others
p3241
aVHAL, scroll down, there seems to be an unofficial C++ binding available too (haven't tested it though, while libhal works also fine for C++ programs)
p3242
aVUse the command  to display all device informations available to HAL
p3243
as(dp3244
g15
V34509
p3245
stp3246
a((dp3247
g2
(lp3248
VYou can use a technique called NVI (Non-Virtual-Interface) together with the  pattern
p3249
aVThis probably is how i would do it (of course, it's only my personal opinion, which is indeed debatable):
p3250
aVBecause  is non-virtual, the invariant is still checked if a derived class overrides  for special handling
p3251
aVTo your options: I think it depends on the condition you want to check
p3252
aVIf it is an internal invariant
p3253
aVIf it is an invariant, it should not
p3254
aVbe possible for a user of your class
p3255
aVto violate it
p3256
aVThe class should care
p3257
aVabout its invariant itself
p3258
aVTherefor,
p3259
aVi would  in
p3260
aVsuch a case
p3261
aVIt's merely a pre-condition of a method
p3262
aVIf it's merely a pre-condition that
p3263
aVthe user of the class would have to
p3264
aVguarantee (say, only printing after
p3265
aVthe printer is ready), i would throw
p3266
aVas shown above
p3267
aVI would really discourage from check a condition, but then doing nothing
p3268
aVThe user of the class could itself assert before calling a method that the pre-conditions of it are satisfied
p3269
aVSo generally, if a class is responsible for some state, and it finds a state to be invalid, it should assert
p3270
aVIf the class finds a condition to be violated that doesn't fall in its responsibility, it should throw
p3271
as(dp3272
g15
V34509
p3273
stp3274
a((dp3275
g2
(lp3276
VAFAIK a shared_ptr is only useful if
p3277
aVdifferent threads are going to be
p3278
aVaccessing the same data
p3279
aVWell, it's for situations where multiple owners own the same object pointed to by the smart pointer
p3280
aVThey may access the smart pointers from different threads, and shared_ptr is usable in that area too, but that's not the main point
p3281
aVIf the last owner loses its reference to the object pointed to, the shared_ptr mechanism deletes the object
p3282
aVYou can use a scoped_ptr if all you want to have is a pointer that is deleted when the scope it's created in is left (either by exceptions, by a goto to a place outside, or by normal control flow or some other mechanism)
p3283
aVIf you use it like that, there is no need to change to shared_ptr
p3284
as(dp3285
g15
V34509
p3286
stp3287
a((dp3288
g2
(lp3289
VThey are different things
p3290
aVI'm not an expert in volatile semantics
p3291
aVBut i think it makes sense what is described here
p3292
aVGlobal
p3293
aVGlobal just means the identifier in question is declared at file-scope
p3294
aVThere are different scopes, called  function (where goto-labels are defined in), \ufb01le (where globals reside), block (where normal local variables reside), and function prototype (where function parameters reside)
p3295
aVThis concept just exist to structure the visibility of identifiers
p3296
aVIt doesn't have anything to do with optimizations
p3297
aVStatic
p3298
aVis a storage duration (we won't look at that here) and a way to give a name declared within file scope internal linkage
p3299
aVThis can be done for functions or objects only required within one translation unit
p3300
aVA typical example might be a  function printing out the accepted parameters, and which is only called from the  function defined in the same  file
p3301
ag488
ag976
aV2/2 in a C99 draft:
p3302
aVIf the declaration of a \ufb01le scope
p3303
aVidenti\ufb01er for an object or a function
p3304
aVcontains  the storage class speci\ufb01er
p3305
aVstatic, the identi\ufb01er has internal
p3306
aVlinkage
p3307
aVInternal linkage means that the identifier is not visible outside the current translation unit (like the  function of above)
p3308
aVVolatile
p3309
aVVolatile is a different thing: (6
p3310
aV7
p3311
aV3/6)
p3312
aVAn object that has volatile-quali\ufb01ed
p3313
aVtype may be modi\ufb01ed in ways unknown to
p3314
aVthe implementation or have other
p3315
aVunknown side effects
p3316
aVTherefore any
p3317
aVexpression referring to such an object
p3318
aVshall be evaluated strictly according
p3319
aVto the rules of the abstract machine,
p3320
aVas described in 5
p3321
ag2790
ag976
ag1037
aVFurthermore,
p3322
aVat every sequence point the value last
p3323
aVstored in the object shall agree with
p3324
aVthat prescribed by the abstract
p3325
aVmachine, except as modi\ufb01ed by the
p3326
aVunknown factors mentioned
p3327
aVpreviously
p3328
aVThe Standard provides an excellent example for an example where  would be redundant (5
p3329
ag2790
ag976
aV3/8):
p3330
aVAn implementation might de\ufb01ne a
p3331
aVone-to-one correspondence between
p3332
aVabstract and actual semantics: at
p3333
aVevery sequence point, the values of
p3334
aVthe actual objects would agree with
p3335
aVthose speci\ufb01ed by the abstract
p3336
aVsemantics
p3337
aVThe keyword
p3338
aVwould then be redundant
p3339
aVSequence points are points where the effect of side effects concerning the abstract machine are completed (i
p3340
aVe external conditions like memory cell values are not included)
p3341
aVBetween the right and the left of  and , after  and returning from a function call are sequence points for example
p3342
aVThe abstract semantics is what the compiler can deduce from seeing only the sequence of code within a particular program
p3343
aVEffects of optimizations are irrelevant here
p3344
aVactual semantics include the effect of side effects done by writing to objects (for example, changing of memory cells)
p3345
aVQualifying an object as volatile means one always gets the value of an object straight from memory ("as modified by the unknown factors")
p3346
aVThe Standard doesn't mention threads anywhere, and if you must rely on the order of changes, or on atomicity of operations, you should use platform dependent ways to ensure that
p3347
aVFor an easy to understand overview, intel has a great article about it here
p3348
aVWhat should i do now
p3349
aVKeep declaring your file-scope (global) data as volatile
p3350
aVGlobal data in itself does not mean the variables' value will equal to the value stored in memory
p3351
aVAnd static does only make your objects local to the current translation unit (the current  files and all other files #include'ed by it)
p3352
as(dp3353
g15
V34509
p3354
stp3355
a((dp3356
g2
(lp3357
VI'm also unsure about why it fails, but i like  and :
p3358
as(dp3359
g15
V34509
p3360
stp3361
a((dp3362
g2
(lp3363
VThat is invalid
p3364
aVAs you show the line prior to it that  is actually a pointer, you cannot treat it as if it were of type
p3365
aVThey don't necassarily have the same sizeof and alignment
p3366
aVUse the format used for
p3367
aVIt will output memory addresses properly:
p3368
as(dp3369
g15
V34509
p3370
stp3371
a((dp3372
g2
(lp3373
VAs you already state in your question, the main difference between  and  is that  members overlay the memory of each other so that the sizeof of a union is the one , while  members are laid out one after each other (with optional padding in between)
p3374
aVAlso an union is large enough to contain all its members, and have an alignment that fits all its members
p3375
aVSo let's say  can only be stored at 2 byte addresses and is 2 bytes wide, and long can only be stored at 4 byte addresses and is 4 bytes long
p3376
aVThe following union
p3377
aVcould have a  of 4, and an alignment requirement of 4
p3378
aVBoth an union and a struct can have padding at the end, but not at their beginning
p3379
aVWriting to a struct changes only the value of the member written to
p3380
aVWriting to a member of an union will render the value of all other members invalid
p3381
aVYou cannot access them if you haven't written to them before, otherwise the behavior is undefined
p3382
aVGCC provides as an extension that you can actually read from members of an union, even though you haven't written to them most recently
p3383
aVFor an Operation System, it doesn't have to matter whether a user program writes to an union or to a structure
p3384
aVThis actually is only an issue of the compiler
p3385
aVAnother important property of union and struct is, they allow that a pointer to them can point to types of any of its members
p3386
aVSo the following is valid:
p3387
aVsome_test_pointer can point to  or
p3388
aVIf you cast an address of type  to , it will point to its first member, , actually
p3389
aVThe same is true for an union too
p3390
aVThus, because an union will always have the right alignment, you can use an union to make pointing to some type valid:
p3391
aVThat union will actually be able to point to an int, and a double:
p3392
aVis actually valid, as stated by the C99 standard:
p3393
aVAn object shall have its stored value accessed only by an lvalue expression that has one of the following types:
p3394
aVa type compatible with the effective type of the object
p3395
aVan aggregate or union type that includes one of the aforementioned types among its members
p3396
aVThe compiler won't optimize out the  as it could affect the value of  (and the function will return  instead of )
p3397
as(dp3398
g15
V34509
p3399
stp3400
a((dp3401
g2
(lp3402
VWhat you linked to is a using directive
p3403
aVA using declaration can be used fine with templated base classes (haven't looked it up in the standard, but just tested it with a compiler):
p3404
aVThe compiler correctly finds the parameter-less  function because of our using-declaration re-declaring it into the scope of , and outputs the expected result
p3405
aVEdit: updated the question
p3406
aVhere is the updated answer:
p3407
aVThe article is right about that you are not allowed to use a template-id (template name and arguments)
p3408
aVBut you can put a template name:
p3409
as(dp3410
g15
V34509
p3411
stp3412
a((dp3413
g2
(lp3414
VSimilar to Konrads answer, but using :
p3415
as(dp3416
g15
V34509
p3417
stp3418
a((dp3419
g2
(lp3420
VYou can't :) What you want is to specialize the member functions instead:
p3421
aVAnother, slightly more complicated solution is to use :
p3422
aVThat will cause a compile time error if cross_product is called for any dim
p3423
aV= 3
p3424
aVNote that that 'trick' only works for functions with parameters, since only then the template parameter can be auto-deduced
p3425
aVFor cases without parameters, i have provided a function  above :)
p3426
as(dp3427
g15
V34509
p3428
stp3429
a((dp3430
g2
(lp3431
VIf you just want to pass a  to a function that needs  you can use
p3432
aVIf you want to get a writable copy, like , you can do that with this:
p3433
aVEdit: Notice that the above is not exception safe
p3434
aVIf anything between the  call and the  call throws, you will leak memory, as nothing will call  for you automatically
p3435
aVThere are two immediate ways to solve this
p3436
aVboost::scoped_array
p3437
aVwill delete the memory for you upon going out of scope:
p3438
aVstd::vector
p3439
aVThis is the standard way (does not require any external library)
p3440
aVYou use , which completely manages the memory for you
p3441
as(dp3442
g15
V34509
p3443
stp3444
a((dp3445
g2
(lp3446
VHere is the tutorial for
p3447
aVI could imagine it would work fine sending the data over the pipe and deserializing on the other side: http://www
p3448
aVboost
p3449
aVorg/doc/libs/1_37_0/libs/serialization/doc/tutorial
p3450
aVhtml
p3451
as(dp3452
g15
V34509
p3453
stp3454
a((dp3455
g2
(lp3456
VHmm, while variadic macros are C99, they are not possible in C++
p3457
aVI wouldn't do it like that :) A simple dsl function taking a  or whatever string class your framework uses, and returning  would be my preferred option, since it's more debug friendly, and you can put it into a namespace
p3458
aVYou will also be able to build up command strings dynamically and pass it to the function
p3459
aVUsing your macro approach, passing a  variable would actually pass  to the MakeCommand function
p3460
aVYou would need another macro for dynamic commands to make it work, which i wouldn't be comfortable with
p3461
as(dp3462
g15
V34509
p3463
stp3464
a((dp3465
g2
(lp3466
VIf i instantiate the above class with
p3467
aVdifferent values of S, will the
p3468
aVcompiler create different instances of
p3469
aVA() and MaxLenth() function
p3470
aVOr will
p3471
aVit create one instance and pass the S
p3472
aVas some sort of argument
p3473
aVThe compiler will instantiate a different copy of the class template for each different value of the parameter
p3474
aVRegarding the member functions, it will instantiate a different copy of each, for each different value of
p3475
aVBut unlike member functions of non-template classes, they will only be generated if they are actually used
p3476
aVHow will it behave if i move the definition of A and Maxlength to a different cpp file
p3477
aVYou mean if you put the definition of  into a header file, but define the member function  in a cpp file
p3478
aVWell, if users of your class template want to call , the compiler wants to see its code, since it wants to instantiate a copy of it with the actual value of
p3479
aVIf it doesn't have the code available, it assumes the code is provided otherwise, and doesn't generate any code:
p3480
aVA
p3481
aVhpp
p3482
ag3481
aVcpp
p3483
aVIf you now only include include A
p3484
aVhpp for the code using the class template A, then the compiler won't see the code for  and won't generate any instantiation
p3485
aVYou have two options:
p3486
aVInclude the file A
p3487
aVcpp too, so the compiler sees the code for it, or
p3488
aVProvide an explicit instantiation for values of  you know you will use
p3489
aVFor those values, you won't need to provide the code of
p3490
aVFor the second option, this is done by putting a line like the following inside A
p3491
aVcpp:
p3492
aVThe compiler will be able to survive without seeing code for the member functions of  now, since you explicitly instantiated a copy of your template for
p3493
aVIf you don't do any of the two options above, the linker will refuse to create a final executable, since there is still code missing that is needed
p3494
as(dp3495
g15
V34509
p3496
stp3497
a((dp3498
g2
(lp3499
VJust some variation of how you can split the items generated
p3500
aVPersonally, i like to use  for this job
p3501
ag1240
as(dp3502
g15
V34509
p3503
stp3504
a((dp3505
g2
(lp3506
VOn Linux, you can use the function  which sets values in the following struct:
p3507
aVIf you want to do it solely using functions of C++ (i would stick to ), i recommend taking a C++ approach using  and :
p3508
as(dp3509
g15
V34509
p3510
stp3511
a((dp3512
g2
(lp3513
VYou can use the XScreenSaver extension ()
p3514
aVIt can provide you with values into this struct using the function :
p3515
aVThe idle field specifies the number of milliseconds since the last input was received from the user on any of the input devices
p3516
aVI don't know about a Qt only solution for this
p3517
as(dp3518
g15
V34509
p3519
stp3520
a((dp3521
g2
(lp3522
VI understand your question this way:
p3523
as(dp3524
g15
V34509
p3525
stp3526
a((dp3527
g2
(lp3528
VYou can do it yourself, or you can do it with boost: http://www
p3529
aVboost
p3530
aVorg/doc/libs/1_37_0/libs/serialization/doc/index
p3531
aVhtml
p3532
aVWhat you currently try is just view the map as a plain old datatype, which essentially means it's a C datatype
p3533
aVBut it isn't, so it fails to save/load
p3534
aVboost serialization does it correctly
p3535
aVHave a look at it
p3536
aVIf you don't want to use it, you can do something like this:
p3537
aVNote that the above needs some changes if the characters stored could be whitespace characters too
p3538
aVBecause of that, it's probably the best to first convert to an int before writing out, and then reading as an int when loading
p3539
aVActually, i recommend boost serialization, and boost iostreams (http://www
p3540
aVboost
p3541
aVorg/doc/libs/1_37_0/libs/iostreams/doc/index
p3542
aVhtml), which includes a compression stream that transparently can compress your data too
p3543
as(dp3544
g15
V34509
p3545
stp3546
a((dp3547
g2
(lp3548
VI'm answering to your updated question (which appeared in your own answer)
p3549
aVFirst your code:
p3550
aVNO
p3551
aVThat's not the right way
p3552
aVIt decays to a pointer - yes, but not a pointer to a float
p3553
aVIf you pass materials[0], you will get a  which decays to  (a pointer to its first element), and that pointer is what is passed
p3554
aVThus, you want to change it into this:
p3555
aVRead about it here: http://stackoverflow
p3556
aVcom/questions/274865/pointer-question-in-c#274943
p3557
aVRead here about how to pass arrays properly: http://stackoverflow
p3558
aVcom/questions/308279/c-vs#308724
p3559
aVI would recommend you a good C or C++ book mate :)
p3560
as(dp3561
g15
V34509
p3562
stp3563
a((dp3564
g2
(lp3565
VHere's a version using isspace:
p3566
as(dp3567
g15
V34509
p3568
stp3569
a((dp3570
g2
(lp3571
VLike others said, a namespace is what you should use
p3572
aVIf you want to stay with your class, create a class that has a private constructor, and derive from it, to make your intention obvious:
p3573
aVOk, now let's look into the namespace which are the one and only way to do this:
p3574
aVYou can call that using  in both cases, but the namespace has the advantage that in a scope you can use the namespace declaration and directive to bring certain or all members into the current scope, so that you can reference them without using :
p3575
aVWhile generally that should be avoided, it can be helpful when the method is using exclusively much stuff from SuperUtils, which then can improve the readability of the code
p3576
as(dp3577
g15
V34509
p3578
stp3579
a((dp3580
g2
(lp3581
VEvery abstract class should either have a,
p3582
aVprotected destructor, or,
p3583
aVvirtual destructor
p3584
aVIf you've got a public non-virtual destructor, that's no good, since it allows users to delete through that pointer a derived object
p3585
aVSince as we all know, that's undefined behavior
p3586
aVFor a class not intended to delete through a pointer to it, there is no reason whatsoever to have a virtual destructor
p3587
aVIt would not only waste resources, but more importantly it would give users a wrong hint
p3588
aVJust think about what crappy sense it would make to give  a virtual destructor
p3589
as(dp3590
g15
V34509
p3591
stp3592
a((dp3593
g2
(lp3594
VYou don't have to write a completely new container class
p3595
aVYou can stick with your STL containers, but change the second parameter of for example  to give it your custom allocator which allocates from a stack-buffer
p3596
aVThe chromium authors wrote an allocator just for this:
p3597
aVhttps://code
p3598
aVgoogle
p3599
aVcom/p/chrome-browser/source/browse/trunk/src/base/stack_container
p3600
aVh
p3601
aVIt works by allocating a buffer where you say how big it is
p3602
aVYou create the container and call
p3603
aVIf you overflow that size, the allocator will automatically get elements from the heap (since it is derived from , it will in that case just use the facilities of the standard allocator)
p3604
aVI haven't tried it, but it looks like it's from google so i think it's worth a try
p3605
aVUsage is like this:
p3606
as(dp3607
g15
V34509
p3608
stp3609
a((dp3610
g2
(lp3611
VI think you pretty much nailed it
p3612
aVThere is no performance difference
p3613
aVGenerics are rationalized away (Type Erasure) when the code is compiled, and don't exist anymore at runtime
p3614
aVThey just add casts when needed and do type-checking as you stated
p3615
aVNeal Gafter wrote a nice overview of how they work, of the current problems with Generics and how they could be solved in the next version of Java: http://gafter
p3616
aVblogspot
p3617
aVcom/2006/11/reified-generics-for-java
p3618
aVhtml
p3619
as(dp3620
g15
V34509
p3621
stp3622
a((dp3623
g2
(lp3624
VIf you need constants (real, compile time constants) you can do that three ways, putting them into header files (there is nothing bad with that):
p3625
aVIn C++, i tend to use the enum way, since it can be scoped into a namespace
p3626
aVFor C, i use the macro
p3627
aVThis basicially comes down to a matter of taste though
p3628
aVIf you need floating point constants, you can't use the enumeration anymore
p3629
aVIn C++ i use the last way, the static const double, in that case (note in C++ static would be redundant then; they would become static automatically since they are const)
p3630
aVIn C, i would keep using the macros
p3631
aVIt's a myth that using the third method will slow down your program in any way
p3632
aVI just prefer the enumeration since the values you get are rvalues - you can't get their address, which i regard as an added safety
p3633
aVIn addition, there is much less boiler-plate code written
p3634
aVThe eye is concentrated on the constants
p3635
as(dp3636
g15
V34509
p3637
stp3638
a((dp3639
g2
(lp3640
VI assume the target knows how to use graphical user interfaces
p3641
aVI found the best way is to describe OOP with stuff that they are really used for
p3642
aVSay
p3643
aVClass
p3644
aVA Window is a class
p3645
aVIt has methods like
p3646
aVShow a window
p3647
aVEnable a window
p3648
aVSet the window's title
p3649
aVA Window has attributes
p3650
aVThat is data associated with it
p3651
aVIt is encapsulated into the class, together with the functions that operate on them
p3652
aVA Window has dimensions
p3653
aVWidth and height
p3654
aVA Window has possibly a parent window, and possibly children
p3655
aVA Window has a title
p3656
aVObject
p3657
aVThere are many windows
p3658
aVEach particular window is an object of the class Window
p3659
aVA Parent window containing 10 windows makes 11 Window objects
p3660
aVDeriveration
p3661
aVA Button is a Window
p3662
aVIt has dimensions has a parent window and has a title, the label of a button
p3663
aVIt's a special kind of a window
p3664
aVWhen you ask for a window object, someone can give you a Button
p3665
aVA Button can add functions and data that are specific for a button:
p3666
aVA Button has a state
p3667
aVIt can be in a pressed state, and unpressed state
p3668
aVA Button can be the default button in a Window
p3669
as(dp3670
g15
V34509
p3671
stp3672
a((dp3673
g2
(lp3674
VThis can be best done using a policy for the transport protocol:
p3675
aVNote that this is also polymorphic
p3676
aVIt's called compile time polymorphism
p3677
aVPutting the policy into a base class will benefit from the Empty-Base-Class-Optimization
p3678
aVThat is, your base class does not need to take any space
p3679
aVPutting the policy as a member has the other drawback that you always have to delegate stuff to that member, which can become annoying with time
p3680
aVThe book Modern C++ Design describes this pattern in-depth
p3681
aVIdeally, the transport protocol doesn't need to know anything about the protocol above it
p3682
aVBut if for some reason you have to get some information about it, you can use the crtp pattern:
p3683
aVYou don't have to put your templates into headers
p3684
aVIf you explicitly instantiate them, you will gain faster compilation times, as much fewer code has to be included
p3685
aVPut this into service
p3686
aVcpp:
p3687
aVNow, code that uses service does not need to know about the template code of service, since that code is already generated into the object file of service
p3688
aVcpp
p3689
as(dp3690
g15
V34509
p3691
stp3692
a((dp3693
g2
(lp3694
Vbool is a fundamental datatype in C++
p3695
aVConverting  to an integer type will yield 1, and converting  will yield 0 (4
p3696
aV5/4 and 4
p3697
aV7/4)
p3698
aVIn C, until C99, there was no bool datatype, and people did stuff like
p3699
aVSo did the Windows API
p3700
aVStarting with C99, we have  as a basic data type
p3701
aVIncluding  will typedef  that to  and provide the constants  and
p3702
aVThey didn't make bool a basic data-type (and thus a keyword) because of compatibility issues with existing code
p3703
as(dp3704
g15
V34509
p3705
stp3706
a((dp3707
g2
(lp3708
V(In the following, the striked-through things are stuff that does not apply anymore to C++11, but did apply to C++03
p3709
aVC++11 makes almost no differences anymore (if there are, they are just language lawyer differences which I can't recall)
p3710
aVUnnamed namespaces are a utility to make an identifier effectively translation unit local
p3711
aVThey behave as if you would choose an unique name per translation unit for a namespace:
p3712
aVThe extra step using the empty body is important, so you can already refer within the namespace body to identifiers like  that are defined in that namespace, since the using directive already took place
p3713
aVThis means you can have free functions called (for example)  that can exist in multiple translation units, and they won't clash at link time, since they all got an unique name due to their unique namespace they are in
p3714
aVThe effect is almost identical to using the  keyword used in C which you can put in in the declaration of identifiers
p3715
aVused in that manner is deprecated in C++, since unnamed namespaces are a superior alternative, being able to even make a type translation unit local
p3716
aVBoth 's are translation unit local and won't clash at link time
p3717
aVBut the difference is that the  in the anonymous namespace just gets an unique name
p3718
aVIt has still external linkage and may be exported into the symbol table of the object file being created
p3719
aVThis becomes important if you want to use its address as a template argument:
p3720
aVTemplate parameters has to have external linkage so in this case the identifier has to be put into an anonymous namespace
p3721
aVRead the excellent article at comeau-computing `Why is an unnamed namespace used instead of static
p3722
as(dp3723
g15
V34509
p3724
stp3725
a((dp3726
g2
(lp3727
VI don't see any point in putting an anonymous namespace into a header file
p3728
aVI've grepped the standard and the libstdc++ headers, found no anonymous namespaces apart of one in the  header (C++1x stuff):
p3729
aVThis is so you can do
p3730
aVelements of the some_tuple are assigned the variables at the left side (see here), a similar technique is used for this iterator
p3731
aVThe second element is ignored
p3732
aVBut as they say, it should be put into a
p3733
aVcpp file and the one instance should be shared by all users
p3734
aVThey would put a declaration of it into the header like this then:
p3735
as(dp3736
g15
V34509
p3737
stp3738
a((dp3739
g2
(lp3740
VWhat Adam says
p3741
aVAnother example where const_cast can be helpful:
p3742
aVWe first add const to the type  points to, then we call the const version of , and then we remove const from the return type, which is valid since  must be non-const (otherwise, the non-const version of  couldn't have been called)
p3743
aVThis can be very useful if you got a large function body and you want to avoid redundant code
p3744
as(dp3745
g15
V34509
p3746
stp3747
a((dp3748
g2
(lp3749
VFrom its manpage:
p3750
aVThe  truncate()  and ftruncate()
p3751
aVfunctions cause the regular file named
p3752
aVby path or referenced by fd to be
p3753
aVtruncated to a size of    precisely
p3754
aVlength bytes
p3755
aVIf the file previously was larger
p3756
aVthan this size, the extra data is
p3757
aVlost
p3758
aVIf the file previously was
p3759
aVshorter, it  is  extended,    and the
p3760
aVextended part reads as null bytes
p3761
aV('\u005c0')
p3762
as(dp3763
g15
V34509
p3764
stp3765
a((dp3766
g2
(lp3767
VThe reason C++ doesn't have reflection is that this would require the compilers to add symbol information to the object files, like what members a class type has, information about the members, about the functions and everything
p3768
aVThis essentially would render include files useless, as information shipped by declarations would then be read from those object files (modules then)
p3769
aVIn C++, a type definition can occur multiple times in a program by including the respective headers (provided that all those definitions are the same), so it would have to be decided where to put the information about that type, just as to name one complication here
p3770
aVThe aggressive optimization done by a C++ compiler, which can optimize out dozens of class template instantiations, is another strong point
p3771
aVIt's possible, but as C++ is compatible to C, this would become an awkward combination
p3772
as(dp3773
g15
V34509
p3774
stp3775
a((dp3776
g2
(lp3777
VThe code you showed is fine so far
p3778
aVThe address printed does not seem to be printed from that part of your code
p3779
aVI can imagine two situations for that
p3780
aVYou accidentally print myArray[i] or myArray and forgot to apply the other index
p3781
aVAs an array value converts to the address of its first element, it causes an address being printed
p3782
aVYou accidentally print cout itself like cout << cout
p3783
aVcout has an implicit conversion to a pointer type (it is used to check for sane state like in ) and this will cause an address being printed too
p3784
aVIt could be a totally other situation
p3785
aVCan you paste the code that appears after the two loops
p3786
as(dp3787
g15
V34509
p3788
stp3789
a((dp3790
g2
(lp3791
VTo clean up some mess,  can be used
p3792
aVIt can provide a list of stuff executed when a specific signal arrives:
p3793
aVbut can also be used to execute something if the shell exits:
p3794
aVIt's a builtin, so  will give you information (works with bash)
p3795
aVIf you only want to kill background jobs, you can do
p3796
aVWatch out to use single , to prevent the shell from substituting the  immediately
p3797
as(dp3798
g15
V34509
p3799
stp3800
a((dp3801
g2
(lp3802
VI find the structure of java projects quite nice
p3803
aVI do it like this (root is the root directory)
p3804
aVroot/include/foo/bar/baz
p3805
aVhpp becomes
p3806
aVin code
p3807
aVI keep the source in
p3808
aVroot/src/foo/bar/baz
p3809
aVcpp
p3810
aVIf i have some stuff that is not exposed to the outside, i put it into a detail/ directory and namespace
p3811
aVI keep the makefiles at root/
p3812
as(dp3813
g15
V34509
p3814
stp3815
a((dp3816
g2
(lp3817
VI've not tested it, but the C++ eigen library is becoming increasingly more popular these days
p3818
aVAccording to them, they are on par with the fastest libraries around there and their API looks quite neat to me
p3819
as(dp3820
g15
V34509
p3821
stp3822
a((dp3823
g2
(lp3824
VYes, there is a way
p3825
aVA pretty simple even in C++ to what that C# code does (without checking for inheritance though):
p3826
aVThis will work and do the same as the C# code
p3827
aVIt is also type-safe: If the type you pass is not inherited from BrokeredObject (or isn't that type itself), then the compiler moans at the return statement
p3828
aVIt will however always return a new object
p3829
aVSingleton
p3830
aVAs another guy suggested (credits to him), this all looks very much like a fine case for the singleton pattern
p3831
aVJust do  to get the one and single instance stored in a static variable of that class
p3832
aVI suppose that would be far easier than the above way, without the need for IDs to solve it (i previously showed a way using templates to store IDs in this answer, but i found it effectively is just what a singleton is)
p3833
aVI've read that you will leave the chance open to have multiple instances of the classes
p3834
aVOne way to do that is to have a Mingleton (i made up that word :))
p3835
aVNow, you just use  and it cares about the details
p3836
aVThe custom deleter in the singleton case for shared_ptr makes deletion a no-op, because the object owned by the shared_ptr is allocated statically
p3837
aVHowever, be aware of problems of destruction order of static variables: Static initialization order fiasco
p3838
as(dp3839
g15
V34509
p3840
stp3841
a((dp3842
g2
(lp3843
VYou haven't specified a language, and i don't know the language, so i answer generally
p3844
aVYou can't do that
p3845
aVIf you want to have common code, put that either into , or if it only needs to be executed for some catching cases, you can copy that code into the respective cases
p3846
aVIf the code is bigger and you want to avoid redundancy, you can put it into a function of its own
p3847
aVIf that would reduce the readability of your code, you can nest your try/catch blocks (at least in Java and C++
p3848
aVI don't know about your language)
p3849
aVHere is an example in Java:
p3850
aVThis will print out:
p3851
aVput your common code into the outer catch block
p3852
aVDoing it using the nested version also handles cases where an exception occurs without you explicitly re-throwing the old in a catch block
p3853
aVIt may fit to what you want even better, but it may also not
p3854
as(dp3855
g15
V34509
p3856
stp3857
a((dp3858
g2
(lp3859
VIt for example happens in this case here:
p3860
aVTry using  instead of just  (and include the  header)
p3861
aVC++ Standard library classes are within the namespace
p3862
as(dp3863
g15
V34509
p3864
stp3865
a((dp3866
g2
(lp3867
VIt may sound obvious to you, but we try to use forward declaration as much as possible, even if it requires to write out long namespace names the type(s) is/are in:
p3868
aVGreatly reduces the time for compiling also on others compilers
p3869
aVIndeed applies to all configurations :)
p3870
as(dp3871
g15
V34509
p3872
stp3873
a((dp3874
g2
(lp3875
VYou can't do it
p3876
aVIn C++ you could overload the function and do some trickery (or use boost::enable_if), or just rely on C++'s type safety making it error out automatically
p3877
aVIn C, that doesn't work since function overloading is not supported
p3878
aVAnd you can't check the value in the function and cause a compile time error, since all values are known only at runtime (as opposed to types)
p3879
aVThe C Standard allows compilers to warn about what you do
p3880
aVSo you could enable the  flag and hope gcc will error out
p3881
aVBut this is not a general purpose C way
p3882
as(dp3883
g15
V34509
p3884
stp3885
a((dp3886
g2
(lp3887
VThat is because:
p3888
aVb means "current bit"
p3889
aVPossibly you don't want to shift by , but by
p3890
aVIf you look for a standard C++ solution, you can use :
p3891
aVFor your output into the stream, you can use the  function:
p3892
aVIt avoids casting pointers and also outputs unformatted (settings like the field-width are ignored)
p3893
as(dp3894
g15
V34509
p3895
stp3896
a((dp3897
g2
(lp3898
VThe standard way without using boost is to use std::vector :
p3899
aVThat will take care of new / delete the memory you need automatically
p3900
aVBut it's rather slow, since  is not primarily designed for using it like that (nesting  into each other)
p3901
aVFor example, all the memory is not allocated in one block, but separate for each column
p3902
aVAlso the rows don't have to be all of the same width
p3903
aVFaster is using a normal vector, and then doing index calculation like  to get at a certain row and col:
p3904
aVBut this will loose the capability to index the vector using
p3905
aVYou also have to store the amount of rows and cols somewhere, while using the nested solution you can get the amount of rows using  and the amount of cols using
p3906
aVUsing boost, you can use , which does exactly what you want (see the other answer)
p3907
aVThere is also the raw way using native C++ arrays
p3908
aVThis envolves quite some work and is in no way better than the nested vector solution:
p3909
aVYou have to store the amount of columns and rows you created somewhere since you can't receive them from the pointer
p3910
as(dp3911
g15
V34509
p3912
stp3913
a((dp3914
g2
(lp3915
VI'm just going to direct you to this answer: http://stackoverflow
p3916
aVcom/questions/240212/what-is-the-difference-between-newdelete-and-mallocfree#240308
p3917
aVMartin provided an excellent overview
p3918
aVQuick overview on how they work (without diving into how you could overload them as member functions):
p3919
aVnew-expression and allocation
p3920
aVThe code contains a new-expression supplying the type-id
p3921
aVThe compiler will look into whether the type overloads the operator new with an allocation function
p3922
aVIf it finds an overload of an operator new allocation function, that one is called using the arguments given to new and sizeof(TypeId) as its first argument:
p3923
aVSample:
p3924
aVif operator new fails to allocate storage, it can call , and hope it makes place
p3925
aVIf there still is not enough place, new has to throw  or derived from it
p3926
aVAn allocator that has  (no-throw guarantee), it shall return a null-pointer in that case
p3927
aVThe C++ runtime environment will create an object of the type given by the type-id in the memory returned by the allocation function
p3928
aVThere are a few special allocation functions given special names:
p3929
aVnew
p3930
aVThat takes a  as second argument
p3931
aVA new-expression of the form like the following will call an allocation function taking only std::size_t and nothrow_t:
p3932
aVExample:
p3933
aVThat takes a void* pointer as first argument, and instead of returning a newly allocated memory address, it returns that argument
p3934
aVIt is used to create an object at a given address
p3935
aVStandard containers use that to preallocate space, but only create objects when needed, later
p3936
aVCode:
p3937
aVIf the allocation function returns storage, and the the constructor of the object created by the runtime throws, then the operator delete is called automatically
p3938
aVIn case a form of new was used that takes additional parameters, like
p3939
aVThen the operator delete that takes those parameters is called
p3940
aVThat operator delete version is only called if the deletion is done because the constructor of the object did throw
p3941
aVIf you call delete yourself, then the compiler will use the normal operator delete function taking only a  pointer:
p3942
aVnew-expression and arrays
p3943
aVIf you do
p3944
aVThe compiler is using the  functions instead of plain
p3945
aVThe operator can be passed a first argument not exactly : The compiler could add some space to store the number of ob
p3946
as(dp3947
g15
V34509
p3948
stp3949
a((dp3950
g2
(lp3951
VAlthought i'm not sure what you mean by "Tricks", i can only give you these links
p3952
aVWhether it's "best" is for you to decide
p3953
aVwxWidgets
p3954
aVFree for commercial use
p3955
aVOld, but compatible API design (no exceptions, no templates, no RTTI, no use of STL)
p3956
aVIt uses the native widgets
p3957
aVQt
p3958
aVModern Framework
p3959
aVSupport for SQL, for embedded ECMA script
p3960
aVIncludes a embedded Webbrowser
p3961
aVWidgets are CSS themable and can be put on transformable canvas
p3962
aVAmazing toolkit
p3963
aVIt's also fast
p3964
aVNot free for commercial use, but free for Open-Source projects
p3965
aVEdit: as of 14
p3966
aVJan 2009, Nokia announced to put Qt into the LGPL license, making Qt available for commercial usage - free of charge
p3967
aVGtkMM
p3968
aVC++ binding to the famous gtk+ toolkit used as the foundation of GNOME
p3969
aVFree for commercial (but can't link statically)
p3970
aVModern C++ API
p3971
aVGUI Toolkit only
p3972
aVLike Qt, it draws the widgets itself
p3973
aVThis yields to somewhat poor look on Windows (Qt draws the widgets quite well)
p3974
aVI haven't tested it, so i can't tell you the performance
p3975
aVThere are more
p3976
aVBut i only know those reasonable well to tell you about them
p3977
as(dp3978
g15
V34509
p3979
stp3980
a((dp3981
g2
(lp3982
VYes, you can declare a pointer using extern
p3983
aVYour error is most likely you forgot to qualify using  :
p3984
as(dp3985
g15
V34509
p3986
stp3987
a((dp3988
g2
(lp3989
VDepending on your needs, you should use  (if you need often appends/removes at the end, and random access), or  (if you need often appends/removes at the end or at the beginning, and your dataset is huge, and still want random access)
p3990
aVHere is a good picture showing you how to make the decision:
p3991
as(dp3992
g15
V34509
p3993
stp3994
a((dp3995
g2
(lp3996
VOn this site the code shows how convert a bitmap to PNG writing it to a file: http://dotnet-snippets
p3997
aVde/dns/gdi-speichern-eines-png-SID814
p3998
aVaspx
p3999
aVInstead of writing to a file, the  method of Bitmap also supports writing to a  (http://msdn
p4000
aVmicrosoft
p4001
aVcom/en-us/library/ms535406%28VS
p4002
aV85%29
p4003
aVaspx)
p4004
aVYou can create a Stream backed up by memory using the  API function
p4005
aV(http://msdn
p4006
aVmicrosoft
p4007
aVcom/en-us/library/aa378980%28VS
p4008
aV85%29
p4009
aVaspx)
p4010
aVThe used library, GDI+, is included in Windows up from WindowsXP, and works in Windows up from Windows98
p4011
aVI've never done something with it, just googled around
p4012
aVLooks like you can use that, though
p4013
as(dp4014
g15
V34509
p4015
stp4016
a((dp4017
g2
(lp4018
VThat associates the underlying streambuf of either cout or the output file stream to out
p4019
aVAfter that you can write to "out" and it will end up in the right destination
p4020
aVIf you just want that everything going to  goes into a file, you can aswell do
p4021
aVThis second method has the drawback that it's not exception safe
p4022
aVYou possibly want to write a class that does this using RAII:
p4023
aVNow, whatever happens, std::cout is in clean state
p4024
as(dp4025
g15
V34509
p4026
stp4027
a((dp4028
g2
(lp4029
VWe had to program that for school:
p4030
aVDepending on whether we do 8-neighbour or 4-neighbour, we check all 8 neighbour pixels, or only pixels left/right or above/below a certain pixel
p4031
aVHere is the code (using ImageJ
p4032
aVI removed some code not relevant)
p4033
aVI hope it makes sense, it's Java
p4034
aVJust ask away for questions:
p4035
as(dp4036
g15
V34509
p4037
stp4038
a((dp4039
g2
(lp4040
VAbstraction
p4041
aVImagine a fraction class:
p4042
aVNow two objects of that:
p4043
aVBoth objects have the value 1:
p4044
aVYou wouldn't expect they behave any different to the outside
p4045
aVThat's abstraction
p4046
aVYou abstract the data your object holds into a logical view, even tho behind the scenes, there are other things
p4047
aVTheoretically, you have got a equivalence relation, with different equivalence groups:
p4048
aVAnd there is a abstraction function that abstracts the internal details to the outside:
p4049
aVIt maps from concrete values to the abstract values of an object
p4050
aVYou do that by writing for example a constructor mapping (-1, -1) to (1, 1) and by writing a equals function for your class
p4051
aVPolymorphism
p4052
aVImagine a pen and two derived classes:
p4053
aVBoth pens can draw
p4054
aVyour general "pen" cannot draw itself
p4055
aVIt's just an interface to pen_thin, pen_thick and lots of other pens
p4056
aVYou say: obj1
p4057
aVdraw(1, 0); and whether obj1 is a thick or a thin pen doesn't matter to you as a user, neither to the compiler at compile time
p4058
aVThe call behaves polymorphic
p4059
aVIt's dynamic polymorphism (happens at runtime) and that's what people usually mean
p4060
aVStatic Polymorphism happens at compile time:
p4061
aVThat's called overloading
p4062
aVYou call
p4063
aVIf you call it with a shirt reference, it will call the version taking a shirt
p4064
aVAnd if you call it with a pant reference, it will call the pants version
p4065
aVThe choice done here is at compile-time
p4066
as(dp4067
g15
V34509
p4068
stp4069
a((dp4070
g2
(lp4071
VThis is inherent implementation dependent, since the Standard doesn't include such a possibility
p4072
aVFor GCC, the  attribute runs a function when a variable goes out of scope:
p4073
aVPrints:
p4074
aVSee here
p4075
as(dp4076
g15
V34509
p4077
stp4078
a((dp4079
g2
(lp4080
VThis isn't possible in C++03
p4081
aVIf you want to pass a function pointer as a non-type parameter, the compiler has to know the type of the parameter
p4082
aVSo you have to provide the missing pieces (in this case, the return type)
p4083
aVYou can give the proxy the function pointer as a value at runtime, and provide it with the type of it as the only argument
p4084
aVThen you could write a generator function for you that does this job:
p4085
aVSadly, in current C++, you still have to give it the type in order to assign to a automatic variable:
p4086
aVYou can't use  yet
p4087
aVNote that if you want to use a function type on the left side, you have to change the generator function to provide not a function pointer type:
p4088
aVNow you can do
p4089
aVusing the proxy, you can now just do
p4090
aVAnd if doSomething is templated or otherwise polymorphic, it will not require you to know the exact type of the function
p4091
as(dp4092
g15
V34509
p4093
stp4094
a((dp4095
g2
(lp4096
VThere is only a slight misunderstanding in that code
p4097
aVInstead of allocating Base objects, you have to allocate pointers
p4098
aVA pointer can exist at any time
p4099
aVA pointer to a abstract class, to an incomplete type, and even to void is valid:
p4100
as(dp4101
g15
V34509
p4102
stp4103
a((dp4104
g2
(lp4105
VI think it is the order of expansions:
p4106
aVThe order of expansions is: , tilde expansion, parameter,
p4107
aVand arithmetic expansion and
p4108
aVcommand substitution (done in a
p4109
aVleft-to-right fashion), word
p4110
aVsplitting, and
p4111
aVSo if your variable is substituted, brace expansion doesn't take place anymore
p4112
aVThis works for me:
p4113
aVBe very careful with eval
p4114
aVIt will execute the stuff verbatimly
p4115
aVSo if dirs contains , some_command will be executed after the ls finished
p4116
aVIt will execute the string you give to  in the current shell
p4117
aVIt will pass  to ls, whether they exist or not
p4118
aVPutting  after the stuff makes it a pathname-expansion, and it will omit non-existing paths:
p4119
aVI'm not 100% sure about this, but it makes sense to me
p4120
as(dp4121
g15
V34509
p4122
stp4123
a((dp4124
g2
(lp4125
VI did write an answer to this here (using awk too)
p4126
aVBut i'm not sure that's what you are looking for
p4127
aVIt at least looks clear to me what it does, instead of trying to fit into one line
p4128
aVFor a simple one liner, though, that only removes stuff, i recommend
p4129
aVReplacing is
p4130
aVor (shorter but less readable)
p4131
aVAnyway, for the same question, and a whole lot of useful answers, see here
p4132
as(dp4133
g15
V34509
p4134
stp4135
a((dp4136
g2
(lp4137
VYou can do it like
p4138
aVNote that when it fails to read a sequence of non-whitespace characters, it sets the fail-bit of the stream
p4139
aVinStream evaluates to false then
p4140
aVThat is what makes the loop work
p4141
aVBe careful when using  It only returns true after you tried to read beyond the end of file
p4142
aVSo for example, you will exit the loop, and miss the word 3 tree here:
p4143
aVAssuming there is no white-space after tree
p4144
aVThe same will of course happen if you have newlines between the word information and have no trailing newline after the last word
p4145
aVUsing  (which the while loop does implicitly) is safe
p4146
aVIt would still evaluate to true in this case, and only to false if it didn't read anything except white-space
p4147
as(dp4148
g15
V34509
p4149
stp4150
a((dp4151
g2
(lp4152
VI see no technical reason why
p4153
aVis forbidden
p4154
aVAny occasion you find where it works is due to non-portable implementation defined features
p4155
aVThey also seem to be of only limited use
p4156
aVFor integral constants initialized in class definitions, you can use them and pass them to templates as non-type arguments, and use them as the size of array dimensions
p4157
aVBut you can't do so for floating point constants
p4158
aVAllowing floating point template parameters would bring its own set of rules not really worth the trouble
p4159
aVNonetheless, the next C++ version will allow that using :
p4160
aVAnd will make  a constant expression
p4161
aVIn the meantime, your best bet is to follow the pattern also used by :
p4162
aVIt will not return a constant expression (value is not known at compile time), but that only matters theoretical, since practical the value will be inlined anyway
p4163
aVSee the constexpr proposal
p4164
aVIt contains
p4165
ag2670
ag2670
aVTraditionally, evaluation of
p4166
aV\ufb02oating-point constant expression at
p4167
aVcompile-time is a thorny issue
p4168
aVFor
p4169
aVuniformity and generality, we suggest
p4170
aVto allow constant-expression data of
p4171
aV\ufb02oating point types, initialized with
p4172
aVany \ufb02oating-point constant
p4173
aVexpressions
p4174
aVThat will also increase
p4175
aVcompatibility with C99 [ISO99, 6
p4176
aV6]
p4177
aVwhich allows
p4178
aV[#5] An expression that evaluates to a
p4179
aVconstant is required in several
p4180
aVcontexts
p4181
aVIf a \ufb02oating expression is
p4182
aVevaluated in the translation envi-
p4183
aVronment, the arithmetic precision and
p4184
aVrange shall be at least as great as if
p4185
aVthe expression were being evaluated in
p4186
aVthe execution environ- ment
p4187
as(dp4188
g15
V34509
p4189
stp4190
a((dp4191
g2
(lp4192
VWhat you tried was to overload an operator for scalar types
p4193
aVC++ doesn't allow you to do that except for enumerations (beside the point that operator= has to be a member)
p4194
aVAt least one of the types has to be a user defined type
p4195
aVThus, what you want to do is to wrap the raw pointer into a user defined class, which overloads constructor, copy constructor, copy assignment operator and destructor an do the proper reference counting
p4196
aVThis is an ideal situation for , which does exactly that :
p4197
aVThe same deal with surfaces:
p4198
aVCarry around that smart pointer, and it will automatically manage the life-time of the pointed to object: If the last copy of the pointer goes out of scope, the object pointed to is freed
p4199
aVis designed to be easy to use
p4200
aVTry to avoid working with raw pointers as much as you can
p4201
aVHave a look at those smart pointers, they will ease your programmers live with C++ :)
p4202
aVEdit: If you are going to wrap a shared_ptr, you can do so using the pimpl (handle/body) idiom:
p4203
as(dp4204
g15
V34509
p4205
stp4206
a((dp4207
g2
(lp4208
VThe compilation errors are caused because you don't cast const away/add const
p4209
aVInstead, you copy i0
p4210
aVFor that operation, no cast is required at all:
p4211
aVThe type you cast to should actually be a pointer or reference
p4212
aVOtherwise, using const_cast doesn't make sense since you could straight copy it
p4213
aVFor pointers, for example, you can cast away the const, because dereferencing the pointer will yield another type for a  (yields ) than for a  (yields )
p4214
aVFor references, the same is true:  will access the object using another this pointer type than using
p4215
aVNow what you really wanted to archive:
p4216
aVThe above can lead to undefined behavior, when you write to an originally const object through a reference to non-const (actually, merely casting and reading it isn't undefined behavior in itself
p4217
aVBut if you're casting away const, you may also write to it, which then yields the undefined behavior)
p4218
as(dp4219
g15
V34509
p4220
stp4221
a((dp4222
g2
(lp4223
VNot really a Java programmer here, but read some good papers about generics
p4224
aVYes, you should add some wildcard or the exact type () to add safety
p4225
aVThe reason is that Class is a generic
p4226
aVSo,  and  are the same after erasure of their generic type parameter
p4227
aVThey all become , the so-called raw type
p4228
aVThat erasure happens when compiling
p4229
aVSome example to illustrate this where the compiler helps you with automatic casting (exception handling omitted for brevity):
p4230
aVSaying  (and the equivalent ), you tell the compiler you really wanted a Class whose  is Object, and didn't accidentally used the raw type
p4231
aVBut it won't add any convenience casts
p4232
aVAll that generics do is to insert automatic casts for you, to cast from  to the destination type
p4233
aVGenerics are the same whether used with type U or with type T at runtime for compatibility reasons with older java versions
p4234
as(dp4235
g15
V34509
p4236
stp4237
a((dp4238
g2
(lp4239
VLooks like you use
p4240
aVNot tested, but looks fine
p4241
aVFound another, shorter way:
p4242
as(dp4243
g15
V34509
p4244
stp4245
a((dp4246
g2
(lp4247
VAdditional to  what Douglas says, i would use
p4248
aVAnd not
p4249
aVIt would exit your shell instead of returning from the function
p4250
aVIf in cases you want to exit your shell if something went wrong, you can do that in the caller:
p4251
aV(That way, you can handle failures and then exit gracefully)
p4252
as(dp4253
g15
V34509
p4254
stp4255
a((dp4256
g2
(lp4257
VOne Word: Boost
p4258
aVInterProcess
p4259
aVIf it really needs to be fast, shared memory is the way to go
p4260
aVYou nearly have zero overhead as the operation system does the usual mapping between virtual and physical addresses and no copy is required for the data
p4261
aVYou just have to lookout for concurrency issues
p4262
aVFor actually sending commands like shutdown and query, i would use message queues
p4263
aVI previously used localhost network programming to do that, and used manual shared memory allocation, before i knew about boost
p4264
aVDamn if i would need to rewrite the app, i would immediately pick boost
p4265
aVBoost
p4266
aVInterProcess makes this more easy for you
p4267
aVCheck it out
p4268
as(dp4269
g15
V34509
p4270
stp4271
a((dp4272
g2
(lp4273
VIndeed there is:
p4274
as(dp4275
g15
V34509
p4276
stp4277
a((dp4278
g2
(lp4279
V is what you look for
p4280
aVExample:
p4281
as(dp4282
g15
V34509
p4283
stp4284
a((dp4285
g2
(lp4286
VI will just link to my other answer: How do YOU reduce compile time, and linking time for Visual C++ projects
p4287
aV(native c++)
p4288
aVAnother point i want to add, but which causes often problems is to use precompiled headers
p4289
aVBut please, only use them for parts which hardly change (like GUI toolkit headers)
p4290
aVOtherwise, they will cost you more time than they save you in the end
p4291
aVAnother option is, when you work with GNU make, to turn on  option:
p4292
aVI usually have it at  since i've got a dual core here
p4293
aVIt will then run compilers in parallel for different translation units, provided there are no dependencies between them
p4294
aVLinking cannot be done in parallel, since there is only one linker process linking together all object files
p4295
aVBut the linker itself can be threaded, and this is what the  ELF linker does
p4296
aVIt's optimized threaded C++ code which is said to link ELF object files a magnitude faster than the old  (and was actually included into binutils)
p4297
as(dp4298
g15
V34509
p4299
stp4300
a((dp4301
g2
(lp4302
VI think this is a reasonable way:
p4303
aVand it will also take care of hidden files and directories
p4304
aVThe slash isn't required after the dot and this then will also eliminate the possible accident of typing
p4305
aVNow if you are worried what it will delete, just change it into
p4306
aVAnd look at the list
p4307
aVNow you can put it into a function:
p4308
aVAnd now your remove is safe:
p4309
aVIf you are not in the habit of having embedded new-lines in filenames, you can omit the  and  parameters
p4310
aVBut i would use them, just in case :)
p4311
as(dp4312
g15
V34509
p4313
stp4314
a((dp4315
g2
(lp4316
VIn addition to what Steve says, let me add that sizeof does not evaluate its operand
p4317
aVSo you are free to do anything in it
p4318
aVNot only you can use not-yet initialized variables, but you can dereference a null-pointer, call functions not defined but only declared and do any other kind of stuff
p4319
aVI encourage you to always use the expression version for reasons Steve explained greatly
p4320
aVAlso consider that sometimes typenames are really long and unreadable, just think of pointers to functions (especially in C++)
p4321
aVInstead of writing  you just do
p4322
as(dp4323
g15
V34509
p4324
stp4325
a((dp4326
g2
(lp4327
VI'm sorry i only know the straight forward one in head:
p4328
aVThe alternative in comments can be used instead of the if to avoid branching
p4329
aVBut then again, the solution isn't exactly fast either and it makes it look stranger :)
p4330
as(dp4331
g15
V34509
p4332
stp4333
a((dp4334
g2
(lp4335
VOne real problem, and one possible solution:
p4336
aVwill give you the next iterator after the removed element
p4337
aVSo if you are at the beginning, and erase, you will be given the new beginning
p4338
aVIf you then decrement the iterator, you decrement before the begin
p4339
aVAnd this is invalid
p4340
aVBetter factor out the  into the body of the loop:
p4341
aVBetter use pre-increment for that since you never know what an iterator does behind the scene when it creates a copy of itself
p4342
aVwill return the new iterator, while  will return a copy of the iterator before the increment
p4343
aVI have commented the part where the possible solution is too :)
p4344
as(dp4345
g15
V34509
p4346
stp4347
a((dp4348
g2
(lp4349
VChange  to  if you want to see the first  lines instead of bytes
p4350
as(dp4351
g15
V34509
p4352
stp4353
a((dp4354
g2
(lp4355
VMaybe you mean
p4356
aVCompare sorted files FILE1 and FILE2 line by line
p4357
aVWith  no  options,  produce three-column output
p4358
aVColumn one
p4359
aVcontains lines unique to FILE1, column
p4360
aVtwo contains lines unique to
p4361
aVFILE2, and column three contains lines common to both files
p4362
aVThe secret in finding these information are the info pages
p4363
aVFor GNU programs, they are much more detailed than their man-pages
p4364
aVTry  and it will list you all the small useful utils
p4365
as(dp4366
g15
V34509
p4367
stp4368
a((dp4369
g2
(lp4370
Vlambda in the programming world means an anonymous function that can be passed and returned like every other normal variable
p4371
aVSo-called functional languages have them builtin but recently there is a growing set of languages supporting them, since they allow writing reusable code
p4372
aVSee this for example, written in the next version of C++:
p4373
aVIt does look similar in C# and other languages supporting lambdas
p4374
aVNow there is the word "closure"
p4375
aVIt means that a lambda can capture local variables and use them in the computation of its result:
p4376
aVThe variable  is now captured inside the closure and can be used within it
p4377
aVVariables may also be updated by a closure
p4378
aVLambdas are a basic building block of functional languages
p4379
aVHere is an example in haskell:
p4380
aVWill do the same as the C++ code above
p4381
aVIt maps the values in the list using the given function (a lambda here) into a result list
p4382
aVUsing haskell, you can see nicely how the syntax used maps to the mathematical notion of Lambda Calculus
p4383
as(dp4384
g15
V34509
p4385
stp4386
a((dp4387
g2
(lp4388
VMake sure that
p4389
aVWill not deep copy its contained TiXmlElement's
p4390
aVOtherwise you return a temporary, use that in the constructor to set the root node, which then will be destructed already
p4391
aVI haven't looked in its API, but just be aware of such pitfalls
p4392
aVThe reason for the ambiguous call is because:
p4393
aVThere are three overloads of  taking one argument:
p4394
aVYou access the TiXmlElement through  (using a  pointer)
p4395
aVBut the version taking a  has an implicit object parameter of
p4396
aVThat is, a qualification conversion is required to make the call work
p4397
aVFor the other versions taking a , there are conversions required too:
p4398
aVThere is an ambiguity between the first and the third overload
p4399
aVAn easy fix is to do
p4400
aVInstead, which will call the last version
p4401
aVAnother fix is to const_cast:
p4402
aVWhich will call the first version
p4403
aVAs for why it only happens in DEBUG
p4404
aVI remember that TiXML has an option to disable the use of the STL
p4405
aVMaybe in release mode you disabled it (and thus the overloads taking ), but in debug mode you forgot
p4406
as(dp4407
g15
V34509
p4408
stp4409
a((dp4410
g2
(lp4411
VPrivate can be useful in quite a few circumstances
p4412
aVJust one of them are policies:
p4413
aVIs partial class template specialization the answer to this design problem
p4414
aVAnother occasion where it is useful is to forbid copying and assigning:
p4415
aVBecause we don't want that the user has a pointer of type  to our object, we derive privately
p4416
aVThat counts not only for noncopyable, but many other such classes too (policies being the most common)
p4417
as(dp4418
g15
V34509
p4419
stp4420
a((dp4421
g2
(lp4422
VI'm sorry i've read this on the few sites where that term is used:
p4423
aVWhat about Virtual Destructor
p4424
aVYes there is a Virtual Destructor
p4425
ag3481
aVdestructor can be virtual as it is
p4426
aVpossible as at runtime depending on
p4427
aVthe type of object baller is balling
p4428
aVto, proper destructor will be called
p4429
aVI seriously doubt there is anything to that weird term, never heard it either
p4430
aVPutting "to ball" into my translator spits out some naughty words, and "baller" also gives no useful result
p4431
aVPossibly some pupil translated some word, and then others copied it
p4432
as(dp4433
g15
V34509
p4434
stp4435
a((dp4436
g2
(lp4437
VYou can only call static functions in the initializer list
p4438
aVThe way you have it in your code:
p4439
aVWill still initialize Base first, and then foo
p4440
aVThe order of how you write things in an constructor initializer list does not matter in any way
p4441
aVIt will always construct in this order:
p4442
aVFirst, all virtual base classes
p4443
aVThen the non-virtual base classes in the order they appear in the base-classes list
p4444
aVThen all member objects in the order they are defined in the class definition
p4445
aVThus, you end up calling  with an uninitialized value
p4446
aVThis problem is solved in
p4447
aVAlso note that calling any nonstatic member function before all the constructor initializers of all base-classes completed is undefined behavior
p4448
aVCalling static functions, however, is totally fine:
p4449
as(dp4450
g15
V34509
p4451
stp4452
a((dp4453
g2
(lp4454
VThere is no way to make that work
p4455
aVThe reason is simple: Adding a way to the iterators to get the container to which they are pointing is
p4456
aVPointless
p4457
aVIterators iterate over a collection
p4458
aVAs other said, only that, nothing more
p4459
aVNot compatible with the iterator requirements
p4460
aVRemember a pointer is a random access iterator
p4461
aVPutting a container pointer into the iterator would be of no use for algorithms, since they intend to be generic, decoupled from specific iterator implementations
p4462
aVA pointer used as an iterator can't have a pointer back to the array it was taken from as a member
p4463
aVYou say you need it for range checking
p4464
aVYou can provide an end iterator which points one after the last valid iterator position of a range
p4465
aVCheck whether your current position is not at the end
p4466
aVThat is all you need to do for range checking
p4467
as(dp4468
g15
V34509
p4469
stp4470
a((dp4471
g2
(lp4472
V contains this typedef:
p4473
aVI think this will get you started
p4474
aVThis works here:
p4475
aVAlso the  works using
p4476
as(dp4477
g15
V34509
p4478
stp4479
a((dp4480
g2
(lp4481
Vis called
p4482
aVIt will define the function as a non-member function of the namespace surrounding the class it appears in
p4483
aVActually, the inline there is redundant: It's implicitly declared inline if it's a friend definition
p4484
aVSome pros and cons of it:
p4485
aVIt makes the operator not visible to normal lookup
p4486
aVThe only way you can call it is using argument depending look-up
p4487
aVThis will keep the namespace free of lots of operator declarations visible normally
p4488
aVNote that this will also disable ability of calling it using implicit conversions to MonitorObjectString (because if both argument types do not match at the time of looking for candidates to be called, argument dependent look-up won't find the function)
p4489
aVThe lookup for names starts in the scope of the class the friend definition appears in
p4490
aVThis means that no long type-names or other names are needed to be written out
p4491
aVJust refer them as you would in a normal member function of the class
p4492
aVAs it is a friend, the function sees the internals of
p4493
aVBut that's neither good nor bad
p4494
aVIt depends on the situation
p4495
aVFor example if there are functions  making the function friend is pretty pointless
p4496
aVCould use  as-well then
p4497
aVI used to like this friend definition style of operators, because they have direct access to class members, and appear within the class definition - so i could have "everything with one sight"
p4498
aVRecently, however, i came to the conclusion that it's not always a good idea
p4499
aVIf you can (and you should) implement the operator purely using public member functions of the class, you should make it a non-friend (and non-member) operator, defined in the same namespace of the class
p4500
aVIt makes sure that if you change some implementation - but keep the interface of the class the same - the operator will still work and you have less cascading changes, because you know it can't access implementation details
p4501
aVHowever, i prefer this style over writing member operators, because operator functions at namespace scope have the added features of being symmetric with their arguments: They don't treat the left side special, because both sides are just normal arguments and not object arguments that are bound to
p4502
aVIf either the left or the right side is of the type of your class, the other side can be implicitly converted - disregarding of whether it's left or right
p4503
aVFor functions that are also defined without the friend definition syntax (traditionally, at namespace scope), you will have the feature of selectively including headers that make those operators available or not
p4504
as(dp4505
g15
V34509
p4506
stp4507
a((dp4508
g2
(lp4509
VBoost
p4510
aVFunction improved performance dramatically as of around 1
p4511
aV34 when used together with boost::bind
p4512
aVIf you profiled with an old boost version, maybe do it again with a more recent one
p4513
aVgot the ability to save small function objects in a small buffer allocated on the stack, instead of on the heap (using placement new)
p4514
aVSee this mailing list message: http://lists
p4515
aVboost
p4516
aVorg/Archives/boost/2006/01/98993
p4517
aVphp
p4518
as(dp4519
g15
V34509
p4520
stp4521
a((dp4522
g2
(lp4523
VUsing C++ arrays with  (that is, using dynamical arrays) should be avoided
p4524
aVThere is the problem you have to keep track of the size, and you need to delete them manually, and do all sort of housekeeping
p4525
aVUsing arrays on the stack is also discouraged because you don't have range checking, and passing the array around will loose any information about its size (array to pointer conversion)
p4526
aVYou should use  in that case, which wraps a C++ array in a small class and provides a  function and iterators to iterate over it
p4527
aVNow the std::vector vs
p4528
aVnative C++ arrays (taken shamelessly from here: http://www
p4529
aVxs4all
p4530
aVnl/~weegen/eelis/vector-speed
p4531
aVcpp):
p4532
as(dp4533
g15
V34509
p4534
stp4535
a((dp4536
g2
(lp4537
VFinal question answer: Yes, there is, it's called  and is at least as precise as
p4538
aVFor whether to use templates or not, yes i would use templates
p4539
aVThat's a great usecase for them and i think it will make porting to some other scalar number type easier
p4540
aVYou can then also just typedef a float and/or a double matrix, depending on the system you are running on and which one works faster/better there
p4541
as(dp4542
g15
V34509
p4543
stp4544
a((dp4545
g2
(lp4546
VWhy worry about checking for the pointers value
p4547
aVJust initialize it to a null pointer value and then just call delete on it
p4548
aVdelete on a null pointer does nothing (the standard guarantees it)
p4549
aVAnd everytime you call delete on it, you should set the pointer to a null pointer value
p4550
aVThen you are all fine
p4551
as(dp4552
g15
V34509
p4553
stp4554
a((dp4555
g2
(lp4556
VWhile i don't have a general answer or some idiom, there is
p4557
aVIt allows you to get a shared_ptr managing an object that is already managed by shared_ptr
p4558
aVSince in a member function you have no reference to those managing shared_ptr's, enable_shared_ptr does allow you to get a shared_ptr instance and pass that when you need to pass the this pointer
p4559
aVBut this won't solve the issue of passing  from within the constructor, since at that time, no shared_ptr is managing your object yet
p4560
as(dp4561
g15
V34509
p4562
stp4563
a((dp4564
g2
(lp4565
VThe builtin copy assignment operator just copies each member in turn using their copy assignment operators
p4566
aVI assume that it's safe for CPoint without looking at its documentation (reason: If it wasn't they would provide an own implementation, of course)
p4567
aVThat point class should just have two members (x and y) and those are just floats (or int depending for what it's used)
p4568
aVOne says it's a "shallow copy" since only the values of the members are copied
p4569
aVIf you have pointer members, the pointer values are copied, instead of the objects where the pointers point to
p4570
as(dp4571
g15
V34509
p4572
stp4573
a((dp4574
g2
(lp4575
VI'm no expert but i gonna try answering you anyway :)
p4576
aVFooClass is a non-POD type
p4577
aVThis mean it could have more than one sections of ,  or
p4578
aVWithin such a section, the order is that of the definition of the members, but across those sections, order is arbitrary and unspecified
p4579
aVfoo will always point to FooClass
p4580
aVWell so we have guarantee there is no offset adjustment done
p4581
aVAt least in one compilation, offsets will be the same then (don't have the backing up Standard quote
p4582
aVBut it can't work if they were different)
p4583
aVWe only care about behavior on a single compiler
p4584
aVWell since the order of members is unspecified across sections of access modifiers and the compiler is allowed to put padding between members, this won't buy us much
p4585
aVWe only care about objects on the stack (automatic storage duration)
p4586
aVWell i don't see how that changes anything of the object layout
p4587
aVSo after all i don't think you have any guarantee that the offset will be constant across compilations
p4588
aVFor considerations within one compilation (so if we would play with a compiler whose generated code uses an ABI that changes with each different compilation), the offset just can't be different
p4589
aVBut even if you know the offset, you can't access the member
p4590
aVYour only way to access a member is using the member access operator  and  (that's said in 9
p4591
aV2/9)
p4592
aVWhy not use data member pointers
p4593
aVThey allow accessing members safely
p4594
aVHere is an example: (looking up members by name)
p4595
as(dp4596
g15
V34509
p4597
stp4598
a((dp4599
g2
(lp4600
VSummary
p4601
aVIf any [static] library A depends on symbols defined in library B, then library A should appear first in the list supplied to the linker
p4602
aVMust be linked as
p4603
aVor, of course,
p4604
aVwhich leaves the compiler open to choose the dynamic  and  variant, if available
p4605
aVDynamic Libraries
p4606
aVThere is no requirements on the linking order of object files or dynamic libraries, though
p4607
aVOf course, a program that contains undefined behavior or depends on unspecified behavior could be affected by that order
p4608
aVFor example, if the order of constructor invocations depends on the link order of object files, and the program accesses objects across translation unit boundaries, then it may access a not yet constructed object - because its translated translation unit was linked after another object file, which contains the other, not yet constructed object
p4609
aVThose effects, however, show up in defect programs - a correct program should not depend on such order
p4610
aVSymbol resolution for dynamic librarries
p4611
aVThere are no requirements regarding symbol resolution that could be affected by the link order of dynamic libraries or object files
p4612
aVRuntime effects that depends on that link order, as in the example above, could happen, but should not affect valid programs
p4613
aVPrograms should use the tools of the toolchain to make sure they behave correctly
p4614
aVFor example GCC has the possibility to control when a constructor runs, and can thereby order the priority of constructor calls at the initialization time of objects
p4615
aVThe issue with Static Libraries
p4616
aVAnyway, static libraries are required to be linked in this order - otherwise, unresolved references will appear with GNU ld:
p4617
aVIf any library A depends on symbols defined in library B, then library A should appear first in the list supplied to the linker
p4618
aVThat can sometimes cause trouble in build-scripts that can be configured to link either way
p4619
aVResolving cyclic dependencies (with gnu linker)
p4620
aVThe GNU linker has an option which causes it to resolve cyclic references between A and B:
p4621
aVor
p4622
aVThe archives should be a list of archive files
p4623
aVThey may be either explicit file names, or -l options
p4624
aVThe specified archives are searched repeatedly until no new undefined references  are  created
p4625
aVNormally,  an  archive  is
p4626
aVsearched  only once in the order that it is specified on the command line
p4627
aVIf a symbol in that archive is needed to resolve
p4628
aVan undefined symbol referred to by an object in an archive that appears later on the command line, the linker would  not  be
p4629
aVable to resolve that reference
p4630
aVBy grouping the archives, they all be searched repeatedly until all possible references are
p4631
aVresolved
p4632
aVUsing this option has a significant performance cost
p4633
aVIt is best to use it only when there are unavoidable circular  references between two or more archives
p4634
aVNote that  in that description refer to static libraries
p4635
aVI've taken it from the manpage of GNU ld ()
p4636
aVAlso note that when using  for invoking the linker, you need to preceede linker options with  to prevent  from thinking the option is a compiler option
p4637
aVFor example
p4638
aVSpecific case with the standard libs
p4639
aVOne occasion that could be useful is to link together the c runtime library with the gcc low-level support libraries
p4640
aVHere is what my gcc port uses to pass to the linker:
p4641
aVBecause functions in  may refer to functions defined in the C library, but functions in the C library may refer to functions defined in  as well (it contains such functions as floating point emulation code)
p4642
aVAnother way to solve that problem could have been to use the start-group and end-group mechanism
p4643
as(dp4644
g15
V34509
p4645
stp4646
a((dp4647
g2
(lp4648
VSimilar comfortable to the eclipse gdb frontend is the emacs frontend, tightly tied to the emacs IDE
p4649
aVIf you already work with emacs, you will like it:
p4650
aVGDB Emacs Frontend
p4651
as(dp4652
g15
V34509
p4653
stp4654
a((dp4655
g2
(lp4656
VI outlined my view on the state of the matter here: How do you validate an object's internal state
p4657
aVGenerally, assert your claims and throw for violation by others
p4658
aVFor disabling asserts in release builds, you can do:
p4659
aVDisable asserts for expensive checks (like checking whether a range is ordered)
p4660
aVKeep trivial checks enabled (like checking for a null pointer or a boolean value)
p4661
aVOf course, in release builds, failed assertions and uncaught exceptions should be handled another way than in debug builds (where it could just call std::abort)
p4662
aVWrite a log of the error somewhere (possibly into a file), tell the customer that an internal error occurred
p4663
aVThe customer will be able to send you the log-file
p4664
as(dp4665
g15
V34509
p4666
stp4667
a((dp4668
g2
(lp4669
VHere is the translation:
p4670
aVSame as
p4671
aVNote the extra set of braces are for the case you have variable definitions in
p4672
aVThe scope of those must be kept local like in the do-loop case
p4673
aVSo, a do-while loop just executes its body at least once
p4674
aVApart from that, the two loops are identical
p4675
aVSo if we apply this rule to your code
p4676
aVThe corresponding while loop for your do-loop looks like
p4677
aVYes, you see the corresponding while for your do loop differs from your while :)
p4678
as(dp4679
g15
V34509
p4680
stp4681
a((dp4682
g2
(lp4683
VFor a gcc specific way to disable the warning, you can use  like
p4684
aVTo ignore the second parameter
p4685
aVIf your program relies on GCC technologies already, you can use that attribute to be 100% safe from that kind of warning
p4686
as(dp4687
g15
V34509
p4688
stp4689
a((dp4690
g2
(lp4691
VYou use C++
p4692
aVSo you can make use of some  C++ utilities to make your life easier
p4693
aVFor example, why not use new_handler
p4694
aVIn the new_handler, you could send all applications a signal so that they know that memory is needed for some application, and then wait a bit to give other applications the time to fulfill the request for memory
p4695
aVImportant is that you do something and not silently hope for available memory
p4696
aVThe new operator will call your handler again if still not enough memory is available, so you don't have to worry about whether or not all applications have free'ed the needed memory already
p4697
aVYou can also overload operator new if you need to know the size of memory that is needed in the new_handler
p4698
aVSee my other answer on how to do that
p4699
aVThis way, you have one central place to handle memory problems, instead of many places concerned with that
p4700
as(dp4701
g15
V34509
p4702
stp4703
a((dp4704
g2
(lp4705
VAs others already said, the order in which function arguments are evaluated is unspecified, and there is no sequence point between evaluating them
p4706
aVBecause you change  subsequently while passing each argument, you change and read  twice in between two sequence points
p4707
aVThat's actually undefined behavior
p4708
aVI found a very nice explanation in the GCC manual, which i think might be helpful:
p4709
aVThe C and C++ standards defines the order in which expressions in a C/C++ program are evaluated in terms of sequence points, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it
p4710
aVThese occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a &&, ||,
p4711
aV: or , (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places
p4712
aVOther than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified
p4713
aVAll these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified
p4714
aVHowever, the standards committee have ruled that function calls do not overlap
p4715
aVIt is not specified when between sequence points modifications to the values of objects take effect
p4716
aVPrograms whose behavior depends on this have undefined behavior; the C and C++ standards specify that \u201cBetween the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression
p4717
aVFurthermore, the prior value shall be read only to determine the value to be stored
p4718
aV\u201d
p4719
aVIf a program breaks these rules, the results on any particular implementation are entirely unpredictable
p4720
aVExamples of code with undefined behavior are a = a++;, a[n] = b[n++] and a[i++] = i;
p4721
aVSome more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs
p4722
aVThe standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases
p4723
aVLinks to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at http://gcc
p4724
aVgnu
p4725
aVorg/readings
p4726
aVhtml
p4727
as(dp4728
g15
V34509
p4729
stp4730
a((dp4731
g2
(lp4732
VI've written a explanation of what it does in this answer
p4733
aVIt explains how
p4734
aVgets the memory
p4735
aVhandles memory failure
p4736
aVhandles constructor exceptions
p4737
aVhandles special placement and nothrow versions
p4738
aVMichael explained how the default allocator function (::operator new) gets memory nicely and how it handles failure
p4739
aVI've seen your question on where the size of an object is stored in his comments
p4740
aVThe answer is, there isn't size stored if not necassary
p4741
aVRemember that C doesn't need the size for  (and ::operator new can just use ):
p4742
aVHere is an example where you see how storing the size has an impact on the size of allocation for the array form of a new expression (not covered by my other answer):
p4743
aVIt will print out something like this:
p4744
aVOne byte for the object itself and 4 bytes for the count which is stored just before the allocated area of the object
p4745
aVNow if we use the deallocation function without a size parameter (just removing it from the operator delete), we get this output:
p4746
aVThe C++ runtime here doesn't care about the size, so it doesn't store it anymore
p4747
aVNote that this is highly implementation specific, and that's what gcc does here to be able to tell you the size in the member operator delete
p4748
aVOther implementations may still store the size, and will most likely if there is a destructor to invoke for the class
p4749
aVFor example just adding  above makes gcc to store the size, regardless on what deallocation function we write
p4750
as(dp4751
g15
V34509
p4752
stp4753
a((dp4754
g2
(lp4755
V01- Is there any better C++ tool (IDE) other than NetBeans and MS Visual Studio
p4756
aVBetter means very mature and popular (and free)
p4757
aVThat's going to end in a flame war
p4758
aVI like emacs
p4759
aVIt's now been more than 20 years old (very mature
p4760
aVand quite popular
p4761
aVeclipse with CDT is also very popular and has been around for several years now
p4762
aVChoose the one you like the best
p4763
aV02- What is the difference between GNU Java and Sun Java compilers
p4764
aVThe GNU Java compiler is just gcc with a java frontend
p4765
aVIt can for example compile your java code into native binary code
p4766
aVThe Sun java compiler is from Sun and is more mature and it's regarded as the reference implementation of java compilers
p4767
aV03- Is there any other popular C/ObjC/C++ complier out which is free, mature and popular
p4768
aVIf by free you mean free as in free speech (open source code available), then look for llvm which can compile C++/C/Obj-C code (using gcc as a frontend
p4769
aVllvm is a compiler infrastructure
p4770
aVIt's not got the actual code)
p4771
aVDouglas Gregor works on a native llvm frontend for C++, without the need of gcc: http://clang
p4772
aVllvm
p4773
aVorg/
p4774
aVLCC is small C compiler you can use too on Unix
p4775
aVI've read there is also a Win32 version
p4776
aVIf by free you mean free as in beer, you can of course also take the Microsoft C++ compiler (shipped with Visual C++ Express) cl , but it will only work on Windows
p4777
as(dp4778
g15
V34509
p4779
stp4780
a((dp4781
g2
(lp4782
VHave you tried  with GCC
p4783
aVThese are runtime checks but are useful, as most often you have got to do with runtime calculated indices anyway
p4784
aVInstead of silently continue to work, it will notify you about those bugs
p4785
aVFor front-ends that support it (C and C++), instrument all risky
p4786
aVpointer/array dereferencing
p4787
aVoperations, some standard
p4788
aVlibrary string/heap functions, and some other associated
p4789
aVconstructs with range/validity tests
p4790
aVModules so instrumented
p4791
aVshould be immune to buffer overflows, invalid heap use, and some
p4792
aVother classes of C/C++ programming
p4793
aVerrors
p4794
aVThe instrumen\u2010
p4795
aVtation relies on a separate runtime library (libmudflap), which
p4796
aVwill be linked into a program if
p4797
aV-fmudflap is given at link
p4798
aVtime
p4799
aVRun-time behavior of the instrumented program is controlled
p4800
aVby the MUDFLAP_OPTIONS environment
p4801
aVvariable
p4802
aVSee "env
p4803
aVMUDFLAP_OPTIONS=-help a
p4804
aVout" for its options
p4805
aVUse -fmudflapth instead of -fmudflap to compile and to link if your program is multi-threaded
p4806
aVUse
p4807
aV-fmudflapir, in addition
p4808
aVto -fmudflap or -fmudflapth, if instrumentation should ignore pointer reads
p4809
aVThis produces
p4810
aVless instrumentation (and there\u2010
p4811
aVfore faster execution) and still provides some protection against
p4812
aVoutright memory corrupting writes, but
p4813
aVallows erroneously
p4814
aVread data to propagate within a program
p4815
aVHere is what mudflap gives me for your example:
p4816
aVIt has a bunch of options
p4817
aVFor example it can fork off a gdb process upon violations, can show you where your program leaked (using ) or detect uninitialized variable reads
p4818
aVUse  to get a list of options
p4819
aVSince mudflap only outputs addresses and not filenames and lines of the source, i wrote a little gawk script:
p4820
aVPipe the output of mudflap into it, and it will display the sourcefile and line of each backtrace entry
p4821
aVAlso  :
p4822
aVEmit extra code to check for buffer overflows, such as stack smashing attacks
p4823
aVThis is done by adding a guard variable to functions with vulnerable objects
p4824
aVThis includes functions that call alloca, and functions with buffers larger than 8 bytes
p4825
aVThe guards are initialized when a function is entered and then checked when the function exits
p4826
aVIf a guard check fails, an error message is printed and the program exits
p4827
aVLike -fstack-protector except that all functions are protected
p4828
as(dp4829
g15
V34509
p4830
stp4831
a((dp4832
g2
(lp4833
VMy kernel command line looks like this:
p4834
aVTell grub that it should omit passing  to the kernel when booting (pressing ,  on the entry you want edit will allow you to edit the arguments given to the kernel), and it will mount your root file system not read only anymore
p4835
aVThen you can change your /etc/fstab and restart
p4836
as(dp4837
g15
V34509
p4838
stp4839
a((dp4840
g2
(lp4841
VThe problem is that since the generic type parameter  is transformed into  by the compiler (it's called type erasure), you actually create an array of
p4842
aVWhat you can do is provide a  to the function:
p4843
aVYou will find a better exlanation of it here: Angelika Langer - Can I create an array whose component type is a type parameter
p4844
as(dp4845
g15
V34509
p4846
stp4847
a((dp4848
g2
(lp4849
VCall
p4850
aVIt will show you an option History Length (it's 30 by default here)
p4851
aVIf you want to save your history across emacs sessions, see
p4852
aVYou can use the normal arrow keys up  down to navigate through the history
p4853
as(dp4854
g15
V34509
p4855
stp4856
a((dp4857
g2
(lp4858
VIt is not always
p4859
aVIt's the value that you gave the program by the Operation System
p4860
aVFor example when starting a program using  you can set that to an arbitrary value:
p4861
aVThe first parameter is the file to start, and argv will contains argv[0] and all other parameters for main
p4862
aVenvp contains the environment variables (not defined by Standard C or C++
p4863
aVThis is a posix thing)
p4864
aVMore precisely, this is the definition of argv in C++:
p4865
aVAn implementation shall not predefine the main function
p4866
aVThis function shall not be overloaded
p4867
aVIt shall
p4868
aVhave a return type of type int, but otherwise its type is implementation-defined
p4869
aVAll implementations
p4870
aVshall allow both of the following definitions of main:
p4871
aVand
p4872
aVIn the latter form argc shall be the number of arguments passed to the program from the environment in
p4873
aVwhich the program is run
p4874
aVIf argc is nonzero these arguments shall be supplied in  through
p4875
aVas pointers to the initial characters of null-terminated multibyte strings (NTMBSs)
p4876
aV(17
p4877
ag1037
ag976
ag2790
ag1037
aV2) and  shall be the pointer to the initial character of a NTMBS that represents the
p4878
aVname used to invoke the program or ""
p4879
aVThe value of argc shall be nonnegative
p4880
aVThe value of
p4881
aVshall be 0
p4882
aV[Note: it is recommended that any further (optional) parameters be added after
p4883
aVargv
p4884
aV]
p4885
aVIt's pretty much up to the implementation what defines a "name used to invoke the program"
p4886
aVIf you want to get the full path of your executable, you can use GetModuleFileName on Windows, and  (for getting the name used to execute, may be relative) together with  (for getting the current working directory, trying to make the name absolute)
p4887
as(dp4888
g15
V34509
p4889
stp4890
a((dp4891
g2
(lp4892
VThis is explained in the book "C++ Templates - The Complete Guide"
p4893
aVIt's because your operator[] takes size_t, but you pass a different type which first has to undergo an implicit conversion to size_t
p4894
aVOn the other side, the conversion operator can be chosen too, and then the returned pointer can be subscript
p4895
aVSo there is the ambiguity
p4896
aVSolution is to drop the conversion operator
p4897
aVThey should generally be avoided as they just introduce problems, as you see
p4898
aVProvide a  and  member function that returns  and  respectively
p4899
aVThen you can use  if you want to pass to native openGL functions
p4900
aVThere is a bit confusion in the comments
p4901
aVI think i will update this answer now to reflect the most recent concept of this
p4902
as(dp4903
g15
V34509
p4904
stp4905
a((dp4906
g2
(lp4907
V is a valid function name in javascript
p4908
aVSo something defines a function  that takes a string looking for some class called  and returns a object where you call  on
p4909
aVI know that jQuery defines a function called  at least that does similar things
p4910
as(dp4911
g15
V34509
p4912
stp4913
a((dp4914
g2
(lp4915
VThis is a perfect example of using :
p4916
aVUnlike with other solutions (including static_cast), the cast will fail if no implicit conversion from  to  is possible
p4917
aVThis is done by a trick, best shown at a simple example:
p4918
aVThat's what is , just that it is a template which tells it the type of
p4919
as(dp4920
g15
V34509
p4921
stp4922
a((dp4923
g2
(lp4924
VSome example of my teacher, which worked without volatile with one compiler (lcc), but breaked when i run it with my gcc port for that processor
p4925
aVI had to put volatile in
p4926
aVIt reads continuously from all pages, until we get past the last page, which causes an interrupt, which will set  to 1
p4927
aVAs that happens behind the scenes, we tell the compiler to read and write the data always to memory
p4928
as(dp4929
g15
V34509
p4930
stp4931
a((dp4932
g2
(lp4933
VI like KScope, which copes with very large projects
p4934
as(dp4935
g15
V34509
p4936
stp4937
a((dp4938
g2
(lp4939
VBecause of two complement in C#, , the number where all bits are 1 in the binary representation
p4940
as(dp4941
g15
V34509
p4942
stp4943
a((dp4944
g2
(lp4945
VThere are three ways i see to solve this
p4946
aVWriting wrapper functions
p4947
aVWrite a wrapper function for each function that can throw exceptions which would handle exceptions
p4948
aVThat wrapper is then called by all the callers, instead of the original throwing function
p4949
aVUsing function objects
p4950
aVAnother solution is to take a more generic approach and write one function that takes a function object and handles all exceptions
p4951
aVHere is some example:
p4952
aVNow if you want to do something, you can just do it:
p4953
aVSince you provide function objects, you can manage state too
p4954
aVLet's say sendData updates len so that it knows how much bytes were read
p4955
aVThen you can write function objects that read and write and maintain a count for how many characters are read so far
p4956
aVThe downside of this second approach is that you can't access result values of the throwing functions, since they are called from the function object wrappers
p4957
aVThere is no easy way to get the result type of a function object binder
p4958
aVOne workaround is to write a result function object that is called by executeAndHandle after the execution of the function object succeeded
p4959
aVBut if we put too much work into this second approach just to make all the housekeeping work, it's not worth the results anymore
p4960
aVCombining the two
p4961
aVThere is a third option too
p4962
aVWe can combine the two solutions (wrapper and function objects)
p4963
aVThe trick is the  pattern
p4964
aVWe can return even when f returns void
p4965
aVThis eventually would be my favorite, since it allows both to keep handle code central at one place, but also allows special handling in the wrapper functions
p4966
aVYou can decide whether it's better to split this up and make an own class that has that error handler function and the wrappers
p4967
aVProbably that would be a cleaner solution (i think of Separation of Concerns here
p4968
aVOne is the basic DataHW functionality and one is the error handling)
p4969
as(dp4970
g15
V34509
p4971
stp4972
a((dp4973
g2
(lp4974
VThat's of course wrong
p4975
aVyou have to do
p4976
aVThe operator requires you to give it a type
p4977
aVBut still then, you are not finished
p4978
aVmust be known at compile time
p4979
aVIn your example it isn't
p4980
aVThe reason is because it becomes part of the type that is returned by the new expression:
p4981
aVAs types are static, yPos can't be determined at runtime
p4982
aVWhat you really want is a vector of int
p4983
aVBut i figure you want to do the memory management yourself, because you want to learn the language rules
p4984
aVSo go with this:
p4985
aVMake squares a :
p4986
aVChange the line in the constructor into
p4987
aVAdd a line like  into your destructor
p4988
aVAdd a copy constructor and copy assigment operator that copies along your memory when your instance is copied
p4989
aVadd a member-function like the below:
p4990
aVCode:
p4991
aVWhich will give you the integer at the given position
p4992
aVOf course, you can also overload  to have natural access using 2d indices:
p4993
aVThe outer index will select the row, the inner will select the column
p4994
aVIf you got to manage the memory right, you can change to better solutions
p4995
aVFor your task,  is ideal: Boost
p4996
aVMultiArray
p4997
aVOther problems
p4998
aVNever do  in a header file
p4999
aVThe reason is that all code that indirectly or directly include that file will automatically also have that line included and thus see all of std::
p5000
aVName conflicts will happen as soon as code tries to reference names that also happen to be defined by the C++ Standard Library
p5001
as(dp5002
g15
V34509
p5003
stp5004
a((dp5005
g2
(lp5006
VThe next C++ can do that with this syntax:
p5007
as(dp5008
g15
V34509
p5009
stp5010
a((dp5011
g2
(lp5012
VI think it's because there is no such inherent need for a copy constructor in Java and in C# for reference types
p5013
aVIn C++ objects are named
p5014
aVYou can (and you will most often) copy (and in C++1x move) them around e
p5015
aVg when returning from functions, since returning pointers require you to allocate dynamic memory which would be slow and painful to manage
p5016
aVThe syntax is T(x) so it makes sense to make a constructor taking a T reference
p5017
aVC++ couldn't make a clone function, since that would require returning an object by value again (and thus another copy)
p5018
aVBut in Java, objects are unnamed
p5019
aVThere are only references to them, which can be copied, but the object itself isn't copied
p5020
aVFor the cases when you actually need to copy them, you can use the clone call (but i read in other anwers clone is flawed
p5021
aVi'm no java programmer so i cannot comment that)
p5022
aVSince not the object itself is returned, but rather a reference to it, a clone function will suffice
p5023
aVAlso a clone function can be overriden
p5024
aVThat's not going to work with copy constructors
p5025
aVAnd incidentally, in C++ when you need to copy a polymorphic object, a  function is required too
p5026
aVIt's got a name, the so-called virtual copy constructor
p5027
as(dp5028
g15
V34509
p5029
stp5030
a((dp5031
g2
(lp5032
V is a marker interface
p5033
aVIt's solely for the purpose so that Object
p5034
aVclone can throw an exception to signal a class does not support cloning by using for example
p5035
aVFrom the documentation:
p5036
aVThe method clone for class Object
p5037
aVperforms a specific cloning operation
p5038
aVFirst, if the class of this object
p5039
aVdoes not implement the interface
p5040
aVCloneable, then a
p5041
aVCloneNotSupportedException is thrown
p5042
aVIt's got no methods
p5043
aVMaking it a generic isn't going to be of any use
p5044
as(dp5045
g15
V34509
p5046
stp5047
a((dp5048
g2
(lp5049
VYes, static datamembers are what you look for
p5050
aVBut you have to take care for the initialization/destruction order of your static variables
p5051
aVThere is no mechanism in C++ to ensure that your static variables are initialized before you use them across translation units
p5052
aVTo be safe, use what looks like the singleton pattern and is well known to fix that issue
p5053
aVIt works because:
p5054
aVAll static objects are completely constructed after the complete construction of any xml_stuff instance
p5055
aVThe order of destruction of static objects in C++ is the exact opposite of the completion of their construction (when their constructor finishes execution)
p5056
aVCode:
p5057
aVNow, the objects returned by xml_stuff::get_memberN() are valid the whole lifetime of any xml_stuff instance, because any of those members were constructed before any xml_stuff instance
p5058
aVUsing plain static data members, you cannot ensure that, because order of creation across translation units is left undefined in C++
p5059
as(dp5060
g15
V34509
p5061
stp5062
a((dp5063
g2
(lp5064
VI think it's worth telling you about the other disambiguations
p5065
aVFor  i already answered another one here
p5066
aVThe other one is template
p5067
aVLook here:
p5068
aVNote how we had to use both template and typename disambiguations
p5069
aVThe typename told the compiler
p5070
aVThe thing you access called  is indeed a type
p5071
aVDon't do multiplication, which would wrongly assume  is a static value (integer or something)
p5072
aVThe template told the compiler
p5073
aVThe  is a template used with the  argument
p5074
aVIt's not a comparison using  and  of  with  and what follows (which would indeed be total nonsense)
p5075
as(dp5076
g15
V34509
p5077
stp5078
a((dp5079
g2
(lp5080
Vusing directives and include preprocessor directives are two different things
p5081
aVThe  roughly corresponds to the  environment variable of Java, or the  option of the java virtual machine
p5082
aVWhat it does is making the types known to the compiler
p5083
aVJust including  for example will make you able to refer to  :
p5084
aVNow, using directives are like  in Java
p5085
aVThey make names visible in the scope they appear in, so you don't have to fully qualify them anymore
p5086
aVLike in Java, names used must be known before they can be made visible:
p5087
aVIt's bad practice to use a using directive in header files, because that means every other source file that happens to include it will see those names using unqualified name lookup
p5088
aVUnlike in Java, where you only make names visible to the package the import line appears in, In C++ it can affect the whole program, if they include that file directly or indirectly
p5089
aVBe careful when doing it at global scope even in implementation files
p5090
aVBetter to use them as local as possible
p5091
aVFor namespace std, i never use that
p5092
aVI, and many other people, just always write  in front of names
p5093
aVBut if you happen to do it, do it like this:
p5094
aVFor what namespaces are and why you need them, please read the proposal Bjarne Stroustrup gave 1993 for adding them to the upcoming C++ Standard
p5095
aVIt's well written:
p5096
aVhttp://www
p5097
aVopen-std
p5098
aVorg/jtc1/sc22/wg21/docs/papers/1993/N0262
p5099
aVpdf
p5100
as(dp5101
g15
V34509
p5102
stp5103
a((dp5104
g2
(lp5105
Vhttp://stackoverflow
p5106
aVcom/questions/308279/c-vs#308724
p5107
aVLook at the Excursion: Multi Dimensional Arrays which describes how you pass multi dimensional arrays to functions as arguments
p5108
aVBasicially you want to change your code into this:
p5109
aVAll but the last dimensions have to be known to the called function
p5110
aVOtherwise indexing the array, the compiler would not be able to calculate the correct distance to values into your array (a[1] is  bytes away from a[0])
p5111
aVYou seem to want to be able to accept the array without knowing the size of the dimensions
p5112
aVYou can use templates for this:
p5113
aVThe compiler will make a copy of (instantiate) that template for each value of N used with the function, auto-deducing the right N
p5114
as(dp5115
g15
V34509
p5116
stp5117
a((dp5118
g2
(lp5119
VNetbeans has a Swing GUI Builder
p5120
aVQuoting from their website
p5121
aVLet's hope this doesn't count has hidden advertising :)
p5122
aVDesign Swing GUIs by dragging and
p5123
aVpositioning GUI components from a
p5124
aVpalette onto a canvas
p5125
aVThe GUI builder
p5126
aVautomatically takes care of the
p5127
aVcorrect spacing and alignment
p5128
aVClick
p5129
aVinto JLabels, JButtons, ButtonGroups,
p5130
aVJTrees, JTextFields, ComboBoxes and
p5131
aVedit their properties directly in
p5132
aVplace
p5133
aVYou can use the GUI builder to
p5134
aVprototype GUIs right in front of
p5135
aVcustomers
p5136
as(dp5137
g15
V34509
p5138
stp5139
a((dp5140
g2
(lp5141
VNo
p5142
aVThe Standard way to build a finally like way is to separate the concerns (http://en
p5143
aVwikipedia
p5144
aVorg/wiki/Separation_of_concerns) and make objects that are used within the try block automatically release resources in their destructor (called "Scope Bound Resource Management")
p5145
aVSince destructors run deterministically, unlike in Java, you can rely on them to clean up safely
p5146
aVThis way the objects that aquired the resource will also clean up the resource
p5147
aVOne way that is special is dynamic memory allocation
p5148
aVSince you are the one aquiring the resource, you have to clean up again
p5149
aVHere, smart pointers can be used
p5150
as(dp5151
g15
V34509
p5152
stp5153
a((dp5154
g2
(lp5155
VThe compile can't know T couldn't be a struct (value type)
p5156
aVSo you have to tell it it can only be of reference type i think:
p5157
aVIt's because if T could be a value type, there could be cases where  would be ill formed - in cases when a type doesn't have an operator == defined
p5158
aVThe same will happen for this which is more obvious:
p5159
aVThat fails too, because you could pass a type T that wouldn't have a function foo
p5160
aVC# forces you to make sure all possible types always have a function foo
p5161
aVThat's done by the where clause
p5162
as(dp5163
g15
V34509
p5164
stp5165
a((dp5166
g2
(lp5167
VIt can't, currently
p5168
aVI don't know the reason yet (just looking it up, because i find it interesting)
p5169
aVUpdate: you can find the reason in the first proposal to support typedef-names as friends: http://www
p5170
aVopen-std
p5171
aVorg/jtc1/sc22/wg21/docs/papers/2003/n1520
p5172
aVpdf
p5173
aVThe reason is that the Standard only supported elaborated-type-specifiers
p5174
aVIt's easy to allow only those, and say if the entity declared as friend is not declared yet, it will be made a member of the surrounding namespace
p5175
aVBut this means that if you want to use a template parameter, you would have to do (a class is required then for example)
p5176
aVBut that brought additional problems, and it was figured not worth the gain
p5177
aVNow, the paper proposes to allow additional type specifiers to be given (so that this then allows use of template parameters and typedef-names)
p5178
aVThe next C++ version (due to 2010) will be able to do it
p5179
aVSee this updated proposal to the standard: http://www
p5180
aVopen-std
p5181
aVorg/jtc1/sc22/wg21/docs/papers/2005/n1791
p5182
aVpdf
p5183
aVIt will not allow only typedef names, but also template parameters to be used as the type declared as friend
p5184
as(dp5185
g15
V34509
p5186
stp5187
a((dp5188
g2
(lp5189
VFor ELF binaries, you can use readelf:
p5190
aV: list symbols
p5191
aV: don't cut too long names
p5192
aVThe awk command will then filter out all functions, and c++filt will unmangle them
p5193
aVThat means it will convert them from an internal naming scheme so they are displayed in human readable form
p5194
aVIt outputs names similar to this (taken from boost
p5195
aVfilesystem lib):
p5196
aVWithout c++filt, the name is displayed as
p5197
as(dp5198
g15
V34509
p5199
stp5200
a((dp5201
g2
(lp5202
VCode of dlo
p5203
aVc (the lib):
p5204
aVCompile with
p5205
aVHere the code of the main program (copied from dlopen manpage, and adjusted):
p5206
aVBuild with
p5207
aVOutput:
p5208
aVThe  option puts all symbols in the dynamic symbol table (which is mapped into memory), not only the names of the used symbols
p5209
aVRead further about it here
p5210
aVOf course you can also provide function pointers (or a struct of function pointers) that define the interface between the library and your main program
p5211
aVIt's actually the method what i would choose probably
p5212
aVI heard from other people that it's not so easy to do  in windows, and it also would make for a cleaner communication between library and main program (you've got precise control on what can be called and not), but it also requires more house-keeping
p5213
as(dp5214
g15
V34509
p5215
stp5216
a((dp5217
g2
(lp5218
VYeah you are right
p5219
aVA plain
p5220
aVis enough to allocate them
p5221
aVYou can then access them
p5222
aVand delete them in your destructor using the way you showed:
p5223
aVThe compiler will remember how many elements were allocated, and call the destructor for each list correctly
p5224
aVThe point of overloading the new and delete operator is to provide custom memory allocation strategy
p5225
aVFor example, you could preallocate memory, and then take from that pool, instead of allocating everytime again memory from the OS
p5226
aVBut note, you have to write a copy constructor and copy assignment operator too
p5227
aVSince if someone copies your hash map, the linked list has to be copied too, and not just the pointer
p5228
aVOr you can make the copy constructor and copy assignment operator private and don't define them, disallowing copies of your hash map:
p5229
as(dp5230
g15
V34509
p5231
stp5232
a((dp5233
g2
(lp5234
VSo the standard note first, please don't worry about performance too much if not profiled yet :)
p5235
aVI'm not sure about the manual loop and checking for a dot
p5236
aVTwo issues
p5237
aVDepending on the locale, the dot can actually be a "," too (here in Germany that's the case :)
p5238
aVAs others noted, there is the issue with numbers like 1e7
p5239
aVPreviously I had a version using sscanf here
p5240
aVBut measuring performance showed that sscanf is is significantly slower for bigger data-sets
p5241
aVSo I'll show the faster solution first (Well, it's also a whole more simple
p5242
aVI had several bugs in the sscanf version until I got it working, while the strto[ld] version worked the first try):
p5243
aVJust for fun, here is the version using sscanf:
p5244
aVI think that should work
p5245
aVHave fun
p5246
aVTest was done by converting test strings (small ones) randomly 10000000 times in a loop:
p5247
ag488
aV6s for
p5248
ag2790
aV7s for
p5249
aV0
p5250
aV5s for  until "
p5251
aVClear win for , considering it will parse numbers correctly I will praise it as the winner over manual looping
p5252
aVAnyway, 1
p5253
aV2s/10000000 = 0
p5254
aV00000012 difference roughly for one conversion isn't all that much in the end
p5255
as(dp5256
g15
V34509
p5257
stp5258
a((dp5259
g2
(lp5260
VThe bash manpage says that the variable OSTYPE stores the name of the operation system:
p5261
aVAutomatically set to a string that describes the operating system on which bash is executing
p5262
aVThe  default  is  system-
p5263
aVdependent
p5264
aVIt is set to  here
p5265
as(dp5266
g15
V34509
p5267
stp5268
a((dp5269
g2
(lp5270
VUse the visitor pattern
p5271
aVDoing it without is cumbersome, and was subject of this question: http://stackoverflow
p5272
aVcom/questions/370812/work-around-javas-static-method-dispatching-without-double-dispatchvisitor-patt
p5273
aVHowever, can you please state your original problem
p5274
aVI mean, why do you need to have those two overloads for the Add method
p5275
aVMaybe you can solve it in a completely different way which doesn't need to rely on dynamic dispatch like the visitor pattern
p5276
as(dp5277
g15
V34509
p5278
stp5279
a((dp5280
g2
(lp5281
VI don't know what exactly you want to know
p5282
aVFor this simple example
p5283
aVOutputs the following into a file
p5284
aVSee the gcc manpage for details
p5285
aVChanging classA to this:
p5286
aVSuddenly pops up a virtual table:
p5287
aVWhat looks so strange (_ZTI6classA and _ZTI6classC and _ZTV6classC) is actually a pointer to the RTTI information gcc created for the classes
p5288
aVUsing  shows that it will assign a null pointer to the second entries of the vtables then
p5289
aVNice, have fun digging in those information
p5290
as(dp5291
g15
V34509
p5292
stp5293
a((dp5294
g2
(lp5295
VIt's precisely this bunch of code:
p5296
aVTrying to pass an int to extractArray, which wants a pointer to a pointer, presumable your dynamic array, and not an int
p5297
aVTry changing it to
p5298
aVOnly changing result to a pointer to pointer won't work
p5299
aVYou of course also have to change what extractPiece returns (changing from int to int**)
p5300
as(dp5301
g15
V34509
p5302
stp5303
a((dp5304
g2
(lp5305
VFirst, the binky video may help
p5306
aVIt's a nice video about pointers
p5307
aVFor arithmetic, here is an example:
p5308
aV(Note that incrementing a pointer that contains a null pointer value strictly is undefined behavior
p5309
aVWe used NULL because we were only interested in the value of the pointer
p5310
aVNormally, only use increment/decrement when pointing to elements of an array)
p5311
aVThe following shows two important concepts
p5312
aVaddition/subtraction of a integer to a pointer means move the pointer forward / backward by N elements
p5313
aVSo if an int is 4 bytes big, pa could contain 0x4 on our platform after having incremented by 1
p5314
aVsubtraction of a pointer by another pointer means getting their distance, measured by elements
p5315
aVSo subtracting pb from pa will yield 1, since they have one element distance
p5316
aVOn a practical example
p5317
aVSuppose you write a function and people provide you with an start and end pointer (very common thing in C++):
p5318
aVis what is the type of (end - begin)
p5319
aVIt may be a synonym for "int" for some compiler, but may be another type for another one
p5320
aVOne cannot know, so one chooses the generic typedef
p5321
as(dp5322
g15
V34509
p5323
stp5324
a((dp5325
g2
(lp5326
VC++ says
p5327
aVBecause a copy assignment operator is
p5328
aVimplicitly declared for a class if not declared by the user, a base class copy assignment operator is always
p5329
aVhidden by the copy assignment operator of a derived class (13
p5330
ag1014
aV3)
p5331
aVA using-declaration (7
p5332
ag1037
aV3) that brings
p5333
aVin from a base class an assignment operator with a parameter type that could be that of a copy-assignment
p5334
aVoperator for the derived class is not considered an explicit declaration of a copy-assignment operator and
p5335
aVdoes not suppress the implicit declaration of the derived class copy-assignment operator; the operator introduced by the using-declaration is hidden by the implicitly-declared copy-assignment operator in the
p5336
aVderived class
p5337
aVThe bug in the code is that your base class declares the  to accept a reference of type of the derived class
p5338
aVThat won't prevent an implicit public declaration of an operator= for the base
p5339
aVThus, your derived class and your base class are still assignable
p5340
aVTry changing your noncopyable class into a non-template, which should suffice:
p5341
aVOne more thing i have just figured in that code: Don't make the destructor of Uncopyable virtual
p5342
aVThe reason is, no-one (apart from the derived class itself) can call delete on a pointer to Uncopyable (because 1: the destructor is protected, 2: you derive privately)
p5343
aVSo it's not the concern of Uncopyable to make the destructor of the derived class implicitly virtual
p5344
aVIf the derived class needs to have a virtual destructor, put virtual in there instead, and leave Uncopyables' destructor non-virtual
p5345
as(dp5346
g15
V34509
p5347
stp5348
a((dp5349
g2
(lp5350
VRAII This is a strange name for a simple but awesome concept
p5351
aVBetter is the name Scope Bound Resource Management (SBRM)
p5352
aVThe idea is that often you happen to allocate resources  at the begin of a block, and need to release it at the exit of a block
p5353
aVExiting the block can happen by normal flow control, jumping out of it, and even by an exception
p5354
aVTo cover all these cases, the code becomes more complicated and redundant
p5355
aVJust an example doing it without SBRM:
p5356
aVAs you see there are many ways we can get pwned
p5357
aVThe idea is that we encapsulate the resource management into a class
p5358
aVInitialization of its object acquires the resource ("Resource Acquisition Is Initialization")
p5359
aVAt the time we exit the block (block scope), the resource is freed again
p5360
aVThat is nice if you have got classes of their own which are not solely for the purpose of allocating/deallocating resources
p5361
aVAllocation would just be an additional concern to get their job done
p5362
aVBut as soon as you just want to allocate/deallocate resources, the above becomes unhandy
p5363
aVYou have to write a wrapping class for every sort of resource you acquire
p5364
aVTo ease that, smart pointers allow you to automate that process:
p5365
aVNormally, smart pointers are thin wrappers around new / delete that just happen to call  when the resource they own goes out of scope
p5366
aVSome smart pointers, like shared_ptr allow you to tell them a so-called deleter, which is used instead of
p5367
aVThat allows you, for instance, to manage window handles, regular expression resources and other arbitrary stuff, as long as you tell shared_ptr about the right deleter
p5368
aVThere are different smart pointers for different purposes:
p5369
aVunique_ptr is a smart pointer which owns an object exclusively
p5370
aVIt's not in boost, but it will likely appear in the next C++ Standard
p5371
aVIt's non-copyable but supports transfer-of-ownership
p5372
aVSome example code (next C++):
p5373
aVCode:
p5374
aVUnlike auto_ptr, unique_ptr can be put into a container, because containers will be able to hold non-copyable (but movable) types, like streams and unique_ptr too
p5375
aVscoped_ptr is a boost smart pointer which is neither copyable nor movable
p5376
aVIt's the perfect thing to be used when you want to make sure pointers are deleted when going out of scope
p5377
aVCode:
p5378
aVshared_ptr is for shared ownership
p5379
aVTherefor, it's both copyable and movable
p5380
aVMultiple smart pointer instances can own the same resource
p5381
aVAs soon as the last smart pointer owning the resource goes out of scope, the resource will be freed
p5382
aVSome real world example of one of my projects:
p5383
aVCode:
p5384
aVAs you see, the plot-source (function fx) is shared, but each one has a separate entry, on which we set the color
p5385
aVThere is a weak_ptr class which is used when code needs to refer to the resource owned by a smart pointer, but doesn't need to own the resource
p5386
aVInstead of passing a raw pointer, you should then create a weak_ptr
p5387
aVIt will throw an exception when it notices you try to access the resource by an weak_ptr access path, even though there is no shared_ptr anymore owning the resource
p5388
as(dp5389
g15
V34509
p5390
stp5391
a((dp5392
g2
(lp5393
VI think the most important reason is that you cannot put an unnamed class in namespace scope
p5394
aVSo, the following is not valid (gcc accepts, but warns
p5395
aVcomeau doesn't accept in strict mode):
p5396
aVThe type of  has no linkage because there is no way to declare its name in another scope referring to it (precisely because it has no name)
p5397
aVBut using it to declare , which has linkage (external here) is not valid (3
p5398
aV5/8)
p5399
aVhas to be defined locally in main where it will have no linkage
p5400
aVYou also cannot pass single to function templates and it can't have static data members (because there is no way to define them)
p5401
aVAll those restrictions make it more or less not applicable as a substitution for a singleton
p5402
as(dp5403
g15
V34509
p5404
stp5405
a((dp5406
g2
(lp5407
VWhat about this one
p5408
aV(If you need to pass some arguments, define your own interface with a function having a suitable parameter, and use that instead of Runnable)
p5409
as(dp5410
g15
V34509
p5411
stp5412
a((dp5413
g2
(lp5414
VNo
p5415
aVIf the parent is killed, children become children of the init process (that has the process id 1 and is launched as the first user process by the kernel)
p5416
aVThe init process checks periodically for new children, and kills them if they have exited (thus freeing resources that are allocated by their return value)
p5417
aVThe question was already discussed with quality answers here:
p5418
aVhttp://stackoverflow
p5419
aVcom/questions/284325/how-to-make-child-process-die-after-parent-exits
p5420
as(dp5421
g15
V34509
p5422
stp5423
a((dp5424
g2
(lp5425
VYou've forgot a closing parenthesis:
p5426
as(dp5427
g15
V34509
p5428
stp5429
a((dp5430
g2
(lp5431
VIt is certainly wise to buy the book
p5432
aVC++1x will hardly break with previous code
p5433
aVNearly everything you learn is also possible with the next C++, and it will greatly help you understand the need of why C++1x will introduce what feature
p5434
aVFor example, why will it have variadic templates, and why those concepts
p5435
as(dp5436
g15
V34509
p5437
stp5438
a((dp5439
g2
(lp5440
V exits your program without calling functions registered using  first, and without calling objects' destructors first
p5441
aVdoes both before exiting your program
p5442
aVIt does not call destructors for automatic objects though
p5443
aVSo
p5444
aVWill destruct  and  properly, but will not call destructors of
p5445
aVwouldn't call destructors of neither objects
p5446
aVAs this is unfortunate, the C++ Standard describes an alternative mechanism which ensures properly termination:
p5447
aVObjects with automatic storage duration are all destroyed in a program whose function  contains no automatic objects and executes the call to
p5448
aVControl can be transferred directly to such a  by throwing an exception that is caught in
p5449
aVInstead of calling , arrange that code  instead
p5450
as(dp5451
g15
V34509
p5452
stp5453
a((dp5454
g2
(lp5455
VYou cannot initialize the pointers of your_T to null using memset, because it is not specified that a null pointer has its bit pattern all consisting of null bits
p5456
aVBut you can create your array like this:
p5457
aVThe elements will be default initialized, which means for a pointer that the pointer will contain a null pointer value
p5458
aVIf your array is global, you don't even have to care
p5459
aVThat will happen by default then
p5460
as(dp5461
g15
V34509
p5462
stp5463
a((dp5464
g2
(lp5465
Vb is contained in Foo
p5466
aVIf the Foo object ends lifetime, b automatically ends lifetime too
p5467
aVThis is what models composition
p5468
aVb above denotes the object itself, not just a pointer to it like in Java
p5469
aVTherefor, if b goes out of scope, the object will end lifetime
p5470
aVHere, the object b points to is used by or referenced by the Foo object
p5471
aVIf the Foo object ends lifetime, the object b points to may continue to live, depending on circumstances
p5472
aVThis can be used to model aggregation and general relationship
p5473
aVThe object may be shared with other Foo objects for example
p5474
aVPointers are roughly what references are in Java
p5475
aVThey can also point to nothing
p5476
aVIf a pointer points to nothing, it's a null pointer
p5477
aVSimilar to pointers are references
p5478
aVReferences in C++ must be initialized and can only point to one (valid) object, for which the reference was initialized
p5479
aVA reference therefor cannot hold value which could mean "nothing" like  in Java
p5480
as(dp5481
g15
V34509
p5482
stp5483
a((dp5484
g2
(lp5485
VThe g of the derived class will be called
p5486
aVIf you want to call the function in the base, call
p5487
aVinstead
p5488
aVIf you want to call the derived, but still want to have the base version be called, arrange that the derived version of g calls the base version in its first statement:
p5489
aVThe fact that a function from the base can call a virtual method and control is transferred into the derived class is used in the template method design pattern
p5490
aVFor C++, it's better known as Non-Virtual-Interface
p5491
aVIt's widely used also in the C++ standard library (C++ stream buffers for example have functions  that call virtual functions that do the real work
p5492
aVFor example  calls the protected )
p5493
aVI wrote an example of that in this answer: How do you validate an object\u2019s internal state
p5494
as(dp5495
g15
V34509
p5496
stp5497
a((dp5498
g2
(lp5499
VYour approach was basically into the right direction
p5500
aVYou will have to know the type you put into
p5501
aVYou can use  and you will be able to put just about anything into the map, as long as you know what you put into:
p5502
aVSome answers recommended the use of  to solve this problem
p5503
aVBut it won't let you store arbitrary typed values in the map (like you wanted)
p5504
aVYou have to know the set of possible types before-hand
p5505
aVGiven that, you can do the above more easily:
p5506
aVThat works because  overloads  for that purpose
p5507
aVIt's important to understand that if you want to save what is currently contained in the variant, you still have to know the type, as with in the  case:
p5508
aVThe order of assignments to a variant is a runtime property of the control flow of your code, but the type used of any variable is determined at compile time
p5509
aVSo if you want to get the value out of the variant, you have to know its type
p5510
aVAn alternative is to use visitation, as outlined by the variant documentation
p5511
aVIt works because the variant stores a code which tells it which type was last assigned to it
p5512
aVBased on that, it decides at runtime which overload of the visitor it uses
p5513
aVis quite big and is not completely standard compliant, while  is standard compliant but uses dynamic memory even for small types (so it's slower
p5514
aVvariant can use the stack for small types)
p5515
aVSo you have to trade off what you use
p5516
aVIf you actually want to put objects into it which differ only in the way they do something, polymorphism is a better way to go
p5517
aVYou can have a base-class which you derive from:
p5518
aVWhich would basically require this class layout:
p5519
aVThe  is a so-called smart pointer
p5520
aVIt will delete your objects automatically if you remove them out of your map and nothing else is referencing them them anymore
p5521
aVIn theory you could have worked with a plain pointer too, but using a smart pointer will greatly increase safety
p5522
aVRead the shared_ptr manual i linked to
p5523
as(dp5524
g15
V34509
p5525
stp5526
a((dp5527
g2
(lp5528
VI think i would do it this way
p5529
aVbeing the input string
p5530
aVbeing the lengths of the parts after which we should put a comma
p5531
aVCode:
p5532
as(dp5533
g15
V34509
p5534
stp5535
a((dp5536
g2
(lp5537
VI take it that you know that C++ already has a linked list class, and you want to implement your own because you want to learn how to do it
p5538
aVFirst, read http://stackoverflow
p5539
aVcom/questions/392397/arrays-whats-the-point , which contains a good answer of basic data-structures
p5540
aVThen think about how to model them in C++:
p5541
aVBasically that's all you need to implement a list
p5542
aV(a very simple one)
p5543
aVYet it has no abstractions, you have to link the items per hand:
p5544
aVNow, you have have a linked list of nodes, all allocated on the stack:
p5545
aVNext step is to write a wrapper class  that points to the start node, and allows to add nodes as needed, keeping track of the head of the list (the following is very simplified):
p5546
aVNext step is to make the List a template, so that you can stuff other values (not only integers)
p5547
aVIf you are familiar with smart pointers, you can then replace the raw pointers used with smart pointers
p5548
aVOften i find people recommend smart pointers to starters
p5549
aVBut in my opinion you should first understand why you need smart pointers, and then use them
p5550
aVBut that requires that you need first understand raw pointers
p5551
aVOtherwise, you use some magic tool, without knowing why you need it
p5552
as(dp5553
g15
V34509
p5554
stp5555
a((dp5556
g2
(lp5557
VIt's very simple with a shared ownership smart pointer:
p5558
aVAssuming the app object owns the clients, and the clients all share the one provider
p5559
aVMake the clients take a  then, instead of a
p5560
aVAs long as there is still a copy of a shared_ptr owning the provider object, the object won't be freed
p5561
aVThe best would be to not copy clientA and clientB, and not copy app by returning it by value, but move the clients into the app, and move the app itself into the returned object
p5562
aVThat will be possible with the upcoming C++ version
p5563
aVBut currently, either you make them pointers (using shared_ptr), or you keep copying them
p5564
aVAnother option would be to use auto_ptr, which has a pseudo-transfer-of-ownership semantic
p5565
aVBut that template has some inherent problems
p5566
aVSo you should avoid using it
p5567
as(dp5568
g15
V34509
p5569
stp5570
a((dp5571
g2
(lp5572
VYou cannot forward declare a member function
p5573
aVI think the reason is that, when you call the function on a pointer to B, the compiler has to pass the this pointer to that method
p5574
aVBut it doesn't know the precise class hierarchy of B yet
p5575
aVSo possible adjustments of that pointer (due to the method being virtual, for example) would not be possible at that point
p5576
aVThe compiler would also not know what visibility that method has
p5577
aVAfter all, it could be private and you are not allowed to call it from outside
p5578
aVThe only way to declare that member function is to define the class, and then declare the function within that definition
p5579
aVAnother way to solve your problem is to declare your free function instead:
p5580
aVThen define do_bar in a file in which you can safely include the definition of the class B
p5581
as(dp5582
g15
V34509
p5583
stp5584
a((dp5585
g2
(lp5586
VYou are looking for http://en
p5587
aVwikipedia
p5588
aVorg/wiki/Factory_method_pattern
p5589
as(dp5590
g15
V34509
p5591
stp5592
a((dp5593
g2
(lp5594
VI tend to use  (because everyone does make bugs, nobody is perfect) , but i don't use  (treat warnings as errors) because now and then gcc warns about things which are right anyway (false positives)
p5595
as(dp5596
g15
V34509
p5597
stp5598
a((dp5599
g2
(lp5600
VI think this largely depends on the type of applications you write
p5601
aVIf i would write something that doesn't affect the global stability of the system, let's say a game or a movie player, i would not check for that exception
p5602
aVMy application would call  and i could log it somewhere, or my kernel would kill my program first to make room for other programs
p5603
aVIf i write a program whose stability directly corresponds with the one of the system it runs on, let's say a video driver or an init system, i would check for memory exceptions all the time (probably wrapping allocations in a function), and get some memory from a pre-allocated pool in case of an allocation failure
p5604
aVI think this all depends on proportionality
p5605
aVWhat do you gain from a amazingly stable movie player, if it starts slowing down to play movies because of your aggressive checking
p5606
aVBtw, someone answered malloc won't return 0 when you're out of memory for some systems
p5607
aVThat's right, but as the manpage of malloc points out (linux specific)
p5608
aVIn case Linux is employed under circumstances where it would be less desirable to suddenly lose some randomly picked processes, and moreover the kernel version is sufficiently recent, one can switch off this overcommitting behavior using a command like:
p5609
aVSee also the kernel Documentation directory, files vm/overcommit-accounting and sysctl/vm
p5610
aVtxt
p5611
as(dp5612
g15
V34509
p5613
stp5614
a((dp5615
g2
(lp5616
VIt's a builtin provided by the GCC compiler to implement the  macro that is specified by the C and C++ Standard:
p5617
aVGCC - offsetof
p5618
aVIt returns the offset in bytes that a member of a POD struct/union is at
p5619
aVSample:
p5620
aV@Jonathan provides a nice example of where you can use it
p5621
aVI remember having seen it used to implement intrusive lists (lists whose data items include next and prev pointers itself), but i can't remember where it was helpful in implementing it, sadly
p5622
as(dp5623
g15
V34509
p5624
stp5625
a((dp5626
g2
(lp5627
VAs you now showed your init function accepts a non-member function
p5628
aVso do it like this:
p5629
aVand call Init with
p5630
aVThat works because a function pointer to a static member function is not a member function pointer and can thus be handled like just a pointer to a free function
p5631
as(dp5632
g15
V34509
p5633
stp5634
a((dp5635
g2
(lp5636
VC doesn't have a foreach, but macros are frequently used to emulate that:
p5637
aVAnd can be used like
p5638
aVIteration over an array is also possible:
p5639
aVAnd can be used like
p5640
aVEdit: In case you are also interested in C++ solutions, boost has it (but C++ itself doesn't have a native for-each loop yet): Boost
p5641
aVForEach
p5642
as(dp5643
g15
V34509
p5644
stp5645
a((dp5646
g2
(lp5647
VOk, here is my silly way (untested
p5648
aVusing a pure shell script parsing your file
p5649
aVThe  command can parse a date string, and output the seconds since 1970
p5650
aVSubtract them from the current seconds, and divide by the amount of seconds one month takes
p5651
aVPrint that value together with the users path
p5652
aVSort the output using  and pipe that into  then you can browse the list of users and their activity
p5653
aVFor a non-hackish way, consider Juan's lastlog idea
p5654
aVIt's on my linux too
p5655
as(dp5656
g15
V34509
p5657
stp5658
a((dp5659
g2
(lp5660
VYou can execute something before main once if a instantiation of a template is made
p5661
aVThe trick is to put a static data member into a class template, and reference that from outside
p5662
aVThe side effect that static data member triggers can be used to call the register function:
p5663
aVDerive the class you want to be auto-registered from
p5664
aVThe register function will be called before main, when the declaration of  is instantiated (which happens when that class is derived from, which will implicitly instantiate that class from the template)
p5665
aVHaving some test program (instead of the register function, a function do_it is called):
p5666
aVYields this output (as expected):
p5667
as(dp5668
g15
V34509
p5669
stp5670
a((dp5671
g2
(lp5672
VWhen you want to have wide characters stored in your string
p5673
aVdepends on the implementation
p5674
aVVisual C++ defaults to 16 bit if i remember correctly, while GCC defaults depending on the target
p5675
aVIt's 32 bits long here
p5676
aVPlease note wchar_t (wide character type) has nothing to do with unicode
p5677
aVIt's merely guaranteed that it can store all the members of the largest character set that the implementation supports by its locales, and at least as long as char
p5678
aVYou can store unicode strings fine into  using the  encoding too
p5679
aVBut it won't understand the meaning of unicode code points
p5680
aVSo  won't give you the amount of logical characters in your string, but merely the amount of char or wchar_t elements stored in that string/wstring
p5681
aVFor that reason, the gtk/glib C++ wrapper folks have developed a  class that can handle utf-8
p5682
aVIf your wchar_t is 32 bits long, then you can use  as an unicode encoding, and you can store and handle unicode strings using a fixed (utf-32 is fixed length) encoding
p5683
aVThis means your wstring's  function will then return the right amount of wchar_t elements and logical characters
p5684
aVYes, char is always at least 8 bit long, which means it can store all ASCII values
p5685
aVYes, all major compilers support it
p5686
as(dp5687
g15
V34509
p5688
stp5689
a((dp5690
g2
(lp5691
VWell, this statement
p5692
aVCreates an array either locally or non-locally, depending on where the definition occurs
p5693
aVInitializing it like that, with an aggregate initializer will initialize all its elements to zero (the first explicitly, the remaining ones implicitly)
p5694
aVTherefore i wonder why your program outputs non-zero values
p5695
aVUnless the fill happens before the read, then that makes sense
p5696
aVThat will interpret the bytes making up the array as unsigned short objects when you read from that pointer's target
p5697
aVStrictly speaking, the above is undefined behavior, because you can't be sure the array is suitable aligned, and you would read from a pointer that's not pointing at the type of the original pointed type (unsigned char <-> unsigned short)
p5698
aVIn C++, the only portable way to read the value out of some other pod (plain old data
p5699
aVthat's all the structs and simple types that are possible in C too (such as short), broadly speaking) is by using such library functions as  or
p5700
aVSo if you read  above, you would interpret the first  bytes of the array, and try to read it as unsigned short (that's called )
p5701
as(dp5702
g15
V34509
p5703
stp5704
a((dp5705
g2
(lp5706
VThat question was nicely answered in this one: http://stackoverflow
p5707
aVcom/questions/318398/why-does-c-compilation-take-so-long#318440 (as jalf pointed out in the comments section)
p5708
aVBasically it's the missing modules concept of C++, and the aggressive optimization done by the compiler
p5709
as(dp5710
g15
V34509
p5711
stp5712
a((dp5713
g2
(lp5714
VI think Jon pretty much nailed it
p5715
aVshould be responsibility to ensure a valid Person is created it its constructor
p5716
aVAbout the resonsibility who creates or not creates the  object (whether the AddPerson method or its caller), read
p5717
aVhttp://en
p5718
aVwikipedia
p5719
aVorg/wiki/GRASP_%28Object_Oriented_Design%29#Creator
p5720
aVIt's about questions of responsibility in OOP
p5721
aVIn your specific case if the AddPerson wrapping the call to a DB interface, I'm not quite sure about it
p5722
aVIt depends what that Person object is used for outside that context
p5723
aVIf it's solely for the purpose of containing the data to be added to the Database, creating it in the AddPerson method possibly is a good idea, because it decouples the user of your class from having to know about the Person class
p5724
as(dp5725
g15
V34509
p5726
stp5727
a((dp5728
g2
(lp5729
VAs you said in the comments, you got a binary string and you want to convert it into integers
p5730
aVUse bitset for that:
p5731
aVIf you only have one binary number in that string , you can get away with
p5732
aVConverting that in C is also possible
p5733
aVcan't parse binary numbers
p5734
aVBut  can parse them if you tell it the right base
p5735
as(dp5736
g15
V34509
p5737
stp5738
a((dp5739
g2
(lp5740
VYeah it will work well
p5741
aVThat said, in any case, you really should put another entry in your enumeration defining the value of the amount of items:
p5742
aVThen you can define the array like
p5743
aVotherwise, it's a mess to keep the amount of states synchronous with the size of the array
p5744
aVEnumerations will always start with zero if not otherwise initialized, and then each additional entry will be assigned a value one above the previous one, if not otherwise initialized
p5745
aVOf course it also wouldn't hurt if you put a zero explicitly if you want
p5746
aVIf you don't mind additional code, i would wrap the access to the raw array using a function like
p5747
aVOr an equivalent  function forwarding the request
p5748
aVThat would forbid directly indexing the array with some integer, which would almost certainly at some point fail because one gets the indexes wrong
p5749
as(dp5750
g15
V34509
p5751
stp5752
a((dp5753
g2
(lp5754
VIf you know the size at compile time, this will do it:
p5755
aVDoing it with
p5756
aVWill actually pass a pointer to the first sub-array of the two dimensional array ("board_width" is completely ignored, as with the degenerate case of having only one dimension when you have  accepting a pointer), which is probably not what you want (because you explicitly asked for a reference)
p5757
aVThus, doing it with the reference, using sizeof on the parameter  will yield  (as if you would do it on the argument itself) while doing it with the second method (declaring the parameter as array, thus making the compiler transform it to a pointer) will yield , thus merely the sizeof of a pointer
p5758
as(dp5759
g15
V34509
p5760
stp5761
a((dp5762
g2
(lp5763
VYes, the lifetime of the container member will last as long as the object that contains it exists, which is until you call  on the pointer pointing to it ( in your case)
p5764
aVNo, there is no reason to do that
p5765
aVMaking it a pointer requires you to create a dynamic object of  which you would need to manage the lifetime of (including calling delete on the container pointer)
p5766
aVThat's unnecessary here
p5767
aVAssuming you want the container last as long as the Foo object, you are fine with having it directly contained, without doing it with a pointer
p5768
aVPassing the  pointer will just pass the pointer
p5769
aVThe object that it points to will not be copied, only the pointer pointing to it if necassary
p5770
aVIf you know Java, then it helps you if i tell you passing the pointer is the same as just passing a reference to an object in Java, say:
p5771
as(dp5772
g15
V34509
p5773
stp5774
a((dp5775
g2
(lp5776
VI would do it like this possibly:
p5777
aVIf the comment documents some code that appears between other code blocks, and i want to really make clear where the comment refers to, occasionally i catch me writing blocks around the stuff
p5778
aVSometimes the block needs its own set of local variables to accomplish the task, and then the block also serves to reduce the scope of them to the place where they are needed
p5779
aVArguably, such code should be put into their own respective function, but it occasionally happens doing that will decrease code quality
p5780
aVNow, for commenting methods, i generally only comment them in their header file, and do it by something like this:
p5781
aVFor uncommenting ranges of code, i explicitly do not use those comments, as i reserve them only to document code
p5782
aVI gonna use
p5783
aVAnd it also will save me from having some stuff that is not valid C++ code (stuff in between those delimiters still have to contain valid tokens)
p5784
aVI'm not sure how the matter is in C# about it, though
p5785
as(dp5786
g15
V34509
p5787
stp5788
a((dp5789
g2
(lp5790
VThe C++ Standard says that casting a (pods) struct's pointer to a pointer of the type of its first element will yield a pointer to its first element:
p5791
aVI suspect that code told the compiler not to add any padding between a1, a2 and a3, so that if it indexes the pointer, it will pointer exactly to the float it wants
p5792
aVSo above
p5793
aVThat's platform dependent, as padding can't be changed in Standard C++
p5794
aVLookup how that code arranges it, and whether i'm right at all :)
p5795
as(dp5796
g15
V34509
p5797
stp5798
a((dp5799
g2
(lp5800
VWell, it's not possible
p5801
aVNo way to make it call  each time again
p5802
aVBut you can use boost, of course:
p5803
aVIt does create its own functor, but it happens behind the scene :)
p5804
as(dp5805
g15
V34509
p5806
stp5807
a((dp5808
g2
(lp5809
VI'm not an expert for scheduling schemes, but have a look at
p5810
aVit details what the difference between the different scheduling algorithms are, and provide links to other scheduling functions
p5811
aVSCHED_FIFO actually sounds pretty dangerous, but is described as the most aggressive scheduling:
p5812
aVA  SCHED_FIFO  process  runs  until  either it is blocked by an I/O request, it is preempted by a higher priority process, or it calls sched_yield(2)
p5813
aVBeware not to lock up your system
p5814
aVI would personally do some empirical tests to see what priority fits the best and how they behave exactly
p5815
as(dp5816
g15
V34509
p5817
stp5818
a((dp5819
g2
(lp5820
VI wrote that stuff last hours, and added it to my collection of useful stuff
p5821
aVThe most difficult thing is to cope with the factory function, if the types you want to create are not related in any way
p5822
aVI used a  for this
p5823
aVYou have to give it a set of types you ever want to use
p5824
aVThen it will keep track what is the current "active" type in the variant
p5825
aV(boost::variant is a so-called discriminated union)
p5826
aVThe second problem is how you store your function pointers
p5827
aVThe problem is that a pointer to a member of  can't be stored to a pointer to a member of
p5828
aVThose types are incompatible
p5829
aVTo solve this, i store the function pointers in an object that overloads its  and takes a boost::variant:
p5830
aVOf course, all your types' functions have to have the same return type
p5831
aVOtherwise the whole game would only make little sense
p5832
aVNow the code:
p5833
aVIt uses pretty fun techniques from boost preprocessor, function types and bind library
p5834
aVMight loop complicated, but if you get the keys in that code, it's not much to grasp anymore
p5835
aVIf you want to change the parameter count, you just have to tweak variant_call_type:
p5836
aVNow you can call member functions that take an int
p5837
aVHere is how the call side would look:
p5838
aVHave fun
p5839
aVIf you now say the above is too complicated, i have to agree with you
p5840
aVIt is complicated because C++ is not really made for such dynamic use
p5841
aVIf you can have your methods grouped and implemented in each object you want create, you can use pure virtual functions
p5842
aVAlternatively, you could throw some exception (like std::runtime_error) in the default implementation, so derived classes do not need to implement everything:
p5843
aVFor creating objects, a usual factory will do
p5844
aVThe map could be composed by a map mapping IDs to a pair of class and function name (the same like above), and a map mapping that to a boost::function:
p5845
aVCalling the function would work like this:
p5846
aVOf course, with this approach, you loose flexibility and (possibly, haven't profiled) efficiency, but you greatly simplify your design
p5847
as(dp5848
g15
V34509
p5849
stp5850
a((dp5851
g2
(lp5852
VIf you really want to have new classes derived from Exception, as opposed to having a template parameterized by a parameter, there is no way around writing your own constructor that just delegates the arguments without using a macro
p5853
aVC++0x will have the ability what you need by using something like
p5854
aVYou can read about the details of that (seem to have quite a bit of extra rules) in 12
p5855
aV9 "Inheriting Constructors" in the latest draft of C++0x
p5856
aVIn the meantime, i would recommend a policy based design (made small text, because the OP accepted the above, and not this policy stuff):
p5857
as(dp5858
g15
V34509
p5859
stp5860
a((dp5861
g2
(lp5862
VThe following awk script should do it (not tested though):
p5863
aVThe key is that  returns the amount of seconds since 1970, and  specifies an alternative time/date, instead of
p5864
as(dp5865
g15
V34509
p5866
stp5867
a((dp5868
g2
(lp5869
VIt is certainly Standard Behavior
p5870
aVIf the derived class's operator new was used, its operator delete will also be used (also note even though you do not explicitly tell the compiler those functions are static, they are implicitly declared so)
p5871
aVThere might be the naughty case where you have an operator new in the derived class, but the corresponding operator delete is in the base class
p5872
aVI think that's valid, but i would avoid that
p5873
aVRelying on the base operator delete, while defining ones own operator new in the derived class will inevitable cause trouble
p5874
aVIf I don't define ANY destructors then I get what I expected to happen:
p5875
aVYou will get undefined behavior :) Everything can happen, including something you would expect (wrongly)
p5876
aVDeleting through a base pointer that points to an object of another type requires a virtual destructor
p5877
aVThe implicitly declared destructor is not virtual
p5878
aVWhen should I be using void operator delete( void *, size_t );
p5879
aVIf you want to have the size that was allocated known in the operator delete
p5880
aVI wrote about what it means here:
p5881
aVhttp://stackoverflow
p5882
aVcom/questions/377178/how-does-the-standard-new-operator-work-in-c#390585
p5883
aVIf you use (from within your overloaded member operator delete/new) the global operator new & delete to get your memory and release it, or even malloc / free, you don't need that size information
p5884
aVBut it could be useful for logging purposes
p5885
as(dp5886
g15
V34509
p5887
stp5888
a((dp5889
g2
(lp5890
VTake the filenames of all the files before the run, but include their timestamps:
p5891
aVIf you haven't got that find option available, you can use stat for that job too:
p5892
aVAnd after the run to
p5893
aVThen use
p5894
aVAnd it will show you the lines unique to , which must be new files if i'm not mistaken
p5895
aVIf they existed before, their modification time will have changed, which is taken care by the  thingy (printing out the number of seconds since 1970):
p5896
aV[js@HOST2 cpp]$ find -printf '%p %T@\u005cn' | sort > file1
p5897
aV[js@HOST2 cpp]$ echo foo>bar
p5898
aV[js@HOST2 cpp]$ echo foo>baz
p5899
aV[js@HOST2 cpp]$ find -printf '%p %T@\u005cn' | sort > file2
p5900
aV[js@HOST2 cpp]$ comm -1 -3 file1 file2
p5901
aV1230947309
p5902
aV0000000000
p5903
aV/bar 1230947308
p5904
aV0000000000
p5905
aV/baz 1230947309
p5906
aV0000000000
p5907
aV/file2 1230947315
p5908
aV0000000000
p5909
aV[js@HOST2 cpp]$ find -printf '%p %T@\u005cn' | sort > file1
p5910
aV[js@HOST2 cpp]$ echo lol>bar
p5911
aV[js@HOST2 cpp]$ find -printf '%p %T@\u005cn' | sort > file2
p5912
aV[js@HOST2 cpp]$ comm -1 -3 file1 file2
p5913
aV/bar 1230947359
p5914
aV0000000000
p5915
aV/file2 1230947362
p5916
aV0000000000
p5917
aV[js@HOST2 cpp]$`
p5918
as(dp5919
g15
V34509
p5920
stp5921
a((dp5922
g2
(lp5923
VPut the  inside the implementation of yet another virtual method:
p5924
aVPut A and B like this:
p5925
aVAnd change your if to
p5926
aVAs another one said, that's exactly the point of dynamic dispatch
p5927
aVBeside being more terse, it also will never "forget" to handle a type
p5928
aVDoing your switch, you could silently not handle a particular type, because you missed updating the code at that place when you introduced a new implementation
p5929
aVAlso remember having a virtual destructor in ABC
p5930
as(dp5931
g15
V34509
p5932
stp5933
a((dp5934
g2
(lp5935
Vhttp://awk
p5936
aVfreeshell
p5937
aVorg/RangeOfFields
p5938
aVContains a description how to do it
p5939
aVIt also links to http://student
p5940
aVnorthpark
p5941
aVedu/pemente/awk/awktail
p5942
aVtxt which contains 3 solutions to the problem
p5943
aVAs far as i know, if you assign to a field, then the output field separator is used to concatenate all fields together
p5944
aVSo  suddendly is collapsed to one space
p5945
aVTake it with a grain of salt though, i'm no awk expert
p5946
aVFor example, try assigning  to the variable , and colons instead of spaces will result in between fields in the output:
p5947
aVIf you use gawk, then you can use its  extension which i find pretty straight forward to use:
p5948
as(dp5949
g15
V34509
p5950
stp5951
a((dp5952
g2
(lp5953
VRead calling code stored in the heap from vc++
p5954
aVOn posix,  seems to be appropriate (look into ):
p5955
aVHowever, it says:
p5956
aVWhether  PROT_EXEC  has  any  effect  different  from PROT_READ is architecture- and kernel version-dependent
p5957
aVOn some hardware architectures (e
p5958
ag774
aV, i386), PROT_WRITE implies PROT_READ
p5959
aVSo better, first check whether on your operation system, that works
p5960
as(dp5961
g15
V34509
p5962
stp5963
a((dp5964
g2
(lp5965
VThe following is of course all not quite precise
p5966
aVTake it with a grain of salt when you read it :)
p5967
aVWell, the three things you refer to are automatic, static and dynamic storage duration, which has something to do with how long objects live and when they begin life
p5968
aVYou use automatic storage duration for short lived and small data, that is needed only locally within some block:
p5969
aVThe lifetime ends as soon as we exit the block, and it starts as soon as the object is defined
p5970
aVThey are the most simple kind of storage duration, and are way faster than in particular dynamic storage duration
p5971
aVYou use static storage duration for free variables, which might be accessed by any code all times, if their scope allows such usage (namespace scope), and for local variables that need extend their lifetime across exit of their scope (local scope), and for member variables that need to be shared by all objects of their class (classs scope)
p5972
aVTheir lifetime depends on the scope they are in
p5973
aVThey can have namespace scope and local scope and class scope
p5974
aVWhat is true about both of them is, once their life begins, lifetime ends at the end of the program
p5975
aVHere are two examples:
p5976
aVThe program prints , because  is not destroyed upon exit of its block
p5977
aVYou can say that objects that have local scope begin lifetime when control reaches their definition
p5978
aVFor , it happens when the function's body is entered
p5979
aVFor objects in namespace scope, lifetime begins at program startup
p5980
aVThe same is true for static objects of class scope:
p5981
aVAs you see,  is not bound to particular objects of its class, but to the class itself
p5982
aVThe address of all three names above is the same, and all denote the same object
p5983
aVThere are special rule about when and how static objects are initialized, but let's not concern about that now
p5984
aVThat's meant by the term static initialization order fiasco
p5985
aVThe last storage duration is dynamic
p5986
aVYou use it if you want to have objects live on another isle, and you want to put pointers around that reference them
p5987
aVYou also use them if your objects are big, and if you want to create arrays of size only known at runtime
p5988
aVBecause of this flexibility, objects having dynamic storage duration are complicated and slow to manage
p5989
aVObjects having that dynamic duration begin lifetime when an appropriate new operator invocation happens:
p5990
aVIts lifetime ends only when you call delete for them
p5991
aVIf you forget that, those objects never end lifetime
p5992
aVAnd class objects that define a user declared constructor won't have their destructors called
p5993
aVObjects having dynamic storage duration requires manual handling of their lifetime and associated memory resource
p5994
aVLibraries exist to ease use of them
p5995
aVExplicit garbage collection for particular objects can be established by using a smart pointer:
p5996
aVYou don't have to care about calling delete: The shared ptr does it for you, if the last pointer that references the object goes out of scope
p5997
aVThe shared ptr itself has automatic storage duration
p5998
aVSo its lifetime is automatically managed, allowing it to check whether it should delete the pointed to dynamic object in its destructor
p5999
aVFor shared_ptr reference, see boost documents: http://www
p6000
aVboost
p6001
aVorg/doc/libs/1_37_0/libs/smart_ptr/shared_ptr
p6002
aVhtm
p6003
as(dp6004
g15
V34509
p6005
stp6006
a((dp6007
g2
(lp6008
VI remember someone saying if you create a class through a lib you should destroy it through the lib
p6009
aVThat means if you call a function in a lib to create an object for you, you should read the documentation of that function, which must say how you free that object again
p6010
aVOften the function for free something is named similar to the allocation function
p6011
aVFor example, the library  has two functions called  and
p6012
aVThe reason is, because the library allocates in a way opaque to you (which is the reason you use the function in the first place)
p6013
aVIt could get memory from the data-section of the program, while you would (wrongly) assume it got the memory possibly from the heap when using
p6014
aVIf you are that library writer, the same rules apply
p6015
aVMake sure that when one of your functions return a object allocated dynamically, you say how the caller has to handle it
p6016
aVIs the object encapsulated into a smart pointer
p6017
aVThen the smart pointer will take care of calling the appropriate deleter you designated
p6018
aVDo you return a raw pointer
p6019
aVYou should avoid that, because the caller has to keep track of the pointer, and the caller will have to pass the pointer into a function you document in your interface
p6020
aVThat's just another level of dependency you put on the burden of the user of your library, which smart pointers can elegantly rationalize away
p6021
aVDo you return an object by value, which by itself wraps an allocated resource
p6022
aVIf that is the case, overload the copy constructor, copy assignment operator and destructor of that object's class, which then manages the resource by either copying it properly or sharing it among all other instances of its object (see this answer)
p6023
aVYou should almost never overload the delete operator for your class unless you have also overloaded the new operator
p6024
aVOverloading the delete operator is not to be taking literally: It means you merely overload deallocation of the associated memory of an object
p6025
aVIt only makes sense if you are housing your own memory pool or want to log every allocation/deallocation of memory for your objects
p6026
as(dp6027
g15
V34509
p6028
stp6029
a((dp6030
g2
(lp6031
VIterating Backwards
p6032
aVSee this answer
p6033
aVIterating Forwards
p6034
aVThis is almost identical
p6035
aVJust change the iterators / swap decrement by increment
p6036
aVYou should prefer iterators
p6037
aVSome people tell you to use  as the index variable type
p6038
aVHowever, that is not portable
p6039
aVAlways use the  typedef of the container (While you could get away with only a conversion in the forward iterating case, it could actually go wrong all the way in the backward iterating case when using , in case  is wider than what is the typedef of ):
p6040
aVUsing std::vector
p6041
aVUsing iterators
p6042
aVImportant is, always use the prefix increment form for iterators whose definitions you don't know
p6043
aVThat will ensure your code runs as generic as possible
p6044
aVUsing indices
p6045
aVUsing arrays
p6046
aVUsing iterators
p6047
aVUsing indices
p6048
aVRead in the backward iterating answer what problem the  approach can yield to, though
p6049
as(dp6050
g15
V34509
p6051
stp6052
a((dp6053
g2
(lp6054
VIt's a duplicate: design by contract tests by assert or by exception
p6055
aVYou'll find good answers there
p6056
aVCan't come up with a nicer way to explain it than Dima in there
p6057
as(dp6058
g15
V34509
p6059
stp6060
a((dp6061
g2
(lp6062
Vtuples
p6063
aVI think i agree with you that the issue with what position corresponds to what variable can introduce confusion
p6064
aVBut i think there are two sides
p6065
aVOne is the call-side and the other is the callee-side:
p6066
aVI think it's crystal clear what we got, but it can become confusing if you have to return more values at once
p6067
aVOnce the caller's programmer has looked up the documentation of , he will know what position is what, and can write effective code
p6068
aVAs a rule of thumb, i would say not to return more than 4 values at once
p6069
aVFor anything beyond, prefer a struct
p6070
aVoutput parameters
p6071
aVOutput parameters can be used too, of course:
p6072
aVNow i think that illustrates how tuples are better than output parameters
p6073
aVWe have mixed the input of  with its output, while not gaining any advantage
p6074
aVWorse, we leave the reader of that code in doubt on what could be the actual return value of  be
p6075
aVThere are wonderful examples when output parameters are useful
p6076
aVIn my opinion, you should use them only when you've got no other way, because the return value is already taken and can't be changed to either a tuple or struct
p6077
aVis a good example on where you use output parameters, because the return value is already reserved for the stream, so you can chain  calls
p6078
aVIf you've not to do with operators, and the context is not crystal clear, i recommend you to use pointers, to signal at the call side that the object is actually used as an output parameter, in addition to comments where appropriate
p6079
aVreturning a struct
p6080
aVThe third option is to use a struct:
p6081
aVI think that definitely wins the award for clearness
p6082
aVBut note you have still to access the result within that struct, and the result is not "laid bare" on the table, as it was the case for the output parameters and the tuple used with
p6083
aVI think a major point these days is to make everything as generic as possible
p6084
aVSo, say you have got a function that can print out tuples
p6085
aVYou can just do
p6086
aVAnd have your result displayed
p6087
aVI think that tuples, on the other side, clearly win for their versatile nature
p6088
aVDoing that with div_result, you need to overload operator<<, or need to output each member separately
p6089
as(dp6090
g15
V34509
p6091
stp6092
a((dp6093
g2
(lp6094
VI think much confusion is generated by not communicating what is meant by passed by reference
p6095
aVWhen some people say pass by reference they usually mean not the argument itself, but rather the object being referenced
p6096
aVSome other say that pass by reference means that the object can't be changed in the callee
p6097
aVExample:
p6098
aVSome people would claim that 1 and 3 are pass by reference, while 2 would be pass by value
p6099
aVAnother group of people say all but the last is pass by reference, because the object itself is not copied
p6100
aVI would like to draw a definition of that here what i claim to be pass by reference
p6101
aVA general overview over it can be found here: Difference between pass by reference and pass by value
p6102
aVAll but the first and last are pass by reference:
p6103
aVI vote for the following definition:
p6104
aVAn argument (1
p6105
ag1037
aV1) is passed by reference if and only if the corresponding parameter of the function that's called has reference type and the reference parameter binds directly to the argument expression (8
p6106
ag1014
aV3/4)
p6107
aVIn all other cases, we have to do with pass by value
p6108
aVThat means that the following is pass by value:
p6109
aVis pass by value, because it's not directly bound
p6110
aVThe implementation may copy the temporary and then bind that temporary to the reference
p6111
aVis pass by value, because the implementation initializes a temporary of the literal and then binds to the reference
p6112
aVis pass by value, because the parameter has not reference type
p6113
aVis pass by value for the same reason
p6114
aVis pass by value because the parameter has not got reference type
p6115
aVThe following cases are pass by reference (by the rules of 8
p6116
ag1014
aV3/4 and others):
p6117
as(dp6118
g15
V34509
p6119
stp6120
a((dp6121
g2
(lp6122
VI think sscanf could be appropriate:
p6123
aVOutput:
p6124
as(dp6125
g15
V34509
p6126
stp6127
a((dp6128
g2
(lp6129
VI don't understand quite what you want
p6130
aVDo you want to incrementally process the file, reading one line from it, then abandon it and process the next
p6131
aVOr do you want to read the entire file into a buffer
p6132
aVIf you want the latter, I think this is appropriate (check for NULL return for malloc and fopen in real code for whether the file exist and whether you got enough memory):
p6133
as(dp6134
g15
V34509
p6135
stp6136
a((dp6137
g2
(lp6138
VYou have two possibilities:
p6139
aVMake use of compiler/linker extensions to convert a file into a binary file, with proper symbols pointing to the begin and end of the binary data
p6140
aVSee this answer: Include binary file with GNU ld linker script
p6141
aVConvert your file into a sequence of character constants that can initialize an array
p6142
aVNote you can't just do "" and span multiple lines
p6143
aVYou would need a line continuation character (), escape  characters and others to make that work
p6144
aVEasier to just write a little program to convert the bytes into a sequence like  (or use the unix tool  described by another answer, if you have it available
p6145
ag1240
aVCode:
p6146
aV(not tested)
p6147
aVThen do:
p6148
aVWhere data
p6149
aVh is generated by
p6150
as(dp6151
g15
V34509
p6152
stp6153
a((dp6154
g2
(lp6155
VThere is a way, but it includes that you repeat your specialization for each and every number of arguments and const/volatile modifiers for those member functions
p6156
aVAn easier way to do that is to use  which does that for you:
p6157
aVGrab it from here
p6158
as(dp6159
g15
V34509
p6160
stp6161
a((dp6162
g2
(lp6163
VNothing is as fast as bash & bc:
p6164
as(dp6165
g15
V34509
p6166
stp6167
a((dp6168
g2
(lp6169
VPitfalls in decreasing order of their importance
p6170
aVFirst of all, you should visit the award winning C++ FAQ Light
p6171
aVIt has many good answers to pitfalls
p6172
aVIf you have further questions, visit  on  in IRC
p6173
aVWe are glad to help you, if we can
p6174
aVNote all the following pitfalls are originally written
p6175
aVThey are not just copied from random sources
p6176
aVdelete on new,  on
p6177
aVSolution: Doing the above yields to undefined behavior: Everything could happen
p6178
aVUnderstand your code and what it does, and always  what you , and  what you , then that won't happen
p6179
aVException:
p6180
aVYou need to  even though you , since you new'ed an array
p6181
aVSo if you are working with , take special care
p6182
aVCalling a virtual function in a constructor or destructor
p6183
aVSolution: Calling a virtual function won't call the overriding functions in the derived classes
p6184
aVCalling a pure virtual function in a constructor or desctructor is undefined behavior
p6185
aVCalling  or  on an already deleted pointer
p6186
aVSolution: Assign 0 to every pointer you delete
p6187
aVCalling  or  on a null-pointer does nothing
p6188
aVTaking the sizeof of a pointer, when the number of elements of an 'array' is to be calculated
p6189
aVSolution: Pass the number of elements alongside the pointer when you need to pass an array as a pointer into a function
p6190
aVUse the function proposed here if you take the sizeof of an array that is supposed to be really an array
p6191
aVUsing an array as if it were a pointer
p6192
aVThus, using  for a two dimentional array
p6193
aVSolution: See here for why they are different and how you handle them
p6194
aVWriting to a string literal:
p6195
aVSolution: Allocate an array that is initialized from the data of the string literal, then you can write to it:
p6196
aVWriting to a string literal is undefined behavior
p6197
aVAnyway, the above conversion from a string literal to  is deprecated
p6198
aVSo compilers will probably warn if you increase the warning level
p6199
aVCreating resources, then forgetting to free them when something throws
p6200
aVSolution: Use smart pointers like  or  as pointed out by other answers
p6201
aVModifying an object twice like in this example:
p6202
aVSolution: The above was supposed to assign to  the value of
p6203
aVBut what it does is not defined
p6204
aVInstead of incrementing  and assigning the result, it changes  on the right side as well
p6205
aVChanging an object between two sequence points is undefined behavior
p6206
aVSequence points include , , ,  and  (non exhaustive list
p6207
aVChange the code to the following to make it behave correctly:
p6208
aVMisc Issues
p6209
aVForgetting to flush streams before calling a blocking function like
p6210
aVSolution: Flush the stream by streaming either  instead of  or by calling
p6211
aVDeclaring a function instead of a variable
p6212
aVSolution: The issue arises because the compiler interprets for example
p6213
aVas a function declaration of a function  returning  and having a parameter of type  which is called
p6214
aVYou solve it by putting parentheses around the first argument
p6215
aVNow you get a variable  of type :
p6216
aVCalling the function of a free object that is only declared in the current translation unit ( file)
p6217
aVSolution: The standard doesn't define the order of creation of free objects (at namespace scope) defined across different translation units
p6218
aVCalling a member function on an object not yet constructed is undefined behavior
p6219
aVYou can define the following function in the object's translation unit instead and call it from other ones:
p6220
aVThat would create the object on demand and leave you with a fully constructed object at the time you call functions on it
p6221
aVDefining a template in a  file, while it's used in a different  file
p6222
aVSolution: Almost always you will get errors like
p6223
aVPut all the template definitions in a header, so that when the compiler is using them, it can already produce the code needed
p6224
aVif base is a pointer to a virtual base class of
p6225
aVSolution: A virtual base class is a base which occurs only once, even if it is inherited more than once by different classes indirectly in an inheritance tree
p6226
aVDoing the above is not allowed by the Standard
p6227
aVUse dynamic_cast to do that, and make sure your base class is polymorphic
p6228
aVif base is non-polymorphic
p6229
aVSolution: The standard doesn't allow a downcast of a pointer or reference when the object passed is not polymorphic
p6230
aVIt or one of its base classes has to have a virtual function
p6231
aVMaking your function accept
p6232
aVSolution: You might think that's safer than using , but actually it will cause headache to people that want to pass : The standard doesn't allow it
p6233
aVIt gives a neat example of why it is disallowed:
p6234
aVAlways accept  instead
p6235
aVAnother (closed) pitfalls thread about C++, so people looking for them will find them, is Stack Overflow question C++ pitfalls
p6236
as(dp6237
g15
V34509
p6238
stp6239
a((dp6240
g2
(lp6241
VC++
p6242
aVBash
p6243
aVGnu Awk
p6244
aVHaskell
p6245
aVSome brain dead way doing it in Haskell
p6246
aVPlain English
p6247
as(dp6248
g15
V34509
p6249
stp6250
a((dp6251
g2
(lp6252
VBecause i feel it's really called for, i just want to state some rules of C and C++ (they are the same in this regard)
p6253
aVFirst, all bits of  participate in determining the value if any unsigned char object
p6254
aVSecond,  is explicitly stated unsigned
p6255
aVNow, i had a discussion with someone about what happens when you convert the value  of type int to
p6256
aVHe refused the idea that the resulting  has all its bits set to 1, because he was worried about sign representation
p6257
aVBut he don't have to
p6258
aVIt's immediately following out of this rule that the conversion does what is intended:
p6259
aVIf the new type is unsigned, the value is converted by repeatedly adding or
p6260
aVsubtracting one more than the maximum value that can be represented in the new type
p6261
aVuntil the value is in the range of the new type
p6262
aV( in a C99 draft)
p6263
aVThat's a mathematical description
p6264
aVC++ describes it in terms of modulo calculus, which yields to the same rule
p6265
aVAnyway, what is not guaranteed is that all bits in the integer  are one before the conversion
p6266
aVSo, what do we have so we can claim that the resulting  has all its  bits turned to 1
p6267
aVAll bits participate in determining its value - that is, no padding bits occur in the object
p6268
aVAdding only one time  to  will yield a value in range, namely
p6269
aVThat's enough, actually
p6270
aVSo whenever you want to have an  having all its bits one, you do
p6271
aVIt also follows that a conversion is not just truncating higher order bits
p6272
aVThe fortunate event for two's complement is that it is just a truncation there, but the same isn't necessarily true for other sign representations
p6273
as(dp6274
g15
V34509
p6275
stp6276
a((dp6277
g2
(lp6278
VA quite hidden feature is that you can define variables within an if condition, and its scope will span only over the if, and its else blocks:
p6279
aVSome macros use that, for example to provide some "locked" scope like this:
p6280
aVAlso BOOST_FOREACH uses it under the hood
p6281
aVTo complete this, it's not only possible in an if, but also in a switch:
p6282
aVand in a while loop:
p6283
aV(and also in a for condition)
p6284
aVBut i'm not too sure whether these are all that useful :)
p6285
as(dp6286
g15
V34509
p6287
stp6288
a((dp6289
g2
(lp6290
VI try and keep my lines below 80 columns
p6291
aVThe strongest reason is that i often find myself using  and  to browse my code when working at the command-line
p6292
aVI really don't like how terminals are breaking long source lines (they after all aren't made for that job)
p6293
aVAnother reason is that i find it looks better if everything fits into the line and isn't broken by the editor
p6294
aVFor example having parameters of long function calls nicely aligned below each other and similar stuff
p6295
as(dp6296
g15
V34509
p6297
stp6298
a((dp6299
g2
(lp6300
VFollowing paercebal's construct using variable length arrays to get around the limitation that functions can't return constant expressions yet, here is a way to do just that, in a certain other way:
p6301
aVI've written it in some of my other answers, but it doesn't fit anywhere better than into this thread
p6302
aVNow, well, here is how one could use it:
p6303
aVAdvantage over sizeof
p6304
aVFails for non-arrays
p6305
aVWill not silently work for pointers
p6306
aVWill tell in the code that the array-size is taken
p6307
as(dp6308
g15
V34509
p6309
stp6310
a((dp6311
g2
(lp6312
VDon't take it serious :)
p6313
as(dp6314
g15
V34509
p6315
stp6316
a((dp6317
g2
(lp6318
VI made this community wiki
p6319
aVPlease edit it
p6320
aVI don't agree with the advice against "int" anymore
p6321
aVI now see it as not bad
p6322
aVYes, i agree with Richard
p6323
aVYou should never use  as the counting variable in a loop like those
p6324
aVThe following is how you might want to do various loops using indices (althought there is little reason to, occasionally this can be useful)
p6325
aVForward
p6326
aVBackward
p6327
aVYou can do this, which is perfectly defined behaivor:
p6328
aVSoon, with c++1x (next C++ version) coming along nicely, you can do it like this:
p6329
aVDecrementing below 0 will cause i to wrap around, because it is unsigned
p6330
aVBut unsigned will make bugs slurp in
p6331
aVThat should never be an argument to make it the wrong way (using )
p6332
aVWhy not use std::size_t above
p6333
aVThe C++ Standard defines in , that  , for  being some , that this type is some implementation defined unsigned integral type
p6334
aVNow, using  for  above will let bugs slurp in silently
p6335
aVIf  is less or greater than , then it will overflow , or not even get up to  if
p6336
aVLikewise, the condition of the loop would have been broken completely
p6337
as(dp6338
g15
V34509
p6339
stp6340
a((dp6341
g2
(lp6342
VIt's useful to put function names on a new line, so you can grep like
p6343
aVfor them
p6344
aVI've seen that style used for a loads of GNU projects and like it:
p6345
as(dp6346
g15
V34509
p6347
stp6348
a((dp6349
g2
(lp6350
Vstring array -> int array
p6351
aVLoop over the string array, and convert each string successively into the corresponging integer using
p6352
aVIf you have many values, the constant recreation of the stringstream can introduce substantial overhead
p6353
aVYou can take it out of the loop
p6354
aVchar array -> int array
p6355
aVIf you want to convert a char array  into an int array , you can do it like this:
p6356
aVThe cast to  makes the values of the int array positive (useful if you want to convert extended 8 bit characters which will be represented in a signed 8bit char type as a negative number and would otherwise be negative integers too)
p6357
aVIf you don't want this behaivor, you can just omit that cast safely
p6358
as(dp6359
g15
V34509
p6360
stp6361
a((dp6362
g2
(lp6363
VYeah i think mipadi is right
p6364
aVthe do notation translates into >>= and return calls to the list monad
p6365
aVWill get the list that is returned by  and for the seq and states, ln will be a string of that list each time
p6366
aVSo actually with ln
p6367
aV0, you get the first character of that string
p6368
aVBut a list is required at the right side of the  there
p6369
aVThat's just about all what i remember
p6370
aVHas been quite a bit of time since i did those stuff with haskell :)
p6371
as(dp6372
g15
V34509
p6373
stp6374
a((dp6375
g2
(lp6376
Vi would make a line from the center to the point, and calc where that graph crosses the circle oO i think not so difficult
p6377
as(dp6378
g15
V34509
p6379
stp6380
a((dp6381
g2
(lp6382
VWe have done that by using NaN:
p6383
aVNaN values compared for equality against itself will yield false
p6384
aVThat's the way you test for NaN, but which seems to be only valid if  is true (if so, it conforms to ieee754 too)
p6385
aVIn C99 there is a macro called  for this in , which checks a floating point number for a NaN value too
p6386
as(dp6387
g15
V34509
p6388
stp6389
a((dp6390
g2
(lp6391
Vif you have a TCHAR array or a pointer to the begin of it, you can use  to work with it:
p6392
aVNow,  is the converted number
p6393
aVThis will work in ANSI mode (_TCHAR is typedef'ed to ) and in Unicode (_TCHAR is typedef`ed to wchar_t as you say) mode
p6394
as(dp6395
g15
V34509
p6396
stp6397
a((dp6398
g2
(lp6399
VIf you really can't use exceptions, you can also write a construction macro doing what onebyone proposed always
p6400
aVSo you don't get into the hassle of doing this creation/init/if cycle all the time and most important, you never forget to initialize an object
p6401
aVThe error_type struct will invert the condition, so that errors are checked in the  part of the if
p6402
aVNow write an init function that returns  on success, or any other value indicating the error code
p6403
aVYou can add other functions to , for example stuff that looks up what the code means
p6404
as(dp6405
g15
V34509
p6406
stp6407
a((dp6408
g2
(lp6409
VThe STL does not provide such an iterator
p6410
aVBut you could code it yourself (tested that code):
p6411
aVIt doesn't need any data by using itself as the result of
p6412
aVThe result of  is not used in the output iterator requirements, so we can give it a return type of
p6413
aVEdit: Let's go into how this  works
p6414
aVThe Standard says in 24
p6415
ag2790
aV2/1  about the requirements of an output iterator that in both these cases:
p6416
aVThat the result of those expressions is not used
p6417
aVThat's what makes this work:
p6418
aVNow we don't need to have any data that we return in : We just use the iterator itself
p6419
aVNote that the templated operator= does not overwrite the builtin copy assignment operator
p6420
aVIt's still provided
p6421
as(dp6422
g15
V34509
p6423
stp6424
a((dp6425
g2
(lp6426
VSure that is possible
p6427
aVThis is what GObject, the framework where all of gtk+ and gnome are based on, does
p6428
aVRead this: http://en
p6429
aVwikipedia
p6430
aVorg/wiki/GObject
p6431
as(dp6432
g15
V34509
p6433
stp6434
a((dp6435
g2
(lp6436
VExecutables have no extension in the unix world, because they are meant to be executed in the shell
p6437
aVImagine the following:
p6438
aVThat's ugly
p6439
aVUnix makes use of so-called magic bytes at the start of each file to detect the file-type
p6440
aVFor the default binary format, called ELF, there is a 4 byte word  at the start
p6441
aVThat's not possible for all file formats
p6442
aVConsider C code or Java code
p6443
aVThey can both start with comments, and can be made look exactly the same
p6444
aVSo you still have to use file-name extensions, and it's a good thing when used where it's appropriate
p6445
as(dp6446
g15
V34509
p6447
stp6448
a((dp6449
g2
(lp6450
VWell as another answerer pointed out already the reason why  is an lvalue is to pass it to a reference
p6451
aVThe reason for the second rule is to allow to initialize a reference using a literal, when the reference is a reference to const:
p6452
aVWhy do we introduce an rvalue at all you may ask
p6453
aVWell, these terms come up when building the language rules for these two situations:
p6454
aVWe want to have a locator value
p6455
aVThat will represent a location which contains a value that can be read
p6456
aVWe want to represent the value of an expression
p6457
aVThe above two points are taken from the C99 Standard which includes this nice footnote quite helpful:
p6458
aV[ The name \u2018\u2018lvalue\u2019\u2019 comes originally
p6459
aVfrom the assignment expression E1 =
p6460
aVE2, in which the left operand E1 is
p6461
aVrequired to be a (modi\ufb01able) lvalue
p6462
aVIt is perhaps better considered as
p6463
aVrepresenting an object \u2018\u2018locator
p6464
aVvalue\u2019\u2019
p6465
aVWhat is sometimes called
p6466
aV\u2018\u2018rvalue\u2019\u2019 is in this International
p6467
aVStandard described as the \u2018\u2018value of
p6468
aVan expression\u2019\u2019
p6469
ag4885
aVThe locator value is called lvalue, while the value resulting from evaluating that location is called rvalue
p6470
aVThat's right according also to the C++ Standard (talking about the lvalue-to-rvalue conversion):
p6471
ag2670
aV1/2: The value contained in the object
p6472
aVindicated by the lvalue is the rvalue
p6473
aVresult
p6474
aVConclusion
p6475
aVUsing the above semantics, it is clear now why  is no lvalue but an rvalue
p6476
aVBecause the expression returned is not located in  anymore (it's incremented
p6477
aV, it is just the value that can be of interest
p6478
aVModifying that value returned by  would make not sense, because we don't have a location from which we could read that value again
p6479
aVAnd so the Standard says it is an rvalue, and it thus can only bind to a reference-to-const
p6480
aVHowever, in constrast, the expression returned by  is the location (lvalue) of
p6481
aVProvoking an lvalue-to-rvalue conversion, like in  will read the value out of it
p6482
aVAlternatively, we can make a reference point to it, and read out the value later:
p6483
aVNote also the other occasions where rvalues are generated
p6484
aVFor example, all temporaries are rvalues, the result of binary/unary + and minus and all return value expressions that are not references
p6485
aVAll those expressions are not located in an named object, but carry rather values only
p6486
aVThose values can of course be backed up by objects that are not constant
p6487
aVThe next C++ Version will include so-called  that, even though they point to nonconst, can bind to an rvalue
p6488
aVThe rationale is to be able to "steal" away resources from those anonymous objects, and avoid copies doing that
p6489
aVAssuming a class-type that has overloaded prefix ++ (returning ) and postfix ++ (returning ), the following would cause a copy first, and for the second case it will steal the resources from the rvalue:
p6490
as(dp6491
g15
V34509
p6492
stp6493
a((dp6494
g2
(lp6495
VThat's invalid
p6496
aVThe syntax is
p6497
aVThe difference is that the conversion constructor cannot be used for implicit conversions when you put explicit before it:
p6498
aVThe above doesn't have anything to do with an assignment operator you declared there
p6499
aVIt is not used since that is an initialization (only constructors are used)
p6500
aVThe following will use the assignment operator:
p6501
aVAnd will use the default constructor of Foo (the one taking no arguments)
p6502
aVEdit: The questioner changed his question to the specific ways of whether
p6503
aVAre the same
p6504
aVThe answer is that they are equivalent to the following:
p6505
aVIf and only if the conversion constructor taking the int is not declared with keyword , otherwise the first is a compiler error (see above)
p6506
aVThe compiler is allowed to elide (optimize out) the temporary passed to the copy constructor of Foo in the first case if all semantic restrictions are still safisfied, and even if the copy constructor has side effects
p6507
aVThat especially includes a visible copy constructor
p6508
as(dp6509
g15
V34509
p6510
stp6511
a((dp6512
g2
(lp6513
VIt's a way how to pass arguments to functions
p6514
aVPassing by reference means the called functions' parameter will be the same as the callers' passed argument (not the value, but the identity - the variable itself)
p6515
aVPass by value means the called functions' parameter will be a copy of the callers' passed argument
p6516
aVThe value will be the same, but the identity - the variable - is different
p6517
aVThus changes to a parameter done by the called function in one case changes the argument passed and in the other case just changes the value of the parameter in the called function (which is only a copy)
p6518
aVIn a quick hurry:
p6519
aVJava only supports pass by value
p6520
aVAlways copies arguments, even though when copying a reference to an object, the parameter in the called function will point to the same object and changes to that object will be see in the caller
p6521
aVSince this can be confusing, here is what Jon Skeet has to say about this
p6522
aVC# supports pass by value and pass by reference (keyword  used at caller and called function)
p6523
aVJon Skeet also has a nice explanation of this here
p6524
aVC++ supports pass by value and pass by reference (reference parameter type used at called function)
p6525
aVYou will find an explanation of this below
p6526
aVCodes
p6527
aVSince my language is C++, i will use that here
p6528
aVAnd an example in Java won't hurt:
p6529
aVWikipedia
p6530
aVThis guy pretty much nails it:
p6531
aVhttp://javadude
p6532
aVcom/articles/passbyvalue
p6533
aVhtm
p6534
as(dp6535
g15
V34509
p6536
stp6537
a((dp6538
g2
(lp6539
VBeginner
p6540
aVIntroductory
p6541
aVIf you are new to programming or if you have experience in other languages and are new to C++, these books are highly recommended
p6542
aVC++ Primer * (Stanley Lippman, Jose Lajoie, and Barbara E
p6543
aVMoo)  (updated for C++11) Coming at 1k pages, this is a very thorough introduction into C++ that covers just about everything in the language in a very accessible format and in great detail
p6544
aVThe fifth edition (released August 16, 2012) covers C++11
p6545
aV[Review]
p6546
aVAccelerated C++ (Andrew Koenig and Barbara Moo)  This basically covers the same ground as the C++ Primer, but does so on a fourth of its space
p6547
aVThis is largely because it does not attempt to be an introduction to programming, but an introduction to C++ for people who've previously programmed in some other language
p6548
aVIt has a steeper learning curve, but, for those who can cope with this, it is a very compact introduction into the language
p6549
aV(Historically, it broke new ground by being the first beginner's book using a modern approach at teaching the language
p6550
aV[Review]
p6551
aVThinking in C++ (Bruce Eckel)  Two volumes; is a tutorial style free set of intro level books
p6552
aVDownloads: vol 1, vol 2
p6553
aVUnfortunately they\u2019re marred by a number of trivial errors (e
p6554
ag774
aVmaintaining that temporaries are automatically ), with no official errata list
p6555
aVA partial 3rd party errata list is available at (http://www
p6556
aVcomputersciencelab
p6557
aVcom/Eckel
p6558
aVhtm), but it\u2019s apparently not maintained
p6559
aVProgramming: Principles and Practice Using C++ (Bjarne Stroustrup) (updated for C++11/C++14) An introduction to programming using C++ by the creator of the language
p6560
aVA good read, that assumes no previous programming experience, but is not only for beginners
p6561
aV* Not to be confused with C++ Primer Plus (Stephen Prata), with a significantly less favorable review
p6562
aVBest practices
p6563
aVEffective C++ (Scott Meyers)  This was written with the aim of being the best second book C++ programmers should read, and it succeeded
p6564
aVEarlier editions were aimed at programmers coming from C, the third edition changes this and targets programmers coming from languages like Java
p6565
aVIt presents ~50 easy-to-remember rules of thumb along with their rationale in a very accessible (and enjoyable) style
p6566
aV[Review]
p6567
aVEffective STL (Scott Meyers)  This aims to do the same to the part of the standard library coming from the STL what Effective C++ did to the language as a whole: It presents rules of thumb along with their rationale
p6568
aV[Review]
p6569
aVIntermediate
p6570
aVMore Effective C++ (Scott Meyers) Even more rules of thumb than Effective C++
p6571
aVNot as important as the ones in the first book, but still good to know
p6572
aVExceptional C++ (Herb Sutter)  Presented as a set of puzzles, this has one of the best and thorough discussions of the proper resource management and exception safety in C++ through Resource Acquisition is Initialization (RAII) in addition to in-depth coverage of a variety of other topics including the pimpl idiom, name lookup, good class design, and the C++ memory model
p6573
aV[Review]
p6574
aVMore Exceptional C++ (Herb Sutter)  Covers additional exception safety topics not covered in Exceptional C++, in addition to discussion of effective object oriented programming in C++ and correct use of the STL
p6575
aV[Review]
p6576
aVExceptional C++ Style (Herb Sutter)  Discusses generic programming, optimization, and resource management; this book also has an excellent exposition of how to write modular code in C++ by using nonmember functions and the single responsibility principle
p6577
aV[Review]
p6578
aVC++ Coding Standards (Herb Sutter and Andrei Alexandrescu) "Coding standards" here doesn't mean "how many spaces should I indent my code
p6579
aVThis book contains 101 best practices, idioms, and common pitfalls that can help you to write correct, understandable, and efficient C++ code
p6580
aV[Review]
p6581
aVC++ Templates: The Complete Guide (David Vandevoorde and Nicolai M
p6582
aVJosuttis) This is the book about templates as they existed before C++11
p6583
aVIt covers everything from the very basics to some of the most advanced template metaprogramming and explains every detail of how templates work (both conceptually and at how they are implemented) and discusses many common pitfalls
p6584
aVHas excellent summaries of the One Definition Rule (ODR) and overload resolution in the appendices
p6585
aVA second edition is scheduled for 2015
p6586
aV[Review]
p6587
aVAdvanced
p6588
aVModern C++ Design (Andrei Alexandrescu)  A groundbreaking book on advanced generic programming techniques
p6589
aVIntroduces policy-based design, type lists, and fundamental generic programming idioms then explains how many useful design patterns (including small object allocators, functors, factories, visitors, and multimethods) can be implemented efficiently, modularly, and cleanly using generic programming
p6590
aV[Review]
p6591
aVC++ Template Metaprogramming (David Abrahams and Aleksey Gurtovoy)
p6592
aVC++ Concurrency In Action (Anthony Williams) A book covering C++11 concurrency support including the thread library, the atomics library, the C++ memory model, locks and mutexes, as well as issues of designing and debugging multithreaded applications
p6593
aVAdvanced C++ Metaprogramming (Davide Di Gennaro) A pre-C++11 manual of TMP techniques, focused more on practice than theory
p6594
aVThere are a ton of snippets in this book, some of which are made obsolete by typetraits, but the techniques, are nonetheless, useful to know
p6595
aVIf you can put up with the quirky formatting/editing, it is easier to read than Alexandrescu, and arguably, more rewarding
p6596
aVFor more experienced developers, there is a good chance that you may pick up something about a dark corner of C++ (a quirk) that usually only comes about through extensive experience
p6597
aVReference Style - All Levels
p6598
aVA Tour of C++ (Bjarne Stroustrup) The "tour" is a quick (about 180 pages and 14 chapters) tutorial overview of all of standard C++ (language and standard library, and using C++11) at a moderately high level for people who already know C++ or at least are experienced programmers
p6599
aVThis book is an extended version of the material that constitutes Chapters 2-5 of The C++ Programming Language, 4th edition
p6600
aVThe C++ Programming Language (Bjarne Stroustrup) (updated for C++11) The classic introduction to C++ by its creator
p6601
aVWritten to parallel the classic K&R;, this indeed reads very much alike it and covers just about everything from the core language to the standard library, to programming paradigms to the language's philosophy
p6602
aV(Thereby making the latest editions break the 1k page barrier
p6603
aV[Review] The fourth edition (released on May 19, 2013) covers C++11
p6604
aVC++ Standard Library Tutorial and Reference (Nicolai Josuttis) (updated for C++11) The introduction and reference for the C++ Standard Library
p6605
aVThe second edition (released on April 9, 2012) covers C++11
p6606
aV[Review]
p6607
aVThe C++ IO Streams and Locales (Angelika Langer and Klaus Kreft)  There's very little to say about this book except that, if you want to know anything about streams and locales, then this is the one place to find definitive answers
p6608
aV[Review]
p6609
aVC++11 References:
p6610
aVThe C++ Standard (INCITS/ISO/IEC 14882-2011) This, of course, is the final arbiter of all that is or isn't C++
p6611
aVBe aware, however, that it is intended purely as a reference for experienced users willing to devote considerable time and effort to its understanding
p6612
aVAs usual, the first release was quite expensive ($300+ US), but it has now been released in electronic form for $60US
p6613
aVOverview of the New C++ (C++11/14) (PDF only) (Scott Meyers) (updated for C++1y/C++14) These are the presentation materials (slides and some lecture notes) of a three-day training course offered by Scott Meyers, who's a highly respected author on C++
p6614
aVEven though the list of items is short, the quality is high
p6615
aVClassics / Older
p6616
aVNote: Some information contained within these books may not be up-to-date or no longer considered best practice
p6617
aVThe Design and Evolution of C++ (Bjarne Stroustrup)  If you want to know why the language is the way it is, this book is where you find answers
p6618
aVThis covers everything before the standardization of C++
p6619
aVRuminations on C++ - (Andrew Koenig and Barbara Moo) [Review]
p6620
aVAdvanced C++ Programming Styles and Idioms (James Coplien)  A predecessor of the pattern movement, it describes many C++-specific "idioms"
p6621
aVIt's certainly a very good book and still worth a read if you can spare the time, but quite old and not up-to-date with current C++
p6622
aVLarge Scale C++ Software Design (John Lakos)  Lakos explains techniques to manage very big C++ software projects
p6623
aVCertainly a good read, if it only was up to date
p6624
aVIt was written long before C++98, and misses on many features (e
p6625
ag774
aVnamespaces) important for large scale projects
p6626
aVIf you need to work in a big C++ software project, you might want to read it, although you need to take more than a grain of salt with it
p6627
aVThe first volume of a new edition is expected in 2015
p6628
aVInside the C++ Object Model (Stanley Lippman)  If you want to know how virtual member functions are commonly implemented and how base objects are commonly laid out in memory in a multi-inheritance scenario, and how all this affects performance, this is where you will find thorough discussions of such topics
p6629
as(dp6630
g15
V34509
p6631
stp6632
a((dp6633
g2
(lp6634
VI think the C and C++ language designers noticed there is no real use in forbidding it because
p6635
aVCompilers can warn about it if they want anyway
p6636
aVDisallowing it would add special cases to the language, and would remove a possible feature
p6637
aVThere isn't complexity involved in allowing it
p6638
aVC++ just says that an expression implicitly convertible to  is required
p6639
aVIn C, there are useful cases detailed by other answers
p6640
aVIn C++, they go one step further and allowed this one in addition:
p6641
aVWhich actually limits the scope of t to only the if and its bodies
p6642
as(dp6643
g15
V34509
p6644
stp6645
a((dp6646
g2
(lp6647
VRelease Mode means that you build your program because you want to release it out to the public
p6648
aVUsually, the compiler will try harder to make the executable smaller and faster
p6649
aVThis often means getting rid of symbol information needed get a backtrace of a crash and using a higher optimize level
p6650
aVThe latter makes compilation time slower, so it's not used when building in Debug Mode
p6651
as(dp6652
g15
V34509
p6653
stp6654
a((dp6655
g2
(lp6656
VWell, I can only speak of C++, because I'm a Java beginner totally
p6657
aVIn C++, compilers are free to disregard any language requirements placed by the Standard, as long as the observable behavior is as-if the compiler actually emulated all the rules that are placed by the Standard
p6658
aVObservable behavior is defined as any reads and writes to volatile data and calls to library functions
p6659
aVConsider this:
p6660
aVThe C++ compiler is allowed to optimize out that piece of code and just add the proper value to x that would result from that loop once, because the code behaves as-if the loop never happened, and no volatile data, nor library functions are involved that could cause side effects needed
p6661
aVNow consider volatile variables:
p6662
aVThe compiler is not allowed to do the same optimization anymore, because it can't prove that side effects caused by writing to  could not affect the observable behavior of the program
p6663
aVAfter all, x could be set to a memory cell watched by some hardware device that would trigger at every write
p6664
aVSpeaking of Java, I have tested your loop, and it happens that the GNU Java Compiler () takes in inordinate amount of time to finish your loop (it simply didn't finish and I killed it)
p6665
aVI enabled optimization flags (-O2) and it happened it printed out  immediately:
p6666
aVMaybe that observation could be helpful in this thread
p6667
aVWhy does it happen to be so fast for gcj
p6668
aVWell, one reason surely is that gcj compiles into machine code, and so it has no possibility to optimize that code based on runtime behavior of the code
p6669
aVIt takes all its strongness together and tries to optimize as much as it can at compile time
p6670
aVA virtual machine, however, can compile code Just in Time, as this output of java shows for this code:
p6671
aVOutput for :
p6672
aVAs we see, it JIT compiles the doIt function 2 times
p6673
aVBased on the observation of the first execution, it compiles it a second time
p6674
aVBut it happens to have the same size as bytecode two times, suggesting the loop is still in place
p6675
aVAs another programmer shows, execution time for certain dead loops even is increased for some cases for subsequently compiled code
p6676
aVHe reported a bug which can be read here, and is as of 24
p6677
aVOctober 2008
p6678
as(dp6679
g15
V34509
p6680
stp6681
a((dp6682
g2
(lp6683
V has to return a type
p6684
aVYou forget to put "int" as a return type (implicit int in C++ is banned)
p6685
aVHaving said that, i'm not sure what you mean by
p6686
aVwould, as it is defined in the parameter list, return an
p6687
aVHow is that supposed to store a name
p6688
aVIt will store an integer
p6689
aVOnce again, that said, you can't call that Function (pun intended) with that particular argument
p6690
aVLet's view your types:
p6691
aVContrary to what you said, NameList is not a pointer to an array of arrays
p6692
aVI feel i need to show you what that would be:
p6693
aVThat wouldn't make sense at all
p6694
aVSo what do you have
p6695
aVThat is what you got
p6696
aVAnd you pass  to a Function that wants a pointer to an
p6697
aVIt must fail already at the time you call  in
p6698
aVI've got no idea what you mean by  in that line in Function
p6699
aVBut if you want to print out the integers that are stored in the arrays pointed to (by pointers to their first element), you can do it like this (keeping your code as much as i can):
p6700
aVI keep preaching people asking questions the difference between a pointer and an array
p6701
aVIt's crucial to write correct code
p6702
aVI hope i could help
p6703
aVAt the end, just a little though about the difference between  and
p6704
aVThe first is an incomplete array type, while the second is a complete type (pointer to int):
p6705
aVs type now has a type different from int[], because you initialized the array which would have incomplete type, the array  become complete after defined
p6706
aVIt has type of
p6707
aVIn parameter lists, however, there exist a special rule, which will cause any array type (even complete ones
p6708
aVto be equivalent to a pointer to their first argument
p6709
aVThus:
p6710
aVThat's because you can't pass arrays by value
p6711
aVThe compiler abuses that to make array types equivalent to pointers to their first element
p6712
aVSame deal with functions:
p6713
aVBecause you can't pass functions by value (huh, doesn't even make sense at all to me), the compiler abuses it to make a function type in a parameter list equivalent to a pointer to that function type
p6714
as(dp6715
g15
V34509
p6716
stp6717
a((dp6718
g2
(lp6719
VYour factory is fine
p6720
aVI take it the  and so on were just example class names
p6721
aVYou can use templates, if the following condition is met:
p6722
aVWhen you know at compile time (i
p6723
aVe when you write code) that you want a specific type returned, then use a template
p6724
aVOtherwise, you can't
p6725
aVThat means in code, that you can do this:
p6726
aVHaving that in place, you can then use that like
p6727
aVBut that template-argument, the , can't be a variable that is set to a type at runtime
p6728
aVIn your example, you pass a string, which can of course be set at runtime
p6729
aVSo, when you read that you can use C++ Templates, then that recommendation is only conditionally true - then, when your decision, of which pen to create, is already done at compile time
p6730
aVIf that condition fits, then the template solution is the right thing to do
p6731
aVIt will not cost you anything at runtime, and will be exactly what you need
p6732
as(dp6733
g15
V34509
p6734
stp6735
a((dp6736
g2
(lp6737
VIt is because name lookup stops if it finds a name in one of your bases
p6738
aVIt won't look beyond in other bases
p6739
aVThe function in B shadows the function in A
p6740
aVYou have to re-declare the function of A in the scope of B, so that both functions are visible from within B and C:
p6741
aVEdit: The real description the Standard gives is (from 10
p6742
aV2/2):
p6743
aVThe following steps define the result of name lookup in a class scope, C
p6744
aVFirst, every declaration for the
p6745
aVname in the class and in each of its base class sub-objects is considered
p6746
aVA member name f in one sub-
p6747
aVobject B hides a member name f in a sub-object A if A is a base class sub-object of B
p6748
aVAny declarations
p6749
aVthat are so hidden are eliminated from consideration
p6750
aVEach of these declarations that was introduced by a
p6751
aVusing-declaration is considered to be from each sub-object of C that is of the type containing the declara-
p6752
aVtion designated by the using-declaration
p6753
aV96) If the resulting set of declarations are not all from sub-objects
p6754
aVof the same type, or the set has a nonstatic member and includes members from distinct sub-objects, there is
p6755
aVan ambiguity and the program is ill-formed
p6756
aVOtherwise that set is the result of the lookup
p6757
aVIt has the following to say in another place (just above it):
p6758
aVFor an id-expression [something like "foo"], name lookup begins in the class scope of this; for a qualified-id [something like "A::foo", A is a nested-name-specifier], name lookup begins in the scope of the nested-name-specifier
p6759
aVName lookup takes place before access control (3
p6760
aV4, clause 11)
p6761
aV([
p6762
aVput by me)
p6763
aVNote that means that even if your foo in B is private, the foo in A will still not be found (because access control happens later)
p6764
as(dp6765
g15
V34509
p6766
stp6767
a((dp6768
g2
(lp6769
VA pointer to void,  can point to any object:
p6770
aVYou can't dereference, increment or decrement that pointer, because you don't know what type you point to
p6771
aVThe idea is that  can be used for functions like  that just copy memory blocks around, and don't care about the type that they copy
p6772
as(dp6773
g15
V34509
p6774
stp6775
a((dp6776
g2
(lp6777
VA reference does contain nothing in itself
p6778
aVThe C++ Standard even states that an implementation is not required to allocate any storage for a reference
p6779
aVIt's really just an alias for the object or function that it references
p6780
aVTrying to take the value of a reference will take the value of the object or function (in that case, you get a function pointer, just like when you would try to get the value out of the function using its original name) it references, instead
p6781
aVOf course, when you go on lower levels and look at the assembler code, references are just like pointers
p6782
aVBut at the language level, they are completely different beasts
p6783
aVReferences to const, for example, can bind to temporaries, they are required to implement a copy constructor, for overloading operators and they can't be put into an array (not even if you initialize all elements of it), because references are no objects (as opposed to pointers)
p6784
aVThey are, as trivial as it may sound, reference types
p6785
as(dp6786
g15
V34509
p6787
stp6788
a((dp6789
g2
(lp6790
VUpdate: You told us what you want
p6791
aVI found this question here on SO: Best method for storing this pointer for use in WndProc
p6792
aVI'm not a Windows Programmer, but the Adam Rosenfield guy seem to be right in using SetWindowLongPtr and GetWindowLongPtr
p6793
aVSo, you use it like this:
p6794
aVRegister that function as the wnd-proc and store the  pointer of your Window object using SetWindowLongPtr
p6795
aVIn the  structure, there is a  field that you assign  to, which is enough storage to just contain the this pointer
p6796
aVThen you can call
p6797
aVto put the this pointer into that region
p6798
aVThen receive it like the above and delegate to the real member function
p6799
aVYou could in theory also use a static member function
p6800
aVBut you have to be careful
p6801
aVCalling a static member function from C code can cause bugs, because the calling convention might be different between C code and C++ code
p6802
aVFor Windows, that may not be an issue - I don't know
p6803
aVSo better check yourself in addition
p6804
aVThe thing you try is invalid
p6805
aVYou try to return a pointer to the function call operator, but there is no object provided when the call is made, beside that your conversion operator has the wrong type
p6806
aVThe type that the conversion operator returns has function pointer type, but not member function pointer type
p6807
aVThe closest you can get to is to use the proper type:
p6808
aVNow, your conversion operator is not even considered, because it has to be called like this:
p6809
aVAnd manually like this:
p6810
aVThe usual function call syntax does not cope with that
p6811
aVIn short, what you try is not possible
p6812
aVI think another question is, why the heck do you want to do that
p6813
aVI think we can help you better when we know what the original problem is
p6814
aVIf you are trying to make it look and work like a function call, you don't need any conversion operators at all:
p6815
as(dp6816
g15
V34509
p6817
stp6818
a((dp6819
g2
(lp6820
VNot sure what you mean
p6821
aVSounds like you store the objects by value, and you you have an array of
p6822
aVThat won't work, because as soon as you assign a Derived, that object will be converted to a Base, and the Derived part of the object is sliced away
p6823
aVBut i think you want to have a array of pointers to base:
p6824
aVIf you ever haved worked with pointers, you will know it's a pain in the ass to manage them, espacially pass around and not lose them, since you will need to call delete on them to free the memory and call the destructor of the objects
p6825
aVYou can use shared_ptr, and it will manage that for you:
p6826
aVNow, you can pass  to another shared_ptr, and it will note you have got more than one reference - it will call automatically delete if the last reference to the objects go out of scope
p6827
aVIdeally, you would also replace the raw array by std::vector:
p6828
aVThen you can pass the vector around, and don't lose the size of it, and you can dynamically add items to it on demand
p6829
aVGet the size of the vector using
p6830
aVRead about  here
p6831
aVConversion from a Base class to a Derived class should only be done when absolutely necessary
p6832
aVNormally, you want to use a technique called , which means you call a function on the base pointer, but it will actually call a function defined in the derived class, having the same signature (name and parameters are the same type) and is said to  it
p6833
aVRead the article on wikipedia about it
p6834
aVIf you really need to cast, you can do it like this for a raw pointer:
p6835
aVUsing dynamic_cast ensures, that when you cast to the wrong type (i
p6836
aVe the type you cast is not the type that was created and assigned to the base pointer), you get an exception thrown by the operator
p6837
aVFor the shared_ptr case, there are ways too:
p6838
as(dp6839
g15
V34509
p6840
stp6841
a((dp6842
g2
(lp6843
VMine's are
p6844
aVawk - for filtering and extracting fields
p6845
aVfind - for finding files/directories
p6846
aVxargs - build command lists, often i use it with find
p6847
aVless - for quickly browsing/reading files
p6848
aVman/info - for viewing manpages and info pages
p6849
aVemacs - for editing source code
p6850
aVirssi - to get in touch with other developers
p6851
aVcd - to change to home dir and to other directories
p6852
aVkillall - to kill not behaving commands (yeah, you get power
p6853
aVps - to list processes (oh noes, i hate hanging mplayers blocking my sound
p6854
aV+ - completion of commands by searching in history file
p6855
aV- for completing directory and file names
p6856
aVAnd, last but not least, the most often used power command is , isn't it
p6857
aV:)
p6858
as(dp6859
g15
V34509
p6860
stp6861
a((dp6862
g2
(lp6863
VYou can do
p6864
aVAnd all fields will be zero and false respectively
p6865
aVIf you want to say that the fields have an indeterminate value, i'm afraid you have to use other techniques
p6866
aVOne is to use :
p6867
aVLeaves field3 indeterminate
p6868
aVAccess the values with
p6869
aVTest for a none value with  or
p6870
as(dp6871
g15
V34509
p6872
stp6873
a((dp6874
g2
(lp6875
VYour indentation was wrong and i think you can only have one  in there (i could be very well wrong
p6876
aVI'm not a haskell guy)
p6877
aVThere was also a argument missing for the call to  (an empty list):
p6878
aVPrints out:
p6879
aVI'm going to try to understand it now
p6880
aVAnyway, have fun
p6881
aVEdit: Makes perfect sense to me now
p6882
aVI think that's the right version
p6883
aVFor Haskell indentation rules, read Haskell Indentation
p6884
as(dp6885
g15
V34509
p6886
stp6887
a((dp6888
g2
(lp6889
V"~" is not expanded to your home directory when appearing in double quotes like that
p6890
aVUse  instead
p6891
aVAlso consider using another approach that will work when filenames contain spaces (oh, i just have to think of all my silly mp3 files with their spaces in them
p6892
aVInstead of doing
p6893
aVPrefer
p6894
aVSo by combining @sirlancelots and my space fixes, we get:
p6895
as(dp6896
g15
V34509
p6897
stp6898
a((dp6899
g2
(lp6900
VWhat Konrad already explained can be put further to support nested invocations of operators, all executed lazily
p6901
aVIn Konrad's example, he has an expression object that can store exactly two arguments, for exactly two operands of one operation
p6902
aVThe problem is that it will only execute one subexpression lazily, which nicely explains the concept in lazy evaluation put in simple terms, but doesn't improve performance substantially
p6903
aVThe other example shows also well how one can apply  to add only some elements using that expression object
p6904
aVBut to evaluate arbitrary complex expressions, we need some mechanism that can store the structure of that too
p6905
aVWe can't get around templates to do that
p6906
aVAnd the name for that is
p6907
aVThe idea is that one templated expression object can store the structure of some arbitrary sub-expression recursively, like a tree, where the operations are the nodes, and the operands are the child-nodes
p6908
aVFor a very good explanation i just found today (some days after i wrote the below code) see here
p6909
aVThat will store any addition operation, even nested one, as can be seen by the following definition of an operator+ for a simple point type:
p6910
aVNow, if you have
p6911
aVYou now just need to overload operator= and add a suitable constructor for the Point type and accept AddOp
p6912
aVChange its definition to:
p6913
aVAnd add the appropriate get_x and get_y into AddOp as member functions:
p6914
aVNote how we haven't created any temporaries of type Point
p6915
aVIt could have been a big matrix with many fields
p6916
aVBut at the time the result is needed, we calculate it lazily
p6917
as(dp6918
g15
V34509
p6919
stp6920
a((dp6921
g2
(lp6922
VThat's simple
p6923
aVIt's explained in :
p6924
aVLogin shells are the ones that are read one you login (so, they are not executed when merely starting up xterm, for example)
p6925
aVThere are other ways to login
p6926
aVFor example using an X display manager
p6927
aVThose have other ways to read and export environment variables at login time
p6928
aVAlso read the  chapter in the manual
p6929
aVIt says "The  following  paragraphs  describe  how  bash  executes its startup files
p6930
aV, i think that's a spot-on :) It explains what an "interactive" shell is too
p6931
aVBash does not know about
p6932
aVI suspect that's a file of your distribution, to set environment variables independent of the shell that you drive
p6933
as(dp6934
g15
V34509
p6935
stp6936
a((dp6937
g2
(lp6938
VHow about the Usenet:
p6939
aV(for discussion about C++ Programming, moderated)
p6940
aV(for discussion about C++ Programming)
p6941
aVURL for the two above
p6942
aV(for discussion about the Standard)
p6943
aVURL for the one above
p6944
as(dp6945
g15
V34509
p6946
stp6947
a((dp6948
g2
(lp6949
VA object having POD type, in this case, is already created (Whether or not you call new
p6950
aVAllocating the required storage already suffices), and you can access the members of it, including calling a function on that object
p6951
aVBut that will only work if you precisely know the required alignment of T, and the size of T (the buffer may not be smaller than it), and the alignment of all the members of T
p6952
aVEven for a pod type, the compiler is allowed to put padding bytes between members, if it wants
p6953
aVFor a non-POD types, you can have the same luck if your type has no virtual functions or base classes, no user defined constructor (of course) and that applies to the base and all its non-static members too
p6954
aVFor all other types, all bets are off
p6955
aVYou have to read values out first with a POD, and then initialize a non-POD type with that data
p6956
as(dp6957
g15
V34509
p6958
stp6959
a((dp6960
g2
(lp6961
VYeah you are correct
p6962
aVThe first is called a static library, while the second is called a shared library, because the code is not bound to the executable at compile time, but everytime again when your program is loaded
p6963
aVStatic library
p6964
aVCompile your library's code as follows:
p6965
aVThe  tells the program not to link the object file, but just leaves you with object files for each  file that was compiled
p6966
aVNow, archive them into one static library:
p6967
aVwill tell you what the rcs options mean
p6968
aVNow, libmystuff
p6969
aVa is a archive file (you can open it with some zip-file viewers) which contain those object files, together with an index of symbols for each object file
p6970
aVYou can link it to your program:
p6971
aVNow, your program is ready
p6972
aVNote that the order of where the static libraries appear in the command matter
p6973
aVSee my Link order answer
p6974
aVShared library
p6975
aVFor a shared library, you will create your library with
p6976
aVThat's all it takes, libmystuff
p6977
aVso is now a shared object file
p6978
aVIf you want to link a program to it, you have to put it into a directory that is listed in the  file, or that is given by the  switch to GCC, or listed in the LD_LIBRARY_PATH variable
p6979
aVWhen linking, you cut the  prefix and  suffix from the library name you tell gcc
p6980
aVInternally, gcc will just pass your arguments to the GNU linker
p6981
aVYou can see what arguments it pass using the  option: Gcc will print the exact arguments given to each sub process
p6982
aVFor details about the linking process (how some stuff is done internally), view my Linux GCC linker answer
p6983
as(dp6984
g15
V34509
p6985
stp6986
a((dp6987
g2
(lp6988
VWhat jbourque said is completely right
p6989
aVHe just wasn't too wordy about it:
p6990
as(dp6991
g15
V34509
p6992
stp6993
a((dp6994
g2
(lp6995
VSounds like you do it like this:
p6996
aVWhich would explain why you get the same number within one second
p6997
aVBut you have to do it like this:
p6998
aVAnd call srand once at program startup
p6999
as(dp7000
g15
V34509
p7001
stp7002
a((dp7003
g2
(lp7004
VThere is a trade off the C designers have made
p7005
aVThat's to say, they made the decision to put speed above safety
p7006
aVC won't
p7007
aVCheck array index bound
p7008
aVCheck for uninitialized variable values
p7009
aVCheck for memory leaks
p7010
aVCheck for null pointer dereference
p7011
aVWhen you index into an array, in Java it takes some method call in the virtual machine, bound checking and other sanity checks
p7012
aVThat is valid and absolutely fine, because it adds safety where it's due
p7013
aVBut in C, even pretty trivial things are not put in safety
p7014
aVFor example, C doesn't require memcpy to check whether the regions to copy overlap
p7015
aVIt's not designed as a language to program a big business application
p7016
aVBut these design decisions are not bugs in the C language
p7017
aVThey are by design, as it allows compilers and library writers to get every bit of performance out of the computer
p7018
aVHere is the spirit of C how the C Rationale document explains it:
p7019
aVC code can be non-portable
p7020
aVAlthough it strove to give programmers the opportunity to write truly portable programs, the Committee did not want to force programmers into writing portably, to preclude the use of C as a ``high-level assembler'': the ability to write machine-specific code is one of the strengths of C
p7021
aVKeep the spirit of C
p7022
aVThe Committee kept as a major goal to preserve the traditional spirit of C
p7023
aVThere are many facets of the spirit of C, but the essence is a community sentiment of the underlying principles upon which the C language is based
p7024
aVSome of the facets of the spirit of C can be summarized in phrases like
p7025
aVTrust the programmer
p7026
aVDon't prevent the programmer from doing what needs to be done
p7027
aVKeep the language small and simple
p7028
aVProvide only one way to do an operation
p7029
aVMake it fast, even if it is not guaranteed to be portable
p7030
aVThe last proverb needs a little explanation
p7031
aVThe potential for efficient code generation is one of the most important strengths of C
p7032
aVTo help ensure that no code explosion occurs for what appears to be a very simple operation, many operations are defined to be how the target machine's hardware does it rather than by a general abstract rule
p7033
aVAn example of this willingness to live with what the machine does can be seen in the rules that govern the widening of char objects for use in expressions: whether the values of char objects widen to signed or unsigned quantities typically depends on which byte operation is more efficient on the target machine
p7034
as(dp7035
g15
V34509
p7036
stp7037
a((dp7038
g2
(lp7039
Vand that both ways would require the use of free()
p7040
aVNo, only the first needs the use of a free
p7041
aVThe second is allocated on the stack
p7042
aVThat makes it incredibly fast to allocate
p7043
aVLook here:
p7044
aVWhen you create it, the compiler at compile time knows its size and will allocate the right size at the stack for it
p7045
aVThe stack is a large chunk of continuous memory located somewhere
p7046
aVPutting something at the stack will just increment (or decrement depending on your platform) the stackpointer
p7047
aVGoing out of scope will do the reverse, and your array is freed
p7048
aVThat will happen automatically
p7049
aVTherefor variables created that way have automatic storage duration
p7050
aVUsing malloc is different
p7051
aVIt will order some arbitrary large memory chunk (from a place called freestore)
p7052
aVThe runtime will have to lookup a reasonably large block of memory
p7053
aVThe size can be determined at runtime, so the compiler generally cannot optimize it at compile time
p7054
aVBecause the pointer can go out of scope, or be copied around, there is no inherent coupling between the memory allocated, and the pointer to which the memory address is assigned, so the memory is still allocated even if you have left the function long ago
p7055
aVYou have to call free passing it the address you got from malloc manually if the time has come to do so
p7056
aVSome "recent" form of C, called C99, allows you to give arrays an runtime size
p7057
ag1388
aVe you are allowed to do:
p7058
aVBut that feature should better be avoided if you don't have a reason to use it
p7059
aVOne reason is that it's not failsafe: If no memory is available anymore, anything can happen
p7060
aVAnother is that C99 is not very portable among compilers
p7061
as(dp7062
g15
V34509
p7063
stp7064
a((dp7065
g2
(lp7066
V has loads of free development environments listed, and much more general development tools
p7067
aVhas yet another bunch of tools, where some of them will work on Windows too
p7068
as(dp7069
g15
V34509
p7070
stp7071
a((dp7072
g2
(lp7073
V is your friend
p7074
aVIt allows extracting individual boost libraries out of its tree
p7075
aVI used it with success in the past
p7076
aVshared_ptr consists only of headers, so that will be especially good for you
p7077
as(dp7078
g15
V34509
p7079
stp7080
a((dp7081
g2
(lp7082
VThis is very interesting
p7083
aVI've asked a guy who knows bash quite well, and he told me this way:
p7084
aVFirst, that creates a function reading one line of raw input from stdin, while the assignment to IFS makes it doesn't ignore blanks
p7085
aVHaving read one line, it outputs it with the appropriate data prepended
p7086
aVThen you have to tell bash to redirect stderr into that function:
p7087
aVEverything you write into stderr will now go through the foo function
p7088
aVNote when you do it in an interactive shell, you won't see the prompt anymore, because it's printed to stderr, and the read in foo is line buffered :)
p7089
as(dp7090
g15
V34509
p7091
stp7092
a((dp7093
g2
(lp7094
VThere are many possible reasons of this
p7095
aVRanges from that you access objects not yet created (because order of creation of objects across different translation units is undefined) which i think is quite probable in this case, and ranges to an error on your build-environment
p7096
aVTo make a own function be called before other constructor function, you have a  attribute described here
p7097
aVGCC keeps a priority for each files' constructor input section
p7098
aVAnd it links them in order of those priorities
p7099
aVIn the linker script of my linux system, that code looks like this (output it using ):
p7100
aVYou would want to give it a low priority to make it execute before other registered ctor functions having a higher priority number
p7101
aVHowever from the looks of it, it seems like constructors having no number will be executed first
p7102
aVNot sure entirely
p7103
aVBest you give it a try
p7104
aVIf you want to have your function called even before _do_global_ctors_aux, you have to release the original  function that is normally executed when your program is loaded by the ELF loader (look into the  option of ld)
p7105
aVIt's been some time since i messed with it, but i remember it has to do some intimate details of initialization, so i wouldn't try to replace it
p7106
aVTry using the constructor attribute i linked to
p7107
aVHowever, be very careful
p7108
aVYour code will possibly be executed before other important objects like  are constructed
p7109
aVUpdate: I did a test, and it actually executes ctor functions in reverse
p7110
aVSo ctor functions that are linked first are executed later
p7111
aVThis code happens to be in crtstuff
p7112
aVc of the gcc source code:
p7113
aVI made a little test:
p7114
aVLinking with  yields, among others, this output:
p7115
aVNotice how  is the section we implicitly created by our attribute priority
p7116
aVNow, if you give it that priority, gcc warns and it's totally right :p
p7117
aVtest
p7118
aVcpp:7: warning: constructor priorities from 0 to 100 are reserved for the implementation
p7119
aVI tested it by breaking on  and , and it called them in the order we expect
p7120
aVHave fun
p7121
as(dp7122
g15
V34509
p7123
stp7124
a((dp7125
g2
(lp7126
VYou have a data member pointer to two unrelated classes
p7127
aVWell, you can't find a common type that can hold both pointers
p7128
aVIt will only work if the function parameter is a data member pointer to a member of the derived, because it's guaranteed to contain the member too, if a base contains it:
p7129
aVUpdate: I think i should write why the above converts from  to  implicitly
p7130
aVAfter all, we usually have  to
p7131
aVConsider:
p7132
aVIf the above would be valid, you would really much screw up
p7133
aVThe above is not valid, because conversion from  to  is not implicit
p7134
aVAs you see, we assigned a pointer to b::c, and then we could dereference it using a class that doesn't contain it at all
p7135
aV()
p7136
aVThe compiler enforces this order:
p7137
aVIt fails to compile now, because  is not derived from , the class the member pointer pointer belongs to
p7138
aVGood
p7139
aVThe following, however, is very valid and compiles, of course (changed classes  and ):
p7140
aVTo make it work for your case, you have to make your function a template:
p7141
aVNow, the compiler will auto-deduce the right class that the given member pointer belongs too
p7142
aVYou will have to pass the instance alongside of the member pointer to actually make use of it:
p7143
aVIf you just want to set some member you already know at the time you write DoThings, the following suffices:
p7144
as(dp7145
g15
V34509
p7146
stp7147
a((dp7148
g2
(lp7149
VSince you asked for it, here are symbols having at least ABI version 3
p7150
ag2670
aV9:
p7151
aVRun the file  through c++filt, grepping for GLIBCXX_3
p7152
ag2670
aV9 to make sense of those names (they look like wildcards only)
p7153
aVI didn't do it because those names become quite long and nested
p7154
aVLater versions mostly include c++1x stuff
p7155
aVSee the file  for the above
p7156
aVRead here about the VERSION linker script command
p7157
as(dp7158
g15
V34509
p7159
stp7160
a((dp7161
g2
(lp7162
VThat's not possible portably in pure C++, because it depends too much on the terminal used that may be connected with stdin (they are usually line buffered)
p7163
aVYou can, however use a library for that:
p7164
aVconio available with windows compilers
p7165
aVUse the function  to give you a character without waiting for the enter key
p7166
aVI'm not a frequent windows developer, but i've seen my classmates just include  and use it
p7167
aVSee conio
p7168
aVh at wikipedia
p7169
aVIt lists , which is declared deprecated in Visual C++
p7170
aVcurses available for linux, compatible curses implementations are available for windows too
p7171
aVIt has also a  function
p7172
aV(try  to view its manpage)
p7173
aVSee Curses at wikipedia
p7174
aVI would recommend you to use curses if you aim for cross platform compatibility
p7175
aVThat said, I'm sure there are functions that you can use to switch off line buffering (i believe that's called "raw mode", as opposed to "cooked mode" (look into ))
p7176
aVCurses would handle that for you in a portable manner if i'm not mistaken
p7177
as(dp7178
g15
V34509
p7179
stp7180
a((dp7181
g2
(lp7182
VI think i'm just going to praise C++ for its ability to use templates to catch expressions and execute it lazily when it's needed
p7183
aVFor those not knowing what this is about, here is an example
p7184
as(dp7185
g15
V34509
p7186
stp7187
a((dp7188
g2
(lp7189
VThe  and  are the libraries that the C++ and C Standard define that is provided to C++ and C programs to use
p7190
aVThat's a common meaning of those words, i haven't ever seen another definition of it, and C++ itself defines it as this:
p7191
aVThe C++ Standard Library provides an extensible framework, and contains components for: language support, diagnostics, general utilities, strings, locales, containers, iterators, algorithms, numerics, and input/output
p7192
aVThe language support components are required by certain parts of the C++ language, such as memory allocation (5
p7193
ag1037
aV4, 5
p7194
ag1037
aV5) and exception processing (clause 15)
p7195
aVand  aren't so equally used
p7196
aVSome say a runtime library is the part that a program uses at runtime (like, the code that implements  or the code supporting signal handlers) as opposed to stuff that they only use at compile time (like macro definitions)
p7197
aVOther people say that a runtime library is one that is linked to a program at load time dynamically, as opposed to statically at compile time, though this use is very seldom
p7198
aVshared library or dynamically linked library are better terms for that
p7199
aVand  are very broad terms
p7200
aVThey just mean that a library is written in C++ and/or C
p7201
aVThe above is not only limited to C++ and/or C
p7202
aVThere are python libraries and there is a python Standard Library too
p7203
as(dp7204
g15
V34509
p7205
stp7206
a((dp7207
g2
(lp7208
VYou can use  to handle a page fault, including cases where a stack overflow occurs (from its website):
p7209
aVIn some applications, the stack overflow handler performs some cleanup or notifies the user and then immediately terminates the application
p7210
aVIn other applications, the stack overflow handler longjmps back to a central point in the application
p7211
aVThis library supports both uses
p7212
aVIn the second case, the handler must ensure to restore the normal signal mask (because many signals are blocked while the handler is executed), and must also call sigsegv_leave_handler() to transfer control; then only it can longjmp away
p7213
as(dp7214
g15
V34509
p7215
stp7216
a((dp7217
g2
(lp7218
VGeneric solution where the number can be anywhere in the filename, using the first of such sequences:
p7219
aVAnother solution to extract exactly a part of a variable:
p7220
aVIf your filename always have the format  you can use awk:
p7221
aVYet another solution to remove everything except digits, use
p7222
as(dp7223
g15
V34509
p7224
stp7225
a((dp7226
g2
(lp7227
VI assume your program behaves like standard unix tools, that when not given a file will write to standard output, and when given a file will write into that file
p7228
aVYou can redirect  to write into another stream buffer
p7229
aVAs long as your redirection is alive, everything written to cout is transparently written to the destination you designated
p7230
aVOnce the redirection object goes out of scope, the original stream is put and output will write to the screen again:
p7231
aVNow, cout is redirected to the file as long as the pipe is alive in main
p7232
aVYou can make it more "production ready" by making it non-copyable, because it's not ready to be copied: If the copy goes out of scope, it would restore the original stream already
p7233
as(dp7234
g15
V34509
p7235
stp7236
a((dp7237
g2
(lp7238
VOverloading generally means that you have two or more functions in the same scope having the same name
p7239
aVThe function that better matches the arguments when a call is made wins and is called
p7240
aVImportant to note, as opposed to calling a virtual function, is that the function that's called is selected at compile time
p7241
aVIt all depends on the static type of the argument
p7242
aVIf you have an overload for  and one for , and the argument is a reference to , but it really points to a  object, then the overload for  is chosen in C++
p7243
aVThat's called static dispatch as opposed to dynamic dispatch
p7244
aVYou overload if you want to do the same as another function having the same name, but you want to do that for another argument type
p7245
aVExample:
p7246
aVthey both print their argument, so they are overloaded
p7247
aVBut the first prints a foo, and the second prints a bar
p7248
aVIf you have two functions that do different things, it's considered bad style when they have the same name, because that can lead to confusion about what will happen actually when calling the functions
p7249
aVAnother usecase for overloading is when you have additional parameters for functions, but they just forward control to other functions:
p7250
aVThat can be convenient for the caller, if the options that the overloads take are often used
p7251
aVOverriding is something completely different
p7252
aVIt doesn't compete with overloading
p7253
aVIt means that if you have a virtual function in a base class, you can write a function with the same signature in the derived class
p7254
aVThe function in the derived class overrides the function of the base
p7255
aVSample:
p7256
aVNow, if you have an object and call the  member function, the print function of the derived is always called, because it overrides the one of the base
p7257
aVIf the function  wasn't virtual, then the function in the derived wouldn't override the base function, but would merely hide it
p7258
aVOverriding can be useful if you have a function that accepts a base class, and every one that's derived from it:
p7259
aVNow, even though at compile time the compiler only knows that b is at least base, print of the derived class will be called
p7260
aVThat's the point of virtual functions
p7261
aVWithout them, the print function of the base would be called, and the one in the derived class wouldn't override it
p7262
as(dp7263
g15
V34509
p7264
stp7265
a((dp7266
g2
(lp7267
VIt's this way i believe (we had a lengthy discussion on this earlier on stack overflow in a comment-thread):
p7268
aVIf the initialization or destructor of an object with namespace scope (that are objects with static storage duration) has no side-effects, the objet can be optimized out if there is no use of a function or object in its translation unit
p7269
aVFor objects whose initialization or destruction cause side effects, then the compiler may not optimize that variable out, even if there is no use of objects or functions of its translation units
p7270
aVIn any case, the compiler has to initialize the objects before that use is done, but not necessarily before main
p7271
aVI did tests because someone at stackoverflow said that gcc effectively optimizes out initializations of objects having side effects if there is no such use
p7272
aVI tested that now, and I've seen gcc does not do that
p7273
aVAdditionally, as i understand the Standard, it is not allowed to do so anyway
p7274
aVIt suffices if you just take the address of an object or function of the translation unit of the object you want to have initialized
p7275
aVTo be on the safe side, better always do that, even for objects having initializations with side effects
p7276
aVAssuming your friend is right, i think for the translation unit of main,  is always seen as being used, so that condition immediately is satisfied
p7277
aVRules can be found in ,  and  (definition of use),  (definition of side-effect)
p7278
as(dp7279
g15
V34509
p7280
stp7281
a((dp7282
g2
(lp7283
VYou've got two choices:
p7284
aValready detailed by j_random_hacker, because it's non-copyable (doesn't share ownership like shared_ptr) and non-movable (doesn't transfer ownership like auto_ptr
p7285
aVauto_ptr has a copy constructor, but that one does not copy
p7286
aVIt moves the original pointer to *this)
p7287
aVis exactly what you need
p7288
aVdoesn't allow transfer of ownership
p7289
aVAnd take your parameter by reference to const ()
p7290
aVIf the writer of a function accepts by value instead, it still won't work if you try passing a const auto_ptr, because its copy constructor needs a non-const auto_ptr
p7291
aVUntil C++1x, boost::scoped_ptr is the best choice for your needs, or a const auto_ptr if you have to use official standard stuff (read this)
p7292
aVIn C++1x, you can use  as a better alternative to auto_ptr, because you have to explicitly state when you want to transfer ownership
p7293
aVTrying to copy it will result in a compile time error
p7294
aVunique_ptr is detailed a little in this answer
p7295
as(dp7296
g15
V34509
p7297
stp7298
a((dp7299
g2
(lp7300
VIt depends on what you do with the dereferenced pointer
p7301
aVA mere dereference operation does nothing in itself
p7302
aVIt just gets an lvalue of type  which represents your object, if your pointer is a
p7303
aVIf you actually get the value out of that object denoted by the lvalue returned by the dereference operation, the compiler has to copy the data the object contains
p7304
aVFor a simple POD, that is just a mere memcpy:
p7305
aVMy gcc port outputs this code for f:
p7306
aVOptimized machine code would use in-line code instead of a call to memcpy, but that's really just an implementation detail
p7307
aVWhat is important is, that merely  isn't executing any code, but accessing the value of that object actually needs to copy it
p7308
aVWould we have to do with a type having a user defined copy assignment operator, affairs are more complex:
p7309
aVThe code for the same function f now looks like:
p7310
aVHah
p7311
aVBut it wasn't such a surprise, wasn't it
p7312
aVAfter all, the compiler is supposed to call our operator=, and if it does nothing, the whole function also does nothing
p7313
aVConclusion
p7314
aVI think the conclusion we can draw is, it all depends on how the returned value of operator* is used
p7315
aVIf we have just a pointer that we dereference, we see above that the code generated largely depends on the circumstances
p7316
aVI haven't showed how it behaves if we dereference a class type having overloaded operator*
p7317
aVBut essentially, it's just behaving like we saw with operator=
p7318
aVAll measurements were done with , so the compiler properly inlined calls :)
p7319
as(dp7320
g15
V34509
p7321
stp7322
a((dp7323
g2
(lp7324
VWell, if the special and normal circles can be both applied forces to, and the special circle has another method that applies special forces, why not have two interfaces and two methods
p7325
aVIf it doesn't make sense if there is both a special and a normal apply method (which the name of the class -  - suggests), then why not do even this:
p7326
aVYou can also put the  into the Shape class
p7327
aVIt also depends on the environment in which those classes are used
p7328
aVWhat, in any case, you really should avoid is having the same method in two base classes that appear in two difference base-lattices
p7329
aVBecause that inevitable will lead to such ambiguity problems
p7330
aVThe diamond inheritance is when you use virtual inheritance
p7331
aVI believe there are other good answers on stackoverflow explaining that
p7332
aVIt isn't applicable for your problem, because the ambiguity arises because the method appears in two base class sub-objects of different types
p7333
aV(It only solves such cases where the base classes have the same type
p7334
aVIn those cases, it will merge the base classes and there will only be one base class sub-object contained - inherited by virtual inheritance)
p7335
as(dp7336
g15
V34509
p7337
stp7338
a((dp7339
g2
(lp7340
VYes, if you erase an iterator, that iterator gets a so-called singular value, which means it doesn't belong to any container anymore
p7341
aVYou can't increment, decrement or read it out/write to it anymore
p7342
aVThe correct way to do that loop is:
p7343
aVFor containers that could invalidate other iterators when you erase one iterator,  returns the next valid iterator
p7344
aVThen you do it with
p7345
aVThat's how it works for  and , but not for  or
p7346
as(dp7347
g15
V34509
p7348
stp7349
a((dp7350
g2
(lp7351
VBack then, i tested my middle mouse button using a tool called
p7352
aVIt creates a new window, which you can send events (by clicking on it, or pressing buttons) which are catched and printed on stdout
p7353
aVAccording to a comment by jpalecek, it can also be used to watch other windows, instead of a new one
p7354
aVThe following will watch events from a window you selected by clicking on it:
p7355
aVFor gathering general information, xwininfo can be used, which can display children, attributes and more
p7356
as(dp7357
g15
V34509
p7358
stp7359
a((dp7360
g2
(lp7361
VYes, that's entirely possible
p7362
aVGCC has an attribute for that:
p7363
aVSets the optimization level for that function to
p7364
aVYou can enable/disable specific optimizations:
p7365
as(dp7366
g15
V34509
p7367
stp7368
a((dp7369
g2
(lp7370
VWhat you see is the sign preserving conversion from char to int
p7371
aVThe behavior results from the fact that on your system, char is signed (Note: char is not signed on all systems)
p7372
aVThat will lead to negative values if a bit-pattern yields to a negative value for a char
p7373
aVPromoting such a char to an int will preserve the sign and the int will be negative too
p7374
aVNote that even if you don't put a  explicitly, the compiler will automatically promote the character to an int when passing to printf
p7375
aVThe solution is to convert your value to  first:
p7376
aVAlternatively, you can use  from the start on:
p7377
aVAnd then you don't need any cast at the time you print it with printf
p7378
as(dp7379
g15
V34509
p7380
stp7381
a((dp7382
g2
(lp7383
VIt's making a pointer  point to a statically allocated char array containing
p7384
aVThe string is not writable, even though the type of the pointer might suggest you could write to it
p7385
aVSee the answer in the link below, for reasons to avoid it and how you can do better
p7386
aVIt's creating an array having the type
p7387
aVEven though you tell it with the declarator that  has a type , it's really defining an array with a complete type - that is, with a defined length for that array
p7388
aVThat's because it's directly initialized, and the compiler can deduce the size of the array
p7389
aVThe array is writable
p7390
aVYou can freely change characters in it
p7391
aVI tried to make the difference clear in this answer: http://stackoverflow
p7392
aVcom/questions/308279/c-vs#308724
p7393
aVIt's an integer variable created on the stack
p7394
aVIt's not initialized
p7395
aVIt has automatic storage duration: Going out of scope (returning from the function, breaking out of the loop
p7396
aVwill free the memory of it
p7397
aVYou can of course write to it as much as you want
p7398
aVIt's a pointer which will point to an integer that's dynamically allocated
p7399
aVThe int is not initialized
p7400
aVAnd the memory is not freed when the pointer goes out of scope
p7401
aVThat is, when your function returns, the memory will still be there
p7402
as(dp7403
g15
V34509
p7404
stp7405
a((dp7406
g2
(lp7407
VI don't know the specific reasons why a character literal in C is of type int
p7408
aVBut in  C++, there is a good reason not to go that way
p7409
aVConsider this:
p7410
aVYou would expect that the call to print selects the second version taking a char
p7411
aVHaving a character literal being an int would make that impossible
p7412
aVNote that in C++ literals having more than one character still have type int, although their value is implementation defined
p7413
aVSo,  has type , while  has type
p7414
as(dp7415
g15
V34509
p7416
stp7417
a((dp7418
g2
(lp7419
VInclude guards only protect that function from being included into the same translation unit twice
p7420
aVBut it won't protect that function from being included into the whole program twice
p7421
aVAs the function is non-inline, it violates the One Definition Rule if it appears more than once in the whole program
p7422
aVMake it inline to solve the problem, or put the definition into a implementation file, putting only its declaration in the header
p7423
aVOn a side note - better don't put const on a built-in return value
p7424
aVTemporaries of them can't be qualified with const / volatile
p7425
aVBut that's also not necassary: You can't modify them anyway
p7426
aVIt's ignored as far as i know
p7427
aVBut it won't ever have an effect
p7428
as(dp7429
g15
V34509
p7430
stp7431
a((dp7432
g2
(lp7433
VHere's how i do it:
p7434
aVPut the swap function into the same namespace like the Foo class
p7435
aVArgument dependent lookup finds it when users do a call to swap to swap two Foo
p7436
aVYou can implement  using your swap function too
p7437
as(dp7438
g15
V34509
p7439
stp7440
a((dp7441
g2
(lp7442
VMost answers in here focused on the effect of the macro substitution
p7443
aVBut i think he wanted to know whether
p7444
aVis evaluated at compile time
p7445
aVFirst of all, that is an arithmetic constant expression, and in addition a integral constant expression (because it has only got literals of integer type)
p7446
aVThe implementation is free to calculate it at runtime, but it must also be able to calculate it at compile time, because
p7447
aVit must give a diagnostic message if a constant expression is not representable in the type that its expression has
p7448
aVsuch expressions are allowed in contexts that require the value at translation time, for example if used as the size of an array dimension
p7449
aVIf the compiler can principally calculate the result already at compile time, it should use that value, and not recalculate it at runtime i think
p7450
aVBut maybe there is some reason still to do that
p7451
aVI wouldn't know
p7452
aVEdit: I'm sorry i've answered the question as if it were about C++
p7453
aVNoticed today you asked about C
p7454
aVOverflowing in an expression is deemed as undefined behavior in C, regardless of whether it happens in a constant expression or not
p7455
aVThe second point is also true in C, of course
p7456
as(dp7457
g15
V34509
p7458
stp7459
a((dp7460
g2
(lp7461
VFor questions such as this, i like to look into the Rationale document for C, which often provides answers to C++ mysteries as well, that sometimes arise for me when reading the Standard
p7462
aVIt has this to say about it:
p7463
aVThree types of char are specified: signed, plain, and unsigned
p7464
aVA plain char may be represented as either signed or unsigned, depending upon the implementation, as in prior practice
p7465
aVThe type signed char was introduced to make available a one-byte signed integer type on those systems which implement plain char as unsigned
p7466
aVFor reasons of symmetry, the keyword signed is allowed as part of the type name of other integral types
p7467
aVRationale for C
p7468
as(dp7469
g15
V34509
p7470
stp7471
a((dp7472
g2
(lp7473
VWell, first you have to understand that trying to get a value out of an array can give you a pointer to its first element:
p7474
aVReferences refer to objects using their exact type or their base-class type
p7475
aVThe key is that the template takes arrays by reference
p7476
aVArrays (not references to them) as parameters do not exist in C++
p7477
aVIf you give a parameter an array type, it will be a pointer instead
p7478
aVSo using a reference is necessary when we want to know the size of the passed array
p7479
aVThe size and the element type are automatically deduced, as is generally the case for function templates
p7480
aVThe following template
p7481
aVCalled with our previously defined array  will implicitly instantiate the following function:
p7482
aVWhich can be used like this:
p7483
aVThere's a variation i made up some time ago Edit: turns out someone already had that same idea here which can determine a value at compile time
p7484
aVInstead of returning the value directly, it gives the template a return type depending on :
p7485
aVYou say if the array has  elements, the return type is a reference to an array having size  and element type
p7486
aVNow, you can get a compile-time determined size of the passed array:
p7487
aVBecause an array of  having  elements has sizeof , that will give you the number of elements in the given array too
p7488
aVAt compile time, so you can do
p7489
aVBecause the function never is actually called, it doesn't need to be defined, so it doesn't have a body
p7490
aVHope i could clear the matter up a little bit
p7491
as(dp7492
g15
V34509
p7493
stp7494
a((dp7495
g2
(lp7496
VFriendship in C++ is not transitive:
p7497
aVAlso, friendship is not symmetric
p7498
aVYou have to explicitly state that A is a friend of C to be able to access C's private stuff from within A
p7499
aVIf adding a setter and getter to a class exposes information not meant to be exposed, you should consider friends if you can't find your design being faulty (using friend is valid
p7500
aVIt's not a sign for bad design)
p7501
aVIf you can add a setter and getter without that being destructive to the interface, then you should avoid making other classes friends
p7502
aVNote that a nested class is always a friend of the nesting class
p7503
aVSo a nested class can see the privates of the nesting class
p7504
as(dp7505
g15
V34509
p7506
stp7507
a((dp7508
g2
(lp7509
VYou can always represent a byte (if you mean 8bits) in a unsigned char
p7510
aVIt's always at least 8 bits in size, all bits making up the value, so a 8 bit value will always fit into it
p7511
aVIf you want exactly 8 bits, i also think you'll have to use platform dependent ways
p7512
aVPOSIX systems seem to be required to support int8_t
p7513
aVThat means that on POSIX systems, char (and thus a byte) is always 8 bits
p7514
as(dp7515
g15
V34509
p7516
stp7517
a((dp7518
g2
(lp7519
VMost part of boost is in headers, but some parts are in -files too
p7520
aVThe doc index page lists which libraries are header/not header only
p7521
aVYou can download the boost source here
p7522
aVThe source of  is available in the archive too, in the  subdirectory
p7523
as(dp7524
g15
V34509
p7525
stp7526
a((dp7527
g2
(lp7528
VI would recommend you to use  for linux
p7529
aVIt will catch not freed memory, among other bugs like writing to unallocated memory
p7530
aVAnother option is mudflap, which tells you about not freed memory too
p7531
aVUse  options with gcc, then start your program with
p7532
aVHere's some very simple code
p7533
aVIt's not suitable for sophisticated tracking, but intended to show you how you would do it in principle, if you were to implement it yourself
p7534
aVSomething like this (left out stuff calling the registered new_handler and other details)
p7535
aVWe have to use our own allocator for our map, because the standard one will use our overridden operator new, which would result in an infinite recursion
p7536
aVMake sure if you override operator new, you use the map to register your allocations
p7537
aVDeleting memory allocated by placement forms of new will use that delete operator too, so it can become tricky if some code you don't know has overloaded operator new not using your map, because operator delete will tell you that it wasn't allocated and use  to free the memory
p7538
aVAlso note, as Pax pointed out for his solution too, this will only show leaks that are caused by code using our own defined operator new/delete
p7539
aVSo if you want to use them, put their declaration in a header, and include it in all files that should be watched
p7540
as(dp7541
g15
V34509
p7542
stp7543
a((dp7544
g2
(lp7545
VYour problem is that a fundamental requirement of standard containers is that objects are copy-constructible
p7546
aVThat not only means that they have a copy constructor, but that also means that if you copy the object, the copy and the original are the same
p7547
aVYour object, however, resembles a move-constructor semantic
p7548
aVThat is, after a move, the new object owns the resource, and the old object is empty
p7549
aVThat's not supported by deque as of C++03
p7550
aVThat is, by the way, the same reason that forbids putting auto_ptr into a container
p7551
aVThe next C++ version, called c++0x will support those move semantics by introducing special move constructors
p7552
aVUntil then, you will have to use an object that shares ownership when you want to put it into a standard container
p7553
aVThat means if you copy your object, and the original goes out of scope, the owned resource is not freed until all the copies go out of scope
p7554
aVConsider using boost::shared_ptr for example, or wrap it into your class, if you don't want to program your own class managing that
p7555
as(dp7556
g15
V34509
p7557
stp7558
a((dp7559
g2
(lp7560
VDoug T
p7561
aVanswered your question nicely
p7562
aVI'll tell you about intrusive_ptr
p7563
aVMaybe you can use it in your project too
p7564
aVIf you have some C library that has already reference counting, but you have to manually call those functions, you can use  too, and provide proper definitions for its add_ref and release functions
p7565
aVintrusive_ptr will find and call them
p7566
aVThey are responsible to increment the reference count and decrement it, freeing the resource when necassary:
p7567
aVThen you can just create objects from raw pointers of type
p7568
aVintrusive_ptr will call your functions when its copied/destructed:
p7569
as(dp7570
g15
V34509
p7571
stp7572
a((dp7573
g2
(lp7574
VYou have to tell GCC which encoding your file uses to code those characters into the file
p7575
aVUse the option , for example
p7576
aVThen you need to tell it about the encoding used for those string literals at runtime
p7577
aVThat will determine the values of the wchar_t items in the strings
p7578
aVYou set that encoding using , for example
p7579
aVBeware that the size of the encoding (utf-32 needs 32bits, utf-16 needs 16bits) must not exceed the size of  gcc uses
p7580
aVYou can adjust that
p7581
aVThat option is mainly useful for compiling programs for , designed to be compatible with windows
p7582
aVThe option is called , and will most likely then be 16bits instead of 32bits, which is its usual width for gcc on linux
p7583
aVThose options are described in more detail in , the gcc manpage
p7584
as(dp7585
g15
V34509
p7586
stp7587
a((dp7588
g2
(lp7589
VNo
p7590
aVAn implicitly defined, trivial destructor is by definition trivial :) The difference between the declare and define thingy is that in order for the compiler to even see that a destructor is available, there must always a declaration
p7591
aVSo if you don't provide one, it will implicitly provide one
p7592
aVBut now, it will also define one, if that is needed (if an object of that class type is destroyed)
p7593
aVIn any case, it has to do something: It needs to call the destructors of all its members and base classes
p7594
aVA simple example which illustrates the effect of implicitly defining a destructor:
p7595
aVAs soon as you try to create a local object of bug, the compiler will signal an error, because it yields a definition of a destructor for bug, which tries to call the not accessible destructor of a
p7596
aVNow, i think triviality of destructors/constructors are mostly used to put constraints on your program
p7597
aVObjects having non-trivial versions of them can't be put in unions, for example
p7598
aVOn the other side, you can delete an object having incomplete type, provided it has a trivial destructor
p7599
aVNote that if your program can't decide whether or not a trivial destructor was actually defined, the compiler is allowed to omit defining it
p7600
aVThat's the so-called  rule
p7601
aVThe compiler has to behave as-if it's Standard compliant - optimizations do not matter as long as they don't change the meaning of a program
p7602
as(dp7603
g15
V34509
p7604
stp7605
a((dp7606
g2
(lp7607
VWhile C is a pure procedural language, C++ is a multi-paradigm language
p7608
aVIt supports
p7609
aVGeneric programming: Allowing to write code once, and use it with different data-structures
p7610
aVMeta programming: Allowing to utilize templates to generate efficient code at compile time
p7611
aVInspection: Allows to inspect certain properties at compile time: What type does an expression have
p7612
aVHow many parameters does a function have
p7613
aVWhat type does each one have
p7614
aVObject oriented programming: Allowing the programmer to program object oriented, with sophisticated features such as multiple inheritance and private inheritance
p7615
aVProcedural programming: Allows the programmer to put functions free of any classes
p7616
aVCombined with advanced features such as ADL allows writing clean code decoupled from specifics of certain classes
p7617
aVApart from those, C++ has largely kept compatibility with C code, but there are some differences
p7618
aVThose can be read about in Annex D of the C++ Standard, together with reasons and possible fixed to make C code valid C++ code
p7619
as(dp7620
g15
V34509
p7621
stp7622
a((dp7623
g2
(lp7624
VIt sounds like you use operator delete like a normal function that's supposed to do arbitrary things
p7625
aVAn operator delete, however, is only supposed to free the memory given to it as the first argument, which is a pointer to that memory area
p7626
aVThat pointer will point to the memory location at where your object was
p7627
aVAt this time, however, your object's destructor already ran, and your object doesn't exist anymore
p7628
aVYou can't call any member function at all on it - even less so virtual functions
p7629
aVI have the feeling that you get the purpose of operator delete wrong
p7630
aVIf you call , the compiler calls the destructor for the object, and then calls the deallocation function to free the allocated memory, which is called
p7631
aVWell, why not use the solution that we've shown you earlier, with the
p7632
as(dp7633
g15
V34509
p7634
stp7635
a((dp7636
g2
(lp7637
VSome guys would possibly tell you about that the functions can't be faster than each other, but their implementation can
p7638
aVThat's right i think i would agree
p7639
aVYou are unlikely to ever notice a difference in other than benchmarks
p7640
aVThe reason that c++ streams generally tend to be slower is that they are much more flexible
p7641
aVFlexibility most often comes at the cost of either time or code growth
p7642
aVIn this case, C++ streams are based on stream-buffers
p7643
aVIn itself, streams are just the hull that keep formatting and error flags in place, and call the right  facets of the c++ standard library (for example, num_put to print numbers), that print the values, well formatted, into the underlying stream-buffer connected to the c++ stream
p7644
aVAll this mechanisms - the facets, and the buffers, are implemented by virtual functions
p7645
aVWhile there is indeed no mark note, those functions must be implemented to be slower than c stdio pendants that fact will make them somewhat slower than using c stdio functions normally (i benchmark'ed that some time ago with gcc/libstdc++ and in fact noticed a slowdown - but which you hardly notice in day-by-day usage)
p7646
as(dp7647
g15
V34509
p7648
stp7649
a((dp7650
g2
(lp7651
VThe value  is an rvalue
p7652
aVActually, temporaries like that are rvalues
p7653
aVRvalues have special properties
p7654
aVOne of them is that their address can't be taken ( is illegal), and they can't generally bind to references to non-const (some temporaries can bind to references to non-const, but these undergo special rules: Calling member functions on temporary objects and catching exception objects by reference to non-const
p7655
aVIn the latter case, the temporary even is an lvalue)
p7656
aVThere are two kind of expressions: lvalues that denote objects (that in turn may store an value) or functions, and rvalues which are meant to represent values read out of an object or represented by temporaries, numeral literals and enumerator constants
p7657
aVIn C++03, to be able to pass such values to a function that accepts its value by-reference, there is a rule that they can be accepted by reference-to-const:  would accept it
p7658
aVThat is, you would have to declare your operator like this:
p7659
aVThat's a bit unfortunate, because you can't disambiguate constant lvalues (objects you created on the stack using  for example) and non-const or const rvalues (like  which is a non-const temporary)
p7660
aVAlso, if you go by that, the parameter can't have called non-const member functions on it, because it's a reference-to-const
p7661
aVFor that reason, C++1x, the next C++ version, introduce a new kind of reference, so-called rvalue-references which fixes that
p7662
aVThe Microsoft Visual C++ compiler binds rvalues to references to non-const, but gives out a warning when doing that (you have to use at least warning level 4 for it to show up)
p7663
aVThat's unfortunate, because problems rise up when porting to other compilers that are more strict in Standard compliance
p7664
as(dp7665
g15
V34509
p7666
stp7667
a((dp7668
g2
(lp7669
VLine 60 does not access a depending name
p7670
aVWhat you use is  of which the compiler knows it's a template given an argument
p7671
aVInstead of  you want to use  ;)
p7672
aVLine 64 does access the depending name  which is a type-name, so you have to put  before
p7673
aVI put the two disambiguations, template and typename on this answer: Disambiguations of dependent names
p7674
aVLine 74 would be right, if you fix the bug in Line 60, as far as i can see
p7675
aVLine 83 is alright in itself as far as i can see
p7676
as(dp7677
g15
V34509
p7678
stp7679
a((dp7680
g2
(lp7681
V is not valid in a destructor
p7682
aVIt can be used elsewhere
p7683
aVBut it's only rarely a good idea
p7684
aVThe  framework uses it for their thread class
p7685
aVIt has a mode where, when the thread ends execution, it automatically frees system resources and itself (the wxThread object)
p7686
aVI found it very annoying, because from outside, you can't know whether it's valid to refer it or not - you can't call a function like  anymore, because the object doesn't exist
p7687
aVThat smells like the main problem with , apart from the problem that it can't be used for non-dynamic objects
p7688
aVIf you do it, make sure you don't touch any data-member, or call any member function anymore on the object you deleted that way
p7689
aVBest do it as the last statement in a non-virtual, protected or private function
p7690
aVCalling delete is valid in a virtual and/or public function too, but i would restrict the visibility of the method doing that
p7691
aVThe C++ FAQ has an entry about that
p7692
aVC++ Standard quote on my claim above ():
p7693
aVBefore the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways
p7694
aV[
p7695
aVIf the object will be or was of a class type with a non-trivial destructor, and the pointer is used as the operand of a delete-expression, the program has undefined behavior
p7696
aVLifetime ends when the destructor of the object begins execution
p7697
aVNote there are exceptions to the rules coming after that paragraph for objects under construction and destruction (you are allowed to access non-static data members, for example), detailed at
p7698
as(dp7699
g15
V34509
p7700
stp7701
a((dp7702
g2
(lp7703
VIn C++ it is perfectly safe to call virtual functions from within the base-class - as long as they are non-pure - with some restrictions
p7704
aVHowever, you shouldn't do it
p7705
aVBetter initialize objects using non-virtual functions, which are explicitly marked as being such initialization functions using comments and an appropriate name (like )
p7706
aVIf it is even declared as pure-virtual in the class calling it, the behavior is undefined
p7707
aVThe version that's called is the one of the class calling it from within the constructor, and not some overrider in some derived class
p7708
aVThis hasn't got much to-do with virtual function tables, but more with the fact that the override of that function might belong to a class that's not yet initialized
p7709
aVSo this is forbidden
p7710
aVIn C# and Java, that's not a problem, because there is no such thing as a default-initialization that's done just before entering the constructor's body
p7711
aVIn C#, the only things that are done outside the body is calling base-class or sibling constructors i believe
p7712
aVIn C++, however, initializations done to members of derived classes by the overrider of that function would be undone when constructing those members while processing the constructor initializer list just before entering the constructors body of the derived class
p7713
aVEdit: Because of a comment, i think a bit of clarification is needed
p7714
aVHere's an (contrived) example, let's assume it would be allowed to call virtuals, and the call would result in an activation of the final overrider:
p7715
aVThat problem can indeed be solved by changing the C++ Standard and allowing it - adjusting the definition of constructors, object lifetime and whatnot
p7716
aVRules would have to be made to define what  means for a not-yet constructed object
p7717
aVAnd note how the effect of it then depends on who called
p7718
aVThe feature we get does not justify the problems we have to solve then
p7719
aVSo C++ simply forbids dynamic dispatch while the object is being constructed
p7720
as(dp7721
g15
V34509
p7722
stp7723
a((dp7724
g2
(lp7725
VYou mean an absolute path that's used when the program is started and that's favored when looking for libraries
p7726
aVis exactly that
p7727
aVIt will overwrite the default search path and stuff set in LD_LIBRARY_PATH
p7728
aVJust tell gcc to pass it through to the linker:
p7729
aVYou can make it show you the search processing (use  to make it give you more options):
p7730
as(dp7731
g15
V34509
p7732
stp7733
a((dp7734
g2
(lp7735
VYou possibly still execute the old gcc
p7736
aVTry making a symlink from  to your version of it, like
p7737
aVBeware of not removing an old "gcc" binary placed there, in case they placed not just a symlink
p7738
aVIf you can recompile your own gcc version, the safest is just use another prefix at configure time of gcc, something like  (i did it that way with gcc-4
p7739
aV4 from svn-trunk, and it worked great)
p7740
aVNote that that just runs the right gcc version
p7741
aVIf you update your gcc, your glibc won't be updated automatically too
p7742
aVIt's a separate package which is deeply coupled with the rest of the system
p7743
aVBe careful when installing another glibc version
p7744
as(dp7745
g15
V34509
p7746
stp7747
a((dp7748
g2
(lp7749
Vrmmod has a  parameter
p7750
aVIf you know the stuff your module does, and have a kernel configured to support forcing unload, that might work
p7751
aVThat's to save you from having to restart until you fixed the problem with the ref-counting), but it won't show you the cause of the load of your module
p7752
aVI think it's not possible to get why the module was loaded in the first place (i
p7753
aVe which exact code-path)
p7754
aVMaybe  has logged something useful or you can add some useful logging into your module code
p7755
as(dp7756
g15
V34509
p7757
stp7758
a((dp7759
g2
(lp7760
VMSDN explains how you do what popen does using the Windows API in Pipe Handle Inheritance
p7761
aVHere it provides a well-documented example
p7762
aVIt's way more low-level than the  function found in the runtime library linked by Jason, but uses the Win32 API exclusively
p7763
as(dp7764
g15
V34509
p7765
stp7766
a((dp7767
g2
(lp7768
VI'm going with
p7769
aVin my programs
p7770
aVFor copy constructors and operator=, i tend to call it
p7771
aVFor operators, i'm going with
p7772
aVBecause those are the left hand side and the right hand side of it
p7773
as(dp7774
g15
V34509
p7775
stp7776
a((dp7777
g2
(lp7778
VWell, here is what we have:
p7779
aVC++ allows overloading  and has templates to do the work for you, but doesn't allow dereferencing the null pointer
p7780
aVC allows dereferencing the null pointer, as long as the address is taken afterwards
p7781
aVIt also allows assigning  to any pointer to an object
p7782
aVWell, that's ideal
p7783
aVFirst, the C part, which is very easy
p7784
aVI don't understand your point that you cannot embed it into macros
p7785
aVIt works fine for me
p7786
aVNow, the C++ part
p7787
aVPut the stuff in nullp
p7788
aVhpp:
p7789
aVNow, all we need to do is to glue things together:
p7790
aVNow, you can use  and assign it to some pointer to some object-type
p7791
as(dp7792
g15
V34509
p7793
stp7794
a((dp7795
g2
(lp7796
VThere are a couple of difference
p7797
aVMost importantly, if you overflow the valid range of a char by assigning it a too big or small integer, and char is signed, the resulting value is implementation defined or even some signal (in C) could be risen, as for all signed types
p7798
aVContrast that to the case when you assign something too big or small to an unsigned char: the value wraps around, you will get precisely defined semantics
p7799
aVFor example, assigning a -1 to an unsigned char, you will get an UCHAR_MAX
p7800
aVSo whenever you have a byte as in a number from 0 to 2^CHAR_BIT, you should really use unsigned char to store it
p7801
aVThe sign also makes a difference when passing to vararg functions:
p7802
aVAssume the value assigned to c would be too big for char to represent, and the machine uses two's complement
p7803
aVMany implementation behave for the case that you assign a too big value to the char, in that the bit-pattern won't change
p7804
aVIf an int will be able to represent all values of char (which it is for most implementations), then the char is being promoted to int before passing to printf
p7805
aVSo, the value of what is passed would be negative
p7806
aVPromoting to int would retain that sign
p7807
aVSo you will get a negative result
p7808
aVHowever, if char is unsigned, then the value is unsigned, and promoting to an int will yield a positive int
p7809
aVYou can use unsigned char, then you will get precisely defined behavior for both the assignment to the variable, and passing to printf which will then print something positive
p7810
aVNote that a char, unsigned and signed char all are at least 8 bits wide
p7811
aVThere is no requirement that char is exactly 8 bits wide
p7812
aVHowever, for most systems that's true, but for some, you will find they use 32bit chars
p7813
aVA byte in C and C++ is defined to have the size of char, so a byte in C also is not always exactly 8 bits
p7814
aVAnother difference is, that in C, a unsigned char must have no padding bits
p7815
aVThat is, if you find CHAR_BIT is 8, then an unsigned char's values must range from 0
p7816
aV2^CHAR_BIT-1
p7817
aVTHe same is true for char if it's unsigned
p7818
aVFor signed char, you can't assume anything about the range of values, even if you know how your compiler implements the sign stuff (two's complement or the other options), there may be unused padding bits in it
p7819
aVIn C++, there are no padding bits for all three character types
p7820
as(dp7821
g15
V34509
p7822
stp7823
a((dp7824
g2
(lp7825
VYou can't change the way  displays errors
p7826
aVC and C++ put very little to no requirements on implementations in that regard, so that large parts of it are left unspecified, to allow them to be as flexible as possible
p7827
aVIf you want more precise control, you should use the functions of your runtime library or operation system interface
p7828
aVTry  (see ) in linux/unix or the CreateProcess function for windows systems, which uses the Windows API that allows great control over error handling and other stuff
p7829
as(dp7830
g15
V34509
p7831
stp7832
a((dp7833
g2
(lp7834
VI tend to use  for that
p7835
aVA quick google search showed me zsh also seem to support that:
p7836
aVThat doesn't split with zero bytes, but it will make it work with file-names containing whitespace other than newlines
p7837
aVIf the file-name appears at the very last of the command to be executed, you can use , working also with newlines in filenames:
p7838
aVcopies all files found into the directory
p7839
aVDownside of the xargs approach is that you don't have the filenames in a variable, of course
p7840
aVSo this not always applicable
p7841
as(dp7842
g15
V34509
p7843
stp7844
a((dp7845
g2
(lp7846
VMy favorite is Quanta+
p7847
aVIt has an excellent CSS editor:
p7848
as(dp7849
g15
V34509
p7850
stp7851
a((dp7852
g2
(lp7853
VIf I define a local variable instance of a class halfway down my function without using a pointer and new, does the constructor get called on entering the function or where it is defined
p7854
aVSuch variables have local scope
p7855
aVTheir constructor is called when they're defined
p7856
aVFor local statics, the constructor is only called once, since the statics will survive multiple function calls and returns
p7857
aVThe order is important, and is the order of definition:
p7858
aVIf I define another instance of a class globally within the file does that constructor get called when executable is first loaded
p7859
aVYes, such variable is said to have static storage duration, and namespace scope
p7860
aVIts constructor is called at program start
p7861
aVThe order is the order it is defined in the file
p7862
aVThat is, a variable defined later will have its ctor called later
p7863
aVThe order in which variables defined in different translation units is not defined (look-out for the static initialization order fiasco)
p7864
aVBut they are all called at program start
p7865
aVWhat if multiple threads are accessing the
p7866
aVdll
p7867
aVAll bets are off
p7868
aVThe variable is only constructed once
p7869
aVAfter that, when you start threads and access it, the variable has to be thread safe, or the threads has to do proper locking when accessing the variable
p7870
as(dp7871
g15
V34509
p7872
stp7873
a((dp7874
g2
(lp7875
VContrary to what many people believe, you can actually create an array of objects that do not have a default constructor
p7876
aVWhat you cannot do is make it use a set of arguments for all constructor invokations
p7877
aVYou just have to initialize all elements of it
p7878
aVThat is, you can do the following:
p7879
aVThat will initialize all 50 elements with 1
p7880
aVis used to print a  50 times in a row automatically
p7881
as(dp7882
g15
V34509
p7883
stp7884
a((dp7885
g2
(lp7886
VIf the function is small (the chance you would change it often is low), and if the function can be put into the header without including myriads of other headers (because your function depends on them), it is perfectly valid to do so
p7887
aVIf you declare them extern inline, then the compiler is required to give it the same address for every compilation unit:
p7888
aVheadera
p7889
aVh:
p7890
aVMember functions are implicit inline provided they are defined inside their class
p7891
aVThe same stuff is true for them true: If they can be put into the header without hassle, you can indeed do so
p7892
aVBecause the code of the function is put into the header and visible, the compiler is able to inline calls to them, that is, putting code of the function directly at the call site (not so much because you put inline before it, but more because the compiler decides that way, though
p7893
aVPutting inline only is a hint to the compiler regarding that)
p7894
aVThat can result in a performance improvement, because the compiler now sees where arguments match variables local to the function, and where argument doesn't alias each other - and last but not least, function frame allocation isn't needed anymore
p7895
aVMy understanding is when the compilation is done, compiler will expand the header file and place it where it is included
p7896
aVIs that correct
p7897
aVYes, that is correct
p7898
aVThe function will be defined in every place where you include its header
p7899
aVThe compiler will care about putting only one instance of it into the resulting program, by eliminating the others
p7900
as(dp7901
g15
V34509
p7902
stp7903
a((dp7904
g2
(lp7905
VI can't think of many useful examples
p7906
aVA class without data-members has no state and thus can't initialize anything
p7907
aVYou can have the constructor/destructor do logging for you, though
p7908
aVFor example, to log the creation/destruction of all Visitor objects:
p7909
as(dp7910
g15
V34509
p7911
stp7912
a((dp7913
g2
(lp7914
Vis from ImageMagick
p7915
aV">" says it's only resized if larger
p7916
aVSee here for its other options
p7917
as(dp7918
g15
V34509
p7919
stp7920
a((dp7921
g2
(lp7922
VThe important difference is that the first default initializes the array in an element-specific manner: Pointers will receive a null pointer value, which doesn't need to be 0x00 (as in all-bits-zero), booleans will be false
p7923
aVIf the element type is a class type that's not a so-called POD (plain old data-type), then you can only do the first one, because the second one only works for the simplest cases (where you don't have virtual functions, user defined constructors and so on)
p7924
aVIn contrast, the second way using the memset sets all elements of the array to all-bits-zero
p7925
aVThat is not always that what you want
p7926
aVIf your array has pointers for example, they won't be set to null-pointers necessarily
p7927
aVThe first will default initialize the elements of the array, except for the first one, which is set to 0 explicitly
p7928
aVIf the array is local and on the stack (that is, not a static), the compiler internally often does a memset to clear the array out
p7929
aVIf the array is non-local or static, the first version can be considerably more efficient
p7930
aVThe compiler can put the initializers already, at compile time, into the generated assembler code, making it require no runtime code at all
p7931
aVAlternatively, the array can be laid out on a section that is automatically zero'd out (also for pointers, if they have a all-bits-zero representation) when the program starts in a fast manner (i
p7932
aVe page-wise)
p7933
aVThe second does a memset explicitly over the whole array
p7934
aVOptimizing compilers will usually replace a memset for smaller regions with inline machine code that just loops using labels and branches
p7935
aVHere is assembler-code generated for the first case
p7936
aVMy gcc stuff isn't much optimized, so we got a real call to memset (16 bytes at the stack-top are always allocated, even if we got no locals
p7937
aV$n is a register number):
p7938
aVThe gory details from the C++ Standard
p7939
aVThe first case above will default-initialize remaining elements
p7940
ag1240
aVTo zero-initialize storage for an object of type T means:
p7941
aVif T is a scalar type, the storage is set to the value of 0 (zero) converted to T;
p7942
aVif T is a non-union class type, the storage for each nonstatic data member and each base-class subobject is zero-initialized;
p7943
aVif T is a union type, the storage for its first data member is zero-initialized;
p7944
aVif T is an array type, the storage for each element is zero-initialized;
p7945
aVif T is a reference type, no initialization is performed
p7946
aVTo default-initialize an object of type T means:
p7947
aVif T is a non-POD class type, the default constructor for T is called
p7948
aVif T is an array type, each element is default-initialized;
p7949
aVotherwise, the storage for the object is zero-initialized
p7950
ag1240
aVIf there are fewer initializers in the list than there are members in the aggregate,
p7951
aVthen each member not explicitly initialized shall be default-initialized (8
p7952
aV5)
p7953
as(dp7954
g15
V34509
p7955
stp7956
a((dp7957
g2
(lp7958
VYes, it's perfectly safe
p7959
aVThe lifetime of local statics are that of the entire program execution in C
p7960
aVSo you can return a pointer to it, since the array will be alive even after the function returns, and the pointer returned can validly de-referenced
p7961
as(dp7962
g15
V34509
p7963
stp7964
a((dp7965
g2
(lp7966
VI prefer  and Process Substitution feature of bash:
p7967
aVSaying on position 2, a b occurs for the first, but a q for the second
p7968
aVAt position 5, another difference is happening
p7969
aVJust replace those strings by variables, and you are done
p7970
as(dp7971
g15
V34509
p7972
stp7973
a((dp7974
g2
(lp7975
VThis is a classic example of
p7976
aVYou can create the vector right from the start on, if you wish
p7977
aVRemember to put parentheses around the first argument
p7978
aVThe compiler thinks it's a function declaration otherwise
p7979
aVIf you use the vector for just getting iterators for the numbers, you can use the istream iterators directly:
p7980
as(dp7981
g15
V34509
p7982
stp7983
a((dp7984
g2
(lp7985
VTrying to collect some uses:
p7986
aVBinding some temporary to reference-to-const, to lengthen its lifetime
p7987
aVThe reference can be a base - and the destructor of it doesn't need to be virtual - the right destructor is still called:
p7988
aVExplanation, using code:
p7989
aVThis trick is used in Alexandrescu's ScopeGuard utility class
p7990
aVOnce the temporary goes out of scope, the destructor of Derived is called correctly
p7991
aVThe above code misses some small details, but that's the big deal with it
p7992
aVUse const to tell others methods won't change the logical state of this object
p7993
aVUse const for copy-on-write classes, to make the compiler help you to decide when and when not you need to copy
p7994
aVExplanation: You might want to share data when you copy something as long as the data of the originally and the copie'd object remain the same
p7995
aVOnce one of the object changes data, you however need now two versions: One for the original, and one for the copy
p7996
aVThat is, you copy on a write to either object, so that they now both have their own version
p7997
aVUsing code:
p7998
aVThe above snippet prints the same address on my GCC, because the used C++ library implements a copy-on-write
p7999
aVBoth strings, even though they are distinct objects, share the same memory for their string data
p8000
aVMaking  non-const will prefer the non-const version of the  and GCC will create a copy of the backing memory buffer, because we could change it and it must not affect the data of
p8001
aVFor the copy-constructor to make copies from const objects and temporaries:
p8002
aVFor making constants that trivially can't change
p8003
aVFor passing arbitrary objects by reference instead of by value - to prevent possibly expensive or impossible by-value passing
p8004
as(dp8005
g15
V34509
p8006
stp8007
a((dp8008
g2
(lp8009
V is the stuff that should be talked about in a
p8010
aVThis thread is off-topic for example, because it's not about programming :)
p8011
as(dp8012
g15
V34509
p8013
stp8014
a((dp8015
g2
(lp8016
VI try to avoid using var-arg c-style functions for two main reasons:
p8017
aVThey are not type-safe, can't use operator<<
p8018
aVThey don't recognize when too few or many arguments were provided
p8019
aVI've made a way that works using , which is given arguments in a type-safe way
p8020
aVIt iterates over those arguments, printing out them when a  is encountered
p8021
aVIf too few or too many arguments were given, an exception is thrown
p8022
aVThere is one problem still: Variadic macros are not yet standard in C++
p8023
aVSo, i have made two versions
p8024
aVOne that work with current C++
p8025
aVYou have to invoke it using
p8026
aVThen
p8027
aVThe other version, using variadic macros, can be used by defining a preprocessor symbol, which enables you to write
p8028
aVHere is the code
p8029
aVThe  provides more details for this:
p8030
as(dp8031
g15
V34509
p8032
stp8033
a((dp8034
g2
(lp8035
VYou seem to want to validate a string as input
p8036
aVIt depends on whether you want to validate that your string contains a double or a int
p8037
aVThe following checks for a double (leading and trailing whitespace is allowed)
p8038
aVwill return the items converted (without '%n')
p8039
aVwill be set to the amount of the processed input characters
p8040
aVIf all input was processed, s[n] will return the terminating 0 character
p8041
aVThe space between the two format specifiers accounts for optional trailing whitespace
p8042
aVThe following checks for an int, same techniques used:
p8043
aVThere was a question on that here, which include also more C++'ish ways for doing this, like using string streams and functions from boost, like lexical_cast and so on
p8044
aVThey should generally be preferred over functions like scanf, since it's very easy to forget to pass some '%' to scanf, or some address
p8045
aVscanf won't recognize that, but instead will do arbitrary things, while lexical_cast, for instance, will throw an exception if anything isn't right
p8046
as(dp8047
g15
V34509
p8048
stp8049
a((dp8050
g2
(lp8051
VIt's the reason that makes your code work for generic parameters
p8052
aVConsider a container C:
p8053
aVIt would be annoying to introduce special cases for built-in types
p8054
aVSo C++ allows you to do the above, even if T happens to equal to
p8055
aVThe holy Standard says in :
p8056
aVThe notation for explicit call of a destructor can be used for any scalar type name
p8057
aVAllowing this makes it possible to write code without having to know if a destructor exists for a given type
p8058
aVThe difference between using a plain int and a typedef'ed int is that they are syntactically different things
p8059
aVThe rule is, that in a destructor call, the thing after the  is a type-name
p8060
aVis not such a thing, but a typedef-name is
p8061
aVLook it up in
p8062
as(dp8063
g15
V34509
p8064
stp8065
a((dp8066
g2
(lp8067
VNote, Herb Sutter wrote 3 excellent articles about multiple inheritance (1) here, (2) here and (3) here
p8068
aVHe wrote a whole other bunch of useful articles in guru-of-the-week here
p8069
aVHighly recommended
p8070
aVFirst, i'm not sure that i get your hierarchy right
p8071
aVI take it it is like this:
p8072
aVWell, D is abstract, because there are two  subobjects in an object of type D: One that is made concrete by  through the lattice of B, and one that is still abstract in the lattice going through
p8073
aVI take it you have a pointer to  and try to call
p8074
aVYes, an ambiguity arises, because the compiler finds two functions  in two separate lattices:
p8075
aVLooking like this:
p8076
aVYou can fix that situation formally by deriving from A virtually:
p8077
aVYou then have this situation, called diamond inheritance:
p8078
aVAnd doing the lookup, it finds that there is  overriding
p8079
aVAlthough  can still be reached through , that is not an ambiguity anymore, because  was inherited virtual
p8080
aVWhether this is the correct solution in your particular problem - that's of course not certain
p8081
aVThere are most often better ways than deriving virtual from a class
p8082
aVTo your question about merging of virtual function tables - that's completely depending on the implementation
p8083
aV, as far as i know, will keep a pointer to the one A instance in the virtual table of , if we derive virtual
p8084
as(dp8085
g15
V34509
p8086
stp8087
a((dp8088
g2
(lp8089
VIt's easy, Daniel:
p8090
aVThat doesn't look like a function called "Example", does it
p8091
aVA function has a return value, a name and parameters
p8092
aVHow would the above fit that
p8093
aVExample e1(); // this works
p8094
aVYeah, because you don't create any instance of  anywhere
p8095
aVYou just tell the code that there is a function defined in the surrounding namespace somewhere, and you possibly want to call that function
p8096
aVYes, it's true that in order to return a object of Example, an instance would be made
p8097
aVBut that doesn't mean an instance is made at that point
p8098
aVRather, an instance is made in the function, when you call it
p8099
as(dp8100
g15
V34509
p8101
stp8102
a((dp8103
g2
(lp8104
VYour number already has 2 decimal places
p8105
aVWhy do you need to use printf then
p8106
aVIf i remember correctly (haven't got a shell for testing here), it just pads the number up to 2 decimals when used with those flags
p8107
aVPersonally, i like xargs:
p8108
aVYou can use the  argument for , which pads the numbers with zeros if necessary, so they have all the same width
p8109
aVIt turns out  is linux specific
p8110
aVThanks for Dave in the comments for figuring it out (his answer)
p8111
aVUse  directly, without a loop:
p8112
aVI like to use , because it allows easily running your commands in parallel up to some limit, can pass more than one number at once and allows other flexible options
p8113
aVLike Dave, i recommend you to drop the  from it, and place it into your shell script, as first line instead:
p8114
aVThen just execute your stuff as
p8115
aVThis is more generic, and allows your script also to be called by the  C library calls (at least in Linux, that's the case)
p8116
as(dp8117
g15
V34509
p8118
stp8119
a((dp8120
g2
(lp8121
VThe above , without the _c because we have a plain bool, looks like this:
p8122
aVBoost's  takes not a plain bool, so they have another version which has a _c appended, that takes plain bools
p8123
aVYou won't be able to call it for  < 10
p8124
aVSFINAE will exclude that template as possible candidates, because  will not expose a type  if the condition evaluates to
p8125
aVIf you want, for some reason, test it in the function, then if you have the C++1x feature available, you can use :
p8126
aVIf not, you can use BOOST_STATIC_ASSERT:
p8127
aVThe only way to display a descriptive message is using static_assert, though
p8128
aVYou can more or less simulate that, using types having names that describe the error condition:
p8129
aVIt prints this here:
p8130
aVerror: invalid application of 'sizeof' to incomplete type 'detail::number1_greater_than_10'
p8131
aVBut I think the very first approach, using  will do it
p8132
aVYou will get an error message about an undeclared
p8133
as(dp8134
g15
V34509
p8135
stp8136
a((dp8137
g2
(lp8138
VLooks like you assign a member function pointer to a function of the derived class to a member function pointer to a function of the base class
p8139
aVWell, that's forbidden, because it opens up a hole in the type-system
p8140
aVIt comes at a surprise (at least for me, the first time i heard that)
p8141
aVRead this answer for why
p8142
aVTo answer your actual question - i would make  a template:
p8143
aVChange  in the base-class to this:
p8144
aVBetter use , because it will tell you if  isn't actually derived from
p8145
as(dp8146
g15
V34509
p8147
stp8148
a((dp8149
g2
(lp8150
VUsually you should prefer  over plain char pointers
p8151
aVHere, however, the char pointer initialized with the string literal has a significant benefit
p8152
aVThere are two initializations for static data
p8153
aVThe one is called static initialization, and the other is called dynamic initialization
p8154
aVFor those objects that are initialized with constant expressions and that are PODs (like pointers), C++ requires that their initialization happens at the very start, before dynamic initialization happens
p8155
aVInitializing such an std::string will be done dynamically
p8156
aVIf you have an object of a class being a static object in some file, and that one needs to access the string during its initialization, you can rely on it being set-up already when you use the  version, while using the  version, which isn't initialized statically, you don't know whether the string is already initialized - because the order of initialization of objects across translation unit boundaries is not defined
p8157
as(dp8158
g15
V34509
p8159
stp8160
a((dp8161
g2
(lp8162
VAs others point out, you have the order of the cast and the  wrong
p8163
aVBut why do you use  at all
p8164
aVThat means that you accept a pointer to a void pointer
p8165
aVBut that's not at all what you want
p8166
aVJust make the parameter a , and it will accept any pointer to some object:
p8167
aVThat's what  is for
p8168
aVLater, cast it back using
p8169
aVThat's a quite restrictive cast, that doesn't allow dangerous variants, unlike the C style cast (type):
p8170
aVIf the function takes pointers to , then that function can't accept pointers to
p8171
aVBut if the function accepts either or, then the function should accept , and you should cast to the proper type inside the function
p8172
aVMaybe paste what you really want to do, we can help you better then
p8173
aVC++ has some good tools available, including templates and overloading, both of which sound helpful in this case
p8174
as(dp8175
g15
V34509
p8176
stp8177
a((dp8178
g2
(lp8179
VIt's definitely possible and works fine, but i would avoid it
p8180
aVIt obscures diagnostics
p8181
aVGCC will display the name of the exception type, with the usual template stuff included
p8182
aVI would take the few minutes to define the new exception class, personally
p8183
aVIt's not like you would do it all the time
p8184
as(dp8185
g15
V34509
p8186
stp8187
a((dp8188
g2
(lp8189
V is not a keyword
p8190
aVIt's an identifier defined in some standard headers
p8191
aVYou can include
p8192
aVTo have it in scope, including some other basics, like
p8193
as(dp8194
g15
V34509
p8195
stp8196
a((dp8197
g2
(lp8198
VUsing a menu is a no-go, because  can't put widgets on a menu
p8199
aVUsing the shaped frame would be possible in principle, but the problem is then to get the position of the button you clicked, to display the window at the right position
p8200
aVI tried to do that back then, but didn't have luck (in C++ wxWidgets)
p8201
aVMaybe this situation changed in between though, good luck
p8202
aVYou can also try a , which allows you to have a custom popup window
p8203
aVThat one could then display the radio boxes and the input control
p8204
as(dp8205
g15
V34509
p8206
stp8207
a((dp8208
g2
(lp8209
VI'm going to put a graphic
p8210
as(dp8211
g15
V34509
p8212
stp8213
a((dp8214
g2
(lp8215
VA simple way to do this is using standard input and output:
p8216
as(dp8217
g15
V34509
p8218
stp8219
a((dp8220
g2
(lp8221
VThere isn't an end-of-file character really
p8222
aVWhen you press Ctrl-d or similar characters, the terminal driver signals to the reading application that the end of file has been reached, by returning an invalid value
p8223
aVThe same is done by the operation system, when you have reached the end of the file
p8224
aVThis is done by using an integer instead of a byte (so you have range similar to -2^16
p8225
aV2^16, instead of only 0
p8226
aV255) and returning an out-of-range value - usually
p8227
aVBut there is no character that would represent , because its whole purpose is to be not a character
p8228
aVIf you want to read everything from stdin, up until the end of file, try
p8229
aVThat will however read the whole standard input into the variable
p8230
aVYou can get away with only allocating memory for one line using an array, and make  read words of a line into that array:
p8231
as(dp8232
g15
V34509
p8233
stp8234
a((dp8235
g2
(lp8236
VGood article by Jon Skeet about your question's topic: String conversions - the Good, the Okay-I-Suppose, and the Utterly Horrible
p8237
as(dp8238
g15
V34509
p8239
stp8240
a((dp8241
g2
(lp8242
VOn the shell,  can be used to queue parallel command processing
p8243
aVFor example, for having always 3 sleeps in parallel, sleeping for 1 second each, and executing 10 sleeps in total do
p8244
aVAnd it would sleep for 4 seconds in total
p8245
aVIf you have a list of names, and want to pass the names to commands executed, again executing 3 commands in parallel, do
p8246
aVWould execute the command ,  and so on
p8247
as(dp8248
g15
V34509
p8249
stp8250
a((dp8251
g2
(lp8252
VThe problem is that your copy constructor doesn't accept the temporary that you give the throw
p8253
aVIt's a temporary and thus an rvalue
p8254
aVA reference-to-nonconst, namely  can't bind to it
p8255
aVRead here on the details
p8256
aVAs a comment on that answer suggests, the microsoft compiler had a bug that made it bind references that point to non-const objects accept rvalues
p8257
aVYou should change your copy-constructor to this:
p8258
aVTo make it work
p8259
aVIt says the bug was fixed in Visual C++ 2005
p8260
aVSo you would get the same problem with that version onwards
p8261
aVSo better fix that problem right away
p8262
as(dp8263
g15
V34509
p8264
stp8265
a((dp8266
g2
(lp8267
VIt entirely depends on what that error condition is, and what the method's job is
p8268
aVIf returning  is a valid way of handling that error for the calling function, why would it be bad
p8269
aVOften, however, it is a smell
p8270
aVConsider this:
p8271
aVThat is a very big code smell, because you don't expect a double value
p8272
aVYou just want to know whether a string contains a double
p8273
aVSometimes, the framework you use doesn't have other ways of doing what you want
p8274
aVFor the above, there is a better way:
p8275
aVThat kind of exceptions have a special name, coined by some dude whose blog i read recently
p8276
aVBut sadly, i forgot its name
p8277
aVPlease comment if you know it
p8278
aVLast but not least, the above is pseudo code
p8279
aVI'm not a c# developer so the above doesn't compile, I'm sure, but TryParseInt32 / ParseInt32 demonstrates that well i think so i'm going with C#
p8280
aVNow, to your code
p8281
aVLet's inspect two functions
p8282
aVOne smells, and the other doesn't:
p8283
ag2790
aVSmell
p8284
aVThat's a code smell, because when you want to setup a system, you don't want it to fail
p8285
aVFailing to setup a system means you can't continue without handling that error
p8286
ag976
aVOk
p8287
aVThat is ok, because the purpose of that method is to test whether the workstation is still reachable
p8288
aVIf it's not, then that is part of the result of that method, and not an exceptional case that needs an alternative return path
p8289
as(dp8290
g15
V34509
p8291
stp8292
a((dp8293
g2
(lp8294
VWhat do you mean by "portable wchar_t"
p8295
aVThere is a  type that is 16bits wide everywhere, which is often available
p8296
aVBut that of course doesn't make up a string yet
p8297
aVA string has to know of its encoding to make sense of functions like ,  and so on (so it doesn't cut characters in the middle of a code point when using utf8 or 16)
p8298
aVThere are some unicode compatible string classes i know of that you can use
p8299
aVAll can be used in commercial programs for free (the Qt one will be compatible with commercial programs for free in a couple of months, when Qt 4
p8300
aV5 is released)
p8301
aVfrom the  project
p8302
aVIf you program with gtkmm or use glibmm, that should be the first choice, it uses  internally
p8303
aValso has a string class, called QString
p8304
aVIt's encoded in
p8305
aVis another project that creates portable unicode string classes, and has a  class that internally seems to be encoded in utf-16, like Qt
p8306
aVHaven't used that one though
p8307
as(dp8308
g15
V34509
p8309
stp8310
a((dp8311
g2
(lp8312
VYes, you can use this trick:
p8313
aVIf t is 0 in the specialization, it will match the default argument, and the specialization is taken
p8314
aVOtherwise, the primary template is taken
p8315
aVEdit: What the heck does the third parameter mean
p8316
aVWell, it's a default and it's 0
p8317
aVIt will be passed when we name the specialization  for example
p8318
aVBut really, we instantiate a template with the arguments , because the last is a default argument
p8319
aVThe partial specialization matches, when the third parameter matches the third argument, which is zero by default, and if the third and second arguments are the same, because both are
p8320
aVThe above trick has the drawback that also  uses our specialization
p8321
aVBut on the other side, the above is remarkable simple, so that you can probably get away with that
p8322
aVIf you don't want that to work, then you can use , which is a bit more complicated:
p8323
aVNow, even if you say , our partial specialization won't be chosen, because the condition  isn't true, and  will thus not be available
p8324
aVSFINAE doesn't chose the specialization then
p8325
aVOf course, with this enable_if solution, you are not limited to t being zero
p8326
aVAny condition will do
p8327
aVFor reference, here is the code of enable_if, if you don't use boost
p8328
aVCut the  suffix above then, which we don't need for the version below:
p8329
as(dp8330
g15
V34509
p8331
stp8332
a((dp8333
g2
(lp8334
VBecause C++ is not Java
p8335
aVYou can take the address of a member:
p8336
aVSo you can't have two members have the same name, except that you can overload member functions
p8337
aVEven if you could disambiguate that by some kind of cast, the next problem would already arise at other places
p8338
aVIn C++, a lot of people including me usually call data members specially, like putting a  before their name
p8339
aVThis avoids the problem:
p8340
as(dp8341
g15
V34509
p8342
stp8343
a((dp8344
g2
(lp8345
VIn linux, you can use the  system-call:
p8346
aVIf you can't get enough of it, you can go one step lower, invoking the syscall generically:
p8347
aVIt's worth knowing about , which you can use to see which syscalls are used by any particular program while it runs
p8348
aVBut note that for "some simple parser", it's hardly needed to use raw system calls
p8349
aVBetter use the functions of the c library
p8350
aVBy the way, lookout for WriteFile and GetStdHandle functions if you want to do the above in Windows without using the c standard library
p8351
aVWon't be as l33t as the linux solution though
p8352
as(dp8353
g15
V34509
p8354
stp8355
a((dp8356
g2
(lp8357
VWhat's wrong with it
p8358
aVThe code as you have it there - i can't find a bug
p8359
aVThe only problem i spot is that if you provide no number at all, then this part will cause harm:
p8360
aVIt will subtract one from 0u
p8361
aVThat will wrap around, because  returns an unsigned integer type
p8362
aVYou will end up with a very big value, somewhere around 2^16 or 2^32
p8363
aVYou should change the whole while condition to
p8364
aVYou can try looking for a bug around the call side
p8365
aVOften it happens there is a buffer overflow or heap corruption somewhere before that, and the program crashes at a later point in the program as a result of that
p8366
aVThe argument and parameter stuff in it
p8367
aVConcerning the array and how it's passed, i think you do it alright
p8368
aVAlthough, you still pass the array by value
p8369
aVMaybe you already know it, but i will repeat it
p8370
aVYou really pass a pointer to the first element of this array:
p8371
aVA 2d array really is an array of arrays
p8372
aVThe first lement of that array is an array, and a pointer to it is a pointer to an array
p8373
aVIn that case, it is
p8374
aVEven though in the parameter list you said that you accept an array of arrays, the compiler, as always, adjusts that and make it a pointer to the first element of such an array
p8375
aVSo in reality, your function has the prototype, after the adjustments of the argument types by the compiler are done:
p8376
aVAlthough often suggested, You cannot pass that array as a , because the called function needs the size of the inner dimension, to correctly address sub-dimensions at the right offsets
p8377
aVWorking with a  in the called function, and then writing something like , it will try to interpret the first sizeof(char**) characters of that array as a pointer, and will try to dereference a random memory location, then doing that a second time, if it didn't crash in between
p8378
aVDon't do that
p8379
aVIt's also not relevant which size you had written in the outer dimension of that array
p8380
aVIt rationalized away
p8381
aVNow, it's not really important to pass the array by reference
p8382
aVBut if you want to, you have to change the whole thingn to
p8383
aVPassing by reference does not pass a pointer to the first element: All sizes of all dimensions are preserved, and the array object itself, rather than a value, is passed
p8384
as(dp8385
g15
V34509
p8386
stp8387
a((dp8388
g2
(lp8389
VDoesn't sound too complicated
p8390
aVYou can define the iterator outside
p8391
aVYou can also use typedefs
p8392
aVSomething like this would fit i think
p8393
aVNote that it would be way cleaner if that MagicIterator would be not a free template, but a member of Item, typedefed in Container maybe
p8394
aVAs it's now, there is a cyclic reference in it, which make it necassary to write some ugly workaround code
p8395
aVNow, start using it:
p8396
aVYou can also use a iterator mixin provided by boost, which works like the input version of boost::function_output_iterator
p8397
aVIt calls your iterator's  which then returns the appropriate value, doing what we do above in our  in principle
p8398
aVYou find it in
p8399
aVThat would probably result in fewer code
p8400
aVBut it also requires to wrack up our neck to ensure the friend-stuff because Item is private and the iterator isn't defined inside Item
p8401
aVAnyway, good luck :)
p8402
as(dp8403
g15
V34509
p8404
stp8405
a((dp8406
g2
(lp8407
VHmm, the Standard says in :
p8408
aVIf, in the declaration of a function template with a non-type template-parameter, the non-type template-parameter is used in an expression in the function parameter-list and, if the corresponding template-argument is deduced, the template-argument type shall match the type of the template-parameter exactly, except that a template-argument deduced from an array bound may be of any integral type
p8409
aVProviding this example:
p8410
aVThat suggests that the compilers that fail to compile your code (apparently GCC and Digital Mars) do it wrong
p8411
aVI tested the code with Comeau, and it compiles your code fine
p8412
aVI don't think there is a different to whether the type of the non-type template parameter depends on the type of the type-parameter or not
p8413
aVsays the template arguments should be deduced independent from each other, and then combined into the type of the function-parameter
p8414
aVCombined with /15, which allows the type of the dimension to be of different integral type, i think your code is all fine
p8415
aVAs always, i take the c++-is-complicated-so-i-may-be-wrong card :)
p8416
aVUpdate: I've looked into the passage in GCC where it spits out that error message:
p8417
aVIt seems to have missed to mark the type of the size as dependent in an earlier code block
p8418
aVAs that type is a template parameter, it is a dependent type (see )
p8419
aVUpdate: GCC developers fixed it: Bug #38950
p8420
as(dp8421
g15
V34509
p8422
stp8423
a((dp8424
g2
(lp8425
VYou can use an unsigned char to read the float byte by byte into the integer array:
p8426
aVBy the way, if you just want to compare the bits (as you comment on another answer) use :
p8427
as(dp8428
g15
V34509
p8429
stp8430
a((dp8431
g2
(lp8432
VThe type you pass to  is the function type
p8433
aVFor example,  is the type of a function returning int and taking a bool and a char
p8434
aVThat said, if you want to construct the shared_ptr right away, you don't need to store the functor somewhere ( requires the  operator for that, even though for very small functors, it will use special tricks to only use stack allocation (small buffer optimization)):
p8435
aVboost::function is part of  and will be part of the next official C++ Standard
p8436
aVExample:
p8437
as(dp8438
g15
V34509
p8439
stp8440
a((dp8441
g2
(lp8442
VTry this:
p8443
aVTo list all functions in the file myfile
p8444
ag3601
aVTo count the number of functions in :
p8445
as(dp8446
g15
V34509
p8447
stp8448
a((dp8449
g2
(lp8450
VYou can find out with :
p8451
as(dp8452
g15
V34509
p8453
stp8454
a((dp8455
g2
(lp8456
VJust telling you about one other possibility: I like using friend definitions for that:
p8457
aVThe function will be automatically targeted into the surrounding namespace  (even though its definition appears within the scope of that class) but will not be visible unless you call operator<< with a Matrix object which will make argument dependent lookup find that operator definition
p8458
aVThat can sometimes help with ambiguous calls, since it's invisible for argument types other than Matrix
p8459
aVWhen writing its definition, you can also refer directly to names defined in Matrix and to Matrix itself, without qualifying the name with some possibly long prefix and providing template parameters like
p8460
as(dp8461
g15
V34509
p8462
stp8463
a((dp8464
g2
(lp8465
VI say it depends on the type of the iterator variable
p8466
aVIf you know it's an integer, i would use the second, because you can say
p8467
aVLoop, as long as i is smaller than n
p8468
aVWhich i think is easier to read for most programmers, including myself
p8469
aVIf you don't know the type of the iterator variable, you should make as least assumptions about its capabilities as possible
p8470
aVThe  may not be available for : If it is any iterator other than a random access iterator,  is not guaranteed to be available
p8471
aVIn this case i would use
p8472
aVI would avoid preferring option  just because you could accidentally "step over" the end value
p8473
aVI think the argument is flawed
p8474
aVBecause if you did accidentally step over, then that is a bug and it should be noticed as soon as possible (Fail-fast)
p8475
as(dp8476
g15
V34509
p8477
stp8478
a((dp8479
g2
(lp8480
V doesn't clear the standard input
p8481
aVWhat it does is clearing error bits, like ,  and others, and sets the stream into a good state
p8482
aVMaybe you expected it to clear out anything in it
p8483
aVIf the user typed
p8484
aVJust before, and you
p8485
aVIt will read up to  and the stream will still contain
p8486
aVThe call to  then clears any error bits being active
p8487
aVThen, your
p8488
aVWill read the  that wasn't eaten by the previous read, and the action immediately returns, not waiting for new input
p8489
aVWhat you should do is doing a  followed by an ignore, up to the next newline
p8490
aVYou tell it the amount of characters it should ignore maximally
p8491
aVThat amount should be the highest number possible:
p8492
aVDoing that will make the stream empty, and a following read will wait for you to type something in
p8493
aVAnother problem arises if you have got a  followed by a : The cin will leave any whitespace (also newlines) after its read token, but  will stop reading after it hits such a newline
p8494
aVI see you have put  after nearly everything
p8495
aVSo i want to show you when you need it and when not
p8496
aVYou don't need it when you sequence multiple
p8497
aVAssume you have in your buffer: "foo\u005cnbar\u005cn"
p8498
aVThen you do the following reads
p8499
aVAfter the first, your buffer will contain "\u005cnbar\u005cn"
p8500
aVThat is, the newline is still in
p8501
aVThe second  will first skip all whitespace and newlines, so that it can cope with  being at the front of
p8502
aVNow, you can also sequence multiple  calls:
p8503
aVGetline will throw away the  that it reads at the line end, but won't ignore newlines or whitespace at the begin
p8504
aVSo, after the first getline, the buffer contains "bar\u005cn"
p8505
aVThe second getline will correctly read "bar\u005cn" too
p8506
aVNow, let's consider the case where you need the clear/ignore:
p8507
aVThe first will leave the stream as "\u005cnbar\u005cn"
p8508
aVThe getline then will see immediately the  at the begin, and will think it read an empty line
p8509
aVThus, it will immediately continue and not wait for anything, leaving the stream as "bar\u005cn"
p8510
aVSo, if you have a  after a  you should first execute the clear/ignore sequence, to clear out the newline
p8511
aVBut between  or 's, you should not do it
p8512
as(dp8513
g15
V34509
p8514
stp8515
a((dp8516
g2
(lp8517
VYou can use the library Boost
p8518
aVProcess
p8519
aVIt's not officially part of boost though
p8520
aVI've have seen it working nicely for others
p8521
aVUnfortunately, boost
p8522
aVprocess progress apparently has been stalled
p8523
aVpstreams is another (apparently active) project
p8524
aVCertainly worth a try i would say - but it's only for posix compatible operation systems
p8525
as(dp8526
g15
V34509
p8527
stp8528
a((dp8529
g2
(lp8530
VThe array must have a constant length
p8531
aVI mean a length that is the same for all objects of that class
p8532
aVThat is because the compiler has to know the size of each object, and it must be the same for all objects of that particular class
p8533
aVSo, the following would do it:
p8534
aVAnd in the cpp file:
p8535
aVI prefer to use an enumeration for that, because i won't have to define the static in the cpp file then:
p8536
aVIf you want to have a per-object size of the array, then you can use a dynamic array
p8537
aVis such one:
p8538
aVBest is to do as much initialization in the initialization list as possible
p8539
as(dp8540
g15
V34509
p8541
stp8542
a((dp8543
g2
(lp8544
VHave you had a look at Boost
p8545
aVAsio
p8546
aVIt's a networking library supporting both asynchronous and synchronous operation
p8547
aVI've made some experiments with it in the past, and found it quite useful
p8548
as(dp8549
g15
V34509
p8550
stp8551
a((dp8552
g2
(lp8553
VYou have to provide a type argument for the SharedVector template:
p8554
aVBecause that  type is not a template parameter in TCPClientManager, but an explicit chosen type, you don't need to put  before
p8555
as(dp8556
g15
V34509
p8557
stp8558
a((dp8559
g2
(lp8560
VI think your example usage is quite good
p8561
aVBecause if you would use an ordinary function pointer, and you then apply the address-of operator, you would get the address of the function pointer
p8562
aVUsing a reference to function will do the expected thing, in that it returns a pointer to the function itself
p8563
aVI also can't think of many examples
p8564
aVKeeping function references, as you point out, has some ugly consequences
p8565
aVAnother possibly unwanted consequence is, if kept as a class-member, your objects will be non-assignable if you don't write your own operator= and refrain from trying to re-assign the function-reference
p8566
aVI think most uses of function references are implicit, much like most uses of array-references - although much more so, when you accept arguments by-reference:
p8567
aVWhile accepting arrays by reference has the advantage of not losing their size information, accepting functions by reference explicitly doesn't seem to have an advantage (at least as far as I can see)
p8568
aVI suppose the existence of function references largely is justified by the idealistic view of a reference as an alias-name of some object or function, together with the fact that it allows passing functions to such templates that accept their argument by reference
p8569
aVI would probably avoid using them if I wouldn't need them inevitably
p8570
aVConstant function pointers also provide non-reassignable callables, and will probably avoid confusions when other programmers, who possibly are not very familiar with this language niches, read your code
p8571
aVWorth to note that Vandervoorde & Josuttis also recommend to avoid them to reduce confusion (in their book C++ Templates - The Complete Guide)
p8572
as(dp8573
g15
V34509
p8574
stp8575
a((dp8576
g2
(lp8577
VLet's put it like this:
p8578
aVand  are similar like  and  are similar
p8579
aVIn short, no C is not a subset of C#
p8580
aVThe look of many control structures base on C
p8581
aVLike, for-loops, switches, while and so on
p8582
aVAt the same time, C# forbids potentially dangerous constructs, like falling off a case in a switch when forgetting a break;, or putting an integer as an if condition where a boolean is expected
p8583
aVThe above quote means that C# and C can look very similar, but translate to vastly different results
p8584
aVWhere C will not prevent you from removing everything from your partition, C# will protect you from doing this by mistake, figuratively spoken
p8585
aVAt another level, C allows you to type-cast pointers to integers, push those around, cast back and then access memory locations that are then stored in that pointer
p8586
aVC will not protect you from accessing memory which isn't allocated by you
p8587
aVYou will get a crash - at best
p8588
aVC# - on the other side - will have exceptions that notice you when you do things like accessing object throgh a null-reference
p8589
as(dp8590
g15
V34509
p8591
stp8592
a((dp8593
g2
(lp8594
VI assume that you really wanted to write the following, instead of using  on the left side
p8595
aVSince otherwise, it's really just about checking whether the object in the list is of the right type
p8596
aVWell, Java is statically typed
p8597
aVIt's not possible that you give it a string and it gives you the corresponding static type, so that you can go without casting
p8598
aVEven with generics and , the cast destination type is not given by a string, but by the generic type-argument , which is known at compile-time
p8599
aVYou have to manually cast to the right type, or keep using the most common type (may be Object in your case)
p8600
aVIf you do , it gives you back an object of the type  which contains information about the type at runtime, so that it allows you to do
p8601
aVBut the cast wants a type - not an object of some type
p8602
aVThat is why the compiler told you there is something wrong with that code
p8603
aVThe static type of the reference returned by that is of
p8604
aVThis is important: The dynamic type of an object that is referenced, and the static type of the reference that points to that object
p8605
aVThe dynamic type of the object is what can be "controlled" by a string (by using ), but the static type of the reference that you have to do with at compile time, and that is (just to give an example) used to select functions that overload each other, can not be determined by a string
p8606
as(dp8607
g15
V34509
p8608
stp8609
a((dp8610
g2
(lp8611
VIt can crash because of many reasons
p8612
aVWithout knowing the definition of at least 's constructors, i think we are largely left to guess at the problem
p8613
aVSo far, your code looks fine, but it can be simplified:
p8614
aVIt won't do anything if the symbol is already mapped, discarding the new TheObject object
p8615
as(dp8616
g15
V34509
p8617
stp8618
a((dp8619
g2
(lp8620
VIt assigns an object that has a property "Get" to
p8621
aV"Get" is assigned an anonymous function, which will return a function that just returns the argument that was given to the first returning function
p8622
aVSounds strange, but here is how it can be used:
p8623
aVwill then contain a 10
p8624
aVInstead, you could have written the equivalent
p8625
aVThat is,  just assigns some value to a property
p8626
as(dp8627
g15
V34509
p8628
stp8629
a((dp8630
g2
(lp8631
VThe  will give you the size of the pointer
p8632
aVWhich is often 4 or 8 depending on your processor/compiler, but not the size of the string pointed to
p8633
aVYou can use strlen and strcpy:
p8634
aVI've seen some answers propose use of , but that's a posix function, and not part of C
p8635
as(dp8636
g15
V34509
p8637
stp8638
a((dp8639
g2
(lp8640
VI have a boost solution in the starts:
p8641
aVThis takes the ::second member of the pair, and pushes it forward to ApplyOnCondition's operator()
p8642
aVis the type of the map ( of course)
p8643
as(dp8644
g15
V34509
p8645
stp8646
a((dp8647
g2
(lp8648
VThe best way is setting it to NULL if it doesn't point to anything
p8649
aVGlobals, pointers in other namespaces, and local static pointers are automatically initialized to be null pointers
p8650
aVClass members and normal locals should be initialized to NULL manually if you need to test them against NULL (some people like to use  instead
p8651
aVOf course, that's fully equivalent)
p8652
aVThen, you can check against NULL, but also can pass the pointer right away to , because it won't have any effect to delete a null-pointer (guaranteed by the C++ Standard)
p8653
as(dp8654
g15
V34509
p8655
stp8656
a((dp8657
g2
(lp8658
VThey may not be optimized away because your compiler knows that such strings can be used for those purposes
p8659
aVOf course, the compiler is completely allowed to optimize it away, as long as the program's behavior, more exact the observable behavior, is not changed
p8660
aVThat means the sequence of writes and reads to volatiles, and the calls to library functions is not changed
p8661
aVBy optimizing such a string in your app away, i suppose that behavior won't change
p8662
aVBut compilers want to be usable and try to not strike in the users way
p8663
aVThat's why they contain useful extensions too
p8664
aVIf you want to be sure it's not optimized away on occasion though, maybe have a look into the compilers extensions
p8665
aVGCC has a  attribute, which makes it not emit warnings for unused objects
p8666
aVMaybe that or something similar can help you the variable isn't optimized away
p8667
aVFrom a language stand point, there isn's a utility though to force the compiler to keep it
p8668
aVEdit: There was a usenet post about that topic here, with useful answers
p8669
as(dp8670
g15
V34509
p8671
stp8672
a((dp8673
g2
(lp8674
VSince you ask about the difference in a loop, i guess you mean
p8675
aVIn that case, you have no difference in most languages: The loop behaves the same regardless of whether you write  and
p8676
aVIn C++, you can write your own versions of the ++ operators, and you can define separate meanings for them, if the  is of a user defined type (your own class, for example)
p8677
aVThe reason why it doesn't matter above is because you don't use the value of
p8678
aVAnother thing is when you do
p8679
aVNow, there is a difference, because as others point out,  means increment, but evaluate to the previous value, but  means increment, but evaluate to  (thus it would evaluate to the new value)
p8680
aVIn the above case,  is assigned the previous value of i, while i is incremented
p8681
as(dp8682
g15
V34509
p8683
stp8684
a((dp8685
g2
(lp8686
VYes, then you have one whole line in
p8687
aVIs it that what you wanted in that loop
p8688
aVThen instead of constructing the vector from the istream iterators, copy into the vector, and define the vector outside the loop:
p8689
aVYou actually don't need to read a line into the string first, if all you need is all words from a stream, and no per-line processing
p8690
aVJust read from the other stream directly like you did in your code
p8691
aVIt will not only read words from one line, but from the whole stream, until the end-of-file:
p8692
aVTo do all that manually, like you ask for in the comments, do
p8693
aVI recommend you to read a good book on this
p8694
aVIt will show you much more useful techniques i think
p8695
aVC++ Standard library by Josuttis is a good book
p8696
as(dp8697
g15
V34509
p8698
stp8699
a((dp8700
g2
(lp8701
VHeterogenous Container
p8702
aVIf you want to have a container that can store a fixed set of types, you can use one of :
p8703
aVNow, you can push_back into the vector either strings or integers, and the variant will note what it contains:
p8704
aVYou can read about it in its documentation at Boost variant, including how to get the right value out of the variant
p8705
aVYou can of course also have a map from argument names to such variants, if you have already set up your command line parsing, and don't need libraries for that anymore:
p8706
aVCommand line parsing
p8707
aVIf you want to parse the command line arguments of your program, you can look into the Boost
p8708
aVProgram Options library, which will greatly assist you doing that
p8709
aVMostly, however, i end up using the posix  function, which can also parse the command line
p8710
aVI recommend you to look into boost program options first, and if you feel it's too heavy, you can look into getopt (see )
p8711
as(dp8712
g15
V34509
p8713
stp8714
a((dp8715
g2
(lp8716
VFound the right answer after 3 months of searching :) It's in  of the Standard:
p8717
aVA template-parameter shall not be redeclared within its scope (including nested scopes)
p8718
aVA template-parameter shall not have the same name as the template name
p8719
aVExample:
p8720
aVIf the Microsoft compiler let it compile without errors or even warnings, it is not conforming
p8721
aVI don't know what could drive it to allow it without moaning
p8722
aVYou could try to high warning levels
p8723
as(dp8724
g15
V34509
p8725
stp8726
a((dp8727
g2
(lp8728
VYou don't have to use the heap if you want to use polymorphism, as you pointed out in your question
p8729
aVBut you often have no other choice
p8730
aVSmall contrived example:
p8731
aVYou can't use the stack, because at the moment you know what to do, 1a and 1b, every storage you get from the stack will be reclaimed when that scope is left again
p8732
aVYou have to use the heap because you need some storage that lasts that local scope
p8733
aVSome libraries advertise with them being able to not use the heap, but still behave polymorphic
p8734
aVThey usually do that with placement new:
p8735
aVThe new calls in 1a and 1b now use the buffer created on the stack as the storage for the created object
p8736
aVSo, no heap memory allocation is required anymore
p8737
aVThat form of allocation has the main disadvantage that it's currently not possible in C++ to tell whether the buffer is correctly aligned for the types ConcreteA and ConcreteB though
p8738
aVSo, it can be that the array is aligned on a 2 byte boundary, but the objects are required to be created on a 4 byte boundary, resulting in undefined behavior when you try to create those objects into that buffer
p8739
aVBoost
p8740
aVFunction is one of those libraries that use such a placement new approach to create objects of polymorphic types without using heap allocation using a small buffer (hence, what it does is called small buffer optimization)
p8741
as(dp8742
g15
V34509
p8743
stp8744
a((dp8745
g2
(lp8746
VAll the state information is stored in the static members of my and 3rd party's classes, so I don't have to create global variables
p8747
aVThat is the keypoint
p8748
aVNo, they should definitely not be put into classes
p8749
aVClasses are made to be used for creating objects
p8750
aVIn your situation, you would use them just as a scope, for the data and functions
p8751
aVBut this is what namespaces already solve better:
p8752
aVCreating classes that consist purely only of static members is a bad idea
p8753
as(dp8754
g15
V34509
p8755
stp8756
a((dp8757
g2
(lp8758
VI'd also go for the scripting language answer
p8759
aVUsing pure C++, i would probably use a parser generator, which will will get the token and grammar rules, and will give me C code that exactly can parse the given function call language, and provides me with an syntax tree of that call
p8760
aVcan be used to tokenize an input, and  can be used to parse the tokens and transform them into an syntax tree
p8761
aVAlternatively to that approach, Boost Spirit can be used to parse the function call language too
p8762
aVI have never used any of these tools, but have worked on programs that use them, thus i somewhat know what i would use in case i had to solve that problem
p8763
aVFor very simple cases, you could change your syntax to this:
p8764
aVThen you can use:
p8765
aVThe map would be a
p8766
aVWhich would be populated with the functions at the start of your program
p8767
aVwould just separate the arguments, and return a vector of them as strings
p8768
aVOf course, this is very primitive, but i think it's reasonable if all you want is some way to call a function (of course, if you want really script support, this approach won't suffice)
p8769
as(dp8770
g15
V34509
p8771
stp8772
a((dp8773
g2
(lp8774
VWell, that above code snippet is in effect allocating and creating elements, just to destroy them again
p8775
aVIt's in effect the same as:
p8776
aVJust that this code is way faster
p8777
aVSo,  in both cases and  might be the same as  in both cases too (although this is not guaranteed)
p8778
aVIn the second case, however, the capacity is at least numOfElements, which means the internal buffer will not be reallocated until you have push_back'ed that many elements to your vector
p8779
aVNote that in both cases it is invalid if you try accessing any elements - because there are zero elements actually contained
p8780
aVApart from that, i haven't figured a problem in your code
p8781
aVIt's safe and i would encourage it so use it instead of a raw  or  because of the added safeties it provides
p8782
aVI'm however not sure what you mean by "dump v"
p8783
as(dp8784
g15
V34509
p8785
stp8786
a((dp8787
g2
(lp8788
VLook at Jon Skeet's article about Parameter-Passing in Java, which explains this
p8789
aVIn short (look at his site for a more throughout explanation):
p8790
aVArrays are reference types
p8791
aVIf you pass a reference that points to an array, the value of the reference is copied and assigned to the parameter of the function
p8792
aVSo the parameter will point to the same array as the argument that was passed
p8793
aVThus changes you make to the array through the parameter of your function will be visible in the calling function
p8794
aVChanging the parameter itself (b), for example by setting it to null, however, will not be noticed by the calling function, since the parameter (b) is just a copy of the argument (tiger) passed
p8795
aVIntegers are so-called primitive types
p8796
aVPassing the integer copies its value and assigns it to the parameter too
p8797
aVBut that value is not a reference to the actual data, but is the data itself
p8798
aVSo changes to the paramter in the function will affect the parameter (a), but not the argument passed in the calling function (bird)
p8799
as(dp8800
g15
V34509
p8801
stp8802
a((dp8803
g2
(lp8804
VUse  to determine the CPU on which the calling thread is running
p8805
aVSee  (the system call) and  (a library wrapper)
p8806
aVHowever, note what it says:
p8807
aVThe information placed in cpu is only guaranteed to be current at the time of the call: unless the CPU affinity has been  fixed using  sched_setaffinity(2), the kernel might change the CPU at any time
p8808
aV(Normally this does not happen because the scheduler tries to minimize movements between CPUs to keep caches hot, but it is possible
p8809
aVThe caller must be prepared  to handle the situation when cpu and node are no longer the current CPU and node
p8810
as(dp8811
g15
V34509
p8812
stp8813
a((dp8814
g2
(lp8815
VIt's possible and in your code it's not causing harm
p8816
aVBut it's dangerous, because if you copy CDad, then the keys and pointers will be copied along
p8817
aVThe objects that the pointers will point to, and the reference inside those objects, however, will remain the same
p8818
aVIf the original CDad object then goes out of scope, the references in the objects referenced by the pointers are dangling, referencing no valid object anymore
p8819
aVMaybe you can to reverse lifetimes: Create the keys on the heap, and the kids as normal members within the class
p8820
aVSo if you copy dad, the kids are copied, but the keys are not
p8821
aVI think keys are immutable, so you can share the same key among multiple kids
p8822
aVThis brings to another point: If your keys are reasonable small (read: not huge) and immutable (so you don't have update anomalies if you change one key, but not the others), consider creating it not on the heap too - so they are automatically copied along too, and pass them to the kids when they need the key
p8823
aVYou can make them normal pointers of the kids, but i think that's ugly, because the kid does not contain a key - but uses it
p8824
aVSo a pointer/reference or a function parameter fits well, but not a "real" data member
p8825
aVIf you are going with the shared key and the keys-on-heap, you should use smart pointers - because you have to keep track of all kids and dads
p8826
aVIf the last kid/dad goes out of scope, you have to delete the key again
p8827
aVYou use  for that:
p8828
aVOf course, you can avoid all this complexity by just making the CDad class non-copyable
p8829
aVThen you can use your original solution, just with making the kids use a shared_ptr and make the kids non-copyable too
p8830
aVIdeally, one should use a non-shared pointer, such as , but that auto_ptr has some pitfalls too, which shared_ptr all avoids:
p8831
aVIf i had to implement such a class hierarchy, i would go with that solution, or just drop the keys as members, and pass/create them when needed to the children
p8832
aVSome other notes about your code:
p8833
aVBetter drop the "_" from members or put them at the end or use some other notation
p8834
aVA name that begins with an underscore and is followed by an uppercase letter is reserved by C++ implementations (compiler, C++ std lib
p8835
aVI personally find it confusing to have member names and variables start with an Uppercase letter
p8836
aVI've seen it only very rarely
p8837
aVBut this isn't much to care about, it's just about personal style
p8838
aVThere is a famous rule (Zero-One-Infinity) that states when you got two things of something, you generally should be able to have arbitrary many things of that
p8839
aVSo if you can have two children - why not have many of them
p8840
aVTwo seems like an arbitrary choice
p8841
aVBut it may have a good reason in your case - so ignore this when in your case it makes sense
p8842
as(dp8843
g15
V34509
p8844
stp8845
a((dp8846
g2
(lp8847
VTry it with
p8848
aVAs with this:
p8849
aVAnd make foobar in your code an extern declaration:
p8850
aVThis looks promising
p8851
aVHowever, it's a bad idea to do such a thing (unless you really know what you do)
p8852
aVWhy do you need it
p8853
as(dp8854
g15
V34509
p8855
stp8856
a((dp8857
g2
(lp8858
VWell, scanf expects a char* pointer as the next argument when seeing a "%s"
p8859
aVBut what you give it is a pointer to a char[100]
p8860
aVYou give it a
p8861
aVIt's not guaranteed to work at all, because the compiler may use a different representation for array pointers of course
p8862
aVIf you turn on warnings for gcc, you will see also the proper warning displayed
p8863
aVWhen you provide an argument object that is an argument not having a listed parameter in the function (so, as in the case for scanf when has the vararg style "
p8864
aVarguments after the format string), the array will degenerate to a pointer to its first element
p8865
aVThat is, the compiler will create a  and pass that to printf
p8866
aVSo, never do it with  and pass it to scanf using "%s"
p8867
aVGood compilers, as comeau, will warn you correctly:
p8868
aVwarning: argument is incompatible with corresponding format string conversion
p8869
aVOf course, the  and  have the same address stored
p8870
aVBut that does not mean you can use  and  interchangeably
p8871
aVSome Standard quotes to especially show how pointer arguments are not converted to  auto-magically, and how the whole thing is undefined behavior
p8872
aVExcept when it is the operand of the sizeof operator or the unary & operator, or is a
p8873
aVstring literal used to initialize an array, an expression that has type \u2018\u2018array of type\u2019\u2019 is converted to an expression with type \u2018\u2018pointer to type\u2019\u2019 that points to the initial element of the array object
p8874
aV()
p8875
aVSo, that is done always - it isn't mentioned below explicitly anymore when listening valid cases when types may differ
p8876
aVThe ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter
p8877
aVThe default argument promotions are performed on trailing arguments
p8878
aV()
p8879
aVAbout how  behaves extracting the arguments passed to printf, which is a vararg function, emphasis added by me ():
p8880
aVEach invocation of the va_arg macro modifies ap so that the
p8881
aVvalues of successive arguments are returned in turn
p8882
aVThe parameter type shall be a type
p8883
aVname specified such that the type of a pointer to an object that has the specified type can be obtained simply by post\ufb01xing a  to type
p8884
aVIf there is no actual next argument, or if type is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined, except for the following cases:
p8885
aVone type is a signed integer type, the other type is the corresponding unsigned integer
p8886
aVtype, and the value is representable in both types;
p8887
aVone type is pointer to void and the other is a pointer to a character type
p8888
aVWell, here is what that default argument promotion is:
p8889
aVIf the expression that denotes the called function has a type that does not include a
p8890
aVprototype, the integer promotions are performed on each argument, and arguments that
p8891
aVhave type float are promoted to double
p8892
aVThese are called the default argument
p8893
aVpromotions
p8894
aV()
p8895
as(dp8896
g15
V34509
p8897
stp8898
a((dp8899
g2
(lp8900
VIt's not necessarily leaking
p8901
aVFor example consider the following
p8902
aVIt's assigning to a reference
p8903
aVIt will preserve the identity of the object created (not creating a copy), so it will not lose track of it, and will delete it fine afterwards
p8904
aVPutting it into the form of your code, that class could be defined as
p8905
aVOr even more complex, with reference counting - so that p can be copied, and XPtr keeps track of all its copies, and so on
p8906
as(dp8907
g15
V34509
p8908
stp8909
a((dp8910
g2
(lp8911
VFirst, i believe you originally mean to return
p8912
aVInstead of always a specialization with N==3
p8913
aVSo, what you want to do is writing it like this:
p8914
aVIf you really want to always return a 3dVector, you would probably want to restrict it to N==3, so that for example  doesn't work
p8915
aVYou can do that using the technique described here
p8916
aVIf you want to have a function like  that works with any size, you probably want to replace the parameters with an array
p8917
aVYou can do otherwise, but that's advanced and requires some macro tricks applied with boost::preprocessor
p8918
aVIt's not worth it i think
p8919
aVThe next C++ version will provide variadic templates for this purpose
p8920
aVAnyway,consider using something like this:
p8921
aVI think it would only complicate this unnecessarily here
p8922
aVA quick solution is to use a boost::fusion::vector instead, putting it into the class template instead of the version above:
p8923
aVYou could use it with
p8924
aVNote that it accepts an array by reference
p8925
aVYou can't give it a pointer
p8926
aVThat is because it matches the use of parameters: You couldn't provide less or more arguments for the other way too
p8927
aVIt will also protect you from cases like this:
p8928
aVAn array never can be a null pointer
p8929
aVOf course if you like, you can always change the array parameter to a pointer
p8930
aVIt would just be my personal preference :)
p8931
as(dp8932
g15
V34509
p8933
stp8934
a((dp8935
g2
(lp8936
VHe uses memset on a non-POD class type
p8937
aVIt's invalid, because C++ only allows it for the simplest cases: Where a class doesn't have a user declared constructor, destructor, no virtual functions and several more restrictions
p8938
aVAn array of objects of it won't change that fact
p8939
aVIf he removes the vector he is fine with using memset on it though
p8940
aVOne note though
p8941
aVEven if it isn't C++, it might still be valid for his compiler - because if the Standard says something has undefined behavior, implementations can do everything they want - including blessing such behavior and saying what happens
p8942
aVIn his case, what happens is probably that you apply memset on it, and it would silently clear out any members of the vector
p8943
aVPossible pointers in it, that would point to the allocated memory, will now just contain zero, without it knowing that
p8944
aVYou can recommend him to clear it out using something like this:
p8945
aVAnd write clear using something like:
p8946
aVSwapping would just swap the vector of o with the one of *this, and clear out the other variables
p8947
aVSwapping a vector is especially cheap
p8948
aVHe of course needs to write a swap function then, that swaps the vector () and the other variables
p8949
as(dp8950
g15
V34509
p8951
stp8952
a((dp8953
g2
(lp8954
VYes, it is a non-type parameter
p8955
aVYou can have several kinds of template parameters
p8956
aVType Parameters
p8957
aVTypes
p8958
aVTemplates (only classes, no functions)
p8959
aVNon-type Parameters
p8960
aVPointers
p8961
aVReferences
p8962
aVIntegral constant expressions
p8963
aVWhat you have there is of the last kind
p8964
aVIt's a compile time constant (so-called constant expression) and is of type integer or enumeration
p8965
aVAfter looking it up in the standard, i had to move class templates up into the types section - even though templates are not types
p8966
aVBut they are called type-parameters for the purpose of describing those kinds nonetheless
p8967
aVYou can have pointers (and also member pointers) and references to objects/functions that have external linkage (those that can be linked to from other object files and whose address is unique in the entire program)
p8968
aVExamples:
p8969
aVTemplate type parameter:
p8970
aVTemplate integer parameter:
p8971
aVTemplate pointer parameter (passing a pointer to a function)
p8972
aVTemplate reference parameter (passing an integer)
p8973
aVTemplate template parameter
p8974
aVA template without any parameters is not possible
p8975
aVBut a template without any explicit argument is possible - it has default arguments:
p8976
aVSyntactically,  is reserved to mark an explicit template specialization, instead of a template without parameters:
p8977
as(dp8978
g15
V34509
p8979
stp8980
a((dp8981
g2
(lp8982
VFor equals, look into Secrets of Equals by Angelika Langer
p8983
aVI love it very much
p8984
aVShe's also a great FAQ about Generics in Java
p8985
aVView her other articles here (scroll down to "Core Java"), where she also goes on with Part-2 and "mixed type comparison"
p8986
aVHave fun reading them
p8987
as(dp8988
g15
V34509
p8989
stp8990
a((dp8991
g2
(lp8992
VJust noting that the reason actually is that the size of the enum is not yet known after forward declaration
p8993
aVWell, you use forward declaration of a struct to be able to pass a pointer around or refer to an object from a place that's refered to in the forward declared struct definition itself too
p8994
aVForward declaring an enum would not be too useful, because one would wish to be able to pass around the enum by-value
p8995
aVYou couldn't even have a pointer to it, because i recently got told some platforms use pointers of different size for char than for int or long
p8996
aVSo it all depends on the content of the enum
p8997
aVThe current C++ Standard explicitly disallows doing something like
p8998
aV(in )
p8999
aVBut the next C++ Standard due to next year allows the following, which convinced me the problem actually has to do with the underlying type:
p9000
aVIt's known as a "opaque" enum declaration
p9001
aVYou can even use X by value in the following code
p9002
aVAnd its enumerators can later be defined in a later redeclaration of the enumeration
p9003
aVSee  in the current working draft
p9004
as(dp9005
g15
V34509
p9006
stp9007
a((dp9008
g2
(lp9009
VIt can sound strange to hear that compressed_pair cares about a couple of bytes
p9010
aVBut it can actually be important when one considers where compressed_pair can be used
p9011
aVFor example let's consider this code:
p9012
aVIt can suddenly have a big impact to use compressed_pair in cases like above
p9013
aVWhat could happen if boost::bind stores the function pointer and the place-holder  as members in itself or in a  in itself
p9014
aVWell, it could bloat up to
p9015
aVAssuming a function pointer has 8 bytes (not uncommon especially for member functions) and the placeholder has one byte (see Logan's answer for why), then we could have needed 9 bytes for the bind object
p9016
aVBecause of aligning, this could bloat up to 12 bytes on a usual 32bit system
p9017
aVencourages its implementations to apply a small object optimization
p9018
aVThat means that for small functors, a small buffer directly embedded in the  object is used to store the functor
p9019
aVFor larger functors, the heap would have to be used by using operator new to get memory
p9020
aVAround boost version 1
p9021
aV34, it was decided to adopt this optimization, because it was figured one could gain some very great performance benefits
p9022
aVNow, a reasonable (yet, maybe still quite small) limit for such a small buffer would be 8 bytes
p9023
aVThat is, our quite simple bind object would not fit into the small buffer, and would require operator new to be stored
p9024
aVIf the bind object above would use a , it can actually reduce its size to 8 bytes (or 4 bytes for non-member function pointer often), because the placeholder is nothing more than an empty object
p9025
aVSo, what may look like just wasting a lot of thought for just only a few bytes actually can have a significant impact on performance
p9026
as(dp9027
g15
V34509
p9028
stp9029
a((dp9030
g2
(lp9031
VI like some of the comments in the GNU binutils
p9032
aVThis one is from BFD som
p9033
aVc:
p9034
aVThis one too:
p9035
aVAnother one:
p9036
aVFrom gas:
p9037
as(dp9038
g15
V34509
p9039
stp9040
a((dp9041
g2
(lp9042
V 2
p9043
aV19 has a new ELF linker called  which is multi-threaded, written in modern C++, and quite a bit faster than the usual  linker
p9044
aVI'm not sure however about the work involved to adapt it
p9045
aVOther than that, well new versions always are a good idea
p9046
aVPerformance and bug fixes are likely to have been included, of course
p9047
aVI think i would certainly try it and if something goes wrong you can still backstep
p9048
as(dp9049
g15
V34509
p9050
stp9051
a((dp9052
g2
(lp9053
VYou can fully specialize a member selectively:
p9054
aVYou do a full specialization
p9055
aVMeaning you cannot partial specialize it:
p9056
aVIf you need that, you can use enable_if:
p9057
aVAn alternative approach is to split your stuff up (common stuff into a base class, and specialized stuff into the derived class) like Nick recommends
p9058
aVI usually would take the second approach
p9059
aVBut i prefer the first one if i don't need to partial specialize the functions
p9060
as(dp9061
g15
V34509
p9062
stp9063
a((dp9064
g2
(lp9065
VIf you want to construct an istringstream from it, a char* up to the null character, or all the stuff from an std::string:
p9066
aVIf you talk about wanting a raw pointer into the buffer of an istream, you can't do it
p9067
aVStreams get their data on-demand if they need them either from files, terminals or else, optionally buffering their stuff (well, not exactly right
p9068
aVYou can use a , which accepts a raw pointer and reads/writes directly from that
p9069
aVBut it's a deprecated class - don't use it
p9070
aVI'm lucky i've never done so)
p9071
aVIf all you want is something you can use somewhat like a pointer, you can use streambuf iterators
p9072
aVThey are not really pointers though, so you can't subtract  from  and other stuffs:
p9073
aVIf you talk about getting a string out of what was written into a stringstream, you can use :
p9074
aVOtherwise, you can only generally read stuff from an
p9075
aVYou need an , then you can do
p9076
aVto write exactly N characters from the bytes that str points to
p9077
aVYou can write it into the stream using  too
p9078
aVIt will write everything up to the null character, or everything from an std::string, but will respect formatting flags, like the field width:
p9079
as(dp9080
g15
V34509
p9081
stp9082
a((dp9083
g2
(lp9084
VI've done this function:
p9085
aVYou should probably make sure to call umask with a proper file creation mask (I would prefer 0600)- the manpage for mkstemp says that the file mode creation mask is not standardized
p9086
aVIt uses the fact that mkstemp modifies its argument to the filename that it uses
p9087
aVSo, we open it and close the file it opened (so, to not have it opened twice), being left with a ofstream that is connected to that file
p9088
as(dp9089
g15
V34509
p9090
stp9091
a((dp9092
g2
(lp9093
VI recommend you to certainly look into both
p9094
aVIf your C++ course is finished you will be a better Java programmer and get some work done with it
p9095
aVIf you are still getting confused, you can still stop reading the Java books until the course is finished
p9096
aVI'm always at learning C++ and other languages at the same time and having fun with it
p9097
aVI certainly would say I'm learning something rather than being confused by it
p9098
as(dp9099
g15
V34509
p9100
stp9101
a((dp9102
g2
(lp9103
VThe first subl decrements the stack-pointer, to make room for variables that may be used in your function
p9104
aVOne slot may be used for the frame pointer, another to hold the return address, for example
p9105
aVYou said it should omit the frame pointer
p9106
aVThat usually means that it omits loads/stores to save/restore the frame pointer
p9107
aVBut often the code will still reserve memory for it
p9108
aVThe reason is that it makes code that analyzes the stack much easier
p9109
aVIt's easy to give the offset of the stack a minimal width and so you know you can always access FP+0x12, to get at the first local variable slot, even if you omit saving the frame pointer
p9110
aVWell,  on x86 is used to handle the return value to the caller, as far as i know
p9111
aVAnd the last addl just destroys the previously created frame for your function
p9112
aVThe code that generates the instructions at the start and end of functions is called "epilogue" and "prologue" of the function
p9113
aVHere is what my port does when it has to create the prologue of a function in GCC (it's way more complex for real-world ports that intend to be as fast and versatile as possible):
p9114
aVI omitted some code that deals with other issues, primarily with telling GCC what are instructions important for exception handling (i
p9115
aVe where the frame pointer is stored and so on)
p9116
aVWell, callee saved registers are the ones that the caller don't need to save prior to a call
p9117
aVThe called function cares about saving/restoring them as needed
p9118
aVAs you see in the first lines, we always allocate space for the return address and frame pointer
p9119
aVThat space is just a few bytes and won't matter
p9120
aVBut we only generate the stores/loads when necessary
p9121
aVFinally note the "hard" frame pointer is the "real" frame pointer register
p9122
aVIt's necessary because of some gcc internal reasons
p9123
aVThe "frame_pointer_needed" flag is set by GCC, whenever i can not omit storing the frame-pointer
p9124
aVFor some cases, it has to be stored, for example when  (it changes the stackpointer dynamically) is used
p9125
aVGCC cares about all that
p9126
aVNote it has been some time since i wrote that code, so i hope the additional comments i added above are not all wrong :)
p9127
as(dp9128
g15
V34509
p9129
stp9130
a((dp9131
g2
(lp9132
VYou use the  function:
p9133
aVYou can also cast it to an integer, but be warned you may overflow the integer
p9134
aVThe result is not predictable then
p9135
as(dp9136
g15
V34509
p9137
stp9138
a((dp9139
g2
(lp9140
Vopens up a new scope
p9141
aVIn C++, you can use them like this:
p9142
aVOnce control goes out of the block, the mutex locker is destroyed
p9143
aVAnd in its destructor, it would automatically unlock the mutex that it's connected to
p9144
aVThat's very often done, and is called RAII (resource acquisition is initialization) and also SBRM (scope bound resource management)
p9145
aVAnother common application is to allocate memory, and then in the destructor free that memory again
p9146
aVAnother purpose is to do several similar things:
p9147
aVIt will keep things separate so one can easily find out the different building blocks
p9148
aVYou may use variables having the same name, like the code does above, because they are not visible outside their scope, thus they do not conflict with each other
p9149
as(dp9150
g15
V34509
p9151
stp9152
a((dp9153
g2
(lp9154
VIf you define a free (not a member of a class) function, it has to be defined in a
p9155
aVcpp file separately compiled, or in a header and marked inline
p9156
aVSo in your case, you can get away making it compile by this:
p9157
aVThe error is caused because you have the definition of the function in the header, but haven't marked it inline
p9158
aVIf you now include that header into two files that are compiled separately, the linker, when trying to link the compiled object files, will throw out an error, because it then sees a cross function being defined twice
p9159
aVIt works without exlicitly putting inline for member functions of a class, because member functions that are defined inside the class definition are implicitly inline
p9160
aVIt is however, not a good idea generally to make function definitions in the header
p9161
aVIf your function would depend on other types than just the vector (in your case it's fine IMHO, but it's debatable of course - some people don't like it), then you would be required to include the headers for those types
p9162
aVThat will unnecessarily bloat the code that's indirectly included by your header
p9163
aVInstead, in those cases you would solely put only a declaration of your function inside the header:
p9164
aVBut define it within the
p9165
aVcpp file that's compiled separately
p9166
aVThe inline, of course, should then be dropped
p9167
aVLet me add a small list of definitions and declarations, just to help in keeping things clear about what declaration and definition means for functions and classes
p9168
aVNote that every definition is also a declaration, but not the other way around:
p9169
as(dp9170
g15
V34509
p9171
stp9172
a((dp9173
g2
(lp9174
VC++'s answer is RAII: The object's destructor will be executed when they go out of scope
p9175
aVWhether by a return, by an exception or whatever
p9176
aVIf you handle the exception somewhere else, you can be sure all objects from the called function down to your handler will be properly destructed by having their destructor called
p9177
aVThey will clean up for you
p9178
aVRead http://en
p9179
aVwikipedia
p9180
aVorg/wiki/Resource_acquisition_is_initialization
p9181
as(dp9182
g15
V34509
p9183
stp9184
a((dp9185
g2
(lp9186
VI'll just quote wikipedia:
p9187
aVA nondeterministic programming language is a language which can specify, at certain points in the program (called "choice points"), various alternatives for program flow
p9188
aVUnlike an if-then statement, the method of choice between these alternatives is not directly specified by the programmer; the program must decide at runtime between the alternatives, via some general method applied to all choice points
p9189
aVA programmer specifies a limited number of alternatives, but the program must later choose between them
p9190
aV("Choose" is, in fact, a typical name for the nondeterministic operator
p9191
aVA hierarchy of choice points may be formed, with higher-level choices leading to branches that contain lower-level choices within them
p9192
aVOne method of choice is embodied in backtracking systems, in which some alternatives may "fail", causing the program to backtrack and try other alternatives
p9193
aVIf all alternatives fail at a particular choice point, then an entire branch fails, and the program will backtrack further, to an older choice point
p9194
aVOne complication is that, because any choice is tentative and may be remade, the system must be able to restore old program states by undoing side-effects caused by partially executing a branch that eventually failed
p9195
aVOut of the Nondeterministic Programming article
p9196
as(dp9197
g15
V34509
p9198
stp9199
a((dp9200
g2
(lp9201
Vstarblue explained the first part of your question
p9202
aVI'll take the second part
p9203
aVBecause  is a , which is unsigned, the int is converted to that unsigned type
p9204
aVYour size_t is so that int cannot represent all values of it, so the conversion of the  to  happens, instead of the  to the
p9205
aVConversion of negative numbers to unsigned is perfectly defined: The value wraps around
p9206
aVIf you convert  to an , it ends up at
p9207
aVThat is true whether or not you use twos' complement to represent negative numbers
p9208
aVThe rationale for C document has more information about that value preserving conversion
p9209
as(dp9210
g15
V34509
p9211
stp9212
a((dp9213
g2
(lp9214
VYes, you can use them as alternative to name tokens
p9215
aVFor example:
p9216
aVYour example would work too
p9217
aVIt would however store an one into i
p9218
aVIf you want to use bitwise not, you use compl (~):
p9219
as(dp9220
g15
V34509
p9221
stp9222
a((dp9223
g2
(lp9224
Vscoped_ptr is very good for this purpose
p9225
aVBut one has to understand its semantics
p9226
aVYou can group smart pointers using two major properties:
p9227
aVCopyable: A smart pointer can be copied: The copy and the original share ownership
p9228
aVMovable: A smart pointer can be moved: The move-result will have ownership, the original won't own anymore
p9229
aVThat's rather common terminology
p9230
aVFor smart pointers, there is a specific terminology which better marks those properties:
p9231
aVTransfer of Ownership: A smart pointer is Movable
p9232
aVShare of Ownership: A smart pointer is copyable
p9233
aVIf a smart pointer is already copyable, it's easy to support transfer-of-ownership semantic: That then is just an atomic copy & reset-of-original operation, restricting that to smart pointers of certain kinds (e
p9234
aVg only temporary smart pointers)
p9235
aVLet's group the available smart pointers, using , and , :
p9236
aV: N
p9237
aV: M
p9238
aV: C
p9239
aVhas one big problem, in that it realizes the Movable concept using a copy constructor
p9240
aVThat is because When auto_ptr was accepted into C++, there wasn't yet a way to natively support move semantics using a move constructor, as opposed to the new C++ Standard
p9241
aVThat is, you can do the following with auto_ptr, and it works:
p9242
aVAnyway, as we see, in your case you won't be able to transfer the ownership to another object: Your object will in effect be non-copyable
p9243
aVAnd in the next C++ Standard, it will be non-movable if you stay with scoped_ptr
p9244
aVFor implementing your class with scoped_ptr, watch that you either have one of these two points satisfied:
p9245
aVWrite an destructor (even if it's empty) in the
p9246
aVcpp file of your class, or
p9247
aVMake  a completely defines class
p9248
aVOtherwise, when you would create an object of Example, the compiler would implicitly define a destructor for you, which would call scoped_ptr's destructor:
p9249
aVThat would then make scoped_ptr call , which would complain about  being incomplete, in case you haven't done any of the above two points
p9250
aVIf you have defined your own dtor in the
p9251
aVcpp file, the implicit call to the destructor of scoped_ptr would be made from the
p9252
aVcpp file, in which you could place the definition of your  class
p9253
aVYou have that same problem with auto_ptr, but you have one more problem: Providing auto_ptr with an incomplete type is undefined behavior currently (maybe it will be fixed for the next C++ version)
p9254
aVSo, when you use auto_ptr, you have to make Owned a complete type within your header file
p9255
aVshared_ptr doesn't have that problem, because it uses a polymorphic deleter, which makes an indirect call to the delete
p9256
aVSo the deleting function is not instantiated at the time the destructor is instantiated, but at the time the deleter is created in shared_ptr's constructor
p9257
as(dp9258
g15
V34509
p9259
stp9260
a((dp9261
g2
(lp9262
VI'll tell you why that conversion operator happens to be there
p9263
aVWell, look at this example:
p9264
aVWe have move semantics for our class A: In its copy constructor, we want to "steal" away some stuff from the other instance
p9265
aVFor auto_ptr, that is the pointer that is managed, for us we just output a message instead
p9266
aVWhat is important is that we can't use a usual copy constructor:
p9267
aVBut if we change that to , we won't be able to construct from a by-value/temporary A: Those can't be bound to a reference-to-nonconst:
p9268
aVauto_ptr and our A class uses the trick that non-const member functions can still be called on temporaries/by-value A's
p9269
aVThat is, we could also have written:
p9270
aVBut that works, we don't want to be bothered with that, of course
p9271
aVWe want that it just works to assign a  or the return value of a function returning an  by-value
p9272
aVSo what auto_ptr and our A class uses is a conversion operator, which automatically figures out that when A is converted to B, then we could construct a A instance using the B we created temporarily
p9273
as(dp9274
g15
V34509
p9275
stp9276
a((dp9277
g2
(lp9278
VThis answer is outdated, gdb now supports saving directly
p9279
aVSee this answer
p9280
aVYou can use logging:
p9281
aVThe file breaks
p9282
aVtxt now contains:
p9283
aVWriting an awk script that transforms that into a format useful for the  or a  file is easy
p9284
aVOr you may even make the script emit separate 's to the gdb command line
p9285
aVAdding this small macro to
p9286
aVgdbinit will help you do it:
p9287
as(dp9288
g15
V34509
p9289
stp9290
a((dp9291
g2
(lp9292
VYou can do that, if the function does not depend on the template parameter:
p9293
aVBut if the function in C_Foo_Common needs to know the type  (for example to have another return type that depends on T), then that's not possible anymore
p9294
aVis a different type than
p9295
aVYou can use discriminated unions instead
p9296
aVThose keep track about what is stored in them and are completely generic:
p9297
aVThe variant knows what it stores, and can call functions overloaded on the types of what can be stored in it
p9298
aVRead the documentation of  for more information on how to get at what the variants contain
p9299
as(dp9300
g15
V34509
p9301
stp9302
a((dp9303
g2
(lp9304
VIt's the operator<< that is overloaded for  and for
p9305
aVYour char array is converted to  and passed to that overload, because it fits better than to
p9306
aVThe int array, however, is converted to  and passed to that version
p9307
aVThe version of operator<< taking  just outputs the address
p9308
aVThe version taking the  actually treats it like a C-string and outputs every character until the terminating null character
p9309
aVIf you don't want that, convert your char array to  explicitly when passing it to operator<<:
p9310
as(dp9311
g15
V34509
p9312
stp9313
a((dp9314
g2
(lp9315
VI would only overload operator<< when that has anything to do with streaming, or with shifting and the class is purely numeral
p9316
aVFor writing something into an ostream, as in your code, i think it's fine
p9317
aVAnything else, i think, will cause confusion and i would better use member functions for those other purposes
p9318
aVOne other application, which i think i would still do as an exception to the rule, is doing something like this:
p9319
aVIt is how Qt does it with its string list, and which i find quite nice
p9320
as(dp9321
g15
V34509
p9322
stp9323
a((dp9324
g2
(lp9325
VMany C++ developers do not use namespaces, sadly
p9326
aVWhen i started with C++, i didn't use them for a long time, until i've come to the conclusion that i can do better using namespaces
p9327
aVMany libraries work around namespaces by putting prefixes before names
p9328
aVFor example, wxWidgets puts the characters "wx" before everything
p9329
aVQt puts "Q" before everything
p9330
aVIt's nothing really wrong with that, but it requires you to type that prefix all over again, even though when it can be deduced from the context which declarations you mean
p9331
aVNamespaces have a hierarchic order
p9332
aVNames that are lexically closer to the point that reference them are found earlier
p9333
aVSo if you reference "Window" within your GUI framework, it will find "my::gui::Window", instead of "::Window"
p9334
aVNamespaces enable some nice features that can't be used without them
p9335
aVFor example, if you put your class into a namespace, you can define free functions within that namespace
p9336
aVYou then call call the function without putting the namespace in front by importing all names, or selectively only some of them into the current scope ("using declaration")
p9337
aVNowadays, i don't do any project anymore without using them
p9338
aVThey make it so easy not to type the same prefix all over again, but still have good organization and avoidance of name-pollution of the global namespace
p9339
as(dp9340
g15
V34509
p9341
stp9342
a((dp9343
g2
(lp9344
VWhat you are talking about are intrusive and non-intrusive smart pointers
p9345
aVBoost has both
p9346
aVcalls a function to decrease and increase the reference count of your object, everytime it needs to change the reference count
p9347
aVIt's not calling member functions, but free functions
p9348
aVSo it allows managing objects without the need to change the definition of their types
p9349
aVAnd as you say,  is non-intrusive, your category 2
p9350
aVI have an answer explaining intrusive_ptr: Making shared_ptr not use delete
p9351
aVIn short, you use it if you have an object that has already reference counting, or need (as you explain) an object that is already referenced to be owned by an intrusive_ptr
p9352
as(dp9353
g15
V34509
p9354
stp9355
a((dp9356
g2
(lp9357
VIn some derived language, the caret is used to declare a managed pointer
p9358
aVIt's the so-called C++/CLI language made by microsoft and is used in
p9359
aVNet
p9360
aVIt doesn't have that meaning in normal C++
p9361
aVIn expressions, the caret means, as already explained by others, the bit-wise XOR, anyway
p9362
as(dp9363
g15
V34509
p9364
stp9365
a((dp9366
g2
(lp9367
VIf you just need read-only access, then  will do it:
p9368
aVIf you need read/write access, then you can copy the string into a vector
p9369
aVvectors manage dynamic memory for you
p9370
aVYou don't have to mess with allocation/deallocation then:
p9371
as(dp9372
g15
V34509
p9373
stp9374
a((dp9375
g2
(lp9376
VI have found the following two libraries:
p9377
aVZipIOS++
p9378
aVSeems to be "pure" C++
p9379
aVThey don't list Windows explicitly as a supported platform
p9380
aVSo i think you should try your luck yourself
p9381
aVQuaZIP
p9382
aVBased on Qt4
p9383
aVActually looks nice
p9384
aVThey list Windows explicitly (Using mingw)
p9385
aVApparently, it is a C++ wrapper for [this] library
p9386
aVAh, and of course, i have ripped those sites from this Qt Mailinglist question about Zipping/Unzipping of directories :)
p9387
as(dp9388
g15
V34509
p9389
stp9390
a((dp9391
g2
(lp9392
VJacobM's answer is great
p9393
aVFor doing it manually, i would use something like this:
p9394
aVThe test before the output makes sure only executable, regular files are shown
p9395
aVThe above shows all commands starting with
p9396
as(dp9397
g15
V34509
p9398
stp9399
a((dp9400
g2
(lp9401
VUse the builtin command compgen:
p9402
as(dp9403
g15
V34509
p9404
stp9405
a((dp9406
g2
(lp9407
VI think Treb is on the right track
p9408
aVIt's more important for integers that you have an unsigned corresponding type
p9409
aVThose are the ones that are used in bit-shifting and used in bit-maps
p9410
aVA sign bit just gets into the way
p9411
aVFor example, right-shifting a negative value, the resulting value is implementation defined in C++
p9412
aVDoing that with an unsigned integer or overflowing such one has perfectly defined semantics because there is no such bit in the way
p9413
aVSo for integers at least, the need for a separate unsigned type is stronger than just giving warnings
p9414
aVAll the above points do not need to be considered for floats
p9415
aVSo, there is, i think, no real need for hardware support for them, and C will already don't support them at that point
p9416
as(dp9417
g15
V34509
p9418
stp9419
a((dp9420
g2
(lp9421
VYour problem is that they are constant, but they are not constant expressions when evaluated:
p9422
aVWhat you need are true constant expressions
p9423
aVYou can use  to make up a mpl vector of mpl pairs, each with a pair of integral constants:
p9424
aVNow, you can iterate over the items of it using  algorithms
p9425
aVEach  is exposes a static int constant  set to the value you told it
p9426
aVThat will evaluate to a constant expression:
p9427
aVAnd that would actually make that array contain 5 elements
p9428
aVWebsite of boost::mpl Reference Manual: Here
p9429
as(dp9430
g15
V34509
p9431
stp9432
a((dp9433
g2
(lp9434
VIn C, you can create array literals ("compound literal"), but in C++ you cannot
p9435
aVYou can also create an array with size not yet known at compile time, but C++ has no such possibility ("variable length array"):
p9436
as(dp9437
g15
V34509
p9438
stp9439
a((dp9440
g2
(lp9441
Vis parsed as
p9442
aVBut  does not have a default constructor
p9443
aVTry giving it a name:
p9444
as(dp9445
g15
V34509
p9446
stp9447
a((dp9448
g2
(lp9449
VC code:
p9450
aVYou will see how many digits you converted by taking the difference
p9451
aVIf you want to put it into a function:
p9452
aVI prefer automatic arrays to dynamic memory allocation in this case, since it's easier to do it right and not leak accidentally
p9453
as(dp9454
g15
V34509
p9455
stp9456
a((dp9457
g2
(lp9458
VOh it has
p9459
aVBut the other way around
p9460
aVIgnoring that warning caused a huge headache to me one day
p9461
aVI was writing a function that plotted a graph, and mixed signed and unsigned variables
p9462
aVIn one place, i compared a negative number to a unsigned one:
p9463
aVGuess what happened
p9464
aVThe signed number got promoted to the unsigned type, and thus was greater at the end, even though it was below 0 originally
p9465
aVIt took me a couple of hours until i found the bug
p9466
as(dp9467
g15
V34509
p9468
stp9469
a((dp9470
g2
(lp9471
VIt's fine, you can store iterators in the map
p9472
aVIf you get some error, that is caused by something else
p9473
aVNote that if you modify your string, iterators pointing into your string will become invalid
p9474
aVPlease show us a complete, compilable code snippet that is rendered unusable, so we can analyze it
p9475
as(dp9476
g15
V34509
p9477
stp9478
a((dp9479
g2
(lp9480
VYou can derive from this class template:
p9481
aVAnd use it like this:
p9482
aVPreviously i had a version that called post functions too
p9483
aVBut i dropped it
p9484
aVIt would have needed additional work
p9485
aVHowever, i would still not recommend you to do this "call function automatically" thingy
p9486
aVBecause one can easily forget to use the operator-> syntax and just use the dot - and suddenly have the pre function not called
p9487
aVUpdate: The version above takes care of that, so one cannot accidentally call functions with the dot anymore
p9488
as(dp9489
g15
V34509
p9490
stp9491
a((dp9492
g2
(lp9493
VIt's a macro called  that gets into the way as Adam explained
p9494
aVAnother solution (more a "hotfix") may be to put parentheses around the function, to prevent it from being seen as a macro invocation:
p9495
as(dp9496
g15
V34509
p9497
stp9498
a((dp9499
g2
(lp9500
VWell
p9501
aVIn C++, dereferencing the pointer in any but case 2 will yield undefined behavior, so you don't know what happens
p9502
aVFor most operation systems, however, dereferencing the null pointer will cause a segmantation fault
p9503
aVJust using the pointer in comparisons is fine for a null pointer but is not precisely defined (unspecified) for any other case than that and case 2
p9504
aVCase 2 is perfectly defined
p9505
aVYou can have your pointer point to an int that has an value of 0
p9506
aVI don't understand why such a thing would be illegal in C# even
p9507
aVProbably i have misunderstood your case 2
p9508
aVFor case 3, you have to differentiate whether the pointer points already to that wrong object, or whether you are still trying to make it point to that
p9509
aVThe C++  will check the type of the object you point to, and if it's not derived or of the same type than your casted to type, then it will give you a null pointer
p9510
aVBut there are other casts that do not do that check, and will leave you with an invalid pointer
p9511
as(dp9512
g15
V34509
p9513
stp9514
a((dp9515
g2
(lp9516
VWell,  is not derived from
p9517
aVBut  is derived from
p9518
aVThe auto_ptr does not know about that (it's not that clever)
p9519
aVLooks like you want to use a shared ownership pointer
p9520
aVis ideal, it also provides a dynamic_pointer_cast:
p9521
aVFor auto_ptr, such a thing can't really work
p9522
aVBecause ownership will move to
p9523
aVBut if the cast fails, b can't get ownership
p9524
aVIt's not clear what to do then to me
p9525
aVYou would probably have to say if the cast fails, a will keep having the ownership - which sounds like it will cause serious trouble
p9526
aVBest start using shared_ptr
p9527
aVBoth  and  then would point to the same object - but  as a  and  as a
p9528
as(dp9529
g15
V34509
p9530
stp9531
a((dp9532
g2
(lp9533
VMaybe there are some words which remember me more of making a copy and add stuff to that instead of mutating the instance (like "Concatenate")
p9534
aVBut i think having some symmetry for those words for other actions would be good to have too
p9535
aVI don't know of a similar word for "Remove" that i think of the same kind like "Concatenate"
p9536
aV"Plus" sounds little strange to me
p9537
aVI wouldn't expect it being used in a non-numerical context
p9538
aVBut that could aswell come from my non-english background
p9539
aVMaybe i would use this scheme
p9540
aVThese have their own problems though, when i think about it
p9541
aVOne could think they remove something or add something to an argument given
p9542
aVNot sure about it at all
p9543
aVThose words do not play nice in chaining either, i think
p9544
aVToo wordy to type
p9545
aVMaybe i would just use plain "Add" and friends too
p9546
aVI like how it is used in math
p9547
aVWell, certainly, a 2 remains a 2 and you get a new number
p9548
aVThis is about two numbers and not about a list and an element, but i think it has some analogy
p9549
aVIn my opinion,  does not necessarily mean you mutate something
p9550
aVI certainly see your point that having a lonely statement containing just an  and not using the returned new object does not look buggy
p9551
aVBut I've now also thought some time about that idea of using another name than "add" but i just can't come up with another name, without making me think "hmm, i would need to look at the documentation to know what it is about" because its name differs from what I would expect to be called "add"
p9552
aVJust some weird thought about this from litb, not sure it makes sense at all :)
p9553
as(dp9554
g15
V34509
p9555
stp9556
a((dp9557
g2
(lp9558
VIt certainly works for objects created by  and when the caller of  is properly informed about that behavior
p9559
aVBut i would avoid it
p9560
aVIn your case, the ownership clearly is at the World, so i would make the world delete it
p9561
aVThe object does not create itself, i think it should also not delete itself
p9562
aVCan be very surprising if you call a function "Update" on your object, but then suddenly that object is not existing anymore without World doing anything out of itself (apart from Removing it out of its list - but in another frame
p9563
aVThe code calling Update on the object will not notice that)
p9564
aVSome ideas on this
p9565
aVAdd a list of object references to World
p9566
aVEach object in that list is pending for removal
p9567
aVThis is a common technique, and is used in wxWidgets for toplevel windows that were closed, but may still receive messages
p9568
aVIn idle time, when all messages are processed, the pending list is processed, and objects are deleted
p9569
aVI believe Qt follows a similar technique
p9570
aVTell the world that the object wants to be deleted
p9571
aVThe world will be properly informed and will take care of any stuff that needs to be done
p9572
aVSomething like a  maybe
p9573
aVAdd a  function to each object which returns true if the object wishes to be deleted by its owner
p9574
aVI would prefer option 3
p9575
aVThe world would call Update
p9576
aVAnd after that, it looks whether the object should be deleted, and can do so - or if it wishes, it remembers that fact by adding that object to a pending-removal list manually
p9577
aVIt's a pain in the ass when you can't be sure when and when not to be able to access functions and data of the object
p9578
aVFor example, in wxWidgets, there is a wxThread class which can operate in two modes
p9579
aVOne of these modes (called "detachable") is that if its main function returns (and the thread resources should be released), it deletes itself (to release the memory occupied by the wxThread object) instead of waiting for the owner of the thread object to call a wait or join function
p9580
aVHowever, this causes severe headache
p9581
aVYou can never call any functions on it because it could have been terminated at any circumstances, and you can not have it created not with new
p9582
aVQuite some people told me they very much dislike that behavior of it
p9583
aVThe self deletion of reference counted object is smelling, imho
p9584
aVLet's compare:
p9585
aVCompare that with self-deleting refcounted objects:
p9586
aVI think the first is so much nicer, and i believe well designed reference counted objects do not do "delete this", because it increases coupling: The class using the reference counted data has to know and remember about that the data deletes itself as a side-effect of decrementing the reference-count
p9587
aVNote how "bmp" becomes possibly a dangling pointer in ~Bitmap's destructor
p9588
aVArguably, not doing that "delete this" is much nicer here
p9589
aVAnswer to a similar question "What is the use of delete this"
p9590
as(dp9591
g15
V34509
p9592
stp9593
a((dp9594
g2
(lp9595
VI think awk is not done for this sort of numeric work
p9596
aVIt's more for text processing
p9597
aVArrays in awk are associative and sparsely occupied (may have "holes" between its indexes)
p9598
aVYou use strings to index them:
p9599
aVIt's like a hash-map
p9600
aVSo, in awk you can do
p9601
aVAnd have only 2 elements stored in that array (elements from 2 to 99 do not exist), indexed by strings that are created by converting the numbers 100 and 1
p9602
aVThe GNU Awk manual has a nice section about arrays in awk here
p9603
as(dp9604
g15
V34509
p9605
stp9606
a((dp9607
g2
(lp9608
VAs it is for education, as you say, i will show you how i would do such a thingy
p9609
aVOtherwise,  is really the way to go
p9610
aVSounds like you want to create a streambuf implementation that then writes to a vector / deque
p9611
aVSomething like this (copying from another answer of me that targeted a /dev/null stream):
p9612
aVYou can use it like this:
p9613
aVIf you want to have a deque as sequence, you can do so:
p9614
aVOr something similar
p9615
aVWell i haven't tested it
p9616
aVBut maybe that's also a good thing - so if it contains still bugs, you can try fixing them
p9617
as(dp9618
g15
V34509
p9619
stp9620
a((dp9621
g2
(lp9622
VYou can't
p9623
aVIt's built into compilers to allow you overloading functions and to have functions with the same name in different classes and such stuff
p9624
aVBut you can write functions that are mangled like C functions
p9625
aVThose can be called from C code
p9626
aVBut those can't be overloaded and can't be called by "normal" C++ function pointers:
p9627
aVThe above function will be mangled like C functions for your compiler
p9628
aVThat may include no change at all to the name, or some changes like a leading "_" in front of it or so
p9629
as(dp9630
g15
V34509
p9631
stp9632
a((dp9633
g2
(lp9634
VYou can have a look at
p9635
aVIt's a kind of "meta-make" system: You write a make-file for it, which says how your project is structured, what libs and sources it needs, and so on
p9636
aVAnd it can build make-files for you for GNU make, nmake (i believe), project files for Kdevelop and Visual Studio
p9637
aVKDE has adopted it for KDE4 onwards and it was since greatly enhanced: CMake
p9638
aVAnother such system is Bakefile which was built to generate make-files and project-files for the wxWidgets GUI toolkit
p9639
aVIt can be used for non-wx applications too, and is relatively young and modern (uses XML as its makefile description)
p9640
as(dp9641
g15
V34509
p9642
stp9643
a((dp9644
g2
(lp9645
VI suspect you could write such a thing, but it would need to have an endless loop at the end, because you can't ask the operation system to exit your process
p9646
aVAnd you couldn't do anything useful
p9647
aVWell start with compiling an ELF program, look into the ELF spec and craft together the header, the program segments and the other parts you need for a program
p9648
aVThe kernel would load your code and jump to some initial address
p9649
aVYou could place an endless loop there
p9650
aVBut without knowing some assembler, that's hopeless from the start on anyway
p9651
aVThe  file as used by glibc may be useful as a start point
p9652
aVTry to change it so that you can assemble a stand-alone executable out of it
p9653
aVThat start
p9654
aVS file is the entry point of all ELF applications, and is the one that calls  which in turn calls
p9655
aVYou just change it so it fits your needs
p9656
aVOk, that was theoretical
p9657
aVBut now, what practical use does that have
p9658
aVAnswer to the Updated Question
p9659
aVWell
p9660
aVThere is a library called  that provides a minimal interface for programs that are meant to run on embedded systems
p9661
aVThe  C library uses that one as its system-call interface
p9662
aVThe general idea is that libgloss is the layer between the C library and the operation system
p9663
aVAs such, it also contains the startup files that the operation system jumps into
p9664
aVBoth these libraries are part of the GNU binutils project
p9665
aVI've used them to do the interface for another OS and another processor, but there does not seem to be a libgloss port for Linux, so if you call system calls, you will have to do it on your own, as others already stated
p9666
aVIt is absolutely possible to write programs in the C programming language
p9667
aVThe linux kernel is a good example of such a program
p9668
aVBut also user programs are possible
p9669
aVBut what is minimally required is a runtime library (if you want to do any serious stuff)
p9670
aVSuch one would contain really basic functions, like memcpy, basic macros and so on
p9671
aVThe C Standard has a special conformance mode called freestanding, which requires only a very limited set of functionality, suitable also for kernels
p9672
aVActually, i have no clue about x86 assembler, but i've tried my luck for a very simple C program:
p9673
aVWe're happy, it actually compiles and runs :)
p9674
as(dp9675
g15
V34509
p9676
stp9677
a((dp9678
g2
(lp9679
VBecause there are immutable and mutable classes
p9680
aV, as another answer points out, is an immutable class
p9681
aVTheir value always stays the same once a String is created
p9682
aVIf you have an  object, you can use its  function to add another Integer to the list
p9683
aVThe  function changes the list in-place, instead of returning a new list
p9684
aVAn ArrayList is mutable
p9685
aVResponse to Edit:
p9686
aVFor your groovy example, probably its designers sat down and noticed that more often one would want a new list that contains the reversed result, and keep the old list untouched
p9687
aV(Why
p9688
aVI don't know)
p9689
aVOn the other side, they may have noticed there are more cases where you want not to have a new list which contains the sorted result
p9690
aVSo it does its job in-place
p9691
aVBut i don't know and haven't used groovy before, so just a guess
p9692
aVIn Ruby, i have heard there is a notion for this: Functions that change objects in-place have an exclamation written after them, and functions that return the result as a new object have no exclamation mark:
p9693
as(dp9694
g15
V34509
p9695
stp9696
a((dp9697
g2
(lp9698
VWell, the error message says it :) If you 'new an array, then new returns a pointer to its first element
p9699
aVA multidimensional array is just another name for an array of arrays
p9700
aVYou 'newed an array of , and precisely numTriangles elements of those
p9701
aVSo what new does is returning a pointer to
p9702
aVThe variable you assign the result to has to have that type, which is a pointer to an array of 3 integers:
p9703
aVOf course, typedefs also help here:
p9704
aVThe parentheses are needed because of the C++ precedence rules
p9705
aVThey tell the compiler that it's not creating an array of three pointers to integers, but a pointer to an array of 3 integers
p9706
aVThis is similar to the more common use on function pointers ()
p9707
as(dp9708
g15
V34509
p9709
stp9710
a((dp9711
g2
(lp9712
VYeah, lower_bound can be used for that, i've seen it before and used it like that
p9713
aVWould actually return the greatest, yet smaller (if it
p9714
aV= map
p9715
aVbegin() was true) one
p9716
aVIf it was at
p9717
aVbegin, then there is no smaller key
p9718
aVNice idea from the comments is to return  if there is no element that's less and pack this stuff into a function:
p9719
aVThe template should work for  too
p9720
as(dp9721
g15
V34509
p9722
stp9723
a((dp9724
g2
(lp9725
VCygwin's version of gcc may have other default flags and tweaked settings (wchar_t being 2 bytes for example), but i doubt it is specifically more "lax" with code and even so - your code should not crash
p9726
aVIf it does, then most probably there is a bug in your code that needs be fixed
p9727
aVFor example your code may depend on a particular size of wchar_t or may execute code that's not guaranteed to work at all, like writing into string literals
p9728
aVIf you write clean code then it runs also on linux
p9729
aVI'm currently running firefox and the KDE desktop which together consist of millions of C++ lines, and i don't see those apps crashing :)
p9730
aVI recommend you to paste your code into your question, so we can look what is going wrong
p9731
aVIn the meantime, you can run your program in , which is a debugger for linux
p9732
aVYou can also compile with all mudflap checks enabled and with all warnings enabled
p9733
aVmudflaps checks your code at runtime for various violations:
p9734
aVThere are many mudflap checks you can do, and the above runs a
p9735
aVout using the default options
p9736
aVAnother tools which helps for those kind of bugs is , which can also help you find leaks or off by one bugs like above
p9737
aVSetting the environment variable "MALLOC_CHECK_" to 1 will print messages for violations too
p9738
aVSee the manpage of  for other possible values for that variable
p9739
aVFor checking where your program crashes you can use :
p9740
aVCompile your code with -g3 to include many debugging information, so gdb can help you find the precise lines where your program is crashing
p9741
aVAll the above techniques are equally applicable for C and C++
p9742
as(dp9743
g15
V34509
p9744
stp9745
a((dp9746
g2
(lp9747
VFor the printf part - it's part of the C Standard Library, which is a part of C
p9748
aVSo the implementation of your C compiler or C Standard library can use all sort of tricks to make it work
p9749
aVLet's take a simple example on how such a function can be implemented in Unix
p9750
aVTake  (simplified here - without returning anything)
p9751
aVIt outputs one character to standard output, which has the file descriptor number 1
p9752
aVThe operation system provides a function called "write"
p9753
aVA program can write into a file descriptor
p9754
aVSo, putchar can use that function:
p9755
aVWill write 1 byte to the file descriptor 1
p9756
aVThe write function will tell the operation system about that wish:
p9757
aVIt will usually just contain a small block of assembly lines that raises a software interrupt (in the sample above, it's the interrupt number 0x80)
p9758
aVThe CPU will switch into kernel mode and jump to some fixed address, from which the operation system can handle that interrupt
p9759
aVwill have written the system call number for write into some register and will have put the arguments into some memory location or into registers too, so that the operation system knows what to do at that point
p9760
aVThe operation system will then send the bytes that should be written to the designated file/device (in case of stdout, it could be the terminal driver that is connected to the file descriptor), and will return from interrupt, making the CPU switch to user mode again
p9761
aVThat's the rough plan
p9762
aVThere is more to it (putchar could buffer the output before doing the system call
p9763
aVof course
p9764
aVBut in principle, it works this way
p9765
aVThe MessageBox function too will call some system call in the end, that transfers control into the windows kernel in some or another way similar to the above explanation
p9766
as(dp9767
g15
V34509
p9768
stp9769
a((dp9770
g2
(lp9771
VIt's particularly difficult to add a manipulator to a C++ stream, as one has no control of how the manipulator is used
p9772
aVOne can imbue a new locale into a stream, which has a facet installed that controls how numbers are printed - but not how strings are output
p9773
aVAnd then the problem would still be how to store the quoting state safely into the stream
p9774
aVStrings are output using an operator defined in the  namespace
p9775
aVIf you want to change the way those are printed, yet keeping the look of manipulators, you can create a proxy class:
p9776
aVWhich would be suitable to be used for
p9777
aVIf you want to generalize, you can make it a template too and also accept  instead of plain
p9778
aVIt has different behaviors to standard manipulators in some cases
p9779
aVBecause it works by returning the proxy object, it will not work for cases like
p9780
as(dp9781
g15
V34509
p9782
stp9783
a((dp9784
g2
(lp9785
VThis multi dimensional array topic unfortunately confuses so many C++ programmers
p9786
aVWell, here is the solution:
p9787
aVThat is what the function declaration has to look like
p9788
aVAn alternative, but fully equivalent is
p9789
aVBoth are creating a parameter that is a pointer to an array of 5 integers
p9790
aVYou can then pass your array of arrays of 5 integers to that function:
p9791
aVBecause your array's first element is an array of 5 integers, it will be converted automatically (implicitly) to a pointer to that first element when passed to that function
p9792
aVIn the comments, you have shown you are bound to an , because both your inner and outer dimension must have runtime values
p9793
aVA multi-dimensional array can not be used anymore
p9794
aVWhat you can do for testing purposes then is to create an array of pointers like this:
p9795
aVThen, actually, you can have your function accept a
p9796
aVAs the first element of you array then is a , it will be converted to a  automatically
p9797
aVAnother way of doing this is keeping the data in the 2 dimensional array, but just creating a "view" structured of pointers to that array:
p9798
aVWhere store is your  array
p9799
aVSince  accesses the n'th sub-array of that two-dimensional array and the element type of it is , the pointer-converted type of it is , which will be compatible again
p9800
as(dp9801
g15
V34509
p9802
stp9803
a((dp9804
g2
(lp9805
VYou can write a function that returns the C struct:
p9806
aVIf you wonder whether you can have "normal" member functions in C
p9807
aVWell, you can to some extent
p9808
aVI prefer the object-as-first-argument style
p9809
aVYou pass a pointer to your struct as the first argument
p9810
aVThis way, you can have several functions, defining the interface to your objects:
p9811
aVIf you write in that style, what you have at the end is an abstract data-type
p9812
aVI've seen guys emulating the member function call syntax used in C++ by having function pointers into their struct and then doing:
p9813
aVIt's used by the linux kernel for defining the interface to file system drivers
p9814
aVIt's a style of writing that one may like, or may not like
p9815
aVI don't like it too much, because i keep using members of structures for data and not for emulating member functions calls to look like in popular object oriented languages
p9816
as(dp9817
g15
V34509
p9818
stp9819
a((dp9820
g2
(lp9821
VBy the way, the next C++ version will support user defined literals
p9822
aVThey are already included into the working draft
p9823
aVThis allows that sort of stuff (let's hope i don't have too many errors in it):
p9824
aVwould be a template like this:
p9825
aVWell, what we get are binary literals that evaluate fully at compile time already, because of the "constexpr" above
p9826
aVThe above uses a hard-coded int return type
p9827
aVI think one could even make it depend on the length of the binary string
p9828
aVIt's using the following features, for anyone interested:
p9829
aVGeneralized Constant Expressions
p9830
aVVariadic Templates
p9831
aVA brief introduction can be found here
p9832
aVStatic Assertions (static_assert)
p9833
aVUser defined Literals
p9834
aVActually, current GCC trunk already implements variadic templates and static assertions
p9835
aVLet's hope it will support the other two soon
p9836
aVI think C++1x will rock the house
p9837
as(dp9838
g15
V34509
p9839
stp9840
a((dp9841
g2
(lp9842
VJust to show another way, reverse iterators:
p9843
aVIf you have boost::bind, you can make your life easier
p9844
as(dp9845
g15
V34509
p9846
stp9847
a((dp9848
g2
(lp9849
VYou will need to provide a rebind member template and the other stuff that is listed in the allocator requirements in the C++ Standard
p9850
aVFor example, you need a template copy constructor which accepts not only  but also
p9851
aVFor example, one code might do, which a std::list for example is likely to do
p9852
aVThe code will fail if there either exist no correct rebind template, or there exist no corresponding copy constructor
p9853
aVYou will get nowhere useful with guessing what the requirements are
p9854
aVSooner or later you will have to do with code that relies on one part of those allocator requirements, and the code will fail because your allocator violates them
p9855
aVI recommend you take a look at them in some working draft your your copy of the Standard in
p9856
as(dp9857
g15
V34509
p9858
stp9859
a((dp9860
g2
(lp9861
VYou can say one
p9862
aVcpp file and all its included headers make up one translation unit
p9863
aVAs the name implies, one translation unit is compiled on its own
p9864
aVThe result, often called file
p9865
aVo or file
p9866
aVobj, of each translation unit, is then linked together by the linker, fixing up yet unresolved references
p9867
aVSo in your case you have
p9868
aVYou will have your class definition appear in both translation units
p9869
aVBut that's OK
p9870
aVIt's allowed, as long as both classes are equally defined
p9871
aVBut it's not allowed to have the same function appear in the two translation units if the function is not inline
p9872
aVNot inline functions are allowed to be defined only once, in one single translation unit
p9873
aVThen, you have the linker take the result of each translation unit, and bind them together to an executable:
p9874
as(dp9875
g15
V34509
p9876
stp9877
a((dp9878
g2
(lp9879
VYes, as far as i know the second declaration is invalid in C++ and C89, but it is valid in C99
p9880
aVFrom The C99 draft, TC2 ():
p9881
aVThe special case of an unnamed parameter of type void as the only item in the list
p9882
aVspeci\ufb01es that the function has no parameters
p9883
aVIt's explicitly talking about the type "void", not the keyword
p9884
aVFrom The C++ Standard, :
p9885
aVIf the parameter-declaration-clause is empty, the function takes no arguments
p9886
aVThe parameter list  is equivalent to the empty parameter list
p9887
aVThat it means the actual keyword with "void", and not the general type "void" can also be seen from one of the cases where template argument deduction fails ():
p9888
aVAttempting to create a function type in which a parameter has a type of void
p9889
aVIt's put clear by others, notable in one core language issue report here and some GCC bugreports linked to by other answers
p9890
aVTo recap, your GCC is right but earlier GCC versions were wrong
p9891
aVThus that code might have been successfully compiled with it earlier
p9892
aVYou should fix your code, so that it uses "void" for both functions, then it will compile also with other compilers (comeau also rejects the second declaration with that "VOID")
p9893
as(dp9894
g15
V34509
p9895
stp9896
a((dp9897
g2
(lp9898
VClearly the function, for a simple reason
p9899
aVThe macro evaluates its argument multiple times
p9900
aVThis can have evil side effects
p9901
aVAlso the function can be scoped
p9902
aVNothing better than that :)
p9903
as(dp9904
g15
V34509
p9905
stp9906
a((dp9907
g2
(lp9908
VYou have to reset all status flags (eofbit) and bring the stream into a good state (goodbit):
p9909
aVThe reason is that if you keep extracting until the end, you will hit the end, and the eof flag will be set on that stream
p9910
aVAfter that, read operations will be canceled and you have to clear that flag out again
p9911
aVAnyway, after clearing and resetting the string, you can then go on extracting the integers
p9912
as(dp9913
g15
V34509
p9914
stp9915
a((dp9916
g2
(lp9917
VAs so many answers already said, you don't need the "if" stuff
p9918
aVJust create the bare block
p9919
aVBut i want to get at another point
p9920
aVIn C, you can create variable declarations anywhere in a block, not only at the start
p9921
aVIn C89, you had that restriction
p9922
aVStarting with C99 (that's 10 years now), you don't have that restriction anymore, although some compilers will moan anyway
p9923
aVGCC won't, though, if you tell it to use the most "recent" C Standard with the -std=c99 option
p9924
aVBecause there are still compilers in existence that moan by default, i would not prefer mixing declarations and code though
p9925
aVI would keep putting declarations at the start of blocks for compatibility reasons
p9926
as(dp9927
g15
V34509
p9928
stp9929
a((dp9930
g2
(lp9931
VFor Windows there is this function available in the API
p9932
aVHave a look at its MSDN page
p9933
aVIt sleeps for the specified amount of milliseconds
p9934
as(dp9935
g15
V34509
p9936
stp9937
a((dp9938
g2
(lp9939
VHere is code you could use to make sure you also reject things like
p9940
aVWhere non-number characters follow the number
p9941
aVIf you read the whole line and then parse it and execute actions appropriately it will possibly require you to change the way your program works
p9942
aVIf you program read your number from different places until now, you then have to put one central place that parses one line of input, and decides on the action
p9943
aVBut maybe that's a good thing too - so you could increase the readability of the code that way by having things separated: Input - Processing - Output
p9944
aVAnyway, here is how you can reject the number-non-number of above
p9945
aVRead a line into a string, then parse it with a :
p9946
aVIt eats all trailing whitespace
p9947
aVWhen it hit the end-of-file of the stringstream while reading the integer or trailing whitespace, then it sets the eof-bit, and we check that
p9948
aVIf it failed to read any integer in the first place, then the fail or bad bit will have been set
p9949
aVEarlier versions of this answer used  directly - but  won't work well together with  connected to a terminal (it will block instead waiting for the user to input something), so we use a  for reading the integer
p9950
aVAnswering some of your questions:
p9951
aVQuestion:  1
p9952
aVUsing a try catch block
p9953
aVIt didn't work
p9954
aVI think this is because an exception is not raised due to bad input
p9955
aVAnswer: Well, you can tell the stream to throw exceptions when you read something
p9956
aVYou use the  function, which you tell for which kind of error you want to have an exception thrown:
p9957
aVI did never use it
p9958
aVIf you do that on , you will have to remember to restore the flags for other readers that rely on it not throwing
p9959
aVFinding it way easier to just use the functions fail, bad to ask for the state of the stream
p9960
aVQuestion: 2
p9961
aVI tried  which didn't work either
p9962
aVI haven't yet figured this one out
p9963
aVAnswer: That could come from the fact that you gave it something like "42crap"
p9964
aVFor the stream, that is completely valid input when doing an extraction into an integer
p9965
aVQuestion: 3
p9966
aVThirdly, I tried inputting a fixed length string and then parsing it
p9967
aVI would use atoi()
p9968
aVIs this standards compliant and portable
p9969
aVShould I write my own parsing function
p9970
aVAnswer: atoi is Standard Compliant
p9971
aVBut it's not good when you want to check for errors
p9972
aVThere is no error checking, done by it as opposed to other functions
p9973
aVIf you have a string and want to check whether it contains a number, then do it like in the initial code above
p9974
aVThere are C-like functions that can read directly from a C-string
p9975
aVThey exist to allow interaction with old, legacy code and writing fast performing code
p9976
aVOne should avoid them in programs because they work rather low-level and require using raw naked pointers
p9977
aVBy their very nature, they can't be enhanced to work with user defined types either
p9978
aVSpecifically, this talks about the function "strtol" (string-to-long) which is basically atoi with error checking and capability to work with other bases (hex for example)
p9979
aVQuestion:  4
p9980
aVIf write a class that uses cin, but dynamically does this kind of error detection, perhaps by determining the type of the input variable at runtime, would it have too much overhead
p9981
aVIs it even possible
p9982
aVAnswer: Generally, you don't need to care too much about overhead here (if you mean runtime-overhead)
p9983
aVBut it depends specifically on where you use that class
p9984
aVThat question will be very important if you are writing a high performance system that processes input and needs to have high throughout
p9985
aVBut if you need to read input from a terminal or a file, you already see what this comes down to: Waiting for the user to input something takes really so long, you don't need to watch runtime costs at this point anymore on this scale
p9986
aVIf you mean code overhead - well it depends on how the code is implemented
p9987
aVYou would need to scan your string that you read - whether it contains a number or not, whether some arbitrary string
p9988
aVDepending on what you want to scan (maybe you have a "date" input, or a "time" input format too
p9989
aVLook into  for that), your code can become arbitrary complex
p9990
aVFor simple things like classifying between number or not, i think you can get away with small amount of code
p9991
as(dp9992
g15
V34509
p9993
stp9994
a((dp9995
g2
(lp9996
VWell, it's certainly not well understood by the C community as can be seen by glancing over SO
p9997
aVThe magic is, all of the following are totally, 100%, equivalent:
p9998
aVIt is very important to draw the distinction of a pointer and an array
p9999
aVAn array is not a pointer
p10000
aVAn array can be converted to a pointer to its first element
p10001
aVIf you have a pointer you have this:
p10002
aVHowever, if you have an array, you have this:
p10003
aVWith the pointer, the data is at a whole other planet, but linked to by the pointer
p10004
aVAn array has the data itself
p10005
aVNow, a multi-dimensional array is just an array of arrays
p10006
aVThe arrays are nested into a parent array
p10007
aVSo, the sizeof of your array is:
p10008
aVThat is because you have 10 arrays, all of which are arrays of 10 integers
p10009
aVNow, if you want to pass that array, it is converted
p10010
aVBut to what
p10011
aVA pointer to its first element
p10012
aVThe element type is not a pointer, but an array
p10013
aVAs a consequence, you pass a pointer to an array of 10 int:
p10014
aVIt is neither a array of , nor a
p10015
aVYou may ask why the array is not passed as an
p10016
aVIt's because the compiler has to know the row-length
p10017
aVIf you do an , the compiler will address a place  bytes apart from the begin of the 2 dimensional array
p10018
aVIt decodes that information in the pointer-to-array type
p10019
aVSo, you have to chose among one of the above fully equivalent function prototypes
p10020
aVNaturally, the last one is just confusing
p10021
aVThe compiler just silently ignores any number written in the most outer dimension if a parameter is declared to be an array
p10022
aVSo i would also not use the second last version
p10023
aVBest is to use the first or second version
p10024
aVWhat is important to remember is that C has no (real) array parameters
p10025
aVThe parameter will be a pointer in the end (pointer to array in this case)
p10026
aVNote how the multi-dimensional case of above is similar to the degenerate, one dimensional case below
p10027
aVAll of the following 4 versions are fully equivalent:
p10028
as(dp10029
g15
V34509
p10030
stp10031
a((dp10032
g2
(lp10033
VFor such things, the  keyword is for
p10034
aVPut your cache as a mutable object into your class
p10035
aVThat is because your cache seems to not change the logical content/state of your object (i
p10036
aVe the elements of your vector or the size of it do not change)
p10037
aVmethods do not state they don't physically change your object
p10038
aVThey state that they won't change the abstract value of your object
p10039
aVImplementation details that are abstracted away may still be changed by const functions
p10040
aVThe mutable is for this kind of cases
p10041
aVMake your vector mutable or add a mutable cache member that contains some sort of cache entries
p10042
aVRead the What are the semantics of a const member function answer by Anthony Williams
p10043
as(dp10044
g15
V34509
p10045
stp10046
a((dp10047
g2
(lp10048
VYou have tried to link it already:
p10049
aVThat will not only compile it, but try to already create the executable
p10050
aVThe linker then is unable to find the main function that it needs
p10051
aVWell, do it like this:
p10052
aVThat will create two files file
p10053
aVo and hasmain
p10054
aVo, both only compiled so far
p10055
aVNow you can link them together with g++:
p10056
aVIt will automatically figure out that those are files already compiled, and invoke the linker on them to create a file "my_program" which is your executable
p10057
as(dp10058
g15
V34509
p10059
stp10060
a((dp10061
g2
(lp10062
VDrop the conversion operator
p10063
aVIt will cause troubles all the way
p10064
aVHave a function like
p10065
aVOr similar that returns the double value and call that function explicitly to get a double
p10066
aVFor the problem at hand, there is this problem:
p10067
aVConsider that expression
p10068
aVThe builtin operator matches the first argument by a user defined conversion sequence for your type using the conversion operator long double()
p10069
aVBut your function matches the second argument by a standard conversion sequence from int to long double (integral to floating point conversion)
p10070
aVIt is always ambiguous when there are conversions for two arguments, but not at least one argument that can be converted better while the remaining arguments are not converted worse for one call
p10071
aVIn your case, the builtin one matches the second argument better but the first worse, but your function matches the first argument better but the second worse
p10072
aVIt's confusing, so here are some examples (conversions from char to int are called promotions, which are better than conversions from char to something other than int, which is called a conversion):
p10073
aVCalls the first version
p10074
aVBecause all arguments for the first can be converted better
p10075
aVEqually, the following will still call the first:
p10076
aVBecause the first can be converted better, and the second is not converted worse
p10077
aVBut the following is ambiguous:
p10078
aVIt's more interesting in this case
p10079
aVThe first version accepts the first argument by an exact match
p10080
aVThe second version accepts the second argument by an exact match
p10081
aVBut both versions do not accept their other argument at least equally well
p10082
aVThe first version requires a conversion for its second argument, while the second version requires a promotion for its argument
p10083
aVSo, even though a promotion is better than a conversion, the call to the second version fails
p10084
aVIt's very similar to your case above
p10085
aVEven though a standard conversion sequence (converting from int/float/double to long double) is better than a user-defined conversion sequence (converting from MyClass to long double), your operator version is not chosen, because your other parameter (long double) requires a conversion from the argument which is worse than what the builtin operator needs for that argument (perfect match)
p10086
aVOverload resolution is a complex matter in C++, so one can impossibly remember all the subtle rules in it
p10087
aVBut getting the rough plan is quite possible
p10088
aVI hope it helps you
p10089
as(dp10090
g15
V34509
p10091
stp10092
a((dp10093
g2
(lp10094
VThat code has a bug
p10095
aVCalling  will only guarantee you that you can push_back at least that many elements until references and iterators to the vector are invalidated again (through a possible reallocation of the used buffer)
p10096
aVIt will not allow you to write into v[0
p10097
aV1024*16-1], as you do there with
p10098
aVYou have to do
p10099
aVto actually have that many elements available and actually pass  instead of
p10100
aVFor your substring operation, i would probably do
p10101
aVWhere n ranges from 0 up to v
p10102
aVsize()
p10103
aVYou can use  to guarantee that, if n could be larger in your case and you need an upper limit
p10104
aV(on a side node, i would avoid having a variable called "l" (ell) there, because it can look very much like an "1" (one), which can confuse the hell out of people)
p10105
as(dp10106
g15
V34509
p10107
stp10108
a((dp10109
g2
(lp10110
VUpdate for clarification: The problem is not with stale, freed or uninitialized pointers; instead, I'm implementing an API that takes pointers from the caller (like a pointer to a string, a file handle, etc
p10111
aVThe caller can send (in purpose or by mistake) an invalid value as the pointer
p10112
aVHow do I prevent a crash
p10113
aVYou can't make that check
p10114
aVThere is simply no way you can check whether a pointer is "valid"
p10115
aVYou have to trust that when people use a function that takes a pointer, those people know what they are doing
p10116
aVIf they pass you 0x4211 as a pointer value, then you have to trust it points to address 0x4211
p10117
aVAnd if they "accidentally" hit an object, then even if you would use some scary operation system function (IsValidPtr or whatever), you would still slip into a bug and not fail fast
p10118
aVStart using null pointers for signaling this kind of thing and tell the user of your library that they should not use pointers if they tend to accidentally pass invalid pointers, seriously :)
p10119
as(dp10120
g15
V34509
p10121
stp10122
a((dp10123
g2
(lp10124
VWell, at the time you put that member, the nesting class, myclass, is not complete yet
p10125
aVYou can define the mystruct type afterwards, when myclass is complete:
p10126
aVNote that just because mystruct is a nested type of myclass, that does not mean that myclass contains an object of mystruct
p10127
aVSo there is no problem with circular containment here
p10128
aVSince you mention you come from Java - maybe it helps you when i tell you nested classes are like static nested classes in Java
p10129
aVIn fact, C++ does not have "non-static nested classes" like they exist in Java
p10130
aVSo if you create a myclass object, neither there is a mystruct object automatically created and embedded, nor there is a special relationship between a mystruct that can be created and any created object of the nesting class
p10131
aVWhat nested classes in C++ buy you (probably some more - this is from the top of my head):
p10132
aVIncluding members of the outer class into usual unqualified name-lookup (1)
p10133
aVAutomatic friendship of the nested class and the nesting class - the nested class can access non-public members of the nesting class
p10134
aV(2)
p10135
aVHiding or encapsulating the nested class from outside into the nesting class
p10136
aVHere is an example:
p10137
aVBut you probably meant to put a pointer to the nesting class anyway in your code - which is often needed when nested classes are into the game
p10138
aVYou have to remember that when you have a variable, that variable is the name for the object itself - instead of merely a reference (like in java) to it
p10139
aVA C++ pointer, however, behaves like a Java reference - it can be nulled and point to different objects during its lifetime:
p10140
aVThat will make it merely reference an object of type myclass, which is to be created elsewhere, instead of being that object itself
p10141
aVSo, it is like a node that may have one parent (pointed to by something) - but doesn't have to
p10142
aVAnd like an iterator that points to some container it's iterating over
p10143
aVThere is also the other way around, where the nesting class has a pointer to the nested class (apart from my silly example above)
p10144
aVThat's very commonly used in the pimpl idiom
p10145
aVI highly recommend you to have a look at it
p10146
as(dp10147
g15
V34509
p10148
stp10149
a((dp10150
g2
(lp10151
VFirst, i recommend you a good book too
p10152
aVThere are very good SO threads about C++ books, like The definitive C++ book guide and List
p10153
aVIn the following, you find i tell you how to solve some problems, but i don't delve into details, because i think that's what a book can do much better
p10154
aVI've glanced over the code, here is what i've figured:
p10155
aVThat constructor has 3 parameters, all of which are local to the function
p10156
aVWhen the function returns, the parameters do not exist anymore, and their memory occupied by them is cleaned up automatically
p10157
aVBut you store their addresses into the pointers
p10158
aVThat will fail then
p10159
aVWhat you want is passing pointers
p10160
aVBy the way always use constructor initializer lists:
p10161
aVCreating the tree now does look different:
p10162
aVNew creates a dynamic object and returns a pointer to it
p10163
aVThe pointer must not be lost - otherwise you have a memory-leak because you can't delete the object anymore
p10164
aVNow, make sure you delete child nodes ordinarily by creating a destructor for Node (put it as you would put any other member function):
p10165
aVHere you see it's important to always null-ify pointers: delete on a null pointer will do nothing
p10166
aVTo start cleaning-up, you create a CalcTree destructor too, which starts the delete chain:
p10167
aVDon't forget to create a default constructor for CalcTree that initializes that pointer to 0
p10168
aVNow, you have one remaining problem: If you copy your object, the original object and the copy share the same pointer, and when the second object (the copy) goes out of scope, it will call delete on the pointer a second time, thus deleting the same object twice
p10169
aVThat's unfortunate
p10170
aVIt can be solved by forbidding copying your classes - or by using smart pointers that have shared ownership semantics (look into shared_ptr)
p10171
aVA third variant is to write your own copy constructor and copy assignment operator
p10172
aVWell, here is how you would disable copy constructor and copy assignment operators
p10173
aVOnce you try to copy, you will get a compile error
p10174
aVPut this into Node:
p10175
aVThe same for CalcTree, and you are protected from that subtle bug now
p10176
aVNow, onto your other questions:
p10177
aVIt seems in c++ people prefer to define members of a class outside the class
p10178
aVThat is because the more code you add to the header, the more you have to include into your header from other files (because your code depends on something that's defined in them)
p10179
aVNote that all other files that include that header then will transitively include the headers that one includes too
p10180
aVSo you will in the end have less indirectly included headers when you put your code into separately compiled files instead
p10181
aVAnother problem that is solved are cyclic references
p10182
aVSometimes, you have to write a method that needs to have access to something defined later in the header
p10183
aVSince C++ is a single-pass language, the compiler can't resolve references to symbols that are declared after the point of use - generally
p10184
aVI'd very much like some pointers on c++ conventions
p10185
aVThat's very subjective, but i like this convention:
p10186
aVClass data-members are written like 
p10187
as(dp10188
g15
V34509
p10189
stp10190
a((dp10191
g2
(lp10192
VYou have a compatible function type if the return type and parameter types are compatible - basically (it's more complicated in reality :))
p10193
aVCompatibility is the same as "same type" just more lax to allow to have different types but still have some form of saying "these types are almost the same"
p10194
aVIn C89, for example, two structs were compatible if they were otherwise identical but just their name was different
p10195
aVC99 seem to have changed that
p10196
aVQuoting from the c rationale document (highly recommended reading, btw
p10197
ag1240
aVStructure, union, or enumeration type declarations in two different translation units do not formally declare the same type, even if the text of these declarations come from the same include file, since the translation units are themselves disjoint
p10198
aVThe Standard thus specifies additional compatibility rules for such types, so that if two such declarations are sufficiently similar they are compatible
p10199
aVThat said - yeah strictly this is undefined behavior, because your do_stuff function or someone else will call your function with a function pointer having  as parameter, but your function has an incompatible parameter
p10200
aVBut nevertheless, i expect all compilers to compile and run it without moaning
p10201
aVBut you can do cleaner by having another function taking a  (and registering that as callback function) which will just call your actual function then
p10202
as(dp10203
g15
V34509
p10204
stp10205
a((dp10206
g2
(lp10207
VHeaders and implementation files
p10208
aVThis is also a concept misunderstood by many
p10209
aVQuestions like what goes into header files and why it causes link errors if function definitions appear multiple times in a program on the one side but not when class definitions appear multiple times on the other side
p10210
aVVery similar to those questions is why it is important to have header guards
p10211
as(dp10212
g15
V34509
p10213
stp10214
a((dp10215
g2
(lp10216
VLike someone else said, the C++ Standard does not mandate a virtual method table, but allows one to be used
p10217
aVI've done my tests using gcc and this code and one of the simplest possible scenario:
p10218
aVAdded data-members to prevent the compiler to give the base-class a size-of of zero (it's known as the empty-base-class-optimization)
p10219
aVThis is the layout that GCC chose: (print using -fdump-class-hierarchy)
p10220
aVAs you see each class has a vtable
p10221
aVThe first two entries are special
p10222
aVThe second one points to the RTTI data of the class
p10223
aVThe first one - i knew it but forgot
p10224
aVIt's got some use in more complicated cases
p10225
aVWell, as the layout shows, if you have an object of class Derived1, then the vptr (v-table-pointer) will point to the v-table of class Derived1 of course, which has exactly one entry for its function bark pointing to Derived1's version
p10226
aVDerived2's vptr points to Derived2's vtable, which has two entries
p10227
aVThe other one is the new method that's added by it, smile
p10228
aVIt repeats the entry for Base::bark, which will point to Base's version of the function of course, because it's the most derived version of it
p10229
aVI've also dumped the tree that's generated by GCC after some optimizations are done (constructor inlined,
p10230
aV, with -fdump-tree-optimized
p10231
aVThe output is using GCC's middle-end language  which is front-end independent, indented into some C-like block structure:
p10232
aVAs we can see nicely, it's just setting one pointer - the vptr - which will point to the appropriate vtable we have seen before when creating the object
p10233
aVI've also dumped the assembler code for the creation of the Derived1 and call to use ($4 is first argument register, $2 is return value register, $0 is always-0-register) after demangling the names in it by the  tool :)
p10234
aVWhat happens if we want to call
p10235
ag1240
aVGIMPL code:
p10236
aVis a GIMPL construct which is pretty printed into (it's documented in  in the gcc SVN source-code)
p10237
aVIt's meaning: Use the expression  on the object , and store the frontend (c++) specific value  (it's the index into the vtable)
p10238
aVFinally, it's passing  as the "this" argument
p10239
aVWould we call a function that appears at the 2nd index in the vtable (note, we don't know which vtable of which type
p10240
aV, the GIMPL would look like this:
p10241
aVOf course, here the assembly code again (stack-frame stuff cut off):
p10242
aVRemember that the vptr points exactly at the first function
p10243
aV(Before that entry the RTTI slot were stored)
p10244
aVSo, whatever appears at that slot is called
p10245
aVIt's also marking the call as tail-call, because it happens as the last statement in our  function
p10246
as(dp10247
g15
V34509
p10248
stp10249
a((dp10250
g2
(lp10251
V alone is not a type, but a template which can generate a family of types, such as  and
p10252
aVAll these fields are not related such that the one is somehow derived from the other or such
p10253
aVSo you have to establish some relation between all these generated types
p10254
aVOne way is to use a common non-template base class:
p10255
aVAnd consider using smart pointer instead of that raw pointer in the code
p10256
aVAnyway, now the problem is that the type-information is lost - whether you point to a  or to a  is not known anymore and can only be detected by keeping some sort of type-flag in the base which is set by the templated derived class - or by asking RTTI using
p10257
aVBut that's ugly
p10258
aVEspecially because what you want there is a value semantic
p10259
ag1388
aVe you would want to be able to copy your row, and it would copy all the fields in it
p10260
aVAnd you would want to get a double when a double is stored - without first using RTTI to hack your way to the derived type
p10261
aVOne way of doing it is to use a discriminated union
p10262
aVThat is basically an union for some arbitrary types and in addition a type-flag, which stores what value is currently stored in that field (e
p10263
aVg whether a double, int,
p10264
aVFor example:
p10265
aVboost::variant does all the work for you
p10266
aVYou can use visitation to make it call a functor using the right overload
p10267
aVHave a look at its manual
p10268
as(dp10269
g15
V34509
p10270
stp10271
a((dp10272
g2
(lp10273
VI fully agree with you
p10274
aVIt is the reason that i first explain them how it should be done (i
p10275
aVe when recommending boost::variant, i explain they should in general use a discriminated union
p10276
aVAnd i try not to say it's just a "magic boost thing" but show how they in principle implemented it
p10277
aVWhen i recommend boost::shared_ptr, i explain they would need to use a pointer - but it's better to use a smart pointer that has shared ownership semantics
p10278
aVI try not to say just "use " when i see the questioner is a beginner
p10279
aVIt is a language that's not just as simple to use as some scripting language
p10280
aVOne has to understand the stuff one uses, because the language does not protect the programmer from doing bad things
p10281
aVOf course it's not possible for novices to understand everything from the start on
p10282
aVBut they should understand what their boost library solves and how it does it basically
p10283
aVYou can't compare this with learning processors or assembly language first
p10284
aVSimilar it's not important to know how the bit-pattern of a null-pointer looks like
p10285
aVKnowledge of those are irrelevant in learning programming with C++
p10286
aVBut pointers, array or any other basic things in C++ is not
p10287
aVOne doesn't get around learning them before using  or  successfully
p10288
aVThese are things that has to be understood first in order to use the boost utilities successfully in my opinion
p10289
aVIt's not about details like how to manually implement the pimpl-idiom using raw pointers - that's not the point I'm making
p10290
aVBut the point is that one should first know basic things about pointers or the other parts a boost library helps with (for pointers, what they are and what they are good for, for example)
p10291
aVJust look at the shared_ptr manual and try to get it without knowing about pointers
p10292
aVIt's impossible
p10293
aVAnd it's important to always point them to the appropriate boost manual
p10294
aVBoost manuals are high quality
p10295
as(dp10296
g15
V34509
p10297
stp10298
a((dp10299
g2
(lp10300
VBasic properties of smart pointers
p10301
aVIt's easy when you have properties that you can assign each smart pointer
p10302
aVThere are three important properties
p10303
aVno ownership at all
p10304
aVtransfer of ownership
p10305
aVshare of ownership
p10306
aVThe first means that a smart pointer cannot delete the object, because it doesn't own it
p10307
aVThe second means that only one smart pointer can ever point to the same object at the same time
p10308
aVIf the smart pointer is to be returned from functions, the ownership is transferred to the returned smart pointer, for example
p10309
aVThe third means that multiple smart pointers can point to the same object at the same time
p10310
aVThis applies to a raw pointer too, however raw pointers lack an important feature: They do not define whether they are owning or not
p10311
aVA share of ownership smart pointer will delete the object if every owner gives up the object
p10312
aVThis behavior happens to be needed often, so shared owning smart pointers are widely spread
p10313
aVSome owning smart pointers support neither the second nor the third
p10314
aVThey can therefore not be returned from functions or passed somewhere else
p10315
aVWhich is most suitable for  purposes where the smart pointer is kept local and is just created so it frees an object after it goes out of scope
p10316
aVShare of ownership can be implemented by having a copy constructor
p10317
aVThis naturally copies a smart pointer and both the copy and the original will reference the same object
p10318
aVTransfer of ownership cannot really be implemented in C++ currently, because there are no means to transfer something from one object to another supported by the language: If you try to return an object from a function, what is happening is that the object is copied
p10319
aVSo a smart pointer that implements transfer of ownership has to use the copy constructor to implement that transfer of ownership
p10320
aVHowever, this in turn breaks its usage in containers, because requirements state a certain behavior of the copy constructor of elements of containers which is incompatible with this so-called "moving constructor" behavior of these smart pointers
p10321
aVC++1x provides native support for transfer-of-ownership by introducing so-called "move constructors" and "move assignment operators"
p10322
aVIt also comes with such a transfer-of-ownership smart pointer called
p10323
aVCategorizing smart pointers
p10324
aVis a smart pointer that is neither transferable nor sharable
p10325
aVIt's just usable if you locally need to allocate memory, but be sure it's freed again when it goes out of scope
p10326
aVBut it can still be swapped with another scoped_ptr, if you wish to do so
p10327
aVis a smart pointer that shares ownership (third kind above)
p10328
aVIt is reference counted so it can see when the last copy of it goes out of scope and then it frees the object managed
p10329
aVis a non-owning smart pointer
p10330
aVIt is used to reference a managed object (managed by a shared_ptr) without adding a reference count
p10331
aVNormally, you would need to get the raw pointer out of the shared_ptr and copy that around
p10332
aVBut that would not be safe, as you would not have a way to check when the object was actually deleted
p10333
aVSo, weak_ptr provides means by referencing an object managed by shared_ptr
p10334
aVIf you need to access the object, you can lock the management of it (to avoid that in another thread a shared_ptr frees it while you use the object) and then use it
p10335
aVIf the weak_ptr points to an object already deleted, it will notice you by throwing an exception
p10336
aVUsing weak_ptr is most beneficial when you have a cyclic reference: Reference counting cannot easily cope with such a situation
p10337
aVis like a shared_ptr but it does not keep the reference count in a shared_ptr but leaves incrementing/decrementing the count to some helper functions that need to be defined by the object that is managed
p10338
aVThis has the advantage that an already referenced object (which has a reference count incremented by an external reference counting mechanism) can be stuffed into an intrusive_ptr - because the reference count is not anymore internal to the smart pointer, but the smart pointer uses an existing reference counting mechanism
p10339
aVis a transfer of ownership pointer
p10340
aVYou cannot copy it, but you can move it by using C++1x's move constructors:
p10341
aVThis is the semantic that std::auto_ptr obeys, but because of missing native support for moving, it fails to provide them without pitfalls
p10342
aVunique_ptr will automatically steal resources from a temporary other unique_ptr which is one of the key features of move semantics
p10343
aVauto_ptr will be deprecated in the next C++ Standard release in favor of unique_ptr
p10344
aVC++1x will also allow stuffing objects that are only movable but not copyable into containers
p10345
aVSo you can stuff unique_ptr's into a vector for example
p10346
aVI'll stop here and reference you to a fine article about this if you want to read more about this
p10347
as(dp10348
g15
V34509
p10349
stp10350
a((dp10351
g2
(lp10352
VLet's try with an explanation :)
p10353
aVThat tries to extract from  into an object of struct C
p10354
aVWell, so it needs an operator>> that actually does that work:
p10355
aVIn addition, as another one mentioned, you have to actually add the elements to the vector first:
p10356
aVFor the next time, please format the text (correct indent it)
p10357
aVIt was hard for me to step through it :)
p10358
as(dp10359
g15
V34509
p10360
stp10361
a((dp10362
g2
(lp10363
VClassical example of a buffer-overflow:
p10364
aVThe buffer overflow alone does most often not happen purposely
p10365
aVIt happens most often because of a so-called "off-by-one" error
p10366
aVMeaning you have mis-calculated the array-size by one - maybe because you forgot to account for a terminating null character, or because some other stuff
p10367
aVBut it can also be used for some evil stuff
p10368
aVIndeed, the user long knew this hole, and then inserts say 70 characters, with the last ones containing some special bytes which overwrite some stack-slot - if the user is really tricky he/she will hit the return-address slot in the stack, and overwrites it so it jumps forward into that just inserted buffer: Because what the user entered was not his name, but his shell-code that he previously compiled and dumped out
p10369
aVThat one will then just executed
p10370
aVThere are some problems
p10371
aVFor example, you have to arrange not to have a "\u005cn" in that binary code (because gets would stop reading there)
p10372
aVFor other ways that mess with dangerous string functions, the binary zero is problematic because string functions stop copying there to the buffer
p10373
aVPeople have used  with two times the same value to produce a zero too, without writing a zero byte explicitly
p10374
aVThat's the classic way of doing it
p10375
aVBut there are some security blocks that can tell that such things happened and other stuff that make the stack non-executable
p10376
aVBut i guess there are way better tricks than i just explained
p10377
aVSome assembler guy could probably now tell you long stories about that :)
p10378
aVHow to avoid it
p10379
aVAlways use functions that take a maximal-length argument too, if you are not 100% sure that a buffer is really large enough
p10380
aVDon't play such games as "oh, the number will not exceed 5 characters" - it will fail some day
p10381
aVRemember that one rocket where scientists said that the number will not exceed some magnitude, because the rocket would never be that fast
p10382
aVBut some day, it was actually faster, and what resulted was an integer overflow and the rocket crashed (it's about a bug in Ariane 5, one of the most expensive Computer bugs in history)
p10383
aVFor example, instead of gets use
p10384
aVAnd instead of  use  where suitable and available (or just the C++ style things like istream and stuff)
p10385
as(dp10386
g15
V34509
p10387
stp10388
a((dp10389
g2
(lp10390
V says that the function is not part of C99 but part of POSIX
p10391
aVActivate  or  or any other suitable feature test macro that declares the srandom/random function (see  and )
p10392
aVThis one has good chances, but you need to figure out the macros that are defined/not defined implicitly thereby too by reading the manpages above
p10393
as(dp10394
g15
V34509
p10395
stp10396
a((dp10397
g2
(lp10398
VVisitor pattern, indeed
p10399
aVThen just implement the visitor interface and call
p10400
aVControl will be given to the Visitor, which then can do the appropriate action(s)
p10401
aVIf you need to have the variable locally and of the right type - then however you will hardly get around down-casting it
p10402
aVBut i think driving control to specific implementations using virtual functions often is a good way to solve it
p10403
as(dp10404
g15
V34509
p10405
stp10406
a((dp10407
g2
(lp10408
VYou can fail if you compile the code without telling gcc to compile with C99 mode () and tell it not to know about "special builtin" functions (using )
p10409
aVThen it assumes that your round/roundf function is defined as
p10410
aVBecause in pre-C99 times there were no such functions yet, so it does not have a declaration and implicitly declares them then
p10411
aVAnd this will obviously fail, because the call-side treats the return value as an int, while the callee side (in the definition of those functions in the linked library) returns a float
p10412
aVI get these results for example:
p10413
aVNot that you think now that you could cast the return value to a float and be OK
p10414
aVWell, it's worse
p10415
aVThe return value is not even guaranteed to have anything to do with the float returned
p10416
aVThe call-side reads from a place that it knows where integers are returned
p10417
aVBut your compiler may return floats in another place (say, in a floating pointer register) from the callee side
p10418
aVThe above could actually have done anything, including aborting the program because it behaves in an undefined manner
p10419
aVSo, what can you do to make it work
p10420
aVPass the compiler the  flag or use other ways to round (floor is one of them) which do not require those functions
p10421
aVSee the manpage of
p10422
aVHowever, if you have a very old GCC - i'm not sure whether it supports enough of C99 to have that switch
p10423
aVLook into the feature test macros described in the manpage of round then
p10424
as(dp10425
g15
V34509
p10426
stp10427
a((dp10428
g2
(lp10429
VOf course you are
p10430
aVWhat is different regarding the inheritance is that if you define a class, it will inherit private from other classes/structs
p10431
aVIf you define a struct and derive it from a class or struct, it will be a public inheritance by default:
p10432
aVIf you wonder how you should wrap C structs - i would embed them as a member into the class
p10433
aVBecause the C structs were not designed to be inherited from (think of the neither protected nor virtual destructor in the C structs - they can't have one)
p10434
aVThey are simple aggregates that collect data
p10435
aVAnd putting them as members uses them as such (as in "a point has a pair of an x and an y coordinate")
p10436
aVC structs also expose members that possibly should not be exposed in the class
p10437
aVContainment allows precise control over what is exposed and what not by get/set functions and you can still let it give you a copy or reference to the contained naked C struct object
p10438
as(dp10439
g15
V34509
p10440
stp10441
a((dp10442
g2
(lp10443
VYou have to provide a definition in a translation unit too, in case you use the value variable
p10444
aVThat means, if for example you read its value
p10445
aVThe important thing is that the compiler is not required to give a warning or error if you violate that rule
p10446
aVThe Standard says "no diagnostic required" for a violation
p10447
aVIn the next C++ Standard version, the rule changed
p10448
aVA variable is not used when it is used as a constant expression
p10449
aVSimply reading value above where the variable is initialized directly in the class means that still no definition is required then
p10450
aVSee the definition of  in section  of the Standard and requirement for a definition for static data-members in  (in the C++98 Standard
p10451
aVAppears in paragraph 3 and 4 in the n2800 draft of the next Standard)
p10452
aVCorrection: The rule already changed for c++03: If the variable appears where a integral constant expression is required, no definition is needed (quoting from an unofficial revisions list for the 2003 update), see resolution for this language defect report:
p10453
aVAn expression is potentially evaluated unless it appears where an integral constant expression is required (see 5
p10454
aV19), is the operand of the sizeof operator (5
p10455
ag1037
aV3), or is the operand of the typeid operator and the expression does not designate an lvalue of polymorphic class type (5
p10456
ag976
aV8)
p10457
aVNote that even then, many uses are in cases where an integral constant is not required
p10458
aVCases where one is, is in array dimensions or in template metaprogramming
p10459
aVSo strictly speaking (see this report), only the c++1x solution provides really guarantee that in obvious cases also like  where an integral constant is not required the definition of the static member is not needed, because the next Standard has a different, better wording of 3
p10460
ag976
aVThis is however quite theoretical stuff, since most (all
p10461
aVcompiler don't moan anyway
p10462
aVThanks for the guy in the comment section for telling me
p10463
as(dp10464
g15
V34509
p10465
stp10466
a((dp10467
g2
(lp10468
VIt's traditionally the left side of the "=" operator
p10469
aVHowever, with time, meaning of "lvalue"/"rvalue" changed
p10470
aVC++ added the term of a "non-modifiable lvalue" which is any lvalue that cannot assigned to: arrays and variables that are qualified with "const" are two examples
p10471
aVIn C, you cannot assign to any rvalue (see below)
p10472
aVLikewise, in C++, you cannot assign to rvalues that are not of some user defined class type
p10473
aVYou can say an "lvalue" is an expression that names an object which persists over time and occupies some location of storage
p10474
aVWhether or not you can assign to that expression is not important for that classification
p10475
aVA reference, in particular, is also an lvalue, because it has a name that persists over time
p10476
aVAll the following are lvalues, because they all refer to named objects
p10477
aVAlso note that a  does not have any effect on the lvalue-ness
p10478
aVThe term "rvalue" is used for things like literals and enumerator values and for temporaries that do not enjoy the fun of having a long life and are destroyed right away at the end of a full expression
p10479
aVFor rvalues, not the aspect of persistence is important, but the value-aspect
p10480
aVFunctions in C++ are lvalues, because they are persistent and they have an address, even though they are not objects
p10481
aVI've left them out in the above overview of lvalues, because it's easier to grasp lvalues when first only taking objects into account
p10482
aVAll the following are rvalues:
p10483
aVIncidentally, often you have an lvalue, but an operator needs an rvalue
p10484
aVFor example the binary builtin "+" operator adds two values
p10485
aVAn lvalue expression first and for all specifies a location where a value first has to be read out
p10486
aVSo when you add two variables, an "lvalue to rvalue" conversion takes place
p10487
aVThe Standard says that the value contained in an lvalue expression is its rvalue result:
p10488
aVOther operators do not take rvalue, but lvalues
p10489
aVThey don't read a value
p10490
aVAn example is the address-of operator,
p10491
aVYou cannot take the address of an rvalue expressions
p10492
aVSome rvalues are not even objects: They do not occupy any storage
p10493
aVExamples are again, literals (10, 3
p10494
aV3,
p10495
aVand enumerator values
p10496
aVHow is that scary stuff useful
p10497
aVWell it has several advantages to have the distinction of lvalue and rvalue
p10498
aVAllowing the compiler to omit taking storage for rvalues and using registers/readonly memory for scalar values
p10499
aVFlagging expressions as elusive: rvalues will not live long
p10500
aVAllows efficient copy semantics for the compiler internally and in c++1x also exposed to the programmer (see move semantics and rvalue references): We can steal away resources from rvalues that are going to be destroyed anyway
p10501
aVAllows to build rules upon that property
p10502
aVrvalues are not allowed to be generated from a yet uninitialized objects where an lvalues refers to
p10503
aVBut lvalues may refer to uninitialized objects just fine
p10504
aVrvalues can never be polymorphic
p10505
aVTheir static type must also be their dynamic type: Simplifies rules for the typeid operator
p10506
aVThere is more to it, i feel it
p10507
as(dp10508
g15
V34509
p10509
stp10510
a((dp10511
g2
(lp10512
VJust to say why it probably isn't called : Because  has a dynamic size
p10513
aVAn array conceptually is fixed in length
p10514
aVNext C++ Standard by the way has a  template, which is fixed in size and should be preferred over a plain array:
p10515
as(dp10516
g15
V34509
p10517
stp10518
a((dp10519
g2
(lp10520
VI expect that compiling templated code will be speed up with having variadic templates / rvalue references
p10521
aVToday, if we want to write template code that does something at compile time, we abuse rules of the language
p10522
aVWe create dozens of overloads and template specializations that results in what we want, but not in a way that tells the compiler our intention
p10523
aVSo there is little to shortcut for the compiler at build-time
p10524
aVSee Motivation for variadic templates
p10525
aVAre there projects to develop a new generation of c++ compilers that would optimize this
p10526
aVYes, there is CLang which is a C Language Frontend for the LLVM Compiler infrastructure
p10527
aVBoth CLang and LLVM are coded using C++
p10528
aVAmong the developers of CLang is Douglas Gregor, author of several C++1x Language Proposals like variadic templates and Concepts
p10529
aVFor reference, see this test by Douglas Gregor of clang against GCC
p10530
aVHere are some quick-n-dirty performance results for template instantiation in Clang and GCC 4
p10531
ag976
aVThe test is very simple: measure compilation time (-fsyntax-only) for a translation unit that computes the Nth Fibonacci number via a template metaprogram
p10532
aVClang appears to be scaling linearly (or close to it) with the number of instantiations
p10533
aVAnd, although you can't see it in the chart, Clang is a little over 2x faster than GCC at the beginning ()
p10534
aVCLang is still in its early days but i think it's got good chances to become a great C++ Compiler
p10535
as(dp10536
g15
V34509
p10537
stp10538
a((dp10539
g2
(lp10540
VNope, there is none, unless you do the mapping yourself
p10541
aVC++ has no mechanism to create objects whose types are determined at runtime
p10542
aVYou can use a map to do that mapping yourself, though:
p10543
aVAnd then you can do
p10544
aVGetting a new instance
p10545
aVAnother idea is to have the types register themself:
p10546
aVYou could decide to create a macro for the registration
p10547
aVI'm sure there are better names for those two though
p10548
aVAnother thing which probably makes sense to use here is
p10549
aVIf you have a set of unrelated types that have no common base-class, you can give the function pointer a return type of  instead
p10550
aVLike if you have a class Foo, Bar and Baz, it looks like this:
p10551
aVA  is like an union
p10552
aVIt knows which type is stored in it by looking what object was used for initializing or assigning to it
p10553
aVHave a look at its documentation here
p10554
aVFinally, the use of a raw function pointer is also a bit oldish
p10555
aVModern C++ code should be decoupled from specific functions / types
p10556
aVYou may want to look into  to look for a better way
p10557
aVIt would look like this then (the map):
p10558
aVwill be available in the next version of C++ too, including
p10559
as(dp10560
g15
V34509
p10561
stp10562
a((dp10563
g2
(lp10564
VResponse to Edit: Well, if you need to return hundreds and thousands if values, a tuple of course would not be the way to go
p10565
aVBest pick the solution with the iterator then, but it's best not use any specific iterator type
p10566
aVIf you use iterators, you should use them as generic as possible
p10567
aVIn your function you have used an insert iterator like
p10568
aVYou lost any genericity
p10569
aVDo it like this:
p10570
aVWhatever you give it, it will work now
p10571
aVBut it will not work if you have different types in the return set
p10572
aVYou can use a tuple then
p10573
aVAlso available as  in the next C++ Standard:
p10574
aVIf the amount of values is variadic and the type of the values is from a fixed set, like (int, bool, char), you can look into a container of
p10575
aVThis however implies changes only on the call-side
p10576
aVYou can keep the iterator style of above:
p10577
as(dp10578
g15
V34509
p10579
stp10580
a((dp10581
g2
(lp10582
VIn that particular case, it looks quite strange and like a candidate for review
p10583
aVCan be useful in other cases:
p10584
aVWhere it would limit the scope of
p10585
aVOne common use is to make the objects in it destroy earlier
p10586
aVClasses that do special stuff in their constructor and destructor can then be used inside the braces:
p10587
aVThe lock for the send-queue would be held while sending  in that example, and be released when the locker is destroyed at the closing brace
p10588
as(dp10589
g15
V34509
p10590
stp10591
a((dp10592
g2
(lp10593
VThe destructor for that sort of temporaries is called at the end of the full-expression
p10594
aVThat's the most outer expression which is not part of any other expression
p10595
aVThat is in your case after the function returns and the value is evaluated
p10596
aVSo, it will work all nice
p10597
aVIt's in fact what makes expression templates work: They can keep hold references to that sort of temporaries in an expression like
p10598
aVBecause every temporary will last until the expression
p10599
aVIs evaluated completely
p10600
aVIt's quite concisely described in  in the Standard
p10601
as(dp10602
g15
V34509
p10603
stp10604
a((dp10605
g2
(lp10606
VI think if you overwrite a method and want to all the super-class version of it (like, say for ), then you virtually always want to call the direct superclass version first, which one will call its superclass version in turn if it wants
p10607
aVI think it only makes rarely sense (if at all
p10608
aVi can't think of a case where it does) to call some arbitrary superclass' version of a method
p10609
aVI don't know if that is possible at all in Java
p10610
aVIt can be done in C++:
p10611
as(dp10612
g15
V34509
p10613
stp10614
a((dp10615
g2
(lp10616
VIf you pop elements from a vector, it does not free memory (because that would invalidate iterators into the container elements)
p10617
aVYou can copy the vector to a new vector, and then swap that with the original
p10618
aVThat will then make it not waste space
p10619
aVThe Swap has constant time complexity, because a swap must not invalidate iterators to elements of the vectors swapped: So it has to just exchange the internal buffer pointers
p10620
aVIt is known as the "Shrink-to-fit" idiom
p10621
aVIncidentally, the next C++ version includes a "shrink_to_fit()" member function for std::vector
p10622
as(dp10623
g15
V34509
p10624
stp10625
a((dp10626
g2
(lp10627
VYou can use  for size_t and  for ptrdiff_t like in
p10628
aVBut my manpage says some older library used a different character than  and discourages use of it
p10629
aVNevertheless, it's standardized (by the C99 standard)
p10630
aVFor those  and  of  and so on, there are macros you can use, like another answer said:
p10631
aVThey are listed in the manpage of
p10632
aVPersonally, I would just cast the values to  or  like another answer recommends
p10633
aVIf you use C99, then you can (and should, of course) cast to  or  and use the  or  formats respectively
p10634
as(dp10635
g15
V34509
p10636
stp10637
a((dp10638
g2
(lp10639
VThey are not completely identical
p10640
aVThe first is called "direct initialization" while the second is called "copy initialization"
p10641
aVNow, the Standard makes up two rules
p10642
aVThe first is for direct initialization and for copy initialization where the initializer is of the type of the initialized object
p10643
aVThe second rule is for copy initialization in other cases
p10644
aVSo, from that point of view both are termed in one - the first - rule
p10645
aVIn the case where you have copy initialization with the same type, the compiler is allowed to elide a copy, so it can construct the temporary you create directly into the initialized object
p10646
aVSo you can end up very well with the same code generated
p10647
aVBut the copy constructor, even if the copy is elided (optimized out), must still be available
p10648
ag1388
aVe if you have a private copy constructor, that code is invalid if the code in which it appears has no access to it
p10649
aVThe second is called copy-initialization, because if the type of the initializer is of a different type, a temporary object is created in trying to implicitly convert the right side to the left side:
p10650
aVThe compiler creates a temporary object of the type of myclass then when there is a constructor that takes an int
p10651
aVThen it initializes the object with that temporary
p10652
aVAlso in this case, the temporary created can be created directly in the initialized object
p10653
aVYou can follow these steps by printing messages in constructors / destructors of your class and using the option  for GCC
p10654
aVIt does not try to elide copies then
p10655
aVOn a side-note, that code above has nothing to do with an assignment operator
p10656
aVIn both cases, what happens is an initialization
p10657
as(dp10658
g15
V34509
p10659
stp10660
a((dp10661
g2
(lp10662
VPlease note that  does not measure wall clock time
p10663
aVThat means if your program takes 5 seconds,  will not measure 5 seconds necessarily, but could more (your program could run multiple threads and so could consume more CPU than real time) or less
p10664
aVIt measures an approximation of CPU time used
p10665
aVTo see the difference consider this code
p10666
aVIt outputs on my system
p10667
aVBecause all we did was sleeping and not using any CPU time
p10668
aVHowever, using  we get what we want (
p10669
aVOutputs on my system
p10670
aVIf you need more precision but want to get CPU time, then you can consider using the  function
p10671
as(dp10672
g15
V34509
p10673
stp10674
a((dp10675
g2
(lp10676
VIt's a common problem, because you can't overload functions in C
p10677
aVOnly the compiler can (as in tgmath
p10678
aVh)
p10679
aVHaving a look into  of GCC already served my hack-o-meter for today
p10680
aVThey found the right words i think
p10681
aVPeople have invented different ways to solve it
p10682
aVOpenGL for example take a course where they include parameter types and count into the function name:
p10683
aVTo say the function takes 3 floats
p10684
as(dp10685
g15
V34509
p10686
stp10687
a((dp10688
g2
(lp10689
VIt says in the Boost Faq:
p10690
aVWhat do the Boost version numbers mean
p10691
aVThe scheme is x
p10692
aVy
p10693
aVz, where x is incremented only for massive changes, such as a reorganization of many libraries, y is incremented whenever a new library is added, and z is incremented for maintenance releases
p10694
aVy and z are reset to 0 if the value to the left changes
p10695
as(dp10696
g15
V34509
p10697
stp10698
a((dp10699
g2
(lp10700
VIt helps to look into the sequence of syscalls done by those programs
p10701
aVUse  to do that
p10702
aVI think what  does is crawling through , gathering all the processes and their information
p10703
aVHave a look at the site of procps, download its code and look how they did it
p10704
as(dp10705
g15
V34509
p10706
stp10707
a((dp10708
g2
(lp10709
g1240
aVOr write your own function object if you don't have boost
p10710
aVWould look like this
p10711
as(dp10712
g15
V34509
p10713
stp10714
a((dp10715
g2
(lp10716
VDo you have any virtual function in Base
p10717
aVIt won't work otherwise
p10718
aVIf nothing else, make its dtor virtual
p10719
aVDon't know whether it was already asked by the other guy that deleted his answer, but i believe it was something different: Are you doing the dynamic_cast from the bases' constructor
p10720
aVIf so, that won't work
p10721
aVThe compiler will think that the Base is the most derived type, similar to when you call a virtual function and it ends up calling the version of the Base
p10722
as(dp10723
g15
V34509
p10724
stp10725
a((dp10726
g2
(lp10727
VYes, you are just lucky :) The extern "C" is one language linkage for the C language that every C++ compiler has to support, beside extern "C++" which is the default
p10728
aVCompilers may supports other language linkages
p10729
aVGCC for example supports extern "Java" which allows interfacing with java code (though that's quite cumbersome)
p10730
aVextern "C" tells the compiler that your function is callable by C code
p10731
aVThat can, but not must, include the appropriate calling convention and the appropriate C language name mangling (sometimes called "decoration") among other things depending on the implementation
p10732
aVIf you have a static member function, the calling convention for it is the one of your C++ compiler
p10733
aVOften they are the same as for the C compiler of that platform - so i said you are just lucky
p10734
aVIf you have a C API and you pass a function pointer, better always put one to a function declared with extern "C" like
p10735
aVEven though the function pointer type does not contain the linkage specification but rather looks like
p10736
aVThe linkage is an integral part of the type - you just can't express it directly without a typedef:
p10737
aVThe Comeau C++ compiler, in strict mode, will emit an error for example if you try to assign the address of the extern "C" function of above to a , beause this is a pointer to a function with C++ linkage
p10738
as(dp10739
g15
V34509
p10740
stp10741
a((dp10742
g2
(lp10743
VIt's common to functions to return zero for the common - or one-of-a-kind - case and non-zero for special cases
p10744
aVTake the main function, which conventionally returns zero on success and some nonzero value for failure
p10745
aVThe precise non-zero value indicates what went wrong
p10746
aVFor example: out of memory, no access rights or something else
p10747
aVIn your case, if the string is equal, then there is no reason why it is equal other than that the strings contain the same characters
p10748
aVBut if they are non-equal then either the first can be smaller, or the second can be smaller
p10749
aVHaving it return 1 for equal, 0 for smaller and 2 for greater would be somehow strange i think
p10750
aVYou can also think about it in terms of subtraction:
p10751
aVIf s1 is "lexicographically" less, then it will give is a negative value
p10752
as(dp10753
g15
V34509
p10754
stp10755
a((dp10756
g2
(lp10757
VNo and it will not work reliable with typeid either
p10758
aVIt will give you some internal string that depends on the compiler implementation
p10759
aVSomething like "int", but also "i" is common for
p10760
aVBy the way, if what you want is to only compare whether two types are the same, you don't need to convert them to a string first
p10761
aVYou can just do
p10762
aVAnd then do
p10763
aVBoost already has such a template, and the next C++ Standard will have  too
p10764
aVManual registration of types
p10765
aVYou can specialize on the types like this:
p10766
aVSo, you can use it like
p10767
aVOf course, you can also get rid of the primary template definition (and keep only the forward declaration) if you want to get a compile time error if the type is not known
p10768
aVI just included it here for completion
p10769
aVI used static data-members of char const* previously, but they cause some intricate problems, like questions where to put declarations of them, and so on
p10770
aVClass specializations like above solve the issue easily
p10771
aVAutomatic, depending on GCC
p10772
aVAnother approach is to rely on compiler internals
p10773
aVIn GCC, the following gives me reasonable results:
p10774
aVReturning for
p10775
aVSome  magic intermixed with  will give you the string representation you look for
p10776
as(dp10777
g15
V34509
p10778
stp10779
a((dp10780
g2
(lp10781
VAngelika Langers Secrets of equals gets into that with a long and detailed discussion for a few common and well-known examples, including by Josh Bloch and Barbara Liskov, discovering a couple of problems in most of them
p10782
aVShe also gets into the  vs
p10783
aVSome quote from it
p10784
aVConclusions
p10785
aVHaving dissected the four arbitrarily chosen examples of implementations of equals() , what do we conclude
p10786
aVFirst of all: there are two substantially different ways of performing the check for type match in an implementation of equals()
p10787
aVA class can allow mixed-type comparison between super- and subclass objects by means of the instanceof operator, or a class can treat objects of different type as non-equal by means of the getClass() test
p10788
aVThe examples above illustrated nicely that implementations of equals() using getClass() are generally more robust than those implementations using instanceof
p10789
aVThe instanceof test is correct only for final classes or if at least method equals() is final in a superclass
p10790
aVThe latter essentially implies that no subclass must extend the superclass's state, but can only add functionality or fields that are irrelevant for the object's state and behavior, such as transient or static fields
p10791
aVImplementations using the getClass() test on the other hand always comply to the equals() contract; they are correct and robust
p10792
aVThey are, however, semantically very different from implementations that use the instanceof test
p10793
aVImplementations using getClass() do not allow comparison of sub- with superclass objects, not even when the subclass does not add any fields and would not even want to override equals()
p10794
aVSuch a "trivial" class extension would for instance be the addition of a debug-print method in a subclass defined for exactly this "trivial" purpose
p10795
aVIf the superclass prohibits mixed-type comparison via the getClass() check, then the trivial extension would not be comparable to its superclass
p10796
aVWhether or not this is a problem fully depends on the semantics of the class and the purpose of the extension
p10797
as(dp10798
g15
V34509
p10799
stp10800
a((dp10801
g2
(lp10802
VIn rare cases it can be useful to change the line that is given by  to something else
p10803
aVI've seen GNU configure does that for some tests to report appropriate line numbers after it inserted some voodoo between lines that do not appear in original source files
p10804
aVFor example:
p10805
aVWill make the following lines start with  100
p10806
aVYou can optionally add a new file-name
p10807
aVIt's only rarely useful
p10808
aVBut if it is needed, there are no alternatives i know of
p10809
aVActually, instead of the line, a macro can be used too which must result in any of the above two forms
p10810
aVUsing the boost preprocessor library, you can increment the current line by 50:
p10811
aVI thought it's useful to mention it, since you asked about usage of  and
p10812
aVOne never gets enough surprises out of C++ :)
p10813
aVEdit: @Jonathan Leffler provides some more good use-cases in the comments:
p10814
aVMessing with #line is very useful for pre-processors that want to keep errors reported in the user's C code in line with the user's source file
p10815
aVYacc, Lex, and (more at home to me) ESQL/C preprocessors do that
p10816
as(dp10817
g15
V34509
p10818
stp10819
a((dp10820
g2
(lp10821
VI thought the difference was that in Java all passing of objects is done with pointers automatically, where as in C one has to actually sprinkle little asterisks and ampersands here and there
p10822
aVConceptional, that's quite right
p10823
aVIf we are pedantic (and that's a good thing), we can even say objects are not passed at all in Java
p10824
aVWhat is passed is only ever the "pointer", which in Java is called the reference
p10825
aVAll indirection is done automatically
p10826
aVSo when you do "objref->foo" instead of "objref
p10827
aVfoo" in C and can't use the dot because you work with a pointer, in Java you can still use the dot because it doesn't know anything else to access members anyway
p10828
aVIn C, you can pass the pointer (and here, it is actually called pointer) and you can pass the object itself, in which case a copy is passed
p10829
aVIn C, you access the object that a pointer refers to by indirection using the star or "->"
p10830
aVIn Java, the only way objects are accessed anyway are using the dot (objref
p10831
aVmember)
p10832
aVIf we are pedantic again (now more important again), neither in Java nor in C there is "pass by reference"
p10833
aVWhat we pass in Java is the reference/pointer to the object and in C we either pass a copy of the object (obvious case) or we pass again just a copy of a pointer to the object
p10834
aVSo in both cases - Java and C - what we pass are the addresses of the objects
p10835
aVNot talking about primitive java types, which are copied in both Java and C - even though you can pass their address in C too, there is no difference between an aggregate type (i
p10836
aVe a struct) and a "primitive type" in C in that regard
p10837
as(dp10838
g15
V34509
p10839
stp10840
a((dp10841
g2
(lp10842
VIs operator overload written correctly
p10843
aVIt is, but one can do better
p10844
aVLike someone else mentioned, your function can be defined entirely out of existing, public functions
p10845
aVWhy not make it use only those
p10846
aVRight now, it is a friend, which means it belongs to the implementation details
p10847
aVThe same is true if you put operator<< as a member into your class
p10848
aVHowever, make your operator<< a non-member, non-friend function
p10849
aVIf you change your class, you will not be sure that that your operator<< will still work
p10850
aVBut if your operator<< entirely depends only on public functions, then you can be sure that it will work after changes were made to implementation details of your class only
p10851
aVYay
p10852
aVIs it a good practice to overload operators in situations like this
p10853
aVAs another guy said again, this is arguable
p10854
aVIn many situations, operator overloading will look "neat" at first sight, but will look like hell next year, because you have no clue anymore what you had in mind when giving some symbols special love
p10855
aVIn the case of operator<<, i think this is an OK use
p10856
aVIts use as an insertion operator for streams is well known
p10857
aVAnd i know of Qt and KDE applications that use it extensively in cases like
p10858
aVA similar case is  which also reuses  for passing arguments for placeholders in its string:
p10859
aVIt's of course also arguable to use it there
p10860
aVBut its use for printf format specifies are well known and so its use is OK there too, imho
p10861
aVBut as always, style is also subjective so take it with a grain of salt :)
p10862
aVHow can i accept variable length arguments in a typesafe way
p10863
aVWell, there is the way of accepting a vector if you are looking for homogeneous arguments:
p10864
aVIt's not really confortable to pass it though
p10865
aVYou have to construct your vector manually and then pass
p10866
aVI see you already have the right feeling about the vararg style functions
p10867
aVOne should not use them for this kind of code and only when interfacing with C code or debugging functions if at all
p10868
aVAnother way to handle this case is to apply preprocessor programming
p10869
aVThis is an advanced topic and is quite hacky
p10870
aVThe idea is to automatically generate overloads up to some upper limit roughly like this:
p10871
aVThat is pseudo code
p10872
aVYou can have a look at the boost preprocessor library here
p10873
aVNext C++ version will offer far better possibilities
p10874
aVInitializer lists can be used:
p10875
aVIt's also possible in next C++ to support arbitrary many (mixed-type) arguments using variadic templates
p10876
aVGCC4
p10877
aV4 will have support for them
p10878
aVGCC 4
p10879
aV3 already partially supports them
p10880
as(dp10881
g15
V34509
p10882
stp10883
a((dp10884
g2
(lp10885
VLook into Boost
p10886
aVPython
p10887
aVIt's a library to write python modules with C++
p10888
aVAlso look into SWIG which can also handle modules for other scripting languages
p10889
aVI've used it in the past to write modules for my class and use them within python
p10890
aVWorks great
p10891
aVYou can do it manually by using the Python/C API, writing the interface yourself
p10892
aVIt's pretty lowlevel, but you will gain a lot of additional knowledge of how Python works behind the scene (And you will need it when you use SWIG anyway)
p10893
as(dp10894
g15
V34509
p10895
stp10896
a((dp10897
g2
(lp10898
VThis depends on your goals
p10899
aVYou can use version 1 if you
p10900
aVIntend to replace brakes of a car (at runtime)
p10901
aVIntend to pass Car around to non-template functions
p10902
aVI would generally prefer version 1 using the runtime polymorphism, because it is still flexible and allows you to have the Car still have the same type:  is another type than
p10903
aVIf your goals are great performance while using the brakes frequently, i recommend you to use the templated approach
p10904
aVBy the way, this is called policy based design
p10905
aVYou provide a brake policy
p10906
aVExample because you said you programmed in Java, possibly you are not yet too experienced with C++
p10907
aVOne way of doing it:
p10908
aVIf you have lots of policies you can group them together into their own struct, and pass that one, for example as a  collecting ,  and some more
p10909
aVIn my projects i try to keep a good deal of code template-free, allowing them to be compiled once into their own object files, without needing their code in headers, but still allowing polymorphism (via virtual functions)
p10910
aVFor example, you might want to keep common data and functions that non-template code will probably call on many occasions in a base-class:
p10911
aVIncidentally, that is also the approach that C++ streams use:  contains flags and stuff that do not depend on the char type or traits like openmode, format flags and stuff, while  then is a class template that inherits it
p10912
aVThis also reduces code bloat by sharing the code that is common to all instantiations of a class template
p10913
aVPrivate Inheritance
p10914
aVPrivate inheritance should be avoided in general
p10915
aVIt is only very rarely useful and containment is a better idea in most cases
p10916
aVCommon case where the opposite is true when size is really crucial (policy based string class, for example): Empty Base Class Optimization can apply when deriving from an empty policy class (just containing functions)
p10917
aVRead Uses and abuses of Inheritance by Herb Sutter
p10918
as(dp10919
g15
V34509
p10920
stp10921
a((dp10922
g2
(lp10923
VThe part before the braces is the condition: If we are in line 3, we append some text
p10924
aVIf braces are omitted, the default action is to just print out
p10925
aVRedirect to a new file or pipe to another program as appropriate
p10926
aVYou cannot redirect to the same file you are just reading
p10927
aVA common workaround is to redirect to a new file, and then move over if the command was successful:
p10928
as(dp10929
g15
V34509
p10930
stp10931
a((dp10932
g2
(lp10933
VJust my two cents
p10934
aVThis is not about virtual function in particular, but about inline and member-functions generally
p10935
aVMaybe it is useful
p10936
aVC++
p10937
aVAs far as Standard C++ is concerned, a inline function must be defined in every translation unit in which it is used
p10938
aVAnd an non-static inline function will have the same static variables in every translation unit and the same address
p10939
aVThe compiler/linker will have to merge the multiple definitions into one function to achieve this
p10940
aVSo, always place the definition of an inline function into the header - or place no declaration of it into the header if you define it only in the implementation file ("
p10941
aVcpp") (for a non-member function), because if you would, and someone used it, you would get a linker error about an undefined function or something similar
p10942
aVThis is different from non-inline functions which must be defined only once in an entire program (one-definition-rule)
p10943
aVFor inline functions, multiple definitions as outlined above are rather the normal case
p10944
aVAnd this is independent on whether the call is atually inlined or not
p10945
aVThe rules about inline functions still matter
p10946
aVWhether the Microsoft compiler adheres to those rules or not - i can't tell you
p10947
aVIf it adheres to the Standard in that regard, then it will
p10948
aVHowever, i could imagine some combination using virtual, dlls and different TUs could be problematic
p10949
aVI've never tested it but i believe there are no problems
p10950
aVFor member-functions, if you define your function in the class, it is implicitly inline
p10951
aVAnd because it appears in the header, the rule that it has to be defined in every translation unit in which it is used is automatically satisfied
p10952
aVHowever, if you define the function out-of-class and in a header file (for example because there is a circular dependency with code in between), then that definition has to be inline if you include the corresponding file more than once, to avoid multiple-definition errors thrown by the linker
p10953
aVExample of a file :
p10954
aVThis would have the same effect as placing the definition straight into the class definition
p10955
aVC99
p10956
aVNote that the rules about inline functions are more complicated for C99 than for C++
p10957
aVHere, an inline function can be defined as an inline definition, of which can exist more than one in the entire program
p10958
aVBut if such a (inline-) definition is used (e
p10959
aVg if it is called), then there must be also exactly one external definition in the entire program contained in another translation unit
p10960
aVRationale for this (quoting from a PDF explaining the rationale behind several C99 features):
p10961
aVInlining in C99 does extend the C++ specification in two ways
p10962
aVFirst, if a function is declared inline in one translation unit, it need not be declared inline in every other translation unit
p10963
aVThis allows, for example, a library function that is to be inlined within the library but available only through an external definition elsewhere
p10964
aVThe alternative of using a wrapper function for the external function requires an additional name; and it may also adversely impact performance if a translator does not actually do inline substitution
p10965
aVSecond, the requirement that all definitions of an inline function be "exactly the same" is replaced by the requirement that the behavior of the program should not depend on whether a call is implemented with a visible inline definition, or the external definition, of a function
p10966
aVThis allows an inline definition to be specialized for its use within a particular translation unit
p10967
aVFor example, the external definition of a library function might include some argument validation that is not needed for calls made from other functions in the same library
p10968
aVThese extensions do offer some advantages; and programmers who are concerned about compatibility can simply abide by the stricter C++ rules
p10969
aVWhy do i include C99 into here
p10970
aVBecause i know that the Microsoft compiler supports some stuff of C99
p10971
aVSo in those MSDN pages, some stuff may come from C99 too - haven't figured anything in particular though
p10972
aVOne should be careful when reading it and when applying those techniques to ones own C++ code intended to be portable C++
p10973
aVProbably informing which parts are C99 specific, and which not
p10974
aVA good place to test small C++ snippets for Standard conformance is the comeau online compiler
p10975
aVIf it gets rejected, one can be pretty sure it is not strictly Standard conforming
p10976
as(dp10977
g15
V34509
p10978
stp10979
a((dp10980
g2
(lp10981
VThere is no default value for your pointer
p10982
aVYour pointer will point to whatever it stores currently
p10983
aVAs you haven't initialized it, the line
p10984
aVEffectively accesses some uncertain part of memory
p10985
aVRemember that subcells[i] is equivalent to
p10986
aVIf the left side contains some garbage, you will end up adding  to a garbage value and access the memory at that uncertain location
p10987
aVAs you correctly said, you will have to initialize the pointer to point to some valid memory area:
p10988
aVAfter which line you can access that many bytes
p10989
aVWith regards to other sources of memory, there are different kind of storage that all have their uses
p10990
aVWhat kind you get depends on what kind of object you have and which storage class you tell the compiler to use
p10991
aVreturns a pointer to an object with no type
p10992
aVYou can make a pointer point to that region of memory, and the type of the object will effectively become the type of the pointed to object type
p10993
aVThe memory is not initialized to any value and access usually is slower
p10994
aVObjects so obtained are called
p10995
aVYou can place objects globally
p10996
aVTheir memory will be initialized to zero
p10997
aVFor points, you will get NULL pointers, for floats you will get a proper zero too
p10998
aVYou can rely on a proper initial value
p10999
aVIf you have local variables but use the  storage class specifier, then you will have the same initial value rule as for global objects
p11000
aVThe memory usually is allocated the same way like global objects, but that's in no way a necessity
p11001
aVIf you have local variables without any storage class specifier or with , then your variable will be allocated on the stack (even though not defined so by C, this is what compilers do practically of course)
p11002
aVYou can take its address in which case the compiler will have to omit optimizations like putting it into registers of course
p11003
aVLocal variables used with the storage class specifier , are marked as having a special storage
p11004
aVAs a result, you cannot take its address anymore
p11005
aVIn recent compilers, there is normally no need to use  anymore, because of their sophisticated optimizers
p11006
aVIf you are really expert, then you may get some performance out of it if using it, though
p11007
aVObjects have associated storage durations that can be used to show the different initialization rules (formally, they only define how long at least the objects live)
p11008
aVObjects declared with  and  have automatic storage duration and are not initialized
p11009
aVYou have to explicitly initialize them if you want them to contain some value
p11010
aVIf you do not, they will contain whatever the compiler left on the stack before they began lifetime
p11011
aVObjects that are allocated by  (or another function of that family, like ) have allocated storage duration
p11012
aVTheir storage is not initialized either
p11013
aVAn exception is when using , in which case the memory is initialized to zero ("real" zero
p11014
aVi
p11015
aVe all bytes 0x00, without regard to any NULL pointer representation)
p11016
aVObjects that are declared with  and global variables have static storage duration
p11017
aVTheir storage is initialized to zero appropriate for their respective type
p11018
aVNote that an object must not have a type, but the only way to get a type-less object is using allocated storage
p11019
aV(An object in C is a "region of storage")
p11020
aVSo what is what
p11021
aVHere is the fixed code
p11022
aVBecause once you allocated a block of memory you can't get back anymore how many items you allocated, best is to always store that count somewhere
p11023
aVI've introduced a variale  to the struct that gets the count stored
p11024
aVNow, things look like this for dim=2:
p11025
aVNote that in C, the return value of a function is not needed to be an object
p11026
aVNo storage at all is required to exist
p11027
aVConsequently, you are not allowed to change it
p11028
aVFor example, the following is not possible:
p11029
aVYou will need a "free function" that free's the allocated memory again
p11030
aVBecause storage for allocated objects is not freed automatically
p11031
aVYou have to call  to free that memory for every  pointer in your tree
p11032
aVIt's left as an exercise for you to write that up :)
p11033
as(dp11034
g15
V34509
p11035
stp11036
a((dp11037
g2
(lp11038
VC++ does require the implementation only to provide explicit specializations for two versions of character traits:
p11039
aVThe streams and strings use those traits to figure out a variety of things, like the EOF value, comparison of a range of characters, widening of a character to an int, and such stuff
p11040
aVIf you instantiate a stream like
p11041
aVYou have to make sure that there is a corresponding character trait specialization that the stream can use and that this specialization does do useful things
p11042
aVIn addition, streams use facets to do actual formatting and reading of numbers
p11043
aVLikewise you have to provide specializations of those too manually
p11044
aVThe standard doesn't even require the implementation to have a complete definition of the primary template
p11045
aVSo you could aswell get a compile error:
p11046
aVerror: specialization std::char_traits could not be instantiated
p11047
aVI would use  instead (which is a ) and then go and read into a
p11048
aVWhen interpreting the data in the vector, you can still convert them to  later
p11049
as(dp11050
g15
V34509
p11051
stp11052
a((dp11053
g2
(lp11054
VIt's the terminal that does echo that thing
p11055
aVYou have to tell it to stop doing that
p11056
aVMy manpage of  says
p11057
aVrunning  shows
p11058
aVSo running ioctl with the right parameters could switch that control echo off
p11059
aVLook into  for a convenient interface to those
p11060
aVIt's easy to use them
p11061
aVAlternatively, you can consider using  to read a line of input
p11062
aVAs far as i know, it has options to stop the terminal doing that sort of stuff
p11063
as(dp11064
g15
V34509
p11065
stp11066
a((dp11067
g2
(lp11068
VJust like in C++, an enum in D seems to be a "conserved integer literal" (edit: amazing, D2 even supports floats and strings)
p11069
aVIts enumerators have no location
p11070
aVThey are just immaterial as values without identity
p11071
aVPlacing  is new in D2
p11072
aVIt first defines a new variable
p11073
aVIt is not an lvalue (so you also cannot take its address)
p11074
aVAn
p11075
aVIs like
p11076
aVIf i can trust my poor D knowledge
p11077
aVSo,  in here is not an lvalue (no location and you can't take its address)
p11078
aVA const, however, has an address
p11079
aVIf you have a global (not sure whether this is the right D terminology) const variable, the compiler usually can't optimize it away, because it doesn't know what modules can access that variable or could take its address
p11080
aVSo it has to allocate storage for it
p11081
aVI think if you have a local const, the compiler can still optimize it away just as in C++, because the compiler knows by looking at its scope whether or not anyone is interested in its address or whether everyone just takes its value
p11082
as(dp11083
g15
V34509
p11084
stp11085
a((dp11086
g2
(lp11087
VThe answers by Mitch Wheat and hhafez are completely right and to the point
p11088
aVI'm going to show some additional information which may prove useful sometimes
p11089
aVNote that the same happens if you tell the compiler that you have an array of the right size
p11090
aVAn array as parameter is just declaring a pointer
p11091
aVThe compiler automatically changes that to  even if it was declared as
p11092
aVIf you want to force callers to pass an array of size 100 only, you can accept the address of the array (and the type of that) instead:
p11093
aVIt's a pointer to the array you have in main, so you need to dereference in the function to get the array
p11094
aVIndexing then is done by
p11095
aVNobody I know is doing that and I'm neither doing it myself, because it rather complicates passing of the argument
p11096
aVBut it's good to know about it
p11097
aVYou can call the function like this then
p11098
aVIf you want to accept other sizes too, i would go with the passing-N option the other two answers recommend
p11099
as(dp11100
g15
V34509
p11101
stp11102
a((dp11103
g2
(lp11104
VLike Mykola explains, they are just adding typedefs
p11105
aVImagine for your , you want to fix the first argument to some person
p11106
aVThe  would need to store the first argument somewhere, and so it needs the type of the first argument
p11107
aVprovides that as a typedef:
p11108
aVNow, the returned  object knows that the type of the argument it needs to store is of type Person
p11109
aVSome function objects negate the result of another function object
p11110
aVHere we need the type of the argument too:
p11111
aVThat could also use a templated , but the Standard defines it to use the  type as parameter
p11112
aVThe negator itself is derived from unary_function and needs to provide the first argument type anyway
p11113
aVSometimes, people try to use  to store function objects/pointers
p11114
aVHowever, they cannot be used for that
p11115
aVfulfills that job and will be adopted in the next Standard as
p11116
as(dp11117
g15
V34509
p11118
stp11119
a((dp11120
g2
(lp11121
VI'm following the rules in here
p11122
aVLet me quote from it
p11123
aVwas initially introduced into the C library to deal with fixed-length name fields in structures such as directory entries
p11124
aVSuch fields are not used in the same way as strings: the trailing null is unnecessary for a maximum-length field, and setting trailing bytes for shorter names to null assures efficient field-wise comparisons
p11125
aVstrncpy is not by origin a ``bounded strcpy,'' and the Committee has preferred to recognize existing practice rather than alter the function to better suit it to such use
p11126
aVFor that reason, you will not get a trailing  in a string if you hit the  not finding a  from the source string so far
p11127
aVIt's easy to misuse it (of course, if you know about that pitfall, you can avoid it)
p11128
aVAs the quote says, it wasn't designed as a bounded strcpy
p11129
aVAnd i would prefer not to use it if not necessary
p11130
aVIn your case, clearly its use is not necessary and you proved it
p11131
aVWhy then use it
p11132
aVAnd generally speaking, programming code is also about reducing redundancy
p11133
aVIf you know you have a string containing 'n' characters, why tell the copying function to copy maximal  characters
p11134
aVYou do redundant checking
p11135
aVIt's little about performance, but much more about consistent code
p11136
aVReaders will ask themselves what  could do that could cross the  characters and which makes it necessary to limit the copying, just to read in manuals that this cannot happen in that case
p11137
aVAnd there the confusion start happen among readers of the code
p11138
aVFor the rational to use ,  or , i chose among them like in the above linked document:
p11139
aVwhen i want to copy raw bytes, like bytes of a structure
p11140
aVwhen copying a null terminated string - only when 100% no overflow could happen
p11141
aVwhen copying a null terminated string up to some length, filling the remaining bytes with zero
p11142
aVProbably not what i want in most cases
p11143
aVIt's easy to forget the fact with the trailing zero-fill, but it's by design as the above quote explains
p11144
aVSo, i would just code my own small loop that copies characters, adding a trailing :
p11145
aVJust a few lines that do exactly what i want
p11146
aVIf i wanted "raw speed" i can still look out for a portable and optimized implementation that does exactly this bounded strcpy job
p11147
aVAs always, profile first and then mess with it
p11148
aVLater, C got functions for working with wide characters, called  and  (for )
p11149
aVI would use them likewise
p11150
as(dp11151
g15
V34509
p11152
stp11153
a((dp11154
g2
(lp11155
VIn order to parse a C++ program, the compiler needs to know for certain names whether they are types or not
p11156
aVThe following example demonstrates that
p11157
aVHow should this be parsed
p11158
aVFor many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does
p11159
aVIn C++, the above however can yield vastly different interpretations depending on what  means
p11160
aVIf it's a type, then it will be a declaration of a pointer
p11161
aVHowever if it's not a type, it will be a multiplication
p11162
aVSo the C++ Standard says at paragraph
p11163
aVSome names denote types or templates
p11164
aVIn general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it
p11165
aVThe process that determines this is called name lookup
p11166
aVHow will the compiler find out what a name  refers to, if  refers to a template type parameter
p11167
aVcould be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration
p11168
aVIf a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a dependent name (it "depends" on the template parameters)
p11169
aVYou might recommend to just wait till the user instantiates the template
p11170
aVLet's wait until the user instantiates the template, and then later find out the real meaning of
p11171
aVThis will work and actually is allowed by the Standard as a possible implementation approach
p11172
aVThese compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition
p11173
aVBut instead of bothering the template's users (poor colleagues
p11174
aVwith errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place
p11175
aVSo there has to be a way to tell the compiler that certain names are types and that certain names aren't
p11176
aVThe "typename" keyword
p11177
aVThe answer is: We decide how the compiler should parse this
p11178
aVIf  is a dependent name, then we need to prefix it by  to tell the compiler to parse it in a certain way
p11179
aVThe Standard says at 14
p11180
aV6/2
p11181
aVA name used in a template declaration or definition and that is dependent on a template-parameter is
p11182
aVassumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
p11183
aVby the keyword typename
p11184
aVThere are many names for which  is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with , when  is a type template parameter
p11185
aVBut for  to be a declaration, it must be written as
p11186
aVIf you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler
p11187
aVSometimes, the error consequently is given at definition time
p11188
aVThe syntax allows  only before qualified names - it is therefor taken as granted that unqualified names are always known to refer to types if they do so
p11189
aVA similar gotcha exists for names that denote templates, as hinted at by the introductory text
p11190
aVThe "template" keyword
p11191
aVRemember the initial quote above and how the Standard requires special handling for templates aswell
p11192
aVLet's take the follow innocently looking code
p11193
aVIt might look obvious to a human reader
p11194
aVNot so for the compiler
p11195
aVImagine the following arbitrary definition of  and
p11196
aVThat's actually a valid expression
p11197
aVIt compares  with zero (), and then compares the resulting  against
p11198
aVHowever as you might well know,  in real life is a template, so the compiler knows (14
p11199
aV2/3)
p11200
aVAfter name lookup (3
p11201
aV4) finds that a name is a template-name, if this name is followed by a <, the < is
p11202
aValways taken as the beginning of a template-argument-list and never as a name followed by the less-than
p11203
aVoperator
p11204
aVNow we are back to the same problem as with
p11205
aVWhat if we can't know yet whether the name is a template when parsing the code
p11206
aVWe will need to insert  immediately before the template name, as specified by
p11207
aVThis looks like
p11208
aVTemplate names can not only occur after a  but also after a  or  in a class member access
p11209
aVYou need to insert the keyword there too
p11210
aVDependencies
p11211
aVFor the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard
p11212
aVIn template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions
p11213
aVSuch constructs are generally said to depend on template parameters
p11214
aVThe Standard defines precisely the rules by whether a construct is dependent or not
p11215
aVIt separates them into logically different groups: One catches types, another catches expressions
p11216
aVExpressions may depend by their value and/or their type
p11217
aVSo we have, with typical examples appended
p11218
aVDependent types (e
p11219
aVg: a type template parameter )
p11220
aVValue-dependent expressions (e
p11221
aVg: a non-type template parameter )
p11222
aVType-dependent expressions (e
p11223
aVg: a cast to a type template parameter )
p11224
aVMost of the rules are intuitive and are built up recursively: For example, a type constructed as  is a dependent type if  is a value-dependent expression or  is a dependent type
p11225
aVThe details of this can be read in section  for dependent types,  for type-dependent expressions and  for value-dependent expressions
p11226
aVDependent names
p11227
aVThe Standard is a bit unclear about what exactly is a dependent name
p11228
aVOn a simple read (you know, the principle of least surprise), all it defines as a dependent name is the special case for function names below
p11229
aVBut since clearly  also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition)
p11230
aVTo avoid this problem, I have resorted to a simple interpretation of the Standard text
p11231
aVOf all the constructs that denote dependent types or expressions, a subset of them represent names
p11232
aVThose names are therefore "dependent names"
p11233
aVA name can take different forms - the Standard says
p11234
aVA name is a use of an identifier (2
p11235
aV11), operator-function-id (13
p11236
aV5), conversion-function-id (12
p11237
ag1037
aV2), or template-id (14
p11238
aV2) that denotes an entity or label (6
p11239
ag488
aV4, 6
p11240
aV1)
p11241
aVAn identifier is just a plain sequence of characters / digits, while the next two are the  and  form
p11242
aVThe last form is
p11243
aVAll these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in
p11244
aVA value dependent expression  is not a name, but  is
p11245
aVThe subset of all dependent constructs that are names is called dependent name
p11246
aVFunction names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule
p11247
aVDependent function names
p11248
aVNot primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately
p11249
aVAn identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call
p11250
aVIn the example ,  is a dependent name
p11251
aVIn the Standard, this is specified at
p11252
aVAdditional notes and examples
p11253
aVIn enough cases we need both of  and
p11254
aVYour code should look like the following
p11255
aVThe keyword  doesn't always have to appear in the last part of a name
p11256
aVIt can appear in the middle before a class name that's used as a scope, like in the following example
p11257
aVIn some cases, the keywords are forbidden, as detailed below
p11258
aVOn the name of a dependent base class you are not allowed to write
p11259
aVIt's assumed that the name given is a class type name
p11260
aVThis is true for both names in the base-class list and the constructor initalizer list
p11261
aVIn using-declarations it's not possible to use  after the last , and the C++ committee said not to work on a solution
p11262
as(dp11263
g15
V34509
p11264
stp11265
a((dp11266
g2
(lp11267
VHas been some time since i worked with ELF
p11268
aVBut i think i still remember this stuff
p11269
aVNo, it does not physically contain those zeros
p11270
aVIf you look into an ELF file program header, then you will see each header has two numbers: One is the size in the file
p11271
aVAnd another is the size as the section has when allocated in virtual memory ():
p11272
aVHeaders of type  are the one that are copied into virtual memory when the file is loaded for execution
p11273
aVOther headers contain other information, like the shared libraries that are needed
p11274
aVAs you see, the  and  significantly differ for the header that contains the  section (the second  one):
p11275
aVFor this example code:
p11276
aVThe ELF specification says that the part of a segment that the mem-size is greater than the file-size is just filled out with zeros in virtual memory
p11277
aVThe segment to section mapping of the second  header is like this:
p11278
aVSo there are some other sections in there too
p11279
aVFor C++ constructor/destructors
p11280
aVThe same thing for Java
p11281
aVThen it contains a copy of the  section and other stuff useful for dynamic linking (i believe this is the place that contains the needed shared libraries among other stuff)
p11282
aVAfter that the  section that contains initialized globals and local static variables
p11283
aVAt the end, the  section appears, which is filled by zeros at load time because file-size does not cover it
p11284
aVBy the way, you can see into which output-section a particular symbol is going to be placed by using the  linker option
p11285
aVFor gcc, you use  to put the option through to the linker
p11286
aVThe above example shows that  is allocated within
p11287
aVIt may help you verify that your uninitialized objects really end up in  and not somewhere else:
p11288
aVGCC keeps uninitialized globals in a COMMON section by default, for compatibility with old compilers, that allow to have globals defined twice in a program without multiple definition errors
p11289
aVUse  to make GCC use the
p11290
aVbss sections for object files (does not make a difference for the final linked executable, because as you see it's going to get into a
p11291
aVbss output section anyway
p11292
aVThis is controlled by the linker script
p11293
aVDisplay it with )
p11294
aVBut that shouldn't scare you, it's just an internal detail
p11295
aVSee the manpage of gcc
p11296
as(dp11297
g15
V34509
p11298
stp11299
a((dp11300
g2
(lp11301
VTwo guesses:
p11302
aVIf you are in a  block, you can get C++ language linkage again by specifying a nested
p11303
aVIt reserves  linkage, because it's the document defining C++
p11304
aVWho is in a better position for defining  language linkage than it itself
p11305
aVIt also provides for completeness
p11306
aVSame deal as with
p11307
aVRead this answer that explains  (i
p11308
aVe GCC has ) aswell
p11309
as(dp11310
g15
V34509
p11311
stp11312
a((dp11313
g2
(lp11314
VI would not worry about it
p11315
aVIf you do it in a loop, strings will always preallocate memory to minimize reallocations - just use  in that case
p11316
aVAnd if you do it manually, something like this or longer
p11317
aVThen it's creating temporaries - even if the compiler could eliminate some return value copies
p11318
aVThat is because in a successively called  it does not know whether the reference parameter references a named object or a temporary returned from a sub  invocation
p11319
aVI would rather not worry about it before not having profiled first
p11320
aVBut let's take an example for showing that
p11321
aVWe first introduce parentheses to make the binding clear
p11322
aVI put the arguments directly after the function declaration that's used for clarity
p11323
aVBelow that, i show what the resulting expression then is:
p11324
aVNow, in that addition,  is what was returned by the first call to operator+ with the shown arguments
p11325
aVWe assume the compiler is really clever and optimizes out the return value copy
p11326
aVSo we end up with one new string that contains the concatenation of  and
p11327
aVNow, this happens:
p11328
aVCompare that to the following:
p11329
aVIt's using the same function for a temporary and for a named string
p11330
aVSo the compiler has to copy the argument into a new string and append to that and return it from the body of
p11331
aVIt cannot take the memory of a temporary and append to that
p11332
aVThe bigger the expression is, the more copies of strings have to be done
p11333
aVNext Visual Studio and GCC will support c++1x's move semantics (complementing copy semantics) and rvalue references as an experimental addition
p11334
aVThat allows figuring out whether the parameter references a temporary or not
p11335
aVThis will make such additions amazingly fast, as all the above will end up in one "add-pipeline" without copies
p11336
aVIf it turns out to be a bottleneck, you can still do
p11337
aVThe  calls append the argument to  and then return a reference to themselves
p11338
aVSo no copying of temporaries is done there
p11339
aVOr alternatively, the  can be used, but you would need ugly parentheses to fix precedence
p11340
as(dp11341
g15
V34509
p11342
stp11343
a((dp11344
g2
(lp11345
VI would not make this cache a local static
p11346
aVThe mutable map is the solution for caching results
p11347
aVOtherwise it will make your function useless, as different objects of your class will share the same cache, as the local static cache is the same for all objects
p11348
aVYou can use the local static if the result does not depend on the object though
p11349
aVBut then i would ask myself why the function is a non-static member of your object, if it does not need to access any state of it
p11350
aVAs you say it should be thread-safe - if different threads can call the member function on the same object, you probably want to use a mutex
p11351
aVis a good library to use
p11352
as(dp11353
g15
V34509
p11354
stp11355
a((dp11356
g2
(lp11357
VI've seen quite a lot of examples that use a fixed set of arguments, like in your name example, and have used them myself too and i can't see anything wrong with it
p11358
aVHowever there is a good reason that many tutorials or small articles avoid showing factories that forward parameters to the constructed objects: It is practically impossible to forward arbitrary number of arguments (even for a sane limit like 6 arguments)
p11359
aVEach parameter you forward has to be accepted as  and  if you want to do it generic
p11360
aVFor more complicated examples, however, you need an exponentially growing set of overloads (for each parameter, a const and a nonconst version) and perfect forwarding is not possible at all (so that temporaries are forwarded as temporaries, for example)
p11361
aVFor the next C++ Standard that issue is solved:
p11362
aVThat way, you can call
p11363
aVAnd it will return
p11364
aVRead the article i linked above
p11365
as(dp11366
g15
V34509
p11367
stp11368
a((dp11369
g2
(lp11370
VUnless you overwrite  again in , no it is not possible
p11371
aVBecause there is no final overrider in a D object: Both  and  override
p11372
aVYou have several options:
p11373
aVDrop either  or
p11374
aVThen, the one that still overrides  has the final overrider
p11375
aVPlace a final overrider in D
p11376
aVThen, that one overrides  aswell as  in  and
p11377
aVFor example the following results in a compile time error:
p11378
aVYou can, however derive non-virtual from A in C and B, but then you have no diamond inheritance anymore
p11379
aVThat is, each data-member in A appears twice in B and C because you have two A base-class sub-objects in an D object
p11380
aVI would recommend you to rethink that design
p11381
aVTry to eliminate double-objects like that that require virtual inheritance
p11382
aVIt often cause such kind of conflicting situations
p11383
aVA case very similar to this is when you want to override a specific function
p11384
aVImagine you have a virtual function with the same name in B and C (now without a common base A)
p11385
aVAnd in D you want to override each function but give different behavior to each
p11386
aVDepending whether you call the function with a B pointer or C pointer, you have the different behavior
p11387
aVMultiple Inheritance Part III by Herb Sutter describes a good way of doing that
p11388
aVIt might help you decide on your design
p11389
as(dp11390
g15
V34509
p11391
stp11392
a((dp11393
g2
(lp11394
VI think the error comes from the fact that old C did not know const yet: strcmp there took two pointers to non-const characters () i think (which could be the reason why it compiled back then, but not with your compiler)
p11395
aVHowever, nowadays strcmp takes  ( is the same thing)
p11396
aVChange your function prototype to this:
p11397
as(dp11398
g15
V34509
p11399
stp11400
a((dp11401
g2
(lp11402
VIf you use GCC, you can make your function
p11403
aVThose can be overridden by non-weak functions:
p11404
aVtest
p11405
aVc:
p11406
aVWhat does it do
p11407
aVtest1
p11408
aVc:
p11409
aVWhat does it do
p11410
aVSadly, that won't work for other compilers
p11411
aVBut you can have the weak declarations that contain overridable functions in their own file, placing just an include into the API implementation files if you are compiling using GCC:
p11412
aVweakdecls
p11413
aVh:
p11414
aVfunctions
p11415
aVc:
p11416
aVDownside of this is that it does not work entirely without doing something to the api files (needing those three lines and the weakdecls)
p11417
aVBut once you did that change, functions can be overridden easily by writing a global definition in one file and linking that in
p11418
as(dp11419
g15
V34509
p11420
stp11421
a((dp11422
g2
(lp11423
VYou apparently forgot to include the object file of your application which defines the  function
p11424
aVMaybe you typed  instead of  (to actually create an object file instead of a ready linked binary already)
p11425
aVA static library really is not much more than just an archive of many or few object files (archived by the  utility) with a symbol table index attached for quick lookups
p11426
aVSo if you include the object files manually in the link i think it's doing essentially the same
p11427
aVTry the following to view the object files it contains
p11428
as(dp11429
g15
V34509
p11430
stp11431
a((dp11432
g2
(lp11433
VYour  probably is represented signed
p11434
aVCast it to  instead to avoid that it becomes a negative integer when casting to :
p11435
aVDepending on your needs,  might do a better job, checking for a printable character, including space:
p11436
aVNote that you have to cast to : input for  requires values between  and  as character values
p11437
as(dp11438
g15
V34509
p11439
stp11440
a((dp11441
g2
(lp11442
VI would also wrap a vector:
p11443
aVThere is no need to add many more functions to it, i think
p11444
aVYou can always get the vector using  and operate on it directly
p11445
aVSince a vectors' storage is contiguous, you can use it like a C array, but it is still resizable:
p11446
aVThe template conversion constructor and  function allows you to initialize or assign from a C array directly
p11447
aVIf you like, you can add more constructors that can initialize from a set of two iterators or a pointer and a length
p11448
aVBut i would try keeping the amount of added functionality low, so it keeps being a tight, transparent vector wrapping struct
p11449
as(dp11450
g15
V34509
p11451
stp11452
a((dp11453
g2
(lp11454
VIf your file-scope variable is not static, then you can use a declaration that uses extern in a nested scope:
p11455
aVIf the variable is declared with static, i don't see a way to refer to it
p11456
as(dp11457
g15
V34509
p11458
stp11459
a((dp11460
g2
(lp11461
VIgnoring every syntactic sugar and possibilities that can be done with the one and not with the other and difference between pointers and references explained in other answers (to other questions)
p11462
aVYeah those two are functionally exactly the same
p11463
aVBoth call the function and both handle virtual functions equally well
p11464
aVAnd no, your line does not slice
p11465
aVIt's just binding the reference directly to the object pointed to by a pointer
p11466
aVSome questions on why you would want to use one over the other:
p11467
aVDifference between pointer and reference
p11468
aVAre there any benefits of passing by pointer over reference
p11469
aVPointer vs
p11470
aVReference
p11471
aVInstead of trying to come up with differences myself, i delegate you to those in case you want to know
p11472
as(dp11473
g15
V34509
p11474
stp11475
a((dp11476
g2
(lp11477
VI think of concepts as a kind of meta-interface
p11478
aVThey categorize types after their abilities
p11479
aVThe next C++ version supplies native concepts
p11480
aVI hadn't understood it until i came across C++1x's concepts and how they allow putting different yet unrelated types together
p11481
aVImagine you have a  interface
p11482
aVYou can model that with two ways
p11483
aVOne is a subtype relationship:
p11484
aVOf course, every class that derives from that implements the Range interface and can be used with your functions
p11485
aVBut now you see it is limited
p11486
aVWhat about an array
p11487
aVIt's a range too
p11488
aVSadly, you cannot derive an array from that Range class implementing that interface
p11489
aVYou need an extra method (overloading)
p11490
aVAnd what about third party containers
p11491
aVA user of your library might want to use their containers together with your functions
p11492
aVBut he can't change the definition of their containers
p11493
aVHere, concepts come into game:
p11494
aVNow, you say something about the supported operations of some type which can be fulfilled if  has the appropriate member functions
p11495
aVIn your library, you would write the function generic
p11496
aVThis allows you accept any type so long as it supports the required operations:
p11497
aVIt's a great kind of substitutability
p11498
aVAny type will fit the bill that adheres to the concept, and not only those types that actively implement some interface
p11499
aVThe next C++ Standard goes further: It defines a  concept that will be fit by plain arrays (by something caled concept map that defines how some type fits some concept) and other, existing standard containers
p11500
aVThe reason why I bring this up is because I have a templated container, where the containers themselves have a hierarchical relationship
p11501
aVI would like to write algorithms that use these containers without caring about which specific container it is
p11502
aVAlso, some algorithms would benefit from knowing that the template type satisfied certain concepts (Comparable, for example)
p11503
aVYou can actually do both with templates
p11504
aVYou can keep having your hierarchical relationship to share code, and then write the algorithms in a generic fashion
p11505
aVFor example, to communicate that your container is comparable
p11506
aVThat's like standard random-access/forward/output/input iterator categories are implemented:
p11507
aVIt's a reasonable simple way to do it, actually
p11508
aVNow you can call a function and it will forward to the correct implementation
p11509
aVThere are actually different techniques that can be used to implement that
p11510
aVAnother way is to use  to enable or disable different implementations each time
p11511
as(dp11512
g15
V34509
p11513
stp11514
a((dp11515
g2
(lp11516
VYou just do
p11517
aVSee the shared_ptr manual
p11518
aVIt is equivalent to
p11519
aVYou call  on every smart pointer that should not reference the object anymore
p11520
aVThe last such  (or any other action that causes the reference count drop to zero, actually) will cause the object to be free'ed using the deleter automatically
p11521
aVMaybe you are interested in the Smart Pointer Programming Techniques
p11522
aVIt has an entry about delayed deallocation
p11523
as(dp11524
g15
V34509
p11525
stp11526
a((dp11527
g2
(lp11528
VI think it might be helpful to link to an answer explaining this good too
p11529
aVIt is about  by Logan Capaldo
p11530
as(dp11531
g15
V34509
p11532
stp11533
a((dp11534
g2
(lp11535
V can do that:
p11536
as(dp11537
g15
V34509
p11538
stp11539
a((dp11540
g2
(lp11541
VYou want to use  which fills the following struct:
p11542
aVFor completion, :
p11543
aVAs always, consult the manpage for details ()
p11544
as(dp11545
g15
V34509
p11546
stp11547
a((dp11548
g2
(lp11549
VConsider using the Boost zip filters
p11550
aVAccording to them, it supports ,  and  format
p11551
aVboost zlib
p11552
aVboost gzip
p11553
aVboost bzip2
p11554
as(dp11555
g15
V34509
p11556
stp11557
a((dp11558
g2
(lp11559
VI've used a sequence of clear and str in the past:
p11560
aVWhich has done the thing for both input and output stringstreams
p11561
aVAlternatively, you can manually clear, then seek the appropriate sequence to the begin:
p11562
aVThat will prevent some reallocations done by  by overwriting whatever is in the output buffer currently instead
p11563
aVResults are like this:
p11564
aVIf you want to use the string for c-functions, you can use , putting a terminating null like this:
p11565
aVis a relict of the deprecated , which was able to write directly to a char array you allocated on the stack
p11566
aVYou had to insert a terminating null manually
p11567
aVHowever,  is not deprecated, i think because it's still useful as in the above cases
p11568
as(dp11569
g15
V34509
p11570
stp11571
a((dp11572
g2
(lp11573
VIf you use shared memory, you can't pass the pointer
p11574
aVThe pointer will contain the virtual address, which is different from one process to another
p11575
aVYou have to exchange offset values, based on the start of the shared memory area
p11576
aVIf you don't use shared memory, you can't exchange pointers of any kind: The other process won't be able to access the memory of your process
p11577
as(dp11578
g15
V34509
p11579
stp11580
a((dp11581
g2
(lp11582
VThe function is used to make a copy of c-strings
p11583
aVThat's often needed to get a writable version of a string literal
p11584
aVThey (string literals) are itself not writable, so such a function copies them into an allocated writable buffer
p11585
aVYou can then pass them to functions that modify their argument given, like  which writes into the string it has to tokenize
p11586
aVI think you can come up with something like this, since it is called newstrdup:
p11587
aVYou would be supposed to free it once done using the string using
p11588
aVAn alternative way of writing it is using
p11589
aVIf the library is old, it may have used that, which C++ inherited from C:
p11590
aVNow, you are supposed to free the string using  when done:
p11591
aVPrefer the first version if you are writing with C++
p11592
aVBut if the existing code uses  to deallocate the memory again, use the second version
p11593
aVBeware that the second version returns  if no memory is available for dup'ing the string, while the first throws an exception in that case
p11594
aVAnother note should be taken about behavior when you pass a  argument to your
p11595
aVDepending on your library that may be allowed or may be not allowed
p11596
aVSo insert appropriate checks into the above functions if necessary
p11597
aVThere is a function called  available in POSIX systems, but that one allows neither  arguments nor does it use the  operator new to allocate memory
p11598
aVAnyway, i've looked with google codesearch for  functions and found quite a few
p11599
aVMaybe your library is among the results:
p11600
aVGoogle CodeSearch, newstrdup
p11601
as(dp11602
g15
V34509
p11603
stp11604
a((dp11605
g2
(lp11606
VYou almost certainly don't want the parameters be pointers in that case
p11607
aVConsider this example for why:
p11608
aVFor references to constant that is no problem
p11609
aVYou could easily nest operations even:
p11610
as(dp11611
g15
V34509
p11612
stp11613
a((dp11614
g2
(lp11615
VMake  like this (and remove  and the ):
p11616
aVThe reason you get this warning is because static variables survive one function call
p11617
aVTheir value is retained across all function calls (without regard to which thread calls that function)
p11618
aVSo,  will control whether you initialize
p11619
aVThe first time you call the function that code is in will correctly initialize the  variable
p11620
aVBut with every further function call,  is zero, and you will not initialize  anymore, and thus will use an uninitialized variable down the code
p11621
aVEdit: Now, with your updated information, you say that you have two  functions
p11622
aVThe first time you want to use one, and all the other times you want to use another function
p11623
aVHow about this then:
p11624
aVDepending on your actual use case, there may be better ways to handle this, though
p11625
aVFor example, why not update the state of , like this:
p11626
aVSomething like this for :
p11627
aVThat pattern is called : You associate some useful action with the constructor and destructor of a locally allocated object
p11628
as(dp11629
g15
V34509
p11630
stp11631
a((dp11632
g2
(lp11633
VYes, it mandates that (both evaluation order and short circuit)
p11634
aVIn your example if all functions return true, the order of the calls are strictly from functionA then functionB and then functionC
p11635
aVUsed for this like
p11636
aVSame for the comma operator:
p11637
aVOne says between the left and right operand of , ,  and between the first and second/third operand of  (conditional operator) is a "sequence point"
p11638
aVAny side effects are evaluated completely before that point
p11639
aVSo, this is safe:
p11640
aVNote that the comma operator is not to be confused with the syntactical comma used to separate things:
p11641
aVThe C++ Standard says in :
p11642
aVThe && operator groups left-to-right
p11643
aVThe operands are both implicitly converted to type bool (clause 4)
p11644
aVThe result is true if both operands are true and false otherwise
p11645
aVUnlike &, && guarantees left-to-right
p11646
aVevaluation: the second operand is not evaluated if the first operand is false
p11647
aVAnd in :
p11648
aVThe || operator groups left-to-right
p11649
aVThe operands are both implicitly converted to bool (clause 4)
p11650
aVIt returns true if either of its operands is true, and false otherwise
p11651
aVUnlike |, || guarantees left-to-right evaluation; moreover, the second operand is not evaluated if the first operand evaluates to true
p11652
aVIt says for both next to those:
p11653
aVThe result is a bool
p11654
aVAll side effects of the first expression except for destruction of temporaries (12
p11655
aV2) happen before the second expression is evaluated
p11656
aVIn addition to that,  says
p11657
aVIn the evaluation of each of the expressions
p11658
aVusing the built-in meaning of the operators in these expressions (5
p11659
aV14, 5
p11660
aV15, 5
p11661
aV16, 5
p11662
aV18), there is a sequence point after the evaluation of the first expression
p11663
as(dp11664
g15
V34509
p11665
stp11666
a((dp11667
g2
(lp11668
VI've come up with this one:
p11669
aVDrop the second  if the search within the directories for jpg files should be recursive considering sub-directories
p11670
aVNote that that only considers the name of the files
p11671
aVYou could rename a file, hiding that it is a jpg picture
p11672
aVYou can use the  command to do a guess on the content, instead (now, also searches recursively):
p11673
aVHowever, that is much slower, since it has to read part of the files and eventually interpret what they contain (if it is lucky, it finds a magic id at the start of the file)
p11674
aVThe  prevents it from printing  (the current directory) as another directory that it searches
p11675
as(dp11676
g15
V34509
p11677
stp11678
a((dp11679
g2
(lp11680
VLiterally, you can solve it like this:
p11681
aVIf you want to move all the pictures beyond 77 and other numbers too, Daniel L solution will do it too
p11682
aVHis one is simplier and the best ad hoc solution if you know those are the only files with a  prefix
p11683
as(dp11684
g15
V34509
p11685
stp11686
a((dp11687
g2
(lp11688
VSubtract '0' like this:
p11689
aVThe C Standard guarantees each digit in the range  is one greater than its previous digit (in section  of the C99 draft)
p11690
aVThe same counts for C++
p11691
as(dp11692
g15
V34509
p11693
stp11694
a((dp11695
g2
(lp11696
VYou initialize it normally with :
p11697
aVNow, that is using "brace elision"
p11698
aVSome compilers warn for that, even though it is completely standard, because it could confuse readers
p11699
aVBetter you add braces, so it becomes clear what is initialized where:
p11700
aVIf you only want to initialize the  member of the points, you can do so by omitting the other initializer
p11701
aVRemaining elements in aggregates (arrays, structs) will be value initialized to the "right" values - so, a  for pointers, a  for bool, zero for ints and so on, and using the constructor for user defined types, roughly
p11702
aVThe row initializing the points looks like this then
p11703
aVNow you could see the danger of using brace elision
p11704
aVIf you add some member to your struct, all the initializers are "shifted apart" their actual elements they should initialize, and they could hit other elements accidentally
p11705
aVSo you better always use braces where appropriate
p11706
aVConsider using constructors though
p11707
aVI've just completed your code showing how you would do it using brace enclosed initializers
p11708
as(dp11709
g15
V34509
p11710
stp11711
a((dp11712
g2
(lp11713
VDo you mean without opening them in an editor
p11714
aVUse :
p11715
aVThe  redirects the output of the  command (which output file ) to the file
p11716
aVBut instead of overwriting contents of , it appends to it
p11717
aVIf you use a single , it will instead overwrite any previous content in
p11718
as(dp11719
g15
V34509
p11720
stp11721
a((dp11722
g2
(lp11723
VThis is very interesting
p11724
aVI found out it is the display manager setting a cookie
p11725
aVThat one can be used to register processes to belong to a "session" which are managed by a daemon called
p11726
aVThat is to support fast user switching
p11727
aVMy KDE4
p11728
ag976
aV1 system apparently supports it too
p11729
aVRead this fedora wiki entry
p11730
aVSo this environment variable is like  to give access to some entity (in the case of  a login-session managed by ConsoleKit)
p11731
aVFor example having that environment variable in place, you can ask the manager for your current session:
p11732
aVThe Manager also supports querying for the session some process belongs to
p11733
aVHowever, it does not list or somehow contain variables that is related to some  job
p11734
aVHowever, documentation of  says that  will automatically find the right DBUS bus address
p11735
aVFor example, files are stored in  that contain the correct current dbus session addresses
p11736
as(dp11737
g15
V34509
p11738
stp11739
a((dp11740
g2
(lp11741
VYou have a case like this:
p11742
aVNow, you use that in some context that requires  to be assignable - possible in a container (like a map, vector or something else)
p11743
aVThis will fail, because the implicitly defined copy assignment operator does something along this line:
p11744
aVBut  is const
p11745
aVYou have to make it non-const
p11746
aVIt doesn't hurt because as long as you don't change it, it's still logically const :) You could fix the problem by introducing a suitable  too, making the compiler not define one implicitly
p11747
aVBut that's bad because you will not be able to change your const member
p11748
aVThus, having an operator=, but still not assignable
p11749
aV(because the copy and the assigned value are not identical
p11750
ag1240
aVHowever in your case, the apparent problem apparently lies within
p11751
aVRemember that a  is sorted on the keys it contains
p11752
aVBecause of that, you cannot change its keys, because that could easily render the state of a map invalid
p11753
aVBecause of that, the following holds:
p11754
aVThat is, it forbids changing its keys that it contains
p11755
aVSo if you do
p11756
aVThe map throws an error at you, because in the pair of some value stored in the map, the  member has a const qualified type
p11757
as(dp11758
g15
V34509
p11759
stp11760
a((dp11761
g2
(lp11762
VThe error is in the line before
p11763
aVChange the typedef to
p11764
aVTo make it a pointer to a const member function type
p11765
aVThe difference might be more clear when considering this code and how it works:
p11766
aVA member-function pointer in particular is actually just a special case of a member-pointer in general
p11767
aVFor a const member function, the function type of the member function is different than for a non-const member function
p11768
aVThat is why the types have to match
p11769
as(dp11770
g15
V34509
p11771
stp11772
a((dp11773
g2
(lp11774
VDeclare it in one header file (using ), and define it in one  (or whatever other extension) file
p11775
aVYou may use a function and return a reference to a static variable like you showed to circumvent problems with construction order relative to other such namespace scope variables in other  files
p11776
aVBut remember that won't protect you from destruction order problems - which is in the exact reverse order from construction (these things are called "static initialization order fiasco"
p11777
aVIf you use a function like yours and put it into headers, make it inline to make the redefinition of the function valid when it is included into multiple  files (logically, the function is still only apparent once, because the static in it will only exist once, not separately for each file it is included into)
p11778
aVAlternatively just declare it in a header but define it in one  file (but then, remove the inline from it
p11779
aVThe potential problems with destruction order can be circumvented by using :
p11780
aVThe destructor of it, however, will never be called then
p11781
aVIf you need thread safety, you should add a mutex that protects against multiple accesses
p11782
aVprobably has something for that
p11783
as(dp11784
g15
V34509
p11785
stp11786
a((dp11787
g2
(lp11788
VI answered it here
p11789
aVOne thing i put into this answer here: Neither is using any assignment operator
p11790
aVShort explanation for the string specific thing though
p11791
aVhas a constructor taking one argument that accepts :
p11792
aVNow you see that has a constructor taking a pointer to character(s)
p11793
aVSo that it can accept a string literal
p11794
aVI think the following case is obvious then:
p11795
aVIt will call the constructor directly and initialize  thereby
p11796
aVThis is called direct initialization
p11797
aVThe other way of initializing a variable is called copy initialization
p11798
aVThe Standard says for the case of copy initialization where the initializer has not the type of the object it is initializing, the initializer is converted to the proper type
p11799
aVFirst, let's state the types
p11800
aVhas type std::string
p11801
aVis an array, which in this case again is handled like a pointer
p11802
aVWe will therefor consider it as
p11803
aVThe compiler looks for two ways to do the conversion
p11804
aVIs there a conversion constructor in std::string
p11805
aVDoes the initializer has a type that has a conversion operator function returning a
p11806
aVIt will create a temporary  by one of those ways that is then used to initialize the object  by using 's copy constructor
p11807
aVAnd it sees  has a conversion constructor that accepts the initializer
p11808
aVSo it uses it
p11809
aVIn the end, it is effectively the same as
p11810
aVNote that the form that is used in your example that triggered all that
p11811
aVdefines an implicit conversion
p11812
aVYou can mark the constructor taking the  as explicit for your types if you wonder about the initialization rules for your stuff, and it will not allow to use the corresponding constructor as a conversion constructor anymore:
p11813
aVWith that, initializing it using a  and a  actually is forbidden now (and in various other places)
p11814
aVNow, that was if the compiler does not support elision of temporaries at various places
p11815
aVThe compiler is allowed to assume that a copy constructor copies in this context, and can eliminate the extra copy of the temporary string, and instead construct the temporary std::string directly into the initialized object
p11816
aVHowever, the copy constructor must be accessible in particular
p11817
aVSo, the copy initialization is invalid if you do this
p11818
aVNow actually, only the direct initialization case is valid
p11819
as(dp11820
g15
V34509
p11821
stp11822
a((dp11823
g2
(lp11824
VWell there are definitely known problems regarding the performance of strings and other containers
p11825
aVMost of them have to do with temporaries and unnecessary copies
p11826
aVIt's not too hard to use it right, but it's also quite easy to Do It Wrong
p11827
aVFor example, if you see your code accepting strings by value where you don't need a modifyable parameter, you Do It Wrong:
p11828
aVYou better had taken that by const reference or done a swap operation inside, instead of yet another copy
p11829
aVPerformance penalty increases for a vector or list in that case
p11830
aVHowever, you are right definitely that there are known problems
p11831
aVFor example in this:
p11832
aVWe are creating one temporary foo just to add a new Foo into our vector
p11833
aVIn a manual solution, that might create the foo directly into the vector
p11834
aVAnd if the vector reaches its capacity limit, it has to reallocate a larger memory buffer for its elements
p11835
aVWhat does it do
p11836
aVIt copies each element separately to their new place using their copy constructor
p11837
aVA manual solution might behave more intelligent if it knows the type of the elements before-hand
p11838
aVAnother common problem is introduced temporaries
p11839
aVHave a look at this
p11840
aVThere are loads of temporaries created, which you might avoid in a custom solution that you actually optimize onto performance
p11841
aVBack then, the interface of  was designed to be copy-on-write friendly
p11842
aVHowever, with threads becoming more popular, transparent copy on write strings have problems keeping their state consistent
p11843
aVRecent implementations tend to avoid copy on write strings and instead apply other tricks where appropriate
p11844
aVMost of those problems are solved however for the next version of the Standard
p11845
aVFor example instead of push_back, you can use emplace_back to directly create a Foo into your vector
p11846
aVAnd instead of creating copies in a concatenation above, std::string will regognize when it concatenates temporaries and optimize for those cases
p11847
aVReallocation will also avoid making copies, but will move elements where appropriate to their new places
p11848
aVFor an excellent read, consider Move Constructors by Andrei Alexandrescu
p11849
aVSometimes, however, comparisons also tend to be unfair
p11850
aVStandard containers have to support the features they have to support
p11851
aVFor example if your container does not keep map element references valid while adding/removing elements from your map, then comparing your "faster" map to the standard map can become unfair, because the standard map has to ensure that elements keep being valid
p11852
aVThat was just an example, of course, and there are many such cases that you have to keep in mind when stating "my container is faster than standard ones
p11853
as(dp11854
g15
V34509
p11855
stp11856
a((dp11857
g2
(lp11858
VThis  keeps the first occurrence
p11859
aVSame algorithm as other answers use:
p11860
aVHere's one that only needs to store duplicated lines (as opposed to all lines) using :
p11861
as(dp11862
g15
V34509
p11863
stp11864
a((dp11865
g2
(lp11866
VIt has to be a integral constant expression
p11867
aVThat's explained by the Standard document at :
p11868
aVAn integral constant-expression can involve only literals (2
p11869
aV13), enumerators, const variables or static data members of integral or enumeration types initialized with constant expressions (8
p11870
aV5), non-type template parameters of integral or enumeration types, and sizeof expressions
p11871
aVFloating literals (2
p11872
aV13
p11873
aV3) can appear only if they are cast to integral or enumeration types
p11874
aVOnly type conversions to integral or enumeration types can be used
p11875
aVNote that "integral" is another term for "integer", but is not the same as "int"
p11876
aV"char" for example has integer/integral type, but is not the int type, obviously
p11877
aVSo concretely, the following is allowed
p11878
aVof course, any other template parameter as detailed above
p11879
aVAny of those can be used as a template argument for a parameter that has an integral type of the corresponding type
p11880
aVSome conversions are still applied though
p11881
aVSo if it wants an int and you pass a char, it automatically promotes the char to the int
p11882
aVSame if you provide an enumerator and it wants an int
p11883
aVSo by those rules, if you have
p11884
aVAnd it does not see a definition which initializes that constant with a integral constant expression, it can't be used as a template argument
p11885
aVBut it can be used as a function argument, of course
p11886
aVThose don't need to be known at compile time because those are not part of a type
p11887
aVThe moment you name a template specialization, the arguments you used become part of the type:
p11888
aVNote that there are other ways to pass  as an argument
p11889
aVHowever, all of which can not be accepted by an integer template parameter
p11890
aVYou can accept the above by a reference parameter, for example
p11891
aVAnd it would accept the  of above
p11892
aVNow, rather than a value, a particular location that is unique across the whole program (as the variable has  linkage) has been chosen
p11893
as(dp11894
g15
V34509
p11895
stp11896
a((dp11897
g2
(lp11898
VI prefer a map
p11899
aVYou may also decide to increment the counter if you want to count the calls too
p11900
aVBut note that it is also not really fail-safe
p11901
aVIf you delete an object, and then new it again and it happens to get the same address, it will be assumed to be already printed
p11902
as(dp11903
g15
V34509
p11904
stp11905
a((dp11906
g2
(lp11907
VThe problem isn't whether or not you write  or
p11908
aVThe problem has to do with the type of the template parameter of your function template
p11909
aVIts type has to match the one used in the declaration of
p11910
aVThat's  according to the Standard (section )
p11911
aVThe exception are array dimensions, for which you can use any integer type (even  - then the only size that can be accepted is  of course):
p11912
aVBut in other occasions, types have to match
p11913
aVNote that this is only true for autodeduced template arguments, but not for explicitly given ones
p11914
aVThe reason is that for deduced ones, the compiler tries to figure out the best match between actual template arguments and what it deduced from the call to it
p11915
aVMany otherwise implicit conversions are disallowed then
p11916
aVYou have the full range of conversions available if you put the argument explicit (ignoring the solution of using  now to make my point)
p11917
as(dp11918
g15
V34509
p11919
stp11920
a((dp11921
g2
(lp11922
VThat completely depends on which hardware you have, which determines which driver you need
p11923
aVBack then, i got a simple led and put it into the printer LPT port
p11924
aVThen i could write a byte to address 0x0378h and the bits in it determined whether a pin had power or not (using linux)
p11925
aVFor windows, you need a driver that allows you to access the lpt port directly
p11926
aVI did it with a friend back then too, and it worked nicely (we built up a traffic light :)) Read this page (click on Parallel Port on the left
p11927
aVFor some reason, i cannot link directly to it) for details on windows
p11928
aVAnd read  on linux
p11929
aVNow, that Port is really old
p11930
aVBut if you have some machine around that still got one, i think it's a lot of fun to play with it
p11931
aVAnyway, i've got a fritz box that has a neat LED
p11932
aVOne can connect to it via  and then write something (i forgot the numbers) into  iirc
p11933
aVA kernel driver then interprets the number and makes the right LED blink
p11934
aVThat's another way of doing it :)
p11935
as(dp11936
g15
V34509
p11937
stp11938
a((dp11939
g2
(lp11940
VYou apparently talk about  (no tags yet, so i'll think it is C++ here)
p11941
aVWell you seem to want to say
p11942
aVAs arguments to my template, i accept any type that models a string
p11943
aVSadly, currently that is not possible yet
p11944
aVIt requires the  feature that will be in the next C++ version
p11945
aVHere is a video about them
p11946
aVWhat you can do is accept  if you want to keep it generic, for example if you want to accept wide character strings aswell as narrow character strings
p11947
aVIt will not accept other or custom string classes that happen to be strings too
p11948
aVIf you want that, keep it totally free of what it accepts and what not
p11949
aVYou will have to tell the users of that library what functions and type they have to expose for that to work
p11950
aVThe compiler will not know about that contract
p11951
aVInstead, it will just throw error messages when it comes to call the function with a type that's not a string
p11952
aVOften, you will find pages of error messages and it's difficult to get to the real reason of what goes wrong
p11953
aVThe proposed Concepts feature for the next version of the standard fixes that nicely
p11954
aVIf you did not intend to write such a generic function, you can just go ahead and write a normal function like this
p11955
aVIf you did not intend to invent that function to learn in the first place, but because you did not find another already written algorithm, look into the boost string algorithm library
p11956
aVThen you can write
p11957
as(dp11958
g15
V34509
p11959
stp11960
a((dp11961
g2
(lp11962
VI prefer remove_if
p11963
aVreturns an iterator pointing after the last element that's still in the sequence
p11964
aVerases everything from its first to its last argument (both iterators)
p11965
as(dp11966
g15
V34509
p11967
stp11968
a((dp11969
g2
(lp11970
VOk, fixing your main function and iostream
p11971
ag3601
aVThis is the way
p11972
aVI figured i should explain why that works
p11973
aVThe code defines a structure that has a constructor and a destructor
p11974
aVThe constructor is run when you create an object of the struct and the destructor is run when that object is destroyed
p11975
aVNow, at the end of a struct definition, you can put declarators that will have the type
p11976
aVSo, what we did above is creating an object called  which is constructed (and the constructor called) at program start - even before main is run
p11977
aVAnd when the program terminates, the object is destroyed and the destructor is run
p11978
aVIn between,  printed "Love"
p11979
aVThat pattern actually is very well known by the term  which usually claims some resource in the constructor and releases it again in the destructor call
p11980
as(dp11981
g15
V34509
p11982
stp11983
a((dp11984
g2
(lp11985
VThere is a good discussion about that
p11986
aVP
p11987
aVJ
p11988
aVPlauger answers to this
p11989
aVI'm the guy who insisted back in 1983 that the space of
p11990
aVnames available to a C program be partitioned into:
p11991
aVa) those defined by the implementation for the benefit of the programmer (such as printf)
p11992
aVb) those reserved to the programmer (such as foo)
p11993
aVc) those reserved to the implementation (such as _unlink)
p11994
aVWe knew even then that "the implementation" was too monolithic --
p11995
aVoften more than one source supplies bits of the implementation --
p11996
aVbut that was the best we could do at the time
p11997
aVStandard C++
p11998
aVhas introduced namespaces to help, but they have achieved only
p11999
aVa fraction of their stated goals
p12000
aV(That's what happens when you
p12001
aVstandardize a paper tiger
p12002
aVIn this particular case, Posix supplies a list of category (a) names
p12003
aV(such as unlink) that you should get defined when and only when you
p12004
aVinclude certain headers
p12005
aVSince the C Standard stole its headers from
p12006
aVUnix, which is the same source as for Posix, some of those headers
p12007
aVoverlap historically
p12008
aVNevertheless, compiler warnings should have
p12009
aVsome way of taking into account whether the supported environment
p12010
aVis "pure" Standard C++ (a Platonic ideal) or a mixed C/C++/Posix
p12011
aVenvironment
p12012
aVThe current attempt by Microsoft to help us poor
p12013
aVprogrammers fails to take that into account
p12014
aVIt insists on treating
p12015
aVunlink as a category (b) name, which is myopic
p12016
aVWell, GCC will not declare POSIX names in strict C mode, at least (though, it still does in C++ mode):
p12017
aVOutput using
p12018
aVYou will have to tell it explicitly that you are operating in a mixed C/Posix by using feature test macros or not passing any specific standard
p12019
aVIt will then default to  which assumes a mixed environment ()
p12020
aVApparently, MSVC does not have that possibility
p12021
as(dp12022
g15
V34509
p12023
stp12024
a((dp12025
g2
(lp12026
VYour problem is that you should accept a reference in your function
p12027
aVThe reason is that a reference does not actually copy the argument passed
p12028
aVIf you however accept an  - instead of a reference  - then you actually copy the argument passed into the parameter object, and what you get is an object of type  - but which is actually not allowed
p12029
aVAnd then you will have to change the member in your class to be a pointer
p12030
aVIt can't be a reference because  will change what it references - a reference can only reference one object during its entire lifetime, while a pointer can be set to point do different things just by reassigning it a different address
p12031
aVThe remaining parts look like this then
p12032
aVAlso note that you have to compile C++ programs using , because it additionally links the C++ standard library to your code
p12033
as(dp12034
g15
V34509
p12035
stp12036
a((dp12037
g2
(lp12038
VIf the size is determined at runtime, easiest to use one is a vector
p12039
aVNow you can copy, swap, resize it and it will act accordingly
p12040
aVIf you need a pointer to the begin, you can do that with
p12041
aVIf the size is determined and fixed at compile time, you can use boost::array
p12042
aVYou can use it like an array, but can also copy it and do stuff like  like with the vector
p12043
aVIf you need a pointer to the begin, you can do that with  or
p12044
aVThere is the way using raw pointers too like you did, and copying it manually
p12045
aVBut it is cumbersome as you will need to remember to  them, which a vector will do all for you
p12046
as(dp12047
g15
V34509
p12048
stp12049
a((dp12050
g2
(lp12051
VIn C, it's common to define macros that do some stuff getting the verbatim argument, and at the same time define functions to be able to get the address of it transparently
p12052
as(dp12053
g15
V34509
p12054
stp12055
a((dp12056
g2
(lp12057
VIf you have a file descriptor and want a , you can use
p12058
aVis a Posix function and documented in
p12059
aVTo do the reverse you can use
p12060
as(dp12061
g15
V34509
p12062
stp12063
a((dp12064
g2
(lp12065
VThat looks like a candidate for
p12066
aVI've written something using  that probably looks more than disgusting, but provides a generalization of your algorithm
p12067
aVI would probably prefer the manual loop
p12068
aVC++1x will make look that really much better with lambda expressions
p12069
as(dp12070
g15
V34509
p12071
stp12072
a((dp12073
g2
(lp12074
VFrom a theoretical point of view, yes
p12075
aVBut it's a horrible thing to do
p12076
aVis a null pointer constant that is assigned to a pointer to make it point to nothing
p12077
aVHere are the references to the Standard if you are interested in any case
p12078
aVFirst, a null pointer constant is ()
p12079
aVA null pointer constant is an integral constant expression (5
p12080
aV19) rvalue of integer type that evaluates to zero
p12081
aVThen, what happens if we convert a null pointer constant to
p12082
aVIt's explained in :
p12083
aVAn rvalue of arithmetic, enumeration, pointer, or pointer to member type can be converted to an rvalue of type bool
p12084
aVA zero value, null pointer value, or null member pointer value is converted to false; a
p12085
aV(When it talks about  it essentially means a simple value as opposed to a variable of that type)
p12086
aVNow, what actually is that
p12087
aVRead  (note that in C, a null pointer constant is defined differently
p12088
aVWhich might be the reason it explicitly refers to C++)
p12089
aVThe macro NULL is an implementation-defined C++ null pointer constant in this International Standard
p12090
aVThe important bit of that combination is the part ""
p12091
aVAn assignment of  to a bool variable will try to convert  to a boolean value
p12092
aVAs the above passages say, such a conversion exist and can be done
p12093
aVAnother important thing about null pointers to understand is the different between a  and a
p12094
aVAs we just read, a null pointer constant is some integer value that's zero
p12095
aVHowever, a  and its value, a , are pointers and their type is of pointer type
p12096
aVThe following has type int and is a null pointer constant
p12097
aVBecause it is a integral constant expression (that is essentially an integer value that is known at compile time) with value zero
p12098
aVThe following is a null pointer value
p12099
aVbut it is not a null pointer constant
p12100
aVBut anyway, also null pointer values are converted to bool as the above quote tells: ""
p12101
aVSo you are all fine
p12102
as(dp12103
g15
V34509
p12104
stp12105
a((dp12106
g2
(lp12107
VThe reason is that when instantiating a class template, all its declarations (not the definitions) of its member functions are instantiated too
p12108
aVThe class template is instantiated precisely when the full definition of a specialization is required
p12109
aVThat is the case when it is used as a base class for example, as in your case
p12110
aVSo what happens is that  is instantiated at
p12111
aVat which point  is not a complete type yet (it is after the closing brace of the class definition)
p12112
aVHowever, 's declaration requires  to be complete, because it is crawling in the scope of it:
p12113
aVWhat you need to do is delaying the instantiation to some point at which  is complete
p12114
aVOne way making it work is to completely omit that way of declaring  and make it a member template instead
p12115
aVIt is still type-safe because if var is not of the right type, passing  to  will fail to work
p12116
as(dp12117
g15
V34509
p12118
stp12119
a((dp12120
g2
(lp12121
VIf you intend to store arbitrary binary data, you should use
p12122
aVIt is the only data type that is guaranteed to have no padding bits by the C Standard
p12123
aVEach other data type may contain padding bits in its object representation (that is the one that contains all bits of an object, instead of only those that determines a value)
p12124
aVThe padding bits' state is unspecified and are not used to store values
p12125
aVSo if you read using  some binary data, things would be cut down to the value range of a char (by interpreting only the value bits), but there may still be bits that are just ignored but still are there and read by
p12126
aVMuch like padding bits in real struct objects
p12127
aVType  is guaranteed to not contain those
p12128
aVThat follows from  (C99 TC2, n1124 here):
p12129
aVIf the value of an object of type char is treated as a signed integer when used in an
p12130
aVexpression, the value of  shall be the same as that of  and the
p12131
aVvalue of  shall be the same as that of
p12132
aVOtherwise, the value of
p12133
aVshall be 0 and the value of  shall be the same as that of
p12134
aVThe value  shall equal
p12135
aVFrom the last sentence it follows that there is no space left for any padding bits
p12136
aVIf you use  as the type of your buffer, you also have the problem of overflows: Assigning any value explicitly to one such element which is in the range of  bits - so you may expect such assignment to be OK - but not within the range of a , which is
p12137
aV, such a conversion overflows and causes implementation defined results, including raise of signals
p12138
aVEven if any problems regarding the above would probably not show in real implementations (would be a very poor quality of implementation), you are best to use the right type from the beginning onwards, which is
p12139
aVFor strings, however, the data type of choice is , which will be understood by string and print functions
p12140
aVUsing  for these purposes looks like a wrong decision to me
p12141
aVFor further information, read  which contain a fix for a next version of the C Standard which eventually will require  not have any padding bits either
p12142
aVIt's already incorporated into the working paper
p12143
as(dp12144
g15
V34509
p12145
stp12146
a((dp12147
g2
(lp12148
VI suspect your test is flawed
p12149
aVYou can't test with only one such file whether the compiler ignores the inline specifier or not
p12150
aVYou need to include the header containing the inline function definition and include it into multiple implementation files that are then linked together
p12151
aVIf you get linker errors about multiple defined instances of that functions, then the compiler is ignoring the inline specifier regarding its most important property: Allowing it to be defined multiple times across the entire program while still retaining the same address for it and its local static variables
p12152
aVWhat your test probably checks is whether or not the compiler inlines the call to the function, which is actually only a hint to the compiler and only a small of many other more important consequences of the inline specifier
p12153
aVIf the compiler does not not inline a call to the function, it is fine doing so
p12154
aVThe standard does not require it to do anything in this matter
p12155
as(dp12156
g15
V34509
p12157
stp12158
a((dp12159
g2
(lp12160
VYou can never change the data-type of any variable
p12161
aVIf you have  it is the same as  always
p12162
aVThough, for function declarations, there are special cases
p12163
aVActually,
p12164
aVand
p12165
aVOr any combination of  in it all declare the same function
p12166
aVTo outside, they are all the same and have actually also all the same type
p12167
aVIt only matters for definition of functions
p12168
aVIf you don't put const
p12169
aVyou can change the parameters (which in this example are copies of the arguments passed)
p12170
aVBut if you put const, parameters will be const within the function definition
p12171
aVWhy does it not matter whether you write const or not for function declarations
p12172
aVBecause the argument will be copied, and so it will not have any impact on the caller and the callers arguments anyway
p12173
aVFor that reason, the following style is recommended
p12174
aVIn a header, declare the functions without const
p12175
aVThen, in the definition, if you want a parameter to be const, put the const in
p12176
aVSame counts for member functions
p12177
aVNote that we only talked about the const that affects the constness of the parameter directly
p12178
aVThere are other const that affect constness when using references or pointers
p12179
aVThose consts are not to be ignored and are actually important
p12180
as(dp12181
g15
V34509
p12182
stp12183
a((dp12184
g2
(lp12185
VYou asked for a practical example of volatile member functions
p12186
aVWell i can't think of one because the only situations i could imagine are so low-level that i would not consider using a member function in the first place, but just a plain struct with data-members accessed by a volatile reference
p12187
aVHowever, let's put a const volatile function into it just for the sake of answering the question
p12188
aVAssume you have a port with address 0x378h that contains 2 integers, 4 bytes each
p12189
aVThen you could write
p12190
aVYou are stating
p12191
aVI'm not changing them, but another thing outside this abstract semantics could change it
p12192
aVSo always do a real load from its address
p12193
aVActually, volatile signals that the value of an object might not be the value last stored into it but is actually unknown and might have been changed in between by external (not observable by the compiler) conditions
p12194
aVSo when you read from a volatile object, the compiler has to emulate the exact abstract semantics, and perform no optimizations:
p12195
aVThe following already determines what  does
p12196
aVEverything can be found in  of the Standard
p12197
aVThe parameters it talks about are implementation defined things, like the sizeof of some type
p12198
aVThe semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine
p12199
aVThis International Standard places no requirement on the structure of conforming implementations
p12200
aVIn particular, they need not copy or emulate the structure of the abstract machine
p12201
aVRather, conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below
p12202
ag7695
aVA conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible execution sequences of the corresponding instance of the abstract machine with the same program and the same input
p12203
ag7695
aVThe observable behavior of the abstract machine is its sequence of reads and writes to volatile data and calls to library I/O functions
p12204
as(dp12205
g15
V34509
p12206
stp12207
a((dp12208
g2
(lp12209
VIf you  (call any exec function from the exec family), then the code of a new program is loaded into your current process and execution continues with its main function and its stuff
p12210
aVOn a successful execution of those functions, they will never return because your  does not exist anymore in memory
p12211
aVI think you confuse  with the  function
p12212
aVThat will splice off a new child process which will run the same code as the parent
p12213
aVIf what you want is to create a new thread, that shares data and the address space with the main thread, you should use the  function
p12214
aVA new process will not share data and you will have to communicate with the other process using other mechanisms, like pipes or shared memory
p12215
as(dp12216
g15
V34509
p12217
stp12218
a((dp12219
g2
(lp12220
VYou first have to get a pointer, and you would need a condition when to stop
p12221
aVA last NULL pointer can be used for that
p12222
aVSo the code becomes
p12223
aVWhat you did was to increment the pointer stored in the array's first element
p12224
aVThat pointer will never too soon equal to a null pointer (if at all), So, the loop will not stop until that pointers' internal value overflows or something else happens so that it equals to a null pointer
p12225
aVThen, you pass a pointer to the arrays first element to  (you pass the array, but the compiler will convert it to a pointer - see below)
p12226
aVwill interpret the bytes of those pointers as characters and print them, which will result in garbage printed out if it doesn't crash right away
p12227
aVYou want to increment at a higher level instead: Increment not one element (pointer) of the array, but the pointer to the elements itself
p12228
aVNow, you can't do
p12229
aVBecause  is an array
p12230
aVIt's not a pointer, even though it can be converted to a pointer, which will then point to the first element of it
p12231
aVSo, we create a pointer which points to  initially, but increment it all again
p12232
aVNote that we increment it after printing, so that we print out the first element too
p12233
aVActually, i think i should explain why you can't do
p12234
aVWell,  is an array
p12235
aVAn array is an object that occupies some fixed amount of storage
p12236
aVAbove, the array occupies 4 times the size of a char pointer,
p12237
aVWhat looks like a pointer at the first glance is a block of elements of the same type
p12238
aVFor addressing elements, the compiler can make up a pointer out of an array in expressions, which then can be used to address elements in the array
p12239
aVIf you do , the compiler will create a pointer for you
p12240
aVBut that pointer is temporary, exists only for a short while for the sole purpose of immediately doing something with it, but it can not be changed like being incremented
p12241
aVThat is the reason that we create a real pointer variable that we then can increment
p12242
as(dp12243
g15
V34509
p12244
stp12245
a((dp12246
g2
(lp12247
VIt has to have separate  clauses for each template that is involved
p12248
aVHere, two templates are involved, that all deserve their (non-empty) template clauses:
p12249
aVThe class template
p12250
aVThe constructor template
p12251
aVConsider this case which fails because of the ambiguity as to where the parameter  belongs to
p12252
aVNow, what is up with the parameter
p12253
aVSure the compiler could guess it could belong to , but guesswork is not what the compiler likes :) The existing rule says that depending on the nesting of templates, template clauses appear in the right order
p12254
aVEverything is clear then
p12255
aVEven if one comes up with a rule how to match the parameters to arguments of the templates involved (so far i don't see a real difficulty in doing that), it would be inconsistent
p12256
aVBecause as of now, one template clause lists all parameters that the corresponding template accepts
p12257
aVMuch like a function parameter list
p12258
aVIf we would put everything into one clause, that clear semantic could be broken - not to mention that when we put the definition into the class again, all of a sudden the template would get its own clause:
p12259
aVIt's much more natural when we have separate template clauses that catch each their own arguments
p12260
aVSo, the syntax for the above wrong definition is
p12261
aVNow, also the reader of the code immediately sees that this is a definition of a member template, and not a (potential accidentally declared but unused) second parameter for
p12262
as(dp12263
g15
V34509
p12264
stp12265
a((dp12266
g2
(lp12267
VPlease forgive me if i overlook anything in your analysis
p12268
aVBut i think the fundamental bug in all that is this wrong assumption
p12269
aVtype2_p->ptr has type "pointer to int" and the value is the start address of my_test
p12270
aVThere is nothing that makes it have that value
p12271
aVRather, it is very probably that it points somewhere to
p12272
aVBecause what you do is to interpret the bytes making up that integer array as a pointer
p12273
aVThen you add something to it and subscript
p12274
aVAlso, i highly doubt your casting to the other struct is actually valid (as in, guaranteed to work)
p12275
aVYou may cast and then read a common initial sequence of either struct if both of them are members of an union
p12276
aVBut they are not in your example
p12277
aVYou also may cast to a pointer to the first member
p12278
aVFor example:
p12279
as(dp12280
g15
V34509
p12281
stp12282
a((dp12283
g2
(lp12284
VYour function leaks
p12285
aVThe manpage of  says:
p12286
aVThis function makes copies of the strings pointed to by name and value
p12287
aVSo you don't have to copy them yourself before passing them to it
p12288
aVDo you execute your program like this from within the shell
p12289
aVWell, then the environment variable will be set for the process so executed (), and be inherited to the processes launched by it
p12290
aVBut it will not "bubble up" into the shell that executed
p12291
aVThat is also the reason why commands such as  or  are shell built-ins rather than real programs
p12292
aVCheckout "help export" in bash
p12293
as(dp12294
g15
V34509
p12295
stp12296
a((dp12297
g2
(lp12298
VSee this defect report they say
p12299
aVThe LWG believes that nothing in the standard prohibits function objects that modify the sequence elements
p12300
aVThe problem is that for_each is in a secion entitled "nonmutating algorithms", and the title may be confusing
p12301
aVA nonnormative note should clarify that
p12302
aVBut also note this one
p12303
aVThey seem to call it "non-modifying" because for_each itself does not exlicitly modify the elements of the sequence
p12304
as(dp12305
g15
V34509
p12306
stp12307
a((dp12308
g2
(lp12309
VThe array  is an array of pointers
p12310
aVIt is not an array of buffers of some size
p12311
aVTherefor, if you do
p12312
aVYou will get the sizeof of the first element of that array
p12313
aVEquivalent to
p12314
aVBecause your array stores pointers
p12315
aVSo, in the line that reads
p12316
aVYou allocate 4 or 8 pointers in one array (depends on how wide a pointer on your platform is
p12317
aVUsually it's either 4 or 8)
p12318
aVBut that's of course not senseful
p12319
aVWhat you wanted to do is create an array of pointers of the same size as
p12320
aVYou will have to first get the total size of the animals array, and then divide by the size of one element
p12321
aVNow, that is what you want
p12322
aVBut the pointers will yet have indeterminate values
p12323
aVNext you pass the array using  (same for the other)
p12324
aVWhy that
p12325
aVYou can pass  directly
p12326
aVTaking its address and then dereference is the same as doing nothing in the first place
p12327
aVThen in the function you call, you copy the strings pointed to by elements in  to some indeterminate destination (remember the elements of the  array - the pointers - have yet indeterminate values
p12328
aVWe have not assigned them yet
p12329
aVYou first have to allocate the right amount of memory and make the elements point to that
p12330
aVAddition, about the sizeof above
p12331
aVThere's one important thing you have to be sure about
p12332
aVIt's the way we calculate the size
p12333
aVWhatever you do, make sure you always have enough room for your string
p12334
aVA C string consists of characters and a terminating null character, which marks the end of the string
p12335
aVSo,  should point to a buffer that is at least as large so that it contains space for  and
p12336
aVThe first contains 11 characters
p12337
aVThe second depends on what we actually copy over - its length is what  returns
p12338
aVSo, in total we need
p12339
aVspace for all characters including the terminating null
p12340
aVNow it's not good style to hardcode that number into your code
p12341
aVThe prefix could change and you could forget to update the number or miscount about one or two characters
p12342
aVThat is why we use , which we provide with the string literal we want to have prepended
p12343
aVRecall that a  expression evaluates to the size of its operand
p12344
aVYou use it in  to get the total size of your array before
p12345
aVNow you use it for the string literal
p12346
aVAll string literals are arrays of characters
p12347
aVstring literals consist of the characters you type in addition to the null character
p12348
aVSo, the following condition holds, because  counts the length of a C string, and does not include the terminating null character to its length
p12349
aVWe don't have to divide by the size of one element, because the sizeof char is one anyway, so it won't make a difference
p12350
aVWhy do we use  instead of strlen
p12351
aVBecause it already accounts for the terminating null character, and it evaluates at compile time
p12352
aVThe compiler can literally substitute the size that the sizeof expression returns
p12353
as(dp12354
g15
V34509
p12355
stp12356
a((dp12357
g2
(lp12358
VAndrew Grant provided the solution
p12359
aVI want to tell you why it doesn't work the way you tried
p12360
aVIf you have two viable functions for an argument, then the one that matches the argument best is called
p12361
aVThe second requires a user-defined conversion, while the first only needs a standard conversion
p12362
aVThat is why the compiler prefers the first over the second
p12363
as(dp12364
g15
V34509
p12365
stp12366
a((dp12367
g2
(lp12368
VIn the one project, you are passing the  to the linker accidentally
p12369
aVThe GNU linker (ld) supports an -m option for specifying the emulation mode
p12370
aVAn emulation consists of a linker script, output object file format and parameters for it - like the start address
p12371
aVWatch not to put  to LDFLAGS but to CXXFLAGS (C++ compiler flags) or CFLAGS (c compiler flags)
p12372
aVFor example, my  supports the emulation modes elf_i386 and i386linux, for generating ELF binaries and a
p12373
aVout binaries respectively
p12374
as(dp12375
g15
V34509
p12376
stp12377
a((dp12378
g2
(lp12379
VGCC has an attribute for this, which calls a function when an automatic variable goes out of scope, passing it the address of that variable
p12380
aVOutput:
p12381
as(dp12382
g15
V34509
p12383
stp12384
a((dp12385
g2
(lp12386
V has less surprises and is generally safer to use
p12387
aVBut it is not portable - Posix doesn't specify what it does and only some shells support it (beside bash, i heard ksh supports it too)
p12388
aVFor example, you can do
p12389
aVto test whether a file exists
p12390
aVBut with , you have to quote , because it splits the argument and expands things like  (where  takes it literally)
p12391
aVThat has also to do with how  can be an external program and receives its argument just normally like every other program (although it can also be a builtin, but then it still has not this special handling)
p12392
aValso has some other nice features, like regular expression matching with  along with operators like they are known in C-like languages
p12393
aVHere is a good page about it: What is the difference between test,  and
p12394
aVand Bash Tests
p12395
as(dp12396
g15
V34509
p12397
stp12398
a((dp12399
g2
(lp12400
VHere is my theory on that
p12401
aVI think it has much to do with what operators are valid (syntactically) for symbols
p12402
aVConsider
p12403
aVConceptually, in those declarations what is named with a type (, , ) is substituted with an expression of that type later on
p12404
aVOf course the intention is to reuse as much of the existing language as possible
p12405
aVSo i think he used :
p12406
aVThe important one is that  is only valid on the kind of expression a reference denotes: For
p12407
aVReferences are lvalues (named variables are too) and only for them  can be applied:
p12408
as(dp12409
g15
V34509
p12410
stp12411
a((dp12412
g2
(lp12413
VI would teach pointers first
p12414
aVThey can be explained without teaching arrays
p12415
aVWhile teaching arrays i could then refer to pointers when explaining the expression , and when explaining how one can pass them to functions
p12416
as(dp12417
g15
V34509
p12418
stp12419
a((dp12420
g2
(lp12421
VI would go with the traditional find & xargs way:
p12422
aVmakes it not search recursively
p12423
aVIf you only care about files, you can say
p12424
aVmakes it not include the  path itself into the result
p12425
aVWorks with any filenames, including with those that contain embedded newlines
p12426
aVOne comment notes that the mv  option is a probably GNU extension
p12427
aVFor systems that don't have it
p12428
as(dp12429
g15
V34509
p12430
stp12431
a((dp12432
g2
(lp12433
VYou use the constructor-forwarding version of , which construct a tee-stream itself and forward all arguments to that
p12434
aVC++03 has only limited capabilities when it comes to forwarding arguments to functions (amount of overloads needed easily grow exponentially)
p12435
aVIt () makes the following restrictions:
p12436
aVEach of these members constructs an instance of stream and associates it with an instance of the Device T constructed from the given lists of arguments
p12437
aVThe T constructors involved must take all arguments by value or const reference
p12438
aVWell, but the  constructor says
p12439
aVConstructs an instance of tee_device based on the given pair of Sinks
p12440
aVEach function parameter is a non-const reference if the corresponding template argument is a stream or stream buffer type, and a const reference otherwise
p12441
aVThat won't work, of course
p12442
aVprovides another constructor that takes a  as first argument
p12443
aVThis works here (Compiles, at least
p12444
aVThe assertion fails, though
p12445
aVI've not worked with  so i can't help with that)
p12446
aVEdit: After calling  or streaming , the assertion passes
p12447
as(dp12448
g15
V34509
p12449
stp12450
a((dp12451
g2
(lp12452
VOnce i cd'ed into such a long directory, i have that in the history
p12453
aVThen i just type  for the "(reverse-i-search)" prompt and type in a few characters, like  that appear somewhere in the path, and it shows me the command what i issued back then and i can easily jump to it again
p12454
aVThat works pretty well in practice
p12455
aVBecause it won't find an entry if you haven't typed that path for quite some time, which would mean doing work to make things easier probably wouldn't be worth the time
p12456
aVBut it definitely will find it if you used it recently
p12457
aVWhich is exactly what i need
p12458
aVIn some way, it's a self-organizing cache for long commands & path-names :)
p12459
as(dp12460
g15
V34509
p12461
stp12462
a((dp12463
g2
(lp12464
VDouble check everything
p12465
aVIf you include  into , the compiler should not raise up an error
p12466
aVDo you include  from
p12467
aVBetter don't do this because that would cause a circular dependency between headers, which will cause that kind of bugs
p12468
aVAlso check for spelling of header guards
p12469
aVThis can be a common source of annoyance:
p12470
aVIn addition, you should avoid putting the underscore before your header guard macro name
p12471
aVThese names are reserved to the compiler
p12472
aVCall it  or just  instead
p12473
as(dp12474
g15
V34509
p12475
stp12476
a((dp12477
g2
(lp12478
VAnother application are intrusive lists
p12479
aVThe element type can tell the list what its next/prev pointers are
p12480
aVSo the list does not use hard-coded names but can still use existing pointers:
p12481
as(dp12482
g15
V34509
p12483
stp12484
a((dp12485
g2
(lp12486
VThe segfault is not an intended action of your C program that would tell you that an index is out of bounds
p12487
aVRather, it is an unintended consequence of undefined behavior
p12488
aVIn C and C++, if you declare an array like
p12489
aVYou are only allowed to access elements with indexes from  up to
p12490
aVAnything outside of that range causes undefined behavior
p12491
aVIf the index was near the range, most probably you read your own program's memory
p12492
aVIf the index was largely out of range, most probably your program will be killed by the operating system
p12493
aVBut you can't know, anything can happen
p12494
aVWhy does C allow that
p12495
aVWell, the basic gist of C and C++ is to not provide features if they cost performance
p12496
aVC and C++ has been used for ages for highly performance critical systems
p12497
aVC has been used as a implementation language for kernels and programs where access out of array bounds can be useful to get fast access to objects that lie adjacent in memory
p12498
aVHaving the compiler forbid this would be for naught
p12499
aVWhy doesn't it warn about that
p12500
aVWell, you can put warning levels high and hope for the compiler's mercy
p12501
aVThis is called quality of implementation (QoI)
p12502
aVIf some compiler uses open behavior (like, undefined behavior) to do something good, it has a good quality of implementation in that regard
p12503
aVIf it instead would format your hard disk upon seeing the array accessed out of bounds - which would be legal for it - the quality of implementation would be rather bad
p12504
aVI enjoyed to read about that stuff in the ANSI C Rationale document
p12505
as(dp12506
g15
V34509
p12507
stp12508
a((dp12509
g2
(lp12510
Vsizeof is pure compile time in C++ and C prior to C99
p12511
aVStarting with C99 there are variable length arrays:
p12512
aVThat will evaluate the  operand, because  is not yet known at compile time
p12513
aVThat only applies to variable length arrays: Other operands or types still make sizeof compute at compile time
p12514
aVIn particular, arrays with dimensions known at compile time are still handled like in C++ and C89
p12515
aVAs a consequence, the value returned by  is not a compile time constant (constant expression) anymore
p12516
aVYou can't use it where such a value is required - for example when initializing static variables, unless a compiler specific extension allows it (the C Standard allows an implementation to have extensions to what it treats as constant)
p12517
as(dp12518
g15
V34509
p12519
stp12520
a((dp12521
g2
(lp12522
VYour  script says
p12523
aVIf the fourth field is not a dash, print it out
p12524
aVHowever, you want to print it out if the line is not a dash
p12525
aVDefault action is to print so no body is needed
p12526
aVIf you want to print group of numbers, you can use a GNU awk extension if you use gawk
p12527
aVIt allows splitting records using regular expressions:
p12528
aVNow, instead of lines, it takes a group of numbers separated by a line containing only
p12529
aVSetting the field separator () to a newline allows you to iterate over the numbers within such a group:
p12530
aVHowever I agree with other answers
p12531
aVIf you just want to filter out lines matching some text,  is the better tool for that
p12532
as(dp12533
g15
V34509
p12534
stp12535
a((dp12536
g2
(lp12537
VIt uses the allocator that was given to it as the second template parameter
p12538
aVLike this then
p12539
aVSay it is in push_back, let  be the object to be pushed:
p12540
aVSomething like that
p12541
aVThe allocator will care about allocating memory
p12542
aVIt keeps the steps of allocating memory and constructing object into that memory apart, so it can preallocate memory, but not yet call constructors
p12543
aVDuring reallocate, the vector has to take care about exceptions being thrown by copy constructors, which complicates the matter somewhat
p12544
aVThe above is just some pseudo code snippet - not real code and probably contains many bugs
p12545
aVIf the size gets above the capacity, it asks the allocator to allocate a new greater block of memory, if not then it just constructs at the previously allocated space
p12546
aVThe exact semantics of this depend on the allocator
p12547
aVIf it is the standard allocator, construct will do
p12548
aVAnd the allocate  will just get memory from
p12549
aVwould call the destructor
p12550
aVAll that is abstracted behind the allocator and the vector just uses it
p12551
aVA stack or pooling allocator could work completely different
p12552
aVSome key points about  that are important
p12553
aVAfter a call to , you can have up to N items inserted into your vector without risking a reallocation
p12554
aVUntil then, that is as long as , references and iterators to elements of it remain valid
p12555
aVVector's storage is contiguous
p12556
aVYou can treat &v;[0] as a buffer containing as many elements you have currently in your vector
p12557
as(dp12558
g15
V34509
p12559
stp12560
a((dp12561
g2
(lp12562
VIf it could not read anything, it sets the
p12563
aVJust test the stream in an if condition, and clear the bit:
p12564
aVInternally, the sequence is this way in your case:
p12565
aVWait on the terminal for a string
p12566
aVTerminal will block until the user emits a newline
p12567
aVTwo probable error cases possible
p12568
aVUser presses immediately EOF
p12569
aVThis will make  read nothing at all, and it will set the  and the
p12570
aVUser inputs something and then presses EOF
p12571
aVThis will make  consume something and then it hits EOF while trying to get the next character
p12572
aVThis cause  to be set
p12573
aVYou will try to read something again
p12574
aVThe extraction function will create an object of type  which checks in what state the stream is
p12575
aVIf any of the errorbits are set, it will cause the extraction function to immediately return
p12576
aVThat caused the endless loop before
p12577
aVA call to  clears all error bits, and you can go on reading your stuff again
p12578
as(dp12579
g15
V34509
p12580
stp12581
a((dp12582
g2
(lp12583
VYou can't do that out of the language itself
p12584
aVBut you can with boost
p12585
aVBind a functor to some element of that array and assign it to a :
p12586
as(dp12587
g15
V34509
p12588
stp12589
a((dp12590
g2
(lp12591
VRight, the vector is copied like expected
p12592
aVThere is a good software called geordi which can show this:
p12593
aVIt tracks creation/copies of
p12594
aVHere is the output:
p12595
aVThis is output when we only track :
p12596
aVAs you see, first B0 is created as the default argument of the vector constructor
p12597
aVThen that object is copied into 3 B's and after that B0 is destroyed again as the constructor comes back
p12598
aVpoly then is created
p12599
aVThen, we push_back it into a vector of polygons
p12600
aVThe argument, poly, is copied into a new vector which is created within the vector of polygons and managed by that
p12601
aVIf it crashes, the problem probably lies within another part of your program
p12602
aVChecks that the copy constructor/constructor and destructor work correctly and that they don't delete things twice if you use dynamic memory allocation
p12603
as(dp12604
g15
V34509
p12605
stp12606
a((dp12607
g2
(lp12608
VAs the number is not necessarily known at compile time, the type is a pointer:
p12609
as(dp12610
g15
V34509
p12611
stp12612
a((dp12613
g2
(lp12614
VThe Standard includes a function called remove which does that
p12615
aVThough i would prefer  for that (if i already use boost anyway)
p12616
as(dp12617
g15
V34509
p12618
stp12619
a((dp12620
g2
(lp12621
VWell
p12622
aVFunctions like  usually get a character from the keyboard or standard input
p12623
aVThey are sometimes used at the end of programs like this
p12624
aVThe getch/getche (i don't know what the e stands for in turbo-c++) are then used to give the user the change to see the output of the program, before the terminal windows closes (usually that happens in windows)
p12625
aVNote that there is a portable function called  in C and C++ that does also do that job (waits for an enter in addition, but that won't cause a harm here)
p12626
aVBut it is not used to terminate the program
p12627
aVAfter a key is pressed, control continues and then after main finished, the program exists
p12628
aVC++ and recent C versions insert a  implicitly after the last statement of the main function (0 stands for "succesful")
p12629
aVThis means your main function returns a value of  back to the OS
p12630
aVBut you can return other values if you write the return explicitly and put another value there
p12631
aVThat value is what  expects
p12632
aVIt terminates your program, and returns the given value back to the OS
p12633
aVThat program will return a value of 42 to the OS
p12634
aVNormally you just  there and it has the same effect (*)
p12635
aV(*) Well, not entirely: If you have local variables, the destructor of those are not called if you use
p12636
aVBut they are cleanly destructed and destructors are called when you use
p12637
aVTherefor, prefer  in main when you can
p12638
aVexit called in other functions than your main will terminate your program too, so it can be required to use that instead, because return there will just return from those specific functions and do not at all terminate the program
p12639
as(dp12640
g15
V34509
p12641
stp12642
a((dp12643
g2
(lp12644
VJust to make it crystal clear what happens
p12645
aVLook at this example
p12646
aVWhat will it output
p12647
aVWell, it will output
p12648
aVThe  of above can be parsed in two different ways:
p12649
aVCast to int and discard the result
p12650
aVDeclare a variable called
p12651
aVBut ignore the parentheses around the identifier
p12652
aVThe compiler, when such a situation appears where a function-style cast is used in a statement and it looks like a declaration too, will always take it as a declaration
p12653
aVWhen it can't syntactically be a declaration (the compiler will look at the whole line to determine that), it will be taken to be an expression
p12654
aVThus we are assigning to the inner  above, leaving the outer  at zero
p12655
aVNow, your case is exactly that
p12656
aVYou are trying (accidentally) to declare an identifier called  within a class called :
p12657
aVThe compiler then goes on to moan about a not declared default constructor, because the static, as it assumes it to be, is default constructed
p12658
aVBut even if you had a default constructor for X, it of course is still wrong because neither  is a static member of X, nor a static of X can be defined/declared at block scope
p12659
aVYou can make it not look like a declaration by doing several things
p12660
aVFirst, you can paren the whole expression, which makes it not look like a declaration anymore
p12661
aVOr just paren the type that is cast to
p12662
aVBoth of these disambiguations have been mentioned in other answers:
p12663
aVThere is a similar, but distinct ambiguity when you try to actually declare an object
p12664
aVLook at this example:
p12665
aVBecause  can be both the declaration of a parameter called  and the explicit conversion (cast) of the float-variable to an int, the compiler decides again that that is a declaration
p12666
aVThus, we happen to declare a function called , which takes an integer argument and returns an integer
p12667
aVThere are several possibilities how to disambiguate that, based on the disambiguation of above:
p12668
as(dp12669
g15
V34509
p12670
stp12671
a((dp12672
g2
(lp12673
VI would add a function that returns you a ref like rlbond recommends
p12674
aVFor a quick fix or if you don't have control over the source of it, i would go with this:
p12675
aVThat's actually equivalent, because the following holds if  is a pointer to a defined class:
p12676
aVSee this long discussion on comp
p12677
aVlang
p12678
aVc++ about that same problem with good answers
p12679
as(dp12680
g15
V34509
p12681
stp12682
a((dp12683
g2
(lp12684
VYour linker and compiler don't know about that (without you telling it anything, of course)
p12685
aVIt's up to the designer of the ABI of your platform to specify they don't allocate objects at those addresses
p12686
aVSo, there is sometimes (the platform i worked on had that) a range in the virtual address space that is mapped directly to physical addresses and another range that can be used by user space processes to grow the stack or to allocate heap memory
p12687
aVYou can use the defsym option with GNU ld to allocate some symbol at a fixed address:
p12688
aVOr if the expression is more complicated than simple arithmetic, use a custom linker script
p12689
aVThat is the place where you can define regions of memory and tell the linker what regions should be given to what sections/objects
p12690
aVSee here for an explanation
p12691
aVThough that is usually exactly the job of the writer of the tool-chain you use
p12692
aVThey take the spec of the ABI and then write linker scripts and assembler/compiler back-ends that fulfill the requirements of your platform
p12693
aVIncidentally, GCC has an attribute  that you can use to place your struct into a specific section
p12694
aVYou could then tell the linker to place that section into the region where your registers live
p12695
as(dp12696
g15
V34509
p12697
stp12698
a((dp12699
g2
(lp12700
VI get this output:
p12701
aVBut i'm using long double literals instead of double literals:
p12702
as(dp12703
g15
V34509
p12704
stp12705
a((dp12706
g2
(lp12707
VInclude TestClass
p12708
aVcpp into the commandline, so the linker can find the function definition:
p12709
aVAlternatively, compile each to their own object file, then tell the compiler to link them together (it will forward them to the linker)
p12710
as(dp12711
g15
V34509
p12712
stp12713
a((dp12714
g2
(lp12715
VYes you can't use
p12716
aVUse , but note it returns  instead of :
p12717
aVIt's like with pointers
p12718
aVYou can't assign  to
p12719
aVLikewise, you can't assign  to
p12720
as(dp12721
g15
V34509
p12722
stp12723
a((dp12724
g2
(lp12725
VThe following is part of the  interface (which ArrayList implements):
p12726
aVis the element type
p12727
aVIf the list is empty,  throws an
p12728
aVYou find the whole API documentation here
p12729
as(dp12730
g15
V34509
p12731
stp12732
a((dp12733
g2
(lp12734
VYou can just do
p12735
aVAnd it will sort your strings
p12736
aVThen go through them checking whether they are in order
p12737
aVIn particular,  couldn't be used as a comparator, because it doesn't do what  wants it to do: Return true if the first argument is less than the second, and return false otherwise
p12738
aVIf you use  like above, it will just use , which will do exactly that (i
p12739
aVe  makes it return )
p12740
as(dp12741
g15
V34509
p12742
stp12743
a((dp12744
g2
(lp12745
VThat sounds quite much, given that  only has a precision of 1 second
p12746
aVSounds like you call it way too often
p12747
aVOne possible improvement would be to maybe call it only each 500ms
p12748
aVSo it will still hit every second
p12749
aVSo instead of calling it 100 times a second, start off a timer that rings every 500ms, taking the current time and storing it into an integer
p12750
aVThen, read that integer 100 times a second instead
p12751
as(dp12752
g15
V34509
p12753
stp12754
a((dp12755
g2
(lp12756
VThere are two ways for specifying parameters in C
p12757
aVOne is using an identifier list, and the other is using a parameter type list
p12758
aVThe identifier list can be omitted, but the type list can not
p12759
aVSo, to say that one function takes no arguments in a function definition you do this with an (omitted) identifier list
p12760
aVAnd this with a parameter type list:
p12761
aVIf in a parameter type list the only one parameter type is void (it must have no name then), then that means the function takes no arguments
p12762
aVBut those two ways of defining a function have a difference regarding what they declare
p12763
aVIdentifier lists
p12764
aVThe first defines that the function takes a specific number of arguments, but neither the count is communicated nor the types of what is needed - as with all function declarations that use identifier lists
p12765
aVSo the caller has to know the types and the count precisely before-hand
p12766
aVSo if the caller calls the function giving it some argument, the behavior is undefined
p12767
aVThe stack could become corrupted for example, because the called function expects a different layout when it gains control
p12768
aVUsing identifier lists in function parameters is deprecated
p12769
aVIt was used in old days and is still present in lots of production code
p12770
aVThey can cause severe danger because of those argument promotions (if the promoted argument type do not match the parameter type of the function definition, behavior is undefined either
p12771
aVand are much less safe, of course
p12772
aVSo always use the  thingy for functions without parameters, in both only-declarations and definitions of functions
p12773
aVParameter type list
p12774
aVThe second one defines that the function takes zero arguments and also communicates that - like with all cases where the function is declared using a parameter type list, which is called a
p12775
aVIf the caller calls the function and gives it some argument, that is an error and the compiler spits out an appropriate error
p12776
aVThe second way of declaring a function has plenty of benefits
p12777
aVOne of course is that amount and types of parameters are checked
p12778
aVAnother difference is that because the compiler knows the parameter types, it can apply implicit conversions of the arguments to the type of the parameters
p12779
aVIf no parameter type list is present, that can't be done, and arguments are converted to promoted types (that is called the default argument promotion)
p12780
aVwill become , for example, while  will become
p12781
aVComposite type for functions
p12782
aVBy the way, if a file contains both an omitted identifier list and a parameter type list, the parameter type list "wins"
p12783
aVThe type of the function at the end contains a prototype:
p12784
aVThat is because both declarations do not say anything contradictory
p12785
aVThe second, however, had something to say in addition
p12786
aVWhich is that one argument is accepted
p12787
aVThe same can be done in reverse
p12788
aVThe first defines a function using an identifier list, while the second then provides a prototype for it, using a declaration containing a parameter type list
p12789
as(dp12790
g15
V34509
p12791
stp12792
a((dp12793
g2
(lp12794
VA common mistake
p12795
aVand  are just two structs that add typedefs
p12796
aVand respectively
p12797
aVNot more
p12798
aVThey are for convenience of creators of function object types, so they don't have to do those themselves
p12799
aVBut they don't behave polymorphic
p12800
aVWhat you want is function object wrapper
p12801
aVcomes to mind:
p12802
aVOr make it a template
p12803
aVYou can take it by value and then return the copy from  if use it to apply it to some sequence
p12804
aVWhich would allow the function object to update some state variables among its members
p12805
aVis an example that does it like that
p12806
aVGenerally, anyway, i would accept them by value because they are usually small and copying them allows greater flexibility
p12807
aVSo i do
p12808
aVYou will then be able to take a copy of fct and save it somewhere, and 's operator() can be non-const and update some members (which is part of the whole point of )
p12809
aVRemember if you take a function object by const reference, you can't generally copy it, because the user could have passed a function
p12810
aVCopying it then will try to locally declare a function instead of a local function pointer
p12811
aVHowever, accepting by-value will accept a function pointer instead when a function was passed, which can safely be copied
p12812
as(dp12813
g15
V34509
p12814
stp12815
a((dp12816
g2
(lp12817
VYes it has something to do with memory allocation
p12818
aVThe first loop indexes the inner dimension of , which happens to span over only 3 bytes each time
p12819
aVThat's within one memory page easily (i believe a common size here is 4kB for one page)
p12820
aVBut with your second version, the outer dimension's index changes fast
p12821
aVThat will cause memory reads spread over a much larger range of memory - namely  bytes, which is 24kB
p12822
aVAnd with each change of the inner index, those jumps start to happen again
p12823
aVThat will hit different pages and is probably somewhat slower
p12824
aVAlso i heard the CPU reads ahead memory
p12825
aVThat will make the first version benefit, because at the time it reads, that data is probably already in the cache
p12826
aVI can imagine the second version doesn't benefit from that, because it makes those large jumps around the memory back and forth
p12827
aVI would suspect the difference is not that much, but if the algorithm runs many times, it eventually becomes noticeable
p12828
aVYou probably want to read the article  on wikipedia
p12829
aVThat is the scheme used to store multi-dimensional arrays in C
p12830
as(dp12831
g15
V34509
p12832
stp12833
a((dp12834
g2
(lp12835
VGiven that what you have is an array of two doubles, i wouldn't doubt there is a need to raise that number up at some time
p12836
aVLike, if at some point you decide to add 3d functions too
p12837
aVI would therefor prefer to stay with an array
p12838
aVBut there is no need to use a dynamic array
p12839
aVUse an array wrapped in a struct like :
p12840
aVThen you can add it to a vector which will contain those:
p12841
aVThis is probably the best you can get if you aim for both simplicity and extensibility
p12842
aVis a pretty small and simple struct
p12843
aVIt basically amounts to
p12844
aVAnd several functions, of course, like ,  and  and other stuff
p12845
aVBut without constructors, so that you can initialize it like a normal array as we did above
p12846
as(dp12847
g15
V34509
p12848
stp12849
a((dp12850
g2
(lp12851
VThe Standard doesn't know this "word" thingy used by processors
p12852
aVBut it says the type "int" should have the natural size for a execution environment
p12853
aVBut even for 64 bit environments, int is usually only 32 bits
p12854
aVSo "word" in Standard terms has pretty much no common meaning (except for the common English "word" of course)
p12855
aVCharacter size is the size of a character
p12856
aVDepends on what character you talk about
p12857
aVCharacter types are char, unsigned char and signed char
p12858
aVAlso wchar_t is used to store characters that can have any size (determined by the implementation - but must use one of the integer types as its underlying type
p12859
aVMuch like enumerations), while char/signed char or unsigned char has to have one byte
p12860
aVThat means that one byte has as much bits as one char has
p12861
aVIf an implementation says one object of type char has 16 bits, then a byte has 16 bits too
p12862
aVNow a byte is the size that one char occupies
p12863
aVIt's a unit, not some specific type
p12864
aVThere is not much more about it, just that it is the unit that you can access memory
p12865
ag1388
aVe you do not have pointer access to bit-fields, but you have access to units starting at one byte
p12866
aVInteger size" now is pretty wide
p12867
aVWhat do you mean
p12868
aVAll of bool, char, short, int, long and their unsinged counterparts are integers
p12869
aVTheir range is what i would call "integer size" and it is documented in the C standard - taken over by the C++ Standard
p12870
aVFor signed char the range is from -127 <-> 127, for short and int it is the same and is -2^15+1 <-> 2^15-1 and for long it is -2^31+1 <-> 2^31-1
p12871
aVTheir unsigned counterparts range from 0 up to 2^8-1, 2^16-1 and 2^32-1 respectively
p12872
aVThose are however minimal sizes
p12873
aVThat is, an int may not have maximal size 2^14 on any platform, because that is less than 2^15-1 of course
p12874
aVIt follows for those values that a minimum of bits is required
p12875
aVFor char that is 8, for short/int that is 16 and for long that is 32
p12876
aVTwo's-complement representation for negative numbers is not required, which is why the negative value is not  instead of  for example for signed char
p12877
as(dp12878
g15
V34509
p12879
stp12880
a((dp12881
g2
(lp12882
VI would use bash's :
p12883
aVI found this faq to be a good source of information
p12884
as(dp12885
g15
V34509
p12886
stp12887
a((dp12888
g2
(lp12889
VIt is not valid to have an object that contains an auto_ptr in a standard container
p12890
aVYou run into undefined behavior
p12891
aVTwo common problems:
p12892
aVstd::vector<>::resize copies its argument into each created element
p12893
aVThe first copy will "succeed" (see below why not), but each further copy will be empty, because the element copied is also empty
p12894
aVIf something during reallocation throws, you can happen to have some elements copied (to a new buffer) - but the copy being thrown away - and other elements not, because  must not have any effects if an exception is being thrown
p12895
aVThus some of your elements are now empty
p12896
aVAs this is all about undefined behavior it does not really matter
p12897
aVBut even if we try to come up with this behavior based on what we think is valid, we would fail anyway
p12898
aVAll the member functions like ,  and so on have a const reference that takes an object of type T
p12899
aVThus, a reference of type  is tried to copied into elements of the vector
p12900
aVBut the implicitly created copy constructor/copy assignment operator looks like  - that is, it requires a non-const object to be copied from
p12901
aVGood implementations of the Standard library check that, and fail to compile if necessary
p12902
aVUntil the next C++ version, you have to live with this
p12903
aVThe next one will support element types that are merely movable
p12904
aVThat is, a moved object does not need to be equal to the object moved to
p12905
aVThat will allow putting streams, transfer-of-ownership pointers and threads into containers
p12906
aVSee what the Standard says for this ():
p12907
aVIn certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ Standard Library depends on components supplied by a C++ program
p12908
aVIf these components do not meet their requirements, the Standard places no requirements on the implementation
p12909
aVIn particular, the effects are undefined in the following cases:
p12910
aVfor types used as template arguments when instantiating a template component, if the operations on the type do not implement the semantics of the applicable Requirements subclause (20
p12911
ag2790
aV5, 23
p12912
aV1, 24
p12913
aV1, 26
p12914
aV1)
p12915
as(dp12916
g15
V34509
p12917
stp12918
a((dp12919
g2
(lp12920
VTrying to put the list of places together that makes the example undefined behavior
p12921
aVI will examine the lines up to the one where you instantiate the vector with your type
p12922
aVThe Standard has to say
p12923
aVIn :
p12924
aVThe type of objects stored in these components must meet the requirements of CopyConstructible types (20
p12925
ag2790
aV3), and the additional requirements of Assignable types
p12926
aVIn  (emphasis mine):
p12927
aVIn Table 64, T is the type used to instantiate the container, t is a value of T, and u is a value of (possibly const) T
p12928
aVTable 64
p12929
aVIn :
p12930
aVIf the class definition does not explicitly declare a copy assignment operator, one is declared implicitly
p12931
aVThe implicitly-declared copy assignment operator for a class X will have the form
p12932
aVif
p12933
aVeach direct base class B of X has a copy assignment operator whose parameter is of type const B&,
p12934
aVconst volatile B& or B, and
p12935
aVfor all the nonstatic data members of X that are of a class type M (or array thereof), each such class type has a copy assignment operator whose parameter is of type const M&, const volatile M& or M
p12936
aVOtherwise, the implicitly declared copy assignment operator will have the form
p12937
aV(Note the last and second last sentence)
p12938
aVIn :
p12939
aVIn certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ Standard Library depends on components supplied by a C++ program
p12940
aVIf these components do not meet their requirements, the Standard places no requirements on the implementation
p12941
aVIn particular, the effects are undefined in the following cases:
p12942
aVfor types used as template arguments when instantiating a template component, if the operations on the type do not implement the semantics of the applicable Requirements subclause (20
p12943
ag2790
aV5, 23
p12944
aV1, 24
p12945
aV1, 26
p12946
aV1)
p12947
aVOperations on such types can report a failure by throwing an exception unless otherwise specified
p12948
aVNow, if you look at the specification of  you will note it has a copy-assignment operator that takes a non-const
p12949
aVThus, the implicitly declared copy assignment operator of your class will also take a non-const type as its parameter
p12950
aVIf you read the above places carefully, you will see how it says that instantiating a vector with your type as written is undefined behavior
p12951
as(dp12952
g15
V34509
p12953
stp12954
a((dp12955
g2
(lp12956
VWell, i'll answer what i put as comment already so it can be accepted
p12957
aVProblem is with constness:
p12958
aVClarification:
p12959
aVThe original question didn't contain that
p12960
aVI did a wild guess in the comments whether he possibly has  being a const member function in the real code (because at a yet earlier iteration, it turned out yet another thing was missing/different to the real-world code :p)
p12961
aVHe actually had it being a const member function, and told me i should post this as an answer
p12962
as(dp12963
g15
V34509
p12964
stp12965
a((dp12966
g2
(lp12967
VWithout a pointer, you would have
p12968
aVwhich is a constant Dict
p12969
aVNow, if you make it a pointer you have
p12970
aVwhich is a pointer to a constant Dict
p12971
aVThat does not mean that the pointer is constant
p12972
aVBut it does mean that the Dict pointed to is treated as constant
p12973
aVBut the pointer is not
p12974
aVYou would get an error for the second case if you make the pointer constant
p12975
aVKeeping the pointed dict constant too, this would look like this
p12976
aVNow you can't set currPtr to point to something different, because the pointer is now constant, not just what the pointer points to is treated so
p12977
aVSome people like the look if the const is always right to the stuff that it makes const
p12978
aVThis would look like this
p12979
aVwhich is the same as the previous snippet
p12980
aVIf you then read it from right to left, it tells you what it is "const pointer to a const Dict"
p12981
aVIf you have a type, it doesn't matter how you order the specifiers
p12982
aVBoth are constant integers
p12983
aVThat is why we could put const right of the Dict type specifier
p12984
aVNow, if you have a pointer, you can always pretend you point to a constant object, even though the object wasn't declared const
p12985
aVBut you can't pretend to work with a non-const object if what you point to is a const object:
p12986
aVNote that if you make the pointer itself const, the rules are different to that
p12987
aVThey are analogous to const applied to other types:
p12988
aVAfter copying the value into a new variable (whether pointer or not), the new variable is not connected in any way to the other variable, because the value read has no associativity to how the value was created in the first place
p12989
aVThe const of the other variable doesn't matter
p12990
as(dp12991
g15
V34509
p12992
stp12993
a((dp12994
g2
(lp12995
VWell, you ask about an array
p12996
aVYou can just easily get a pointer to its elements, so it basically boils down to the question whether pointers can be used transparently with STL functions
p12997
aVA pointer actually is the most powerful kind of an iterator
p12998
aVThere are different kinds
p12999
aVInput iterator: Only forward and one-pass, and only read
p13000
aVOutput iterator: Only forward and one-pass, and only write
p13001
aVForward iterator: Only forward, and read/write
p13002
aVBidirectional iterator: Forward and backward, and read/write
p13003
aVRandom access iterator: Arbitrary steps forward and backward in one breath, and read/write
p13004
aVNow each iterator in the second group supports all the things of all iterators mentioned before it
p13005
aVA pointer models the last kind of iterators - a random access iterator
p13006
aVYou may add/subtract an arbitrary integer and you may read and write
p13007
aVAnd all except the output iterator has a  that can be used to access a member of the element type we iterate over
p13008
aVNormally, iterators have several typedefs as members
p13009
aVvalue_type - what the iterator iterates over (int, bool, string,
p13010
aVreference - reference to the value_type
p13011
aVpointer - pointer to the value_type
p13012
aVdifference_type - what type the distance between two iterators has (returned by )
p13013
aViterator_category - this is a tag-type: it is typedefed to a type that represents the kind of the iterator
p13014
aVeither ,
p13015
aV,
p13016
aVAlgorithms can use it to overload on different kinds of iterators (like  is faster for random access iterators, because it can just return )
p13017
aVNow, a pointer of course does not have those members
p13018
aVC++ has an  template and specializes it for pointers
p13019
aVSo if you want to get the value type of any iterator, you do
p13020
aVAnd whether it is a pointer or some other iterator, it will give you the value_type of that iterator
p13021
aVSo - yes, a pointer can very well be used with STL algorithms
p13022
aVAs someone else mentioned, even  can be a
p13023
aVA pointer is a very good example of an iterator even
p13024
aVBecause it is so exceedingly simple but at the same time so powerful that it can iterate over a range
p13025
as(dp13026
g15
V34509
p13027
stp13028
a((dp13029
g2
(lp13030
VI'd vote for :
p13031
as(dp13032
g15
V34509
p13033
stp13034
a((dp13035
g2
(lp13036
VYou misunderstand something
p13037
aVSaying input iterators are only guaranteed to be usable as rvalues doesn't mean you can't get an lvalue out of an iterator somehow
p13038
aVSo it does not mean that the result of  is an rvalue
p13039
aVWhat you/for_each passes to  is the result of  - not the iterator itself
p13040
aVAbout  and a modifying function object - read this question
p13041
as(dp13042
g15
V34509
p13043
stp13044
a((dp13045
g2
(lp13046
VWhat you ultimately want, i think, is to have the user type
p13047
aVAnd depending on , the user will get slight different things
p13048
aVThe first will not fulfill that, but the second will, on the price of code duplication
p13049
aVWhat you can do is to invert the inheritance:
p13050
aVAnd implement the few functions that depend only on N being some specific value in the appropriate base-class
p13051
aVYou may add a protected destructor into them, to prevent users deleting instances of  through pointers to  (normally they should not even be able to name : Put those bases in some implementation namespace, like )
p13052
aVAnother idea is to combine this solution with the one mentioned in another answer
p13053
aVInherit privately (instead of publicly as above) and add wrapper functions into the derived class that call the implementations of the base-class
p13054
aVYet another idea is to use just one class and then  (using ) to enable or disable them for particular values of , or use a int-to-type transformer like this which is much simplier
p13055
aVThat way, it is completely transparent to the user of
p13056
aVIt also won't add any space overhead for compilers doing the empty base class optimization (quite common)
p13057
as(dp13058
g15
V34509
p13059
stp13060
a((dp13061
g2
(lp13062
VI've seen compilers that don't emit any v-table if no non-inline function at all exists (and defined in one implementation file instead of a header then)
p13063
aVThey would throw errors like  or something similar, and you would be confused as hell, as i was
p13064
aVIndeed, that's not conformant with the Standard, but it happens so consider putting at least one virtual function not in the header (if only the virtual destructor), so that the compiler could emit a vtable for the class at that place
p13065
aVI know it happens with some versions of
p13066
aVAs someone mentioned, inline virtual functions can be a benefit sometimes, but of course most often you will use it when you do not know the dynamic type of the object, because that was the whole reason for  in the first place
p13067
aVThe compiler however can't completely ignore
p13068
aVIt has other semantics apart from speeding up a function-call
p13069
aVThe implicit inline for in-class definitions is the mechanism which allows you to put the definition into the header: Only  functions can be defined multiple times throughout the whole program without a violation any rules
p13070
aVIn the end, it behaves as you would have defined it only once in the whole program, even though you included the header multiple times into different files linked together
p13071
as(dp13072
g15
V34509
p13073
stp13074
a((dp13075
g2
(lp13076
VI ported newlib and GCC myself too
p13077
aVAnd i remember i didn't have to do much stuff to make newlib work (porting GCC, gas and libbfd was most of the work)
p13078
aVJust had to tweak some files about floating point numbers, turn off some POSIX/SomeOtherStandard flags that made it not use some more sophisticated functions and write support code for  /  that load and store register state into the jump buffers
p13079
aVBut you certainly have to tell it the target using  so it uses the right machine sub-directory and whatnot
p13080
aVI remember i had to add small code to  to make it know about my target and print out the complete configuration trible (cpu-manufacturer-os or similar)
p13081
aVJust found i had to edit a file called  too, which sets some options for your target (for example, whether an operation systems handles signals risen by , or whether newlib itself should simulate handling)
p13082
aVI used this blog of Anthony Green as a guideline, where he describes porting of GCC, newlib and binutils
p13083
aVI think it's a great source when you have to do it yourself
p13084
aVA fun read anyway
p13085
aVIt took a total of 2 months to compile and run some fun C programs that only need free-standing C (with dummy read/write functions that wrote into the simulator's terminal)
p13086
aVSo i think the amount of work is certainly manageable
p13087
aVThe one that made me nearly crazy was 's build scripts
p13088
aVI certainly was lost in those autoconf magics :) Anyway, i wish you good luck
p13089
aV:)
p13090
as(dp13091
g15
V34509
p13092
stp13093
a((dp13094
g2
(lp13095
VYes, explicitly specializing a function without fully specializing all outer template is not possible (an explicit function specialization is a real function - there can't be any "variable parts" around it that are still parameterized by a template)
p13096
aVA simple way is to use a type2type template together with overloading:
p13097
aVNow, it will call the second  overload if you call it with , and the first otherwise, because the first one is less special
p13098
aVUsing  is possible too:
p13099
aVNow, the second one is taken if  is void, and the first one is taken if  is something else again
p13100
aVBut using a different technique
p13101
aVThis one is called
p13102
aVAn alternative way, but which again adds one parameter is this - to demonstrate the way SFINAE works:
p13103
aVhappens if the substitution of a template parameter yields to an invalid type or construct
p13104
aVBelow, we try to create a pointer to an array of size 0 or 1 respectively
p13105
aVAn array of size 0 is not valid, and will cause an SFINAE failure - the corresponding template specialization will not be considered as a call-candidate if it is a function
p13106
aVIn the  case above, it works different
p13107
aVIf  is given something derived from , then it makes its  typedef not existent
p13108
aVderives itself from  in the case types are not the same
p13109
aVWe would then try to access a not existent name - which is an invalid construct and would therefor be an SFINAE failure too
p13110
as(dp13111
g15
V34509
p13112
stp13113
a((dp13114
g2
(lp13115
VIf you have a member initialized like that, it will be
p13116
aVThat is also true for PODs
p13117
aVFor a struct, every member is value-initialized that way, and for an array, every element of it is value-initialized
p13118
aVValue-initialization for a scalar type like pointer or integer you will have it inialized to  converted to the right type
p13119
aVSo you will get null pointers or false or whatever type you have concretely
p13120
aVNote that the rule changed subtly from C++98 to C++03 (what we have right now), which can have surprising effects
p13121
aVC++98 didn't have that
p13122
aVIt said default initialization happens, which for a non-POD type always meant it's default constructor invokes
p13123
aVBut  in C++03 has special meaning if there is no user-declared constructor: Every element is value-initialized then
p13124
aVHere is the difference:
p13125
aVNow, in C++03, you will be guaranteed that  is zero
p13126
aVWhile in C++98,  will have some indeterminated value
p13127
as(dp13128
g15
V34509
p13129
stp13130
a((dp13131
g2
(lp13132
VThere is a definition present here:
p13133
aVThat style of definition is using an identifier list for its parameters
p13134
aVThe style is deprecated (obsolescent) but can still be used in C
p13135
aVThe identifiers are named in the parameter list, and their type are named in declarations that immediately follow the function declarator but precede the functions body
p13136
aVThe  macro is there to handle compilers that don't know about prototypes for functions (the other form to declare parameters - with type and name combined directly in the function parameter list)
p13137
aVIt would then just emit no parameters at all in declarations, i think
p13138
aVUpdate: See this code in :
p13139
as(dp13140
g15
V34509
p13141
stp13142
a((dp13143
g2
(lp13144
VThere is no reason why that reference would be wrong or bad
p13145
aVIf what you want is a local short-cut name ("alias"), references are the way to go
p13146
aVIf you copy the float into a new variable, then you will get a new object and as you pointed out, of course you will also get a new address: Not at all what you would have wanted
p13147
aVSo take a reference for that:
p13148
aVWhich will behave as the original variable in expressions
p13149
aVHowever, as with everything, hard-coded rules won't do it
p13150
aVIt depends on the specific situation
p13151
aVIf you don't care about the object, but rather about the object's value, then create a copy
p13152
aVIt's better to use the float directly than have that possible indirection through a reference when all you are interested in is to get easy access to the value of something
p13153
aVWhat is bad is to use a reference when storing the result of a computation - because what is clearly of interest is the value only
p13154
aVYou couldn't have any interest in a temporary float identity anyway, because it doesn't exist in the first place: A temporary float is not an object
p13155
aVIt isn't even required to have any address (which can happen if the compiler keeps the float in a register):
p13156
aVSame with the result of a function call of course
p13157
as(dp13158
g15
V34509
p13159
stp13160
a((dp13161
g2
(lp13162
VThe Standard answers all questions in section 9
p13163
aV5:
p13164
aVIn a union, at most one of the data members can be active at any time, that is, the value of at most one of the data members can be stored in a union at any time
p13165
aV[Note: one special guarantee is made in order to simplify the use of unions: If a POD-union contains several POD-structs that share a common initial sequence (9
p13166
aV2), and if an object of this POD-union type contains one of the POD-structs, it is permitted to inspect the common initial sequence of any of POD-struct members; see 9
p13167
ag976
aV] The size of a union is sufficient to contain the largest of its data members
p13168
aVEach data member is allocated as if it were the sole member of a struct
p13169
aVThat means each member share the same memory region
p13170
aVThere is at most one member active, but you can't find out which one
p13171
aVYou will have to store that information about the currently active member yourself somewhere else
p13172
aVStoring such a flag in addition to the union (for example having a struct with an integer as the type-flag and an union as the data-store) will give you a so called "discriminated union": An union which knows what type in it is currently the "active one"
p13173
aVOne common use is in lexers, where you can have different tokens, but depending on the token, you have different informations to store (putting  into each struct to show what a common initial sequence is):
p13174
aVThe Standard allows you to access  of each member, because that's the common initial sequence of each one
p13175
aVThere exist compiler extensions that allow accessing all members disregarding which one currently has its value stored
p13176
aVThat allows efficient reinterpretation of stored bits with different types among each of the members
p13177
aVFor example, the following may be used to dissect a float variable into 2 unsigned shorts:
p13178
aVThat can come quite handy when writing low-level code
p13179
aVIf the compiler does not support that extension, but you do it anyway, you write code whose results are not defined
p13180
aVSo be certain your compiler has support for it if you use that trick
p13181
as(dp13182
g15
V34509
p13183
stp13184
a((dp13185
g2
(lp13186
VWell, in general, C++ templates and C# generics are similar - compared to Java generics which are completely different, but they have also large differences
p13187
aVLike in C#, there is runtime support by using reflection, getting an object describing the types used to instantiate a generics
p13188
aVC++ doesn't have reflection, and all it does with types is done at compile time
p13189
aVThe biggest difference between C# generics and C++ templates indeed are that C# generics are better type checked
p13190
aVThey are always constrained, in the sense that they don't allow operations that are not stated valid at the time of defining the generics
p13191
aVC#'s chief designer raised as a reason of that the added complexity it would have taken to have implied constraints
p13192
aVI'm not well versed with C#, so i can't talk further here
p13193
aVI'll talk about about how matters are in C++ and how they are going to be improved, so that people don't think C++'s stuff is all wrong
p13194
aVIn C++, templates are not constrained
p13195
aVIf you do an operation, at template definition time it is implied that the operation will succeed at instantiation time
p13196
aVIt's not even required to a C++ compiler that the template is syntactically checked for validity
p13197
aVIf it contains a syntax error, then that error has to be diagnosed at instantiation
p13198
aVAny diagnose before that is a pure goody of the implementation
p13199
aVThose implied constraint have shown to be easy for the template designer in the short term, because they don't have to care about stating the valid operations in their template interface
p13200
aVThey put the burden on the user of their template - so the user has to make sure he fulfills all those requirements
p13201
aVOften it happens that the user tries seemingly valid operations but fails, with the compiler giving the user hundreds of lines of error messages about some invalid syntax or not found names
p13202
aVBecause the compiler can't know what constraint in particular was violated in the first place, it lists all parts of code paths ever involved around the faulty place and all not even important details, and the user will have to crawl through the horrible error message text
p13203
aVThat is a fundamental problem, which can be solved by just stating at the interface for a template or generics what properties a type parameter has to have
p13204
aVC#, as far as i know it, can constraint the parameter to implement an interface or inherit a base-class
p13205
aVIt solves that on a type-level
p13206
aVThe C++ committee has long seen there is need to fix these problems, and soon (next year, probably), C++ will have a way to state such explicit constraints too (see time-machine note below), as in the following case
p13207
aVThe compiler signals an error at that point, because the expression as written is not marked valid by the requirements
p13208
aVThis first helps the designer of the template to write more correct code, because the code is type-checked already to some degree (well to what is possible there)
p13209
aVThe programmer can now state that requirement:
p13210
aVNow, it will compiler
p13211
aVThe compiler, by seeing  appearing as the return type, automatically implied that  is copyable, because that use of  appears in the interface, rather than in the templates body
p13212
aVThe other requirements were stated using requirement clauses
p13213
aVNow, the user will get a appropriate error message if he uses a type that doesn't have an  defined
p13214
aVC++1x decouples the requirements from the type
p13215
aVThe above works for primitive types aswell as for classes
p13216
aVIn this sense, they are more flexible, but quite a bit complex
p13217
aVThe rules that state when and when requirements are satisfied are long
p13218
aVYou can with the new rules say the following:
p13219
aVAnd then, call  with an
p13220
aVThat would work by just writing a concept map for  that teaches the compiler how an int can be dereferenced
p13221
aVIt will get quite handy in loops like this:
p13222
aVSince the programmer can tell the compiler how an int can satisfy the concept of an , you could actually write such code in C++1x, if you only write the appropriate concept map, which really isn't all that difficult
p13223
aVOk, enough with this
p13224
aVI hope i could show you that having templates constrained is not all that bad, but in fact better, because the relationship betweens types and the operations on them within the templates are now known by the compiler
p13225
aVAnd i haven't even written about , which are another nice thing in ' concepts
p13226
aVRemember that this is future stuff, it's not yet out, but it will approximately at 2010
p13227
aVThen we will have to wait for some compiler to implement that all :)
p13228
aVUPDATE FROM "FUTURE"
p13229
aVC++0x concepts were not accepted into the draft but have been voted out at late of 2009
p13230
aVToo bad
p13231
aVBut perhaps we will see it again in the next C++ version
p13232
aVLet's all hope
p13233
as(dp13234
g15
V34509
p13235
stp13236
a((dp13237
g2
(lp13238
VNothing special would happen
p13239
aVYou would write at some place in the middle of the allocated memory (100 bytes apart from the start, 99 bytes before the end of the allocated memory)
p13240
aVThen you would free that allocated memory
p13241
aVThe compiler will handle it exactly as we would expect
p13242
aVThe memory allocated by that is completely unrelated to null terminated strings
p13243
aVYou could stick everything you want into that memory
p13244
aVIt's some "raw" chunk of storage, you could even create some arbitrary C++ object into that memory (placement new)
p13245
aVYour bug is somewhere else
p13246
aVFor example, some common error is this one, where the constructor is called once, but the destructor is called twice, double-deleting something:
p13247
aVNow, what happens is that the default constructor is called once, and the created object is copied zero or more times
p13248
aVBut the destructor is run for each copy that's created
p13249
aVThus, you will call the destructor on the pointer more than once, leading to such strange bugs
p13250
aVThe correct way to fix that is to use a smart pointer, like
p13251
aVAs an exercise, you can also do it without, by writing proper copy constructors that copy the object over and allocate memory in the copy constructor, so that the copy and the respective original object keep distinct pointers
p13252
as(dp13253
g15
V34509
p13254
stp13255
a((dp13256
g2
(lp13257
VWell, what you created is not a variable array
p13258
aVIt's an array whose size is not known
p13259
aVThat array has an incomplete type, and can thus not be defined in C++
p13260
aVWhat you can do is to make it just a declaration by putting  before it
p13261
aVThen, in the
p13262
aVcpp file that initializes it, you can then create (define) that array - beware you should do it at namespace scope, outside any function, of course:
p13263
aVIf what you want is an array whose size is not known at compile time yet, but rather at runtime, you should use a :
p13264
aVThen later if you fill it, do
p13265
aVOr create a local array and then initialize the vector using a copy of the elements of that array:
p13266
aVWell, in C, it is slightly different than in C++
p13267
aVYou can define an array whose dimension isn't known
p13268
aVWhat happens is that it's taken to be a "tentative" definition
p13269
aVIf at the end of the file (more precisely, of its translation unit, which is that file, and all the files it includes - meaning everything the compiler translates together) there is not a subsequent definition of it that includes the size, then the size is taken to be
p13270
aVHowever, in C++ there are no tentative definitions, and a definition that does not include the size and does not contain an initializer that can tell the size is an invalid C++ program
p13271
aVFor the reason why your code goes grazy, you are doing
p13272
aVWhich the compiler will read as:
p13273
aVYou see, the compiler has no clue what the right hand side is supposed to mean
p13274
aVC99, for that reason (1999 version of C) introduced so-called compound literals
p13275
aVIt allows you to write
p13276
aVAnd it will actually do what you want it to do - creating a right hand side value of type  and assigns it to the left hand side
p13277
aVBut you should just, already from a compatibility reason (many C compilers are not reasonable C99 compliant - and neither C++ nor C89 supports compound literals), use one of the previous ways i showed you
p13278
as(dp13279
g15
V34509
p13280
stp13281
a((dp13282
g2
(lp13283
VJust another way how to do it using boost iterators
p13284
aVThis time, using :
p13285
aVIt will call a function (In this example
p13286
aVBut it can be anything boost::bind can construct - also a member-function) for each pointer that's pointing to a
p13287
as(dp13288
g15
V34509
p13289
stp13290
a((dp13291
g2
(lp13292
VThe members are actually copy-initialized
p13293
aVThe default constructor for each one is not called and no  is involved contrary to what some other answers suggest
p13294
aVIt can be shown by a software called  - alternatively by reading through the Standard
p13295
aVI'll show the "fun" way using that software
p13296
aVIt has got a class  that can show us when constructors/copy-constructors or destructors/copy assignment operators are called
p13297
aVThe output it shows is ( limits tracking to the statement following it):
p13298
aVI used this code
p13299
aVAs you see, the second  object - which is the member within the local variable , is copy initialized from the other object
p13300
aVOf course, no assignment operator is activated
p13301
aVYou can read about it in  in the Standard, if you wish
p13302
aVThe same, by the way, is true with arrays (which are likewise aggregates)
p13303
aVMany people believe that objects that are member of arrays must have a type that has a default constructor
p13304
aVBut that's not true
p13305
aVThey can just be copy initialized by another object of their type and it will work fine
p13306
aVAll other elements that were not explicitly initialized in the aggregate are value initialized
p13307
aVValue-initialization is a mixture of default initialization and zero initialization
p13308
aVActually, if a member has a type that has a user declared constructor, then that constructor is invoked
p13309
aVIf it has a type that does not have a user declared constructor, then each member of it is value initialized
p13310
aVFor built-in types (int, bool, pointers,
p13311
aVa value initialization is the same as zero initialization (that means that such a variable will become zero)
p13312
aVThe following will initialize each member to zero - except the first (a), which will be one:
p13313
aVThose initialization rules are scary, indeed - especially because the 2003 revision of C++ introduced that value initialization
p13314
aVIt wasn't part of the Standard as of 1998
p13315
aVIf you are more interested in those brace enclosed initializations, you can read How to initialize nested structures in C++
p13316
as(dp13317
g15
V34509
p13318
stp13319
a((dp13320
g2
(lp13321
VAs you are just learning C, i recommend you to really try to understand the differences between arrays and pointers first instead of the common things
p13322
aVIn the area of parameters and arrays, there are a few confusing rules that should be clear before going on
p13323
aVFirst, what you declare in a parameter list is treated special
p13324
aVThere are such situations where things don't make sense as a function parameter in C
p13325
aVThese are
p13326
aVFunctions as parameters
p13327
aVArrays as parameters
p13328
aVArrays as parameters
p13329
aVThe second maybe is not immediately clear
p13330
aVBut it becomes clear when you consider that the size of an array dimension is part of the type in C (and an array whose dimension size isn't given has an incomplete type)
p13331
aVSo, if you would create a function that takes an array by-value (receives a copy), then it could do so only for one size
p13332
aVIn addition, arrays can become large, and C tries to be as fast as possible
p13333
aVIn C, for these reasons, array-values are not existent
p13334
aVIf you want to get the value of an array, what you get instead is a pointer to the first element of that array
p13335
aVAnd herein actually already lies the solution
p13336
aVInstead of drawing an array parameter invalid up-front, a C compiler will transform the type of the respective parameter to be a pointer
p13337
aVRemember this, it's very important
p13338
aVThe parameter won't be an array, but instead it will be a pointer to the respective element type
p13339
aVNow, if you try to pass an array, what is passed instead is a pointer to the arrays' first element
p13340
aVExcursion: Functions as parameters
p13341
aVFor completion, and because i think this will help you better understand the matter, let's look what the state of affairs is when you try to have a function as a parameter
p13342
aVIndeed, first it won't make any sense
p13343
aVHow can a parameter be a function
p13344
aVHuh, we want a variable at that place, of course
p13345
aVSo what the compiler does when that happens is, again, to transform the function into a function pointer
p13346
aVTrying to pass a function will pass a pointer to that respective function instead
p13347
aVSo, the following are the same (analogous to the array example):
p13348
aVNote that parentheses around  is needed
p13349
aVOtherwise, it would specify a function returning , instead of a pointer to a function returning
p13350
aVBack to arrays
p13351
aVNow, i said at the beginning that arrays can have an incomplete type - which happens if you don't give a size yet
p13352
aVSince we already figured that an array parameter is not existant but instead any array parameter is a pointer, the array's size doesn't matter
p13353
aVThat means, the compiler will translate all of the following, and all are the same thing:
p13354
aVOf course, it doesn't make much sense to be able to put any size in it, and it's just thrown away
p13355
aVFor that reason, C99 came up with a new meaning for those numbers, and allows other things to appear between the brackets:
p13356
aVThe last two lines say that you won't be able to change "argv" within the function - it has become a const pointer
p13357
aVOnly few C compilers support those C99 features though
p13358
aVBut these features make it clear that the "array" isn't actually one
p13359
aVIt's a pointer
p13360
aVA word of Warning
p13361
aVNote that all i said above is true only when you have got an array as a parameter of a function
p13362
aVIf you work with local arrays, an array won't be a pointer
p13363
aVIt will behave as a pointer, because as explained earlier an array will be converted to a pointer when its value is read
p13364
aVBut it should not be confused with pointers
p13365
aVOne classic example is the following:
p13366
as(dp13367
g15
V34509
p13368
stp13369
a((dp13370
g2
(lp13371
VYou've some problems
p13372
aVFirst, you try to pass a  to a parameter that's type
p13373
aVThat won't work
p13374
aVGive it type :
p13375
aVThen, you need to pass the size in an additional argument
p13376
aVThe problem is, that when you pass arrays, you really pass just a pointer (the compiler will make up a temporary pointer that points to the array's first element)
p13377
aVSo you need to keep track of the size yourself:
p13378
aVNow it will work
p13379
aVAlso put the return type before them
p13380
aVSome compilers may reject your code, since it doesn't comply to the most recent C Standard anymore, and has long been deprecated (omitting the return type was the way you coded with the old K&R; C)
p13381
as(dp13382
g15
V34509
p13383
stp13384
a((dp13385
g2
(lp13386
VBecause it is a pointer to foo
p13387
aVAnd foo has 3 characters
p13388
aVSo it becomes
p13389
aVThe other one has type , so it becomes
p13390
aVNote that the text is implementation dependent, and in this case GCC just gives you the internal, mangled name
p13391
aVEnter that mangled name into the program  to get the unmangled name:
p13392
as(dp13393
g15
V34509
p13394
stp13395
a((dp13396
g2
(lp13397
VI recommend :
p13398
as(dp13399
g15
V34509
p13400
stp13401
a((dp13402
g2
(lp13403
VEven if they would be located in different translation units, the initialisation order is still defined
p13404
aVThat is because  is initialized with a constant expression () and  has pod-type
p13405
aVIt would still hold true if you had an array
p13406
aVBut it would not be true anymore if you had a
p13407
aVThose are dynamically initialized (because  is a non-POD)
p13408
aVThus, if your  were a , you would run into undefined behavior if  is defined in a different translation unit, but that's the only case of the one you listed that would cause trouble
p13409
as(dp13410
g15
V34509
p13411
stp13412
a((dp13413
g2
(lp13414
VI use it all the time
p13415
aVMy rule is if it doesn't need the header, then i put a forward declaration ("use headers if you must, use forward declarations if you can")
p13416
aVThe only thing that sucks is that i need to know how the class was declared (struct/class, maybe if it is a template i need its parameters,
p13417
aVBut in the vast majority of times, it just comes down to  or something along that
p13418
aVIf something requires some more hassle to be just declared, one can always declare a special forward declare header like the Standard does with  too
p13419
aVNot including the header file will not only reduce compile time but also will avoid polluting the namespace
p13420
aVFiles including the header will thank you for including as little as possible so they can keep using a clean environment
p13421
aVThis is the rough plan:
p13422
aVThere are smart pointers that are specifically designed to work with pointers to incomplete types
p13423
aVOne very well known one is
p13424
as(dp13425
g15
V34509
p13426
stp13427
a((dp13428
g2
(lp13429
VLike everyone else says, the comma is not required
p13430
aVBut it's new in C99 (wasn't allowed in C89) and will be allowed in the next version of C++ too
p13431
aVOne other rationale is to make a difference between a "length" enumerator and a normal enumerator:
p13432
aVNow, you can put into your coding guideline that the last item in your enumeration should have a comma applied, but not if it is a "Length" item - which just tells how many items there are
p13433
aVIt also helps for automatic generation of items (using macros/preprocessors) like other answers explain
p13434
as(dp13435
g15
V34509
p13436
stp13437
a((dp13438
g2
(lp13439
VA technique used in the clang compiler source is to create  files that contains a list like this, which is designed like a C file and can easily be maintained without touching other code files that use it
p13440
aVFor example:
p13441
aVNow, what it does is including the file like this:
p13442
aVIn your case, you could do similar
p13443
aVIf you can live with , ,
p13444
aVas enumerator names you could use the same approach like above
p13445
aVOtherwise, just pass the macro two things
p13446
aVOne lowercase name and one uppercase name
p13447
aVThen you could stringize the one you want like above
p13448
as(dp13449
g15
V34509
p13450
stp13451
a((dp13452
g2
(lp13453
VFirst, you have to store some state into each stream
p13454
aVYou can do that with the function  and an index you pass to it, given by :
p13455
aVHaving that in place, you can already retrieve some state in all streams
p13456
aVNow, you just have to hook into the respective output operation
p13457
aVNumeric output is done by a facet, because it potentially is locale dependent
p13458
aVSo you can do
p13459
aVNow, you can test the stuff
p13460
aVIf you want that only the next number is incremented, just set the word to  again after each call to
p13461
as(dp13462
g15
V34509
p13463
stp13464
a((dp13465
g2
(lp13466
VThe reason for the failure is that at instantiation, no unqualified name lookup for the functions occur (but only ADL - Argument Dependent Lookup)
p13467
aVThe instantiation context is (taken from  of the C++ Standard):
p13468
aVThe instantiation context of an expression that depends on the template arguments is the set of declarations with external linkage declared prior to the point of instantiation of the template specialization in the same translation unit
p13469
aVThe point of instantiation of all those template specializations you called in this case is just after the definition of  (read )
p13470
aVSo, all functions you declared are visible in your  function using unqualified lookup, but lookup for them is actually different for the function calls:
p13471
aVA function call that depends on a template parameter within a template is looked up like this:
p13472
aVNames from the template definition context are considered by both ordinary lookup and ADL
p13473
aVNames from instantiation context are considered only for ADL
p13474
aVThis means that because there is no suitable  function declared in the definition context of the template, a suitable function has to be found in the instantiation context using ADL - otherwise the call will fail and not find any declaration
p13475
aVArgument Dependent Lookup (ADL)
p13476
aVFor an argument of type , ADL searches for functions in namespace  and the namespace of
p13477
aVPutting the  function into the  namespace would work for this (but doing so is not allowed by the Standard because that yields to undefined behavior - this should be done only as the last resort)
p13478
aVTo see the effects of  try to call  with a vector of  instead of
p13479
aVSince then , ADL will search in the namespace of  for a suitable function accepting a  and will succeed - opposed to when you use , which will only look into
p13480
aVFor the other function calls, their respective declarations are all found too, because they are all declared in the global namespace, in which the argument types of the function calls are defined too (,  etc)
p13481
aVThe C++ FAQ is good, but it doesn't go deep into templates (haven't found any mentioning of ADL in it)
p13482
aVThere is a dedicated template faq that handles some of the more intricate pitfalls
p13483
aVBeware of undefined behavior
p13484
aVNote that many compilers will accept the code even when you put that declaration i showed after the  function (instead of before it)
p13485
aVBut as the above Standard quote says, then the declaration won't be part of the instantiation context and the rule found in  is to be watched:
p13486
aVIf the call would be ill-formed or would find a better match had the lookup within the associated namespaces considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation contexts, then the program has undefined behavior
p13487
aVThus, what would appear to work would be undefined behavior
p13488
aVIt's valid for a compiler to accept it, but it's likewise valid for one to reject it or to crash and terminate
p13489
aVSo watch that any name needed is indeed visible at the instantiation context as explained
p13490
aVHope this helps
p13491
as(dp13492
g15
V34509
p13493
stp13494
a((dp13495
g2
(lp13496
V inserts a null character into the stream
p13497
aVGetting the content as a  will retain that null character and create a string with that null character at the respective positions
p13498
aVSo indeed a std::string can contain embedded null characters
p13499
aVThe following std::string contents are different:
p13500
aVA binary zero is not whitespace
p13501
aVBut it's also not printable, so you won't see it (unless your terminal displays it specially)
p13502
aVComparing using  will interpret the content of a  as a C string when you pass
p13503
aVIt will say
p13504
aVHmm, characters before the first  (terminating null character) are ABC, so i take it the string is ABC
p13505
aVAnd thus, it will not see any difference between the two above
p13506
aVYou are probably having this issue:
p13507
aVThe assert will fail, because the sequence that the stringstream uses is still the old one that contains "hello"
p13508
aVWhat you did is just overwriting the first character
p13509
aVYou want to do this:
p13510
aVAlso read this answer: How to reuse an ostringstream
p13511
as(dp13512
g15
V34509
p13513
stp13514
a((dp13515
g2
(lp13516
VIf you talk about C++, in there you can't pass namespaces as entities around
p13517
aVBut you can do so with types, as type argument to templates
p13518
aVIn this case, an MPL sequence could help together with MPL algorithms:
p13519
aVYou may then create your array like
p13520
aVNote that the search within that type-vector happens at compile time
p13521
aVSo the value of the array is determined at compile time either
p13522
as(dp13523
g15
V34509
p13524
stp13525
a((dp13526
g2
(lp13527
VThe pipe you use here:
p13528
aVWill execute the while loop afterwards in a sub-shell
p13529
aVBut that means that the  variable won't be updated in the parent shell, but only in the sub-shell you execute the loop in
p13530
aVInclude the echo commands at the end inside that sub-shell instance:
p13531
aVThat problem is also explained in a Bash FAQ item
p13532
aVHope this helps
p13533
aVAs the FAQ explains, in that particular case, you can also rewrite it so it reads:
p13534
aVPrefer the second option in this case, since it will get rid of one "useless use of cat" :)
p13535
as(dp13536
g15
V34509
p13537
stp13538
a((dp13539
g2
(lp13540
VContrary what some are saying in their answers, it is possible
p13541
aVWill zero initialize all the characters (in reality, it's called value-initialization
p13542
aVBut value-initialization is going to be zero-initialization for all its members of an array of scalar type)
p13543
aVIf that's what you are after
p13544
aVWorth to note that it does also work for (arrays of) class-types without user declared constructor in which case any member of them is value initialized:
p13545
aVIt's not some extension or something
p13546
aVIt worked and behaved the same way in C++98 too
p13547
aVJust there it was called default initialization instead of value initialization
p13548
aVZero initialization, however, is done in both cases for scalars or arrays of scalar or POD types
p13549
as(dp13550
g15
V34509
p13551
stp13552
a((dp13553
g2
(lp13554
VI recommend you to do it exactly as you have shown, since it is the most straight forward one
p13555
aVInitialize to  which will work always, independent of the actual sign representation, while  will sometimes have surprising behavior because you will have to have the right operand type
p13556
aVOnly then you will get the most high value of an  type
p13557
aVFor an example of a possible surprise, consider this one:
p13558
aVIt won't necessarily store a pattern with all bits 1 into
p13559
aVBut it will first create a pattern with all bits 1 in an , and then assign it to
p13560
aVWhat happens when  has more bits is that not all of those are 1
p13561
aVAnd consider this one, which will fail on a non-two's complement representation:
p13562
aVThe reason for that is that  has to invert all bits
p13563
aVInverting that will yield  on a two's complement machine (which is the value we need
p13564
aV, but will not yield  on another representation
p13565
aVOn a one's complement machine, it yields zero
p13566
aVThus, on a one's complement machine, the above will initialize  to zero
p13567
aVThe thing you should understand is that it's all about values - not bits
p13568
aVThe variable is initialized with a value
p13569
aVIf in the initializer you modify the bits of the variable used for initialization, the value will be generated according to those bits
p13570
aVThe value you need, to initialize  to the highest possible value, is  or
p13571
aVThe second will depend on the type of  - you will need to use  for an
p13572
aVHowever, the first will not depend on its type, and it's a nice way of getting the most highest value
p13573
aVWe are not talking about whether  has all bits one (it doesn't always have)
p13574
aVAnd we're not talking about whether  has all bits one (it has, of course)
p13575
aVBut what we are talking about is what the result of the initialized  variable is
p13576
aVAnd for it, only  will work with every type and machine
p13577
as(dp13578
g15
V34509
p13579
stp13580
a((dp13581
g2
(lp13582
VThe compiler is doing the right thing:  should use the  defined as a member function
p13583
aVBecause the temporary stream object cannot be bound to a non-const reference but only to a const reference, the non-member operator that handles  won't be selected
p13584
aVAnd it's designed that way, as you see when you change that operator
p13585
aVYou get ambiguities, because the compiler can't decide which of the available operators to use
p13586
aVBecause all of them were designed with rejection of the non-member  in mind for temporaries
p13587
aVThen, yes, a string literal has a different type than a
p13588
aVA string literal is an array of const characters
p13589
aVBut that wouldn't matter in your case, i think
p13590
aVI don't know what overloads of  MSVC++ adds
p13591
aVIt's allowed to add further overloads, as long as they don't affect the behavior of valid programs
p13592
aVFor why  works even when the first parameter is a non-const reference
p13593
aVWell, MSVC++ has an extension that allows non-const references bind to temporaries
p13594
aVPut the warning level on level 4 to see a warning of it about that (something like "non-standard extension used
p13595
aVNow, because there is a member operator<< that takes a , and a  can convert to that, that operator will be chosen and the address will be output as that's what the  overload is for
p13596
aVI've seen in your code that you actually have a  overload, not a  overload
p13597
aVWell, a string literal can convert to , even though the type of a string literal is  (with N being the amount of characters you put)
p13598
aVBut that conversion is deprecated
p13599
aVIt should be not standard that a string literal converts to
p13600
aVIt looks to me that is another extension by the MSVC++ compiler
p13601
aVBut that would explain why the string literal is treated differently than the  pointer
p13602
aVThis is what the Standard says:
p13603
aVA string literal (2
p13604
aV13
p13605
aV4) that is not a wide string literal can be converted to an rvalue of type "pointer to char"; a wide string literal can be converted to an rvalue of type "pointer to wchar_t"
p13606
aVIn either case, the result is a pointer to the first element of the array
p13607
aVThis conversion is considered only when there is an explicit appropriate pointer target type, and not when there is a general need to convert from an lvalue to an rvalue
p13608
aV[Note: this conversion is deprecated
p13609
aVSee Annex D
p13610
ag4885
as(dp13611
g15
V34509
p13612
stp13613
a((dp13614
g2
(lp13615
VJust for what it is and what not
p13616
aVThere are no pointers involved
p13617
aVA multi dimensional array like that is an array of arrays of
p13618
aVand so on
p13619
aVIn your case, you have an array of 3 arrays of 5 characters
p13620
aVIt becomes clearer when you do it with typedefs
p13621
aVNo pointers are involved whatsoever
p13622
aVIf you want to access the first array of those 3 ones, you can do so:
p13623
aVAnd it will give you back an object of type
p13624
aVNormally, you don't notice that because normally you index all dimensions
p13625
aVSo the array that's returned by  is subscript by the next index, for example
p13626
aVThe  will be applied to the array that was returned by , which as we have figured out earlier has type
p13627
aVSo, is this an array of 3 pointers to 5 arrays of chars or what
p13628
aVLet's create that type and see how it's different to the above
p13629
aVCreating it is simple, once you get the basic declarators:
p13630
aVCreating a pointer:
p13631
aVCreating an array:
p13632
aVD is just an existing another declarator
p13633
aVSo now let's go on
p13634
aVFirst you say
p13635
aVI think you meant
p13636
aVFirst,  is created like
p13637
aVNow, let's replace D1 by a  declarator:
p13638
aVWe had to insert parentheses, because the subscript operator  binds better than the dereference operator , and it would otherwise be read as  which isn't what we want
p13639
aVNow we have
p13640
aVNow let's do the
p13641
aVReplacing  by  yields this:
p13642
aVGreat, now we have got a
p13643
aVJust putting the base type that that declarator appertains to yields the complete declaration:
p13644
aVThat's of course a complete different thing :) You could use it to store pointers to your other array which was of type
p13645
aVLet's store a pointer to the first sub-array of  into
p13646
aVWe figured out earlier that  has type
p13647
aVWe can store a pointer to that array into , because  is an array of pointers to , what a coincidence
p13648
aVI hope this little exercise has shown you some of the relations between pointers and arrays
p13649
aVCheers
p13650
as(dp13651
g15
V34509
p13652
stp13653
a((dp13654
g2
(lp13655
VMicrosoft decided to mark the name without underscore deprecated, because those names are reserved for the programmer to choose
p13656
aVImplementation specific extensions should use names starting with an underscore in the global namespace if they want to adhere to the C or C++ Standard - or they should mark themselves as a combined Standard compliant environment, such as POSIX/ANSI/ISO C, where such a function then corresponds to one of those Standards
p13657
aVRead this answer about getcwd() too, for an explanation by P
p13658
ag11988
aVPlauger, who knows stuff very well, of course
p13659
aVIf you are only interested to wait for some keys typed by the user, there really is no reason not to use
p13660
aVBut sometimes it's just more practical and convenient to the user to use  and friends
p13661
aVHowever, those are not specified by the C or C++ Standard and will thus limit the portability of your program
p13662
aVKeep that in mind
p13663
as(dp13664
g15
V34509
p13665
stp13666
a((dp13667
g2
(lp13668
VWill delete all files/directories below the current one
p13669
aVIf you want to do the same with another directory whose name you have, you can just name that
p13670
aVIf you want to remove not only the sub-directories and files of it, but also the directory itself, omit
p13671
aVDo it without the  to get a list of the things that will be removed
p13672
as(dp13673
g15
V34509
p13674
stp13675
a((dp13676
g2
(lp13677
VWhat are you looking for
p13678
aVAutomatic type inference or looking for the type so you can declare a variable correctly manually
p13679
aV(your own answers look like you want to have the second one)
p13680
aVIn this case, consider using Geordi:
p13681
aVAutomatic type inference is not currently possible without helper libraries like boost
p13682
aVtypeof, which will use compiler extensions like  for GCC
p13683
aVNext C++ will get  (with different semantics than current ) and will be able to do that, together with  to get the type of an expression
p13684
aVIf you can live with getting out of local context, you can always create a function template like this:
p13685
as(dp13686
g15
V34509
p13687
stp13688
a((dp13689
g2
(lp13690
VYou can give each tab an icon (using  if i remember correctly)
p13691
aVI did that in the past to show some progress bar
p13692
aVYou could use it to draw a bitmap (wxMemoryDC) every time your timer triggers and update that image
p13693
aVYou can also use
p13694
aVIt doesn't use native widgets, but it's part of the AUI framework (adopted in wx2
p13695
aV8) and it allows modern things, like drag&drop; of tabs
p13696
aVOf course it also has  method
p13697
aVYou could either render a small led blinking, or you could draw the name of the contact on a colored background (whose color changes each blink interval) and use it itself as the icon instead of drawing the contact name next to the icon
p13698
aVThe latter method only works using  if i recall correctly
p13699
aVIt's been some time since i did it, but it worked out very nicely
p13700
as(dp13701
g15
V34509
p13702
stp13703
a((dp13704
g2
(lp13705
VPut the static into a class so it is a static member of a class
p13706
aVThe Standard allows it to delay initialization of objects having namespace scope until any function/object from its translation unit is used
p13707
aVIf the initialization has side-effect, it can't be optimized out
p13708
aVBut that doesn't forbid delaying it
p13709
aVNot so of objects having class-scope
p13710
aVSo that might forbid it optimizing something there
p13711
as(dp13712
g15
V34509
p13713
stp13714
a((dp13715
g2
(lp13716
VSince you say it prints a negative value, there must be something else wrong, apart from your use of  instead of
p13717
aVA  format specifier just doesn't print a negative value
p13718
aVIt strongly looks like the problem is the  call
p13719
aVCheck that you included  and that the argument list is indeed what is in the source code
p13720
as(dp13721
g15
V34509
p13722
stp13723
a((dp13724
g2
(lp13725
VFunction pointers become easy to declare once you have the basic declarators:
p13726
aVid: : ID is a
p13727
aVPointer: : D pointer to
p13728
aVFunction: : D function taking parameters returning
p13729
aVWhile D is another declarator built using those same rules
p13730
aVIn the end, somewhere, it ends with  (see below for an example), which is the name of the declared entity
p13731
aVLet's try to build a function taking a pointer to a function taking nothing and returning int, and returning a pointer to a function taking a char and returning int
p13732
aVWith type-defs it's like this
p13733
aVAs you see, it's pretty easy to build it up using typedefs
p13734
aVWithout typedefs, it's not hard either with the above declarator rules, applied consistently
p13735
aVAs you see i missed out the part the pointer points to, and the thing the function returns
p13736
aVThat's what appears at the very left of the declaration, and is not of interest: It's added at the end if one built up the declarator already
p13737
aVLet's do that
p13738
aVBuilding it up consistently, first wordy - showing the structure using  and :
p13739
aVAs you see, one can describe a type completely by appending declarators one after each other
p13740
aVConstruction can be done in two ways
p13741
aVOne is bottom-up, starting with the very right thing (leaves) and working the way through up to the identifier
p13742
aVThe other way is top-down, starting at the identifier, working the way down to the leaves
p13743
aVI'll show both ways
p13744
aVBottom Up
p13745
aVConstruction starts with the thing at the right: The thing returned, which is the function taking char
p13746
aVTo keep the declarators distinct, i'm going to number them:
p13747
aVInserted the char parameter directly, since it's trivial
p13748
aVAdding a pointer to declarator by replacing  by
p13749
aVNote that we have to wrap parentheses around
p13750
aVThat can be known by looking up the precedence of the  and the function-call operator
p13751
aVWithout our parentheses, the compiler would read it as
p13752
aVBut that would not be a plain replace of D1 by  anymore, of course
p13753
aVParentheses are always allowed around declarators
p13754
aVSo you don't make anything wrong if you add too much of them, actually
p13755
aVReturn type is complete
p13756
aVNow, let's replace  by the function declarator function taking  returning, which is  which we are at now
p13757
aVNote that no parentheses are needed, since we want  to be a function-declarator and not a pointer declarator this time
p13758
aVGreat, only thing left is the parameters for it
p13759
aVThe parameter is done exactly the same as we've done the return type, just with  replaced by
p13760
aVSo i'll copy it:
p13761
aVI've replaced  by , since we are finished with that parameter (it's already a pointer to a function - no need for another declarator)
p13762
aVwill be the name of the parameter
p13763
aVNow, i told above at the end one adds the type which all those declarator modify - the one appearing at the very left of every declaration
p13764
aVFor functions, that becomes the return type
p13765
aVFor pointers the pointed to type etc
p13766
aVIt's interesting when written down the type, it will appear in the opposite order, at the very right :) Anyway, substituting it yields the complete declaration
p13767
aVBoth times  of course
p13768
aVI've called the identifier of the function  in that example
p13769
aVTop Down
p13770
aVThis starts at the identifier at the very left in the description of the type, wrapping that declarator as we walk our way through the right
p13771
aVStart with function taking parameters returning
p13772
aVThe next thing in the description (after "returning") was pointer to
p13773
aVLet's incorporate it:
p13774
aVThen the next thing was functon taking parameters returning
p13775
aVThe parameter is a simple char, so we put it in right away again, since it's really trivial
p13776
aVNote the parentheses we added, since we again want that the  binds first, and then the
p13777
aVOtherwise it would read function taking parameters returning function
p13778
aVNoes, functions returning functions aren't even allowed
p13779
aVNow we just need to put parameters
p13780
aVI will show a short version of the deriveration, since i think you already by now have the idea how to do it
p13781
aVJust put  before the declarators like we did with bottom-up, and we are finished
p13782
aVThe nice thing
p13783
aVIs bottom-up or top-down better
p13784
aVI'm used to bottom-up, but some people may be more comfortable with top-down
p13785
aVIt's a matter of taste i think
p13786
aVIncidentally, if you apply all the operators in that declaration, you will end up getting an int:
p13787
aVThat is a nice property of declarations in C: The declaration asserts that if those operators are used in an expression using the identifier, then it yields the type on the very left
p13788
aVIt's like that for arrays too
p13789
aVHope you liked this little tutorial
p13790
aVNow we can link to this when people wonder about the strange declaration syntax of functions
p13791
aVI tried to put as little C internals as possible
p13792
aVFeel free to edit/fix things in it
p13793
as(dp13794
g15
V34509
p13795
stp13796
a((dp13797
g2
(lp13798
VHere is one solution (using boost lambda):
p13799
as(dp13800
g15
V34509
p13801
stp13802
a((dp13803
g2
(lp13804
VIt's bad style in C to leave out  when defining or declaring a function
p13805
aVSo put it in
p13806
aVWhile it doesn't change anything about the number of parameters the function has (the function has zero parameters without that  either), it will declare the function as one that accepts only zero arguments, while it won't tell anything about the amount and types of accepted arguments when you omit the
p13807
aVHowever, both versions with and without  are correct
p13808
aVRead this answer about that matter too
p13809
as(dp13810
g15
V34509
p13811
stp13812
a((dp13813
g2
(lp13814
VThere is nothing really wrong, but it will certainly limit the use of the template
p13815
aVYou won't be able to just put an iterator returned by something else or generated like , since those will be temporaries
p13816
aVYou will always first have to make a local copy, which is some kind of boilerplate not really nice to have
p13817
aVOne way is to overload it:
p13818
aVAnother option is to have an output iterator where the number will be written into:
p13819
aVYou will have the return value to return the new input iterator
p13820
aVAnd you could then use a inserter iterator to put the parsed numbers into a vector or a pointer to put them directly into an integer or an array thereof if you already know the amount of numbers
p13821
as(dp13822
g15
V34509
p13823
stp13824
a((dp13825
g2
(lp13826
VIt would be pointless
p13827
aVYou would change the thing in the function, and the change would be lost immediately because the thing was actually a temporary
p13828
aVThe reason for the new type stems from the need to be able to decide what actually is an rvalue and what not
p13829
aVOnly then you can actually use them for the cool things they are used
p13830
aVNow, if you have some rvalue and pass it to toupper, the rvalue can directly be modified, because we know the temporary is a throw-away thing anyway, so we can aswell just change it and don't need to copy it
p13831
aVAlso, the same observation is used for the thing called move-constructors and move-assignment
p13832
aVThe right hand side is not copied, but its things are just stolen away and moved to
p13833
aVIf you were to say that rvalues can bind to non-const lvalue references, then you would have no way to figure out whether that references an lvalue (named object) or an rvalue (temporary) in the end
p13834
aVIt's probably more little know, but useful anyway, you can put lvalue or rvalue ref-qualifiers on a member function
p13835
aVHere is an example, which naturally extends the existing semantics of rvalue references to the implicit object parameter:
p13836
aVNow, you can't anymore say
p13837
aVWhich is confusing and is not really making sense most of the time
p13838
aVWhat the  above does is saying that the assignment operator can only be invoked on lvalues
p13839
aVThe same can be done for rvalues, by putting
p13840
as(dp13841
g15
V34509
p13842
stp13843
a((dp13844
g2
(lp13845
VAnother one listed by the C++ Standard:
p13846
as(dp13847
g15
V34509
p13848
stp13849
a((dp13850
g2
(lp13851
Vstatic_cast
p13852
aVis used for cases where you basically want to reverse an implicit conversion, with a few restrictions and additions
p13853
aVperforms no runtime checks
p13854
aVThis should be used if you know that you refer to an object of a specific type, and thus a check would be unnecessary
p13855
aVExample:
p13856
aVIn this example, you know that you passed a  object, and thus there isn't any need for a runtime check to ensure this
p13857
aVdynamic_cast
p13858
aVis used for cases where you don't know what the dynamic type of the object is
p13859
aVYou cannot use  if you downcast and the argument type is not polymorphic
p13860
aVAn example:
p13861
aVreturns a null pointer if the object referred to doesn't contain the type casted to as a base class (when you cast to a reference, a  exception is thrown in that case)
p13862
aVThe following code is not valid, because  is not polymorphic (it doesn't contain a virtual function):
p13863
aVAn "up-cast" is always valid with both  and , and also without any cast, as an "up-cast" is an implicit conversion
p13864
aVRegular Cast
p13865
aVThese casts are also called C-style cast
p13866
aVA C-style cast is basically identical to trying out a range of sequences of C++ casts, and taking the first C++ cast that works, without ever considering
p13867
aVNeedless to say, this is much more powerful as it combines all of ,  and , but it's also unsafe, because it does not use
p13868
aVIn addition, C-style casts not only allow you to do this, but they also allow you to safely cast to a private base-class, while the "equivalent"  sequence would give you a compile-time error for that
p13869
aVSome people prefer C-style casts because of their brevity
p13870
aVI use them for numeric casts only, and use the appropriate C++ casts when user defined types are involved, as they provide stricter checking
p13871
as(dp13872
g15
V34509
p13873
stp13874
a((dp13875
g2
(lp13876
VYou can simply value-initialize the base, and all its members will be zero'ed out
p13877
aVThis is guaranteed
p13878
aVFor this to work, there should be no user declared constructor in the base class, like in your example
p13879
aVNo nasty  for that
p13880
aVIt's not guaranteed that  works in your code, even though it should work in practice
p13881
as(dp13882
g15
V34509
p13883
stp13884
a((dp13885
g2
(lp13886
VI wrote an  that does this, together with a  macro using Boost
p13887
aVPreprocessor:
p13888
aVIt declares the enum as plain old enum, so you may still use it for "normal" purposes
p13889
aVThe iterator can be used for other normal enums too that have sequential values, that's why it has a second template parameter which defaults to
p13890
aVIt conforms to the bidirectional iterator requirements
p13891
aVThe silly code can be downloaded from here
p13892
as(dp13893
g15
V34509
p13894
stp13895
a((dp13896
g2
(lp13897
VI will use it to call operators implicitly (the return and parameter types below are just dummies for making up the code)
p13898
aVI do like the  syntax more
p13899
aVIt has a slightly different semantic, in that using  will not hide non-member operator functions with the same name as a member, though
p13900
as(dp13901
g15
V34509
p13902
stp13903
a((dp13904
g2
(lp13905
VI've just added an entry to my blog that shows how it can be done in a completely conforming way
p13906
aVHere is an example on how you use it for the following class
p13907
aVJust declare a tag name and instantiate a robber like the following example shows (my post shows the implementation of the robber)
p13908
aVYou can then access that member using a member pointer
p13909
aVBut actually, this doesn't show that c++'s access rules aren't reliable
p13910
aVThe language rules are designed to protect against accidental mistakes - if you try to rob data of an object, the language by-design does not take long ways to prevent you
p13911
aVThe above is a way to access private and protected members in a conforming way
p13912
aVThis one is another way to access protected members in a Standard conforming way
p13913
aVThe basic idea is to use a member pointer
p13914
aVNo casting or type punning involved
p13915
aVIt takes a pointer to a protected member of  through a class derived from it where that member name is public, so the compiler allows this
p13916
aVThen it uses it on a  object, which is allowed too
p13917
as(dp13918
g15
V34509
p13919
stp13920
a((dp13921
g2
(lp13922
VSimilar implemented to @ari's answer, i want to say there is already a boost solution,  solving your problem:
p13923
aV[I'm not sure what you want to do with that algorithm though, but note that i think you want to do  (bit-wise shift) instead of  which is not exponentiation in C++
p13924
aVBoost array is a normal array, just wrapped in a struct, so you lose no performance what-so-ever
p13925
aVIt will also be available in the next C++ version as , and is very easy to do yourself if you don't need the //-sugar it adds (to be a container)
p13926
aVJust go with the most basic one:
p13927
aVBut as usual, use the tools already written by other people, in this case
p13928
aVIt's also got the advantage of being an aggregate (that's why it has no user declared constructor), so it allows initializing with a brace enclosed list:
p13929
as(dp13930
g15
V34509
p13931
stp13932
a((dp13933
g2
(lp13934
VSome lawyer crap from me again
p13935
aVI've often fallen in this pitfall myself, so i'm going to warn you about it
p13936
aVin the  header has these overloads:
p13937
aVNow you can't just do
p13938
aVwith N being an int, because it doesn't know which of float, double or long double version it should take, and you would get an ambiguity error
p13939
aVAll three would need a conversion from int to floating point, and all three are equally costly
p13940
aVTherefor, be sure to have the first argument typed so it matches one of those three perfectly
p13941
aVI usually use
p13942
as(dp13943
g15
V34509
p13944
stp13945
a((dp13946
g2
(lp13947
VIt's not just
p13948
aVIt's  because it is within the namespace called
p13949
aVThat's why the compiler moans
p13950
aVIt doesn't know what  means
p13951
aVSay  instead
p13952
aVDo not add  now into the header because of this
p13953
aVIt may be OK for the assignment to put it into the
p13954
aVcpp file to save typing if you wish
p13955
aVBut it's a really bad idea to put such a line into a header: Because you don't know which files will need your header in future
p13956
aVThe situation can quickly get out of hand as the amount of files including your header grows with time
p13957
aVThe header should therefor include only the names and headers that it really needs so that it causes as little name conflicts as possible - whereas that  line would make all names of  visible directly
p13958
as(dp13959
g15
V34509
p13960
stp13961
a((dp13962
g2
(lp13963
VUse a while loop
p13964
as(dp13965
g15
V34509
p13966
stp13967
a((dp13968
g2
(lp13969
VThat's because enumerations are not objects - they are types
p13970
aVClass types (class,struct,union) and enumerations can be defined multiple times throughout the program, provided all definitions satisfy some restrictions (summed up by the so-called One Definition Rule (ODR))
p13971
aVThe two most important ones are
p13972
aVAll definitions have the same token sequence (textual identical)
p13973
aVNames used must have the same meaning (resolve to the same things) in all definitions
p13974
aV(this is a requirement on the context of the definition)
p13975
aVYour enumeration definition satisfies all conditions of the ODR
p13976
aVTherefor, that is valid and no reason for the linker / compiler to moan (actually, for a violation of the ODR the compiler is not required to issue a message either - most of it falls under the so-called no diagnostic required rule, some violations also result in undefined behavior)
p13977
aVHowever, for every non-inline function and object, these must be only defined one time
p13978
aVMultiply defining those result in spurious errors, like in your case
p13979
aVTo solve it, put only a declaration into the header file (using "extern" without an initializer) and put one definition into one of those
p13980
aVcpp files (omitting the "extern" then, or putting an initializer
p13981
aVIf it is a const object, you still need the "extern", since per default const variables have internal linkage, and the symbol would not be exported otherwise)
p13982
as(dp13983
g15
V34509
p13984
stp13985
a((dp13986
g2
(lp13987
VI decided to create a new answer because my old was so messy
p13988
aVAnyway just want to say something about C++1x, where you can get the underlying type of an enumeration using this one:
p13989
aVAnd for the sake of interest, the overload resolution idea
p13990
aVBut please use names to store the enumeration, as proposed by @lothar
p13991
aVThe overload resolution stems from the fact that there exist one promotion from an enumeration to the first of int, unsigned int, long, unsigned long that can represent all values of its underlying type
p13992
aVA conversion to any other integer type is lower ranked and overload resolution won't prefer it
p13993
aVAnd it prints this one here:
p13994
aVIt's not of particular interest to this serialization problem (since the size of the data serialized is not of constant width, and this can cause problems when the enumeration and its underlying type is changed), but it is generally interesting to figure out a type storing the whole of an enumeration
p13995
aVCheers
p13996
as(dp13997
g15
V34509
p13998
stp13999
a((dp14000
g2
(lp14001
VAs someone else said, it can't be done using templates (templates are computed at compile time
p14002
aVBut your character id is compute at runtime)
p14003
aVYou can use a map from id to constructor function
p14004
aVIt boils down to this question: Instantiate objects from a String holding their class name
p14005
aVI recommend you to keep it simple
p14006
aVIf a plain switch will do it, keep it that way
p14007
aVIf you later really need to have it extensible, you can still introduce some automatic look-up of character ids and so on
p14008
as(dp14009
g15
V34509
p14010
stp14011
a((dp14012
g2
(lp14013
VYes it is possible to use  for this, but it gets messy
p14014
aVPlease use @Dario's boost for-each way, but here is the  one for the sake of completeness
p14015
aVAnyway, as it happens, we don't even get a nice one-liner with this :)
p14016
as(dp14017
g15
V34509
p14018
stp14019
a((dp14020
g2
(lp14021
VLimiting the visibility of inheritance will make code not able to see that some class inherits another class: Implicit conversions from the derived to the base won't work, and  from the base to the derived won't work either
p14022
aVOnly members/friends of a class can see private inheritance, and only members/friends and derived classes can see protected inheritance
p14023
aVpublic inheritance
p14024
aVIS-A inheritance
p14025
aVA button is-a window, and anywhere where a window is needed, a button can be passed too
p14026
aVprotected inheritance
p14027
aVProtected implemented-in-terms-of
p14028
aVRarely useful
p14029
aVUsed in  to derive from empty classes and save memory using empty base class optimization (example below doesn't use template to keep being at the point):
p14030
aVprivate inheritance
p14031
aVImplemented-in-terms-of
p14032
aVThe usage of the base class is only for implementing the derived class
p14033
aVUseful with traits and if size matters (empty traits that only contain functions will make use of the empty base class optimization)
p14034
aVOften containment is the better solution, though
p14035
aVThe size for strings is critical, so it's an often seen usage here
p14036
aVpublic member
p14037
aVAggregate
p14038
aVAccessors
p14039
aVprotected member
p14040
aVProviding enhanced access for derived classes
p14041
aVprivate member
p14042
aVKeep implementation details
p14043
aVNote that C-style casts purposely allows casting a derived class to a protected or private base class in a defined and safe manner and to cast into the other direction too
p14044
aVThis should be avoided at all costs, because it can make code dependent on implementation details - but if necessary, you can make use of this technique
p14045
as(dp14046
g15
V34509
p14047
stp14048
a((dp14049
g2
(lp14050
VMy favorite and most loved cast is
p14051
aVIt only succeeds if the types can be implicitly converted
p14052
aVUseful for conversion from some type into  or from some derived class into a base (if you want to select a specific instance of an overloaded function or constructor) or to safely add const-qualifications and any other scenario where you really just need implicit conversions to happen and even  is too powerful
p14053
aVAlso read How does C++ pick which overload to call
p14054
aVYou can add this to your code collection too, if you want
p14055
as(dp14056
g15
V34509
p14057
stp14058
a((dp14059
g2
(lp14060
VHere is a version using boost preprocessor (This is just for fun
p14061
aVFor the real-world answer, see @kitchen's one above):
p14062
aVThe first part specifies a sequence of declarations:
p14063
aVThe variables declared later can refer to variables declared before them
p14064
aVThe second and third part are as usual
p14065
aVWhere commas occur in the second and third parts, parentheses can be used to prevent them to separate macro arguments
p14066
aVThere are two tricks known to me used to declare variables that are later visible in a compound statement added outside a macro
p14067
aVThe first uses conditions, like an if:
p14068
aVThen  is visible
p14069
aVNaturally, it always have to evaluate to
p14070
aVSo it can't be used by us
p14071
aVThe other context is this one:
p14072
aVThat's what i'm going to use here
p14073
aVWe'll have to watch to only make one iteration of
p14074
aVThe actual  loop that does the increment and condition checking has to come at the end, so the appended compound statement appertains to it
p14075
aVIt's creating a bunch of  statements, each nested into another one
p14076
aVIt expands into:
p14077
as(dp14078
g15
V34509
p14079
stp14080
a((dp14081
g2
(lp14082
VI'm copying over from a comment i made to answer this comment at another place
p14083
aVYou can down-cast with
p14084
aVNot so with
p14085
aVbasically allows you to do any implicit conversion, and in addition the reverse of any implicit conversion (up to some limits
p14086
aVyou can't downcast if there is a virtual base-class involved)
p14087
aVBut  will only accept implicit conversions
p14088
aVno down-cast, no , no  if T has only explicit constructors for U
p14089
aVNote that it's important to note the difference between a cast and a conversion
p14090
aVIn the following no cast is going on
p14091
aVBut an implicit conversion happens from double to int
p14092
aVThings like an "implicit cast" don't exist, since a cast is always an explicit conversion request
p14093
aVThe name construct for  is a lovely combination of "cast using implicit conversions"
p14094
aVNow the whole implementation of  is this (explained here):
p14095
aVThe idea is to use a non-deduced context for the parameter
p14096
aVThat will avoid pitfalls like the following:
p14097
aVWhat was desired is to write it out like this
p14098
aVThe compiler can't deduce what type the template parameter  should name, because it first must know what  is, since it is part of the parameter used for deduction
p14099
aVBut it in turn depends on the parameter  ( could be explicitly specialized for some types)
p14100
aVNow, we got a circular dependency, for which the Standard just says such a parameter is a non-deduced context, and an explicit template-argument must be provided
p14101
as(dp14102
g15
V34509
p14103
stp14104
a((dp14105
g2
(lp14106
VThe end of the GCC manpage contains an overview of its locale environment variables:
p14107
aVLANG
p14108
aVLC_CTYPE
p14109
aVLC_MESSAGES
p14110
aVLC_ALL
p14111
aVThese environment variables control the way that GCC uses localization information that allow GCC to work with different national conventions
p14112
aVGCC inspects the locale categories  and  if it has been configured to do so
p14113
aVThese locale categories can be set to any value supported by your installation
p14114
aVA typical value is en_GB
p14115
aVUTF-8 for English in the United Kingdom encoded in UTF-8
p14116
aVThe  environment variable specifies character classification
p14117
aVGCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that would otherwise be interpreted as a string end or escape
p14118
aVThe  environment variable specifies the language to use in diagnostic messages
p14119
aVIf the  environment variable is set, it overrides the value of LC_CTYPE and ; otherwise,  and  default to the value of the LANG environment variable
p14120
aVIf none of these variables are set, GCC defaults to traditional C English behavior
p14121
aVI do this:
p14122
as(dp14123
g15
V34509
p14124
stp14125
a((dp14126
g2
(lp14127
VThe name of local variables are only needed for the compiler to find the variables you want to refer to
p14128
aVAfter compiling, those names usually are erased and completely replaced by numeric symbols or equivalents
p14129
aVThis happens for all names that have no linkage practically (of course if you do a debug build, things may be different)
p14130
aVSo, the same is true for function parameters
p14131
aVThe name of global variables, for example, can't be erased, because you may use it from another unit in your program, and the linker has to be able to look it up
p14132
aVBut after your program has been linked, even the name of those can be erased
p14133
aVAnd after all, these do not occupy runtime memory
p14134
aVThose names are stored in a reallocation table for the purpose of linking (see the  program how to remove those names)
p14135
aVBut anyway, we are talking about a few bytes which are already wasted by alignment and whatnot
p14136
aVCompare that to the hell-long names of template instantiations
p14137
aVTry out this:
p14138
as(dp14139
g15
V34509
p14140
stp14141
a((dp14142
g2
(lp14143
VYour problem is that you don't add a null character after the data read
p14144
aVSo the  calls don't know where to stop
p14145
aVIn C, strings must be terminated by a null character (that's called the terminating null character)
p14146
aVWith that in place, i don't see what array should be cleared now, since  will read arguments until the first null pointer
p14147
aVThe  loop, however, adds that null pointer already, which is the null pointer returned by the last invocation of
p14148
aVThe problem would of course also be solved too by just clearing bBuffer (the data where  is pointing to after the first command was scanned)
p14149
aVNote that you have to do that also before scanning the first time, since you can't assume the chars in  array are initialized to any sensible values
p14150
aVPlace that just before the  invocation (but in any case, read only maximally , because the terminating null character must have space too
p14151
aVBut as I've shown above, you don't need this memset call
p14152
aVJust add the terminating null character manually
p14153
as(dp14154
g15
V34509
p14155
stp14156
a((dp14157
g2
(lp14158
VIt really depends what you mean by "array"
p14159
aVArrays in C++ will have a size (meaning the "raw" byte-size now) that equals to N times the size of one item
p14160
aVBy that one can easily get the number of items using the  operator
p14161
aVBut this requires that you still have access to the type of that array
p14162
aVOnce you pass it to functions, it will be converted to pointers, and then you are lost
p14163
aVNo size can be determined anymore
p14164
aVYou will have to construct some other way that relies on the value of the elements to calculate the size
p14165
aVHere are some examples:
p14166
aVIf we now lose the name "a" (and therefor its type), for example by passing "pa" to a function where that function only then has the value of that pointer, then we are out of luck
p14167
aVWe then cannot receive the size anymore
p14168
aVWe would need to pass the size along with the pointer to that function
p14169
aVThe same restrictions apply when we get an array by using
p14170
aVIt returns a pointer pointing to that array's elements, and thus the size will be lost
p14171
aVIt can't return a pointer that has the type of the array incorporated, because the size of the array created with  can be calculated at runtime
p14172
aVBut types in C++ must be set at compile-time
p14173
aVThus,  erases that array part, and returns a pointer to the elements instead
p14174
aVNote that you don't need to mess with  in C++
p14175
aVYou can use the  template, as recommended by another answer
p14176
as(dp14177
g15
V34509
p14178
stp14179
a((dp14180
g2
(lp14181
VA header (, ,
p14182
aVfile contains
p14183
aVClass definitions (  )
p14184
aVInline function definitions (  )
p14185
aVFunction declarations (  )
p14186
aVObject declarations (  )
p14187
aVA source file (, , ) contains
p14188
aVFunction definitions (  or  )
p14189
aVObject definitions (  )
p14190
aVHowever, the convention that headers are named with a  suffix and source files are named with a  suffix is not really required
p14191
aVOne can always tell a good compiler how to treat some file, irrespective of its file-name suffix (  for gcc
p14192
aVLike  )
p14193
aVSource files will contain definitions that must be present only once in the whole program
p14194
aVSo if you include a source file somewhere and then link the result of compilation of that file and then the one of the source file itself together, then of course you will get linker errors, because you have those definitions now appear twice: Once in the included source file, and then in the file that included it
p14195
aVThat's why you had problems with including the  file
p14196
as(dp14197
g15
V34509
p14198
stp14199
a((dp14200
g2
(lp14201
VI don't know whether it counts as "excessive copying", but you can use a stringstream:
p14202
aVLike, to read everything from stdin into a string, do
p14203
aVAlternatively, you may also use a
p14204
aVYou will have to measure whether this or the above way is faster - i don't know
p14205
aVNote that  above is meant to represent a , so take its address as appropriate
p14206
aVAlso note the additional parentheses around the first argument in the last example, so that it doesn't interpret it as a function declaration returning a string and taking an iterator and another function pointer ("most vexing parse")
p14207
as(dp14208
g15
V34509
p14209
stp14210
a((dp14211
g2
(lp14212
VUsing , you can have such a thing:
p14213
aVWill construct 100 lazy's and assign one real  to
p14214
aVwill use no heap memory, but use placement-new to create objects in a stack-allocated buffer
p14215
aVI would create a wrapper around  like this:
p14216
aVThis now uses  for doing stuffs
p14217
aVIt ought to support in-place construction like this one (example on ):
p14218
aVWhich would not require any copy-ing
p14219
aVHowever, the current boost-manual does not include that assignment operator overload
p14220
aVThe source does, however
p14221
aVI'm not sure whether this is just a defect in the manual or whether its documentation is intentionally left out
p14222
aVSo i would use the safer way using a copy assignment using
p14223
as(dp14224
g15
V34509
p14225
stp14226
a((dp14227
g2
(lp14228
VTry using the following flags instead
p14229
aVIt says given the , it won't pad
p14230
aVIt has problems with the base, interpreting it as an octal integer
p14231
aVAnyway, if you want to do something every 15 seconds, i find this one easier to follow:
p14232
as(dp14233
g15
V34509
p14234
stp14235
a((dp14236
g2
(lp14237
VBasically, what you want to do is impossible in current C++
p14238
aVFor any number of arity of function you want to wrap, you need to overload by
p14239
aVBut then it's still not perfectly forwarding (some edge cases still stand), but it should work reasonable well
p14240
aVIf you limit yourself to const references, you can go with this one (not tested):
p14241
aVNote that for the return type, you can use boost's function types library
p14242
aVThen
p14243
aVYou can also overload using pure value parameters, and then if you want to pass something by reference, use
p14244
aVThat's actually a pretty common technique, especially when such parameters are going to be saved (this technique is also used for ):
p14245
aVOr you can go and add those overloads for both const and non-const versions as explained above
p14246
aVLook into Boost
p14247
aVPreprocessor for how to write the proper macros
p14248
aVYou should be aware that the whole thing will become more difficult if you want to be able to pass arbitrary callables (not only functions), since you will need a way then to get their result type (that's not all that easy)
p14249
aVC++1x will make this sort of stuff way easier
p14250
as(dp14251
g15
V34509
p14252
stp14253
a((dp14254
g2
(lp14255
VThe difference is that the term "template class" does simply not exist in the C++ Standard
p14256
aVIt's a term used mostly by people that think that the term "class template" is confusing (like the Qt companies Nokia and formerly Trolltech)
p14257
aVThe Standard has no concept of it, so it's up to other peoples to make a difference
p14258
aVSome people use it synonymously, and others say that the term "template class" refers to an instantiated or explicitly specialized class template, which would make it equivalent to the term "class template specialization"
p14259
aVHistoryically, it had this meaning
p14260
aVThe Annotated Reference Manual defines at page 343
p14261
aVA class generated from a class template is called a template class, as is a class specifically defined with a template-class-name as its name
p14262
aVThe non-terminal template-class-name is equivalent to the non-terminal template-id used in todays Standard and comes down
p14263
aVTo get you familiar with the today terms, which is more important than using dubious old terms
p14264
aVThe ARM called the class (2), and the classes generated by (4) and (5) a template class
p14265
aVI'm not sure whether the ARM already knew about partial specializations
p14266
aVBut if so (3) was not called a template class, because (3) does not define a class, but defines a template
p14267
aVThe current Standard calls class (2), and the ones generated by (4) and (5) class template specializations
p14268
aVAnd (3) is called a partial specialization, as opposed to an explicit specialization
p14269
aVIt also sometimes calls (3) a specialization (3
p14270
aV2/5 - however with clarifying cross-links), although i find this isn't entirely clear to me, since it defines a "specialization" as being a "class, function or class member", which (3) doesn't satisfy
p14271
as(dp14272
g15
V34509
p14273
stp14274
a((dp14275
g2
(lp14276
VThe difference lies in the C++ grammar
p14277
aVA simple-declaration is formed like this:
p14278
aVWhere declaration-specifier-seq is a sequence of declaration specifiers:
p14279
aVYou get the idea
p14280
aVAnd init-declarator-list is a list of declarators with an optional initializer for each:
p14281
aVSo a full simple-declaration could look like this, containing 3 declarators:
p14282
aVClass members have special rules to account for the different context in which they appear, but they are very similar
p14283
aVNow, you can do
p14284
aVSince the first uses the typedef specifier and then simple-type-specifier and then a declarator like "a[N]"
p14285
aVThe second declaration then uses the typedef-name "A" (simple-type-specifier) and then a declarator like "*a"
p14286
aVHowever, you of course cannot do
p14287
aVSince "int[3]" is not a valid declaration-specifier-seq as shown above
p14288
aVAnd now, of course, a template is not just like a macro text substitution
p14289
aVA template type parameter of course is treated like any other type-name which is interpreted as just the type it names and can appear where a simple-type-specifier can appear
p14290
aVSome C# folks tend to say C++ templates are "just like macros", but of course they are not :)
p14291
as(dp14292
g15
V34509
p14293
stp14294
a((dp14295
g2
(lp14296
VSome solution with AWK:
p14297
aVNext one is total count, number of files, and number of matches for each, displaying the first match of each one (to display all matches, change the condition to ):
p14298
aVOutput for the first solution (searching within a directory for ""
p14299
aVI manually cut some too long lines so they fit horizontally):
p14300
aVOutput for the second one
p14301
aVColors in the result are nice ( for grep), but they break when piped through awk here
p14302
aVSo better don't enable them then unless you want to have all your terminal colored afterwards :) Cheers
p14303
as(dp14304
g15
V34509
p14305
stp14306
a((dp14307
g2
(lp14308
VIt has no meaning
p14309
aVThat's an error
p14310
aVIt's parsed as this
p14311
aVThus, trying to assign to an rvalue
p14312
aVIn this case, the right side is a cast of  to  (it's an int already, anyway)
p14313
aVThe result of a cast to something not a reference is always an rvalue
p14314
aVAnd you try to assign  to that
p14315
aVWhat Rvalues miss is an object identity
p14316
aVThe following would work:
p14317
aVOf course, you could equally well write it as the following
p14318
aVUpdate: Question was badly formatted
p14319
aVThe actual code was this
p14320
aVWell, now it is an lvalue
p14321
aVBut a fundamental invariant is broken
p14322
aVThe Standard says
p14323
aVAn lvalue refers to an object or function
p14324
aVThe lvalue you assign to is neither an object nor a function
p14325
aVThe Standard even explicitly says that dereferencing a null-pointer ( creates such a null pointer) is undefined behavior
p14326
aVA program usually will crash on an attempt to write to such a dereferenced "object"
p14327
aV"Usually", because the act of dereferencing is already declared undefined by C++
p14328
aVAlso, note that the above is not the same as the below:
p14329
aVWhile the above writes to something where certainly no object is located, this one will write to something that results from reinterpreting n to a pointer
p14330
aVThe mapping to the pointer value is implementation defined, but most compilers will just create a pointer referring to address zero here
p14331
aVSome systems may keep data on that location, so this one may have more chances to stay alive - depending on your system
p14332
aVThis one is not undefined behavior necessarily, but depends on the compiler and runtime-environment it is invoked in
p14333
aVIf you understand the difference between the above dereference of a null pointer (only constant expressions valued 0 converted to pointers yield null pointers
p14334
aVand the below dereference of a reinterpreted zero value integer, i think you have learned something important
p14335
as(dp14336
g15
V34509
p14337
stp14338
a((dp14339
g2
(lp14340
VDo you rely on the value of it
p14341
aVA string literal is not required to have the same address in different uses of it (especially when used in different translation units)
p14342
aVSo you may actually create two values by this:
p14343
aVAlso you get no kind of any sorting, since what happens is that it sorts by address
p14344
aVUse  which does not have that problem as it's aware of the content and whose  compares lexicographical:
p14345
as(dp14346
g15
V34509
p14347
stp14348
a((dp14349
g2
(lp14350
VI get that error when the first parameter doesn't make sense to it
p14351
aVCheck that  is known as type:
p14352
aVTo find out whether something is a object or function declaration, the compiler sometimes has to scan the whole declaration
p14353
aVAny construct within the declaration that could possibly form a declaration is taken to be a declaration
p14354
aVIf not, then any such construct is taken to be an expression
p14355
aVGCC apparently thinks because  is no valid type, it can't be a valid parameter declaration, and thus falls back treating the whole declaration as a field (note that it says in addition  )
p14356
aVSame thing in local scope
p14357
as(dp14358
g15
V34509
p14359
stp14360
a((dp14361
g2
(lp14362
VThe -object will be cleaned up as soon as  is deleted at the end of its block
p14363
aVBut the shared_ptr it contains was subsequently copied, incrementing its reference count
p14364
aVThus, the -object will have a reference count of 2 after  (referenced by the -object and by the -object's )
p14365
aVWhen  is deleted at the end of its block, then the reference count of the -object drops to  again since only 's shared_ptr is referencing it now
p14366
aVAfter  is destroyed at the end of main, its  will be destroyed too as part of 's destruction, and now as the reference count drops to zero, the pointed-to  object will be deleted by
p14367
aVSo, the reference counts of the -object:
p14368
as(dp14369
g15
V34509
p14370
stp14371
a((dp14372
g2
(lp14373
V is not yet known at that point
p14374
aVYou need to tell it it's in the  class:
p14375
aVNotice the  is required, since  is a type prefixed with a template specialization, and you need to tell the compiler about that - in spite of the fact that Visual C++ probably will accept code not putting  before it
p14376
aVOmitting the , the compiler should assume it's not a type and should sort of produce the same error message
p14377
aVYou could safe yourself that hassle by putting the code straight into the class:
p14378
as(dp14379
g15
V34509
p14380
stp14381
a((dp14382
g2
(lp14383
VYou want to convert the number to a :
p14384
aVOr :
p14385
as(dp14386
g15
V34509
p14387
stp14388
a((dp14389
g2
(lp14390
VWhat happens is called slicing
p14391
aVYou initialize an object of type  with an object of type
p14392
aVSince any object of type  has also an object of type  contained (called "base-class sub-object"), there will be two  objects and one  object in existance throughout the program
p14393
aVThe Derived object (and its base-class sub-object of type ) only exists for the time of initialization, while the remaining  object exists until end of
p14394
aVSince there are two Base objects and one Derived object, you will also see one more Base destructors run
p14395
as(dp14396
g15
V34509
p14397
stp14398
a((dp14399
g2
(lp14400
VThe class  (base class of ) has a function  that simulates a command event
p14401
aVTry this one
p14402
aVI'm not sure about the python syntax (programming in the C++ version of wxWidgets normally)
p14403
aVBut that's the rough plan
p14404
as(dp14405
g15
V34509
p14406
stp14407
a((dp14408
g2
(lp14409
VAnswered in this answer
p14410
aVThis is a SymLink to that answer
p14411
aVPlease vote there, if anywhere :)
p14412
as(dp14413
g15
V34509
p14414
stp14415
a((dp14416
g2
(lp14417
VHere is my attempt at it
p14418
aVSadly it relies on variadic macros which is a C99/C++1x feature
p14419
aVBut works in GCC
p14420
aVNote that you can also iterate with a reference variable, to avoid useless copying
p14421
aVHere is one using  and the  syntax, compiling down to the same code after pre-processing stage
p14422
aVThe trick is to assemble a function type that has as parameter the enumeration variable, and getting the type of that parameter
p14423
aVThen  will remove any reference
p14424
aVFirst version used
p14425
aVBut it would also convert arrays into pointers, which i found is not what is wanted sometimes
p14426
aVThe resulting type is then used as the array element type
p14427
aVFor use in templates where the enumerator variable has a dependent type, you will have to use another macro which puts  before  and
p14428
aVCould name it  (D == dependent)
p14429
as(dp14430
g15
V34509
p14431
stp14432
a((dp14433
g2
(lp14434
VThere are two things not clear in the question to me
p14435
aVDo you want to set the pointer to a specific value (i
p14436
aVe address), or do you want to make the pointer point to some specific variable
p14437
aVIn the latter case, you can just use the address-of operator
p14438
aVThe value of the pointer is then set to the address of
p14439
aVNote: What follows is evil changing of the pointer's value manually
p14440
aVIf you don't know whether you want to do that, you don't want to do it
p14441
aVIn the former case (i
p14442
aVe setting to some specific, given address), you can't just do
p14443
aVSince the compiler won't take the int and interpret it as an address
p14444
aVYou will have to tell the compiler it should do that explicitly:
p14445
aVNow, the pointer will reference some integer (hopefully) at address 1000
p14446
aVNote that the result is implementation defined
p14447
aVBut nevertheless, that are the semantics and that is the way you tell the compiler about it
p14448
aVUpdate: The committee fixed the weird behavior of  that was suggested by a note and for which i provided a workaround before
p14449
aVSee here
p14450
as(dp14451
g15
V34509
p14452
stp14453
a((dp14454
g2
(lp14455
VDirect assignment is not possible
p14456
aVAs others explained, the equivalence is not established by the pointer types, but by the container types
p14457
aVIn this case, vector doesn't want to accept another vector that has a different, but compatible element type
p14458
aVNo real problem, since you can use the  member function:
p14459
as(dp14460
g15
V34509
p14461
stp14462
a((dp14463
g2
(lp14464
VThe usual  issue:
p14465
aVRemember: As a general rule, all qualified names that depend on a template parameter need  before them
p14466
as(dp14467
g15
V34509
p14468
stp14469
a((dp14470
g2
(lp14471
VRead about  here
p14472
aVThe following is copied from that article, explaining the relation between shared memory and  in particular
p14473
aVSo, when you actually use POSIX shared memory (which i used before, too), then  will create a file at , which is used to share data between the applications
p14474
aVThe file-descriptor it returns will refer to that file, which you can pass to  to tell it to map that file into memory, like it can do with any "real" file either
p14475
aVThe techniques you listed are thus complementary
p14476
aVThey are not competing
p14477
aVis just the file-system that provides in-memory files as an implementation technique for
p14478
aVAs an example, there is a process running on my box currently having registered such a shared memory object:
p14479
as(dp14480
g15
V34509
p14481
stp14482
a((dp14483
g2
(lp14484
VYou are probably hitting the shell builtin
p14485
aVTry using the real program
p14486
aVFor a help section of the builtin echo, try
p14487
aVAnd for its manpage, try
p14488
aVIf you are using the bash as your shell
p14489
as(dp14490
g15
V34509
p14491
stp14492
a((dp14493
g2
(lp14494
VIt does
p14495
aVFor a type ,  value-initializes an "object" of type  and yields an rvalue expression
p14496
aVSame for pod-classes:
p14497
aVAlso true for some non-POD classes that have no user declared constructor:
p14498
aVSince you cannot do  (creates a function declaration instead), boost has a class , allowing to work around that, and C++1x will have the following, alternative, syntax
p14499
aVIn the dry words of the Standard, this sounds like
p14500
aVThe expression T(), where T is a simple-type-specifier (7
p14501
ag2790
ag1014
aV2) for a non-array complete object type or the (possibly cv-qualified) void type, creates an rvalue of the specified type, which is value-initialized
p14502
aVSince a typedef-name is a type-name, which is a simple-type-specifier itself, this works just fine
p14503
as(dp14504
g15
V34509
p14505
stp14506
a((dp14507
g2
(lp14508
V doesn't have  because the position of an element is determined by the comparator of the set
p14509
aVUse  and pass it :
p14510
aVThe insert iterator will then call  where  is the value passed to the iterator when written to it
p14511
aVThe set uses the iterator as a hint where to insert
p14512
aVYou could as-well use
p14513
as(dp14514
g15
V34509
p14515
stp14516
a((dp14517
g2
(lp14518
VIndeed, there is this one definition rule saying that an inline function must be defined in every translation unit it is used
p14519
aVGory details follow
p14520
aVFirst :
p14521
aVEvery program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required
p14522
aVThe definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12
p14523
aV1, 12
p14524
aV4 and 12
p14525
aV8)
p14526
aVAn inline function shall be defined in every translation unit in which it is used
p14527
aVAnd of course :
p14528
aVAn inline function shall be defined in every translation unit in which it is used and shall have exactly the same definition in every case (3
p14529
aV2)
p14530
aV[Note: a call to the inline function may be encountered before its definition appears in the translation unit
p14531
aV] If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required
p14532
aVAn inline function with external linkage shall have the same address in all translation units
p14533
aVA static local variable in an extern inline function always refers to the same object
p14534
aVA string literal in an extern inline function is the same object in different translation units
p14535
aVHowever, if you define your function within the class definition, it is implicitly declared as  function
p14536
aVThat will allow you to include the class definition containing that inline function body multiple times in your program
p14537
aVSince the function has  linkage, any definition of it will refer to the same function (or more gory - to the same )
p14538
aVGory details about my claim
p14539
aVFirst :
p14540
aVIn addition, a member function, static data member, class or enumeration of class scope has external linkage if the name of the class has external linkage
p14541
aVThen :
p14542
aVA name having namespace scope has external linkage if it is the name of [
p14543
aVa named class (clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes
p14544
aVThis "name for linkage purposes" is this fun thing:
p14545
aVSince now you have multiple definitions of the same entity in your programs, another thing of the ODR happens to restrict you
p14546
aVfollows with boring stuff
p14547
aVThere can be more than one definition of a class type (clause 9), enumeration type (7
p14548
aV2), inline function with external linkage (7
p14549
ag2790
aV2) [
p14550
aVin a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements
p14551
aVGiven such an entity named D defined in more than one translation unit, then
p14552
aVeach definition of D shall consist of the same sequence of tokens; and
p14553
aVin each definition of D, corresponding names, looked up according to 3
p14554
aV4, shall refer to an entity defined within the definition of D, or shall refer to the same entity, after overload resolution (13
p14555
aV3) and after matching of partial template specialization (14
p14556
aV8
p14557
aV3) [
p14558
aVI cut off some unimportant stuff now
p14559
aVThe above are the two important one to remember about inline functions
p14560
aVIf you define an extern inline function multiple times, but do define it differently, or if you define it and names used within it resolve to different entities, then you are doing undefined behavior
p14561
aVThe rule that the function has to be defined in every TU in which it is used is easy to remember
p14562
aVAnd that it is the same is also easy to remember
p14563
aVBut what about that name resolution thingy
p14564
aVHere some example
p14565
aVConsider a static function :
p14566
aVNow, since  will give it internal linkage, when you include it into multiple translation units, then each definition will define a different entity
p14567
aVThis means that you are not allowed to use  from an extern inline function that's going to be defined multiple times in the program: Because what happens is that the inline function will refer to one entity called  in one TU, but to another entity of the same name in another TU
p14568
aVYou will find that this all is boring theory and compilers won't probably complain, but i found this example in particular shows the relation between the ODR and entities
p14569
aVWhat follows is getting back to your particular problem again
p14570
aVFollowing are the same things:
p14571
aVBut this one is different, since the function is non-inline
p14572
aVYou will violate the ODR, since you have more than one definition of  if you include the header more than once
p14573
aVNow if you put  on the declaration of  inside the class, but then omit defining it in the header, then you violate  (and  which says the same thing, just more elaborating), since the function isn't defined in that translation unit
p14574
aVNote that in C (C99), inline has different semantics than in C++
p14575
aVIf you create an extern inline function, you should first read some good paper (preferably the Standard), since those are really tricky in C (basically, any used inline-definition of a function will need another, non-inline function definition in another TU
p14576
aVstatic inline functions in C are easy to handle
p14577
aVThey behave like any other function, apart of having the usual "inline substitution" hint
p14578
aVstatic  in both C and C++ serve only as a inline-substitution hint
p14579
aVSince static will already create a different entity any time it's used (because of internal linkage),  will just add the inline-substitution hint - not more
p14580
as(dp14581
g15
V34509
p14582
stp14583
a((dp14584
g2
(lp14585
VUnless i misunderstand you, what you want is impossible
p14586
aVIn your example you show an invalid use of a pointer template parameter
p14587
aVThat's not valid, since  must be a constant expression for it to be able to initialize
p14588
aVSure  within class  would be fine as a constant expression when used as  instead
p14589
aVBut this time, it's not since it involves a pointer (references are equally invalid in constant expressions)
p14590
aVTo sum up, you can't do this:
p14591
aVAnd expect  to be T if T isn't int, and  otherwise, since  can only be an enumeration, integer, pointer or reference type
p14592
aVAnd in the latter two cases, you won't get at the "value" of anything pointed to by the pointer or referred to by the reference at compile time
p14593
aVIf you are satisfied with that, it's easy to solve your problem and i'm not going to show you how (i suspect you already know how)
p14594
aVI think you have driven yourself into a situation where solving your problem has become impossible to do with the rules as given
p14595
aVDrive back some steps and show us the real problem you are trying to solve, when the matter still allows to solve things
p14596
as(dp14597
g15
V34509
p14598
stp14599
a((dp14600
g2
(lp14601
VClearly,  is the way to go
p14602
aVIt already stores a type-tag that makes it impossible for you to cast to the wrong type, ensuring this using the help of the compiler
p14603
aVHere is how it works
p14604
as(dp14605
g15
V34509
p14606
stp14607
a((dp14608
g2
(lp14609
VNote that this loop that you use is not necessary
p14610
aVUse reverse iterators
p14611
aVNow its more obvious what it does
p14612
aVIf writing to idxRho only when something was found was a mistake or doesn't matter, you can shorten it to this
p14613
as(dp14614
g15
V34509
p14615
stp14616
a((dp14617
g2
(lp14618
VFor ,  is equal to , which is equal to the
p14619
aVFor other containers, it's some implementation defined unsigned integer type
p14620
aVSometimes it's useful to have the exact type, so for example one knows where the type wraps around to (like, to ) so that one can make use of that
p14621
aVOr for templates, where you really need to pass two identical types to function/class templates
p14622
aVOften i find i use  for brevity or iterators anyway
p14623
aVIn generic code, since you generally don't know with what container instance your template is used and what size those containers have, you will have to use the  typedef if you need to store the containers size
p14624
as(dp14625
g15
V34509
p14626
stp14627
a((dp14628
g2
(lp14629
VYou can set the internal field separator (IFS) variable, and then let it parse into an array
p14630
aVWhen this happens in a command, then the assignment to  only takes place to that single command's environment (to  )
p14631
aVIt then parses the input according to the  variable value into an array, which we can then iterate over
p14632
aVIt will parse one line of items separated by , pushing it into an array
p14633
aVStuff for processing whole of , each time one line of input separated by :
p14634
as(dp14635
g15
V34509
p14636
stp14637
a((dp14638
g2
(lp14639
VIf you change the initialization of  to this here:
p14640
aVThen your program should behave correct
p14641
aVThe reason for this is that variables that
p14642
aVHave POD type
p14643
aVAre initialized with constant expressions (1)
p14644
aVare initialized at static initialization time
p14645
aVThese initializations include
p14646
aVZero initialization of all objects having static storage duration
p14647
aVInitializations of PODs initialized with constant expressions
p14648
aVOf your shown variables, only  satisfies both conditions of being fully initialized at static initialization time
p14649
aVHowever,  does not, since its initializer does not satisfy the requirements of a constant expression
p14650
aVIn particular, it includes a variable that doesn't have integral type (here, it has floating point type)
p14651
aVHowever, floating point literals *are* allowed in arithmetic constant expressions
p14652
aVThat is why  is an arithmetic constant expression
p14653
aVAnd that is why changing the initializer to that will require it to be statically initialized
p14654
aVWhat will happen with  if you stay with the non-constant expression
p14655
aVThe answer is, you don't know
p14656
aVThe Standard allows that variable to be statically initialized, but does not require it to do so
p14657
aVIn your case, it was dynamically initialized - thus its value just after static initialization time was still zero
p14658
aVTo get a feeling for how complicated that is, here is an example:
p14659
aVIf the dynamic initialization doesn't change any other static storage variable (satisfied in your code) and when the static initialization would produce the same value as would be produced by dynamic initialization when all objects not required to be statically initialized would be initialized dynamically (also satisfied in your code) - then the variable is allowed to be initialized statically
p14660
aVThese two conditions are also satisfied in the above code for both variables  and :
p14661
aVAnalysis of
p14662
aVdoes not change any other static storage variable
p14663
aVWhen both  and  are initialized dynamically, then  would be initialized to , because  is defined before , and dynamic initialization of  would grab the value of  as of the state just after static initialization (where only zero initialization of  took place)
p14664
aVAnalysis of
p14665
aVdoes not change any other static storage variable
p14666
aVWhen both  and  are initialized dynamically, then  will initialize  to
p14667
aVSo, the compiler may initialize  statically to , because both conditions for optional-static-initialization are met
p14668
aVIf the compiler decides to initialize  and  dynamically, then  will be initialized to , since it will grab the value of  as it was just after zero initialization
p14669
aVHowever, if the compiler decides to initialize  statically and  dynamically, then  will be initialized to , since the dynamic initialization of  will grab the fully initialized value of  as it was just after static initialization
p14670
aVI'm not sure what the value of  is when  and  is initialized statically, though
p14671
aVThat is, whether  is supposed to grab the  or the , since there is no order defined for static initialization
p14672
aV(1) Constant expressions include arithmetic constant expressions too (not only integral constant expressions), when considering initialization order of objects with static storage duration
p14673
as(dp14674
g15
V34509
p14675
stp14676
a((dp14677
g2
(lp14678
V sources the file called  into the current shell
p14679
aVSo if a file contains this
p14680
aVThen if you sources that, afterwards you can refer to a variable called  which will contain hello
p14681
aVBut if you execute the file (given proper execution rights and line), then such things won't work, since the variable and other things that script sets will only affects its subshell it is run in
p14682
aVSourcing a binary file will not make any sense: Shell wouldn't know how to interpret the binary stuff (remember it inserts the things appearing in that file into the current shell - much like the good old  mechanism in C)
p14683
aVExample:
p14684
aVExecuting a binary file, however, does make a lot of sense, of course
p14685
aVSo normally you want to just name the file you want to execute, and in special cases, like the  case above, you want to source a file
p14686
as(dp14687
g15
V34509
p14688
stp14689
a((dp14690
g2
(lp14691
VI don't think that in this case, the rule "if it could be a declaration, it's taken to be a declaration" applies
p14692
aVSince in the following, both things are declarations
p14693
aVThe one is the declaration of an object, and the other is the declaration of a function
p14694
aVThe rule applies in other cases
p14695
aVFor example, in this case:
p14696
aVIn that case,  can mean two things
p14697
aVDeclaration of an unnamed function parameter
p14698
aVExpression creating a default constructed
p14699
aVThe fule applies here, and  is taken to mean the same as the following, named parameter (names are irrelevant in parameters when declaring a function)
p14700
aVIf a function takes as parameter an array or another function, that parameter decays into a pointer
p14701
aVIn case of a function parameter, to a pointer to the function
p14702
aVThus, it is equivalent to the following, which may look more familiar
p14703
aVBut in your case, it's rather the syntax that's getting into the way
p14704
aVIt's saying that the following is a function declaration
p14705
aVIt can never be the declaration of an object (even though that was probably intended by the programmer
p14706
aVSo there is no ambiguity in this context in the first place, and thus it declares a function
p14707
aVSince  has a user defined constructor, you can just omit the parentheses, and the effect remains the same as what was intended
p14708
as(dp14709
g15
V34509
p14710
stp14711
a((dp14712
g2
(lp14713
VThe declaration looks right
p14714
aVBut the error message suggests that  is not known as a type
p14715
aVTry including the  header and say  instead
p14716
aVAnother thing you should consider is making the parameter 'hand' a const reference
p14717
aVSo you could also accept temporaries and print them out
p14718
as(dp14719
g15
V34509
p14720
stp14721
a((dp14722
g2
(lp14723
VYou may want to fixate the array within the class definition already, but you don't have to
p14724
aVThe array will have a complete type at the point of definition (which is to keep within the
p14725
aVcpp file, not in the header) where it can deduce the size from the initializer
p14726
as(dp14727
g15
V34509
p14728
stp14729
a((dp14730
g2
(lp14731
VAs to why your declaration of
p14732
aVis better than this one
p14733
aVIt's generally good if you keep declarations as local as possible, so that as few name clashes as possible result
p14734
aVI say it's arguable whether declaring a function locally (this way) is really fortunate, as i think it's still better to ordinary include its header and then go the "usual" way, which is also less confusing to people not knowing about that
p14735
aVSometimes, it's also useful to work around a shadowed function
p14736
aVOf course, in C++ we could call function  using  - but in the old days of C, that wouldn't have been possible, and that thing allowed the programmer to still access the function
p14737
aVAlso note that while syntactically it is not the same, semantically the following does also declare a function within a local scope, that actually targets a different scope
p14738
aVAs a side note, there are more situations like that where the target scope of a declaration is not the scope where that declaration appears in
p14739
aVIn general, the entity you declare becomes a member of the scope in which the declaration appears
p14740
aVBut that's not always the case
p14741
aVConsider for example friend declarations, where that thing happens
p14742
aVEven though the function declaration (and definition
p14743
aVof  happened within the scope of , the entity (the function itself) became a member of the enclosing namespace
p14744
as(dp14745
g15
V34509
p14746
stp14747
a((dp14748
g2
(lp14749
VImagine X and Y are your points on a flat surface
p14750
aVThen  is  and  is
p14751
aVThe length of  is their distance, and is the length of the hypotenuse of that triangle
p14752
aVIt is calculated using
p14753
aVSince you see we are squaring  and , the sign of them isn't relevant - it will come down to the same
p14754
aVSo this method always works, where ever the points lie
p14755
aVLookup the
p14756
as(dp14757
g15
V34509
p14758
stp14759
a((dp14760
g2
(lp14761
VIf what you want is to differentiate between a compile time constant and a non-compile time constant - then you have no chance
p14762
aVThat's not possible
p14763
aVBut if you want to differentiate between a non-constant variable and between a constant variable (and everything else included - like literals), then you can overload a function with a const-reference and non-const reference parameter
p14764
aVFor this scenario, the C++ Standard introduces extra rules that make this otherwise ambiguous case not ambiguous
p14765
aVIn this matter, the following decisions are done
p14766
aVNote how it can't differentiate between y and z, even though value of z is a compile time constant (termed integral constant expression, or ICE), while y is not
p14767
aVWhat you can do is to only accept compile time values then
p14768
aVOverload the function so that one is a template and the other isn't
p14769
aVIt behaves like this then:
p14770
as(dp14771
g15
V34509
p14772
stp14773
a((dp14774
g2
(lp14775
VFor operators, associativity means that when the same operator appears in a row, then to which direction the evaluation binds to
p14776
aVIn the following, let  be the operator
p14777
aVIf  is left associative, then it evaluates as
p14778
aVAnd if it is right associative, then it evaluates as
p14779
aVIt's important, since it changes the meaning of an expression
p14780
aVConsider the division operator with integer arithmetic, which is left associative
p14781
aVIf it were right associative, it would evaluate to an undefined expression, since you would divide by zero
p14782
as(dp14783
g15
V34509
p14784
stp14785
a((dp14786
g2
(lp14787
VYou could scan the string, replacing  by the appropriate directory
p14788
aVThe POSIX function  does that, and a few other things
p14789
aVvariable substitution, like you can use
p14790
aVoptional command substitution, like  (can be disabled)
p14791
aVarithmetic expansion, like
p14792
aVword splitting, like splitting  into two words
p14793
aVwildcard expansion, like
p14794
aVand quoting, like  remains that
p14795
as(dp14796
g15
V34509
p14797
stp14798
a((dp14799
g2
(lp14800
VI would use a function object
p14801
as(dp14802
g15
V34509
p14803
stp14804
a((dp14805
g2
(lp14806
VI've looked it up, and found that it is specified by 14
p14807
ag1014
aV2/2:
p14808
aVA local class shall not have member templates
p14809
aVAccess control rules (clause 11) apply to member template names
p14810
aVA destructor shall not be a member template
p14811
aVA normal (non-template) member function with a given name and type and a member function template of the same name, which could be used to generate a specialization of the same type, can both be declared in a class
p14812
aVWhen both exist, a use of that name and type refers to the non-template member unless an explicit template argument list is supplied
p14813
aVAnd it provides an example:
p14814
aVNote that in Standard terms,  refers to the function you write using an explicit specialization and to the function generated using instantiation, in which case we have to do with a generated specialization
p14815
aVdoes not only refer to functions you create using explicitly specializing a template, for which it is often only used
p14816
aVConclusion: GCC gets it wrong
p14817
aVComeau, with which i also tested the code, gets it right and issues a diagnostic:
p14818
aV, line 16: error:  is not an entity that
p14819
aVcan be explicitly specialized
p14820
aVNote that it isn't complaining about the specialization of the template for  (only for ), since it doesn't refer to the same name and type: The function type that specialization would have is , which is distinct from the function type of the non-template member function, which is
p14821
as(dp14822
g15
V34509
p14823
stp14824
a((dp14825
g2
(lp14826
VIt depends on the compiler and on its optimizations performed
p14827
aVIf it performs dead store elimination, then it may well omit emitting assembler code writing to a variable
p14828
aVConsider
p14829
aVCould easily optimized to this one, since the writings to  will be overwritten by the later assignment anyway
p14830
aVAnd if the assignment of 1 to i wasn't happening and the loop would run  times, the compiler could optimize it to
p14831
aVIncluding optimizing increment of  entirely (and in the previous example too) if  is local and would not change any global state
p14832
aVIf  has a volatile qualified type, then the compiler is required to omit these optimizations
p14833
aVIt has to do every step as the language specification describes
p14834
aVBut even then, different compilers could generate different assembler/instructions depending on the capabilities of the processor targeted
p14835
as(dp14836
g15
V34509
p14837
stp14838
a((dp14839
g2
(lp14840
VIt looks to me that  (link to some old SUS specification) is intended to be the vendor-neutral interface to the system's compiler
p14841
aVIt's marked as legacy:
p14842
aVThe c89 utility provides an interface to the ISO C standard, but the cc utility accepts an unspecified dialect of the C language: it may be Standard C, common-usage C or some other variant
p14843
aVPortable C programs should be written to conform to the ISO C standard and compiled with c89
p14844
aVPOSIX has a utility called  which I believe is the successor of
p14845
aVIt says
p14846
aVThe c99 utility is based on the c89 utility originally introduced in the ISO POSIX-2:1993 standard
p14847
aVSome of the changes from c89 include the modification to the contents of the Standard Libraries section to account for new headers and options; for example,  added to the -l rt operand, and the -l trace operand added for the Tracing functions
p14848
aVI'm not really familiar to all those different standards, but it looks like the more recent SUSv3 (POSIX:2004) and the yet more recent POSIX:2008 (doesn't seem to have a SUS number yet) do not specify a utility called  anymore, but only the utility called
p14849
aVIncidentally, my Linux system (Arch_Linux) contains a manpage of  but not , but only contains a utility called , but neither  nor
p14850
aVMuch confusion in there :)
p14851
as(dp14852
g15
V34509
p14853
stp14854
a((dp14855
g2
(lp14856
VDon't specialize the template, but overload it
p14857
aVThe compiler will figure out what function template to take by ordering them according to their specialization of their function parameter types (this is called partial ordering)
p14858
aVIn general, partial ordering will result in exactly what you expect
p14859
aVIn more detail, consider having these two functions
p14860
aVNow, to see whether one is at least as specialized as the other one, we test the following for both function templates:
p14861
aVchose some unique type for each template parameter, substitute that into the function parameter list
p14862
aVWith that parameter list as argument, make argument deduction on the other template (make a virtual call with those arguments to that other template)
p14863
aVIf the deduction succeeds and there is no conversion required (adding const is such one)
p14864
aVExample for the above:
p14865
aVsubstituting some type  into  gives us some type, call it
p14866
aVargument deduction of   against  won't work
p14867
aVSo the first is not at least as specialized as the second template
p14868
aVsubstituting types  and  into  yields
p14869
aVDoing argument deduction against  of the first template works:  will be deduced as
p14870
aVSo the second is at least as specialized as the first
p14871
aVThe rule is, a function template A is more specialized than the other B, if A is at least as specialized as B, but B is not at least as specialized as A
p14872
aVSo, the second wins in our example: It's more specialized, and it will be chosen if we could in principle call both template functions
p14873
aVI'm afraid, that overview was in a hurry, i only did it for type parameters and skipped some details
p14874
aVLook into  in the C++ Standard Spec to see the gory details
p14875
ag774
as(dp14876
g15
V34509
p14877
stp14878
a((dp14879
g2
(lp14880
VKnow that
p14881
aVallocates static storage somewhere, which lasts the whole program lifetime
p14882
aVYou cannot write to that storage, so C++ gives it the type  (an array of N constant characters)
p14883
aVNow, the following makes a pointer point to that storage
p14884
aVSince that drops a , that way of initializing the pointer is deprecated
p14885
aVThat it works at all is just to keep backward compatibility with C, where a string literal does not have a const type (but is still read only)
p14886
aVPrefer the following instead
p14887
aVIn constrast, the last way you have shown copies the string literal's content to an array, which will be writable, and be sized so the string literal just fits into it
p14888
aVIf you do that in a function, then as all variables, that array will be cleaned up when you leave its scope
p14889
aVNow, the first way you have shown is different
p14890
aVIt creates a character dynamically
p14891
aVYou could have initialized it like this
p14892
aVAnd since that happens dynamically, you need to tell the compiler explicitly when it should free the memory
p14893
aVBut you cannot initialize the character with a string literal
p14894
aVWhat you probably had in mind is creating storage dynamically, initialized with the string literal
p14895
aVThat's not possible using
p14896
aVThe only form of initializing a dynamic array is to zero it out, but you cannot directly-initialize with the content of a string literal or another array
p14897
aVFor this form of using , there is rarely a need to do that directly
p14898
aVIf you want, you can do it by creating a dynamic array of the right size, and then copy bytes from the string literal to that buffer
p14899
aVRemember that this is quite low-level, and i recommend you to use strings
p14900
aVIt completely manages memory for you
p14901
aVConcatenation, indexing and that stuff is available too
p14902
as(dp14903
g15
V34509
p14904
stp14905
a((dp14906
g2
(lp14907
VThere is some confusion, since  in C can mean two different things
p14908
aVOne is static storage duration, and the other is internal linkage
p14909
aVused as a keyword on file-scope will give the function or object it is used with internal linkage
p14910
aVInternal linkage for a function or object means that if you declare another function in another "file" (this is not really called "file", but rather translation unit - TU), then that declaration will refer to a different function: The name declared in that unit will "link" to a different entity than the name declared in that other translation unit, which was "internal" to that TU
p14911
aVThe same applies to objects
p14912
aVWhether or not a file-scope variable is declared with , it will still have a static storage duration: That means it lives through the whole program, and dies when the program terminates
p14913
aVAnother example of an object that has static storage duration is a string literal
p14914
aVWhere objects that have static storage duration are stored isn't specified, but they are usually stored depending on whether they are initialized or not: Initialized file-scope variables are usually stored in a section called "
p14915
aVdata", while non-initialized file-scope variables are usually stored in a section called "
p14916
aVbss"
p14917
aVRemember that if the variable isn't initialized, it will be zero initialized at the start of the program: The "
p14918
aVbss" section is usually zero initialized by an implementation on program's startup
p14919
aVI said "usually" everywhere, since where things are stored isn't specified
p14920
aVFor example, some implementations could store string literals in a read-only section
p14921
aVAnd if you have a file-scope pointer and don't initialize it, the implementation initializes it to a null-pointer, which is not necessarily an object with all null bytes :)
p14922
as(dp14923
g15
V34509
p14924
stp14925
a((dp14926
g2
(lp14927
VThe two functions are not itself illegal
p14928
aVFirst, you in both case return a copy of a pointer, which points to an object having static storage duration: The string literal will live, during the whole program duration
p14929
aVBut your  function is all about undefined behavior
p14930
aVYou are not allowed to write into a string literal's memory :) What your main function does can be cut down to equivalent behavior
p14931
aVBoth are undefined behavior and on some platforms crash (good
p14932
aVEdit: Note that string literals have a const type in C++ (not so in C):
p14933
aVYour assignment to a pointer to a non-const character triggers a deprecated conversion (which a good implementation will warn about, anyway)
p14934
aVBecause the above writings to that const array won't trigger that conversion, the code will mis-compile
p14935
aVReally, your code is doing this
p14936
aVRead
p14937
as(dp14938
g15
V34509
p14939
stp14940
a((dp14941
g2
(lp14942
VNo it's not valid
p14943
aVYou can't override them separately like that, because they would have the same signature
p14944
aVThere is a guru of the week about that
p14945
as(dp14946
g15
V34509
p14947
stp14948
a((dp14949
g2
(lp14950
VYou can't - in C
p14951
aVIn C initializing of global and local static variables are designed such that the compiler can put the values statically into the executable
p14952
aVIt can't handle non-constant expressions as initializers
p14953
aVAnd only in C99, you can use non-constant expression in aggregate initializers - not so in C89
p14954
aVIn your case, since your array is an array containing characters, each element has to be an arithmetic constant expression
p14955
aVLook what it says about those
p14956
aVAn arithmetic constant expression shall have arithmetic type and shall only have
p14957
aVoperands that are integer constants, \ufb02oating constants, enumeration constants, character
p14958
aVconstants, and sizeof expressions
p14959
aVSurely this is not satisfied by your initializer, which uses an operand of pointer type
p14960
aVSurely, the other way is to initialize your array using a string literal, as it explains too
p14961
aVAll the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals
p14962
aVAll quotes are taken out of the C99 TC3 committee draft
p14963
aVSo to conclude, what you want to do - using non-constant expression - can't be done with C
p14964
aVYou have several options:
p14965
aVWrite your stuff multiple times - one time reversed, and the other time not reversed
p14966
aVChange the language - C++ can do that all
p14967
aVIf you really want to do that stuff, use an array of  instead
p14968
aVHere is what i mean by the last option
p14969
aVThat works fine, as an address constant expression is used to initialize the pointers
p14970
aVAn address constant is a null pointer, a pointer to an lvalue designating an object of static storage duration, or a pointer to a function designator; it shall be created explicitly using the unary & operator or an integer constant cast to pointer type, or implicitly by the use of an expression of array or function type
p14971
aVThe array-subscript [] and member-access
p14972
aVand -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators
p14973
aVYou may have luck tweaking your compiler options - another quote:
p14974
aVAn implementation may accept other forms of constant expressions
p14975
as(dp14976
g15
V34509
p14977
stp14978
a((dp14979
g2
(lp14980
VI have to set this pointer to NULL in the constructor and then lazy load when property is touched
p14981
aVHow can i instantiate this to a new instance of a vector
p14982
aVI'm not sure i understand you all the way
p14983
aVWhy not simply leave the vector empty, and set a boolean that says whether the property was loaded or not
p14984
aVAlternatively, you can use
p14985
aVOr
p14986
aVYou can then simply receive the object by dereferencing the optional object, and assign a vector to it like usual
p14987
aVI would not use a pointer for this
p14988
aVIt complicates the matter, and you have to think about what happens when you copy the object containing the property,
p14989
aVIf you really have to use a pointer, you can do it like this
p14990
aVOr use , which would be the way to go in my program (but boost::optional would still be first option, after which would be the vector-and-boolean option, after which would be the following)
p14991
aVCopy and assignment are disabled, as they would share the prop behind the scene (shallow copy), which should be either clearly documented or disabled by deep copying in these functions
p14992
as(dp14993
g15
V34509
p14994
stp14995
a((dp14996
g2
(lp14997
VI like using  to check boolean conditions
p14998
aVIt can be quite useful
p14999
aVFor example, i used it to check whether an initializer list collected using operator comma is no longer than a fixed size
p15000
aVThe list is only accepted when M is smaller than N, which means that the initializer list has not too many elements
p15001
aVThe syntax  means: Pointer to an array with element type char and size
p15002
aVIf  is false (0 here), then we get the invalid type , pointer to a zero sized array: SFINAE makes it so that the template will be ignored then
p15003
aVExpressed with , that looks like this
p15004
aVIn practice, i often find the ability to check conditions a useful ability
p15005
as(dp15006
g15
V34509
p15007
stp15008
a((dp15009
g2
(lp15010
VHotfix
p15011
aVThere is a hot-fix available, but read the below explanation if you want to understand what's going on
p15012
aVAs the snippet shows, you have to declare the template to make it visible when you call it
p15013
aVFriend function definitions
p15014
aVThis is confusing, since there are some rules in the way in this case
p15015
aVSome basic points, and then some other points
p15016
aVWhat does it do
p15017
aVIt defines a friend function
p15018
aVSuch a function is a member of the enclosing namespace
p15019
aVIt's not a class member, even though it is defined within a class
p15020
aVThe fact that it's defined within a class only changes the lexical scope of that function: It can refer to that class' members directly, without preceding the class-name
p15021
aVMost importantly, though, the function is not visible after being declared
p15022
aVYou cannot take its address doing something like this, for example
p15023
aVThe only way that the function would work is using argument dependent lookup
p15024
aVA lookup that ends up having that class as its associated class will consider that friend function
p15025
aVThat means that the following works:
p15026
aVIt works because the call includes an argument with type that has the class included
p15027
aVIn that case, the class is an associated class, and the friend declaration will be considered
p15028
aVThe following won't work, for example
p15029
aVBecause it has no idea that it should look within  to find a friend declaration
p15030
aVA friend function definition of a function without an argument won't be found, because there is no argument dependent lookup happening, then
p15031
aVFriend function definition for templates
p15032
aVIn addition to the fact that your call does not include arguments, it has another problem
p15033
aVIf you define a friend function template, the matter is more complicated
p15034
aVThere is a rule that says that if the compiler sees , that this only refers to a template specialization if  actually resolves to a template
p15035
aVConsider
p15036
aVThe compiler can't resolve , because it is not visible to normal lookup
p15037
aVTherefor, the rule says that  does not refer to a function
p15038
aVIt has to be parsed as a relational expression, yielding to the following
p15039
aVThat will be a syntax error, because  is not a value, and  is neither a value
p15040
aVExample
p15041
aVHere is an example where it matters
p15042
aVThat compiles
p15043
aVIt compiles because  resolves to a template (although a completely different one that can't even accept a non-type template argument - but that doesn't matter
p15044
aVBut a Standard conforming compiler will not compile the snippet once you comment out the second declaration, because it's compiled as a relational expression (less-than and smaller-than) and it will not find symbol
p15045
aVRead this thread for further information: What am I missing in this template toy example
p15046
as(dp15047
g15
V34509
p15048
stp15049
a((dp15050
g2
(lp15051
VIt's not possible in C89 (what most C compilers target)
p15052
aVC99 is supported by a few, and has compound literals:
p15053
aVYou however cannot assign to an array
p15054
aVYou can only copy to its memory
p15055
aVYou would need another array that you copy from in C89
p15056
aVNote that the  operator returns the size of its operand in bytes
p15057
as(dp15058
g15
V34509
p15059
stp15060
a((dp15061
g2
(lp15062
VIt's a function declaration for a function taking a reference to a  and returning a
p15063
aVYou can memorize the following rule, which turns out to apply to many other such disambiguation cases
p15064
aVYou can find descriptions of these cases in section  of the C++ Standard
p15065
aVAny construct that could possibly be a declaration will be taken as a declaration
p15066
aVThat means, the following will be taken as a parameter declaration, with superfluous parentheses
p15067
aVIf you remove the parentheses, this will become clear
p15068
aVAnd thus, the whole declaration will not anymore declare an object, but a function
p15069
aVTo fix it, use the cast-notation
p15070
aVOr put parentheses around the whole expression, like you did
p15071
aVHere is the Standard in all its glory from :
p15072
aVThe ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6
p15073
aV8 can also occur in the context of a declaration
p15074
aVIn that context, the choice is between a function declaration with a redundant set of parentheses around a parameter name and an object declaration with a function-style cast as the initializer
p15075
aVJust as for the ambiguities mentioned in 6
p15076
aV8, the resolution is to consider any construct that could possibly be a declaration a declaration
p15077
aV[Note: a declaration can be explicitly disambiguated by a nonfunction-style cast, by a = to indicate initialization or by removing the redundant parentheses around the parameter name
p15078
ag4885
aVNote that for controlling precedence, you are allowed to introduce parentheses just about anywhere, like in the following
p15079
as(dp15080
g15
V34509
p15081
stp15082
a((dp15083
g2
(lp15084
VUnlike the concerns asked in that other questions, the answer to this question can be answered entirely by means of the Standard
p15085
aVHere are the rules
p15086
aVA handler is a match for an exception object of type E if
p15087
aVThe handler is of type cv T or cv T& and E and T are the same type (ignoring the top-level cv-qualifiers), or
p15088
aVthe handler is of type cv T or cv T& and T is an unambiguous public base class of E, or
p15089
aVthe handler is of type cv1 T* cv2 and E is a pointer type that can be converted to the type of the handler by either or both of
p15090
aVa standard pointer conversion (4
p15091
aV10) not involving conversions to pointers to private or protected or ambiguous classes
p15092
aVa qualification conversion
p15093
aV[Note: a throw-expression which is an integral constant expression of integer type that evaluates to zero
p15094
aVdoes not match a handler of pointer type; that is, the null pointer constant conversions (4
p15095
aV10, 4
p15096
aV11) do not
p15097
aVapply
p15098
ag4885
aVAs i'm not quite sure about your level of understanding of the Standard, i will leave this unexplained, and answer as you ask
p15099
aVWith regard to whether it uses RTTI or not - well, the type of the exception object being thrown is the static type of the expression you hand over to the  statement (some time ago, i had fun figuring this out in GCC)
p15100
aVSo it does not need to do runtime type identification
p15101
aVSo it happens, with , that at the side where the  appears, it hands over a  object representing the type of the exception object, the object itself and a destructor function
p15102
aVIt's then thrown and frames are searched for a matching handler
p15103
aVUsing information found in big tables (located in a section called ), and using the return address, it looks what function is responsible for the next handling
p15104
aVThe function will have a personality routine installed that figures out whether it can handle the exception or not
p15105
aVThis whole procedure is described (and in more detail, of course) in the Itanium C++ ABI (implemented by G++) linked by @PaV
p15106
aVSo, to conclude
p15107
aVand
p15108
aVDo not handle the same type, of course
p15109
as(dp15110
g15
V34509
p15111
stp15112
a((dp15113
g2
(lp15114
VYou can rely on this
p15115
aVThe ODR (One Definition Rule) says at  in the Standard, where  stands for the non-static function template (cursive font by me)
p15116
aVIf D is a template, and is defined in more than one translation unit, then the last four requirements from the list above shall apply to names from the template\u2019s enclosing scope used in the template definition (14
p15117
ag488
aV3), and also to dependent names at the point of instantiation (14
p15118
ag488
aV2)
p15119
aVIf the definitions of D satisfy all these requirements, then the program shall  behave as if there were a single definition of D
p15120
aVIf the definitions of D do not satisfy these requirements, then the behavior is undefined
p15121
aVOf the last four requirements, the two most important are roughly
p15122
aVeach definition of D shall consist of the same sequence of tokens
p15123
aVnames in each definition shall refer to the same things ("entities")
p15124
aVEdit
p15125
aVI figure that this alone is not sufficient to guarantee that your static variables in the different instantiations are all the same
p15126
aVThe above only guarantees that the multiple definitions of the template is valid
p15127
aVIt doesn't say something about the specializations generated from it
p15128
aVThis is where linkage kicks in
p15129
aVIf the name of a function template specialization (which is a function) has external linkage (), then a name that refers to such a specialization refers to the same function
p15130
aVFor a template that was declared static, functions instantiated from it have internal linkage, because of
p15131
aVEntities generated from a template with internal linkage are distinct from all entities generated in other translation units
p15132
aVA name having namespace scope (3
p15133
ag1037
aV6) has internal linkage if it is the name of [
p15134
aVan object, reference, function or function template that is explicitly declared static
p15135
aVIf the function template wasn't declared with static, then it has extern linkage (that, by the way, is also the reason that we have to follow the ODR at all
p15136
aVOtherwise,  would not be multiply defined at all
p15137
aVThis can be derived from  (together with )
p15138
aVA non-member function template can have internal linkage; any other template name shall have external linkage
p15139
aVFinally, we come to the conclusion that a function template specialization generated from a function template with external linkage has itself external linkage by :
p15140
aVA name having namespace scope has external linkage if it is the name of [
p15141
aVa function, unless it has internal linkage
p15142
aVAnd when it has internal linkage was explained by  for functions provided by explicit specializations, and  for generated specializations (template instantiations)
p15143
aVSince your template name has external linkage, all your specializations have external linkage: If you use their name () from different translation units, they will refer to the same functions, which means your static objects will be the same in each occasion
p15144
as(dp15145
g15
V34509
p15146
stp15147
a((dp15148
g2
(lp15149
VThis seems to work ( being the filename up to which to delete)
p15150
aVIf you are sure it does what you want, replace the echo command by
p15151
aVNever pipe  for processing things
p15152
aVls isn't made for that task
p15153
aVUse pathname expansion or tools like
p15154
aVExample failure case:
p15155
aVIt splits the result of  into words and passes these words as separate arguments
p15156
aVThus, rm would not see such a name as a whole, but as splitted into its words
p15157
aVPathname expansion is done after word splitting, so word splitting does not affect its result anymore
p15158
aVThat is why a  will correctly handle spaces (or for that purpose, any other characters in the  variable)
p15159
as(dp15160
g15
V34509
p15161
stp15162
a((dp15163
g2
(lp15164
VI believe you mean
p15165
aVWhy does const imply internal linkage in C++
p15166
aVIt's true that if you declare a const object at namespace scope, then it has internal linkage
p15167
aVAppendix C gives the rationale
p15168
aVChange: A name of file scope that is explicitly declared const, and not explicitly declared extern, has internal linkage, while in C it would have external linkage
p15169
aVRationale: Because const objects can be used as compile-time values in C++, this feature urges programmers to provide explicit initializer values for each const
p15170
aVThis feature allows the user to put const objects in header files that are included in many compilation units
p15171
as(dp15172
g15
V34509
p15173
stp15174
a((dp15175
g2
(lp15176
VI think these work now, regardless of whether you use two's complement or not
p15177
aVPlease test extensively before you use it
p15178
aVThey give the following results
p15179
aVEach line gives one assertion failure (just change them into exceptions as you please)
p15180
aVImplementation
p15181
aVFirst some utilities to check for integer ranks (types with higher ranks will be able to contain values of types with lower rank, given the same sign
p15182
aVAnd some promotion tools, to be able to figure out a common, safe type (this will never yield a signed type if an unsigned type is involved, if the signed type won't be able to store all values of the unsigned one)
p15183
aVThe conversion templates make use of them, to figure out for each case when what needs to be done or not done
p15184
as(dp15185
g15
V34509
p15186
stp15187
a((dp15188
g2
(lp15189
VI think there are two cases how one can use templates
p15190
aVProviding generic code for an arbitrary set of conforming types
p15191
aVProviding generic code for a fixed set of types
p15192
aVFor the second one, you don't need to put templates into the header: Since you know beforehand, precisely, with what types your template is used
p15193
aVYou can very well define a class template's member function, or a function template in a separate translation unit, without linker errors
p15194
aVSome people keep teaching others that this is not possible, and confuse the matter by this
p15195
aVBut i think it depends on these two cases whether you want to separate declaration and definition into different translation units or not
p15196
aVIf you want to use case 1, you always want to have the definition in the header (whether included by special named files, like ,  or whatever)
p15197
aVI only know of one C++ frontend that supports separating definition from declarations even in this case, which is the EDG (edison design group) frontend, used by the intel and comeau compilers, that implement
p15198
aVThat keyword is seen as a misfeature by some, and most compilers don't implement it
p15199
aVAnd if you want to use case 2, it's no good to put the definitions into the header, because there would be no reason to do so: You will just explicitly instantiate the needed functions and classes for the fixed set of types
p15200
aVIn this second scenario, you use the template to save yourself from the burden to maintain possibly redundant code, and have the option open to introduce special behavior for some types in some cases
p15201
aVYour scenario is clearly a case 1 situation, and so you will have to put your definitions into the header
p15202
as(dp15203
g15
V34509
p15204
stp15205
a((dp15206
g2
(lp15207
VAnother way is this one, which relies on SFINAE for expressions too
p15208
aVIf the name lookup results in ambiguity, the compiler will reject the template
p15209
aVIt's based on a brilliant idea of someone on usenet
p15210
as(dp15211
g15
V34509
p15212
stp15213
a((dp15214
g2
(lp15215
V will be zero, and  too, if they are global and not explicitly initialized
p15216
aVThis is also true for local static variables
p15217
aVOnly local non-static variables are not initialized
p15218
aVAlso memory allocated with malloc is not initialized
p15219
aVSee  for rules of initializations and allocation in C for the different objects
p15220
as(dp15221
g15
V34509
p15222
stp15223
a((dp15224
g2
(lp15225
VThat's the left shift operator, and its standard meaning (for number types) is shifting bits to the left
p15226
aVThe code creates a 64 bit number out of two 32 bit numbers
p15227
as(dp15228
g15
V34509
p15229
stp15230
a((dp15231
g2
(lp15232
VThis can be done with a conversion function
p15233
aVNow you just need to do
p15234
aVAnd it should work well
p15235
aVIncidentally, you may just use the class directly
p15236
aVI recommend renaming it to  to point to the fact that it's just a proxy to a happening conversion but that it itself doesn't do conversion
p15237
as(dp15238
g15
V34509
p15239
stp15240
a((dp15241
g2
(lp15242
VYou can explicitly instantiate function templates
p15243
aVTo instantiate a specialization with
p15244
aVThe template argument brackets can be omitted if all template arguments can be deduced (like in this case, from the type
p15245
aVIf it can't, for example because the template parameters do not occur in a function parameter type, you have to explicitly specify it
p15246
as(dp15247
g15
V34509
p15248
stp15249
a((dp15250
g2
(lp15251
VUse the conditional operator
p15252
aVIf the expression is larger, use a function
p15253
aVTo call a function before initializing m_class, you can place a struct before that member and leverage RAII
p15254
aVThis will call  before initializing
p15255
aVNote that you are not allowed to call non-static member functions of  before the constructor initializer list has completed
p15256
aVThe function would have to be a member of its base class and the base class' ctor must already be completed for that to work
p15257
aVAlso note that the function, of course, is always called, for each separate object created - not only for the first object created
p15258
aVIf you want to do that, you could create a static variable within the initializer's constructor:
p15259
aVIt's using the comma operator
p15260
aVNote that you can catch any exception thrown by  by using a function-try block
p15261
aVThe  function will be called again next time, if it threw that exception that caused the  object fail to be created
p15262
aVHope this helps :)
p15263
as(dp15264
g15
V34509
p15265
stp15266
a((dp15267
g2
(lp15268
VI think the reason is history
p15269
aVIt may be worth to note that next C++ version (C++0x, C++1x) introduces scopes enumerations that are not allowed to implicitly convert to an integer, making the following code ill-formed
p15270
aVIt makes sense to me for numbers to allow the implicit conversion to bool, though, but it doesn't make much sense to me for enumerations, because the primary purpose is to enumerate a list of values - only secondary the real values of an enumerator are of interest most of the time, i believe
p15271
aVScoped enumerations will require a cast
p15272
aVThis adds some type-safety that the needed C compatibility of enumerations did not allow so far (i guess this would break a lot of code if forbidden to ordinary enumerations)
p15273
as(dp15274
g15
V34509
p15275
stp15276
a((dp15277
g2
(lp15278
VI recommend you to do the following, if you have to keep the pointers separately (probably the most pressing need would be if the pointers can have different types)
p15279
aVThis does work, because value-initialization for classes that doesn't have a user declared constructor will value initialize all its members
p15280
aVValue initialization of a pointer will create a null pointer
p15281
as(dp15282
g15
V34509
p15283
stp15284
a((dp15285
g2
(lp15286
VYou should assign the pointer the new address  returns
p15287
aVNote that for error checking, you may desire to assign to a new pointer and check for
p15288
aVAlso note the parens - you basically just added  instead of multiplying with the required size
p15289
aVEasily overseen
p15290
aVNote that there is no need for the initial
p15291
aVJust initialize  to , and realloc will behave like  when first passed a null pointer
p15292
as(dp15293
g15
V34509
p15294
stp15295
a((dp15296
g2
(lp15297
VIt will do the same thing (nothing, in essence)
p15298
aVBut it's not the same as if you didn't write it
p15299
aVBecause writing the destructor will require a working base-class destructor
p15300
aVIf the base class destructor is private or if there is any other reason it can't be invoked, then your program is faulty
p15301
aVConsider this
p15302
aVThat is OK, as long as your don't require to destruct an object of type B (and thus, implicitly of type A) - like if you never call delete on a dynamically created object, or you never create an object of it in the first place
p15303
aVIf you do, then the compiler will display an appropriate diagnostic
p15304
aVNow if you provide one explicitly
p15305
aVThat one will try to implicitly call the destructor of the base-class, and will cause a diagnostic already at definition time of
p15306
aVThere is another difference that centers around the definition of the destructor and implicit calls to member destructors
p15307
aVConsider this smart pointer member
p15308
aVLet's assume the object of type  is created in the definition of A's constructor in the  file, which also contains the definition of struct
p15309
aVNow, if you use struct , and require destruction of an  object, the compiler will provide an implicit definition of the destructor, just like in the case above
p15310
aVThat destructor will also implicitly call the destructor of the auto_ptr object
p15311
aVAnd that will delete the pointer it holds, that points to the  object - without knowing the definition of
p15312
aVThat appeared in the  file where struct A's constructor is defined
p15313
aVThis actually is a common problem in implementing the pimpl idiom
p15314
aVThe solution here is to add a destructor and provide an empty definition of it in the  file, where the struct  is defined
p15315
aVAt the time it invokes the destructor of its member, it will then know the definition of struct , and can correctly call its destructor
p15316
aVNote that  does not have that problem: It instead requires a complete type when its constructor is invoked in certain ways
p15317
aVAnother point where it makes a difference in current C++ is when you want to use  and friends on such an object that has a user declared destructor
p15318
aVSuch types are not PODs anymore (plain old data), and these are not allowed to be bit-copied
p15319
aVNote that this restriction isn't really needed - and the next C++ version has improved the situation on this, so that it allows you to still bit-copy such types, as long as other more important changes are not made
p15320
aVSince you asked for constructors: Well, for these much the same things are true
p15321
aVNote that constructors also contain implicit calls to destructors
p15322
aVOn things like auto_ptr, these calls (even if not actually done at runtime - the pure possibility already matters here) will do the same harm as for destructors, and happen when something in the constructor throws - the compiler is then required to call the destructor of the members
p15323
aVThis answer makes some use of implicit definition of default constructors
p15324
aVAlso, the same is true for visibility and PODness that i said about the destructor above
p15325
aVThere is one important difference regarding initialization
p15326
aVIf you put a user declared constructor, your type does not receive value initialization of members
p15327
as(dp15328
g15
V34509
p15329
stp15330
a((dp15331
g2
(lp15332
VI believe you wanted to write your loop as
p15333
aVAn int can at least store values up to , which is more than enough for this
p15334
aVNonetheless, here is how i do it
p15335
aVYou could do it with  too, if you happen to have that type available in your compiler
p15336
as(dp15337
g15
V34509
p15338
stp15339
a((dp15340
g2
(lp15341
VI have always taken it to mean absent
p15342
aVHere are four cases in the C language that matches to this use of absent
p15343
aV- Function parameters are absent
p15344
aV- Return value is absent
p15345
aV- Type of what is pointed to is absent
p15346
aV- Usage of value is absent
p15347
aVOther C descendants use it for other things
p15348
aVThe  programming language uses it for cases where an initializer is absent
p15349
aV- initializing value is absent
p15350
as(dp15351
g15
V34509
p15352
stp15353
a((dp15354
g2
(lp15355
VChange the parameter to a value parameter
p15356
aVFunction objects are intentionally light weight, and  certainly is, specially crafted to fit in within space of a few bytes using  and what not
p15357
aVThen you can pass it the result of
p15358
aVRemember that  is actually a function template that returns some object of some type
p15359
aVSo having  have a non-const reference parameter couldn't work
p15360
as(dp15361
g15
V34509
p15362
stp15363
a((dp15364
g2
(lp15365
V is a storage class specifier, ,  and  too
p15366
aVYou can only use one of these four in a declaration
p15367
aVLocal variables (without ) have automatic storage duration, which means they live from the start of their definition until the end of their block
p15368
aVPutting auto in front of them is redundant since that is the default anyway
p15369
aVI don't know of any reason to use it in C++
p15370
aVIn old C versions that have the implicit int rule, you could use it to declare a variable
p15371
aVTo to make it valid syntax or disambiguate from an assignment expression in case  is in scope
p15372
aVBut this doesn't work in C++ anyway (you have to specify a type)
p15373
aVFunny enough, the C++ Standard writes:
p15374
aVAn object declared without a storage-class-specifier at block scope or declared as a function parameter has automatic storage duration by default
p15375
aV[Note: hence, the auto specifier is almost always redundant and not often used; one use of auto is to distinguish a declaration-statement from an expression-statement (6
p15376
aV8) explicitly
p15377
aV\u2014end note]
p15378
aVWhich refers to the following scenario, which could be either a cast of  to int or the declaration of a variable  of type  having redundant parentheses around
p15379
aVIt is always taken to be a declaration, so  wouldn't add anything useful here, but would for the human, instead
p15380
aVBut then again, the human would be better off removing the redundant parentheses around , I would say
p15381
aVWith the new meaning of  arriving with C++0x, I would discourage using it with C++03's meaning in code
p15382
as(dp15383
g15
V34509
p15384
stp15385
a((dp15386
g2
(lp15387
VThis is caused by confusing terms
p15388
aVin C does not refer to restrict linkage of an identifier to only one translation unit
p15389
aVIt also doesn't mean that scope is limited to one physical file
p15390
aVInstead,  means that your identifier is global
p15391
aVThe term , here, refers to the text that results from processing all ,  and other pre-processor directives
p15392
aVIn general, scope is only a concept taking effect within one translation unit
p15393
aVWhen multiple compilations are involved, linkage starts to happen
p15394
aVIf you declare your file scope variable , then it gives the variable internal linkage, which means that it isn't visible outside of that translation unit
p15395
aVIf you don't declare it static explicitly, or if you declare the file scope variable , then it is visible to other translation units: Those, if they declare a file-scope variable with the same identifier, will have that identifier link to that same variable
p15396
aVIn your case, the inclusion of  into  inserts the definition of  into the translation unit being compiled
p15397
aVThus, it's visible in that unit
p15398
as(dp15399
g15
V34509
p15400
stp15401
a((dp15402
g2
(lp15403
VYou are not using the move constructor
p15404
aVI think swap is implemented something like this
p15405
aVYou want to use the move assignment operator, which doesn't exist in your code, so it falls back to the copy assignment operator
p15406
as(dp15407
g15
V34509
p15408
stp15409
a((dp15410
g2
(lp15411
VOverload resolution for integer types happen on two categories, which can be very roughly summarized to
p15412
aVPromotion: This is a conversion from types smaller than  to  or , depending on whether  can store all the values of the source type
p15413
aVConversion: This is a conversion from any integer type to another integer type
p15414
aVSimilar, conversion for floating point types happen on two categories
p15415
aVPromotion: This is a conversion from  to
p15416
aVConversion: This is a conversion from any floating point type to another floating point type
p15417
aVAnd there is a conversion from integer to floating or back
p15418
aVThis is ranked as a conversion, rather than a promotion
p15419
aVA promotion is ranked better than a conversion, and where only a promotion is needed, that case will be preferred
p15420
aVThus, you can use the following constructors
p15421
aVFor any integer type, this should select the first group of constructor
p15422
aVAnd for any floating point type, this should select the second group of constructors
p15423
aVYour original two constructors could easily result in an ambiguity between  and , if you pass an , for example
p15424
aVFor the other, two argument constructor, you can go with your solution, if you want
p15425
aVThat said, i would use a factory function too, because deciding on the type the meaning of the parameter is quite fragile i think
p15426
aVMost people would expect the following result to equal
p15427
aVBut it would result in a different state of affairs
p15428
as(dp15429
g15
V34509
p15430
stp15431
a((dp15432
g2
(lp15433
VDepends on what type  returns
p15434
aVI assume it returns an  - then it's doing the same - except that when the copy constructor is explicit, then the first one will fail
p15435
aVRead
p15436
aVThis is doing the same because it's a built-in type (this means not a class type here)
p15437
aVRead
p15438
aVThis is not doing the same
p15439
aVThe first default-initializes if  is a non-POD, and doesn't do any initialization for a POD (Read )
p15440
aVThe second copy initializes: Value-initializes a temporary and then copies that value into  (Read  and )
p15441
aVThis of course will require a non-explicit copy constructor (Read  and  and )
p15442
aVThe third creates a function declaration for a function  that returns an  and that takes a function pointer to a function returning a  (Read )
p15443
aVDelving into Initializations Direct and Copy initialization
p15444
aVWhile they look identical and are supposed to do the same, these two forms are remarkably different in certain cases
p15445
aVThe two forms of initialization are direct and copy initialization:
p15446
aVThere is behavior we can attribute to each of them:
p15447
aVDirect initialization behaves like a function call to an overloaded function: The functions, in this case, are the constructors of  (including  ones), and the argument is
p15448
aVOverload resolution will find the best matching constructor, and when needed will do any implicit conversion required
p15449
aVCopy initialization constructs an implicit conversion sequence: It tries to convert  to an object of type
p15450
aV(It then may copy over that object into the to-initialized object, so a copy constructor is needed too - but this is not important below)
p15451
aVAs you see, copy initialization is in some way a part of direct initialization with regard to possible implicit conversions: While direct initialization has all constructors available to call, and in addition can do any implicit conversion it needs to match up argument types, copy initialization can just set up one implicit conversion sequence
p15452
aVI tried hard and got the following code to output different text for each of those forms, without using the "obvious" through  constructors
p15453
aVHow does it work, and why does it output that result
p15454
aVDirect initialization
p15455
aVIt first doesn't know anything about conversion
p15456
aVIt will just try to call a constructor
p15457
aVIn this case, the following constructor is available and is an exact match:
p15458
aVThere is no conversion, much less a user defined conversion, needed to call that constructor (note that no const qualification conversion happens here either)
p15459
aVAnd so direct initialization will call it
p15460
aVCopy initialization
p15461
aVAs said above, copy initialization will construct a conversion sequence when  has not type  or derived from it (which is clearly the case here)
p15462
aVSo it will look for ways to do the conversion, and will find the following candidates
p15463
aVNotice how I rewrote the conversion function: The parameter type reflects the type of the  pointer, which in a non-const member function is to non-const
p15464
aVNow, we call these candidates with  as argument
p15465
aVThe winner is the conversion function: Because if we have two candidate functions both accepting a reference to the same type, then the less const version wins (this is, by the way, also the mechanism that prefers non-const member function calls for non-const objects)
p15466
aVNote that if we change the conversion function to be a const member function, then the conversion is ambiguous (because both have a parameter type of  then): The Comeau compiler rejects it properly, but GCC accepts it in non-pedantic mode
p15467
aVSwitching to  makes it output the proper ambiguity warning too, though
p15468
aVI hope this helps somewhat to make it clearer how these two forms differ
p15469
as(dp15470
g15
V34509
p15471
stp15472
a((dp15473
g2
(lp15474
VHere you wanna make a pointer to the first element of the array
p15475
aVWith typedef, this looks cleaner
p15476
aVThen you can enjoy life again :)
p15477
aVBeware of the pointer/array world in C, much confusion is around this
p15478
aVEdit
p15479
aVReviewing some of the other answers here, because the comment fields are too short to do there
p15480
aVMultiple alternatives were proposed, but it wasn't shown how they behave
p15481
aVHere is how they do
p15482
aVIf you fix the error and add the address-of operator  like in the following snippet
p15483
aVThen that one creates a pointer to an incomplete array type of elements of type array of 20 uint8_t
p15484
aVBecause the pointer is to an array of arrays, you have to access it with
p15485
aVAnd because it's a pointer to an incomplete array, you cannot do as a shortcut
p15486
aVBecause indexing requires the element type's size to be known (indexing implies an addition of an integer to the pointer, so it won't work with incomplete types)
p15487
aVNote that this only works in , because  and  are compatible types
p15488
aVC++ does not have a concept of compatible types, and so it will reject that code, because  and  are different types
p15489
aVThe following alternative doesn't work at all, because the element type of the array, when you view it as a one-dimensional array, is not , but
p15490
aVThe following is a good alternative
p15491
aVYou access it with
p15492
aVIt has the benefit that it preserves the outer dimension's size
p15493
aVSo you can apply sizeof on it
p15494
aVThere is one other answer that makes use of the fact that items in an array are contiguously stored
p15495
aVNow, that formally only allows you to access the elements of the first element of the two dimensional array
p15496
aVThat is, the following condition hold
p15497
aVYou will notice it probably works up to , but if you throw on alias analysis and other aggressive optimizations, some compiler could make an assumption that may break that code
p15498
aVHaving said that, i've never encountered a compiler that fails on it (but then again, i've not used that technique in real code), and even the C FAQ has that technique contained (with a warning about its UB'ness), and if you cannot change the array type, this is a last option to save you :)
p15499
as(dp15500
g15
V34509
p15501
stp15502
a((dp15503
g2
(lp15504
VNo, there isn't any way
p15505
aVTry making all your exception classes derive from one single class, like , and then catch that one
p15506
aVYou could rethrow in a nested , though, in an attempt to figure out the type
p15507
aVBut then you could aswell use a previous catch clause (and  only as fall-back)
p15508
as(dp15509
g15
V34509
p15510
stp15511
a((dp15512
g2
(lp15513
VDon't call  from a worker thread
p15514
aVOnly do that from the GUI thread
p15515
aVYield will process gui events, and is intended to be used if in some GUI event handler you do much of work and want to update other controls and process pending events in between
p15516
aVThe  in  means that it disables GUI controls before it processes pending events first
p15517
aVThat will protect you from such cases like entering the event handler you called  from a second time, recursively
p15518
aVIt doesn't mean that it is thread-safe, or something like that
p15519
aVIf you want to give the rest of the time slice your thread would have to other threads, call wx's  or boost's  (depending on your thread class) instead
p15520
as(dp15521
g15
V34509
p15522
stp15523
a((dp15524
g2
(lp15525
VThe Standard is clear on this in  about associative containers
p15526
aVThe insert members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements
p15527
as(dp15528
g15
V34509
p15529
stp15530
a((dp15531
g2
(lp15532
VYou probably forgot to include  which makes  visible
p15533
aVYou also need to change this into , because C++ standard library names are within the namespace
p15534
aVDo not write  in a header-file, ever
p15535
aVIt's ok to place it into the implementation file, if you want, or if you write up an example for a friend
p15536
aVBecause any file that includes that header will have all of the standard library visible as global names, which is a huge mess and smells a lot
p15537
aVIt suddenly increases the chance for name-clashes with other global names or other 'ed names - i would avoid using directives at all (see Using me by Herb Sutter)
p15538
aVSo change the code into this one
p15539
aVAnd in the implementation file ("
p15540
aVcpp")
p15541
as(dp15542
g15
V34509
p15543
stp15544
a((dp15545
g2
(lp15546
VThey are not null if you don't initialize the struct
p15547
aVThe second will make all members zero, the first leaves them at unspecified values
p15548
aVNote that it is recursive:
p15549
aVThe second will make  zero
p15550
aVYou cannot use these aggregate initializer lists if you've got constructors in your struct
p15551
aVIf that is the case, you will have to add proper initalization to those constructors
p15552
aVWill initialize both x and y to 0
p15553
aVNote that you can use  to initialize them disregarding of their type: That's then value initialization, and usually yields a proper initial value (0 for int, 0
p15554
aV0 for double, calling the default constructor for user defined types that have user declared constructors,
p15555
aVThis is important especially if your struct is a template
p15556
as(dp15557
g15
V34509
p15558
stp15559
a((dp15560
g2
(lp15561
VI want to write some text about initializaton too, which i can later link to
p15562
aVFirst the list of possibilities
p15563
aVNamespace Static
p15564
aVClass Static
p15565
aVLocal Static
p15566
aVNamespace Static
p15567
aVThere are two initialization methods
p15568
aVstatic (intended to happen at compile time) and dynamic (intended to happen at runtime) initialization
p15569
aVStatic Initialization happens before any dynamic initialization, disregarding of translation unit relations
p15570
aVDynamic Initiaization is ordered in a translation unit, while there is no particular order in static initialization
p15571
aVObjects of namespace scope of the same translation unit are dynamically initialized in the order in which their definition appears
p15572
aVPOD type objects that are initialized with constant expressions are statically initialized
p15573
aVTheir value can be relied on by any object's dynamic initialization, disregarding of translation unit relations
p15574
aVIf the initialization throws an exception,  is called
p15575
aVExamples:
p15576
aVThe following program prints
p15577
aVAnd the following, based on the same class, prints
p15578
aVLet's pretend there is a translation unit where  is defined as the following
p15579
aVThen the following prints
p15580
aVNote that  receives dynamic initialization
p15581
aVBut because the static initialization ( is a POD type, and  is an address constant expression) of  happens before that, this is fine, and  is guaranteed to be correctly initialized
p15582
aVDynamic initialization of an object is not required to happen before main at all costs
p15583
aVThe initialization must happen before the first use of an object or function of its translation unit, though
p15584
aVThis is important for dynamic loadable libraries
p15585
aVClass Static
p15586
aVBehave like namespace statics
p15587
aVThere is a bug-report on whether the compiler is allowed to initialize class statics on the first use of a function or object of its translation unit too (after main)
p15588
aVThe wording in the Standard currently only allows this for namespace scope objects - but it seems it intends to allow this for class scope objects too
p15589
aVRead Objects of Namespace Scope
p15590
aVFor class statics that are member of templates the rule is that they are only initialized if they are ever used
p15591
aVNot using them will not yield to an initialization
p15592
aVNote that in any case, initialization will happen like explained above
p15593
aVInitialization will not be delayed because it's a member of a template
p15594
aVLocal Static
p15595
aVFor local statics, special rules happen
p15596
aVPOD type objects initialized with constant expression are initialized before their block in which they are defined is entered
p15597
aVOther local static objects are initialized at the first time control passes through their definition
p15598
aVInitialization is not considered to be complete when an exception is thrown
p15599
aVThe initialization will be tried again the next time
p15600
aVExample: The following program prints :
p15601
aVIn all the above cases, in certain limited cases, for some objects that are not required to be initialized statically, the compiler can statically initialize it, instead of dynamically initializing it
p15602
aVThis is a tricky issue, see this answer for a more detailed example
p15603
aVAlso note that the order of destruction is the exact order of the completion of construction of the objects
p15604
aVThis is a common and happens in all sort of situations in C++, including in destructing temporaries
p15605
as(dp15606
g15
V34509
p15607
stp15608
a((dp15609
g2
(lp15610
VNo it isn't, because the type of the template parameter would include itself
p15611
aVThis would yield to an endless recursion in the type
p15612
aVIf instead of the class template specialization, you accept a base-class of it, that's very possible
p15613
aVWhat do you want to do with this
p15614
as(dp15615
g15
V34509
p15616
stp15617
a((dp15618
g2
(lp15619
V can do it
p15620
aVNo need to upcast
p15621
aVA member pointer to a base-class member can be applied to a derived class too
p15622
as(dp15623
g15
V34509
p15624
stp15625
a((dp15626
g2
(lp15627
VYou are slicing the  object part and copy the object into an  object
p15628
aVThe function then called is called on an  object, and thus the function of  is called
p15629
aVWhen you specify a type in C++ in a declaration or cast, that is meant to say that the object declared or casted-to is actually of that type, not of a derived type
p15630
aVIf you want to merely treat the object is being of type  (that is to say, if you want the static type of the expression be , but still want it to denote an  object) then you cast to a reference type
p15631
aVThis will call the function in the  object, and will not slice nor copy into an  object
p15632
aVIn steps, this does
p15633
aVDereference the pointer , which is of type
p15634
aVDereferencing yields an lvalue expression of type
p15635
aVAn lvalue expression can actually denote an object of a derived type, even if its static type is the one of its base
p15636
aVCast to a , which is a reference to
p15637
aVThat will yield an lvalue expression of type
p15638
aVCall the function
p15639
aVYour original cast did
p15640
aVDereference the pointer
p15641
aVThe resulting expression casted to
p15642
aVThis will yield to a copy operation into a new  object
p15643
aVThe resulting expression of that is an rvalue expression of static type
p15644
aVThe dynamic type of the object denoted is also , as is with all rvalue expressions
p15645
aVCall the function
p15646
as(dp15647
g15
V34509
p15648
stp15649
a((dp15650
g2
(lp15651
VWhat you dereference is a pointer to an array
p15652
aVThus, dereferencing gives you the array
p15653
aVPassing an array to printf (or to any function) passes the address of the first element
p15654
aVYou tell  that you pass it an  (), but actually what is passed is an
p15655
aVThe numbers you see are the addresses of the first element of the array interpreted as an unsigned int
p15656
aVOf course, this is undefined behavior
p15657
aVIf you want to print an address, you have to use  and pass a
p15658
as(dp15659
g15
V34509
p15660
stp15661
a((dp15662
g2
(lp15663
VIt works because the Standard says that's how it should happen
p15664
aVI did some tests with GCC, and it turns out for virtual functions, GCC stores the virtual table offset of the function in question, in bytes
p15665
aVThat program outputs  - the byte offsets of the virtual table entries of those two functions
p15666
aVIt follows the Itanium C++ ABI, which specifies that
p15667
as(dp15668
g15
V34509
p15669
stp15670
a((dp15671
g2
(lp15672
VSounds like you have the same header guard
p15673
aVCheck that at the start of your header, you don't have something like this
p15674
aVin both files
p15675
aVThose guards have to have unique names in every header file they guard from multiple inclusions
p15676
aVOtherwise, they will prevent inclusion of content into other headers
p15677
as(dp15678
g15
V34509
p15679
stp15680
a((dp15681
g2
(lp15682
VWell, you don't initialize this member:
p15683
aVWhat you do instead is creating a local array inside the constructor, and initialize that
p15684
aVThat can only fail
p15685
aVChange the member to this
p15686
aVAnd in the constructor, copy your local array into the member (and better remove the  prefix from the local array's name, so it's not confused with the actual member array)
p15687
aVAlternatively, you can assign each element separately, if you like huge pains :) Then you call the array of member pointers using another syntax
p15688
aVOf course, somewhere you need to tell it on which object it's invoked on
p15689
as(dp15690
g15
V34509
p15691
stp15692
a((dp15693
g2
(lp15694
VI tried this, and it fails because the keys of the map need to be comparable (with , thus there needs to be an  defined)
p15695
aV's comparison operators are defined in the header
p15696
aVHaving included that, this code works fine:
p15697
as(dp15698
g15
V34509
p15699
stp15700
a((dp15701
g2
(lp15702
V (which is what  returns) does not overload
p15703
aVYou can use it with , which has special treating for it (not using  would make  copy the provided function object)
p15704
aVBut  returns the function object it invokes the stuff on
p15705
aVSo just do this
p15706
aVIt will call the stuff on the copied , and return the function object as it's after the last invocation
p15707
aVJust to tell you where you might use , because you seem to misuse it
p15708
aVImagine a template that takes its parameter by value, and calls another function:
p15709
aVIf you now want to call it with a variable, it will copy it
p15710
aVOften, that's a reasonable decision, for example if you want to pass data to a thread as start parameters, you could copy it out of your local function into the thread object
p15711
aVBut sometimes, you could want not to copy it, but to actually pass a reference
p15712
aVThis is where  helps
p15713
aVThe following actually does what we expect, and outputs :
p15714
aVFor binding arguments, a copy is a good default
p15715
aVIt also easily makes arrays and functions decay to pointers (accepting by reference would make  be possibly an array/function-type, and would cause some nasty problems)
p15716
as(dp15717
g15
V34509
p15718
stp15719
a((dp15720
g2
(lp15721
VIn this case, casting with  to  is guaranteed to work and will point to the first  data member, because your type is a so-called POD struct (roughly, a C struct)
p15722
aVQuote of the Standard (from , if you wanna look)
p15723
aVA pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa
p15724
aV[Note: There might therefore be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment
p15725
ag4885
aVSo the following works
p15726
as(dp15727
g15
V34509
p15728
stp15729
a((dp15730
g2
(lp15731
VAlso for the first call of g(1), I should have one call of f(char) followed by two calls of f(int) and for the second call I should get three calls of f(char)
p15732
aVThis is not the expected result with a Standard compliant compiler
p15733
aVSince both time you call it with a fundamental type, you will not get name lookup at the instantiation context for the function call
p15734
aVName lookup at instantiation context only happens for argument dependent lookup (called lookup using associated namespaces)
p15735
aVBoth of  and  do not have argument dependent lookup, an thus all the function calls you do will call  after you removed the  line
p15736
aVSince i understand you won't possibly just believe me, here is the Standard quote, out of :
p15737
aVFor a function call that depends on a template parameter, if the function name is an unqualified-id but not a template-id, the candidate functions are found using the usual lookup rules (3
p15738
ag2670
aV1, 3
p15739
ag2670
aV2) except that:
p15740
aVFor the part of the lookup using unqualified name lookup (3
p15741
ag2670
aV1), only function declarations with external linkage from the template definition context are found
p15742
aVFor the part of the lookup using associated namespaces (3
p15743
ag2670
aV2), only function declarations with external linkage found in either the template definition context or the template instantiation context are found
p15744
aVNote that the article uses a defective example of the Standard (at ) (and note that examples are non-normative: They can't change or state rules
p15745
aVTheir purpose entirely is illustrative)
p15746
aVThe defect has been fixed and is incorporated into the upcoming Standard
p15747
aVSee this defect report
p15748
aVAs you see, you will have to change from  /  to some user defined type (enums or classes) too see the effect of lookup in instantiation context
p15749
aVRead this answer Order affects visibility for more information
p15750
as(dp15751
g15
V34509
p15752
stp15753
a((dp15754
g2
(lp15755
VTwo pointers can be compared with using the comparison function objects ,   etc
p15756
aVOtherwise, using blanket  etc, this is only possible if the pointers point to elements of the same array object or one past the end
p15757
aVOtherwise, results are unspecified
p15758
aVin C++03
p15759
aVFor templates , , , and , the specializations for any
p15760
aVpointer type yield a total order, even if the built-in operators , , ,  do not
p15761
aVNo need to explicitly specialize and manually casting to : That would lower the portability even, since the mapping of  from pointers to integers is implementation defined and is not required to yield any order
p15762
aVEdit: For a more detailed answer, see this one
p15763
as(dp15764
g15
V34509
p15765
stp15766
a((dp15767
g2
(lp15768
VIt's worth pointing out that you don't need a
p15769
aVYou can just do it like the following
p15770
aVIt's a style question whether you prefer
p15771
aVWithout it, if you want to refer to the enumeration type, you need to use
p15772
aVWith it, you can just say
p15773
aVBoth ways have their pro and cons
p15774
aVThe one is more wordy, but keeps type identifiers into the tag-namespace where they won't conflict with ordinary identifiers (think of  and the  function: these don't conflict either), and where you immediately see that it's a type
p15775
aVThe other is shorter, but brings type identifiers into the ordinary namespace
p15776
as(dp15777
g15
V34509
p15778
stp15779
a((dp15780
g2
(lp15781
VWhy do you want to do that
p15782
aVDo you want those values as return values
p15783
aVI would introduce a struct for that, according to the meaning of the values the struct would get a suitable name
p15784
aVOtherwise, such variables are for managing local state in the function while it is activated
p15785
aVThey don't have any meaning or life anymore after the function terminated
p15786
as(dp15787
g15
V34509
p15788
stp15789
a((dp15790
g2
(lp15791
VWhether or not the mere fact of dereferencing a null pointer already results in undefined behavior is currently a gray zone in the Standard, unfortunately
p15792
aVWhat is certain is that reading a value out of the result of dereferencing a pointer is undefined behavior
p15793
aVThat it is undefined behavior is stated by various notes throughout the Standard
p15794
aVBut notes are not normative: They could say anything, but they will never be able to state any rules
p15795
aVTheir purpose is entirely informative
p15796
aVThat calling a member function on a null pointer formally is undefined behavior too
p15797
aVThe formal problem with merely dereferencing a null pointer is that determining the identity of the resulting lvalue expression is not possible: Each such expression that results from dereferencing a pointer must unambiguously refer to an object or a function when that expression is evaluated
p15798
aVIf you dereference a null pointer, you don't have an object or function that this lvalue identifies
p15799
aVThis is the argument the Standard uses to forbid null-references
p15800
aVAnother problem that adds to the confusion is that the semantics of the  operator make part of this misery well defined
p15801
aVIt says that if it was given an lvalue that resulted from dereferencing a null pointer, the result is throwing a  exception
p15802
aVAlthough, this is a limited area where there exist an exception (no pun) to the above problem of finding an identity
p15803
aVOther cases exist where similar exception to undefined behavior is made (although much less subtle and with a reference on the affected sections)
p15804
aVThe committee discussed to solve this problem globally, by defining a kind of lvalue that does not have an object or function identity: The so called empty lvalue
p15805
aVThat concept, however, still had problems, and they decided not to adopt it
p15806
aVNow, practically, you will not encounter a crash when merely dereferencing a null pointer
p15807
aVThe problem of identifying an object or function for an lvalue seems to be entirely language theoretical
p15808
aVWhat is problematic is when you try to read a value out of the result of dereference
p15809
aVThe following case will almost certainly crash, because it tries to read an integer from an address which is most probably not mapped by the affected process
p15810
aVThere are few cases where reading out of such an expression probably won't cause a crash
p15811
aVOne is when you dereference an array pointer:
p15812
aVSince reading from an array just returns its address using a element pointer type, this will most probably just make a null pointer (but as you dereference a null pointer before, this still is undefined behavior formally)
p15813
aVAnother case is dereferencing of function null pointers
p15814
aVHere too, reading a function lvalue just give you its address but using a function pointer type:
p15815
aVAswell as the other cases, this is undefined behavior too, of course, but will probably not result in a crash
p15816
aVLike the above cases, just calling a non-virtual member function on a null pointer isn't practically problematic either, most probably - even though it formally is undefined behavior
p15817
aVCalling the function will jump to the functions address, and don't need to read any data
p15818
aVAs soon as you would try to read a nonstatic data-member, the same problem occurs as when reading out of a normal null pointer
p15819
aVSome people place an
p15820
aVIn front of some member function bodies in case they accidentally called a function on a null pointer
p15821
aVThis may be a good idea when there are often cases where such functions are mistakenly called on null pointers, to catch errors early
p15822
aVBut from a formal point of view,  can never be a null pointer in a member function
p15823
as(dp15824
g15
V34509
p15825
stp15826
a((dp15827
g2
(lp15828
VWithin the same compilation unit, the C++ standard says that static initialization order is well defined -- it's the order of the declarations of the static objects
p15829
aVIn your shown code you have no declaration of a static data member
p15830
aVYou have a declaration of a typedef-name
p15831
aVThese have nothing to do with that, and don't influence any order
p15832
aVYou probably think along this way:
p15833
aVIf i make that typedef declaration, it will instantiate , and thus instantiate its static data member declaration first
p15834
aVThe problem is, that line does not cause an instantiation of
p15835
aVFor that to happen, you would need an explicit instantiation or manage to make it instantiate it implicitly (creating an object of  for example, or using it as a nested name specifier as in  and explicitly referencing the static member - otherwise, creation of it is omitted)
p15836
aVBut there is a much deeper problem
p15837
aVThe order is not the declaration of the static data-members
p15838
aVThe order is their definition
p15839
aVConsider the following
p15840
aVIn this code, b is created before a, even though a is declared before b
p15841
aVThe following code prints :
p15842
aVBut the following code prints nothing, unless you comment in the line in
p15843
aVI'm not actually sure what the correct output for this second snippet is
p15844
aVReading the Standard, i can't determine an order
p15845
aVIt says at  "Point of Instantiation":
p15846
aVFor a function template specialization, a member function template specialization, or a specialization for a member function or static data member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization [
p15847
aVOtherwise, the point of instantiation for such a specialization immediately follows the namespace scope declaration or definition that refers to the specialization
p15848
aVThe point of instantiation of their definitions both appear immediately after the definition of
p15849
aVWhich definition is instantiated before the other definition seems to be left unspecified
p15850
aVIf anyone knows the answer and khow other compilers behave (GCC prints  but with the order of the expressions in  swapped, prints ), please let me know in the comment
p15851
aVFor details, see this answer about static object's lifetime
p15852
as(dp15853
g15
V34509
p15854
stp15855
a((dp15856
g2
(lp15857
VIt's said to illustrate that pointers merely store addresses, and that addresses may be thought as numbers, much like integers
p15858
aVBut usually addresses have a structure (like, page number, offset within page, etc)
p15859
aVYou should not take that by word
p15860
aVAn integer literally stores a number, which you can add, subtract etc
p15861
aVBut which you cannot use as a pointer
p15862
aVAn integer is an integer, and a pointer is a pointer
p15863
aVThey serve different purposes
p15864
aVSometimes, a cast from a pointer to an integer may be necessary (for whatever purposes - maybe in a OS kernel to do some address arithmetic)
p15865
aVThen you may cast the pointer to such an integer type, previously figuring out whether your compiler guarantees correct sizes and preserves values
p15866
aVBut if you want to dereference, you have to cast back to a pointer type
p15867
as(dp15868
g15
V34509
p15869
stp15870
a((dp15871
g2
(lp15872
VIt is compiler dependent and may differ between enums
p15873
aVThe following are the semantics
p15874
aVNote that "some integer type" in C99 may also include extended integer types (which the implementation, however, has to document, if it provides them)
p15875
aVThe type of the enumeration is some type that can store the value of any enumerator ( and  in this case)
p15876
aVI don't think there are any penalties in using enumerations
p15877
aVEnumerators are integral constant expressions too (so you may use it to initialize static or file scope variables, for example), and i prefer them to macros whenever possible
p15878
aVEnumerators don't need any runtime memory
p15879
aVOnly when you create a variable of the enumeration type, you may use runtime memory
p15880
aVJust think of enumerators as compile time constants
p15881
aVI would just use a type that can store the enumerator values (i should know the rough range of values before-hand), cast to it, and send it over the network
p15882
aVPreferably the type should be some fixed-width one, like , so it doesn't come to conflicts when different machines are involved
p15883
aVOr i would print the number, and scan it on the other side, which gets rid of some of these problems
p15884
aVResponse to Edit
p15885
aVWell, the compiler is not required to use any size
p15886
aVAn easy thing to see is that the sign of the values matter - unsigned types can have significant performance boost in some calculations
p15887
aVThe following is the behavior of GCC  on my box
p15888
aVBut if you assign a , then GCC choses to use  as the type that  is compatible with
p15889
aVUsing the option  of GCC, that makes it use the smallest type still fitting all the values
p15890
as(dp15891
g15
V34509
p15892
stp15893
a((dp15894
g2
(lp15895
VThe code is playing evil pointer games, without luck
p15896
aVYou are passing a pointer having type  to a function that wants a pointer having type
p15897
aVThe pointer you pass has as value the "base address" of the array
p15898
aVSo, when you dereference the , it thinks at that address it gets an , even though what it looks at is an  object
p15899
aVAnd it writes the address returned from  into that memory cell
p15900
aVBack in main, you print out that cell
p15901
aVNote that it is the value of the array's first element, not the address of the array's first element
p15902
aVSo what is printed is the integer value interpretation of the address you wrote in the called function
p15903
aVWhat you do is undefined behavior: The function wants a , so you have to give it an ,
p15904
aVHere is how i think you view the matter
p15905
aVYou hear someone say that an array name is a constant pointer to its first element
p15906
aVYou take the address of that pointer, cast away any const
p15907
aVYou happily write some other address into the pointer, and hope that it doesn't crash
p15908
aVYou use the array again, expecting it "overlays" now the uninitialized memory region that malloc created
p15909
aVBut that view is flawed
p15910
aVThe first point is flawed the most, because an array name is not a constant pointer
p15911
aVIf the first point were correct, your snippet would make a lot more sense, actually
p15912
aVBut an array name will generate an address value that refers to its first element when you use it in an expression, except in very few cases (sizeof, address-of)
p15913
aVBecause that address value is not generated when you use address-of, you will get a pointer to that array instead (which was exactly what you wrote with the address-of operator)
p15914
aVSince it makes sense that an array and the first element of it has the same address, the address of an array happens to equal to the address of its first element
p15915
aVSo what you actually did was writing into the first element, instead of writing into some pointer (that in reality isn't there)
p15916
aVResponse to Comment
p15917
aVConsider what happens when the type of the array matters in practice (out of these experiments)
p15918
aVYou have an array whose elements are arrays themselves
p15919
aVSo, by using  in an expression other than  and , you will get a pointer to the first element,
p15920
aVThis is crucial, because the following writes into an integer that's offset  bytes
p15921
aVIf  in that expression would give you an , then the compiler would have no idea where it should store the integer  correctly into, because any size information about the element type is lost
p15922
aVIt could surely store the size somewhere in memory, but where
p15923
aVIn the array, there is no space for that
p15924
aVAnd in addition,  couldn't be able to give you a compile time result anymore
p15925
as(dp15926
g15
V34509
p15927
stp15928
a((dp15929
g2
(lp15930
VThis returns a dangling reference, just like with the lvalue reference case
p15931
aVAfter the function returns, the temporary object will get destructed
p15932
aVYou should return  by value, like the following
p15933
aVNow, it's properly moving a temporary  object into the return value of the function
p15934
aVIf the compiler can, it will avoid the move altogether, by using RVO (return value optimization)
p15935
aVNow, you can do the following
p15936
aVAnd it will move construct the temporary into , or do RVO to omit doing a move or copy altogether
p15937
aVI recommend you to read BoostCon09 Rvalue References 101 which explains the matter, and how (N)RVO happens to interact with this
p15938
aVYour case of returning an rvalue reference would be a good idea in other occasions
p15939
aVImagine you have a  function which you often invoke on a temporary
p15940
aVIt's not optimal to make it return a const lvalue reference for rvalue temporaries
p15941
aVYou may implement it like this
p15942
aVNote that  in this case is not optional, because  is neither a local automatic nor a temporary rvalue
p15943
aVNow, the ref-qualifier  says that the second function is invoked on rvalue temporaries, making the following move, instead of copy
p15944
as(dp15945
g15
V34509
p15946
stp15947
a((dp15948
g2
(lp15949
VYour code is ill-formed with regard to C++03
p15950
aVYou can not ever construct a const (or volatile) qualified function type
p15951
aVWhenever you do, your program becomes ill-formed
p15952
aVThis rule has been changed for C++1x, to make the compiler ignore the  /
p15953
aVC++ compilers will usually already implement this rule even in C++03 mode
p15954
aVThus, the following two will define the same function twice, and results in a compilation error
p15955
aVHere is the proof of my claim
p15956
aVC++03,
p15957
aVA cv-qualifier-seq shall only be part of the function type for a nonstatic member function, the function type to which a pointer to member refers, or the top-level function type of a function typedef declaration
p15958
aVThe effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top of the function type, i
p15959
ag1992
aV, it does not create a cv-qualified function type
p15960
aVIn fact, if at any time in the determination of a type a cv-qualified function type is formed, the program is ill-formed
p15961
aVHere is that text for C++1x,  n2914:
p15962
aVA cv-quali\ufb01er-seq shall only be part of the function type for a non-static member function, the function type to which a pointer to member refers, or the top-level function type of a function typedef declaration
p15963
aVThe e\ufb00ect of a cv-quali\ufb01er-seq in a function declarator is not the same as adding cv-quali\ufb01cation on top of the function type
p15964
aVIn the latter case, the cv-quali\ufb01ers are ignored
p15965
aVThe above says that the below is valid, though, and creates the function type for a function that can declare a const member function
p15966
as(dp15967
g15
V34509
p15968
stp15969
a((dp15970
g2
(lp15971
VI put the error through , it says that the mangled name stands for
p15972
aVThis suggests that you call  somewhere and forgot to link against  or you even forgot to define
p15973
as(dp15974
g15
V34509
p15975
stp15976
a((dp15977
g2
(lp15978
VYou may use  in the following way:
p15979
aVI don't think there is such a way with the Standard C++ Library
p15980
as(dp15981
g15
V34509
p15982
stp15983
a((dp15984
g2
(lp15985
VThis is equivalent to
p15986
aVAnd similar to how
p15987
aVis equivalent to the following
p15988
aVSo the parameter is a function pointer
p15989
aVFunctions as parameters are function pointers
p15990
aVAnd arrays as parameters are pointer to their element type
p15991
aVIt is not similar to
p15992
aVWhich is a reference to a function, but only rarely used: It cannot be used for function pointer arguments, while a function pointer parameter can be used for function, function references and function pointer arguments
p15993
as(dp15994
g15
V34509
p15995
stp15996
a((dp15997
g2
(lp15998
VIs it possible to do the same as for the structure (i
p15999
ag1992
aVdeclare and initialise an array of classes at the same time)
p16000
aVNot unless you create a suitable constructor:
p16001
aVOr you make all members public and omit the constructor, in which case you can use the same initialization syntax as for the struct
p16002
aVBut i think that's not what you intended
p16003
aVAm I correct to think that it is not possible to declare and initialise  or  at the same time
p16004
aVNo it's not possible with current C++
p16005
aVYou can however use libraries that make this possible
p16006
aVI recommend Boost
p16007
aVAssign for that
p16008
aVFor that, however, your class has to have a constructor, and likewise your struct too - Or you need to create some kind of factory function
p16009
aVIf you want to keep the struct initializable with the brace enclosed initializer list in other cases
p16010
as(dp16011
g15
V34509
p16012
stp16013
a((dp16014
g2
(lp16015
VThis really sounds like a case for Herb Sutter's excellent article The String Formatters of Manor Farm
p16016
aVFor the record: I myself use , build the string up and pass
p16017
as(dp16018
g15
V34509
p16019
stp16020
a((dp16021
g2
(lp16022
VI would say it's OK if it increases readability
p16023
aVJudge yourself
p16024
aVJust my two cents: Specializing  isn't really the right way to do this
p16025
aVConsider this situation:
p16026
aVThis won't find  if you haven't done  or something similar
p16027
aVYou should rather declare your own swap in 's namespace:
p16028
aVNow, this will work also in the above case, because argument dependent lookup searches in the namespace of the class
p16029
aVCode swapping generic things where the type isn't known should do it like this:
p16030
aVRegardless of the type, this will use the best matching swap, and fall-back to  if there wasn't a better matching one in the namespaces of
p16031
aVHard-coding the call to  will cut too short on types that don't specialize  but rather decide to provide their own swap in their namespace
p16032
aVThis is superious in another way: Imagine  is a template
p16033
aVYou cannot specialize  in this case
p16034
aVBut just defining your own swap, that's perfectly fine
p16035
aVThis is the way how the swap for  and other classes is implemented too
p16036
as(dp16037
g15
V34509
p16038
stp16039
a((dp16040
g2
(lp16041
VYou would not dereference, but subscript, like with other pointers
p16042
aVThe first  is probably a little confusing, since it suggests that you are handling with an array
p16043
aVTo make clear that you are working with a pointer, i would use dereferencing
p16044
aVThe  dereferences the array pointer and yields the array, and the following subscript operation addresses and dereferences the item you want
p16045
as(dp16046
g15
V34509
p16047
stp16048
a((dp16049
g2
(lp16050
VYou can use a flexible array member
p16051
aVSo that you can then allocate the right amount of space
p16052
aVLater, you can free, and allocate another chunk of memory and make a pointer to  point to it, at which time you will have more / less elements in the flexible array member ()
p16053
aVNote that you will have to save the length somewhere, too
p16054
aVIn Pre-C99 times, there isn't a flexible array member:  is simply regarded as an array with incomplete type, and the compiler would moan about that
p16055
aVHere i recommend you two possible ways out there
p16056
aVUsing a pointer:  and make it point to the allocated memory
p16057
aVThis won't be as convenient as using the embedded array, because you will possibly need to have two allocations: One for the struct, and one for the memory pointed to by the pointer
p16058
aVYou can also have the struct allocated on the stack instead, if the situation in your program allows this
p16059
aVUsing a  instead, but treat it as if it were bigger, so that it overlays the whole allocated object
p16060
aVThis is formally undefined behavior, but is a common technique, so it's probably safe to use with your compiler
p16061
as(dp16062
g15
V34509
p16063
stp16064
a((dp16065
g2
(lp16066
VWhat he means is that you cannot return the struct by-value in the header, because for that, the struct must be completely declared
p16067
aVBut that happens in the C file (the declaration that makes  a complete type is "hidden" in the C file, and not exposed into the header), in his example
p16068
aVThe following declares only an incomplete type, if that's the first declaration of the struct
p16069
aVThen, you can declare the function
p16070
aVBut you cannot define the function, because you cannot create a variable of that type, and much less so return it (its size is not known)
p16071
aVThe error happens because "x" is still incomplete
p16072
aVNow, if you only include the header with the incomplete declaration in it, then you cannot call that function, because the expression of the function call would yield an incomplete type, which is forbidden to happen
p16073
aVIf you were to provide a declaration of the complete type  in between, it would be valid
p16074
aVThis would apply to the way using  too: They both name the same, (possibly incomplete) type
p16075
aVOne time using an ordinary identifier , and another time using a tag
p16076
as(dp16077
g15
V34509
p16078
stp16079
a((dp16080
g2
(lp16081
VFormally, when comparing conversion sequences, lvalue transformations are ignored
p16082
aVConversions are grouped into several categories, like qualification adjustment ( -> ), lvalue transformation ( -> ,  -> ), and others
p16083
aVThe only difference between your two candidates is an lvalue transformation
p16084
aVString literals are arrays that convert to pointers
p16085
aVThe first candidate accepts the array by reference, and thus won't need an lvalue transformation
p16086
aVThe second candidate requires an lvalue transformation
p16087
aVSo, if there are two candidates that both function template specializations are equally viable by looking only at the conversions, then the rule is that the more specialized one is chosen by doing partial ordering of the two
p16088
aVLet's compare the two by looking at their signature of their function parameter list
p16089
aVIf we choose some unique type  for the first parameter list and try to match against the second parameter list, we are matching  against
p16090
aVThis will fail, since  is not a pointer
p16091
aVThus, the second is at least as specialized as the first
p16092
aVIf we do the other way around, we match  against
p16093
aVThe reference is dropped and toplevel qualifiers are ignored, and the remaining  becomes
p16094
aVThis is an exact match for the purpose of partial ordering, and thus deduction of the transformed parameter list of the second against the first candidate succeeds
p16095
aVSince the other direction (against the second) didn't succeed, the second candidate is more specialized than the first - and in consequence, overload resolution will prefer the second, if there would otherwise be an ambiguity
p16096
aVAt :
p16097
aVStandard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if [
p16098
aVS1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form
p16099
aVdefined by 13
p16100
ag1037
ag1037
ag2790
aV1, excluding any Lvalue Transformation; the identity conversion sequence is considered to be a subsequence of any non-identity conversion sequence) or, if not that [
p16101
aVThen
p16102
aVlet ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F
p16103
aV13
p16104
ag1037
ag1037
aV1 defines the implicit conversion sequences and 13
p16105
ag1037
ag1037
aV2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another
p16106
aVGiven these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then [
p16107
aVF1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14
p16108
ag1014
ag1014
aV2, or, if not that, [
p16109
aVFinally, here is the table of implicit conversions that may participate in an standard conversion sequence at
p16110
as(dp16111
g15
V34509
p16112
stp16113
a((dp16114
g2
(lp16115
VAn example I use very often in C code is:
p16116
aVIt involves pointers and structures
p16117
aVSurely,  frees you from having to use that idiom by saying  instead in C++
p16118
as(dp16119
g15
V34509
p16120
stp16121
a((dp16122
g2
(lp16123
VIt's not possible
p16124
aVIf you have a template that behaves that way, it violates the ODR and / or other rules, such as that a specialization should be declared before it would be instantiated
p16125
aVSo you can't just put a specialization that would somehow change a typedef member to make it resolve to a different type for all following references
p16126
aVRemember that  references a class if  is a class template
p16127
aVIf the class's typedef member is defined to be one type at one point in the program, and another type at another point, then something must have been gone wrong
p16128
aVHere are various Standard quotes that concern this
p16129
aVA specialization for a function template, a member function template, or of a member function or static data member of a class template may have multiple points of instantiations within a translation unit
p16130
aVA specialization for a class template has at most one point of instantiation within a translation unit
p16131
aVA specialization for any template may have points of instantiation in multiple translation units
p16132
aVIf two different points of instantiation give a template specialization different meanings according to the one definition rule (3
p16133
aV2), the program is ill-formed, no diagnostic required
p16134
aVIf a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required
p16135
aV(Various "noise" skipped)
p16136
ag7695
aVVarious entities that may be defined multiple in the whole program
p16137
aVGiven such an entity named D defined in more than one translation unit, then
p16138
aVeach definition of D shall consist of the same sequence of tokens;
p16139
aVin each definition of D, corresponding names, looked up according to 3
p16140
aV4, shall refer to an entity defined within the definition of D, or shall refer to the same entity, after overload resolution (13
p16141
aV3) and after matching of partial template specialization (14
p16142
ag14557
aV3)
p16143
aVIf D is a template, and is defined in more than one translation unit, then the last four
p16144
aVrequirements from the list above shall apply to names from the template\u2019s enclosing scope used in the template definition (14
p16145
ag488
aV3), and also to dependent names at the point of instantiation (14
p16146
ag488
aV2)
p16147
aVIf the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D
p16148
aVIf the definitions of D do not satisfy these requirements, then the behavior is undefined
p16149
as(dp16150
g15
V34509
p16151
stp16152
a((dp16153
g2
(lp16154
VIf you compare  with  then here are a couple of things
p16155
aVNo tentative definitions in C++
p16156
aVint[] and int[N] not compatible (no compatible types in C++)
p16157
aVNo K&R; function definition style
p16158
aVNested struct has class-scope in C++
p16159
aVNo default int
p16160
aVC99 adds a whole lot of other cases
p16161
aVNo special handling of declaration specifiers in array dimensions of parameters
p16162
aVNo variable length arrays
p16163
aVNo flexible array member
p16164
aVNo restrict qualifier for helping aliasing analysis
p16165
as(dp16166
g15
V34509
p16167
stp16168
a((dp16169
g2
(lp16170
VI thought that C++ allows non-const to const conversion in function parameters, such as:
p16171
aVYou are trying to do the exact opposite: Const to non-const
p16172
aVCalling a non-const member function, the compiler will bind the expression (which is a  to a  for binding the  pointer)
p16173
aVIt thus will drop const - not allowed because it would call a non-const function on a const object
p16174
aVWell that code is a whole other thing
p16175
aVIt declares a function (constructor) two times, with the only difference being that one time the parameter is const, and another time it isn't
p16176
aVThe type of the function is the same both times, and so they don't conflict (the  parameter will only have an impact within the function body locally - it won't make any difference to the caller)
p16177
aVIn addition, this code doesn't contain any call (assuming that the first block is within some function)
p16178
aVIf you wonder: If the above two versions are identical - why isn't the below
p16179
aVThen this is because the below contains one other level of indirection: Below, the reference itself (the top level) is not const (you can't put  on a reference itself directly), but the type referenced is const
p16180
aVAt this time, const is not ignored in determining the type of the function
p16181
as(dp16182
g15
V34509
p16183
stp16184
a((dp16185
g2
(lp16186
VThere is another option, which uses inheritance and which works like the following
p16187
aVFor the last two arguments, it uses a class that inherits virtually from a class that has two member templates, that can be used to generate the needed types
p16188
aVBecause the inheritance is virtual, the typedefs it declares are shared among the inheritance as seen below
p16189
aVNow, have a default argument that you use, which has typedefs for the default arguments you want provide
p16190
aVThe member templates will be parameterized by the key and value types
p16191
aVNow,  will derive from all the template arguments
p16192
aVWhere a derived class of  hides a member from the base, that member of the derived class is dominant over the member of the base, and will be used, even though the base-class member can be reached by other path in the inheritance tree
p16193
aVNote that you don't pay for the virtual inheritance, because you never create an object of type
p16194
aVYou only use virtual inheritance to make use of the dominance rule
p16195
aVBecause we potentially derive from the same class more than once, we use a class template : Inheriting the same class directly twice is forbidden
p16196
aVBut inheriting it indirectly is allowed
p16197
aVYou can now use this all like the following:
p16198
as(dp16199
g15
V34509
p16200
stp16201
a((dp16202
g2
(lp16203
VIf you compile using the IDE, look for some button like "add file to project" or something like this, to add the  file to your project, so that when you build it, the IDE will put the translated result to the linker and all functions are resolved
p16204
aVCurrently, it looks like you don't tell the IDE about that cpp file, and so that function definition is never considered
p16205
as(dp16206
g15
V34509
p16207
stp16208
a((dp16209
g2
(lp16210
VTo summarize: Yes, that is valid in C, although being illegal in C++
p16211
aVThe latter contains this note which explains the difference
p16212
aVChange: In C++, types may not be defined in return or parameter types
p16213
aVIn C, these type definitions are allowed
p16214
aVExample:
p16215
aVRationale: When comparing types in different compilation units, C++ relies on name equivalence when C relies on structural equivalence
p16216
aVRegarding parameter types: since the type defined in an parameter list would be in the scope of the function, the only legal calls in C++ would be from within the function itself
p16217
aVEffect on original feature: Deletion of semantically well-defined feature
p16218
aVDifficulty of converting: Semantic transformation
p16219
aVThe type definitions must be moved to file scope, or in header files
p16220
aVHow widely used: Seldom
p16221
aVThis style of type definitions is seen as poor coding style
p16222
aVThe structural equivalence in C is done by the concept of "type compatibility"
p16223
aVThis allows C to treat many types as if they were identical, even though they are theoretically distinct - because they are declared in two different translation units
p16224
aVIn C++, this concept doesn't exist, because types have linkage and are matched to the same entity (i
p16225
aVe to allow member functions to link against each other)
p16226
aVNote that the above cited explanation is based off C89, which did not consider the tag name of a struct in determining type compatibility
p16227
aVIn a C89 draft, the relevant text reads as the following:
p16228
aVMoreover, two structure, union, or enumeration types declared in separate translation units are compatible if they have the same number of members, the same member names, and compatible member types; for two structures, the members shall be in the same order;
p16229
aVIn C99, type checking is more stricter: If one struct has a tag name, the other struct declaration has to have that same tag name
p16230
aVSo in your unnamed union type case, to declare a function in another TU that has a compatible type, you would need an unnamed union again if you want to have valid C99 code (without undefined behavior) - you cannot "trick" around, and use a named union in one TU, and an unnamed union in another TU
p16231
aVIt looks to me that this "trick" is valid for C89, though
p16232
ag1240
aVMoreover, two structure, union, or enumerated types declared in separate translation units are compatible if their tags and members satisfy the following requirements: If one is declared with a tag, the other shall be declared with the same tag
p16233
aVIf both are complete types, then the following additional requirements apply: there shall be a one-to-one correspondence between their members such that each pair of corresponding members are declared with compatible types, and such that if one member of a corresponding pair is declared with a name, the other member is declared with the same name
p16234
aVFor two structures, corresponding members shall be declared in the same order
p16235
aVThe way you want to do it doesn't work
p16236
aVCalling a function will convert the arguments to the type of the parameters as if by normal assignment
p16237
aVSo for this to work, you will have to have an argument that's compatible with the parameter type
p16238
aVFor two unions declared in the same translation unit, this means that their type must equal - that's the only way you can come up with a compatible type within the same translation unit
p16239
aVBut this cannot work, because the declaration of the unnamed union creates an unique new type - no way to "refer back" to it using another declaration
p16240
aVSo, to summarize - you have to give the union type a name
p16241
aVTo avoid creating a separate variable to pass the needed base argument, I would declare it outside the function, and create functions that give back an union you may pass over
p16242
aVNow, it can look like the following
p16243
as(dp16244
g15
V34509
p16245
stp16246
a((dp16247
g2
(lp16248
VThis is a valid pattern
p16249
aVIt's a known "valid" pattern, i would say
p16250
aVBoost has a class template called  that does exactly that, too
p16251
aVI am using the right terminology
p16252
aVWell, your template can be optimized to have fewer requirements on the type parameter
p16253
aVAs of now, your type  requires a copy constructor, unfortunately
p16254
aVLet's change the initializer to the following
p16255
aVThen, technically this kind of initialization is called , starting with C++03
p16256
aVIt's a little bit weird, since no kind of value is provided in the first place
p16257
aVWell, this kind of initialization looks like default initialization, but is intended to fill things with zero, but respecting any user defined constructor and executing that instead
p16258
aVTo summarize, what you did was to value initialize an object having type , then to copy that object to
p16259
aVWhat my version of above does it to value initialize the member directly
p16260
as(dp16261
g15
V34509
p16262
stp16263
a((dp16264
g2
(lp16265
VFirst, you have to use  and give  a return type, and then it depends on your needs
p16266
aVThe wrapper should call  on : Omit
p16267
aVThe wrapper should call  on a passed  object: Shift  in place of
p16268
aVThen,  returns some complicated synthesized type that will call the specified function
p16269
aVYou need a way to store it, which is where  comes handy
p16270
aVThis is how you can do it
p16271
aVThen it should work
p16272
as(dp16273
g15
V34509
p16274
stp16275
a((dp16276
g2
(lp16277
VThis can happen with multiple inheritance, if your layout looks like this:
p16278
aVThen the layout can be like this, for each object involved
p16279
aVThe last one is the complete object containing the first two ones as base-class sub-objects, and that you take the pointer of, and which will be converted to
p16280
aVNow since your vector contains , the compiler adjusts the pointer to point to the  sub-object, while when it would point to  or , it would start 0x38 (56) bytes earlier
p16281
as(dp16282
g15
V34509
p16283
stp16284
a((dp16285
g2
(lp16286
VIt fails because a template doesn't suppress the implicit declaration of a copy constructor
p16287
aVIt will serve as a simple converting constructor, which can be used to copy an object when overload resolution selects it
p16288
aVNow, you probably copied your matrix somewhere, which would use the implicitly defined copy constructor which does a flat copy
p16289
aVThen, the copied matrix and the copy would both in their destructor delete the same pointer
p16290
aVFurthermore, why is the extremely verbose  syntax required
p16291
aVBecause there are two templates involved: The Matrix, which is a class template, and the converting constructor template
p16292
aVEach template deserves its own template clause with its own parameters
p16293
aVYou should get rid of the  in your first line, by the way
p16294
aVSuch a thing does not appear when defining a template
p16295
aVThis is a poor solution, as it results in the wholesale duplication of the copy-constructor code
p16296
aVYou can define a member function template, which will do the work, and delegate from both the converting constructor and the copy constructor
p16297
aVThat way, the code is not duplicated
p16298
aVRichard made a good point in the comments which made me amend my answer
p16299
aVIf the candidate function generated from the template is a better match than the implicitly declared copy constructor, then the template "wins", and it will be called
p16300
aVHere are two common examples:
p16301
aVA copy constructor can have a non-const reference parameter too, if any of its members has
p16302
as(dp16303
g15
V34509
p16304
stp16305
a((dp16306
g2
(lp16307
VI think this can be caused by a few circumstances
p16308
aVis a  type (defined at )
p16309
aVIts declaration appears in the class template
p16310
aVBecause it's non-dependent, its name has to be resolved to a declaration at the time the member function is defined
p16311
aVI suspect that Visual C++ is not able to do this lookup, and errors out instead
p16312
aVAs someone else mentions, you can explicitly qualify the type-names in the member function definition
p16313
aVThe types are then dependent, and this will trigger the compiler's mechanism to delay name lookup until instantiation
p16314
as(dp16315
g15
V34509
p16316
stp16317
a((dp16318
g2
(lp16319
VYour array is an array of   arrays, each storing   pointers
p16320
aVThis means that when passing it to a function whose parameter is not a reference, it is converted to a
p16321
aVThe correct function parameter type is thus
p16322
aVRead further on this Pet peeve entry on Stackoverflow
p16323
as(dp16324
g15
V34509
p16325
stp16326
a((dp16327
g2
(lp16328
V is like  a function that returns an expression template that records that it has to call the given function
p16329
aVThese are designed to work together with phoenix and lambda, respectively
p16330
aVAs a result, they contain much more things
p16331
aVLike, the type they return overloads all possible operators so that their respective action can be recorded and executed later
p16332
aVis "just" a binder
p16333
aVIt will bind the function, and return a type that has the function call operator overloaded, and not much more
p16334
as(dp16335
g15
V34509
p16336
stp16337
a((dp16338
g2
(lp16339
VHow to indicate invalid data in the stream
p16340
aVThrow an exception
p16341
aVYou should set the  bit
p16342
aVIf the user of the stream wants exception to be thrown, he can configure the stream (using ), and the stream will throw accordingly
p16343
aVI would do it like this, then
p16344
aVWhat state should the stream be in if there is malformed data in the stream
p16345
aVFor malformed data that doesn't fit the format you want to read, you usually should set the  bit
p16346
aVFor internal stream specific errors, the  bit is used (such as, if there is no buffer connected to the stream)
p16347
aVShould any flags be reset before returning the reference for operator chaining
p16348
aVI haven't heard of such a thing
p16349
aVFor checking whether the stream is in a good state, you can use the  class
p16350
aVCreate an object of it, passing the stream and  (to tell it not to skip whitespace immediately)
p16351
aVThe sentry will evaluate to  if the ,  or  bit is set
p16352
as(dp16353
g15
V34509
p16354
stp16355
a((dp16356
g2
(lp16357
VWhat follows is a guess at your complete code
p16358
aVPlease post that, then we can help you better
p16359
aVIf by any chance your complete code looks like the following then you should change it
p16360
aVBecause the  macro will already be defined, in  the other header won't be included another time, and then at that time  and  would not be known yet
p16361
aVFix it by using a forward declaration where possible
p16362
aVFor example in :
p16363
aVIf the other header doesn't need the definition of  either, then use a forward declaration too, there
p16364
aVThe definition is not needed for (i
p16365
aVe a declaration suffices)
p16366
aVReferences and Pointers
p16367
aVFunction parameters in function declarations that aren't definitions
p16368
aVIt's needed if you want to access a member, want to get the  or want to defined a function that has a parameter type of ,  etc by-value
p16369
as(dp16370
g15
V34509
p16371
stp16372
a((dp16373
g2
(lp16374
VHow is it a keyword and an instance of a type
p16375
aVThis isn't surprising
p16376
aVBoth  and  are keywords and as literals they have a type (  )
p16377
aVis a pointer literal of type , and it's a prvalue (you cannot take the address of it using )
p16378
aVabout pointer conversion says that a prvalue of type  is a null pointer constant, and that an integral null pointer constant can be converted to
p16379
aVThe opposite direction is not allowed
p16380
aVThis allows overloading a function for both pointers and integers, and passing  to select the pointer version
p16381
aVPassing  or  would confusingly select the  version
p16382
aVA cast of  to an integral type needs a , and has the same semantics as a cast of  to an integral type (mapping implementation defined)
p16383
aVA  cannot convert  to any pointer type
p16384
aVRely on the implicit conversion if possible or use
p16385
aVThe Standard requires that  be
p16386
as(dp16387
g15
V34509
p16388
stp16389
a((dp16390
g2
(lp16391
VYou can use placement new
p16392
aVLike, set a maximal limit of size you want to allow  to have, like  bytes
p16393
aVThen, put an  buffer into your  class that's exactly that wide, and make sure it's aligned correctly ( has an attribute for that, and if you are lucky, microsoft has an attribute for that too)
p16394
aVYou may also go fairly safe if you use an union, and beside the char buffer put dummies of the types you want to stuff into it - that will ensure proper alignment too
p16395
aVThen, instead of using normal new, use placement new, like
p16396
aVThen, make the  member a pointer instead
p16397
aVYou also need to set a flag so you remember whether you have to call delete in the destructor, or leave the placement buffer alone with explicitly calling the destructor
p16398
aVThat's basically how  does it
p16399
aVIt, however, does a whole lot of other stuff to optimize allocation
p16400
aVIt uses its own vtable mechanism to optimize space, and of course is very well tested
p16401
aVOf course, this is not exactly easy to do
p16402
aVBut that seems to be the only thing to do about it
p16403
as(dp16404
g15
V34509
p16405
stp16406
a((dp16407
g2
(lp16408
VThe one definition rule allows that at
p16409
aVAll of the following can be put into headers, and be included multiple times into different translation units
p16410
aVThere can be more than one definition of a class type (clause 9), enumeration type (7
p16411
aV2), inline function with external linkage (7
p16412
ag2790
aV2), class template (clause 14), non-static function template (14
p16413
ag1014
aV5), static data member of a class template (14
p16414
ag1014
ag2790
aV3), member function of a class template (14
p16415
ag1014
ag2790
aV1), or template specialization for which some template parameters are not specified (14
p16416
aV7, 14
p16417
ag1014
aV4) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements
p16418
aVThe requirements essentially come down to that each definition must be the same
p16419
aVNote that if your enumeration type itself has no name, then it's not covered by that rule
p16420
aVEach definition of it in another translation unit defines a new enumeration type then, and doesn't clash with each other
p16421
aVPutting them into the header is a good place if it's supposed to be public
p16422
aVPutting them in the implementation file is a good place if it's supposed to be private to that single file
p16423
aVIn the latter case, either put them into an unnamed namespace, or make them unnamed (like it's the case with your enumeration example), so that it can't clash with another enumeration having the same name
p16424
as(dp16425
g15
V34509
p16426
stp16427
a((dp16428
g2
(lp16429
VYou can try including  instead, and using  (cast necessary to resolve to the  overload)
p16430
aVOtherwise, you will limit your function to  functions
p16431
aVThis would work like
p16432
aVAnother way is to make  a functor
p16433
aVThen you can pass  to , and because it's templated, it will accept any linkage
p16434
aVIt will also work with function objects, not only with function pointers
p16435
as(dp16436
g15
V34509
p16437
stp16438
a((dp16439
g2
(lp16440
VMake them reference parameters
p16441
aVIn C++, otherwise such plain parameters don't just reference objects, but they are those objects themselves
p16442
aVMaking them reference parameters will merely reference what is passed
p16443
aVIn this matter, C++ has the same semantics as C (in which you would use pointers for that)
p16444
as(dp16445
g15
V34509
p16446
stp16447
a((dp16448
g2
(lp16449
VYou want to make one single instance (called "specialization" in generic terms) of that template a friend
p16450
aVYou do it the following way
p16451
aVBecause the compiler knows from the parameter list that the template arguments are  and , you don't have to put those between , so they can be left empty
p16452
aVNote that you have to put a declaration of  above the  template, like the following:
p16453
as(dp16454
g15
V34509
p16455
stp16456
a((dp16457
g2
(lp16458
VThe type in the exception specification should be complete
p16459
aVTry including the   header which defines the exception class
p16460
aVThe set of headers you include seem to merely declare it, which isn't enough
p16461
as(dp16462
g15
V34509
p16463
stp16464
a((dp16465
g2
(lp16466
VThis appears in the context of the Handle-Body-Idiom, also called Pimpl idiom
p16467
aVIt allows one to keep the ABI (binary interface) of a library the same, by keeping actual data into another class object, which is merely referenced by a pointer held in an "handle" object, consisting of functions that delegate to that class "Body"
p16468
aVIt's also useful to enable constant time and exception safe swap of two objects
p16469
aVFor this, merely the pointer pointing to the body object has to be swapped
p16470
as(dp16471
g15
V34509
p16472
stp16473
a((dp16474
g2
(lp16475
VOthers pointed out you cannot do that cast (strongly speaking, casting to  anything using  is also not allowed - but silently tolerated by the compilers
p16476
aVis intended to be used here)
p16477
aVI usually do the following, which is doing a type pun, and is the recommended way to do it, according to the manpage of  (which is about doing the converse - casting from  to a function pointer)
p16478
aVTaking the address of the function pointer will give you a data-pointer: Pointer to a function pointer
p16479
aVThis will allow you to cast it to
p16480
aVIt pretends it's pointing to a  (instead of a function pointer), and then reads it
p16481
aVThe intermediary cast to  makes it equivalent to using two 's internally, and makes GCC be quiet about warning about a type pun
p16482
aVUsing C++ Style casts, this looks like a combination of two 's
p16483
aVI found that using this technique, GCC automatically notices when the left and the right types differ in size, and spit out a warning in that case
p16484
aVNeedless to say that like with all techniques that try to work around this limitation, this is undefined behavior
p16485
aVIf you have a function, and want a  pointing to it, you can do it all in one line, but that's a bit cumbersome on the syntax
p16486
aVHere it is how this can be done, but i don't recommend it if you have problems to read it - you may however use it inside a macro
p16487
aVThe trick to start being able to do the type but is to transform the temporary function pointer to an lvalue reference to const, which you can take the address of, and then proceed like above
p16488
aVUsing explicit C++ style  casts, this looks much more complicated, because you have to take the constness into account
p16489
aVThe C style cast automatically dealed with that
p16490
aVHave fun
p16491
as(dp16492
g15
V34509
p16493
stp16494
a((dp16495
g2
(lp16496
VTable 72 in C++03 about input iterator requirements says that the pre-condition of  is that  is de-referenceable
p16497
aVThe same pre-conditions holds for
p16498
aVNow,  says about
p16499
aVThe result of  on an end of stream is not defined
p16500
aVIn conclusion, the effects of  on an end-of-stream iterator are undefined
p16501
aVTable 72 in C++03 about input iterator requirements says that the pre-condition of  is that  is de-referenceable
p16502
aVThe same pre-conditions holds for
p16503
aVNow,  says about
p16504
aVThe result of  on an end of stream is not defined
p16505
aVIn conclusion, the effects of  on an end-of-stream iterator are undefined
p16506
aVNote that I think this conclusion makes behavior undefined only when you write or use an algorithm taking input iterators which exhibits that behavior, and then pass an istream iterator
p16507
aVFrom only using the istream iterator itself explicitly, without treating it as an input iterator and relying on its invariants, then i think the conclusion above isn't quite right (we may have a class that doesn't require that  is dereferenceable, for example)
p16508
aVBut looking at how istream iterator is described, an invocation of  after reaching the end of stream value results in undefined behavior either
p16509
aVfor it is defined as being equivalent to
p16510
aVWhere  is a pointer to the stream iterated over - and exposed into the Standard text for defining behavior and semantics "exposition only"
p16511
aVNow, the only implementation i can think of that makes this work, is using an end-of-stream iterator that stores as stream pointer a null pointer
p16512
aVBut  is defined as doing something having the effect of the following
p16513
aVNow, if you enter the end-of-stream state, and we would set  to a null pointer, then surely the effect of that would be undefined behavior
p16514
aVSo even if you use the istream iterator alone, there doesn't seem to be any guarantee that you may increment past the end-of-stream value
p16515
as(dp16516
g15
V34509
p16517
stp16518
a((dp16519
g2
(lp16520
VSome random situations where conversion functions are used and not used follow
p16521
aVFirst, note that conversion functions are never used to convert to the same class type or to a base class type
p16522
aVConversion during argument passing
p16523
aVConversion during argument passing will use the rules for copy initialization
p16524
aVThese rules just consider any conversion function, disregarding of whether converting to a reference or not
p16525
aVArgument passing is just one context of copy initialization
p16526
aVAnother is the "pure" form using the copy initialization syntax
p16527
aVConversion to reference
p16528
aVIn the conditional operator, conversion to a reference type is possible, if the type converted to is an lvalue
p16529
aVAnother conversion to reference is when you bind a reference, directly
p16530
aVConversion to function pointers
p16531
aVYou may have a conversion function to a function pointer or reference, and when a call is made, then it might be used
p16532
aVThis thing can actually become quite useful sometimes
p16533
aVConversion to non class types
p16534
aVThe implicit conversions that happen always and everywhere can use user defined conversions too
p16535
aVYou may define a conversion function that returns a boolean value
p16536
aV(The conversion to bool in this case can be made safer by the safe-bool idiom, to forbid conversions to other integer types
p16537
aVThe conversions are triggered anywhere where a built-in operator expects a certain type
p16538
aVConversions may get into the way, though
p16539
aVThe call can be ambiguous, because for the member, the second parameter needs a conversion, and for the built-in operator, the first needs a user defined conversion
p16540
aVThe other two parameters match perfectly respectively
p16541
aVThe call can be non-ambiguous in some cases ( needs be different from  then)
p16542
aVConversion function template
p16543
aVTemplates allow some nice things, but better be very cautious about them
p16544
aVThe following makes a type convertible to any pointer type (member pointers aren't seen as "pointer types")
p16545
as(dp16546
g15
V34509
p16547
stp16548
a((dp16549
g2
(lp16550
VIf it's really that temporary that costs you the time, then i would say there is nothing wrong with including it into your class as a member
p16551
aVBut note that this will possibly make your function thread-unsafe if used without proper synchronization - once again, this depends on the use of
p16552
aVI would, however, mark such a variable as
p16553
aVIf you read a class definition with a member being , you can immediately assume that it doesn't account for the value of its parent object
p16554
aVThis will also make it possible to use  as a mutable entity inside a const function - just like you could use it as a mutable entity if it was a local variable inside such a function
p16555
as(dp16556
g15
V34509
p16557
stp16558
a((dp16559
g2
(lp16560
VBy really pedantic rules, yes, your code needs a definition for that static integer
p16561
aVBut by practical rules, and what all compilers implement because that's how the rules of C++03 are intended - no, you don't need a definition
p16562
aVThe rules for such static constant integers are intended to allow you to omit the definition if the integer is used only in such situations where a value is immediately read, and if the static member can be used in constant expressions
p16563
aVIn your return statement, the value of the member is immediately read, so you can omit the definition of the static constant integer member if that's the only use of it
p16564
aVThe following situation needs a definition, however:
p16565
aVNo value is read here - but instead the address of it is taken
p16566
aVTherefore, the intent of the C++03 Standard is that you have to provide a definition for the member like the following in some implementation file
p16567
aVNote that the actual rules appearing in the C++03 Standard says that a definition is not required only where the variable is used where a constant expression is required
p16568
aVThat rule, however, if strictly applied, is too strict
p16569
aVIt would only allow you to omit a definition for situation like array-dimensions - but would require a definition in cases like a return statement
p16570
aVThe corresponding defect report is here
p16571
aVThe wording of C++0x has been updated to include that defect report resolution, and to allow your code as written
p16572
as(dp16573
g15
V34509
p16574
stp16575
a((dp16576
g2
(lp16577
VLooks like your situation is like this:
p16578
aVThe second call to f is ambiguous, because in looking up the name, it finds functions in two different base class scopes
p16579
aVIn this situation, the lookup is ambiguous - they don't overload each other
p16580
aVA fix would be to use a using declaration for each member name
p16581
aVLookup will find names in the scope of  and don't lookup further:
p16582
aVNow, the call would find two functions, do overload resolution, and find that the one taking  will fit
p16583
aVCarried over to your code, it would mean that you have to do something like the following
p16584
aVNow, the two names are in the same scope, and now they can overload each other
p16585
aVLookup will now stop at the controller class, not diving further into the two base-class branches
p16586
as(dp16587
g15
V34509
p16588
stp16589
a((dp16590
g2
(lp16591
VThe rule is the following
p16592
aVIf the compiler can do RVO, then it is allowed to do it, and no copy and no move is made
p16593
aVOtherwise, the appropriate constructor is taken
p16594
aVLike you say, the temporary is an rvalue, and thus the move constructor is selected, because of a rule in , which says that a rvalue reference binds to an rvalue better than an lvalue reference
p16595
aVIn deciding whether to use the move or the copy constructor, overload resolution will therefor prefer the move constructor
p16596
aVThe rule that the compiler is allowed to perform RVO is written at
p16597
as(dp16598
g15
V34509
p16599
stp16600
a((dp16601
g2
(lp16602
VYes you need
p16603
aVNote that all three lines do different things
p16604
aVThe first declares a class
p16605
aVThe second declares a template, and the third declares a typedef-name
p16606
aVIn declaring the typedef-name, you can use an elaborated type specifier like "class A" to name the class without having its name in scope (with some nasty pitfalls included) - but you cannot further collapse the template declaration with the typedef declaration
p16607
aVI would not worry about the three lines
p16608
aVIf it's necessary, i would just write them out :)
p16609
as(dp16610
g15
V34509
p16611
stp16612
a((dp16613
g2
(lp16614
VIt can have different reasons
p16615
aVConsider this code:
p16616
aVAt the time the constructor is instantiated (in the "
p16617
aVcpp" file),  is a completely defined type
p16618
aVBut at the time  is instantiated (in the "
p16619
aVh" file),  is not yet completely defined
p16620
as(dp16621
g15
V34509
p16622
stp16623
a((dp16624
g2
(lp16625
VThere are many other cases where you find that book diverge from the behavior of VC++
p16626
aVExamples are the  and  ambiguity tools and the binding of non-const references to rvalues
p16627
aVIn this case, of course the behavior of G++ is correct, as the book says
p16628
aVTry the following changes
p16629
aVThe next C++ Standard (C++0x) allows local types as template arguments
p16630
aVPlease note what the book means with giving a name to a type with typedef
p16631
aVThis does not apply to the following, because the name  does not name the enumeration type, but a pointer type to it
p16632
aVSo, when you use  or in your example , then you are not going safe
p16633
aVTechnically, that name is a pointer type to a type without linkage, which is not allowed as a template argument
p16634
aVNote that you may put  into an unnamed namespace to make the type local to the current translation unit, but still have the type acceptable as a type template argument
p16635
aVThat way, if you just want to have a "scratch" type for something like a function object, the struct won't clash with a struct defined in a different file
p16636
as(dp16637
g15
V34509
p16638
stp16639
a((dp16640
g2
(lp16641
VThe following is a definition of the static data member
p16642
aVIt has to occur only in one file that's compiled and then linked
p16643
aVIf you have multiple such definitions, it is as if you had multiple functions called
p16644
aVThey will clash and the linker will complain
p16645
aVI think you are mistaking static members with static applied to namespace scope variables
p16646
aVAt the namespace level, static gives the variable or reference internal linkage
p16647
aVBut at the class scope level (when applied to a member), it will become a static member - one that is bound to the class instead of each object separately
p16648
aVThat then has nothing to do with the C meaning of "static" anymore
p16649
as(dp16650
g15
V34509
p16651
stp16652
a((dp16653
g2
(lp16654
VSince the syntax of C is like the one of C++ in this matter, geordi could be interesting to you
p16655
aVIt is another good tool for teaching and learning those declarations (and other things related to C++ and sometimes, C too)
p16656
aVAs its page explains, it can do much more, including building a type for you
p16657
aVIf you know in principle how to declare things, but are unsure about just one thing, you may use parentheses:
p16658
aVIf you want to see how this looks like with an identifier in it, you may change the type of names, too
p16659
aVIf you build up a declaration, but you are unsure about the precedence of the operators, then geordi's precedence functions can help you out
p16660
as(dp16661
g15
V34509
p16662
stp16663
a((dp16664
g2
(lp16665
VAnother way could be to write a template that calls the function (using CRTP) and inherit from it
p16666
aVNote that the call has no performance lost: Since the member pointer is passed as a template parameter, the call can be inlined as usual
p16667
as(dp16668
g15
V34509
p16669
stp16670
a((dp16671
g2
(lp16672
VAn array contains the elements
p16673
aVA pointer points to them
p16674
aVThe first is a short form of saying
p16675
aVThat is, it is an array that contains all the characters
p16676
aVThe special initialization initializes it for you, and determines it size automatically
p16677
aVThe array elements are modifiable - you may overwrite characters in it
p16678
aVThe second form is a pointer, that just points to the characters
p16679
aVIt stores the characters not directly
p16680
aVSince the array is a string literal, you cannot take the pointer and write to where it points
p16681
aVThis code would probably crash on your box
p16682
aVBut it may do anything it likes, because its behavior is undefined
p16683
as(dp16684
g15
V34509
p16685
stp16686
a((dp16687
g2
(lp16688
VI would use
p16689
aVIf it does not make sense to you to have it comparable, and the only use of that would be to stuff it into the , you can use a functor
p16690
aVIf you however provide the operator independent (not using the functor) like above, then also provide , ,  and  to keep it consistent
p16691
as(dp16692
g15
V34509
p16693
stp16694
a((dp16695
g2
(lp16696
VC++0x comes with  which is a replacement for  which is going to be deprecated
p16697
aVIf you use  with an array type, it uses  to free it, and to provide  etc
p16698
aVIf you use it with a non-array type, it uses
p16699
aVThis needs partial template specialization like
p16700
aVAnother use (although a very questionable) is  in the standard library
p16701
aVThe bool specialization uses a space optimization to pack bools into individual bits
p16702
aVYet another use is with
p16703
aVIterators are required to define the nested typedefs ,  and others to the correct types (for a const iterator,  would usually be , for example) so algorithms may use them for their work
p16704
aVThe primary template uses type-members of the iterator type in turn
p16705
aVFor pointers, that of course doesn't work
p16706
aVThere is a partial specialization for them
p16707
as(dp16708
g15
V34509
p16709
stp16710
a((dp16711
g2
(lp16712
VSomething like
p16713
aVwon't work according to your specification, because  will skip leading whitespace
p16714
aVThe user can't just hit enter
p16715
aVHe first has to enter some text
p16716
aVIf he enters the following
p16717
aVThen the input is read into the double, up to , where it stops
p16718
aVwon't find anything wrong, and leaves  in the stream
p16719
aVOften, this is enough error handling, i think
p16720
aVBut if it's a requirement that you  want to actually repeat when the user enters something like above, then you need a bit more code
p16721
aVIf you want to test whether the whole input up to the newline is a number, then you should use , read into a string and then try to convert to a number
p16722
aVThe  function can use a stringstream to test the string
p16723
aVThe  will eat leading whitespace, and  will consume trailing whitespace
p16724
aVIf it hits to the end of the stream, it will signal
p16725
aVThis way, you can signal the error to the user immediately, instead of erroring out at the next time you try to read from
p16726
aVWrite a similar function that returns the double or pass the address of a double to `isnumber, so that it can write the result in case of a successful parse
p16727
aVIt's also worth to have a look at the various error flags and how they relate to , , , ,  and  which can be quite confusing:
p16728
aVThere is an  if the respective bit influences the result
p16729
aVis used when converting to  () while  is used for code doing
p16730
as(dp16731
g15
V34509
p16732
stp16733
a((dp16734
g2
(lp16735
VWell you search for things in  but never set it to anything (it's an empty string)
p16736
aVYou should read one whole line into
p16737
aVThen you can look out for the  and spaces etc
p16738
aVThe second problem is that you should use  as the type of comma, space1 and space2
p16739
aVThese keep the positions of the spaces and commas in the string: If the comma or space isn't found in input, then the find functions return , which is the highest value in a
p16740
aVBut this would overflow a
p16741
aVFor reliably assigning the position, you should thus change the type of these three variables to
p16742
aVThen instead of using  to say that you want to extract a substring until end just omit it: It has a default argument for that parameter which specifies
p16743
aVIf you really want to pass it, maybe because it improves readability for you, use  instead: It has the right type (), and won't need a conversion of  (with value ) to it
p16744
as(dp16745
g15
V34509
p16746
stp16747
a((dp16748
g2
(lp16749
VFirst, you should do it inside a function body
p16750
aVThen, the syntax of using the braces is illegal, because you assign them to a pointer, not to an array or struct
p16751
aVThat syntax is also only valid when initializing, not during assignment
p16752
aVThe code is probably using compound literals, and some programmer removed the necessary type name:
p16753
aVNote the parenthesized  i added
p16754
aVThat will tell GCC to create an unnamed array living for the lifetime of that function invocation, and assign the address of it to the  pointer
p16755
aVThis is not a cast in this case, but it's essential for this syntax to work and to create an array compound literal
p16756
aVThese compound literals, however, are a C99 feature, and don't work in every compiler
p16757
as(dp16758
g15
V34509
p16759
stp16760
a((dp16761
g2
(lp16762
VSince you manually cast the  to , the compiler will allow you to do that
p16763
aVIf you tried to initialize the variable  with a plain  without a cast, you would get a diagnostic
p16764
aVNote that the range of values an enumeration can store is not limited by the enumerators it contains
p16765
aVIt's the range of values of the smallest bitfield that can store all enumerator values of the enumeration
p16766
aVThat is, the range of your enumeration type is :
p16767
aVThe value  is thus still in range, and so the code is valid
p16768
aVHad you cast a , then the resulting value would be left unspecified by the C++ Standard
p16769
aVIn practice, the implementation has to chose an underlying integer type for the enumeration
p16770
aVThe smallest type it can choose is , but which is still able to at least store values ranging up to
p16771
aVBut as mentioned, the compiler is not required to convert a  to a value of , because it's outside the range of your enumeration
p16772
aVI figure i should post some explanation on the difference of "underlying type" and "range of enumeration values"
p16773
aVThe range of values for any type is the smallest and largest value of that type
p16774
aVThe underlying type of an enumeration must be able to store the value of any enumerator (of course) - and two enumerations that have the same underlying type are layout compatible (this allows some flexibility in case a type mismatch occurs)
p16775
aVSo while the underlying type is meant to fix the object representation (alignment and size), the values of the enumeration is defined as follows in
p16776
aVFor an enumeration where emin is the smallest enumerator and emax is the largest, the values of the enumeration are the values of the underlying type in the range bmin to bmax, where bmin and bmax are, respectively, the smallest and largest values of the smallest bit-field that can store emin and emax
p16777
aVIt is possible to define an enumeration that has values not defined by any of its enumerators
p16778
aV[Footnote:  On a two\u2019s-complement machine, bmax is the smallest value greater than or equal to eminemax of the form
p16779
aV2M\u22121; bmin is zero if emin is non-negative and bmin otherwise
p16780
as(dp16781
g15
V34509
p16782
stp16783
a((dp16784
g2
(lp16785
VChecking the template definition
p16786
aVA big difference of concepts to these manual solutions is that concepts allow the definition of a template to be type-checked without doing anything special
p16787
aVThe concept check library allows only the use of it to be type checked
p16788
aVExample:
p16789
aVYou may now sprinkle that template with concept checks and traits, but you will never get an error after writing that template - because the Standard allows the compiler to delay compiling the template until instantiation
p16790
aVFor checking, you have to write "archetype" classes, which contain exactly those operations that are required by the interface and then instantiate them artificially
p16791
aVReading the documentation of BCCL, i found it already includes the common archetypes like "default constructible"
p16792
aVBut if you write your own concepts, you will have to also provide your own archetypes, which isn't easy (you have to find exactly the minimal functionality a type has to provide)
p16793
aVFor example, if your archetype contains a , then the test of your template with that (incorrect) archetype will succeed, although the concepts don't require such an operator
p16794
aVThe rejected concepts proposal creates archetypes for you automatically, based on the requirements that were specified and that were implied (a pointer type  used in a parameter will imply the PointeeType requirement for , for example)
p16795
aVYou don't have to care about this stuff - except of course when your template definition contains a type error
p16796
aVChecking semantic requirements
p16797
aVConsider this code, using hypothetical concept checks
p16798
aVThe BCCL manual says that semantic requirements are not checked
p16799
aVOnly syntax requirement and types are checked
p16800
aVConsider a forward iterator: There exists the semantic requirement that you may use it in multi-pass algorithms
p16801
aVSyntax-checking only won't be able to test this requirement (think about what happens if a stream iterator accidentally would pass that check
p16802
aVIn the rejected proposal, you had to explicitly put  in front of concept definitions to make the compiler flag success after syntax-checking
p16803
aVIf  wasn't specified, then a type explicitly had to define a concept map to say it supports that concept
p16804
aVA stream iterator would thus never be taken to pass a ForwardIterator check
p16805
aVSyntax remapping
p16806
aVThis was another feature
p16807
aVA template such as
p16808
aVCan be used like the following, if the user would provide a concept map that teaches the compiler how to dereference an integer, and thus how an integer satisfies the InputIterator concept
p16809
aVThis is the benefit of a language-based solution, and cannot be solved by BCCL ever, i believe
p16810
aVConcept based Overloading
p16811
aVOn a quick read of BCCL, i can also not spot anything that allows this to happen
p16812
aVA concept matching failure seems to cause a hard compilation error
p16813
aVThe rejected proposal allows the following:
p16814
aVIf a type could be used with both templates, then the second template would be used, because it's more specialized:  refines the  concept
p16815
as(dp16816
g15
V34509
p16817
stp16818
a((dp16819
g2
(lp16820
VUsing raw  is a bit unwieldy to use
p16821
aVThe inner dimension (last 4) must be a compile time constant, in addition
p16822
aVYou also have to remember to delete the array once you are finished using it
p16823
aVIf that feels too "syntactic braindead", you can use typedef to prettify it
p16824
aVThat's called a rectangular 2-dimensional array, because all the rows (4 of them, which can be determined at runtime) have the same width (which must be known at compile time)
p16825
aVAlternatively, use , with which you don't need to mess around with delete anymore, and which will also handle the raw pointer mess:
p16826
aVYou may later add or remove integers from the vector as you wish
p16827
aVYou could also create a , but i find it unwieldy to use, because you have to manage the separate row-vectors (which can be of varying lengths), and they are not seen as "one unit" together
p16828
aVYou can always create a function that maps a two dimensional coordinate to a one-dimensional index
p16829
aVFor a simple two-dimensional array whose size you know beforehand, you don't need  at all, though
p16830
as(dp16831
g15
V34509
p16832
stp16833
a((dp16834
g2
(lp16835
VThis compiles, using the  GCC extension
p16836
aVLooks like GCC's  uses expression templates to delay calculation of the sinus
p16837
aVBut that will make the return type of the  template not exactly , but rather some weird complex type
p16838
aVEdit: See AProgrammer's standard quote for why GCC is fine doing that
p16839
aVEdit: Standard compliant workaround
p16840
aVDoing this without  in a strictly Standard conforming way is a bit tricky
p16841
aVYou will need to get the return type of
p16842
aVYou can use the conditional operator for this, as Eric Niebler has shown
p16843
aVIt works by having the  function not actually called, but only type-checked
p16844
aVBy trying to convert the other branch (the one which is actually evaluated) of the conditional operator to that same type, we can generate a dummy parameter just to be able to deduce the type of the function pointer:
p16845
aVIf you want to get the address right away, you can write  so it returns  again
p16846
aVNow, you can finally write a macro to encapsulate the conditional operator trickery, and use it when you want to get the address of any such math function
p16847
aVTo get the address and pass it to some generic function, the following works then
p16848
as(dp16849
g15
V34509
p16850
stp16851
a((dp16852
g2
(lp16853
VI've read it in at least one coding guideline that constructors of abstract classes should not be public - I think that rule makes sense for the reason you gave
p16854
aVHowever, i can't imagine a scenario where making it public would make things go wrong
p16855
aVSo i wouldn't go so far as saying it's a code smell
p16856
aVI see the protected constructor as a "nice to have" property :)
p16857
as(dp16858
g15
V34509
p16859
stp16860
a((dp16861
g2
(lp16862
VThere are declared arrays and arrays that are not declared, but otherwise created, particularly using :
p16863
aVThat array with 3 elements is created dynamically (and that  could have been calculated at runtime, too), and a pointer to it which has the size erased from its type is assigned to
p16864
aVYou cannot get the size anymore to print that array
p16865
aVA function that only receives the pointer to it can thus not print that array
p16866
aVPrinting declared arrays is easy
p16867
aVYou can use  to get their size and pass that size along to the function including a pointer to that array's elements
p16868
aVBut you can also create a template that accepts the array, and deduces its size from its declared type:
p16869
aVThe problem with this is that it won't accept pointers (obviously)
p16870
aVThe easiest solution, i think, is to use
p16871
aVIt is a dynamic, resizable "array" (with the semantics you would expect from a real one), which has a  member function:
p16872
aVYou can, of course, also make this a template to accept vectors of other types
p16873
as(dp16874
g15
V34509
p16875
stp16876
a((dp16877
g2
(lp16878
VThe  temporary is destroyed after initialization of  is complete
p16879
aVSo when you print it with , the c-string that was associated with that  temporary has long been destoryed, and thus you will be lucky if it crashes and asserts, and not lucky if it prints garbage or does appear to work
p16880
aVThe C-string where  points to, however, is associated with a string that still exists at the time you do the  - so it correctly prints the result
p16881
aVIn the following code, the first  is correct (i assume it is  in the real code
p16882
aVThe second prints the c-string associated with the temporary string object
p16883
aVThe object is destroyed at the end of evaluating the full-expression in which it appears
p16884
aVThe full-expression is the entire  expression - so while the c-string is output, the associated string object still exists
p16885
aVFor  - it is pure badness that it succeeds
p16886
aVIt most possibly internally chooses the same storage location for the new temporary which it already chose for the temporary used to initialize
p16887
aVIt could aswell crash
p16888
aVThe return of  will usually just point to the internal string buffer - but that's not a requirement
p16889
aVThe string could make up a buffer if its internal implementation is not contiguous for example (that's well possible - but in the next C++ Standard, strings need to be contiguously stored)
p16890
aVIn GCC, strings use reference counting and copy-on-write
p16891
aVThus, you will find that the following holds true (it does, at least on my GCC version)
p16892
aVThe two strings share the same buffer here
p16893
aVAt the time you change one of them, the buffer will be copied and each will hold its separate copy
p16894
aVOther string implementations do things different, though
p16895
as(dp16896
g15
V34509
p16897
stp16898
a((dp16899
g2
(lp16900
VThe code contains a few syntactic and semantic bugs
p16901
aVLet's fix them
p16902
aVYou may choose to change the type in the conversion function to something else
p16903
aVAs written, the boolean conversion will also succeed to convert to any integer type
p16904
aVConverting to  will limit conversion to only bool and , which is a commonly used idiom
p16905
aVYet another and better way is to convert to some private type, called safe bool idiom
p16906
aVBack to syntax: If you have an else part, you may use the name of the declared variable, because it's still in scope
p16907
aVIt's destroyed after all branches are processed successfully
p16908
aVYou may also use the same name as before, and the variable will shadow the other variables, but you may not declare the same name in the most outer block of any branch - it will conflict rather than hide with the other declaration
p16909
aVThe technique to declare and initialize a variable is most often used together with  though, but can be perfectly used together with a user defined type like above, too
p16910
aVNote that syntactically, you have to initialize the variable (using the  form like for a default argument)
p16911
aVThe following is not valid
p16912
as(dp16913
g15
V34509
p16914
stp16915
a((dp16916
g2
(lp16917
VNo, the declaration does not imply that the initializer has a specific type
p16918
aVThe type of the initialize is the same, no matter what type the variable initialized is
p16919
aVSo, if you initialize a , but use a  for intialization, that would be pretty silly
p16920
aVBy using the  suffix, you say it's a floating point literal of type
p16921
aVAppended to an integer literal, it would say the type has
p16922
as(dp16923
g15
V34509
p16924
stp16925
a((dp16926
g2
(lp16927
VFor that to work, you would need to know the exact type of the bind expression that you store into the  object
p16928
aVThe object  returns is some weird expression template, not a function pointer
p16929
aVTo understand why this is needed, consider how boost::function is implemented in principle
p16930
aVThat's the most fundamental structure, without the  bloat - much like
p16931
aVThe mechanism is called type-erasure: The constructor accepts objects of arbitrary types, and then stores an object encapsulated into an object that you may reach through virtual function calls ( is optimized like hell, using its own vtable and stack-allocation to avoid  for small types and so on)
p16932
aVFor function pointers, this works great, because you know the type of the function that you assign to the  object
p16933
aVBut for complex callable objects, it doesn't quite work anymore
p16934
aVTo be able to see it working and to see that it's not just working with function pointers, but also with bind expressions, consider the following code
p16935
aVWithin  you know the type of what  returns
p16936
aVYou can use that to call the  call and return the object that's wrapped inside the
p16937
aVWithin  we then call the bind expression
p16938
aVPlease read Eric Niebler's article Conditional Love to see how this code snippet works
p16939
as(dp16940
g15
V34509
p16941
stp16942
a((dp16943
g2
(lp16944
VThe  overloads that prints strings and characters are free functions
p16945
aVBut as you force calling member functions, you will force them to convert to one candidate of the member functions declared in
p16946
aVFor , it will probably use the  overload, and for , it will probably use the  overload
p16947
aVI would not inherit , but instead store the  as a reference member, and then delegate from your  to it
p16948
aVI would also not make  a member, but rather a free function template, and not specialize but overload the  for both  and
p16949
as(dp16950
g15
V34509
p16951
stp16952
a((dp16953
g2
(lp16954
VI would keep two iterators, and then check whether the second iterator has reached
p16955
aVThis will make it not require bidirectional iterators anymore:
p16956
as(dp16957
g15
V34509
p16958
stp16959
a((dp16960
g2
(lp16961
VYou do copy initialization, and the candidate functions that are considered to do the conversions in the conversion sequence are conversion functions and converting constructors
p16962
aVThese are in your case
p16963
aVNow, that are the way you declare them
p16964
aVOverload resolution abstracts away from that, and transforms each candidate into a list of parameters that correspond to the arguments of the call
p16965
aVThe parameters are
p16966
aVThe second one is because the conversion function is a member function
p16967
aVThe  is the so-called implicit object parameter that's generated when a candidate is a member function
p16968
aVNow, the argument has type
p16969
aVWhen binding the implicit object parameter, a non-const reference can bind to an rvalue
p16970
aVSo, another rule says that when you have two viable functions whose parameters are references, then the candidate having the fewest const qualification will win
p16971
aVThat's why your conversion function wins
p16972
aVTry making  a const member function
p16973
aVYou will notice an ambiguity
p16974
aVFrom an object-oriented philosophical standpoint, is this the way the code should behave
p16975
aVWho knows more about how an A object should become a B object, A or B
p16976
aVAccording to C++, the answer is A -- is there anything in object-oriented practice that suggests this should be the case
p16977
aVTo me personally, it would make sense either way, so I'm interested to know how the choice was made
p16978
aVFor the record, if you make the conversion function a const member function, then GCC will chose the constructor (so GCC seems to think that  has more business with it
p16979
aVSwitch to pedantic mode () to make it cause a diagnostic
p16980
aVStandardese,
p16981
aVOtherwise (i
p16982
ag1992
aV, for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13
p16983
ag1037
ag2790
aV4, and the best one is chosen through overload resolution (13
p16984
aV3)
p16985
aVAnd
p16986
aVOverload resolution is used to select the user-defined conversion to be invoked
p16987
aVAssuming that "cv1 T" is the type of the object being initialized, with T a class type, the candidate functions are selected as follows:
p16988
aVThe converting constructors (12
p16989
ag1037
aV1) of T are candidate functions
p16990
aVWhen the type of the initializer expression is a class type "cv S", the conversion functions of S and its base classes are considered
p16991
aVThose that are not hidden within S and yield a type whose cv-unqualified version is the same type as T or is a derived class thereof are candidate functions
p16992
aVConversion functions that return "reference to X" return lvalues of type X and are therefore considered to yield X for this process of selecting candidate functions
p16993
aVIn both cases, the argument list has one argument, which is the initializer expression
p16994
aV[Note: this argument will be compared against the first parameter of the constructors and against the implicit object parameter of the conversion functions
p16995
ag4885
aVAnd
p16996
aVStandard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if [
p16997
aVS1 and S2 are reference bindings (8
p16998
ag1014
aV3), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers
p16999
as(dp17000
g15
V34509
p17001
stp17002
a((dp17003
g2
(lp17004
VJust in case you really need it (although from a performance point of view, i doubt it would be noticeable), i would overload
p17005
aVAlso, you should first follow the real rules: Pass  by-const-reference instead of passing a copy, for example
p17006
as(dp17007
g15
V34509
p17008
stp17009
a((dp17010
g2
(lp17011
VThere are two lookups that are done for the name
p17012
aVOne is the unqualified lookup at the definition context of
p17013
aVThe other is argument dependent lookup at each instantiation context (but the result of the lookup at each instantiation context is not allowed to change behavior between two different instantiation contexts)
p17014
aVTo get the desired behavior, you could go and define a fallback function in a  namespace that returns some unique type
p17015
aVThe  function will be called if nothing else matches because the ellipsis has worst conversion cost
p17016
aVNow, include that candidates into your function by a using directive of , so that  is included as candidate into the call to
p17017
aVNow, to see whether a call to  resolves to your function, you will call it, and check whether the return type is
p17018
aVThe return type of an otherwise chosen function could be void, so you have to do some comma operator tricks to get around that
p17019
aVIf our function was selected then the comma operator invocation will return a reference to
p17020
aVIf not or if the selected function returned , then the invocation returns  in turn
p17021
aVThen the next invocation with  as second argument will return a type that has sizeof 1 if our fallback was selected, and a sizeof greater 1 (the built-in comma operator will be used because  is in the mix) if something else was selected
p17022
aVWe compare the sizeof and delegate to a struct
p17023
aVThis solution is ambiguous if the existing function has an ellipsis too
p17024
aVBut that seems to be rather unlikely
p17025
aVTest using the fallback:
p17026
aVAnd if a candidate is found using argument dependent lookup
p17027
aVTo test unqualified lookup at definition context, let's define the following function above  and  (put the foo_impl template above , so they have both the same definition context)
p17028
as(dp17029
g15
V34509
p17030
stp17031
a((dp17032
g2
(lp17033
VTo answer your other questions
p17034
aVThe following is the invocation of the comma operator
p17035
aVIt creates a  temporary, which includes calling its constructor
p17036
aVIt then evaluates the second expression  which will print out the Y
p17037
aVIt then, at the end of the full expression, will destroy the temporary, which will call its destructor
p17038
aVSo your expectations were right
p17039
aVFor the following to work, you should add parentheses, because the comma has a predefined meaning in declarations
p17040
aVIt would start declaring a function  returning an  and taking no parameters and would assign the  object to
p17041
aVUsing parentheses, you say that the whole thing is a single comma operator expression instead
p17042
aVIt should be noted that the following two lines are equivalent
p17043
aVThe first does not create a temporary unnamed object using  as the constructor argument, but instead the parentheses around the name are redundant
p17044
aVDon't let the syntax confuse you
p17045
aVI've seen misuse of the terms scope and lifetime
p17046
aVis where you can refer to a name without qualifying its name
p17047
aVNames have scopes, and objects inherit the scope of the name used to define them (thus sometimes the Standard says "local object")
p17048
aVA temporary object has no scope, because it's got no name
p17049
aVLikewise, an object created by  has no scope
p17050
aVScope is a compile time property
p17051
aVThis term is frequently misused in the Standard, see this defect report, so it's quite confusing to find a real meaning
p17052
aVis a runtime property
p17053
aVIt means when the object is set up and ready for use
p17054
aVFor a class type object, the lifetime begins when the constructor ends execution, and it ends when the destructor begins execution
p17055
aVLifetime is often confused with scope, although these two things are completely different
p17056
aVThe lifetime of temporaries is precisely defined
p17057
aVMost of them end lifetime after evaluation of the full expression they are contained in (like, the comma operator of above, or an assignment expression)
p17058
aVTemporaries can be bound to const references which will lengthen their lifetime
p17059
aVObjects being thrown in exceptions are temporaries too, and their lifetime ends when there is no handler for them anymore
p17060
as(dp17061
g15
V34509
p17062
stp17063
a((dp17064
g2
(lp17065
VDefining a macro that replaces  is not something you should upload to your VCS, but if you just do it temporarily during debugging, I think it serves its place
p17066
aVSo you can just replace  by  like
p17067
aVThis way, it works with both  and plain , and  is available when including
p17068
aVWriting into a  is a no-op
p17069
aVThe  function call is done so that you get a non-const reference to it (so it also binds to non-member  that's used for outputting  and others)
p17070
aVAs its type is , it should behave exactly like
p17071
as(dp17072
g15
V34509
p17073
stp17074
a((dp17075
g2
(lp17076
VIf you are looking for metaprogramming using the built-in operator: Such a thing isn't possible - the built-in operators operate on runtime values, not on compile time values
p17077
aVYou may use  for that, and instead of using the built-in operators, use its templates, like  for ,  for  etc
p17078
as(dp17079
g15
V34509
p17080
stp17081
a((dp17082
g2
(lp17083
VTo add to @StackedCrooked answer, you can overload ,  and  and have iterator like functionality
p17084
aVLet's test with some  template
p17085
aVNow,  is a constant bidirectional iterator
p17086
aVHere is a reusable class i coded while doing it manually above
p17087
aVI noticed it could work for many more enums, so repeating the same code all over again is quite tedious
p17088
aVImplementation follows
p17089
as(dp17090
g15
V34509
p17091
stp17092
a((dp17093
g2
(lp17094
VI assume you added the  version to the global namespace too, and you call  from main after everything is defined
p17095
aVSo this is basically two phase name lookup
p17096
aVLooking up an unqualified function name that is dependent because an argument in the call is dependent (on its type) is done in  two phases
p17097
aVThe first phase does a unqualified and argument dependent lookup in the definition context
p17098
aVIt then freezes the result, and using the instantiation context (the sum of the declarations at the point of instantiation) does a second argument dependent lookup only
p17099
aVNo unqualified lookup is done anymore
p17100
aVSo for your example it means:
p17101
aVThe call  within  looks up  using argument dependent lookup at the instantiation context (it doesn't find it using unqualified lookup, because  is declared  the bar template)
p17102
aVDepending on whether you define the global  before or after the  template, it will find the global  declaration using argument dependent lookup already in the first phase (it's defined in 's namespace)
p17103
aVThen the call in main will instantiate  and it will possible find  in this phase (if you declared it after you declared the template)
p17104
aVThe call  within  doesn't do argument dependent lookup (or rather, the result for the lookup is an empty declaration set), because  is a fundamental type
p17105
aVSo, unqualified lookup at the definition context will find nothing either, because the matching  template is declared  the  template
p17106
aVThe call would be ill-formed, and the standard says about this situation at
p17107
aVIf the call would be ill-formed [
p17108
aVthen the program has undefined behavior
p17109
aVYou should therefor consider this as a "i did a dirty thing and the compiler chose not to slap me" case, i think :)
p17110
aVThe call  within  will do the lookups again, and will look for bar in  (because that's where  is defined)
p17111
aVIt doesn't find a  there, neither in the definition context
p17112
aVSo it decides to go by undefined behavior again, and uses the  template, and which in itself again does undefined behavior by using the  declared after it and which cannot be found by neither ADL nor unqualified lookup from the definition context
p17113
aVIf the vector were a , then lookup for  would be done at global scope too, because argument dependent lookup will not only use the argument type directly, but also the type of the template arguments in them, if there are any
p17114
aVIf you use GCC, then don't rely entirely on its behavior
p17115
aVIn the following code, it claims the call is ambiguous, although the code is perfectly fine - the  in  should not be a candidate
p17116
aVIf you want to test your snippets against conformance, best use the comeau online compiler with the strict settings
p17117
as(dp17118
g15
V34509
p17119
stp17120
a((dp17121
g2
(lp17122
VMy question is, why isn't the second one a pointer
p17123
aVBecause it declares an array
p17124
aVIn the two other cases, you have a pointer that refers to data that lives somewhere else
p17125
aVYour array declaration, however, declares an array of data that lives where it's declared
p17126
aVIf you declared it within a function, then data will die when you return from that function
p17127
aVFinally  would be an array of  pointers - it wouldn't be a char pointer
p17128
aVIn case you just want to point to a block of 4 chars, then  would fully suffice, no need to tell it that there are exactly  chars to be pointed to
p17129
aVThe first way which creates an object on the heap is used if you need data to live from thereon until the matching  call
p17130
aVThe data will survive a return from a function
p17131
aVThe last way just creates data that's not intended to be written to
p17132
aVIt's a pointer which refers to a string literal - it's often stored in read-only memory
p17133
aVIf you write to it, then the behavior is undefined
p17134
aVI understand what pointers do, but I don't understand what the point of them is (no pun intended)
p17135
aVPointers are used to point to something (no pun, of course)
p17136
aVLook at it like this: If you have a row of items on the table, and your friend says "pick the second item", then the item won't magically walk its way to you
p17137
aVYou have to grab it
p17138
aVYour hand acts like a pointer, and when you move your hand back to you, you dereference that pointer and get the item
p17139
aVThe row of items can be seen as an array of items:
p17140
aVAnd how come it seems that a pointer to a struct or an int is always an array
p17141
aVWhen you do  then you first point your hand at the first item (get a pointer to the first one), and then you advance till you are at the second item
p17142
aVThen you take your hand with the item back to you :) So, the  syntax is not something special to arrays, but rather special to pointers - it's equivalent to , and a temporary pointer is made up when you use an array like that
p17143
aVWhat is the difference between A and B
p17144
aVA is the 'tag-name', but what's that
p17145
aVWhen do I use which
p17146
aVSame thing for enums
p17147
aVThat's not valid code
p17148
aVYou basically said "define the type  to be referable by the following ordinary identifier" but you missed to tell it the identifier
p17149
aVThe two following snippets are equivalent instead, as far as i can see
p17150
aVWhat is the difference between A and B
p17151
aVA is the 'tag-name', but what's that
p17152
aVWhen do I use which
p17153
aVSame thing for enums
p17154
aVIn our case, the identifier  was declared two times in the same scope
p17155
aVBut the declarations won't conflict because each of the identifiers are in a different namespace
p17156
aVThe two namespaces involved are the ordinary namespace and the tag namespace
p17157
aVA tag identifier needs to be used after a struct, union or enum keyword, while an ordinary identifier doesn't need anything around it
p17158
aVYou may have heard of the POSIX function , whose interface looks like the following
p17159
aVIn that code snippet,  is registered into the two aforementioned namespaces too
p17160
aVwill refer to the struct, and merely  will refer to the function
p17161
aVSome people don't like to precede identifiers always with ,  or
p17162
aVThose use  to introduce an ordinary identifier that will refer to the struct too
p17163
aVThe identifier can of course be the same (both times ), or they can differ (one time  the other time )
p17164
aVIt doesn't matter
p17165
as(dp17166
g15
V34509
p17167
stp17168
a((dp17169
g2
(lp17170
VThere are interesting edge cases in C++ (some of them in C too)
p17171
aVConsider
p17172
aVThat can be a definition or a declaration, depending on what type  is:
p17173
aVIn C++, when using templates, there is another edge case
p17174
aVThe last declaration was not a definition
p17175
aVIt's the declaration of an explicit specialization of the static member of
p17176
aVIt tells the compiler: "If it comes to instantiating , then don't instantiate the definition of the member from the primary template, but use the definition found elsewhere"
p17177
aVTo make it a definition, you have to supply an initializer
p17178
as(dp17179
g15
V34509
p17180
stp17181
a((dp17182
g2
(lp17183
VThe C++ Standard says about protected non-static members at
p17184
aVWhen a friend or a member function of a derived class references a protected nonstatic member function or protected nonstatic data member of a base class, an access check applies in addition to those described earlier in clause 11
p17185
aVExcept when forming a pointer to member (5
p17186
ag1037
aV1), the access must be through a pointer to, reference to, or object of the derived class itself (or any class derived from that class) (5
p17187
ag976
aV5)
p17188
aVIf the access is to form a pointer to member, the nested-name-specifier shall name the derived class (or any class derived from that class)
p17189
aVIn addition to fixing things mentioned earlier by others (constructor of  is private), i think rlbond's way will do it fine
p17190
aVHowever, a direct consequence of the above paragraph of the Standard is that the following is possible using a member pointer, which arguably is a hole in the type system, of course
p17191
aVOf course, this code is not recommended to do, but shows that you can access it, if you really need to (I've seen this way being used for printing out a , ,  by accessing its protected container member )
p17192
as(dp17193
g15
V34509
p17194
stp17195
a((dp17196
g2
(lp17197
VFor both function and object pointers, they compile but their result is only guaranteed to be consistent for addresses to sub-objects of the same complete object (you may compare the addresses of two members of a class or array) and if you compare a function or object against itself
p17198
aVUsing ,  and so on will work with any pointer type, and will give consistent results, even if the result of the respective built-in operator is unspecified:
p17199
aVEverything of that should compile though (although the compiler is free to warn about any code snippet it wants)
p17200
aVSince function types have no  value, operations that are defined in terms of  of the pointee type will not work, these include:
p17201
aVThe unary  works on any pointer type, and will just return the value of it, there is nothing special about it for function pointers
p17202
aVFinally note that a pointer to a function pointer is not a function pointer anymore:
p17203
as(dp17204
g15
V34509
p17205
stp17206
a((dp17207
g2
(lp17208
VI think this is surely subjective, but if i were to align up the names, then i would put the modifiers directly next to them and align the names directly
p17209
aVBut usually, i just do
p17210
aVI try to order things from "short lines" to "long lines", if the order wouldn't matter otherwise :)
p17211
as(dp17212
g15
V34509
p17213
stp17214
a((dp17215
g2
(lp17216
VIt may be worthwhile to explain why it's not , but the other way around
p17217
aVThe reason is, the declarations are built recursively, and so a reference to a pointer builds up like
p17218
aVThe parentheses are dropped since they are redundant, but they may help you see the pattern
p17219
aV(To see why they are redundant, imagine how the thing looks in expressions, and you will notice that first the address is taken, and then dereferenced - that's the order we want and that the parentheses won't change)
p17220
aVIf you change the order, you would get
p17221
aVPointer to reference isn't legal
p17222
aVThat's why the order is , which means "reference to pointer"
p17223
as(dp17224
g15
V34509
p17225
stp17226
a((dp17227
g2
(lp17228
VThe compiler and linker relies on both classes to be exactly the same
p17229
aVIn your case, they are different and so strange things happen
p17230
aVThe one definition rule says that the result is undefined behavior - so behavior is not at all required to be consistent among compilers
p17231
aVI suspect that in , in the delete line, it puts a call to the first virtual table entry (because in its translation unit, the destructor may occupy the first entry)
p17232
aVIn the second translation unit, this entry happens to point to , but in the first translation unit (where you execute the ), the entry points to
p17233
aVSince these two are differently named ( vs ) you don't get a name clash (you will have code emitted for both the destructor and )
p17234
aVBut since their class name is the same, their v-tables will clash on purpose, because since both classes have the same name, the linker will think they are the same class and assume same contents
p17235
aVNotice that all member functions were defined in-class, which means they are all inline functions
p17236
aVThese functions can be defined multiple times in a program
p17237
aVIn the case of in-class definitions, the rationale is that you may include the same class definition into different translation units from their header files
p17238
aVYour test function, however, isn't an inline function and thus including it into different translation units will triggers a linker error
p17239
aVIf you enable namespaces, there will be no clash what-so ever, because  and  are different classes, and of course will get different v-tables
p17240
as(dp17241
g15
V34509
p17242
stp17243
a((dp17244
g2
(lp17245
Vhas type , but  has type  (because the member is found in , not in )
p17246
aVThus the function called compares these two member pointers with those types, and the standard says
p17247
aVIn addition, pointers to members can be compared, or a pointer to member and a null pointer constant
p17248
aVPointer to member conversions (4
p17249
aV11) and qualification conversions (4
p17250
aV4) are performed to bring them to a common type
p17251
aVIf one operand is a null pointer constant, the common type is the type of the other operand
p17252
aVOtherwise, the common type is a pointer to member type similar (4
p17253
aV4) to the type of one of the operands, with a cv-qualification signature (4
p17254
aV4) that is the union of the cv-qualification signatures of the operand types
p17255
aVdescribes an implicit Standard conversion from  to
p17256
aVThus, the comparison would find the common type
p17257
aVFor an object of type , both member pointers would refer to the same function (which is ) - so the comparison would yield true
p17258
aVThe comeau web compiler follows this interpretation and compiles your code
p17259
as(dp17260
g15
V34509
p17261
stp17262
a((dp17263
g2
(lp17264
VNo this is currently not possible in C++
p17265
aVIt's called "perfect forwarding", and is allowed in C++0x
p17266
aVYou can simulate it by producing overloads of your constructor up to a fixed maximum (like, say, 8 parameters), both for const and non-const references
p17267
aVThis is still not perfect (temporaries won't be forwarded as temporaries), but usually works in practice:
p17268
aVThe generation can be automated using Boost
p17269
aVPreprocessor or some script, but it's not exactly nice, since the amount of overloads grows fast
p17270
aVSo in short - no write your constructors yourself until C++0x is available, which supports both perfect forwarding for any function, and special constructor forwarding ()
p17271
as(dp17272
g15
V34509
p17273
stp17274
a((dp17275
g2
(lp17276
VThe conditional operator checks conversions in both directions
p17277
aVIn this case, since your constructor is explicit (so the  is not ambiguous), the conversion from  to  is used, using your conversion function that converts to : That works, because after applying the conversion function, a standard conversion that converts the  to  (truncation) follows
p17278
aVThe result of  in your case is , and has the value
p17279
aVIn the second case, since the operand has type , no such trailing conversion to  takes place, and thus the result type of  has type  with the expected value
p17280
aVTo understand the "unnecessary" conversions, you have to understand that expressions like your  are evaluated "context-free": When determining the value and type of it, the compiler doesn't consider that it's the operand of a  for a function returning a
p17281
aVEdit: What happens if your constructor is implicit
p17282
aVThe  expression will be ambiguous, because you can convert an  to an rvalue of type  (using the constructor), and a  to an rvalue of type  (using the conversion function)
p17283
aVThe Standard says
p17284
aVUsing this process, it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand
p17285
aVIf both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed
p17286
aVParagraphs explaining how your  is converted to :
p17287
aVabout :
p17288
aVOtherwise, if the second and third operand have different types, and either has (possibly cv-qualified) class type, an attempt is made to convert each of those operands to the type of the other
p17289
ag7695
aVE1 can be converted to match E2 if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted to an rvalue (or the type it has, if E2 is an rvalue)
p17290
aVabout "implicitly converted":
p17291
aVAn expression e can be implicitly converted to a type T if and only if the declaration  is well-formed, for some invented temporary variable t
p17292
aVabout copy initialization (  )
p17293
aVIf the source type is a (possibly cv-qualified) class type, conversion functions are considered
p17294
aVThe applicable conversion functions are enumerated (13
p17295
ag1037
ag2790
aV5), and the best one is chosen through overload resolution (13
p17296
aV3)
p17297
aVThe user-defined conversion so selected is called to convert the initializer expression into the object being initialized
p17298
aVIf the conversion cannot be done or is ambiguous, the initialization is ill-formed
p17299
aVabout the conversion function candidates
p17300
aVThe conversion functions of S and its base classes are considered
p17301
aVThose that are not hidden within S and yield type T or a type that can be converted to type T via a standard conversion sequence (13
p17302
ag1037
ag1037
ag2790
aV1) are candidate functions
p17303
as(dp17304
g15
V34509
p17305
stp17306
a((dp17307
g2
(lp17308
VLike others say - No this isn't possible, the compiler can't infer the type of  from the non-type template arguments (in the case of functions, it infers types from the function arguments):
p17309
ag1240
aVA template type argument cannot be deduced from the type of a non-type template-argument
p17310
aVIn any case, no deduction will be made for the arguments of a class template anyway
p17311
aVAn example for a function template might be
p17312
aVIn this case,  won't be deduced as  - you have to explicitly specify it
p17313
as(dp17314
g15
V34509
p17315
stp17316
a((dp17317
g2
(lp17318
VNo, there is no way to do that
p17319
aVThe note at  in the Standard explains why
p17320
aV[Note: because the explicit template argument list follows the function template name, and because conversion member function templates and constructor member function templates are called without using a function name, there is no way to provide an explicit template argument list for these function templates
p17321
ag4885
aVOf course, it doesn't need to be a  object you send
p17322
aVIt can be any object that has  encoded in its type
p17323
as(dp17324
g15
V34509
p17325
stp17326
a((dp17327
g2
(lp17328
VThe names of the  Standard library are in namespace
p17329
as(dp17330
g15
V34509
p17331
stp17332
a((dp17333
g2
(lp17334
VYou can't write it like that:
p17335
aVBecause the default argument will have to repeat itself
p17336
aVYou can use a tag-type, though
p17337
aVIf it is applicable, i would determine the allocator in the container, though
p17338
aVLike this:
p17339
as(dp17340
g15
V34509
p17341
stp17342
a((dp17343
g2
(lp17344
VThis is bad, because the  can't rely on a set-up object anymore
p17345
aVYou should do it the other way around, and can use the copy-swap idiom
p17346
aVIn the case where you just have to copy over all elements, you can use the implicitly generated assignment operator
p17347
aVIn other cases, you will have to do something in addition, mostly freeing and copying memory
p17348
aVThis is where the copy-swap idiom is good for
p17349
aVNot only is it elegant, but it also provide so an assignment doesn't throw exceptions if it only swaps primitives
p17350
aVLet's a class pointing to a buffer that you need to copy:
p17351
aVThat's how i write the assignment operator usually
p17352
aVRead Want speed
p17353
aVPass by value about the unusual assignment operator signature (pass by value)
p17354
as(dp17355
g15
V34509
p17356
stp17357
a((dp17358
g2
(lp17359
VI found the following issue report, which says
p17360
aVThere is no ambiguity; the standard is clear as written
p17361
aVLibrary implementors are not permitted to add template parameters to standard library classes
p17362
aVThis does not fall under the "as if" rule, so it would be permitted only if the standard gave explicit license for implementors to do this
p17363
aVThis would require a change in the standard
p17364
aVThe LWG decided against making this change, because it would break user code involving template template parameters or specializations of standard library class templates
p17365
aVThe books and people that say an implementation may add other optional parameters seem to be wrong
p17366
as(dp17367
g15
V34509
p17368
stp17369
a((dp17370
g2
(lp17371
VThe forward references in your code seems to be to  and , which is resolved by forward declaring them
p17372
aVSince you reference  in member function declarations of , you cannot define the member functions right away in
p17373
aVTheir definitions have to appear after  is defined
p17374
aVSo you have to either move the definition of the functions into the  file, or you have to move their definition in the header after definition of  whichever suites you more
p17375
aVis only used as a pointee type in , so we don't have the same problem for it here:
p17376
aVDefinition at the end of the header looks like
p17377
aVNonetheless i would recommend you to use const references to pass the board to 's member functions, but this is not a requirement for your code to work
p17378
aVDeclarations go fine with incomplete parameter types
p17379
as(dp17380
g15
V34509
p17381
stp17382
a((dp17383
g2
(lp17384
VAnytime you ed an array you use
p17385
aVSometimes you new'ed an array using  - then you still have to use  - no way out
p17386
aVSo it's not exactly a rule "use delete[] when you new[]'ed" but rather "use delete[] when deleting an array"
p17387
as(dp17388
g15
V34509
p17389
stp17390
a((dp17391
g2
(lp17392
VShould work fine (notice the )
p17393
aVTemplate arguments should be deduced in either case
p17394
as(dp17395
g15
V34509
p17396
stp17397
a((dp17398
g2
(lp17399
VIn any case, your code doesn't make much sense in the following declaration
p17400
aVBecause the  parameter is used nowhere in the declaration
p17401
aVI think you either wanted to write one of the following things:
p17402
aVI suspect it was the first one
p17403
aVFor the compiler crash - that surely shouldn't happen in any case :)
p17404
aVEdit: The bug has already been fixed in 4
p17405
ag2670
aV1 at least - i think there is no need for reporting anymore
p17406
as(dp17407
g15
V34509
p17408
stp17409
a((dp17410
g2
(lp17411
VIn this case, both conversions in the first group are exact matches, while both conversions in the second group are conversions
p17412
aVThey are equally ranked - it's like  vs
p17413
aVThe other call has the same types, just different values, so it exhibits the same behavior
p17414
aVOnly  is a promotion, like only integer types smaller than int to int (and for some exotic platforms to unsigned int) are promotions
p17415
aVSo the following wouldn't be ambiguous
p17416
aVIn that case, the second argument has a better conversion sequence when converted to the parameter of
p17417
as(dp17418
g15
V34509
p17419
stp17420
a((dp17421
g2
(lp17422
VYou can only specialize it explicitly by providing all template arguments
p17423
aVNo partial specialization for member functions of class templates is allowed
p17424
aVA work around is to introduce overloaded functions, which have the benefit of still being in the same class, and so they have the same access to member variables, functions and stuffs
p17425
aVNote that by passing along to the overloaded functions and pushing the template parameters into a function parameter, you may arbitrary "specialize" your functions, and may also templatize them as needed
p17426
aVAnother common technique is to defer to a class template defined separately
p17427
aVI find that usually requires more code and i find the function overload easier to handle, while others prefer the defer to class template way
p17428
aVIn the end it's a matter of taste
p17429
aVIn this case, you could have put that other template inside  too as a nested template - in other cases where you explicitly specialize instead of only partially, then you can't do that, because you can place explicit specializations only at namespace scope, not into class scope
p17430
aVYou could also create such a  template just for purpose of function overloading (it then works similar to our  of before), as the following variant demonstrates which leaves the first parameter variable too (so you may call it with other types - not just with the current instantiation's template parameters)
p17431
aVI think sometimes, deferring to another template is better (when it comes to such cases as arrays and pointers, overloading can tricky and just forwarding to a class template has been easier for me then), and sometimes just overloading within the template is better - especially if you really forward function arguments and if you touch the classes' member variables
p17432
as(dp17433
g15
V34509
p17434
stp17435
a((dp17436
g2
(lp17437
VThere is a subtle difference between implicit and explicit calling functions
p17438
aVConsider the following test-case out of the Standard doc
p17439
aVThe first one fails because you gave a function name explicitly, and the name will be looked up "inside out": first in the function, then in its class, and then at global scope
p17440
aVIn the second one, lookup for function candidates works different: Member and non-member functions are looked up in two phases, and when looking up Non-member functions, member functions are ignored, so the member operator won't hide the global operator in the second case
p17441
aVExplicit function calls will also never select a built-in operator
p17442
aVYou cannot do  for example
p17443
aVIn general, always prefer implicit function calls, i would say
p17444
aVAre all functions inside of a class member functions
p17445
aVOr only the ones preceded by the declaration "friend"
p17446
aVAs someone else said too, friend functions are not members of the class that contains the declaration, even if the functions is defined in the declaration too
p17447
aVThe lexical scope of  is  - that means you can refer to (static) members or nested types of  without preceding their names with
p17448
aVWith regard to special member functions, you can call a destructor or assignment operator explicitly, while constructors cannot be called explicitly
p17449
aVTheir calls are implicit, and is part of creating a new object
p17450
as(dp17451
g15
V34509
p17452
stp17453
a((dp17454
g2
(lp17455
VIf you just want to search for  or , you can say that if you don't find them in the line, you want to skip following rules:
p17456
as(dp17457
g15
V34509
p17458
stp17459
a((dp17460
g2
(lp17461
VOf course, this won't work with commans that use quoting like
p17462
aVYou can consider the POSIX function  which cares about that and much more
p17463
as(dp17464
g15
V34509
p17465
stp17466
a((dp17467
g2
(lp17468
VI can only think of a few differences - here are some examples that don't necessarily cause harm (i think)
p17469
aVI'm omitting definitions to keep it terse
p17470
aVThat is because specializations are not found by name lookup, but by argument matching, so a using declaration will automatically consider a later introduced specialization
p17471
aVThen, you of course cannot partially specialize function templates
p17472
aVOverloading however accomplishes something very similar by partial ordering (using different types now, to make my point)
p17473
aVThat wouldn't be possible with function template explicit specialization
p17474
aVAnother example is when references are involved, which causes template argument deduction to look for an exact match of the types involved (modulo base/derived class relationships and constness):
p17475
aVI recommend you to always use overloading, because it's richer (allows something like partial specialization would allow), and in addition you can place function in whatever namespace you want (although then it's not strictly overloading anymore)
p17476
aVFor example, instead of having to specialize  in the  namespace, you can place your  overload in your own namespace and make it callable by ADL
p17477
aVWhatever you do, never mix specialization and overloading, it will be a hell of a mess like this article points out
p17478
aVThe Standard has a lovely paragraph about it
p17479
aVThe placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member function templates of member classes of class templates, etc
p17480
aV, and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc
p17481
aV, can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below
p17482
aVWhen writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation
p17483
as(dp17484
g15
V34509
p17485
stp17486
a((dp17487
g2
(lp17488
VYou need branching at compile time
p17489
aVChange the content in your template to something like this:
p17490
aVThere are a couple of alternative ways to solve this
p17491
aVTo avoid repeatedly adding overloads,  could be useful
p17492
aVBut as long as you have only two special cases for int and float, i would keep it simple and just repeat that one call to
p17493
aVAnother pattern that avoids  and still avoids repeating the overloads is to introduce a hierarchy of type flags - change  to the following, and keep the code within  the same as above
p17494
aVI would use this if there tends to be more cases that need special handling:
p17495
aVneeds to be defined outside the class template now, because you cannot explicitly specialize it within the template
p17496
aVThen change the overloads of the helper function to the following
p17497
aVThe specializations would then determine the "configuration" of what should use strings and what number conversion
p17498
as(dp17499
g15
V34509
p17500
stp17501
a((dp17502
g2
(lp17503
VFor the language difference (keeping only the function declarations below, since that's what's important only)
p17504
aVIt doesn't work, because it wants a function, not a function pointer
p17505
aVFor the same reason that array answer rejects a pointer, this rejects a pointer too
p17506
aVYou have to pass "g" directly
p17507
aVFor templates, it matters too
p17508
aVThose two are very different from one another
p17509
aVIf you call it with  like above, then the first will try to declare a function and initialize it with  (reference to )
p17510
aVThe generated function would look like this
p17511
aVNow you can initialize references and pointers to functions, but of course not functions itself
p17512
aVIn the second definition,  will be deduced to a function pointer type by template argument deduction, and passing a function will convert it to that pointer parameter type implicitly
p17513
aVSo everything will go fine
p17514
aVI don't know why MSVC treats them differently for inlining - but i also suspect it's because function references appear more seldom
p17515
as(dp17516
g15
V34509
p17517
stp17518
a((dp17519
g2
(lp17520
VThe easiest is to create an event type id, and use a  using the type id, set its string member ("evt
p17521
aVSetText"), and send the event to one of your windows (using )
p17522
aVIn the handler of that event, you can then call  on your control using the text you sent (), because you are in the GUI thread by then
p17523
aVHere is an overview how it works: Custom Events
p17524
as(dp17525
g15
V34509
p17526
stp17527
a((dp17528
g2
(lp17529
VYou have to do two steps
p17530
aVFinding an integral type large enough to store the values
p17531
aVYou could use , but the values could be negative
p17532
aVThen you could use  but the values could extend into the range of
p17533
aVSo there is not really a fit-it-all type
p17534
aVThere is a trick though, by using overload resolution
p17535
aVHere is it
p17536
aVYou can change it appropriately to cover also  or  if your implementation has support for that
p17537
aVNow, passing an enum type will prefer one of these over all the other ones - that's a type that can store all values of it
p17538
aVYou just need to pass  of the return type to some template
p17539
aVNow, you can get a right type
p17540
aVAll you need now is to see whether some type is an enumeration
p17541
aVHow to do this is described in the book "C++ Templates - The complete Guide", and unfortunately is a whole lot of code
p17542
aVSo i would use boost's
p17543
aVPutting it together, it could look like
p17544
aVHope this helps
p17545
as(dp17546
g15
V34509
p17547
stp17548
a((dp17549
g2
(lp17550
VAnother possibility
p17551
aVis storing non-null terminated data, and has a templated  accepting byte arrays
p17552
aVThis way, you could think of the code as
p17553
aVImagine the following implementation of
p17554
aVUsing that class, we can assign  to , and it will give it a length of , and then executing the loop's first iteration will get us to
p17555
as(dp17556
g15
V34509
p17557
stp17558
a((dp17559
g2
(lp17560
VIt's because the definition of the static data member is itself a template
p17561
aVAllowing this is necessary for the same reason you are allowed to have a function template that's not inline multiple times in a program
p17562
aVYou need the template to generate the resulting entity (say, a function, or a static data member)
p17563
aVIf you wouldn't be allowed to put the definition of a static data member, how would you instantiate the following
p17564
aVIt's not known what  is - the Standard says the definition outside the class template is a template definition, in which the parameters are inherited from its class template owner
p17565
aVI've made some experiment with GCC
p17566
aVIn the following, we have one implicit instantiation of , and one explicit specialization of  which has to be defined in a
p17567
aVcpp file to not cause duplicated symbol errors when included multiple times
p17568
aVThe second translation unit contains just another implicit instantiation of the same static data member
p17569
aVHere is what we get with GCC - it makes each implicit instantiation into a weak symbols and sticks it into its own section here
p17570
aVWeak symbols will not cause errors when there exist multiple of them at link time
p17571
aVInstead, the linker will choose one instance, and discards the other ones assuming all of them are the same
p17572
aVSo as we can see  is a weak symbol which means the linker can see multiple of these at link time
p17573
aV,  and  are global (non-weak) symbols
p17574
aVLinking  and  together, we see in the map output () the following
p17575
aVThis indicates that actually it drops all except one instance
p17576
as(dp17577
g15
V34509
p17578
stp17579
a((dp17580
g2
(lp17581
VFirst, it's just an implementation detail, and if you put const there, don't put it in the declaration set (header)
p17582
aVOnly put it in the implementation file:
p17583
aVWhether or not a parameter is const in a definition is purely an implementation detail, and should not be part of the interface
p17584
aVI've not seen this sort of thing often, and i also don't do this
p17585
aVHaving the parameter const would confuse me more often than help, because i would immediately pattern-match-fail it to "const int &age;" :) The matter of course is entirely different from having const at another level:
p17586
aVIn this case, the const will affect whether the function can change the caller's argument
p17587
aVConst in this meaning should be used as often as possible, because it can help ensuring program correctness and improve self-documenting the code
p17588
as(dp17589
g15
V34509
p17590
stp17591
a((dp17592
g2
(lp17593
V2) Do you mean the following
p17594
aVLet's assume the first multiplies 2 integers
p17595
aVThe second multiplies  integers passed by var-args
p17596
aVCalled with  will not be ambiguous, because an argument passed through "the ellipsis" is associated with the highest possible cost
p17597
aVPassing an argument to a parameter of the same type however is associated with the lowest possible cost
p17598
aVSo this very call will surely be resolved to the first function :)
p17599
aVNotice that overload resolution only compares argument to parameter conversions for the same position
p17600
aVIt will fail hard if either function for some parameter pair has a winner
p17601
aVFor example
p17602
aVImagine the first multiplies two integers, and the second multiplies a list of doubles that is terminated by a
p17603
aVThis overload set is flawed and will be ambiguous when called by
p17604
aVThis is because the second function wins for the first argument, but the first function wins for the second argument
p17605
aVIt doesn't matter that the conversion cost for the second argument is higher for the second function than the cost of the first argument for the first function
p17606
aVOnce such a "cross" winner situation is determined, the call for such two candidates is ambiguous
p17607
as(dp17608
g15
V34509
p17609
stp17610
a((dp17611
g2
(lp17612
VTaken from Move constructors
p17613
aVI like the easy rules
p17614
aVIf the function intends to change the argument as a side effect, take it by reference/pointer to a non-const object
p17615
aVExample:
p17616
aVIf the function doesn't modify its argument and the argument is of primitive type, take it by value
p17617
aVExample:
p17618
aVOtherwise
p17619
ag1037
ag2790
aVIf the function always makes a copy of its argument inside, take it by value
p17620
ag1037
ag976
aVIf the function never makes a copy of its argument, take it by reference to const
p17621
ag1037
ag1037
aVAdded by me: If the function sometimes makes a copy, then decide on gut feeling: If the copy is done almost always, then take by value
p17622
aVIf the copy is done half of the time, go the safe way and take by reference to const
p17623
aVIn your case, you should take the int by value, because you don't intend to modify the argument, and the argument is of primitive type
p17624
aVI think of "primitive type" as either a non-class type or a type without a user defined copy constructor and where  is only a couple of bytes
p17625
as(dp17626
g15
V34509
p17627
stp17628
a((dp17629
g2
(lp17630
VI use
p17631
aVAlso works with C++
p17632
as(dp17633
g15
V34509
p17634
stp17635
a((dp17636
g2
(lp17637
VSure this should work, but it sounds like you either have one or both of the following in action
p17638
aVHave  a template parameter or a type that somehow otherwise depend on it (typedef to it)
p17639
aVPut a  before  then, so that the compiler knows that  is a type and can proceed analysis properly (it could be a static value member)
p17640
aVKnowing it is a type, the compiler can produce better diagnostics for template definitions, and you are required to tell whether it is a type using
p17641
aVHave  a const list
p17642
aVUse  then
p17643
aVUpdate: The shown compile error surely indicates that the first point is true:  directly or indirectly depends on a template parameter, and you have to put  like so:
p17644
aVThe compiler believes you that it is a non-type, and so it requires some operator or semicolon behind  (like, a multiplication)
p17645
aVPut  to make it know it names a type instead
p17646
aVUpdate: See the Template FAQ for similar template issues and solutions
p17647
as(dp17648
g15
V34509
p17649
stp17650
a((dp17651
g2
(lp17652
VYes, OK
p17653
aVThe  is a member-function, which is called, and which returns itself (and lvalue referring to itself)
p17654
aVThe object is then copied into the parameter of
p17655
aVNotice that return value optimization is not allowed to apply, since the temporary created by  was previously bound to a reference
p17656
aVYes, OK
p17657
aVThe call  returns a temporary which is bound to the const reference
p17658
aVA copy constructor is required, but the call it it may be optimized out by the implementation
p17659
aVThe temporary persists until the end of the full-expression containing the call to  (the whole expression statement here)
p17660
aVYes, OK
p17661
aVNo copy constructor required, as we bind the const reference not to a temporary but to the lvalue representing the object itself
p17662
aVThat is not required to work
p17663
aVThink of a situation where  returns a  (allowed)
p17664
aVYou are not allowed to modify rvalues of non-class type, so in that case, this would be ill-formed
p17665
aVYes, OK
p17666
aVThe argument is evaluated as in , but the resulting lvalue is directly passed and the const reference is bound to it
p17667
aVIn this sense it's equal to  (except for the decrement side effect)
p17668
aVThe Standard wording is not entirely clear
p17669
aVIt surely intends to only extend lifetime of objects not yet bound to a reference
p17670
aVBut in our case,  yields an lvalue refering to a temporary object which was previously bound to a reference
p17671
aVIt may be worth submitting a defect report to the committee (i may also have missed wording that requires the temporary object to not be bounded to a reference yet)
p17672
aVIn any case, the intended behavior is to destruct the temporary that results from  at the end of initializing , so  will become a dangling reference
p17673
aVThe thing is that operator-- returns some reference and the compiler does not see any relation between this reference and the temporary we created
p17674
aVExactly (but applies only to the initialization of  which will go mad
p17675
aVIn all other cases, the intended behavior you want (or what i believe you want) is achieved)
p17676
as(dp17677
g15
V34509
p17678
stp17679
a((dp17680
g2
(lp17681
VWhat's also interesting is the calling convention difference of functions with, and functions without a prototype
p17682
aVConsider an old style definition:
p17683
aVIn this case, the calling convention is that all arguments are promoted before being passed to the function
p17684
aVSo if  receives a  but the parameter has type  (which is perfectly valid) the compiler has to emit code that converts the double to a float prior to executing the function's body
p17685
aVIf you include a prototype, the compiler does not do such automatic promotions anymore and any data passed is converted to the types of the parameters of the prototype as if by assignment
p17686
aVSo the following is not legal and results in undefined behavior:
p17687
aVIn this case, the function's definition would convert the submitted parameter from  (the promoted form) to  because the definition is old-style
p17688
aVBut the parameter was submitted as a float, because the function has a prototype
p17689
aVYour options of solving the contradictions are the two following:
p17690
aVOption 2 should be preferred if you have the choice because it gets rid of the old style definition up front
p17691
aVIf such contradicting function types for a function appears in the same translation unit, the compiler will usually tell you (but is not required)
p17692
aVIf such contradictions appear over multiple translation units, the error will possibly go unnoticed and can result in hard to predict bugs
p17693
aVIt is best to avoid these old style definitions
p17694
as(dp17695
g15
V34509
p17696
stp17697
a((dp17698
g2
(lp17699
VC++ Standard :
p17700
aVThere is a sequence point (1
p17701
aV9) after the initialization of each base and member
p17702
aVThe expression-list of a mem-initializer is evaluated as part of the initialization of the corresponding base or member
p17703
aVThe order of the initialization is the one you specified in the question
p17704
aVEvaluation is part of this initialization, and the initializations can't interleave (because there is a sequence point between them)
p17705
aVThat means that the function calls in your initializer lists are not called in the desired order, but in the order in which the member declarations appear
p17706
as(dp17707
g15
V34509
p17708
stp17709
a((dp17710
g2
(lp17711
VThe rules are as follows for C++03:
p17712
aVAfter name lookup (3
p17713
aV4) finds that a name is a template-name, if this name is followed by a , the  is always taken as the beginning of a template-argument-list and never as a name followed by the less-than operator
p17714
aVWhen parsing a template-id, the first non-nested  [foot-note:  A  that encloses the type-id of a , ,  or , or which encloses the template-arguments of a subsequent template-id, is considered nested for the purpose of this description
p17715
aV] is taken as the end of the template-argument-list rather than a greater-than operator
p17716
aVSo the result is:
p17717
aVHowever, in C++0x the following are the rules
p17718
aVAfter name lookup (3
p17719
aV4) \ufb01nds that a name is a template-name, or that an operator-function-id refers to a set of overloaded functions any member of which is a function template, if this is followed by a , the  is always taken as the delimiter of a template-argument-list and never as the less-than operator
p17720
aVWhen parsing a template-argument-list, the \ufb01rst non-nested > [foot-note:  A  that encloses the type-id of a , ,  or , or which encloses the template-arguments of a subsequent template-id, is considered nested for the purpose of this description
p17721
aVis taken as the ending delimiter rather than a greater-than operator
p17722
aVSimilarly, the \ufb01rst non-nested  is treated as two consecutive but distinct  tokens, the \ufb01rst of which is taken as the end of the template-argument-list and completes the template-id
p17723
aVResult will be
p17724
aVBe sure to disable C++0x mode in comeau when testing
p17725
as(dp17726
g15
V34509
p17727
stp17728
a((dp17729
g2
(lp17730
Vis an incomplete type, the compiler doesn't know its  value
p17731
aVThe outermost dimension may stay incomplete, because it's not important for the array to function correctly in most contexts (in particular, indexing will still work)
p17732
aVSomething like  wouldn't be a correct type anymore
p17733
aVSure this can be nested:
p17734
as(dp17735
g15
V34509
p17736
stp17737
a((dp17738
g2
(lp17739
VThe way you wrote it, it was saying "the returned pointer value is const"
p17740
aVBut non-class type rvalues are not modifiable (inherited from C), and thus the Standard says non-class type rvalues are never const-qualified (right-most const was ignored even tho specified by you) since the const would be kinda redundant
p17741
aVOne doesn't write it - example:
p17742
aVNotice that for the type of "g", the const is significant, but for rvalue expressions generated from type  the const is ignored
p17743
aVSo the following is an error:
p17744
aVThere is no way known to me you could observe the "const" other than getting at the type of "g" itself (and passing  to a template and deduce its type, for example)
p17745
aVFinally notice that "char const" and "const char" signify the same type
p17746
aVI recommend you to settle with one notion and using that throughout the code
p17747
as(dp17748
g15
V34509
p17749
stp17750
a((dp17751
g2
(lp17752
VAs we figured out in IRC, that was because you have
p17753
aVMade your functions non-pure
p17754
aVSliced the derived object part
p17755
aVSo the base class functions were called because the object wasn't a complete derived object anymore
p17756
aV(Below follows my suspicion on earlier versions of your question - i keep it for further consideration and to keep the comments meaningful)
p17757
aVI think the issue here is that the compiler is free to instantiate any virtual function member of a class template even if it's not used (i
p17758
aVe not called)
p17759
aVInstantiating a function will need a function definition to be provided
p17760
aVTry to add this in the header, where the compiler will find them and instantiate a definition from:
p17761
aVC++ Standard :
p17762
aVAn implementation shall not implicitly instantiate a function template, a member template, a non-virtual
p17763
aVmember function, a member class or a static data member of a class template that does not require instantiation
p17764
aVIt is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated
p17765
as(dp17766
g15
V34509
p17767
stp17768
a((dp17769
g2
(lp17770
VA struct cannot be empty in C because the syntax forbids it
p17771
aVFurthermore, there is a semantic constraint that makes behavior undefined if a struct has no named member:
p17772
aVIf you write
p17773
aVIt will give you a diagnostic message, because you violate syntactic rules
p17774
aVIf you write
p17775
aVThen you have a non-empty struct with no named members, thus making behavior undefined, and not requiring a diagnostic:
p17776
aVIf the struct-declaration-list contains no named members, the behavior is unde\ufb01ned
p17777
aVNotice that the following is disallowed because a flexible array member cannot be the first member:
p17778
as(dp17779
g15
V34509
p17780
stp17781
a((dp17782
g2
(lp17783
VYes, that means that  isn't necessarily zero, and the assert may fail
p17784
aVBecause while the null pointer constant is zero, the null pointer of some type is not necessarily an address with all bits zero
p17785
aVhas no special provisions to yield zero when casting a null pointer to int
p17786
aVYou can achieve that by using boolean operators, which will initialize the variable with either  or :
p17787
as(dp17788
g15
V34509
p17789
stp17790
a((dp17791
g2
(lp17792
VExplanation by Dennis Ritchie about C history:
p17793
aVEmbryonic C
p17794
aVNB existed so briefly that no full description of it was written
p17795
aVIt supplied the types int and char, arrays of them, and pointers to them, declared in a style typified by
p17796
aVThe semantics of arrays remained exactly as in B and BCPL: the declarations of iarray and carray create cells dynamically initialized with a value pointing to the first of a sequence of 10 integers and characters respectively
p17797
aVThe declarations for ipointer and cpointer omit the size, to assert that no storage should be allocated automatically
p17798
aVWithin procedures, the language's interpretation of the pointers was identical to that of the array variables: a pointer declaration created a cell differing from an array declaration only in that the programmer was expected to assign a referent, instead of letting the compiler allocate the space and initialize the cell
p17799
aVValues stored in the cells bound to array and pointer names were the machine addresses, measured in bytes, of the corresponding storage area
p17800
aVTherefore, indirection through a pointer implied no run-time overhead to scale the pointer from word to byte offset
p17801
aVOn the other hand, the machine code for array subscripting and pointer arithmetic now depended on the type of the array or the pointer: to compute iarray[i] or ipointer+i implied scaling the addend i by the size of the object referred to
p17802
aVThese semantics represented an easy transition from B, and I experimented with them for some months
p17803
aVProblems became evident when I tried to extend the type notation, especially to add structured (record) types
p17804
aVStructures, it seemed, should map in an intuitive way onto memory in the machine, but in a structure containing an array, there was no good place to stash the pointer containing the base of the array, nor any convenient way to arrange that it be initialized
p17805
aVFor example, the directory entries of early Unix systems might be described in C as
p17806
aVI wanted the structure not merely to characterize an abstract object but also to describe a collection of bits that might be read from a directory
p17807
aVWhere could the compiler hide the pointer to name that the semantics demanded
p17808
aVEven if structures were thought of more abstractly, and the space for pointers could be hidden somehow, how could I handle the technical problem of properly initializing these pointers when allocating a complicated object, perhaps one that specified structures containing arrays containing structures to arbitrary depth
p17809
aVThe solution constituted the crucial jump in the evolutionary chain between typeless BCPL and typed C
p17810
aVIt eliminated the materialization of the pointer in storage, and instead caused the creation of the pointer when the array name is mentioned in an expression
p17811
aVThe rule, which survives in today's C, is that values of array type are converted, when they appear in expressions, into pointers to the first of the objects making up the array
p17812
aVTo summarize in my own words - if  above were just a pointer, any of that struct would contain an additional pointer, destroying the perfect mapping of it to an external object (like an directory entry)
p17813
as(dp17814
g15
V34509
p17815
stp17816
a((dp17817
g2
(lp17818
VBetter use a typedef
p17819
aVThe reason your macro may fail is - it might not syntactically valid in some places
p17820
aVConsider:
p17821
aVIn this case, you get
p17822
aVThis is not valid, because the cast form used is not compatible with the way you name the type (it has to consist of a simplier form, like a single word)
p17823
aVUse a typedef:
p17824
as(dp17825
g15
V34509
p17826
stp17827
a((dp17828
g2
(lp17829
VIt's wrong to say flat-out that a template parameter can only be a type or an integer
p17830
aVIt can be more than that, including a reference or pointer
p17831
aVBut you cannot have it a  as a value parameter
p17832
aVSo, even though the preferred way to write your code is to write a functor with an , you can still pass a map as a template argument
p17833
aVYou should be aware of the consequences:
p17834
aVOnly non-local variables can be passed and only non-static variables - variables with internal linkage can't be used
p17835
aVIt's very strange, and will confuse most C++ programmers
p17836
aVSo to summarize: Don't do it - but it's good to know that you can do it, and i think it's important to say the full truth, even though it may seem confusing at times
p17837
as(dp17838
g15
V34509
p17839
stp17840
a((dp17841
g2
(lp17842
VAn expression is not only classified by its type, but also by its lvalueness
p17843
aVThis one mostly determines whether it's stored somewhere, and it also determines whether it can be bound to non-const references
p17844
aVA non-const rvalue (non-lvalue) cannot be bound to non-const references, so if you do the following, you always fail:
p17845
aVThe second call may surprise you, but actually cv-qualifiers are dropped from non-class rvalues, and so the cast expression happens to have the type , still
p17846
aVSo the function template's parameter type will be deduced to  - compilation fails
p17847
aVNow, pre-C++0x  does only support non-const references as the type of argument it forwards, so if you give it a const argument it's fine - its templated parameter will make it so it becomes a const reference
p17848
aVBut if you give it a non-const argument, and it's an rvalue, it's not fine, because it won't be able to be bound by the reference parameter
p17849
aVYou want to call the bind object with an lvalue - that is, with  or with it cast to a const lvalue
p17850
aVNotice also that toplevel qualifiers of function parameter types are dropped, and so  effectively has type  - this toplevel cv-dropping happens for all types of parameters
p17851
aVAnyway, the solution is to change the call to
p17852
as(dp17853
g15
V34509
p17854
stp17855
a((dp17856
g2
(lp17857
VMore theoretically, if you derive one class from another, you have a base class and a derived class
p17858
aVIf you create an object of a derived class, you have a derived object
p17859
aVIn C++, you can inherit from the same class multiple times
p17860
aVConsider:
p17861
aVIn the  object, you have two  objects within each  objects, which are called "base-class sub-objects"
p17862
aVIf you try to convert  to , then the compiler will tell you the conversion is ambiguous, because it doesn't know to which  object you want to convert:
p17863
aVSame goes if you name a non-static member of : The compiler will tell you about an ambiguity
p17864
aVYou can circumvent it in this case by converting to  or  first:
p17865
aVThe object  is called the "most derived object", because it's not a sub-object of another object of class type
p17866
aVTo avoid the ambiguity above, you can inherit virtually
p17867
aVNow, there is only one subobject of type , even though you have two subobject that this one object is contained in: subobject  and sub-object
p17868
aVConverting a  object to  is now non-ambiguous, because conversion over both the  and the  path will yield the same  sub-object
p17869
aVHere comes a complication of the above: Theoretically, even without looking at any implementation technique, either or both of the  and  sub-objects are now not contiguous anymore
p17870
aVBoth contain the same A object, but both doesn't contain each other either
p17871
aVThis means that one or both of those must be "split up" and merely reference the A object of the other, so that both  and  objects can have different addresses
p17872
aVIn linear memory, this may look like (let's assume all objecs have size of 1 byte)
p17873
aVis what both the  and the  sub-object contains
p17874
aVNow, as you see, the  sub-object would be split up, and there is no way without, because  is not contained in , and neither the other way around
p17875
aVThe compiler, to access some member using code in a function of , can't just use an offset, because the code in a function of  doesn't know whether it's contained as a sub-object, or - when it's not abstract - whether it's a most derived object and thus has the  object directly next to it
p17876
as(dp17877
g15
V34509
p17878
stp17879
a((dp17880
g2
(lp17881
VIt's because the language expects a member to appear after
p17882
aVThat's how the language is made up
p17883
aVYou can use the function call syntax, if you like
p17884
aVIf you have to do this a lot in sequence, using  instead of the parentheses can improve readability greatly
p17885
aVOtherwise, for one level, i find  is perfectly readable to me
p17886
as(dp17887
g15
V34509
p17888
stp17889
a((dp17890
g2
(lp17891
VThere is a way which is completely allowed by the Standard
p17892
aVRead the Hidden features of C++ entry for an explanation
p17893
aVYou may write a macro for your convenience (the parenthesis are there so that you can use this macro also for types that have a comma, like ):
p17894
aVThe matter now becomes
p17895
as(dp17896
g15
V34509
p17897
stp17898
a((dp17899
g2
(lp17900
VPut the array into a struct
p17901
aVis such a package:
p17902
aVQuick and dirty:
p17903
aVNotice how you can use aggregate initialization syntax
p17904
as(dp17905
g15
V34509
p17906
stp17907
a((dp17908
g2
(lp17909
VThe member template is a dependent name, because its semantics depend on the type of
p17910
aVThat means you should put "template" before its name (to disambiguate the use of the "less-than" token), similar to how you should put  before dependent qualified names:
p17911
aVAs a workaround, you may use a helper type:
p17912
aVNow, you could define your  as follows:
p17913
aVThis comes handy for templated constructors, for which you cannot do  or something
p17914
aVThey will have to be deducible in that case
p17915
as(dp17916
g15
V34509
p17917
stp17918
a((dp17919
g2
(lp17920
VEven in C, using  isn't a good thing to do for converting user input
p17921
aVIt doesn't provide error checking at all
p17922
aVProviding a C++ version of it wouldn't be all that useful - considering that it wouldn't throw and do anything, you can just pass  to it and use it
p17923
aVInstead you should use  in C code, which does do error checking
p17924
aVIn C++03, you can use stringstreams to do the same, but their use is error-prone: What exactly do you need to check for
p17925
aV, , or
p17926
aVHow do you eat up remaining whitespace
p17927
aVWhat about formatting flags
p17928
aVSuch questions shouldn't bother the average user, that just want to convert his string
p17929
aVdoes do a good job, but incidentally, C++0x adds utility functions to facilitate fast and safe conversions, through C++ wrappers that can throw if conversion failed:
p17930
aVEffects: the \ufb01rst two functions call , and the last three functions
p17931
aVcall , , and , respectively
p17932
aVEach function returns the converted result, if any
p17933
aVThe argument  designates a pointer to an object internal to the function that is used to determine what to store at
p17934
aVIf the function does not throw an exception and , the function stores in  the index of the first unconverted element of str
p17935
aVReturns: the converted result
p17936
aVThrows:  if , , , or  reports that no conversion could be performed
p17937
aVThrows  if the converted value is outside the range of representable values for the return type
p17938
as(dp17939
g15
V34509
p17940
stp17941
a((dp17942
g2
(lp17943
Vfor-each loop in C99:
p17944
as(dp17945
g15
V34509
p17946
stp17947
a((dp17948
g2
(lp17949
VThe issue can be demonstrated by the following snippet
p17950
aVReplace line 412 by the following
p17951
as(dp17952
g15
V34509
p17953
stp17954
a((dp17955
g2
(lp17956
VCast to  within both branches:
p17957
as(dp17958
g15
V34509
p17959
stp17960
a((dp17961
g2
(lp17962
VThis is undefined behavior: The your class definitions define the same class type, and so they have to be both the same
p17963
aVFor the linker it means it can choose one arbitrary definition as the one that gets emitted
p17964
aVIf you want them to be separated types, you have to nest them into an unnamed namespace
p17965
aVThis will cause anything in that namespace to be unique for that translation unit:
p17966
aVSo then the question changes to: what happens to the second definition of the inline function during non-optimized compilation
p17967
aVAre they silently ignored
p17968
aVYes, for inline functions (functions defined within class definitions are inline, even if not explicitly declared inline), the same principle applies: They can be defined multiple times in the program, and the program behaves as if it was defined only once
p17969
aVTo the linker it means again it can discard all but one definition
p17970
aVWhich one it chooses is unspecified
p17971
as(dp17972
g15
V34509
p17973
stp17974
a((dp17975
g2
(lp17976
VA typedef-name denotes a type, and not a sequence of tokens (as does a macro)
p17977
aVIn your case,  denotes the type also denoted by the token sequence
p17978
aVSo the diagram looks like
p17979
aVSemantically if you specify the type , you get the following diagram (the brackets around the specifiers mean "the type denoted by the specifier"):
p17980
aVIt's not the same thing as the token sequence  - because this one would not denote a const qualified pointer type, but rather a pointer to a const qualified type (the thing pointed to would be const)
p17981
aVSyntactically a parameter declaration has the following (simplified) form:
p17982
aVThe declaration-specifiers in case of  are  - so the base-type of  is a const qualified , but the pointer itself is not qualified
p17983
aVIn case of  however the declaration-specifiers specify a const qualified  - which means the pointer type itself is qualified, making the parameter declaration identical to
p17984
as(dp17985
g15
V34509
p17986
stp17987
a((dp17988
g2
(lp17989
VThis was discussed on usenet some time ago, while i was trying to answer another question on stackoverflow: Point of Instantiation of Static Data Members
p17990
aVI think it's worth reducing the test-case, and considering each scenario in isolation, so let's look at it more general first:
p17991
aVYou have the definition of a static data member template
p17992
aVThis does not yet create any data members, because of :
p17993
aVin particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist
p17994
aVThe definition of something (= entity) is needed when that entity is "used", according to the one definition rule which defines that word (at )
p17995
aVIn particular, if all references are from uninstantiated templates, members of a template or a  expressions or similar things that don't "use" the entity (since they are either not potentially evaluating it, or they just don't exist yet as functions/member functions that are itself used), such a static data member is not instantiated
p17996
aVAn implicit instantiation by  instantiates declarations of static data members - that is to say, it will instantiate any template needed to process that declaration
p17997
aVIt won't, however, instantiate definitions - that is to say, initializers are not instantiated and constructors of the type of that static data member are not implicitly defined (marked as used)
p17998
aVThat all means, the above code will output nothing yet
p17999
aVLet's cause implicit instantiations of the static data members now
p18000
aVThis will cause the two static data members to exist, but the question is - how is the order of initialization
p18001
aVOn a simple read, one might think that  applies, which says (emphasis by me):
p18002
aVObjects with static storage duration defined in namespace scope in the same translation unit and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit
p18003
aVNow as said in the usenet post and explained in this defect report, these static data members are not defined in a translation unit, but they are instantiated in a instantiation unit, as explained at :
p18004
aVEach translated translation unit is examined to produce a list of required instantiations
p18005
aV[Note: this may include instantiations which have been explicitly requested (14
p18006
ag3311
aV2)
p18007
aV] The definitions of the required templates are located
p18008
aVIt is implementation-defined whether the source of the translation units containing these definitions is required to be available
p18009
aV[Note: an implementation could encode sufficient information into the translated translation unit so as to ensure the source is not required here
p18010
aV] All the required instantiations are performed to produce instantiation units
p18011
aV[Note: these are similar to translated translation units, but contain no references to uninstantiated templates and no template definitions
p18012
aV] The program is ill-formed if any instantiation fails
p18013
aVThe Point of Instantiation of such a member also does not really matter, because such a point of instantiation is the context link between an instantiation and its translation units - it defines the declarations that are visible (as specified at , and each of those point of instantiations must give instantiations the same meaning, as specified in the one definition rule at , last bullet)
p18014
aVIf we want ordered initialization, we have to arrange so we don't mess with instantiations, but with explicit declarations - this is the area of explicit specializations, as these are not really different to normal declarations
p18015
aVIn fact, C++0x changed its wording of  to the following:
p18016
aVDynamic initialization of a non-local object with static storage duration is either ordered or unordered
p18017
aVDefinitions of explicitly specialized class template static data members have ordered initialization
p18018
aVOther
p18019
aVclass template static data members (i
p18020
ag1992
aV, implicitly or explicitly instantiated specializations) have unordered initialization
p18021
aVThis means to your code, that:
p18022
aVand  commented: No reference to the static data members exist, so their definitions (and also not their declarations, since there is no need for instantiation of ) are not instantiated
p18023
aVNo side effect occurs
p18024
aVuncommented:  is used, which in itself uses , which requires that static member to exist
p18025
aVThe string is initialized prior to main (at any case before that statement, as part of initializing non-local objects)
p18026
aVNothing uses , so it's not instantiated, and so no object of  is ever created, which makes its constructor not being used, which in turn will never assign something to : You will just output an empty string
p18027
aVand  uncommented: That this worked for you is luck (or the opposite :))
p18028
aVThere is no requirement for a particular order of initialization calls, as explained above
p18029
aVIt might work on VC++, fail on GCC and work on clang
p18030
aVWe don't know
p18031
aVcommented,  uncommented: Same problem - again, both static data members are used:  is used by , and the instantiation of  will cause its constructor to be instantiated, which will use  - but for your compiler, the order is different in this particular run (unspecified behavior is not required to be consistent among different runs): It initializes  first, which will operate on a not-yet-constructed string object
p18032
as(dp18033
g15
V34509
p18034
stp18035
a((dp18036
g2
(lp18037
VWhy does your  not work, while your  works
p18038
aVFirst i want to show you another way to solve it by use of an elaborated type specifier:
p18039
aVThat works because "class some_class" is an elaborated type specifier, which will ignore any non-type declarations when looking up the name you specify, so the POSIX function at global scope, which has the same name, will not hide the class name
p18040
aVYou tried two other ways to solve it: Using directives and using declarations:
p18041
aVThen, you tried to stick the type into a namespace, and tried  in main - why did it not work
p18042
aVYou might wonder why that is so, because you might have thought that the using directive declares the names of  into the local scope of main - but that's not the case
p18043
aVIt's not declaring any name, actually it's just a link to another namespace
p18044
aVIt's making a name visible during unqualified name lookup in that case - but the name is made visible as a member of the namespace enclosing both the using-directive and the denoted namespace ()
p18045
aVThat enclosing namespace is the global namespace here
p18046
aVSo what happens is that name lookup will find two declarations of that name - the global POSIX  declaration, and the class declaration within
p18047
aVThe declarations were not made in the same scope (declarative region), and so the function name doesn't hide the class name as usual (see  for an example where it does), but the result is an ambiguity
p18048
aVA using declaration however declares one name as a member of the declarative region that it appears in
p18049
aVSo, when  is looked up starting from , it will first find a name that refers to the declaration of  in , and this will effectively hide the global POSIX function
p18050
aVSo the following works
p18051
as(dp18052
g15
V34509
p18053
stp18054
a((dp18055
g2
(lp18056
VI've just added an entry to my blog that shows how it can be done
p18057
aVHere is an example on how you use it for the following class
p18058
aVJust declare a tag name and instantiate a robber like the following example shows (my post shows the implementation of the robber)
p18059
aVYou can then access that member using a member pointer
p18060
aVBut actually, this doesn't show that c++'s access rules aren't reliable
p18061
aVThe language rules are designed to protect against accidental mistakes - if you try to rob data of an object, the language by-design does not take long ways to prevent you
p18062
as(dp18063
g15
V34509
p18064
stp18065
a((dp18066
g2
(lp18067
VYou haven't shown the class definition enclosing these function-declarations
p18068
aVBut i assume it's some class where these templates are declared in
p18069
aVYou have to define the specializations outside:
p18070
aVRemember that since you have defined them outside, they are not inline implicitly, so you either have to make them inline explicitly, or move them into a  file (not a header), and forward-declare the specializations in the header like this:
p18071
aVIf you omit the forward-declaration, the compiler has no way to know whether to instantiate the functions or to use the explicit specializations
p18072
aVThe forward declaration tells it
p18073
as(dp18074
g15
V34509
p18075
stp18076
a((dp18077
g2
(lp18078
VThis one got me upset back then:
p18079
aVThe last line in main is ambiguous, because the compiler not only looks up  within , but also as an unqualified name starting from within
p18080
aVSo it finds both  and
p18081
aVTo fix this, you have to write
p18082
aVGCC does not care about that, and accepts the above code by doing the intuitive thing (calling the member), other compilers do better and warn like comeau:
p18083
as(dp18084
g15
V34509
p18085
stp18086
a((dp18087
g2
(lp18088
VThere recently was a discussion about this kicked off in usenet: Why no VLAs in C++0x
p18089
aVI agree with those people that seem to agree that having to create a potential large array on the stack, which usually has only little space available, isn't good
p18090
aVThe argument is, if you know the size beforehand, you can aswell use a static array
p18091
aVAnd if you don't know the size beforehand, you will write unsafe code
p18092
aVC99 VLAs could provide a small benefit of being able to create small arrays without wasting space or calling constructors for not used elements, but they will introduce rather large changes to the type system (you need to be able to specify types depending on runtime values - this does not yet exist in current C++, except for  operator type-specifiers, but they are treated specially, so that the runtime-ness doesn't escape the scope of the  operator)
p18093
aVYou can use , but it is not quite the same, as it uses dynamic memory, and making it use ones own stack-allocator isn't exactly easy (alignment is an issue, too)
p18094
aVIt also doesn't solve the same problem, because a vector is a resizable container, whereas VLAs are fixed-size
p18095
aVThe C++ Dynamic Array proposal is intended to introduce a library based solution, as alternative to a language based VLA
p18096
aVHowever, it's not going to be part of C++0x, as far as i know
p18097
as(dp18098
g15
V34509
p18099
stp18100
a((dp18101
g2
(lp18102
VIf you are passing , you are actually passing a  (an array of 100 doubles), that happens to be passed as a pointer to its first element
p18103
aVIf you advance further than those 100 doubles using  added to that pointer, you advance into the next array of 100 doubles, since the 100 arrays of 100 doubles are stored next to each other
p18104
aVBackground: A multi-dimensional array is an array whose element type is itself an array
p18105
aVAn array like  can be declared equivalently as
p18106
aVIf you use an array like a pointer, a temporary pointer is created to the array's first element (which might be an array)
p18107
aVThe  operator is such an operation, and doing  creates a pointer of type  (which is a pointer to an array of 100 doubles), and dereferences it
p18108
aVSo what you end up with  is a
p18109
aVPassing it to the  function will create a pointer to its first element, which is of type
p18110
aVYour pointer parameters point to the start of each of two arrays of 100 doubles each
p18111
aVSo you should rewrite the function as
p18112
aVNotice that since your  iterates beyond the first of the 100 arrays stored in the 2d array, you will formally not be correct with this
p18113
aVBut as it happens those arrays must be allocated next to each other, it will work in practice (and in fact, is recommended as a good enough work around for passing multi-dimensional arrays around as pointers to their first scalar element)
p18114
as(dp18115
g15
V34509
p18116
stp18117
a((dp18118
g2
(lp18119
VIn C, there are two (actually more, but i keep it at this) kind of namespaces: Ordinary identifiers, and tag identifiers
p18120
aVA struct, union or enum declaration introduces a tag identifier:
p18121
aVThe namespace from which the identifier is chosen is specified by the syntax around
p18122
aVHere, it is prepended by a
p18123
aVIf you want to introduce an ordinary identifier, put it inside a typedef declaration
p18124
aVOrdinary identifiers don't need special syntax
p18125
aVYou may declare a tag and ordinary one too, if you like
p18126
as(dp18127
g15
V34509
p18128
stp18129
a((dp18130
g2
(lp18131
VWhat are your alternatives
p18132
aVThat will create a copy of any string passed, even if the type matches exactly: Overhead that's not really needed
p18133
aVThat will allow changing the passed argument
p18134
aVWe don't want to do that, and C++ does not allow us to pass a temporary anymore, to protect us from changing a temporary (where those changes are lost in the next moments anyway)
p18135
aVSo, the way you have it fits on two sides: It allows us to pass non-temporary strings without copying them, and it allows us to pass temporary strings
p18136
aVAnd it protects us from trying to change the argument
p18137
aVSeems like a good compromise
p18138
as(dp18139
g15
V34509
p18140
stp18141
a((dp18142
g2
(lp18143
VBy default if  is a template parameter like in your example, the  is assumed not to name a type
p18144
aVYou have to explicitly specify that it is, by prefixing it with :
p18145
aVThis resolves some parsing problems like in the following example
p18146
aVSo that the compiler can parse this even before instantiating the template, you have to give it a hand and use , including in those cases where it wouldn't be ambiguous, like in the first case above
p18147
aVThe Template FAQ has more insight into this
p18148
as(dp18149
g15
V34509
p18150
stp18151
a((dp18152
g2
(lp18153
VImagine you want to print an object that can't be copied:
p18154
aVThe reference version will not copy the thread, but will take the address of  and create an alias to it
p18155
aVThe other version would try to copy the thread when passing by value - but copying may not be senseful for such an object (would there be one additional thread then
p18156
aVIt may help you to think of copy an object as cloning an object
p18157
aVCopying  above in C++ does not merely mean to have another handle to the same object as in Java - it does mean to implicitly clone the object denoted, and have a whole copy of it
p18158
aVSo the question is similar to "Why does Java support both  and copying of references
p18159
aV- both have different purposes
p18160
aVAnd then there is a matter of performance too, after all
p18161
aVYou don't want to copy each and every time you pass something around for resource hungry objects
p18162
as(dp18163
g15
V34509
p18164
stp18165
a((dp18166
g2
(lp18167
VA member function must be first declared in its class (not in a friend declaration)
p18168
aVThat must mean that prior to the friend declaration, you should have the class of it defined - a mere forward declaration does not suffice
p18169
as(dp18170
g15
V34509
p18171
stp18172
a((dp18173
g2
(lp18174
VYes, and the reason is that on the very beginning of evaluating any expression, references are being replaced by the object that's referenced, as defined at  in the Standard
p18175
aVThat will make it so the -operator doesn't see any difference:
p18176
aVIf an expression initially has the type "reference to T" (8
p18177
ag1037
aV2, 8
p18178
ag1014
aV3), the type is adjusted to "T" prior to any further analysis, the expression designates the object or function denoted by the reference, and the expression is an lvalue
p18179
aVThis makes it so that any operator that operates on an expression "sees through" the reference
p18180
as(dp18181
g15
V34509
p18182
stp18183
a((dp18184
g2
(lp18185
VYou can have two functions called
p18186
aVThe name is not special in any way and it's not reserved
p18187
aVWhat's special is the function, and it happens to have that name
p18188
aVThe function is global
p18189
aVSo if you write a main function in some other namespace, you will have a second  function
p18190
aVThe first  function is not special - notice how you have to  explicitly
p18191
as(dp18192
g15
V34509
p18193
stp18194
a((dp18195
g2
(lp18196
VYou can use
p18197
aVIt's formally deprecated, but it's still a great tool if you need to work with C strings, i think
p18198
aVThis will write  and then  into the stream, and append a terminating  using
p18199
aVIn case both strings could end up writing exactly  characters - so no space would be left writing  - we write one manually at the last position
p18200
as(dp18201
g15
V34509
p18202
stp18203
a((dp18204
g2
(lp18205
VNo assignment operator is used in the first test-case
p18206
aVIt just uses the initialization form called "copy initialization"
p18207
aVCopy initialization does not consider explicit constructors when initializing the object
p18208
aVCopy initialization is used in those cases that correspond to implicit conversions, where one does not explicitly kick off a conversion, as in function argument passing, and returning from a function
p18209
as(dp18210
g15
V34509
p18211
stp18212
a((dp18213
g2
(lp18214
VYou forgot
p18215
aVThe  just says that you are going to use a typename that at the point of the template declaration is not yet known as a type
p18216
aVIf you actually want to create a typedef, you actually need that keyword in addition
p18217
aVAnd i think you forgot to actually name the type when you use it below:
p18218
aVRemember to initialize the reference
p18219
aVIf you know in advance that  is never a reference (to avoid the reference-to-reference problem) you can also do this directly:
p18220
aVIf what you wanted to do is to create a reference data member, your syntax without  was correct
p18221
aVI do not know what you want to do exactly
p18222
as(dp18223
g15
V34509
p18224
stp18225
a((dp18226
g2
(lp18227
VThe problem is that when you read something and  sees the input can never be a double, it stops reading, leaving the stuff in the buffer that it didn't consume
p18228
aVIt will signal failure, which you clear but you won't eat the remaining input that  didn't eat up
p18229
aVSo, the next time the same wrong input is tried to read again, and again
p18230
aVThe problem with the  one is that you have to press the return key to make it process any characters on most terminals (this does not happen if you make your program read from a file, for instance)
p18231
aVSo if you press  then it won't go out of the read call, until you hit the return key
p18232
aVHowever, then it will normally proceed and exit the loop
p18233
aVAs others mentioned you are better off with reading a whole line, and then decide what to do
p18234
aVYou can also check the number with C++ streams instead of C functions:
p18235
aVThis reads any initial double number and then any remaining whitespace
p18236
aVIf it then hit  (end of the file/stream), it means the string contained only a double
p18237
aVFor the char, you can just test for length 1
p18238
aVIf you want to read only 1 char and continue as soon as that char was typed, then you will have to use platform dependent functions (C++ won't provide them as standard functions)
p18239
aVLook out for the conio
p18240
aVh file for windows for instance, which has the  function for this
p18241
aVOn unix systems, ncurses provides such functionality
p18242
as(dp18243
g15
V34509
p18244
stp18245
a((dp18246
g2
(lp18247
VThe temporary is destructed as soon as the initialization of  is complete
p18248
aVAnd the reference member will be dangling, referring to a not anymore existing object
p18249
aVThe solution is not difficult or complicated at all
p18250
aVA polymorphic object usually is not temporary, but it exists for a longer time
p18251
aVSo you just use a smart pointer to store a reference to the passed object and create the object before-hand with
p18252
aVNotice that for this, the class  must have a virtual destructor
p18253
aVThe  will care about destroying the object when your parent object ends lifetime
p18254
aVWhen copied,  will share the pointed to object with the copy, and both point to the same object
p18255
aVThis is not necessarily obvious to users of  and not intended for many use cases, so you may wish to make its copy constructor and assignment operator private:
p18256
aVOr you use a reference member and store the object on the stack and pass it along to the constructor like you were showing
p18257
aVLengthening the lifetime of a temporary is only done when directly assigning to a const reference:
p18258
aVThen you can also get away with a non-virtual destructor and may call virtual functions on  - provided they are const member functions
p18259
aVThis special handling is not done for class members though, and it has the downside of requiring a working copy constructor (polymorphic objects usually are not copyable or designed to be so - they are are identified not by value, but by identity)
p18260
aVAnything temporary of other nature is destroyed after the end of the full expression in which it appears - so happening for your temporary  object
p18261
as(dp18262
g15
V34509
p18263
stp18264
a((dp18265
g2
(lp18266
VGetting on the language side of this, since the assembler side has already been handled:
p18267
aVNote this sentence: " an expression of the form a[i] causes the array to decay into a pointer, following the rule above, and then to be subscripted just as would be a pointer variable in the expression p[i] (although the eventual memory accesses will be different, " I'm pretty confused of this: since a has decayed to pointer, then why does he mean about "memory accesses will be different
p18268
aVThis is because after decaying, access is equal for the (now a pointer value) and the pointer
p18269
aVBut the difference is how that pointer value is got in the first place
p18270
aVLet's look at an example:
p18271
aVNow, you have an array
p18272
aVThis array does not take any storage other than one char
p18273
aVThere is no pointer stored for it
p18274
aVAnd you have a pointer that points to a char
p18275
aVThe pointer takes the size of one address, and you have one char that the pointer points to
p18276
aVNow let's look what happens for the array case to get the the pointer value:
p18277
aVThe pointer case is different:
p18278
aVAs you see, for the array case for getting the pointer value needed where we add the index value to (in this case a boring ), we don't need to read from memory, because the address of the array is already the pointer value needed
p18279
aVBut for the pointer case, the pointer value we need is stored in the pointer: We need one read from memory to get that address
p18280
aVAfter this, the path is equal for both:
p18281
aVHere is the assembler code generated for the array and the pointer case:
p18282
aVWe can just store  (ASCII for ) at the address of  (which will be known already at compile or link time when it is global)
p18283
aVFor the pointer case, we will first have to load the address stored by it into register , and then write the  to that address
p18284
as(dp18285
g15
V34509
p18286
stp18287
a((dp18288
g2
(lp18289
VIf you want to return a double (i
p18290
aVe the type that you would get when dereferencing), you can use the iterator traits:
p18291
aVThese work for all iterators, including pointers:
p18292
as(dp18293
g15
V34509
p18294
stp18295
a((dp18296
g2
(lp18297
VThere are two ways i know of
p18298
aVDon't declare them in the header
p18299
aVOne way is to not declare those functions inside the header
p18300
aVThey can be placed into unnamed namespaces within the implementation file, only
p18301
aVIndeed, you will then have to implement any function that accesses this private function in the implementation file (not inline in the header)
p18302
aVPut them into a detail namespace
p18303
aVPreferably, you put them in a different header, and include them
p18304
aVSo the code of them won't disturb your interface header
p18305
aVThis is how  does it, too:
p18306
as(dp18307
g15
V34509
p18308
stp18309
a((dp18310
g2
(lp18311
VWith regard to your declaration without : These are called "access declarations", and are deprecated
p18312
aVHere is the text from the Standard, from :
p18313
aVThe access of a member of a base class can be changed in the derived class by mentioning its qualified-id in
p18314
aVthe derived class declaration
p18315
aVSuch mention is called an access declaration
p18316
aVThe effect of an access declaration  is defined to be equivalent to the declaration  [Footnote: Access declarations are deprecated; member using-declarations (7
p18317
ag1037
aV3) provide a better means of doing the same things
p18318
aVIn earlier versions of the C++ language, access declarations were more limited; they were generalized and made equivalent to using-declarations - end footnote]
p18319
aVI would say that most often it's not good to change public members to private or protected members in the derived class, because this will violate the substitution principle: You know a base class has some functions, and if you cast to a derived class then you expect those functions to be callable too, because the derived class is-a base
p18320
aVAnd like you already mentioned, this invariant is already enforced anyway by the language allowing to convert (which working implicitly
p18321
aVto a base class reference, or qualifying the function name, and then calling the (then public) function
p18322
aVIf you want to forbid someone calling a set of functions of the base, then i think this hints that containment (or in rare cases, private inheritance) is a better idea
p18323
as(dp18324
g15
V34509
p18325
stp18326
a((dp18327
g2
(lp18328
VWith the  compiler, you can see them by passing the  argument
p18329
aVClang is still in development stage, but you can already use it for these things:
p18330
aVI hope that's what you asked for
p18331
aVLet's change the code and look again
p18332
aVNotice how the implicitly declared copy constructor of  now has a non-const reference parameter, because one of its members has too (member ), and that  has no default constructor declared
p18333
aVFor getting the generated code, you can let it emit virtual machine intermediate language
p18334
aVLet's look on the generated code for this:
p18335
aVNow, i don't understand that intermediate language (which is defined at llvm
p18336
aVorg)
p18337
aVBut you can translate all that code into C using the llvm compiler:
p18338
aVTada
p18339
aVNotice how it sets the virtual table pointer in the copy constructor and default constructor
p18340
aVHope this helps
p18341
as(dp18342
g15
V34509
p18343
stp18344
a((dp18345
g2
(lp18346
VI think you can just use a static function for this, and inherit its class:
p18347
aVOf course, that won't be a static compile time constant - i don't think that is possible automatically (you would have to add those types manually to some type list like )
p18348
aVPlease notice that for just comparing types for equality, you don't need all this
p18349
aVYou just need to use  (found in boost and other libraries and trivial to write) which yields a compile time constant
p18350
as(dp18351
g15
V34509
p18352
stp18353
a((dp18354
g2
(lp18355
VI'm returning a reference, because a string seems not "cheap to copy" to me
p18356
aVIt's a complex data type with dynamic memory management and all that
p18357
aVThe "if you want the caller to get a copy, you should return by value" argument is moot, because it doesn't preclude copies at all
p18358
aVThe caller can still do the following and get a copy anyway
p18359
aVYou need to explicitly create a reference on the caller side to be able to refer to the data member directly afterwards - but why would you do that
p18360
aVThere definitely are enough user defined types that are cheap to copy
p18361
aVSmart Pointers
p18362
aVIterators
p18363
aVAll of the non-class types
p18364
as(dp18365
g15
V34509
p18366
stp18367
a((dp18368
g2
(lp18369
VYou have one address-of too much:
p18370
aVYou were adding one to the address of your parameter (and thus were pointing to nowhereland), instead of  to the value of your parameter (which will bring you to after the array data, which is your goal)
p18371
aVNotice that the parameter is a pointer to an array of dimensions
p18372
aVIn other words, the argument you pass to the function can be an array of type , which will decay to the pointer type of that parameter
p18373
aVYou have  rows, so you add  to that pointer to reach the position after the last cell
p18374
aVWhat you were probably having in mind was adding one to the pointer to the whole array
p18375
aVThis will work if you have the following declaration, instead
p18376
aVYou now need to pass the argument using  instead of just , to actually pass the address of the array, instead of letting it decay to its inner dimension type
p18377
aVThe loop can then be written as
p18378
as(dp18379
g15
V34509
p18380
stp18381
a((dp18382
g2
(lp18383
VI would put an
p18384
aVNot handling an enumeration value, while the intention is to cover all cases, is an error in the code that needs to be fixed
p18385
aVThe error can't be resolved from nor handled "gracefully", and should be fixed right away (so i would not throw)
p18386
aVFor having the compiler be quiet about "returning no value" warnings, call , like so
p18387
aVNo warning by the compiler anymore about a return without value, because it knows  never returns
p18388
aVWe immediately terminate the failing program, which is the only reasonable reaction, in my opinion (there is no sense in trying to continue to run a program that caused undefined behavior)
p18389
as(dp18390
g15
V34509
p18391
stp18392
a((dp18393
g2
(lp18394
VThe answer is no
p18395
aV: Except for bit-\ufb01elds, objects are composed of contiguous sequences of one or more bytes, the number, order, and encoding of which are either explicitly speci\ufb01ed or implementation-de\ufb01ned
p18396
aVNo such specification is done for function / void pointers
p18397
as(dp18398
g15
V34509
p18399
stp18400
a((dp18401
g2
(lp18402
VYou are not initializing anything in your default constructor
p18403
aVThat means that the destructor will go mad on a default constructed object
p18404
aVYou are also not disabling the copy constructor, which is not functioning with your class, because if you have copied an object, it will try to delete the same table twice
p18405
aVChange it as follows, for example
p18406
as(dp18407
g15
V34509
p18408
stp18409
a((dp18410
g2
(lp18411
VFirst you have to understand the C99 inline model - perhaps there is something wrong with your headers
p18412
aVThere are two kind of definitions for inline functions with external (non-static) linkage
p18413
aVExternal definition
p18414
aVThis definition of a function can only appear once in the whole program, in a designated TU
p18415
aVIt provides an exported function that can be used from other TUs
p18416
aVInline definition
p18417
aVThese appear in every TU where declared as a separate definition
p18418
aVThe definitions do not need to be identical to one another or to the external definition
p18419
aVIf used internal in a library, they can do omit checking on function arguments that would otherwise be done in the external definition
p18420
aVEach definition of the function has its own local static variables, because their local declarations have no linkage (they are not shared like in C++)
p18421
aVA definition of a non-static inline function will be an inline definition if
p18422
aVEvery function declaration in a TU includes the specifier , and
p18423
aVNo function declaration in a TU includes the specifier
p18424
aVOtherwise, the definition that must appear in that TU (because inline functions must be defined in the same TU where declared) is an external definition
p18425
aVIn a call to an inline function it's unspecified whether the external or the inline definition is used
p18426
aVHowever, because the function defined in all cases is still the same (because it has external linkage), the address of it compares equal in all cases, no matter how many inline definitions appear
p18427
aVSo if you take the function's address, it's likely the compiler resolves to the external definition (especially if optimizations are disabled)
p18428
aVAn example that demonstrates a wrong use of , because it includes an external definition of a function twice in two TUs, causing a multiple definition error
p18429
aVThe following program is dangerous, because the compiler is free to use the external definition, but the program does not provide one
p18430
aVI have made some test cases using GCC that demonstrate the mechanism further:
p18431
aVmain
p18432
ag2259
aVmain1
p18433
ag2259
aVmain2
p18434
ag2259
aVNow, the program outputs what we expected
p18435
aVLooking at the symbol table, we will see that the symbol of an inline definition is not exported (from ), while an external definition is exported (from )
p18436
aVNow, if your static libraries each have an external definition of their inline functions (as they should), they will naturally conflict with each other
p18437
aVThe solution is to make the inline functions static or just to rename them
p18438
aVThese will always provide external definitions (so they are full fledged definitions), but they are not exported because they have internal linkage, thus not conflicting
p18439
as(dp18440
g15
V34509
p18441
stp18442
a((dp18443
g2
(lp18444
VThat's correct
p18445
aVA typedef-name cannot be used in such a forward declaration (this is technically called an elaborated type specifier, and if such a specifier resolves to a typedef-name, the program is ill-formed)
p18446
aVI don't understand why you actually need the forward declaration in the first place
p18447
aVBecause if you already have the typedef in place, why not just use that typedef
p18448
aVIt's just aswell denoting that class
p18449
aVEdit: From your comment, it seems you need a designated forward declaration header, much in the same vain of
p18450
aVSo, if you template is called , this a header can look like
p18451
aVTestFwd
p18452
ag3601
aVThen you can just use that header, instead of doing , which the compiler has no clue about what it is (and will think it is a new class, independent of any template and typedef)
p18453
as(dp18454
g15
V34509
p18455
stp18456
a((dp18457
g2
(lp18458
VThat's not valid
p18459
aVThe only valid place where  may be used in a function parameter i'm aware of is in an array dimension
p18460
aVSaying that  will, in all calls to this function, point to memory providing at least  floats (this is a C99 addition, it doesn't appear in C89)
p18461
as(dp18462
g15
V34509
p18463
stp18464
a((dp18465
g2
(lp18466
VI suspect someone should tell you why it could not be a good idea to not use overloading or specialization
p18467
aVConsider:
p18468
aVYou might think on a first sight that it will work for  too, because it will only try to call  for strings
p18469
aVBut that intuition is wrong: The compiler still checks the string branch, even if that branch is not taken at runtime
p18470
aVAnd it will find you are trying to call a member function on non-classes if  is an int
p18471
aVThat's why you should separate the code if you need different behavior
p18472
aVBut better use overloading instead of specialization, since it's easier to get a clue how things work with it
p18473
aVYou have also better separated the code for different paths of behavior
p18474
aVIt's not all anymore clued together
p18475
aVNotice that with overloading, the parameters may have different type forms and the compiler will still use the correct version if both match equally well, as is the case here: One can be a reference, while the other can not
p18476
as(dp18477
g15
V34509
p18478
stp18479
a((dp18480
g2
(lp18481
VThis one works:
p18482
aV(outputs )
p18483
as(dp18484
g15
V34509
p18485
stp18486
a((dp18487
g2
(lp18488
VSome answers here say a 2-dimensional array is an array of pointers to other arrays
p18489
aVThat's not true (where to store pointers, if all you allocate is the data of the array
p18490
aVInstead, a 2-dimensional array is an array of other arrays
p18491
aVThus, you will have to change the type of your member:
p18492
aVThat is because  returns a pointer to the first element of an array created
p18493
aVThis element is an array of 10 integers, and thus the member type change
p18494
aVIf the syntax scares you off, simplify it with a temlate (this template is equivalent to )
p18495
aVThis effectively works like a in-place typedef
p18496
aVOf course, like with any use of , it needs a proper  placed in the destructor and invoked when your object is destroyed
p18497
aVSince  allocates an array of elements that have types known at compile time, you can only have the first (most outer) dimension set to a runtime value - all others must have values known at compile time
p18498
aVIf that is not what you want, you will have to allocate an array of pointers, like some other answers say
p18499
aVBut notice, to avoid further confusion, that those are not multi-dimensional arrays
p18500
aVThey are single-dimensional arrays of pointers, which happen to point at other single-dimensional arrays
p18501
as(dp18502
g15
V34509
p18503
stp18504
a((dp18505
g2
(lp18506
VChange the definition of  to the following:
p18507
aVNotice that the typedef and  don't necessarily specify the same type: While the typedef relies on  being passed to ,  relies on the template parameter  being passed
p18508
aVSo you cannot use the  here to specify a definition for  in
p18509
as(dp18510
g15
V34509
p18511
stp18512
a((dp18513
g2
(lp18514
VAnother point is when the pointed data of members is immutable
p18515
aVIt is not observable that you share it across instances by using reference counted smart pointers
p18516
aVFor example, i have some code that looks like
p18517
aVI didn't declare a copy constructor and copy assignment operator, because you cannot change  anyway, so it can be shared across multiple instances
p18518
as(dp18519
g15
V34509
p18520
stp18521
a((dp18522
g2
(lp18523
VThere is no way in C89 to do what you desire, because an array type in C can only be specified with compile time known values
p18524
aVSo in order to avoid the mad dynamic allocation, you will have to stick to the one dimensional way
p18525
aVYou may use a function to ease this process
p18526
aVIn C99 you can use an ordinary array syntax even if the dimensions are runtime values:
p18527
aVHowever, it only works with local non-static arrays
p18528
as(dp18529
g15
V34509
p18530
stp18531
a((dp18532
g2
(lp18533
VAlternatively you can do it recursively
p18534
aVYou can then process it like this
p18535
as(dp18536
g15
V34509
p18537
stp18538
a((dp18539
g2
(lp18540
VThe Standard forbids you to do  - exactly because it's not an lvalue
p18541
aVOrdinarily, if this was allowed, then the temporary resulting from that function call will live until the outer function returns and every other thing in the whole expression has completed being processed
p18542
aVThis can be called "destroying temporaries after end of full-expression", and ensures things like the following works as expected
p18543
aVThe compiler gives you a diagnostic - that's all the Standard requires for ill-formed code
p18544
aVIt doesn't force the compiler to abort compilation, for instance
p18545
aVBut after code being ill-formed was diagnosed, the compiler can do everything it wants
p18546
aVSo if you want to know what the compiler does in your case, you should read its manual
p18547
as(dp18548
g15
V34509
p18549
stp18550
a((dp18551
g2
(lp18552
VFor static member specializations, if you don't initialize the member, it is taken as a specialization declaration, that just says "Oh, don't instantiate the member from the primary template, because there is a specialized definition somewhere else"
p18553
aVIt should be mentioned that the definition should appear in a
p18554
aVcpp file (otherwise, you will earn the opposite: multiple definitions), and the declaration without initializer should still be placed in the header file
p18555
aVNow the correct syntax is indeed the following, and it should not appear in a header file, but in a  file
p18556
aVThe following should still appear in a header file:
p18557
aVThis will serve as the specialization declaration
p18558
aVFrom this, it follows that you can't specialize a member that only has a default constructor and is not copyable, because you would need this syntax:
p18559
aVC++0x fixes this:
p18560
aVFor the Standardese people among us, here are the quotes:
p18561
ag1240
aVIf a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required
p18562
ag1240
aVAn explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration
p18563
aV[Note: there is no syntax for the definition of a static data member of a template that requires default initialization
p18564
aVThis is a declaration regardless of whether X can be default initialized (8
p18565
aV5)
p18566
ag4885
ag1240
aVEvery program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required
p18567
ag1240
aVThere can be more than one definition of a class type (clause 9), enumeration type (7
p18568
aV2), inline function with external linkage (7
p18569
ag2790
aV2), class template (clause 14), non-static function template (14
p18570
ag1014
aV5), static data member of a class template (14
p18571
ag1014
ag2790
aV3), member function of a class template (14
p18572
ag1014
ag2790
aV1), or template specialization for which some template parameters are not specified (14
p18573
aV7, 14
p18574
ag1014
aV4) in a program [
p18575
aVThe restriction of this to "for which some template parameters are not specified" means that we are allowed to do the following, placing it into a header (thus possibly having multiple definitions of this specialization):
p18576
aVIn your case, you have all parameters specified, making it not being covered by the one defintion rule for allowing multiple definitions
p18577
as(dp18578
g15
V34509
p18579
stp18580
a((dp18581
g2
(lp18582
VYou cannot
p18583
aVStandardese at :
p18584
aVA handler is a match for an exception object of type E if
p18585
aVThe handler is of type  or  and E and T are the same type (ignoring the top-level cv-
p18586
aVqualifiers), or
p18587
aVthe handler is of type  or  and T is an unambiguous public base class of E, or
p18588
aVthe handler is of type  and E is a pointer type that can be converted to the type of the handler
p18589
aVby either or both of
p18590
aVa standard pointer conversion (4
p18591
aV10) not involving conversions to pointers to private or protected or
p18592
aVambiguous classes
p18593
aVa qualification conversion
p18594
aVYour desired scenario matches none of these
p18595
aVmeans "const and/or volatile combination"
p18596
as(dp18597
g15
V34509
p18598
stp18599
a((dp18600
g2
(lp18601
VThere is the class  for suppressing those log messages
p18602
aVSee http://docs
p18603
aVwxwidgets
p18604
aVorg/stable/wx_wxlognull
p18605
aVhtml#wxlognull where also an example is given
p18606
aVRead the  for more details on how wxWidgets handles this
p18607
as(dp18608
g15
V34509
p18609
stp18610
a((dp18611
g2
(lp18612
VThe inner arrays seem to be fixed to size of 2
p18613
aVYou could therefor use a vector of
p18614
aVUsage is like
p18615
aVNo need for manual memory management since you use
p18616
aVis in boost, but you can quickly write a similar class manually
p18617
aVThe data member is an array of  elements of type
p18618
aVAlternatively, you can write this using low-level 2d arrays
p18619
aVSince the inner dimension is fixed in your code, you can actually allocate a real, native 2d array instead of a complicated 1d array of pointers to separate buffers:
p18620
aVNow you can use it like
p18621
aVNotice the use of  (from  or see below) to simplify the syntax
p18622
aVYou would need to write the following otherwise
p18623
as(dp18624
g15
V34509
p18625
stp18626
a((dp18627
g2
(lp18628
VYou can write a constructor accepting anything, and then delegate to whatever the policies provide:
p18629
aVNow, once you forward the argument, the compiler will figure out the best match among the policies:
p18630
as(dp18631
g15
V34509
p18632
stp18633
a((dp18634
g2
(lp18635
VIn a C array, any element is an object
p18636
aVIt's not like in Java where you have references that first have to be assigned to point to objects
p18637
aVAnything in C behaves like a primitive type in Java
p18638
aVIf you have an array of pointers in C, you may view this similar to how things in Java work
p18639
aVYou can use null pointers to designate "is not filled to point to an object":
p18640
aVThen you can simply test with
p18641
as(dp18642
g15
V34509
p18643
stp18644
a((dp18645
g2
(lp18646
VIt knows the difference between them because of the type of the pointer you pass to it: It is undefined behavior to pass a different pointer type than you allocated with (except you may pass a pointer to a base class, if the destructor is , of course)
p18647
aVThe size of an array will be stored somewhere
p18648
aVIt's like in C where you can malloc a certain amount of memory, and free afterwards - the runtime will have to manage to know the size allocated previously
p18649
aVFor example it can store the count of elements prior to the buffer allocated
p18650
aVThe Standard explicitly allows the compiler to pass a different request size to the allocation function () in case of array allocations - this can be used by the compiler to stick the count into, and offset the address returned by the  expression by the size of that counter
p18651
as(dp18652
g15
V34509
p18653
stp18654
a((dp18655
g2
(lp18656
VThe C90 Standard says
p18657
aVThe type of an integer constant is the first of the corresponding list in which its value can be represented
p18658
aVUnsuffixed decimal: ;
p18659
aVYour literal has no suffix (like  for unsigned or  for long)
p18660
aVC99 has a different list:
p18661
aVYet another rule has C++ (the current edition), which has the list:  (current C++ has no  type)
p18662
aVNow your line initializing to  apparently would have  type in C90 on this compiler (because it would not fit ) even though it could also fit
p18663
aVBut on C99, it would have the type
p18664
as(dp18665
g15
V34509
p18666
stp18667
a((dp18668
g2
(lp18669
VThis sounds like a usecase for exceptions
p18670
aVIf you don't want to or can't use exceptions, you could change the function's interface
p18671
aVThough most often, i've seen the return value is used for the actual result, and an error pointer is passed
p18672
aVThis has the benefit that you can default the error argument pointer to  and code that can ignore the error (because it could live with an empty string return, for example, or if it knows in advance the input is valid) would not need to bother:
p18673
as(dp18674
g15
V34509
p18675
stp18676
a((dp18677
g2
(lp18678
VI know it's not directly what you asked for, but it's your goal
p18679
aVI would use a different way to achieve this: Pass classes (this includes structs and unions) by reference, and pass everything else by value
p18680
aVThis implements the (in my opinion) very good point that @Poita_ made
p18681
as(dp18682
g15
V34509
p18683
stp18684
a((dp18685
g2
(lp18686
s(dp18687
g15
V34509
p18688
stp18689
a((dp18690
g2
(lp18691
VYep you can
p18692
aVBut in C++03, you are bound to do copy/paste code for every number of parameters (not too bad, since here you won't need overloads for const/non-const etc
p18693
aVThe constnes is already known
p18694
aVIn C++0x, you will be able to write
p18695
aVHow much nicer
p18696
as(dp18697
g15
V34509
p18698
stp18699
a((dp18700
g2
(lp18701
VWell, that code looks fine
p18702
aVYou are even caring about the padding issue
p18703
aVI don't see how you can avoid casting here
p18704
aVYou can do this sequence:
p18705
aVBut really, i don't do that in my code
p18706
aVIt's just a more noisy way of doing a direct reinterpret_cast to
p18707
aV(See http://stackoverflow
p18708
aVcom/questions/1863069/casting-via-void-instead-of-using-reinterpret-cast )
p18709
aVThe struct size can be determined using
p18710
aVYou just have to initialize the  member out of the class inside the  (however, then the compiler doesn't know the value of  anymore and can't inline it)
p18711
aVAlternatively, you can write it as a static inline member function
p18712
aVIn its body, the class type is considered complete and  is allowed
p18713
aVOr you can just use  like you have in the comment, but use the type and not the members (referring to nonstatic members that way is allowed only in C++0x) :
p18714
aVHowever, the second way is not nice since you can easily forget updating it when you add a member
p18715
as(dp18716
g15
V34509
p18717
stp18718
a((dp18719
g2
(lp18720
VGCC has a bug
p18721
aVThe Standard makes this valid
p18722
aVSee:
p18723
aVNotice that there are two sides of this
p18724
aVHow and what initialization is done in general
p18725
aVHow is initialization used during overload resolution, and what cost does it have
p18726
aVThe first question is answered in section
p18727
aVThe second question is answered in section
p18728
aVFor example, reference binding is handled at  and , while list initialization is handled in  and
p18729
ag1240
aVThe initialization that occurs in the form
p18730
aVas well as in argument passing, function return, throwing an exception (15
p18731
aV1), handling an exception (15
p18732
aV3), and aggregate member initialization (8
p18733
ag1014
aV1) is called copy-initialization
p18734
aVThe semantics of initializers are as follows[
p18735
aV: If the initializer is a braced-init-list, the object is list-initialized (8
p18736
ag1014
aV4)
p18737
aVWhen considering the candidate , the compiler will see an initializer list (which has no type yet - it's just a grammatical construct
p18738
aVas the argument, and a  as the parameter of
p18739
aVTo figure out what the cost of conversion is and whether we can convert these in context of overloading,  says
p18740
ag1240
aVWhen an argument is an initializer list (8
p18741
ag1014
aV4), it is not an expression and special rules apply for converting it to a parameter type
p18742
ag1240
aVOtherwise, if the parameter is a non-aggregate class X and overload resolution per 13
p18743
ag1037
ag2790
aV7 chooses a single best constructor of X to perform the initialization of an object of type X from the argument initializer list, the implicit conversion sequence is a user-de\ufb01ned conversion sequence
p18744
aVUser-de\ufb01ned conversions are allowed for conversion of the initializer list elements to the constructor parameter types except as noted in 13
p18745
ag1037
ag1037
ag2790
aVThe non-aggregate class  is , and i will figure out the single best constructor below
p18746
aVThe last rule grants us to use user defined conversions in cases like the following:
p18747
aVWe are allowed to convert the string literal to , even if this needs a user defined conversion
p18748
aVHowever, it points to restrictions of another paragraph
p18749
aVWhat does  say
p18750
aV, which is the paragraph responsible for forbidding multiple user defined conversions
p18751
aVWe will only look at list initializations:
p18752
aVHowever, when considering the argument of a user-de\ufb01ned conversion function [(or constructor)] that is a candidate by [
p18753
aV13
p18754
ag1037
ag2790
aV7 when passing the initializer list as a single argument or when the initializer list has exactly one element and a conversion to some class X or reference to (possibly cv-quali\ufb01ed) X is considered for the \ufb01rst parameter of a constructor of X, or [
p18755
aV, only standard conversion sequences and ellipsis conversion sequences are allowed
p18756
aVNotice that this is an important restriction: If it weren't for this, the above can use the copy-constructor to establish an equally well conversion sequence, and the initialization would be ambiguous
p18757
aV(notice the potential confusion of "A or B and C" in that rule: It is meant to say "(A or B) and C" - so we are restricted only when trying to convert by a constructor of X having a parameter of type )
p18758
aVWe are delegated to  for collecting the constructors we can use to do this conversion
p18759
aVLet's approach this paragraph from the general side starting from  which delegated us to :
p18760
ag1240
aVList-initialization can occur in direct-initialization or copy-initialization contexts; list-initialization in a direct-initialization context is called direct-list-initialization and list-initialization in a copy-initialization context is called copy-list-initialization
p18761
ag1240
aVA constructor is an initializer-list constructor if its \ufb01rst parameter is of type  or reference to possibly cv-quali\ufb01ed  for some type E, and either there are no other parameters or else all other parameters have default arguments (8
p18762
ag1037
aV6)
p18763
ag1240
aVList-initialization of an object or reference of type T is de\ufb01ned as follows: [
p18764
aVOtherwise, if T is a class type, constructors are considered
p18765
aVIf T has an initializer-list constructor, the argument list consists of the initializer list as a single argument; otherwise, the argument list consists of the elements of the initializer list
p18766
aVThe applicable constructors are enumerated (13
p18767
ag1037
ag2790
aV7) and the best one is chosen through overload resolution (13
p18768
aV3)
p18769
aVAt this time,  is the class type
p18770
aVWe have one argument (which does not have a type yet
p18771
aVWe are just in the context of having a grammatical initializer list)
p18772
aVConstructors are enumerated as of :
p18773
ag7695
aVIf T has an initializer-list constructor (8
p18774
ag1014
aV4), the argument list consists of the initializer list as a single argument; otherwise, the argument list consists of the elements of the initializer list
p18775
aVFor copy-list-initialization, the candidate functions are all the constructors of T
p18776
aVHowever, if an explicit constructor is chosen, the initialization is ill-formed
p18777
aVWe will only consider the initializer list of  as the only candidate, since we already know the others won't win against it or won't fit the argument
p18778
aVIt has the following signature:
p18779
aVNow, the rules of converting an initializer list to an  (to categorize the cost of the argument/parameter conversion) are enumerated in :
p18780
aVWhen an argument is an initializer list (8
p18781
ag1014
aV4), it is not an expression and special rules apply for converting it to a parameter type
p18782
ag7695
aVIf the parameter type is  and all the elements of the initializer list can be implicitly converted to X, the implicit conversion sequence is the worst conversion necessary to convert an element of the list to X
p18783
aVThis conversion can be a user-de\ufb01ned conversion even in the context of a call to an initializer-list constructor
p18784
aVNow, the initializer list will be successfully converted, and the conversion sequence is a user defined conversion (from  to )
p18785
aVHow this is made is detailed at  again:
p18786
aVOtherwise, if T is a specialization of , an initializer_list object is constructed as described below and used to initialize the object according to the rules for initialization of an object from a class of the same type (8
p18787
aV5)
p18788
aV(
p18789
aVSee  how this final step is made :)
p18790
as(dp18791
g15
V34509
p18792
stp18793
a((dp18794
g2
(lp18795
V is supposed to be the program name
p18796
aVIt's passed to the program's  function
p18797
aVSome programs differentiate their behavior depending on what string  is
p18798
aVFor example the GNU  shell will disable some of its features if called using  instead of
p18799
aVBest give it the same value that you pass to
p18800
aVIn linux,  is the process name displayed by the  utility (which it probably gets from reading entries in )
p18801
as(dp18802
g15
V34509
p18803
stp18804
a((dp18805
g2
(lp18806
VIt never invalidates iterators or pointers/references to the elements
p18807
aVOnly if you remove the element itself does the iterator or pointer/reference become invalid
p18808
ag1240
aVThe insert members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements
p18809
as(dp18810
g15
V34509
p18811
stp18812
a((dp18813
g2
(lp18814
VFor a similar example, see this which should fail too
p18815
aVThe problem here is how the move semantic is implemented: The "copy constructor" takes a non-const reference, thus not being able to bind to temporaries
p18816
aVTo still "move" from temporaries, the class has a conversion function (following are really just conceptual - they may be differently implemented in detail):
p18817
aVAnd a constructor will take that object:
p18818
aVHere is an example that fails for the same reason:
p18819
aVNow, consider this code:
p18820
aVCopy initialization will first convert to
p18821
aVBut then, the temporary  object is tried to be copied again to the final object
p18822
aVThis will need the way using
p18823
aVBut that's another user defined conversion in the initialization, which the standard forbids:
p18824
aVWhen invoked for the copying of the temporary in the second step of a class copy-initialization, [
p18825
aV, only standard conversion sequences and ellipsis conversion sequences are allowed
p18826
aVThis is why your code fails
p18827
as(dp18828
g15
V34509
p18829
stp18830
a((dp18831
g2
(lp18832
VIt's set into  state, because  does not know how many items to read
p18833
aVIt reads as long as the stream is in a  non- state
p18834
aVWhile skipping the last space, it hits the end, and sets both  (because it tried to read beyond the end) and  (because it could not read the double it wanted to)
p18835
aVCall  afterwards to clear those error bits
p18836
aVThe difference between the iterators comparing non-equal while  is true and while  is false is that  will still advance even if the stream is in an  state
p18837
aVThe following further examines it:
p18838
aVNow, after we read "2
p18839
aV2", the  state is set (because it tried to read beyond "2")
p18840
aVBut the begin and end iterator won't yet compare equal, because the  state is not set, and thus  does not return true (while  would have returned false, because it considers  in addition)
p18841
aVOnly after the next read, when it could not read another double anymore, the  state is set, and then the iterators compare equal, and the loop within  exits
p18842
as(dp18843
g15
V34509
p18844
stp18845
a((dp18846
g2
(lp18847
VThis is a possible solution
p18848
aVIt will always choose the operator with the highest alignment in a given hierarchy:
p18849
aVIt's based on the dominance rule: If there is an ambiguity in lookup, and the ambiguity is between names of a derived and a virtual base class, the name of the derived class is taken instead
p18850
aVQuestions were risen why  inherits
p18851
aVThe answer is because in a given hierarchy, there may be different alignment requirements imposed by classes
p18852
aVImagine that  has no alignment requirements,  has 8 byte requirement and  has 16 byte requirement and inherits :
p18853
aVand  both expose an
p18854
aVIf you now say , the compiler will look for  in  and will find two functions:
p18855
aVThus, this would be ambiguous and we would fail to compile: Neither of these hide the other one
p18856
aVBut if you now inherit  virtually from  and make  and  inherit them virtually, the  in  will be hidden:
p18857
aVThis special hiding rule (also called dominance rule) however only works if all  objects are the same
p18858
aVThus we always inherit virtually: In that case, there is only one  (or 16,
p18859
aVobject existing in any given class hierarchy
p18860
as(dp18861
g15
V34509
p18862
stp18863
a((dp18864
g2
(lp18865
VFor the second question, it is probably because you don't cause it to be implicitly defined
p18866
aVIf the constructor is merely implicitly declared, there is no error
p18867
aVExample:
p18868
aVFor your first question - it depends on what name the compiler uses
p18869
aVI have no idea what the standard specifies, but this code for instance is correct because the outer class name (instead of the inherited class name) is accessible:
p18870
aVMaybe the Standard is underspecified at this point
p18871
aVWe'll have to look
p18872
aVThere does not seem to be any problem with the code
p18873
aVFurthermore, there is indication that the code is valid
p18874
aVThe (virtual) base class subobject is default initialized - there is no text that implies that name lookup for the class name is dine inside the scope of
p18875
aVHere is what the Standard says:
p18876
aV(C++0x)
p18877
aVIf a given non-static data member or base class is not named by a mem-initializer-id (including the case
p18878
aVwhere there is no mem-initializer-list because the constructor has no ctor-initializer) and the entity is not a virtual base class of an abstract class
p18879
ag7695
aVotherwise, the entity is default-initialized
p18880
aVAnd C++03 has similar text (thou less clear text - it simply says its default constructor is called at one place, and at another it makes it dependent on whether the class is a POD)
p18881
aVFor the compiler to default initialize the subobject, it just has to call its default constructor - there is no need to lookup the name of the base class first (it already knows what base is considered)
p18882
aVConsider this code that certainly is intended to be valid, but that would fail if this would be done (see  in C++0x)
p18883
aVIf the compiler's default constructor would simply look-up class name  inside of , it would have an ambiguous lookup result with regard to what subobject to initialize, because both the non-virtual  and the virtual 's class-names are found
p18884
aVIf your code is intended to be ill-formed, i would say the Standard certainly needs to be clarified
p18885
aVFor the constructor, notice what  says about the destructor of :
p18886
aVAll destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes
p18887
aVThis can be interpreted in two ways:
p18888
aVcalling A::~A()
p18889
aVcalling ::A::~A()
p18890
aVIt seems to me that the Standard is less clear here
p18891
aVThe second way would make it valid (by , C++0x, because both class-names  are looked up in global scope), while the first will make it invalid (because both  will find the inherited class names)
p18892
aVIt also depends what subobject the search starts with (and i believe we will have to use the virtual base class' subobject as start point)
p18893
aVIf this goes like
p18894
aVThen we will directly find the virtual base' class name as a public name, because we won't have to go through the derived class' scopes and find the name as non-accessible
p18895
aVAgain, the reasoning is similar
p18896
aVConsider:
p18897
aVIf the destructor would simply call , this call would not be valid because of the ambiguous lookup result of  as an inherited class name (you cannot refer to any non-static member-function of the direct base class object from the scope , see , C++03)
p18898
aVIt will uniquely have to identify the class names that are involved, and has to start with the class' subobject reference like
p18899
as(dp18900
g15
V34509
p18901
stp18902
a((dp18903
g2
(lp18904
VBecause there are more fail cases than success cases
p18905
aVUsually, there is only one reason we succeed (because we're successful :)), but there are a whole lot of reasons why we could fail
p18906
aVSo  means success, and everything else means failure, and the value could be used to report the reason
p18907
aVFor functions in your code, this is different, because you are the one specifying the interface, and thus can just use a  if it suffices
p18908
aVFor , there is one fixed interface for returns, and there may be programs that just report succeed/fail, but others that need more fine error reporting
p18909
aVTo satisfy them all, we will have multiple error cases
p18910
as(dp18911
g15
V34509
p18912
stp18913
a((dp18914
g2
(lp18915
VUse a vector
p18916
aVThe entire vector is filled with '\u005c0' first, automatically
p18917
aVBut the performance "lost" might not be noticable
p18918
aVIt's certainly safer and more comfortable
p18919
aVThen access it like a usual array
p18920
aVYou may even pass the pointer to the data to legacy C functions
p18921
as(dp18922
g15
V34509
p18923
stp18924
a((dp18925
g2
(lp18926
VAll of them, except possibility , suffer from the static initialization order fiasco
p18927
aVThis is because your class is not a POD
p18928
aVIn C++0x, this problem can be solved by marking the constructor , but in C++03 there is no such solution
p18929
aVYou can remove the constructor to solve the problem in C++03, and initialize using
p18930
aVThis is initializing a POD, and all initializers in the list are constant expression (for the purpose of static initialization)
p18931
aVThe intialization of them happen before any code is run that might access it before being initialized
p18932
ag1240
aVObjects with static storage duration (3
p18933
ag3311
aV1) shall be zero-initialized (8
p18934
aV5) before any other initialization takes place
p18935
aVZero-initialization and initialization with a constant expression are collectively called static initialization; all other initialization is dynamic initialization
p18936
aVObjects of POD types (3
p18937
aV9) with static storage duration initialized with constant expressions (5
p18938
aV19) shall be initialized before any dynamic initialization takes place
p18939
ag1240
aVWhen an aggregate with static storage duration is initialized with a brace-enclosed initializer-list, if all the member initializer expressions are constant expressions, and the aggregate is a POD type, the initialization shall be done during the static phase of initialization (3
p18940
ag488
aV2); otherwise, it is unspecified whether the initialization of members with constant expressions takes place during the static phase or during the dynamic phase of initialization
p18941
as(dp18942
g15
V34509
p18943
stp18944
a((dp18945
g2
(lp18946
VYou don't need a cast to invoke the conversion function
p18947
aVA plain
p18948
aVwill invoke it too
p18949
aVThat way, i can see how that's more convenient to use than a  function
p18950
aVAlthough i generally don't use conversion functions
p18951
aVI would prefer an explicit  function
p18952
aVIn particular consider this one
p18953
aVIt quickly gets out of hand
p18954
as(dp18955
g15
V34509
p18956
stp18957
a((dp18958
g2
(lp18959
VVery often encountered issue
p18960
aVPut :
p18961
aVis a dependent name
p18962
aVWhile parsing the template, the compiler doesn't know yet whether it will be a type
p18963
aVFor still being able to parse it (and collect information won thereby), it assumes it is not a type
p18964
aVBut then, the line must be an expression, and misses an operator between the two names
p18965
aVwill tell it the name is a type, and the line then becomes a declaration
p18966
aVIt may not be apparent why it fails above because the whole line cannot be an expression
p18967
aVBut there are other situation where this isn't possible to decide on the form of the whole statement:
p18968
aVIs that a multiplication, or a pointer declaration
p18969
aVThe compiler will assume it is a multiplication
p18970
aVIf later when instantiating the template it figures out that  names a type, it will rise an error message
p18971
aVwill also here tell the compiler to parse this as a declaration instead of an expression (by taking  as a type)
p18972
aVNotice some compilers may still work without  (if i remember right, the MSVC compiler is one of them)
p18973
aVI think this should come with the restriction that those compilers won't do two-phase name lookup: They will parse the complete template at instantiation time, and all names, even those that were not visible in the definition of the template, will be found (as opposed to what the Standard says, that treats name lookup at definition/instantiation differently)
p18974
aVVisit the Template FAQ for further assistance: C++ Templates FAQ
p18975
as(dp18976
g15
V34509
p18977
stp18978
a((dp18979
g2
(lp18980
VYou got some wrong answers in this thread
p18981
aVThe problem in your code is that you define your inline function twice in your code:
p18982
aVwill, as someone else said correctly, already protect you from having an error risen by defining the function twice
p18983
aVYou don't need , nor will you need unnamed namespaces
p18984
aVAlso notice that you shouldn't define inline functions that are supposed to be used by other translation units (a file where all #include and #if etc
p18985
aVare processed and expanded) within the  file
p18986
aVTheir definition have to be known by all translation units that use them - so put their definition only in the header file in that case - not in both the  and the header file - that will yield to the error you get
p18987
aVYou also need header guards to avoid the above problem in each of your headers
p18988
aVAnd you should make sure not to include a  file into another  file ( files are not supposed to be included)
p18989
aVYou are supposed to include the header files into the  files
p18990
as(dp18991
g15
V34509
p18992
stp18993
a((dp18994
g2
(lp18995
VThat's not better
p18996
aVFirst of all, it's not really compile time, since you make function calls here
p18997
aVIf you are lucky, the compiler will inline these and end up with a loop you could have written yourself with much less amount of code (or just by using )
p18998
as(dp18999
g15
V34509
p19000
stp19001
a((dp19002
g2
(lp19003
VYes, copy constructor and copy assignment operators are still created even if you declare your own default constructor
p19004
aVThe creation of those are only suppressed if you declare your own copy constructor or copy assignment operator in the class definition respectively
p19005
aVNote that it is possible to have both your own copy constructor, and a compiler provided one:
p19006
aVThe Standard however allows compilers to accept this code - but the effect is similar to having undefined behavior: The program is ill-formed, but no warning/error is required for that program
p19007
aV(early GCC versions don't reject this code, recent ones reject it)
p19008
as(dp19009
g15
V34509
p19010
stp19011
a((dp19012
g2
(lp19013
VThe error is in your code, not in
p19014
aVYou pass a functor that does not expect any arguments
p19015
aVInstead of your call, do
p19016
aVIf you omit  then  will create a zero-argument function object, and the member function (which expects a data pointer) will miss one argument when called by
p19017
as(dp19018
g15
V34509
p19019
stp19020
a((dp19021
g2
(lp19022
VYou can also do
p19023
aVwill be deduced to whatever the to be initialized object is
p19024
aVAnd you are not allowed to copy the proxy
p19025
aVThat said, i prefer an explicit  function like another one proposed too
p19026
as(dp19027
g15
V34509
p19028
stp19029
a((dp19030
g2
(lp19031
VIt allows for the code to appear here:
p19032
aVIf they simply used a  you would get
p19033
aVThe else would not belong to any  anymore, because the semicolon would be the next statement and separate the  from the preceeding
p19034
aVA compile error would occur
p19035
as(dp19036
g15
V34509
p19037
stp19038
a((dp19039
g2
(lp19040
VUse :
p19041
as(dp19042
g15
V34509
p19043
stp19044
a((dp19045
g2
(lp19046
VThe most straight forward solution to this is to write a loop where the start and end values are known
p19047
aVI think this is better than any sort of template/runtime-call mixture: The loop as written is completely clear to the compilers' optimizer, and there are no levels of function calls to dig through just to see what's going on
p19048
as(dp19049
g15
V34509
p19050
stp19051
a((dp19052
g2
(lp19053
VOne other thing to note with your code before you go back to us with a very similar question: Better remove the  and  functions
p19054
aVThey will cause you major headache
p19055
aVLet's make a few examples:
p19056
aVIn the original situation you had, your addition was ambiguous, because there were  and  builtin operators considered and they were equally well
p19057
aVOthers solved that problem
p19058
aVBut before you start and run into these other problems, better remove the conversion functions and insert explicit functions like  or something similar
p19059
as(dp19060
g15
V34509
p19061
stp19062
a((dp19063
g2
(lp19064
VThe difference is because for  to have any effect, somewhere the compiler would need to store that  will evaluate to the address of the second element of the array
p19065
aVBut there is no place for that information
p19066
aVThe compiler only allocates place for  integers
p19067
aVNow when you declare that a function parameter is an array, the function parameter won't be an array
p19068
aVThe function parameter will be a pointer
p19069
aVThere are no array parameters in C
p19070
aVSo the following two declarations are equivalent
p19071
aVIt doesn't even matter what number you put between the brackets - since the parameter really will be a pointer, the "size" is just ignored
p19072
aVThis is the same for functions - the following two are equivalent and have a function pointer as parameter:
p19073
aVWhile you can call both a function pointer and a function (so they are used similar), you also won't be able to write to a function, because it's not a pointer - it merely converts to a pointer:
p19074
aVMuch the same way you can't modify an array
p19075
as(dp19076
g15
V34509
p19077
stp19078
a((dp19079
g2
(lp19080
VIt's not valid
p19081
aVThe vector has no elements, so you cannot access any element of them
p19082
aVYou just reserved space for  elements (which means that it's guaranteed that no reallocation happens until over 100 elements have been inserted)
p19083
aVThe fact is that you cannot resize the vector without also initializing the elements (even if just default initializing)
p19084
as(dp19085
g15
V34509
p19086
stp19087
a((dp19088
g2
(lp19089
VKate (3
p19090
aV4) only highlights the first test, fails hilighting the second test
p19091
as(dp19092
g15
V34509
p19093
stp19094
a((dp19095
g2
(lp19096
VFor function declarations, parameter types are allowed to be incomplete if the function is not defined there:
p19097
aVSo you just define them after  and  become complete
p19098
aVBut since they are defined outside the class, make them  so multiple definitions in different translation units won't cause linker errors
p19099
as(dp19100
g15
V34509
p19101
stp19102
a((dp19103
g2
(lp19104
VThe first won't construct the objects directly
p19105
aVIt will first construct a temporary , and then copy the  into the element
p19106
aVIt's similar to your second way
p19107
aVThe difference is that your second way won't work with a  copy constructor, while your first will
p19108
aVAnd conversely, the first will not work with a  constructor taking , while the second will
p19109
aVStated another way, the first constructor used in the initialization of an element must not be
p19110
aVNotice that neither way needs to copy
p19111
aVBut they still need to check whether the copy constructors are accessible
p19112
aVSo, they shall behave as-if they would copy, but they don't really need to do the copy
p19113
as(dp19114
g15
V34509
p19115
stp19116
a((dp19117
g2
(lp19118
VYes, operator overloading can be done on enum and class types
p19119
aVThe way you do it is fine, but you should use  to promote the enumeration, instead of  or something (the purpose ultimately is to avoid infinite recursion because ):
p19120
aVThis will scale well to other operations
p19121
aVwill promote the enumeration to an integer type that can represent its value, and then you can apply  without causing infinite recursion
p19122
aVNotice that your  does only allow you to do , but not the other way around
p19123
aVIt may be worth considering the other direction too
p19124
aVAlso notice that it's always a bit dangerous to overload operators for operands that builtin-operators already accept (even if only by implicit conversions)
p19125
aVImagine that  has a converting constructor taking int (as in ), then given your  the following is ambiguous
p19126
aVFor this, maybe it's better to make  a real class with the appropriate operators, so that you can exclude any of such implicit conversions from begin on
p19127
aVAnother good solution is provided by C++0x's , which provides strong enumerations
p19128
as(dp19129
g15
V34509
p19130
stp19131
a((dp19132
g2
(lp19133
VSince there are questions about how unqualified names may be dependent, or how unqualified name lookup may apply to dependent names:
p19134
aVTrail parse: Determining how we parse a statement
p19135
aVIf in a template a dependent name is encountered, it is always assumed not to name a type, unless the name lookup that is applicable finds that it is a type or we prepend the name with :
p19136
aVThis lookup of a name to determine whether it is a type is always done at the point of the template definition for all dependent names: It guides the following parse into a certain direction
p19137
aVIn the second statement, we will parse  as a declaration of a pointer, but not as a multiplication
p19138
aVIn the last statement, we assumed during the pre-parse disambiguation that  is not a type and try to parse it as an expression
p19139
aVThis will fail, because we will expect a semicolon or some operator after
p19140
aVThis lookup whether or not the name is a type has no influence on the meaning of the name in later phases: It won't yet bind the name to any declaration
p19141
aVActual parse
p19142
aVAfter we determined what names are types and what not, we will actually parse the template
p19143
aVNames that are not dependent - that is, those that are not looked up in a scope that is dependent or that are not explicitly made dependent by other rules - are looked up at the point where they are used in the template, and their meaning is not influenced by any declaration visible when instantiating
p19144
aVNames that are dependent are looked up when instantiating, both in the template definition where they are used, and where their template is instantiated
p19145
aVThis is true also for unqualified names that are dependent:
p19146
aVThe unqualified  is made dependent by the Standard because the argument  is type-dependent
p19147
aVWhen instantiating, we will look for functions called  using unqualified name lookup around the template definition, and using argument dependent lookup (meaning, roughly, in the namespace of ) around both the template definition and the point where we instantiate it (after )
p19148
aVArgument dependent lookup will then find
p19149
aVIf  now has a dependent base class, unqualified lookup must ignore that dependent base class:
p19150
aVThis must still find , despite the fact that unqualified name-lookup would find a class member function if it were done (ADL will not find additional functions if a class member function was found)
p19151
aVBut unqualified namelookup will not find that function, because it's a member of a dependent base class, and those are ignored during unqualified name lookup
p19152
aVAnother interesting case:
p19153
aVThe Standard states that during lookup of  in the  name, we will lookup independently in both the scope of  (which is in the scope of class ), and the scope in which the complete expression appears (which is the scope of  as an unqualified name), and compare the two names, if found, whether they designate the same type
p19154
aVIf we would not ignore the dependent base class  during the lookup in the scope of the complete expression, we will find  in two base classes, thus having an ambiguity
p19155
aVIgnoring  will mean we find the name once when we do lookup into , and another time when we do lookup into
p19156
as(dp19157
g15
V34509
p19158
stp19159
a((dp19160
g2
(lp19161
VThe syntax is wrong
p19162
aVA member pointer is a different type category from a ordinary pointer
p19163
aVThe member pointer will have to be used together with an object of its class:
p19164
aVdoes not yet say on what object the function is to be called on
p19165
aVIt just says that you want to use the pointer stored in the object
p19166
aVPrepending  another time as the left operand to the  operator will tell the compiler on what object to call the function on
p19167
as(dp19168
g15
V34509
p19169
stp19170
a((dp19171
g2
(lp19172
VThere is a function  that will hide your  class of the same name
p19173
aVYou can work this around by saying
p19174
aVIt's very bad practice to do  in a header
p19175
aVInstead put that line into the  file only
p19176
aVIt may solve your problem if you remove that line (if the name comes from namespace  instead of from the global namespace originally)
p19177
as(dp19178
g15
V34509
p19179
stp19180
a((dp19181
g2
(lp19182
VIt should be noted that  also modifies the types of functions
p19183
aVIt does not only modify things on lower levels:
p19184
aVThe type of  does not equal the type that the typedef designates (although the code is accepted by some, but not all compilers)
p19185
as(dp19186
g15
V34509
p19187
stp19188
a((dp19189
g2
(lp19190
VThe object is copied into an exception object that survives stack-unwinding
p19191
aVWhere the memory for that object comes from is unspecified
p19192
aVFor big object, it will probably be 'ed, and for smaller objects, the implementation could have a pre-allocated buffer (i could imagine this could be used for a  exception)
p19193
aVThe reference  is then bound to that exception object, which is a temporary (it has no name)
p19194
as(dp19195
g15
V34509
p19196
stp19197
a((dp19198
g2
(lp19199
VSounds like you want to print 1 decimal place, and if that place is 0, drop it
p19200
aVThis function should work fine:
p19201
as(dp19202
g15
V34509
p19203
stp19204
a((dp19205
g2
(lp19206
VYou could use :
p19207
aVThat will dereference the adapted iterator twice in its
p19208
as(dp19209
g15
V34509
p19210
stp19211
a((dp19212
g2
(lp19213
VOnly the latter two are Standard headers
p19214
aVThe first is some non-standard header
p19215
aVThis is , but with the declarations put into namespace
p19216
aVIt's the "C++ version" of the C header
p19217
aVThis is where  is defined
p19218
aVIt has nothing to do with the C header
p19219
as(dp19220
g15
V34509
p19221
stp19222
a((dp19223
g2
(lp19224
VI would not do this personally but just come up with unique names
p19225
aVBut if you want to do it, one way is to use a combination of  and :
p19226
aVYou can use it like
p19227
aVEach of those names are in separate scopes and won't conflict
p19228
aVThe inner names hide the outer names
p19229
aVThe expressions in the  and  loops are constant and should be easily optimized by the compiler
p19230
aVIf you really want to pass an expression, you can use the ScopedGuard trick (see Most Important ), but it will need some more work to write it
p19231
aVBut the nice side is, that we can get rid of the  loop, and let our object evaluate to :
p19232
aVYou then provide the proper  and  functions:
p19233
aVNow you can write it entirely without a name on the user side:
p19234
aVIf you want to pass multiple expressions at once, it's a bit more tricky, but you can write an expression template that acts on  to collect all expressions into a
p19235
aVYou need to inherit the RAII object from  like the following shows
p19236
aVAll of these involve no virtual functions, and the functions involved are transparent to the compiler
p19237
aVIn fact, with the above  changed to add a single integer to a global variable and when leaving subtracting it again, and the below defined , i did a test:
p19238
aVIn fact, GCC at optimization level  outputs this:
p19239
aVI wouldn't have expected that, it optimized quite well
p19240
as(dp19241
g15
V34509
p19242
stp19243
a((dp19244
g2
(lp19245
VI think the solution may be in the wording of "++i"
p19246
aVIt says "The value is the new value of the operand; it is an lvalue
p19247
aVAnd behavior is undefined in 5/4 by "Furthermore, the prior value shall be accessed only to determine the value to be stored
p19248
aVSo, we are not accessing the prior, but the new value
p19249
aVAnd then we may be fine
p19250
aVIt seems to be a very thin line between undefined behavior and defined behavior though
p19251
aVActually "prior value" sounds to me like "value the object had at the previous sequence point"
p19252
aVAnd if interpreted like that, then this construct looks undefined
p19253
aVBut if we directly compare the wording of "++i" in 5
p19254
aV3/2 to 5/4, we are confronted by "new value" vs "prior value", and things are "bent" to defined behavior ("++i" would peek at the value of "i" at the next sequence point, and produce that value as the contents of the resulting lvalue of "++i")
p19255
as(dp19256
g15
V34509
p19257
stp19258
a((dp19259
g2
(lp19260
V has a  form called
p19261
aVPass the  you construct locally to it as the last argument
p19262
as(dp19263
g15
V34509
p19264
stp19265
a((dp19266
g2
(lp19267
VYou can use a functional approach too
p19268
aVIf the iterator cannot read an integer, it will set the fail state on the stream and will compare equal to the end iterator
p19269
aVthen returns the number of iteration steps it took to reach the end iterator
p19270
as(dp19271
g15
V34509
p19272
stp19273
a((dp19274
g2
(lp19275
VI think i found the reason
p19276
aVThis is what TR1  says about , used in the determination of the return type of :
p19277
aVThe implementation may determine the type member via any means that produces the exact type of the expression f(t1, t2,
p19278
aV, tN) for the given types
p19279
aV[Note: The intent is that implementations are permitted to use special compiler hooks \u2014end note]
p19280
aVAnd then paragraph 3:
p19281
aVIf F is not a function object defined by the standard library, and if either the implementation cannot determine the type of the expression f(t1, t2,
p19282
aV, tN) or if the expression is ill-formed, the implementation shall use the following process to determine the type member:
p19283
aVIf F is a possibly cv-qualified class type with no member named  or if  is not a type:
p19284
aVIf N=0 (no arguments), type is void
p19285
aVIf N>0, type is
p19286
aVThe error message is an artefact of trying these fall-backs
p19287
aVProvide a typedef for  to  and it should work, i think
p19288
aVNotice that in , this is different
p19289
aVIt does not rely on  or a  template, since it can use
p19290
aVIf with  it fails with MSVC10 in C++0x mode, it smells like a bug, i would say
p19291
aVBut maybe someone else knows what's going on
p19292
aVIt may (but is not guaranteed to) work with  in C++0x mode if that header chooses to take the  way instead of
p19293
aVI would typedef  - that way i think it should always work regardless of whether the  header is used or the  header
p19294
aVAlso notice that  says in its documentation that it does not support the function call operator (but it merely supports implicit conversions to )
p19295
as(dp19296
g15
V34509
p19297
stp19298
a((dp19299
g2
(lp19300
VThe  operator is used to delete arrays
p19301
aVThe  operator is used to delete non-array objects
p19302
aVIt calls  and  function respectively to delete the memory that the array or non-array object occupied after (eventually) calling the destructors for the array's elements or the non-array object
p19303
aVThe following shows the relations:
p19304
aVFor a  that creates an array (so, either the  or  applied to an array type construct), the Standard looks for a  in the array's element type class or in the global scope, and passes the amount of memory requested
p19305
aVIt may request more than  if it wants (for instance to store the number of elements, so it later when deleting knows how many destructor calls to done)
p19306
aVIf the class declares an  that additional to the amount of memory accepts another , that second parameter will receive the number of elements allocated - it may use this for any purpose it wants (debugging, etc
p19307
aVFor a  that creates a non-array object, it will look for a  in the element's class or in the global scope
p19308
aVIt passes the amount of memory requested (exactly  always)
p19309
aVFor a , it looks into the arrays' element class type and calls their destructors
p19310
aVThe  function used is the one in the element type's class, or if there is none then in the global scope
p19311
aVFor a , if the pointer passed is a base class of the actual object's type, the base class must have a virtual destructor (otherwise, behavior is undefined)
p19312
aVIf it is not a base class, then the destructor of that class is called, and a  in that class or the global  is used
p19313
aVIf a base class was passed, then the actual object type's destructor is called, and the  found in that class is used, or if there is none, a global  is called
p19314
aVIf the  in the class has a second parameter of type , it will receive the number of elements to deallocate
p19315
as(dp19316
g15
V34509
p19317
stp19318
a((dp19319
g2
(lp19320
VFor this, what you can use is the  operator
p19321
aVIt will give you the common type between two types
p19322
aVFirst, if the two types are the same, you are fine
p19323
aVThen, if the types differ, you invoke the  and see what type you get back
p19324
aVYou need to special case the non-promoted types ,  and their unsigned/signed versions thereof since applied to two of such operands of differing types, the result will be neither of them
p19325
aVYou need also take care of the case where two classes can be converted to promoted arithmetic types
p19326
aVTo get these right, we check whether the result of  is a promoted arithmetic type (in the spirit of clause ), and use that type then
p19327
aVIf your  types can be converted into each other,  won't find a common type
p19328
aVYou could specialize  to tell it how to figure out a common type of two :
p19329
aVUsage is simple:
p19330
aVNote that for real-world uses, you should best catch a few cases I left out for simplicity, for example  should be handled similar to  (you best first strip  and  and convert  to  and  to  and afterwards  delegate to the actual  template - i
p19331
aVe do  for both  and  before delegating them)
p19332
aVIf you don't do this, the call to  will end up in an ambiguity for these cases
p19333
as(dp19334
g15
V34509
p19335
stp19336
a((dp19337
g2
(lp19338
VIt's not possible to directly invoke the address-of operator to the temporary (MSVC will tell you that this is not Standard C++ at higher warning levels, too)
p19339
aVExcept you may do
p19340
aVBut this is disgusting
p19341
aVJust declare a local variable and pass its address
p19342
as(dp19343
g15
V34509
p19344
stp19345
a((dp19346
g2
(lp19347
VYou could use  to see whether a type is a numeric type ( is true for all float and integer fundamental types)
p19348
as(dp19349
g15
V34509
p19350
stp19351
a((dp19352
g2
(lp19353
VThe problem is that the output operator that would work takes a , but that is a member
p19354
aVIf you change it to the following, it will convert the  returned by the  to  and output it (and it is a null pointer if the extraction worked, and a non-NULL pointer otherwise):
p19355
aVI'm not quite sure though why you are doing this
p19356
aVCan you please elaborate
p19357
aVIf you want to output all stuff from  right away, use the underlying buffer
p19358
as(dp19359
g15
V34509
p19360
stp19361
a((dp19362
g2
(lp19363
VYour logic error in your other answer was already explained by others
p19364
aVTo let me explain to you again, given this statement:
p19365
aVThe simple-type-specifiers specify either a previously-declared user-defined type or one of the fundamental types
p19366
aVIt does not mean that there are simple-type-specifiers for all fundamental types
p19367
aVIt just means that each simple-type-specifier (or a combination of those - i think this sentence is not very clear) specify either a user defined type or one of the fundamental types
p19368
aVThat statement also would apply to the following "sample-specifiers":
p19369
aVEach of my sample-specifiers specify either a previously declared user defined type, or one of the fundamental types (in my case, it's )
p19370
aVIt does not mean that all previously declared user defined types can be denoted, nor does it mean that all fundamental types can be denoted
p19371
aVNow if another paragraph in the Standard says that  works for  being a simple-type-specifier, that does not mean that it also must work for a combination of these
p19372
aVThat's a totally invalid conclusion to do
p19373
aVIt's like when i say "decimal digits specify exclusively numbers from 0 to 9" and you say "you are wrong because they can't specify number 10"
p19374
aVBut what you did was to take a combination of two digits and then claim something i've never said
p19375
aVI think this is a pretty clear logical fallacy you do
p19376
as(dp19377
g15
V34509
p19378
stp19379
a((dp19380
g2
(lp19381
VYou cannot cast the temporary stream to
p19382
aVIt is ill-formed (the compiler must tell you that it is wrong)
p19383
aVThe following can do it, though:
p19384
aVThat of course is ugly
p19385
aVBut it shows how it can work
p19386
aVis a member function returning a
p19387
aVWould probably better to write this generally
p19388
aVThe reason that without anything it takes the , is because that  is a member-function
p19389
aVThe  that takes a  is not
p19390
as(dp19391
g15
V34509
p19392
stp19393
a((dp19394
g2
(lp19395
VYou are using your own deleter, which means that you don't have to have a complete type upon construction
p19396
aVThe only requirement is that  can handle that
p19397
aV(it may convert the pointer passed to a complete type, for example (say, from  to )
p19398
aVThe background of completeness is that once the constructor of  is called with the default deleter, it will instantiate a class that contains the line  - and for this code to be correct,  must not be incomplete
p19399
aVThe destructor will call this deleter code indirectly, so it doesn't depend on the completeness of the type
p19400
aVHowever if you pass your own deleter, the requirements of your own deleter will apply
p19401
aVBe sure to define  after  has become completed
p19402
as(dp19403
g15
V34509
p19404
stp19405
a((dp19406
g2
(lp19407
VYou are trying to execute the command
p19408
aVPut a space after  so it will be regognized as a test
p19409
as(dp19410
g15
V34509
p19411
stp19412
a((dp19413
g2
(lp19414
g1240
aVIf any declaration of a function has an exception-specification, all declarations, including the definition and an explicit specialization, of that function shall have an exception-specification with the same set of type-ids
p19415
as(dp19416
g15
V34509
p19417
stp19418
a((dp19419
g2
(lp19420
VYou are doing it all wrong
p19421
aVJust create it as an automatic object if all you need is a vector in the current scope and time
p19422
aVThe constructor has default arguments for the second and third parameters
p19423
aVSo it is callable with just an int
p19424
aVIf you want to pass an own allocator, you have to pass a second argument since you can't just skip it
p19425
aVA dedicated example might clarify the matter
p19426
as(dp19427
g15
V34509
p19428
stp19429
a((dp19430
g2
(lp19431
VC++ and C (remove  for C):
p19432
aVBut the true C++ way:
p19433
aVUsing  does not work because it tries to compare the addresses of the first character of each array (obviously, they do not equal)
p19434
aVIt won't compare the content of both arrays
p19435
as(dp19436
g15
V34509
p19437
stp19438
a((dp19439
g2
(lp19440
VUse :
p19441
aVThe compiler's parser otherwise assumes that  is not a type and misparses the code (it can't know that it is a type, because at that point it doesn't know what type  is, so potentially  could be a static data-member likewise)
p19442
aVYou should also generally catch by reference instead of by value
p19443
as(dp19444
g15
V34509
p19445
stp19446
a((dp19447
g2
(lp19448
VIt makes sense to give default template arguments
p19449
aVFor example you could create a sort function:
p19450
aVC++0x introduces them to C++
p19451
aVSee this defect report by Bjarne Stroustrup: Default Template Arguments for Function Templates and what he says
p19452
aVThe prohibition of default template arguments for function templates is a misbegotten remnant of the time where freestanding functions were treated as second class citizens and required all template arguments to be deduced from the function arguments rather than specified
p19453
aVThe restriction seriously cramps programming style by unnecessarily making freestanding functions different from member functions, thus making it harder to write STL-style code
p19454
as(dp19455
g15
V34509
p19456
stp19457
a((dp19458
g2
(lp19459
VNot returning a reference is a waste of resources and a yields a weird design
p19460
aVWhy do you want to do a copy for all users of your operator even if almost all of them will discard that value
p19461
aVIn addition, it would be surprising to users of your class, since the built-in assignment operator doesn't copy likewise
p19462
as(dp19463
g15
V34509
p19464
stp19465
a((dp19466
g2
(lp19467
VThe Standard says (at 14/3
p19468
aVFor the non-standard folks, the names following a class definition body (or the type in a declaration in general) are "declarators")
p19469
aVIn a template-declaration, explicit specialization, or explicit instantiation the init-declarator-list in the dec-laration shall contain at most one declarator
p19470
aVWhen such a declaration is used to declare a class template, no declarator is permitted
p19471
aVDo it like Andrey shows
p19472
as(dp19473
g15
V34509
p19474
stp19475
a((dp19476
g2
(lp19477
VThat doesn't work because declared arrays can't have runtime sizes
p19478
aVTry a vector:
p19479
aVOr use new
p19480
aVIf you don't have boost available, make your own array type you can stick into vector
p19481
aVFor easing the syntax of , you can use an  template which effectively is an in-place typedef (also available in )
p19482
aVIf you want, you can also use a vector of
p19483
as(dp19484
g15
V34509
p19485
stp19486
a((dp19487
g2
(lp19488
VIf you pass a variable instead of a temporary, the compiler is not allowed to optimize away the copy if the copy constructor of it does anything you would notice when running the program ("observable behavior": inputs/outputs, or changing volatile variables)
p19489
aVApart from that, the compiler is free to do everything it wants (it only needs to resemble the observable behavior as-if it wouldn't have optimized at all)
p19490
aVOnly when the argument is an rvalue (most temporary), the compiler is allowed to optimize the copy to the by-value parameter even if the copy constructor has observable side effects
p19491
as(dp19492
g15
V34509
p19493
stp19494
a((dp19495
g2
(lp19496
VDeleting a pointer (or deleting what it points to, alternatively) means
p19497
aVwas allocated prior to that statement like
p19498
aVIt may also refer to using other ways of dynamic memory management, like
p19499
aVwhich was previously allocated using malloc or calloc
p19500
aVThe latter is more often referred to as "freeing", while the former is more often called "deleting"
p19501
aVis used for classes with a destructor since  will call the destructor in addition to freeing the memory
p19502
aV(and malloc, calloc etc) is used for basic types, but in C++ new and delete can be used for them likewise, so there isn't much reason to use malloc in C++, except for compatibility reasons
p19503
as(dp19504
g15
V34509
p19505
stp19506
a((dp19507
g2
(lp19508
VNot exactly an answer to this question, but rather a different approach to your problem
p19509
aVI find it easier to do SFINAE tests in specializations rather than in functions defined in that template:
p19510
aVUsing it to pass a type that may be invalid:
p19511
aVThis way it's considerably shorter and the noise with  and things aren't done
p19512
as(dp19513
g15
V34509
p19514
stp19515
a((dp19516
g2
(lp19517
VAnother version is to leave it undefined for the forbidden types
p19518
as(dp19519
g15
V34509
p19520
stp19521
a((dp19522
g2
(lp19523
VHow 'bout this one:
p19524
aVThen
p19525
aVThat's using a metafunction class by wrapping the  into a non-template
p19526
aVThat allows passing it to C++03 templates (which cannot accept templates with arbitrary parameters by simply doing )
p19527
aVYou may, of course, accept a pure metafunction (not a class) too
p19528
aVAnd use the  template
p19529
aVOr you can wrap it into a class so it is compatible with the first version
p19530
aVHope it helps
p19531
as(dp19532
g15
V34509
p19533
stp19534
a((dp19535
g2
(lp19536
VThey are not
p19537
aVHowever, the difference are affected only by the fact that the second case needs a copy constructor to be accessible in C++03 (even if the copy constructor call is not actually done)
p19538
as(dp19539
g15
V34509
p19540
stp19541
a((dp19542
g2
(lp19543
VOn comeau and GCC, the warning disappears if you wrap the variables into a :
p19544
aVTo avoid warnings on GCC about that the left or right side of the comma operator has no effect (if it expands to  for example), you can introduce a debug-nullify type that has its own comma operator:
p19545
aVThe benefit of  is that argument expressions are not evaluated
p19546
as(dp19547
g15
V34509
p19548
stp19549
a((dp19550
g2
(lp19551
VApparently it's called "Object Generator"
p19552
aVSee "More C++ Idioms" and "Boost" on this topic
p19553
aVI personally find it very useful and use it alot
p19554
aVAlso, I think one might see expression templates as a special form of object generators, since all they do is construct complex types by means of operand types and data you normally could specify also manually
p19555
aVExcept, they are calling the generators implicitly
p19556
as(dp19557
g15
V34509
p19558
stp19559
a((dp19560
g2
(lp19561
VOnly if you are fine with processing the type in a function
p19562
aVIt won't work with reference data members
p19563
aVC++0x will allow  to do that more easily
p19564
aVNot only that, but it allows  and any other fancy expression stuff within the
p19565
aVGcc4
p19566
aV5 already supports it
p19567
as(dp19568
g15
V34509
p19569
stp19570
a((dp19571
g2
(lp19572
VI doubt that this is possible without a virtual function
p19573
aVYou need to do type erasure since you can't use  and similar
p19574
aVBut then later on in that scope since you are calling a function on the type erasured object you need runtime support to invoke a function on the derived class object
p19575
aVI suspect without  you can't do it
p19576
as(dp19577
g15
V34509
p19578
stp19579
a((dp19580
g2
(lp19581
VAre you serious
p19582
aVWhy would you want to give up on such a useful feature just because you make a mistake sometimes
p19583
aVBetter try and learn to avoid mistakes with  and you benefit from the great assistance it adds to ensure correctnes with your code
p19584
aVOf course, you can say goodbye to all the help the language provides, and tell the compiler thereby not tell you about mistakes in your code anymore
p19585
aVInstead, you will have to ask the debugger later on where your bugs are
p19586
aVNot sure whether that's better
p19587
as(dp19588
g15
V34509
p19589
stp19590
a((dp19591
g2
(lp19592
VI wrote an enum iterator a while ago for these cases
p19593
aVIf you are interested, here is the code
p19594
aVIf you like, you can extend it to be a random access iterator by providing , ,  and friends
p19595
aVAlgorithms like  will thank you by providing  time complexity for the then random-access iterator
p19596
as(dp19597
g15
V34509
p19598
stp19599
a((dp19600
g2
(lp19601
V is stateless
p19602
aVSo why do you want to pass a non-static member function
p19603
aVIf in the real code you need access to non-static members, you also need to pass the object along
p19604
aVYou can then call it like the following, assuming the member function is made public
p19605
aVIf the class is heavy-weight or if the function changes its object during execution, you may decide to pass the object to  by reference
p19606
as(dp19607
g15
V34509
p19608
stp19609
a((dp19610
g2
(lp19611
VThere is the  macro
p19612
aVused like this
p19613
aVTo go with your example:
p19614
aVOnce some compiler supports C++0x's user defined literals, you could write
p19615
as(dp19616
g15
V34509
p19617
stp19618
a((dp19619
g2
(lp19620
VIt seems you are making the distinction between the handling of new-expressions and allocation functions
p19621
aVnew-expressions call constructors in addition for class types and is responsible for looking up allocation functions (so it is built into the compiler) and calling them
p19622
aVYou can't change that behavior
p19623
aVWhat you can change is the behavior of allocation functions
p19624
aVTheir name is  and they are found and used by new-expressions to allocate memory
p19625
aVSee Plain new, new[], delete and delete[]  in a nutshell
p19626
as(dp19627
g15
V34509
p19628
stp19629
a((dp19630
g2
(lp19631
VThe  pointer is not stored
p19632
aVWhen the constructor is called for an object that occupies a specific memory location, that location is passed as a parameter to the constructor and other member functions
p19633
aVIf  would be stored inside the object, how to retrieve that pointer
p19634
aVRight, you would again need the  pointer :)
p19635
as(dp19636
g15
V34509
p19637
stp19638
a((dp19639
g2
(lp19640
V variables declared in the enclosing method can be accessed by an anonymous inner class in that method
p19641
aVIf you would make the parameters non-final, you would see the compiler complain
p19642
aVYou can't declare a constructor in an anonymous inner class
p19643
aVPeople work around that sometimes by writing initializer blocks
p19644
aVI think the rationale of not being able to access non-final variables is because if you create your anonymous inner class object, and then would change the non-final variables - should the anonymous inner class use the updated value
p19645
aVHow does it manage the case when the function terminates execution and the variable is destroyed
p19646
aVIf it can only use final variables, the semantics are clear: It will take a snapshot of the final variable's values
p19647
as(dp19648
g15
V34509
p19649
stp19650
a((dp19651
g2
(lp19652
VI think you have to develop some kind of feeling for the error messages of your compiler
p19653
aVThere are worse and there are better compilers
p19654
aVThat one is surely one of the worse
p19655
aVA good one points the caret to the place where the error occurs and gives hint what could be wrong
p19656
aVFor example in the given case, the compiler probably stops parsing the type of the declaration when it reaches  and parses it as the name of what is to be declared
p19657
aVThe grammar allows that, because some declarations are not given a type (constructors are an example)
p19658
aVSo it expects an initializer for that name, and not a star
p19659
aVThis hints that  probably isn't declared
p19660
aVCheck you included the correct header
p19661
as(dp19662
g15
V34509
p19663
stp19664
a((dp19665
g2
(lp19666
V is a different type than
p19667
aVYou have to use
p19668
aVEven though they may use the same representation, they are nontheless different integer types
p19669
aVMuch like the three of ,  and
p19670
aVAlso be sure you included the correct header ( or include )
p19671
as(dp19672
g15
V34509
p19673
stp19674
a((dp19675
g2
(lp19676
VOnly the first and the last are null pointers
p19677
aVThe others are results of  and thus operate on implementation defined pointer values
p19678
aVWhether the behavior is undefined for them depends on whether there is an object at the address you casted to
p19679
as(dp19680
g15
V34509
p19681
stp19682
a((dp19683
g2
(lp19684
VThis is OK under the conditions @Neil elaborated on
p19685
aVHowever a better way would be to return a reference to the string
p19686
aVStill keeping in mind that somestlstring` must not be a local automatic variable but stored somewhere else in a namespace or a class
p19687
aVOtherwise you can return the string by value
p19688
as(dp19689
g15
V34509
p19690
stp19691
a((dp19692
g2
(lp19693
V is not necessarily sized equal to  and may even use an entire different internal representation
p19694
aVTherefor you cannot bind a non-const reference to  to an object of type  or the other way around
p19695
aVThe Standard forbids it, and your compiler is correct to not allow it
p19696
aVYou can wonder the same way about the following code snippet:
p19697
aVThe last initialization won't work
p19698
aVJust because a type is convertible to another one, doesn't mean another type that compounds one of them is convertible to a third type that compounds the other one
p19699
aVLikewise, for the following case
p19700
aVIn this case  and  each compound the type  and  respectively, much like  and  compound these types
p19701
aVHowever they won't be convertible into each other just because of that fact
p19702
aVOther rules happen to apply
p19703
aVIf the reference is to const, a temporary object is created that has the correct type, and the reference is then bound to that object
p19704
as(dp19705
g15
V34509
p19706
stp19707
a((dp19708
g2
(lp19709
VIt doesn't know whether the destructor will be public or not
p19710
as(dp19711
g15
V34509
p19712
stp19713
a((dp19714
g2
(lp19715
VThis is not valid C++ code
p19716
aVis not dependent on the template parameter , so it must be found in the context of the template definition when it's parsed
p19717
aVHowever, in that context no declaration of  exists, and so there is an error
p19718
aVThe diagnostic message for that ill-formed template can be delayed until instantiation by the compiler, but if the compiler is good, it will diagnose the error earlier
p19719
aVCompilers that don't give any diagnostic message for that code even when the template is instantiated are not conforming
p19720
aVIt has nothing to do with unnamed namespaces
p19721
aVIn addition, notice that even if you put the unnamed namespace above that template, it will not be a valid C++ program either if you define and call that template in multiple translation units
p19722
aVThis is because different instantiations of the same template with the same template arguments will refer to different things (the string in the unnamed namespace will produce a different object each time it's defined in another translation unit)
p19723
aVBehavior for such a program would be undefined
p19724
as(dp19725
g15
V34509
p19726
stp19727
a((dp19728
g2
(lp19729
VYes, but the syntax won't look nice
p19730
aVBasically, it's just your  replaced by  (a function)
p19731
aVUsing a typedef it becomes more readable
p19732
aVNotice that to denote the abstact type, without a name, you need to write
p19733
aVThat is, you just erase the name
p19734
aVis not valid syntax
p19735
aVYou are right - you can't return  because this means you have a pointer to a pointer
p19736
aVAccessing with  would read from the address the returned pointer gives, and then read again from the address given by that pointer in turn
p19737
aVBut in fact, the array pointer you return points only to one memory block, so if you would make two indirections, you would try to reinterpret data as being pointers
p19738
aVContrary, if you return a  and do  you will not read any value from the address returned by the pointer
p19739
aVInstead, you merely add the offset  to the address, and adjust the type from  to  to have an array that refers to memory at the adjusted address
p19740
aVThe next index will then again adjust by  and since it operates on a  then (after the array decayed), not anymore on an array pointer, it will then read the content stored at the adjusted address, to finally yield the
p19741
aVThis is an important difference of non-array pointers and array pointers
p19742
aVYou can experiment with this, if you want
p19743
aVConsider these two snippets
p19744
aVOne will probably crash, but the other probably won't (but both yield undefined behavior, so this shouldn't be done in real programs)
p19745
as(dp19746
g15
V34509
p19747
stp19748
a((dp19749
g2
(lp19750
VYou should not test against code that tries to crash badly
p19751
aVSee Null References
p19752
aVIt says
p19753
aVJust as you must assume that a non-null pointer is valid, you must assume that a reference is valid
p19754
aVYou must have faith in your fellow programmers
p19755
aVI want to complement
p19756
aVyou must assume that the source of a copy is valid
p19757
aVIf you "fix" your case, what to do for this one
p19758
as(dp19759
g15
V34509
p19760
stp19761
a((dp19762
g2
(lp19763
VThis is called using declaration
p19764
aVThere are actually two ways you can use the  keyword
p19765
aVThere is a third special form of using declarations used inside class definitions, but i'll focus on the general using declaration here
p19766
aV(see below)
p19767
aVusing declaration
p19768
aVusing directive
p19769
aVThese have two very different effects
p19770
aVA using declaration declares a name to be an alias to another declaration or a set of declarations (if you were to name a set of overloaded functions)
p19771
aVThe name is declared in the current scope
p19772
aVThat is, you can use it inside blocks too
p19773
aVThis is quite useful if you use a name very often locally and you don't want to prefix it in all uses, and it's also useful in implementing the swap using argment dependent lookup idiom
p19774
aVA using directive names a namespace and does not declare any names
p19775
aVInstead it will modify name lookup to find names that aren't really declared where it thinks they are
p19776
aVFor unqualified name lookup, it find names declared in the enclosing namespace that encloses both the using directive and the target namespace
p19777
aVAll names that are declared in the target namespaces will be found:
p19778
aVHere,  will be thought as being declared twice in the global namespace, and causes an ambiguity ( encloses both  and )
p19779
aVIn qualified namelookup, it will build the transitive closure of a namespace with all the namespaces named in using directives
p19780
aVis not only looked up in the global namespace, but also in the namespace  and in the namespaces that  has using directives for and so on
p19781
aVIf however the global namespace would contain a direct declaration (including a using declaration), that declaration will hide the declarations found indirectly by using directives:
p19782
aVUsing declarations can appear in many places, including inside class definitions
p19783
aVIts meaning is similar to its meaning otherwhere with an important restriction: It declares a name to be an alias to one or more declarations, but the declarations must be members of a base class
p19784
aVThis is very useful for making names visible in a derived class that would otherwise be hidden by the same name declared there
p19785
aVNow you can call
p19786
aVIf there were no using declaration, then name lookup would only find one declaration of  in  and stop lookup, not delving into the base class scope:
p19787
aVIt also allows to change the accessibility of base-class members, although you should use that sparingly :)
p19788
aVIn practice, i found it useful for making virtual member function re-visible:
p19789
aVOops - now  is invalid because name lookup only finds the zero parameter
p19790
aVThe using directive would solve it
p19791
aVNotice that if you alias a function declaration that has the same parameter types and constness as an explicit declaration (like  in this case), then the explicit declaration will still hide the one that the using declaration is an alias for - so both  functions won't conflict in this case
p19792
aVAn alternative to solve this is using the non-virtual interface idiom
p19793
aVNow, both  and  are valid no matter on what object you call it
p19794
as(dp19795
g15
V34509
p19796
stp19797
a((dp19798
g2
(lp19799
VThat's probably not what you do in your code
p19800
aVThe error message looks like you do this
p19801
aVThe compiler has to know before it parses the code whether a name names a type or not
p19802
aVIn this case, when it parses, it cannot know because what type  is, is not yet known (you could have a specialization for  that doesn't have that nested class)
p19803
aVSo it assumes  is not a type
p19804
aVBut then, it is an expression and an operator is needed after it or a semicolon
p19805
aVYou can fix it by inserting :
p19806
aVThat asserts the name is a type, and the compiler then knows to parse this as a declaration
p19807
as(dp19808
g15
V34509
p19809
stp19810
a((dp19811
g2
(lp19812
VThis is not possible
p19813
aVA using declaration can't name a private base class member
p19814
aVNot even if there are other overloaded functions with the same name that aren't private
p19815
aVThe only way could be to make the derived class a friend:
p19816
aVSince you make the names public in the derived class anyway so derived classes of  will be able to access them, you could make them  in the base-class too and omit the  declaration
p19817
as(dp19818
g15
V34509
p19819
stp19820
a((dp19821
g2
(lp19822
VWe can't know what will
p19823
aVEverything can happen, because the program exposes undefined behavior
p19824
aVSee Does invoking a member function on a null instance cause undefined behavior
p19825
as(dp19826
g15
V34509
p19827
stp19828
a((dp19829
g2
(lp19830
V means to translate the result of the  phase, and  means to combine the results of the assemble phases of different executions of gcc together into an executable or library
p19831
aVThe  phase takes the result of the preprocessing phase and results in assembler code, roughly
p19832
as(dp19833
g15
V34509
p19834
stp19835
a((dp19836
g2
(lp19837
VUse sfinae
p19838
aVThat  will only be able to accept  or  for
p19839
aVNo hard compile time error occurs if you call , but rather if there is another function that accepts the argument, that one is taken instead
p19840
as(dp19841
g15
V34509
p19842
stp19843
a((dp19844
g2
(lp19845
VThe problem is that if in a template one of its function parameters is not a reference type before deduction starts, that parameter will never deduce to a reference type
p19846
aVSo in the deduction on the left side,  yields , but on the deduction on the right side,  yields
p19847
aVThat's a mistmatch and the compiler complains
p19848
aVThe best is to make the function parameter the same type as the parameter type of the function pointer:
p19849
aVBy using , you disable deduction on the left side
p19850
aVOnce the  was determined at the right side,  is sustituted into the left side and yields the final parameter type
p19851
aVOne guy proposed to take the right side as a template parameter - this is a good thing since it can then accept function objects with  overloaded
p19852
aVBut you then face the problem of having to know whether it wants a reference or not
p19853
aVTo solve it,  has  (by the way,  also has the  template above)
p19854
aVNow, if you want to pass a reference and not a copy, you can do that like this
p19855
aVreturns a reference_wrapper object which is implicitly convertible to
p19856
aVSo if you call , the  is converted to the target reference automagically
p19857
aVIf you don't want to pass a reference, just pass  directly
p19858
as(dp19859
g15
V34509
p19860
stp19861
a((dp19862
g2
(lp19863
VIn fact the problem is due to  declaration not having seen yet when you inherit from the policy
p19864
aVThere is some discussion about the exact semantics where these declarations are visible by instantiated templates, which has pretty complex issues, see this defect report
p19865
aVBut in your case, the situation is clear: Before the class body, no code can see any declaration of class members, and so your code fails
p19866
aVYou could pass the type as a template argument
p19867
aVIf there are more types, you may decide to pass a trait
p19868
as(dp19869
g15
V34509
p19870
stp19871
a((dp19872
g2
(lp19873
VKDevelop4 can do it
p19874
aVhas a public constructor taking an , so it shows its operator+ for all but the last use of
p19875
as(dp19876
g15
V34509
p19877
stp19878
a((dp19879
g2
(lp19880
VI reduced the testcase and then consider three options
p19881
aVOption 1
p19882
aVOption 2
p19883
aVOption 3
p19884
as(dp19885
g15
V34509
p19886
stp19887
a((dp19888
g2
(lp19889
VFor class type, C++ already supports it directly
p19890
aVFor nonclass types, you need to store the size manually like the other solution shows
p19891
as(dp19892
g15
V34509
p19893
stp19894
a((dp19895
g2
(lp19896
VFirst: where are std::move and std::forward defined
p19897
aVSee  Utility components,
p19898
aVWhen implementing move semantics, the source is presumably left in an undefined state
p19899
aVShould this state necessarily be a valid state for the object
p19900
aVObviously, the object should still be destructibly
p19901
aVBut further than that, i think it's a good idea to be still assignable
p19902
aVThe Standard says for objects that satisfy "MoveConstructible" and "MoveAssignable":
p19903
aV[ Note: rv remains a valid object
p19904
aVIts state is unspecified
p19905
aV\u2014 end note ]
p19906
aVThis would mean, i think, that the object can still participate in any operation that doesn't state any precondition
p19907
aVThis includes CopyConstructible, CopyAssignable, Destructible and other things
p19908
aVNotice that this won't require anything for your own objects from a core language perspective
p19909
aVThe requirements only take place once you touch Standard library components that state these requirements
p19910
aVNext: when you don't care about move semantics, are there any limitations that would cause a non-const reference to be preferred over an rvalue reference when dealing with function parameters
p19911
aVThis, unfortunately, crucially depends on whether the parameter is in a function template and uses a template parameter:
p19912
aVHowever for a function template
p19913
aVYou can't say that, because the second template will, after being called with an lvalue, have as parameter of the synthesized declaration the type  for nonconst lvalues (and be a better match), and  for const lvalues (and be ambiguous)
p19914
aVTo my knowledge, there is no partial ordering rule to disambiguate that second ambiguity
p19915
aVHowever, this is already known
p19916
aVEdit
p19917
aVDespite that issue report, i don't think that the two templates are ambiguous
p19918
aVPartial ordering will make the first template more specialized, because after taking away the reference modifiers and the , we will find that both types are the same, and then notice that the first template had a reference to const
p19919
aVThe Standard says ()
p19920
aVIf, for a given type, deduction succeeds in both directions (i
p19921
ag1992
aV, the types are identical after the transfor-mations above) and if the type from the argument template is more cv-quali\ufb01ed than the type from the parameter template (as described above) that type is considered to be more specialized than the other
p19922
aVIf for each type being considered a given template is at least as specialized for all types and more specialized for some set of types and the other template is not more specialized for any types or is not at least as specialized for any types, then the given template is more specialized than the other template
p19923
aVThis makes the  template the winner of partial ordering (and GCC is indeed correct to choose it)
p19924
aVEdit End
p19925
aVWhich brings me to my final question
p19926
aVYou still can not bind temporaries to non-const references
p19927
aVBut you can bind them to non-const rvalue references
p19928
aVThis is nicely explained in this article
p19929
aVThe second call using  only takes nonconst rvalues
p19930
aVThe rest of the program won't notice if they are modified, because they won't be able to access those rvalues afterwards anymore
p19931
aVAnd the  you pass is not a class type, so a hidden temporary is created and then passed to the  rvalue reference
p19932
aVThe code calling  won't be able to access that hidden object here, so it won't notice any change
p19933
aVA different situation is if you do this one:
p19934
aVYou have explicitly requested that  is moved, so it will be modified according to its move specification
p19935
aVHowever moving is a logically non-modifying operation (see the article)
p19936
aVThis means whether you move or not shouldn't be observable from the calling code:
p19937
aVIf you erase the line that moves, behavior will still be the same, because it's overwritten anyway
p19938
aVThis however means that code that uses the value of  after it has been moved from is bad, because it breaks this implicit contract between  and the calling code
p19939
aVThus, the Standard makes no specification about the concrete value of a moved from container
p19940
as(dp19941
g15
V34509
p19942
stp19943
a((dp19944
g2
(lp19945
VYes, integer operands are promoted
p19946
aVBut that doesn't matter here
p19947
aVcannot be  if it's of unsigned type
p19948
aVProbably you did
p19949
aVBut that will do the same as
p19950
aVAnd this is likely to cause undefined behavior if the address range the pointer can hold can't cope with this addition
p19951
aVThe Standard says at
p19952
aVFor the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type
p19953
aVWhen an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand
p19954
aVIf the pointer operand points to an element of an array object, and the array is large enough, [
p19955
aVIf both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined
p19956
aVThat is, if the result pointer does not lie in the same array or one past the end, or if it does but did so by overflow, behavior is undefined
p19957
as(dp19958
g15
V34509
p19959
stp19960
a((dp19961
g2
(lp19962
V is what you want to use
p19963
aVIf you use a pointer as member of the union, you have to allocate and free the string that the pointer points to yourself, preferably using  and
p19964
aVsolves that problem: It allocates all members within the variant object itself (so no dynamic allocation for storing members), and you don't have to do any  or  call yourself at all
p19965
as(dp19966
g15
V34509
p19967
stp19968
a((dp19969
g2
(lp19970
VNotice that you can have references to functions
p19971
aVNow calling it with  won't work anymore because you try to bind a function reference to a pointer instead of to a function
p19972
aVSometimes this shines through when using templates
p19973
aVNow calling it with  will fail because  is tried to be deduced to both a function pointer and a function type (no decay to a pointer is done when passing to a reference parameter
p19974
as(dp19975
g15
V34509
p19976
stp19977
a((dp19978
g2
(lp19979
VName lookup is the process of identifying what a name means
p19980
aVName lookup has two purposes
p19981
aVDisambiguate parsing of your code
p19982
aVDetermining what precisely your code means
p19983
aVFor instance if you have this code
p19984
aVIt depends on whether  is a type or not: If it is a type, it will be a declaration of , and if it isn't a type, it's interpreted as a function call
p19985
aVSome names denote types or templates
p19986
aVIn general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it
p19987
aVThe process that determines this is called name lookup
p19988
aVName lookup associates the use of a name with a declaration (3
p19989
aV1) of that name
p19990
aVThere are two main classes of name-lookup
p19991
aVUnqualified name lookup: Starting from the current scope, a name is looked up, escaping into the enclosing scopes and base classes if inside a class
p19992
aVDoes not start from a specific named scope
p19993
aVThis lookup form stops as soon as it finds a name
p19994
aVSo a name in an inner scope (or class) hides a name found in an outer scope (or base class)
p19995
aVQualified name lookup: Looking a name up in a given scope using the  operator
p19996
aVSeveral other forms exist, like looking up a name that appears after the dot or arrow (like ) or looking up a name in  (in which nontype names are ignored)
p19997
aVOne particular interesting form is the argument dependent lookup used for finding function declarations based on argument types used in a function call
p19998
aVAfter name lookup found a declaration, it's inspected to see what attributes it got and whether the program can use it
p19999
aVOnly after name lookup, function overload resolution (if applicable) and access checking have succeeded are the attributes introduced by the name\u2019s declaration used further in expression processing
p20000
aVThus name-lookup will find private class members, but your code is rejected if you use such names if you haven't access to them
p20001
aVThis is true even if a base class would have the same name with public access - that's because name-lookup stops in the derived class if it finds a name
p20002
as(dp20003
g15
V34509
p20004
stp20005
a((dp20006
g2
(lp20007
VTakes , and casts it to
p20008
aVThe cast may have different reasons
p20009
aVPerhaps  is  and the cast is needed to tell the compiler what type it should use for finding
p20010
aVIt may also be another struct that has an  as its first member
p20011
aVThen, casting  to  would be valid because on its address there is a  at the beginning
p20012
aVAfter the cast, the member  is accessed
p20013
aVThese types are common in network programming under POSIX, and don't look like in my above example, but the above could have been the situation at hand
p20014
as(dp20015
g15
V34509
p20016
stp20017
a((dp20018
g2
(lp20019
VYou can pass a function pointer to decouple the function from its users
p20020
aVThen suppose you pass a  to the function, you can pass it a getter like this:
p20021
aVYou could use a more uglier alternative with  though
p20022
aVis a macro that gives you the offset of a member within a struct
p20023
aVIn the function you position the pointer to the  member (so you have to cast to  to get the appropriate type) and get the member value
p20024
aVHowever i would prefer the first way of using functions
p20025
aVThat way, the print function doesn't even have to know that  points to a struct
p20026
aVIt can hand over it as a black box to the getter function and in it you can let the compiler handle the low-level offset calculations for you
p20027
as(dp20028
g15
V34509
p20029
stp20030
a((dp20031
g2
(lp20032
Vchange/initialize each time the function is called
p20033
aVYou use the words "change" and "initialize" as though they were the same, but they aren't
p20034
aVWhen at file-scope (outside functions)  does not mean "const" as in "static value", but it means that the identifier can only be referred to in that translation unit
p20035
aVSo your first  without  can still be changed
p20036
aVOnly  guards against changes
p20037
aVBut if you omit  then if you link in a library or another object file that has the same non-static identifier at file-scope you will get conflicts at link-time
p20038
as(dp20039
g15
V34509
p20040
stp20041
a((dp20042
g2
(lp20043
VThis goes from  first bullet to  list-initialization and from  third bullet to  aggregate initialization and then  says
p20044
aVAn array of unknown size initialized with a brace-enclosed initializer-list containing n initializer-clauses, where shall be greater than zero, is de\ufb01ned as having elements
p20045
aVThe only difference if the object is an array between  and  is that the first is called copy-list-initialization and the second is called direct-list-initialization, so both are kinds of list-initialization
p20046
aVThe elements of the array are copy-initialized from the elements of the initializer list in both cases
p20047
aVNotice that there is a subtle difference between those forms if the array has a size and the list is empty, in which case  second bullet applies:
p20048
aVThis difference does not apply to lists that have content in which case third bullet applies again, though
p20049
aVThe FCD changed this compared to the previous draft, and initialization with an empty initializer list now always works even with explicit default constructors
p20050
aVThis is because the FCD states that the elements are value-initialized, and value initialization doesn't care about explicitness since it doesn't do overload resolution on default constructors (it couldn't figure out better or worse matches anyway)
p20051
aVThe previous draft used normal overload resolution on the constructors and thus rejected explicit default constructors during copy initialization
p20052
aVThis defect report did that change
p20053
as(dp20054
g15
V34509
p20055
stp20056
a((dp20057
g2
(lp20058
VIt depends on the machine executing your program
p20059
aVBut the value evaluates at compile time
p20060
aVThus the compiler (of course) has to know for which machine it's compiling
p20061
as(dp20062
g15
V34509
p20063
stp20064
a((dp20065
g2
(lp20066
VYou can use identity
p20067
aVYou are correct that function and array declarators won't work in conversion functions
p20068
aVThis is also known and discussed in this issue report
p20069
aVHowever i think that C++0x already provides a solution to what they discuss there
p20070
aVUnlike the  and  approach, this allows  and  to be deduced, i think
p20071
as(dp20072
g15
V34509
p20073
stp20074
a((dp20075
g2
(lp20076
VYou can also move the condition from the primary template into the specialization
p20077
aVThe trick is that while non-type parameters in sub-expressions aren't allowed in non-type specialization arguments, they are allowed in type arguments
p20078
aVOccassionally, people also use SFINAE for this
p20079
aVThe following accesses  which is only there if the condition is true
p20080
aVIf it is false, the type is not there and SFINAE sorts out the specialization
p20081
aVWith  being the following well-known template
p20082
as(dp20083
g15
V34509
p20084
stp20085
a((dp20086
g2
(lp20087
VUsually the way to solve this kind of problem is through overloading
p20088
aVThis mimics explicit specializations quite well, and even works in cases where type check for the other paths would go mad (unlike the  solution)
p20089
aVThat works because this path is only taken if
p20090
aVNow in your case, i first of all wonder why you don't just pass a normal function argument
p20091
aVYou don't seem to need the compile time nature of
p20092
aVThis also has good chances of being optimized if the compiler inlines the function call
p20093
aVUsing the template non-type parameter where it's not strictly necessary only limits the abilities of that function not to work with runtime values
p20094
as(dp20095
g15
V34509
p20096
stp20097
a((dp20098
g2
(lp20099
VYou can do what you want, but don't do it, because it's not typesafe
p20100
aVBest pass a vector of  or a pair of iterators containing those values
p20101
aVThis can be better solved, since all the elements ae homogenuous typed anyway
p20102
aVOf course, you have to make sure there is enough place in
p20103
as(dp20104
g15
V34509
p20105
stp20106
a((dp20107
g2
(lp20108
VYou are missing a closing  for your  body
p20109
aVAlso, this is not correct:
p20110
aVThe order has to be the other way around
p20111
aVGCC's behavior isn't conforming:  must not be visible if no standard header is included yet
p20112
aVSo on the next more conformant compiler, it may fail hard
p20113
aVAlso, in the header you should write  instead of just  (same for , etc)
p20114
aVIn your current code, your header relies on its users to have typen  before including it, which is pretty ugly from a design point of view, since it makes the headers dependent on its users in a non-obvious way (normally, it should be the other way around)
p20115
as(dp20116
g15
V34509
p20117
stp20118
a((dp20119
g2
(lp20120
VThis can be done with facets
p20121
aVAlternatively, you may code your own loop
p20122
as(dp20123
g15
V34509
p20124
stp20125
a((dp20126
g2
(lp20127
VIn a later comment, he clears up the matter a bit
p20128
aVThis is the important point I tried to get through in the first section
p20129
aVWhen you use QSharedPointer, you\u2019re sharing the ownership of the pointer
p20130
aVThe class controls and handles the pointer only \u2014 anything else (like access to the data) is outside its scope
p20131
aVWhen you use QSharedDataPointer, you\u2019re sharing the data
p20132
aVAnd that class is intended for implicit sharing: so it may split up
p20133
aVTrying to interpret that:
p20134
aVWhat's important to see is that "pointer" does not mean the object storing the address in this case, but it means the storage location where the object is located (the address itself)
p20135
aVSo strictly, i think, you have to say you are sharing the address
p20136
aVis thus a smart pointer sharing the "pointer"
p20137
aVor another intrusive smart pointer seems to share the pointer too, albeit knowing something about the object pointed to (that it has a reference-count member or functions incrementing/decrementing it)
p20138
aVExample: If someone shares a black box with you and he doesn't know what is in the black box, it is similar to sharing the pointer (which represents the box), but not the data (what is inside the box)
p20139
aVIn fact, you can't even know that what is inside the box is sharable (what if the box contains nothing at all
p20140
aVThe smart pointers are represented by you and the other guy (and you aren't shared, of course), but the address is the box, and it is shared
p20141
aVSharing the data means the smart pointer knows sufficiently enough of the data pointed to that it may change the address pointed to (and this needs to copy over data, etc)
p20142
aVSo, the pointers now may point to different addresses
p20143
aVSince the address is different, the address isn't shared anymore
p20144
aVThis is what  does on some implementations, too:
p20145
aVSharing data does not necessarily mean you have a pointer presented to you
p20146
aVYou may use a  by pure means of  and  and never touch any of the  functions
p20147
aVStill sharing may go on behind the scene
p20148
aVThe same thing happens with many Qt classes and classes of other widget toolkits too, which is called implicit sharing (or copy on write)
p20149
aVSo i think one may sum it up like this:
p20150
aVSharing the pointer: We always point to the same address when we copy a smart pointer, implying that we share the pointer value
p20151
aVSharing the data: We may point to different addresses at different times
p20152
aVImplying that we know how to copy data from one address to the other
p20153
aVSo trying to categorize
p20154
aV, : Share the pointer, not the data
p20155
aV, , : Share the data it contains
p20156
aV,  (and also ): Neither share the pointer, nor the data
p20157
as(dp20158
g15
V34509
p20159
stp20160
a((dp20161
g2
(lp20162
VYou cannot protect yourself from this
p20163
aVIf you want, you have to use another language that checks for you
p20164
aVC and C++ demand that you check yourself that you write safe code
p20165
aVAn alternative may be to wrap the array into a struct
p20166
aVThat class is provided by  and C++0x too (however, without a  function), but error checking is not required for them
p20167
as(dp20168
g15
V34509
p20169
stp20170
a((dp20171
g2
(lp20172
VImagine a slightly different scenario
p20173
aVIf this would work, would it increment the  in  or the  in
p20174
aVThat's why it's ambiguous
p20175
aVThe  pointer and any non-static data member is distinct for the two  subobjects (one of which is contained by the  subobject, and the other by the  subobject)
p20176
aVTry changing your code like this and it will work (in that it compiles and prints "A")
p20177
aVThat will call  on the  subobject of  and  respectively
p20178
as(dp20179
g15
V34509
p20180
stp20181
a((dp20182
g2
(lp20183
VYou are not reading linewise
p20184
aVReplace the condition by
p20185
aVIf you use  it will extract only the first word to
p20186
as(dp20187
g15
V34509
p20188
stp20189
a((dp20190
g2
(lp20191
VYou can call  by using , because  is inherited
p20192
aVThe term "methods" is not defined by C++
p20193
aVIf you refer to non-static member functions - they are members and are inherited to derived classes
p20194
aVYour error is not that  isn't inherited, but that you try to access the inaccessible members  and
p20195
as(dp20196
g15
V34509
p20197
stp20198
a((dp20199
g2
(lp20200
VIt's not even guaranteed to be a value at all
p20201
aVTrying to read the int, anything can happen (such as a signal sent causing your program to terminate)
p20202
aVWith particular importance in real life programming, switching on a not initialized  can cause you hit neither  nor  cases
p20203
as(dp20204
g15
V34509
p20205
stp20206
a((dp20207
g2
(lp20208
VIt's complete
p20209
aVBut there are two points you should note:
p20210
aVIt's the copy =operator
p20211
aVJust like there is a copy constructor, there is a copy assignment operator
p20212
aVThey are only provided if actually used
p20213
aVSome explanation for 2:
p20214
aVThat's fine
p20215
aVProviding a default constructor would be ill-formed for "B", because it would not be able to call the base-class' constructor
p20216
aVBut the default constructor (and the other special functions) is only provided (we say it's implicitly defined) if it's actually needed
p20217
as(dp20218
g15
V34509
p20219
stp20220
a((dp20221
g2
(lp20222
VI suspect many values aren't strings
p20223
aVSo the first thing you can do is to get rid of the  object if you don't need it
p20224
aVPut it into an union
p20225
aVAnother thing is that probably many of your strings are only small, thus you can get rid of heap allocation if you save small strings in the object itself
p20226
aVLLVM has the  template for that
p20227
aVAnd then you can use string interning, as another answer says too
p20228
aVLLVM has the  class for that: Call  and get a smart pointer refering to a shared string potentially used by other  objects too
p20229
aVThe union can be written like this
p20230
aVdoes the type tagging for you
p20231
aVYou can implement it like this, if you don't have boost
p20232
aVThe alignment can't be gotten portably in C++ yet, so we push some types that possibly require some large alignment into the storage union
p20233
aVYou get the idea
p20234
as(dp20235
g15
V34509
p20236
stp20237
a((dp20238
g2
(lp20239
VIt doesn't matter
p20240
aVSomeone will now come along and close the question as a dupe, and someone else will show how the  way breaks if you declare multiple variables in the same declarations while the  way better reflects the syntactical structure of the code, and another guy shows that stroustrup prefers the  way
p20241
aVMuch opinions, but no "right" way here
p20242
as(dp20243
g15
V34509
p20244
stp20245
a((dp20246
g2
(lp20247
VYou may want to look into
p20248
aVA specialization is done for class type that wraps them into an , thus calling the constructor/destructor lazily
p20249
aVFor non-class types, we don't need that wrapping
p20250
aVNot wrapping them means we can treat  as a contiguous memory area and pass that address to C functions that want an array
p20251
aVwill create the class types in-place, without using a temporary  or its copy constructor
p20252
aVNot using inheritance or private members allow the class to stay an aggregate, allowing a convenient form of initialization
p20253
as(dp20254
g15
V34509
p20255
stp20256
a((dp20257
g2
(lp20258
VClang solves that by having their diagnostics have  overloaded, streaming the required arguments, which I adopted in my compiler too
p20259
aVYou can then call it like
p20260
aVWhen the diagnostic-builder's destructor is called, the error is emitted
p20261
aVI find that this way of doing it is quite convenient
p20262
aVYou can extend it to support multiple languages by numbering the argument placeholders, like
p20263
as(dp20264
g15
V34509
p20265
stp20266
a((dp20267
g2
(lp20268
VIt's not allowed right now
p20269
aVBut it's supported in C++0x
p20270
aVThe current Standard says at
p20271
aVA local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall not be used as a template-argument for a template type-parameter
p20272
aVThat said, if the function is also local, there's no problem
p20273
as(dp20274
g15
V34509
p20275
stp20276
a((dp20277
g2
(lp20278
VDo you mean the following
p20279
aVYes, it's allowed
p20280
aVUse smart pointers if you need it to be destroyed when the program exits
p20281
as(dp20282
g15
V34509
p20283
stp20284
a((dp20285
g2
(lp20286
VYou are compiling a  file with
p20287
aVRename the file to end with  so it compiles as C code or compile it with the C++ driver
p20288
aVThat will link in the  library providing these functions
p20289
as(dp20290
g15
V34509
p20291
stp20292
a((dp20293
g2
(lp20294
VChange  to be an array of
p20295
aVThen you can say
p20296
aVYou can't get the address of a variadic arg
p20297
as(dp20298
g15
V34509
p20299
stp20300
a((dp20301
g2
(lp20302
V is an array of , and  is a pointer to
p20303
aVIt's initialized to , which decays to a pointer to its first element
p20304
aVDereferencing  yields , which decays to  (pointer to its first element)
p20305
aVSo  adds  to the  that was the result of the decay
p20306
aVSo it's setting the third of the first  integers (, with  being 4) to
p20307
aVAdding to  would advance the address stored in it by units of  bytes, which at runtime (since  is not a compile time constant) evaluates to
p20308
aVSo  would access the third of the second  integers
p20309
aVIn total,  has  such arrays of  ints to point to: ,  and
p20310
aVNotice that you created a C99 VLA, variable length array
p20311
aVYou need to   and  to integer constants to get rid of those VLAs (which aren't quite portable among C compilers)
p20312
as(dp20313
g15
V34509
p20314
stp20315
a((dp20316
g2
(lp20317
VIt's a bug in G++
p20318
aVis an unqualified dependent name (because it has  in it and lookup will thus be different depending on its type)
p20319
aVAs such it has to be looked up when instantiating
p20320
aVThe Standard rules
p20321
aVTwo names are the same if
p20322
aVthey are the names of user-defined conversion functions formed with the same type
p20323
aVThus the type name specified after the operator keyword doesn't have to match lexically in any way
p20324
aVYou can apply the following work-around to force GCC treating it as a dependent name
p20325
as(dp20326
g15
V34509
p20327
stp20328
a((dp20329
g2
(lp20330
VThese solve different problems
p20331
aV(or ) points to a C style string which isn't necessarily owned by the one storing the  pointer
p20332
aVIn C, because of the lack of a string type, necessarily you often use  as "the string type"
p20333
aVowns the string data it points to
p20334
aVSo if you need to store a string somewhere in your class, chances are good you want to use  or your librarie's string class instead of
p20335
aVOn contiguity of the storage of , other people already answered
p20336
as(dp20337
g15
V34509
p20338
stp20339
a((dp20340
g2
(lp20341
VThere is no technical reason
p20342
aVIf you ignore the stylistic reason, you could write ,  and the-like too
p20343
as(dp20344
g15
V34509
p20345
stp20346
a((dp20347
g2
(lp20348
VIf  cannot throw (hard to believe that it could), there is no problem with this
p20349
aVSide effects are allowed in constructor initializers
p20350
aVIt's good practice to do any initialization there, if it takes only little code
p20351
as(dp20352
g15
V34509
p20353
stp20354
a((dp20355
g2
(lp20356
VFirst of all, the Standard is ambivalent on the use of "name", i think
p20357
aVFirst, it says (added the other forms of names below, as corrected by the C++0x draft)
p20358
aVA name is a use of an identi\ufb01er (2
p20359
aV11), operator-function-id (13
p20360
aV5), conversion-function-id (12
p20361
ag1037
aV2), or template-id (14
p20362
aV2) that denotes an entity or label (6
p20363
ag488
aV4, 6
p20364
aV1)
p20365
aVThen in parts of the Standard it uses "name" as if it would contain qualifier portions like
p20366
aVAnd in other parts, it excludes such portions from a "name"
p20367
aVOne paragraph even says that a name prefixed by  refers to a global name
p20368
aVBut in our example,  was prefixed by such a token, even though its intentionally not referring to a global name
p20369
aVThe construct in our example is not a name, i think, but rather two names, one qualifying the other
p20370
aVA destructor is referenced by the construct  (see  and )
p20371
aVSuch a construct consists of a  token and a name, refering to the constructor's class
p20372
aVIt's conventional to call it the destructor's "name" (just like the Standard at  talks about a "constructor name") - but pedantically, it isn't a name
p20373
aVSo, if you are pedantical, you would say that a destructor does not have an own name, but rather special mechanisms are used for referring to it
p20374
aVLikewise for constructors, special constructs are used to refer to them (otherwise, you couldn't declare a constructor out of class - the declaration has to refer to it
p20375
aVAnd in C++0x using declarations have to be able to refer to them too, using the special constructs provided (see  for how you can refer to a constructor)
p20376
aVThe destructor lookup is quite convoluted, and has quite a few bugs in the Standard
p20377
aVSee this issue report for further details
p20378
as(dp20379
g15
V34509
p20380
stp20381
a((dp20382
g2
(lp20383
VYou need to define that template in the header file if your compiler doesn't have the "export" template feature (only compilers based on the EDG frontend have, which GCC and MSVC do not)
p20384
aVYou can alternatively explicitly instantiate the function template in the
p20385
aVcpp file (if you placed its definition there):
p20386
aVBut as soon as you pass another pair of types you haven't explicitly instantiated like that, it again fails to link
p20387
aVSo you need to put the function template's definition into the header, so the compiler sees it when calling the function, and instantiates a copy of the function itself
p20388
as(dp20389
g15
V34509
p20390
stp20391
a((dp20392
g2
(lp20393
VYou cannot do  because you have no random access for list iterators
p20394
aVYou can only do one step at a time with list iterators (these are bidirectional iterators)
p20395
aVYou can use  and
p20396
aVOr you can print the comma before:
p20397
as(dp20398
g15
V34509
p20399
stp20400
a((dp20401
g2
(lp20402
VYou probably look at a recursive call which sets  to true
p20403
aVBut when that call returns to its caller, that  is still at false, and that's then returned
p20404
aVYou need to assign the recursive callee's result:
p20405
as(dp20406
g15
V34509
p20407
stp20408
a((dp20409
g2
(lp20410
VYes it is
p20411
aVIf you call it with a specific , the compiler will deduce  and  to the appropriate values
p20412
aVThe above value-parameter matches your example, but it's better to pass user defined classes that need to do work in their copy constructors by const reference ( instead)
p20413
aVSo you avoid copies, but still can't change the caller's argument
p20414
as(dp20415
g15
V34509
p20416
stp20417
a((dp20418
g2
(lp20419
VIf you want to have a "template pointer", you could try a function object
p20420
aVThe example below adds  to the wrapped function template
p20421
aVThe difference to a "real" template pointer is that you cannot re-seat "AcceptsVector" to call another template, like you can do with normal function pointers
p20422
aVThe binding is hardcoded at compile-time
p20423
aVHowever you can pass along  like a function pointer, and can call  with any  like a template
p20424
as(dp20425
g15
V34509
p20426
stp20427
a((dp20428
g2
(lp20429
VYou could also overload the operators if you want to compare it
p20430
aVHowever you have to do that dance for any integer type on the right side
p20431
aVOtherwise if you do  it would be ambiguous: The compiler could use your  matching the left side exactly but needing a conversion on the right side, or its built-in operator, needing a promotion for the left side and matching the rigth side exactly
p20432
aVSo ultimately, i would put the following versions:
p20433
aVNot very nice :) But at least the user of your enumeration has easy going
p20434
aVHowever if you ultimately don't want to compare against ordinary  but against some meaningful value, i would do what some other guy proposed, and add another enumerator that has as value , and name it
p20435
aVThat way, warnings will go away too
p20436
as(dp20437
g15
V34509
p20438
stp20439
a((dp20440
g2
(lp20441
VIt doesn't contradict, because  is not defined
p20442
aVIt's just a static member function
p20443
aVFunctions can't be const, and static member functions can't have a const attached at the very right either
p20444
aVThere is also a  in the double version of the limits, and in C++03 it wouldn't work to say
p20445
aVSo to be consistent,  is a function for all versions of the limit template
p20446
aVNow, it's known that  not being able to be used like that is bad, and C++0x already solves it by making it a  function, allowing your proposed usage
p20447
as(dp20448
g15
V34509
p20449
stp20450
a((dp20451
g2
(lp20452
VYou are talking about implicit instantiation
p20453
aVBut that does only happen if the completenes of the class type would affect semantics of the program
p20454
aVIn your case, the class type doesn't need to be complete because the type you typedef can stay incomplete (class body is not needed, so there is no need to instantiate it)
p20455
aVTo illustrate, you can also say  in a statement of its own, without ever defining that class anywhere
p20456
aVIf you create an object, the type of it has to be complete, and so the class template then is implicitly instantiated
p20457
aVPlease note that implicit instantiation of a class template will not implicitly instantiate the member function or static datamember definitions, unless they are explicitly used elsewhere
p20458
aVAlso, to declare a specialization of a class-template, the whole point is to prevent an instantiation to happen, to tell the compiler "don't instantiate, because later i specialize it explicitly"
p20459
aVThe declaration if your specialization also misses a  in front of it
p20460
as(dp20461
g15
V34509
p20462
stp20463
a((dp20464
g2
(lp20465
VYou are probably compiling in non-strict mode in icc
p20466
aVAnyway, since  is unqualified, it shall not be looked up in any base classes that depend on the template parameters
p20467
aVSo in your code, there is no place where  is found, and your code is invalid
p20468
aVThe other names are looked up using another form of lookup (class member access lookup, and qualified lookup)
p20469
aVBoth of those forms will look into dependent base classes if they can (i
p20470
aVe if they are dependent, and are thus looked up when instantiating the template when  is known - all your other names are dependent on template parameters)
p20471
aVEven GCC in their latest versions don't implement that correctly, and some dependent names still resolve against dependent bases during unqualified lookup
p20472
as(dp20473
g15
V34509
p20474
stp20475
a((dp20476
g2
(lp20477
VIt seems pretty easy
p20478
aVThe questioner himself proposed a nice solution, but he can just use a usual copy constructor with a const-reference parameter
p20479
aVHere is what i proposed in comments:
p20480
aVIt Just Works
p20481
aVNo need for complex templates or smart pointers
p20482
as(dp20483
g15
V34509
p20484
stp20485
a((dp20486
g2
(lp20487
VWhat do you want the static to do
p20488
aVIt serves there to give variables defined in the declaration internal linkage:
p20489
aVAs a shortcut for
p20490
aVGiving "a" internal linkage
p20491
aVBut since you don't define a variable there in your code, it is useless in fact (if not illegal)
p20492
as(dp20493
g15
V34509
p20494
stp20495
a((dp20496
g2
(lp20497
VYes, there is
p20498
aVBut not in that particular example
p20499
aVIf the parameter is not deduced, it can make a difference
p20500
aVYou cannot specialize that without  because it cannot deduce what  is from the parameter list
p20501
aVOf course in your case, it's the digraph  that's meaning the same as  causing your problem
p20502
aVPut a space like  to avoid the problem
p20503
as(dp20504
g15
V34509
p20505
stp20506
a((dp20507
g2
(lp20508
VYou can't do it
p20509
aVC provides absolutely no way to get to the type of a variable
p20510
as(dp20511
g15
V34509
p20512
stp20513
a((dp20514
g2
(lp20515
VGCC is doing it wrong according the FCD
p20516
aVThe FCD says at  about reference binding
p20517
aVIf the reference is an lvalue reference and the initializer expression is an [lvalue / class type]
p20518
aVOtherwise, the reference shall be an lvalue reference to a non-volatile const type (i
p20519
ag1992
aV, cv1 shall be const), or the reference shall be an rvalue reference and the initializer expression shall be an rvalue or have a function type
p20520
aVYour case for the call to the  matches none of them, because the initializer is an lvalue
p20521
aVIt doesn't get to the place to create a temporary rvalue, because that toplevel bullet already requires an rvalue
p20522
aVNow, overload resolution doesn't directly use reference binding to see whether there exist an implicit conversion sequence
p20523
aVInstead, it says at
p20524
aVWhen a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the one required to convert the argument expression to the underlying type of the reference according to 13
p20525
ag1037
ag1037
ag2790
aVThus, overload resolution figures out a winner, even though that winner may actually not be able to bind to that argument
p20526
aVFor example:
p20527
aVReference binding at  forbids bitfields to bind to lvalue references
p20528
aVBut overload resolution says that the conversion sequence is the one converting to , thus succeeding even though when the call is made later, the call is ill-formed
p20529
aVThus my bitfields example is ill-formed
p20530
aVIf it was to choose the  version, it would have succeeded, but needed a user defined conversion
p20531
aVHowever, there exist two exceptions for that rule
p20532
aVThese are
p20533
aVExcept for an implicit object parameter, for which see 13
p20534
ag1037
aV1, a standard conversion sequence cannot be formed if it requires binding an lvalue reference to non-const to an rvalue or binding an rvalue reference to an lvalue
p20535
aVThus, the following call is valid:
p20536
aVAnd thus, your example calls the  version
p20537
aVHowever, if you say , you create an rvalue, and thus the second function is viable
p20538
as(dp20539
g15
V34509
p20540
stp20541
a((dp20542
g2
(lp20543
VI don't quite see your point in this question
p20544
aVIf you have a class that is movable, then you just need a  version:
p20545
aVAnd if the class is traditional but has an efficient  you can write the swap version or you can fallback to the  way
p20546
aVRegarding the swap version, I would rather go with the  way instead of that swap
p20547
aVThe main advantage of the swap technique is exception safety and is to move the copy closer to the caller so that it can optimize away copies of temporaries
p20548
aVBut what do you have to save if you are just constructing the object anyway
p20549
aVAnd if the constructor is small, the compiler can look into it and can optimize away copies too
p20550
aVTo me, it doesn't seem right to automatically convert a string lvalue to a rvalue copy of itself just to bind to a rvalue reference
p20551
aVAn rvalue reference says it binds to rvalue
p20552
aVBut if you try binding to an lvalue of the same type it better fails
p20553
aVIntroducing hidden copies to allow that doesn't sound right to me, because when people see a  and you pass a  lvalue, I bet most will expect that there is no copy, and that binding is directly, if it works at all
p20554
aVBetter fail out straight away so the user can fix his/her code
p20555
as(dp20556
g15
V34509
p20557
stp20558
a((dp20559
g2
(lp20560
VIt's not possible to define member functions or derive structs from each other in C
p20561
aVAlso, C++ is not only C + "derive structs"
p20562
aVTemplates, references, user defined namespaces and operator overloading all do not exist in C
p20563
as(dp20564
g15
V34509
p20565
stp20566
a((dp20567
g2
(lp20568
VInlining function calls is not something the language requires compilers to do
p20569
aVIt's a quality of implementation issue (QoI)
p20570
aVBut any of GCC, MSVC and clang will do it
p20571
aVOf course, you have to enable optimization
p20572
aVFor instance
p20573
as(dp20574
g15
V34509
p20575
stp20576
a((dp20577
g2
(lp20578
VAll the below said, if you don't need an operator to be a friend, then don't make it a friend
p20579
aVFor output operators in particular, in my opinion you should not make them friends
p20580
aVThat is because if your class can be output to a stream, it should have equivalent  functions that provide the same data programmatically
p20581
aVAnd in that event, you can write a  as a non-friend in terms of those  functions
p20582
aVIn case you have some good reason for making them friends, you can do a friend definition
p20583
aVThat way you don't need the  clause that gets you the type
p20584
aVIt's alreay known if you define the operator inside the template
p20585
aVNote that even though you defined it inside the template, it's not a member function
p20586
aVIt's still a non-member, but has access to the names declared in the class (like the template parameter)
p20587
aVFor each instance of  you create, a different non-template operator function is created out of that friend function that prints things
p20588
aVIf you want to define the template outside, you have to predeclare it to be able to declare a given specialization of it as a friend
p20589
aVThat makes  a friend of
p20590
aVIf you were to omit the  or an also possible empty , the compiler would understand that as saying you made a non-template operator having concrete instead of templated parameters as friend
p20591
aVThe more easy but less "correct" solution is to make  have as friend all the  instantiations
p20592
aVSo theoretically  could access private members of
p20593
aVIt's not what is wanted, but it works too, gaining more access than needed
p20594
aVIt gets rid of the need for forward declaring:
p20595
as(dp20596
g15
V34509
p20597
stp20598
a((dp20599
g2
(lp20600
VYour suspicion is correct
p20601
aVThe compiler doesn't know what  is
p20602
aVIt can't deduce it from the arguments
p20603
aVSuch forms often are too loose to provide the needed informations
p20604
aVConsider
p20605
aVIf you were to pass an , then any of  would fit the bill because all of them have type
p20606
aVIn the specific case of nested classes, it may be possible, but even then it's not unique
p20607
aVImagine that in  you could put a , then both  and  would fit the bill
p20608
aVBack in pre-standard time, there existed a list of template-issues that in particular John Spicer did go through and invented reasonable solutions
p20609
aVThat was one such problem, and it was found that it's not worth the trouble
p20610
aVYou always explicitly need to provide the argument - it's never deduced
p20611
aVYou could change your code to this
p20612
aVOr to this
p20613
as(dp20614
g15
V34509
p20615
stp20616
a((dp20617
g2
(lp20618
VI think you are getting it right: GCC implements the standard to the letter in this case, while the others implement it less strict (have a look at issue #355)
p20619
aVYou could do the following to work-around the limitation of the syntax
p20620
aVOr you use an explicit named
p20621
aVOr, of course, you exchange the order of  and the nested class definition
p20622
aVNotice that Annex A is informative only
p20623
aVThe normative text is at clauses  and
p20624
as(dp20625
g15
V34509
p20626
stp20627
a((dp20628
g2
(lp20629
VYou could also use
p20630
as(dp20631
g15
V34509
p20632
stp20633
a((dp20634
g2
(lp20635
VIt doesn't, because 's constructor parameter is a non-const reference, but you provide a temporary
p20636
aVYou cannot provide temporaries (that are rvalues) to non-const references
p20637
aVBut aside, even if it would take a const reference, it would still not work, because  is not copyable
p20638
aVCuriously, C++ requires an accessible copy constructor to bind an rvalue to a non-const reference
p20639
as(dp20640
g15
V34509
p20641
stp20642
a((dp20643
g2
(lp20644
VThere is nothing special about null characters in strings
p20645
aVOf course if you do
p20646
aVIt will interpret that as a C-style string converted to , and thus will stop at the , not taking it as a real content byte
p20647
aVTelling  the size explicitly allows it to consume any null byte as real content data
p20648
aVIf you want to read directly from a char array, you can use
p20649
aVThat will directly read from the data provided by , up to  bytes
p20650
aVis declared "deprecated" officially, but it's still going to be in C++0x, so you can use it
p20651
aVOr you create your own , if you really need to read from a raw  like that
p20652
as(dp20653
g15
V34509
p20654
stp20655
a((dp20656
g2
(lp20657
VIt's not possible
p20658
aVThe Standard also has a note on this at
p20659
aV[Note: because the explicit template argument list follows the function template name, and because conversion member function templates and constructor member function templates are called without using a function name, there is no way to provide an explicit template argument list for these function templates
p20660
ag4885
aVIf you can live with it, you can work it around
p20661
aVGiven  like it's defined in boost
p20662
as(dp20663
g15
V34509
p20664
stp20665
a((dp20666
g2
(lp20667
VOthers reported the code compiles fine
p20668
aVI want to supply the Standard wording for backing it up
p20669
aVAt
p20670
aVAll access controls in clause 11 affect the ability to access a class member name from a particular scope
p20671
aVThe access control for names used in the definition of a class member that appears outside of the member\u2019s class definition is done as if the entire member definition appeared in the scope of the member\u2019s class
p20672
aV[Example:
p20673
aVHere, all the uses of  are well-formed because  and  are members of class A and g is a friend of class A
p20674
aVThis implies, for example, that access checking on the first use of  must be deferred until it is determined that this use of  is as the return type of a member of class A
p20675
ag4885
as(dp20676
g15
V34509
p20677
stp20678
a((dp20679
g2
(lp20680
VIt's is the same in terms of efficiency
p20681
aVIt's not the same in terms of readability
p20682
aVThe second is better in this aspect, isn't it
p20683
aVIt's a semantic difference which the code keeps hidden because it's not making a difference for int, but it makes a difference to the human reader
p20684
aVDo you want to carry the value of whatever calculation you do in  outside of the loop
p20685
aVYou don't, so you should write code that reflects your intention
p20686
aVA human reader will need to seek the function and look for other uses of  to confirm himself that what you did was just premature "optimization" and didn't have any deeper purpose
p20687
aVAssuming it makes a difference for the type you use, you can help the human reader by commenting your code
p20688
as(dp20689
g15
V34509
p20690
stp20691
a((dp20692
g2
(lp20693
VLike @Steward suspected, it's not valid
p20694
aVFormally it's effectively causing undefined behavior, because the Standard rules that for a violation no diagnostic is required, which means the implementation can silently do anything it wants
p20695
aVAt
p20696
aVIf a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required
p20697
aVIn practice at least on GCC, it's implicitly instantiating the primary template  since the specialization wasn't declared and is not visible in , and then calling
p20698
aVIf its definition is visible, it instatiates the primary definition of the member function (which is why when it is defined, it wouldn't work)
p20699
aVInstantiated function name symbols have weak linkage because they could possibly be present multiple times in different object files, and have to be merged into one symbol in the final program
p20700
aVContrary, members of explicit specializations that aren't templates anymore have strong linkage so they will dominate weak linkage symbols and make the call end up in the specialization
p20701
aVAll this is implementation detail, and the Standard has no such notion of weak/strong linkage
p20702
aVYou have to declare the specialization prior to creating the  object:
p20703
aVThe Standard lays it bare (emphasize by me)
p20704
aVThe placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member function templates of member classes of class templates, etc
p20705
aV, and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc
p20706
aV, can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below
p20707
aVWhen writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation
p20708
as(dp20709
g15
V34509
p20710
stp20711
a((dp20712
g2
(lp20713
VI think this should work:
p20714
aV, , , , ,  (and, i think  too) are members of
p20715
aVBut honestly, i would refuse to work with such code, personally :)
p20716
as(dp20717
g15
V34509
p20718
stp20719
a((dp20720
g2
(lp20721
VThis declares an explicit default constructor:
p20722
aVIn case there is no parameter, like in the following example, the  is redundant
p20723
aVIn some C++0x draft, i believe it was n3035, it made a difference in the following way:
p20724
aVBut in the FCD, they changed this (though, i suspect that they didn't have this particular reason in mind) in that all three cases value-initialize the respective object
p20725
aVValue-initialization doesn't do the overload-resolution dance and thus won't fail on explicit constructors
p20726
as(dp20727
g15
V34509
p20728
stp20729
a((dp20730
g2
(lp20731
VHopefully it is understood that this is only currently available for POD structures; you'd get a compiler error if there was a C++ std::string in that structure
p20732
aVNo you won't
p20733
aVIf you use  on such, at the best you will just crash, and at the worst you get some gibberish
p20734
aVThe  way can be used perfectly fine on non-POD structs, as long as they are aggregates
p20735
aVThe  way is the best way to take in C++
p20736
aVPlease note that there is no reason in C++ to put that  in it, nor is it recommended, since it drastically reduces the cases in which it can be used
p20737
aVThe first will not do what you want: It will try to create a  from a C-string given a null pointer to its constructor
p20738
aVThe second, however, does what you want: It creates an empty string
p20739
as(dp20740
g15
V34509
p20741
stp20742
a((dp20743
g2
(lp20744
VChange it to this:
p20745
aVI suspect that the  function is defined in the base-class
p20746
aVUnqualified names are not looked up in a base class that depends on a template parameter
p20747
aVSo in this case, the name  is probably associated with the  template which requires template arguments
p20748
aVIf you qualify the name with , the compiler is explicitly told to look into the scope of the class, and includes dependent base classes in that lookup
p20749
as(dp20750
g15
V34509
p20751
stp20752
a((dp20753
g2
(lp20754
VYes you can use the scope-guard technique
p20755
aVThen write a function creating the autolocker
p20756
aVYou can then write it like this:
p20757
aVOnce the const reference goes out of scope, the destructor is called
p20758
aVIt doesn't need to be virtual
p20759
aVAt least GCC optimizes this quite well
p20760
aVSadly, this means you have to make your locker-object copyable since you need to return it from the maker function
p20761
aVBut the old object won't try to unlock twice, because its pointer is set to 0 when it's copied, so it's safe
p20762
as(dp20763
g15
V34509
p20764
stp20765
a((dp20766
g2
(lp20767
VThe name of a typedef does not represent the syntactical construct used to define its type
p20768
aVThe typedef name should convey some of its desired meaning
p20769
aVFor example, the Standard defines the names of iterators over  as , even though the iterator itself is not const (you can still increment it)
p20770
aVIn fact, the whole purpose of an iterator is to change it, in order to iterate over a sequence :)
p20771
aVFor pointers, i personally see little reason to generally typedef them as constant
p20772
aVSo the  in front of the trailing parts could convey the same meaning as the iterators do, and will go with existing practice
p20773
aVSo i think it is perfectly fine for you to go and say
p20774
aVIn fact, this is how  is worded too
p20775
as(dp20776
g15
V34509
p20777
stp20778
a((dp20779
g2
(lp20780
VIt can only know that at runtime
p20781
aVImagine it slightly changed
p20782
aVBut that's not going to happen
p20783
aVC++ puts emphasize in speed, but this would basically make it into a language that ensures safety of operations
p20784
aVThere is Java, C# and others that already solve this
p20785
aVKernel and device driver developers don't want a clever language runtime
p20786
aVThey just want to have things run fast
p20787
aVHave a look at Common undefined behavior in C++ question for all the things that will need to get "fixed" along
p20788
aVIt won't be C++ anymore
p20789
as(dp20790
g15
V34509
p20791
stp20792
a((dp20793
g2
(lp20794
VIf  is the base class, you need to qualify your call with that base class name or alternatively with
p20795
aVBut since both of these depend on the template parameters, the compiler cannot lookup what the name  means
p20796
aVIt could be a static integer constant, which you compare against something else, or it could be a template that you put arguments enclosed in  for
p20797
aVYou need to tell the compiler about the latter
p20798
aVOr with
p20799
aVThe reason for the qualification is that the compiler does not look for unqualified names in base classes that depend on template parameters (in your case the parameter is ), since the binding of the name would depend on whether the base class has such a name or not, which is considered unfortunate
p20800
aVFor a plain name like , there is in addition no indication that this name depends on a template parameter, thus the Standard requires compilers not to delay lookup of the name until instantiation
p20801
aVSo the name, even if lookup in dependent bases would be allowed on instantiation (which isn't), couldn't be found anyway
p20802
aVYou have to explicitly tell the compiler to look in the enclosing class by qualifying it, in which event the compiler will include dependent base classes during lookup when instantiating
p20803
aVPrefixing with  or the class name will also make the name dependent, thus delaying lookup of it until instantiation
p20804
aVThese two facts are required for it to work
p20805
as(dp20806
g15
V34509
p20807
stp20808
a((dp20809
g2
(lp20810
VYou can do that in standard c++
p20811
aVSee Conditional Love for an explanation
p20812
as(dp20813
g15
V34509
p20814
stp20815
a((dp20816
g2
(lp20817
VC doesn't have templates
p20818
aVI think the best you could do is to use an union or to have the functions have different names
p20819
aVThe latter way of having different names is the quasi-standard method of doing it (for instance   , also heavily used by OpenGL which also accounts for the fact C can't overload functions)
p20820
aVIf there is a lot of common code, you may decide to factor it out in separate functions
p20821
aVOr you can take the union way, which will have the function names be equal but instead blow up the parameter type with meta informations
p20822
aVThe union way is particular well-suited if you want to store the value somewhere and then execute the print function without caring what value type you pass to it
p20823
aVIn C89 you would need to create the value separately since it doesn't have compound literals
p20824
aVIt's a good idea to create functions for that, though
p20825
aVSome compilers may provide extensions for writing such things
p20826
aVFor instance Clang provides function overloading in C
p20827
aVThis solves the call-side of the function not to depend on the type
p20828
aVOn the definition side, you still have to write the code twice
p20829
aVThat's mainly because (as another answer explains) C doesn't have type-generic output functions
p20830
aVOf course if you use this feature, your code becomes nonportable
p20831
as(dp20832
g15
V34509
p20833
stp20834
a((dp20835
g2
(lp20836
VThis doesn't work, because  does not participate in deduction
p20837
aVWhile  is a dependent type, during deduction for  it's treated like a fixed type spelled with a nondependent name
p20838
aVYou need to add it to the parameter list of
p20839
aVSo in your case because  does not depend on parameters of  itself, you receive an error while implicitly instantiating  (try to comment out the call, and it should still fail)
p20840
aVThe FCD says at
p20841
aVThe implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the de\ufb01nitions or default arguments, of the class member functions, member classes, static data members and member templates;
p20842
aVThat is, if you implicitly instantiate  the following function template declaration will be instantiated
p20843
aVAnalysis on that template declaration will then find that it can't resolve the reference to  and error out
p20844
aVIf you add , the template declaration will not yet try to resolve the reference to  (since  is a parameter of ), and will thus remain valid and SFINAE when  is tried to be called
p20845
as(dp20846
g15
V34509
p20847
stp20848
a((dp20849
g2
(lp20850
VIn C++, accessibility to class members doesn't influence the other language semantics
p20851
aVInstead, any invalid access causes a program to be ill-formed
p20852
aVIn other words, there is accessibility and visibility
p20853
aVThe Standard has it straight
p20854
aVIt should be noted that it is access to members and base classes that is controlled, not their visibility
p20855
aVNames of members are still visible, and implicit conversions to base classes are still considered, when those members and base classes are inaccessible
p20856
aVThe interpretation of a given construct is established without regard to access control
p20857
aVIf the interpretation established makes use of inaccessible member names or base classes, the construct is ill-formed
p20858
as(dp20859
g15
V34509
p20860
stp20861
a((dp20862
g2
(lp20863
VThe following has been valid in C89
p20864
aVBut in modern C (C99), this isn't allowed anymore because you need to explicitly tell the type of variables and return type of functions, so it becomes
p20865
aVAlso, it's legal to omit the  in modern C, so it is legal to write
p20866
aVAnd the behavior is as if it returned 0
p20867
aVPeople put  between the parentheses because it ensures proper typechecking for function calls
p20868
aVAn empty set of parentheses in C mean that no information about the amount and type of the parameters are exposed outside of the function, and the caller has to exactly know these
p20869
aVThe call to  causes undefined behavior, because the compiler can't verify the type of the argument against what  expects in the other modules
p20870
aVIf you were to write it with  or with , the compiler would know
p20871
aVSo for  it's just a good habit to put  there since it's good to do it elsewhere
p20872
aVIn C you are allowed to recursively call  in which case such differences may even matter
p20873
aVSadly, only a few compilers support modern C, so on many C compilers you may still get warnings for using modern C features
p20874
aVAlso, you may see programs to declare  to return different things than
p20875
aVSuch programs can do that if they use a freestanding C implementation
p20876
aVSuch C implementations do not impose any restrictions on  since they don't even know or require such a function in the first place
p20877
aVBut to have a common and portable interface to the program's entry point, the C specification requires strictly conforming programs to declare main with return type , and require hosted C implementations to accept such programs
p20878
as(dp20879
g15
V34509
p20880
stp20881
a((dp20882
g2
(lp20883
VIt's a GCC statement expression
p20884
aVIt executes the statements in it, and returns the value evaluated in the last statement
p20885
aVThus  is initialized to
p20886
aVIf you delete the second part, there is no expression as the last statement, so it can't get a value from the statement expression
p20887
aVThe braces are necessary to disambiguate it from ordinary C parenthesized expressions
p20888
as(dp20889
g15
V34509
p20890
stp20891
a((dp20892
g2
(lp20893
VHow is it supposed to know what  is from outside the function
p20894
aV(It can't look into the body, because in which body of which function it looks depends on what value  gets
p20895
aVAlso you cannot write that  because both your branches yield totally unrelated types that can't possibly get to a common type
p20896
aVBut that operator requires to have a common type for both branches that it evaluates to
p20897
aVAnd then the other problem you have that  is not a compile time constant is already elaborated by another post
p20898
aVI think this should work:
p20899
aVNow when calling it,  and  are deduced by the parameters, and then the parameters are substituted into the return type
p20900
aVThe  will test whether  or  is greater
p20901
aVIn the respective template that evaluates this to  (which yields 1) we will multiply by the value that is greater (or equal)
p20902
aVIf the respective template yields  this is a deduction failure (an array can't be of zero size
p20903
aVand the template won't get selected by overload resolution (known as SFINAE)
p20904
aVThe unary  yields  or  as int instead of  or , which could cause compiler warnings for some compilers
p20905
aVThere is also the "clean" way with
p20906
aVIt's not doing hideous  tricks, but rather using the general established enable_if pattern
p20907
aVBoost has an implementation of it
p20908
aVThis may at first sight look more noisy, but should be easier to understand and faster to follow to folks that are already used to  (the  variant of boost's implementation accepts plain booleans, as above)
p20909
as(dp20910
g15
V34509
p20911
stp20912
a((dp20913
g2
(lp20914
VIf they are related
p20915
aVLet's for a moment assume that  is actually a base of
p20916
aVThen for the call to , both versions are viable because  can be converted to  and
p20917
aVIt's a user defined conversion sequence as described by  from  to  and  respectively
p20918
aVFor finding conversion functions that can convert the class, the following candidate functions are synthesized for the first  function according to
p20919
aVThe first conversion function isn't a candidate, because  can't be converted to
p20920
aVFor the second function, the following candidates exist:
p20921
aVThose are the two conversion function candidates that take the host object
p20922
aVThe first takes it by const reference, and the second doesn't
p20923
aVThus the second is a better match for the non-const  object (the implied object argument) by  and is used to convert to  for the second  function
p20924
aVIf you would remove the const, we would have the following candidates
p20925
aVThis would mean that we can't select by constness anymore
p20926
aVIn an ordinary overload resolution scenario, the call would now be ambiguous because normally the return type won't participate in overload resolution
p20927
aVFor conversion functions, however, there is a backdoor
p20928
aVIf two conversion functions are equally good, then the return type of them decides who is best according to
p20929
aVThus, if you would remove the const, then the first would be taken, because  converts better to  than  to
p20930
aVNow what user defined conversion sequence is better
p20931
aVThe one for the second or the first check function
p20932
aVThe rule is that user defined conversion sequences can only be compared if they use the same conversion function or constructor according to
p20933
aVThis is exactly the case here: Both use the second conversion function
p20934
aVNotice that thus the const is important because it forces the compiler to take the second conversion function
p20935
aVSince we can compare them - which one is better
p20936
aVThe rule is that the better conversion from the return type of the conversion function to the destination type wins (again by )
p20937
aVIn this case,  converts better to  than to
p20938
aVThus the first function is selected and we recognize the inheritance
p20939
aVNotice that since we never needed to actually convert to a base class, we can thereby recognize private inheritance because whether we can convert from a  to a  isn't dependent on the form of inheritance according to
p20940
aVIf they are not related
p20941
aVNow let's assume they are not related by inheritance
p20942
aVThus for the first function we have the following candidates
p20943
aVAnd for the second we now have another set
p20944
aVSince we cannot convert  to  if we haven't got a inheritance relationship, we now have no common conversion function among the two user defined conversion sequences
p20945
aVThus, we would be ambiguous if not for the fact that the first function is a template
p20946
aVTemplates are second choice when there is a non-template function that is equally good according to
p20947
aVThus, we select the non-template function (second one) and we recognize that there is no inheritance between  and
p20948
as(dp20949
g15
V34509
p20950
stp20951
a((dp20952
g2
(lp20953
VNonstandard Behavior
p20954
aVShort summary
p20955
aVCompiler Limits
p20956
aV10
p20957
aV3 (Paragraph 5) Covariant Return Types
p20958
aV14 export Keyword on a Template
p20959
aV14
p20960
ag488
aV2 Dependent Names
p20961
aV15
p20962
aV4 Function Exception Specifiers
p20963
aV16
p20964
ag1037
aV2 The # Operator
p20965
aV21
p20966
ag2790
aV1 Character Traits Requirements
p20967
aVStorage Location of Objects
p20968
as(dp20969
g15
V34509
p20970
stp20971
a((dp20972
g2
(lp20973
VBecause  requires a binary function object
p20974
aVHowever you pass an unary function object
p20975
aVThe function object binders of C++03 aren't as sophisticated as the one found in boost or tr1
p20976
aVIn fact, they suffer from basic problems like not being able to handle functions with reference parameters
p20977
aVSince you already use boost, i recommend to use
p20978
as(dp20979
g15
V34509
p20980
stp20981
a((dp20982
g2
(lp20983
VI've written a class with const data members, and I never intended on using assignment on it, but apparently I need assignment to put it in a vector
p20984
aVIs there a way around this that still preserves const-correctness
p20985
aVYou have to ask whether the following constraint still holds
p20986
aVIf this constraint is not true for  and  being of type  (you have to define the semantics of what "equivalent" means
p20987
aV, then you just cannot put  into a Standard container
p20988
aVFor example,  cannot be put into Standard containers because it violates that requirement
p20989
aVIf you can say about your type that it satisfies this constraint (for example if the const member does not in any way participate to the value of your object, but then consider making it a static data member anyway), then you can write your own assignment operator
p20990
aVBut think twice
p20991
aVTo me, it looks like that your type does not satisfy the constraint
p20992
as(dp20993
g15
V34509
p20994
stp20995
a((dp20996
g2
(lp20997
VThere is no way for the compiler to deduce  from the function arguments
p20998
aVYou need to pass this argument explicitly
p20999
aVChange the order of the parameters to make this possible
p21000
aVThen you can call it with
p21001
aVIt's more difficult if you want to deduce  to the actual result of the addition
p21002
aVC++0x (next C++ version's codename) will allow to do this by saying that the return type is equal to the type of the addition the following way
p21003
aVThen you could cast explictly at the point of use
p21004
aVSimulate this in the current C++ version isn't going to be easy
p21005
aVYou can use my promote template to do that
p21006
aVIf you feel that this rather confuses the matter for you and that you are OK with explictly providing the return type, i think it's better to stay with explicitly providing it
p21007
aVLike Herb Sutter says "Write What You Know, and Know What You Write"
p21008
aVNontheless you can do the above like this with that template
p21009
as(dp21010
g15
V34509
p21011
stp21012
a((dp21013
g2
(lp21014
VVariables are named objects
p21015
aVThe following create objects that are not variables
p21016
aVThe following creates one array variable with name "foo" and 5 unnamed (sub-) objects of type "int"
p21017
aVThe following is not a variable in C++03, but has become a variable in C++0x (declared references are variables in C++0x, for details see the link)
p21018
aVDoes a variable give a name to an object, i
p21019
ag1992
aVare variables just a naming mechanism for otherwise anonymous objects
p21020
aVVariables are objects (or references respectively)
p21021
aVThe entity list ( in C++03) of C++ contains multiple such is-a relationships
p21022
aVFor instance, a sub-object is-a object and an array element is-a object and a class-member is-a object or function or type or template or enumerator
p21023
aVThe entity list of C++0x looks a bit cleaner to me, and it doesn't contain "variables", "instance of a function" (what that kind of entity even is has never been apparent to me), "sub-object" and "array element" anymore
p21024
aVInstead it added "template specialization" which either are functions, classes or templates (partial specializations)
p21025
aVThe C++ object model at  says
p21026
aVAn object can have a name (clause 3)
p21027
aVSo if you like, you can formulate the statement as "The object's name denotes the object
p21028
as(dp21029
g15
V34509
p21030
stp21031
a((dp21032
g2
(lp21033
VThis is why several classes in the Standard library can be implemented
p21034
aVConsider for example
p21035
aVIf you do   you exactly assign some value to an rvalue of class type
p21036
aVThe proxy that's returned by  can access the bits which are space efficiently packed into integers
p21037
as(dp21038
g15
V34509
p21039
stp21040
a((dp21041
g2
(lp21042
VThe Standard has such a class template and it is called  (N for the number of bits/flags)
p21043
aVThe actual object of this class could be named according its purpose then, like  or something
p21044
as(dp21045
g15
V34509
p21046
stp21047
a((dp21048
g2
(lp21049
VI have tested the code on Clang, GCC and Comeau
p21050
aVComeau rejects it while GCC and Clang accept it
p21051
aVI think that for both groups of compilers there can be made points
p21052
aVComeau follows the C++03 rule, which requires an "exact match (so the deduction does not rely on implicit conversions)" for the deduced template arguments
p21053
aVHowever this specification was horribly underspecified and has been completely rewritten for C++0x
p21054
aVClang and GCC seem to implement the rewritten rule, and this rule better specifies what "exact match" means
p21055
aVThis specification goes fine with the different types of the array dimensions
p21056
aVIn any case, if you want to go fine with all compilers, then really go by the accepted answer and change the non-type parameter types to a common type :)
p21057
as(dp21058
g15
V34509
p21059
stp21060
a((dp21061
g2
(lp21062
VSince your  already contains the pointer declarator, you don't need to specify it at the point of use
p21063
aVDrop the :
p21064
aVOr write
p21065
as(dp21066
g15
V34509
p21067
stp21068
a((dp21069
g2
(lp21070
VI would use an assertion if null pointers are not allowed
p21071
aVIf you throw an exception for null pointers, you effectively allow them as arguments, because you specify behavior for such arguments
p21072
aVIf you don't allow null pointers but you still get them, then some code around definitely has a bug
p21073
aVSo in my opinion it does not make sense to "handle" it at some higher levels
p21074
aVEither you want to allow callers to pass null pointers and handle this case by throwing an exception and let the caller react properly (or let the exception propagate, as the caller wishes), or you don't allow null pointers and  them, possibly crashing in release mode (undefined behavior) or use a designated assertion macro that is still active in release mode
p21075
aVThe latter philosophy is taken by functions such as , while the former philosophy is taken by functions such as
p21076
aVThe latter function explicitly dictates the behavior for out-of-bound values, while the former simply declares behavior undefined for a null pointer being passed
p21077
aVIn the end, how would you "handle" null pointers anyway
p21078
aVThat's plain ugly, in my opinion
p21079
aVIf you assert in the function that pointers are null, such code becomes
p21080
aVI think this is far superior, as it doesn't use exceptions for control flow (supplying a non-NULL source as argument)
p21081
aVIf you don't handle the exception, then you could aswell fail already with an assertion in , which will directly point you to the file and line number the crash occurred at (and with a debugger, you can actually get a stack trace)
p21082
aVIn my applications, i always take the  route
p21083
aVMy philosophy is that null pointer arguments should be handled completely by non-exceptional paths, or asserted to be non-NULL
p21084
as(dp21085
g15
V34509
p21086
stp21087
a((dp21088
g2
(lp21089
VI've no idea what you mean
p21090
aVTemplate template parameters seem the solution, although you somehow say they won't work
p21091
aVWhy not do this
p21092
aVFor your SFINAE question, yes that is possible too
p21093
aVStill i'm not sure what you mean at all
p21094
as(dp21095
g15
V34509
p21096
stp21097
a((dp21098
g2
(lp21099
VLambdas without a capture are implicitly convertible to a pointer to function (by a non-explicit conversion function defined by the closure type)
p21100
aVThe FCD does not seem to specify what language linkage the function type of that function pointer type has, so if you need to pass this function pointer to C functions, the calling convention of C++ functions and C functions need to be the same
p21101
aVI believe that on Windows, that is the case though
p21102
aVSo you should be able to pass the lambda to Windows API functions
p21103
aVFCD wording at :
p21104
aVThe closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator
p21105
aVThe value returned by this conversion function shall be the address of a function that, when invoked, has the same e\ufb00ect as invoking the closure type\u2019s function call operator
p21106
aVI think the final Standard should have a note that says that there is a conversion function to both C linkage function pointers and C++ linkage function pointers, as convertibility to C function pointers is one of the goal of this functionality
p21107
as(dp21108
g15
V34509
p21109
stp21110
a((dp21111
g2
(lp21112
VYou need  and , where  is the number of template arguments your template takes
p21113
aVAlternatively if you implement  as a metafunction class, you don't need to
p21114
aVExample of a metafunction class yielding the first of two given types:
p21115
aVThen you can use  as a metafunction class that takes a sequence
p21116
aVOr if you have it as a template, you need to quote it first
p21117
aVHope it helps
p21118
as(dp21119
g15
V34509
p21120
stp21121
a((dp21122
g2
(lp21123
VYour  does not participate in deduction for
p21124
aVSee this answer for a deeper explanation of why your code fails
p21125
aVYou can resolve it like this:
p21126
as(dp21127
g15
V34509
p21128
stp21129
a((dp21130
g2
(lp21131
VYour declaration declares this function:
p21132
aVThe parentheses in your code around  are ignored
p21133
aVThey are like the parentheses around  in the following example
p21134
aVThey are for grouping modifiers like pointer () or references () (think about )
p21135
aVIn your case the parentheses are just semantically redundant
p21136
aVTry this one instead:
p21137
aVThe parentheses introduced make the compiler regognize that it should instead construct an object  initialized from an expression (because a function parameter declaration can't have parentheses around it, it's not parsed as a parameter declaration, but instead as an initializer)
p21138
as(dp21139
g15
V34509
p21140
stp21141
a((dp21142
g2
(lp21143
VPeople's opinion differ on this
p21144
aVI know some perfectly capable developers who write that const for any parameter that should not be changed locally in the function
p21145
aVLogically that is just consequent application of the const-correctness principle
p21146
aVWhatever you do, however, you should omit the const in the function declaration in the header
p21147
aVThe  should be part only in the function definition
p21148
aVC (and C++, too) has rules that make this compatible (i
p21149
aVe a  for a value parameter is ignored (when it affects the parameter only at its toplevel) for pure function declarations that don't have a body)
p21150
aVThe rationale is that such a  will not change anything with regard to the caller, and is thus an implementation detail of the called function
p21151
aVThis does not hold for your first parameter
p21152
aVAny capable developer i know will put that const there, because it's making an important guarantee to the caller of your function (that it won't change the data pointed to of what is passed in)
p21153
aVThe name of your parameter, however, seems a bit odd, because it indicates that the function does need to write into what is pointed to
p21154
aVNotice that to be consequent, you would have to make the first parameter itself const too, like you did with the second parameter
p21155
aVThus this would become (renaming it to "source" too, to avoid confusion)
p21156
as(dp21157
g15
V34509
p21158
stp21159
a((dp21160
g2
(lp21161
VThis all looks like you forgot to include the  header
p21162
aVSince its parser doesn't interpret  as a type if it doesn't know it is one, it comes up with an own type, and ignores , i think
p21163
aVThe type it comes up with is
p21164
aVNotice that your code leaks because you need to call  on any 'ed object
p21165
aVThere is nothing wrong with creating objects like this:
p21166
aVIn this case you are free'd of memory management
p21167
as(dp21168
g15
V34509
p21169
stp21170
a((dp21171
g2
(lp21172
VThere is no way for you to know
p21173
aVYou could write a class that tightly interacts with  and that creates a constant string pointing to an external buffer (by making the corresponding constructor private and making the interacting class a nested class or a friend of )
p21174
aVIf all you worry about is doing dynamic memory management on a potentially small constant string, you can implement the Small String Optimization (also Small Object/Buffer Optimization)
p21175
aVIt works by having an embedded buffer in your string class, and copying each string up to some predefined size into that buffer, and each string that's larger to a dynamically allocated storage (the same technique is used by  for storing small sized function objects)
p21176
aVThere are clever techniques for storing even the length of the embedded string into the buffer itself (storing its length as  and similar trickeries)
p21177
as(dp21178
g15
V34509
p21179
stp21180
a((dp21181
g2
(lp21182
VYou can declare the conversion function as friend
p21183
as(dp21184
g15
V34509
p21185
stp21186
a((dp21187
g2
(lp21188
VYes, Standard says
p21189
aVReferences, pointers, and iterators referring to the elements of a  sequence may be invalidated
p21190
aVby the following uses of that  object:
p21191
aVCalling non-const member functions, except , , , , , and
p21192
as(dp21193
g15
V34509
p21194
stp21195
a((dp21196
g2
(lp21197
VIf  is an int, then the first isn't viable
p21198
aVLast two remain
p21199
aVThen, for deduction of , the second and the third both yield the same function types for overload resolution (both  as parameter)
p21200
aVSo you have to rely on partial ordering
p21201
aVHowever, partial ordering can't tell them apart
p21202
aVFor a function call partial ordering context, only the parameters are used to determine an order (and the return type in your example is not considered), and any reference modifier is peeled off from them
p21203
aVSo you will succeed deducing the parameter type from one against the other in both direction - both parameter types will be at least as specialized as the other parameters respectively
p21204
aVAnd neither has const applied, so neither is more specialized than the other
p21205
aVThere is an issue report placeholder that aims at clarifying anything related to rvalue/lvalue reference difficulties during partial ordering
p21206
aVSee this usenet question for details
p21207
aVIf any of the two should be more specialized, i would say that it should the first one
p21208
aVAfter all, it accepts less arguments than the other one (the other one being a potential perfect forwarder)
p21209
aVEspecially since the T1&& won't bind to an lvalue unless I explicitly forward/move it
p21210
aVActually, it will accept anything
p21211
aVHaving a parameter of type  in a template will switch to the "perfect-forwarding-deduction-mode", which will deduce  to the type of the argument if it's an rvalue, and add a lvalue-reference modifier to the type of  if it's an lvalue
p21212
aVSo if the argument is an lvalue, the resulting parameter type is  collapsed to , which accepts lvalues fine (just like in your case)
p21213
aVOn a second look, what you seem to be trying to do is to overload a function for taking objects by moving them
p21214
aVBut this won't work because of the special deduction done for  (see below)
p21215
aVJust erase the first function and write your code as
p21216
aVThis will move-construct  if the argument was an rvalue, and copy  if the argument was an lvalue or if  doesn't have a move constructor
p21217
aVThis is just an illustration, it may not be what you actually should do depending on your real use-case
p21218
aVI'm also not sure why you have two template parameter types here
p21219
aVI propose to get rid of the , and say  for the return type, instead
p21220
aVSo that you can gain from argument deduction
p21221
as(dp21222
g15
V34509
p21223
stp21224
a((dp21225
g2
(lp21226
VOne of them need to get around not to include it
p21227
aVFor many cases this is possible such that you can move the #include into the
p21228
aVcpp file
p21229
aVGenerally for the function declarations whose definitions are in the
p21230
aVcpp files, you don't need any #includes in the header
p21231
aVFor class members you only need headers if you want to have them as value objects embedded
p21232
aVYou need to change those to pointers (or smart-pointers) and  them within the
p21233
aVcpp file in that case
p21234
aVFor the compiler to know what  is in my above example, you just need to put a forward declaration before the definition of  like this:
p21235
as(dp21236
g15
V34509
p21237
stp21238
a((dp21239
g2
(lp21240
VBecause  returns a non-const value
p21241
aVOnly objects can be const, because they store some state that could be modified if it weren't const
p21242
aVWhat you return there is not an object, but a pure value
p21243
aVConceptually, they are not modifiable (like enumeration constants, for example), but they are not const qualified (like, again, enumeration constants)
p21244
as(dp21245
g15
V34509
p21246
stp21247
a((dp21248
g2
(lp21249
VYes, i agree with you
p21250
aVThis should be fixed in my opinion, and several people i deeply pay respect to have risen the exact same question about this
p21251
as(dp21252
g15
V34509
p21253
stp21254
a((dp21255
g2
(lp21256
VTo answer your addition - your specialization argument passes the member typedef and expects it to yield  as type
p21257
aVThere is nothing magic about this - it just uses a default argument
p21258
aVLet's see how it works
p21259
aVIf you say , the compiler uses the default argument of , which is , and the type name becomes
p21260
aVNow, the compiler checks whether any partial specialization matches
p21261
aVYour partial specialization's argument list  is deduced from the original argument list
p21262
aVThis will deduce  to  and afterwards substitutes that  into the second argument of the specialization, yielding a final result of  for your partial specialization
p21263
aVThat doesn't, however, match the original argument list  at all
p21264
aVYou need a way to yield the  type, as in the following:
p21265
aVNow this will work like you expect
p21266
aVUsing MPL, you can use  instead of
p21267
as(dp21268
g15
V34509
p21269
stp21270
a((dp21271
g2
(lp21272
VIn C++ there is no reason to not use it
p21273
aVIn C, i only use  for this task, without any  or something like that
p21274
aVVariable-names like  are clear enough to indicate what's going on, in my opinion
p21275
aVOf course, there is nothing wrong with defining your own bool or using the ones of
p21276
as(dp21277
g15
V34509
p21278
stp21279
a((dp21280
g2
(lp21281
VThe second code snippet shows a way to change the order of the type and the const without making anything different: The order is irrelevant
p21282
aVIn the first code snippet, the third variable's "const" signifies that you cannot change the object pointed to using that pointer
p21283
aVIn the same code snippet the last variable's other const signifies that you cannot reseat the pointer to point to another object afterwards
p21284
aVIt's, for that matter, a constant variable and a pointer that doesn't allow changing the object pointed to
p21285
aVTo illustrate the matter of the second code snippet using variables of the first code snippet - you may change the order of the type and the "const" in the first code snippet for the third and next variable without making anything different:
p21286
as(dp21287
g15
V34509
p21288
stp21289
a((dp21290
g2
(lp21291
VThe question about the code is this: it fails if I declare function int *bar as a parameter of foo, but not int (*bar)
p21292
aVWhy
p21293
aVBecause you would declare the function pointer as a pointer to a function returning
p21294
aVNotice that in parameter lists there is no difference between a function and a function pointer declaration, neither there is a difference in them between an array and a pointer declaration:
p21295
aVThese are equivalent - the first two have their parameters have function pointer types, and the second two have their parameters have pointer type
p21296
aVThe star and the parentheses are written because it is consistent with its meaning outside of parameter lists where of course a function pointer and a function are different things
p21297
aVWhy, in lSearch, is the function called cmpFn, but defined as intCmp, which is of type int, not int* and still works
p21298
aVThe star signifies that it's a pointer to a function
p21299
aVThe star doesn't attach to the return type (that's why the paren is there in the first place - to have the binding to the function instead of to the return type)
p21300
aVAnd why does the function in lSearch not have to have defined parameters
p21301
aVThe function pointer's parameter types are all what matters
p21302
aVYou may give them names, but the names are ignored
p21303
as(dp21304
g15
V34509
p21305
stp21306
a((dp21307
g2
(lp21308
VThe add operator should generally be a free function to avoid preferring any operand type as @Stephen nicely explains
p21309
aVThis way it's completely symmetric
p21310
aVAssuming you have a function  that returns the stored value, this can be like the following (alternatively, you can declare it as a friend if such a  function does not exist)
p21311
aVThe problem now is to find a result type
p21312
aVAs other answers show this is possible with  in C++0x
p21313
aVYou can also simulate this by using the rules of the  operator which are mostly quite intuitive
p21314
aVpromote<> is a template that uses that technique
p21315
aVNow for example if you add  and , it will yield  as the result
p21316
aVAlternatively as shown in the  answer, you can also specialize  so you can apply it directly to  types
p21317
as(dp21318
g15
V34509
p21319
stp21320
a((dp21321
g2
(lp21322
VIf you don't mind some undefined behavior, you can do it like this in C++:
p21323
aVThis works fine with GCC and Clang
p21324
aVIt works by calling  on the buffer in
p21325
aVThat buffer is kept wrapped in a class because it can be an array, and arrays can only be copied if they are wrapped in a class
p21326
aV's constructor then takes 's return value and initializes  with it
p21327
aVIn 's destructor that flag is tested and if it's false (first return of ), it jumps back and let  return a non-zero value
p21328
aVThe destructor of  is called when one of the branches finish
p21329
aVThe compiler is free to copy the  object constructed in initializing
p21330
aVIf that happens, the copy constructor of it cares about setting  to , ensuring that we jump back only one time even if the compiler didn't optimize out the  copy during initialization
p21331
aVThus the program prints
p21332
as(dp21333
g15
V34509
p21334
stp21335
a((dp21336
g2
(lp21337
VThis is a known issue in the Standard
p21338
aVAlso see this usenet discussion on the topic
p21339
as(dp21340
g15
V34509
p21341
stp21342
a((dp21343
g2
(lp21344
VVery common problem
p21345
aVOne way to solve it is through overloading
p21346
as(dp21347
g15
V34509
p21348
stp21349
a((dp21350
g2
(lp21351
VI don't think that warning is intentional
p21352
aVThe compiler mistakenly belives that the function is local to the translation unit, but the function isn't such at all
p21353
aVYou use the generated function in the other translation unit from , thus the function is used
p21354
aVThe different ways you figured out to make the warning disappear just seem to be different ways to work around the buggy path in the compiler
p21355
aVThe difference with regard to  is that  functions can be instantiated even without a use of them
p21356
aVThis happens when their class was implicitly instantiated usually
p21357
aVThe Standard declares that valid (emphasis by me)
p21358
aVAn implementation shall not implicitly instantiate a function template, a member template, a non-virtual
p21359
aVmember function, a member class or a static data member of a class template that does not require instantiation
p21360
aVIt is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated
p21361
aVIn this case there are two implicit instantiations of that same virtual function
p21362
aVThe one in  was done without any use, and thus the compiler thinks the function is useless
p21363
aVBut as that same function is used elsewhere (in ), that warning is clearly at odds
p21364
as(dp21365
g15
V34509
p21366
stp21367
a((dp21368
g2
(lp21369
VAnother way to solve it is by delegating to a private function and overloading that function
p21370
aVThis way you still have access to member data of  and to the outer template parameter type
p21371
as(dp21372
g15
V34509
p21373
stp21374
a((dp21375
g2
(lp21376
VNotice that there are code snippet that are valid for both the keyword added and not added, yielding different results in each case, even for templates that take type parameters instead of integers
p21377
aVThis outputs  when run without the  keyword added
p21378
aVIf you add the keyword before  it outputs
p21379
aVExplanation
p21380
aVThe version without the keyword parses as
p21381
aVAnd the version with the keyword parses as
p21382
aVNotice that  is a null pointer (produced by )
p21383
aVWhole different parses, and both are valid
p21384
aVThis really needs a way to disambiguate - which is to insert the  keyword as appropriate
p21385
as(dp21386
g15
V34509
p21387
stp21388
a((dp21389
g2
(lp21390
VI prefer boost noncopyable over the macro because it's not a macro and it is easier (IMO) to use
p21391
aVIn real code, i'm using neither of them and write the two declarations needed myself
p21392
aVA subtle difference you might be interested in, though, is that using that macro or your own declarations will not give a compiler error when the class itself tries to copy the object (but rather fail to link later on)
p21393
aVhowever will also signal a compiler error in this case, because it's the base-class that has the functions declared private, not the class itself
p21394
as(dp21395
g15
V34509
p21396
stp21397
a((dp21398
g2
(lp21399
VI want to implement that method simply in the header file
p21400
aVThat is much cleaner
p21401
aVSo be it
p21402
aVYou don't even need to write this
p21403
aVThe compiler provides a default constructor itself
p21404
aVThe only thing you need is the destructor because it's not virtual by default
p21405
aVIn case you heard you need to define these in the
p21406
aVcpp file - this is sometimes needed if you have smart pointers in your class as members
p21407
aVA rule of thumb is that when you have smart pointers to in your class, and they point to a class that's just forward declared in the header, always provide constructors and destructors in the
p21408
aVcpp file where you actually define the pointed-to class
p21409
aVOtherwise you can get problems with deletion of incomplete classes (causing undefined behavior in many cases)
p21410
as(dp21411
g15
V34509
p21412
stp21413
a((dp21414
g2
(lp21415
VIt's important for the visibility of class members
p21416
aVYou can only refer to a not yet declared name in a parameter, default argument, function body or constructor initialization list in class (or such things in nested classes)
p21417
aVIn other cases, you can't and you have to arrange declarations such that they are visible
p21418
as(dp21419
g15
V34509
p21420
stp21421
a((dp21422
g2
(lp21423
VAs others explained, C is kept more simple than C++ and doesn't allow const variables to appear in integer constant expressions
p21424
aVBut in both C89 and C++ declared arrays must have compile-time constant sizes
p21425
aVYou can use enumerations for this
p21426
aVIt doesn't have to do with internal linkage - external linkage variables are equally viable in integer constant expressions in C++
p21427
aVThe internal linkage in C++ rather is a consequence, but not a neccessity, of allowing them to appear in constant expressions
p21428
aVThe C++ Standard explains why they have internal linkage by default
p21429
aVBecause const objects can be used as compile-time values in C++, this feature urges programmers to provide explicit initializer values for each const
p21430
aVThis feature allows the user to put const objects in header files that are included in many compilation units
p21431
as(dp21432
g15
V34509
p21433
stp21434
a((dp21435
g2
(lp21436
VYou can change the  interface
p21437
aVThen your function template looks more user-friendly
p21438
aVBut the user doesn't need to care about those arguments - the compiler figures out the template arguments itself if the user passes a proper function argument as in the example
p21439
aVThink of  and
p21440
aVThe latter really looks like the following, with  being
p21441
aVAnd the  printing it to an output stream really accepts such a type, still C++ coders don't need to care about allocators or character traits
p21442
aVProper documentation is there to teach them to use  easily and just pass it around and print it out
p21443
as(dp21444
g15
V34509
p21445
stp21446
a((dp21447
g2
(lp21448
VYou cannot predict it without knowing the compiler and the target platform it compiles to
p21449
as(dp21450
g15
V34509
p21451
stp21452
a((dp21453
g2
(lp21454
VThere are quite a few ways a parameter type can be applicable to the call syntax
p21455
aVType is a pointer or reference to a function type, or
p21456
aVType is a class-type which has a conversion function to one of the types in 1
p21457
aV, or has an applicable operator()
p21458
aVThe current C++ cannot check for 2
p21459
aV, so you are left without checking, like the other answers explain
p21460
as(dp21461
g15
V34509
p21462
stp21463
a((dp21464
g2
(lp21465
VYou are taking the size of a function which cannot be done
p21466
aVYou need to preceede the name with a  to take the size of a pointer to that function
p21467
aVYou also need to cast the  value to be of type , which is what  expects for the  specifier
p21468
aVAs for the concrete values ---- It's not known what they are beyond that are greater or equal to
p21469
aVIt depends on the compiler
p21470
as(dp21471
g15
V34509
p21472
stp21473
a((dp21474
g2
(lp21475
VIf you need to access non-static members from within  you need to bind its  argument properly
p21476
aVThis, however contains a hidden bug
p21477
aVYour object is copyable, and you bind the deleter to the object of
p21478
aVThe handle is associated with the first wrapper you create, but if you copy the wrapper, the handle is shared but associated with the first wrapper, which may not exist anymore:
p21479
aVAfter that code was executed and  is going to be destroyed, behavior is undefined because 's destruction of the internal handle pointer will try to use the object bound in 's constructor invokation - however that object doesn't exist anymore
p21480
aVA solution to this can be to store the data associated with the handle in the allocated object itself, instead of trying to store it in the toplevel handle object, like in the following code
p21481
aVThe auxilary data is not not stored in the handle anymore, but together with the data that's shared among all copy of the wrapper
p21482
aVThe shared data itself is created and destroyed using its normal constructor and destructor
p21483
aVThe last wrapper going out of life will destroy the handle, which is explicitly shared among all wrappers
p21484
as(dp21485
g15
V34509
p21486
stp21487
a((dp21488
g2
(lp21489
VIn C++ you cannot initialize class-members in-place
p21490
aVYou need to do that in the constructor initializer list
p21491
aVThe function needs to be declared as  in the class definition as  calls it without a  pointer, like an ordinary function
p21492
aVPerformance is really unnecessary bad of the comparison function because you always copy the two items to be compared when passing them as arguments
p21493
aVBetter make the comparison function's type to receive const-references and change 's signature appropriately
p21494
as(dp21495
g15
V34509
p21496
stp21497
a((dp21498
g2
(lp21499
VThe  keyword can be put by the function you call
p21500
aVAfter which you can call
p21501
aVIf you like you can inherit the function
p21502
aVThat way you can just use  and not first write it, just like with the macro
p21503
aVUseful if you have a wide range of classes that you use the function in
p21504
aVEdit: Notice that the C-Style cast is required here (can't use ), because of the private inheritance
p21505
aVIt's a safe cast if  is derived from
p21506
aVPersonally i would prefer this over the macro
p21507
aVNotice that your macro can't cope with commas in the type-name
p21508
aVThis tries to pass 3 arguments to the macro instead of 2
p21509
aVYou could reverse the order of the type and the function and use variadic macros (which are a C++0x feature, but available in some compiler in C++03 mode) or you could use a typedef and pass the alias name
p21510
as(dp21511
g15
V34509
p21512
stp21513
a((dp21514
g2
(lp21515
VYour second way will make that no translation unit other than  is allowed to call , because the Standard says that inline functions shall be defined in every translation unit in which they are used
p21516
aVEntirely possible this gets you a link-time error (i've run into this problem before)
p21517
aVAlways define inline functions in the header to avoid this problem
p21518
as(dp21519
g15
V34509
p21520
stp21521
a((dp21522
g2
(lp21523
VYou have to pass the class type of the derived
p21524
aVTo not break the typedef-way, you can can give that parameter a default value
p21525
aVSomething like the following should work
p21526
aVAlternatively you can simply have two classes for this
p21527
aVOne for inheritance and one if you don't inherit
p21528
aVThe first is for inheritance
p21529
aVAnd the second is for non-inheritance
p21530
aVYou can make use of the base-class for this
p21531
as(dp21532
g15
V34509
p21533
stp21534
a((dp21535
g2
(lp21536
VYou forgot the line splice characters
p21537
aVNot sure why you put those newlines though
p21538
aVIt all gets down to
p21539
aVNote that the characters must be the last ones on the line
p21540
aVAnd you cannot put a line comment () before them, because the line comment would extend to the next physical line
p21541
aVUse C Style comments if you still want to comment the lines separately
p21542
as(dp21543
g15
V34509
p21544
stp21545
a((dp21546
g2
(lp21547
VD has it
p21548
as(dp21549
g15
V34509
p21550
stp21551
a((dp21552
g2
(lp21553
VThere is a better way in C++0x for this
p21554
aVIf you declare a perfect-forwarding template, your type will behave badly in overload resolution
p21555
aVImagine your base class is convertible from  and there exist two functions to print out classes
p21556
aVYou call it with
p21557
aVWhat will be called
p21558
aVIt's ambiguous, because  can convert any argument, including character arrays
p21559
aVIt does so without regard of existing base class constructors
p21560
aVInheriting constructors with using declarations only declare the constructors that are needed to make this work
p21561
as(dp21562
g15
V34509
p21563
stp21564
a((dp21565
g2
(lp21566
VYou need the  keyword
p21567
aVGCC is correct to give a diagnostic here
p21568
aVThis is because  cannot be looked up in the dependent scope
p21569
aVThe meaning of the  after it depends on whether  is a template or not
p21570
aVThe Standard says that  shall be assumed to be not a template and thus  cannot be followed by a template argument list
p21571
aVis like  in that it tells the compiler to treat  as a template and that the  is the start of an argument list in any case
p21572
aVThe Standard says in paragraphs  and
p21573
aVFor a template-name to be explicitly qualified by the template arguments, the name must be known to refer
p21574
aVto a template
p21575
aVWhen the name of a member template specialization appears after
p21576
aVor -> in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14
p21577
ag488
aV2), the member template name must be prefixed by the keyword template
p21578
aVOtherwise the name is assumed to name a non-template
p21579
aVIn your case, you have  appear after the nested-name-specifier  which depends on the template-parameter
p21580
aVFor the typename-specifier to parse correctly, the construct  must interpret  as the name of a class template, which  forbids
p21581
aVOn that topic, it's always a good idea to try and compile with Clang
p21582
as(dp21583
g15
V34509
p21584
stp21585
a((dp21586
g2
(lp21587
VThe problem is that  gets one type for the left parameter, and another type for the right one
p21588
aVI suspect you also want to be able to say  - but with that template you couldn't
p21589
aVI recommend to add a separate template parameter to solve this
p21590
as(dp21591
g15
V34509
p21592
stp21593
a((dp21594
g2
(lp21595
VYes, you can overload operators like this
p21596
aVBut I'm not sure what "switch case" you are referring to
p21597
aVYou can live with one overload if you have a converting constructor
p21598
aVNo switch is needed at all
p21599
aVThis is eligible if "MyClass" logically represents a number
p21600
aVNotice that you should overload these operators by non-member functions
p21601
aVIn your code  would not work, because there is no operator that takes an int as left hand side
p21602
aVThe following would work
p21603
aVNow if you keep the converting constructor you can add the int by either side with minimal code overhead
p21604
as(dp21605
g15
V34509
p21606
stp21607
a((dp21608
g2
(lp21609
VAnything goint from int above isn't a promotion anymore
p21610
aVAnything going less than int to int is a promotion (except for rare cases - see below)
p21611
aVSo if you change to the following it becomes non-ambiguous, choosing the first one
p21612
aVNotice that this is only true on platforms where  can store all values of
p21613
aVOn platforms where that is not the case, this won't be a promotion and the call is ambiguous
p21614
aVOn such platforms, the type  will be the promotion target
p21615
aVSort of the same thing happens with floating points
p21616
aVConverting  to  is a promotion, but  to  isn't a promotion
p21617
aVIn this case, C++ differs from C, where  to  is a promotion likewise (however, it doesn't have overloading anyway)
p21618
as(dp21619
g15
V34509
p21620
stp21621
a((dp21622
g2
(lp21623
VThis is discussed on usenet currently
p21624
aVSee Rvalue reference example in 8
p21625
aV5/3 correct or wrong
p21626
aVIt's not legal
p21627
as(dp21628
g15
V34509
p21629
stp21630
a((dp21631
g2
(lp21632
VI did a search over the draft Standard
p21633
aVBasically, in the grammar the  productions are the ones that have commas in them to separate different items
p21634
aVThe following results are C++03 specific
p21635
aVIn C++0x, expression-list directly delegates to initializer-list because in C++0x brace lists can occur in function and constructor arguments likewise
p21636
aVexpression-list For function/constructor arguments (including functional casts)
p21637
aVenumerator-list The list of items of an enumeration
p21638
aVinit-declarator-list The different names declared in one declaration
p21639
aVExample:
p21640
aVparameter-declaration-list The parameter declaration list (surprise
p21641
aVof a function
p21642
aVinitializer-list List similar to expression-list, but can include braced expression lists
p21643
aVUsed for aggregate initialization (initializing arrays or structs)
p21644
aVmember-declarator-list Similar to the init declarator list, but for member declarations in classes
p21645
aVExample:
p21646
aVbase-specifier-list List of base-classes of a class
p21647
aVmem-initializer-list List of the initializers for members
p21648
aVExample:
p21649
aVtemplate-parameter-list List of template parameter declarations
p21650
aVtemplate-argument-list List of template arguments passed to a template
p21651
aVtype-id-list List of types for exception specifications
p21652
aVExample:
p21653
aVThere is an identifier-list for macro parameters too, which i haven't got in that list because it's really part of the preprocessor grammar
p21654
as(dp21655
g15
V34509
p21656
stp21657
a((dp21658
g2
(lp21659
VYou cannot use qualified names there
p21660
aVI you write  you are overriding both functions
p21661
aVHerb Sutter shows how it can be solved
p21662
aVAnother option is to rename those functions, because apparently they do something different (otherwise i don't see the problem of overriding both with identical behavior)
p21663
as(dp21664
g15
V34509
p21665
stp21666
a((dp21667
g2
(lp21668
VI don't think it's a good idea to do this by overloading
p21669
aVThe name of the function doesn't tell the caller whether it's going to fill an open array or not
p21670
aVAnd what if the caller has only a pointer and wants to fill coordinates (let's say he wants to fill multiple rectangles to be part of a bigger array at different offsets)
p21671
aVI would do this by two functions, and let them take pointers
p21672
aVThe size isn't part of the pointer's type
p21673
aVI don't see what's wrong with this
p21674
aVYour reinterpret-cast should work fine in practice (i don't see what could go wrong - both alignment and representation will be correct, so the merely formal undefinedness won't carry out to reality here, i think), but as i said above i think there's no good reason to make these functions take the arrays by reference
p21675
aVIf you want to do it generically, you can write it by output iterators
p21676
aVYou can then use it with vectors and also with arrays, whatever you prefer most
p21677
aVIf you want to write safer code, you can use the vector way with back-inserters, and if you work with lower level code, you can use a pointer as output iterator
p21678
as(dp21679
g15
V34509
p21680
stp21681
a((dp21682
g2
(lp21683
VYou are not creating any object in that code
p21684
aVInitialization is done when you create objects, and is not particularly tucked by the way you declare the struct
p21685
aVFor instance the following initializes the boolean to  and the integer to
p21686
aVNotice that you have just typdefed your struct
p21687
aVYou have not created an object
p21688
aVLike others said you can omit the typedef in C++ and just declare the struct, and you are still able to refer to the type by just saying
p21689
aVIf you omit explicit initialization when you define an object, then for sure no initialization is done unless the object is defined at namespace scope or defined as  locally (in which case all members are zero-initialized) or the class has a user defined default constructor that does initialization accordingly
p21690
as(dp21691
g15
V34509
p21692
stp21693
a((dp21694
g2
(lp21695
VNotice that all typecasts are explicit in C++ and C
p21696
aVThere are, in the language, no "implicit" typecasts
p21697
aVIt's called "implicit conversions" and "explicit conversions", the latter of which are also called "casts"
p21698
aVTypecasts are most often used to inhibit warnings by the compiler
p21699
aVFor instance if you have a signed and an unsigned value and compare them, the compiler usually warns you
p21700
aVIf you know the comparison is correct, you can cast the operands to a signed type
p21701
aVAnother example is overload resolution, where type casts can be used to drive to the function to be called
p21702
aVFor example to print out the address of a , you can't just say  because that would try to interpret it as a C-Style String
p21703
aVInstead you would have to cast to  before you print
p21704
aVOften implicit conversions are superior to casts
p21705
aVBoost provides  to go by implicit conversions
p21706
aVFor example the following relies on the implicit conversions of pointers to
p21707
aVThis has the benefit that it's only allowing conversions that are safe to do
p21708
aVDowncasts are not permitted, for example
p21709
as(dp21710
g15
V34509
p21711
stp21712
a((dp21713
g2
(lp21714
VI think this only works in C++0x
p21715
aVIn C++03 whatever you do - you will end up with a dynamically initialized array, and thus potentially have initialization order problems
p21716
aVThe following C++0x code won't have such problems
p21717
as(dp21718
g15
V34509
p21719
stp21720
a((dp21721
g2
(lp21722
VTry to use
p21723
aVThe macro is probably expanding to some compiler intrinsics like  which aren't necessarily eligible to appear as nested name specifier
p21724
aVEven the C++0x proposed  initially wasn't allowed before a , but is in the FCD
p21725
as(dp21726
g15
V34509
p21727
stp21728
a((dp21729
g2
(lp21730
VThey are not quite as same
p21731
aVBoth create unnamed classes, but their similarity ends at that point
p21732
aVIn C++ you create a closure catching your local variables, optionally by reference
p21733
aVIn Java, you just get a snapshot of the current local variable's values (and those variables need to be "final")
p21734
aVThe purpose of anonymous inner classes is to extend another class or implement another interface ad-hoc
p21735
aVFor that reason, anonymous inner classes can simulate the job of lambda expressions to some extend, for example by implementing the  interface
p21736
aVLambda expressions are specifically designed to be called and possibly modify the local variables in their environment
p21737
as(dp21738
g15
V34509
p21739
stp21740
a((dp21741
g2
(lp21742
VTell latex to align it at the top of the baseline of its textline by the option
p21743
aVThe problem also happens with other boxes
p21744
aVIf you leave out the position parameter , it will align both boxes centered relative to each other
p21745
as(dp21746
g15
V34509
p21747
stp21748
a((dp21749
g2
(lp21750
VYou have hit my quiz by accident - the sequence  is interpreted as a single name
p21751
aVYou need to put some token in between the colons and
p21752
aVSolution is presented in the linked question too
p21753
aVNotice that in any case you first have to declare the function designated by a qualified name in its respective namespace, too
p21754
aVEdit: There are different solutions for the syntax problem
p21755
aVIf you often need to refer to the outer namespace and have problems with this syntax, you can introduce a namespace alias
p21756
as(dp21757
g15
V34509
p21758
stp21759
a((dp21760
g2
(lp21761
VI think you want to use "non-pointer and non-reference type"
p21762
aVThere is no name especially designed for your purpose, i think
p21763
aVA name which allows me to say, I am using pointers all over the place, but there in many cases there is no reason to do so, so I should change them to s wherever possible
p21764
aVIt sounds to me you look rather for "pass by copy" or "copy" vs "pass by reference" or "reference"
p21765
aVThe fact that you can pass a pointer by value makes it impossible to use an absolute term, but makes it necessary to use a term tied to the usecase:
p21766
aVIs this a variable used to change a pointer of type  (then it would be "pass by reference" in the sense you aim to modify the referent
p21767
aVTo clarify that a pointer is used, you may wish to use the term "pass by pointer" too), or is this variable just used to hold a value of type  (then it would be "pass by value" in the sense that you copy such a value)
p21768
as(dp21769
g15
V34509
p21770
stp21771
a((dp21772
g2
(lp21773
VIn C++03 compilers this is usually allowed, because the committee figured out it would be logical to allow it, because nested classes are members of their enclosing class
p21774
aVTherefor they edited the Standard to allow it for C++0x (well, the fix was done at 2001), and those compilers implement that edit retroactively as part of their C++03 implementation
p21775
aVI've tried GCC, Comeau and Clang, all of which allow this
p21776
aVPrecisely by C++03 rules, it's not allowed, although no compiler out there implements the Standard strictly to the law
p21777
aVPitfalls
p21778
aVIf you want to declare the nested class as friend, notice that you first have to declare the class, and then put the friend declaration
p21779
aVYou have to swap the order to do it right
p21780
aVI've seen a couple of code that has done it the wrong way, but it wasn't noticed because the nested class had access anyway
p21781
aVAnother pitfall is that not all parts of  have full access to  above
p21782
aVOnly those parts where  is considered a completely defined class have such access
p21783
aVTo be able to define , you would need to first declare it and later define
p21784
aVTo check the friends code you need an old conforming compiler
p21785
aVThe Comeau Online Compiler in version 4
p21786
ag1037
aV1 BETA 3/1/03 or below can be used
p21787
as(dp21788
g15
V34509
p21789
stp21790
a((dp21791
g2
(lp21792
VI think you should use  for the following reasons
p21793
aVIndices can be negative (thus all unsigned types, including , are out of question)
p21794
aVThe type of  is
p21795
aVThe type of  in the reverse thing, , should be that type too (notice that  is equivalent to )
p21796
as(dp21797
g15
V34509
p21798
stp21799
a((dp21800
g2
(lp21801
VFunctions at the instantiation point are looked up only using argument dependent lookup (looking up functions in the namespaces associated with a function argument)
p21802
aVNormal lookup is only done at the point of the template definition
p21803
aVSo for , only the generic  function template is visible and called, since there is no specific one for it in namespace
p21804
aVFor , the more specific function is found in the global namespace of
p21805
aVIf you forward declare the string specific function to appear prior to , normal unqualified lookup finds it at the definition and uses it later on
p21806
aVIf you call  as follows, it inhibits argument dependent lookup, and will thus use the generic template for  too
p21807
aV(As a side-node: In that case, not only argument dependent lookup is inhibited at instantiation, but  won't be a dependent name in the first place - only non-parenthesized and unqualified function names are made dependent
p21808
aVThus only non-ADL lookup at definition is done anyway and no lookup at instantiation is taken place what-so-ever, even if there would be a form different from ADL that would be done there
p21809
as(dp21810
g15
V34509
p21811
stp21812
a((dp21813
g2
(lp21814
VIt's not required by the Standard that this works
p21815
aVThe Standard requires that  and  have the same representation and alignment requirements, all struct pointers do so and all unions pointers do so too
p21816
aVWhile it is undefined behavior to call the casted function pointer in any case (6
p21817
ag1014
ag976
aV2p9), the same representation and alignment requirements give a practical guarantee that the call works (6
p21818
ag976
aV5p27)
p21819
aVOther pointer types need not behave in such a way, though i haven't personally met such a machine
p21820
aVIt's theoretically possible that an  has a smaller  than a  for example (if  has stricter alignment requirements than , this could be a reasonable thing to do)
p21821
aVUnder the right calling convention, on such a machine it would be practically impossible to call a casted function pointer
p21822
as(dp21823
g15
V34509
p21824
stp21825
a((dp21826
g2
(lp21827
VYou cannot do  before the namespace was defined
p21828
aVIf there is a cyclic dependency, you need to solve it by using one or more techniques
p21829
aVForward declare if your uses don't need to know the members or size of classes, but just handle with pointers or references to them:
p21830
aVDefine stuff in engines
p21831
aVcc
p21832
aVUse of the pimpl idiom reduces dependencies even more, as it keeps headers free of headers that are only used by implementations
p21833
aVSplit the part in
p21834
aVh files for the interface and
p21835
aVcpp files for the implementation to handle such dependencies
p21836
aVThat way, headers are less dependent on other headers, and implementation files can include the headers
p21837
as(dp21838
g15
V34509
p21839
stp21840
a((dp21841
g2
(lp21842
VThere is no guarantee that a C++ compiler will enforce that
p21843
aVA C++ function could jump out of its control flow by mechanisms unknown to the compiler
p21844
aVContext switches when C++ is used to write an OS kernel is an example of that
p21845
aVAn uncaught exception thrown by a called function (whose code isn't necessarily available to the caller) is another one
p21846
aVSome other languages, like Java, explicitly enforce that with knowledge available at compile time, all paths return a value
p21847
aVIn C++ this isn't true, as is with many other occasions in the language, like accessing an array out of its bounds isn't checked either
p21848
as(dp21849
g15
V34509
p21850
stp21851
a((dp21852
g2
(lp21853
VYes, there is a semantic difference
p21854
aVThe second snippet declares a tag identifier, but the first doesn't
p21855
aVBoth declare an ordinary identifier
p21856
aVThat means that for the first, this code is not valid, but for the second, it is:
p21857
aVAs far as i know, there is no other semantic difference between them in your code
p21858
aVFor structs and unions, the second form, maybe combined with the typedef in one declaration, is needed for recursive types
p21859
aVThe ordinary identifier is not yet visible in the struct's specifier, and thus you need to refer to the struct by the already declared tag identifier
p21860
aVTag identifiers are referred to by prepending them by "struct", "union" or "enum", while ordinary identifiers are referred to without a prefix (thus the name "ordinary")
p21861
aVBesides separating the identifiers that refer to structs, unions and enumerations from those that refer to values, tag identifiers are also useful for creating forward declarations:
p21862
aVTypedef names can't be declared repeatedly at the same scope (as opposed to C++ where they can), and they need to refer to an existing type, so that they cannot be used to create forward declarations
p21863
as(dp21864
g15
V34509
p21865
stp21866
a((dp21867
g2
(lp21868
VYour example indicates that you are creating a virtual function
p21869
aVDefault arguments in virtual (especially pure) functions are not a good idea, because they are not considered when you call an overridden function
p21870
aVNow, if someone calls  on a  object, he will have to provide the argument - the default isn't used
p21871
aVYou would have to duplicate the default argument in the derived class, which creates ugly redundancies
p21872
aVInstead, you can use the non-virtual interface pattern
p21873
aVThe user can now call  with one, and with two arguments, from whatever class type he calls the function, and the implementers of  don't have to worry about the default argument
p21874
aVBy using overloading instead of default arguments, you don't need to break your head around lvalues or temporaries
p21875
as(dp21876
g15
V34509
p21877
stp21878
a((dp21879
g2
(lp21880
VIn Bash version 4 (use bash -version) you can use brace expansion
p21881
aVPutting a  before either limit forces the numbers to be padded by zeros
p21882
as(dp21883
g15
V34509
p21884
stp21885
a((dp21886
g2
(lp21887
VThe  of the parameter is not the character count of the string pointed to, because the parameter, despite its declaration form, is merely a pointer but not an array
p21888
aVUse  instead and notice that it does not include the terminating  in its returned value (as opposed to  when applied to a string array)
p21889
aVThe string  looks like a palindrome if you only take the first 3 characters of it,
p21890
aVSince  applied to a pointer yields  on your machine, it's only those first three characters that are inspected
p21891
as(dp21892
g15
V34509
p21893
stp21894
a((dp21895
g2
(lp21896
VIt's not possible to assign classes or namespaces and make the outcome of namelookup dependent on this
p21897
aVBut you can assign the address of variables
p21898
aVSo in your example, you could say
p21899
aVHowever in this case you can put the print into each respective if clause, which looks easier to me
p21900
aVIf you accesses are often, you may wish to put the colors into a single data-structure
p21901
aVSo you could use an index, maybe using enumerations for the color names instead of raw numbers
p21902
aVThis way you can also iterate over the colors (using array's  function or its iterator interface)
p21903
aVis part of TR1, C++0x and Boost
p21904
as(dp21905
g15
V34509
p21906
stp21907
a((dp21908
g2
(lp21909
VFour distinct ways exist
p21910
aVWhich one is the best is up to you
p21911
as(dp21912
g15
V34509
p21913
stp21914
a((dp21915
g2
(lp21916
VIf  is declared in that namespace and you want to declare it again (for defining it), you do it by prefixing its name, not its type
p21917
aVIf its type is declared in that namespace too, you also need to prefix the name of the type
p21918
aVIt's rarely needed to redeclare an object like that
p21919
aVOften the first declaration of an object is also its definition
p21920
aVIf you want to first declare the object, you have to do it in that namespace
p21921
aVThe following declares and defines "myobject"
p21922
aVIf you have defined in object like this, you refer to it by saying
p21923
aVYou don't have to "declare" that object somehow in order to use it locally
p21924
as(dp21925
g15
V34509
p21926
stp21927
a((dp21928
g2
(lp21929
VVS2008 gives me a warning about the double to float conversion
p21930
aVHow do I get rid of this warning
p21931
aVOr
p21932
aVOr overload your function with both variants, or make it a template
p21933
aVOf course, it's not a good idea to assume a fixed
p21934
aVNotice that neither your original code is safe, because the  in the parameter list of your function has no meaning
p21935
aVIt's simply ignored
p21936
aVSo better document it clearly, that the iterator or pointer needs to provide access to sufficiently many values
p21937
as(dp21938
g15
V34509
p21939
stp21940
a((dp21941
g2
(lp21942
VIt's legal to define namespace members outside of their namespace as long as their name is prefixed with the name of their namespace, and the definition actually occurs in a namespace that encloses it
p21943
aVIt can't happen in a namespace that's nested inside the member namespace
p21944
aVIt's the same stuff as for class members, where you can also define functions outside of their class, as long as you prefix the names with the name of the class
p21945
aVHowever as for classes, namespace members must be first declared in their respective namespace before they can be defined outside out it
p21946
as(dp21947
g15
V34509
p21948
stp21949
a((dp21950
g2
(lp21951
VYou can as follows
p21952
aVBut that evaluates  multiple times
p21953
aVYou can instead create a static function, which is cleaner
p21954
aVThen you are also able to pass things to  that have side effects, and have the side effect happen only one time
p21955
aVWhat you have written is using the ,  and  preprocessor directives, but you need to use language constructs if you pass variables to the macro and want to evaluate their values
p21956
aVUsing , and  statements as in the actual language constructs don't work either, because control flow statements don't evaluate to values
p21957
aVIn other words, an if statement is steering control flow only ("if A, then execute B, else execute C"), not evaluating to any values
p21958
as(dp21959
g15
V34509
p21960
stp21961
a((dp21962
g2
(lp21963
VThat's a definition of a member of a partial specialization that would be defined as follows
p21964
aVIt's not a specialization of the member "scalingCoeff" of the primary template "DaubechiesWavelet"
p21965
aVSuch a specialization is required to pass the value of all arguments, which your specialization does not do
p21966
aVTo do what you want, you can use overloading though
p21967
aVNotice that the initialization syntax you use will only work in C++0x
p21968
as(dp21969
g15
V34509
p21970
stp21971
a((dp21972
g2
(lp21973
VIt's allowed in C to declare the array as follows, which will initialize it without copying the terminating
p21974
aVBut it's illegal in C++
p21975
aVI'm not aware of a trick that would allow it for C++
p21976
aVThe C++ Standard further says
p21977
aVRationale: When these non-terminated arrays are manipulated by standard string routines, there is potential for major catastrophe
p21978
aVEffect on original feature: Deletion of semantically well-defined feature
p21979
aVDifficulty of converting: Semantic transformation
p21980
aVThe arrays must be declared one element bigger to contain the string terminating \u2019\u005c0\u2019
p21981
aVHow widely used: Seldom
p21982
aVThis style of array initialization is seen as poor coding style
p21983
as(dp21984
g15
V34509
p21985
stp21986
a((dp21987
g2
(lp21988
VIt doesn't match the  token, but the  token, which stands for "identifier"
p21989
aVIt's the catch-all if no keyword matches
p21990
aVThe lexical analyser doesn't know what to "expect" at certain positions
p21991
aVIt just returns tokens, and the parser will know what it expects
p21992
aVA C parser has to accept the following statement, for example, which is a function call
p21993
as(dp21994
g15
V34509
p21995
stp21996
a((dp21997
g2
(lp21998
VAn important thing is to differentiate between:
p21999
aVReference as an expression
p22000
aVReference itself
p22001
aVThe FAQ and the teacher seem to talk about the first point, but the teacher's question is formulated as if it were asking about the second point
p22002
aVTo explain the point of view of the FAQ, consider what the Standard describes as the very first stage of expression processing
p22003
aVIf an expression initially has the type "reference to T" (8
p22004
ag1037
aV2, 8
p22005
ag1014
aV3), the type is adjusted to "T" prior to any further analysis, the expression designates the object or function denoted by the reference, and the expression is an lvalue
p22006
aVAfter this transformation, a reference and the object or function it designates cannot be distinguished anymore using that expression
p22007
aVBut that doesn't make a reference equivalent to an object
p22008
aVThe former just refers to the latter
p22009
aVEven less so since references can also refer to functions
p22010
aVNow, a reference itself is just that - an entity that happens to refer to an object or function but that doesn't store something on its own
p22011
aVThe same mistake in arguing is sometimes made by people when they say that arrays in C would be just pointers
p22012
aVWhat they really mean is that arrays in expressions are (mostly) just pointers
p22013
aVBut that doesn't make both of them equal in their own right
p22014
as(dp22015
g15
V34509
p22016
stp22017
a((dp22018
g2
(lp22019
VBoth of those codes are invalid (only the last one is valid), but your compiler (which is not conforming) only diagnoses one
p22020
aVAs another answer says, this uses the injected class name
p22021
aVA class  is considered to have a member name  denoting that same class
p22022
aVFor example (notice the "class" keyword before  in the first example is necessary to force a reference to the injected class name, instead of the default constructor):
p22023
aVClass templates also have an injected class name
p22024
aVLike the injected class name, it is inherited to derived classes, and thus  is ill-formed because it uses that injected class name, which however is not accessible
p22025
aVIf you use GCC less 4
p22026
aV5, it may have something to do with a change introduced with GCC4
p22027
aV5:
p22028
aVG++ now implements DR 176
p22029
aVPreviously G++ did not support using the injected-class-name of a template base class as a type name, and lookup of the name found the declaration of the template in the enclosing scope
p22030
aVNow lookup of the name finds the injected-class-name, which can be used either as a type or as a template, depending on whether or not the name is followed by a template argument list
p22031
aVAs a result of this change, some code that was previously accepted may be ill-formed because
p22032
aVThe injected-class-name is not accessible because it's from a private base, or
p22033
aVThe injected-class-name cannot be used as an argument for a template template parameter
p22034
aVIn either of these cases, the code can be fixed by adding a nested-name-specifier to explicitly name the template
p22035
aVThe first can be worked around with -fno-access-control; the second is only rejected with -pedantic
p22036
aVTo have a bit more fun with injected class names - notice that the injected class name is not equivalent to a typedef as one might think first
p22037
aVThe injected class name is a class-name, but is not classified as a typedef-name, which means it can be hidden by function, object or enumerator names:
p22038
aVTo refer to the injected class name you can say  (likewise, in a base-class list, non-type names are ignored thus you don't need special pre-cautions there), but a simple lookup to  will refer to the data-member
p22039
as(dp22040
g15
V34509
p22041
stp22042
a((dp22043
g2
(lp22044
VNo
p22045
aVThe correct syntax is
p22046
aVYour code will only change the local pointer to a FILE pointer
p22047
aVOnly changes to  are seen by the caller in your code
p22048
aVIf you change it to the above, things are passed by reference and changes are promoted like intended
p22049
aVThe corresponding argument is passed as usual
p22050
as(dp22051
g15
V34509
p22052
stp22053
a((dp22054
g2
(lp22055
VFirst of all that's not valid, because  names the constructor, and not the class type
p22056
aVJust say
p22057
aVThen you probably forget to link against 's object file
p22058
aVBe sure to include it in the compiler command line when you compile the executable, or add it to the project config by whatever IDE you are using
p22059
as(dp22060
g15
V34509
p22061
stp22062
a((dp22063
g2
(lp22064
VJust say the following
p22065
aVIt works perfectly well with  being  and is equivalent to the code you have shown
p22066
as(dp22067
g15
V34509
p22068
stp22069
a((dp22070
g2
(lp22071
VYou can't do this and C++ does not support it because it breaks with fundamental C++ principles
p22072
aVA  is a different type than an , and name lookup as well as determining what conversions will be needed for a value assignment happens at compile time
p22073
aVHowever what is really named by  including its actual type would only be known at runtime
p22074
aVYou can use templates to parameterize class
p22075
aVThen you can pass the type, however only at compile time for the above mentioned principle's reason
p22076
as(dp22077
g15
V34509
p22078
stp22079
a((dp22080
g2
(lp22081
VThere are two syntaxes to denote array types
p22082
aVThe first is the type-id syntax and is used everywhere where the language expects a compile time type, which looks like:
p22083
aVThis specifies an array type that, in the first form, has a number of elements given by an integer constant expression (means it has to be known at compile time)
p22084
aVIn the second form, it specifies an array type with an unknown number of elements
p22085
aVSimilar to class types that you declare without a body, such an array type is said to be incomplete, and you cannot create arrays of that type
p22086
aVYou can, however, specify that type
p22087
aVFor example you may typedef it
p22088
aVIn the same manner, you may specify it as a template type argument, so the answer to your question is yes you can pass such a type specifier to a template
p22089
aVNotice that i talk about specifiers here, because the form you use here is not the type itself
p22090
aVThe second way is using the new-type-id syntax which allows denoting runtime types by having non-constant bounds
p22091
aVThis allows passing variables as element count, and also allows passing a zero
p22092
aVIn such a case, a zero element array is created
p22093
aVThat syntax is only usable with the  operator for supporting dynamic arrays
p22094
as(dp22095
g15
V34509
p22096
stp22097
a((dp22098
g2
(lp22099
VThere is no guarantee that any of the two are statically initialized before any runtime code is executed
p22100
aVFor the first, it's easy to make it happen, though
p22101
aVAs another guy says,  in C++0x allows constructors to be executed statically
p22102
aVIn your case that would work for the first case, but not for the second
p22103
aVYou will have to live that for the second, no guarantee is made by the Standard
p22104
aVBut the Standard still allows an implementation to optimize it to be done at static initialization phase
p22105
aVSee 3
p22106
ag488
aV2/2
p22107
aVAn implementation is permitted to perform the initialization of an object of namespace scope with static storage duration as a static initialization even if such initialization is not required to be done statically, provided that
p22108
aVthe dynamic version of the initialization does not change the value of any other object of namespace
p22109
aVscope with static storage duration prior to its initialization, and
p22110
aVthe static version of the initialization produces the same value in the initialized object as would be produced by the dynamic initialization if all objects not required to be initialized statically were initialized dynamically
p22111
aVIf the array given is suitable, your constructor may not violate those rules
p22112
aVThe Standard shows an example, which i explained in more detail here
p22113
aVFor completion, the example code is shown below
p22114
aVAs you see, putting things to be initialized earlier can even go with changed initial values if there exist a certain relation between variables
p22115
as(dp22116
g15
V34509
p22117
stp22118
a((dp22119
g2
(lp22120
VI think it violates my taste
p22121
aVI would code it like this:
p22122
as(dp22123
g15
V34509
p22124
stp22125
a((dp22126
g2
(lp22127
VThe names of enumerators, function and objects hide the names of enumerations and classes that are declared in the same scope
p22128
aVIn your case, the data member name hides the name of the struct
p22129
aVYou can access the hidden type name by special lookups:
p22130
aVThe name prior to  is looked up by ignoring object-, function- and enumerator names
p22131
aVThe name used to specify a base class ignores any non-type names
p22132
aVThe name specified in an elaborated type specifier ignores object-, function- and enumerator names
p22133
aVThus, the following elaborated type specifier is valid and refers to the class
p22134
aVAlso, note that it is ill-formed when in class scope a member declaration changes the meaning of a name used in that declaration
p22135
aVIn your case, let's take
p22136
aVThe first name will refer to the type, but in the complete scope of , that name would refer to the data member
p22137
aVThe Standard says
p22138
aVA name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S
p22139
aVNo diagnostic is required for a violation of this rule
p22140
aVYour compiler is not required to diagnose it, which is a phrase meaning that it is effectively undefined behavior (good compilers warn you with something like "member changes meaning of name")
p22141
aVAlbeit i doubt that the above rule is intended to apply in this case (as it is worded, it certainly applies though), you can clear the code up by using an elaborated type specifier
p22142
aVNotice that you are required to use the elaborated type specifier in the out-of-class definition of the static member
p22143
aVSome compilers allow you to use the injected class name for refering to the type too (GCC did, in the past)
p22144
aVThe following uses the injected class name
p22145
aVappears before  and ignores the data member
p22146
aVBut the compiler has to lookup the name  to 's constructor and not to its class type
p22147
as(dp22148
g15
V34509
p22149
stp22150
a((dp22151
g2
(lp22152
VYes we can do that
p22153
as(dp22154
g15
V34509
p22155
stp22156
a((dp22157
g2
(lp22158
VThe C Standard is quite clear on it
p22159
aVThe effective type of the object named by  is , because it has a declared type, see
p22160
aVThe aliasing rules in C99 apply to reads and writes, and the write to  through an  lvalue in  is undefined behavior according to
p22161
aVIn contrast, the  of  is fine, because  can alias any object ()
p22162
aVThe Standard defines  at  as
p22163
aVFor all functions in this subclause, each character shall be interpreted as if it had the type unsigned char (and therefore every possible object representation is valid and has a different value)
p22164
aVThe memcpy function copies n characters from the object pointed to by s2 into the object pointed to by s1
p22165
aVIf copying takes place between objects that overlap, the behavior is unde\ufb01ned
p22166
aVHowever if there exist a use of  afterwards, that might cause undefined behavior depending on the bitpattern
p22167
aVIf such a use does not happen, that code is fine in C
p22168
aVAccording to the C++ Standard, which in my opinion is far from clear on the issue, i think the following holds
p22169
aVPlease don't take this interpretation as the only possible - the vague/incomplete specification leaves a lot of room for speculation
p22170
aVLine  is problematic because the alignment of  might not be ok for the  type
p22171
aVIt changes the type of the object stored in  to be
p22172
aVAs long as you don't access that object later on through , aliasing rules are not broken, but alignment requirements might still be
p22173
aVLine  however has no alignment problems, and is thus valid, as long as you don't access  afterwards as a , which might cause undefined behavior depending on how the  type interprets the stored bitpattern
p22174
aVI don't think that the type of the object is changed thereby
p22175
aVThere is a long GCC Bugreport that also discusses the implications of a write through a pointer that resulted from such a cast and what the difference to placement-new is (people on that list aren't agreeing what it is)
p22176
as(dp22177
g15
V34509
p22178
stp22179
a((dp22180
g2
(lp22181
VAlso, as long as your inner dimension size is constant, you can allocate a variable number of counts of that inner dimension
p22182
as(dp22183
g15
V34509
p22184
stp22185
a((dp22186
g2
(lp22187
VHow can I fix this (i
p22188
ag1992
aV, keep internal pseudo-explicit specializations in a templated Foo) on VC++ 2010
p22189
aVYou can make the enumeration type non-dependent by declaring it in a non-template base class (C++03 made nested classes dependent in #108 but that doesn't include enumeration, but even if, such code would still be legal)
p22190
aVThe "error class" link already gives a description of the intended cases where the error should be risen
p22191
aVThe error thinks that all dependent types are forbidden, but in fact this is what the Standard says:
p22192
aVThe type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a parameter of the specialization
p22193
aVSo even if the name  would be somehow dependent, that wouldn't make it ill-formed as long as it doesn't depend on a parameter of the specialization like in the example of your "error class" link
p22194
as(dp22195
g15
V34509
p22196
stp22197
a((dp22198
g2
(lp22199
VYou can only do that for one variable
p22200
aVBut i would declare them outside of the conditions
p22201
aVIf you are scared about the scope, you can always limit it:
p22202
aVOf course, this evaluates the second initializer even if  evaluates to true
p22203
aVBut i assume that's not important
p22204
as(dp22205
g15
V34509
p22206
stp22207
a((dp22208
g2
(lp22209
VYes it is perfectly valid to not define a class member function if it is not used
p22210
aVThat is also true for non-member functions
p22211
aVA definition is required for virtual functions, though
p22212
aVBut pure virtuals can omit definitions if they aren't used
p22213
aVUsed", btw, does not include refering to the function within
p22214
aVIn other words, this is still valid:
p22215
as(dp22216
g15
V34509
p22217
stp22218
a((dp22219
g2
(lp22220
VSince you are using C++, falling back to  is unnecessary
p22221
aVYou can write it in terms of operator
p22222
aVThe nothrow version of  returns a null pointer if allocation fails, instead of throwing an exception
p22223
as(dp22224
g15
V34509
p22225
stp22226
a((dp22227
g2
(lp22228
VOf course, if the implementation documents when exactly the behavior changes with different runs, that's fine
p22229
aVNotice that the implementation-defined behavior is part of the parameters of the abstract machine:
p22230
aVThe semantic descriptions in this International Standard define a parameterized nondeterministic abstract
p22231
aVmachine
p22232
aVCertain aspects and operations of the abstract machine are described in this International Standard as implementation-defined (for example, sizeof(int))
p22233
aVThese constitute the parameters of the abstract machine
p22234
aVEach implementation shall include documentation describing its characteristics and behavior in these respects
p22235
aVSuch documentation shall define the instance of the abstract machine that corresponds to that implementation (referred to as the \u2018\u2018corresponding instance\u2019\u2019 below)
p22236
aVThis does not allow changing the behavior in a single run of the compiler
p22237
aVBut between different runs of the compiler, the compiler may use a different corresponding abstract machine which differs by different implementation defined values, according to what the implementation defined
p22238
aVCommand line parameters like  (which changes the implementation-defined set of diagnostic messages) are the most common example of this
p22239
aVThis is a difference to unspecified behavior in addition to the documentation requirements
p22240
aVUnspecified behavior is much less restrictive:
p22241
aVCertain other aspects and operations of the abstract machine are described in this International Standard as unspecified (for example, order of evaluation of arguments to a function)
p22242
aVWhere possible, this International Standard defines a set of allowable behaviors
p22243
aVThese define the nondeterministic aspects of the abstract machine
p22244
aVAn instance of the abstract machine can thus have more than one possible execution sequence for a given program and a given input
p22245
as(dp22246
g15
V34509
p22247
stp22248
a((dp22249
g2
(lp22250
VThis should be all you need:
p22251
aVThis reads characters from  and inserts them into the stringstream
p22252
aVAfterwards it gets the string created behind the scenes
p22253
aVNotice that i fell into the following trap: Using the extraction operator will skip initial whitespace
p22254
aVYou have to use the insertion operator like above, or use the  manipulator:
p22255
aVThese functions are described as reading the stream character by character though (not sure what optimizations are possible here, though), i haven't timed these to determine their speed
p22256
as(dp22257
g15
V34509
p22258
stp22259
a((dp22260
g2
(lp22261
VThe Standard says
p22262
aVThe operand shall have a pointer type, or a class type having a single conversion function (12
p22263
ag1037
aV2) to a pointer type
p22264
aVIf the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section
p22265
aVYou can (ab)-use the absence of overload resolution by declaring a const version of the conversion function
p22266
aVOn a conforming compiler that's enough to make it not work anymore with :
p22267
aVResults in the following
p22268
aVOn compilers that are less conforming in that regard (EDG/Comeau, GCC) you can make the conversion function a template
p22269
aVdoes not expect a particular type, so this would work:
p22270
aVHowever, this has the downside that your smartpointer is now convertible to any pointer-type
p22271
aVAlthough the actual conversion is still typechecked, but this won't rule out conversions up-front but rather give a compile time error much later
p22272
aVSadly, SFINAE does not seem to be possible with conversion functions in C++03 :) A different way is to return a private nested type pointer from the other function
p22273
aVThe only problem now is with a conversion to , in which case both conversion functions are equally viable
p22274
aVA work-around suggested by @Luther is to return a function pointer type from the other conversion function, which works with both GCC and Comeau and gets rid of the  problem while having no other problems on the usual conversion paths, unlike the template solution
p22275
aVNotice that these workarounds are only needed for compilers that are not conforming, though
p22276
as(dp22277
g15
V34509
p22278
stp22279
a((dp22280
g2
(lp22281
VNo you don't
p22282
aVIt closes the file
p22283
ag1240
aVEffects: Destroys an object of class basic_filebuf
p22284
aVCalls close()
p22285
aV(which is contained as an object within  (), thus being destructed when the  is destructed)
p22286
as(dp22287
g15
V34509
p22288
stp22289
a((dp22290
g2
(lp22291
VWhat you try is simply to pass a  (which is ) to a , which is the wrong way around
p22292
aVYou need to explicitly cast to perform this downward conversion
p22293
as(dp22294
g15
V34509
p22295
stp22296
a((dp22297
g2
(lp22298
V in C++03:
p22299
aVAn implementation shall not implicitly instantiate a function template, a member template, a non-virtual member function, a member class or a static data member of a class template that does not require instantiation
p22300
aVIt is unspecified whether or not an implementation implicitly instantiates a virtual member function of a class template if the virtual member function would not otherwise be instantiated
p22301
as(dp22302
g15
V34509
p22303
stp22304
a((dp22305
g2
(lp22306
VThere is no difference between  and
p22307
aVThese two are completely equivalent
p22308
aVMost people prefer  for classes and  for non-class types, but that's purely up to one's own choice
p22309
aVBoth call constructors for classes with one argument
p22310
aVThe preferred way for classes is , because this allows passing more than one argument to the constructor, as in
p22311
aVTrying to apply the other form,  will not work: It casts , and then applies the comma operator and evalutes  in isolation
p22312
aVParentheses like  do not help: This will evaluate  and  in isolation using the comma operator and then cast  to
p22313
aVFor non-class types, such a cast is often too powerful
p22314
aVC++ has  for roughly doing the reverse of an implicit conversion (such as casting base classes to derived classes and casting  to another pointer), which often is what fits in
p22315
aVSee When should static_cast, dynamic_cast and reinterpret_cast be used
p22316
aVis not a function, though
p22317
aVDoing  will call it the function, but doing  is illegal, beause there are two expressions next to each other, with no operator in between
p22318
aVFor those who don't believe this answer, and downvote it on gut feeling, please consult the Standard at
p22319
aVA simple-type-specifier (7
p22320
ag2790
aV5) followed by a parenthesized expression-list constructs a value of the specified type given the expression list
p22321
aVIf the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5
p22322
aV4)
p22323
as(dp22324
g15
V34509
p22325
stp22326
a((dp22327
g2
(lp22328
VThe reason is that  is first promoted to  before doing the bitwise OR, which causes sign extension to take place (assuming that char is signed and can hold negative values):
p22329
aVThe representation of  promoted to  is (at least) 1 byte full of , so it overwrites the zero bit of  that you previously shifted up
p22330
aVYou can cast to  first
p22331
aVWith two complement representation, that will not change the bitpattern in the lowest byte
p22332
aVWhile not strictly necessary, you may cast  to  too, for consistency (if short is 2 bytes long, it won't matter that  was sign extended beyond those 2 bytes)
p22333
as(dp22334
g15
V34509
p22335
stp22336
a((dp22337
g2
(lp22338
VUse placement-new like this (burried behind the  call)
p22339
aVThen you can call the constructor with  (you don't need to repeat the argument for the outer Vector, because  refers to  automatically since you inherit from the outer Vector
p22340
aVYou need to make sure to call destructors manually before doing  in the destructor then
p22341
aVYou might also want to embed the vector as a member, which i would probably prefer because I imagine not necessarily all operations of the outer vector make sense for a matrix
p22342
aVThen the initialization looks like
p22343
aVIt should be noted that  can also be used for this
p22344
aVThis is an easy and safe way to accomplish that, and you get automatic memory management
p22345
as(dp22346
g15
V34509
p22347
stp22348
a((dp22349
g2
(lp22350
VThis means that this is ill-formed:
p22351
aVLikewise for other function template specializations (not only conversion functions)
p22352
as(dp22353
g15
V34509
p22354
stp22355
a((dp22356
g2
(lp22357
VIt's actually quite straight forward
p22358
aVFor , overload resolution has these candidates:
p22359
aVCandidate 1 (builtin: 13
p22360
aV6/13) (T being some arbitrary object type):
p22361
aVParameter list:
p22362
aVCandidate 2 (your operator)
p22363
aVParameter list:
p22364
aVThe argument list is given by :
p22365
aVThe set of candidate functions for overload resolution is the union of the member candidates, the non-member candidates, and the built-in candidates
p22366
aVThe argument list contains all of the operands of the operator
p22367
aVArgument list:
p22368
aVYou see that the first argument matches the first parameter of Candidate 2 exactly
p22369
aVBut it needs a user defined conversion for the first parameter of Candidate 1
p22370
aVSo for the first parameter, the second candidate wins
p22371
aVYou also see that the outcome of the second position depends
p22372
aVLet's make some assumptions and see what we get:
p22373
aVis : The first candidate wins, because it has an exact match, while the second candidate requires an integral conversion
p22374
aVis : Neither candidate wins, because both require an integral conversion
p22375
aVNow,  says
p22376
aVLet ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F
p22377
aVA viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then
p22378
aVfor some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that
p22379
aVFor our first assumption, we don't get an overall winner, because Candidate 2 wins for the first parameter, and Candidate 1 wins for the second parameter
p22380
aVI call it the criss-cross
p22381
aVFor our second assumption, the Candidate 2 wins overall, because neither parameter had a worse conversion, but the first parameter had a better conversion
p22382
aVFor the first assumption, it does not matter that the integral conversion (int to unsigned) in the second parameter is less of an evil than the user defined conversion of the other candidate in the first parameter
p22383
aVIn the criss-cross, rules are crude
p22384
aVThat last point might still confuse you, because of all the fuss around, so let's make an example
p22385
aVThis gives you the same confusing GCC warning (which, I remember, was actually confusing the hell out of me when I first received it some years ago), because  converts to  worse than  to  - yet you get an ambiguity, because you are in a criss-cross situation
p22386
as(dp22387
g15
V34509
p22388
stp22389
a((dp22390
g2
(lp22391
VIt looks to me that this is a confusing way of separating code
p22392
aVstands for header and  for C++ header commonly
p22393
aVPutting template definitions into  while other code into  seems to abuse the file extension
p22394
aVTemplate code is usually all written in one header together with the template declaration, or in another header that may also be specially suffixed like  or something and then included into the header where the template declarations are put in
p22395
aVBut really, the file extension doesn't matter as long as you are consistent in your project
p22396
aVExceptions are when you use explicit instantiation, and know exactly what instantiations you will need
p22397
aVImagine you have a template, and exactly two instantiations of it:
p22398
aVYou don't need to put the definition of  and others into the header
p22399
aVYou can put them all into a  file, alongside with the two explicit instantiation directives
p22400
aVThe last point you ask about is about a different topic: Explicit specializations
p22401
aVI recommend you to make a separate question about that
p22402
aVIn a nutshell, explicit specialization definitions where all template arguments have concrete values/types should be put into the  file, but declarations of them are needed to be put into the header (to tell others that those certain members are specialized)
p22403
as(dp22404
g15
V34509
p22405
stp22406
a((dp22407
g2
(lp22408
VWith Visual C++, there is an issue with derived to base delegation of the copy constructor argument:
p22409
aVThis code is valid, but Visual C++ fails to compile it, because they call the base-class copy constructor using a  object
p22410
aVThe Standard however require the compiler to pass a  (or  in some cases) down to the base class
p22411
aVThis is the first part of your puzzle: The template is a better match, because the copy constructor would need a derived to base conversion, but your template accepts the derived class directly, and then would need another copy, and so on and so on
p22412
aVNotice that the template will not act as a copy constructor here (given the VC++ bug), just as the above declaration of  did not declare a copy constructor
p22413
aVThe second part is the answer to your other question: The Standard was ambiguous and not clear in C++03 as to whether instantiated templates could act as copy constructors or not
p22414
aVIn a note, it says
p22415
aVBecause a template constructor is never a copy constructor, the presence of such a template does not suppress the implicit declaration of a copy constructor
p22416
aVTemplate constructors participate in overload resolution with other constructors, including copy constructors, and a template constructor may be used to copy an object if it provides a better match than other constructors
p22417
aVbut a few paragraphs below that, it says
p22418
aVA member function template is never instantiated to perform the copy of a class object to an object of its class type
p22419
aVBecause of the context that this text appears on (forbidding by-value parameter copy constructors) one may argue that this is not forbiding an instantiation of a by-reference copy constructor from a template
p22420
aVBut such arguing is moot, facing this vague wording
p22421
aVThe C++0x FCD clearified it, and removed the weird note
p22422
aVIt now is clear that templates are never instantiated to perform a copy, no matter whether it would yield to by-reference or by-value parameters
p22423
aVBut as explained above, if you happen to use VC++ by any chance, and it exhibits that behavior, then it has nothing to do with copy constructors
p22424
as(dp22425
g15
V34509
p22426
stp22427
a((dp22428
g2
(lp22429
VYour example code is not specializing, but overloading
p22430
aVThe order does matter (not in your code though), because functions need to be declared before being known in C++
p22431
aVSo if one overload calls another, or if another function in between calls the overload set, calls may end up somewhere not desired
p22432
aVYour example code is valid and common
p22433
aVFor some reason I think I remember reading that if you put the specialization below in this scenario then when the compiler looks through the header, it will see the default first, see that it works, and use that
p22434
aVYou are thinking of the following rule
p22435
aVIf a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required
p22436
aVI can't help but to quote the hilarious sayings of the Standard here about specializations
p22437
aVThe placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member function templates of member classes of class templates, etc
p22438
aV, and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc
p22439
aV, can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below
p22440
aVWhen writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation
p22441
as(dp22442
g15
V34509
p22443
stp22444
a((dp22445
g2
(lp22446
VYou don't need to do anything complicated
p22447
aVJust use overloading and delegation
p22448
aVNote that we cannot just add an  overload, because when  turns out to be  too, this would be an invalid overload (two functions with the same signature)
p22449
aVOr, for this case, you can do this by specialization
p22450
aVUsing specialization this way is only possible if all template arguments are fixed
p22451
aVIn other words, partially specializing the member function is not possible
p22452
as(dp22453
g15
V34509
p22454
stp22455
a((dp22456
g2
(lp22457
VThe code looks valid, and it compiles with GCC, after changing the syntax error in your for loop (the comma should be a semicolon after the initial part)
p22458
aVNote that C++03 compilers are not necessarily required to correctly get a function pointer with
p22459
aVOnly C++0x allows directly getting the address of a function template specialization without casting but merely giving a template argument list, but usually C++03 compilers backpart that feature and implement it even in C++03 mode
p22460
aVBut i think it is unlikely that this is the source of your problem here
p22461
as(dp22462
g15
V34509
p22463
stp22464
a((dp22465
g2
(lp22466
V is not a definition in C++, but only in C
p22467
aVYou also cannot, from what I know, provide a non-defining declaration for  without changing its meaning, because the definition it shows has internal linkage, but if you put  you will give it external linkage (possibly conflicting with other translation units's  names)
p22468
aVNote that linkage rules are complicated
p22469
aVYou also cannot only declare an enumeration without defining it
p22470
aVI believe your other solutions are correct
p22471
as(dp22472
g15
V34509
p22473
stp22474
a((dp22475
g2
(lp22476
V is a pointer to the 'th subarray
p22477
aVIf you dereference it, you get an lvalue to the 'th subarray, which decays to a pointer to that array's first element
p22478
aVThe address of an array's first element and that of its array is the same
p22479
aVThe dereference is needed to make  calculate with the correct element byte-width
p22480
aVIf you would not dereference, then instead of getting  you would get a  pointer that you add  to, which together with  advances into memory pointing to  instead (advancing by  instead of )
p22481
as(dp22482
g15
V34509
p22483
stp22484
a((dp22485
g2
(lp22486
VIf the function that performs these checks just does those conversions that don't have any side effects, the optimizer will likely optimize that entire code away and will not generate any code for the function body
p22487
aVThe only thing left will be the function symbol and a return instruction
p22488
aVAs it turns out (tested with GCC 4
p22489
ag1014
aV1) not even the function's symbol need to be emitted
p22490
aVThe compiler optimized out the address-taking, and then observed no other code in that file accesses the function, not emitting code for it
p22491
aVI think that's OK, because any other translation unit that needs that definition provides a definition by itself - so they don't depend on other translation units's compilation anyway
p22492
aVNotice that using this method, the checks only trigger once you create an object of
p22493
aVOtherwise, the constructor of  will never be implicitly instantiated and the checks are never done
p22494
aVThere are ways that completely get this done without any such dummy code, like
p22495
as(dp22496
g15
V34509
p22497
stp22498
a((dp22499
g2
(lp22500
VI don't think that any of these are ill-formed
p22501
aVFirst, for ,  is looked up, and this will unambiguously yield the class type
p22502
aVThen  in  is looked up, and this is unambiguous too (it is not looked up in
p22503
aVThe second case will work for the same reason
p22504
aVBut if you call  on a  object, the call will be be ambiguous because the name  is looked up in all subobjects of  of type , and  has two such subobjects, and  is a non-static member function
p22505
aVThe same reason holds for the second case
p22506
aVIt does not make a difference for this whether you name  using  or  directly
p22507
aVBoth of these designate the class
p22508
aVTo get an ambiguity for the using declaration, you need to write it differently
p22509
aVNote that in C++0x  is not valid
p22510
aVIt is in C++03 though, as long as the whole name refers to a base-class member
p22511
aVConversely, if this would be allowed in C++0x, the whole using declaration would also be valid, because C++0x does not take subobjects into account for name-lookup:  unambiguously refers to only one declaration (the one in )
p22512
aVSee DR #39 and the final paper N1626
p22513
aVThe C++03 Standard describes this in paragraphs  and
p22514
aVResponse for Edit3:
p22515
aVYes, GCC and VS2010 are wrong
p22516
aVrefers to the type found by the injected class name of  and to the nested class found as
p22517
aVThe name  preceeding the  is looked up using unqualified lookup (by , which delegates to  in the first bullet) ignoring any object, function and enumerator names ( - there are no such names in this case, though)
p22518
aVIt then violates against 's requirement that:
p22519
aVIf the resulting set of declarations are not all from sub-objects of the same type
p22520
aVthe program is ill-formed
p22521
aVIt is possible that VS2010 and GCC interpret C++0x wording differently than Comeau and retroactively implement that wording:
p22522
aVIn a using-declaration used as a member-declaration, the nested-name-specifier shall name a base class of the class being defined
p22523
aVThis means that non-base classes are considered, but it is an error if a non-base class is named
p22524
aVIf the Standard would intend to ignore non-base class names, it would say can only here, or spell it out explicitly (both practices are done)
p22525
aVThe Standard however is not at all consequent with its use of shall and can
p22526
aVAnd GCC implements C++0x wording, because it rejects otherwise completely fine C++03 code, just because the using declaration contains its class-name
p22527
aVFor an example of the unclear wording, consider the following expression:
p22528
aVThis is syntactically ambiguous, because it can be a member function call if  is a class object, but it can be a pseudo-destructor-call (which is a no-op) if  has a scalar type (such as )
p22529
aVBut what the Standard says is for the syntax of a pseudo-destructor call and class member access at  and  respectively
p22530
aVThe left-hand side of the dot operator shall be of scalar type
p22531
aVFor the \ufb01rst option (dot) the type of the \ufb01rst expression (the object expression ) shall be \u201cclass object\u201d (of a complete type)
p22532
aVThat is the wrong use, because it does not clear up the ambiguity at all
p22533
aVIt should use "can only", and compilers interpret it in that way
p22534
aVThis has mostly historical reasons, as some committee-member recently told me on usenet
p22535
aVSee The rules for the structure and drafting of International Standards, Annex H
p22536
as(dp22537
g15
V34509
p22538
stp22539
a((dp22540
g2
(lp22541
VYou will lose track from what template the specialization comes from:
p22542
aVGCC outputs
p22543
aVIf it just said  and  you would lose an important information that this diagnostic contains
p22544
as(dp22545
g15
V34509
p22546
stp22547
a((dp22548
g2
(lp22549
VIn my LLVM code, I create  wrapper functions for this, and insert LLVM function declarations into the module in order to call them
p22550
aVThen, a good way to make LLVM know about the functions is not to let it use  and search for the function name in the executing binary (this is a pain in the ass, since the function names need to be in the  section, and it is slow too), but to do the mapping manually, using ExecutionEngine::addGlobalMapping
p22551
aVJust get the  of that declaration and the address of the function as given in C++ by  converted to  and pass these two things along to LLVM
p22552
aVThe JIT executing your stuff will then know where to find the function
p22553
aVFor example, if you wanted to wrap  you could create several functions that create, destroy and call functions of such an object
p22554
aVAnd create proper declarations and a mapping
p22555
aVThen you can  these functions, passing along a memory region suitably aligned and sized for  (possibly 'ed) and a  pointing to the C string data for initialization
p22556
as(dp22557
g15
V34509
p22558
stp22559
a((dp22560
g2
(lp22561
VIt's a GCC extension made by Apple, and implemented also in Clang
p22562
aVBlocks are small unnamed functions and that syntax is the type of a block
p22563
aVSee Block Language Spec
p22564
as(dp22565
g15
V34509
p22566
stp22567
a((dp22568
g2
(lp22569
VYou can do this currently (there is no reason to, though)
p22570
aVBut you cannot do this anymore with C++0x
p22571
aVThey removed the deprecated conversion of a string literal (which has the type ) to a
p22572
aVNote that this conversion is only for string literals
p22573
aVThus the following two things are illegal, the first of which specifies an array and the second of which specifies a pointer for initialization
p22574
aVGCC incorrectly accepts both, Clang correctly rejects both
p22575
as(dp22576
g15
V34509
p22577
stp22578
a((dp22579
g2
(lp22580
VC++ has nice classes to animate what is going on at the bit level
p22581
as(dp22582
g15
V34509
p22583
stp22584
a((dp22585
g2
(lp22586
VI have done it this way, like some other people did
p22587
aVHave a function  /  /  / etc that could look like this
p22588
aVThis will return a temporary builder object, whose class is basically defined like
p22589
aVSo if you are building a log message in a loop, be it so
p22590
aVAs soon as the builder's destructor is called automatically, the message is emitted
p22591
aVMostly you would use it anonymously
p22592
as(dp22593
g15
V34509
p22594
stp22595
a((dp22596
g2
(lp22597
V must promise it does not change the value of the object by making it a const member function
p22598
as(dp22599
g15
V34509
p22600
stp22601
a((dp22602
g2
(lp22603
VIn C++, a  is a class
p22604
aVAn  is a class too
p22605
aVIf a non-union class can derive from another non-union classes, structs can derive from other non-struct/non-union classes, and non-union/non-struct classes can derive from structs
p22606
as(dp22607
g15
V34509
p22608
stp22609
a((dp22610
g2
(lp22611
VAccording to the Standard, GCC is correct and Clang is wrong
p22612
aVIt says at 11
p22613
aV2/4
p22614
aVA member m is accessible when named in class N if
p22615
aVm as a member of N is protected, and the reference occurs in a member or friend of class N, or in a member or friend of a class P derived from N, where m as a member of P is private or protected
p22616
aVThis is subject of this Clang bugreport, which prevents Clang from building Qt: http://llvm
p22617
aVorg/bugs/show_bug
p22618
aVcgi
p22619
aVid=6840
p22620
aVOne Clang guy says
p22621
aVActually, I intentionally haven't implemented this rule yet
p22622
aVIt is either a
p22623
aVdrafting error or a horrible mistake
p22624
aVIt neuters the entire 'protected'
p22625
aVspecifier, it makes the well-formedness of code dependent on the
p22626
aVexistence of completely unrelated classes, it imposes high costs on the
p22627
aVimplementation, and it's formally undecidable in the presence of templates
p22628
as(dp22629
g15
V34509
p22630
stp22631
a((dp22632
g2
(lp22633
V10x30:
p22634
aV15x20:
p22635
aVResizing to 20x25:
p22636
aVThe outer dimension (10, 15, 20) can be determined at runtime, because it's not need as part of index calculations by the compiler
p22637
aVThe inner dimension (30, 20, 25) needs to be known at compile time
p22638
aVHope it helps
p22639
aVNote that unlike the array-of-pointer solutions, this one can be handled as a single block of memory, because it allocates everything in a single chunk of memory like a real declared array:
p22640
aVIt ultimately depends on your usecase, though
p22641
aVSince some people have difficulties understanding the actions taken by an index operation to , let's what Clang gives us for an index expression in the following code
p22642
aVIt's a nice compiler, which can print its AST in an easily readable manner
p22643
aVNote that each array subscript expression takes a pointer, adds the value of the index, and yields the addressed element
p22644
aVIf that subelement is an array, it is decayed to a pointer to its first element
p22645
aVThis is really not actually different than the steps done for a declared array
p22646
aVYields a very similar AST, with just the most inner expression first being decayed to a pointer to its first element
p22647
as(dp22648
g15
V34509
p22649
stp22650
a((dp22651
g2
(lp22652
VYou are not explicitly specializing a member function
p22653
aVBut you are defining the member function of an explicit (class template-) specialization
p22654
aVThat's different, and you need to define it like
p22655
aVNote that the "inline" is important, because this is not a template and it is not implicitly inline if it is defined outside the class
p22656
aVIt's needed to be inline to avoid duplicate linker symbols if you include the header into more than one translation unit
p22657
aVWould you have a template in your explicit specialization, your syntax would have to be used:
p22658
aVYou also have an error in your first code
p22659
aVYou need to define the out of class definition like this, without "typename" in the argument list of the class template
p22660
as(dp22661
g15
V34509
p22662
stp22663
a((dp22664
g2
(lp22665
VC++ allows multidimensional arrays to be iterated entirely through by a base-element pointer
p22666
aVSo you can use  and pass it the very first nonarray element
p22667
aVIn C this is formally not allowed, and you would need to iterate through each sub-array separately, because iterating beyond the first subarray's past-the-end pointer causes undefined behavior in C
p22668
aVNontheless, in practice this still works
p22669
as(dp22670
g15
V34509
p22671
stp22672
a((dp22673
g2
(lp22674
VDeclare a namespace scope , so that you can also have a convertible operand on the left hand side that is not of type
p22675
aVNeedless to say that you should remove the in-class one then, and you need a converting constructor to take the
p22676
as(dp22677
g15
V34509
p22678
stp22679
a((dp22680
g2
(lp22681
VPlease read a C++ template tutorial on how to give a template multiple parameters
p22682
aVInstead of
p22683
aVThe way it is done is
p22684
aVMultiple template clauses represent multiple levels of templates (class template -> member template)
p22685
as(dp22686
g15
V34509
p22687
stp22688
a((dp22689
g2
(lp22690
VNo, that won't work
p22691
aVThere is also no way to use SFINAE in such a way (this was last discussed on usenet for a compatibility test against some C++0x component)
p22692
aVThe C inside  is not related to the template parameter at all
p22693
aVRemember that templates are not just macros
p22694
aVThe parameter  denotes not just a piece of text, but a semantical entity
p22695
aVIn this case it is a type
p22696
aVIt's bound already to the meaning it has as an argument
p22697
aVThat is, if your class had a member of name , the meaning of the parameter still would not change
p22698
aVIf all you want is to use some struct  if it exists, and  otherwise, you can do some tricks to get there, but I'm not aware of a way that does it without touching
p22699
aVNow if you say  and  contains a member declared so, it will refer to that member (that member will hide the one in
p22700
aVHowever if it doesn't contain that member, then the using directive's name will be found and refer to
p22701
as(dp22702
g15
V34509
p22703
stp22704
a((dp22705
g2
(lp22706
Van object declared in a function is created when its definition is encountered and destroyed when its name goes out of scope
p22707
aVThis can easily be disproven for local statics:
p22708
aVNote that the scope of a name is a static, compile time concept
p22709
aVBut lifetime of an object is a runtime concept
p22710
aVSo you can entirely get a refer to to an already destroyed object
p22711
aVIt's not possible for the compiler to protect you from this at compile time
p22712
aVIn case that the storage duration that object was assigned stopped at this point too, you cannot do anything anymore with your variable, because memory is not guaranteed to exist anymore
p22713
aVStorage duration for automatic variables lasts only until the exit of its block
p22714
aVSometimes an object ends lifetime, but the storage that object was allocated on still exists
p22715
aVThis is true if you manually call a class's destructor or for the active member of an union if you write to the other member
p22716
aVThe destruction time is important for RAII to work
p22717
aVLet's take an example where we lock a mutex
p22718
as(dp22719
g15
V34509
p22720
stp22721
a((dp22722
g2
(lp22723
VC++03's categories are too restricted to capture the introduction of rvalue references correctly into expression attributes
p22724
aVWith the introduction of them, it was said that an unnamed rvalue reference evaluates to an rvalue, such that overload resolution would prefer rvalue reference bindings, which would make it select move constructors over copy constructors
p22725
aVBut it was found that this causes problems all around, for example with Dynamic Types and with qualifications
p22726
aVTo show this, consider
p22727
aVOn pre-xvalue drafts, this was allowed, because in C++03, rvalues of non-class types are never cv-qualified
p22728
aVBut it is intended that  applies in the rvalue-reference case, because here we do refer to objects (= memory
p22729
aV, and dropping const from non-class rvalues is mainly for the reason that there is no object around
p22730
aVThe issue for dynamic types is of similar nature
p22731
aVIn C++03, rvalues of class type have a known dynamic type - it's the static type of that expression
p22732
aVBecause to have it another way, you need references or dereferences, which evaluate to an lvalue
p22733
aVThat isn't true with unnamed rvalue references, yet they can show polymorphic behavior
p22734
aVSo to solve it,
p22735
aVunnamed rvalue references become xvalues
p22736
aVThey can be qualified and potentially have their dynamic type different
p22737
aVThey do, like intended, prefer rvalue references during overloading, and won't bind to non-const lvalue references
p22738
aVWhat previously was an rvalue (literals, objects created by casts to non-reference types) now becomes an prvalue
p22739
aVThey have the same preference as xvalues during overloading
p22740
aVWhat previously was an lvalue stays an lvalue
p22741
aVAnd two groupings are done to capture those that can be qualified and can have different dynamic types (glvalues) and those where overloading prefers rvalue reference binding (rvalues)
p22742
as(dp22743
g15
V34509
p22744
stp22745
a((dp22746
g2
(lp22747
VThe Standard defines the places where a member name is in scope in certain parts of its members
p22748
aVSee :
p22749
aVThe potential scope of a name declared in a class consists not only of the declarative region following
p22750
aVthe name\u2019s declarator, but also of all function bodies, default arguments, and constructor ctor-
p22751
aVinitializers in that class (including such things in nested classes)
p22752
aVPotential scope" is the scope that the name has if it isn't hidden by any other name
p22753
aVNote that "following the name's declarator" is a not quite correct term, because some declarations are not declared using a declarator (nested class declarations, for example)
p22754
aVSo C++0x changed this to read
p22755
aVThe potential scope of a name declared in a class consists not only of the declarative region following
p22756
aVthe name\u2019s point of declaration, [
p22757
aVAnother guy quoted another part of the Standard (), that requires the class type to be regarded as complete at certain parts
p22758
aVThis allows you to create objects of your class within member function bodies, for example
p22759
as(dp22760
g15
V34509
p22761
stp22762
a((dp22763
g2
(lp22764
VNonono this cannot work
p22765
aVBecause  has a templated constructor to accept any and all types
p22766
aVCompatibility with the call signature is checked later on
p22767
aVOverload resolution cannot resolve this
p22768
aVAlso, i think you want to pass  instead of
p22769
aVTry converting explicitly:
p22770
aVThis is utterly ugly though so you may want to introduce a typedef
p22771
aVOr ultimately you could make  a template that accepts just any callable type
p22772
aVI suspect that may be the simplest, because in the general case i suspect you don't know to what  you need to cast to
p22773
aVAnd how about folks that want to return a
p22774
aVSo
p22775
aVHope this helps
p22776
as(dp22777
g15
V34509
p22778
stp22779
a((dp22780
g2
(lp22781
VThis is because the argument type,  is not a derived class of : The arguments of  have for their base class's second template argument passed the type  (which is ) but the 's function parameter specifies  as second template argument
p22782
aVSince with these many types in there it's quite convoluted, let's make a simplier example
p22783
aVNow, let's see how these behave
p22784
aVThe C++ Standard specifies that derived->base conversions are considered when matching a deduced function parameter type
p22785
aVThat's why  works: The operator is defined in terms of  even though  really could be an  (derived class of it)
p22786
aVThis applies in your first case
p22787
aVBut in your second case you try to deduce a parameter that's entirely not a base class of the argument passed
p22788
as(dp22789
g15
V34509
p22790
stp22791
a((dp22792
g2
(lp22793
VThis is ill-formed by the Standard, but no diagnostic is required
p22794
aVMSVC is fine not diagnosing this particular case (even when instantiation happens
p22795
aVMore specifically, the (C++03) Standard rules at 14
p22796
aV6/7
p22797
aVIf a type used in a non-dependent name is incomplete at the point at which a template is defined but is complete at the point at which an instantiation is done, and if the completeness of that type affects whether or not the program is well-formed or affects the semantics of the program, the program is ill-formed; no diagnostic is required
p22798
aVSo the solution is to just make the type dependent, but arrange it that during instantiation, that type is designated
p22799
aVFor example, you can do that by rewriting your template like this
p22800
as(dp22801
g15
V34509
p22802
stp22803
a((dp22804
g2
(lp22805
VThe Standard says at
p22806
aVA class template specialization is implicitly instantiated if the class type is used in a context that requires a completely-defined object type or if the completeness of the class type affects the semantics of the program; in particular, if an expression whose type is a class template specialization is involved in overload resolution, pointer conversion, pointer to member conversion, the class template specialization is implicitly instantiated (3
p22807
aV2);
p22808
aVNote that Vandervoorde made an issue report here, and the committee found
p22809
aVThe standard already specifies that this creates a point of instantiation
p22810
aVFor your second case - you need to consider the associated classes and namespaces of the argument
p22811
aVThese are, since this is a pointer to a class template specialization (note that "template-id" below is not quite correct - C++0x corrected that to use the correct term) and also a pointer to a class (this confusing split was also corrected in C++0x - it lists these two cases in one bullet point)
p22812
aVIf T is a template-id, its associated namespaces and classes are the namespace in which the template is
p22813
aVdefined; [
p22814
aVlots of noise
p22815
aVIf T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes
p22816
aVIts associated namespaces are the namespaces in which its associated classes are defined
p22817
aVSo to summary, we have as associated classes are  and the associated namespaces are the global namespace
p22818
aVNow the friend functions that are visible are
p22819
aVAny namespace-scope friend functions declared in associated classes are visible within their respective namespaces even if they are not visible during an ordinary lookup
p22820
aVThere is no friend function declared in  so the friend function declaration is not visible when looking into the global namespace
p22821
aVNote that  is an entirely different class-type than
p22822
aVThe implicit instantiation of  you do there has no effect on this call - it just adds a non-visible name into the global namespace that refers to a friend function of class
p22823
as(dp22824
g15
V34509
p22825
stp22826
a((dp22827
g2
(lp22828
VPointer to members can be useful for intrusive lists
p22829
as(dp22830
g15
V34509
p22831
stp22832
a((dp22833
g2
(lp22834
VYou are correct
p22835
aVThis is not possible to do (as far as I know)
p22836
aVYour member declaration causes an implicit instantiation before the explicit specialization was declared
p22837
aVBut how would you want to declare it
p22838
aVYou cannot do that in class scope
p22839
aVOthers have felt that this is an ugly restriction
p22840
aVYou could work around this by making the class member a pointer
p22841
aVThis would not need to implicitly instantiate the class at that point, but rather at the point where you create the object in the end
p22842
aVI realize that this is an ugly work around
p22843
aVSo better find other ways to do this
p22844
aVFor instance partial specializations are allowed in class scope
p22845
aVSo you could add a dummy template parameter, then you can specialize this in the class before the member declaration
p22846
aVLikewise, i find this ugly, but it would not disturb things that much, I feel
p22847
as(dp22848
g15
V34509
p22849
stp22850
a((dp22851
g2
(lp22852
VThere is no maximum size
p22853
aVA data type has a size, and it remains constant in that implementation
p22854
aVYou can get it by
p22855
aVIf you ask for the maximal number representable by a data type, then for unsigned types you can just do
p22856
aVThis is useful if you just use an unsigned typedef ( etc) and don't know the exact underlying type name
p22857
aVFor signed types, this won't work
p22858
aVThere are macros for this though (including the unsigned variants)
p22859
as(dp22860
g15
V34509
p22861
stp22862
a((dp22863
g2
(lp22864
VI really can't see why it would not work, but it's actually a pretty ugly solution
p22865
aVJust take  and be without those issues present in C++03 binders
p22866
as(dp22867
g15
V34509
p22868
stp22869
a((dp22870
g2
(lp22871
VIt's not only a bad solution, it's a non-solution
p22872
aVYou can't index over an array's bounds
p22873
aVIf you do, you have a non-solvable problem with regard to achieving a correct C++ program
p22874
aVWhat you might see on common C++ implementations is that sometimes  is put into the stack directly after
p22875
aVSo if you over-index and then write, you may modify  and then any assumption on the value of  that is based purely on direct writes to it isn't correct anymore because there is a write to it by that over-index operation
p22876
aVIf you now make it  the variable then is allocated in some other section of the program (usually the  for 0-initialized and  for otherwise initialized data), the count variable on common implementations won't be allocated  next to the array anymore and this will cause another incident to happen: Instead of overwriting  you may then be overwriting whatever is then next to the array
p22877
as(dp22878
g15
V34509
p22879
stp22880
a((dp22881
g2
(lp22882
VFor the following, you need a copy constructor
p22883
aVIt does not use the assignment operator function
p22884
aVEdit
p22885
aVFor the linker error - I can't help you with that
p22886
aVRather than guessing at what  that line calls, I will just give up on this because you haven't provided the code
p22887
aVIn normal C++ code, there is no way that a simple  would cause a linker error
p22888
aVhas an operator that accepts a  for this
p22889
aVYou have declared an operator somewhere that provides a better match but did not define it
p22890
as(dp22891
g15
V34509
p22892
stp22893
a((dp22894
g2
(lp22895
VIn C++0x this is guaranteed to work
p22896
aVHowever in C++03 this wasn't working (the initializer part, that is) and some compilers apparently don't support it yet
p22897
aVFurthermore, I remember that the C++0x wording is not clear what happens with  when it is an argument to a function template and the corresponding parameter is deduced (this is what  is translated to, conceptionally)
p22898
aVThe intention is, however, that it is valid
p22899
aVSee this defect report where they designed the wording, the example by "Nico Josuttis" and their final example
p22900
aVThere is another rule that the wording enforces but compilers are not correctly implementing
p22901
aVFor example, see this clang PR
p22902
as(dp22903
g15
V34509
p22904
stp22905
a((dp22906
g2
(lp22907
VThe numerical values of digit characters are required to be next to each other
p22908
aVSo this works everywhere and always
p22909
aVNo matter what character-set your compiler uses
p22910
as(dp22911
g15
V34509
p22912
stp22913
a((dp22914
g2
(lp22915
VFirst you need to do a floating point division
p22916
aVThen you need to have space for  variables on  or use
p22917
as(dp22918
g15
V34509
p22919
stp22920
a((dp22921
g2
(lp22922
VHuh
p22923
aVYou don't need to prefix it with the enumeration name
p22924
aVThat's only needed for C++0x  scoped enumerations
p22925
as(dp22926
g15
V34509
p22927
stp22928
a((dp22929
g2
(lp22930
VWhy would one do this
p22931
aVBecause the compiler only knows names that have been declared
p22932
aVSo if you want to use a class, you have to declare it
p22933
aVBut if its definition depends on its user, a forward declaration can suffice if the user doesn't depend on the definitin of the class in turn, but just on its declaration (= name)
p22934
aVIn particular, if the user just needs a pointer or referece, it doesn't depend on the definition
p22935
aVBut in the cases listed (which do not claim to be exclusive, since it's a standard non-normative excerpt), the user depends on the definition of class T if
p22936
aVan object of type T is de\ufb01ned (3
p22937
aV1), or
p22938
aVT is used as the object type or array element type in a new-expression (5
p22939
ag1037
aV4), or
p22940
aVan lvalue-to-rvalue conversion is applied to a lvalue referring to an object of type T (4
p22941
aV1), or
p22942
aVan expression is converted (either implicitly or explicitly) to type T (Clause 4, 5
p22943
ag976
aV3, 5
p22944
ag976
aV7, 5
p22945
ag976
aV9, 5
p22946
aV4),
p22947
aVor
p22948
aVan expression that is not a null pointer constant, and has type other than void*, is converted to the
p22949
aVtype pointer to T or reference to T using an implicit conversion (Clause 4), a dynamic_cast (5
p22950
ag976
aV7) or
p22951
aVa static_cast (5
p22952
ag976
aV9), or
p22953
aVa class member access operator is applied to an expression of type T (5
p22954
ag976
aV5), or
p22955
aVthe typeid operator (5
p22956
ag976
aV8) or the sizeof operator (5
p22957
ag1037
aV3) is applied to an operand of type T, or
p22958
aVa function with a return type or argument type of type T is de\ufb01ned (3
p22959
aV1) or called (5
p22960
ag976
aV2), or
p22961
aVa class with a base class of type T is de\ufb01ned (Clause 10), or
p22962
aVan lvalue of type T is assigned to (5
p22963
aV17), or
p22964
aVan exception-declaration has type T, reference to T, or pointer to T (15
p22965
aV3)
p22966
aVIn these cases, a forward declaration will not suffice and you need to fully define it
p22967
aVIs it needed
p22968
aVYes, in the cases where it is needed it is needed
p22969
aVIn the following case it is, because both classes refer to each other
p22970
aVThe member function definition required not only a declaration but also the definition of class A
p22971
aVWhat are the benefits
p22972
aVDrawbacks
p22973
aVThe benefits are that your program compiles
p22974
aVThe drawback is that you have polluted the scope with just another name
p22975
aVBut that's the necessary evil of it
p22976
as(dp22977
g15
V34509
p22978
stp22979
a((dp22980
g2
(lp22981
VThe moment you do that, behavior is undefined
p22982
aVNote that removing volatile from an expression that really refers to a non-volatile variable and removing volatile from an expression that refers to a volatile variable are different
p22983
aVThe latter thing is what you asked about, and it causes undefined behavior
p22984
aVThe Standard laws
p22985
aVIf an attempt is made to refer to an object defined with a volatile-qualified type through the use of an lvalue with a non-volatile-qualified type, the program behaviour is undefined
p22986
as(dp22987
g15
V34509
p22988
stp22989
a((dp22990
g2
(lp22991
VFaster: printf
p22992
aVMore typesafe and extensible: cout
p22993
aVBetter: depends
p22994
aVI like  more
p22995
aVI'm not alone in thinking that the way C++'s cout does formatting is just epic fail
p22996
as(dp22997
g15
V34509
p22998
stp22999
a((dp23000
g2
(lp23001
VYes
p23002
aVYou can initialize them to all-0 by value-initializing the array
p23003
aVBut in fact I would prefer to use  and  like some commenter said, unless you need that struct to really be byte-compatible with some interface that doesn't understand highlevel structures
p23004
aVIf you do need this simplistic design, then you can still initialize on the stack and copy over
p23005
aVFor example to "initialize" the first element
p23006
aVNote that in C++0x you can say
p23007
as(dp23008
g15
V34509
p23009
stp23010
a((dp23011
g2
(lp23012
VIs your misunderstanding that you think you have created a pointer to an array of  int
p23013
aVYou haven't
p23014
aVYou actually have created an array of  pointers to int
p23015
aVSo there is no "second pointer" here that would point to an array
p23016
aVThere is just one pointer that points to the first of the 7 pointers ()
p23017
aVAnd with  you get that first pointer which you haven't initialized yet, though
p23018
aVIf you would add  to that, you would add  to some random address
p23019
aVBut if you add  to  you get a pointer that points to the second pointer of the array
p23020
aVAnd dererencing that you get that second pointer, which you did initialize
p23021
aVWhat you describe would be achieved by a different syntax
p23022
aVWithout using the typedef, this looks like the following
p23023
aVThat is, you have created a one-element array, where the element-type of that is a 7-element array of int
p23024
aVgives you a pointer back to that array
p23025
aVNote that the parenthesis is important: The  has less precedence than the , so otherwise this would be taken as an array of 7 pointer to integers
p23026
as(dp23027
g15
V34509
p23028
stp23029
a((dp23030
g2
(lp23031
VYou need to take this by const reference
p23032
aVIt does not make sense to accept a temporary conversion result by a non-const reference
p23033
aVChanges to that parameter will just be lost afterwards
p23034
aVMaking it work by having it be a const reference is easy, so Standard C++ just forbids it
p23035
as(dp23036
g15
V34509
p23037
stp23038
a((dp23039
g2
(lp23040
VTo restate what I said in those little comment boxes
p23041
aVIn particular, I was never talking about inlin-ing:
p23042
aVNow, both TU1 and TU2 have their own copy of  - the code of  is in the executable two times
p23043
aVBoth TUs will emit specially marked versions of  that are effectively merged by the linker by discarding all but one of them
p23044
aVThe code of  only exists one time in the executable
p23045
aVThus we have saved space in the executable
p23046
as(dp23047
g15
V34509
p23048
stp23049
a((dp23050
g2
(lp23051
VYou can use these macros to work-around this in a Standard conforming manner
p23052
aVSo your for-loop becomes
p23053
aVCredit goes to Conditional Love: FOREACH Redux, by Eric Niebler
p23054
aVNot sure whether this is really worth it though :)
p23055
as(dp23056
g15
V34509
p23057
stp23058
a((dp23059
g2
(lp23060
VYou could use  and just specialize  handling
p23061
aVNo need to duplicate the whole template
p23062
as(dp23063
g15
V34509
p23064
stp23065
a((dp23066
g2
(lp23067
VFor sticking into an array if the arguments have different types, you can use also
p23068
aVSo for example,  creates an array of
p23069
as(dp23070
g15
V34509
p23071
stp23072
a((dp23073
g2
(lp23074
VYou are going to have an overload resolution that prefers the first  for the first case
p23075
aVIt accepts both arguments by an exact match, while the second  needs a derived to base conversion to accept arguments
p23076
aVAs you have subsequently figured out (by experimentation
p23077
aV, if you use  as argument types, instead of derived classes, this won't need a derived to base conversion anymore, and overload resolution will then prefer the second template because otherwise both are equally well accepting the arguments but the second template (In your own solution) is more specialized
p23078
aVYet in your own solution, you need to put a  before the return type to make the solution Standard C++
p23079
aVI think the problem that causes you to need to define a second template is that in order to make the template more specialized, the first min  needs to accept all the arguments that the second template accepts, which is figured out by just trying to match second template's arguments against first
p23080
aVSo, the different template parameter types try to deduce to the same template parameter, which will cause a conflict and make the first template not successfully deduce all argument of the second template
p23081
aVFor your own solution, this won't be the case:
p23082
aVThis will make the first template deduce all the parameter types from the second template, but not the other way around:  won't match an arbitrary
p23083
aVSo your own solution's template is more specialized and is called, and then explicitly forwards to the other template
p23084
aVFinally note that your own solution only accepts containers where the third template argument is the same, while your other  template accepts containers where that argument can be different for both function arguments
p23085
aVI'm not sure whether that's on purpose - but given the other  function in place which conflicts if you won't make the third argument types the same as shown above, I'm not sure how to otherwise fix that
p23086
aVQuestioner subsequently edited his own answer , so most of my references above to "your own answer" don't apply anymore
p23087
as(dp23088
g15
V34509
p23089
stp23090
a((dp23091
g2
(lp23092
VI have only heard people use the term "deferred instantiation" to refer to the situation where a class member definition is instantiated only if it is used
p23093
aVIn this case,  is implicitly instantiated because the compiler needs to know its size (formally, the class type needs to be complete, so an instantiation is triggered)
p23094
aVBut the instantiation of its member definitions are deferred until they are actually used
p23095
aVThis does not only apply to member functions, but also to static data members and nested classes
p23096
aVNow even if you implicitly instantiate  the message won't be printed until you explicitly refer to  and use it
p23097
aVExplicit instantiation won't defer instantiation of member definitions - so the following will always print the message
p23098
aVThere is a trick to trigger instantiation of member definitions for implicit instantiations though: Refer to them in declaration parts of a class' member, like in the following changed class template
p23099
aVNow if  is implicitly instantiated the message is printed, because the typedef declaration refers to it
p23100
as(dp23101
g15
V34509
p23102
stp23103
a((dp23104
g2
(lp23105
VI think the general expansion of this is
p23106
aVThis could be written as follows
p23107
as(dp23108
g15
V34509
p23109
stp23110
a((dp23111
g2
(lp23112
VPotatoswatter found an error in my conclusions
p23113
aVC++ explicitly allows an implementation to explicitly define an assignment operator "with the same apparent semantics"
p23114
aVThis will make it a non-trivially copyable type
p23115
aVMaking it community wiki
p23116
aVIt seems to me you don't want to test against PODnes, but against trivially copyable, which is way less restricting
p23117
aVBecause that is how C++0x constraints types that can be used with  and friends
p23118
aVAnd while I don't think there are any guarantees about PODness of , there are guarantees about trivial copyability, as the following shows (if I haven't got an error in the conclusions)
p23119
aVAs we know  is an aggregate, and aggregates are
p23120
aVAn aggregate is an array or a class (Clause 9) with no user-provided constructors (12
p23121
aV1), no brace-or-equal-
p23122
aVinitializers for non-static data members (9
p23123
aV2), no private or protected non-static data members (Clause 11),
p23124
aVno base classes (Clause 10), and no virtual functions (10
p23125
aV3)
p23126
aVWhile trivially copyability is defined for a class that has class that
p23127
aVhas no non-trivial copy constructors (12
p23128
aV8),
p23129
aVhas no non-trivial move constructors (12
p23130
aV8),
p23131
aVhas no non-trivial copy assignment operators (13
p23132
ag1014
aV3, 12
p23133
aV8),
p23134
aVhas no non-trivial move assignment operators (13
p23135
ag1014
aV3, 12
p23136
aV8), and
p23137
aVhas a trivial destructor (12
p23138
aV4)
p23139
aVhas no destructor (as a comment in the definition of  says)
p23140
aVThis does not seem to follow from the definition of aggregate classes though, even though the comment in 's class definition claims that
p23141
aVThe remaining 4 requirements follow from the absence of bases, virtual functions and user provided versions for those 4 special member functions for aggregates
p23142
as(dp23143
g15
V34509
p23144
stp23145
a((dp23146
g2
(lp23147
VConsider a  which inherits from
p23148
aVYou would like that your type would support all the  operators that are defined for  normally in the std namespace
p23149
aVSo base classes are associated classes for ADL
p23150
aVI think this also follows from the substitution principle - and functions in a class' namespace are considered part of its interface (see Herb Sutter's "What's in a class
p23151
aVSo an interface that works on the base class should remain working on a derived class
p23152
aVYou can also work around this by disabling ADL:
p23153
as(dp23154
g15
V34509
p23155
stp23156
a((dp23157
g2
(lp23158
V is also a template in C++ which accepts a templated character and also a locale with which it uses the facet  to classify the given character (so it can't make up its mind what version to take, and as such ignores the template)
p23159
aVTry specifying that you mean the C compatibility version:
p23160
aVThe differences between the compilers could come from the inconsistent handling of deduction from an overloaded function name among the compilers - see this clang PR
p23161
aVSee the second case in Faisal's first set of testcases for an analogous case
p23162
aVSomeone pointed out on IRC that this code would call  using a  - but  takes  and requires the value given to be in the range of  values or
p23163
aVNow in case that  is signed on your PC and stores a negative non-EOF value, this will yield to undefined behavior
p23164
aVI recommend to do it like @Kirill says in a comment and just use the templated  - then you can get rid of the function object argument too
p23165
as(dp23166
g15
V34509
p23167
stp23168
a((dp23169
g2
(lp23170
VYou can use  instead:
p23171
aVNote that  applied on a reference type is a no-op
p23172
aVSo if  is , then saying  does not yield back  but  again
p23173
aVSo if your source items are constant you would try to bind them to the non-const reference parameter of  in case that  is a reference:
p23174
as(dp23175
g15
V34509
p23176
stp23177
a((dp23178
g2
(lp23179
VYou can make it accept a metafunction and you can apply any transformation you like
p23180
aVOr accept a metafunction class to get more flexibility (including the ability to make  have default arguments not known to your  and such
p23181
as(dp23182
g15
V34509
p23183
stp23184
a((dp23185
g2
(lp23186
VEither add a using declaration like the other answers show or make a call using a qualified name
p23187
as(dp23188
g15
V34509
p23189
stp23190
a((dp23191
g2
(lp23192
VSome examples for each:
p23193
aVInfix:
p23194
aVPostfix:
p23195
aVPrefix (also called "unary" in C and C++):
p23196
as(dp23197
g15
V34509
p23198
stp23199
a((dp23200
g2
(lp23201
VThis is not specific to lambdas at all
p23202
aVYou need to tell the compiler what version of the template you want to call:
p23203
aVIt doesn't matter whether you use them or not
p23204
aVIt's like unused function parameters:
p23205
as(dp23206
g15
V34509
p23207
stp23208
a((dp23209
g2
(lp23210
VNote: The two defect reports DR#637 and DR#222 are important to understand the below's behavior rationale
p23211
aVFor explanation, in C++0x there are  and
p23212
aVA side effect for example is an assigment, and a value computation is determining what an lvalue refers to or reading the value out of an lvalue
p23213
aVNote that C++0x has no sequence points anymore and this stuff is worded in terms of "sequenced before" / "sequenced after"
p23214
aVAnd it is stated that
p23215
aVIf a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined
p23216
aVis equivalent to  which is equivalent to  (except that v is only evaluated once)
p23217
aVThis yields to  which I will write as , where  refers to the lvalue result of
p23218
aVIn C++0x  is not undefined behavior because for  the assignment is sequenced after value computation of b and a, but before value computation of the assignment expression
p23219
aVIt follows that the asignment in  is sequenced before value computation of
p23220
aVAnd the assignment in  is sequenced after value computation of
p23221
aVIn the end, both assignments will thus be sequenced, and there is no undefined behavior
p23222
as(dp23223
g15
V34509
p23224
stp23225
a((dp23226
g2
(lp23227
VUse :
p23228
aVThen call it like
p23229
as(dp23230
g15
V34509
p23231
stp23232
a((dp23233
g2
(lp23234
VI personally can see no benefit from specializing a function template
p23235
aVOverloading it by either a different function template or a non-template function is arguably superior because its handling is more intuitive and it's overall more powerful (effectively by overloading the template, you have a partial specialization of the template, even though technically it's called partial ordering)
p23236
aVHerb Sutter has written an article Why not specialize function templates
p23237
aVwhere he discourages specializing function templates in favour of either overloading them or writing them so that they just forward to a class template's static function and specializing the class template instead
p23238
as(dp23239
g15
V34509
p23240
stp23241
a((dp23242
g2
(lp23243
VNo, that's not possible to do in C++
p23244
as(dp23245
g15
V34509
p23246
stp23247
a((dp23248
g2
(lp23249
VYes,  knows the value type that it currently stores
p23250
aVIt allows visitation and calls the correct overloaded
p23251
aVuses a fundamental different technique and can't tell you what it currently stores
p23252
as(dp23253
g15
V34509
p23254
stp23255
a((dp23256
g2
(lp23257
VSince when you instantiate you get a class, that function is like an ordinary member function
p23258
aVIt's defined in that class, so the function is automatically inline
p23259
aVBut it does not really matter here that much
p23260
aVYou can define function templates or members of class templates multiple times in a program anyway - you don't need  to tell the compiler about that like in the non-template case
p23261
as(dp23262
g15
V34509
p23263
stp23264
a((dp23265
g2
(lp23266
VSometimes you need it to explicitly have type , like in the following case
p23267
as(dp23268
g15
V34509
p23269
stp23270
a((dp23271
g2
(lp23272
VSo, not only must the general specialization not conflict with the array specialization, it can't conflict with any  specialization that names a user-defined type
p23273
aVThat is, if the user declares a specialization, the existence of the general argument getter cannot affect whether it's chosen
p23274
aVI don't understand this
p23275
aVWhat do you mean
p23276
aVIs it OK for the implementation to expose a general template indexer through std::tuple_element
p23277
aVIt's impossible to do so for the general case
p23278
aVImagine this one
p23279
aVHappy macro meta-programming :)
p23280
aVI haven't made many forays into the partial ordering rules
p23281
aVIs this analysis correct
p23282
aVPartial ordering for two partial specializations
p23283
aVWorks like transforming them to function templates and ordering them
p23284
aVPartial ordering like your analysis says correctly puts unique types for each template parameter transforming it to an argument for argument deduction, comparing it to the other template
p23285
aVIf there is a non-deduced context it's not compared like usual
p23286
aVLike if  is , the first deduction above would consider deduction of the last sub-type as success because there can't be a mismatch for a nondeduced context
p23287
aVThe other way around though,  against  can mismatch though if  is not a nondeduced context itself
p23288
aVIf deduction succeeds for one round and not the other way around (
p23289
aVleaving off some other rules because they only happen for real function template ordering), the template on the right side above for the round that failed deduction is more specialized
p23290
aVOtherwise, the partial specializations are unordered
p23291
as(dp23292
g15
V34509
p23293
stp23294
a((dp23295
g2
(lp23296
VIf you always calloc exactly  array, you can only index the array pointer with  anyway
p23297
aVWhat's the reason for not taking  then and omitting the one index step
p23298
aVI don't really see the whole purpose of this
p23299
as(dp23300
g15
V34509
p23301
stp23302
a((dp23303
g2
(lp23304
VIt is "possible" in some sense (if your goal was that the derived class stays abstract otherwise)
p23305
aVBut it won't give the result you would like: Because the compiler will create a destructor itself implicitly if the programmer hasn't done so
p23306
aVIt's therefor not possible to force the derived class' author to explicitly declare a constructor
p23307
aV(edit: Like @chubsdad notes noted, the error in your particular code is because you need to define the explicitly declared destructor of the base class)
p23308
aVEdit: Just for fun, there are situations that necessiate an explicitly declared constructor
p23309
aVConsider the following
p23310
aVThis code won't compile because the implicitly declared  will have an exception specification  which is looser than what  has - so it violates the requirement that overriders shall not have a looser exception specification
p23311
aVYou will need to explicitly declare the destructor appropriately
p23312
aVBut this is not really a solution to your problem, because derived classes need to "cooperate" into either deriving from  or putting it as a non-static data member
p23313
aVIt's also very ugly :)
p23314
aVEdit: The following seems to be a Standard conforming way to do it
p23315
aVClang and GCC (starting with v4
p23316
aV6) reject any derived class of  that has an implicitly declared destructor, because it has an incompatible exception specification (any derived class shall call  directly, instead of indirectly by calling , the Standard says)
p23317
aVComeau accepts this, but I strongly suspect that it is non-conforming in this regard
p23318
as(dp23319
g15
V34509
p23320
stp23321
a((dp23322
g2
(lp23323
VAre you realizing that "C++ is slower than C
p23324
aVis meant to be a myth, so it actually says "C++ is not slower than C
p23325
aVThat one comment to that answer isn't really serious
p23326
aVIs it true that C++ is slower than C
p23327
aVIf not, why to use C anyway
p23328
aVIs it true that a Ferrari is slower than a Ford
p23329
aVIf not, why to use a Ford anyway
p23330
as(dp23331
g15
V34509
p23332
stp23333
a((dp23334
g2
(lp23335
VYour returning of  is not legal, because the compound literal is going to emit an automatic array, and you are returning a pointer to an automatic array which is destroyed if control flow leaves that function
p23336
aVYou get a dangling pointer
p23337
aVIt's also a C99 feature, so your code is really C++/C99 :)
p23338
aVThe second problem that the compiler detects at compile time is the array initialization
p23339
aVHere, brace elision applies
p23340
aVBecause a  cannot initialize a , the compiler assumes brace elision and tries to initialize the first member of  using that
p23341
aVThis will not work either and that is reflected by the error message
p23342
aVYou are going to have to fill that array yourself at runtime using some sort of loop or you are going to have to specify the initial values in the array initialization similar to how you do it in the  statement
p23343
aVSince you are using C++ and C99, why not combine the power and use
p23344
aVBeware that the  semantics between C++ and C99 differ
p23345
aVBetter be sure what semantics apply to your program
p23346
as(dp23347
g15
V34509
p23348
stp23349
a((dp23350
g2
(lp23351
VYou can just accept the arguments by the variadic template and let typechecking check the validity later on when they are converted
p23352
aVYou can check convertibility on the function interface level though, to make use of overload resolution for rejecting outright wrong arguments for example, by using SFINAE
p23353
aVFor your use-case if you know the steps to go from an  to your  then you have already solved it though according to the first option above ("convert-later"):
p23354
aVIf you combine this with the above  approach you have a reject-early template that also does overload resolution on arguments and rejects them if not applicable
p23355
as(dp23356
g15
V34509
p23357
stp23358
a((dp23359
g2
(lp23360
VThere is no explicit instantiation in your code
p23361
aVThere is no order of initialization of instantiated static data members among other static data members
p23362
aVSo your code has effectively undefined behavior: Depending on whether the compiler first initializes the map or , the reference to the map is valid or not
p23363
aVSee C++ Static member initialization
p23364
as(dp23365
g15
V34509
p23366
stp23367
a((dp23368
g2
(lp23369
VThe Standard says
p23370
aVThe explicit instantiation of a class template specialization implies the instantiation of all of its members not previously explicitly specialized in the translation unit containing the explicit instantiation
p23371
aVIn other words, it does not mandate that base classes are explicitly instantiated in turn
p23372
aVIt will cause an implicit instantiation of them which will not instantiate their member definitions up-front
p23373
aVIt's some ugly glitch in the Standard as to whether some text when it says "member" means "direct" or "inherited" member, as that often seems to be "obvious" to the one who wrote the Standards wording, but not to the one who reads it
p23374
aVC++0x has added some clarifications (it also has a difference between explicit instantiation declarations and definitions that C++03 doesn't have, but even ignoring that, the C++0x wording contains some more bits of insight):
p23375
aVAn explicit instantiation that names a class template specialization is also an explicit instantiation of the
p23376
aVsame kind (declaration or de\ufb01nition) of each of its members (not including members inherited from base
p23377
aVclasses) that has not been previously explicitly specialized in the translation unit containing the explicit
p23378
aVinstantiation, except as described below
p23379
aV[ Note: In addition, it will typically be an explicit instantiation of
p23380
aVcertain implementation-dependent data about the class
p23381
aV\u2014 end note ]
p23382
as(dp23383
g15
V34509
p23384
stp23385
a((dp23386
g2
(lp23387
VIt's entirely possible
p23388
aVTry for example
p23389
aVWhere  is something like
p23390
as(dp23391
g15
V34509
p23392
stp23393
a((dp23394
g2
(lp23395
VYou don't need any complicated code
p23396
as(dp23397
g15
V34509
p23398
stp23399
a((dp23400
g2
(lp23401
VYour code has several errors:
p23402
aVYou try to hide the template parameter  by an inner declaration of that name
p23403
aVYou use  intead of
p23404
aVWhat @potatoswatter says
p23405
as(dp23406
g15
V34509
p23407
stp23408
a((dp23409
g2
(lp23410
VI think that's pretty sane
p23411
aVJust pass a function object and save it since it seems you need to recall it later (otherwise why not pass the pointer directly and create the object before
p23412
as(dp23413
g15
V34509
p23414
stp23415
a((dp23416
g2
(lp23417
VOr you can use the boost libraries and functions like
p23418
as(dp23419
g15
V34509
p23420
stp23421
a((dp23422
g2
(lp23423
VThe second in the first struct is not a pointer, but a FAM - flexible array member
p23424
aVIt is used when you have a long buffer and place an  at the start of that buffer
p23425
aVYou can then index the remaining memory that follow the  object using that FAM and treat that memory as an array of
p23426
aVThe Standard says (emphasis by me)
p23427
aVAs a special case, the last element of a structure with more than one named member may
p23428
aVhave an incomplete array type; this is called a flexible array member
p23429
aVIn most situations,
p23430
aVthe \ufb02exible array member is ignored
p23431
aVIn particular, the size of the structure is as if the
p23432
aVflexible array member were omitted except that it may have more trailing padding than
p23433
aVthe omission would imply
p23434
aVFor example, the following code outputs  for the struct without, but  for the struct with the FAM on GCC, because to access integers the FAM need to be properly aligned (on a 4 byte boundary in this example)
p23435
as(dp23436
g15
V34509
p23437
stp23438
a((dp23439
g2
(lp23440
VNo  call needed - the streams close itself when they are open when they are destroyed
p23441
aVAlso, the  there looks suspicious
p23442
aVis called only once, so it doesn't have any effect here (apart from pedantic standardese differences that don't matter here, i think
p23443
aVDefinitely not in the case shown)
p23444
aVThat said, you can just call  if a stream is not opened -  will return a null pointer if it wasn't open
p23445
aV(I was looking at the spec for  - the file streams's  returns )
p23446
aVFile-streams can also handle non-open streams: If the stream wasn't open, it sets the
p23447
aVYou can check for that using  (which tests whehter the failbit or badbit is set)
p23448
aVBut there is  anyway to test whether the stream is open, but you don't need it for the above reasons
p23449
as(dp23450
g15
V34509
p23451
stp23452
a((dp23453
g2
(lp23454
VIs it important to declare a variable as unsigned if you know it should never be negative
p23455
aVCertainly it is not important
p23456
aVSome people (Stroustrup and Scott Meyers, see "Unsigned vs signed - Is Bjarne mistaken
p23457
aVreject the idea that a variable should be unsigned just because it represents an unsigned quantity
p23458
aVIf the point of using  would be to indicate that a variable can only store non-negative values, you need to somehow check that
p23459
aVOtherwise, all you get is
p23460
aVA type that silently hides errors because it doesn't let negative values to expose
p23461
aVDouble of the positive range of the corresponding signed type
p23462
aVDefined overflow/bit-shift/etc semantics
p23463
aVCertainly it doesn't prevent people from supplying negative values to your function, and the compiler won't be able to warn you about any such cases (think about a negative runtime based int-value being passed)
p23464
aVWhy not assert in the function instead
p23465
aVThe unsigned type introduces many pitfalls too
p23466
aVYou have to be careful when you use it in calculations that can temporary be less than zero (down counting loop, or something) and especially the automatic promotions that happen in the C and C++ languages among unsigned and signed values
p23467
as(dp23468
g15
V34509
p23469
stp23470
a((dp23471
g2
(lp23472
VAn implementation is allowed to accept the above as a syntactically ill-formed template definition and not diagnose it until it's actually instantiated
p23473
aVHope this explains it
p23474
aV(Of course I'm kidding, but I'm not entirely unserious
p23475
aVIt shows a flaw of the above quoted text: There is no "template definition" that can contain ";+;")
p23476
aVThe other thing about incomplete types says the following is ill-formed but no diagnostic is required
p23477
aVThe "no diagnostic required" rules in the Standard grants an implementation to behave in any way it sees fit (this makes any program that violates a rule for which no diagnostic is required to have effectively undefined behavior)
p23478
aVAs a result, the text you quoted really is (IMHO) badly lawyered
p23479
aVSee Confused about ill-formed templates and Compiling C++ templates as opposed to preprocessing them (with Digital Mars fame Walter Bright)
p23480
as(dp23481
g15
V34509
p23482
stp23483
a((dp23484
g2
(lp23485
VAs has been said, order of destructor calls is the exact reverse of order of completion of constructors ()
p23486
aVIn other words (), stop of lifetime of an object of static storage duration is the reverse of start of lifetime of an object of static storage duration
p23487
aVSo it all comes down to when their constructors are called
p23488
aVSuppose that  is a type that outputs something in its constructor in the following examples
p23489
aVNamespace scope
p23490
aVObjects of namespace scope (global and user defined) are in any case created before the first use of any function or variable that is defined in the same translation unit that the object is defined in ()
p23491
aVThis deferred initialization (after main was called) must respect the order of definition with respect to other object definitions in the same translation unit of that objects's definition
p23492
aV()
p23493
aVTranslation unit 1:
p23494
aVTranslation unit 2:
p23495
aVIf we use , this will not necessarily force creation of , because f is not defined in the translation unit where  was defined in
p23496
aVis created after  because it's defined later
p23497
aVBlock scope
p23498
aVObjects of block scope (local statics) are created when control passes through their definition first or when their block is first entered for PODs ()
p23499
aVStarting lifetime is tried again the next time control passes throgh it if creation couldn't successfully succeed (in case of an exception) ()
p23500
aVThis snippet outputs "XAP"
p23501
aVClass scope
p23502
aVFor static data members, the same rule applies about order of initialization according to their definition order within the same translation unit ()
p23503
aVThis is because the rule for that is formulated as "objects defined in namespace scope
p23504
aVrather than "objects of namespace scope
p23505
aVIn C++03 deferred initialization (delaying the construction until a variable/function is used from its translation unit) was only allowed for objects of namespace scope, which was not intended
p23506
aVC++0x allows this also for static data members ("non-local variable with static storage duration")
p23507
aVThus by taking the above rules and taking into account that destruction order is actually determined by completion of constructors rather than by the start of them, we will get to the order
p23508
aVIf  throws an exception, C++0x says that  is called, and you end up having  destroyed and having ended lifetime of  without completing its destructor if it threw the exception
p23509
aVI can't find anything in the C++03 Standard specifying this
p23510
aVIt seems to only specifies that for non-local statics and not also for block-scope statics like C++0x does
p23511
as(dp23512
g15
V34509
p23513
stp23514
a((dp23515
g2
(lp23516
VThe folks here that say that values are always converted to the larger type are wrong
p23517
aVWe cannot talk about anything if we don't know your platform (I see you have provided some information now)
p23518
aVSome examples
p23519
aVint = 32bits, uint16_t = unsigned short, int8_t = signed char
p23520
aVThis results in value  because both operands are converted to , and the operation is carried out signed and the signed result is written to an
p23521
aVint = 16bits, uint16_t = unsigned int, int8_t = signed char
p23522
aVThis results in value 63036 because the  operand is first converted to , resulting in
p23523
aVIt is then multiplied with it, resulting in  (unsigned is modulo arithmetic) which is 63036
p23524
aVThat result is then written to
p23525
aVNotice that the minimum  bit-size is  bits
p23526
aVSo on your 8-bit platform, this second scenario is what likely happens
p23527
aVI'm not going to try and explain the rules here because it doesn't make sense to me to repeat what is written in the Standard / Draft (which is freely available) in great detail and which is usually easily understandable
p23528
as(dp23529
g15
V34509
p23530
stp23531
a((dp23532
g2
(lp23533
VYou can just use a C-style cast
p23534
aVNo need for any "hacks" or "implementations"
p23535
aVWrapping it into an explicit function serves the "C-Style casts are bad" people
p23536
aVTo have the cast safe, you need to ensure that  is actually a private or public base
p23537
aVThis is done by
p23538
aVOf course you should prefer member functions in the respective derived class that return the base pointer, instead of doing such a cast
p23539
aVDefining public casting operator does not work
p23540
aVThat doesn't make sense to me
p23541
aVWhy make the base class private at all then
p23542
aVJust make it public
p23543
aVThe reason your conversion functions don't work is because the Standard requires that implicit conversions never consider conversion functions to a base class, the class itself or
p23544
as(dp23545
g15
V34509
p23546
stp23547
a((dp23548
g2
(lp23549
VThe code is valid according to the Standard - see this Standard rule, which I did not have in mind when I answered before
p23550
aVA member m is accessible when named in class N if
p23551
ag7695
aV, or
p23552
aVthere exists a base class B of N that is accessible at the point of reference, and m is accessible when
p23553
aVnamed in class B
p23554
aVThis entirely applies to your code, and thus the access is valid
p23555
aVIt appears the main purpose of this rule is for allowing friend declarations of the base to apply to inherited members, but it also applies to this case
p23556
aV(Disregard the parts of this that say the code is invalid - It's valid as explained above
p23557
aVThis part is an old version of my answer, kept here to serve as background information)
p23558
aVNo, this code is invalid
p23559
aVThat's why the equivalent "access-declarations" are called that way (these are deprecated though)
p23560
aVThese are called "access-declarations" precisely because they can change the access
p23561
aVIn your example the naming class is  and  as a member of  is private because the using-declaration did change the access level of the name
p23562
as(dp23563
g15
V34509
p23564
stp23565
a((dp23566
g2
(lp23567
VOne way to ensure uniqe ids is to abuse friend function definitions
p23568
as(dp23569
g15
V34509
p23570
stp23571
a((dp23572
g2
(lp23573
VBecause  is mangled in the binary with the class name  in it, so multiple classes could have a function  in them and not conflict
p23574
aVIt's not got the same mangled name as  is going to have
p23575
aVI remember that with an earlier version of MSVC, it accepted the following without a linker error which ended up accidentally as a result of macro expansion in my code base once
p23576
aVIt apparently treated the name  specially and didn't mangle it or mangle it the same as
p23577
aVBut such a thing is not Standard conformant
p23578
aVLike in the class case, such a function is completely unrelated to the main function
p23579
as(dp23580
g15
V34509
p23581
stp23582
a((dp23583
g2
(lp23584
VYou want
p23585
as(dp23586
g15
V34509
p23587
stp23588
a((dp23589
g2
(lp23590
V in a constructor just yields the constructor's class (you had it  but that's wrong anyway since it will just give you the type_info of a pointer)
p23591
aVThat's considered the dynamic type of the object during construction
p23592
aVAnother difference there is that virtual functions called during construction won't end up in the derived class, but in the class where the call is made during construction
p23593
as(dp23594
g15
V34509
p23595
stp23596
a((dp23597
g2
(lp23598
VThis is part of a defect
p23599
aVWhile C++03 did provide , it did not provide the necessary rules to say that the name declared by the using declaration is a type-name
p23600
aVIt just provided the instrument to say that the name referenced in the using declaration is a type-name
p23601
aVSo you can do in fact the following, but with varying success among compilers
p23602
aVSome will make it work, but some won't
p23603
aVThis issue has been fixed for C++0x
p23604
aVFor C++03, the way to work around it is to use a  instead
p23605
as(dp23606
g15
V34509
p23607
stp23608
a((dp23609
g2
(lp23610
VYes that reasoning is valid
p23611
aVPut it on the right of all '*'es that are not within function parameter lists and on the left of all []'es that are not in function parameter lists
p23612
aVThen you have
p23613
aVThen read it as usual
p23614
aVFrom thereon and even how to find the correct place for the name, there are many tutorials how to parse this on the internet
p23615
aVFor C++, you may want to look into geordi
p23616
aVYou can then do analysis on the syntax of it
p23617
aVIt lets you mix C with English
p23618
aVAs you see, it's pretty powerful
p23619
as(dp23620
g15
V34509
p23621
stp23622
a((dp23623
g2
(lp23624
VYes you need both versions
p23625
aVBut you can forward the one to the other, if the operation really is commutative
p23626
as(dp23627
g15
V34509
p23628
stp23629
a((dp23630
g2
(lp23631
VNo, you cannot do this reliably in C++03, because the constructor of  takes references to , and creating a reference to a reference is not legal in C++03
p23632
aVNotice that I said "reliably"
p23633
aVSome common compilers still in use (for GCC, I tested GCC4
p23634
aV1, @Charles reported GCC4
p23635
ag2670
aV4) do not allow forming a reference to a reference, but more recently do allow it as they implement reference collapsing ( is  if  is a reference type)
p23636
aVIf your code uses such things, you cannot rely on it to work on other compilers until you try it and see
p23637
aVIt sounds like you want to use
p23638
as(dp23639
g15
V34509
p23640
stp23641
a((dp23642
g2
(lp23643
VIs it posible to use the type of a prefiously declared function as a function pointer without using a typedef
p23644
aVI'm going to cheat a bit
p23645
aVOf course, this is not completely without pitfalls: It uses the function, so it must be defined, whereas such things as  do not use the function and do not require the function to be defined
p23646
as(dp23647
g15
V34509
p23648
stp23649
a((dp23650
g2
(lp23651
VIn C++03, it was not legal to do the following
p23652
aVThis frequently causes problems for people compiling with really strict or older C++03 compilers  (GCC4
p23653
aV1 as well as Comeau 8/4/03 do not like the above) because the Standard function object binders do not take care of the "reference to reference" situation, and occasionally create such illegal types
p23654
aVIn C++0x this is called "reference collapsing", yes
p23655
aVMost current C++03 compilers do that (i
p23656
aVe a  where  denotes a reference type is  again), by retroactively applying the rule
p23657
aVThe boost
p23658
aVcall_traits library makes it easy to declare such function parameters though, so that the "reference to reference" situation does not occur
p23659
aVPlease note that the  there does not have any effect
p23660
aVA  applied on a reference type is silently ignored
p23661
aVSo even if the compiler supports reference collapsing, the following is not legal
p23662
as(dp23663
g15
V34509
p23664
stp23665
a((dp23666
g2
(lp23667
VThis will not work because  is a non-deduced context
p23668
aVMeans that  and  cannot be deduced, likewise for the other parameter
p23669
aVThis is because before the compiler can deduce , it has to know what type  is a member of, but to know that, it has to deduce
p23670
aVYou can put this function as a friend function template into  and make it work as long as both are members of the same template
p23671
aVBut last time I checked, GCC did not find friend functions defined in class templates
p23672
aVYou could also declare some member typedef in  that specifies the type of the outer class, and formulate  in terms of that, so that SFINAE can sort it out for non-members
p23673
aVOf course you don't need that  thing if you don't need to access the  types, like in the above
p23674
aVIn such a case you are better off just accepting  and have less to write
p23675
aVThe SFINAE will still make sure only the right thing is accepted
p23676
as(dp23677
g15
V34509
p23678
stp23679
a((dp23680
g2
(lp23681
VBecause this would not be a useful utility
p23682
aVSince they are not of the allowed form of a template argument, it currently does not work
p23683
aVLet's assume they work
p23684
aVBecause they are not required to have the same address for the same value used, you will get different instantiations even though you have the same string literal value in your code
p23685
aVYou could write a plugin for your text editor that replaces a string by a comma separated list of character literals and back
p23686
aVWith variadic templates, you could "solve" that problem this way, in some way
p23687
as(dp23688
g15
V34509
p23689
stp23690
a((dp23691
g2
(lp23692
VThe compiler is free to optimize your code out because  is not a volatile object
p23693
aVThe Standard only requires a compiler to strictly adhere to semantics for volatile objects
p23694
aVHere is what C++03 says
p23695
aVThe least requirements on a conforming implementation are:
p23696
aVAt sequence points, volatile objects are stable in the sense that previous evaluations are complete and
p23697
aVsubsequent evaluations have not yet occurred
p23698
ag7695
aVand
p23699
aVThe observable behavior of the abstract machine is its sequence of reads and writes to volatile data and
p23700
aVcalls to library I/O functions
p23701
aVIn your example, what you have are reads and writes using volatile lvalues to non-volatile objects
p23702
aVC++0x removed the second text I quoted above, because it's redundant
p23703
aVC++0x just says
p23704
aVThe least requirements on a conforming implementation are:
p23705
aVAccess to volatile objects are evaluated strictly according to the rules of the abstract machine
p23706
ag7695
aVThese collectively are referred to as the observable behavior of the program
p23707
aVWhile one may argue that "volatile data" could maybe mean "data accessed by volatile lvalues", which would still be quite a stretch, the C++0x wording removed all doubts about your code and clearly allows implementations to optimize it away
p23708
aVBut as people pointed out to me, It probably does not matter in practice
p23709
aVA compiler that optimizes such a thing will most probably go against the programmers intention (why would someone have a pointer to volatile otherwise) and so would probably contain a bug
p23710
aVStill, I have experienced compiler vendors that cited these paragraphs when they were faced with bugreports about their over-aggressive optimizations
p23711
aVIn the end,  is inherent platform specific and you are supposed to double check the result anyway
p23712
as(dp23713
g15
V34509
p23714
stp23715
a((dp23716
g2
(lp23717
VIn addition to the points others made, notice that sometimes the compiler couldn't make up his mind and both interpretations can yield alternative valid programs when instantiating
p23718
aVThis prints  when omitting  before  but  when inserting it
p23719
aVI leave it as an exercise to figure out what the code does
p23720
as(dp23721
g15
V34509
p23722
stp23723
a((dp23724
g2
(lp23725
VWith the new C++0x wording, an expression can either be an lvalue, xvalue or prvalue
p23726
aVThe first two are summed as glvalue and the latter two as rvalue
p23727
aVThe C++0x text says prvalue, not rvalue
p23728
aVSince neither "not lvalue" nor "rvalue" will say definitely what it is
p23729
as(dp23730
g15
V34509
p23731
stp23732
a((dp23733
g2
(lp23734
VThere is no way to work this around
p23735
aVAn expression , where  names a reference, always has the type the reference refers to
p23736
aVNo expression ever has type
p23737
aVSo you cannot detect whether an expression originated from a reference or not
p23738
aVThis cannot be done with C++0x either
p23739
aVIt's a deep principle of C++ that there are no expressions that have reference type
p23740
aVYou can write  to get the type of what  names instead of what type the expression  has
p23741
aVBut you will not be able to write , unless  is a macro of course, but I don't see why you would go that horrible road
p23742
as(dp23743
g15
V34509
p23744
stp23745
a((dp23746
g2
(lp23747
VYes,  is dependent so  is not found
p23748
aVIn C++03 this was clearified by the addition  (which did not exist in C++98) and in C++0x this is directly stated by  (n3126)
p23749
aVDependency of it is important, because the following is possible
p23750
as(dp23751
g15
V34509
p23752
stp23753
a((dp23754
g2
(lp23755
VMake life a bit simplier and use typedefs
p23756
aVOr equivalent
p23757
aVI doubt you know what the following means, but suffice it to say it's equivalent too
p23758
aVNote that based on type, it is not a "a pointer to a two dimension array of void*", much like  is not a "pointer to a one dimension array of char*"
p23759
aVBut keeping the way you do it in the one-dimension case (pointing to the first element), this is the declaration you need
p23760
as(dp23761
g15
V34509
p23762
stp23763
a((dp23764
g2
(lp23765
VSomeone has recommended a constructor parameter, which I second
p23766
aVBut you can still do it as originally desired
p23767
aVBut notice that the property that determines the type-identity of  is not the value of , but the address/identity of it
p23768
aVThat is, the following does not work because  denotes a different type
p23769
aVAs such, an enumeration may be better suited for this
p23770
aVOr even a traits class with static member functions, similar to a solution someone else had
p23771
as(dp23772
g15
V34509
p23773
stp23774
a((dp23775
g2
(lp23776
VI deeply believe that a picture is worth a thousand words
p23777
aVTake the following example
p23778
aVSo in the above,  points to the first integer in the sequence of N integers
p23779
aVAnd  points to a pointer that the caller will have the pointer to the found integer stored in
p23780
aVis used to pass the address of  to the function
p23781
aVThis address has type , because it's the address of a pointer to int
p23782
as(dp23783
g15
V34509
p23784
stp23785
a((dp23786
g2
(lp23787
VA declarator-id is the syntactical element that specifies the name in a simple-declaration ("type name;")
p23788
aVIn the following "A" and "B::C" is the declarator-id
p23789
aVA type-id syntactically is roughly a simple-declaration where the declarator-id is missing
p23790
aVA type-id is used as the syntactical element in a template type argument and in a cast
p23791
aVA template-name is the name of a template
p23792
aVSyntactically it appears before a template-argument list
p23793
aVThe above quote misuses "template-name" and "declarator-id", because a template-name is a plain identifier and does not contain any qualifiers
p23794
aVC++0x has changed the text to
p23795
aVIn a function template declaration, the last component of the declarator-id shall be a template-name or operator-function-id (i
p23796
ag1992
aV, not a template-id)
p23797
aV(The last part appears in cases such as )
p23798
aVEven the C++0x text misses some cases - see this defect report
p23799
aVThe misuse of "declarator-id" happens in the note
p23800
aVThe note was replaced by C++0x with
p23801
aV[ Note: in a class template declaration, if the class name is a
p23802
aV\u2014 end note ]
p23803
aVIn class template declarations, the name specified syntactically is a class-name instead of a declarator-id
p23804
aVThe relation of class-name and declarator-id is as follows (very simplified
p23805
aVIn class template declarations, there may not be a declarator-id specified
p23806
aVA template-id is a template-name followed by a template-argument list
p23807
aVThe quote means that in a function template declaration, the name must not be a template-id
p23808
aVIn your example you declare a function instead of a template
p23809
aVThere are still cases where an explicit specialization declares a template, though
p23810
aVBut that can only happen for member function templates
p23811
as(dp23812
g15
V34509
p23813
stp23814
a((dp23815
g2
(lp23816
VYou can use
p23817
aVIt has a plain native array inside, so it still has the same memory layout like in your example
p23818
aVIf you don't have boost you can create your own  class or use  if your compiler has it
p23819
aVThat's all you need, but you can add the usual , ,  functions and so on to make it more comfortable to use
p23820
as(dp23821
g15
V34509
p23822
stp23823
a((dp23824
g2
(lp23825
VFor a name to be looked up in a dependent base class, two conditions need to be satisfied
p23826
aVIt's necessary that the lookup is not unqualified
p23827
aVIt's necessary that the name is dependent
p23828
aVThese rules as stated in C++03 are different from the rules stated by unrevised C++98, where satisfying the second bullet (making a name dependent) was sufficient for finding names declared in dependent base classes
p23829
aVA dependent name is looked up at instantiation time and a lookup other than unqualified lookup will not ignore dependent base classes
p23830
aVBoth of these conditions need to be satisfied to find a name declared in a dependent base class, neither of them alone is sufficient
p23831
aVTo satisfy both conditions you can use various constructs
p23832
aVBoth names  are dependent and the first version uses class member access lookup and the second version uses qualified name lookup
p23833
as(dp23834
g15
V34509
p23835
stp23836
a((dp23837
g2
(lp23838
VYou can forward declare
p23839
aVTemplates, including partial specializations
p23840
aVExplicit specializations
p23841
aVNested classes (this includes structs, "real" classes and unions)
p23842
aVNon-nested and local classes
p23843
aVVariables ("extern int a;")
p23844
aVFunctions
p23845
aVIf by "forward declaration" you strictly mean "declare but not define" you can also forward declare member functions
p23846
aVBut you cannot redeclare them in their class definition once they are declared
p23847
aVYou cannot forward-declare enumerations
p23848
aVI'm not sure whether I missed something
p23849
aVPlease note that all forward declarations listed above, except partial and explicit specializations, need to be declared using an unqualified name and that member functions and nested classes can only be declared-but-not-defined in their class definition
p23850
as(dp23851
g15
V34509
p23852
stp23853
a((dp23854
g2
(lp23855
VYou can reduce that to this
p23856
aVYou try to add an unsigned int to a string
p23857
aVThat does not make sense, and the  class does not need to take any precautions to add implicit conversions to  here because that would hide such potential programming bugs
p23858
aVTry to convert the unsigned int to  into a decimal/hexadecimal/octal/etc form and then concatenate (you can do that using  or ) or fix the bug in other ways you see fit
p23859
as(dp23860
g15
V34509
p23861
stp23862
a((dp23863
g2
(lp23864
VUse forward declarations
p23865
aVYou don't need to make any data member a pointer
p23866
aVThere is no "recursive infinite size" in the above code snippet
p23867
aVIndependent of this, it still looks like a good idea to make that  a pointer
p23868
aVBecause it does not seem to be required to have a submenu, is it
p23869
aVSo you should use a pointer since otherwise that member will always be a menu and needs to be initialized
p23870
aVA pointer can be left uninitialized or as a null pointer
p23871
aVYou might also want to use  instead
p23872
as(dp23873
g15
V34509
p23874
stp23875
a((dp23876
g2
(lp23877
VYou are not correct
p23878
aVThe object is not default-initialized but value-initialized
p23879
aVAnd its value is well-defined
p23880
aVNote that zero is in the range of values for any enumeration, even if it doesn't contain an explicit enumerator with that vaue, so it's safe to initialize an enumeration variable to that value
p23881
aVIn particular for pointer to data members, the representation used in practice is not all-zero bits
p23882
aVIn the so-called C++ Itanium ABI used by at least GCC and Clang, pointer to data members have an all-one bits null representation
p23883
as(dp23884
g15
V34509
p23885
stp23886
a((dp23887
g2
(lp23888
VSome use the latter term to describe what's being done when you defined an own global  or
p23889
aVThat's because your own definition can replace the default version in the library
p23890
aVThe C++ Standard uses the words replaces and displaces for this
p23891
aVUsing "override" is a bit confusing because that term is already used for virtual functions being overridden by a function in a derived class
p23892
aVThe term "overloading" is the general term used for defining your own operator functions
p23893
aVThis term is used even if no actual overloading happens by the operator function
p23894
aVOne way to approach this term is because it "overloads" the built-in meaning of certain operators
p23895
as(dp23896
g15
V34509
p23897
stp23898
a((dp23899
g2
(lp23900
VI think the whole point of  is that you use it inconsistently among names
p23901
aVNames you need very frequently in some block can be declared locally with a using declaration, while others are not
p23902
aVI don't see a problem with that
p23903
aVDeclaring a name to have namespace scope is always much harder to take
p23904
aVI think if the name clearly is known to belong to a particular namespace so that confusing it with other namespaces won't occur, It won't hurt to put a using declaration if it makes your code more readable
p23905
as(dp23906
g15
V34509
p23907
stp23908
a((dp23909
g2
(lp23910
VHere is one which even appears in the Standard: Declaring a using directive to denote a namespace
p23911
aVAfterwards you can open the namespace other times and add to it, and the using directive makes the stuff visible to the outer namespace
p23912
as(dp23913
g15
V34509
p23914
stp23915
a((dp23916
g2
(lp23917
VYou can do it but you won't like it
p23918
aVThis will only allow null pointer constants
p23919
aVIn other words, zero compile time values
p23920
as(dp23921
g15
V34509
p23922
stp23923
a((dp23924
g2
(lp23925
VYou can make the  a template too
p23926
aVThen you can pass
p23927
aVFor passing arguments like in  I recommend using , so you could also work with non-default constructible
p23928
as(dp23929
g15
V34509
p23930
stp23931
a((dp23932
g2
(lp23933
VI find this quite mind-screwing, and the committee has more such fun
p23934
aVSo I think it's likely I have some errors in the below
p23935
aVSo please read it with care :)
p23936
aVThird paragraph
p23937
aVFor a class template specialization, a class member template specialization, or a specialization for a class member of a class template, if the specialization is implicitly instantiated because it is referenced from within another template specialization, if the context from which the specialization is referenced depends on a template parameter, and if the specialization is not instantiated previous to the instantiation of the enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing template
p23938
aVIn other words, if a class template or a nested class of a class template is instantiated, and the context that causes that instantiation depends on a template parameter, the template/nested class is instantiated immediately before the point of instantiation of the template that refers to it
p23939
aVThe context in the other specialization can either depend on template parameters, which is the case for primary templates, partial specializations and members of a class template, or it does not depend on template parameters, which is the case for references from within explicit specializations
p23940
aVOtherwise [i
p23941
ag1992
aVthe context is nondependent], the point of
p23942
aVinstantiation for such a specialization immediately precedes the namespace scope declaration or definition that refers to the specialization
p23943
aVThis distinction is important
p23944
aVConsider what would happen if the point of instantiation for specializations from dependent contexts would preceede immediately to the namespace scope declaration or definition that refers to it
p23945
aVThis template is supposed to add  pointer declarators
p23946
aVSo  is  for example
p23947
aVThe context around  is non-dependent, so  is instantiated before the typedef declaration
p23948
aVWithin , we have , which appears in a dependent context and which references
p23949
aVSo the Standard requires us to instantiate  at the same point we instantiated
p23950
aVIf we would instantiate this immediately before the namespace scope declaration that referred to it (before the primary template definition), we would not notice the partial specialization  when processing  within  because we would instantiate  before that specialization
p23951
aVSecond paragraph
p23952
aVThis is just so that names looked up in default arguments are consistent with names looked up in the rest of the function that they are used for (i
p23953
aVe their POI is the same as the POI of their function template / member function of class template)
p23954
aVFirst paragraph
p23955
aVThis is basically the same as the third paragraph
p23956
aVHowever, function templates are instantiated after the entity that refer to them so that recursive uses are possible, like in the following example
p23957
aVIn contrast, class templates are instantiated before the entity that refer to them because the entity required that class type to be complete
p23958
aVIf the class type's POI would be after that entity, the class type would still be non-existent
p23959
aVIf  would be instantiated before , then it could not access  because at that point it did not exist yet
p23960
aVTherefor, function templates are instantiated after the entity that refer to them, and class templates are instantiated before the entity that refer to them
p23961
as(dp23962
g15
V34509
p23963
stp23964
a((dp23965
g2
(lp23966
VSomething like this should suffice
p23967
as(dp23968
g15
V34509
p23969
stp23970
a((dp23971
g2
(lp23972
VI have the C Draft Standard here, and it makes it undefined by omission
p23973
aVIt defines the case of  at 6
p23974
ag1014
aV6/8 for
p23975
aVIf the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression
p23976
aVMoreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object
p23977
aVYour case does not fit any of these
p23978
aVNeither is your array large enough to have  adjust the pointer to point to a different array element, nor does any of the result or original pointer point one-past-end
p23979
as(dp23980
g15
V34509
p23981
stp23982
a((dp23983
g2
(lp23984
VThis is not a puzzle
p23985
aVIt's an invalid piece of code since it assigned a  to a
p23986
aVActually the problem happens in the array declaration
p23987
aVhas type , but you declare  as an array of
p23988
as(dp23989
g15
V34509
p23990
stp23991
a((dp23992
g2
(lp23993
VYes just make the member a pointer
p23994
aVA reference won't be able to be reseated, and there is no work-around
p23995
aVEdit: @"Steve Jessop" makes a valid point to how work-around the problem using the PIMPL idiom (private implementation using a "d-pointer")
p23996
aVIn an assignment, you will delete the old implementation and create a new one copy-constructed from the source object's d-pointer
p23997
as(dp23998
g15
V34509
p23999
stp24000
a((dp24001
g2
(lp24002
VThis is not a declaration, because in , the  would be part of the decl-specifier-seq and forms a type-name therein
p24003
aVAnd then  can only be a function-declarator
p24004
aVThis requires that there is a declarator-id specified, which in your case is not
p24005
aVA special syntactical form is needed to allow such a syntax in declaring a constructor
p24006
aVBut such syntactical exceptions are not made in a declaration-statement
p24007
aVSo this construct cannot be a declaration
p24008
aVIt is parsed as an expression which specifies a functional cast creating a temporary of type
p24009
aVIf the compiler does not print Hello it is either non-conforming or you are not calling  in your program
p24010
aVYour edit also does not specify a declaration without a name
p24011
aVIt instead specifies a declaration that does have a name
p24012
aVIt declares a function that is called
p24013
aVThe compiler has no way that you meant something else by this
p24014
aVIt could in an effort deduce this by having a recovering rule when it later discovers errors in your code such as the following
p24015
aVIf you have this in your code to try and call a member function and "a" is a function, the compiler could check to see if  contains a member  such that this expression is well-formed
p24016
aVBut what if you just forgot to place parentheses
p24017
aVThe following would be valid for the above declared function that returns a , assuming a suitably declared member
p24018
aVSo in effect, the compiler can't really know what you mean
p24019
as(dp24020
g15
V34509
p24021
stp24022
a((dp24023
g2
(lp24024
VThe loop should be
p24025
aVOtherwise, the compiler will treat  as a non-type (at parse-time, it does not yet know what  is going to be later
p24026
aVand will likely parse it as the sole constituent of an expression
p24027
aVThe  that then follows is nonsense for the compiler so it expects a  before it
p24028
aVis used to tell the compiler that a certain qualified name is intended to denote a type instead of a value (function / static data member / etc)
p24029
aVThe second issue, which is solved by adding  is of similar kind
p24030
aVIt tells the compiler that  is a template and thus that  is not a comparison against , but the start of a template argument list
p24031
as(dp24032
g15
V34509
p24033
stp24034
a((dp24035
g2
(lp24036
V is actually
p24037
aVIt declares an object, and does not create a temporary
p24038
aVYou need to disambiguate the statement to be an expression statement
p24039
aVBut ultimately what you want to do is
p24040
aVBecause what you wrote would intend to create a temporary and passing  as a constructor parameter
p24041
aVWhat you actually need is to create an object by the default constructor and then invoke the function call operator as above
p24042
as(dp24043
g15
V34509
p24044
stp24045
a((dp24046
g2
(lp24047
VI don't see why this would be bad
p24048
aVI think I would rather name my member functions consistently with good names than to invent hard to remember artificial names to disambiguate them
p24049
aVSome coding guidelines are written such that this case cannot happen
p24050
aVBy forcing types to start with an upper-case letter and functions with a lower-case letter and such
p24051
aVYou should avoid calling your member functions according to common template names though
p24052
aVThe following program is ill-formed according to current C++ Standard, though some compilers tend (for the good) to ignore that error
p24053
aVClang and comeau give a warning
p24054
aVComeauTest
p24055
aVc", line 11: warning: ambiguous class member reference -- function
p24056
aVtemplate "A::vector" (declared at line 6) used in preference to
p24057
aVclass template "std::vector" (declared at line 163 of
p24058
aV"stl_vector
p24059
aVh")
p24060
aVa
p24061
aVvector(); // ill-formed
p24062
aV^
p24063
aVIt has been proposed to get rid of this
p24064
as(dp24065
g15
V34509
p24066
stp24067
a((dp24068
g2
(lp24069
VThe second version is specified to search first in an implementation defined location, and afterwards if the file is not found, search in the same place as the  version, which searches in the paths usually specified by the  command line option and by built-in include paths (pointing to the location of the standard library and system headers)
p24070
aVUsually, implementations define that location to be relative to the location of the including file
p24071
as(dp24072
g15
V34509
p24073
stp24074
a((dp24075
g2
(lp24076
VYes in some sense, but you need to move  into a parameter
p24077
aVThis is the conditional trick explored by Eric Niebler and explained here
p24078
aVyields an  object such that  is the cv-unqualified type of that expression
p24079
aVSo you can do
p24080
as(dp24081
g15
V34509
p24082
stp24083
a((dp24084
g2
(lp24085
VTwo bugs:
p24086
aVis not copyable (change the constructor parameter to a reference)
p24087
aVis equivalent to
p24088
aVThus the compiler tries to call the default constructor
p24089
aVWrap parens around it
p24090
aVOr just give it a name
p24091
aVAlso, what's wrong with using a function for this
p24092
aVOnly the class's constructor is used it seems, which you seem to abuse as a function returning
p24093
as(dp24094
g15
V34509
p24095
stp24096
a((dp24097
g2
(lp24098
V tries to access a private member of
p24099
aVYou should be able to fix it by making the conversion function a friend, but compilers I tried go havoc if you try
p24100
aVYou could also make any  a friend of  to fix this
p24101
as(dp24102
g15
V34509
p24103
stp24104
a((dp24105
g2
(lp24106
VThe names are mangled with their class name in them
p24107
aVAn example with the clang compiler
p24108
aVOutput
p24109
aVWhere  is
p24110
as(dp24111
g15
V34509
p24112
stp24113
a((dp24114
g2
(lp24115
VThe following is fine
p24116
aVAnd the following is fine too
p24117
aVBut the following is ambiguous
p24118
aVFor overload resolution (the process that tells what function to call), parameters that have not passed explicit arguments and that make use of default arguments are ignored
p24119
aVSo the compiler really sees two functions both having one int parameter for the above call and can't decide
p24120
aVThe following is ill-formed though
p24121
aVWhile for the code in your question you declare two functions (because both declarations have different number of parameters), in this example you only declare one function
p24122
aVBut the second declaration of it repeats a default argument for a parameter (and even with a different value, but that doesn't matter anymore)
p24123
aVThis is not allowed
p24124
aVNote that the following is fine
p24125
aVThe set of default arguments for declarations that appear in the same scope for the same function are merged, and only for those that appear in the same scope
p24126
aVSo the following is valid
p24127
aVThis calls the function with  passed for
p24128
as(dp24129
g15
V34509
p24130
stp24131
a((dp24132
g2
(lp24133
VNo, you cannot put it into  because
p24134
aVA lambda-expression shall not appear in an unevaluated operand
p24135
aVYou can do the following though
p24136
aVBut that is really ugly
p24137
aVNote that each lambda expression creates a new unique type
p24138
aVIf afterwards you do the following somewhere else,  has a different type than
p24139
aVYou can use  here, but note that this will incur a tiny bit of runtime cost because it needs an indirect call to the lambda function object call operator
p24140
aVIt's probably negligible here, but may be significant if you want to pass function objects this way to  for example
p24141
aVAs always, first code then profile :)
p24142
as(dp24143
g15
V34509
p24144
stp24145
a((dp24146
g2
(lp24147
VImagine the following
p24148
aVIf you say that  is an alias for another name - what name
p24149
aVA reference either references an object or function
p24150
aVWhen you say "glvalue", you refer to a property of a particular expression, not to a property of an object
p24151
aVNow,  is an lvalue expression and  is an lvalue expression too (both of the syntactic category )
p24152
aVThey name (as found by name-lookup) a reference and an  variable
p24153
aVIf you now determine the object identity for the  case, you need to take the reference and make the expression refer to the object it was initialized with
p24154
aVThis is called an lvalue evaluation because you determine the property of an lvalue (i
p24155
aVe the referent)
p24156
aVYou need to do the same for the  case
p24157
ag1388
aVe you figure out to what object the lvalue expression  refers to
p24158
aVA glvalue evaluation of  thus is different than glvalue evaluation of , despite both of them yielding the same result
p24159
aVRvalue evaluation means to take an lvalue and apply the lvalue to rvalue conversion
p24160
aVIn other words, to read a value
p24161
as(dp24162
g15
V34509
p24163
stp24164
a((dp24165
g2
(lp24166
VThis is because  returns a type that is a class template specialization which has one argument of type
p24167
aVThus when  is applied in the expression , argument dependent lookup looks also in the namespace of
p24168
aVIt finds your  and passes it the iterator and an
p24169
aVYou could fix it by not accepting any and all types as arguments
p24170
aVFor example, try accepting  instead
p24171
aVShow all your combinations, possibly there is a way to cut them down using another way to formulate them
p24172
aVIn my opinion, an implementation that acts that way should be non-conforming (I think this is really disgusting though)
p24173
aVBecause doing  is specified to yield another iterator to the previous element and must not do something crazy like that, I think
p24174
aVOne way for it is to declare operator as a non-template accepting the iterator type and the integer argument (which is of the iterator's ) directly
p24175
aVThis way their version should always be preferred
p24176
as(dp24177
g15
V34509
p24178
stp24179
a((dp24180
g2
(lp24181
VYou cannot observe the  here except for a few cases
p24182
aVTaking the address of
p24183
aVIn C++0x, directly calling  with the function-call syntax as a  operand, will yield
p24184
aVThis is because you return a pure pointer value, that is to say a pointer value not actually stored in a pointer variable
p24185
aVSuch values are not const qualified because they cannot be changed anyway
p24186
aVYou cannot say  even if you take away the
p24187
aVIn both cases, the expression  has
p24188
aVthe type  and is non-modifiable (someone will soon quote the Standard and come up with the term "rvalue")
p24189
aVSo in contexts you use the return value you won't be able to figure a difference
p24190
aVJust in cases you refer to the declaration or whole function itself you will notice the difference
p24191
aVThis is what you usually would do if the body would be something like
p24192
aVIt does not allow changing the int member by doing
p24193
aVThis is just the combination of the first two :)
p24194
as(dp24195
g15
V34509
p24196
stp24197
a((dp24198
g2
(lp24199
VIt means the implementation expects an object, but you just passed a value or function
p24200
aVThis happens for assignments you passed a non-lvalue or for address-of operations applied to non-functions
p24201
aVLvalue stands for "location value" and means an expression that refers to an object either declared as  or to a memory location
p24202
aVSomething like  is a value that matches neither criteria
p24203
aVMore formally there are three categories
p24204
aVLvalues: Referring to objects
p24205
aVThis includes objects declared const
p24206
aVSuch are non-modifiable lvalues
p24207
aVFunction designators: Referring to functions
p24208
aVis a function designator, but  is not, while  is again
p24209
aVOthers: Sometimes called "rvalue" and by the Standard described as "the value of an expression"
p24210
aVExamples are  (yielding a value not associated with objects anymore), or an enumerator of an enumeration
p24211
aVbelongs to this category
p24212
as(dp24213
g15
V34509
p24214
stp24215
a((dp24216
g2
(lp24217
VYou need to put it into 's enclosing namespace
p24218
aVNot as a member
p24219
aVOr as a member but then only specifying the right parameter
p24220
aVBut then  won't work anymore, because the left side is not a
p24221
aVSo it's advisable to write it as a non-member in 's namespace
p24222
aVNote that to be able to say  or the other way around or even writing , you also need to accept a  as a constructor parameter
p24223
aVOtherwise, a  won't be implicitly convertible to a  because that will require to first converting to  and then converting from that to
p24224
aVTwo such user defined conversions are not allowed in a single implicit conversion sequence
p24225
as(dp24226
g15
V34509
p24227
stp24228
a((dp24229
g2
(lp24230
VI put your code through Clang and got
p24231
as(dp24232
g15
V34509
p24233
stp24234
a((dp24235
g2
(lp24236
VWhat you could do is to return a proxy object
p24237
aVYou can resort to  or to something similar too
p24238
as(dp24239
g15
V34509
p24240
stp24241
a((dp24242
g2
(lp24243
VIt looks like a compiler bug to me
p24244
aVTo be sure, I put your code into  and instantiated , all working fine also with the comment chars removed
p24245
aVIt also works on GCC4
p24246
ag1014
aV1 and GCC4
p24247
ag1037
ag2670
as(dp24248
g15
V34509
p24249
stp24250
a((dp24251
g2
(lp24252
VOverview
p24253
aVSpecialization: The class, function or class template member you get when substituting template arguments into the template parameters of a class template or function template
p24254
aVInstantiation: The act of creating a specialization out of a template or class template member
p24255
aVThe specialization can be created out of a partial specializaton, class template member or out of a primary class or function template
p24256
aVAn explicit specialization is one that defines the class, function or member explicitly, without an instantiation
p24257
as(dp24258
g15
V34509
p24259
stp24260
a((dp24261
g2
(lp24262
VA string literal of N characters is an array of N constant characters with a terminating '\u005c0' afterwards
p24263
aVSo type of  is  and the one of  is
p24264
aVSo if you pass it to the template,  is deduced to two different types
p24265
aVNote that when in a reference parameter, template argument deduction does not transform arrays to pointers
p24266
aVAlso, please check up in comparing pointers to each other
p24267
aVThe way you do that won't ever compare the strings lexically, but just the addresses of them, yielding an unspecified value
p24268
aVYou can fix the argument deduction bit by having two separate template parameters
p24269
aVClang gives a good error message
p24270
as(dp24271
g15
V34509
p24272
stp24273
a((dp24274
g2
(lp24275
VThis way
p24276
aVPlease read about two dimensional arrays and pointer to arrays
p24277
aVAlternatively in C++ you can pass it by a reference, which will make it not decay to its first element
p24278
as(dp24279
g15
V34509
p24280
stp24281
a((dp24282
g2
(lp24283
VLike someone stated, but was sadly downvoted (not sure why he did delete his answer), the compiler can do any and everything as long as the observable behavior is the same as if it did not do anything different
p24284
aVIt's self-expanatory that if your function writes into the reference, and a global variable was passed as argument to the function and the global was later printed after the function returns, or anything else fancy is done, then if the compiler would change the parameter passing convention, it's more difficult for the compiler to prove you still get the same observable behavior
p24285
aVIf the compiler can't prove it, it can't do the desired optimization
p24286
aVSo whatever further question comes up, just think "it can do anything as long as I won't notice it"
p24287
as(dp24288
g15
V34509
p24289
stp24290
a((dp24291
g2
(lp24292
VIn the header outside of the classes
p24293
aVNote that whatever you write in 's default constructor, the code will never be executed if you never call  or never refer to  in another way from non-template code
p24294
aVBut that should be fine
p24295
as(dp24296
g15
V34509
p24297
stp24298
a((dp24299
g2
(lp24300
VYou could just omit defining it
p24301
aVYou could also derive from a non-defined specialization
p24302
aVNote that explicit specializations that declare classes or functions will never depend on template parameters
p24303
aVSo, stuff like this that depend on template parameters can't work anyway
p24304
aVIn that case, declaring a non-defined explicit specialization should be sufficient
p24305
as(dp24306
g15
V34509
p24307
stp24308
a((dp24309
g2
(lp24310
VIt's the order but it's not only the order
p24311
aVFor the first code, both templates was defined before
p24312
aVBut the second was taken
p24313
aVThis is because the two templates are compared and it is found that  matches any type that  matches, but that  does not match all types that  matches
p24314
aVThus, the second template is more specialized
p24315
aVWhenever you put an explicit specialization and those two templates match, the templates are compared and the more specialized one is associated by the explicit specialization
p24316
aVThis comparison is called "partial ordering"
p24317
as(dp24318
g15
V34509
p24319
stp24320
a((dp24321
g2
(lp24322
VI've got 207 real-world examples of : Code search 1, Code search 2
p24323
aVIncluding  (to get the underlying naked integer), boost::gil (apparently also to yield the raw data), Mozilla (that say "it is risky to define operator&, but, hey, we know what we're doing
p24324
aV, wxWidgets, Armagetron and lots of more
p24325
aVIt seems some use the iterator idiom  to get a raw reference or pointer backwards, and write  to get a raw reference and  to get a raw pointer
p24326
aVNotice that once your type overloads  and returns something different than the built-in operator, your type is not CopyConstructible anymore (in C++03 - C++0x seems to have lifted it), and so cannot be used as element-type in a Standard container anymore
p24327
as(dp24328
g15
V34509
p24329
stp24330
a((dp24331
g2
(lp24332
VAnything can happen if you compare an uninitialized variable to itself
p24333
aVIt is after all undefined behavior
p24334
aVFor initialized int variables, this can't happen
p24335
aVNote that namespace-scope, class-static, and function-static int variables not explicitly initialized are given the value 0
p24336
aVThen they won't compare equal
p24337
aVI have just tested with Clang:
p24338
aVWhen compiled with -O1, this returns 0 because the optimizer is allowed to assume that x has no stable value
p24339
aVGCC is more forgiving with the above, returning 1
p24340
aVThe following makes GCC return 0 too (obviously not doing the branch is cheaper if you are allowed to choose):
p24341
aVIn the end, the result is not only dependent on the CPU executing the code, but also from anything else in the toolchain
p24342
as(dp24343
g15
V34509
p24344
stp24345
a((dp24346
g2
(lp24347
VInstead of introducing a whole explicit specialization, you could just specialize the initialization
p24348
as(dp24349
g15
V34509
p24350
stp24351
a((dp24352
g2
(lp24353
VThe question is, in this case pf is itself volatile, so is the compiler allowed to assume that b won't change in the loop even if b is not volatile
p24354
aVIt can't, because you say that  might be changed by the other threads, and this indirectly changes  if  is called then by the while loop
p24355
aVSo while it is theoretically not required to read  normally, it in practice must read it to determine whether it should short circuit (when  becomes  it must not read  another time)
p24356
aVAnswer to the second part
p24357
aVIn this case  is not volatile anymore, so the compiler can get rid of it and see that  has an empty body and  sets  to false
p24358
aVIt could optimize  as follows
p24359
aVAnswer to older revision
p24360
aVOne condition for the compiler to be allowed to optimize the loop away is that the loop does not access or modify any volatile object (See [stmt
p24361
aViter]p5 in n3126)
p24362
aVYou do that here, so it can't optimize the loop away
p24363
aVIn C++03 a compiler wasn't allowed to optimize even the non-volatile version of that loop away (but compilers did it anyway)
p24364
aVNote that another condition for being able to optimize it away is that the loop contains no synchronization or atomic operations
p24365
aVIn a multithreaded program, such should be present anyway though
p24366
aVSo even if you get rid of that , if your program is properly coded I don't think the compiler can optimize it away entirely
p24367
as(dp24368
g15
V34509
p24369
stp24370
a((dp24371
g2
(lp24372
VNobody has yet pointed out any part of the current Standard that says I can't
p24373
aVIn C++03, the name in the function call  is nondependent
p24374
aVC++03 does not make the name  dependent
p24375
aVDependency happens for type names by dependent types, and for non-type names by dependent expressions that are either type or value dependent
p24376
aVIf a name is looked up in a dependent type, it becomes a type-dependent id-expression (14
p24377
ag488
ag976
aV2/3 last bullet), and its lookup is delayed until instantiation
p24378
aVThe name  is no such dependent expression
p24379
aVIf you were to call , a special rule of C++03 at 14
p24380
ag976
aV6 says
p24381
aVIn an expression of the form:
p24382
aVwhere the postfix-expression is an identifier, the identifier denotes a dependent name if and only if any of the expressions in the expression-list is a type-dependent expression (14
p24383
ag488
ag976
aV2)
p24384
aVSo you need to remove the  in order to make it an identifier and to make it dependent by this special rule
p24385
aVThe reason I can't remove the :: is that in my real code, the template function foo is a member function of class CC, and there exist a family of overloaded member functions CC::bar(
p24386
aV, meaning I need to qualify ::bar(TT*) to avoid defaulting to CC::bar(
p24387
aVThat's what :: exists for, I'm surprised if the Standard says I can't use :: here
p24388
aVThe proper way to solve it is to introduce a using declaration into the local scope of your function
p24389
aVADL will not do anything if ordinary lookup finds a class member function
p24390
aVTherefor, you introduce a using declaration, so ordinary lookup doesn't find a class member function, and ADL can advance the declarations visible when instantiating
p24391
aVBut this seems to disagree with you: Stroustrup TC++PL Sp Ed, Section C
p24392
aV13
p24393
ag14557
aV1, Dependent Names: "Basically, the name of a function called is dependent if it is obviously dependent by looking at its arguments or at its formal parameters"
p24394
aVStroustrup's book is far from being authorative on this
p24395
aVIt's written for people who possibly don't know C++ yet
p24396
aVIt won't try to be 100% correct with regards to these questions, and it certainly isn't
p24397
aVAlso, the formal parameters of a function have nothing to do with whether a function call is dependent or not
p24398
aVIn the IS, only actual arguments define dependency of a function name
p24399
aVThis was different in an old draft from 1996, which had the notion of implicit and explicit dependency
p24400
aVImplicitly dependency was defined as
p24401
aVA name implicitly depends on a template-argument if it is  a  function
p24402
aVname  used  in a function call and the function call would have a dif-
p24403
aVferent resolution or no resolution if a type, template, or  enumerator
p24404
aVmentioned in the template-argument were missing from the program
p24405
ag7695
aV[Example: some calls that depend on a template-argument type T are:
p24406
aVThe function called has a parameter that depends on T  according  to
p24407
aVthe  type  deduction  rules  (temp
p24408
aVdeduct)
p24409
aVFor  example,  f(T),
p24410
aVf(Array), and f(const T*)
p24411
aVThe type of the actual argument depends on T
p24412
aVFor example, f(T(1)),
p24413
aVf(t), f(g(t)), and f(&t;) assuming that t has the type T
p24414
aVA practical example is also given
p24415
aVThis ill-formed template instantiation uses a function that does not
p24416
aVdepend on a template-argument:
p24417
aVThe call x
p24418
aVf() gives rise to the specialization:
p24419
aVThe call g(1) would call g(int), but since that call does not depend
p24420
aVon the template-argument Horse and because g(int) was not in scope at
p24421
aVthe point of the definition of the template, the call x
p24422
aVf() is  ill-
p24423
aVformed
p24424
aVOn the other hand:
p24425
aVHere, the call y
p24426
aVf() gives rise to the specialization:
p24427
aVThe  call  g(1)  calls g(int), and since that call depends on the tem-
p24428
aVplate-argument int, the call y
p24429
aVf() is acceptable  even  though  g(int)
p24430
aVwasn't in scope at the point of the template definition
p24431
ag4885
aVThese things are left to history, and even the last traces from it are disappearing slowly, albeit not actively driven (n3126 for instance gets rid of "explicitly depends" at [temp
p24432
aVnames]/p4 as a side-effect of another change, because the distinction between "explicitly depends" and "implicitly depends" has never existed in the IS)
p24433
as(dp24434
g15
V34509
p24435
stp24436
a((dp24437
g2
(lp24438
VAs far as I understand, it's impossible to have it (because it would conflict with the default constructor - am I right
p24439
aVYou are wrong
p24440
aVIt doesn't conflict in any way
p24441
aVYou just can't call it ever
p24442
as(dp24443
g15
V34509
p24444
stp24445
a((dp24446
g2
(lp24447
VEdit: My question is: why should the member function declararions be all well-formed
p24448
aVSince the compiler instantiates the methods only upon their usage, why does it need correct declaration
p24449
aVConsider the above example2 as a possible use-case of this feature
p24450
aVWhen implicitly instantiating a class template specialization, the compiler has to inspect the complete declarator of that member because it needs to know basic information about the declaration
p24451
aVSuch can contribute to the size of the class template specialization
p24452
aVIf inspecting the declaration part will find out it's declaring a data-member, the  value of the class will possibly yield a different value
p24453
aVIf you would have declared a function pointer instead, this would be the case
p24454
aVThe C++ language is defined in such a way that the type of a declaration is known only once the whole declaration is parsed
p24455
aVYou can argue that you put static there, and thus in this case this is not needed to compute its size
p24456
aVBut it is needed for name-lookup to know what a name  refers to and that there was declared a name f at all
p24457
aVThe compiler will not instantiate the definition of , but it will only instantiate the non-definition part of the declaration, to gets its type and adding its name to the class type for name lookup purposes
p24458
aVI believe supporting delayed-instantiation for declaration of names in particular cases where it would possibly work would complicate implementation of C++ compilers and the C++ spec even more, for no comparable benefit
p24459
aVAnd finally, in your example where you attempt to call it, the compiler has to instantiate the declaration, because it needs to lookup the name , and for this it needs to know whether that declaration is a function or something else
p24460
aVSo I really even theoretically can't see a way your example could work without instantiating the declaration
p24461
aVNote that in any case, these will not instantiate a definition of the function
p24462
as(dp24463
g15
V34509
p24464
stp24465
a((dp24466
g2
(lp24467
VHow about overloading
p24468
aVExplicit specializations can't be added like that in your example
p24469
aVIn addition, your Base class is ill-formed as you have to define any explicit specialization outside of the class's scope
p24470
aVAll explicit specializations need to give the name of the template to be specialized though, or be in the same scope as the template
p24471
aVYou can't just write an explicit specialization in a Derived class like that
p24472
as(dp24473
g15
V34509
p24474
stp24475
a((dp24476
g2
(lp24477
VIt is about what the example shows
p24478
aVIn sum, these are those conversions
p24479
aVThe function parameter can be a , while the function argument is a
p24480
aVCompare with  - left side of  is deduced in that way
p24481
aVThe function parameter can be a , while the function argument is a  (same for volatile)
p24482
aVThe function parameter can be a  or  while the function argument is a  or  respectively (these are the qualification conversions) - same for volatile
p24483
aVOther conversions cannot be done for a function parameter / argument that participate in deduction
p24484
aVThe whole range of conversions can be applied if a function parameter does not participate in deduction, but this needs a non-deduced context or a context where there is no argument to be deduced at all, and implementation don't actually agree on it (see here)
p24485
aVIn other words:
p24486
aVThe second example is vital for some partial ordering contexts to work
p24487
as(dp24488
g15
V34509
p24489
stp24490
a((dp24491
g2
(lp24492
VYou need to say the following (since you befriend a whole template instead of just a specialization of it, in which case you would just need to add a  after the ):
p24493
aVActually, there is no need to declare it as a friend unless it accesses private or protected members
p24494
aVSince you just get a warning, it appears your declaration of friendship is not a good idea
p24495
aVIf you just want to declare a single specialization of it as a friend, you can do that like shown below, with a forward declaration of the template before your class, so that  is regognized as a template
p24496
aVBoth the above and this way declare specializations of it as friends, but the first declares all specializations as friends, while the second only declares the specialization of  as a friend whose  is equal to the  of the class granting friendship
p24497
aVAnd in the other case, your declaration looks OK, but note that you cannot  a  to a  when  and  are different type with that declaration (unless you have an implicit conversion between those types)
p24498
aVYou can make your  a member template
p24499
as(dp24500
g15
V34509
p24501
stp24502
a((dp24503
g2
(lp24504
VYou cannot do that
p24505
aVOperator functions are only considered for operands that have enumeration or class types among them
p24506
aVYou after all shift a pointer, but not a class
p24507
aVYou need to explicitly say that you want to shift into a class object by dereferencing the pointer first
p24508
as(dp24509
g15
V34509
p24510
stp24511
a((dp24512
g2
(lp24513
VHow can I do what I want to do (that is, initialize an array in a constructor (not assigning elements in the body))
p24514
aVIs it even possible
p24515
aVYes
p24516
aVIt's using a struct that contains an array
p24517
aVYou say you already know about that, but then I don't understand the question
p24518
aVThat way, you do initialize an array in the constructor, without assignments in the body
p24519
aVThis is what  does
p24520
aVDoes the C++03 standard say anything special about initializing aggregates (including arrays) in ctor initializers
p24521
aVOr the invalidness of the above code is a corollary of some other rules
p24522
aVA mem-initializer uses direct initialization
p24523
aVAnd the rules of clause 8 forbid this kind of thing
p24524
aVI'm not exactly sure about the following case, but some compilers do allow it
p24525
aVSee this GCC PR for further details
p24526
aVDo C++0x initializer lists solve the problem
p24527
aVYes, they do
p24528
aVHowever your syntax is invalid, I think
p24529
aVYou have to use braces directly to fire off list initialization
p24530
as(dp24531
g15
V34509
p24532
stp24533
a((dp24534
g2
(lp24535
VYes, you are correct
p24536
aVThe expression is an rvalue of array type
p24537
aVThis is not a defect - the committee knows about it, and it was also a common issue in C89, which only allows conversion to pointers for lvalues of array types
p24538
aVAs a consequence, you could not index or dereference an array like
p24539
aVC99 fixed this, and C++ does not have a problem with it
p24540
aVNote that whether or not it is an rvalue is independent to whether or not the expression denotes an object
p24541
aVC++03 accidentally omitted to say that an rvalue expression that is of array type denotes an object
p24542
aVThis was fixed in C++0x by DR#450
p24543
aV(obviously appreciating that there are no rvalues of such)
p24544
aVThere are actually rvalues of function types
p24545
aVThese occur for non-static member functions denoted by a class member access expression
p24546
as(dp24547
g15
V34509
p24548
stp24549
a((dp24550
g2
(lp24551
VOr
p24552
aVThe reason yours does not work is because it is not sufficient for determining T if you know the type of the argument
p24553
aVWhat if  would be a template like the following
p24554
aVAny  in  would do it
p24555
aVIn general, a function parameter type formed by  is called a non-deduced context and can't be used to deduce
p24556
as(dp24557
g15
V34509
p24558
stp24559
a((dp24560
g2
(lp24561
VIf an RAII constructor throws, all resources bound to RAII objects prior to the throwing point will be cleaned up properly
p24562
aVThe C++ rules are sensibly designed to guarantee that
p24563
aVIf your  construction throws because of a  then any RAII object created prior to  in the  block will be properly cleaned up
p24564
aVSo if you consequently use RAII, you don't need a manual  /  like that, because the RAII objects handle cleanup for you
p24565
aVIf you do need it for some reason, in the case above you could use swap like the following
p24566
as(dp24567
g15
V34509
p24568
stp24569
a((dp24570
g2
(lp24571
VThe difference between the two is that the first has type  and the second has type
p24572
aVA function that has such a type with  at the end can only be a member function of a class, and it means that the member function does not change the class value (which  refers to) as seen from outside the class
p24573
aVThe compiler will check that to a degree, and any straight write to a class member in a const member function results in a compile time error, and the function can straightly only call const member functions on itself (special directives exist so you can tell the compiler that a member write won't change the class' value as seen from outside
p24574
aVThis is done by the  keyword)
p24575
aVIn the functions you presented, one had a parameter of type
p24576
aVSuch a parameter cannot be changed inside its function
p24577
aVIt has no effect on the function's type though, and no effect to the callers of the function
p24578
as(dp24579
g15
V34509
p24580
stp24581
a((dp24582
g2
(lp24583
VLike others say, in C++ this can't be done
p24584
aVThe issue is not specific to class templates, though
p24585
aVBut there are some workarounds that work in some scenarios
p24586
aVYou can use  to do what you want
p24587
aVSee boost::variant
p24588
aVYou can use lexical scoping to make a new variable that hides the name of the other
p24589
aVThis is usable when you just want the name to change its meaning, not necessarily the previous object
p24590
aVAn important difference is that this changes things at compile time only
p24591
aVis able to track its stored type at runtime
p24592
aVHope it helps
p24593
as(dp24594
g15
V34509
p24595
stp24596
a((dp24597
g2
(lp24598
VThat's perfectly fine
p24599
aVJust do it like that
p24600
aVAlso consider whether  could be a nested class (for something like an iterator, that could well make sense
p24601
aVYou haven't said anything on what you try to model
p24602
aVIt should be noted that Outer also needs to have an own copy constructor and copy assignment operator or disable it
p24603
aVOtherwise a flat copy would cause major catastrophe
p24604
as(dp24605
g15
V34509
p24606
stp24607
a((dp24608
g2
(lp24609
VSurely sizeof(T) and sizeof(data) should be the same, right
p24610
aVOr have I misunderstood what sizeof actually gets the size of
p24611
aVThat's not necessarily the case
p24612
aVConsider this one:
p24613
aVThis will yield  when applied to , and  when applied to
p24614
aVDepending on your code, you may have weird instantiations of your template, which could have causes such a case
p24615
as(dp24616
g15
V34509
p24617
stp24618
a((dp24619
g2
(lp24620
VYes, that space is still required currently
p24621
aVBut US National Body comment 15 requested this to be removed, and it looks like the proposed resolution will be incorporated (since it's "ready")
p24622
as(dp24623
g15
V34509
p24624
stp24625
a((dp24626
g2
(lp24627
VHow can I avoid explicitly specifying int while calling f
p24628
aVJust make  declare its nesting class type
p24629
aVThen you can deduce it
p24630
aVThe following takes the outer template, the inner's typedef and a return type
p24631
as(dp24632
g15
V34509
p24633
stp24634
a((dp24635
g2
(lp24636
VYour template is not a "generic move assignment"
p24637
aVBut it is a "perfect forwarder", except that in your case it doesn't forward
p24638
aVThe rule in C++0x is that template argument deduction treats a parameter "T&&" specially: Lvalue arguments deduce  to , and Rvalue arguments deduce it to
p24639
aVThat way, an lvalue of type  will yield to ultimate parameter type , and an Rvalue will ultimately yield to
p24640
aVIn your case, the lvalue right hand side yields a deduced parameter type "Foo &", which perfectly well matches the lvalue argument
p24641
aVThe currently draft (n3126) forbids the compiler to use the template to perform the copy assignment (in a very confusingly worded paragraph), though
p24642
aVIt depens on the resolution of issue 1080 whether that will change or not
p24643
as(dp24644
g15
V34509
p24645
stp24646
a((dp24647
g2
(lp24648
VNone of it is legal
p24649
aVSee [dcl
p24650
aVdcl] paragraph 3
p24651
as(dp24652
g15
V34509
p24653
stp24654
a((dp24655
g2
(lp24656
VWhen you do  then  is declared as having type , but not as having type
p24657
aVSo you need to put some number in the brackets
p24658
aVIt will limit what you can return to a specific size
p24659
aVThis is where C++ differs from C, which will allow you to assign a  to an
p24660
aVC++ has no such so-called "type compatibility" rules
p24661
aVIf you want to get rid of the need for the , you need to return the decay-type of the array
p24662
aVThe element type of your array is
p24663
aVUsing an identity template you can make your declaration look much more readable
p24664
as(dp24665
g15
V34509
p24666
stp24667
a((dp24668
g2
(lp24669
VA rule of thumb (the reason of which should be clear)
p24670
aVPrivate member templates should be defined in the
p24671
aVcpp file (unless they need to be callable by friends of your class template)
p24672
aVNon-private member templates should be defined in headers, unless they are explicitly instantiated
p24673
aVYou can often avoid having to include lots of headers by making names be dependent, thus delaying lookup and/or determination of their meaning
p24674
aVThis way, you need the complete set of headers only at the point of instantiation
p24675
aVAs an example
p24676
aVThis is what I used for implementing a visitor pattern that uses CRTP
p24677
aVIt looked like this initially
p24678
aVThis will need the headers of all statement classes because of those static casts
p24679
aVSo I have made the types be dependent, and then I only need forward declarations
p24680
as(dp24681
g15
V34509
p24682
stp24683
a((dp24684
g2
(lp24685
VThe quote means that the following works - the code is in the lexical scope of the class, such that unqualified name lookup will behave specially
p24686
aVIf you had defined "function" in the namespace scope, then "type" would not be visible - you would have to say "A::type"
p24687
aVThat's why it says in the next sentence "A friend function defined outside the class is not
p24688
aVUnqualified name lookup for an in-class definition is stated as
p24689
aVName lookup for a name used in the definition of a friend function (11
p24690
aV4) defined inline in the class
p24691
aVgranting friendship shall proceed as described for lookup in member function definitions
p24692
aVIf the friend
p24693
aVfunction is not defined in the class granting friendship, name lookup in the friend function definition
p24694
aVshall proceed as described for lookup in namespace member function definitions
p24695
aVSo the text you quoted is not really required to be normative - the specification of unqualified name-lookup already covers it
p24696
as(dp24697
g15
V34509
p24698
stp24699
a((dp24700
g2
(lp24701
VYou could use virtual inheritance and the dominance rule, if you don't want to templatize
p24702
aVNow you can do it as follows
p24703
aVThe second argument respectively is the direct base class, which can be omitted if there is none
p24704
aVFor instance if you derive from , you need to do that as follows
p24705
as(dp24706
g15
V34509
p24707
stp24708
a((dp24709
g2
(lp24710
VIt can only be done for aggregates (arrays and certain classes
p24711
aVContrary to popular belief, this works for many nonpods too)
p24712
aVWriting a constructor that takes them is not possible
p24713
aVSince you tagged it as "C++0x", then this is possible though
p24714
aVThe magic words is "initializer-list constructor"
p24715
aVThis goes like
p24716
aVHowever, such initialization will default construct the array and then use the assignment operator
p24717
aVIf you aim for speed and safety (you get compile time errors for too many initializers
p24718
aV, you can also use an ordinary constructor with a variadic template
p24719
aVThis can be more generic than needed though (often an initializer_list completely suffices, especially for plain integers)
p24720
aVIt benefits from perfect forwarding, so that an rvalue argument can be move constructed into an array element
p24721
aVIt's a hard choice
p24722
aVEdit Correction, the last one works too, as we didn't make the constructor , so it can use the copy constructor of , constructing a temporary  object and copy it over to
p24723
aVBut that's not what we really would want the calls to be :)
p24724
as(dp24725
g15
V34509
p24726
stp24727
a((dp24728
g2
(lp24729
VThis has nothing to do with overriding functions
p24730
aVIt has to do with conversions
p24731
aVIt really doesn't have to do with accessibility (i
p24732
aVe "private" or such) directly either
p24733
aVHere is a simpler example
p24734
aVYou can refer to the indirect  object by first converting to  and then to :
p24735
aVYou cannot do such with the direct A object
p24736
aVIf you try to directly convert to , it will have two possibilities
p24737
aVIt follows that it is impossible to refer to the non-static data members of the direct  object given a  object
p24738
aVNotice that accessibility is orthogonal to visibility
p24739
aVSomething can be accessible even tho it's not visible (for example by refering to it by a qualified name), and something can be visible even though it's not accessible
p24740
aVEven if all the above derivations would be declared , the problem would still show up: Access is checked last - it won't influence name lookup or conversion rules
p24741
aVAlso, anyone can cast to an unambiguous private base class with defined behavior (the C++ Standard makes an exception for this) using a C-style cast, even if normally access wouldn't be granted to do so
p24742
aVAnd then there are still friends and the class itself that could freely convert
p24743
as(dp24744
g15
V34509
p24745
stp24746
a((dp24747
g2
(lp24748
VWorking with such object is the same as working with POD values
p24749
aVNo
p24750
aVYou are not totally safe to use  and friends on it (only allowed on PODs
p24751
aVCan I cast a pointer or an array of such objects as a pointer/array of POD values and viceversa
p24752
aVIf it is a POD, you are perfectly safe
p24753
aVBut this is not a POD because it has a private data member
p24754
aVBoth of that said, in practice it will work fine for that class (and in C++0x, you are allowed to use such a class with private members with , because it allows it for all trivially copyable types, which includes your type and many other non-PODs)
p24755
as(dp24756
g15
V34509
p24757
stp24758
a((dp24759
g2
(lp24760
VWhy should the compiler know that that is OK
p24761
aVI think you want the following instead
p24762
aVA  doesn't have the special properties that a  has (that of being an universal data pointer)
p24763
as(dp24764
g15
V34509
p24765
stp24766
a((dp24767
g2
(lp24768
V2) Are there any technical reasons you can think of that would preclude "perfect forwarding constructors" from being an adequate alternative
p24769
aVI have shown one problem with that perfect forwarding approach here: Forwarding all constructors in C++0x
p24770
aVAlso, the perfect forwarding approach can't "forward" the expliciteness of base-class constructors: Either it is always a converting constructor or never, and the base-class will always be direct initialized (always making use of all constructors, even explicit ones)
p24771
aVAnother problem are initializer-list constructors because you can't deduce  to
p24772
aVInstead, you would need to forward to the base with  (note the braces) and initialize  objects with  or  or
p24773
aVIn that case,  would be the element types of the initializer list, and forward them to the base class
p24774
aVA initializer-list constructor can then receive them
p24775
aVThis seems to cause unnecessary code bloat because the template argument pack will potentially contain lots of type sequences for each different combination of types and length and because you have to choose an initialization syntax this means:
p24776
as(dp24777
g15
V34509
p24778
stp24779
a((dp24780
g2
(lp24781
VThis is caused by a twist in name-lookup in C++03: Checking for an unambiguous subobject was part of class member name lookup in C++03
p24782
aVLookup in C++03 will find D::X and C::x and A::x, where A::x matches, but is associated with two distinct subobjects of type A
p24783
aVIn C++0x, the checking for an unambiguous subobject is now part of the respective subclauses, see DR #39: The class where  is directly a member of is an ambiguous base - so clause 5 will cause a compile error, instead of clause 10
p24784
aVNote that the comment talks about the subobjects of
p24785
aVThere is one subobject of  that goes over path , and another subobject of  that goes over path
p24786
aVThis is why the comment says " or "
p24787
aVThe presence of multiple subobjects of the same class type can be determined by just trying to convert to its class type, ignoring accessibility issues: If the conversion is ambiguous, the subobject appeared multiple times
p24788
as(dp24789
g15
V34509
p24790
stp24791
a((dp24792
g2
(lp24793
VJust pick one of those in 13
p24794
ag488
aVLike
p24795
aVFor every pointer or enumeration type T, there exist candidate operator functions of the form
p24796
aVSo
p24797
as(dp24798
g15
V34509
p24799
stp24800
a((dp24801
g2
(lp24802
VYou can use a template
p24803
aVis deduced to , and that won't bind to rvalues
p24804
as(dp24805
g15
V34509
p24806
stp24807
a((dp24808
g2
(lp24809
VThe most recent C (currently that's C99 with a few amendmends) returns  by default if there is no explicit return statement at the end of the function, and control flows off the function's end (see 5
p24810
ag2790
ag976
ag976
aV3 in C99 TC3)
p24811
aVThis is because most often one would write such a form of return anyway
p24812
aVIn C89 you need to return something there - it has no such implicit return
p24813
aVBut the compiler is by no means required to diagnose such a mistake (see 3
p24814
ag488
ag488
aV4 in the C89 draft and 6
p24815
aV9
p24816
aV1/12 in C99 TC3)
p24817
as(dp24818
g15
V34509
p24819
stp24820
a((dp24821
g2
(lp24822
VYou can define it in the class template like this
p24823
aVThis gives a compile time error if you call  on a  for whose  you haven't given the proper definition
p24824
as(dp24825
g15
V34509
p24826
stp24827
a((dp24828
g2
(lp24829
VYou can use my switch macros, which support all kind of value types
p24830
aVFor a few cases, using  a few times in a row is an order of magnitudes faster than creating map each time and looking up in it
p24831
as(dp24832
g15
V34509
p24833
stp24834
a((dp24835
g2
(lp24836
VI believe both are correct (see below for Primer's definition, though), depending on how compatible you want to are
p24837
aVThe formal definition is
p24838
aVFor an enumeration where e min is the smallest enumerator and e max is the largest, the values of the enumeration are the values of the underlying type in the range b min to b max , where b min and b max are, respectively, the smallest and largest values of the smallest bit-field that can store e min and e max
p24839
aVFor negative numbers, the question is what representation we use
p24840
aVThe footnote to it says
p24841
aVOn a two\u2019s-complement machine, b
p24842
aVmax is the smallest value greater than or equal to max (abs(e min ) \u2212 1 ,abs(e max ) ) of the form
p24843
aV2 M \u2212 1; b is zero if e is non-negative and \u2212 (b + 1 ) otherwise
p24844
aVIf you assume sign magnitude or one's complement then the example enumeration's range is
p24845
aVFor two's complement you get one more in the negative range
p24846
aVPrimer's definiton lacks the maximum enumerator value, so I'm not sure how it comes to lower limit
p24847
aVIf you want to be maximum compatible with other implementations, I would go with
p24848
as(dp24849
g15
V34509
p24850
stp24851
a((dp24852
g2
(lp24853
VIt tries to map the argument expressions to express them only in terms of types
p24854
aVSo for lvalues of type , it uses , and for rvalues of type  it uses  (unmodified)
p24855
aVOf course, an argument expression never has reference type (no expression can have reference type), but that's GCC's way to expressing that
p24856
aVFor C++0x, there will be lvalues, xvalues and prvalues
p24857
aVGCC would probably use  for the first and  for the latter two, or  for the second and  for the last
p24858
aVClang does a better job here
p24859
as(dp24860
g15
V34509
p24861
stp24862
a((dp24863
g2
(lp24864
VSequence points
p24865
aVSequence points are points in an execution of a program where all side effects produced by evaluations prior to the sequence points have been completed
p24866
aVSide effects produced by evaluations that occur after the sequence point will therefor be separated from side effects produced by evaluations that occur before the sequence point and happen afterwards
p24867
aVEvaluations
p24868
aVEvaluating something means to apply some runtime semantics on an expression
p24869
aVThere are unevaluated expressions (operands of , some operands of  and such) that only inspect the expression's type and don't have meaning at runtime
p24870
aVIf an expression is evaluated, it can result in a value which may imply reading values out of objects, or it may just evaluate to an object without reading the value of it (it then remains an lvalue, as with the left subexpression of an assignment)
p24871
aVIn addition, it can produce side effects as necessary
p24872
aVAn evaluation is complete if its value is known, but until a sequence point has been reached, side effects produced by the evaluation are assumed to be still processed
p24873
aVYou have sequence points after all evaluations that usually are needed to be processed completely before some certain other expressions are processed
p24874
aVThese are
p24875
aVAfter evaluation of  in  and  and
p24876
aVAlso after evaluation of  in  - this operator is called the "comma operator"
p24877
aVFor a function call, after evaluating the function call arguments and before starting evaluations in the function body
p24878
aVAfter the evaluation of a complete expression (one that wasn't evaluated as part of another expression)
p24879
aVExamples are loop conditions, if conditions, switch values and expression statements
p24880
aVImmediately before a function terminates (by unwinding the function by an exception or by ordinarily returning it after (possibly) creating the return value)
p24881
aVThis makes sure that every side effect in a function really has been settled and is completely processed
p24882
aVSide effects
p24883
aVA side effect is a change in the execution environment of the program that happens in addition to simply computing a value
p24884
aVThis can be (among others) writing to an object, calling an input/output function or calling a function that does so
p24885
aVFlow of program execution
p24886
aVWith these three terms, the flow of a program can be visualized as follows
p24887
aVIn the following diagrams, an  specifies the evaluation of a (sub-)expression , an  specifies a sequence point and an  specifies a side effect  on an object
p24888
aVIf an evaluation needs to read a value from a named object (if  is a name), the evaluation is written as , otherwise it's written as
p24889
aVSide effects are written right and left to the expressions
p24890
aVAn edge between two expressions means that the upper expression is evaluated before the lower expression (usually because the lower expression depends on the value or lvalue of the upper expression)
p24891
aVIf you look at the two expression statements , you can depict the following diagram
p24892
aVAs can be seen, there are two sequence points, and one of them separates the two modifications of
p24893
aVFunction call arguments are interesting too, although I will omit the diagram for this
p24894
aVThe assert is fine, because it is guaranteed that when 's body is executed, side effects produced by argument evaluations are complete: Therefor,  and  have been completely incremented
p24895
aVLet's consider the expression statement
p24896
aVWow, where do the two branches come from
p24897
aVRemember from the initial definition of sequence point: Sequence points affect evaluations that occur prior to it
p24898
aVAll subexpressions of the multiplication are evaluated prior to it and there is no other sequence point, so we must assume "maximal parallelity" to find where potentially we have concurring writes to the same object
p24899
aVMore formally, the two branches are not ordered
p24900
aVThe sequence point relation is this a relation that orders some evaluations to each other and doesn't order others: It's therefor a partial order
p24901
aVConflicting side effects
p24902
aVTo give the compiler maximal freedom in generating and optimizing machine code, cases like the multiplication above don't sequence the evaluations of subexpressions and don't separate the side effects produced by them except in the few cases outlined above
p24903
aVThis can lead to conflicts, and the C++ Standard marks behavior of programs undefined if they try to modify the same object without an intervening sequence point (really, it applies to scalar objects, because other objects are either non-modifiable (arrays) or just aren't applicable to this rule (class objects))
p24904
aVBehavior is also undefined if a previous value is read from the object but there is a modification too, as in
p24905
aVAs an exception, it's allowed to read the value of the object if it is needed for computing the new value
p24906
aVThis is the case in
p24907
aVAs we see here, the value of  is read on the right side and after the evaluation of both sides the assignment takes place
p24908
aVSo we have a side effect and the read of 's value without an intervening sequence point, but the read was only to determine the value to be stored into , so it is fine
p24909
aVSometimes, a value is read after a modification was done
p24910
aVThis is the case for , which in C++ will write to  and then read from , without an intervening sequence point
p24911
aVThis however is fine, because it does not read the previous value of , but the new value of it
p24912
aVIn this case, the side effect of the assignment to b has been complete not only before the next sequence point, but also before the read of , as needed for the assignment to  to get the new value from
p24913
aVIn the spec, this relation is established by explicit constraints, in this case it appertains in particular to  and reads "The result of the assignment operation is the value stored in the left operand after the assignment has taken place; the result is an lvalue
p24914
aVWhy not a sequence point to make this relation
p24915
aVBecause a sequence point would have the undesirable effect of requiring every side effect that happens in the evaluation of the left and right operand to be complete, instead of doing so only for the assignment in case its resulting lvalue is read from
p24916
aVClosing words
p24917
aVIt should be noted that temporaries created in the evaluation of a full-expression are usually not cleaned up before the very next sequence point but only when the full-expression has been completely evaluated (in certain situations, the lifetime of temporaries will instead be even longer if there were references bound to them)
p24918
as(dp24919
g15
V34509
p24920
stp24921
a((dp24922
g2
(lp24923
VMultiple purposes depending on what you cast
p24924
aVMarking your intention to the compiler that an expression that is entirely a no-op is intended as written (for inhibiting warnings, for example)
p24925
aVMarking your intention to to the compiler and programmer that the result of something is ignored (the result of a function call, for example)
p24926
aVIn a function template, if a return type is given by a template parameter type , and you return the result of some function call that could be different from  in some situation
p24927
aVAn explicit cast to  could, in the  case, prevent a compile time error:
p24928
aVInhibiting the compiler to choose a comma operator overload ( will never invoke an overloaded comma operator function)
p24929
aVNote that the Standard guarantees that there will never be an  called if you cast a class object to  (some GCC versions ignore that rule, though)
p24930
as(dp24931
g15
V34509
p24932
stp24933
a((dp24934
g2
(lp24935
VGCC can't look into the already compiled code of the ,  and  functions at compile time
p24936
aVYou just pass the address of the struct, from the point of the call, without reading anything
p24937
aVValgrind on the other hand executes your program and tracks all the memory and will check up whether there is a read before a write of a particular memory block and can thus tell you
p24938
aVIf those functions would be defined inline in the header, you could have a chance that the compiler could inline them and track back the pointer address back to the uninitialized struct
p24939
aVI haven't tested how good GCC is at that, though (or for that matter, compilers in general)
p24940
as(dp24941
g15
V34509
p24942
stp24943
a((dp24944
g2
(lp24945
VLet's ask the other way around: Why would it not be valid
p24946
aVI really can't find any argument or rule that forbids the above code
p24947
aVThe function call in the respective other branch is never executed (although discussion in the comments indicate it's not so easy
p24948
as(dp24949
g15
V34509
p24950
stp24951
a((dp24952
g2
(lp24953
VIn addition to what @James wrote, it seems you rather want to have something like
p24954
aVThese class templates handle functions/function pointers and function object classes or references to them for up to 5 parameters
p24955
aVUse them at your own risk :)
p24956
as(dp24957
g15
V34509
p24958
stp24959
a((dp24960
g2
(lp24961
VConsider the following piece of code
p24962
aVOn the other hand
p24963
aVSo there is an implicit conversion from a function to a pointer (which is called "decay")
p24964
aVThis also makes you able to say  - arbitrarily many times dereference it - in each step a function to pointer conversion occurs which undoes the effect of the previous dereference
p24965
aVIn function parameter lists, a  and a  are equivalent ways (except for spelling) of declaring a parameter
p24966
aVA reference will inhibit this parameter type adjustment
p24967
aVThis is exactly the same as for array declared parameters: Parameters are never arrays, but they will always be pointers, if they were declared as being arrays
p24968
as(dp24969
g15
V34509
p24970
stp24971
a((dp24972
g2
(lp24973
VNope, that's not going to work in C++0x
p24974
as(dp24975
g15
V34509
p24976
stp24977
a((dp24978
g2
(lp24979
VThis is a known issue
p24980
aVThe Standard is to blame or you for not providing a definition of the statics
p24981
aVDepending on your point of view :)
p24982
as(dp24983
g15
V34509
p24984
stp24985
a((dp24986
g2
(lp24987
VThat's because  is a non-dependent name, so it is looked up at the time the template is parsed, instead of being looked up at instantiation (when the base class is known)
p24988
aVUnqualified name lookup will not lookup and non-dependent names are never looked up in dependent base classes
p24989
aVYou can make the name  dependent as follows, which will also get rid of unqualified name lookup
p24990
aVAll of these will work
p24991
aVOr you can declare the name in the derived class with a using-declaration
p24992
aVNote that in  there will be no problem - it only affects
p24993
as(dp24994
g15
V34509
p24995
stp24996
a((dp24997
g2
(lp24998
VIt's common to delegate data that is independent of template arguments to a non-template base class, to avoid code duplication
p24999
aVIn this case, the address of the first element of the array is not dependent on any template argument, so you can move it out
p25000
aVIn a class small like that it probably wouldn't pay off, but cost/use ratio increases as the independent operations or the class itself grows
p25001
aVNote that if your goal is to have the class as aggregate then the above way is not feasible
p25002
aVYou will need to either delegate work to some other non-templated function and live with the (possibly very small anyway) generated template specializations or you just pass the address of the array manually
p25003
aVThis would also help making non-template functions more general
p25004
aVIncidentally, then you are at  which provides exactly that interface and other useful functions (still being an aggregate), although it's a bit too general in that it isn't fixed on
p25005
as(dp25006
g15
V34509
p25007
stp25008
a((dp25009
g2
(lp25010
VYou are trying to use  before it was declared
p25011
aVThat's why the compiler shouts at you
p25012
aVNotice that when you derive from a class, the class is generated if it comes from a class template
p25013
aVAnd the implicit generation of the class (which is called implicit instantiation) necessiates the generation of declarations for all its members (so the compiler knows the sizeof value of the class, and can perform lookup into it)
p25014
aVSo it also instantiates the declaration  and surely fails here
p25015
as(dp25016
g15
V34509
p25017
stp25018
a((dp25019
g2
(lp25020
VThat looks wrong
p25021
aVYour member function still accepts one argument
p25022
aVSo you need a placeholder, or you forgot to bind
p25023
aVAn  that accepts its class type looks a bit weird though
p25024
aVHere is an example how it should look for a "usual" subscript operator
p25025
as(dp25026
g15
V34509
p25027
stp25028
a((dp25029
g2
(lp25030
VYou can overload operators for enumeration types that return the proper typed result
p25031
aVIt should be noted that to be theoretically safe, you should declare manually the highest possible value so the enumeration type's range is guaranteed to catch all the combinations
p25032
aVActually that is not needed: An enumeration's range will always be able to catch all combination, because the highest positive value of an enumeration's range is always  for the first  being able to represent the highest enumerator
p25033
aVThat value has all bits 1
p25034
as(dp25035
g15
V34509
p25036
stp25037
a((dp25038
g2
(lp25039
VThe Standard lays it bare at 24
p25040
ag2790
aV1 as a note followed from the requirement rules
p25041
aVAnd since everyone wants to hear Standardese, I'm quoting it
p25042
aV[Note: For input iterators, a == b does not imply ++a == ++b
p25043
aV(Equality does not guarantee the substitution property or referential transparency
p25044
aVAlgorithms on input iterators should never attempt to pass through the same iterator twice
p25045
aVThey should be single pass algorithms
p25046
as(dp25047
g15
V34509
p25048
stp25049
a((dp25050
g2
(lp25051
VIf you want to run your program on a hosted C++ implementation, you need a  function
p25052
aVThat's just how things are defined
p25053
aVYou can leave it empty if you want of course
p25054
aVOn the technical side of things, the linker wants to resolve the  symbol that's used in the runtime library (which has no clue of your special intentions to omit it - it just still emits a call to it)
p25055
aVIf the Standard specified that  is optional, then of course implementations could come up with solutions, but that would need to happen in a parallel universe
p25056
aVIf you go with the "Execution starts in the constructor of my global object", beware that you set yourself up to many problems related to the order of constructions of namespace scope objects defined in different translation units (So what is the entry point
p25057
aVThe answer is: You will have multiple entry points, and what entry point is executed first is unspecified
p25058
aVIn C++03 you aren't even guaranteed that  is properly constructed (in C++0x you have a guarantee that it is, before any code tries to use it, as long as there is a preceeding include of )
p25059
aVYou don't have those problems and don't need to work around them (wich can be very tricky) if you properly start executing things in
p25060
aVAs mentioned in the comments, there are however several systems that hide  from the user by having him tell the name of a class which is instantiated within
p25061
aVThis works similar to the following example
p25062
aVTo the user of this system, it's completely hidden that there is a  function, but that macro would actually define such a main function as follows
p25063
aVThis doesn't have the problem of unspecified order of construction mentioned above
p25064
aVThe benefit of them is that they work with different forms of higher level entry points
p25065
aVFor example, Windows GUI programs start up in a  function -  could then define such a function instead on that platform
p25066
as(dp25067
g15
V34509
p25068
stp25069
a((dp25070
g2
(lp25071
VYour question only makes sense to me when interpreted such as
p25072
aVI'm assuming you are on 8 bit byte platform, and that by shifting you mean shift the bits when interpreted as a long bit-sequence of consecutive bytes (and there need to be one char after the array to account for the shift)
p25073
aVThen indeed the value stored at address  will then be stored at
p25074
aVHowever if you do a loop like this
p25075
aVAnd assume 8 bit bytes you will just nullify everything there, byte for byte shifting away all bits
p25076
as(dp25077
g15
V34509
p25078
stp25079
a((dp25080
g2
(lp25081
VIt doesn't work like that
p25082
aVis a full blown type, instead of a template
p25083
aVSo you need type parameters
p25084
aVFor getting  and  it's useful to export them so you can use them in  as shown above
p25085
aVBe sure to read Where to put the "template" and "typename" on dependent names to understand why and when to use  before type names like above
p25086
as(dp25087
g15
V34509
p25088
stp25089
a((dp25090
g2
(lp25091
VThe example you refer to is known to be inconsistent
p25092
aVThe committee hasn't yet fixed this
p25093
aVSo, is this a bug in GCC and VS2010
p25094
aVI don't think it's a bug in either of GCC/VS2010/Clang or Comeau
p25095
aVIt appears to be a bug in the C++ Standard
p25096
aVIn these cases, compile writers have to make up their mind on what is most viable
p25097
aVIf you remove the example in question, then 3
p25098
aV3/4 states the example is valid: "Given a set of declarations in a single declarative region, each of which specifies the same unqualified name,
p25099
aVthey shall all refer to the same entity, or all refer to functions and function templates; or
p25100
aVThe question arises, as discussed in the linked issue, what 7
p25101
ag1037
aV3/8 refers to when it says "declarations", which the committee didn't reach consensus about
p25102
aVAnd so, until then 3
p25103
aV3/4 applies for GCC/VS2010 and Clang, while Comeau chooses to use some other semantics
p25104
as(dp25105
g15
V34509
p25106
stp25107
a((dp25108
g2
(lp25109
VAccording to the C++03 Standard, that code is ill-formed because template argument deduction will not be able to deduce  or  against
p25110
aVC++03 missed to state that the reference is stripped off from the return type of the conversion function prior to deduction, so you can never get a match in your case
p25111
aVFor C++0x, this will be fixed and is included in the latest working paper, so it may compile with some compilers that include the fix retroactively
p25112
aVYour code actually has a different problem: GCC does implement that defect report resolution, and therefor compares  (it strips off cv-qualifiers prior to deduction
p25113
aVagainst  and against
p25114
aVOnly  matches and so only that first conversion function is the single candidate in a call with a  argument - that's why GCC complains about the missing  on the conversion function
p25115
aVIf you try the following code it would work
p25116
as(dp25117
g15
V34509
p25118
stp25119
a((dp25120
g2
(lp25121
VThis is an advanced topic of C++ if you want to do this in C++03
p25122
aVSee Howard Hinnants Unique_ptr C++03 emulation for an example of that
p25123
aVIt basically works by abusing several subtle rules in C++ overload resolution, in particular the rule that non-const references cannot bind to rvalue temporaries and that non-const conversion functions can still be called on non-const temporaries
p25124
aVYou can also use the auto_ptr technique as employed by C++03, which however is seen as broken by several groups because auto_ptr lets you copy variables, but steal resources from the copied-from object (other groups have other opinions about this)
p25125
as(dp25126
g15
V34509
p25127
stp25128
a((dp25129
g2
(lp25130
VYes your code is invalid
p25131
aVThis is an interesting show of how templates can change meaning of code in subtle ways
p25132
aVThe following code is valid:
p25133
aVStandard says at 7
p25134
ag1037
ag2790
aV2/3
p25135
aVIf a friend declaration in a non-local class first declares a class or function83) the friend class or function is a member of the innermost enclosing namespace
p25136
aVWhen is it a "first declared class"
p25137
aVIt says that too there
p25138
aVWhen looking for a prior declaration of a class or a function declared as a friend, and when the name of the friend class or function is neither a qualified name nor a template-id, scopes outside the innermost enclosing namespace scope are not considered
p25139
aVThe lookup for "class b" is delegated from 7
p25140
ag2790
ag1014
aV3/2 to 3
p25141
ag2670
aV4 which in turn delegates to unqualified name lookup at 3
p25142
aV4/7
p25143
aVAll the question now is whether the template-name "b" is visible in the friend declaration class a
p25144
aVIf it isn't, the name is not found and the friend declaration will refer to a new declared class at global scope
p25145
ag1037
ag1037
aV6/1 about the scope of it says
p25146
aVThe potential scope of a name declared in a class consists not only of the declarative region following
p25147
aVthe name\u2019s declarator, but also of all function bodies, default arguments, and constructor ctor-
p25148
aVinitializers in that class (including such things in nested classes)
p25149
aVIgnoring a few pedantic points that would make this wording not apply to here (which were a defect but are fixed in the C++0x version of that paragraph which also makes this easier to read), this list does not include the friend declaration as an area where that template name is visible
p25150
aVHowever, the friend was declared in a member class of a class template
p25151
aVWhen the member class is instantiated different lookup applies - the lookup for friend names declared in a class template
p25152
aVThe Standard says
p25153
aVFriend classes or functions can be declared within a class template
p25154
aVWhen a template is instantiated, the
p25155
aVnames of its friends are treated as if the specialization had been explicitly declared at its point of instantiation
p25156
aVSo the following code is invalid:
p25157
aVWhen that causes  to be implicitly instantiated, the name  is looked up at "// POI" as if there would have been an explicit specialization declared
p25158
aVIn that case, the template  has already been declared, and this lookup will hit it and emit an error because it's a template and not a non-template class
p25159
as(dp25160
g15
V34509
p25161
stp25162
a((dp25163
g2
(lp25164
VThe switch body is just a normal statement (in your case a compound statement, looking like ) which can contain any crap
p25165
aVIncluding case labels
p25166
aVThis switch philosophy is abused by Duffs device
p25167
aVMany people don't realize that even something like  is a valid statement (instead of having a compound statement, it has a null statement as body), although quite useless
p25168
as(dp25169
g15
V34509
p25170
stp25171
a((dp25172
g2
(lp25173
VYou can work around this by having an explicit  class like the following
p25174
aVNow the following semantics apply
p25175
aVAlternatively, you can use a conversion function
p25176
aVThis relies on a subtle corner of the C++ language
p25177
aVSo if you use this, you better know what you're doing or you don't do it: It first calls the conversion function on HugoCopy (or in the first case, the constructor of ) to get a  / , and then it direct initializes the destination  object with that  object
p25178
aVGCC doesn't like the code, but Clang and Comeau/EDG accept it according to the above semantics
p25179
as(dp25180
g15
V34509
p25181
stp25182
a((dp25183
g2
(lp25184
VYou have two options
p25185
aVOne of which was mentioned already: Using
p25186
aVThis however has the disadvantage that it doesn't work in strict C++03, but requires a sufficiently C99/C++0x compatible preprocessor
p25187
aVThe other option is to parenthesize the type-name
p25188
aVBut unlike another answer claims, it's not as easy as just parenthesizing the type name
p25189
aVWriting a specialization as follows is ill-formed
p25190
aVI have worked around this (and boost probably uses the same under the hood) by passing the type name in parentheses, and then building up a function type out of it
p25191
aVWith that,  denotes the type
p25192
aVNow you can rewrite your macro to
p25193
aVAnd you just need to pass the type wrapped in parentheses
p25194
as(dp25195
g15
V34509
p25196
stp25197
a((dp25198
g2
(lp25199
VIt's because you have a broken compiler
p25200
aVBroken compilers can choose their behavior themselfs
p25201
aVI know some compilers have this broken handling of that case
p25202
aVLook on MSDN about a manual that documents that broken behavior
p25203
aVIt works fine with compliant (non-broken in this regard) compilers
p25204
as(dp25205
g15
V34509
p25206
stp25207
a((dp25208
g2
(lp25209
VWith the most recent draft (n3225), your code is in fact ambiguous
p25210
aVThe candidates that are in vector will be
p25211
aVThe question is: Is a list-initialization of a  a better/worse conversion sequence than a list-initialization of a
p25212
aVOverload resolution will make both conversions user defined conversion sequences
p25213
aVThis means they are not comparable because there is no rule that can do so
p25214
aVThis is handled by core issue #1079
p25215
aVIf that issue gets accepted, the intention is that your code calls the second candidate
p25216
aVIncidentally, Jason Merril is a GCC developer :)
p25217
as(dp25218
g15
V34509
p25219
stp25220
a((dp25221
g2
(lp25222
VAnother guy told you were the problem is (static initialization order fiasco)
p25223
aVI'll provide you with one solution
p25224
aVYou need to get rid of the constructor, so the type will become a POD
p25225
aVThen you need to initialize it with a braced initializer list that only contains constant expressions (this is not limited to only integral constant expressions)
p25226
aVAlternatively, but only in the case of zeros, you can leave off the explicit values and just use empty braces
p25227
aVIn such cases, C++ guarantees you that the values are initialized before any of your code that tries to read it runs
p25228
as(dp25229
g15
V34509
p25230
stp25231
a((dp25232
g2
(lp25233
VBecause of perfect forwarding, when the argument to  is an lvalue, then  will be deduced to the argument's type plus having a  attached
p25234
aVSo you get  with  being
p25235
aVIf the argument is an rvalue then  will be deduced to only the argument's type, so you would get an  argument with  being  if you would pass, for example  directly
p25236
aVwill collapse to  (this is a semantic view - syntactically  is illegal
p25237
aVBut saying  when  is a template parameter or a typedef refering to a type , then  is still the type  - i
p25238
aVe the two references "collapse" to one lvalue reference)
p25239
aVThat's why  has type
p25240
as(dp25241
g15
V34509
p25242
stp25243
a((dp25244
g2
(lp25245
VThe expression is well defined in C++0x
p25246
aVA very Standardese quoting FAQ is given by Prasoon here
p25247
aVI'm not convinced that such a high ratio of (literal Standards quotes : explanatory text) is preferable, so I'm giving an additional small explanation: Remember that  is equivalent to , and that the value computation of that expression is sequenced after the increment of
p25248
aVAnd in , value computation of expression  is sequenced before assignment of the multiplication result into
p25249
aVWhat side effects do you have
p25250
aVIncrement
p25251
aVAssignment of the multiplication result
p25252
aVBoth side-effects are transitively sequenced by the above two sequenced after and sequenced before
p25253
as(dp25254
g15
V34509
p25255
stp25256
a((dp25257
g2
(lp25258
VIf you slightly change your declaration, you get an entire different story
p25259
aVThat isn't unambiguous anymore
p25260
aVIt could declare a variable of type  that is initialized by a bit-wise  expression
p25261
aVThe entire declaration would be templated
p25262
aVOf course, this semantically is all nonsense, but it syntactically is alright
p25263
aVThe appearance of a single  syntactically makes it unambiguous, but it's too much context dependence to make this work in a compiler
p25264
aVIt has to remember that it read a  or any other such thing, and when it parses the  after it will need to remember to take this name as a type
p25265
aVIt would also further bloat the already complicated Standard beyond belief
p25266
aVLet's again change your function declaration
p25267
aVNot even the appearance of  in there provides for a unambiguous parse
p25268
aVShould it be a function declaration with an unnamed parameter, or should it be a function declaration with an invalid parameter name that misses its type
p25269
aVA parameter's name is parsed by a , which can also be a qualified name
p25270
aVSo here, the  will belong to the type specifiers, while the  will be parsed by the compiler as the name of the parameter, in absence of a
p25271
aVThat is totally nonsense too, but is syntactically valid
p25272
aVIn the case of base-class names name lookup itself states that non-type names are ignored
p25273
aVSo you get omission of  for free: The name that name lookup yields to more higher level modules of the compiler either refers to a type, or name lookup will have given an error
p25274
aVI have written a FAQ entry about Where to put the "template" and "typename" on dependent names
p25275
as(dp25276
g15
V34509
p25277
stp25278
a((dp25279
g2
(lp25280
VIt's not objectively bad to typedef pointer types
p25281
aVMuch well written code uses it to typedef pointer to handler function types and it's also common for things like
p25282
aVIt may be one's personal opinion that it's bad, but it definitely isn't well-accepted opinion
p25283
aVI for one don't agree with that opinion at all
p25284
aVI myself use that option more seldom, but I still don't think it's "bad"
p25285
as(dp25286
g15
V34509
p25287
stp25288
a((dp25289
g2
(lp25290
VThe standalone  function only accepts one , and the  needs to be strictly nonnegative or , otherwise behavior is undefined
p25291
aVAnother version of  exists, which however is a template
p25292
aVBoth of these facts make it difficult to use them with  easily and safely
p25293
aVC++ also provides  in its  facet, which you can use here
p25294
aVHowever the whole code shows you aren't familiar with arrays and points, so maybe you should start using  and easy to use algorithms
p25295
aVLook into 's case conversions
p25296
as(dp25297
g15
V34509
p25298
stp25299
a((dp25300
g2
(lp25301
VThe following two are equivalent
p25302
aVYou may have have seen that pattern before with function pointers
p25303
aVNow just replace the  with  to create an array instead of a function part, and replace  by  to create a reference instead of a pointer, and replace the  by a function declarator
p25304
aVThen you get a function that returns a reference to an array of size
p25305
aVYou may want to look into , which contains a similarly typed function declaration
p25306
aVIf you take out the inner declarator that actually declares the function, you get the same pattern
p25307
aVIt will return a pointer to a function that takes an  and returns , as described in that manpage
p25308
aVThe following is just a way to yield a compiler error if some condition is not satisfied
p25309
aVIf the test  turns out to be , the array created is of zero size, which is illegal in C++, and will earn a compile time error
p25310
aVIf it evaluates to true, nothing happens except the array being declared
p25311
as(dp25312
g15
V34509
p25313
stp25314
a((dp25315
g2
(lp25316
VC++0x changes a number of previously undefined cases to now conditionally-supported cases
p25317
aVThe semantics is:
p25318
aVIf the implementation does not support the conditionally-supported feature, it shall document that and shall emit a diagnostic for a program that violates it
p25319
aVIf the implementation does support it, it should behave to additional requirements the Standard makes on it
p25320
aVFor example, the Standard might say something is conditionally-supported with implementation-defined semantics
p25321
aVIf so, the implementation shall document how it supports the feature
p25322
aVA popular case that previously was undefined is when passing an argument of class type having a non-trivial copy constructor, a non-trivial move contructor, or a non-trivial destructor though an ellipsis function parameter
p25323
aVThis is now conditionally-supported, with implementation-de\ufb01ned semantics
p25324
as(dp25325
g15
V34509
p25326
stp25327
a((dp25328
g2
(lp25329
VJust create an array
p25330
aVIf  can be arbitrarily large (say, like 4 million), it's better to use  though, because it can tell you whether allocation succeeded or not (although some operation systems in certain configurations will lie to you, telling you enough memory is available, only to then later crash when you try to access it)
p25331
aVIf the above array's allocation fails, behavior is undefined
p25332
aVNot all compiles support arrays with a variable size, though
p25333
as(dp25334
g15
V34509
p25335
stp25336
a((dp25337
g2
(lp25338
VIt won't remain valid
p25339
aVThe temporary object will be destroyed after initializing
p25340
aVAt the time you call  you invoke undefined behavior by calling
p25341
aVOnly the following is valid:
p25342
as(dp25343
g15
V34509
p25344
stp25345
a((dp25346
g2
(lp25347
VThe Standard rules at [basic
p25348
aVstc
p25349
aVdynamic
p25350
aVdeallocation]p3
p25351
aVOtherwise, the
p25352
aVvalue supplied to  in the standard library shall be one of the values returned
p25353
aVby a previous invocation of either  or  in the standard library, and the value supplied to  in the standard library shall be one of the values returned by a previous invocation of
p25354
aVeither  or
p25355
aVin the standard library
p25356
aVYour  call will call the libraries' , unless you have overwritten it
p25357
aVSince you haven't said anything about that, I will assume you haven't
p25358
aVThe "shall" above really should be something like "behavior is undefined if not" so it's not mistaken as being a diagnosable rule, which it isn't by [lib
p25359
aVres
p25360
aVon
p25361
aVarguments]p1
p25362
aVThis was corrected by n3225 so it can't be mistaken anymore
p25363
as(dp25364
g15
V34509
p25365
stp25366
a((dp25367
g2
(lp25368
VYes, it's wrong
p25369
aVYou need the
p25370
aVSee the typename and template FAQ entry
p25371
aVis a dependent type and  is a dependent type too
p25372
aVThis is legal in C++0x, but it's illegal in current C++
p25373
as(dp25374
g15
V34509
p25375
stp25376
a((dp25377
g2
(lp25378
VWhy GCC and Clang think they are right
p25379
aV, which is the injected class name, has a dual nature in the scope of
p25380
aVYou can use it without template arguments
p25381
aVThen it refers to  (to its own type)
p25382
aVIt can be followed by a template argument list too
p25383
aVIMO it's reasonable to say that you need to prefix it with  because of the parser ambiguity with the  that follows
p25384
aVIt then refers to the specified type that's determined by the template arguments
p25385
aVSo it can be treated as a member template and as a nested type, depending on whether it's followed by a template argument list
p25386
aVOf course,  is not really a member template
p25387
aVThe dual nature of the injected class name seems to me more of a hack anyway, though
p25388
aVThe Standard has an example that reads like this:
p25389
aVOne might be inclined to conclude from this that the intent is that you could leave off the
p25390
aVThe Standard says
p25391
aVFor a template-name to be explicitly qualified by the template arguments, the name must be known to refer to a template
p25392
aVI can't see how this wouldn't apply to
p25393
aVIf  is a dependent type then you can just lean back because you can't know what  refers to when parsing it, so to make any sense of the code, you just have to be able to prefix it with
p25394
aVNotice that n3225 has that example too, but it's not a defect there: You can officially leave off  if you lookup into the template's own scope in C++0x (it's called the "current instantiation")
p25395
aVSo until now, Clang and GCC are fine
p25396
aVWhy Comeau is right
p25397
aVJust to make it even more complicated, we will have to consider the constructors of
p25398
aVThere is a default constructor and a copy constructor implicitly declared
p25399
aVA name  will refer to the constructor(s) of  unless the name lookup used will ignore function (constructor) names
p25400
aVWill  ignore function names
p25401
ag1037
ag2670
aV4/3 says about elaborated type specifiers, which  is one of:
p25402
aVIf the name is a qualified-id, the name is looked up according its qualifications, as described in 3
p25403
ag2670
aV3, but ignoring any non-type names that have been declared
p25404
aVHowever, a  uses different lookup
p25405
aV14
p25406
aV6/4 says
p25407
aVThe usual qualified name lookup (3
p25408
ag2670
aV3) is used to find the qualified-id even in the presence of typename
p25409
aVThe usual qualified lookup of 3
p25410
ag2670
aV3 won't ignore non-type names, as illustrated by the example attached to 14
p25411
aV6/4
p25412
aVSo, we will find the constructor(s) as specified by 3
p25413
ag2670
ag1037
aV1/1a (the additional twist that this only happens when non-types are not ignored was added by a later defect report, which all popular C++03 compilers implement though):
p25414
aVIf the nested-name-specifier nominates a class C, and the name specified after the nested-name-specifier, when looked up in C, is the injected-class-name of C (clause 9), the name is instead considered to name the constructor of class C
p25415
aVSuch a constructor name shall be used only in the declarator-id of a constructor definition that appears outside of the class definition
p25416
aVSo in the end, I think comeau is correct to diagnose this, because you try to put a template argument list onto a non-template and also violate the requirement quoted in the last part (you use the name elsewhere)
p25417
aVLet's change it by accessing the injected name by a derived class, so no constructor name translation occurs, and you really access the type so that you really can append the template arguments:
p25418
aVEverything compiles now with comeau too
p25419
aVNotice I already did problem report to clang about this exact thing
p25420
aVSee Incorrect constructor name resolution
p25421
aVBTW, if you declare a default constructor in , you can see comeau give a better error message if you use
p25422
as(dp25423
g15
V34509
p25424
stp25425
a((dp25426
g2
(lp25427
VC++ syntax is more crazy than that
p25428
aVOthers have commented about your example
p25429
aVThe  specifier does not yield to lookup ignoring non-type names
p25430
aVSo if you say , and there is an object name  in , it will still be found instead of the type name  (GCC however ignores non-type names in looking up a name after a
p25431
aVBut that's not Standards compliant)
p25432
aVAnswers to edits:
p25433
aVConsider this,
p25434
aVSo from the context, it's still clear enough to the compiler that T::X is a type, no matter whether it appears before typedef,or after typedef
p25435
aVThe compiler has to know when the declaration specifiers and (i
p25436
aVe the "type section" and when the declarator section start (i
p25437
aVe the "names" section)
p25438
aVThere are declarations where the type section is empty:
p25439
aVIf the first name you specify is not a type, the type section ends, and the name section starts
p25440
aVSaying  tells the compiler:
p25441
aVNow I want to define
p25442
aVIt reads from left to right, so it will think you forgot a semicolon when it then encounters the
p25443
aVInside classes the interpretation is slightly different but much like this too
p25444
aVThat's a simple and effective parse
p25445
aVSame argument holds true for new as well
p25446
aVI tend to agree with you here
p25447
aVSyntactically it should be unambiguous if you leave off parentheses
p25448
aVAs I've never written a C++ parser, there may be hidden pitfalls I'm not seeing, though
p25449
aVEvery addition of  in corner cases of the language like in  will potentially require substantial amount of design for both compilers and standards writers, while still requiring  for the vast majority of other cases where it's needed
p25450
aVI don't think that this pays off
p25451
as(dp25452
g15
V34509
p25453
stp25454
a((dp25455
g2
(lp25456
VThis:
p25457
aVgives rise to this instantiation:
p25458
aVapplied to a type that is a reference is a no-op
p25459
aVCompare it with a non-static member function operating on a reference data member:
p25460
aVYou have to pass  to  to achieve your goal
p25461
as(dp25462
g15
V34509
p25463
stp25464
a((dp25465
g2
(lp25466
V is a keyword
p25467
aVThe sequence  tries to declare an assignment operator which in your case would have a pointer parameter type
p25468
aVAnd your compiler wants to parse the very last  as a special specifier like  (afaik an extension of MSVC),  or such
p25469
aVRename the variable to something else, like
p25470
as(dp25471
g15
V34509
p25472
stp25473
a((dp25474
g2
(lp25475
VThis is not an assignment
p25476
aVIt's a declaration
p25477
aVYou can put declarations elsewhere as conditions, as in the following
p25478
aVThis is a rarely used form, but it isn't an expression specified there
p25479
aVWhat you have done there is declaring a variable  which you can use in the body
p25480
aVAnd parentheses aren't allowed around such a declaration
p25481
aVI think that would make no sense
p25482
as(dp25483
g15
V34509
p25484
stp25485
a((dp25486
g2
(lp25487
V with  being  is a better match because it will have parameter type  matching a non-const  lvalue, while the other has a  that will make it a bit worse match
p25488
aVThere was some confusion during the made-up process of C++0x and before as to whether templates can be used to copy an object of a class to its own class type
p25489
aVThe committee just recently figured they want to stop the confusion about it and allow such a thing
p25490
aVVS2010 seems to reflect that decision
p25491
as(dp25492
g15
V34509
p25493
stp25494
a((dp25495
g2
(lp25496
VIt isn't too easy and in C++03 it isn't in general possible
p25497
aVIf you use  and  for  for example, you will get a hard error at compile time
p25498
aVSo for non-class types, you need to filter out the types that the Standard forbids
p25499
aVFor  I once wrote such a thing for the kicks
p25500
aVNote that I'm using  headers, because I needed to test the code with the  compiler too, which at that time didn't support my C++ headers:
p25501
aVOf course, it's very important to do tests afterwards
p25502
as(dp25503
g15
V34509
p25504
stp25505
a((dp25506
g2
(lp25507
VIt's constructed by
p25508
aVFirst time that object is created,  and friends are created
p25509
aVIf the last object is destroyed,  and friends are flushed (calling )
p25510
aVIn C++0x it will be guaranteed that if you include , and use of  and friends after the  will use constructed  and friends objects
p25511
aVIn C++03, it is said that
p25512
aVThe objects are constructed, and the associations are established at some time prior to or during first time an object of class  is constructed, and in any case before the body of main begins execution
p25513
as(dp25514
g15
V34509
p25515
stp25516
a((dp25517
g2
(lp25518
VThis virtual member function will be instantiated whenever the enclosing class is instantiated on most implementations
p25519
aVYou don't have to use it for that instantiation to occur:
p25520
aVHowever when is a , the use of  will be ill-formed
p25521
aVSo this derivation is wrong:
p25522
aVFWIW you don't need to specialize for  being
p25523
aVYou can have a return statement in a void function with an expression that has type  just fine
p25524
aVWOW, now I see you are also slicing objects in your  class template
p25525
aVIf you don't know what "slicing" is about, I recommend you to read on basic C++ topics first, before writing this sort of code
p25526
as(dp25527
g15
V34509
p25528
stp25529
a((dp25530
g2
(lp25531
VSadly you cannot
p25532
aVThe spec says at 7
p25533
ag2790
ag488
aV4/3 and follows
p25534
aVOtherwise, the type of the variable is deduced from its initializer
p25535
aVThe name of the variable being declared shall not appear in the initializer expression
p25536
aVThis use of auto is allowed when declaring variables in a block (6
p25537
aV3), in namespace scope (3
p25538
ag1037
aV6), and in a for-init-statement (6
p25539
ag1014
aV3)
p25540
aVThe auto type-specifier can also be used in declaring a variable in the condition of a selection statement (6
p25541
aV4) or an iteration statement (6
p25542
aV5), in the type-speci\ufb01er-seq in the new-type-id or type-id of a new-expression (5
p25543
ag1037
aV4), in a for-range-declaration, and in declaring a static data member with a brace-or-equal-initializer that appears within the member-specification of a class definition (9
p25544
ag2670
aV2)
p25545
aVA program that uses auto in a context not explicitly allowed in this section is ill-formed
p25546
aVI'm not sure why they forbid  for non-static data members, it would be quite handy
p25547
as(dp25548
g15
V34509
p25549
stp25550
a((dp25551
g2
(lp25552
VOne reason certainly is because it doesn't hurt
p25553
aVOne reason where it's needed is, if you have default arguments for the first parameter
p25554
aVThe constructor becomes a default constructor, but can still be used as converting constructor
p25555
aVC++0x makes actual use of it for multi parameter constructors
p25556
aVIn C++0x, an initializer list can be used to initialize a class object
p25557
aVThe philosophy is
p25558
aVif you use , then you initialize the object with a sort of "compound value" that conceptually represents the abstract value of the object, and that you want to have converted to the type
p25559
aVif you use a  initializer, you directly call the constructors of the object, not necessarily wanting to specify a conversion
p25560
aVConsider this example
p25561
aVIn this way, C++0x shows that the decision of C++03, to allow explicit on other constructors, wasn't a bad idea at all
p25562
as(dp25563
g15
V34509
p25564
stp25565
a((dp25566
g2
(lp25567
VI think I would answer in an implementation independent way
p25568
aVThe  is easier to read to me because it's just showing me what it does
p25569
aVWhereas for  I first have to scan all the addition
p25570
aVI prefer to go for the choice that's more foolproof
p25571
aVThe former, , evaluates to the prior value, so you can use it to express things in sometimes surprisingly simpler manners
p25572
aVFor instance
p25573
aVApart from these considerations, I don't think any of them is more efficient, assuming you have to do with basic integer types
p25574
as(dp25575
g15
V34509
p25576
stp25577
a((dp25578
g2
(lp25579
VThe purpose of them is so you could pass more than one argument to a class' constructor:
p25580
aVThere is no mechanism that the  style cast would be able to pass multiple arguments, so a new form of conversion was needed
p25581
aVIt's natural to define  as a degenerate case of
p25582
aVContrary to what some people here say,  works exactly like , so it will work just fine with class types too
p25583
as(dp25584
g15
V34509
p25585
stp25586
a((dp25587
g2
(lp25588
VYou are going to have more problems than that
p25589
as(dp25590
g15
V34509
p25591
stp25592
a((dp25593
g2
(lp25594
VIn current C++, you can't use  like in that code
p25595
aVFor a conversion of  to  you can only use  (or the equivalent C-style cast)
p25596
aVFor a conversion between different function type pointers or between different object type pointers you need to use
p25597
aVIn C++0x,  will be equivalent to
p25598
aVIt's probably incorporated in one of the next WPs
p25599
aVIt's a misconception that  would interpret the bits of  as if they were representing a
p25600
aVIn that case it will read the value of  using 's type, and that value is then converted to a
p25601
aVAn actual type-pun that directly reads the bits of  using the representation of type  only happens when you cast to a reference type, as in
p25602
aVAs far as I know, all current compilers allow to  from  and behave equivalent to the corresponding , even though it is not allowed in current C++03
p25603
aVThe amount of code broken when it's rejected will be no fun, so there is no motivation for them to forbid it
p25604
as(dp25605
g15
V34509
p25606
stp25607
a((dp25608
g2
(lp25609
VIt's always a function declaration in C++ (and in C), except when it appears as a parameter declaration, in which case it declares a function pointer
p25610
aVThe inverse can't be stated though:
p25611
aVIs "T var;" always an object declaration in C++
p25612
aVNo it isn't, because  can be a function type, in which case  will be declared as a function, except when it appears as a parameter declaration, as above
p25613
as(dp25614
g15
V34509
p25615
stp25616
a((dp25617
g2
(lp25618
VThe base field in the format flags of  dictates how to interpret numbers
p25619
aVThe field can be set to ,  and to
p25620
aVBy default it's set to
p25621
aVIf it's set to none of them,  will behave like 's  flag:
p25622
as(dp25623
g15
V34509
p25624
stp25625
a((dp25626
g2
(lp25627
Vhow is the code compiled if not in C++
p25628
aVWith C
p25629
aVhow would the code continue to function without that header
p25630
aVThat's why the header is included
p25631
aVIf it would compile and work without the header with a C++ compiler, the  would be pretty pointless
p25632
aVwhat circumstances would require this
p25633
aVThey may just bring in stuff needed when compiling with a C++ compiler
p25634
aVMaybe a debug macro needs to use , then that header may include
p25635
aVIt could have millions of reasons
p25636
as(dp25637
g15
V34509
p25638
stp25639
a((dp25640
g2
(lp25641
VA common way to solve it is to factor out the virtual functions into their own interface that doesn't depend on template parameters:
p25642
aVYou can then write
p25643
as(dp25644
g15
V34509
p25645
stp25646
a((dp25647
g2
(lp25648
VNot sure why you commented out one op[], but you have a bug there
p25649
as(dp25650
g15
V34509
p25651
stp25652
a((dp25653
g2
(lp25654
VThey are of type  where  is the number of characters including the terminating
p25655
aVSo yes you can assign them to , but you still cannot write to them (the effect will be undefined)
p25656
aVWrt : It points to an array of pointers to strings
p25657
aVThose strings are explicitly modifiable
p25658
aVYou can change them and they are required to hold the last stored value
p25659
as(dp25660
g15
V34509
p25661
stp25662
a((dp25663
g2
(lp25664
VCMain gets deallocated just fine, but ~CList() is never called
p25665
aVThat sounds like a wrong statement
p25666
aVIf  is called, then  is eventually called too, because it's a base class
p25667
aVCheck how you detect whether or not a destructor is called
p25668
aVWhen you say "CMain gets deallocated", do you mean to say you issue  on it
p25669
aVCheck that at the point you do , the class definition of  is visible
p25670
aVIn absence of its definition, the compiler is allowed to assume the class doesn't have a user defined or virtual destructor, and can omit calling it
p25671
as(dp25672
g15
V34509
p25673
stp25674
a((dp25675
g2
(lp25676
VThe cases are logically labels
p25677
aVMany people put labels at the same indentation level as the block they are in
p25678
aVIn my opinion, that way it's easier to read through the text
p25679
aVI compare it with a timeline you can scroll through
p25680
aVYou have markers on the time line itself, not indented into the content
p25681
aVYou can then quickly point out where labels/markers are, without moving your eye away from the base-line
p25682
as(dp25683
g15
V34509
p25684
stp25685
a((dp25686
g2
(lp25687
VYou are only seeing this if  in some way depends on template arguments
p25688
aVIn that case, it's deemed too dangerous that a name like  is lookup up in such a dependent base class: For some template instantiation, the name could be found in the base class, and for another instantiation, the member could be absent and the name would refer to a some namespace member
p25689
aVBecause this was thought to be confusing, C++ follows the consistent rule that  is never lookup in a dependent base class when doing unqualified name lookup
p25690
aVYou need to prefix the name with  or with the name of the class as in
p25691
aVSo when the base class doesn't declare a , the name doesn't silently refer to a potentially globally declared name, but it will just be a compile time error
p25692
as(dp25693
g15
V34509
p25694
stp25695
a((dp25696
g2
(lp25697
VOutside class scope (if you are in a block etc), you can only name namespace members in a using declaration
p25698
aVIf you don't want to place that using declaration into the scope of  (which IMO is the favorable solution), your other option is to use a reference
p25699
aVIt should be noted that this is semantically different, because it
p25700
aVForces a definition to exist for , which might not be the case for static const data members
p25701
aVForces  to be of type  or be convertible to type
p25702
aVOtherwise, if you want to avoid using  all again, I don't see other options
p25703
as(dp25704
g15
V34509
p25705
stp25706
a((dp25707
g2
(lp25708
VThe obvious return type is  :)
p25709
aVFor increased elaboration:
p25710
as(dp25711
g15
V34509
p25712
stp25713
a((dp25714
g2
(lp25715
VFor this case, you can specialize the member function only
p25716
as(dp25717
g15
V34509
p25718
stp25719
a((dp25720
g2
(lp25721
VThat's not legal according to Standard C++
p25722
aVSee 5
p25723
aV19/2 for the rules in the spec
p25724
as(dp25725
g15
V34509
p25726
stp25727
a((dp25728
g2
(lp25729
VTemplates don't work like that
p25730
aVIn your template  specifies a type, and not a sequence of tokens:
p25731
aVThere is no way to get  or  respectively
p25732
aVWhat you could try is using , but that isn't very helpful because it isn't required to be human readable and not even required to be distinct for each type
p25733
aVYou could try using geordi's file  , which can print out a human readable string when compiled with GCC
p25734
as(dp25735
g15
V34509
p25736
stp25737
a((dp25738
g2
(lp25739
VHere is how short circuit could work for a three-argument version
p25740
aVThat is, if  is true, it inherits , otherwise it inherits
p25741
aVYou need a stop criteria, which works like @begemoth shows: Specialize  for the first type being , which will define it's  to
p25742
as(dp25743
g15
V34509
p25744
stp25745
a((dp25746
g2
(lp25747
VAs has been said, you want to take the type that is more generic
p25748
aVLike,  and  should become ;  and  should become
p25749
aVThis works with my  template
p25750
aVJust write
p25751
aVThis will always return a copy, even if  and  is the same type (like ), which is why I would overload it for non-const same-type arguments
p25752
aVThese two variants seem to be a reasonable configuration
p25753
aVIf you want to have a slightly more risky, but in more cases performant, solution, you can accept , also accepting temporaries
p25754
aVIf you then use it like , which could pass temporaries, and use the result directly, that's all fine
p25755
aVThe result is usable and can still be copied into a local variable
p25756
as(dp25757
g15
V34509
p25758
stp25759
a((dp25760
g2
(lp25761
VIt just uses compiler magics
p25762
aVLike, GCC's
p25763
aVFor compilers that don't provide such magic, it provides an emulation that can detect the type of some expressions, but fails with completely unknown types
p25764
aVA possible implementation could be to have a list of functions that accept an expression of a given type, and then dispatch from that type to a number using a class template
p25765
aVTo make the function template return the number as a compile time entity, we put it into an array dimension
p25766
aVThen it goes from that number back to the type, so that our  could directly name the type
p25767
aVSo to register a type, we write
p25768
aVHaving this in place, you can write
p25769
aVWhenever you need to register a type, you write
p25770
aVOf course, now you find you need a mechanism to accept , where you don't know  in advance and then it gets arbitrary complex
p25771
aVYou could create a system where the numbers mean more than just a type
p25772
aVThis could probably work:
p25773
aVThis could detect types like  and also types like  - in other words, types that aren't class template specializations, and class template specializations with one template argument, by doing some kind of systematical mapping
p25774
aVIf the first number yields 1, the second number specifies a type; otherwise
p25775
aVthe first number specifies a template, and the second number its first type template argument
p25776
aVSo this becomes
p25777
aVWe also need to change the  template and split it up in two versions, shown below, alongside the  for registering one-argument templates
p25778
aVRegistering the  template and both  variants now look like
p25779
aVYou probably also want to register multiple numbers with each type, one number for each combination of const/volatile or may need more than one number per type for recording ,  and such
p25780
aVYou also want to support , so you need more than one number for the template argument too, making  call itself recursively
p25781
aVAs you can create an arbitrary long list of integers, you can encode anything into that sequence anyway, so it's just up to your creativity on how to represent these things
p25782
aVIn the end, you are probably reimplementing BOOST_TYPEOF :)
p25783
as(dp25784
g15
V34509
p25785
stp25786
a((dp25787
g2
(lp25788
VAs others and the compiler commented, strings are not allowed with
p25789
aVI would just use
p25790
aVI don't think that's any more complicated, and it's about as fast as it could get
p25791
aVYou could also use my switch macro, making it look like
p25792
aV(having  after a  is dead code, and so should be avoided)
p25793
as(dp25794
g15
V34509
p25795
stp25796
a((dp25797
g2
(lp25798
VThis doesn't work and it isn't intended to make it work for any further revision of C++
p25799
aVSo you cannot have that using declaration - use the ordinary  way when using it, instead
p25800
as(dp25801
g15
V34509
p25802
stp25803
a((dp25804
g2
(lp25805
VThe bug in your code is that you need to handle this when you still know you removed it
p25806
aVAfterwards you cannot handle it anymore
p25807
aVIn the following example,  returns true when the element should be removed
p25808
as(dp25809
g15
V34509
p25810
stp25811
a((dp25812
g2
(lp25813
VYes, this is called virtual inheritance
p25814
aVPeople cannot do  or  but they can do  and can convert a  to a
p25815
aVHowever once they do so, they can call  and , of course
p25816
aVYou haven't said anything about your goal, but it sounds like you really want to keep  as a pointer though
p25817
aVThis looks more familiar to me
p25818
as(dp25819
g15
V34509
p25820
stp25821
a((dp25822
g2
(lp25823
VIf you have a line of data that isn't necessarily a C-string, you use string's constructor
p25824
as(dp25825
g15
V34509
p25826
stp25827
a((dp25828
g2
(lp25829
VIt makes no difference when the type you  has a user declared constructor
p25830
aVIf it doesn't, then Line 4 will initialize all the members to zero first (but only call constructors for those members that have user declared constructors) and do the same to base classes
p25831
aVIf you don't want to have that done, use Line 3
p25832
aVThis rule also takes place for complex objects with virtual member functions, base classes and so on - only condition is whether or not the class has a user declared constructor
p25833
aVThis is a very subtle corner of C++, and I think I wouldn't base my code on these facts without having a comment explaining that in the code (oh dear, my colleagues will get mad at me otherwise)
p25834
as(dp25835
g15
V34509
p25836
stp25837
a((dp25838
g2
(lp25839
VLooks like it doesn't need to use loops
p25840
as(dp25841
g15
V34509
p25842
stp25843
a((dp25844
g2
(lp25845
VYou cannot define a function using a typedef for a function type
p25846
aVIt's explicitly forbidden - refer to 6
p25847
ag24816
aV1/2 and the associated footnote:
p25848
aVThe identi\ufb01er declared in a function de\ufb01nition (which is the name of the function) shall
p25849
aVhave a function type, as speci\ufb01ed by the declarator portion of the function definition
p25850
aVThe intent is that the type category in a function definition cannot be inherited from a typedef:
p25851
as(dp25852
g15
V34509
p25853
stp25854
a((dp25855
g2
(lp25856
VInstead of assignment, use initialization
p25857
aVYes that works
p25858
aVConstructor initializer lists have that exact purpose
p25859
as(dp25860
g15
V34509
p25861
stp25862
a((dp25863
g2
(lp25864
VI've created one today, and tested on GCC4
p25865
ag488
ag5250
aVSome test
p25866
aVSo while you don't get a , you still get compile time strings
p25867
as(dp25868
g15
V34509
p25869
stp25870
a((dp25871
g2
(lp25872
VI'm surprised no one mentioned the  namespace
p25873
aVIt defines , ,  and
p25874
aVYou can bring those in scope by a using directive or declaration and define a  and  for your type
p25875
aVThe operators provided by  then work in terms of these two
p25876
as(dp25877
g15
V34509
p25878
stp25879
a((dp25880
g2
(lp25881
VI heard boost has a foreach loop
p25882
aVIf you haven't boost at hands, I would go with a usual for loop
p25883
aVBut I don't think I would use nested   in the first place
p25884
aVIf you only ever have two-column rows, best use a vector of
p25885
as(dp25886
g15
V34509
p25887
stp25888
a((dp25889
g2
(lp25890
V1) Is there a recommended way to do this in general
p25891
aVYes, I would do it the way you did in 2)
p25892
aVI don't think there is any deeper meaning as to why 2) works
p25893
aVThe type  simply doesn't match , so it has no way to find out
p25894
aVIt will therefor ignore the template
p25895
as(dp25896
g15
V34509
p25897
stp25898
a((dp25899
g2
(lp25900
VThat's known as partial template specialization
p25901
aVOf course, you need a third one for  to play safe
p25902
aVOtherwise you will get an ambiguity of both are pointers
p25903
as(dp25904
g15
V34509
p25905
stp25906
a((dp25907
g2
(lp25908
VRaising an error in the situation of an empty class is a known problem, and reported as issue #253
p25909
as(dp25910
g15
V34509
p25911
stp25912
a((dp25913
g2
(lp25914
VThe type of both the expression  and the expression  is
p25915
aVA reference appearing in an expression won't keep reference type
p25916
aVInstead, the type of the expression will be the referenced type, with the expression being an lvalue
p25917
aVSo in both cases,  is deduced to , and thus the explicit specialization is not used at all
p25918
aVWhat's important to note (other than that you should really use overloading, as another guy said), is that you have a non-reference function parameter in your template
p25919
aVBefore any deduction of  against the argument type is done, the argument type will be converted from arrays to a pointer to their first element (for functions, arguments will be converted to function pointers)
p25920
aVSo a function template with a non-reference function parameter doesn't allow for accurate deduction anyway
p25921
as(dp25922
g15
V34509
p25923
stp25924
a((dp25925
g2
(lp25926
VA parameter declared as being an array of type  or  becomes actually a parameter of type
p25927
aVSame is done for functions (a parameter declared as  becomes actually a parameter of type )
p25928
aVSuch transformation however is not done for other declarations
p25929
aVThe reason it's done for function by-value parameters is that there is no way in C to actually copy an array directly (that is, to actually copy its contents) and it doesn't make sense to try and copy a function either, so such parameters are transformed in a way that conveys their purpose in a meaningful way
p25930
aVSo while you are initializing a pointer in the function parameter case, you are trying to initialize an array in the other case
p25931
as(dp25932
g15
V34509
p25933
stp25934
a((dp25935
g2
(lp25936
VThe reason of this is:
p25937
aVA SCS 1 is better than a SCS 2 if, among other things, SCS 1 binds a reference to const, and SCS 2 binds a reference to non-const
p25938
aVA UCS 1 is better than a UCS 2 if and only if, among other things, both use the same conversion function or constructor
p25939
aVFor , which uses a SCS, the first bullet will figure out a winner for the case where both functions are viable candidates (second call)
p25940
aVFor , the case where both functions are viable candidates (second call) there is no UCS better than the other UCS, because both UCSs use different constructors
p25941
aVNotice that an UCS is defined as
p25942
aVOne SCS (converting the argument to the parameter type of the constructor in case a constructor is used, and to  for a conversion operator function)
p25943
aVThe call to the user defined conversion (constructor or conversion operator function)
p25944
aVAnother SCS (converts the result of the conversion to the final destination type)
p25945
aVYou cannot formate a SCS for "const Y to Y&", so there exist no first SCS for the UCS for the second  function, and so it is not a viable candidate
p25946
aVThis is not true for the second call to  though, and it thus results in the ambiguity described above
p25947
aVI've shortened some terms:
p25948
aVUCS: User-defined Conversion Sequence
p25949
aVSCS: Standard Conversion Sequence
p25950
aVMy guess is no, in the sense that I managed to have PassConstY constructable from a const Y only (and not a mutable Y), which removes the ambiguity, but then point 2 is doomed to failure
p25951
aVThat suspicion of yours, if I understand you correctly, is not true
p25952
aVWith your current definitions, you can remove the mutable versions of both  and  and your code will compile fine
p25953
aVThere is an SCS for  to
p25954
aVYou can, of course, rewrite PassY and PassConstY as
p25955
aVOther than that, I'm not sure what you are heading at when you say "rewrite"
p25956
aVIf you want to just change the class body, then definitely overload resolution will be different
p25957
as(dp25958
g15
V34509
p25959
stp25960
a((dp25961
g2
(lp25962
VIt might be useful in C89 where you have an implicit int rule
p25963
aVBut then, you can just write straight  instead of
p25964
aVC99 doesn't have an implicit int rule anymore
p25965
aVSo I don't think  has any real purpose anymore
p25966
aVIt's "just the default" storage specifier
p25967
as(dp25968
g15
V34509
p25969
stp25970
a((dp25971
g2
(lp25972
VA quick glance over n3225 doesn't show any requirement that a name is required to be present
p25973
aVThe text that comes the most near just says
p25974
aVIn a simple-declaration, the optional init-declarator-list can be omitted only when declaring a class (clause 9) or enumeration (7
p25975
aV2), that is, when the decl-specifier-seq contains either a class-specifier, an elaborated- type-specifier with a class-key (9
p25976
aV1), or an enum-specifier
p25977
aVSo your code seems to be valid, but I think it smells bad
p25978
as(dp25979
g15
V34509
p25980
stp25981
a((dp25982
g2
(lp25983
VRules for conditional operator in the draft n3225 says at one point
p25984
aVOtherwise, the result is a prvalue
p25985
aVIf the second and third operands do not have the same type, and either
p25986
aVhas (possibly cv-quali\ufb01ed) class type, overload resolution is used to determine the conversions (if any) to be
p25987
aVapplied to the operands (13
p25988
ag1037
ag2790
aV2, 13
p25989
aV6)
p25990
aVIf the overload resolution fails, the program is ill-formed
p25991
aVOtherwise,
p25992
aVthe conversions thus determined are applied, and the converted operands are used in place of the original
p25993
aVoperands for the remainder of this section
p25994
aVUp to that point, every other alternative (like, convert one to the other operand) failed, so we will now do what that paragraph says
p25995
aVThe conversions we will apply are determined by overload resolution by transforming  into  (an imaginary function call to a so-named function)
p25996
aVIf you look what the candidates for the imaginary  are, you find (among others)
p25997
aVFor every type T , where T is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate operator functions of the form
p25998
aVAnd this includes a candidate for which  is the type
p25999
aVThis is important, because lambda expressions yield an object of a class that can be converted to such a type
p26000
aVThe spec says
p26001
aVThe closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator
p26002
aVThe value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator
p26003
aVThe lambda expressions can't be convert to any other of the parameter types listed, which means overload resolution succeeds, finds a single  and will convert both lambda expressions to function pointers
p26004
aVThe remainder of the conditional opreator section will then proceed as usual, now having two branches for the conditional operator having the same type
p26005
aVThat's why also your first version is OK, and why GCC is right accepting it
p26006
aVHowever I don't really understand why you show the second version at all - as others explained, it's doing something different and it's not surprising that it works while the other doesn't (on your compiler)
p26007
aVNext time, best try not to include useless code into the question
p26008
as(dp26009
g15
V34509
p26010
stp26011
a((dp26012
g2
(lp26013
VYou can solve the problem of making your  work
p26014
aVNow you can say
p26015
aVHope it helps
p26016
as(dp26017
g15
V34509
p26018
stp26019
a((dp26020
g2
(lp26021
VTemporary objects can be const, but they don't have to be
p26022
aVIt allows for various things
p26023
aVConsider
p26024
aVYou could do
p26025
aVThis is what's done by the  template
p26026
as(dp26027
g15
V34509
p26028
stp26029
a((dp26030
g2
(lp26031
VAccess only applies to names (and as a special case, to constructors/destructors)
p26032
aVIt doesn't apply to entities themselves
p26033
aVThe spec further elaborates
p26034
aV[ Note: because access control applies to names, if access control is applied to a typedef name, only the accessibility of the typedef name itself is considered
p26035
aVThe accessibility of the entity referred to by the typedef is not considered
p26036
aVFor example,
p26037
aV\u2014 end note ]
p26038
aVSo what you have disovered here isn't surprising
p26039
aVYou can get hold of the type  even in C++03, when taking the address of  by saying  and passing it to a function template deducing the return type
p26040
as(dp26041
g15
V34509
p26042
stp26043
a((dp26044
g2
(lp26045
VDetermining class types you could use the fact that member pointers exist
p26046
aVYou cannot detect the difference of an union and a non-union class
p26047
aVAt least I don't know how, and boost doesn't know either
p26048
aVI think detecting enums could work by making sure  isn't a class, function or integral type, and then trying to assign to an integral type
p26049
aVYou could
p26050
aVQuick & dirty test (works on GCC/clang/comeau):
p26051
as(dp26052
g15
V34509
p26053
stp26054
a((dp26055
g2
(lp26056
VAn operator is a symbol like , ,  and so forth (see 13
p26057
aV5)
p26058
aVThey don't carry a meaning
p26059
aVDuring semantic analysis, the meaning of an operator is determined
p26060
aVA function is a constructor, destructor, conversion function (that looks like ) or operator function (function template specialization and instantiation can yield these in turn)
p26061
aVAn operator function is something that implements an operator (see 13
p26062
aV5)
p26063
aVAn example is
p26064
aVThese are functions in all respects, and the only difference to "usual" functions is that they may be called implicitly and they have a funny name
p26065
aVSome operators have a built-in meaning, that can be changed by the programmer
p26066
aVOne refers to the built-in meaning of an operator simply by saying built-in operator (see 5/3)
p26067
aVHowever, if such an operator is applied on operands for which a built-in meaning is defined, changing that meaning is only allowed for a few cases (these are assignment, address-of and the comma operator, see 13
p26068
aV5/6)
p26069
as(dp26070
g15
V34509
p26071
stp26072
a((dp26073
g2
(lp26074
VIn the first case you are not implicitly converting  to
p26075
aVYou are converting it to an , so it's not an error
p26076
aVSaying  is regarded as a direct call to the constructor to initialize a  object
p26077
aVIn the second case, you are trying to implicitly convert  to a
p26078
aVThe constructor marked  will not be considered (as you rightfully say), and therefor you will get an error
p26079
as(dp26080
g15
V34509
p26081
stp26082
a((dp26083
g2
(lp26084
VThis depends on how  is defined
p26085
aVThe following is well-defined
p26086
aVIf you change the parameter type of  to , it becomes undefined
p26087
aVLet's draw a tree of the version taking an
p26088
aVAs can be seen, we have a read of  (designated by ) and a side-effect on  (at the very top) that are not separated by a sequence point: In this expression, relative to each other sub-expression, there is no sequence point at all
p26089
aVThe very bottom  signifies the full-expression sequence point
p26090
as(dp26091
g15
V34509
p26092
stp26093
a((dp26094
g2
(lp26095
VBecause they noticed that deprecation of  doesn't really make sense
p26096
aVIt won't ever be removed from C++, and it's still useful because you don't need the boilerplate code you need with unnamed namespaces, if you just want to declare a function or object with internal linkage
p26097
as(dp26098
g15
V34509
p26099
stp26100
a((dp26101
g2
(lp26102
VFWIW, I'm copying over my answer I gave to the usenet copy of this question:
p26103
aVHi all,
p26104
aV
p26105
aVI am very confused about the standard n3225 10
p26106
aV2/13,
p26107
ag26105
aV[ Note: Even if the result of name lookup is unambiguous, use of a
p26108
aVname found in multiple subobjects might still be ambiguous (4
p26109
aV11,
p26110
ag1014
ag976
aV5, 5
p26111
ag1037
aV1, 11
p26112
aV2)
p26113
aV\u2014end note ] [ Example:
p26114
ag26105
aVI cannot see why this is unambiguous int B1::* mpB1 = &D;::i; //
p26115
aVUnambiguous
p26116
ag26105
aVhas type , and unambiguously refers to data member  of
p26117
aVIf you dereference it with a  object or if you assign it to a , you will get an ambiguity as needed
p26118
ag26105
aVVisual C++, Gcc and CLang all say that it is ambiguous access to D::i
p26119
ag26105
aVNone of those compilers implement 10
p26120
aV2 yet
p26121
ag26105
aVThe wording seems to be related to the core issue #39
p26122
aVhttp://www
p26123
aVopen-std
p26124
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p26125
aVhtml#39, and
p26126
aVthe final proposal is here:
p26127
aVhttp://www
p26128
aVopen-std
p26129
aVorg/jtc1/sc22/wg21/docs/papers/2004/n1626
p26130
aVpdf
p26131
ag26105
aVI now find that the new algorithm-based wordings (10
p26132
aV2/3-10
p26133
aV2/6) are
p26134
aVeven more confusing because none of the note in 10
p26135
aV2/9, 10
p26136
aV2/10,
p26137
aV10
p26138
aV2/11, and 10
p26139
aV2/13 fully complies with 10
p26140
aV2/3-10
p26141
aV2/6
p26142
aVI can take
p26143
aV10
p26144
aV2/9-10
p26145
aV2/11 as exceptions, but I am especially confused about
p26146
aV10
p26147
aV2/13
p26148
aVI have no idea on the intention of 10
p26149
aV2/13
p26150
ag26105
aVYou need to give examples that show what you don't understand
p26151
ag26105
aVHow should the example in 10
p26152
aV2/13 be looked-up according to the
p26153
aV10
p26154
aV2/3-10
p26155
aV2/6
p26156
aVWhat's the intention of 10
p26157
aV2/13, i
p26158
ag1992
aV, what's the
p26159
aVsituation of which 10
p26160
aV2/13 is considered as an exception of
p26161
aV10
p26162
aV2/3-10
p26163
aV2/6
p26164
ag26105
aVThe new algorithm based lookup rules decouples runtime concerns (finding an
p26165
aVunique object) from compile time/lookup concerns (finding a declaration that
p26166
aVa name refers to)
p26167
ag26105
aVThe following is well-formed with the new wording:
p26168
aVThe declaration  introduces a member name into B that refers to
p26169
aVthe declaration
p26170
aVIn a declarative context, this is perfectly fine
p26171
aVAn
p26172
aVerror is risen only when you access  as a member access expression
p26173
aV(5
p26174
ag976
aV5)
p26175
ag26105
aVDon't feel bad about having mistaken this about the member pointer case
p26176
aVI did so too in the past, and the corresponding issue report actually made it into a C++0x draft
p26177
aVThey luckily changed it back when they noticed that change was wrong
p26178
as(dp26179
g15
V34509
p26180
stp26181
a((dp26182
g2
(lp26183
VPure virtual functions don't need a definition (as opposed to virtual functions), and they make their class abstract
p26184
aVAbstract classes can't have an object created from, except when they act as base class object
p26185
aVYour confusion seems to center around the presence or absence of the  keyword
p26186
aVIf a function is declared  in a base class, then a function of a derived class, whether or not you put a  keyword, will automatically become  if it has the same name, parameter types and constness
p26187
aVSo if you call XYZ on a  or  that actually points to a  object, then the XYZ of the  object will be executed
p26188
as(dp26189
g15
V34509
p26190
stp26191
a((dp26192
g2
(lp26193
VYes, this is supposed to work
p26194
aVIt's a GCC error
p26195
aVGCC doesn't support C++0x variadic templates to the fullest yet (and to be fair, the specification is still constantly changing in details)
p26196
aVWhat you say "This works" is really declaring a function; it doesn't initialize an object, which was what you intended
p26197
aVFor what you intended, see 14
p26198
ag1037
aV3p3 which describes how  can match , and 14
p26199
ag14557
ag976
aV5p9 which describes how  can match
p26200
as(dp26201
g15
V34509
p26202
stp26203
a((dp26204
g2
(lp26205
VYou can't easily solve this
p26206
aVand  don't support only functors callable by , but also pointer to members callable by  and data members, so their constructors basically slurp everything in, and later decide what to do with the type
p26207
aVIt's not trivial at all to write such a SFINAE testing class that guards from implicit conversions (and I'm not even sure whether it would be at all possible, since the Standard library doesn't do it
p26208
aVThat must have some reason)
p26209
aVRemember that a type may be callable because of many different properties - it may have a conversion function to function pointer type etc pp
p26210
aVWriting a SFINAE class that could make this work means to reject an implicit conversion in some cases and accept an implicit conversion in other cases based on really not obvious properties at all
p26211
aVIf you want to avoid this ambiguity, I would try just choose a different function name or if it's a one-shot problem, do the casting on the caller side
p26212
as(dp26213
g15
V34509
p26214
stp26215
a((dp26216
g2
(lp26217
VIt's legal both as a declaration in the immediate block scope, and as a function definition as a member function of a local class
p26218
as(dp26219
g15
V34509
p26220
stp26221
a((dp26222
g2
(lp26223
VYou can take advantage of the wrap-around behavior of unsigned integers
p26224
aVIt's important not to say , to avoid a warning again
p26225
aVThe following appears to trick GCC too
p26226
as(dp26227
g15
V34509
p26228
stp26229
a((dp26230
g2
(lp26231
VNo there is no simple way
p26232
aVThe type name will be rather long and even more unreadable
p26233
aVAnd if you use boost, you don't need to use , because you can just use  and have it readable, without a need for a local
p26234
as(dp26235
g15
V34509
p26236
stp26237
a((dp26238
g2
(lp26239
VAbout C and C++:
p26240
aVMy opinion is that using the parameter as a local variable of the function is fine because it is a local variable already
p26241
aVWhy then not use it as such
p26242
aVI feel silly too when copying the parameter into a new local variable just to have a modifiable variable to work with
p26243
aVBut I think this is pretty much a personal opinion
p26244
aVDo it as you like
p26245
aVIf you feel sill copying the parameter just because of this, it indicates your personality doesn't like it and then you shouldn't do it
p26246
as(dp26247
g15
V34509
p26248
stp26249
a((dp26250
g2
(lp26251
VYou are most probably using the C++0x version of the libstdc++ library
p26252
aVC++0x declares  as
p26253
aVIf  is , then  is , and therefor cannot take lvalues of type
p26254
aVQuite obviously,  is designed to be called without explicit template arguments
p26255
as(dp26256
g15
V34509
p26257
stp26258
a((dp26259
g2
(lp26260
VThe following does not violate the aliasing rule, because it has no use of lvalues accessing different types anywhere
p26261
as(dp26262
g15
V34509
p26263
stp26264
a((dp26265
g2
(lp26266
VThis appears to be an unfortunate ambiguity in the meaning of such a constructor
p26267
aVI think the most straight forward way to disambiguate this is to use a pointer
p26268
aVI know a lot of people who would expect the parameter to be a pointer anyway
p26269
aVIncidentally, you yourself mistyped  as
p26270
as(dp26271
g15
V34509
p26272
stp26273
a((dp26274
g2
(lp26275
VThis is totally fail
p26276
aVWhat you've done here:
p26277
aVInitialize an  from an uninitialized chunk of characters allocated on the heap
p26278
aVCompletely undefined behavior and leaks like hell
p26279
aVCall , thereby still copying a std::string
p26280
aVWhat you probably really wanted to do is  but even then this would be totally fail
p26281
aVThere isn't going to be any real difference of just doing
p26282
aVArguably, the construction from  is even more performant because  already knows the length of the string, while the length of  first has to be calculated by the constructor of
p26283
aVI recommend to first think through all you have written there
p26284
aVThe whole point of  is to avoid constructing an object just to pass it to  and copy it
p26285
aVBut in your case you already have an object so it doesn't really make sense to pass it through
p26286
as(dp26287
g15
V34509
p26288
stp26289
a((dp26290
g2
(lp26291
VIt's not required by the C spec that those values be put into memory
p26292
aVThe implementation can keep them in registers and never store them on memory for carrying out the addition or the compiler can even rewrite  into  and don't do any addition at all at runtime
p26293
aVAny real implementation does it like that
p26294
aVIn the language theory, in fact,  and  aren't referring to memory
p26295
aVThey are values (instead of merely representing a location where a value can be fetched from)
p26296
aVYou can easily see that by trying to write
p26297
aVIt won't work - there is no address you could receive
p26298
as(dp26299
g15
V34509
p26300
stp26301
a((dp26302
g2
(lp26303
VYou need to catch it with  instead of
p26304
aVNeither anything like  nor  will catch it
p26305
aVCatching has restricted rules with regard to what types it match
p26306
aVThe spec says (where "cv" means "const/volatile combination" or neither of them)
p26307
aVA handler is a match for an exception object of type E if
p26308
aVThe handler is of type cv T or cv T& and E and T are the same type (ignoring the top-level cv-qualifiers), or
p26309
aVthe handler is of type cv T or cv T& and T is an unambiguous public base class of E, or
p26310
aVthe handler is of type cv1 T* cv2 and E is a pointer type that can be converted to the type of the handler by either or both of
p26311
aVa standard pointer conversion (4
p26312
aV10) not involving conversions to pointers to private or   protected or ambiguous classes
p26313
aVa qualification conversion
p26314
aVA string literal has type , but throwing an array will decay the array and actually throws a pointer to its first element
p26315
aVSo you cannot catch a thrown string literal by a , because at the time it matches, it needs to match the  to a , which would throw away a const (a qualification conversion is only allowed to add const)
p26316
aVThe special conversion of a string literal to  is only considered when you need to convert a string literal specifically
p26317
as(dp26318
g15
V34509
p26319
stp26320
a((dp26321
g2
(lp26322
VThe template argument has nothing to do with the content of the object you are pointing to
p26323
aVThere is no reason this should work
p26324
aVTo illustrate
p26325
aVYou will eventually access integer  that doesn't really exist in
p26326
aVOK, now that you provided some more information, it's clear you want to do something completely different
p26327
aVHere is some starter:
p26328
aVThen you can use it as
p26329
aVYou may want to look into
p26330
aVWith a bit of luck, you can use that template for your purpose (I haven't tested it)
p26331
as(dp26332
g15
V34509
p26333
stp26334
a((dp26335
g2
(lp26336
VIf you have a fixed set of types, a  may be a suitable solution
p26337
aVIt has the benefit that it's fast (it does not use , but stores the vectors in place), and tracks the type for you
p26338
aVIf the set of possible types isn't fixed, you can use
p26339
aVBut then you need to track the type stored yourself
p26340
as(dp26341
g15
V34509
p26342
stp26343
a((dp26344
g2
(lp26345
VThe semantics for  and  explicitly say that the mapping is except for their truth-value result
p26346
aVSo you need to look what is defined for their truth value result
p26347
aVIf they say that the result is unspecified, then it is unspecified
p26348
aVIf they define specific rules, then it is not
p26349
aVIt says in particular
p26350
aVTwo pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address
p26351
as(dp26352
g15
V34509
p26353
stp26354
a((dp26355
g2
(lp26356
VOdds are that your clang uses C99 inline semantics
p26357
aVIn C99, if one of your functions doesn't use "inline" or does include "extern", then the definition is an "external definition", which can only appear once in the program
p26358
aVSee inline in C99
p26359
aVIn C++, your program is fine
p26360
aVIn Clang SVN, this bug has been fixed and your program should work fine
p26361
as(dp26362
g15
V34509
p26363
stp26364
a((dp26365
g2
(lp26366
VThe compiler operates correctly according to the current C++0x WP
p26367
aVSee this issue report, which is currently being worked on
p26368
aVPossibly the final C++0x Standard won't change the meaning of your  application in the return type before the function name
p26369
aVYou would need to move it to after the parameter list using , which hopefully will do The Right thing in final C++0x
p26370
as(dp26371
g15
V34509
p26372
stp26373
a((dp26374
g2
(lp26375
VThe questioner has answered itself with some GCC PR, but which really does not answer his question
p26376
aVThe reason is like @Fred describes
p26377
aVReducing it:
p26378
aVWhat can the compiler do
p26379
aVIt could call  on both operands and then do the comparison
p26380
aVBut why should it do that call in the first place
p26381
aVIt first needs to find an  that has two parameters of type
p26382
aVLet's look at how its operator is defined
p26383
aVThere we have it
p26384
aVIt first needs to do template argument deduction, and the fact that  does not match  will make it so that this  is ignored
p26385
aVYou are lucky that  is found anyway using ADL so that it does argument deduction in the first place (since  is a template argument of your type, it will consider namespace  by ADL and find this operator)
p26386
aVSo we have no suitable  to call and therefor GCC is alright with rejecting your code for the reasons @Fred gave in a nutshell
p26387
aVIn the end, trying to make a class behave like another type is deemed to failure
p26388
as(dp26389
g15
V34509
p26390
stp26391
a((dp26392
g2
(lp26393
VYour fix doesn't solve the problem with  firing though
p26394
aVThe  will still trigger for compilers that parse templates at definition time (most do)
p26395
aVThey will see that any function template instantiation will be ill-formed, and the Standard allows them to issue an error for the template itself then, and most will do so
p26396
aVFor making this work you need to make the expression dependent so that the compiler doesn't know when it parses the template that it will always evaluate to false
p26397
aVFor example
p26398
as(dp26399
g15
V34509
p26400
stp26401
a((dp26402
g2
(lp26403
VShort version:  declares a pointer to a function
p26404
aVdeclares a function that returns a pointer to a function
p26405
aVLonger version: You know the following pattern to declare a pointer to a function
p26406
aVNow, take the "f", and modify it
p26407
aVFor example, make it an array
p26408
aVNow, instead of having a pointer to a function, you have an array of pointer to functions
p26409
aVNow if you instead modify it to be a function rather than an array, you have transformed the first declaration to the second declaration
p26410
aVYou have modified it to be a function that returns a pointer to a function
p26411
aVInstead of having no parameter like in this case, your declaration has two parameters
p26412
aVOne of which is an  and the other of which is another pointer to function
p26413
aVIt's easier to use typedefs than to combine the C declarators for doing this though
p26414
as(dp26415
g15
V34509
p26416
stp26417
a((dp26418
g2
(lp26419
Vthere's no guarantee that a reinterpret_cast from char* to unsigned char* won't crash your program when you try to dereference the unsigned char* pointer
p26420
aVYou can't do such a cast in any other way, so you have to have to trust what your compiler does with this completely reasonable cast
p26421
aVSince reinterpret_cast doesn't seem to guarantee this actually works, are C-style casts the only safe option here
p26422
aVThe C-style cast will just map to  so it will be exactly the same
p26423
aVAt some point you have to trust your compiler
p26424
aVThe Standard has a limit on which it simply says "no
p26425
aVread your compiler's manual"
p26426
aVWhen it comes to cross-casting pointers, this is such a point
p26427
aVIt allows you to read a  using an  lvalue
p26428
aVA compiler that cannot cast a  to a usable  to do such is just about unusable and doesn't exist for that reason
p26429
as(dp26430
g15
V34509
p26431
stp26432
a((dp26433
g2
(lp26434
VYou are, as another answer describes already, trying to access a member of a class in one of the class' base class
p26435
aVThat's going to fail because the member is yet undeclared at that point
p26436
aVWhen it instantiates the base class, it instantiates all its member declarations, so it needs to know the return type
p26437
aVYou can make the return type be dependent on , which makes it delay the computation of the return type until  is known
p26438
aVThis would change the base class like the following
p26439
aVThis artificially makes the  cast to a type dependent on , so it does not immediately require a complete  type
p26440
aVRather, the type needs to be complete when  is instantiated with the respective template argument
p26441
as(dp26442
g15
V34509
p26443
stp26444
a((dp26445
g2
(lp26446
VI believe the following are valid because complex_base is POD
p26447
aVYou are wrong
p26448
aVdoes not refer to the first member of a  object
p26449
aVIts alignment may therefor not be good enough for a  object, therefor such a cast is not safe (and not allowed by the text you quote)
p26450
aVDoes the following complete a valid cast to complex even though complex is NOT POD
p26451
aVand  do not point to subobjects of an object of type , therefor the  produces undefined behavior
p26452
aVRefer to 5
p26453
ag976
aV9p5 of C++03
p26454
aVIf the lvalue of type "cv1 B" is actually a sub-object of an object of type D, the lvalue refers to the enclosing object of type D
p26455
aVOtherwise, the result of the cast is undefined
p26456
aVIt's not enough if merely the types involved fit together
p26457
aVThe text talks about a pointer pointing to a POD-struct object and about an lvalue referring to a certain subobject
p26458
aVoth complex and complex_base are standard-layout objects
p26459
aVThe C++0x spec says, instead of the text you quoted:
p26460
aVIs POD-ness requirement too strict
p26461
aVThis is a different question, not regarding your example code
p26462
aVYes, requiring POD-ness is too strict
p26463
aVIn C++0x this was recognized, and a new requirement which is more loose, "standard-layout" is given
p26464
aVI do think that both  and  are standard-layout classes, by the C++0x definition
p26465
aVThe C++0x spec says, instead of the text you quoted:
p26466
aVA pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa
p26467
aVI interpret that as allowing to cast a pointer to a , which actually points to a  member (member by inheritance), to be casted to a
p26468
aVA Standard-layout class is one that either has no base classes containing non-static data, or has only one base-class containing non-static data
p26469
aVThus there is an unique "initial member"
p26470
as(dp26471
g15
V34509
p26472
stp26473
a((dp26474
g2
(lp26475
VYour code is not really C++
p26476
aVIt uses a compound literal which is a C99 feature
p26477
aVIn C99 it evaluates to an lvalue and taking the address of the literal is completely fine there
p26478
aVIntegrating this extension into C++, GCC appears to change the rule of it and make it an rvalue, better fitting the classification of them into the existing rules of C++ for usual casts that also produce rvalues
p26479
aVGCC does not like , complaining that I take the address of a temporary
p26480
aVIt's a warning about invalid code which it still accepts but does not really like
p26481
aVThe same warning is given for other obviously-wrong code like , which is a legal functional style C++ cast, which also produces an rvalue and thus cannot be used as the operand of the address-of operator
p26482
aVThe integration of compound literals into C++ by GCC also destroys the temporary prematurely, as can be seen by the following test
p26483
aVIn C99, the object that the literal refers to will be alive for the entire block (it will have automatic storage duration)
p26484
aVIn GNU C++ the object is destructed already at the end of the full expression, before the end of its block is even reached (the "~B" is printed before the "main")
p26485
as(dp26486
g15
V34509
p26487
stp26488
a((dp26489
g2
(lp26490
VIt's possible to deduce the type of a lambda-expression when it is the argument to a function template function parameter whose type is deduced
p26491
aVLambda expressions however are explicitly forbidden to appear inside an unevaluated operand --- this includes
p26492
aVIt was found that this includes several yet unhandled special cases and it was found that there is no real utility to allow lambda expressions inside  and friends
p26493
aVRecall that every lambda expression creates a new unique type
p26494
aVYou can instead use , which is able to store any function object that can be called without arguments and yields  as return type
p26495
aVOf course, as I said above, function templates can deduce their argument type, so you can also make the constructor a template
p26496
aVBut I take it that this is not really useful in your case, since you presumably want to do something with  inside your class definition
p26497
aVLike, storing the object as a non-static data member
p26498
aVWith , that's possible
p26499
as(dp26500
g15
V34509
p26501
stp26502
a((dp26503
g2
(lp26504
VYour order is wrong
p26505
aVTry exchanging it
p26506
aVIn the primary template, the name  was dependent and the compiler delayed lookup to a point where  was declared ( is not really dependent in C++0x anymore, since  refers to the current instantiation and therefor  to a member of the current instantiation, but as there is a loophole in the current specification (it has to do with dependent base classes), the compiler delayed the lookup nontheless)
p26507
aVIn the explicit specialization, the name is not dependent and lookup is done immediately, which is the reason you need to declare  before referring to it
p26508
aVEdit: You are wrongly using
p26509
aVThe second argument you give is of type , which will be copied/moved by  into its created call wrapper object
p26510
aVThis requires a complete type
p26511
aVIf you want to merely pass a reference to  on which the member function is called, you can pass a , which the  mechanism equally detects as magical first argument to a member pointer invocation
p26512
aVBut it seems to me you want to look into , instead of doing this  and  mess
p26513
aVAfter all you have a powerful toolset given, but by using this doubtful  expression, you throw away all the genericity the Standard library gives you and restrict yourself to use of that single  expression
p26514
aVThat's no good
p26515
as(dp26516
g15
V34509
p26517
stp26518
a((dp26519
g2
(lp26520
VWow, this is confusing beyond belief
p26521
aVIt defines  as  and it as the following ( is the i-th perfect forwarding bind parameter, and  is the decayed type of that parameter - i
p26522
aVe an array becomes a pointer etc)
p26523
aVis an lvalue of type  constructed from
p26524
aVAlright, I did say, this  is  and it's an lvalue
p26525
aVBut this is not what it really means to say
p26526
aVIt means
p26527
aVis an lvalue of type  that refers to an object constructed from
p26528
aVIt makes much more sense now
p26529
aVBecause what if  is actually an rvalue
p26530
aVThe "lvalue
p26531
aVconstructed from
p26532
aVis meant to mean that we create a new object from "
p26533
aVand make the lvalue refer to it
p26534
as(dp26535
g15
V34509
p26536
stp26537
a((dp26538
g2
(lp26539
VThe "sign-ness" of  is implementation defined
p26540
aVIt doesn't have to be able to store negative numbers
p26541
aVIn strict standardese,  even is never a signed integer type, even if it can store negative numbers on an implementation
p26542
aVStill, the class template  will report  for  if it can store negative numbers, because that's a useful thing for it to do
p26543
aVAnyway, the boost docs say the following about , making it look like you can use it for your purpose
p26544
aVIf T is a unsigned integer type then the same type as T, if T is an signed integer type then the corresponding unsigned type
p26545
aVOtherwise if T is an enumerated or character type (char or wchar_t) then an unsigned integer type with the same width as T
p26546
as(dp26547
g15
V34509
p26548
stp26549
a((dp26550
g2
(lp26551
VAnother option is to derive from a marker template
p26552
aVThen derive them from both
p26553
aVNow you can write it as
p26554
aVThe advantage of this is its simplicity
p26555
aVAnd if  is already templated it's even more useful (I take it that this is not the case for your code)
p26556
as(dp26557
g15
V34509
p26558
stp26559
a((dp26560
g2
(lp26561
VWhen we say that variables of "static storage duration" are initialized to 0 implicitly, we don't mean that you need to put the "static" keyword in front of them
p26562
aVstatic storage duration" merely is a specific kind of storage duration for objects that says that their storage lasts for the complete duration of the program
p26563
aVThis kind of storage duration is used for variables declared at file scope (like your variable) and local static variables
p26564
as(dp26565
g15
V34509
p26566
stp26567
a((dp26568
g2
(lp26569
VThis is not overloading and using unary +
p26570
aVYou need to either make that a free function or make the member function take 0 arguments
p26571
as(dp26572
g15
V34509
p26573
stp26574
a((dp26575
g2
(lp26576
VI don't understand your question
p26577
aVThis code works fine with GCC and I see no reason why it shouldn't work
p26578
aVI don't know what you mean by "initialize the template"
p26579
aVSince you have now updated the question, I can update my answer
p26580
aVremoves  / , removes references and transforms array and function types to element and function pointers respectively
p26581
aVThat is what you seem to look for
p26582
as(dp26583
g15
V34509
p26584
stp26585
a((dp26586
g2
(lp26587
VThe following gives you the sizeof of the type that  has, which is  (usually an int has 4 or 8 bytes, so it will likely give you value 4 or 8)
p26588
aVHowever, since the expression is not evaluated, no runtime action is done for the expression
p26589
aVEvaluating an expression basically means to execute its side effects (e
p26590
aVg incrementing a variable) or reading values from memory or registers at runtime
p26591
aVSo in some sense  "throws away" its operand, since it does not really perform the runtime operation it specifies (the value of  will still be zero)
p26592
as(dp26593
g15
V34509
p26594
stp26595
a((dp26596
g2
(lp26597
VIt's clear that the first is slower to process for the compiler than the second and there is, like you say, evidence for that
p26598
aVI know of no workaround for a completely generic  in C++
p26599
aVSimulating  requires hundreds if not thousands of lines of codes (see boost
p26600
aVtypeof) and then it's still not generic
p26601
aVSame for
p26602
as(dp26603
g15
V34509
p26604
stp26605
a((dp26606
g2
(lp26607
V is intended to refer to a type, so you need
p26608
aVIf you omit , it thinks when it parses the template you are declaring a member whose name is  (and then it errors out at  because there cannot be a second name afterwards)
p26609
aVRemember it doesn't know at that point what  is yet
p26610
aVA more elaborated explanation can be found here
p26611
aVThe member initializer is fine
p26612
aVThe compiler probably got confused by the member declaration being invalid
p26613
as(dp26614
g15
V34509
p26615
stp26616
a((dp26617
g2
(lp26618
VAdd a constructor that takes 3 double
p26619
aVYou haven't got one yet, or you declared it wrongly or instead of a constructor you want to use aggregate initialization using
p26620
aVChoose what fits
p26621
aVAs for the  - you most probably declared the corresponding template parameter as
p26622
aVNotice that this has an important consequence
p26623
aVYou need to know the exact type of the non-type template parameter to be able to deduce arguments
p26624
aVIn this case, you would need  to be a
p26625
as(dp26626
g15
V34509
p26627
stp26628
a((dp26629
g2
(lp26630
VYou can make the parameter a type parameter to work this around
p26631
aVThis way you can specify any conditions you want in the partial specializations
p26632
as(dp26633
g15
V34509
p26634
stp26635
a((dp26636
g2
(lp26637
VFirst, you did not typedef a signature
p26638
aVA signature is everything that identifies a single function
p26639
aVIt contains the namespace/class of the function and so on
p26640
aVWhat you typedef'ed is the type of a function
p26641
aVLike when you  which typedefs the type of an , you typedef'ed the type of a function
p26642
aVYou can use the typedef-name to declare functions only
p26643
aVBut it cannot be used to define functions
p26644
aVFor defining functions, you need to provide a parameter list literally and manually
p26645
aVReasons include giving names for parameters (and possibly other, more technical reasons
p26646
aVC++0x introduces  which will get a specific initialization meaning)
p26647
as(dp26648
g15
V34509
p26649
stp26650
a((dp26651
g2
(lp26652
VGCC is correct and the other compiler is correct too
p26653
aVRefer to 14
p26654
aV6p8 in the spec
p26655
aVIf no valid specialization can be generated for a template definition, and that template is not instantiated, the template de\ufb01nition is ill-formed, no diagnostic required
p26656
aVTherefor, a compiler is free to reject the following
p26657
aVIf you want to go safe, you have to arrange it so the compiler cannot know until instantiation whether the boolean expression will be true or false
p26658
aVFor example, get the value by , with  being a class template (one could specialize it, so the compiler cannot possibly know the boolean value already)
p26659
as(dp26660
g15
V34509
p26661
stp26662
a((dp26663
g2
(lp26664
VWhy invent pre/postfixes
p26665
aVI just use the same name
p26666
aVC++ is designed for that to work
p26667
aVIt's straight forward
p26668
as(dp26669
g15
V34509
p26670
stp26671
a((dp26672
g2
(lp26673
VTwo other differences:
p26674
aV(i
p26675
aVe ) specifies a constant array type ( http://www
p26676
aVopen-std
p26677
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p26678
aVhtml#112 and http://www
p26679
aVopen-std
p26680
aVorg/jtc1/sc22/wg21/docs/cwg_active
p26681
aVhtml#1059 ) (and whose elements are so-qualified too) in C++, but a non-constant array type whose elements are so-qualified in C
p26682
aVis valid in C99 (not valid in C89), not valid in C++ in any version (you can only semantically repeat a , not syntactically)
p26683
aVIt contracts to  in C99
p26684
as(dp26685
g15
V34509
p26686
stp26687
a((dp26688
g2
(lp26689
VYes it explicitly forbids that
p26690
aVRefer to 3
p26691
ag488
aV1p2
p26692
aVAn implementation shall not predefine the main function
p26693
aVThis function shall not be overloaded
p26694
aVThis way, the main function's name can stay unmangled
p26695
aVThat is, the runtime library can call a symbol having a fixed name (e
p26696
aVg  or ) to jump to the main function
p26697
aVThe libraries' code will not need to depend on what parameter list the program's  function has
p26698
aVThe implementation is also allowed to define additional valid parameter lists for the  function (The POSIX spec specifies a  parameter for the environment variables, for example)
p26699
aVIt would not be clear when an overload of  is a "non-main function" or whether it's a "main function", thus an entry point
p26700
aVPresumably, you would want to get an error if you would declare more than one entry point, so such issues are important
p26701
as(dp26702
g15
V34509
p26703
stp26704
a((dp26705
g2
(lp26706
VA namespace name is the name of a namespace
p26707
aVThe statement says that using a namespace name without a using declaration is an error
p26708
aVBut that's not true: The above code is fine, still using the namespace-name  as an unqualified name
p26709
aVProbably it should say the following, to convey its meaning
p26710
aVUsing an unqualified version of a namespace member name without a using declaration
p26711
aVoutside the scope of the namespace is an error, although some compilers may fail to
p26712
aVdetect this error"
p26713
aVMentioning the scope is important
p26714
aVThe following, for example, is fine too, even though it uses the unqualified version of a namespace member name
p26715
aVBooks should be careful to try and not use slippery language
p26716
aVAnd even outside the scope of the namespace, the above sentence is not entirely correct because you can also extend the scope of  by a using directive
p26717
aVUsing declarations aren't the only way to name a namespace member outside the namespace using an unqualified name
p26718
as(dp26719
g15
V34509
p26720
stp26721
a((dp26722
g2
(lp26723
VI personally don't like this, but sometimes it's useful
p26724
aVThe Standard library uses this too:
p26725
aVWhy does it not work
p26726
aVBecause  has hidden  with a same named function that only provides read access to its internal , rather than to the attached buffer
p26727
aVYou need to do the following
p26728
aVNow, the buffer attached to the stream is not equal to what  returns
p26729
aVI personally dislike this design though
p26730
aVI once had a good use of hiding though
p26731
aVIn my opinion, hiding needs one requirement:
p26732
aVThe behavior should be the same
p26733
aVIn my case, I had a base class like this (not really near as it was, but it's conveying the situation)
p26734
aVWhat happens when one calls
p26735
aVIt needs the header of , because the function wants to call  on the class and creates a variable of that type
p26736
aVThe workaround was simple
p26737
aVThis way, I prevented that every user of my  class needs to include the Foo's header
p26738
aVOnly B's cpp file, which knows it depends on "Foo", has to do this
p26739
as(dp26740
g15
V34509
p26741
stp26742
a((dp26743
g2
(lp26744
VThese were discussed as "polymorphic lambdas", and were declined because it made problems with the concepts proposal
p26745
aVLast year 2009 at the Frankfurt meeting, the concepts proposal was voted out of the working paper, but polymorphic lambdas weren't considered anymore for C++0x
p26746
aVSee C++0x and the Lack of Polymorphic Lambdas
p26747
as(dp26748
g15
V34509
p26749
stp26750
a((dp26751
g2
(lp26752
VHow are they related
p26753
aVUsing an initializer list constructor doesn't work for a pair, because a  is heterogeneously typed, while an initializer list constructor uses an , which is only usable to retrieve an homogeneously typed initializer list
p26754
aV(Looking into the spec, it should really be called "initializer-list constructor", instead of "initializer list constructor"
p26755
aVDo you really mean to refer to the first
p26756
aVIf not, what do you refer to
p26757
aVIf you just refer to initialize a  using an initializer list against using  and using , I think both are fine
p26758
aVIf you have already the types  and  and can use them for the , then the initializer list is a good way to use
p26759
aVIf you haven't, then  might be a good thing
p26760
aVIf you have types  and , but aren't sure whether they are already transformed properly (i
p26761
aVe they should not be array or function types, and you probably also want them to be non-reference types), then it might be easier to use , which will properly decay the type of the expressions
p26762
as(dp26763
g15
V34509
p26764
stp26765
a((dp26766
g2
(lp26767
VNo expression ever has reference type
p26768
aVTherefor, when argument deduction deduces against the argument expression type, it cannot make a distinction between  and  because the arguments  and  both have the same type
p26769
aVRefer to [expr]p5 in the spec
p26770
aVIf an expression initially has the type "reference to T" (8
p26771
ag1037
aV2, 8
p26772
ag1014
aV3), the type is adjusted to T prior to any further analysis
p26773
as(dp26774
g15
V34509
p26775
stp26776
a((dp26777
g2
(lp26778
VThe error message is because  derives (indirectly) from , which makes  inside the scope of  refer to the class , instead of the template
p26779
aVMSVC is correct to reject this, and GCC4
p26780
aV5 should reject this too (GCC4
p26781
aV5 has more correct injected class name lookup)
p26782
aVHere is a solution that might work for both compilers
p26783
aVNotice that we use the scope resolution operator and need to put a space before  (the token  would otherwise be taken as a digraph)
p26784
aVBreaking News: C++0x will make the above work even if you do
p26785
aVThe reason is, that it says that if the injected class name is passed to a template template parameter, the injected class name is treated as a template, instead of as a type
p26786
aVTherefor, for C++0x, GCC would be the compiler doing it correctly
p26787
as(dp26788
g15
V34509
p26789
stp26790
a((dp26791
g2
(lp26792
VUnqualified names are not looked up in dependent base classes (your base class depends on template parameter )
p26793
aVQualify that name, and it will work
p26794
as(dp26795
g15
V34509
p26796
stp26797
a((dp26798
g2
(lp26799
VYou need to initialize it
p26800
aVThis is a known problem with the spec
p26801
as(dp26802
g15
V34509
p26803
stp26804
a((dp26805
g2
(lp26806
VFirst, the conversion sequence of all three is the same, except that for the first two, there is an lvalue transformation (lvalue to rvalue conversion), which however is not used in ordering conversion sequences
p26807
aVAll three are exact matches (the function template specialization has parameter type )
p26808
aVIf you iterate over the rules at , you stop at this paragraph
p26809
aVS1 and S2 are reference bindings (8
p26810
ag1014
aV3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference
p26811
aVA conversion sequence cannot be formed if it requires binding an rvalue reference to an lvalue, the spec says at 13
p26812
ag1037
ag1037
ag2790
aV4p3
p26813
aVIf you look at how reference binding works at 8
p26814
ag1014
aV3p5 last bullet, it will create a temporary (I think they meant rvalue temporary) of type  from the array lvalue and bind the reference to that temporary
p26815
aVTherefor, I think  is better than
p26816
aVSame holds for  against , although we wouldn't need this because  is a template so in a tie, we would choose  again
p26817
aVIn , they changed the reference binding rules so that rvalue references can bind to initializer expressions that are lvalues, as long as the reference will be bound to an rvalue (possibly created by converting the initializer properly before)
p26818
aVThis could influence the handling by Visual C++, which may not be up to date here
p26819
aVI'm not sure about clang
p26820
aVEven if it would ignore , then it would end up in a tie between  and , and would need to choose  because it's a non-template
p26821
aVI think that 8
p26822
ag1014
aV3p5 last bullet is confusing because it says "Otherwise a temporary of type
p26823
aVIt's not clear whether the temporary is regarded as an lvalue or as an rvalue by 13
p26824
ag1037
ag1037
ag2790
aV4p3, which means I'm not sure how the following should really behave according to the exact words of the spec
p26825
aVIf we assume the temporary is treated as an rvalue by clause 13, then we bind an rvalue ref to an rvalue in the second function and an lvalue in the first
p26826
aVTherefor, we will choose the second function and then get a diagnostic by 8
p26827
ag1014
aV3p5 last bullet because  and  are reference-related
p26828
aVIf we assume the temporary is treated as an lvalue by clause 13, then the following would not work
p26829
aVBecause we would bind an rvalue ref to an lvalue which by clause 13 will make the function non-viable
p26830
aVAnd if we interpret "binding an rvalue ref to an lvalue" to refer to the initializer expression instead of the final expression bound to, we won't accept the following
p26831
aVThis however is valid as of n3225
p26832
aVSo there seems to be some confusion - I sent a DR to the committee about this
p26833
as(dp26834
g15
V34509
p26835
stp26836
a((dp26837
g2
(lp26838
VThere's another difference when you want to create a dynamic array
p26839
aVThe parenthesized version requires a constant size
p26840
as(dp26841
g15
V34509
p26842
stp26843
a((dp26844
g2
(lp26845
VLookup in the instantiation context of a function template only uses ADL
p26846
aVNo unqualified lookup
p26847
aVTherefor, you need to rely on ADL
p26848
aVBut the ADL lookup for  does not include the global namespace, hence your  is not found
p26849
aVTry this, which should work fine:
p26850
aVThis works because the global namespace is associated with the ADL lookup set for  (because  is a template argument), therefor finding the globally declared template when instantiating the respective member functions of , which will use your  for  being , which then in turn will use  of
p26851
as(dp26852
g15
V34509
p26853
stp26854
a((dp26855
g2
(lp26856
VYes, a semicolon is explicitly allowed after a function definition in a class specifier
p26857
aVAs a result, currently in the C++0x draft, the following is valid too: The first semicolon belongs to the function definition, the second to the class specifier delegating to the function-definition non-terminal
p26858
aVBut three semicolons would be illegal
p26859
aVAs are two semicolons after a function definition having a body
p26860
aVThe respective text in the spec is the grammar at
p26861
aVSemicolons after function definitons were allowed already in C++03, but they were not allowed at namespace scope after function definitions
p26862
aVC++0x fixes that by introducing empty-declarations
p26863
aVBut those only appear when you have a semicolon after function definitions outside class bodies
p26864
aVSutter talks about "extra" semicolons at the end of function declarations though, which is not entirely correct
p26865
aVBecause the following is invalid syntax
p26866
aVAn extra semicolon in a class specifier is only valid after a function-definition
p26867
aVAlso, as a checkup at  uncovers, it's not valid when the function definition is a template
p26868
aVThis is because it is parsed by a template-declaration (which will itself parse the remaining text to function-definition eventually) for which the class specifier does not have an additional  afterwards
p26869
as(dp26870
g15
V34509
p26871
stp26872
a((dp26873
g2
(lp26874
VGCC uses a built-in  for  (which is a constant integer expression evaluating to zero
p26875
aVon GCC satisfies such), so that it can detect special cases and warn about them
p26876
aVLike, accidentally passing  to a  parameter, when it was intended to be passed to a pointer parameter (changes made to a function, forgot to adapt the call side)
p26877
aVLike the error message says, making a virtual function pure requires the exact token sequence , not some other things ( or such will fail too)
p26878
as(dp26879
g15
V34509
p26880
stp26881
a((dp26882
g2
(lp26883
VThen
p26884
aVYields some shiny picture (there is an "external node", because  has external linkage and might be called from outside that translation unit too):
p26885
aVYou may want to postprocess this with , so that you can get the unmangled names of the functions and classes involved
p26886
aVLike in the following
p26887
aVYields this beauty (oh my, the size without optimizations turned on was too big
p26888
aVThat mystical unnamed function, , is a placeholder assumed to be called by any function whose definition is not known
p26889
as(dp26890
g15
V34509
p26891
stp26892
a((dp26893
g2
(lp26894
VThe C spec I have (C99 TC3) says
p26895
aVIf the } that terminates a function is reached, and the value of the function call is used by the caller, the behavior is unde\ufb01ned
p26896
aVThe value of an expression that's said to be "evaluated as a void expression" is discarded
p26897
aVSo in the C case, there is no undefined behavior
p26898
aVIt may have been different in old C (some details are, if I remember correctly)
p26899
aVThe situation for C++ is slightly different than for C, because C++ supports class objects with constructor and destructors as return values and having them operate on uninitialized memory can't be guaranteed to work well
p26900
aVPerhaps this contributed to the different rules for C++
p26901
as(dp26902
g15
V34509
p26903
stp26904
a((dp26905
g2
(lp26906
VTo let this parse correctly, you would need to insert  before the , to tell the compiler that  is to be regarded as a template name (it cannot look into  to tell itself, since  is unknown)
p26907
aVBut using  is not allowed in a using declaration
p26908
aVThe name also does not refer to all constructors of : Instead, it would refer to a specific constructor function template specialization ( is the template argument) of such a constructor as follows
p26909
aVIn addition, it's not valid for a using declaration to use a  (like ) as its name (which in effect forbids it to refer to function template specialization, with the addition of forbidding to name conversion function template specializations stated too), so even if you correct the parsing problem using  (if it would be possible), you would still error out at this point
p26910
aVWhen inherited constructors were introduced, special rules were added that allow to reference a constructor using a syntactic rule: If you have a qualified-id (which basically a qualified name using ), and the last qualified before the final part names a specific class, then you can denote the constructor(s) of that class in two additional ways:
p26911
aVIf the class was named using a template-id (a name of the form ) and the final part matches the template name (so,  or  with  being a template template parameter)
p26912
aVIf the final part matches the class name (so,  or , with  being a template parameter)
p26913
aVThese two additional rules are only active in a using declaration
p26914
aVAnd they were naturally not present in C++03
p26915
aVThe other rule that was also present in C++03 is: If the final part names the injected class name, then this qualified name also refers to the constructor:
p26916
aVwould therefor work
p26917
aVBut with this rule alone,  (where  denotes class ) would not work, because  has no member called
p26918
aVTherefor, with the special rules in place you can write
p26919
aVThe second is valid too:  is the injected class name which was injected into the base class  and inherited to
p26920
aVWe refer to that name by , and then add the last part , which refers to the injected class name again, to denote the constructor(s) of `foo
p26921
aVNow you understand why the initial name you tried would refer to a constructor function template specialization (if it were to be allowed to): Because the  part would name all constructors, and the  that would follow would then filter out the template and pass the type argument
p26922
as(dp26923
g15
V34509
p26924
stp26925
a((dp26926
g2
(lp26927
VThe size of both dimensions is fixed
p26928
aVThe outer dimension has size  and the inner has size
p26929
aVIf you iterate over the inner dimension, then you will print lots of zeros, as that is what you initialize the remaining integers that aren't explicitly initialized to
p26930
aVYou seem to want this:
p26931
as(dp26932
g15
V34509
p26933
stp26934
a((dp26935
g2
(lp26936
VThis is not valid:
p26937
aVYou can specialize members of class templates, but only for implicit instantiations of those class templates
p26938
aVThis means in plain English: Only if you give values for all the template arguments of the enclosing class template (whose member you need to specialize)
p26939
aVWhat you wrote is the definition of a , which is a member of a class template partial specialization of
p26940
aVSuch a partial specialization does not exist, therefor, the compiler errored out
p26941
aVYou have several options to solve this
p26942
aVOne is
p26943
aVNote that explicit specializations (non-partial) cannot be put into the class template directly (so,  would be ill-formed when writting inside the body of )
p26944
aVYou would need to define the "selector" template outside  then (perhaps in a  namespace)
p26945
aVOther alternatives include deriving from  and inheriting its typedefs
p26946
as(dp26947
g15
V34509
p26948
stp26949
a((dp26950
g2
(lp26951
VYour code is already correct
p26952
aVAt least the parts you have shown
p26953
aVThe compiler thinks that  is
p26954
aVBut what you wrote is not, as it correctly wants to have a member pointer
p26955
aVThis appears to be a compiler related problem
p26956
as(dp26957
g15
V34509
p26958
stp26959
a((dp26960
g2
(lp26961
VIterators can also have singular values that are not associated with any container
p26962
aVI suppose that's its definition
p26963
aVHow and why dereferenceable values are always nonsingular
p26964
aVBecause if they wouldn't, dereferencing them would be undefined behavior
p26965
as(dp26966
g15
V34509
p26967
stp26968
a((dp26969
g2
(lp26970
VThe class A is POD and can be initialized like this
p26971
aVSorry, that is wrong
p26972
aVBecause  is private, the class is not a POD
p26973
aVBut Clang assumes A as non-aggregate type
p26974
aVWhy I can't have constructor like that
p26975
aVOr should I do something else
p26976
aVThis is a limitation of C++ as it exists currently
p26977
aVC++0x will not have this limitation anymore
p26978
aVWhile in C++0x your type is not a POD either, your initialization will work (assuming that you make that constructor )
p26979
aV(Also, I think a better term for you to use here is "aggregate"
p26980
aVThe requirement for using  is that your class is an aggregate
p26981
aVIt doesn't have to be a POD)
p26982
as(dp26983
g15
V34509
p26984
stp26985
a((dp26986
g2
(lp26987
VThis is known statically at compile time
p26988
aVSometimes, it's more difficult
p26989
as(dp26990
g15
V34509
p26991
stp26992
a((dp26993
g2
(lp26994
VThis is according to the C++ Standard
p26995
aVThe ternary operator does constitute a single lvalue that will refer to either  or  at runtime
p26996
aVThe lvalue to rvalue conversion is not applied immediately to either the lvalue  or , and therefor you require a definition of  and
p26997
aVSee the core language issue report http://www
p26998
aVopen-std
p26999
aVorg/jtc1/sc22/wg21/docs/cwg_active
p27000
aVhtml#712
p27001
aVAs a workaround, you can apply explicit casts to  (which reads their values, thereby doing an lvalue to rvalue conversion) or use an operator that reads the value, like :
p27002
as(dp27003
g15
V34509
p27004
stp27005
a((dp27006
g2
(lp27007
VNo there is no guaranteed way to stop this sort of thing
p27008
aVIt is an integral part of C++ and C that the variable's name is visible in its initializer
p27009
aVIt allows you to do such things as
p27010
aVThere is an issue report on the C++ issues list to require diagnostics in simple cases, but currently compilers are not required to diagnose your case
p27011
aVIt's also valid in a different context
p27012
aVEdit: To clarify - the behavior of your snippet is undefined: You are reading the value of a not initialized variable
p27013
aVThat compilers are not required to diagnose this does not mean that behavior is defined
p27014
as(dp27015
g15
V34509
p27016
stp27017
a((dp27018
g2
(lp27019
VUse  in programs where applicable
p27020
aVIf you really need to use a raw , you can use placement new
p27021
aVAnd delete it with
p27022
aVNotice that you need to manually call the destructors of these objects then
p27023
aVAlternatively, you can create the objects with a raw storage iterator
p27024
aVThe need to manually call the destructors at the end of use stays, of course
p27025
as(dp27026
g15
V34509
p27027
stp27028
a((dp27029
g2
(lp27030
VYou cannot have a vector of
p27031
aVThe compiler when it creates the vector needs to know precisely what type it stores because every instantiation of  could potentially have a different size and entirely different members (because you can provide explicit and partial specializations)
p27032
aVYou need to give the  a common base class and then put  pointers into the vector (preferably using  or something similar)
p27033
aVAs an alternative there are ready classes that hide this from you and act like a container of references
p27034
aVAmong them is , which however also need a common type to store
p27035
as(dp27036
g15
V34509
p27037
stp27038
a((dp27039
g2
(lp27040
VIn this case I would also recommend an  constructor, because I think that an arbitrary string (which your constructor takes) does not model a number (which your  class models)
p27041
aVSuch cases are what  was designed for
p27042
aVHowever, this will not work for cases where direct initialization is used
p27043
aVIn general,  should not be used to resolve internal ambiguities
p27044
aVIt should merely be used to forbid the conversion from one type to the other, but not to prefer another constructor over the  constructor
p27045
aVIn fact, the new C++0x uniform initializations will not ignore  constructors in a copy initialization context:
p27046
aVThe rules for uniform initialization is: Both constructors are considered, but if an explicit constructor is chosen, initialization is ill-formed
p27047
aVThe literal  is an
p27048
aVAssuming you want to be able to accept all integer types, you need to at least add an  taking constructor
p27049
aVYou don't need to add overloads for integer types smaller than , because those types prefer  over other integer conversions or pointers
p27050
aVAssuming you have an  overload you also need to add overloads for the remaining integer types and, if available and you use it,  and
p27051
aVAmbiguities will then not arise anymore:
p27052
as(dp27053
g15
V34509
p27054
stp27055
a((dp27056
g2
(lp27057
VI was under the impression that the whole point of capture-by-value is to allow the user to change the temporary -- otherwise I'm almost always better off using capture-by-reference, aren't I
p27058
aVThe question is, is it "almost"
p27059
aVA frequent use-case appears to be to return or pass lambdas:
p27060
aVI think that  isn't a case of "almost"
p27061
aVI consider "capture-by-value" like "allow me to use its value after the captured entity dies" rather than "allow me to change a copy of it"
p27062
aVBut perhaps this can be argued
p27063
as(dp27064
g15
V34509
p27065
stp27066
a((dp27067
g2
(lp27068
VYou could also do tricks with default template arguments, just for making the operand of the operator be dependent
p27069
aVPerhaps with a helper function in between
p27070
as(dp27071
g15
V34509
p27072
stp27073
a((dp27074
g2
(lp27075
VFor , both the  and  will match the overload of  with one, and with two template parameters respectively (in the case of the two parameter version, the second template argument will be deduced, the first argument was provided by you explicitly)
p27076
aVIf you want to disambiguate ambiguous cases, I recommend that you pass the exact type, so no surprises can happen
p27077
aVInstead of those overloads, why not have a single overload
p27078
aVThe last call to  should work fine in your code too
p27079
aVYou then can dissect the type  in  with separate templates, to get the parameter and return types
p27080
as(dp27081
g15
V34509
p27082
stp27083
a((dp27084
g2
(lp27085
VYou can invoke functions in your constructor initializer list
p27086
aVNote that in the initializer list, the class is considered completely defined, so you can see members declared later on too
p27087
aVAlso better not use non-static functions in the constructor initializer list, since not all members have yet been initialized at that point
p27088
aVA static member function call is fine
p27089
as(dp27090
g15
V34509
p27091
stp27092
a((dp27093
g2
(lp27094
VIt doesn't work that way
p27095
aVYou would need to say the following, but it is not correct
p27096
aVExplicitly specialized members need their surrounding class templates to be explicitly specialized as well
p27097
aVSo you need to say the following, which would only specialize the member for
p27098
aVIf you want to keep the surrounding template unspecialized, you have several choices
p27099
aVI prefer overloads
p27100
as(dp27101
g15
V34509
p27102
stp27103
a((dp27104
g2
(lp27105
VIs putting the enumeration into a base class an option
p27106
aVPersonally I wouldn't do this, as it looks like an overly complex work around
p27107
aVI would simply forbid the caller to pass
p27108
aVTrue, the type system doesn't check that
p27109
aVBut surely this is an easy thing to check for human programmers
p27110
aVWhy would they pass
p27111
as(dp27112
g15
V34509
p27113
stp27114
a((dp27115
g2
(lp27116
VIt's an error to have a parameter have the same name twice, because parameter names are in scope in their parameter list
p27117
aVI think it's obvious that having two parameters have the same name isn't useful
p27118
aVIn C it is allowed to define the content of struct types in parameter type lists
p27119
aVThe tag identifier either has prototype scope or block scope (when the function is a definition) and has no linkage, which means it is different from a struct declared outside the prototype or blocks, whose tag identifier has file scope
p27120
aVYou cannot call such a function except recursively from inside its body
p27121
aVNote that this applies only for calls that happen in the same translation unit that  is defined in
p27122
aVIf in another translation unit you declare the function and struct as follows, that is entirely fine, and the function will be callable (you need to make sure the above declaration is not visible, otherwise you get a clash, because  at both points denotes a different type)
p27123
aVIn both translation units, even though  is a different type (because they are different translation units), the types are compatible, which is the only thing that matters for parameter types
p27124
aVYou cannot only define the struct in a parameter list, but also in the return type section of a function
p27125
aVThis too applies only to C
p27126
aVNo such thing is allowed in C++
p27127
as(dp27128
g15
V34509
p27129
stp27130
a((dp27131
g2
(lp27132
VIf f() and g() both have side effects on some shared object then the behaviour is undefined because the order of execution is unknown
p27133
aVThis is not true
p27134
aVFunction invocations do not interleave, and there is a sequence point before entering functions, and before leaving functions
p27135
aVAll side effects in  respective to side effects in  are separated by at least one sequence point
p27136
aVBehavior is not undefined
p27137
aVAs a consequence, the order of execution of the functions  and  is not determined, but once one function is executed, only that function's evaluations are executed, and the other function "has to wait"
p27138
aVDifferent observable results are possible, but this does not imply that undefined behavior has happened
p27139
aVNow I was wondering what happens when you chain member functions on an object
p27140
aVIf you have  then you need to first evaluate  to know what object you call function  on, which means you have to wait for  to return and yield a value
p27141
aVThis however does not necessarily mean that all side effects initiated by evaluation of  are finished
p27142
aVAfter evaluating an expression, you need a sequence point for those side effects to be considered complete
p27143
aVBecause there is a sequence point before returning from  and also before calling , you have effectively a determined order for executing side effects initiated by evaluating expressions in  and  respectively
p27144
aVTo explain a bit more, the reason  is called before  in your example is the same to why  is first incremented before the function  is called in the following
p27145
aVThe question to ask here is: Will this program print ,  or is its behavior undefined or unspecified
p27146
aVThe answer is, because the expression  necessarily has to be first evaluated before the function call, and there is a sequence point before entering , the value of  inside  is
p27147
aVI don't think you need to extend the scope of the implicit object parameter to sequence points to explain your case, and you certainly cannot extend it to explain this case (which I hope is defined behavior)
p27148
aVThe C++0x draft (which doesn't have sequence points anymore) has a more explicit wording of this (emphasize mine)
p27149
aVWhen calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function
p27150
as(dp27151
g15
V34509
p27152
stp27153
a((dp27154
g2
(lp27155
VIt is valid C++0x to say
p27156
aVGCC just doesn't support it yet
p27157
aVYou can work it around with an identity template
p27158
aVis part of the  namespace
p27159
as(dp27160
g15
V34509
p27161
stp27162
a((dp27163
g2
(lp27164
VI think you could use explicit instantiation, and then define your serialize member functions in
p27165
aVcpp files
p27166
aVThen a
p27167
aVcpp can include b
p27168
aVh and c
p27169
aVh as needed, and users of a
p27170
aVh don't need to do that anymore
p27171
aVLook into the pimpl-idiom examples http://www
p27172
aVboost
p27173
aVorg/doc/libs/1_46_1/libs/serialization/example/demo_pimpl_A
p27174
aVhpp (header) and http://www
p27175
aVboost
p27176
aVorg/doc/libs/1_46_1/libs/serialization/example/demo_pimpl_A
p27177
aVcpp (source file) for how to do that
p27178
as(dp27179
g15
V34509
p27180
stp27181
a((dp27182
g2
(lp27183
V is an lvalue in the return statement (named rvalue references are lvalues, for safety reasons), but the return type of  is an rvalue reference ( is , but you remove the reference, so you form the type  in the return type)
p27184
aVYou need to  the  to  first to create an unnamed rvalue reference, when you want to return it
p27185
aVI'm not sure what your goal is
p27186
aVEither you want to use  (like you say in your title), or you want to learn how it would be implemented (like the code you show indicates)
p27187
aVIt doesn't make sense to try to learn how  works without knowing the basic C++ rules
p27188
aVI recommend you to have a look in our C++ Books List
p27189
aVAfter you have a good grasp about C++, you can learn how  works
p27190
as(dp27191
g15
V34509
p27192
stp27193
a((dp27194
g2
(lp27195
VThe spec draft (n3242) says
p27196
aVIf a virtual function is marked with the virt-speci\ufb01er override and does not override a member function of a base class, the program is ill-formed
p27197
aVSince the function declarations you show are not virtual, you also run afoul of
p27198
aVA virt-specifier-seq shall contain at most one of each virt-specifier
p27199
aVThe virt-specifiers override and final shall only appear in the declaration of a virtual member function
p27200
aVNote that a function that has the same name and parameter list (including constness) as a base function, but that is not virtual does not override that base function
p27201
aVIt is instead said to hide the base function
p27202
aVDesignating that a function hides a base function by putting  instead of  after the function's declaration was part of the C++0x draft, but will not be part of C++0x as there were problems with finding syntax spots for non-function members for putting  at, in time
p27203
aVConsequently, it was voted out for C++0x
p27204
as(dp27205
g15
V34509
p27206
stp27207
a((dp27208
g2
(lp27209
VThis is not currently possible with C++
p27210
aVIn C++0x it will be possible with braces, like
p27211
aVAnd for the time being, you can wrap that array in a class, without any performance loss (the array will still be a normal, native multidimensional array)
p27212
as(dp27213
g15
V34509
p27214
stp27215
a((dp27216
g2
(lp27217
VThis compiles and links (and works) using recent g++ (which is the only target compiler) both 4
p27218
ag2790
aV2 and 4
p27219
ag2670
aV5 -- because of (N)RVO the copy-constructor is never called; destructor is called at the end of main() only
p27220
aVWhile it may work with GCC, your code really has undefined behavior because it references a function that's not defined
p27221
aVIn such a case, your program is ill-formed; no diagnostic required
p27222
aVWhich means that GCC may ignore the rule violation, but other compilers may diagnose it or do something else strange
p27223
aVSo on those grounds, I would reject this way
p27224
aVMy feelings is not sufficient argumentation, so I'm looking for technicalities now
p27225
aVYou want to have move semantics here
p27226
aVWhat about having this explicit
p27227
aVNow you can say
p27228
as(dp27229
g15
V34509
p27230
stp27231
a((dp27232
g2
(lp27233
VThis was a known issue
p27234
aVIt thinks that the second comma separates parameter declarations
p27235
aVThis comes from the fact that in a class definition, function default arguments are first only tokenized, and then only later parsed when the full class body has been read
p27236
aVAs it thus doesn't really parse the default argument, it doesn't notice the comma is really a comma within a template argument list instead
p27237
aVSee http://www
p27238
aVopen-std
p27239
aVorg/jtc1/sc22/wg21/docs/cwg_active
p27240
aVhtml#325 for something to read about it
p27241
aVCited
p27242
aVThe other problem is with collecting the tokens that form the default argument expression
p27243
aVDefault arguments which contain template-ids with more than one parameter present a difficulty in determining when the default argument finishes
p27244
aVConsider,
p27245
aVThe default argument contains a non-parenthesized comma
p27246
aVIs it required that this comma is seen as part of the default argument expression and not the beginning of another of argument declaration
p27247
aVTo accept this as part of the default argument would require name lookup of T (to determine that the '<' was part of a template argument list and not a less-than operator) before C is complete
p27248
aVFurthermore, the more pathological
p27249
aVwould be very hard to accept
p27250
aVEven though T is declared after Foo, T is in scope within Foo's default argument expression
p27251
as(dp27252
g15
V34509
p27253
stp27254
a((dp27255
g2
(lp27256
VThe spec says for the condition (switched-over value):
p27257
aVThe condition shall be of integral type, enumeration type, or of a class type for which a single conversion function to integral or enumeration type exists
p27258
aVYour class type has 3 conversion functions to integral or enumeration types, so it easily fails this constraint
p27259
aVIt won't even work if you remove the  overload, because then there are still 2 conversion functions
p27260
aVNo overload resolution happens
p27261
aVThere is also no need for a non-const  overload if it doesn't write anything anyway
p27262
aVAn explicit cast will be a safe bet
p27263
aVSame rather weird way is to use , but which I wouldn't take for clarity reasons
p27264
as(dp27265
g15
V34509
p27266
stp27267
a((dp27268
g2
(lp27269
VWithout typename, SubType would be considered a static member
p27270
aVThus, it would be a concrete variable or object
p27271
aVAs a result, the expression T::SubType *ptr would be a multiplication of the static SubType member of class T with ptr
p27272
aVThis description is incorrect when applied to the example you give
p27273
aVIn class bodies there can be no expressions, and no constructs are parsed as a multiplication
p27274
aVHowever, in the C++03 syntax, there is a construct that looks as follows
p27275
aVThis construct was deprecated in C++03 but still supported, and means the same as the following
p27276
aVBecause you didn't tell the compiler that  is a type and hence tell the compiler that it should parse it as the type of a pointer declaration, the compiler assumed that  is the name in an access-declaration
p27277
aVHence it expected a semicolon directly after it, and hence it expected that  is a base class of  (or that  is a derived class of )
p27278
aVThe error message actually has it backwards:
p27279
aVWhile the macro says
p27280
as(dp27281
g15
V34509
p27282
stp27283
a((dp27284
g2
(lp27285
VGoing from  to  requires creating a temporary  pointer and binding the reference  to that temporary
p27286
aVThe Standard forbids doing that creating of a temporary for non-const references
p27287
aVYou therefor need to make the reference const as you did your fix
p27288
aVThis is because non-const references mean "I want to change the argument that the caller passes using that reference parameter"
p27289
aVBut if the caller needs to convert their argument and ends up passing a temporary, the point of the reference is for naught, and so the Standard deems it an error to try and pass the temporary
p27290
as(dp27291
g15
V34509
p27292
stp27293
a((dp27294
g2
(lp27295
VThis does, like your original code snippet, rely on extern "C++" calling convention to be the same as what your pthread library uses
p27296
aVI'm not sure whether POSIX has any requirements that those be the same, but if they differ you are out of luck, because you cannot give function templates C language linkage
p27297
as(dp27298
g15
V34509
p27299
stp27300
a((dp27301
g2
(lp27302
VThe second one will prevent that you copy it to a new non-const array
p27303
aVSince I would expect that to work, I would probably go with the first option
p27304
aVPassing the second one to templates that expect a  will prevent those templates from modifying their parameter (even if it's a copy)
p27305
aVThe first one would "just work", since the parameter would have the type
p27306
as(dp27307
g15
V34509
p27308
stp27309
a((dp27310
g2
(lp27311
VCritical Update
p27312
aVThe below analysis is wrong, because it confuses one important thing
p27313
aVThe following statement I did missed one important detail, which requires an entirely different answer
p27314
aVThe unnamed reference  returns will refer to that operand
p27315
aVThe problem here is that function invocation substitution is done at that point
p27316
aVIf the invocation susbstitution would include the lvalue to rvalue conversion on that glvalue that  yields, everything would be fine, because reading from a glvalue that refers to a temporary not of static storage duration is fine during computation of the constant expression
p27317
aVBut since the read happens outside of function invocation substitution, the result of function invocation substitution is an lvalue
p27318
aVThe respective text of the spec says
p27319
aVA reference constant expression is an lvalue core constant expression that designates an object with static storage duration or a function
p27320
aVBut the reference that  returns yields an lvalue that designates an object of unspecified storage duration
p27321
aVFunction invocation substitution is required to yield a constant expression, not merely a core constant expression
p27322
aVSo  is not guaranteed to work
p27323
aVThe following (older) text needs to be read taking the above into account
p27324
aVI can't see any reason at the moment why you wouldn't want to stick a  there
p27325
aVAnyway, the following code definitely is useful
p27326
aVContrary to what other answers write, I think this is legal
p27327
aVNot all instantiations of  are required to be constexpr functions
p27328
aVThe current n3242 says
p27329
aVIf the instantiated template specialization of a constexpr function template or member function of a class template would fail to satisfy the requirements for a constexpr function or constexpr constructor, that specialization is not a constexpr function or constexpr constructor
p27330
aVIf you call the template, argument deduction will yield a function template specialization
p27331
aVCalling it will trigger function invocation substitution
p27332
aVConsider the following call
p27333
aVIt will first do an implicit conversion of the two  prvalues to the two reference parameters, binding both references to temporary objects storing their value
p27334
aVThe result of this conversion is a glvalue for each case that refers to a temporary object (see 4p3)
p27335
aVNow function invocation substitution takes those two glvalues and substitutes all occurences of  and  in the function body by those glvalues
p27336
aVThe condition will require lvalue to rvalue conversions on these glvalues, which are allowed by 5
p27337
aV19p2
p27338
aVa glvalue of literal type that refers to a non-volatile temporary object initialized with a constant expression
p27339
aVThe conditional expression will yield a glvalue to either the first or second operand
p27340
aVThe unnamed reference  returns will refer to that operand
p27341
aVAnd the final lvalue to rvalue conversion happening in the array dimension size specification will be valid by the same rule quoted above
p27342
aVNote that  currently doesn't have  member functions
p27343
aVThis is a known limitation and will be handled post-C++0x, most likely making those members
p27344
as(dp27345
g15
V34509
p27346
stp27347
a((dp27348
g2
(lp27349
VHow about putting a common base class
p27350
as(dp27351
g15
V34509
p27352
stp27353
a((dp27354
g2
(lp27355
VYou don't have to redefine the struct in , and you also can't do this
p27356
aVThe caller of  statically gets a  back, so the compiler forbids you to override the base class function like that, because the dynamically returned object would potentially be incompatible with  (who knows what you put into  and how  differs in behavior from the base class vector
p27357
aVAs for the allowed difference, C++ only allows the derived class return type to be a derived class of the base class return type, and only when the return types are pointers or references
p27358
as(dp27359
g15
V34509
p27360
stp27361
a((dp27362
g2
(lp27363
VI don't know why you think that this make sense
p27364
aVYou cannot make this work: Template arguments cannot be values of type  (they can be an lvalue of type , but your template requires the address of a , so that's off)
p27365
aVYou can use function templates to make your syntax work
p27366
aVAlternatively, you can use class templates if you are up for some ugly hacks
p27367
aVThe default argument will not be used if you provide both arguments
p27368
aVIf you provide only , the default argument will be used and will work
p27369
aVIf you only provide , the default argument will be used too, but will not work
p27370
as(dp27371
g15
V34509
p27372
stp27373
a((dp27374
g2
(lp27375
VIf you want to compare arbitrary class hierarchies, the safe bet is to make them polymorphic and use
p27376
aVConsider that sometimes you cannot use static_cast or implicit conversion from a derived to a base class:
p27377
aVIf  is inherited virtually, you can't static_cast to a  either
p27378
as(dp27379
g15
V34509
p27380
stp27381
a((dp27382
g2
(lp27383
VI think they just forgot to change the warning text
p27384
aVThe  operator evaluates the left operand, then evaluates the right operand and yields the result of the right operand's evaluation
p27385
aVIf the right operand has no effect and its value is not used, it's probably a bug in the program
p27386
aVNow they just abused the above warning text to warn for other binary operators, it seems
p27387
as(dp27388
g15
V34509
p27389
stp27390
a((dp27391
g2
(lp27392
VI think this will call
p27393
aVEach invocation of  will increment
p27394
aVCalclating the number of calls is equivalent to calculating the number of nodes of a complete n-ary tree of height  (the root of this tree represents the call )
p27395
aVSo I think the solution is
p27396
as(dp27397
g15
V34509
p27398
stp27399
a((dp27400
g2
(lp27401
VRVO allows it to construct the temporary string object directly into the return value object of
p27402
aVRVO allows it to directly construct the temporary string object (the return value object) directly into the parameter object of
p27403
aVThese are the RVO scenarios allowed
p27404
aVIf your compiler cannot apply them, it has to use move constructors (if available) to move the return value into the return value object and the parameter object, respectively
p27405
aVIn this case that is not surprising because both temporary objects are or are treated as rvalues anyway
p27406
aV(For the first scenario, no expression corresponds to the created temporary, so the treatment is only for the purpose of selecting what constructor is used for copying/moving the temporary into the return value object)
p27407
aVFor other cases, the compiler has to consider things as rvalues even if they are otherwise lvalues
p27408
aVThe spec says when it could potentially apply RVO (or NRVO) to an lvalue by the rules it sets forth, the implementation is required to treat the expressions as rvalues and use move constructors if available, and only if it couldn't find a suitable constructor, it should use the expression as an lvalue
p27409
aVIt would be a pity for the programmer to write explicit moves in these cases, when it's clear the programmer would always want a move instead of a copy
p27410
aVExample:
p27411
aVFor the first, it takes  as an rvalue, but cannot find constructors that accept this rvalue ( cannot bind to rvalues)
p27412
aVTherefor, it then again treats  as what it is (an lvalue)
p27413
aVFor the second, it takes  as a rvalue, and has  take that rvalue and move it
p27414
aVIf it would have taken  as an lvalue (what it is), then the copy initialization would have failed, because  has no copy constructor implicitly declared
p27415
aVNote that returning and paramter passing uses the rules of copy initialization, which means
p27416
aVHence, in the example where we return a , we first create an rvalue temporary and then move that into the target
p27417
aVFor the case where we return an expression of the type of the return value / paramter, we will directly move / copy the expression into the target
p27418
as(dp27419
g15
V34509
p27420
stp27421
a((dp27422
g2
(lp27423
VFor C++, I would use unary +:
p27424
aVFor a general macro case, this has the advantage over adding  that it also works for  and function pointers
p27425
aVFor C, you can use the comma operator
p27426
as(dp27427
g15
V34509
p27428
stp27429
a((dp27430
g2
(lp27431
VNow,  is
p27432
aVIt would be  if you for example stored a
p27433
aVYes,  is a variable
p27434
as(dp27435
g15
V34509
p27436
stp27437
a((dp27438
g2
(lp27439
VI think if  is encountered, it takes , replaces  with , and then rescans
p27440
aVis an invocation of
p27441
aVTherefor, it takes , and replaces  by  (along with the other parameters)
p27442
aVIt then rescans and resolves to
p27443
aVI don't know why it works that it calls a 4-parameter macro with 3 arguments in your case
p27444
aVYou could do
p27445
aVThat would take , substitute , and then rescan, causing  to be replaced by
p27446
aVThe resulting token string  would then do what you expected
p27447
aVEDIT: Tested with GCC :)
p27448
aVEDIT: I noticed you want the string , but my answer yields the string
p27449
aVI think that's because when it rescans after calling , it replaces  by
p27450
aVThen it would need another scan to notice that it can now invoke  with those arguments
p27451
aVSo  should be
p27452
aVWhen  for the outer  is substituted by , it rescans and yields  for the invocation of
p27453
aVThen it rescans again for the invocation of  and yields the sequence you really wanted
p27454
as(dp27455
g15
V34509
p27456
stp27457
a((dp27458
g2
(lp27459
VThe usual way to lower references in compilers is to pointers
p27460
aVFor a reference-returning function, it will mean you get an arbitrary address represented, whatever was in the register or stack slot used for the return value
p27461
aVFormally in the language, the effects are undefined
p27462
as(dp27463
g15
V34509
p27464
stp27465
a((dp27466
g2
(lp27467
VDoesn't MSVC implement the late-parsing scheme
p27468
aVIn such a scheme, the compiler isn't dependent on
p27469
aVIt just stores all the token in between the template definition's braces, and when the template is instantiated, it parses those tokens
p27470
aVSince it then knows what is and what is not a type, it will work without
p27471
aVBut if the compiler doesn't diagnose the missing  when you instantiate the template, then it's non-conforming
p27472
aVOr is it actually possible to deduce that iterator_category is either a type or a function because it's followed by a pair of parenthesis ()
p27473
aVAll that matters is whether the name is dependent and qualified
p27474
aVWhether or not the template could deduce itself that the name is always a type doesn't matter
p27475
aVIt might matter for the quality of error messages for missing s though
p27476
aVFWIW, no it's not possible to deduce anything about  on a language level
p27477
as(dp27478
g15
V34509
p27479
stp27480
a((dp27481
g2
(lp27482
VYes, you get a function call
p27483
aVBut function calls can be compile time constant expressions because of  literal operator functions
p27484
aVFor an example, see this one
p27485
aVAs another example to show the advanced form of  computations allowed by the FDIS, to have compile time base-26 literals you can do
p27486
aVSaying  will evaluate a throw-expression, and thereby cause the return value to become non-constant
p27487
aVIn turn, it causes any use of  as a constant expression to become ill-formed, and any non-constant use to throw at runtime
p27488
aVThe allowed form  evaluates to a constant expression of the respective computed value
p27489
aVNote that reading from string literals is not explicitly allowed by the FDIS, however it presents no problem and GCC supports this (the character lvalue reference is a constant expression and the character's value is known at compile time)
p27490
aVIMO if one squints, one can read the FDIS as if this is allowed to do
p27491
aVThen, we got the templated user-defined-literal, that never really gets defined in the standard AFAICS (i
p27492
ag1992
aV, no example is given, please prove me wrong)
p27493
aVThe treatment of literals as invoking literal operator templates is defined in 2
p27494
aV14
p27495
ag14557
aVYou find more examples at 13
p27496
ag1014
aV8 that detail on the literal operator function/function templates itself
p27497
aVIs that function somehow magically invoked at compile time or is it still runtime
p27498
aVThe keyword is function invocation substitution
p27499
aVSee 7
p27500
ag2790
ag1014
as(dp27501
g15
V34509
p27502
stp27503
a((dp27504
g2
(lp27505
VThe safest way is to check it before doing the conversion
p27506
aVThese templates do exactly that
p27507
aVExample:
p27508
as(dp27509
g15
V34509
p27510
stp27511
a((dp27512
g2
(lp27513
VYou need to be able to mangle template arguments
p27514
aVNow an impl would need to come up with a unique sequence of characters for a  or, for that matter, any other arbitrary user defined class, storing a particular value, the meaning of which is not known to the implementation
p27515
aVAnd in addition, the value of arbitrary class objects can't be calculated at compile time
p27516
aVIt's planned to consider allowing literal class types as template parameter types for post-C++0x, which are initialized by constant expressions
p27517
aVThose could be mangled by having the data members recursively mangled according to their values (for base classes, for example we can apply depth-first, left-to-right traversal)
p27518
aVBut it's definitely not going to work for arbitrary classes
p27519
as(dp27520
g15
V34509
p27521
stp27522
a((dp27523
g2
(lp27524
Vboost::optional and boost::recursive_wrapper look useful for this
p27525
aVYou need 4 braces for every submenu you add
p27526
aVBrace elision does not happen when constructor calls are involved
p27527
aVFor example
p27528
aVHonestly, using constructors look more readable
p27529
aVNow it simplifies to
p27530
as(dp27531
g15
V34509
p27532
stp27533
a((dp27534
g2
(lp27535
VIt appears you want to use the  form of initialization
p27536
aVOne of the reasons for these uniform initialization was that to use explicit constructors for creating a temporary, you need a cast aka
p27537
aVWith  that problem was solved
p27538
aVFor C++03, I imagine you could do something like this:
p27539
aVThen you can say , although in a case like in your conversion function, it also works to use a named variable as an intermediary step, I think
p27540
as(dp27541
g15
V34509
p27542
stp27543
a((dp27544
g2
(lp27545
VMost likely you forgot a semicolon after 's definition
p27546
aVThen your code is parsed as
p27547
aVThat's valid syntactically
p27548
aVBut as constructors don't have a return type, like the message says, the compiler complains
p27549
as(dp27550
g15
V34509
p27551
stp27552
a((dp27553
g2
(lp27554
V is an elaborated type specifier
p27555
aVName lookup for an elaborated type specifier ignores non-type names
p27556
aVSo if you are parsing a template, you can assume two things:
p27557
aVWhen we are instantiating and do name-lookup for , either name lookup gives us a type, or it errors out (wouldn't find any name)
p27558
aVIn C++0x for that reason,  doesn't need  (you can't put it anywhere anyway on a elaborated type specifier)
p27559
aVC++03 doesn't allow that, so GCC appears to implement the C++0x rules as an extension
p27560
aVThat's not particularly bad
p27561
aVEvery real compiler implements rules that are sensible and easy to implement in their C++03 version, on their behalf, even if formally they would need to reject it
p27562
aVHowever,  must lookup to a class name
p27563
aVIf it's merely a typedef, then the lookup for the elaborated type specifier is invalid
p27564
aVNote that  is the only way to ignore non-type names in a lookup (except for arcane cases like before a  in a qualified name that have similar special rules)
p27565
aVFor example
p27566
aVIf you compile to C++0x, and you use , then the code becomes valid, because  ignores the data member, but finds the nested class
p27567
as(dp27568
g15
V34509
p27569
stp27570
a((dp27571
g2
(lp27572
VThe reason is that only ADL is done at the instantiation context
p27573
aVOther function lookups are only done in the definition context of the  template
p27574
aVAnd at that definition context, only the  overload accepting the  is declared
p27575
aVEdit: If you want to have a Standard reference for this, refer to [temp
p27576
aVdep
p27577
aVcandidate] and [temp
p27578
aVres]p1
p27579
as(dp27580
g15
V34509
p27581
stp27582
a((dp27583
g2
(lp27584
VYes, it does initialize a non-const reference with a temporary
p27585
aVBut only conceptually during overload resolution and not actually
p27586
aVThe compiler should not warn about it
p27587
aVIn overload resolution, the  has this function parameter signature
p27588
aVThe first parameter will receive the temporary returned by , but as said, that's fine and C++ makes specifically an exception for that reference, which is the so-called "implicit object parameter", so that overload resolution accepts the temporary argument
p27589
as(dp27590
g15
V34509
p27591
stp27592
a((dp27593
g2
(lp27594
VThis is only possible with C++0x
p27595
aVNo chance with C++03
p27596
aVEDIT: Constexpr function for C++0x
p27597
aVThe following works with GCC4
p27598
aV6, however the Standard is not explicit in allowing it, and a small wording tweak was and is being considered to make the spec allow it
p27599
aVThe compiler is required to track the reference to characters of the string literals already, throughout all the recursions
p27600
aVJust the final read from characters isn't explicitly allowed (if you squint, you can read it as being allowed, IMO)
p27601
aVIf your compiler doesn't want to accept the above simple version, you can make your macro declare arrays and then compare those
p27602
aVThat's definitely fine
p27603
aVNote that  can be used inside of functions
p27604
aVThe FCD did make a change to allow  functions to read from automatic arrays in their invocation substitution
p27605
aVSee DR1197
p27606
as(dp27607
g15
V34509
p27608
stp27609
a((dp27610
g2
(lp27611
VYes, your solution is portable
p27612
aVHere is a different way
p27613
aVNow whenever  is implicitly instantiated, it will implicitly instanitate
p27614
aVNo object needs to be created
p27615
as(dp27616
g15
V34509
p27617
stp27618
a((dp27619
g2
(lp27620
VThe call to  returns before the full expression has been completely evaluated
p27621
aVAnd when  has returned, it will have printed its stuff (there is a sequence point before returning from )
p27622
aVThe temporary  is only destroyed after the complete full expression has been evaluated
p27623
as(dp27624
g15
V34509
p27625
stp27626
a((dp27627
g2
(lp27628
VThis works fine for me with GCC4
p27629
aV5:
p27630
aVIt doesn't need the type of the parameters
p27631
aVThose parameter types could be templated anyway (for some functors), so in general it cannot depend on them
p27632
aVIt only needs the return type
p27633
aVIncidentally, it even works for me when I pass , but only when the lambdas has no captures
p27634
aVI think that this may work for me because GCC4
p27635
aV5 supports conversion of lambdas to function pointer types, when the lambdas has no capture clause
p27636
aVwould make  have a candidate that accepts a function pointer, and make the lambda convert to that
p27637
aVYour compiler apparently doesn't support that special conversion yet (but the FDIS requires it)
p27638
aVSo, just pass  only, and it should work
p27639
as(dp27640
g15
V34509
p27641
stp27642
a((dp27643
g2
(lp27644
VNo, this is undefined behavior
p27645
aVBoth  temporaries and the temporary returned by  only live until the end of the initialization of your  (end of full expression)
p27646
aVThen they are destroyed and  points to uncertain memory
p27647
as(dp27648
g15
V34509
p27649
stp27650
a((dp27651
g2
(lp27652
V and  are drivers
p27653
aVUsually, they run the preprocessor (), compiler proper ( for C++ and  for C) and the linker (gold or GNU ld) and all other things necessary
p27654
aVThe difference between  and  is that the latter includes one additional library to link against ()
p27655
aVDepending on what type of file they are invoked on, they may omit some steps or do things differently
p27656
aVFor  files, it doesn't need to run the compiler proper or the preprocessor, for example
p27657
aVIf you pass  to them, you can see it print the tools it invokes in each step of its execution
p27658
as(dp27659
g15
V34509
p27660
stp27661
a((dp27662
g2
(lp27663
VNow doing
p27664
aVWill do
p27665
as(dp27666
g15
V34509
p27667
stp27668
a((dp27669
g2
(lp27670
s(dp27671
g15
V34509
p27672
stp27673
a((dp27674
g2
(lp27675
VIf  doesn't have a user declared constructor, the behavior is different
p27676
aVCompare:
p27677
aVNow,  and  are guaranteed to be zero
p27678
aVIf you would have left off the explicit initialization of the base class, they would have indeterminate values
p27679
aVIt may be unknown to you that, despite the syntax, the above use of  does not call the default constructor, though
p27680
aVIt simply value initializes the base class (we have several good answers here on Stackoverflow about what "value initialization" is), not calling the default constructor because there is none user declared
p27681
as(dp27682
g15
V34509
p27683
stp27684
a((dp27685
g2
(lp27686
VThat's because the spec says in 14
p27687
aVp5:
p27688
aVA class template shall not have the same name as any other template, class, function, variable, enumeration,
p27689
aVenumerator, namespace, or type in the same scope (3
p27690
aV3), except as speci\ufb01ed in (14
p27691
ag1014
aV5)
p27692
aVExcept that a
p27693
aVfunction template can be overloaded either by (non-template) functions with the same name or by other
p27694
aVfunction templates with the same name (14
p27695
ag14557
aV3), a template name declared in namespace scope or in class
p27696
aVscope shall be unique in that scope
p27697
as(dp27698
g15
V34509
p27699
stp27700
a((dp27701
g2
(lp27702
VThe reason this doesn't work is because overload resolution for user defined operator functions is only triggered if at least one operand of the expression has a class or enumeration type
p27703
aVSo you are out of luck
p27704
aVThis won't work
p27705
aVI think the best you could try is waiting for a C++0x compiler and instead of writing , you write , as a user defined literal
p27706
as(dp27707
g15
V34509
p27708
stp27709
a((dp27710
g2
(lp27711
VIt could probably be argued for the following
p27712
aVOnly in the middle case,  can be a runtime value
p27713
aVNevertheless, the spec does not establish such a type difference
p27714
aVArrays need special handling anyway in almost all cases (as in, you cannot just copy them either)
p27715
aVSo you should be prepared to handle them specially
p27716
aVFor example, you also have to use  instead of  in your case
p27717
aVJust to make it clear, if the above would be true, then you would need awkward syntax
p27718
aVYou would first need to dereference the array pointer
p27719
as(dp27720
g15
V34509
p27721
stp27722
a((dp27723
g2
(lp27724
Vthat it doesn't just complain that no suitable operator exists
p27725
aVThat's IMO a plain stupid compiler behavior, if that's what happens
p27726
aVSurely it should first tell you what's wrong (i
p27727
aVe no suitable operator exists) and then list all the considered templates
p27728
aVone is that it gives this error for each overloaded + operator that involves templates
p27729
aVThis tells me that the compiler has absolutely no way of ruling out that any of these + are not meaningful;
p27730
aVIn general, it cannot do this, because for example  might be a base class of , which means that that one operator overload might be viable and deduction succeed
p27731
aVArgument deduction is the phase in compiling a C++ at that stage that figures these things out, and the compiler just reports the result of argument deduction to you
p27732
as(dp27733
g15
V34509
p27734
stp27735
a((dp27736
g2
(lp27737
VWhy can I call a protected method but not take its address
p27738
aVThis question has an error
p27739
aVYou cannot do a call either
p27740
aVAs another answer says if you access the non-static protected member by a , then you can
p27741
aVMaybe you want to read this
p27742
aVAs a summary, read this issue report
p27743
as(dp27744
g15
V34509
p27745
stp27746
a((dp27747
g2
(lp27748
VWhy would you want to do this
p27749
aVAs far as I know, the only difference is that  in addition passes  to the linker, to link the C++ Standard library
p27750
aVSo if you pass that option to GCC, it should forward it to the linker, and all should be fine
p27751
aVBut I really don't see a reason in doing this
p27752
aVJust use
p27753
aVThat said, I used  myself in the past, to compile C++ code
p27754
aVWhen I had a bunch of files, mixed C++ and C code, I just compiled everything using , because  by default treats  as being C++ code, which breaks the build when the C code uses such things as  as identifiers
p27755
aVAdding  always worked nicely
p27756
aVSee the GCC manpage
p27757
aVCompiling C++ Programs
p27758
aVC++ source files conventionally use one of the suffixes
p27759
aVC,
p27760
aVcc,
p27761
aVcpp,
p27762
aVCPP,
p27763
aVc++,
p27764
aVcp, or
p27765
aVcxx; C++ header files often use
p27766
aVhh,
p27767
aVhpp,
p27768
aVH,
p27769
aVor (for shared template code)
p27770
aVtcc; and preprocessed C++ files use the suffix
p27771
aVii
p27772
aVGCC recognizes files with these names and compiles them
p27773
aVas C++ programs even if you call the compiler the same way as for compiling C programs (usually with the name gcc)
p27774
aVHowever, the use of gcc does not add the C++ library
p27775
aVg++ is a program that calls GCC and treats
p27776
aVc,
p27777
aVh and
p27778
aVi files as C++ source files
p27779
aVinstead of C source files unless -x is used, and automatically specifies linking against the C++ library
p27780
aVThis program is also useful when
p27781
aVprecompiling a C header file with a
p27782
aVh extension for use in C++ compilations
p27783
aVOn many systems, g++ is also installed with the name c++
p27784
aVWhen you compile C++ programs, you may specify many of the same command-line options that you use for compiling programs in any language;
p27785
aVor command-line options meaningful for C and related languages; or options that are meaningful only for C++ programs
p27786
as(dp27787
g15
V34509
p27788
stp27789
a((dp27790
g2
(lp27791
V will return either  or
p27792
aVIt depends on whether the implementation first increments  and then calls , or whether it first calls  and then increments
p27793
aVPlease note that this choice does not mean that behavior is undefined
p27794
aVSince before a function is entered, and after a function is left, there is a sequence point at each point, both increments we have here are separated by a sequence point, so that the increment in , if it started to happen before the call, will be finished once entering , and if it happens after  was called, will not have yet started until  has left
p27795
aVWe have multiple scenarios here:
p27796
aVFirst do the increment for , then call
p27797
aVThis will write  into
p27798
aVFirst call , then do the increment for
p27799
aVThis will write  into
p27800
aVSo,  is always , and  is always  (it wasn't overwritten)
p27801
aVSo it should output , not
p27802
aVI think that if you do the following, you have more options
p27803
aVNow, the value read from  can be different than , because there is nothing that stops  to be called after incrementing  but before reading it
p27804
aVIn this case we have
p27805
aVFirst do the increment for , then call , then read from
p27806
aVThis will write  into
p27807
aVFirst do the increment for , then read from , and then call
p27808
aVThis will write  into
p27809
aVFirst call , then do the increment for  and read from it
p27810
aVThis will write  into
p27811
aVIn this case, you can either have output  or  or
p27812
as(dp27813
g15
V34509
p27814
stp27815
a((dp27816
g2
(lp27817
VNothing happens, because your code is ill-formed
p27818
aVand  declare  and
p27819
aVSince  has already been declared, and  in any case has no default constructor, the compiler shall emit a diagnostic
p27820
aVIf you fix these issues, then the compiler is allowed to optimize away these, if the  and  you are using are the Standard libraries' functions, because that code really has no observable side effects
p27821
aVAn optimizing compiler should know about the special meaning of  and , and I wouldn't be surprised to see it optimize this away
p27822
aVBut for whatever reasons there might be, I can also imagine the compiler doesn't optimize it away
p27823
aVIt really depends on your compiler and the flags it uses, but the Standard definitely allows it to optimize here
p27824
aVHere is the code that  outputs:
p27825
as(dp27826
g15
V34509
p27827
stp27828
a((dp27829
g2
(lp27830
VThere were a couple of good notes in existing answers
p27831
aVFirst, 's type is incomplete at the time the nested class template is defined, but  is a dependent type
p27832
aVNow, if you instantiate the nesting template (), it will instantiate a declaration of the nested template (the member)
p27833
aVNote that the declaration of the member does not include the base clause list, so it doesn't need complete base classes
p27834
aVOnce the nesting template has been instantiated implicitly,  is complete and when it comes to instantiating the definition of the member, there should be no issue anymore
p27835
aVSo I don't think that comeau is correct complaining here
p27836
aVThe other bug is that, in fact,  is naming the constructor of , and requires it to be a constructor template (with  being the template arguments)
p27837
aVThe base of this was DR #147
p27838
aVThe translation to the constructor is not done when the qualifier name isn't the class of the injected class name
p27839
aVFor example, if it is a derived class, your code becomes valid (as some answers figured out)
p27840
as(dp27841
g15
V34509
p27842
stp27843
a((dp27844
g2
(lp27845
VMSVC++ is not correct
p27846
aVis a template, not a type
p27847
aVNote that in the usual case,  is looked up in the scope of , which means that it will first find the injected class name inherited from , which refers to the type
p27848
aVBut as you have a dependent base class, the name inherited from  is not found (the base class scope is not looked into)
p27849
as(dp27850
g15
V34509
p27851
stp27852
a((dp27853
g2
(lp27854
VThe better question is when and why
p27855
aVYour question indicates that you think all base classes should have virtual destructors, which is not quite true
p27856
aVIt would make it impossible to apply the empty base class optimization, and could multiply the size of classes up to 16 times than what it would be without  on common platforms
p27857
aVA  destructor is needed when you  an object whose dynamic type is  by a pointer that has type
p27858
aVThe  makes the compiler associate information in the object making it able to execute the derived class constructor
p27859
aVMissing the  in such cases causes undefined behavior
p27860
aVIf you don't need this, and your class is only used as a base class, it's best to make the destructor , thus preventing that users accidentally  in the described way
p27861
as(dp27862
g15
V34509
p27863
stp27864
a((dp27865
g2
(lp27866
VThey mean to sum up the items of where functions must differ in order to be put into the same class scope
p27867
aVThe  at the end is:
p27868
aVThese are valid overloads
p27869
aVThe first is called if you call  on a , and the second is used if you call it on a :
p27870
aVNote that the term "signature" is misused here
p27871
aVThe signature of a function is more broad, and includes also the class of which a function is a member of
p27872
aVA signature uniquely identifies a function
p27873
as(dp27874
g15
V34509
p27875
stp27876
a((dp27877
g2
(lp27878
VYou are missing the line splice characters
p27879
aVThe line splice characters say that the current line and the next line are merged into a single line
p27880
aVWithout them, the macro definition ends at the end-of-line, so the  in your code wasn't really part of the macro
p27881
aVYou also miss a semicolon after the macro invocation in  (there needs to be a semicolon after each class or enumeration definition in C++)
p27882
as(dp27883
g15
V34509
p27884
stp27885
a((dp27886
g2
(lp27887
VAll this is missing the better readability it adds, without needing to use typedefs or alias templates
p27888
aVCompare that to the equivalent
p27889
aVYou can also access  in a late specified return type, but not in the early return type
p27890
aVIf you had it the other way around, it wouldn't work, because  would not be in scope, and  would have the same type both time (no implicit  would be added, so the type of  could not influence the type of )
p27891
as(dp27892
g15
V34509
p27893
stp27894
a((dp27895
g2
(lp27896
VBecause compilers are not required to diagnose templates that can never be instantiated to valid specializations
p27897
aVThey are only required to diagnose them when they are actually instantiated
p27898
aVWhether they diagnose them any earlier is only a quality of implementation
p27899
aVThis is true for member functions of class templates too
p27900
aVIf you would try to call , the compiler will need to instantiate the member function, and would be required to diagnose the error
p27901
aVA good compiler would given an error in both cases
p27902
aVHardLogic::compare returns void but the function tries o return a int/bool
p27903
aVSince the  in question is not defined, you don't know what it would return
p27904
aVIt could return , in which case  would be fine
p27905
aVAre thoose mistakes
p27906
aVI found it odd to be so many mistakes in a code from a book like this, so am I missing something
p27907
aVCheck the errata pages of the book, if they exist
p27908
aVFrom what I can see from your description, it contains at least one typo ( vs )
p27909
as(dp27910
g15
V34509
p27911
stp27912
a((dp27913
g2
(lp27914
VIt's UB because it's not worded in terms of loops, but in terms of (1
p27915
aV10p24):
p27916
aVThe implementation may assume that any thread will eventually do one of the following:
p27917
aVterminate,
p27918
aVmake a call to a library I/O function,
p27919
aVaccess or modify a volatile object, or
p27920
aVperform a synchronization operation or an atomic operation
p27921
aVThis applies to both, as opposed to the more older formulation in one of the C++0x drafts
p27922
aV(See this question for discussions)
p27923
aVNote that disregarding of that, the behavior can easily be undefined if the recursion exceeds the implementation limit of the number of nested recursive function calls
p27924
aVThat has always been the case
p27925
as(dp27926
g15
V34509
p27927
stp27928
a((dp27929
g2
(lp27930
VHave you  be defined
p27931
aVYou need to include  for it
p27932
aVBut better you include  and use
p27933
aVYour declaration otherwise looks fine, apart from the semantics of always returning  being screwed up
p27934
aVThe  should return a buffer of the size specified as the first argument
p27935
as(dp27936
g15
V34509
p27937
stp27938
a((dp27939
g2
(lp27940
VFirst: Don't use
p27941
aVInstead, put the name of the enumeration in its head
p27942
aVIn a nutshell, doing like you did will behave mostly the same, but in arcane corner cases will be different
p27943
aVThe syntax you used will behave very different from the syntax I used above only in C
p27944
aVSecond: That just defines a type
p27945
aVBut you want to define an object of that enumeration
p27946
aVDo so:
p27947
aVIn summary:
p27948
as(dp27949
g15
V34509
p27950
stp27951
a((dp27952
g2
(lp27953
VIt compiles in C++ because C++ needs to support dynamic initialization anyway, or you couldn't have local static or non-local objects with non-trivial constructors
p27954
aVSo since C++ has this complexity anyway, supporting that initialization like you show isn't complicated to add anymore
p27955
aVIn C that would be a big matter because C doesn't have any other reason to support initialization done at program startup (apart from trivial zero initialization)
p27956
aVIn C, initial values of file-scope or local static objects can always statically be put into the executable image
p27957
as(dp27958
g15
V34509
p27959
stp27960
a((dp27961
g2
(lp27962
VYour code should work
p27963
aVHowever,  is of type
p27964
aVYou want to say  to say
p27965
aVBut this doesn't necessarily matter here,  is convertible to
p27966
aVYes, the constructor with parameter  would be used to create a temporary  object, which would be copied to  (and your compiler should optimizes the copy, so you are likely not to see a copy constructor call here, unless you have told it not to optimize)
p27967
as(dp27968
g15
V34509
p27969
stp27970
a((dp27971
g2
(lp27972
VIn my world, "FileX
p27973
aVh" is defined as follows
p27974
aVSo yes, there "Does something happen different in the compiler" in this case
p27975
aVEven if it is simply defined as follows, things may be different
p27976
aVIf you include too many headers, you may hit the compiler's resource limit earlier than if you included  directly, and it may hit different paths that may hit different errors in your compiler etc
p27977
aVSo it really depends on what you mean by "Does something different in the compiler" at all
p27978
as(dp27979
g15
V34509
p27980
stp27981
a((dp27982
g2
(lp27983
VA major difference is: Explicit specializations don't participate in overloading at all
p27984
aVCalling with  will not consider any explicit specializations
p27985
aVIt will only take all templates, and deduce their template arguments
p27986
aVThe above  will be deduced to , and so the specialization won't be selected
p27987
aVIf you overload the function template instead, you have completely different characteristics
p27988
aVCalling this, it will select the second function, because because both the  parameter of the generated specialization and the  parameter match the argument equally well, but the second function is a non-template function, hence it is preferred eventually
p27989
as(dp27990
g15
V34509
p27991
stp27992
a((dp27993
g2
(lp27994
VAs some say,  is accepted by your compiler, but when it's evaluated, it produces undefined behavior in C++03
p27995
aVNote that simply saying  is fine, because nothing is evaluated
p27996
aVSaying  is fine in C++11 even if it's evaluated
p27997
as(dp27998
g15
V34509
p27999
stp28000
a((dp28001
g2
(lp28002
VYou can befriend arbitrary types (for non-class types, the friend declaration will be ignored), but then you shall omit :
p28003
as(dp28004
g15
V34509
p28005
stp28006
a((dp28007
g2
(lp28008
VThat looks like valid code
p28009
aVWhatever MSVC is doing, it appears to be some weird non-conforming behavior, from what I can see
p28010
as(dp28011
g15
V34509
p28012
stp28013
a((dp28014
g2
(lp28015
VThat's because  needs a base conversion to  when you pass it to the other template, while it doesn't need any conversion when you pass it to the template that forwards to
p28016
aVSo if you pass , it selects the more generic template which forwards the ostringstream as an argument to output to the more specific template
p28017
aVOutputting the  converts it to a , which is then printed
p28018
aVYou can solve this with  (just feels better to me than using )
p28019
aVI personally dislike using too much SFINAE in my code, because I can't cope with a certain level of angle brackets
p28020
aVSo I like to use overloading
p28021
aVThis way, if you call it with something other than lvalue of  as first argument, it will call , which will transform the call into such an lvalue of , so that your other  template can continue
p28022
aVOn a final note, you should say , otherwise all your work to use  in previous recursion steps would be for naught, because in the end you would output everything as lvalues anyway
p28023
as(dp28024
g15
V34509
p28025
stp28026
a((dp28027
g2
(lp28028
VI'm not aware of a short and concise way
p28029
aVBut you can abuse overloading again
p28030
aVIt will only detect public inheritance
p28031
aVNote that you can instead detect derivation from , which may work for you equally well (this test will also be positive for input streams, so it's only of limited applicability)
p28032
as(dp28033
g15
V34509
p28034
stp28035
a((dp28036
g2
(lp28037
VYou can codegen your source-language  statement / expressions as copies into the return storage followed by a branch to a designated return basic block, which will destroy locals
p28038
aVIf your generated LLVM function returns the value itself, instead of following its own protocol (by returning the value through the first parameter, or some such), you can save the return value to an  first, and then load that  and return that with
p28039
aVExample for when you return through the first parameter, with  denoting the struct storing values in your language runtime
p28040
as(dp28041
g15
V34509
p28042
stp28043
a((dp28044
g2
(lp28045
VReplace
p28046
aVby
p28047
aVto typedef the function-type
p28048
aVYou can then write the  when using it
p28049
as(dp28050
g15
V34509
p28051
stp28052
a((dp28053
g2
(lp28054
VThere's still the question: Who's right
p28055
aVGCC is right here
p28056
aVUnqualified name lookup does not look into dependent base classes, hence will not find  in the scope of
p28057
aVYou can change your code to the following Standard conformant variant too
p28058
aVIf I remember correctly, this is only supported by GCC4
p28059
aV5 though
p28060
aVEarlier versions didn't implement injected class name lookup properly
p28061
as(dp28062
g15
V34509
p28063
stp28064
a((dp28065
g2
(lp28066
VDefine:
p28067
aVThen:
p28068
aVThen you can pass  to a template that has a partial specialization for
p28069
aVIf you typedef the , you can instead write a partial specialization for , which may make more sense for your case
p28070
aVSo having a typedef for  equal , you could write this as follows (untested, but should work):
p28071
as(dp28072
g15
V34509
p28073
stp28074
a((dp28075
g2
(lp28076
VI'm sorry
p28077
aVI talked to its author, and he said he won't make it parse C++ fully, but admits that he accepts it to parse certain constructs as ambiguous
p28078
aVSo this is not an answer anymore
p28079
aVI recommend you to have a look at scalpel
p28080
aVFrom its homepage
p28081
aVScalpel stands for source code analysis, libre and portable library
p28082
aVThis is a C++ library which aims to perform full syntax and semantic analysis of any given C++ program
p28083
aVAnd
p28084
aVWhat makes me think Scalpel could be accepted into Boost
p28085
aVScalpel uses itself several Boost libraries: Spirit, Wave, shared_ptr (now in C++0x's STL), Optional, Test, etc
p28086
aVActually, it exclusively uses Boost libraries and the C++ standard library, which is required by Boost
p28087
aVBesides, Boost already provides a Spirit-based C++ source code preprocessing library: Wave
p28088
aVIncluding a C++ source code analysis library seems to be a natural evolution
p28089
as(dp28090
g15
V34509
p28091
stp28092
a((dp28093
g2
(lp28094
VVS is right on C++03
p28095
aVGCC is right on C++0x
p28096
aVNow it may be sensible for GCC to also allow this in C++03 mode (there are many things real compilers don't diagnose in C++03 mode that are actually only valid in C++0x), and it may as-well sensible for VS to reject it in C++03 mode
p28097
aVIt doesn't matter anymore whether or not a use of  happens in a template or not, in C++0x
p28098
aVThat is, the following is perfectly legal for C++0x:
p28099
aVIn C++03,  could only be used inside of a template
p28100
aVAnd the explicit specialization in your code is not a template
p28101
aVThere are no  clauses (all parameters in your code are fixed)
p28102
as(dp28103
g15
V34509
p28104
stp28105
a((dp28106
g2
(lp28107
VHope it helps
p28108
as(dp28109
g15
V34509
p28110
stp28111
a((dp28112
g2
(lp28113
VPlease don't do that in a project I'm managing
p28114
aVThat's an awkward abuse of lambdas in my opinion
p28115
aVUse a  where a  is useful
p28116
as(dp28117
g15
V34509
p28118
stp28119
a((dp28120
g2
(lp28121
VThis  is a positive number
p28122
aVSo you need to take
p28123
aVinto consideration
p28124
aVNegating it immediately afterwards doesn't make the operand of the  operator itself negative
p28125
as(dp28126
g15
V34509
p28127
stp28128
a((dp28129
g2
(lp28130
Vincrements  by two and returns the value "in the middle"
p28131
aVWhy not  or
p28132
aVBoth seem to be clearer
p28133
aVFor scalars, both are well-defined also in C++03, as opposed to your proposed expression
p28134
aVis essentially equivalent to  but completely avoids having to call , which can be quite useful sometimes
p28135
aVThat's an arbitrary statement without any explanation
p28136
aVSo I'm going to throw into the pool:
p28137
aVis essentially equivalent to  but completely avoids having to call  and  which can be useful sometimes
p28138
aVSo why is the precedence not defined to have ++x++ automatically expand to (++x)++ rather than ++(x++)
p28139
aVJust to make such arcane corner cases not error out
p28140
aVNo way
p28141
aVCan you please recite  for me
p28142
aVIf you cannot do that, better not try and write  in your code
p28143
as(dp28144
g15
V34509
p28145
stp28146
a((dp28147
g2
(lp28148
VSee the spec, in the compatibility appendix C
p28149
ag2790
aV6:
p28150
ag3311
ag2790
aV6 [see also 3
p28151
aV5]
p28152
aVChange: const objects must be initialized in C++ but can be left uninitialized in C
p28153
aVRationale: A const object cannot be assigned to so it must be initialized to hold a useful value
p28154
aVEffect on original feature: Deletion of semantically well-defined feature
p28155
aVDifficulty of converting: Semantic transformation
p28156
aVHow widely used: Seldom
p28157
as(dp28158
g15
V34509
p28159
stp28160
a((dp28161
g2
(lp28162
VFirst we should clarify: What do you mean by "temporary"
p28163
aVMany people mean different things when they say temporary
p28164
aVTechnically,  is not a temporary, but most people will include them into their own meaning of that term
p28165
aVTechnically, given , then  isn't a temporary either, but you may want to treat it as one with your macro
p28166
aVThe first kind of "temporaries" I mentioned above are really "prvalue expressions"
p28167
aVThose are the  or  kind of things, but not the  and also (for sure) not the  kind of things
p28168
aVThe  operator yields a non-reference type for the first kind of "temporaries" I talked about above
p28169
aVFor the second kind, , which are xvalues, it will yield an rvalue reference
p28170
aVAnd for the "non-temporaries", i
p28171
aVe the  cases, it will yield an lvalue reference
p28172
aVSo to summarize, I will define three precise macros, and you can choose from them
p28173
as(dp28174
g15
V34509
p28175
stp28176
a((dp28177
g2
(lp28178
VThis is a very often found problem, and there is a surprisingly simple solution
p28179
aVI will show it in an artificial example, because it's more clearer than to use your code, and you will have to understand it to adapt it to your code
p28180
aVExplicitly specializing functions is never (almost never
p28181
aVthe right way
p28182
aVIn my work as a programmer, I've never explicitly specialized a function template
p28183
aVOverloading and partial ordering is superior
p28184
as(dp28185
g15
V34509
p28186
stp28187
a((dp28188
g2
(lp28189
VThe code will conceptionally read like a nice specification
p28190
aVFirst define the interface the main entry point uses
p28191
aVThen define the main entry point
p28192
aVThen the behavior of the program in the ideal case is conceptually fully specified
p28193
aVLast, implement the interface (definitions after )
p28194
aVThat he omits declarations of the functions to be put before  (to satisfy first bullet - defining the interface) is considered bad style by many programmers regarding modern C
p28195
aVThe code however uses old-style function definitions, for which their declarations don't define parameter types to the caller
p28196
aVPresumably, updating this code to be modern C would break a lot of very old systems that still use pre-ANSI compilers
p28197
as(dp28198
g15
V34509
p28199
stp28200
a((dp28201
g2
(lp28202
VCommon problem
p28203
aVYou probably have a  line in your "board
p28204
aVH" file or in a file included by "board
p28205
aVH"
p28206
aVSo when you include "bear
p28207
aVH" into "board
p28208
aVH", the "bear
p28209
aVH" file is processed and tries to include "board
p28210
aVH", but that file is already being processed so the header guard of "bear
p28211
aVH" won't include the content another time
p28212
aVBut then "bear
p28213
aVH" is processed without a leading "Board" class definition
p28214
as(dp28215
g15
V34509
p28216
stp28217
a((dp28218
g2
(lp28219
VIn C and C++ you have these least requirements (i
p28220
aVe actual implementations can have larger magnitudes)
p28221
aVNow, on particular implementations, you have a variety of bit ranges
p28222
aVThe wikipedia article describes this nicely
p28223
as(dp28224
g15
V34509
p28225
stp28226
a((dp28227
g2
(lp28228
VFor your , you can use both conversion functions
p28229
aVYou can make the compiler prefer one over the other by making one non-const
p28230
aVNow for , the  is taken
p28231
aVThis way will also fix the call to  to get a non-const reference
p28232
aVYou can also return a const reference from the other
p28233
aVThis way will still prefer the second conversion function for , but if your object  is const and you initialize a const reference, you won't always require to copy
p28234
as(dp28235
g15
V34509
p28236
stp28237
a((dp28238
g2
(lp28239
VNo, it refers to:
p28240
aVIf  is a class template like the following
p28241
as(dp28242
g15
V34509
p28243
stp28244
a((dp28245
g2
(lp28246
VOne prominent case are enumerators
p28247
aVThe expressions  and  are rvalues (more specifically, prvalues in C++0x)
p28248
aVAnother are template non-type parameters
p28249
aVThe expression  is an rvalue too (more specifically again, a prvalue in C++0x)
p28250
as(dp28251
g15
V34509
p28252
stp28253
a((dp28254
g2
(lp28255
VYour lambda catches  implicitly
p28256
aVA lambda that catches things cannot implicitly convert to a raw function pointer
p28257
aVSo you need to write  so it accepts the lambda function object directly, instead of letting it convert to a function pointer
p28258
aVAlternatively, if you don't want to write this as a template, you can use a polymorphic function object wrapper
p28259
aVI would also consider changing the callback's interface so it accepts the string by const reference (unless all the callback implementations inherently want to modify or save/move the passed string internally, which seem unlikely in your case)
p28260
as(dp28261
g15
V34509
p28262
stp28263
a((dp28264
g2
(lp28265
VYou can fix it my introducing a move constructor
p28266
aVAnd then you can rewrite your toy
p28267
aVHope it helps
p28268
aVNo "const reference" trick is needed when you work with
p28269
aVSee here for how to do it in C++03 with const references
p28270
as(dp28271
g15
V34509
p28272
stp28273
a((dp28274
g2
(lp28275
VNo you cannot
p28276
aVThe type cannot be expressed, since it would repeat itself:
p28277
aVBut you can write a function which accepts itself, without any problems
p28278
aVConsider
p28279
aVThat's perfectly fine
p28280
aVThe parameter type of  is a function pointer ( is equivalent to  here) whose type is compatible with the type of
p28281
aVThe rule for compatibility for the function types of both the parameter of  and the argument in the call,  and  is specified as:
p28282
aVIf one type has a parameter type list [the call argument] and the other type is specified by a function declarator that is not part of a function definition and that contains an empty identifer list [the function parameter type], the parameter list shall not have an ellipsis terminator and the type of each parameter shall be compatible with the type that results from the application of the default argument promotions
p28283
aVBoth types satisfy this compatibility rule, so the function call is well defined
p28284
as(dp28285
g15
V34509
p28286
stp28287
a((dp28288
g2
(lp28289
VDefine your own constructor that value initializes the array, setting all of its elements to null pointers
p28290
aVThat's done by providing  initializer for the member, which also works for arrays
p28291
as(dp28292
g15
V34509
p28293
stp28294
a((dp28295
g2
(lp28296
VIn short,  is a typedef for a reference to the type
p28297
aVThat means, whenever you use , you denote the type "reference to Rep"
p28298
aVIn my opinion, this is a weird C++ course material
p28299
aVFrom what the interface looks like, we can suppose the implementation will be something like
p28300
aVNow, if you do the following, you violate the principle of least surprise for most C++ programmers
p28301
aVThe "principle of least surprise" says that this shall copy the stack
p28302
aVBut actually,  stands for the type , which is a "reference to Rep"
p28303
aVThis means that the second line creates an alias to  (reference to what  refers to)
p28304
aVIt doesn't copy, but just creates another reference
p28305
aVI recommend you: Stay clear of such code
p28306
aVIf you want to hide the implementation or layout of , then implement the Pimpl idiom
p28307
as(dp28308
g15
V34509
p28309
stp28310
a((dp28311
g2
(lp28312
VThis is wrong, because  is a non-dependent name
p28313
aVSo for the case there is no , your template is ill-formed, and the compiler is at right to reject it at template definition time
p28314
aVSFINAE applies when a dependent name turns out to be not declared
p28315
as(dp28316
g15
V34509
p28317
stp28318
a((dp28319
g2
(lp28320
VThe text of the FDIS says
p28321
aVSimilarly, the first non-nested >> is treated as two consecutive but distinct > tokens
p28322
aVIt cannot unlex tokens and relex
p28323
aVSo this will be a
p28324
aVNote that the input to a C++ implementation is first lexed into preprocessing tokens, and then those tokens are converted into C++ tokens
p28325
aVSo first your input are the C++ tokens , then the C++ parser changes these to
p28326
aVEach preprocessing token is converted into a token
p28327
aV(2
p28328
aV7)
p28329
aVThe resulting tokens are syntactically and semantically analyzed and translated as a translation unit
p28330
aV[ Note: The process of analyzing and translating the tokens may occasionally result in one token being replaced by a sequence of other tokens (14
p28331
aV2)
p28332
aV\u2014 end note ]
p28333
aVThere's no chance you could merge those two trailing  tokens
p28334
as(dp28335
g15
V34509
p28336
stp28337
a((dp28338
g2
(lp28339
VIf  is a , doing  is ill-formed
p28340
aVSo you only need to figure out whether it is a pointer or a non-pointer
p28341
aVYou can use overloading for this
p28342
aVThis has the drawback that it only works with zero-parameter member function pointers, and it won't return the value (if any) that those functions return
p28343
aVYou cannot do the following (which can easily be implemented), because both branches will be type-checked
p28344
aVWhat you can do is to just call a function to dereference your object, if it is a pointer
p28345
aVThen you can say
p28346
as(dp28347
g15
V34509
p28348
stp28349
a((dp28350
g2
(lp28351
V@HighCommander4 explained what is wrong here
p28352
aVAn alternative solution is to disable deduction for the second parameter of
p28353
aVThe type of the second parameter is then deduced solely based on the first argument of the -operator:
p28354
aVIf you do it like this, there is no contradiction as to what type  is supposed to stand for, and the  will work as expected
p28355
as(dp28356
g15
V34509
p28357
stp28358
a((dp28359
g2
(lp28360
VGoal: [stripped the description of the again wrong approach]
p28361
aVSo this mytuple can be created without and moves and copies, nor unnecessary references to temporaries which could have been created in place using aggregate construction
p28362
aVYou made your requirements more precise in a comment
p28363
aVPassing by my parameter pack ideally should be as close to as fast as ordinary argument passing as possible
p28364
aVI imagine these parameter packs could get reasonably large
p28365
aVYou've been on the complete wrong path
p28366
aVThe following is not a macro, creates no moves or copies (not more than a macro) and has no unnecessary references to temporaries (not sure what the last part of your requirements means, but I think we can clarify that iteratively)
p28367
aVIt's as fast as "ordinary argument passing", since it's doing nothing else
p28368
aVThis has different behavior than the sequence of  expressions you give, with regard to argument type
p28369
aVPrvalues are forwarded to the tuple as as
p28370
aVXvalues are forwarded to the tuple as
p28371
aVLvalues are forwarded to the tuple as
p28372
aVYour macro behaves different
p28373
aVPrvalues are forwarded to the tuple as as
p28374
aVXvalues are forwarded to the tuple as
p28375
aVLvalues are forwarded to the tuple as
p28376
aVNote the middle part - you are prone to dangling references, unless the lifetime of your tuple is always less than the lifetime of all the arguments, but then storing prvalues as  creates an unnecessary copy
p28377
aVUse  in my code for always using references, as follows
p28378
aVPrvalues are forwarded to the tuple as as
p28379
aVXvalues are forwarded to the tuple as
p28380
aVLvalues are forwarded to the tuple as
p28381
as(dp28382
g15
V34509
p28383
stp28384
a((dp28385
g2
(lp28386
VActually, that is not valid
p28387
aVThe C++0x FDIS says (9
p28388
aV2p1)
p28389
aVExcept when used to declare friends (11
p28390
aV3) or to introduce the name of a member of a base class into a derived class (7
p28391
ag1037
aV3), member-declarations declare members of the class, and each such member-declaration shall declare at least one member name of the class
p28392
aVIn your case, no enumerator name is introduced into the class' scope and no enumeration name is introduced either
p28393
aVSo, no member name at all is introduced by that member-declaration
p28394
aVEDIT: And actually, there's a more direct prohibition of the enumeration declaration
p28395
ag3311
aV2p2:
p28396
aVThe optional identifier shall not be omitted in the declaration of a scoped enumeration
p28397
as(dp28398
g15
V34509
p28399
stp28400
a((dp28401
g2
(lp28402
VYou can do
p28403
aVThis will give the function 's type C linkage which in practice means that it uses the C calling convention on your platform
p28404
aVThe function's name will still have C++/internal linkage, because a language linkage specification only applies to function names of external linkage
p28405
aVIf you specify the  directly on the declaration, the Standard specifies that the  is taken to be also a storage class specifier, so if you would add , then you would get a conflict
p28406
aVDoes it matter when passing a function pointer to C
p28407
aVIt can theoretically matter - an implementation is allowed to differ in behavior from calling a function whose type has C++ linkage to calling a function whose type has C linkage
p28408
aVI don't know of implementation details though, just what the spec says about it
p28409
aVBest to follow the spec and you are safe
p28410
as(dp28411
g15
V34509
p28412
stp28413
a((dp28414
g2
(lp28415
VIt was deemed useful that , when reading into a  terminates at whitespace
p28416
aVBut it wasn't deemed useful that only the first word is printed when you print a string
p28417
aVAfter all you said print "something here" to cout In the other case, you just said read something from
p28418
aVThe choice between a word, between a line and between the whole content of stdin (until an EOF is received) is arbitrary and the design happens to be to read a word
p28419
aVThat makes it easy to quickly read a record line like "john 10 2
p28420
aV15" (first read into string, then into an int, and then into a float)
p28421
aVUse  to read a whole line into a
p28422
as(dp28423
g15
V34509
p28424
stp28425
a((dp28426
g2
(lp28427
VYou cannot do that, except by writing the specialization for all , except when  is
p28428
aVOtherwise, you will derive the class from itself, which for obvious reasons can't work
p28429
aVInstantiating the primary class template for arguments that have an explicit or partial specialization is not possible
p28430
aVIf you try to, by provoking an instantiation before the explicit or partial specialization is visible (note that your code did not provoke such an instantiation), your program is ill-formed, with no diagnostic being required (which effectively renders the behavior undefined)
p28431
aVTo achieve the above work-around, you can use SFINAE
p28432
as(dp28433
g15
V34509
p28434
stp28435
a((dp28436
g2
(lp28437
VWhat @David has been saying, but wasn't apparently understood by some
p28438
aVSo I believe an example is in order:
p28439
aVWill cause an error, because in a template, dependent base classes are not looked into by unqualified lookup
p28440
aVThis is an important concept in C++
p28441
aVIf there is a global  visible, then that  will be used by  - a member declared in a dependent base class will never hide that global
p28442
aVFor telling the compiler to look into dependent base classes, you have to qualify your name
p28443
aVSo  works fine, as does
p28444
aVIf you put a , you tell the compiler to declare a member name  in the scope of
p28445
aVThen  will find the  directly in
p28446
aVThat is an acceptable fix too
p28447
as(dp28448
g15
V34509
p28449
stp28450
a((dp28451
g2
(lp28452
Vedit2: but what happens to constructor template arguments that are not part of the constructor arguments itself
p28453
aVThen you can pass-in an argument that has it encoded
p28454
as(dp28455
g15
V34509
p28456
stp28457
a((dp28458
g2
(lp28459
V produces better messages: http://ideone
p28460
aVcom/BR0GJ
p28461
as(dp28462
g15
V34509
p28463
stp28464
a((dp28465
g2
(lp28466
VI do believe that this is intuitive to some degree (what others already said - the value is needed, so there is an obvious need to convert the object designator to the value contained therein)
p28467
aVThe best I could come up with, by 4p3:
p28468
aVAn expression e can be implicitly converted to a type T if and only if the declaration "T t=e;" is well-formed, for some invented temporary variable t (8
p28469
aV5)
p28470
aVThe effect of the implicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion
p28471
aVThe result is an lvalue if T is a reference type (8
p28472
ag1037
aV2), and an rvalue otherwise
p28473
aVThe expression e is used as an lvalue if and only if the initialization uses it as an lvalue
p28474
aVNote the "if and only if" at the end - the initializer therefor is used as an rvalue, because the initialization uses it as an rvalue (result of the conversion)
p28475
aVSo by 3
p28476
aV10p7
p28477
aVWhenever an lvalue appears in a context where an rvalue is expected, the lvalue is converted to an rvalue; see 4
p28478
aV1, 4
p28479
aV2, and 4
p28480
ag1037
aVEDIT: The paragraph for entering 4p3 can be found at 8
p28481
aV5p16, last bullet:
p28482
aVOtherwise, the initial value of the object being initialized is the (possibly converted) value of the initializer expression
p28483
aVAlso note the comments below
p28484
as(dp28485
g15
V34509
p28486
stp28487
a((dp28488
g2
(lp28489
VThat line is not allowed by C++
p28490
aVThe spec says (8
p28491
aV5p9):
p28492
aVIf no initializer is specified for an object, and the object is of (possibly cv-qualified) non-POD class type (or
p28493
aVarray thereof), the object shall be default-initialized; if the object is of const-qualified type, the underlying
p28494
aVclass type shall have a user-declared default constructor
p28495
aV(emphasize mine)
p28496
aVC++0x (FDIS) wording (8
p28497
aV5p6 and 8
p28498
aV5p11):
p28499
aVIf no initializer is specified for an object, the object is default-initialized;
p28500
aVIf a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor
p28501
as(dp28502
g15
V34509
p28503
stp28504
a((dp28505
g2
(lp28506
VIf you want to make it solid, use clang's libraries
p28507
as(dp28508
g15
V34509
p28509
stp28510
a((dp28511
g2
(lp28512
V stops reading before the first whitespace
p28513
aVYou want  here
p28514
as(dp28515
g15
V34509
p28516
stp28517
a((dp28518
g2
(lp28519
VI strive to do the least number of explicit casts possible, and everything else implicit, if possible
p28520
aVSo I would use the former (i
p28521
aVe not including  in the cast)
p28522
aVBut this is only my opinion
p28523
aVYou may be of the opinion to write the  there too, as it fits your taste
p28524
as(dp28525
g15
V34509
p28526
stp28527
a((dp28528
g2
(lp28529
VWith this, you don't have to allocate the memory elsewhere and make the pointer point to that
p28530
aVNo extra memory management
p28531
aVAccesses to the memory will hit the memory cache (much) more likely
p28532
aVThe trick is to allocate more memory than , and make a  point to it
p28533
aVThen the initial memory will be used by your  object, and the remaining memory can be used by the
p28534
aVThat is, you can say  but also  and so on up until you hit the end of memory you allocated
p28535
aVPoints can be made that this use results in undefined behavior though, because you declared your array to only have one element, but access it as if it contained more
p28536
aVBut real compilers do allow this with the expected meaning because C++ has no alternative syntax to formulate these means (C99 has, it's called "flexible array member" there)
p28537
as(dp28538
g15
V34509
p28539
stp28540
a((dp28541
g2
(lp28542
VI'm sorry you are out of luck
p28543
aVUnless you use a preprocessor metaprogramming library (boost
p28544
aVpp), there is no way to automate that
p28545
aVNot with template metaprogramming
p28546
aVWhat you have produced there are implicit instantiations of
p28547
aVBut implicit instantiations have two important differences to explicit instantiations
p28548
aVThey won't instantiate all member definitions (only those that are immediately needed are instantiated)
p28549
aVOther definitions are only instantiated when they are used
p28550
aVThe implicit instantiation of used member definitions cannot be used as a definition source for other translation units
p28551
aVFor the latter, since I'm not aware of the reason for that, I will just quote the spec
p28552
aVA non-exported template must be defined in every translation unit in which it is implicitly instantiated (14
p28553
ag3311
aV1), unless the corresponding specialization is explicitly instantiated (14
p28554
ag3311
aV2) in some translation unit; no diagnostic is required
p28555
aVThat may have to do with linker complications, because implicit instantiations for the same template can occur multiple times in multiple translation units, so they need special handling
p28556
aVExplicit instantiations and non-inline functions can't
p28557
as(dp28558
g15
V34509
p28559
stp28560
a((dp28561
g2
(lp28562
VThe FDIS has a section for incompatibilities, at appendix  "C++ and ISO C++ 2003"
p28563
aVSummary, paraphrasing the FDIS here, to make it (better) suitable as a SO answer
p28564
aVI added some examples of my own to illustrate the differences
p28565
aVThere are a few library-related incompatibilities where I don't exactly know the implications of, so I leave those for others to elaborate on
p28566
aVCore language
p28567
aVNew keywords: alignas, alignof, char16_t, char32_t, constexpr, decltype, noexcept, nullptr, static_assert, and thread_local
p28568
aVCertain integer literals larger than can be represented by long could change from an unsigned integer type to signed long long
p28569
aVValid C++ 2003 code that uses integer division rounds the result toward 0 or toward negative infinity, whereas C++0x always rounds the result toward 0
p28570
aV(admittedly not really a compatibility problem for most people)
p28571
aVValid C++ 2003 code that uses the keyword  as a storage class specifier may be invalid in C++0x
p28572
aVNarrowing conversions cause incompatibilities with C++03
p28573
aVFor example, the following code is valid in C++ 2003 but invalid in this International Standard because double to int is a narrowing conversion:
p28574
aVImplicitly-declared special member functions are de\ufb01ned as deleted when the implicit definition would have been ill-formed
p28575
aVA valid C++ 2003 program that uses one of these special member functions in a context where the definition is not required (e
p28576
ag774
aV, in an expresion that is not potentially evaluated) becomes ill-formed
p28577
aVExample by me:
p28578
aVSuch sizeof tricks have been used by some SFINAE, and needs to be changed now :)
p28579
aVUser-declared destructors have an implicit exception specification
p28580
aVExample by me:
p28581
aVThis code calls  in C++0x, but does not in C++03
p28582
aVBecause the implicit exception specification of  in C++0x is
p28583
aVA valid C++ 2003 declaration containing  is ill-formed in C++0x
p28584
aVA valid C++ 2003 expression containing  followed immediately by another  may now be treated as closing two templates
p28585
aVIn C++03,  would always be the shift-operator token
p28586
aVAllow dependent calls of functions with internal linkage
p28587
aVExample by me:
p28588
aVIn C++03, this calls , but in C++0x, this calls
p28589
aVIt should be noted that in both C++03 and C++0x, the following calls  (the instantiation context still only considers extern linkage declarations)
p28590
aVThe better matching  is not taken, because it does not have external linkage
p28591
aVLibrary changes
p28592
aVValid C++ 2003 code that uses any identifiers added to the C++ standard
p28593
aVlibrary of C++0x may fail to compile or produce different results in This International Standard
p28594
aVValid C++ 2003 code that  headers with names of new C++0x standard library headers may be invalid in this International Standard
p28595
aVValid C++ 2003 code that has been compiled expecting swap to be in  may have to instead include
p28596
aVThe global namespace  is now reserved for standardization
p28597
aVValid C++ 2003 code that defines , , , or  as macros is invalid in C++0x
p28598
as(dp28599
g15
V34509
p28600
stp28601
a((dp28602
g2
(lp28603
VConsider:
p28604
aVIt's also possible without introducing any member:
p28605
as(dp28606
g15
V34509
p28607
stp28608
a((dp28609
g2
(lp28610
VA couple of people mentioned very good points
p28611
aVI just want to note that while C has kept the meaning "declaration reflects use" very strongly, C++ didn't
p28612
aVSeveral declarators in C++ don't reflect the use in declarations;
p28613
aVI don't think that C++ programmers writing it different actually have that as their reason, but it may be something stopping C++ book writers from mentioning it, which may influence those C++ programmers
p28614
as(dp28615
g15
V34509
p28616
stp28617
a((dp28618
g2
(lp28619
VThey implement the C++0x specification, where  is the current instantiation
p28620
aVAnd C++0x allows to omit  keyword in such a case
p28621
aVSince  is a typedef for , when you say , that names the current instantiation too
p28622
aVTo quote the spec, since you seem to be interested in spec refs
p28623
aVA name is a member of the current instantiation if it is [
p28624
aVA qualified-id in which the nested-name-speci\ufb01er refers to the current instantiation and that, when looked up, refers to at least one member of the current instantiation or a non-dependent base class thereof
p28625
aVand
p28626
aVA name refers to the current instantiation if it is [
p28627
aVin the definition of a [
p28628
aVnested class of a class template, [
p28629
aV, the injected-class-name (Clause 9) of the class template or nested class
p28630
aVand (the modified 14
p28631
aV2/4 that you quoted)
p28632
ag7695
aVor the nested-name-specifier in the qualified-id refers to a dependent type, but the name is not a member of the current instantiation (14
p28633
ag488
ag976
aV1), the member template name must be prefixed by the keyword template
p28634
ag7695
aVNote: In C++03 your code is ill-formed because both  and  are dependent
p28635
aVThe spec says:
p28636
aVA type is dependent if it is [
p28637
aVa template parameter
p28638
aVa qualified-id with a nested-name-specifier which contains a class-name that names a dependent type
p28639
aVa template-id in which either the template name is a template parameter or any of the template arguments is a dependent type
p28640
aV(note that  is equivalent to , which is the base on which  and  are dependent types)
p28641
aVNote that "explicitly depends" in your quote is a pre-standard term, and was gotten rid of fairly lately (I believe it was at December1996)
p28642
aVIt basically meant (in this context) a qualified-id in which the qualifier is dependent or a class member access ( / ) where the  was dependent
p28643
aVAfter "explicitly depends" was removed from the draft, it was still lurking around at some places, and even C++0x has still references to "explicitly depends" in a note at 14
p28644
ag488
aV2p2:
p28645
aVthe base class name , the type name , the names  and  explicitly depend on the template-parameter
p28646
as(dp28647
g15
V34509
p28648
stp28649
a((dp28650
g2
(lp28651
VIf you have a declared non-volatile  variable, there is no legal way for it to be modified externally
p28652
aVWriting to a  variable is undefined behavior
p28653
aVAnd declaring a  in another translation unit will declare a different variable than what you declared, because yours has internal linkage, which means it can only be redeclared in the same translation unit
p28654
aVAnd even if it were to declare the same variable, then behavior would be undefined (because of a  /  mismatch in type identity)
p28655
as(dp28656
g15
V34509
p28657
stp28658
a((dp28659
g2
(lp28660
VI've manually specified which classes will be used in the source file, but it's really obnoxious:
p28661
aVThis is not legal (I assume you meant to declare dummy variables here, and missed their name)
p28662
aVWe will see below why
p28663
aVIs there anything standard that has been mandated, and/or does g++ support anything like this
p28664
aVC++03 had something called , but which turned out to be a misfeature
p28665
aVThe EDG implemented that feature, and their experience with it indicated that it's not worth the trouble implementing it
p28666
aVAnd it doesn't provide a useful feature separate compilation usually gives you: Hiding of the code of templates which you once compiled
p28667
aVstill requires the code of templates, be it in raw form or encoded into a mid-level compiler-specific language
p28668
aVSee Why we can't afford export
p28669
aVA short example is given by EDG worker David Vandevoorde here
p28670
aVFor C++0x and for C++0x sans export, we have
p28671
aVA function template, member function of a class template, or static data member of a class template shall be de\ufb01ned in every translation unit in which it is implicitly instantiated (14
p28672
ag3311
aV1) unless the corresponding specialization is explicitly instantiated (14
p28673
ag3311
aV2) in some translation unit; no diagnostic is required
p28674
aVAs this indicates, the only way you can achieve separate compilation is to explicitly instantiate the template you want to have separately compiled
p28675
aVBy defining dummy variables, you merely implicitly instantiate the class template
p28676
aVAnd you do not instantiate the member functions of the class templates that way - you would need to do dummy calls or take their address
p28677
aVAnd to all this, you are not guaranteed that an implicitly instantiated function won't be discarded if it's not used in the translation unit it was instantiated by, after optimization, based on the above quote
p28678
aVSo you explicitly instantiate the class template, which will explicitly also instantiate its member functions the following way:
p28679
as(dp28680
g15
V34509
p28681
stp28682
a((dp28683
g2
(lp28684
VCore Language
p28685
aVAccessing an enumerator using :
p28686
aVYou can also abuse the new keywords
p28687
aVAlso, the fact that string literals do not anymore convert to
p28688
aVI don't know how likely you are to have this working on a real implementation though
p28689
aVOne that exploits
p28690
aVThe following is based on the fact that  is a conversion function to  in C++0x, and a conversion to  followed by logical-and in C++03
p28691
aVThat test-case doesn't work for C++0x in GCC (looks like a bug) and doesn't work in C++03 mode for clang
p28692
aVA clang PR has been filed
p28693
aVThe modified treatment of injected class names of templates in C++11:
p28694
aVA couple of "detect whether this is C++03 or C++0x" can be used to demonstrate breaking changes
p28695
aVThe following is a tweaked testcase, which initially was used to demonstrate such a change, but now is used to test for C++0x or C++03
p28696
aVStandard Library
p28697
aVDetecting the lack of  in C++0x'
p28698
as(dp28699
g15
V34509
p28700
stp28701
a((dp28702
g2
(lp28703
VThat's exactly right
p28704
aVI would expect it to work
p28705
aVSo I think that GCC is in error with rejecting that
p28706
aVFWIW:
p28707
as(dp28708
g15
V34509
p28709
stp28710
a((dp28711
g2
(lp28712
VJust write it like normal
p28713
aVDefining the generic version out of class doesn't help you with providing special versions of it though, or I do miss the goal of yours here
p28714
as(dp28715
g15
V34509
p28716
stp28717
a((dp28718
g2
(lp28719
VYou want to determine whether it is a non-union class
p28720
aVThere is no way known to me to do that (and boost hasn't found a way either)
p28721
aVIf you can live with union cases false positives, you can use a
p28722
aVBoost has an  that uses compiler-specific builtins though, which will help you here
p28723
aV(which boost also provides) combined with  will solve your problem
p28724
as(dp28725
g15
V34509
p28726
stp28727
a((dp28728
g2
(lp28729
VBecause the implicitly declared copy assignment operator of  hides the implicitly declared copy assignment operator of
p28730
aVSo for the line , only the the  of  is a candidate
p28731
aVBut its parameter has type , which cannot be initialized by an  argument (you would need a downcast)
p28732
aVSo you get an error
p28733
as(dp28734
g15
V34509
p28735
stp28736
a((dp28737
g2
(lp28738
VA different technique is to provide an out of line class template which works like a hook
p28739
aVUsing a friend function definition is preferable though
p28740
aVBut it's good to know about alternatives
p28741
as(dp28742
g15
V34509
p28743
stp28744
a((dp28745
g2
(lp28746
VI would expect that the implicit conversion operator to foo declared in convertible_to_foo would hide, i
p28747
ag1992
aVoverload,
p28748
aVThis mixes up the terms
p28749
aVTo hide means that when you look into the derived class, you only see the derived's conversion function and not the base
p28750
aVTo overload means that you would see both functions
p28751
aVThe function in the derived will hide the function in the base if the derived's function has the same name as the base's function
p28752
aVThe rule for a conversion function names is: Two of them are the same if they convert to the same type
p28753
aVSo, if in the base you have , and in the derived class too, then the derived's function will hide the base's one
p28754
aVIf the derived's one would be , then you have no hiding
p28755
aVYou also have no overloading, but if you lookup in the derived class for a conversion function , then you find the base class's one, because it is not hidden by a derived's function with the same name
p28756
aVFor templates, it works the same
p28757
aVIn this case, if you try to convert  to an , you get an ambiguity, because both functions will be taken and both functions will end up to convert to  after template argument deduction is done ( is a different type than  - the first is a template parameter in the first position, while the second is a template parameter in the second position
p28758
aVSo no hiding will take place)
p28759
aVIn your case, it's similar but I don't agree with GCC's behavior
p28760
aVInstantiating  will instantiate the member declarations of that template, and one member will happen to be
p28761
aVThe conversion function in the derived class converts to exactly the same type, so I don't think that GCC should yield an ambiguity here
p28762
as(dp28763
g15
V34509
p28764
stp28765
a((dp28766
g2
(lp28767
VIn a nutshell: You use  and  if you know what member you want to access
p28768
aVAnd you use  and  if you don't know what member you want to access
p28769
aVExample with a simple intrusive list
p28770
as(dp28771
g15
V34509
p28772
stp28773
a((dp28774
g2
(lp28775
VBehavior is undefined because the Standard does not define what happens with a program that exceeds resource limits
p28776
aVNote that there are recommended limits in Annex B of the spec
p28777
aVThat annex is non-normative though and an implementation can ignore that annex, including having different limits than specified there
p28778
aVIn 1
p28779
aV4 [intro
p28780
aVcompliance], the spec says
p28781
aVIf a program contains no violations of the rules in this International Standard, a conforming implementation shall, within its resource limits, accept and correctly execute that program
p28782
aVThere is nothing that says what shall happen with a program that contains no violation of the rules in the IS but that can't be accepted and correctly executed within the resource limits of the implementation
p28783
aVHence behavior is undefined for such a case
p28784
as(dp28785
g15
V34509
p28786
stp28787
a((dp28788
g2
(lp28789
VThat doesn't make sense to me
p28790
aVA function template is not "implicit inline"
p28791
aVYou have to explicitly declare it "inline" to make it inline
p28792
aVThat doesn't mean that calls to it are or aren't inlined
p28793
aVThat's entirely the compiler's decision
p28794
aVAs a template can be defined in multiple translation units (provided each definition gives the template the same behavior), putting  on such a template doesn't have much effects, from what I can see
p28795
aVThe only effect is to tell the optimizer that you wish that calls to the function template should be inlined, from what I can see
p28796
aVMaking a function template  is entirely sensible
p28797
aVThis makes it so you can have the template defined in multiple translation units, with each definition having a different behavior
p28798
aVBecause of the  the templates will have internal linkage which means they are local to their translation unit and won't clash
p28799
aVPutting  on functions and function template is entirely independent of putting  on them, though
p28800
aVand  aren't dependent in C++ like they are in C99
p28801
as(dp28802
g15
V34509
p28803
stp28804
a((dp28805
g2
(lp28806
VThe function call operator of the type that  returns is
p28807
aVThis won't work with reference parameters of the bound function object and a very strict C++03 compiler (more recent releases are more lax)
p28808
aVC++03 forbids references to references
p28809
as(dp28810
g15
V34509
p28811
stp28812
a((dp28813
g2
(lp28814
VIt is valid in C++11, but it was a very late addition to the working paper that Bjarne put through
p28815
aVSo it's not surprising that GCC doesn't support brace default arguments yet
p28816
as(dp28817
g15
V34509
p28818
stp28819
a((dp28820
g2
(lp28821
VThe conversion is the conversion of a language value to a lexical representation of that value
p28822
aVYour theory is wrong; behavior is undefined
p28823
aVThe spec says (7
p28824
aV19
p28825
ag488
aV1p8 and 9, using C99 TC2):
p28826
aVThe int argument is converted to signed decimal in the style [\u2212]dddd
p28827
aVAnd
p28828
aVIf any argument is not the correct type for the corresponding conversion speci\ufb01cation, the behavior is undefined
p28829
as(dp28830
g15
V34509
p28831
stp28832
a((dp28833
g2
(lp28834
VWhat the Standard means by "specialization" is the transformation of a generic template to a more specialized entity
p28835
aVFor example, instantiating a non-member class template yields a class that's not a template anymore
p28836
aVThe term "specialization" is two fold, and can refer to a generated specialization (which is a specialization that was instantiated, possibly from a partial specialization) and to an explicit specialization (which is what you referred to)
p28837
aVAlias templates aren't instantiated and there aren't specializations of them
p28838
aVThere is nothing they could instantiate to
p28839
aVInstead, whenever their name is followed by a template argument list, the type denoted is the type you get by replacing the name and argument list by the alias'ed type, replacing all template parameter references with the arguments given in the argument list
p28840
aVThat is, rather than the specialization of it being an alias, the alias template itself serves as an alias, without the need to instantiate anything
p28841
aVThis replacement is done very early
p28842
aVConsider:
p28843
aVThe replacement is done at the time  is named (such a names are used to refer to class or function template specializations; hence the spec describes such names to "refer to the specialization of an alias template")
p28844
aVThat is, the parameter of  has type , and thus,  can be deduced
p28845
aVThis property is preventing explicit or partial specializations of alias templates
p28846
aVBecause in order to pick the correct specialization of , it needs to know
p28847
aVBut to know it, it needs to compare  against the argument type to deduce
p28848
aVIt's summarized in the paper N1406, "Proposed addition to C++: Typedef Templates", section 2
p28849
ag976
ag976
aV2 The Main Choice: Specialization vs
p28850
aVEverything Else
p28851
aVAfter discussion on the reflectors and in the Evolution WG, it turns out that we have to choose between two mutually exclusive models:
p28852
aVA typedef template is not itself an alias; only the (possibly-specialized) instantiations of the typedef template are aliases
p28853
aVThis choice allows us to have specialization of typedef templates
p28854
aVA typedef template is itself an alias; it cannot be specialized
p28855
aVThis choice would allow:
p28856
aVdeduction on typedef template function parameters (see 2
p28857
aV4)
p28858
aVa declaration expressed using typedef templates be the same as the declaration without
p28859
aVtypedef templates (see 2
p28860
aV5)
p28861
aVtypedef templates to match template template parameters (see 2
p28862
aV6)
p28863
aVIt should be noted that the quoted paper, which favors option 1, did not make it into C++0x
p28864
aVEDIT: Because you desperately want to have a spec quote saying so explicitly
p28865
aV14
p28866
aV5p3 is one that does
p28867
aVBecause an alias-declaration cannot declare a template-id, it is not possible to partially or explicitly specialize an alias template
p28868
as(dp28869
g15
V34509
p28870
stp28871
a((dp28872
g2
(lp28873
VUse overloading instead of explicit specialization when you want to refine the behavior for a more specific parameter type
p28874
aVIt's easier to use (less surprises) and more powerful
p28875
aVAn example that uses SFINAE () as you seem to be curious
p28876
aVWay more ugly of course
p28877
aVThere's no reason to use  here, I think
p28878
aVIt's overkill
p28879
as(dp28880
g15
V34509
p28881
stp28882
a((dp28883
g2
(lp28884
VThis would work
p28885
aVI suspect with "elegant" you mean "without introducing a new variable"
p28886
aVBut I think I would just do it "non-elegant" if I couldn't find anything else
p28887
aVIt's still clear
p28888
aVImagine 100
p28889
aV000 entries in the vector
p28890
aVIf that is all you have to offer, I'd rather remove the last comma after I have gone thorough the loop
p28891
aVYou are saying that as if printing  is one machine instruction
p28892
aVCome on, executing that expression will execute lots of 's and loops inside
p28893
aVYour  will be nothing compared to that
p28894
as(dp28895
g15
V34509
p28896
stp28897
a((dp28898
g2
(lp28899
VYou have an infinitely large tree, as it looks like both your  and  pointers always point to another
p28900
aVWhat else do you expect from copying such a large tree than always descending into another subtree
p28901
aVYou want to have a stop condition, like
p28902
as(dp28903
g15
V34509
p28904
stp28905
a((dp28906
g2
(lp28907
VSometimes you want it to be
p28908
aVConsider
p28909
aVIn C++03 this successfully parses and creates an array of size
p28910
as(dp28911
g15
V34509
p28912
stp28913
a((dp28914
g2
(lp28915
VGCC internally links against a few additional libraries and object files
p28916
aVTo see what those are, execute , which will print the tool commands it would execute, including the linker
p28917
aVThe linker command used by my GCC is (I made the actual  file I invoked  on bold, so you can spot it easily)
p28918
aV/usr/lib/gcc/i686-pc-linux-gnu/4
p28919
ag488
aV0/collect2 --build-id --eh-frame-hdr -m elf_i386 "--hash-style=both" -dynamic-linker /lib/ld-linux
p28920
aVso
p28921
aV2 /usr/lib/gcc/i686-pc-linux-gnu/4
p28922
ag488
aV0/
p28923
aV/
p28924
ag28924
aV/crt1
p28925
aVo /usr/lib/gcc/i686-pc-linux-gnu/4
p28926
ag488
aV0/
p28927
ag28924
ag28924
aV/crti
p28928
aVo /usr/lib/gcc/i686-pc-linux-gnu/4
p28929
ag488
aV0/crtbegin
p28930
aVo -L/usr/lib/gcc/i686-pc-linux-gnu/4
p28931
ag488
aV0 -L/usr/lib/gcc/i686-pc-linux-gnu/4
p28932
ag488
aV0/
p28933
ag28924
ag28924
aVmain1
p28934
aVo "-lstdc++" -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/i686-pc-linux-gnu/4
p28935
ag488
aV0/crtend
p28936
aVo /usr/lib/gcc/i686-pc-linux-gnu/4
p28937
ag488
aV0/
p28938
ag28924
ag28924
aV/crtn
p28939
aVo
p28940
aVYou can substitute the  path by  (if I remember correctly,  is only needed as a proxy for the real  by GCC backends that don't support modern binary formats, to collect constructor and destructor functions according to their mangled name
p28941
aVThe ELF format has native sections support for that)
p28942
aVExecuting that command, with  substituted literally, successfully links the executable
p28943
as(dp28944
g15
V34509
p28945
stp28946
a((dp28947
g2
(lp28948
VYour analysis is correct - an explicitly specialized function template that has any template parameters specified with explicit values provides a complete definition of a function
p28949
aVIf you have properly included the corresponding  file that contains the explicit specialization's definition into your project, then VC++ should not raise a linker error
p28950
aVFor Standards compliance though, let me note that you have to declare your specialization outside of the enclosing class
p28951
aVThe Standard forbids to declare explicit specializations inside of the enclosing class (and other compilers will reject your code)
p28952
aVSo change the header file to declare the specialization like this, instead
p28953
aVLet me also note that you can't call  inside of your class body
p28954
aVThat's because any such call would not yet see the explicit specialization declaration, and would hence try to instantiate the function from the template definition
p28955
aVThe Standard renders such code ill-formed, without a diagnostic being required
p28956
as(dp28957
g15
V34509
p28958
stp28959
a((dp28960
g2
(lp28961
V works exactly (but see below) as if you take the whole auto'ed variable type and use it as the type of a function template parameter type
p28962
aVAll  occurrences in the type are replaced by a template parameter
p28963
aVSo if you used  as the auto'ed variable type, the function template's parameter type becomes
p28964
aVNow let the variable initializer be the argument in a call
p28965
aVThe type of the function parameter you get will be the type of the auto'ed variable
p28966
aVFor example if you use  as the type like above, then  will become a function template with parameter type
p28967
aVIf the initializer is a  expression, then the variable ends up having type , because that will be the deduced parameter type for the call
p28968
aVSo, using  as the auto'ed variable type will use a function template with parameter type  behind the scenes
p28969
aVCalling  will end up with the parameter type
p28970
aVThis is not a reference to another object anymore, but a new  variable
p28971
aVThe above way to get the auto'ed type is true for the vast majority of cases, but C++0x has a special case for initializers of the form  (i
p28972
aVe with variable initializers that are braced lists)
p28973
aVIn your case you don't have such an initializer, so I have ignored that special case
p28974
aVThe reason why in one of your cases  instead of  is explained by other answers
p28975
aVTo get what you were looking for using , you can first get the declared type of the variable (using ), and then pass that as a type to  as in
p28976
as(dp28977
g15
V34509
p28978
stp28979
a((dp28980
g2
(lp28981
VFor addition, you can use my  implementation:
p28982
aVFor types  and , it will yield  for example
p28983
as(dp28984
g15
V34509
p28985
stp28986
a((dp28987
g2
(lp28988
VThere is no way to do this
p28989
aVImagine the amount of overloads
p28990
aVFor each of that, you would need a different template to accept them
p28991
aVYou cannot even use C++0x's variadic templates, because template parameter packs only work on one parameter form and type (for example,  only works for a parameter pack full of integers)
p28992
as(dp28993
g15
V34509
p28994
stp28995
a((dp28996
g2
(lp28997
V is not the built-in  operator
p28998
aVIt invokes a user defined operator function
p28999
aVSo take a deep breath and go on using this fun syntax
p29000
as(dp29001
g15
V34509
p29002
stp29003
a((dp29004
g2
(lp29005
VYou have the following competing user defined functions (candidates)
p29006
aVYou are invoking this with arguments:
p29007
aVFor the first argument, the first two candidates are better than the last
p29008
aVFor the second argument, the last candidate is better than the first two candidates
p29009
aVNo candidate has at least as good matches as all the others for all arguments, and better matches for some arguments
p29010
aVYou cannot figure out a clear winner for this situation
p29011
aVThis is what I like to call the "criss cross"
p29012
aVThere are builtin candidates too that are considered among user defined candidates
p29013
aVFrom all the builtin candidates,  would match best
p29014
aVBut that would require a user defined conversion for the first argument, which is worse than all the three other user defined operators for the first argument, so it cannot win either
p29015
as(dp29016
g15
V34509
p29017
stp29018
a((dp29019
g2
(lp29020
VAssuming a valid and non-conflicting , that looks like valid code
p29021
aVYou will find people tell you that in C++, you don't have to say  or  if nothing is hiding  (like a function called )
p29022
aVIn C you have to, because C has a different concept for looking up names
p29023
aVBut in C++, to refer to a struct, class, union or enum, you can just use
p29024
aVSo you can use  instead of
p29025
aVBut the different choice of naming the type should not make the compiler reject your code
p29026
as(dp29027
g15
V34509
p29028
stp29029
a((dp29030
g2
(lp29031
VThis seems to work fine
p29032
aVNote that his code is all in one line
p29033
aVPrefer code clarity
p29034
aVIf you can put a function's code into one line using language features, then use those features
p29035
as(dp29036
g15
V34509
p29037
stp29038
a((dp29039
g2
(lp29040
VGCC has the ability to optimize code based on the fact that it detects that two pointers that point to incompatible types point to the same memory location
p29041
aVUsing both pointers to access the value will give a warning about an aliasing violation then ("type punning")
p29042
aVSometimes, if you put a  cast in between the one cast operands, before casting to the other point type, will silence false positive warnings in cases where you can legally do such an overlapping access
p29043
as(dp29044
g15
V34509
p29045
stp29046
a((dp29047
g2
(lp29048
VYou are mistaken about the second comment
p29049
aVIn , the  is a name in a nested name specifier
p29050
aVWhat the Standard refers to with "base-specifier" is the following
p29051
aVYou are also not correct about this:
p29052
aV// nested name specifier, ignores the struct declaration 'S'
p29053
aV`
p29054
aVThat code calls the function not because  would be a nested-name-specifier (it isn't a nested-name-specifier
p29055
aV, but because function names hide class or enumeration names if both the function and the class/enumeration are declared in the same scope
p29056
aVFWIW, the following code would be equally valid for line 2 of your main
p29057
aVWhat's important is that  preceedes a , which makes lookup ignore the function
p29058
aVThat you put  before  has no effect in your case
p29059
as(dp29060
g15
V34509
p29061
stp29062
a((dp29063
g2
(lp29064
VWait
p29065
aVYou are not declare a friend template
p29066
aVYou declare a specialization of a template as friend
p29067
aVAs such, why would you want to put a  clause there
p29068
aVThe syntax to name specializations of function templates is by , and that is what you shall use according to the Standard in the friend declarations
p29069
aVIf you want to befriend the whole template and all specializations generated and explicitly specialized, you can still do that, and then you can use a template clause
p29070
as(dp29071
g15
V34509
p29072
stp29073
a((dp29074
g2
(lp29075
VYour program is not valid
p29076
aVC forbids implicitly removing a  like that, and in conformance to the spec GCC should give you at least a warning for that code
p29077
aVYou would need a cast to remove the
p29078
aVHaving consumed a warning for that, you can however rely on the program to work (although not anymore from a Standards point of view), because the pointer is pointing to a malloc'ed memory area
p29079
aVAnd you are allowed to write to that area
p29080
aVA  pointing to some memory doesn't mean that the memory is thereafter marked immutable
p29081
aVNote that the Standard doesn't require a compiler to reject any program
p29082
aVThe Standard merely requires compilers to sometimes emit a message to the user
p29083
aVWhether that's an error message or warning and how the message is emitted and whatever happens after that emission, isn't specified by the Standard at all
p29084
as(dp29085
g15
V34509
p29086
stp29087
a((dp29088
g2
(lp29089
VStrictly speaking, you couldn't refer to the specialization of a function template by simply giving a template argument list
p29090
aVYou always had to have a target type around (like, a function parameter type you pass to, or a cast type you cast to, or a variable type you assign to)
p29091
aVThat was the case even if the target type is completely free of template parameters, for example
p29092
aVThe committee added rules that were adopted into C++0x and by popular compilers in their C++03 mode that made it possible to omit a target type if you supply a complete template argument list supplying types for all template parameters, together with all default template arguments
p29093
as(dp29094
g15
V34509
p29095
stp29096
a((dp29097
g2
(lp29098
VYou want to declare those parameters
p29099
aVThe names you used in the formal parameter list have no meaning
p29100
aVYou also forgot to use  actually
p29101
aVBut I'm assuming that was accidental
p29102
aVAs another poster said, you also need the  keyword because the names are dependent names
p29103
aVFor why the names in the formal list are meaningless, compare it to function pointers:
p29104
aVWhat is important is only the type of the parameters, and I could have written  too
p29105
aVIn your case, what is important is only that both parameters are type parameters
p29106
aVSo you could have written the template template parameter also as  too, completely equivalent
p29107
aVLast but not least, I would like to emphasize that you have not specialized , but you have overloaded it with another template
p29108
aVSo, both s are two completely different function templates
p29109
as(dp29110
g15
V34509
p29111
stp29112
a((dp29113
g2
(lp29114
VTwo things:
p29115
aVYes, GCC is wrong to reject
p29116
aVIt's possible that it hasn't been implemented yet
p29117
aVWhat you declared by  is equivalent to
p29118
aVIn C++ (not in C), you can leave off the comma before the C-style variadic ellipsis
p29119
aVSo instead of doing  you can declare
p29120
aVThat's what happens in your lambda
p29121
aVThe first ellipsis is the parameter pack unpacking, and the second ellipsis is the C-style variadic ellipsis
p29122
as(dp29123
g15
V34509
p29124
stp29125
a((dp29126
g2
(lp29127
VIt doesn't matter whether  has any derived classes
p29128
aVIn that situation  points to a  object so the compiler can inline the call
p29129
aVAnd surely any decent modern compiler can and will do that in your situation
p29130
aVIf you don't use pointers it becomes a whole lot easier
p29131
aVIt's not really an "optimization" then
p29132
aVThe fact that you can omit a virtual call then becomes obvious by only looking at the AST node at the left side of the -operator
p29133
aVBut if you use pointers, you need to track the dynamic type of the pointee
p29134
aVBut modern compilers are capable of that
p29135
aVEDIT: Some experiment is in order
p29136
aVAs can be seen, clang does direct calls to , both when  points to a  and when it points to a
p29137
aVGCC does that too
p29138
as(dp29139
g15
V34509
p29140
stp29141
a((dp29142
g2
(lp29143
V1 and 2 are equivalent, and specify the type of a pointer to a const
p29144
aVThe pointer itself is not const
p29145
aV3 is invalid, because it repeats "const"
p29146
aVIt's like saying
p29147
aVThe order is not relevant, so it's also like saying
p29148
aVIn C99 it is valid to repeat  like that
p29149
aVBut in C++, you cannot repeat it
p29150
aVAlso, how are string-literalls stored by the compiler
p29151
aVThey are stored in an unspecified way
p29152
aVBut compilers are allowed to store them in a read-only portion of the program
p29153
aVSo you cannot write to string literals
p29154
aVYou are guaranteed that they stay allocated through the whole program lifetime (in other words, they have static storage duration)
p29155
aVThis isn't homework, I'm just brushing up on C for interviews in case anyone cares
p29156
aVYou should be aware of the subtle differences between C and C++
p29157
aVIn C99, like explained above,  is allowed
p29158
aVIn C89 and C++ it is forbidden
p29159
aVIn C++ you can however introduce a redundant const, if applied to a typedef that is itself const:
p29160
aVSame goes for template parameters
p29161
as(dp29162
g15
V34509
p29163
stp29164
a((dp29165
g2
(lp29166
VThe type of  (of the variable) is
p29167
aVSo  yields
p29168
aVThe type of the expression  is
p29169
aVIf the expression is an lvalue,  yields a lvalue reference to the type of the expression
p29170
aVSo  yields
p29171
as(dp29172
g15
V34509
p29173
stp29174
a((dp29175
g2
(lp29176
VIt says
p29177
aVExcept for
p29178
aVclass template specializations
p29179
aVSo it does not apply to , but to its members (members that aren't inline member functions and presumably that aren't nested classes
p29180
aVUnfortunately, there isn't a one term that catches both of "class template specialization and specializations of member classes of class templates"
p29181
aVSo there are some places that use only the former but mean to also include the latter)
p29182
aVSo  and its nested classes (like , if it is defined as a nested class) will still be implicitly instantiated if needed
p29183
as(dp29184
g15
V34509
p29185
stp29186
a((dp29187
g2
(lp29188
VSee my blog post
p29189
aVI'm reposting the code here
p29190
aVSome class with private members
p29191
aVAnd how to access them
p29192
as(dp29193
g15
V34509
p29194
stp29195
a((dp29196
g2
(lp29197
VContrary to what the other answers say, you can specialize a member function of a class template
p29198
aVBut you need to provide all template arguments
p29199
aVWhat you try is not valid:
p29200
aVPartially specializing a member of a class template for particular arguments of that class template is not valid, so that means "define the member function 'f' of a partial specialization of A for "
p29201
aVBecause there is no such partial specialization, the compiler will error out
p29202
aVIf you cannot provide all arguments, you can overload  as follows
p29203
as(dp29204
g15
V34509
p29205
stp29206
a((dp29207
g2
(lp29208
VThat's not a proper question
p29209
aVSo to give you some idea how to ask properly, here we go
p29210
aVFirst understand your code
p29211
aVYou evidently haven't, otherwise you wouldn't have presented us this slice of your code
p29212
aVThen elaborate on other parts of your code, if you aren't sure whether you picked the right slice
p29213
aVFor example, do you have code as follows
p29214
aVIf you don't press the "Enter" key on your keyboard, then on most terminals input won't be sent to  yet
p29215
aVSo just entering "1 1" will not enter a number in the upper left cell at all, it will still wait for your "Enter" to terminate the input (and to terminate reading the second number, too), and hence "when i get to the 9th value it does not reprint the chart"
p29216
as(dp29217
g15
V34509
p29218
stp29219
a((dp29220
g2
(lp29221
VThe  directive roughly works by replacing all macros, and then replacing all identifier and keywords of what's left by  and afterwards processing what's left has a constant expression according to the rules of the C++ language (the subset of those rules applicable to what's left from that replacing - quite little :))
p29222
aVSo  may yield a  if  is defined to be , and a  if it is not defined, if  is simply defined as
p29223
aVThe resulting  is an identifier and will later be replaced by
p29224
aVIt's more likely that they are concatenating the  to something like , so as to support multiple queries with  as argument, testing for existence of different macros
p29225
aVAs a developer of a " C++ Static Analysis" tool you probably have access to the C++ spec
p29226
aVTake a look at clause
p29227
as(dp29228
g15
V34509
p29229
stp29230
a((dp29231
g2
(lp29232
VAn  has no constructor that takes an  (initializer list constructor) and there is no special language support for what it may mean to pass a  to a class' constructors such that that may work
p29233
aVSo that fails
p29234
aVFor it to work, your derived class needs to catch all elements and then forward them, a constructor template:
p29235
aVNote that you need  in this case because brace elision (omitting braces like in your case) does not work at that place
p29236
aVIt's only allowed in declarations of the form
p29237
aVBecause an  consists of a struct embedding a raw array, that will need two level of braces
p29238
aVUnfortunately, I believe that the exact aggregate structure of  is unspecified, so you will need to hope that it works on most implementations
p29239
as(dp29240
g15
V34509
p29241
stp29242
a((dp29243
g2
(lp29244
VIt's used whenever you explicitly specialize a template (class or function template) or a member of a class template
p29245
aVThe first set of examples use this class template and members:
p29246
aVSpecializing and defining members
p29247
aVExample with specializing a non-member class template
p29248
as(dp29249
g15
V34509
p29250
stp29251
a((dp29252
g2
(lp29253
VSFINAE only works if substitution in argument deduction of a template argument makes the construct ill-formed
p29254
aVThere is no such substitution
p29255
aVI thought of that too and tried to use  and  which gives the same result
p29256
aVThat's because when the class template is instantiated (which happens when you create an object of type  among other cases), it instantiates all its member declarations (not necessarily their definitions/bodies
p29257
aVAmong them are also its member templates
p29258
aVNote that  is known then, and  yields false
p29259
aVSo it will create a class  which contains
p29260
aVThe  accesses a non-existing type, so that declaration is ill-formed
p29261
aVAnd thus your program is invalid
p29262
aVYou need to make the member templates'  depend on a parameter of the member template itself
p29263
aVThen the declarations are valid, because the whole type is still dependent
p29264
aVWhen you try to call one of them, argument deduction for their template arguments happen and SFINAE happens as expected
p29265
aVSee this question and the corresponding answer on how to do that
p29266
as(dp29267
g15
V34509
p29268
stp29269
a((dp29270
g2
(lp29271
VYou can only define  once
p29272
aVSo putting  would not serve any purpose -  only has a significant purpose on functions you can define multiple times in a program (all definitions will be treated as if there were only one definition and all definitions are required to be the same)
p29273
aVBecause  functions can be defined multiple times in a program, and  also serves the purpose of making calls to an -marked function as fast as possible, the Standard requires  functions to be defined in every translation unit in which it is used
p29274
aVSo compilers will usually throw away the definition of a function if it is  and the function wasn't used by the code in the current translation unit
p29275
aVTo do that for  would be entirely wrong, which goes to show that  and the semantics  has is entirely incompatible
p29276
aVNote that the question in your title "Why main() in C++ cannot be inlined
p29277
aVand the statement you quote out of the Standard concern different things
p29278
aVYou are asking whether the function can be inlined, which commonly is understood to insert the code of a called function completely or partially into the calling function
p29279
aVJust marking a function  doesn't imply inlining that function at all
p29280
aVIt's entirely the compiler's decision, and of course if you never call  (and you cannot do so) then there is nothing to be inlined
p29281
as(dp29282
g15
V34509
p29283
stp29284
a((dp29285
g2
(lp29286
VWhy do you expect debug information without passing
p29287
aVThis outputs a lot of metadata nodes:
p29288
aVLooking for the class-type tags, you find
p29289
as(dp29290
g15
V34509
p29291
stp29292
a((dp29293
g2
(lp29294
VI think you are right
p29295
aVIt's an ambiguity and I'm not aware of a paragraph that resolves it in the spec
p29296
aVThere are other ambiguities in the C++0x spec that are not explicitly resolved, but that (hopefully) are going to be implemented in the straight forward way by compilers
p29297
aVFor example, the following can be parsed as both the definition of a nested class  and as the definition of an unnamed bitfield having size  of the underlying type
p29298
aVThe latter interpretation would render the program invalid)
p29299
aVAnother example
p29300
aVClang recently had to fix the following because it got it the wrong way (it parsed it as initializing a variable , instead of making a function pure)
p29301
as(dp29302
g15
V34509
p29303
stp29304
a((dp29305
g2
(lp29306
VFirst, you really have two variants of one thing:
p29307
aVThese two are really doing the same initialization with the exception that the first is invalid if it selects an  constructor
p29308
aVOtherwise they are identical
p29309
aVThe first is called "copy list-initialization" and the second is "direct list-initialization"
p29310
aVThe concept is that the form with the  is assigning a "compound value" - a value consisting of 3 ints
p29311
aVAnd it initializes  with that value
p29312
aVFor such an initialization, only non- constructors should be allowed
p29313
aVThe concept for  (without an equal sign) is that you initialize the variable with 3 values - conceptually not a compound value, but 3 separate values that you happen to give all at once
p29314
aVYou could say it's a "constructor call" in the most general sense of that term
p29315
aVThe other initialization you showed is really something completely different from the above two:
p29316
aVIt only calls the constuctors of  with  as an argument
p29317
aVIt doesn't do any of the fancy things, like initializing an array if  is an array or initializing struct members if  is an aggregate struct/class
p29318
aVIf  is not a class, that declaration is not valid
p29319
aVBut if  happens to have a copy or move constructor, then it can in turn use that constructor to construct a temporary  by copy list-initialization and bind the copy/move constructor reference parameter to that temporary
p29320
aVI believe you will not need that form often in real code
p29321
aVAll this is recorded in the committee proposal papers for initializer lists
p29322
aVIn this case, you want to have a look at Initializer Lists \u2014 Alternative Mechanism and Rationale, at section "A programmer's view of initialization kinds":
p29323
aVWe have observed that expert programmers who are aware of a difference between copy-
p29324
aVinitialization and direct-initialization frequently erroneously think that the former is less efficient than the latter
p29325
aV(In practice, when both initializations make sense, they are equally efficient
p29326
aVWe find, in contrast, that it is more useful to think about these things in different terms:
p29327
aVconstructing by calling a constructor (a "ctor-call")
p29328
aVconstructing by transferring a value (a "conversion")
p29329
aV(As it happens, the former corresponds to "direct-initialization", and the latter to "copy-
p29330
aVinitialization", but the standard's terms don't help the programmer
p29331
aVLater on, they find
p29332
aVNote that since we treat the  in
p29333
aVas a single value, it is not equivalent to
p29334
aVwhere the  is an argument list for the constructor call (we emphasize it because it is unlike N2531)
p29335
aVThe rules as laid out in the C++0x FDIS are slightly different than presented in that paper, but the rationale presented in that paper is kept and implemented in the C++0x FDIS
p29336
as(dp29337
g15
V34509
p29338
stp29339
a((dp29340
g2
(lp29341
VThe  form calls the constructors of  directly, and passes as first argument a
p29342
aVYou could have passed more arguments
p29343
aVIf  would not have a constructor whose first parameter is an  or of another type that could be initialized by  (like, another container class), it would not work
p29344
aVIn your case it works because  in fact has a constructor whose first parameter is a
p29345
aVThis is just like in normal function calls
p29346
aVIf you omit the parentheses, as in , the exact meaning depends on the class
p29347
aVA  has an initializer list constructor, which is a constructor with a first parameter of type  (optionally a reference to it), and all other params with default arguments
p29348
aVIf the class has such a constructor, then the initializer list is passed to that constructor
p29349
aVAlternatively the class could simply be an aggregate (like , the initializer list would then init the members) or have a constructor that accepts  separate  arguments
p29350
aVFinally the  form is almost identical to the version omitting the parentheses (i
p29351
aVe just removing ), except that it forbids to use explicit constructors (i
p29352
aVe had they declared it as  or had they declared a  instead, it would result in an error if you use )
p29353
as(dp29354
g15
V34509
p29355
stp29356
a((dp29357
g2
(lp29358
VThey may refer to a program written for a freestanding implementation
p29359
aVThe C++ Standard defines two sorts of implementations
p29360
aVOne is a hosted implementation
p29361
aVPrograms written for those implementations are required to have a  function
p29362
aVBut otherwise, no  function is required if the freestanding implementation doesn't require one
p29363
aVThis is useful for operation system kernels or embedded system programs that don't run under an operation system
p29364
as(dp29365
g15
V34509
p29366
stp29367
a((dp29368
g2
(lp29369
VWhen the compiler can check the data type,why cant it check the number of arguments
p29370
aVwhich as per the definition must be two only
p29371
aVThat's undefined behavior par excellence
p29372
aVThe compiler lets you do it because it assumes you know what you are doing
p29373
aVIf you put up warning levels and don't get a warning about it, I would switch to another compiler though
p29374
aVIt's one thing to assume that you know what you are doing
p29375
aVBut it's another thing to assume that you're not making any mistakes, by not warning you about that
p29376
aVLike you already pointed out, it's technically possible to do it, and it's not difficult
p29377
aVWhat is the Significance of allowing non prototypes like void fun(); what difference do they make,when they do not help in checking the parameters passed at the function call,why are they supported
p29378
aVFirst, they are for backward compatibility
p29379
aVOld pre-standard C didn't have prototypes
p29380
aVSecond, having a function pointer that doesn't contain a prototype can be useful:
p29381
aVThat code is valid and its behavior is well defined
p29382
as(dp29383
g15
V34509
p29384
stp29385
a((dp29386
g2
(lp29387
VUse overloading
p29388
aVYou cannot partially specialize a member of a class template
p29389
aVWhat you wrote would be the definition of a member function  of a partial specialization of the class template itself
p29390
as(dp29391
g15
V34509
p29392
stp29393
a((dp29394
g2
(lp29395
VYes it is undefined behavior, because the spec says that an "lvalue designates an object or function" (at clause 3
p29396
aV10) and it says for the -operator "the result [of dereferencing] is an lvalue referring to the object or function to which the expression points" (at clause 5
p29397
ag1037
aV1)
p29398
aVThat means there is no description for what happens when you dereference a null pointer
p29399
aVIt's simply undefined behavior
p29400
as(dp29401
g15
V34509
p29402
stp29403
a((dp29404
g2
(lp29405
VA default constructor is always declared
p29406
aVBut it is not always defined
p29407
aVOnly if it is used, then the compiler (or you) define it
p29408
aVExamples:
p29409
aVNote that this has direct practical consequences
p29410
as(dp29411
g15
V34509
p29412
stp29413
a((dp29414
g2
(lp29415
VImagine this code:
p29416
aVWithout the trick with the parentheses, you would not be able to take a pointer directly to B's data member (you would need base-class casts and games with  - not nice)
p29417
aVFrom the ARM:
p29418
aVNote that the address-of operator must be explicitly used to get a pointer to member; there is no implicit conversion
p29419
aVHad there been, we would have an ambiguity in the context of a member function
p29420
aVFor example,
p29421
aVThe IS just kept this pre-Standard concept and explicitly mentioned that parentheses make it so that you don't get a pointer to member
p29422
as(dp29423
g15
V34509
p29424
stp29425
a((dp29426
g2
(lp29427
VImagine this code:
p29428
aVWithout the trick with the parentheses, you would not be able to take a pointer directly to B's data member (you would need base-class casts and games with  - not nice)
p29429
aVFrom the ARM:
p29430
aVNote that the address-of operator must be explicitly used to get a pointer to member; there is no implicit conversion
p29431
aVHad there been, we would have an ambiguity in the context of a member function
p29432
aVFor example,
p29433
aVThe IS just kept this pre-Standard concept and explicitly mentioned that parentheses make it so that you don't get a pointer to member
p29434
as(dp29435
g15
V34509
p29436
stp29437
a((dp29438
g2
(lp29439
VYou are allowed to cast a standard layout class object address to a pointer to its first member and back by one of the later paragraphs, which is also often done in C:
p29440
aVFor that to work, the first member and the complete object have to have the same address (the compiler cannot adjust the int pointer by any bytes because it can't know whether it's a member of an  or not)
p29441
aVFinally, what would go wrong if more than one constituent class had data members
p29442
aVWithin a class, members are allocated in increasing addresses according to the declaration order
p29443
aVHowever C++ doesn't dictate the order of allocation for data members across classes
p29444
aVIf both the derived class and base class had data members, the Standard doesn't define an order for their addresses on purpose, so as to give an implementation full flexibility in layouting memory
p29445
aVBut for the above cast to work, you need to know what is the "first" member in allocation order
p29446
aVWhat would go wrong if the first data member was also a base class
p29447
aVIf the base class has the same type as the first data member, implementations that place the base classes before the derived class objects in memory would need to have a padding byte before the derived class object data members in memory (base class would have size one), to avoid having the same address for both the base class and the first data member (in C++, two distinct objects of the same type always have different addresses)
p29448
aVBut that would again make impossible to cast the address of the derived class object to the type of its first data member
p29449
as(dp29450
g15
V34509
p29451
stp29452
a((dp29453
g2
(lp29454
VAs others said, it means that the order of the evaluation of the two sides is unspecified
p29455
aVTo answer your other questions -
p29456
aVI've also considered that I may be running into the multiple changes between sequence points rule (and thus undefined behavior)
p29457
aVNo, your case does not modify  in between two adjacent sequence points
p29458
aVBefore entering a function and before leaving a function, there always is a sequence point, which means that both modifications of  happen in between two different pairs of sequence points
p29459
aVDoes this vary when the operator is overloaded
p29460
aVAll of clause 5 only talks about builtin operators
p29461
aVFor user defined operator implementations, the rules don't apply
p29462
aVSo also for , for user defined operators the order is not specified
p29463
aVBut notice that it is only for user defined operators; not when both operands are converted to bool and trigger the builtin operator:
p29464
aVThis will always first execute , and then
p29465
aVAnd it will only call  if  evaluates to
p29466
as(dp29467
g15
V34509
p29468
stp29469
a((dp29470
g2
(lp29471
VYou get the ambiguity because your second parameter is different
p29472
aVTrying to call it with  will raise an ambiguity because it matches the second argument better with the first overload, but the first argument is matched better with the second overload
p29473
aVMake the second parameter have the same type in both cases and you will get rid of the ambiguity, as then the second argument is matched equally worse/good for both overloads, and the first argument will be matched better with the second overload
p29474
as(dp29475
g15
V34509
p29476
stp29477
a((dp29478
g2
(lp29479
VYou have this wrong
p29480
aVIt should be
p29481
aVThe allocator of  is not a template
p29482
aVThen the declaration of  becomes
p29483
aVAs you gave a default argument for the allocator, you don't need to pass any argument for it
p29484
aVIf you wanted to, you would need to pass  or some other allocator again
p29485
aVThe default argument of a parameter of a template template argument is not "inherited" to the corresponding template template parameter of your class/struct template
p29486
aVYou need to specify it again, like above (by stating  as default template argument)
p29487
as(dp29488
g15
V34509
p29489
stp29490
a((dp29491
g2
(lp29492
VNow in c++11 we have
p29493
aVLink to reference: http://en
p29494
aVcppreference
p29495
aVcom/w/cpp/string/basic_string/to_string
p29496
as(dp29497
g15
V34509
p29498
stp29499
a((dp29500
g2
(lp29501
VThe error message that GCC gives shows that your version of GCC still had a bug that is only resolved in GCC4
p29502
aV7 trunk versions
p29503
aVOlder versions, including GCC4
p29504
aV1 will happily accept following code
p29505
aVGCC will look up  in  within the base class  and will find the declaration in the base class
p29506
aVGCC does that because  is dependent, because there are arguments to  that "depend on a template parameter" (look at its error message it gave you
p29507
aVBut the Standard forbids GCC to do that for two reasons
p29508
aVThe Standard says that use of unqualified names will never find a declaration in a dependent base class no matter whether the name is dependent
p29509
aVThe Standard says that dependent lookup of a function name at instantiation time will only do ADL
p29510
aVGCC 4
p29511
aV7 implements the Standard correctly in that regard
p29512
as(dp29513
g15
V34509
p29514
stp29515
a((dp29516
g2
(lp29517
VAs an addition to the answer by @Paul, I found that when painting text (Qt4
p29518
aV8 on linux), the width of an actually painted text compared to the width of what  returns is often off
p29519
aVIn my cases, the painting was often too wide
p29520
aVIf you want accurate results when painting text (for example to dimension rectangles you draw around text), better use the  functions provided directly by
p29521
as(dp29522
g15
V34509
p29523
stp29524
a((dp29525
g2
(lp29526
VWhen should I not write the keyword 'inline' for a function/method in C++
p29527
aVIf the function is defined in the  file, you should not write the keyword
p29528
aVWhen will the the compiler not know when to make a function/method 'inline'
p29529
aVThere is no such situation
p29530
aVThe compiler cannot make a function inline
p29531
aVAll it can do is to inline some or all calls to the function
p29532
aVIt can't do so if it hasn't got the code of the function (in that case the linker needs to do it if it is able to do so)
p29533
aVDoes it matter if an application is multithreaded when one writes 'inline' for a function/method
p29534
aVNo, that does not matter at all
p29535
as(dp29536
g15
V34509
p29537
stp29538
a((dp29539
g2
(lp29540
VUpdate for C++11 (09/30/2011)
p29541
aVStop, this is well defined in C++11
p29542
aVIt was undefined only in C++03, but C++11 is more flexible
p29543
aVAfter that line,  will be 2
p29544
aVThe reason for this change was
p29545
aVbecause it already works in practice and it would have been more work to make it be undefined than to just leave it defined in the rules of C++11 (actually, that this works now is more of an accident than a deliberate change, so please don't do it in your code
p29546
aVStraight from the horse's mouth
p29547
aVhttp://www
p29548
aVopen-std
p29549
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p29550
aVhtml#637
p29551
as(dp29552
g15
V34509
p29553
stp29554
a((dp29555
g2
(lp29556
VFrom the official C Rationale Document
p29557
aVThe terms unspecified behavior, undefined behavior, and implementation-defined behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe
p29558
aVThe goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard
p29559
aVAppendix F to the Standard catalogs those behaviors which fall into one of these three categories
p29560
aVUnspecified behavior gives the implementor some latitude in translating programs
p29561
aVThis latitude does not extend as far as failing to translate the program
p29562
aVUndefined behavior gives the implementor license not to catch certain program errors that are difficult to diagnose
p29563
aVIt also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior
p29564
aVImplementation-defined behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user
p29565
aVBehaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition
p29566
aVImplementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be
p29567
aVAs with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response
p29568
as(dp29569
g15
V34509
p29570
stp29571
a((dp29572
g2
(lp29573
VI'm not sure what you refer to by "initialization/declaration" in this context
p29574
aVBut rvalues of array type are not too uncommon
p29575
aVNow  is an rvalue of array type and it will be converted to a pointer
p29576
aVSame for the below C++11 code
p29577
aVCreating arrays this way on the fly wasn't initially intended to work but slipped into the working draft by-the-way of related work on uniform initialization
p29578
aVWhen I realized that some paragraphs in the C++0x working draft disallow some special case of this on-the-fly creation of array temporaries while other paragraphs allow it, I sent a defect report to the C++ committee, which then on the basis of GCC's partially working implementation decided to fully support this
p29579
as(dp29580
g15
V34509
p29581
stp29582
a((dp29583
g2
(lp29584
VThere's no technical reason for this
p29585
aVIIRC it was already implemented by the GCC C++ maintainer and he said it's trivial to implement
p29586
aVThe committee is very conservative about accepting features into the Standard so they went with this simple form of deduction and will later hopefully accept a more powerful form
p29587
aVSee the reason for rejection on US 30 comment
p29588
aVDR 975 is already marked "ready" so chances are good it will be accepted
p29589
as(dp29590
g15
V34509
p29591
stp29592
a((dp29593
g2
(lp29594
VYour code is wrong for two reasons
p29595
aVYou cannot initialize a static data member in-class if it is not of integer or enumeration type and not
p29596
aVYou miss a definition for
p29597
aVAs you are odr-using that member, you need to define it
p29598
aVIt's not a clang bug
p29599
aVOnce clang gets  support and when you then add a definition of out class (which then cannot have an initializer), as you already provided one in-class) and replace  by  the code should then work fine
p29600
aVFor the general public, here is the PR that @James sent to Clang
p29601
as(dp29602
g15
V34509
p29603
stp29604
a((dp29605
g2
(lp29606
VAnswering my own question because I just earned a Tumbleweed badge for it
p29607
aVand I found out subsequently
p29608
aVBut I was wondering whether there is perhaps a finer-grained control over this, like overwriting  for individual function definitions of a library
p29609
aVYes, there is the option  which does exactly that
p29610
aVShould I be aware of any pitfalls of using
p29611
aVI plan to only use that, because the -Bsymbolic will break exceptions, I think (it will make it so that references to typeinfo objects are not unified, I think)
p29612
aVI looked more into it, and it seems there is no issue
p29613
aVThe libstdc++ library apparently does it or at least did consider it and they only had to add  to still have  unified (to prevent issues with multiple allocator / deallocators mixing up in a program but I would argue such programs are broken anyway)
p29614
aVUbuntu uses it or used it by default, and it seems it causes conflicts with some packages
p29615
aVBut overall it should work nicely I expect
p29616
as(dp29617
g15
V34509
p29618
stp29619
a((dp29620
g2
(lp29621
VYou can define the nested class later
p29622
aVThe compiler is right to moan at you
p29623
aVFor a class member access ( and ), unlike for , the class must be complete
p29624
aVSo if it would be a static function, it would be fine, but since it's a non-static member function, it errors out
p29625
aVAn exception to that rule is when the member access happens in a late specified return type of a non-static member function when using  (generally, in between after the closing  of the parameter list and before the start of the function body, that exception to the rule is allowed
p29626
aVWithin a member function body of the inner class, the outer class is regarded complete, so no exception to the rule is needed anymore)
p29627
as(dp29628
g15
V34509
p29629
stp29630
a((dp29631
g2
(lp29632
VIt's defined behavior
p29633
aVThe value that ends up in  is unspecified if  is outside the range of values of  and is the same as  if it is inside of the range of values of
p29634
aVThe range of  is
p29635
aVThat is, the values of a bitfield that can store all the values of your enum constants (enumerators)
p29636
as(dp29637
g15
V34509
p29638
stp29639
a((dp29640
g2
(lp29641
VThe rule you are looking for is stated in the same paragraph, 12
p29642
aV4p2
p29643
aVA destructor takes no parameters, and no return type can be specified for it (not even void)
p29644
aVThe phrase "no return type can be specified for it" also forbids "*", which is not immediately clear but can be seen by comparison with 12
p29645
ag1037
aV2p1 (compare with this issue report):
p29646
aVSuch functions are called conversion functions
p29647
aVNo return type can be specified
p29648
aVThat rule is what makes implementations forbid
p29649
aVYou can also argue with 12
p29650
aV4p1, although as that's phrased very general and is the first statement in the destructors section, I think the other statement above should be the primary argument
p29651
aVA special declarator syntax using an optional function-specifier (7
p29652
ag2790
aV2) followed by \u02dc followed by the destructor's class name followed by an empty parameter list is used to declare the destructor in a class definition
p29653
aVAs can be seen/read there is no mention of declarators such as  in that description, which shows the intent of the authors
p29654
as(dp29655
g15
V34509
p29656
stp29657
a((dp29658
g2
(lp29659
VIt is not "wrong", but surprising
p29660
aVAn assignment evaluates to the target object
p29661
aVThat's what the builtin meaning is
p29662
aVIf you define it different for your own class, people could become confused
p29663
aVExample:
p29664
aVThe assignment to  returned  itself and compared it to  afterwards
p29665
aVUsers would expect your  class to behave similar
p29666
as(dp29667
g15
V34509
p29668
stp29669
a((dp29670
g2
(lp29671
VPut this outside of the class definition then:
p29672
aVThat is the definition of , which can supply an initializer and has to go into the  file (like any other definition of objects, it can only appear once in the whole program, otherwise you will get linker errors)
p29673
aVSometimes you will find code that doesn't have definitions for its static data members:
p29674
aVOmitting the definition like that is valid only if  is never address-taken and never passed to reference parameters
p29675
aVA more formal way to say when it is valid to omit the definition is: "When all uses of A::x immediately read the stored value of A::x"
p29676
aVThat's the case for many static integer constants
p29677
as(dp29678
g15
V34509
p29679
stp29680
a((dp29681
g2
(lp29682
VIt's a bit more complicated
p29683
aVIn C++03 and C++11,  is a constant expression if  is a local static / class static or namespace scope variable
p29684
aVThis is called an address constant expression
p29685
aVInitializing a class static or namespace scope pointer variable with that constant expression is guaranteed to be done before any code is run (static initialization phase), because of it being a constant expression
p29686
aVHowever only in C++11, a constexpr pointer variable that stores the address  can also be used as an address constant expression and only in C++11, you can dereference an address constant expression (actually, you can dereference even more - even local array element addresses, but let's keep it ontopic) and if it refers to a constant integral variable initialized prior to the dereference or a constexpr variable, you again get a constant expression (depending on the type and value category, the kind of constant expression may vary)
p29687
aVAs such, the following is valid C++11:
p29688
aVIf so, why can't a pointer be a constant expression
p29689
aVIf not, why don't the above programs compile
p29690
aVThis is a known limitation in the Standard's wording - it currently only allows other template parameters as arguments or , for a template parameter of pointer type
p29691
aVEven though the compiler should be capable of doing much more
p29692
as(dp29693
g15
V34509
p29694
stp29695
a((dp29696
g2
(lp29697
VYes it works, and the reason is the name lookup mechanism
p29698
aVThe mechanism a inheriting-constructors declaration works is simple: If the using declaration's name refers to base class constructors, that's an inheriting constructors declaration
p29699
aVAt 3
p29700
ag2670
ag1037
aV1[class
p29701
aVqual]p2 we find:
p29702
aVIn a lookup in which the constructor is an acceptable lookup result and the nested-name-specifier nominates a class C
p29703
aVif the name specified after the nested-name-speci\ufb01er, when looked up in C, is the injected-class-name of C (Clause 9), or
p29704
aVin a using-declaration (7
p29705
ag1037
aV3) that is a member-declaration, if the name specified after the nested-name-specifier is the same as the identifier or the simple-template-id's template-name in the last component of the nested-name-specifier
p29706
aVthe name is instead considered to name the constructor of class C
p29707
aVThis is the paragraph that makes out of class constructor definitions work, and this is also the paragraph that makes inheriting constructor declarations work
p29708
aVThe second bullet applies in this case:
p29709
aVThe latter example proves also useful in cases such as the following
p29710
aVIn summary:
p29711
aVThe first bullet above is a semantic rule - if the name after the nested name specifier refers to the injected class name ( or ), then it will be translated to refer to the constructor(s)
p29712
aVThe second bullet is a syntactic rule - the names just must match - their meaning is irrelevant otherwise - there could have been a member called  in the template argument provided to , such as in the following, but the using declaration would still import the constructors and do not name the member :
p29713
as(dp29714
g15
V34509
p29715
stp29716
a((dp29717
g2
(lp29718
VAs there are several solutions given that don't generate a table but still allow compile time lookup, here is another one
p29719
aVUse at compile time
p29720
aVSpecifying a character that doesn't exist will result in an error
p29721
aVIf you use the function at runtime, you will get undefined behavior if you specify a character that doesn't exist
p29722
aVProper checking can be added for those cases
p29723
aVIt yields the index of the first character found
p29724
aVNo error is given if a character appears twice in the haystack
p29725
as(dp29726
g15
V34509
p29727
stp29728
a((dp29729
g2
(lp29730
VThe intent is that this works and the paragraphs that state when an lvalue to rvalue conversion is valid will be amended with a note that states that an lvalue that refers to a subobject of a string literal is a constant integer object initialized with a constant expression (which is described as one of the allowed cases) in a post-C++11 draft
p29731
aVYour comment about the use within the preprocessor looks interesting but I'm unsure whether that is intended to work
p29732
aVI hear about this the first time at all
p29733
as(dp29734
g15
V34509
p29735
stp29736
a((dp29737
g2
(lp29738
VAn expression doesn't only have a value and a type, but it also has a value category
p29739
aVThis category can be
p29740
aVAn lvalue: These expressions generally refer to declared objects, references, functions or dereference results of pointers
p29741
aVAn xvalue: These are the result of generating an unnamed rvalue reference
p29742
aVRvalue references are created by  instead of
p29743
aVThey are a C++11 concept, and you can ignore them here
p29744
aVMentioned only for sake of completeness
p29745
aVAn prvalue: These are the results of casts to non-reference types (like ) or computing/specifying a value, like  or
p29746
aVAn lvalue reference requires an lvalue expression for initialization
p29747
aVThat is, the following is invalid:
p29748
aVThe reason behind this is that only lvalue expressions refer to things that are suitable and intended for staying alive a longer time than only for the duration of the initialization
p29749
aVLike, a declared object is alive until exiting its block (if it was a local non-static variable) or until the end of the program (if it was declared outside functions and classes)
p29750
aVThe rvalue expression  refers to an object that dies already when the initialization is finished
p29751
aVAnd if you said the following, it would not make any sense of all, because pure values like  don't have an address at all, but references require some sort of identity to which they bind, which in practice is implemented by taking the address of their target internally in compilers
p29752
aVBut for const references, C++ has a backdoor
p29753
aVWhen initialized with a prvalue, a const lvalue reference will automatically lengthen the lifetime of the object, if the expression refers to an object
p29754
aVIf the expression has a non-object value, C++ creates a temporary object with a value of that expression, and lengthens the lifetime of that temporary, binding the reference to that temporary:
p29755
aVWhat happens in your case
p29756
aVNow the compiler in your case, because you supply a temporary object, will choose the version that has a  parameter type rather than a  parameter type
p29757
as(dp29758
g15
V34509
p29759
stp29760
a((dp29761
g2
(lp29762
VYou read it incorrectly
p29763
aVThis would break lots of C++03 classes in cases such as the following
p29764
aVInstead, the FDIS says that a move constructor will be declared iff {there is no user declared {copy constructor, {copy, move} assignment operator, destructor} and the implicitly declared move constructor would not be defined as deleted}
p29765
aVRegarding Update 2
p29766
aVIt has been brought to my attention that if you explicitly-default the move constructor, it will be defined as deleted by the condition
p29767
aVfor the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable
p29768
aVIn the following, the move constructor will be defined as deleted, because  is not trivially copyable
p29769
as(dp29770
g15
V34509
p29771
stp29772
a((dp29773
g2
(lp29774
VThere is no way to do this in C++11
p29775
aVJust in case you are not aware of it - you get the  notation even for an unscoped enumeration
p29776
aVFor such an enumeration, you have  accessible with and without the use of
p29777
aVBut you cannot take a scoped enumeration and selectively make all its enumerators visible in a given scope
p29778
aVIt should also be noted that you can not write
p29779
aVThe spec explicitly forbids this, your compiler just doesn't reject it yet
p29780
as(dp29781
g15
V34509
p29782
stp29783
a((dp29784
g2
(lp29785
VOn a related note, in this particular case you can use vector's  support by writing the constructor as follows
p29786
aVOr by using assignment if for any reason you can't use constructor initializers
p29787
as(dp29788
g15
V34509
p29789
stp29790
a((dp29791
g2
(lp29792
VThis was subject of an earlier question
p29793
aVIt can be achieved as follows
p29794
aVHowever in practice, I can't imagine running into this problem, because I could always rename the local variable or create a small  function that can access the global  and that I could call
p29795
as(dp29796
g15
V34509
p29797
stp29798
a((dp29799
g2
(lp29800
VYou need to make the third function parameter a non-deduced context for the template parameters therein
p29801
aVThen the compiler will not compare the argument type against the parameter type without also considering all implicit conversions (the Standard says, and C++0x clarified this further, that for a function parameter where there are no template parameters in deducing positions, all implicit conversions are allowed in bridging a difference)
p29802
aVInstead of  you can use
p29803
aVIn C++0x and compilers that support it, you can have a more readable edition using alias templates
p29804
aVThen your code becomes simply
p29805
aVHowever GCC does not yet support alias templates
p29806
as(dp29807
g15
V34509
p29808
stp29809
a((dp29810
g2
(lp29811
VSince comment boxes are too small to explain why you have a serious error in your reasoning, I'm putting this as a community wiki answer
p29812
aVFor header-only functions,  is pretty much useless because anyone who includes their header will get a different function
p29813
aVThat means you will duplicate code the compiler creates for each of the functions (unless the linker can merge the code, but by all I know, that's very unlikely), and worse, if the function would have local statics, each of those locals would be different, resulting in potentially multiple initializations for each call to a definition from a different inclusion
p29814
aVNot good
p29815
aVWhat you need for header-only functions is  (non- ), which means each header inclusion will define the same function and modern linkers are capable of not duplicating the code of each definition like done for  (for many cases, the C++ Standard even requires them to do so), but emitting only one copy of the code out of all definitions created by all inclusions
p29816
as(dp29817
g15
V34509
p29818
stp29819
a((dp29820
g2
(lp29821
VThe compile error for
p29822
aVIs a combination of four things
p29823
aVThe draft until not long ago said that if  has an initializer list constructor ( has one, taking  elements), that the initializer list is passed itself as an argument
p29824
aVSo the argument to the constructor(s) is not , but
p29825
aVThe draft says that an initializer list initializing a reference is done not by direct binding, but by first constructing a temporary out of the element in the initializer list, and then binding the target reference to that temporary
p29826
aVThe draft says that when initializing a reference by an initializer list, when the initialization of the reference is not direct binding, that the conversion sequence is a user defined conversion sequence
p29827
aVThe draft says that when passing the initializer list itself when considering constructors of class  as candidates in an overload resolution scenario in a context like the above, then when considering a first constructor parameter of type "reference to cv X" (cv = const / volatile) - in other words highly likely a copy or move constructor, then no user defined conversions are allowed
p29828
aVOtherwise, if such a conversion would be allowed, you could always run in ambiguities, because with list initialization you are not limited to only one nested user defined conversion
p29829
aVThe combination of all the above is that no constructor can be used to take the
p29830
aVThe one using  does not match, and the others using  and  are forbidden, because they would necessitate user defined conversions for binding their parameter to the
p29831
aVNote that more recent draft changed the first rule: They say that if no initializer list constructor can take the initializer list, that then the argument list consists of all the elements of the initializer list
p29832
aVWith that updated rule, your example code would work fine
p29833
as(dp29834
g15
V34509
p29835
stp29836
a((dp29837
g2
(lp29838
VYour suspicions are incorrect
p29839
aVNow  has type , but with your rewrite, it has type
p29840
aVIn any case, everywhere you want to get the type of an expression or declaration, you use  (note the subtle difference in between these two
p29841
aVis not necessarily the same as )
p29842
aVFor example, it's likely your Standard library implementation somewhere contains lines like
p29843
aVFinding out the correct return type of  has been a challenging problem throughout past C++
p29844
aVThis is now an easy exercise
p29845
aVLittle known is that you can use  before  and in a pseudo destructor name
p29846
as(dp29847
g15
V34509
p29848
stp29849
a((dp29850
g2
(lp29851
VOne thing that definitely is present in the Apple GCC branch but not in GNU GCC is blocks
p29852
as(dp29853
g15
V34509
p29854
stp29855
a((dp29856
g2
(lp29857
VYou can do this by running a local event loop, letting the components process network income and load the page
p29858
aVWhen they emit the signal, you execute a slot on the event loop to quit it
p29859
aVI've been using this before and it works fine
p29860
aVI don't advice to use this too often though, because it will process events, including those that the caller of  might not be expecting to be processed during the call to , so you need to document this to its callers
p29861
aVYou can prevent the processing of some events by passing certain flags to , like preventing to process user interface events
p29862
as(dp29863
g15
V34509
p29864
stp29865
a((dp29866
g2
(lp29867
VThe construction and destruction of function parameters happens in the context of the caller
p29868
aVSo no, if the construction of  throws, that is not a violation of
p29869
aVSoon folks would comment and ask for a spec quote :) So I will give you 5
p29870
ag976
aV2p4
p29871
aVThe initialization and destruction of each parameter occurs within the context of the
p29872
aVcalling function
p29873
as(dp29874
g15
V34509
p29875
stp29876
a((dp29877
g2
(lp29878
VIt appears that you already have your answer in that boost mailing list posting
p29879
aVYes, in my opinion it is undefined behavior or at least not sufficiently clear defined behavior
p29880
aVSee this usenet discussion for the same matter being discussed
p29881
as(dp29882
g15
V34509
p29883
stp29884
a((dp29885
g2
(lp29886
VI think I would move it into a separate namespace
p29887
aVAlternatively you can move the whole code up into  and delegate to there
p29888
as(dp29889
g15
V34509
p29890
stp29891
a((dp29892
g2
(lp29893
VThe in class body member initializer is just a default
p29894
aVIf the member initializer list of a constructor initializes the member too, it takes precedence always
p29895
aVThis is specified by 12
p29896
ag488
aV2p9 in the C++11 spec
p29897
as(dp29898
g15
V34509
p29899
stp29900
a((dp29901
g2
(lp29902
VThis is surprisingly easy once you get the hang of it
p29903
aVThis is necessary because if you explicitly specialize a single member, you must provide all template arguments
p29904
aVYou cannot leave some off
p29905
as(dp29906
g15
V34509
p29907
stp29908
a((dp29909
g2
(lp29910
VVolatile has one primary function, which is to say "STOP
p29911
aVThis object is connected to external resources, and thus when I write to it, don't reorder the write with respect to other volatile reads or writes, and when I read to it, don't reorder it likewise and don't optimize these away
p29912
aVTo support this, you can put  after member functions, which is necessary to call member functions on  class objects
p29913
aVPutting  on a return value can be done too, but it seems to me that it would be less useful since return values are usually temporaries and  semantics are quite on the the opposite scale of temporaries
p29914
aVPutting  on  is particularly nonsensical ( and  are ignored if put at the top-level of a return type if the type is not a class type (i
p29915
aVe at the right of a  if it is a pointer), because these return values do not correspond to memory, likely being kept in registers by implementations too)
p29916
aVPutting  on non-toplevel for references or pointers can be useful, like in the following
p29917
aVHope it helps
p29918
as(dp29919
g15
V34509
p29920
stp29921
a((dp29922
g2
(lp29923
VChances are that you are compiling in C mode
p29924
aVC does not have
p29925
aVUse  instead or include  to get a  of  (only C99) or create a typedef /  yourself (if your compiler doesn't have or you don't want to use
p29926
aVBut GCC provides this header)
p29927
aVAlternatively in C99 code you can use  instead (which is a keyword in C99, much like  is to C++), but take in mind that C99 is not widely supported
p29928
as(dp29929
g15
V34509
p29930
stp29931
a((dp29932
g2
(lp29933
VYou will have to live with adding a default constructor to  (which perhaps sets mode to  to indicate an invalid mode) and assign to  in the constructor body
p29934
aVThe parameter  is a runtime value
p29935
aVIt is not possible to make types and overloading result depend on runtime values
p29936
as(dp29937
g15
V34509
p29938
stp29939
a((dp29940
g2
(lp29941
VInstead you can pass the address of a pointer storing the same value as
p29942
aVWhen  returns you can copy the value back into
p29943
aVYou can also cast the address
p29944
aVA write through  to an object of type  is not an aliasing violation
p29945
aVThe fact that this is valid is less obvious that simply passing a copy and then assigning back to  in my opinion, anyway
p29946
as(dp29947
g15
V34509
p29948
stp29949
a((dp29950
g2
(lp29951
VGCC according to C++11 cannot deduce the type for either first two calls to
p29952
aVIt warns because it implements an extension to C++11
p29953
aVThe Standard says that when a function argument in a call to a function template is a  and the parameter is not  (optionally a reference parameter), that then the parameter's type cannot be deduced by the
p29954
aVIf the parameter is such a , then the elements of the initializer list are deduced independently by comparing against , and each of the deductions of the elements have to match
p29955
aVIn this example, the first is OK, and the second is OK too because the first element yields type , and the second element compares  against  - this deduction cannot yield a constradiction since it doesn't deduce anything, hence eventually the second call takes  as
p29956
aVThe third cannot deduce  by any element, hence is NOT OK
p29957
aVThe last call yields contradicting deductions for two elements
p29958
aVOne way to make this work is to use such a type as parameter type
p29959
aVI should note that doing  is dangerous - better remove those  around the braces
p29960
aVIn your case it happens to work by accident, but consider
p29961
aVThe reason is that  calls the copy/move constructor of  passing it a temporary  associated with the
p29962
aVThat temporary object will then be destroyed and die when the initialization is finished
p29963
aVWhen that temporary object that is associated with the list dies, the backing-up array holding the data will be destroyed too (if the move is elided, it will live as long as "v"; that's bad, since it would not even behave bad guaranteedly
p29964
aVBy omitting the parens,  is directly associated with the list, and the backing array data is destroyed only when  is destroyed
p29965
as(dp29966
g15
V34509
p29967
stp29968
a((dp29969
g2
(lp29970
VBecause link is also a posix function and the function name hides the class name
p29971
aVYou can say  but better put your class into a new namespace or rename it
p29972
as(dp29973
g15
V34509
p29974
stp29975
a((dp29976
g2
(lp29977
VIf you add  to , then  is first converted to a pointer value of type  (pointing to the first element of an array of type )
p29978
aVThen  is added to that, which adds  bytes to the address represented by that pointer value
p29979
aVSince that multiplication yields 0, it will yield  the same pointer value
p29980
aVSince it is a pointer,  yields the size of a pointer, which is 8 bytes on your box
p29981
aVIf you do , there is no reason for the compiler to convert  to a pointer value (that makes only sense if you want to index elements or to do pointer arithmetic involving the address of the elements)
p29982
aVSo expression  stays being of an array type, and you get the size of  instead the size of
p29983
aVSo,  which on your box is 24 bytes
p29984
aVHope this clarifies things
p29985
as(dp29986
g15
V34509
p29987
stp29988
a((dp29989
g2
(lp29990
VThe code requested an implicit instantiation at
p29991
aVThe fact that you didn't define the template in that translation unit means that it could not instantiate a specialization, hence  yields an "unresolved symbol" (linker-) error in your case
p29992
aVTo get rid of that error, you either have to define the template in that TU, or provide an explicit instantiation directive of that template in a TU where you define the template
p29993
aVThe mere fact that the code requested an implicit instantiation for specialization  before you explicitly provided that specialization is enough for the program to become ill-formed (without a diagnostic being required though; the compiler does a good job here which it is not required to do)
p29994
aVAs @CharlesBailey helpfully notes, declaring the explicit specialization is perfectly sufficient; a definition of it can be given elsewhere, even outside of the using TU
p29995
as(dp29996
g15
V34509
p29997
stp29998
a((dp29999
g2
(lp30000
VSay  instead of , because  is declared in the Standard namespace , not in the global namespace
p30001
aVIn the  file corresponding to  you may choose to say  in that  file if you don't want to type  everywhere in that file (it's basically a question of taste and how likely you want to be to get name conflicts
p30002
aVMaking all names of  unqualified visible increases the likelihood of name conflicts with global names)
p30003
aVBut don't put such a line into a header
p30004
aVSince your code appears to be entirely into one  file you won't have such an option then
p30005
aVBut you can locally in the member functions say  or declare individual names as aliases in local scope of member functions, like , if you want
p30006
aVAlso, you need to put the definition of those member functions (of the class template) within the header guard, if not directly within the class body if you like
p30007
aVYour other error messages appear because you include the header multiple times, but the member function definitions, appearing outside the header guard, wrongly will be emitted into the translation unit multiple times, raising multiple definition errors at compile time
p30008
as(dp30009
g15
V34509
p30010
stp30011
a((dp30012
g2
(lp30013
V in the instantiation you do will yield
p30014
aVSince you don't show its definition, we have no idea what type that is
p30015
aVBut  says it is
p30016
aVRecall that  can yield whatever name it wants
p30017
aVGNU libstdc++ yields the mangled type name
p30018
as(dp30019
g15
V34509
p30020
stp30021
a((dp30022
g2
(lp30023
VFor both cases you call it member template
p30024
aVIt's a member template because it's a member that is a template
p30025
aVThe member function  is not a template, but is a member function of a class template
p30026
aVIn C++ there is unfortunately not a clear terminology for such a thing, so it happens that certain rules are formulated in the Standard to apply for templates, but are intended to apply also for member functions of class templates
p30027
aVAnd many rules need to enlist all the joyful combinations like
p30028
aVSame applies for member classes of class templates
p30029
aVIt has been proposed to call member functions/classes of class templates temploid or something like that
p30030
aVWork is under way to fix this state of affairs, though
p30031
as(dp30032
g15
V34509
p30033
stp30034
a((dp30035
g2
(lp30036
VIn C, using the values of uninitialized automatic variables (non-static locals and parameter variables) that satisfy the requirement for being a  variable is undefined behavior, because such variables values may have been fetched from a register and certain platforms may abort your program if you read such uninitialized values
p30037
aVThis includes variables of type  (this was added to a later C spec, to accommodate these platforms)
p30038
aVUsing values of uninitialized automatic variables that do not satisfy the requirement for being a  variable, like variables that have their addresses taken, is fine as long as the C implementation you use hasn't got trap representations for the variable type you use
p30039
aVFor example if the variable type is , the Standard requires all platforms not to have trap representations stored in such variables, and a read of an indeterminate value from it will always succeed and is not undefined behavior
p30040
aVTypes like  or  don't have such guarantees, so your program may crash, depending on the C implementation you use
p30041
aVVariables of static storage duration are always initialized if you don't do it explicitly, so you don't have to worry here
p30042
aVFor variables of allocated storage duration (
p30043
aV, the same applies as for automatic variables that don't satisfy the requirements for being a  variable, because in these cases the affected C implementations need to make your program read from memory, and won't run into the problems in which register reads may raise exceptions
p30044
as(dp30045
g15
V34509
p30046
stp30047
a((dp30048
g2
(lp30049
VOthers have given good workarounds, but I want to answer that other question you had
p30050
aVI expected there is no ambiguity :  exists only for
p30051
aVYou said  so it first needs to look for name  in
p30052
aVIt finds two s
p30053
aVIn  and
p30054
aVAt name lookup time, it does not know yet that it later could have only selected  as a winner because  would be thrown away by SFINAE
p30055
aVThe clear separation of name lookup and overload resolution and template argument deduction does not allow such intermingling
p30056
as(dp30057
g15
V34509
p30058
stp30059
a((dp30060
g2
(lp30061
VYou need to build a parameter pack of numbers and unpack them
p30062
as(dp30063
g15
V34509
p30064
stp30065
a((dp30066
g2
(lp30067
VThe reason is that there is no special case for lambda-expression initializers of  variables
p30068
aVSuch special cases would be prone to errors and misuses
p30069
aVYou need to define the rules when you propose that something like  should work
p30070
aVHow is the  looked up
p30071
aVWhat is the precise state of 's type
p30072
aVWill the type be complete
p30073
aV(which implies that you already know the capture list of the lambda)
p30074
aVOnce you have formulated that in a format reasonable for a spec, it would be easier to make statements on it
p30075
aVAllowing your use case would mean yet another case where you need to scan ahead in code, because to determine the type of  in  you must be sure that the initializer ends with nothing that could "unlambda" the type
p30076
aVIn this case,  would call , not the lambda
p30077
aVAs it is now,  is simply forbidden to be mentioned in its entire initializer
p30078
aVBecause in C++,  is not a type
p30079
aVIt is merely a type specifier standing for a to-be-deduced type
p30080
aVAs a consequence, an expression can never have type auto
p30081
as(dp30082
g15
V34509
p30083
stp30084
a((dp30085
g2
(lp30086
VIn this case a function taking another function to simulate pass by name could work if you don't mind
p30087
as(dp30088
g15
V34509
p30089
stp30090
a((dp30091
g2
(lp30092
VSometimes it's useful
p30093
aVWithout the , in C++  would be  and have internal linkage (which means you could not use  from another translation unit)
p30094
aVThe  in both cases in your example is redundant
p30095
aVIn C99 an  can make a difference for  functions
p30096
as(dp30097
g15
V34509
p30098
stp30099
a((dp30100
g2
(lp30101
VFor  you have two constructors that can be used
p30102
aVSo overload resolution takes place and looks what function to take
p30103
aVwill have been deduced to zero as you figured out
p30104
aVSo the compiler compares constructing  against constructing a  temporary out of
p30105
aVConstructing  from  is straight forward and takes your declared constructor of
p30106
aVConstructing  from  also is straight forward and takes your constructor template (the copy constructor is not viable because it has only one parameter, but two arguments -  and  - are passed)
p30107
aVThese two conversion sequences are not comparable
p30108
aVSo the two constructors would be ambiguous, if it weren't for the fact that the first is a template
p30109
aVSo GCC will prefer the non-template, selecting the deleted copy constructor and will give you a diagnostic
p30110
aVNow for your  testcase, three constructors can be used
p30111
aVFor the two last, the compiler will prefer the third because it binds an rvalue to an rvalue
p30112
aVBut if you consider  against  you won't find a winner between the two parameter types because for  you can construct an  from a  and for  you can initialize a  temporary from a  by taking the  constructor (the Standard explicitly forbids user defined conversions for a parameter of a move or copy constructor to be usable for an initialization of a class  object from , since this could result in unwanted ambiguities; this is why the conversion of  to  is not considered here but only the conversion from  to )
p30113
aVBut this time, as opposed to your first testcase, neither constructor is a template so you end up with an ambiguity
p30114
aVThis is entirely how things are intended to work
p30115
aVInitialization in C++ is weird so getting everything "intuitive" to everyone is going to be impossible sadly
p30116
aVEven a simple example as above quickly gets complicated
p30117
aVWhen I wrote this answer and after an hour I looked at it again by accident I noticed I overlooked something and had to fix the answer
p30118
as(dp30119
g15
V34509
p30120
stp30121
a((dp30122
g2
(lp30123
VIf A and B are copy constructors and one of them was declared, any attempt to copy the objects should not drop to the template, is it right
p30124
aVA constructor that is not a copy constructor can still be used to copy objects
p30125
aVIn your case the constructor instantiated from the constructor template is used for copying the object
p30126
aVWhich is fine
p30127
as(dp30128
g15
V34509
p30129
stp30130
a((dp30131
g2
(lp30132
VIt has the drawback that it doesn't really work
p30133
aVThe base member function is not overridden, but it is just hidden by the derived class' function when you try to call it from outside
p30134
aVWhich means if you call  out of the base class (where presumably all your other functions live) it will call the base class  which is not what is wanted
p30135
aVThe accepted answer on that question shows multiple ways for how you can solve your problem
p30136
as(dp30137
g15
V34509
p30138
stp30139
a((dp30140
g2
(lp30141
VThe problem is that your  is not usable because the compiler cannot automatically find out what  is
p30142
aVYou can solve your problem by declaring a non-template
p30143
aVThe  declaration is then found by argument dependent lookup for  for the expression
p30144
aVAlternatively you can put the  definition inside the definition   (but this doesn't really matter in this case, since  is an associated class of )
p30145
as(dp30146
g15
V34509
p30147
stp30148
a((dp30149
g2
(lp30150
VOne meaning of asynchronous is that at a point where you emit an computation, you don't wait for an answer, but you get the answer later
p30151
aVThe answer comes in orthogonal to you normal control flow
p30152
aVOne way the answer comes in is using events: They happen spontaneously in this case, without your code triggering them
p30153
aVIn a handler you may process the result
p30154
aVWhereas the computation and answer is connected by the point in control flow for synchronous mode, you have to do the connection yourself in asynchronous mode
p30155
aVFor example by use of a sequence number or something
p30156
as(dp30157
g15
V34509
p30158
stp30159
a((dp30160
g2
(lp30161
VYes that is valid
p30162
aVWithin unevaluated operands (operands of , , ,
p30163
aVyou can name nonstatic data members also outside of member functions
p30164
aVThose compilers you tried just don't support this feature yet
p30165
as(dp30166
g15
V34509
p30167
stp30168
a((dp30169
g2
(lp30170
VHere is how it can work
p30171
aVThis works even though  has no working copy or move constructor and no other constructor that could copy or move an
p30172
aVTo make use of this feature of C++11, the constructor (taking  in this case) has to be non-explicit though
p30173
as(dp30174
g15
V34509
p30175
stp30176
a((dp30177
g2
(lp30178
VIt works for any expression whose type is an array
p30179
aVFor example:
p30180
aVFor a more detailed explanation, if the type of the expression passed to the right of  is an array type, then the loop iterates from  to  ( pointing to the first element of the array,  being the element count of the array)
p30181
aVThis is in contrast to user defined types, which work by looking up  and  as members if you pass a class object or (if there is no members called that way) non-member functions
p30182
aVThose functions will yield the begin and end iterators (pointing to directly after the last element and the begin of the sequence respectively)
p30183
aVThis question clears up why that difference exists
p30184
as(dp30185
g15
V34509
p30186
stp30187
a((dp30188
g2
(lp30189
VIn C++, the term identifier is just a sequence of digits, letters and , not starting with a digit
p30190
aVSuch an identifier can appear anywhere, and doesn't have to identify anything, despite its name (no pun intended)
p30191
aVThe term name associates a meaning with a certain grammar construct
p30192
aVThe C++ spec says that one of the following grammar constructs is a name if it denotes an entity (an object, a class, a template and so on) or a label (where you can jump to with )
p30193
aVidentifier
p30194
aVtemplate-id (,  and , as in )
p30195
aVconversion-function-id (, as in )
p30196
aVoperator-function-id (, as in )
p30197
aVliteral-operator-id (, as in )
p30198
aVFor each of these constructs, the rule when a name is the same as another name is defined differently: For identifiers, two names are the same of the sequence is the same (this is only a lexical comparison)
p30199
aVFor names of form conversion-function-id they are the same if the type used is the same type (so this is a semantic comparison)
p30200
aVAs you can see in the example of literal-operator-id, the non-terminal identifier can appear in the grammar in places where it is not a name
p30201
aVSo not every identifier is a name, and not every name is an identifier
p30202
aVIn the example of template-id, we have a nested use of names
p30203
aVThe constructs before the  respectively are names again, as they denote declared templates
p30204
as(dp30205
g15
V34509
p30206
stp30207
a((dp30208
g2
(lp30209
VIt's not so much the performance of initialization that is a problem, but the order of initialization
p30210
aVIf someone uses your map before  has started (for example at initialization for a namespace scope variable), then you are SOL, because you are not guaranteed that your map has been initialized before the user's initialization uses it
p30211
aVHowever you can do this thing at compile time
p30212
aVString literals are constant expressions, as are enumerators
p30213
aVA simple linear-time complexity structure
p30214
aVIf you use  in a constant expression context, and the name you specify doesn't exist, you will get a compile time error because the function call would become non-constant
p30215
aVTo use  in a non-constant expression context, you better add safety features, like adding an end marker to your array and throwing an exception in  if you hit the end marker (the function call will still be a constant expression as long as you never hit the end marker)
p30216
as(dp30217
g15
V34509
p30218
stp30219
a((dp30220
g2
(lp30221
VNot everything about it is good, in my opinion
p30222
aVPeople, including compiler vendors, have been insulting it because of its sometimes unfortunate behavior
p30223
aVADL is responsible for a major overhaul of the for-range loop in C++11
p30224
aVTo understand why ADL can sometimes have unintended effects, consider that not only the namespaces where the arguments are defined are considered, but also the arguments of template arguments of the arguments, of parameter types of function types / pointee types of pointer types of those arguments, and so on and forth
p30225
aVAn example using boost
p30226
aVThis resulted in an ambiguity if the user uses the boost
p30227
aVrange library, because both  is found (by ADL using ) and  is found (by ADL using )
p30228
as(dp30229
g15
V34509
p30230
stp30231
a((dp30232
g2
(lp30233
VI dont think there is a
p30234
aVreason
p30235
aVNormal static datamembers are disallowed because there is no way to define them after being declared
p30236
aVAlso dont forget you can create a local const variable outside the
p30237
aVclass that you can use inside the class as long as you only read its value (that is, as long as you dont take
p30238
aVits
p30239
aVaddress)
p30240
as(dp30241
g15
V34509
p30242
stp30243
a((dp30244
g2
(lp30245
VFunction objects usually should be small so I don't think that passing them by value will suffer from performance noticably (compare it to the work the function does in its body)
p30246
aVIf you pass by value, you can also gain from code analysis, because a by value parameter is local to the function and the optimizer may tell when and when not a load from a data member of the functor can be omitted
p30247
aVIf the functor is stateless, passing it as argument implies no cost at all - the padding byte that the functor takes doesn't have to have any particular value (in the Itanium Abi used by GCC at least)
p30248
aVWhen using references, you always have to pass an address
p30249
aVThe last one () has the drawback that in C++03 that doesn't work for raw functions, because in C++03 the program is ill-formed if you try to apply  to a function type (and is an SFINAE case)
p30250
aVMore recent implementations instead ignore  when applied on function types
p30251
aVThe second one () has the obvious drawback that you cannot pass temporary functors
p30252
aVLong story short, I would generally pass them by value, unless I see a clear benefit in concrete cases
p30253
as(dp30254
g15
V34509
p30255
stp30256
a((dp30257
g2
(lp30258
VI've tried implementing this as above and get a linker error for every special type I try to explicitly instantiate
p30259
aVWhat does that mean
p30260
aVIf you explicitly specialize the template you cannot explicitly instantiate it anymore for the same template arguments
p30261
aVThe whole purpose of an explicit specialization is to prevent the instantiation of it (which is a generated specialization) in favor of your explicit specialization
p30262
aVSo your description does not make sense to me
p30263
aVJust remember that you need to put definitions of templates and member functions of class templates in the header instead of in the
p30264
aVcpp file if you want to instantiate them implicitly
p30265
aVAnd that explicit specializations need to be declared to everyone who uses their template with their arguments
p30266
as(dp30267
g15
V34509
p30268
stp30269
a((dp30270
g2
(lp30271
VBoth have internal linkage (the one in the unnamed namespace only in c++11) but the one in the unnamed namespace is  not a member of the global namespace
p30272
aVso for example you can put an x into the unnamed namespace and the global namespace and they will not conflict
p30273
as(dp30274
g15
V34509
p30275
stp30276
a((dp30277
g2
(lp30278
VHowever the class template specialization you pass to  can only have type template arguments
p30279
aVSo you cannot pass  for example
p30280
aVIt is not possible to do a fully generic , because you would have to enlist every possible template parameter list variety, and there are basically infinitely many
p30281
as(dp30282
g15
V34509
p30283
stp30284
a((dp30285
g2
(lp30286
VPerhaps because  in your example has external linkage so that it is emitted into your executable even if the call is inlined
p30287
aVFor the template, if the call is inlined there is no reason to emit an implicitly instantiated function template specialization
p30288
aVTry making  an  function or making it
p30289
aVIf you want to emit the function template specialization you need to explicitly instantiate it
p30290
aVDoing this, my measures give the exact same size for the non-template function and the function template version
p30291
as(dp30292
g15
V34509
p30293
stp30294
a((dp30295
g2
(lp30296
VThis code either yields 5 or 10 depending on the choice of evaluation oder of the function call relative to that of the left side of +
p30297
aVIts behavior is not undefined because a function call is surrounded by two sequence points
p30298
as(dp30299
g15
V34509
p30300
stp30301
a((dp30302
g2
(lp30303
VThis error message is given by GCC in the wrong order of both type names
p30304
aV(but it apparently fixed this in the latest version)
p30305
aVIt is meant to say that  was not found to be a type name
p30306
aVThe underlying cause of this diagnostic is that the code is parsed as an access-declaration, which has the following syntax
p30307
aVAn example of that syntax
p30308
aVIn C++11 this access-declaration construct was taken out of the specification and it was deprecated in C++03
p30309
aVBut since the compiler still supports parsing it, when the  is not found to be a type, it will be taken as a name to be declared in an access-declaration (so the parser moves forward across the type specifier section)
p30310
aVHence according to the above syntax, after the unqualified-id which in this case is  (and in my example was ), it wants to see a semicolon and it wants that  is a base class of , but confusingly the diagnostic it gives has it the other way around
p30311
aVCheck your names and make sure the type exists
p30312
as(dp30313
g15
V34509
p30314
stp30315
a((dp30316
g2
(lp30317
VA move constructor for a class X is implicitly declared as defaulted exactly when
p30318
aVX does not have a user-declared copy constructor,
p30319
aVX does not have a user-declared copy assignment operator,
p30320
aVX does not have a user-declared move assignment operator,
p30321
aVX does not have a user-declared destructor, and
p30322
aVthe move constructor would not be implicitly defined as deleted
p30323
aVSo for example, if your class has a class type data member that does not have a move constructor, your class will not get a move constructor even if it doesn't have any copy/move constructor declared, because the implicitly declared move constructor would be defined as deleted (because of that data member)
p30324
as(dp30325
g15
V34509
p30326
stp30327
a((dp30328
g2
(lp30329
s(dp30330
g15
V34509
p30331
stp30332
a((dp30333
g2
(lp30334
VYou can move the operator into the inner class body and put  before it
p30335
aVThen replace the parameter type by just
p30336
aVAnother technique is to derive inner from a CRTP base parameterized by inner
p30337
aVThen make the parameter type the CRTP class and cast the parameter reference to the derived  class, the type of which is given by the template argument you deduce
p30338
as(dp30339
g15
V34509
p30340
stp30341
a((dp30342
g2
(lp30343
VIt should be noted
p30344
aVthat   would then not be the call of an anonymous functor with argument 123  anymore but would declare a functor initialized by 123
p30345
aVAnd i think introducing such pitfalls for that little feature is not worth it
p30346
aVSince it may not be clear what the above means, let's take a deeper look
p30347
aVFirst remember that parentheses around a declarator are allowed, including for the degenerate case of being directly around a declared name:
p30348
aVBoth of the parenthesized versions are ambiguous, because the first could be an assignment and the second could be a function call
p30349
aVBut both could also be declarations
p30350
aVAnd the Standard says that they are declarations
p30351
aVIf we will allow paren-initializers in conditions, then we introduce the latter ambiguity into conditions too, just as for the statement case
p30352
aVThus we would make valid condition expressions that are used nowadays into declarations after the feature is supported
p30353
aVConsider
p30354
aVWhat you think will happen
p30355
aVOf course, it will never enter the  body, because it always declares a null pointer
p30356
aVIt never calls function
p30357
aVWithout the "feature" it will properly call , because we don't have the ambiguity
p30358
aVThis is not limited to only , but also  (declares a pointer),  (declares a reference) et al
p30359
aVAgain: Do we want such pitfalls as price for such a small feature
p30360
aVI don't know how many people even know they could declare stuff in a condition
p30361
as(dp30362
g15
V34509
p30363
stp30364
a((dp30365
g2
(lp30366
VDo you mean how to convert them to integers
p30367
aVYou cannot convert an array of characters into a function on the language level - perhaps you can with some compiler specific inline assembler syntax
p30368
aVFor doing a conversion into an integer you can use
p30369
aVOr
p30370
as(dp30371
g15
V34509
p30372
stp30373
a((dp30374
g2
(lp30375
VYou can use type traits and SFINAE
p30376
aVC++03 version that also works for C++11
p30377
aVThere is the C++11 version of moving the  into the template parameter list, using a default argument
p30378
aVSadly you then cannot overload  if the only difference of your other overload is the SFINAE string (i
p30379
aVe the default argument), because the default argument is not part of the signature of a function template
p30380
aVBut the type of the template parameters themselfs are (these rules are just like for normal function parameters)
p30381
as(dp30382
g15
V34509
p30383
stp30384
a((dp30385
g2
(lp30386
VIt is not the cast that instantiates the class template specialization, but the function call, because the argument triggers ADL
p30387
aVThe instantiation is done because the completeness of it may affect the semantics of the program
p30388
aVThat clang does not follow the spec here is known and a PR was sent by me some time ago
p30389
aVSee http://llvm
p30390
aVorg/bugs/show_bug
p30391
aVcgi
p30392
aVid=9440
p30393
as(dp30394
g15
V34509
p30395
stp30396
a((dp30397
g2
(lp30398
VThis diagnostic is given if you use the name
p30399
aVThis name does not denote the class  but its constructor(s)
p30400
as(dp30401
g15
V34509
p30402
stp30403
a((dp30404
g2
(lp30405
VIn c++03 it was not ignored, but illformed (and was an sfinae case)
p30406
aVI guess they changed that in c++11 because then you can simply have function parameters be  and can pass to it rvalue function objects aswell as normal functions
p30407
aVSee this DR which made the change http://www
p30408
aVopen-std
p30409
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p30410
aVhtml#295
p30411
as(dp30412
g15
V34509
p30413
stp30414
a((dp30415
g2
(lp30416
VYes in the description of the + operator
p30417
aVYou may not dereference that pointer in C because it is a past the end pointer for the first subarray
p30418
aVIn C++ this currently is legal because the pointer points to a valid integer (the points to relation is defined somewhere in clause 3)
p30419
aVHowever in both standards adding more than 50 yields undefined behavior
p30420
aVA DR was recently sent to the c++ committee about the rule that dereferencing such "valid out of thin air" pointers may be dereferenced, so i would not rely on that
p30421
as(dp30422
g15
V34509
p30423
stp30424
a((dp30425
g2
(lp30426
VYes you could overload operator new for a nonvoid pointer
p30427
aVThe cast ensures that the void pointer overload is taken
p30428
aVFor example
p30429
as(dp30430
g15
V34509
p30431
stp30432
a((dp30433
g2
(lp30434
VThe reason is because you cannot initialize a unique_ptr with another unique_ptr without doing a user defined conversion (to rv, by passing the rvalue to the rv-taking constructor of unique_ptr)
p30435
aVHowever when not explicitly calling the ctor of  (as in ), you do a copy initialization which in your case first successfully constructs a rvalue temporary unique_ptr but then fails to copy that temporary into the return value target object,  because in that copy, no user defined conversions are allowed (this is also known as the principle rule "no two user defined conversions in an initialization")
p30436
aVMsvc allows the copy to use the ctor taking a nonconst unique_ptr reference, which is nonstandard
p30437
aVWhen doing copy initialization of a class from an object of the same class, there is no such two-step initialization
p30438
aVThe source object is just passed to the non-explicit constructors of , which will convert it to  using the rv-taking constructor, and by that way successfully construct the return value target object
p30439
aVFor the same reason, there is no implicit conversion from  to
p30440
aVIn the first step, a  will be successfully created, but then when copying that temporary into the  target object, the restriction that no user defined conversions can be used prevents success
p30441
as(dp30442
g15
V34509
p30443
stp30444
a((dp30445
g2
(lp30446
VWith unnamed namespaces you cannot give a variable internal linkage within the same namespace you are currently in
p30447
aVWith , you can
p30448
aVFor example, the following use of unnamed namespaces does not give a global variable internal linkage
p30449
aVHad the first  been declared as , the attempt to declare a second  at global scope would have been an error immediately because the first  already exists at global scope
p30450
aVSo to achieve their job of making identity unique, unnamed namespaces place entities into different namespaces (in addition to affecting their linkage)
p30451
aVonly affects the linkage, leaving the namespace of which functions and variables are a member of unchanged
p30452
as(dp30453
g15
V34509
p30454
stp30455
a((dp30456
g2
(lp30457
VThis is invalid because you cannot explicitly specialize a member function without also giving fixed template arguments to any enclosing class template
p30458
aVNot C++11 compatible, but working on MSVC
p30459
aVThe Microsoft compiler has an extension that allows to declare explicit specializations within class templates though
p30460
aVEven though I have never tried it, chances are good that it will accept the following non-standard code
p30461
aVUpdate: Clang compiles this and reports
p30462
aVC++11/C++03 compatible
p30463
aVThe way here is overloading instead of specialization
p30464
as(dp30465
g15
V34509
p30466
stp30467
a((dp30468
g2
(lp30469
VYes that is true
p30470
aVBut it is not necessarily when control flows through the closing brace
p30471
aVIt can be because of a return, an exception or a goto out of its block
p30472
aVHowever care should be taken when calling exit() to terminate the program
p30473
aVThe local automatics like your unique ptr will no be destroyed then
p30474
as(dp30475
g15
V34509
p30476
stp30477
a((dp30478
g2
(lp30479
VYour question is not technically precise
p30480
aVA signature is not something you pass as argument
p30481
aVI try my best to make sense of your question
p30482
aVThe following function objects can be passed as argument to each other
p30483
as(dp30484
g15
V34509
p30485
stp30486
a((dp30487
g2
(lp30488
VI suppose the simplest thing is to declare all 6 constructors (int, long, long long, and their unsigned variants), instead of using intptr_t
p30489
as(dp30490
g15
V34509
p30491
stp30492
a((dp30493
g2
(lp30494
VI'm sorry, your code is not syntactically valid
p30495
aVand  should be declaration names
p30496
aVLike  and
p30497
aVTo use the comma operator, you have to parenthesize
p30498
aVI will forgive you this accident and continue to explain
p30499
aVIf you use the comma operator, which is used as , it will give you the value (or lvalue) of
p30500
aVSo you initialize  to  (as in , since the comma operator is left associative)
p30501
as(dp30502
g15
V34509
p30503
stp30504
a((dp30505
g2
(lp30506
VA template argument can be a function pointer only if the parameter is a non-type parameter
p30507
aVBut sadly C++11 does even not yet allow to use the full variety of constant expressions to compute a template argument
p30508
aVFor a non-type pointer or reference, you are only allowed to pass the value of another template parameter or the directly obtained address of the function or object, without storing it first in a  /  variable
p30509
aVThis limitation will most probably be lifted for next C++ revision
p30510
as(dp30511
g15
V34509
p30512
stp30513
a((dp30514
g2
(lp30515
VWhen you now do , and at some place  is actually defined as an array (instead of as a pointer like above), then it will try to interpret the contents of the array as an address
p30516
aVSo for example in another file/another translation unit we defined at as
p30517
aVLet's assume that  has all bits zero
p30518
aVThen the  operation on the  above would try to dereference a pointer address having all bits zero
p30519
aVOn most boxes, that will crash
p30520
aVAnd on the remaining others it would result in random nonsense
p30521
as(dp30522
g15
V34509
p30523
stp30524
a((dp30525
g2
(lp30526
s(dp30527
g15
V34509
p30528
stp30529
a((dp30530
g2
(lp30531
s(dp30532
g15
V34509
p30533
stp30534
a((dp30535
g2
(lp30536
VThere might be differences with  and  being invoked in the one and other case respectively (You would need to check the spec and the DRs that modified/fixed that part of the spec)
p30537
aVWhat definitely is different is  for both cases
p30538
as(dp30539
g15
V34509
p30540
stp30541
a((dp30542
g2
(lp30543
VBecause in the nontemplate foo, you are doing a valid multiplication operation (assuming you declared  before that use)
p30544
aVTry to omit the star, and you will get a compiler error
p30545
aVThe int hides the class
p30546
aVThe typename keyword does not prevent that hiding
p30547
aVOnly gcc implements it incorrectly to do so
p30548
aVSo if you try to instantiate your function template with  as the type, then you will get a compile error, because the name specified afteer typenake will refer to a nontype on any standard conformant compiler
p30549
as(dp30550
g15
V34509
p30551
stp30552
a((dp30553
g2
(lp30554
VThat leeway wording doesnt mean that any and everything in c99 is in c++11
p30555
aVWhat you quoted is just introductory text
p30556
as(dp30557
g15
V34509
p30558
stp30559
a((dp30560
g2
(lp30561
VThere is nothing in the c spec that says why this is invalid
p30562
aVThe spec is the wrong place to clarify that
p30563
aVFWIW it is allowed in C1x (according to an answer i received to one of my last questions)
p30564
aVI suppose that this c1x feature supports transforming macros to typedefs (the former are allowed to be repeated if identically)
p30565
as(dp30566
g15
V34509
p30567
stp30568
a((dp30569
g2
(lp30570
VI think we can do this in C++ using lambdas
p30571
aVIt should be easy to wrap this up in a macro
p30572
as(dp30573
g15
V34509
p30574
stp30575
a((dp30576
g2
(lp30577
Vis the thing you passed to the constructor, and  is deduced from that argument
p30578
aVis  part of the smart pointer type and provides type checking when you pass the  around
p30579
aVwill completely erase any type information at compile time
p30580
aVWhile if you use  you completely preserve any type information (unless you would pass the constructor a class derived from , in which case of course some information is again erased)
p30581
aVShared ptr remembers the  passed to its constructor and using virtual calls or equivalent mechanisms it is able to call correct destructors when all Shared ptr copies die
p30582
as(dp30583
g15
V34509
p30584
stp30585
a((dp30586
g2
(lp30587
VThis is not valid C++11 code, because a constexpr function must only contain a return statement
p30588
aVThis is incorrect
p30589
aVin a  function are fine
p30590
aVWhat is not fine is using function parameters in constant expressions, like you do it
p30591
aVYou could throw if
p30592
aVCalling the function in a context that requires a constant expression will then fail to compile
p30593
as(dp30594
g15
V34509
p30595
stp30596
a((dp30597
g2
(lp30598
VI will put a mail copy of a possible DR I recently sent out on Christmas here
p30599
aVIs the following code well formed
p30600
aVThe several compilers that I tested (clang, g++ and comeau conline)
p30601
aVaccept this
p30602
aVIndeed 12
p30603
aV1 does not forbid this ( is a name of that
p30604
aVclass and is not a typedef-name), but 8
p30605
aV3p1 says
p30606
aVAn unqualified-id occurring in a declarator-id shall be a simple
p30607
aVidentifier except for the declaration of some special functions (12
p30608
aV3,
p30609
aV12
p30610
aV4, 13
p30611
aV5)
p30612
aVA constructor is a special member function, but the list of cross
p30613
aVreferences does not include 12
p30614
ag2790
aVDoes that mean that the above code
p30615
aVis ill-formed
p30616
aVOr is this an accidental omission
p30617
aVIf you do the same in an out-of-line definition, you will try to pass template arguments to a constructor
p30618
aVThis is valid code
p30619
aVThe spec says that when the injected class name is used in a qualified name when looking into the scope of the class (just as in ), then when name lookup accepts function/constructor names, the injected class name reference will be translated to be resolved to the constructor(s) of that class (if the name lookup context only accepts types, then the name will remain the injected class name, and will denote the class type)
p30620
aVAfter , name lookup is complete and yields the constructor
p30621
aVThe  can then only be parsed as a template argument list
p30622
aVIf there is no template among your constructors, your code will be invalid
p30623
as(dp30624
g15
V34509
p30625
stp30626
a((dp30627
g2
(lp30628
VYes, that is prohibited
p30629
aVJust as otherwise you cannot declare variables of differing types in one declaration statement (edit: modulo the declarator modifiers that @MrLister mentions)
p30630
aVYou can declare structs
p30631
aVC++03 code:
p30632
aVOf course when all are , you can omit the initializers altogether and write
p30633
as(dp30634
g15
V34509
p30635
stp30636
a((dp30637
g2
(lp30638
VSince  is actually a struct, the fully braced version needs  (the inner ones are for the array member of the  object)
p30639
aVThe spec does not allow brace elision here
p30640
aVIt only allows it in a declaration of the form
p30641
aVSo you have to use fully braced syntax
p30642
aVThis is not a GCC bug, but required by the spec
p30643
as(dp30644
g15
V34509
p30645
stp30646
a((dp30647
g2
(lp30648
VAs per my knowledge, board (i
p30649
aVe) array name represents the address of the first subarray (i
p30650
aVe) board[0]
p30651
aVThis is only true if  is used outside of these contexts
p30652
aVAs operand of the  operator
p30653
aVAs operand of
p30654
aVWhen any of that applies, expression  represents the array and keeps having the type of the array ()
p30655
aVApplying the  operator to it results in getting the address of the array, which of course equals the address of its first element, merely having a different type ( instead of )
p30656
aVThe same that is true about the array  is true about its first sub array
p30657
aVWhen you use it outside of those contexts, you get the address of the first element (subarray in your case)
p30658
aVThat address is not an object but just a value
p30659
aVValue have no address, but objects have
p30660
aVTrying to apply  on it would fail
p30661
aVFor example
p30662
aVNote that anything said above applies to C; not necessarily to C++
p30663
as(dp30664
g15
V34509
p30665
stp30666
a((dp30667
g2
(lp30668
VYes we can implement it
p30669
aVThis requires that you pass a function to
p30670
aVTo prevent overload to pick this up for something other than a plain function, you can SFINAE it
p30671
aVYou cannot pass it class type function objects though and no member pointers
p30672
aVFor arbitrary function objects there is no way to obtain a call signature (what would you do if the respective  is a template
p30673
aVThis probably is the reason that C++11 provides no such facility
p30674
as(dp30675
g15
V34509
p30676
stp30677
a((dp30678
g2
(lp30679
VLet's make it clearer what happens
p30680
aVYou forgot a  in your
p30681
as(dp30682
g15
V34509
p30683
stp30684
a((dp30685
g2
(lp30686
VThe  and  modifiers are not exactly like  and
p30687
aVThe latter two can be put on any integer type, but if you leave them off, then  is the default for each integer type (except )
p30688
aVSo  and  are the same type
p30689
aVFor  and , if you leave them off, neither is chosen, but the resulting type is different
p30690
aV,  and  are all different types, with  <=  <=
p30691
aVThe  after , ,  and  is optional:  and  are the same type
p30692
as(dp30693
g15
V34509
p30694
stp30695
a((dp30696
g2
(lp30697
VNo, first you need to actually access the  typedef of , and second, your code will not work because your members are not templates
p30698
aVOne of them always will end up being an invalid declaration
p30699
aVAfter applying the necessary  fix, your code will fail when instantiating , long before you try to call the member
p30700
aVMake your members member templates, and make the  depend on a parameter of the member template, instead of on a parameter of the enclosing class template
p30701
as(dp30702
g15
V34509
p30703
stp30704
a((dp30705
g2
(lp30706
VDefault template arguments are not part of the signature of function templates
p30707
aVBut the type of template parameters is
p30708
aVSo you can do the following and be able to overload it
p30709
as(dp30710
g15
V34509
p30711
stp30712
a((dp30713
g2
(lp30714
V is initialized by a constant expression and  is a POD type (C++03 terms, but C++11 it is analogous, but with different terms and way more allowed cases)
p30715
aVSuch an initialization is done in static initialization phase, and the static initialization phase has no issue of order
p30716
aVIt happens before any dynamic initialization
p30717
aVis initialized in the dynamic initialization phase
p30718
as(dp30719
g15
V34509
p30720
stp30721
a((dp30722
g2
(lp30723
VYour whole assumption is wrong
p30724
aVYou don't need that feature
p30725
aVThe thing after  is a type, not a constructor reference
p30726
as(dp30727
g15
V34509
p30728
stp30729
a((dp30730
g2
(lp30731
VIn other words, are template aliases a deduced context or a non-deduced context
p30732
aVThey are as deducible as the equivalent code without using template aliases
p30733
aVFor example
p30734
aVNow you can call  and  will be deduced perfectly fine
p30735
aVAt the definition time of  already,  is replaced by type
p30736
aVAnd  is a deduced context
p30737
aVIn your case  is replaced by , and that is a non-deduced context for , so  cannot be deduced
p30738
as(dp30739
g15
V34509
p30740
stp30741
a((dp30742
g2
(lp30743
VAn union is a container of its members
p30744
aVI would use  and  to give back iterators to the first and after-the-last members, respectively
p30745
aVThe list of types is not IMO the primary iterable property of an union
p30746
aVSo I would myself use the following, and reserve the plain  and  for the member data itself
p30747
as(dp30748
g15
V34509
p30749
stp30750
a((dp30751
g2
(lp30752
VBecause noone has thought it would be worth to have this feature
p30753
aVThe design of variadic template was intended to be simple and working
p30754
aVOther potentially advanced and useful features werent included either
p30755
as(dp30756
g15
V34509
p30757
stp30758
a((dp30759
g2
(lp30760
VWhen rendering a widget, the widget background is always drawn
p30761
aVThere is a special render flag to disable rendering of the widget background
p30762
aVIt is explained in the manual of the qwidget api
p30763
as(dp30764
g15
V34509
p30765
stp30766
a((dp30767
g2
(lp30768
VIt is not undefined behavior
p30769
aVThe reason depends on two facts, both are sufficient for giving defined behavior
p30770
aVA function call and termination is a sequence point
p30771
aVThe '&&' operator is a sequence point
p30772
aVThe following is defined behavior too
p30773
aVHowever, you don't know whether  evaluates to  or , because either the first or the second operand of  can be evaluated first
p30774
aVThat's not important for the behavior of this code to be defined, though
p30775
as(dp30776
g15
V34509
p30777
stp30778
a((dp30779
g2
(lp30780
VThe benefit is that you have
p30781
aVless to type
p30782
aVBut the drawback is that you are only allowed to leave off braces when the declaration has that form
p30783
aVIf you leave off the , or if the array is a member and you initialize it with , you cannot only pass one pair of braces
p30784
aVThis is because there were worries of possible overload ambiguities when braces are passed to functions, as in
p30785
aVBut it caused some discussion and an issue report has been generated
p30786
aVEssentially, the  initialization always has been able to omit braces, as in
p30787
aVThat's not new
p30788
aVWhat is new is that you can omit the , but then you must specify all braces
p30789
as(dp30790
g15
V34509
p30791
stp30792
a((dp30793
g2
(lp30794
VAlternatively
p30795
as(dp30796
g15
V34509
p30797
stp30798
a((dp30799
g2
(lp30800
VYour "trick" has one big problem
p30801
aVTry calling  and you will see that return , because ADL will look into both the namespaces of  and  (because of )
p30802
aVIgnoring that problem, with using your functions it is straight forward
p30803
aVThat calls  depending on whether it is in family2 or family1
p30804
aVThat one has also a generic fallback
p30805
aVAnd your code had undefined behavior because you used a reserved name
p30806
aVDon't use
p30807
as(dp30808
g15
V34509
p30809
stp30810
a((dp30811
g2
(lp30812
VYour code is invalid C++11, because the class is not consider complete in the return type of a member function
p30813
aVYou can only access members that have previously been declared
p30814
aVLike so
p30815
aVModulo that, yes using  is valid in C++11 in a trailing return type
p30816
as(dp30817
g15
V34509
p30818
stp30819
a((dp30820
g2
(lp30821
VIt uses the default constructor because list initialization with  is meant to be a short form of value initialization always, disregarding of other constructors, even if they are initializer list constructors
p30822
aVIs there anyway to differentiate the following two constructions:
p30823
aVThe  is always value initialization, while  is only value initialization if  has a default constructor
p30824
aVIf it is an aggregate, then  is aggregate initialization (initializing the members of  by a  recursively)
p30825
aVIf it only has initializer list constructors and no default constructors, then  is invalid and  could be valid
p30826
aVEssentially, what  does depends on what  is
p30827
aVBut  always value initializes
p30828
aVor return X(); vs return {};
p30829
aVSomething subtle to mention
p30830
aVIn  the target is copy-list-initialized, while in  first direct-initializes an
p30831
aVBut even though it is copy-list-initialized, it can use an  default constructor, because value initialization doesn't care about
p30832
aVHowever when you do  and you try to use an explicit non-default constructor you will error out
p30833
as(dp30834
g15
V34509
p30835
stp30836
a((dp30837
g2
(lp30838
VYes, declare it without a prototype
p30839
aVNow you can assign any function that returns , but also can pass any argument and the compiler is not required to reject incompatible arguments
p30840
as(dp30841
g15
V34509
p30842
stp30843
a((dp30844
g2
(lp30845
Vis like a keyword in C++ and is an alternative spelling for the  token
p30846
aVYou cannot use it as the name of a function
p30847
as(dp30848
g15
V34509
p30849
stp30850
a((dp30851
g2
(lp30852
VIt depends on their lifetime
p30853
aVTemporaries you create inside of a function that you dont bind to a local static reference to lengthen their lifetime will most likely be created on the stack
p30854
aVTemporaries you bind to local static references will most likely be stored in the
p30855
aVdata section of your program binary
p30856
aVSame holds for temporaries you bind to nonlocal references
p30857
aVTemporaries that are created during initialization of a nonlocal variable other that the one bound to by a reference should be on the stack of the function that produces the value of that nonlocal variable
p30858
aVException objects that represent the thrown object during unwinding are temporaries too
p30859
aVThose usually reside on the heap
p30860
as(dp30861
g15
V34509
p30862
stp30863
a((dp30864
g2
(lp30865
VThe correct way to go about this is
p30866
aVYou cannot omit braces when you initialize a member with aggregate initialization
p30867
aVThe only time you can omit braces is in a declaration of the form
p30868
aVSo in your case you have to type out all braces: One for the  itself, and one for the  array
p30869
aVFor , your syntax is correct too, since  can be converted to  implicitly
p30870
aVFrom the remaining commented ones, the ,  and  work too, but are more wordy
p30871
aVHowever conceptionally the  one produces the least amount of temporaries on implementations that don't do copy elision (I guess that's irrelevant, but still good to know), even less than the  one, because instead of copy initialization you use copy list initialization for your , which doesn't produce an intermediary temporary by design
p30872
as(dp30873
g15
V34509
p30874
stp30875
a((dp30876
g2
(lp30877
VIt's some implementation dependent value
p30878
aVImplementations may just crash or do something other silly thing if you exceed the number of arguments
p30879
aVActual C++11 implementations use variadic templates here (VC++ does not have that feature yet), so their limits should be more than enough for everyone
p30880
aVThis is one case of undefined behavior, exceeding implementation limits
p30881
aVNo different than you having a 1TB file trying to feed into the compiler and it running out of memory
p30882
as(dp30883
g15
V34509
p30884
stp30885
a((dp30886
g2
(lp30887
VChances are that you get compile time errors, because  is not a perfect forwarding vehicle
p30888
aVOnly  is
p30889
aVSo your  parameter only accepts rvalues
p30890
aVAnd in addition to that, your  should be , but of course now that you have the other error anyway this is irrelevant
p30891
aVAnd in addition to that the call to  misses to hit a base case of  with zero parameters, because if  is empty
p30892
aVIf you really only want to accepts pointers, you can work with  and  or
p30893
aVBut then of course I don't think it's "forwarding" anymore
p30894
aVWhat about
p30895
aVThat way you let  decide whether or not it accepts the argument (if you want you can put the recursive call into that  too
p30896
aVI leave it as an exercise to the reader as to what operator might be needed here)
p30897
aVBut of course  has the same problem too about not being generic
p30898
as(dp30899
g15
V34509
p30900
stp30901
a((dp30902
g2
(lp30903
VConceptually copy-list-initialization is the conversion of a compound value to a destination type
p30904
aVThe paper that proposed wording and explained rationale already considered the term "copy" in "copy list initialization" unfortunate, since it doesn't really convey the actual rationale behind it
p30905
aVBut it is kept for compatibility with existing wording
p30906
aVA  a pair/tuple value and should not be able to copy initialize a , because a string is not a pair
p30907
aVExplicit constructors are considered but forbidden to be used
p30908
aVThis makes sense in cases as follows
p30909
aVdoes not convey the value of a string
p30910
aVSo this results in an error because both constructors are considered, but an  constructor is selected, instead of the  being treated as a null pointer constant
p30911
aVUnfortunately this also happens in overload resolution across functions
p30912
aVThis is ill-formed too because of an ambiguity
p30913
aVSome people (including me) before C++11 was released thought that this is unfortunate, but didn't came up with a paper proposing a change regarding this (as far as I am aware)
p30914
as(dp30915
g15
V34509
p30916
stp30917
a((dp30918
g2
(lp30919
VYour submission should consist of exactly two declarations as described above, separated by whitespace
p30920
aVI don't see that your member declarations are separated by whitespace
p30921
aVYour second "solution" is wrong because that's invalid C syntax (at least C89/C99)
p30922
as(dp30923
g15
V34509
p30924
stp30925
a((dp30926
g2
(lp30927
VShould you really need  in , for example when you have an  member in , you can still make the use of  depend on
p30928
aVThen you only need the full definition of  when the member function of the template is actually called
p30929
aVNow the user of  can include the header of  if he wishes to call that member function
p30930
aVNo need to include  within  now anymore
p30931
aVBut this complication is only needed or useful if
p30932
aVYou cannot omit including  within , or
p30933
aVYou don't want users that don't call  to have  included automatically ("name pollution")
p30934
as(dp30935
g15
V34509
p30936
stp30937
a((dp30938
g2
(lp30939
VIn C, you don't need to include A
p30940
aVOnly the other two headers need their include directives you put there
p30941
aVPut the definition of  into a  file where you can include  then
p30942
aVOnly the definition of  needs its parameter type to have a definition
p30943
as(dp30944
g15
V34509
p30945
stp30946
a((dp30947
g2
(lp30948
VSee 8
p30949
ag1037
aV5p9, which lays down the exact rules
p30950
aVFor a  definition, implementations are likely to accept incomplete parameter types too, retroactively (as was determined in a DR resolution by the C++ committee)
p30951
aVIn particular, there is no action done on parameters or return values in a non-defining function declaration
p30952
aVCopying of arguments to parameters is done in the context of the caller
p30953
aVAnd destruction of parameters is done in the context of the callee, in the function definition
p30954
aVDestruction of the return value is done in the context of the caller in a function call except if the call is the topmost expression or right operand of a topmost comma operator in a
p30955
aVThen no destruction happens because no temporary is created as a special case (to help SFINAE libraries)
p30956
as(dp30957
g15
V34509
p30958
stp30959
a((dp30960
g2
(lp30961
VC++ is a Standard that doesn't require an iterator know what container it belongs to
p30962
aVWe cannot change the Standard just because on one particular implementation a function can do its work without needing a particular parameter
p30963
as(dp30964
g15
V34509
p30965
stp30966
a((dp30967
g2
(lp30968
VIt looks like you want to use overloading
p30969
aVThis simple implementation will accept most if not all the functions you will try to pass
p30970
aVExotic functions will be rejected (like )
p30971
aVMore work will give you more genericity
p30972
as(dp30973
g15
V34509
p30974
stp30975
a((dp30976
g2
(lp30977
VThe  on pointers is a noop except for turning things to rvalues
p30978
aVIt sometimes is handy if you want to decay arrays or functions
p30979
aVNow  is an  and not an
p30980
aVIf you want to pass  or  to templates, this difference might become important
p30981
aVis not always equivalent, consider
p30982
aVThe last line is ill-formed, because adding anything to a pointer requires the pointer's pointed-to class type to be completely defined (because it advances by  bytes)
p30983
as(dp30984
g15
V34509
p30985
stp30986
a((dp30987
g2
(lp30988
VThat sounds like two totally unrelated things
p30989
aVPutting  at both the declaration in the class and the definition outside of the class is not needed
p30990
aVPutting it at one of the declarations is enough
p30991
aVIf you talk about adding  in a  file where a function is defined there, and that function is a  member, then you should not do that
p30992
aVPeople who call  functions must have their definitions visible to them
p30993
aVThe C++ Standard requires that
p30994
as(dp30995
g15
V34509
p30996
stp30997
a((dp30998
g2
(lp30999
VIt doesn't matter how you order them
p31000
aVYou can write funny stuff like
p31001
aVThe compiler doesn't care
p31002
aVThe Standard doesn't care either
p31003
as(dp31004
g15
V34509
p31005
stp31006
a((dp31007
g2
(lp31008
VIf this doesn't work then your compiler is at error
p31009
aVTwo expressions involving template parameters are considered equivalent if two function definitions containing the expressions would satisfy the one definition rule
p31010
aVThat's the most important rule to consider here (left out the details of "
p31011
aVYour two templates do not satisfy the ODR because their token sequences differ
p31012
aVTwo function templates are equivalent if they are declared in the same scope, have the same name, have identical template parameter lists, and have return types and parameter lists that are equivalent using the rules described above to compare expressions involving template parameters
p31013
aVSo your two templates define different templates and do not clash
p31014
aVYou could now check whether your templates perhaps are "functionally equivalent"
p31015
aVThey would be if for any possible set of template arguments, your  expression would always yield the same value
p31016
aVBut since that is not true for  and , this is not the case either
p31017
aVIf it would, then your code would be ill-formed, but without requiring a diagnostic (which effectively means "undefined behavior")
p31018
as(dp31019
g15
V34509
p31020
stp31021
a((dp31022
g2
(lp31023
VYes
p31024
aVFor example local nonstatic references have automatic storage duration and corresponding liifetime and can refer to objects that have longer lifetime
p31025
aVYes, dangling references are an example
p31026
aVAs long as such references are not used in any expressions when they become dangling, they are fine
p31027
aVThere is a special rule in clause 3 about this case
p31028
aVNames of objects, pointers and references automatically refer to the new object that reuses the storage under restricted conditions
p31029
aVI believe it is at the end of 3
p31030
ag14557
aVSomeone who has the spec handy please fill in the correct ref here
p31031
as(dp31032
g15
V34509
p31033
stp31034
a((dp31035
g2
(lp31036
VInstead of the one pair of braces you need two
p31037
as(dp31038
g15
V34509
p31039
stp31040
a((dp31041
g2
(lp31042
VBecause "i" is not "const int", i+9 is not a constant expression
p31043
aVThat makes it so that the initialization of "j" is dynamic
p31044
aVThe one of "u" is too
p31045
aVThe order of the dynamic initializations of "u" and "j" is undefined
p31046
aVSo you dont know which value will be used for "u"
p31047
aVIn your case you get the value of "j" that was the result of zero initialization but before it was dynamically initialized, so "j" was still zero
p31048
aVIf you make "i" a "const int" then you should get the correct value into "u", since "j" will then be initialized statically
p31049
as(dp31050
g15
V34509
p31051
stp31052
a((dp31053
g2
(lp31054
VYou have two errors
p31055
aVThe one error is what you spotted yourself
p31056
aVThe other error is that you try to access the member before it is declared
p31057
aVDeclare it before you use it (notice that the return type, even if it is specified in a trailing manner, cannot access members you declare later, unlike the function body)
p31058
aVSo the  that you term as a drawback of your workaround is not actually a drawback because the real way to code this still needs the member to be declare before you use it
p31059
as(dp31060
g15
V34509
p31061
stp31062
a((dp31063
g2
(lp31064
VThe  are hiding the name of the base class
p31065
aVTry
p31066
aVIf you are pedantic, then your partial specializations are incorrect
p31067
aVThe C++11 spec terms ambiguous two partial specializations of the form  and
p31068
aVThis was discussed and many people find it surprising, so some compilers do not implement that part of C++11
p31069
as(dp31070
g15
V34509
p31071
stp31072
a((dp31073
g2
(lp31074
VI'm sorry, I have to tell you that
p31075
aVIt is not possible
p31076
aVTake the macro, put it into a scary named header and protect it from your colleague's cleanup script
p31077
aVHope for the best
p31078
as(dp31079
g15
V34509
p31080
stp31081
a((dp31082
g2
(lp31083
VYour compiler probably does not correctly define the assignment operator as deleted
p31084
aVIn c++03 code with respect to implicitly declared special member functions, such an assignment within an unevaluated operand was fine even if the assignment would be illformed if it occurs in an evaluated operand
p31085
aVThe reason for that is because the asignment operator would never be implicitly defined but only implicitly declared thus never rising an error
p31086
aVSince that changed in c++11 and your assignment operator should be deleted automatically it appears to me that your compiler is at fault
p31087
as(dp31088
g15
V34509
p31089
stp31090
a((dp31091
g2
(lp31092
VWhatever you do, you are not compiling that code
p31093
aVIt has a syntax error
p31094
aVCheck your build system
p31095
as(dp31096
g15
V34509
p31097
stp31098
a((dp31099
g2
(lp31100
VThe reason for this is because C++ specifies that this is ambiguous
p31101
aVOverload resolution specifies that for , since  is not in scope, the argument list in that call is augmented by a contrived A object argument, instead of
p31102
aVOverload resolution does not exclude non-static member functions, but instead
p31103
aVIf the argument list is augmented by a contrived object and overload resolution selects one of the non-static member functions of T, the call is ill-formed
p31104
aVThis has recently been subject of extensive discussion both in the committee in context of core issue 1005
p31105
aVSee core issue 364 which considered changing this rule but didn't do so
p31106
as(dp31107
g15
V34509
p31108
stp31109
a((dp31110
g2
(lp31111
VIt will use non-const iterators if  is a non-const expression
p31112
aVYou could therefore say
p31113
aVAnd then
p31114
as(dp31115
g15
V34509
p31116
stp31117
a((dp31118
g2
(lp31119
VI think this is handled by http://www
p31120
aVopen-std
p31121
aVorg/jtc1/sc22/wg21/docs/cwg_active
p31122
aVhtml#1343
p31123
aVInitially my report was only about non-class initializers for namespace scope objects (see When exactly is an initializer temporary destroyed
p31124
aV, but the problem exists for aggregate elements just aswell if they are non-class
p31125
aVAnd as the additional recent note explains, even seems to exist for the entire aggregate initialization aswell, even if it is a class object, because then no constructor call happens that would enlargen the full-expression of the initializer
p31126
aVIf instead of  you would have used a class, and the initialization would be a constructor call, then that constructor call would be part of the same full expression that encloses the aggregate-ininitializer element, so that here the order would be OK and your code would be well-defined
p31127
as(dp31128
g15
V34509
p31129
stp31130
a((dp31131
g2
(lp31132
VPerhaps I'm alone but I think that this is not safe:
p31133
aVThe lifetime-lengthening rules apply only when the reference is initialized by an expression that directly refers to a temporary object
p31134
aVIn other words, the expression has carry the "temporary" attribute
p31135
aVIf you omit the , then for binding to the reference, the compiler will implicitly create a prvalue expression that refers to a temporary object which is initialized by the value  and lifetime lengthening then applies
p31136
aVBut if you mix rvalue references in between, the compiler has no way to know at compile time whether or not to lengthen the lifetime of the referred-to object
p31137
aVI therefor think that your code has undefined behavior, because you evaluate a dangling reference (even if only for taking its address)
p31138
as(dp31139
g15
V34509
p31140
stp31141
a((dp31142
g2
(lp31143
VThis is undefined behavior because at the point you define the member, the class is not yet completely defined
p31144
aVAt that point,  needs to be instantiated though, from the template  to a class  (to determine its size, among others)
p31145
aVWhen that instantiation happens, the Standard requires the class to be completely defined
p31146
as(dp31147
g15
V34509
p31148
stp31149
a((dp31150
g2
(lp31151
VIt means your class is not a literal type
p31152
aVThis program is invalid, because  is not a literal class type
p31153
aVBut  is a literal type
p31154
aVClang prints
p31155
aVIf you fix this and make the  constructor , my example snippet compiles
p31156
aVSimilar things may apply to your code
p31157
aVYou appear to not understand what  means
p31158
aVI recommend reading a book about it (if such a book exists already, anyway)
p31159
as(dp31160
g15
V34509
p31161
stp31162
a((dp31163
g2
(lp31164
VYour  parameter cannot be deduced, because the compiler cannot know that your  ends up denoting  again (and in fact, there are some specializations of it that by design don't do that
p31165
aVIt's called a "non-deduced context" for
p31166
aVIf  has only one parameter, there is no way (that I am aware of) to SFINAE out your partial specialization
p31167
as(dp31168
g15
V34509
p31169
stp31170
a((dp31171
g2
(lp31172
VThis is called designated initializers and is a C feature (supported since C99)
p31173
aVIt allows addressing array and structure/union elements directly, filling the gaps with default values
p31174
aVNow this results in  elements of , all initialized to zero followed by a sixth element of  with the 4th element of  initialized to 20
p31175
aVLike someone else suspected, this is not supported by C++
p31176
as(dp31177
g15
V34509
p31178
stp31179
a((dp31180
g2
(lp31181
VPerhaps like this
p31182
aVWithin , you can then say
p31183
aVIt should not give warnings about type inconsistency violations anymore now, because unlike in your code, this code does not contain variables that have different types in different files
p31184
as(dp31185
g15
V34509
p31186
stp31187
a((dp31188
g2
(lp31189
VClang is wrong to reject the partial specialization
p31190
aVTo know how to interpret the errormessage, you need to understand what clang diagnoses
p31191
aVIt means to diagnose a partial specialization whose arguments match exactly the implicit argument list of the primary class template ()
p31192
aVHowever the argument lists are differently so clang shall not diagnose it
p31193
aVIn particular this has nothing to do wheter the partial specialization matches more or less arguments
p31194
aVConsider
p31195
aVThe partial specialization here matches everything and not more that the primary template would match
p31196
aVAnd the argument lists of both templates are different so this partial specialization is valid, just like you'rs
p31197
as(dp31198
g15
V34509
p31199
stp31200
a((dp31201
g2
(lp31202
VThis is a GCC bug
p31203
aVThere is no error in your code
p31204
aVPlease file a bug report
p31205
as(dp31206
g15
V34509
p31207
stp31208
a((dp31209
g2
(lp31210
V is a class template, so you need to declare it as such in your friend declaration
p31211
aVIf you only want  to be a friend, you need to tell it that template argument, so then the friend declaration becomes
p31212
aVFor this to work, it needs to know that  exists as a class template, so you need to forward-declare it at the top of :
p31213
as(dp31214
g15
V34509
p31215
stp31216
a((dp31217
g2
(lp31218
VI would like to add to the useful answer @Vaughn provided
p31219
aVIn the template definition of , you have a non-defining member function declaration and also a defining member function declaration
p31220
aVBut that function definition and declaration is associated with the surrounding template , and not with the class  that will eventually be instantiated from it
p31221
aVIf you implicitly instantiate  from that template, for example by using the -operator (scope) on it, or by creating a variable definition having that type and so on, then declarations but not necessarily the definitions of all members are also implicitly instantiated
p31222
aVAll of them are associated with and members of
p31223
aVSo when you write your explicit specialization for , because you used  to look into the class , that class is being implicitly instantiated and with it all its member declarations
p31224
aVThe definition of  is only instantiated when it is required (for example when you call it)
p31225
aVThe explicit specialization you declared then redeclares the member function that was previously implicitly instantiated and provides a definition that is associated with
p31226
aVIt is a real function and cannot be safely defined in a header unless it is marked  - otherwise you risk "defined more than once" errors when you include its header multiple timrs
p31227
aVTo summarize what declarations and definitions exist for  and where they come from:
p31228
aVBy your template definition:
p31229
aVGenerated specialization by the compiler from
p31230
aVExplicit specialization by you of
p31231
aVIn particular, there is no generated definition of
p31232
aVIf there was, then your code would be ill-formed, without diagnostics required, because the generated definition would interfere with your explicit specialization that provided a definition for the same function
p31233
aVBut such a thing can only happen if you cause its instantiation before explicitly specializing it
p31234
aVSo if you move the explicit specialization definition into a  file (if you don't want to make it ), put an explicit specialization declaration, like @Vaughn demonstrated, into the header
p31235
as(dp31236
g15
V34509
p31237
stp31238
a((dp31239
g2
(lp31240
VLike @RMatin says
p31241
aVBut you could overload
p31242
aVSo that you can use the  idiom
p31243
as(dp31244
g15
V34509
p31245
stp31246
a((dp31247
g2
(lp31248
VYou need to make the  dependent on a template parameter
p31249
aVAs it is now, it is only dependent on the outer template parameter within the template definition
p31250
aVBut if you instantiate a class from the outer template, then your assignment operator template that is instantiated into that class is not dependent on a template parameter anymore because  will have been substituted already
p31251
aVJust introduce a dummy parameter equal to
p31252
aVUsing  in just one of theplaces within the  template arguments would suffice already, because that already makes the  dependent
p31253
aVHowever it is not the call to your  that was previously illformed but the declaration of it, which conflicts with the copy-assignment operator, so the  has little utility here
p31254
aVJust replace your code by
p31255
aVSince this  is a template, it will not conflict with the non-template overload
p31256
aVAnd also because it is a template, when you call it the compiler will prefer the non-template if  is
p31257
as(dp31258
g15
V34509
p31259
stp31260
a((dp31261
g2
(lp31262
VAfter this when you have a random  or  object, you can access the member that  points to
p31263
aVAfter the above initialization of , this would change
p31264
aVThink of  the same way as you think of  and : It's just another "pointer/reference-like tool" you can use in declarations to specify what the thing you declare is going to be
p31265
as(dp31266
g15
V34509
p31267
stp31268
a((dp31269
g2
(lp31270
VYou can pass an initializer list, which effectively disables deduction (but causes list-initialization of parameters which in this case of  has the same effect though):
p31271
aVBut in your case, if you call  you seem to want to call the second one, and if you call  you always seem to want to call the second one too, and only for  you want to call the first one, so you can always disable deduction for  by making the parameter a nondeduced context for it
p31272
as(dp31273
g15
V34509
p31274
stp31275
a((dp31276
g2
(lp31277
VGoing to collect rep
p31278
aVSee Where and why do I have to put the "template" and "typename" keywords
p31279
aVfor why the template keyword is needed
p31280
as(dp31281
g15
V34509
p31282
stp31283
a((dp31284
g2
(lp31285
VAn lvalue in C++ does not always refer to an object
p31286
aVIt can refer to a function too
p31287
aVMoreover objects do not have to be referred to by lvalues
p31288
aVThey may be referred to by rvalues, including for arrays (in C++ and C)
p31289
aVHowever in old C89, the array to pointer conversion did not apply for rvalues arrays
p31290
aVNow, an rvalue denotes no, limited or soon to be expired lifetime
p31291
aVA string literal however lives for the entire program
p31292
aVSo string literals being lvalues is exactly right
p31293
as(dp31294
g15
V34509
p31295
stp31296
a((dp31297
g2
(lp31298
VYou need to say
p31299
aVBecause the baseclass is dependent
p31300
aVSame for Execute, you need to qualify the call with the baseclass name in front:
p31301
aVOtherwise those unqualified names ignore the dependent base class
p31302
as(dp31303
g15
V34509
p31304
stp31305
a((dp31306
g2
(lp31307
VSee http://clang
p31308
aVllvm
p31309
aVorg/get_started
p31310
aVhtml
p31311
aVIf you intend to work on Clang C++ support, you may need to tell it how to find your C++ standard library headers
p31312
aVIf Clang cannot find your system libstdc++ headers, please follow these instructions:
p31313
aVgcc -v -x c++ /dev/null -fsyntax-only to get the path
p31314
aVLook for the comment "FIXME: temporary hack: hard-coded paths" in clang/lib/Frontend/InitHeaderSearch
p31315
aVcpp and change the lines below to include that path
p31316
as(dp31317
g15
V34509
p31318
stp31319
a((dp31320
g2
(lp31321
VBecause calculations are not done with types below int / unsigned int (char, short, unsigned short etc; but not long, unsigned long etc), but they are first promoted to one of int or unsigned int
p31322
aV"uint16_t" is possibly "unsigned short" on your implementation, which is promoted to "int" on your implementation
p31323
aVSo the result of that calculation then is "-15", which is smaller than 10
p31324
aVOn older implementations that calculate with 16bit, "int" may not be able to represent all values of "unsigned short" because both have the same bitwidth
p31325
aVSuch implementations must promote "unsigned short" to "unsigned int"
p31326
aVOn such implementations, your comparison results in "0"
p31327
as(dp31328
g15
V34509
p31329
stp31330
a((dp31331
g2
(lp31332
VYou shall not pass any template arguments to callsomeone, because you want to befriend a function template, and not a specialization of it (in other words, you want to befriend all specializations of it)
p31333
as(dp31334
g15
V34509
p31335
stp31336
a((dp31337
g2
(lp31338
VThe validator documentation says that it returns "Intermediate" from "validate" when the input is an arbitrary double but out of range
p31339
aVYou need to distinguish intermediate input and the final input the user wants to submit by use of a line edit control (e
p31340
ag774
aVby emitting the "returnPressed" signal)
p31341
aVIf the user typed "10000" that is still a valid intermediate input for a number between 0 and 100 because the user can prefix this input with "0
p31342
as(dp31343
g15
V34509
p31344
stp31345
a((dp31346
g2
(lp31347
VYou seem to be asking one implicit question and one explicit question
p31348
aVThe answer to your implicit question, "how to merge the const and nonconst versions", is as follows
p31349
as(dp31350
g15
V34509
p31351
stp31352
a((dp31353
g2
(lp31354
VThis should help you start
p31355
as(dp31356
g15
V34509
p31357
stp31358
a((dp31359
g2
(lp31360
VLike ildjarn is saying, this is undefined behavior
p31361
aVAnd the reason that this actually can fail on real implementations is that normal C++03 enums don't have a fixed underlying type
p31362
aVWhile your enum-class type always has "int" as its underlying type, a corresponding C++03 enum could have "short" as its underlying type, making the code not be layout compatible
p31363
as(dp31364
g15
V34509
p31365
stp31366
a((dp31367
g2
(lp31368
VWhat about
p31369
aVThen you can say
p31370
as(dp31371
g15
V34509
p31372
stp31373
a((dp31374
g2
(lp31375
VBoth your variants will move the string
p31376
aVThe second variant should be preferred because it will not default construct an empty string just to move assign it afterwards
p31377
aVCheck your testcase and then your compiler's bugzilla list
p31378
aVYou need to trace calls to both  (1st case) and  (2nd case) if you want to ensure for both cases that they move
p31379
as(dp31380
g15
V34509
p31381
stp31382
a((dp31383
g2
(lp31384
VYour code looks well-formed
p31385
aVIn a constructor body and destructor body, a class is considered to be a complete type
p31386
as(dp31387
g15
V34509
p31388
stp31389
a((dp31390
g2
(lp31391
VIt seems like this should work
p31392
aV@Potatoswatter had the good (IMO) remark that this may copy more than needed when the lists are of different size, and that using only iterators will be better since pop_front does more than actually needed
p31393
aVI think the following "fixes" the iterator one at the cost of more code
p31394
as(dp31395
g15
V34509
p31396
stp31397
a((dp31398
g2
(lp31399
VTry
p31400
as(dp31401
g15
V34509
p31402
stp31403
a((dp31404
g2
(lp31405
VIt looks like you want several overloads instead of specializations
p31406
aVUnfortunately you don't detail on what  is, but it seems it's just a type that has a member  defined
p31407
aVI would probably go like this
p31408
aVis a dependent call
p31409
aVA dependent call does ADL at definition and instantiation time and unqualified lookup only at definition time
p31410
aVThat's why  and the additional  overloads using it must be defined before the  type overloads instead of after them, or the result of resolution in the return type and body of the functions will be different since they are parsed at different times (bodies are late parsed after the class definition, and return types are parsed immediately)
p31411
aVYou can either make  a  function and make  be a literal class with a constexpr constructor initializing  appropriately, or you could apply  as follows
p31412
as(dp31413
g15
V34509
p31414
stp31415
a((dp31416
g2
(lp31417
VYour code is valid C++11, which defines that a toplevel function call that appears as a decltype operand does not introduce a temporary even when the call is a prvalue
p31418
aVThis rule specifically was added to make code as yours valid and to prevent instantiations of the return type  (if it is a class template specialization) otherwise needed to determine the access restrictions of a destructor
p31419
as(dp31420
g15
V34509
p31421
stp31422
a((dp31423
g2
(lp31424
VYou could make "T" provide this information
p31425
aVThen it becomes easy
p31426
aVAlternatively you can use friend function definitions
p31427
aVThen you can write
p31428
as(dp31429
g15
V34509
p31430
stp31431
a((dp31432
g2
(lp31433
VYou stumbled upon two bugs
p31434
aVThe first bug in GCC is that during the "perfect forwarding"-value category deduction, it thinks that  is an rvalue
p31435
aVBut  is actually an lvalue
p31436
aVSo instead of deducing  to , it should have deduced it to
p31437
aVThen reference collapsing would have yielded that lvalue reference as parameter type, instead of  like it incorrectly does with your GCC version
p31438
aVDuring the actual initialization of the parameter, it also incorrectly rejects initialization of rvalue reference parameter by the function lvalue (I don't remember what the state of the working draft was when GCC4
p31439
aV5 was released - but possibly the draft had it ill-formed back then)
p31440
aVFor function type expressions, the Standard allows to initialize an rvalue reference to function type with an lvalue of function type
p31441
aVResolving a template id to a function lvalue is quite convoluted, so it doesn't surprise me GCC got it wrong (see http://llvm
p31442
aVorg/bugs/show_bug
p31443
aVcgi
p31444
aVid=7505 and http://llvm
p31445
aVorg/bugs/show_bug
p31446
aVcgi
p31447
aVid=7505 for two examples of how many rules interact for seemingly simple things)
p31448
as(dp31449
g15
V34509
p31450
stp31451
a((dp31452
g2
(lp31453
VIn addition to what others say about the lambdas having unique types, you are not allowed to use  as the specifier in an array variable declaration
p31454
aVEven the following is ill-formed
p31455
as(dp31456
g15
V34509
p31457
stp31458
a((dp31459
g2
(lp31460
VRichard Smith (zygoloid) at the LLVM IRC channel had a short talk with me about this issue which is your answer
p31461
aVSo it seems that sometimes, Clang instantiates called function templates or member function of class templates but their instantiation is too late for the call to see, and at other cases it doesn't even instantiate them because it thinks it will never need them (unevaluated context)
p31462
as(dp31463
g15
V34509
p31464
stp31465
a((dp31466
g2
(lp31467
VIn addition to what others have been saying, the caller also need the return type to know what destructor it should invoke on the result (the return value may be a temporary)
p31468
aVUnfortunately it is not as easy as
p31469
aVAlthough GCC and Clang accept this
p31470
aVI need to recheck the spec to see whether that's actually correct
p31471
aVUpdate: The spec says
p31472
aVThe auto type-specifier signifies that the type of a variable being declared shall be deduced from its initializer or that a function declarator shall include a trailing-return-type
p31473
aVThis can be misleading when read fast, but this is implemented by GCC and clang to only apply to the toplevel declarator
p31474
aVIn our case, this is a pointer declarator
p31475
aVThe declarator nested in it is a function declarator
p31476
aVSo just substitute  for  and then the compiler will deduce the type for you
p31477
aVBy the way, you can always make this work manually, but it takes some trickery to make it work
p31478
as(dp31479
g15
V34509
p31480
stp31481
a((dp31482
g2
(lp31483
VDont do list operations before not having the element type declared movable
p31484
aVDefine any member function body that does so after the macro
p31485
as(dp31486
g15
V34509
p31487
stp31488
a((dp31489
g2
(lp31490
VIt is not 1, but it is output by ostream as 1 (bool) if you havent switched on boolalpha flag
p31491
aVostream has no special output operator for member pointers
p31492
as(dp31493
g15
V34509
p31494
stp31495
a((dp31496
g2
(lp31497
VQuestion #1: In C++03, is there was no way to specify a function conversion operator template
p31498
aVIt appears there was no way to resolve the template arguments (i
p31499
ag1992
aV, name them in a deduced context) in an acceptable function pointer type
p31500
aVYes, that is correct
p31501
aVQuestion #2: In C++11, can such a conversion be specified using a default template argument
p31502
aVIt can, and you can also use alias templates, but you cannot use such a conversion function template for creating surrogate call functions
p31503
aVYou can use it for converting your class object to function pointers in implicit conversions otherwise
p31504
aVWe also have alias templates
p31505
aVIt seems that alias substitution occurs before instantiation, given the example in 14
p31506
ag1014
aV7/2, where the declarations of process conflict
p31507
aVIn GCC 4
p31508
aV7, this code at least instantiates the declaration, but then it produces a bizarre "candidate expects 2 arguments, 2 provided" error
p31509
aVYes, this is https://groups
p31510
aVgoogle
p31511
aVcom/forum/
p31512
aVfromgroups#
p31513
aVtopic/comp
p31514
aVstd
p31515
aVc++/lXLFBcF_m3c (and caused closure of DR395), but even though such a conversion function template can work in cases like , it won't work for surrogate call functions, because there the conversion function needs to provide a fixed non-dependent type that the class object is converted to when the surrogate function is called, but a conversion function template does not provide such a type normally (weird things like  aside
p31516
aVI think that GCC may incorrectly generates the candidate  with the dependent types still there and try to call that candidate, thereby violating some invariant of it (which could explain the weird error message - possibly hitting an  unexpectedly somewhere)
p31517
as(dp31518
g15
V34509
p31519
stp31520
a((dp31521
g2
(lp31522
VStrictly speaking, clang is right because of 7
p31523
ag1037
aV3p15 of C++11(the using declaration of the inherited function template is ignored because it has the same name and parameters as a member function template of the derived class)
p31524
aVAlthough it is pretty clear that that paragraph is defective in not considering these nonconflicting declarations
p31525
aVYou can work it around by using something like   as the second parameter type in one of your templates
p31526
as(dp31527
g15
V34509
p31528
stp31529
a((dp31530
g2
(lp31531
VOthers explained why your code does not work
p31532
aVBut in general it is a very bad idea to write function templates that accept any argument type
p31533
aVThat's only asking for ambiguities
p31534
aVIf you have a list of "volume" types you want to have operator+ for, you can make them inherit a common base class, which you can then use as parameter type in your template
p31535
aVUnfortunately you have moved the argument copy into the body of the template this way, but if it can be inlined (for such a simple body, I would think that's no problem), that's not going to hurt performance
p31536
aVSo each volume class will be defined as
p31537
as(dp31538
g15
V34509
p31539
stp31540
a((dp31541
g2
(lp31542
VYou cannot do this
p31543
aVwants a string literal
p31544
aVYou have no way to assemble the semantic identity of  and  into the string literal
p31545
aVYou can hope that the compiler gives an easy to read backtrace of the template instantiation stack and gives you the value of  and  template parameters of the enclosing class template instantiation
p31546
aVOther people thought about this too, see http://comments
p31547
aVgmane
p31548
aVorg/gmane
p31549
aVcomp
p31550
aVcompilers
p31551
aVclang
p31552
aVdevel/5073 for example
p31553
as(dp31554
g15
V34509
p31555
stp31556
a((dp31557
g2
(lp31558
VDefault template arguments are not part of the signature of a template (so both definitions try to define the same template twice)
p31559
aVTheir parameter types are part of the signature, however
p31560
aVSo you can do
p31561
as(dp31562
g15
V34509
p31563
stp31564
a((dp31565
g2
(lp31566
VI think you are right
p31567
aVIt is not possible to reach the primary template
p31568
aVIf you would try and instantiate it before your partial specialization was defined, your program would be ill-formed; no diagnostic required
p31569
aVRecently there were thoughts about marking a partial specialization ill-formed if it isn't more specialized (by partial ordering rules) than the primary template
p31570
aVWhile your code causes no harm, people came up with another testcase where the partial specialization is not more specialized than the primary template:
p31571
aVFor the first parameter, the primary template is less specialized, but for the following parameter, the primary template is more specialized and the other way around vice versa
p31572
aVBy not specializing the first parameter in the partial specialization but keeping it variable, you could even make the partial specialization be less specialized than the primary template, which is kinda weird and not the purpose of partial specializations
p31573
as(dp31574
g15
V34509
p31575
stp31576
a((dp31577
g2
(lp31578
VThat wat variable declaration is a definition that should belong in a cpp file
p31579
aVIt is as if you would put your function bodies into the header
p31580
aVYou need to put extern before the wat declaration and copy your current declaration without the extern into one of the cpp files
p31581
as(dp31582
g15
V34509
p31583
stp31584
a((dp31585
g2
(lp31586
VThe identity of a partial specialization is its argument list passed to its template
p31587
aVTemplate type parameter names denote specific dependent types, whose identity includes their position in their template parameter list and the nesting depth of their template parameter list (i
p31588
ag1992
aVa member template's list is one more level nested than its enclosing template if the member template is a member of a class template)
p31589
aVThis makes sense because you need to mangle two function templates different that overload each other and differ only in their template parameter order
p31590
aVTheir instantiation behavior is different because their position directly correspond to the respective argument in a function template calls' template argument list
p31591
aVIf you reorder their the positions, the argument lists become different because different types are passed as arguments
p31592
aVSo you are not redefining partial specializations
p31593
as(dp31594
g15
V34509
p31595
stp31596
a((dp31597
g2
(lp31598
VThe spec says at 14
p31599
ag14557
ag976
aV5p9
p31600
aVIf P has a form that contains  or , then each argument  of the respective template argument list  is compared with the corresponding argument  of the corresponding template argument list of
p31601
aVIf the template argument list of  contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context
p31602
aVYour  unfortunately matches that pattern
p31603
as(dp31604
g15
V34509
p31605
stp31606
a((dp31607
g2
(lp31608
VIn addition to what others said, the trailing return type also allows to use , which is not otherwise allowed
p31609
aVIn the second declaration, we used the traditional style
p31610
aVHowever since  is not allowed at that position, the compiler does not implicitly use it
p31611
aVSo the  uses the statically declared type of  to determine what  overload of  it is going to call, which ends up being the non-const version
p31612
as(dp31613
g15
V34509
p31614
stp31615
a((dp31616
g2
(lp31617
VHope this helps
p31618
as(dp31619
g15
V34509
p31620
stp31621
a((dp31622
g2
(lp31623
VYou can employ
p31624
as(dp31625
g15
V34509
p31626
stp31627
a((dp31628
g2
(lp31629
VYou can return a class type that has  overloaded from your literal operator
p31630
aVThen you could write
p31631
as(dp31632
g15
V34509
p31633
stp31634
a((dp31635
g2
(lp31636
VThe second argument type is not , but some bind type, so the compiler is unable to deduce the  for the second function parameter
p31637
aVYou need to tell the compiler "You are OK with not finding a type for  in the second function parameter"
p31638
aVThis can be done by making the second parameter a non-deduced context
p31639
as(dp31640
g15
V34509
p31641
stp31642
a((dp31643
g2
(lp31644
VIn C++, we currently have defective rules for object lifetime, which prevents us to properly say that this is OK or not OK according to the Standard
p31645
aVTo demonstrate, the Standard says that an object of type  becomes alive if
p31646
aVstorage with the proper alignment and size for type T is obtained, and
p31647
aVif the object has non-trivial initialization, its initialization is complete
p31648
aVThe second bullet is never active for types like
p31649
aVWhat follows is that the following has undefined behavior
p31650
aVWhy
p31651
aVBecause you are reading a  object by the use of an int lvalue - this is not allowed by the aliasing rules
p31652
aVThis inconsistent/illogical definition of object lifetime currently is tried to be fixed by http://www
p31653
aVopen-std
p31654
aVorg/jtc1/sc22/wg21/docs/cwg_active
p31655
aVhtml#1116 , but until we have a sane definition, we can't say something definite
p31656
aVIn practice, I believe that the rules are, greatly simplified (which is meant to say - contains a lot of missing details needed to be used in practice), interpreted as follows
p31657
aVAn object of non-class type T becomes alive if
p31658
aVstorage with the proper alignment and size for type T is obtained, and
p31659
aVthe storage comes from a new-expression, variable or object non-union data member definition, or was created for a temporay object, or if not that,
p31660
aVa write by an lvalue of type  to that location has been done
p31661
aVThe last bullet would need to handle writes by a , when the object is non-volatile - does the object then become volatile too
p31662
aVAnd also needs to handle writes by  lvalues to  objects, and some more special cases - we probably don't want to change the type of the target location
p31663
aVThis mechanism provides the rules by which  can work
p31664
aVIf you write into one member, we bring an object of the type of the data member alive
p31665
aVIf the type of the other data member is aliasing compatible, we can still read that object by use of the other data members type, in my opinion, because I can find nowhere in the Standard that explicitly forbids it (the phrase that an union can store the value of only one member at a time is not such a rule - that situation is the same for every other plain variable - and still we can apply the aliasing rule to all of them
p31666
as(dp31667
g15
V34509
p31668
stp31669
a((dp31670
g2
(lp31671
VIt does what you tell it to do
p31672
aVSome people use it to pass an allocator environment and alignments
p31673
aVFor example in a language runtime I wrote I do
p31674
aVThe clang compiler associates allocated AST resources with an "ast context", so it does something like
p31675
aVThe arguments are all passed as a single argument list to an overloaded , with the size requested as a first argument prefixed before them
p31676
as(dp31677
g15
V34509
p31678
stp31679
a((dp31680
g2
(lp31681
VWhen a class is generated out of the class template and in that process declarations of the constructors are instantiated (not theiry body, but just their "signature"), the enable_if type is invalid and you get a compiler error
p31682
aVYou need to make the enable_if type depend on a template parameter of the constructor (make it a function template)
p31683
aVYour goal then works because the invalid type then is formed during deducing the function template parameter type when you use the constructor which will trigger an SFINAE case
p31684
as(dp31685
g15
V34509
p31686
stp31687
a((dp31688
g2
(lp31689
VThis is invalid and rejected by implementations because a typedef name is used in the elaborated type specifier
p31690
aVThe following is invalid too, because the Standard says that there must be a simple template id contained in the elaborated type specifier
p31691
aVComeau online and GCC both accept it, though
p31692
aVYou could apply a pervert workaround though to be fully Standards compliant
p31693
aVAt least I could not find it being invalid anymore on a quick glance over the spec
p31694
as(dp31695
g15
V34509
p31696
stp31697
a((dp31698
g2
(lp31699
VKeep the function prototype and cast the pointer in the function definition
p31700
aVIt will shut the compiler
p31701
as(dp31702
g15
V34509
p31703
stp31704
a((dp31705
g2
(lp31706
VIt can be legit and it depends on what the code does
p31707
aVFor example I have written code that jumps out of a catch block, and it's used in a language's runtime library (for simplicity, the code that uses the runtime library does not implement the itanium exception handling, but is implemented using longjmp/setjmp)
p31708
aVThe runtime library however, through the C++ exceptions, does use it; and a mechanism is needed to cleanly transfer control between them
p31709
aVI put this into a macro so that it's very convenient to write
p31710
aVThe  here is necessary to cleanup resources allocated during exception handling of the diagnostic exception
p31711
aVAs always, don't say "NEVER use this feature"
p31712
aVEvery use must be carefully thought about, instead
p31713
as(dp31714
g15
V34509
p31715
stp31716
a((dp31717
g2
(lp31718
VYou need to make the prefix string be there before the other strings
p31719
aVOne way is to change it to a C string
p31720
aVAnother way is to return the prefix from a function and use  where you previously used
p31721
aVAt last, just a hint: Names with all uppercase letters are used for macros only in most coding conventions, so I would avoid such names for variables and functions
p31722
as(dp31723
g15
V34509
p31724
stp31725
a((dp31726
g2
(lp31727
VAll of them are correct
p31728
aVWhitespace between operators, between names and operators etc is not relevant
p31729
aVDo it the way it is most readable to you
p31730
as(dp31731
g15
V34509
p31732
stp31733
a((dp31734
g2
(lp31735
VInitializations with  in the class body is not allowed
p31736
aVUse  or
p31737
aVUnfortunately since the respective constructor is  and  has an initializer list constructor, you need a functional cast to call the wanted constructor
p31738
aVAs an alternative you can use constructor initializer lists
p31739
as(dp31740
g15
V34509
p31741
stp31742
a((dp31743
g2
(lp31744
VThe Standard does not say "refers to a local variable", but it says "is the name of a non-volatile automatic object"
p31745
ag7695
aVThis elision of copy/move operations, called copy elision, is permitted in the following circumstances [
p31746
ag1240
aVin a  statement in a function with a class return type, when the expression is the name of a non-volatile automatic object [
p31747
aVSo, pointers or references are not allowed
p31748
aVIf you read it in evil ways that seek to exploit an interpretation that is less likely to have been intended, you can say that it means to move the following
p31749
aVIn this case, the return expression is the name of a variable with automatic storage duration
p31750
aVSome other paragraphs in the Standard can be interpreted in multiple ways, but the rule is to take the interpretation that is most likely to be intended
p31751
as(dp31752
g15
V34509
p31753
stp31754
a((dp31755
g2
(lp31756
VParenthesized expressions are equivalent to their unparenthesized expressions unless otherwise noted (as done in the ADL rules, for example, or by decltype for another example)
p31757
aVIt can sometimes be tricky when and when not something is equivalent in this manner (for example, the ADL rules don't explicitly mention "unparenthesized", but they use an explicit grammar non-terminal and examples that make it clear that parens are not taken as being equivalent)
p31758
aVFor the other questions: Yes, GCC does several optimizations on the AST directly that makes it accept various invalid programs, like the following
p31759
as(dp31760
g15
V34509
p31761
stp31762
a((dp31763
g2
(lp31764
VGCC's warning may have been a bit confusing, but its intention is certainly right
p31765
aVThe type of the lambda is unnamed, and it is unique in the whole program
p31766
aVOn the other side if your class isn't put in an unnamed namespace (which it, given your description, I suppose is not), your class is the same type in every translation unit that you include it into
p31767
aVSince the same class should have the same members, and not different members in different translation units, this is a violation (and leads to undefined behavior)
p31768
aVWhat's at least as bad is that  is , so that you will get "multiple definitions of L" linker errors once you include the header into multiple translation units
p31769
as(dp31770
g15
V34509
p31771
stp31772
a((dp31773
g2
(lp31774
VThe C++ Standard contains an informal description of this matter which describes what I think would be a good guideline and is taken by many people to be the normative requirement implied by the specification
p31775
aVHowever, implementations can point to normative parts of the Standard that allow them to go further than what the "obvious" rules seem to state
p31776
aVI will describe this below
p31777
aVNon-Normative description
p31778
aVThe Standard allows an implementation not to check template definitions until they are instantiated
p31779
aVIt doesn't give a formal description as to when a "template definition" is actually supposed to be a template definition, but the usual implementation is to do forms of "brace balancing" / "parens balancing": Start from the outermost brace of the definition's body, count until you hit the last closing brace
p31780
aVEverything in between is ignored
p31781
aVI suppose an example from the Standard clarifies this further
p31782
aVSo early diagnosis of syntax or semantic errors in template definitions is a "quality of implementations"
p31783
aVNormative description
p31784
aVThese rules are of the quality "no diagnostic required"
p31785
aVNoteworthy, implementations by these rule are granted the license not to diagnose ill-formed template definitions even if the template is instantiated, despite what the non-normative note of the Standard says
p31786
aVIf any rule for which no diagnostic is required is violated, an implementation is free to do whatever it wants with the entire program
p31787
aVIt should be noted that also, there is no syntactically ill-formed "template definition", because this very term is defined by the syntax itself
p31788
aVA lonely  renders the whole enclosing context to be some soup of nonsensical tokens
p31789
aVLast but not least, the committee knows about these "loopholes", but there was no majority to change this so far, as far as I know
p31790
as(dp31791
g15
V34509
p31792
stp31793
a((dp31794
g2
(lp31795
VThe compiler has no way to deduce  from your function call
p31796
aVThink about what happens when  is :
p31797
aVIn general, if you write , then the  cannot be deduced in the call
p31798
aVIt must be explicitly provided
p31799
aVI recommend to just use  as the parameter type
p31800
aVThat will allow you to not only accept vector iterators, but also , or  and any other random access iterators
p31801
as(dp31802
g15
V34509
p31803
stp31804
a((dp31805
g2
(lp31806
VThe CPP backend creates LLVM API calls to create an AST that represent the equivalent of the LLVM assembly
p31807
aVYou can try the CPP backend at http://llvm
p31808
aVorg/demo/ by selecting the "LLVM C++ API code" Target
p31809
aVThe C backend creates C code that execute the semantics of the LLVM assembly
p31810
aVThey are fundamentally different
p31811
as(dp31812
g15
V34509
p31813
stp31814
a((dp31815
g2
(lp31816
VShort version: Try updating your compiler
p31817
aVYour version doesn't implement http://www
p31818
aVopen-std
p31819
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p31820
aVhtml#1164
p31821
aVYour second template is a "perfect forwarding" template
p31822
aVAny function template parameter of type , where  is a template parameter will deduce that template parameter to  (where  is the argument type) when the argument is an rvalue, and to  if the argument is an lvalue
p31823
aVIn your case you passed an rvalue, so  was deduced to  (and  in your real code)
p31824
aVIf you would have passed a variable name or something else that is an lvalue, your second template would have the parameter type  (T would be , and  applied to such a type stays )
p31825
aVBut the other template also has such a parameter type
p31826
aVSo during overload resolution the conversion of the argument to the parameter is the same (perfect match), and another criteria needs to inspected, the specifity of the two templates, under the partial ordering rule
p31827
aVIf one template is more specialized than the other template, then it will be chosen by the compiler
p31828
aVIf there is no template more specialized than the other one, a final ambiguity is risen
p31829
aVIn this case, the first template is more specialized than the second template, and hence the compiler should call the first template finally
p31830
as(dp31831
g15
V34509
p31832
stp31833
a((dp31834
g2
(lp31835
VUsing modern facilities
p31836
aVNot sure why you wanna copy it first and then clear it, but that's how you can do it
p31837
aVWithout C++11 generalized initializers, you can say
p31838
aVOf course, you can always use  instead , it works the same
p31839
as(dp31840
g15
V34509
p31841
stp31842
a((dp31843
g2
(lp31844
VYour operator= needs to be volatile
p31845
aVJust as a member function needs to be const to be invoked on a const object
p31846
aVIf your member function is not volatile, the compiler would optimize its body, which is not what you want for a volatile object
p31847
aVSo the language has this useful rule
p31848
aVIt is well known that this error happens even with the implicitly declared operator=, and is documented as one of the incompatibilities to the C language
p31849
aVEDIT: I would like to mention that the object you assign to is not volatile, so a compiler is free to optimize away operations on it, even if the pointer used to access it has the volatile qualifier
p31850
aVAdd volatile to the type of it
p31851
as(dp31852
g15
V34509
p31853
stp31854
a((dp31855
g2
(lp31856
VBecause  is a runtime if
p31857
aVThe fact that the compiler can know before-hand at compile time that it doesn't need to branch at runtime can be used to optimize the generated code, but it must not influence whether it complains about certain parts of the code
p31858
aVIf the code of the  is invalid if  is , the compiler will complain
p31859
aVWhat you are looking for is a static if, which controls whether certain parts of your code is processed by the compiler or not
p31860
aVThere are proposals for such a thing for the next C++ version, but current C++ does not have such a construct
p31861
as(dp31862
g15
V34509
p31863
stp31864
a((dp31865
g2
(lp31866
VYes, you can make it
p31867
aVMaking it  allows the static member to have more types than just integral or enumeration types, when it is initialized in-class
p31868
aVIn particular, the member just needs to be of a literal type, and all expressions in the initializer must be constant expressions
p31869
aVSo this is fine
p31870
as(dp31871
g15
V34509
p31872
stp31873
a((dp31874
g2
(lp31875
VYou can derive your class from  and from other classes that don't derive from it, but  needs to be the first base class in the base classes list
p31876
aVSo this is wrong:
p31877
aVYou need to write it as
p31878
as(dp31879
g15
V34509
p31880
stp31881
a((dp31882
g2
(lp31883
VHere is what you can also do
p31884
aVThen you can simply do
p31885
as(dp31886
g15
V34509
p31887
stp31888
a((dp31889
g2
(lp31890
VIt indicates that  is not assignable
p31891
aVIt is like trying to assign to  (which  will yield when  stored the value )
p31892
aVOf course that makes no sense
p31893
aVYou can compare it to trying to change the color "red", when you actually wanted to first paint your paper red and then blue
p31894
as(dp31895
g15
V34509
p31896
stp31897
a((dp31898
g2
(lp31899
VA brace enclosed initializer list cannot be forwarded, so you are unfortunately out of luck
p31900
as(dp31901
g15
V34509
p31902
stp31903
a((dp31904
g2
(lp31905
VIt means nothing, you better don't write it
p31906
aVGive a proper name to the typedef, if you want
p31907
aVI don't see any benefit of that though
p31908
aVA C programmer who recently changed over to C++ may be inclined to do this though, as in C you cannot refer to a class name ("tag", in C terms) by simply naming it, but you have to prefix it with the tag kind ("struct a_t", or "union a_t") or you make a typedef for it
p31909
aVHowever even in this setting, the programmer would have forgotten the name afterwards :)
p31910
aVIn C++ that's not needed
p31911
aVIn C++, the presence of both a typedef name and a class name is not resolved by keeping those names in different "namespaces" (so to speak, in C terms
p31912
aVEach "namespace" there is a kind of "syntax directed disambiguation"
p31913
aVSo that you can say "foo" and "struct foo" and "goto foo", and each time "foo" may be a totally different entity)
p31914
aVIn C++, the typedef name will replace the pure class name, and henceforth that name "a_t" is both - a typedef name and a class name
p31915
aVAs for the Standardese, we have an issue open for this, see http://www
p31916
aVopen-std
p31917
aVorg/jtc1/sc22/wg21/docs/cwg_active
p31918
aVhtml#157
p31919
as(dp31920
g15
V34509
p31921
stp31922
a((dp31923
g2
(lp31924
VTo make a QVBoxLayout keep a fixed ratio between two elememts, give them stretch parameters in addWidget
p31925
aVA stretch parameter of N that is x times another stretch parameter Y will make the corresponding widget have a height x times higher than the other widget
p31926
as(dp31927
g15
V34509
p31928
stp31929
a((dp31930
g2
(lp31931
VThe compiler gives an error for any template that can never be instantiated
p31932
aVFor your member function of the class template (i assume you mean ), that is true, so the compiler is in right to give you a diagnostic
p31933
aVYou want to make the condition depend on  and cleverly make it always evaluate to false when instantiated
p31934
aVFor example like
p31935
aVSince the compiler cannot know whether the user will put a specialization of  (which you won't, of course), it cannot early-reject the template anymore
p31936
aVI also doubt that you wanted to put the static_assert into , since your error message indicates that  as a whole needs to be specialized
p31937
aVSo put the  outside of the member function into the class body
p31938
aVIf you don't want the user to specialize the whole template, but only the member function, the user instead needs to say
p31939
aVThis will provide an alternative definition of  which will be used by the template if  is
p31940
as(dp31941
g15
V34509
p31942
stp31943
a((dp31944
g2
(lp31945
VI reported this GCC bug some time ago and it was fixed earlier this year
p31946
aVSee http://gcc
p31947
aVgnu
p31948
aVorg/bugzilla/show_bug
p31949
aVcgi
p31950
aVid=48814
p31951
as(dp31952
g15
V34509
p31953
stp31954
a((dp31955
g2
(lp31956
VTake this as a practical usecase
p31957
aVThe assignment fails because  is a nonconst iterator
p31958
aVIf you used cbegin initially, the iterator would have had the right type
p31959
as(dp31960
g15
V34509
p31961
stp31962
a((dp31963
g2
(lp31964
V converts values of pointer types to other pointer type values or integer values and vice versa, in order to allow a dereference of the destination pointer value
p31965
aVYou however try to convert one integer type value to another integer type value
p31966
aVThat's not going to work
p31967
aVsupports the casting of reference types, which is equivalent to the respective pointer value cast with a follow-up dereference
p31968
aVSo it appears you wanted to do
p31969
aVThis is well-formed, but reinterprets the unsigned char as an integer object, which isn't guaranteed to work (possible issues range from invalid alignment of the storage to incompatible sizes - 1 byte vs 4 bytes)
p31970
aVYou can solve these cases by doing the  cast, I think that's perfectly fine
p31971
aVYou can also say , which promotes the value to (signed or unsigned)  automatically
p31972
as(dp31973
g15
V34509
p31974
stp31975
a((dp31976
g2
(lp31977
VIt is so that the author of the class that has the private member can explicitly instantiate that member or pass it as an argument as you just did
p31978
aVThe compiler has no idea who is in front of the keyboard, so the access checking here is rather conservative
p31979
as(dp31980
g15
V34509
p31981
stp31982
a((dp31983
g2
(lp31984
VI would use overload resolution
p31985
aVThat spares you from having to use the gross SFINAE hack
p31986
aVUnfortunately there are many areas where you can't avoid it, but this fortunately isn't one of those
p31987
as(dp31988
g15
V34509
p31989
stp31990
a((dp31991
g2
(lp31992
VThis appears to work fine on my local GCC (4
p31993
aV7, courtesy of rubenvb)
p31994
aVGCC on ideone prints several "implemented" compiler internal errors though
p31995
aVI had to make the "implementation details" of the  class public, because for some reasons (which smells like a bug), my version of GCC complains about them being private, even though only the class itself uses it
p31996
aVUpdate: The code also works on Clang
p31997
as(dp31998
g15
V34509
p31999
stp32000
a((dp32001
g2
(lp32002
VYes,  is OK in that case and the right thing to use
p32003
aVI have to ask why you don't store  pointers in the first place though
p32004
aVIf you want to put derived class pointers into it, then beware, you need to upcast/upconvert (implicitly or explicitly) the derived class pointers to  before you put them into the map
p32005
aVBut even if you put also derived class pointers into the map, a base class pointer would suffice because a derived class pointer is implicitly convertible to a base class pointer
p32006
aVThe reason void* is used is because hold is member of a class define on a header used by some cpp files which don't know what classA is
p32007
aVThat can be a valid reason to prevent layering violations
p32008
aVI would have to include the header of classA definitions on these cpp files which can't be done by many reasons
p32009
aVThat's most probably not necessary in your case
p32010
aVA forward declaration suffices
p32011
aVIf the header knows what is put into the map, but just wants to avoid including additional headers, this is the way to go
p32012
as(dp32013
g15
V34509
p32014
stp32015
a((dp32016
g2
(lp32017
VI have just checked, and the Standard allows
p32018
aVomitting the copy or move of an object specified by the operand of a throw expression into the exception object
p32019
aVomitting the copy or move of the exception object into the catch clause variable of the same type as the exception object if you don't otherwise change the meaning of the program (i
p32020
aVe if you would rethrow and subsequent catches would suddenly see a changed exception object changed by the previous catch block)
p32021
aVSince these omissions are allowed, the spec requires to first regard the source of the copy or move as an rvalue
p32022
aVSo this means that the respective objects will be moved if possible
p32023
aVOf course copy and move elision are still allowed as the first choice
p32024
aVUpdate
p32025
aVI was notified that the consideration of the exception object initializer of a catch clause parameter as an rvalue initializer will probably be dropped from the Standard (because in general it is not possible for all cases to detect when the behavior of the program is unchanged when omitting a copy/move), so I recommend to not rely on this (second bullet above)
p32026
aVWhat you can still rely about is the move of a local variable into the exception object, as in  (first bullet above)
p32027
as(dp32028
g15
V34509
p32029
stp32030
a((dp32031
g2
(lp32032
VAnother guy said that this is a Clang bug
p32033
aVYou can work it around if you change the using declaration like this
p32034
aVAs an educated guess, apparently Clang does not correctly update the identity of the template parameter that appears in the type-id
p32035
aVSo it thinks in your example that the resulting type  refers to the first parameter of the partial specialization (because within  that is the case, but not in the point of use)
p32036
aVAlternatively you can exchange the order at the point of use
p32037
as(dp32038
g15
V34509
p32039
stp32040
a((dp32041
g2
(lp32042
VSee 3
p32043
ag2670
aV2p3, which says
p32044
aVLet X be the lookup set produced by unqualified lookup (3
p32045
ag2670
aV1) and let Y be the lookup set produced by argument dependent lookup (defined as follows)
p32046
aVIf X contains
p32047
aVa declaration that is neither a function or a function template
p32048
aVthen Y is empty
p32049
aVIf there would not be such a rule, you are right: ADL would add your other function to the overload set
p32050
aVIn fact, 13
p32051
ag1037
ag2790
aV1p1 relies on this: It has two branches; one for function call expressions where the operand denotes a class object, and another one where the operand denotes one or more functions or function templates
p32052
as(dp32053
g15
V34509
p32054
stp32055
a((dp32056
g2
(lp32057
VBecause the  operator expects an address value
p32058
aVAnd whenever a value is expected (as opposed to an object or function glvalue), the lvalue to rvalue, function to pointer and array to pointer conversions are applied on an operand
p32059
aVSo the dereferenced function immediately again converts to a pointer when again dereferenced
p32060
aVThese all either read values from objects or produce a pointer value that refers to the beginning of an array or function respectively
p32061
aVThese rows of dereferences have no purpose other than for the lulz of it
p32062
as(dp32063
g15
V34509
p32064
stp32065
a((dp32066
g2
(lp32067
Vfunction object: An object  that you can call with the  syntax
p32068
aVThis includes function pointers, class objects having an overloaded  or conversion function to a function pointer/reference
p32069
aVThe Standard has a straight forward definition of it
p32070
aVA function object type is an object type (3
p32071
aV9) that can be the type of the postfix-expression in a function call (5
p32072
ag976
aV2, 13
p32073
ag1037
ag2790
aV1)
p32074
aVA function object is an object of a function object type
p32075
aVIn particular, a function or function reference is not a function object, even though they are callable entities
p32076
aVSome people confuse the term "function object" and take it to mean exclusively class type objects with an overloaded
p32077
aVfunction pointer: An, err, pointer to a function
p32078
aVlambda function: I think you refer to the C++11 lambdas
p32079
aVThese are not really functions, but special compiler-generated class type function objects that have an overloaded
p32080
as(dp32081
g15
V34509
p32082
stp32083
a((dp32084
g2
(lp32085
VBecause your member is just a reference
p32086
aVIn the second case the object it references is already dead after the definition of the local  variable has finished
p32087
aVSo the later access in the  is undefined behavior
p32088
as(dp32089
g15
V34509
p32090
stp32091
a((dp32092
g2
(lp32093
VAnytime you ask yourself "how to simulate partial specialization for functions", you can think "overload, and let partial ordering decide what overload is more specialized"
p32094
aVI think you wanted to pass  instead of  at the comment-marked position
p32095
as(dp32096
g15
V34509
p32097
stp32098
a((dp32099
g2
(lp32100
Vtypedefs cannot be templated
p32101
aVYou use alias templates for that
p32102
as(dp32103
g15
V34509
p32104
stp32105
a((dp32106
g2
(lp32107
VIt means that that function is only callable on lvalues
p32108
aVSo this will fail because the assignment operator function is called on an rvalue object expression:
p32109
as(dp32110
g15
V34509
p32111
stp32112
a((dp32113
g2
(lp32114
VIn-class initializers do not support the  syntax of initialization because the committee members that designed it worried about potential ambiguities (For example, the well-known  declaration would be ambiguous and does not specify an initialization but declares a function with an unnamed parameter)
p32115
aVYou can say
p32116
aVAlternatively a default value can be passed in the constructor
p32117
as(dp32118
g15
V34509
p32119
stp32120
a((dp32121
g2
(lp32122
VThe operator new function does not call constructors
p32123
aVIt just allocates the needed storage
p32124
aVThe constructor is called afterwards by compiler magic and is considered to be done by  and  respectively
p32125
as(dp32126
g15
V34509
p32127
stp32128
a((dp32129
g2
(lp32130
VI was indeed completely dump
p32131
aVI can just use  and pass it the rectangle
p32132
aVIt will correctly delegate the request to the icon engine
p32133
as(dp32134
g15
V34509
p32135
stp32136
a((dp32137
g2
(lp32138
VYou can use a dummy  parameter
p32139
aVIncidentally you will see this pattern used with  instead of , with the specializations often using  and more complicated (and SFINAE involving) conditions
p32140
as(dp32141
g15
V34509
p32142
stp32143
a((dp32144
g2
(lp32145
VThis was illegal in C++03 because these members are nonstatic datamembers
p32146
aVStarting from C++11 this is legal since in an unevaluated operand you can use nonstatic datamembers without having a corresponding object
p32147
as(dp32148
g15
V34509
p32149
stp32150
a((dp32151
g2
(lp32152
VIf all parameters of one function convert at least as well as those of another function and some of the parameters convert better, that function is taken
p32153
aVIf not all parameters convert at least as well as those of another function, and not all the parameters of the latter function convert at least as well as those of the former function, there is an ambiguity risen in the normal case of plain functions
p32154
as(dp32155
g15
V34509
p32156
stp32157
a((dp32158
g2
(lp32159
VWhy would arr be considered as a pointer
p32160
aVIt is an array and its first element by definition has the same address as it
p32161
aVJust as the first character in WORD has the same starting pixel position as the word itself
p32162
as(dp32163
g15
V34509
p32164
stp32165
a((dp32166
g2
(lp32167
VSome people like to use  for variables that only store positive quantities
p32168
aVSome other people don't want to use  to denote that meaning
p32169
aVIt's an often and much discussed topic
p32170
aVI'm in the latter camp: I won't use  in such parameters
p32171
aVWhen I write a  function for a -like class for instance, I use , even though a size will never become smaller than 0
p32172
aVPutting an assert or test-and-throw to reject negative  values seems appropriate if you want
p32173
aVPeople from the  camp will say that the compiler should warn on the call-side when you pass a negative value
p32174
aVYou can go on with arguments and I'm sure you will find lots of them on the interwebs
p32175
as(dp32176
g15
V34509
p32177
stp32178
a((dp32179
g2
(lp32180
VSure
p32181
aVTry  or  or
p32182
aVThere's a rule that top-level  qualifiers collapse if you get multiple of them through a  or a template argument, which means  will return
p32183
aV[normative text pending]
p32184
aVThen there's a rule that ignores top-level  on things it doesn't work on, like references or function types
p32185
aVThat means  and  will return
p32186
aVCv-qualified references are ill-formed except when the cv-qualifiers are introduced through the use of a typedef (7
p32187
ag2790
aV3) or of a template type argument (14
p32188
aV3), in which case the cv-qualifiers are ignored
p32189
aVand
p32190
aV[ Note: Function types (including those used in pointer to member function types) are never cv-qualified (8
p32191
ag1037
aV5)
p32192
aV\u2014end note ]
p32193
aVThe effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top of the function type
p32194
aVIn the latter case, the cv-qualifiers are ignored
p32195
as(dp32196
g15
V34509
p32197
stp32198
a((dp32199
g2
(lp32200
VFor an array of type int of size n the syntax is
p32201
aVOr with a helper type alias
p32202
aVThen
p32203
aVIn your case you pass a pointer to the arrays first element though, and not a pointer to the array
p32204
aVYou need to prefix the array name with  to do the latter when passing the array
p32205
as(dp32206
g15
V34509
p32207
stp32208
a((dp32209
g2
(lp32210
V is an lvalue, which means "locator value"
p32211
aVIt's called like that because from  the compiler knows where it is located
p32212
aVSo  in a sense is an address, or something that allows an address to be deduced
p32213
aVThat thing becomes a value only when read
p32214
aVIn that case, the compiler takes , reads the value in its location and henceforth in that initialization the  stands for its value
p32215
aVUnfortunately this "value reading" is an implicit process, so whether the text  is a value or a lvalue depends on where it appears in
p32216
as(dp32217
g15
V34509
p32218
stp32219
a((dp32220
g2
(lp32221
VC++ has an explicit rule that disallows references or pointers to arrays without bounds as parameters (but those are otherwise valid types)
p32222
aVThe following would be a valid argument to such a parameter
p32223
aVNote that you cannot use an array with a size
p32224
aVC++ does not have the type compatibility concept
p32225
aVC has, and makes an array type without size compatible to the corresponding array type with a size
p32226
aVIn C++, the typesystem is stricter, types have linkage and prototypeless function types do not exist, so type compatibility is not a real need, so C++ dropped it
p32227
as(dp32228
g15
V34509
p32229
stp32230
a((dp32231
g2
(lp32232
VAn array type with a const element type is both a const qualified type (the const  applies bidirectionally) and an array type
p32233
aVSo you should fix the specializations
p32234
as(dp32235
g15
V34509
p32236
stp32237
a((dp32238
g2
(lp32239
VThis code is ill-formed, no diagnostic required
p32240
aVLike the diagnostic says, if a declaration uses a name and the name has a different meaning than it would have when looked up at the end of the class definition, the programm is illformed, no diagnostic required
p32241
as(dp32242
g15
V34509
p32243
stp32244
a((dp32245
g2
(lp32246
VThe compiler cannot track reference destinations completely at compile time
p32247
aVBecause somewhere it needs to be stored where a reference refers to
p32248
aVThis is a class making it very easy to trigger undefined behavior
p32249
aVJust create a const object of it and call the const member function
p32250
aVC++ supports the  keyword for a supported mechanism of changing the bits of an object in a const member function
p32251
as(dp32252
g15
V34509
p32253
stp32254
a((dp32255
g2
(lp32256
V means that during the lifetime of an object, the value of the object does not change
p32257
aVThe Standard itself notes that hence, const does not make sense on prvalues of nonclass or nonarray prvalues
p32258
aVSuch expressions never refer to objects (at least if the expression originates from user code
p32259
aVThe language itself may create prvalues during reference binding which magically refer to temporary objects
p32260
aVIMHO, though, these should be xvalues instead)
p32261
aVHence since there is no object, there is no lifetime
p32262
aVAnd hence, there is nothing to be held "const"
p32263
as(dp32264
g15
V34509
p32265
stp32266
a((dp32267
g2
(lp32268
VThis one doesn't result in a compiler error, but a runtime error
p32269
aVInstead of measuring a wrong time, you get an exception which may be acceptable too
p32270
aVAny constructor you want to guard needs a default argument on which  is called
p32271
aVThe characteristics are:
p32272
aVThe case of ,  and the return of  may not be wanted
p32273
aVTo prevent throwing, you can allow the source of a copy to be a temporary, by resetting the  to now guard us instead of the source of the copy
p32274
aVNow you also see why we used the pointers above - it allows us to be flexible
p32275
aVThe characteristics for ,  and for  are now always
p32276
as(dp32277
g15
V34509
p32278
stp32279
a((dp32280
g2
(lp32281
VYes, if you pass an lvalue, the lvalue to rvalue conversion will be done, which means calling the copy constructor to copy the object into a new copy and passing that as an argument
p32282
as(dp32283
g15
V34509
p32284
stp32285
a((dp32286
g2
(lp32287
VThe Standard library is part of the language
p32288
aVTo express the subset of the language that concerns only with the rules of the syntax, semantic rules, and such but not with the library, people use the term core language
p32289
aVFor example there is a working group called "core working group" (CWG) and "library working group" (LWG) in the C++ committee
p32290
as(dp32291
g15
V34509
p32292
stp32293
a((dp32294
g2
(lp32295
VAt instantiation, only argument dependent lookup is done
p32296
aVYou can fix your case by using an argument whose type resides in the namespace of your
p32297
as(dp32298
g15
V34509
p32299
stp32300
a((dp32301
g2
(lp32302
VI take it that one of the reasons could have been consistency
p32303
aVRecall that within a class, you can say
p32304
aVIt compiles fine, since the qualified name names the member function, instead of forming a pointer to member
p32305
as(dp32306
g15
V34509
p32307
stp32308
a((dp32309
g2
(lp32310
VIf you overload function templates, the functions produced by these function templates (called a function template specialization) need to be different
p32311
aVHence the C++ Standard specifies that the signature of function template specializations include the signature of the function template from which the specialization was generated
p32312
aVOtherwise if both templates would instantiate functions that have the same function type, they would clash
p32313
as(dp32314
g15
V34509
p32315
stp32316
a((dp32317
g2
(lp32318
VBecause for some domain of input parameters, the impure path will never be taken
p32319
aVFor that domain, constexpr will work fine
p32320
aVFor instance, your function may have a simple branch and a more complicated branch
p32321
aVAnd you may specify that for your function to be usable in constant expressions, the function arguments must be such that this and that condition is met, yielding to the simple branch in your function that is always pure
p32322
aVA useful sideeffect of this is that you can cause errors during constant computation
p32323
ag1388
aVe if a precondition in the simple branch is violated, you could cause the evaluation of an impure expression, provoking a compile time error (an assertion or an exception is a good idea here, as it continues to complain when the function is invoked in a runtime context)
p32324
as(dp32325
g15
V34509
p32326
stp32327
a((dp32328
g2
(lp32329
VI once wrote it (EDIT: see below for limitations and explanations)
p32330
aVFrom http://stackoverflow
p32331
aVcom/a/10287598/34509 :
p32332
aVHowever there are many kinds of constant expressions
p32333
aVThe above answer detects prvalue constant expressions
p32334
aVExplanation
p32335
aVThe  expression gives  iff  contains
p32336
aVa potentially evaluated call to a function that does not have a non-throwing exception-specification unless the call is a constant expression,
p32337
aVa potentially evaluated  expression,
p32338
aVa potentially evaluated throwable form of  or
p32339
aVNote that the function template  is not declared , so the call needs to be a constant expression for the first bullet not to apply, and this is what we abuse
p32340
aVWe need the other bullets to not apply aswell, but thanksfully, both a  and a throwable  or  aren't allowed in constant expressions aswell, so this is fine
p32341
aVLimitations
p32342
aVUnfortunately there is a suble limitation, which may or may not matter for you
p32343
aVThe notion of "potentially evaluated" is much more conservative than the limits of what constant expressions apply
p32344
aVSo the above  may give false negatives
p32345
aVIt will report that some expressions aren't prvalue constant expressions, even though they are
p32346
aVExample:
p32347
aVIn the above  is false, even though the initialization of  succeeded
p32348
aVThat is because for being a constant expression, it suffices that the "evil" non-constant sub-expressions are "never evaluated", even though those evil sub-expressions are potentially-evaluated, formally
p32349
as(dp32350
g15
V34509
p32351
stp32352
a((dp32353
g2
(lp32354
VYou cannot directly initialize class base objects B and C anymore in the constructor of X
p32355
as(dp32356
g15
V34509
p32357
stp32358
a((dp32359
g2
(lp32360
VBecause those compilers seem to miss this feature
p32361
aVI recommend to write them a featurereport
p32362
aVA compiler can easily regognize the std string class internally and emit a sensible warning
p32363
aVI don't know why you want to restrict the warning only to the cast-free cases though
p32364
aVHaving a cast there or otherwise passing a null pointer is equally nonsensible
p32365
as(dp32366
g15
V34509
p32367
stp32368
a((dp32369
g2
(lp32370
VC++03 did normatively say that function invocations do not interleave
p32371
aVC++11 says normatively that
p32372
aVEvery evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function
p32373
aVBoth are sufficient to disallow this
p32374
as(dp32375
g15
V34509
p32376
stp32377
a((dp32378
g2
(lp32379
VYou can do this by simply expanding after the function call, into something that can be expanded to
p32380
aVYou can do something else with a lambda
p32381
aVYou can even have your  incremented
p32382
aVNote that the Standard supports putting everything into the lambda
p32383
aVCompiler support until recently (last time I checked) wasn't very good though
p32384
as(dp32385
g15
V34509
p32386
stp32387
a((dp32388
g2
(lp32389
VThere was a debate on whether  should pick up the being defined  or the  that potentially already was in scope
p32390
aVTo avoid "unknown types" and to make it similar to , it was ruled that the being-defined  is not visible in its to-be-assigned type expression (so rather than being similar to , it is similar to )
p32391
aVRecall that  is just a normal declaration with the  keyword prepended
p32392
aVThe first mentioning of  does not declare anything, it just says what type will be aliased
p32393
aVThat's the major difference with   which could declare  earlier, if the committee decided that way
p32394
aVNote however your code is has effectively undefined behavior, because it violates a rule that has no required diagnostic
p32395
ag1037
ag1037
aV7p1b2
p32396
aVA name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S
p32397
aVNo diagnostic is required for a violation of this rule
p32398
as(dp32399
g15
V34509
p32400
stp32401
a((dp32402
g2
(lp32403
VLet's abstract away from
p32404
aVAnd call it
p32405
aVThe first two forms are list initialization (and the only difference between them is that if  is a class, for the second  constructors are forbidden to be called
p32406
aVIf one is called, the program becomes ill-formed)
p32407
aVThe last form is just ordinary direct initialization as we know it from C++03:
p32408
aVThat there appears a  as arg means that the argument for the constructor call is a brace initializer list
p32409
aVThis third form does not have the special handling that list initialization has
p32410
aVmust be a class type there, even if the braced init list has only 1 argument
p32411
aVI'm glad that we put clear rules before releasing C++11 in this case
p32412
aVAs in terms of what constructors are called for the third, let's assume
p32413
aVSince a direct initialization is just a call to the overloaded constructors, we can transform this to
p32414
aVWe can use both trailing functions, but we would need a user defined conversion if we picked these functions
p32415
aVTo initialize the  parameter, list initialization will be used because this is not a direct initialization with parens (so the parameter initialization is equivalent to )
p32416
aVThe first two functions are exact matches
p32417
aVHowever, the Standard says that in such a case, when one function converts to  and the other does not, then the former function wins
p32418
aVTherefor in this scenario, the second  would be used
p32419
aVNote that in this scenario, we will not do two-phase overload resolution with first only initializer list ctors - only list initialization will do that
p32420
aVFor the first two, we will use list-initialization, and it will do context dependent things
p32421
aVIf  is an array, it will initialize an array
p32422
aVTake this example for a class
p32423
aVIn this case, we do two-phase overload resolution
p32424
aVWe first only consider initializer list constructors and see if one matches, as argument we take the whole braced init list
p32425
aVThe second ctor matches, so we pick it
p32426
aVWe will ignore the first constructor
p32427
aVIf we have no initializer list ctor or if none matches, we take all ctors and the elements of the initializer list
p32428
aVIn this case we pick the first constructor, because  cannot be converted to
p32429
as(dp32430
g15
V34509
p32431
stp32432
a((dp32433
g2
(lp32434
VUnless you explicitly instantiate a function template for the arguments you use in a function call, you have to make the function template definition visible to the caller of it
p32435
aVThis includes the call in main
p32436
aVIt probably works in unoptimized builds because the compiler emits an exported function definition symbol for the implicit function template instantiation
p32437
aVThe C++ Standard grants compilers to omit doing that, and GCC does it here for optimized builds (probably it just inlines the call and then the definitions symbol becomes unused)
p32438
as(dp32439
g15
V34509
p32440
stp32441
a((dp32442
g2
(lp32443
VMake an alias template
p32444
aVSo you can write
p32445
aVThis is not good programming though, because in your function you have no way to know the size of the array pointed to
p32446
aVThis should be passed explicitly to the function, if the function is supposed to work with a list of elements
p32447
aVIf you want to process arrays, consider using something like  or create your own
p32448
as(dp32449
g15
V34509
p32450
stp32451
a((dp32452
g2
(lp32453
VAlso consider this
p32454
aVSince we want it to accept function pointers, by pattern matching the T becomes a function type
p32455
as(dp32456
g15
V34509
p32457
stp32458
a((dp32459
g2
(lp32460
VDisambiguate using
p32461
aVIf a class name and enumerator (or function/variable) name is declared in the same scope, the class name is hidden
p32462
aVYou can access it by
p32463
aVSame if the type name is an enumeration name
p32464
aVYou could access that by
p32465
as(dp32466
g15
V34509
p32467
stp32468
a((dp32469
g2
(lp32470
VIt will not be initialized (still calling the constructor if T is a class, of course)
p32471
aVTo force value-initialization (which is a name that to newbies can be misleading - let's call it zero-initialization which it is for primitive types like ), do
p32472
aVThat is, just put a pair of parenthesis
p32473
as(dp32474
g15
V34509
p32475
stp32476
a((dp32477
g2
(lp32478
VYou could not do this anymore
p32479
aVNote that in a subsequent , suddenly you could
p32480
aVThis would be horribly inconsistent
p32481
aVAlso notice this case, with two different valid outcomes
p32482
aVWith ISO C++, this calls the  version of
p32483
aVWith your alternative definition, it calls the  version
p32484
as(dp32485
g15
V34509
p32486
stp32487
a((dp32488
g2
(lp32489
VIt is not a flexible array member but is used in some code that needs to work with old compilers or with c++ compilers
p32490
aVUsing it as a flexible array member might provoke undefined behavior
p32491
aVIn real code this should work as expected as this trick is used in too much code for the compiler to make any unexpected things
p32492
as(dp32493
g15
V34509
p32494
stp32495
a((dp32496
g2
(lp32497
VThere is no need for a fix
p32498
aVYour code is C++11 conforming
p32499
aVThe Standard for these cases says that the non-universal reference taking template is "more specialized" and it will take precedence
p32500
aVSo your call should pick the first template
p32501
aVIf you remove the first template, it will take the second template
p32502
aVIt is similar to this
p32503
aVNow this will call the second template instance because while both instances have  as parameter type, the second instance is associated with a more specialized function template
p32504
aVSame in your case
p32505
aVNote that it is "complete", in the sense that it works for all combination of const and lvalue/rvalue
p32506
aVconst lvalue
p32507
aVBoth have  as parameter, but the  one is more specialized, so it is taken by partial ordering
p32508
aVnon-const lvalue, your case
p32509
aVThe  one has  as parameter, and the  one too has  as parameter, but the  one is more specialized, so it is taken by partial ordering
p32510
aVconst rvalue
p32511
aVThe  one has  as parameter and the  one has  as parameter
p32512
aVAn rvalue reference is preferred for binding an rvalue over an lvalue reference
p32513
aVHence the  one is taken by overload resolution alone
p32514
aVnon-const rvalue
p32515
aVThe  one has  as parameter
p32516
aVA non-const lvalue reference cannot bind to rvalues
p32517
aVHence the  one, which has type  is picked by overload resolution alone
p32518
as(dp32519
g15
V34509
p32520
stp32521
a((dp32522
g2
(lp32523
VBecause the constructor of  is , so in your case it is
p32524
aVThis does not accept an
p32525
aVA "const (pointer to int)" is not a "(pointer to const int)"
p32526
as(dp32527
g15
V34509
p32528
stp32529
a((dp32530
g2
(lp32531
VIf the variable was declared as extern but is nonglobal, it too receives the same initialization handling
p32532
aVFor instance
p32533
aVThis nonglobal variable will be initialized to zero
p32534
aVAll namespace scope variables receive this handling
p32535
as(dp32536
g15
V34509
p32537
stp32538
a((dp32539
g2
(lp32540
VAccording to the Standards, it is clearly GCC that is correct, because the alias template must immediately be replaced and then normal/usual SFINAE is applied to  later when  is known
p32541
aVBut there currently is an issue for this, see http://www
p32542
aVopen-std
p32543
aVorg/jtc1/sc22/wg21/docs/cwg_active
p32544
aVhtml#1554
p32545
aVAccording to the meetings outcome, it appears that clangs behavior is desired: The substitution of  will be done in the context of the alias template (even though at the time of substitution in , there is no reference to the alias template anymore - it will still need to be referenced as the source of where the parameter type pattern originated from, if this is how it's implemented)
p32546
aVThis is similar to another situation where patterns are thrown away on definition time that could influence instantiation semantics
p32547
aVIn this case too, in my opinion the Standard normatively is clear that the parameter is immediately being replaced by  and thus the instantiation works
p32548
aVSee http://www
p32549
aVopen-std
p32550
aVorg/jtc1/sc22/wg21/docs/cwg_active
p32551
aVhtml#1322
p32552
as(dp32553
g15
V34509
p32554
stp32555
a((dp32556
g2
(lp32557
VYou can do the index tuple trick, as used by many people before
p32558
aVUsage is easy
p32559
aVOr using a lambda
p32560
as(dp32561
g15
V34509
p32562
stp32563
a((dp32564
g2
(lp32565
VA C cast is more like all C++ style casts except  combined
p32566
aVSo when you cast an int to another integer type, it is
p32567
aVWhen you cast pointers to other pointer types or to integer types or vice versa, it is
p32568
aVIf you cast away a , it is
p32569
aVC does not have something similar to  since it has concept of types of objects and would have no use for them like C++ either (no virtual functions
p32570
aVTypes with regard to interpreting an object's bits only become important when combined with expressions referring to objects, in C
p32571
aVThe objects themselfs don't have types
p32572
as(dp32573
g15
V34509
p32574
stp32575
a((dp32576
g2
(lp32577
VThis has become way easier with C++11
p32578
aVThings to note:
p32579
aVYou can name non-static data members in  and  without needing an object
p32580
aVYou can apply extended SFINAE
p32581
aVBasically any expression can be checked and if it is not valid when the arguments are substituted, the template is ignored
p32582
as(dp32583
g15
V34509
p32584
stp32585
a((dp32586
g2
(lp32587
VAccording to http://www
p32588
aVboost
p32589
aVorg/doc/libs/1_52_0/libs/smart_ptr/shared_ptr
p32590
aVhtm#Members ,  cannot be initialized by a null pointer constant because for the pointer-taking constructor, it is templated by  where  is a template parameter
p32591
aVA conversion of a null pointer constant to  is not considered when deducing , so that constructor will have a deduction failure and is ignored when passing
p32592
aVBut  can accept it because it has a  overload, so if you want, you can switch
p32593
aVNote that passing  is different from passing a null pointer like
p32594
aVThe latter won't use a  constructor but the former will (among other differences)
p32595
aVSo in the former case if your pointer is a namespace scope variable, it has constant initialization and will not induce initialization races with namespace scope objects in other translation units
p32596
as(dp32597
g15
V34509
p32598
stp32599
a((dp32600
g2
(lp32601
VYou cannot make an alias for
p32602
aVThe following was discussed in the committee to make an alias for  (because a very late C++11 draft contained notes that stated that it is an alias for  which a Defect Report cleaned up)
p32603
aVNote while  is the same type as , that  is not the same as
p32604
aVThe wording at http://www
p32605
aVopen-std
p32606
aVorg/jtc1/sc22/wg21/docs/cwg_active
p32607
aVhtml#1286 was supposed to change that, but in the last meeting it was considered to be a very special machinery that doesn't really fit what alias templates turned out to be (own templates), and it was pushed back to review
p32608
aVTo get that effect, a  in future may fit the bill (if proposed and accepted, of course)
p32609
as(dp32610
g15
V34509
p32611
stp32612
a((dp32613
g2
(lp32614
VThe second  in  is necessary to make GCC lookup the name as a label, instead of as a variable
p32615
aVFor example
p32616
aVThe second initializer refers to the int variable
p32617
as(dp32618
g15
V34509
p32619
stp32620
a((dp32621
g2
(lp32622
VIf not, are there any adverse consequences of defining this non-const argument copy constructor
p32623
aVI am going to ignore the "If not", since there are other approaches
p32624
aVBut there is an adverse consequence of your approach
p32625
aVThe following still uses the template constructor
p32626
aVBecause  is an rvalue, the template is a better match because it deduces the parameter to an rvalue reference
p32627
as(dp32628
g15
V34509
p32629
stp32630
a((dp32631
g2
(lp32632
VUse  where  is your condition
p32633
aVA nonclass type friend will be ignored
p32634
aVThe conditional template is easily implemented in C++03
p32635
aVHowever since C++03 does not support typedef friends you need to use the following syntax there
p32636
aVNote that the detail dummy class name needs to match the name of the potential friend in this workaround
p32637
as(dp32638
g15
V34509
p32639
stp32640
a((dp32641
g2
(lp32642
VIn C++ there is unlike as in C no concept of compatible types and the type T[] is unrelated to T[N]
p32643
aVYou need to make the reference have a size and the size must equal the one of the array you pass
p32644
aVC++ also bans references to arrays without bounds as function parameter types (perhaps for this reason)
p32645
as(dp32646
g15
V34509
p32647
stp32648
a((dp32649
g2
(lp32650
VThis works because within a trailing return type, members of the surrounding class are visible
p32651
aVNot all members, but only the members that are declared prior to it (in a trailing return type, the class is not considered to be complete, as opposed to function bodies)
p32652
aVSo what is done here:
p32653
aVAs we are in a template, a lookup is done to see whether  is dependent or not
p32654
aVSince  was declared prior to ,  is found to refer to a class member
p32655
aVBy the template rules in C++, it is found that  refers to a member of the current instantiation since it is a member of instantiations of the surrounding template
p32656
aVIn C++, this notion is used mainly to decide whether names are dependent: If a name is known to refer to the surrounding template's members, it is not necessarily needed to be looked up when instantiating, because the compiler already knows the code of the template (which is used as the basis of the class type instantiated from it
p32657
aVConsider:
p32658
aVIn C++03, the second line declaring  would be an error, because  was a dependent name and needed a  in front of it
p32659
aVOnly the first line was accepted
p32660
aVIn C++11, this inconsistency was fixed and both type names are non-dependent and won't need a
p32661
aVIf you change the typedef to  then both declarations,  and  will use a dependent type, but neither will need a , because you still name a member of the current instantiation and the compiler knows that you name a type
p32662
aVSo  is a member of the current instantiation
p32663
aVBut it is dependent, because the type used to declare it () is dependent
p32664
aVHowever this doesn't matter in your code
p32665
aVWhether dependent or not,  is found and the code valid
p32666
aVIn this code, again  is looked up to see whether it is dependent and/or whether it is a member of the current instantiation
p32667
aVBut since we learned above that members declared after the trailing return type are not visible, we fail to find a declaration for
p32668
aVIn C++, besides the notion "member of the current instantiation", there is another notion:
p32669
aVmember of an unknown specialization
p32670
aVThis notion is used to refer to the case where a name might instead refer to a member of a class that depends on template parameters
p32671
aVIf we had accessed , then the  would be a member of an unknown specialization because it is unknown what declarations will be visible when  is substituted at instantiation
p32672
aVneither a member of the current, nor a member of an unknown specialization
p32673
aVThis is the case for all other names
p32674
aVYour case fits here, because it is known that  can never be a member of any instantiation when instantiation happens (remember that name lookup cannot find , since it is declared after )
p32675
aVSince  is not made dependent by any rule, the lookup that did not find any declaration is binding, meaning there is no other lookup at instantiation that could find a declaration
p32676
aVNon-dependent names are lookup up at template definition time
p32677
aVNow GCC rightfully gives you an error (but note that as always, an ill-formed template is not required to be diagnosed immediately)
p32678
aVIn this case, you added  and GCC accepted
p32679
aVThe name  that follows  again is lookup at to see whether it might be a member of the current instantiation
p32680
aVBut again because of the member visibility in trailing return types, no declaration is found
p32681
aVHence the name is deemed not to be a member of the current instantiation
p32682
aVSince there is no way that at instantiation,  could have additional members that  could match (there are no base classes of  that depend on template parameters), the name is also not a member of an unknown specialization
p32683
aVAgain C++ has no rules to make  dependent
p32684
aVHowever it uses , so the name must refer to some member of  when it is instantiated
p32685
aVSo the C++ Standard says
p32686
aVSimilarly, if the id-expression in a class member access expression for which the type of the object expression is the current instantiation does not refer to a member of the current instantiation or a member of an unknown specialization, the program is ill-formed even if the template containing the member access expression is not instantiated; no diagnostic required
p32687
aVAgain no diagnostic is required for this code (and GCC actually doesn't give it)
p32688
aVThe id-expression  in the member access expression  was dependent in C++03 because the rules in that Standard were not as elaborated and fine-tuned as in C++11
p32689
aVFor a moment let's imagine C++03 had  and trailing return types
p32690
aVWhat would this mean
p32691
aVThe lookup would have been delayed until instantiation, because  would be dependent
p32692
aVThe lookup at instantiation of, say,  would fail, because  would not be found at instantiation time (as we said, trailing return types do not see members declared later)
p32693
aVHence, the early rejection of that code by C++11 is good and useful
p32694
as(dp32695
g15
V34509
p32696
stp32697
a((dp32698
g2
(lp32699
VThat is fine
p32700
aVBut if  is empty, it is undefined behavior
p32701
aVBetter use  which will also work if  is empty
p32702
as(dp32703
g15
V34509
p32704
stp32705
a((dp32706
g2
(lp32707
Vor a value computation using the value of the same scalar object
p32708
aVThe important part is bolded here
p32709
aVThe left hand side does not use the value of  for the value computation
p32710
aVWhat is being computed is an glvalue
p32711
aVOnly afterwards (sequenced after), the value of the object is touched and replaced
p32712
aVUnfortunately this is a very subtle point :)
p32713
as(dp32714
g15
V34509
p32715
stp32716
a((dp32717
g2
(lp32718
VEmission is generally fine (QObject does it too with the "destroyed" signal), including a case as yours
p32719
aVWhen the connection is direct, the string is still alive
p32720
aVAnd when it is QueuedConnection, then the string is first copied to the event loop
p32721
as(dp32722
g15
V34509
p32723
stp32724
a((dp32725
g2
(lp32726
V is a function
p32727
aVYou need to call it
p32728
aVThe poor compiler's error message is probably referring to its internal representation, which apparently applies an implicit  operation on the member function name
p32729
as(dp32730
g15
V34509
p32731
stp32732
a((dp32733
g2
(lp32734
VWhen the type of the expression to sizeof is not a variably modified array type, then the expression is not evaluated because the type is completely known at compile time
p32735
aVhas no variably modified parts
p32736
aVIn C++ (up to at least C++11) there are no variably modified types (at least not as in the concept of C - you can argue that  uses a variably modified array type; but the type does not escape to any other part of the language
p32737
aVIn particular, not to ), so in C++, the expression to sizeof is never evaluated
p32738
aVIn C, it is unspecified whether an expression is evaluated if it doesn't influence the size of a variably modified array type
p32739
aVFor example
p32740
aVIn C (from C99 onwards), this may output  for , but it may also output , depending on whether the compiler is clever enough to omit evaluating , deducing that the sizeof  is computed at compile time
p32741
aVFootnote: Variably modified array types are also called VLA (variable length array) types
p32742
aVIn short, a variably modified type is a type that is either a VLA type or a type that depends on one
p32743
aVFor example
p32744
as(dp32745
g15
V34509
p32746
stp32747
a((dp32748
g2
(lp32749
VOne solution would be (pseudo code)
p32750
as(dp32751
g15
V34509
p32752
stp32753
a((dp32754
g2
(lp32755
VThe below was only sufficient for making the class template definition itself valid
p32756
aVHowever the same rules that made the lookup not find the data member in the class template (which necessiated the introduction of the empty dependent base class or the dependent function call) will also make the instantiation of the class template not find the data member, and thereby will trigger a compiler error
p32757
aVWe told the compiler "hold on, perhaps you will find the data member at instantiation time", but I did not think about what will happen when actually instantiating
p32758
aVWe will now make it so that the name is still dependent even after instantiation of the class happened
p32759
aVThe resolution will have to wait until the call to
p32760
aVThe use of a class template for  instead of a function template will also prevent argument dependent lookup from happening, preventing that the author of  also writes a function called  that matches the argument  (this could have been a potential problem with the partial solution below, too)
p32761
aVYou have several other options, beside reordering
p32762
aVMaking the expression on the left side of  dependent, but not just the enclosing class (because it will be special-cased)
p32763
aVIntroduce a dependent base class to work-around the special casing of the enclosing class
p32764
aVThe first is based on the Standard making  a member of an unknown specialization
p32765
aVthe type of the object expression is dependent and is not the current instantiation
p32766
aVThe second is based on the Standard making  a member of an unknown specialization
p32767
aVthe type of the object expression is the current instantiation, the current instantiation has at least one dependent base class, and name lookup of the id-expression does not find a member of the current instantiation or a non-dependent base class thereof;
p32768
aVThis in turn makes  for both cases a dependent expression and hence the name will be looked up at instantiation time
p32769
aVThe Standard says
p32770
aVA class member access expression (5
p32771
ag976
aV5) is type-dependent if the expression refers to a member of the current instantiation and the type of the referenced member is dependent, or the class member access expression refers to a member of an unknown specialization
p32772
as(dp32773
g15
V34509
p32774
stp32775
a((dp32776
g2
(lp32777
VThis is nonconformant behavior as of C++11 because C++11 says that the injected class name (which is a name automatically declared within the class body) is a template when it is passed to a template template parameter
p32778
aVSo your code should  only fail in a C++03 implementation
p32779
aVHowever there is no need to open a bug report about this now
p32780
aVI have already done it way back
p32781
as(dp32782
g15
V34509
p32783
stp32784
a((dp32785
g2
(lp32786
VNo that is not a bug
p32787
aVThere are three parallel sets of operators considered
p32788
aVMembers, non-member operators, and builtins
p32789
aVThe non-member ones are looked up by normal unqualified+ADL lookup, ignoring all class member functions
p32790
aVHence the global operator is hidden by a lexical more closer one (and an intervening member function wouldn't have hidden other non-members)
p32791
aVNote that overload resolution takes place after name lookup1; in your case the name  was found, but no appropriate overload
p32792
aVIf Bar had been declared globally, and/or the other operator in namespace asdf, ADL (in the former case) or ordinary unqualified lookup (in the latter case) would have dragged the operator in
p32793
aV1:  (C++ Standard)
p32794
as(dp32795
g15
V34509
p32796
stp32797
a((dp32798
g2
(lp32799
VThe Standard has a quiet not explicitly defined equivalence rule for types that is mainly based on syntax for qualified names but for template parameters is the position in the paremeter list and the nesting depth of that list (i
p32800
aVe whether it is the one of a member template or of the enclosing class template)
p32801
aVA particular dependent type is remembered by typedefs
p32802
aVHowever that decltype type by 14
p32803
aV4p2 is a distinct type and not equivalent with T
p32804
as(dp32805
g15
V34509
p32806
stp32807
a((dp32808
g2
(lp32809
VYour reasoning is correct when these two types are competing in a partial ordering of class template partial specializations, and it is how things work there
p32810
aVBut when a reference type is compared against a nonreference type, the general gist is that they are ambiguous in a call scenario if nothing else makes one be preferred over the other
p32811
aVThat is, the kind of reference of the reference type doesn't matter in overload resolution when compared against the other, so partial ordering doesnt consider it either
p32812
as(dp32813
g15
V34509
p32814
stp32815
a((dp32816
g2
(lp32817
VA violation of this rule does not require a diagnostic
p32818
aVSo behavior is effectively undefined
p32819
aVI think that the reason this is not required to be diagnosed is because the diagnostic would be given by the linker
p32820
aVAnd when the compiler optimizes the accesses away (as it probably happened in this case), the linker cannot notice anything wrong anymore
p32821
aVStill noticing this error would require whole program analysis in the linker so that it has access to the original unoptimized source code representation
p32822
aVThis increases compile time and requires an advanced linker and compiler
p32823
as(dp32824
g15
V34509
p32825
stp32826
a((dp32827
g2
(lp32828
VThere's no way to distinguish this with the parameter alone
p32829
aVYou can make one of them a template though, which will then be more costly and less preferable for overload resolution
p32830
aVNow calling  will prefer the last function over the function template
p32831
aVNote that  still prefers the function template over the non-template vector-taking function, because the parameter conversion cost is more important than whether or not a candidate was synthesized from a template
p32832
as(dp32833
g15
V34509
p32834
stp32835
a((dp32836
g2
(lp32837
VNo,  is not the same as
p32838
aVAnd  is not the same as
p32839
aVThe former comparison compares expressions
p32840
aVThe latter use of  inspects the expression and the former use of  inspects the declared type of
p32841
aVSo you have to paren your uses of the  operand to make a useful comparison of the types and you will find they are different
p32842
aVIn these 4 expressions, all expressions have type
p32843
aVis a prvalue,  is an xvalue
p32844
aVis an lvalue and  is an xvalue again
p32845
aVIn these two types, the first decltype gives the type of the member named by the expression
p32846
aVThe member has type , so  is
p32847
aVThe second decltype yields the type of the expression, modified by  if the expression is an lvalue and modified by  if the expression is an xvalue
p32848
aVThe expression is an lvalue, so  is
p32849
as(dp32850
g15
V34509
p32851
stp32852
a((dp32853
g2
(lp32854
VAs part of resolving http://www
p32855
aVopen-std
p32856
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p32857
aVhtml#1399, it was decided that a parameter pack that is non-deducible will not participate in deduction, hence keeping the explicitly specified arguments within the parameter list, but not disturbing the matching of subsequent arguments to subsequent function parameters
p32858
aVHowever those added rules do not necessarily apply for deduction when comparing types (which is a sub-algorithm of the deduction of the set of parameters against the arguments for a function call)
p32859
aVI would argue that the resolution should apply to your situation aswell and regard it as simply an area where the specification is not entirely clear
p32860
aVYou may want to send a bug report to the respective compilers and they may want to send an issue report to WG21 for asking to clarify this (although I am not sure I would go as far as saying that this is a normative spec issue - the Standard says elsewhere that non-deducible contexts do not participate in deductions)
p32861
aVNote as  is a parameter of the enclosing class template (and hence become normal parameters when the class is instantiated), you can omit them and keep the same meaning as far as template argment deduction is concerned
p32862
as(dp32863
g15
V34509
p32864
stp32865
a((dp32866
g2
(lp32867
VThis is subject of two issue reports, http://www
p32868
aVopen-std
p32869
aVorg/jtc1/sc22/wg21/docs/cwg_active
p32870
aVhtml#1299 and http://www
p32871
aVopen-std
p32872
aVorg/jtc1/sc22/wg21/docs/cwg_active
p32873
aVhtml#1568
p32874
aVThe former issue report, of which I am the reporter, was intended to cover all these cases where a reference is bound to a temporary object, but is not intended to be lifetime-extending
p32875
aVThe description in the body of the issue only mentions prvalues being confused with temporary expressions (that actually decide whether lifetime of what they evaluate to is lengthened or not)
p32876
aVBut lvalue and xvalues are likewise confused with these in the Standard
p32877
aVAn example where that happens in the context of  is issue number #1568 (in which the use of "temporary variable" further confuses the matter)
p32878
aVActually, this:
p32879
aVA temporary bound to a reference parameter in a function call (5
p32880
ag976
aV2) persists until the completion of the full-expression containing the call
p32881
aVContradicts the other rules in the same paragraph
p32882
aVBecause the temporary is bound to both a reference parameter in a function call and to a local automatic reference variable
p32883
as(dp32884
g15
V34509
p32885
stp32886
a((dp32887
g2
(lp32888
VAnother way
p32889
as(dp32890
g15
V34509
p32891
stp32892
a((dp32893
g2
(lp32894
VBecause when a function parameter pack is not the last parameter, then the template parameter pack cannot be deduced from it and it will be ignored by template argument deduction
p32895
aVSo the two arguments  are compared against , yielding a mismatch
p32896
aVDeduction rules like this need to cover many special cases (like what happens when two parameter packs appear next to each other)
p32897
aVSince parameter packs are a new feature in C++11, the authors of the respective proposal drafted the rules conservatively
p32898
aVNote that a trailing template parameter pack will be empty if it is not otherwise deduced
p32899
aVSo when you call the constructor with one argument, things will work (notice the difference of template parameter pack and function parameter pack here
p32900
aVThe former is trailing, the latter is not)
p32901
as(dp32902
g15
V34509
p32903
stp32904
a((dp32905
g2
(lp32906
VThis is a bug in the C++ spec (which doesn't let this simple construct to compile)
p32907
aVYou need to supply the size
p32908
aVSee http://www
p32909
aVopen-std
p32910
aVorg/jtc1/sc22/wg21/docs/cwg_active
p32911
aVhtml#1469
p32912
aVNote that if you parenthesize the type name it is a type-id and not a new-type-id and hence syntactically allows you to omit the size expression
p32913
aVSo you may be able to find an implementation that allows you to say
p32914
aVAlthought it is clear that it wasn't the explicit intent that this is possible (and some rules in the  paragraphs can be interpreted to forbid it)
p32915
as(dp32916
g15
V34509
p32917
stp32918
a((dp32919
g2
(lp32920
VYou cannot
p32921
aVIt does result in the unexpected implicit conversion
p32922
aVHowever, the unexpected implicit conversion is disallowed and the compiler will reject your program
p32923
aVThat however doesn't stop the compiler to select or consider it
p32924
aVExample
p32925
as(dp32926
g15
V34509
p32927
stp32928
a((dp32929
g2
(lp32930
VNo, a string literal like  has the type  where  is the number of characters you wrote
p32931
aVIt behaves like an array of that type with no special rules
p32932
aVIn C++03, there was a special rule that said that a string literal could convert to
p32933
aVThat allowed you to say
p32934
aVFor example  would yield , and  would yield true
p32935
aVEven this possibiliy would not have allowed you to call a function with a string literal argument and behave differently
p32936
aVC++11 removed that special conversion rule and string literals behave like any other arrays
p32937
aVIn C++11 as a dirty hack you can compose some macros, matching some simple string literals without handling escape sequences
p32938
as(dp32939
g15
V34509
p32940
stp32941
a((dp32942
g2
(lp32943
VAn implicit conversion sequence of an expression  to type  is defined as being equivalent to the following declaration, using  as the result of the conversion (modulo value category, which will be defined depending on ), 4p3 and 4p6
p32944
aVThe effect of any implicit conversion is the same as performing the corresponding declaration and initialization and then using the temporary variable as the result of the conversion
p32945
aVIn clause 4, the conversion of an expression to a type always yields expressions with a specific property
p32946
aVFor example, conversion of  to  yields a null pointer value, and not just one arbitrary pointer value
p32947
aVThe value category too is a specific property of an expression and its result is defined as follows
p32948
aVThe result is an lvalue if T is an lvalue reference type or an rvalue reference to function type (8
p32949
ag1037
aV2), an xvalue if T is an rvalue reference to object type, and a prvalue otherwise
p32950
aVHence we know that in , the result of the conversion sequence is a prvalue, because  is a non-reference type
p32951
aVSo if we provide a glvalue, we are in obvious need of a conversion
p32952
ag1037
aV10p2 further clarifies that to leave no doubt
p32953
aVWhenever a glvalue appears in a context where a prvalue is expected, the glvalue is converted to a prvalue; see 4
p32954
aV1, 4
p32955
aV2, and 4
p32956
ag1037
as(dp32957
g15
V34509
p32958
stp32959
a((dp32960
g2
(lp32961
VThat's right and what you have shown makes the code invalid
p32962
aVThere is also 3
p32963
ag1037
aV1p4 which makes it invalid too (see 7
p32964
ag1037
aV3p13)
p32965
aVFor a reality test, I tested with ICC and it rejects it as expected
p32966
as(dp32967
g15
V34509
p32968
stp32969
a((dp32970
g2
(lp32971
VThe spec says this in 3
p32972
ag1037
aV2p6bullet2 (it actually just says into what scope the name declared is added to
p32973
aVIf I remember correctly, there is no explicit rule that says that theclass is a member of that namespace)
p32974
aVI think that this is an important C compatibility feature
p32975
aVIf it wasn't this way, the class would be global in C, but a class member in C++
p32976
as(dp32977
g15
V34509
p32978
stp32979
a((dp32980
g2
(lp32981
VI think the code in question is incorrect, as when the class template is instantiated, all member declarations are instantiated, except the definition parts and default arguments of the member functions and member function templates
p32982
aVThe Standard also defines when the function default arguments are instantiated precisely
p32983
aVSo default template-arguments are immediately instantiated
p32984
aVThe possibility that default arguments could be intended to include default template arguments at this point is very small here in my opinion, because there is no description of when such an argument would be instantiated later
p32985
aVThis is in line with the requirement that "A default template-argument shall not be specified in the template-parameter-lists of the definition of a member of a class template that appears outside of the member's class
p32986
aV, since there would be no way that such a template argument be instantiated immediately when instantiating the surrounding class template
p32987
as(dp32988
g15
V34509
p32989
stp32990
a((dp32991
g2
(lp32992
VAlternatively
p32993
aVHow we all love these crude and ugly SFINAE hacks :)
p32994
as(dp32995
g15
V34509
p32996
stp32997
a((dp32998
g2
(lp32999
VYes use a typedef and then say
p33000
aVAlternatively use an alias template and then
p33001
as(dp33002
g15
V34509
p33003
stp33004
a((dp33005
g2
(lp33006
VFor polymorphic nonpod type xvalue expressions, the dynamic type of the expression is generally unknown at compile time (so a typeid expression on them is evaluated, and virtual function calls cannot in general be devirtualized)
p33007
aVFor prvalues, that does not apply
p33008
aVThe dynamic type equals the static type
p33009
aVAnother difference is that  is an rvalue reference type for xvalues and a non-reference type for prvalues
p33010
aVYet another difference is that an lvalue to rvalue conversion is not done for prvalues (they are already what the result would yield)
p33011
aVThis can be observed by some rather weird code
p33012
as(dp33013
g15
V34509
p33014
stp33015
a((dp33016
g2
(lp33017
VI don't think there is any reason
p33018
aVThis error does not require a diagnostic (according to Standard C++), so the behavior is effectively undefined when you have this error in your code
p33019
aVYour compiler just hasn't checked the parameter list for this error but may well have done it
p33020
as(dp33021
g15
V34509
p33022
stp33023
a((dp33024
g2
(lp33025
g14557
aV3p1:
p33026
aVWhen the declarator-id is qualified,
p33027
aVthe declaration shall refer to a previously declared member of the class or namespace to which the qualifier
p33028
aVrefers (or, in the case of a namespace, of an element of the inline namespace set of that namespace (7
p33029
ag1037
aV1))
p33030
aVor to a specialization thereof; the member shall not merely have been introduced by a using-declaration
p33031
aVin the scope of the class or namespace nominated by the nested-name-specifier of the declarator-id
p33032
aVA  or  does not contain a declarator-id, so it is not affected by this rule
p33033
aVInstead, the  is part of an elaborated-type-specifier (7
p33034
ag2790
ag488
aV3)
p33035
as(dp33036
g15
V34509
p33037
stp33038
a((dp33039
g2
(lp33040
VThe question is whether there is a substitution phase of the deduced template arguments into the parameter list after argument deduction
p33041
aVThis phase is where default arguments will be used for template parameters that haven't yet been deduced
p33042
aVThe question for what deduction contexts this extra step is done and for what not is subject of an active core issue, http://www
p33043
aVopen-std
p33044
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33045
aVhtml#697
p33046
aVIf you do that extra substitution step, you need to also instantiate templates (otherwise the substitution step would make not much sense on its own)
p33047
aVYou could also just only pick the default arguments, without doing the substitution, but in the Standard these two things go together, so as an implementor I would not choose that path
p33048
aVPartial ordering is largely independent of the context for which partial ordering is being done (some context dependent things are considered - for example, function parameters that do not have explicit call arguments are ignored)
p33049
aVIt is also independent on whether or not a template parameter had an explicit template argument passed or not (so if you had given a value to , partial ordering would not have "remembered" it
p33050
aVClang and GCC do not do the substitution step and don't make use of template default arguments
p33051
aVSo when the  is compared against  to figure out , they say "huh, a non-deduced context
p33052
aVwe will say 'success, nothing to mismatch
p33053
aVfor this parameter"
p33054
aVThe same happens when it compares  against
p33055
aVWhen it compares the other direction along,  against ,  can too deduce that dependent type
p33056
aVSo for the second parameter, in both your tries both templates are at least as specialized as each other
p33057
aVHowever the important difference is that after the deduction, there must be values for all the parameters used in the parameter type list
p33058
aVIn most cases, all template parameters must have values in order for deduction to succeed, but for partial ordering purposes a template parameter may remain without a value provided it is not used in the types being used for partial ordering
p33059
aV[ Note: A template parameter used in a non-deduced context is considered used
p33060
aV\u2014 end note ]
p33061
aVIn your second try,  was deduced by the first parameter, so nothing bad happened after the comparisons of the parameter/argument types were done
p33062
aVIn the first try,  was left undeduced, and so the first template was not considered "more specialized" than the second in the aftermath
p33063
as(dp33064
g15
V34509
p33065
stp33066
a((dp33067
g2
(lp33068
VUpdate: This has now been added as an official C++ Issue
p33069
aVI have finally figured out how to read the paragraph in question
p33070
aVBelow I have bulleted it
p33071
aVIf for each type being considered a given template is at least as specialized for all types, and
p33072
aVmore specialized for some set of types and the other template is not more specialized for any types, or
p33073
aV{the other template} is not at least as specialized for any types,
p33074
aVthen the given template is more specialized than the other template
p33075
aVThis way the following first template is also more specialized than the second template
p33076
aVNote that the first template's parameter is at least as specialized as the second template, but is not defined to be "more specialized" - that term only applies for the case where both  parameters were references and certain conditions apply (see paragraph 9 of 14
p33077
ag14557
ag976
aV4)
p33078
aVThe rules are apparently not meant to follow any formal ordering laws
p33079
aVThe second template is not at least as specialized  as the first template
p33080
aVThis means that the second bullet applies, and not the first
p33081
as(dp33082
g15
V34509
p33083
stp33084
a((dp33085
g2
(lp33086
VYes, you cannot explicitly specify template arguments for a constructor template when you call it
p33087
aVBecause you never call it directly, but always implicitly through a cast or declaration
p33088
aVYou can specify them only when explicitly specializing or instantiating
p33089
aVThat's not really useful, but possible
p33090
as(dp33091
g15
V34509
p33092
stp33093
a((dp33094
g2
(lp33095
VNo, the second is not a temporary
p33096
aVA temporary is something that has a (mostly limited) lifetime and has a region of storage it lives in for its period of life
p33097
aVA  has neither of these
p33098
aVTherefor, such expressions are forbidden to be assigned
p33099
aVIt would not be clear what the assignment modifies from a language point of view
p33100
aVWill afterwards   equal
p33101
as(dp33102
g15
V34509
p33103
stp33104
a((dp33105
g2
(lp33106
VGenerally, there is as much "unsequenced" as possible
p33107
aVIt is not possible to make two functions run interleaving in C++
p33108
aVTherefor, it is not possible to run two  implementations interleaving
p33109
aVTherefor, for class types implementing , this is indeterminately sequenced
p33110
as(dp33111
g15
V34509
p33112
stp33113
a((dp33114
g2
(lp33115
VI believe what you really want to do is to automatically build the right type
p33116
aVAs for why your try did not work, see Templates don't always guess initializer list types
p33117
as(dp33118
g15
V34509
p33119
stp33120
a((dp33121
g2
(lp33122
VHere you have no copy of  being done
p33123
aVFun aside, I would recommend Jacks solutions (if it works with your type) :)
p33124
as(dp33125
g15
V34509
p33126
stp33127
a((dp33128
g2
(lp33129
VThe C++ Standard does not require a minimum
p33130
aVIt has a recommended minimum, but not a required one
p33131
aVNesting levels of compound statements, iteration control structures, and selection control structures [256]
p33132
aVOnce the limit of an implementation is exceeded, the behavior is undefined
p33133
as(dp33134
g15
V34509
p33135
stp33136
a((dp33137
g2
(lp33138
VA {1} can initialize an int
p33139
aVA {{1}} probably should not - there is a defect report on tbe committee for that
p33140
aVGCC forbids that and clang just tends to emit warnings about redundant braces currently
p33141
aVWhen X is a class that has copy or move constructors, then X ({
p33142
aV}) may invoke invoke one of them
p33143
aVNotice that X {
p33144
aV} may too, but is restricted to not allow user defined conversions (for a copy or move constructor)
p33145
aVNow with your A ({{{1}}}) the first brace is consumed by the copy/move constructor
p33146
aVThe second goes to the initializer list recursively
p33147
aVAnd the third goes to the contained int
p33148
aVAccording to the Standard, adding one more brace will break for A ({{{{1}}}})
p33149
aVBecause the second brace would need to be consumed by a copy/move constructor of A but need a user defined conversion sequence
p33150
aVThe same holds for A {{{{1}}}}, which is invalid for this reason too
p33151
as(dp33152
g15
V34509
p33153
stp33154
a((dp33155
g2
(lp33156
VIt's basically a question of what "entity" means here (the possible meanings are defined in clause 3)
p33157
aVConsider
p33158
aVIs 's type  or
p33159
aVIf you take entity to mean "member", it is  because the member  has type
p33160
aVIf you take the entity kind "object", then the type is either  or , depending on the result of
p33161
aVObjects, their existence and properties (including their type in general) is a runtime issue
p33162
aVI say that this is not a real ambiguity
p33163
aVBecause everyone knows what is meant and because the Standard uses the phrase "named by e" rather than "referred to by e" or "denoted by e" indicating that it is only the name lookup result that it is consulted
p33164
aVNote that the type of  is always , because the type of the expression  is  and it is an lvalue
p33165
as(dp33166
g15
V34509
p33167
stp33168
a((dp33169
g2
(lp33170
Vlead me to the following question what is the type of a->x if it is not a lvalue expression
p33171
aVYou are simply confused
p33172
aVif the name of an object is parenthesised, it becomes an lvalue expression
p33173
aVThat should be
p33174
aVif the name of an object is parenthesized, it is handled different by decltype
p33175
aVBoth the parenthesized and nonparenthesized things are lvalue expressions
p33176
aVIf you don't parenthesize, then decltype does not inspect the type of the expression, but the type used by the declaration that the name lookup found the name to refer to (for example, it could be  if name lookup resolves it to an rvalue reference variable, but the type of the expression is  and is an lvalue)
p33177
as(dp33178
g15
V34509
p33179
stp33180
a((dp33181
g2
(lp33182
VFor list initialization, if the element of the list has one element (here, ), and a constructor of a class  with parameter "reference to const/volatile X" is considered, no user defined conversions are considered
p33183
aVSo both the copy and move constructor of  cannot be used
p33184
aVSo the  constructor is unambiguously chosen
p33185
aVSo Clang is correct here
p33186
aVEDIT: For the Standards folks in here, see 13
p33187
ag1037
ag1037
aV1p4
p33188
as(dp33189
g15
V34509
p33190
stp33191
a((dp33192
g2
(lp33193
VA definition of a function required if you take its address (within an evaluated context)
p33194
aVOf course the definition can be given in a separate translation unit, but that doesn't change the fact that a definition is needed
p33195
aVIf only one member function is needed, that does not imply that other member functions are instantiated as well
p33196
aVIf the function template is undefined, it cannot be implicitly instantiated
p33197
aVIt must then be explicitly instantiated in another translation unit
p33198
aVRelying on an implicit instantiation in another translation unit is disallowed (but no diagnostic is required)
p33199
as(dp33200
g15
V34509
p33201
stp33202
a((dp33203
g2
(lp33204
VWe have no constraints or concepts yet in current C++, so your former template interface is more general than needed, because it accepts also types that are not streams in its interface
p33205
aVThis will cause easy ambiguities when you call your function template and it is overloaded
p33206
aVSo make your function template as generic as possible, but not more general than needed
p33207
aVYour effort is best put into something else in that case
p33208
as(dp33209
g15
V34509
p33210
stp33211
a((dp33212
g2
(lp33213
VThe problem here is that your compiler implements a rule that was present in only a pre-C++11 draft and was added there to make inheriting constructors work when the base class is only known via a typedef
p33214
aVSaying  then makes the using declaration refer to the base class constructors (in your case the parameter type is made incorrectly refering to the constructors of )
p33215
aVThe problem was that this handling was active even outside of using declarations
p33216
aVAfter a defect report noted that, the handling was reduced to only using declarations
p33217
aVSo your code is correct and the compiler is wrong
p33218
as(dp33219
g15
V34509
p33220
stp33221
a((dp33222
g2
(lp33223
VOn the other hand, being able to deduce an  for  is attractive to allow:
p33224
aVwhich was deemed desirable behavior since the very beginning of the EWG discussions about initializer lists
p33225
aVRather than coming up with a clever deduction rule for a parameter type  matched with a {}-list (an option we pursued in earlier sketches and drafts of this paper), we now prefer to handle this with a special case for "auto" variable deduction when the initializer is a {}-list
p33226
ag1388
ag1992
aV, for the specific case of a variable declared with an "auto" type specifier and a {}-list initializer, the "auto" is deduced as for a function  instead of as for a
p33227
aVSee chapter "Template argument deduction" in this PDF
p33228
aVhttp://www
p33229
aVopen-std
p33230
aVorg/jtc1/sc22/wg21/docs/papers/2008/n2640
p33231
aVpdf
p33232
aVFor the after-C++14, there is a paper that proposes to change these rules so that the one-element case deduces the type to the type of the initializer
p33233
aVThe zero and multiple element case is proposed to become ill-formed
p33234
aVhttp://www
p33235
aVopen-std
p33236
aVorg/jtc1/sc22/wg21/docs/papers/2013/n3681
p33237
aVhtml
p33238
as(dp33239
g15
V34509
p33240
stp33241
a((dp33242
g2
(lp33243
VNo, there is absolutely no way
p33244
aVDeduction fails if the element types are not of the same type
p33245
aVAnd no deduction is done at all if the parameter is not a  anyway (you are right that  doesn't have anything to do with the braces you give, but this is the simple rule for deduction to work)
p33246
aVThe template parameter values must be deduced by other function parameter positions involving them or must be explicitly specified
p33247
as(dp33248
g15
V34509
p33249
stp33250
a((dp33251
g2
(lp33252
VIn the first case, during overload resolution you have a perfect match requiring no conversion against an array to pointer conversion (which is in the category "lvalue transformation", along with lvalue to rvalue and function to pointer conversion)
p33253
aVA difference that is only made by an lvalue transformation is not sufficient for overload resolution to pick a winner
p33254
aVIn the second case, during overload resolution, both functions have the exact same parameter type
p33255
aVThen partial ordering as the last resort finds that the second template would accept all arguments you ever pass to it, wheras the first template only accepts arrays
p33256
aVTherefor the first template in the second case is found more specialized and taken
p33257
aVAs for your other question - no, overloading specifically for string literals is not possible
p33258
aVYou are always going to catch arrays of the same size along with them
p33259
as(dp33260
g15
V34509
p33261
stp33262
a((dp33263
g2
(lp33264
VYou need to declare you variables with default visibility to make it visible to other shared libraries or the main program
p33265
aVIt appears that you are compiling with , so that a symbol in the library does not resolve to a definition in the main program or other libraries and vice versa
p33266
aVWith the visibility attribute of GCC, you can reverse this effect
p33267
aVIn a nutshell
p33268
aVscope visibility of a declaration across entities of a single object file (global, local,
p33269
aVlinkage visibility of a declaration across entities of multiple object files (external, internal)
p33270
aVvisibility visibility of a declaration across entities of different shared libraries (default, hidden)
p33271
aVAnother possibility is that you are mixing C and C++ code and messing up with the language linkage
p33272
as(dp33273
g15
V34509
p33274
stp33275
a((dp33276
g2
(lp33277
VThis syntax
p33278
aVNames all constructors of
p33279
aVThis syntax
p33280
aVNames only a constructors that accept a template argument  (yes, you can do that, you can pass explicit template arguments to constructors in declarative contexts)
p33281
aVYour base class does not appear to have any constructor templates, so your compiler's parser does not take  as a template-name and hence does not accept the  as an opening template argument list
p33282
aVHence the syntax error
p33283
aVFor a template-name to be explicitly qualified by the template arguments, the name must be known to refer to a template
p33284
aVEven if you had a constructor template, a rule for using declarations forbids that too
p33285
aVIt says
p33286
aVA using-declaration shall not name a template-id
p33287
as(dp33288
g15
V34509
p33289
stp33290
a((dp33291
g2
(lp33292
VNo, but there not anymore is a need for this because you can say
p33293
aVThis will deduce the return type automatically from its body
p33294
as(dp33295
g15
V34509
p33296
stp33297
a((dp33298
g2
(lp33299
VBrace elision applies, but not in C++11
p33300
aVIn C++14, they will apply because of http://www
p33301
aVopen-std
p33302
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p33303
aVhtml#1270
p33304
aVIf you are lucky, Clang will backport that to their C++11 mode (let's hope they will
p33305
as(dp33306
g15
V34509
p33307
stp33308
a((dp33309
g2
(lp33310
VIt is not true that the only purpose is to make the program fail to compile
p33311
aVIn the following,  is "ill-formed; no diagnostic required", while V1 is well-formed
p33312
as(dp33313
g15
V34509
p33314
stp33315
a((dp33316
g2
(lp33317
VThere are no performance penalties involved
p33318
aVThe return value is constructed equivalent to
p33319
aVThere is not even a single copy or move of an  instance involved
p33320
as(dp33321
g15
V34509
p33322
stp33323
a((dp33324
g2
(lp33325
VCopying what I said in my comment
p33326
aVThis is http://cplusplus
p33327
aVgithub
p33328
aVio/LWG/lwg-active
p33329
aVhtml#2193
p33330
aVI'm not sure whether the "proposed resolution" or something equivalent makes it into C++14 or not
p33331
aVThe fact whether or not value initialization using explicit default constructors in a copy initialization context is wellformed or not itself is also a core-language DR http://open-std
p33332
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33333
aVhtml#1518 , which explains possibly cross-compiler differences
p33334
aVIf your implementation implements http://www
p33335
aVopen-std
p33336
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p33337
aVhtml#1494 and the following would be valid syntax for a default argument you could have done
p33338
aVUnfortunately, this is not allowed (I think the reason my be that passing an argument explicitly, you can't direct-initialize a parameter either, so why allow it for default arguments
p33339
aVSo it appears to me the only way is to explicit create it
p33340
aVDecide whether you wanna get away with the redundancy at the cost of possibly more code
p33341
aVSome alternatives
p33342
as(dp33343
g15
V34509
p33344
stp33345
a((dp33346
g2
(lp33347
VThis is by design
p33348
aVThe "foreach" loop doesn't look at the qualifiers or the reference qualifiers of the iteration variable when determining whether to treat  as const
p33349
aVWorkaround is to add the const explicitly
p33350
as(dp33351
g15
V34509
p33352
stp33353
a((dp33354
g2
(lp33355
VThis is specified in 8
p33356
aV2p7
p33357
ag3311
aVAnother ambiguity arises in a parameter-declaration-clause of a function declaration, or in a type-id that
p33358
aVis the operand of a sizeof or typeid operator, when a type-name is nested in parentheses
p33359
aVIn this case,
p33360
aVthe choice is between the declaration of a parameter of type pointer to function and the declaration of a
p33361
aVparameter with redundant parentheses around the declarator-id
p33362
aVThe resolution is to consider the type-name
p33363
aVas a simple-type-specifier rather than a declarator-id
p33364
aVHence, your parameter has type , as you show in your first possible interpretation
p33365
as(dp33366
g15
V34509
p33367
stp33368
a((dp33369
g2
(lp33370
VYou can use an alias template to get an unqualified type name when all you have is a qualified type name
p33371
aVThe following should work
p33372
aVNote that if the  thing worked, it would still be dangerous, because by the qualified type name, you would inhibit an virtual destructor call
p33373
aVBy using the alias template, virtual destructors still work
p33374
aVNote that GCC4
p33375
aV8 appears to accept
p33376
aVClang rejects this
p33377
aVI have long given up trying to understand how destructor name lookup works (if you look into the clang source, you will note that the clang developers also do not follow the spec, because they say that it makes no sense here)
p33378
aVThere exist DRs that cover destructor call syntax and how they are messed up
p33379
aVTherefor, I would recommend not using any complicated syntax here
p33380
as(dp33381
g15
V34509
p33382
stp33383
a((dp33384
g2
(lp33385
VYes, but in C++ the lifetime of the array is actually something temporarily (only is alive for the duration of its surrounding expression statement, roughly speaking)
p33386
aVIn your C99 example, the lifetime of the array will be its surrounding block, actually
p33387
aVThen you can say
p33388
aVThe sole purpose of the user-defined constructor is to prevent the zero-initialization of  when you do the the
p33389
aVIf you want to have it initialized, remove the constructor
p33390
aVOf course, boost::array just works aswell
p33391
as(dp33392
g15
V34509
p33393
stp33394
a((dp33395
g2
(lp33396
VThey can all be the same
p33397
aVEven  and  in the following can be the same
p33398
aVcan overlap with
p33399
as(dp33400
g15
V34509
p33401
stp33402
a((dp33403
g2
(lp33404
VThat's because of a class has no initializer-list constructor, a  initializer is treated as calling the set of constructors with three arguments, ,  and
p33405
aVSo to make your example work, slap in another  that accounts for this peeling-off of the outer-most braces
p33406
as(dp33407
g15
V34509
p33408
stp33409
a((dp33410
g2
(lp33411
VSuch behavior is not correct
p33412
aVSee 8
p33413
ag1014
aV4p3 4rd last bullet
p33414
aVThis was the case for pre-standard drafts for some time, but is not the case in C++11
p33415
aVIt seems you are confused: In no case there should a temporary be created
p33416
aVBoth cases should initialize a reference with another reference
p33417
aVOnly in the second case, some pre-standard drafts said that a temporary should be created and bound to the member reference, instead of initializing the reference directly
p33418
aV(See Number 27 in this list)
p33419
as(dp33420
g15
V34509
p33421
stp33422
a((dp33423
g2
(lp33424
VWhether  is valid is not explicitly said by the spec
p33425
aVIt is subject of a defect report (because the Standard can very reasonably be read to forbid it): http://www
p33426
aVopen-std
p33427
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33428
aVhtml#287
p33429
aVWhether  is invalid can also very reasonably be read to be true by the spec, and actually it makes quite a bit of sense (and aforementioned DR still keeps it ill-formed)
p33430
aVBecause you have an instantiation of a class , which references another class  during a period where a member  has not yet been declared, and that makes a reference back to
p33431
aVThat is ill-formed in the case of non-templates aswell (try to "forget" for a moment that you are dealing with templates: surely the lookup of  is done after the  template was completely parsed, but not after the specific instantiation of it was completely created
p33432
aVAnd it is the instantiation of it that actually will do the reference
p33433
as(dp33434
g15
V34509
p33435
stp33436
a((dp33437
g2
(lp33438
VYes, this is a known problem
p33439
aVSee http://www
p33440
aVopen-std
p33441
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33442
aVhtml#253
p33443
aVIt hasn't been fixed yet in the spec
p33444
as(dp33445
g15
V34509
p33446
stp33447
a((dp33448
g2
(lp33449
VIn your first code, both lines are "illformed, no diagnostic required" because "this" refers to the current instantiation, but no member was found and the class template has no dependent base classes
p33450
aVIt is neither a member of the current instantiation, nor of an unknown specialization
p33451
aVSee 14
p33452
ag488
ag976
aV1p6
p33453
as(dp33454
g15
V34509
p33455
stp33456
a((dp33457
g2
(lp33458
VThere are two important reasons for templates not to do any deduction (the two that I remember in a discussion with the guy in charge)
p33459
aVConcerns about future language extensions (there are multiple meanings you could invent - what about if we wanted to introduce perfect forwarding for braced init list function arguments
p33460
aVThe braces can sometimes validly initialize a function parameter that is dependent
p33461
aVIf  would be deduced at the right side to  but at the left side to , this would fail to work because of a contradictional argument deduction
p33462
aVThe deduction for  to  is controversial
p33463
aVThere exist a proposal for C++-after-14 to remove it (and to ban initialization with  or , and to make  deduce to the type of )
p33464
as(dp33465
g15
V34509
p33466
stp33467
a((dp33468
g2
(lp33469
VN3485 contains about "address constant expression"
p33470
aVAn address constant expression is a prvalue core constant expression (after conversions as required by the context) of
p33471
aVpointer type that evaluates to the address of an object with static storage duration
p33472
aVThe third character object of a string literal is such an object (see the elaborations on 2
p33473
aV14
p33474
aV5), not any less than the first one of it
p33475
aVNote that there is no use of variable, but object here (so we are allowed to access array elements aswell as class members to get an address constant expression, provided that the array or class object has static storage duration and the access does not otherwise violate the rules of core constant expressions)
p33476
aVTechnically there is a relocation in the object file that the linker will carry out:
p33477
aVWe will compile this down to an object file and look what it does
p33478
aVThe linker will take the value what is already in the section, and add it to the value of the symbol (by which is meant its address in the symbol table) referenced by the "VALUE" property of the relocation (in our case we added , so Clang/LLVM hardcoded a  in the section)
p33479
aVHowever, p1 has to be declared explicitly using constexpr in order to p2 be a valid statement
p33480
aVThat is because you are relying on its value, rather than its adress, to be constant
p33481
aVIn general (see below) you must previously mark it as constexpr so that the compiler at that point can validate that any later read access can definitely rely on getting a constant
p33482
aVYou may want to change it as follows and see it working (I THINK since there is a special case for initialized const objects of integral and enumeration types you can even read from the below  array in a constexpr context, even without it being marked
p33483
aVHowever my clang seems to reject it)
p33484
as(dp33485
g15
V34509
p33486
stp33487
a((dp33488
g2
(lp33489
VYou will ned to use some kind of SFINAE, unfortunately
p33490
aVDepending on what you actually want to do, you can require all of the  to be the same type with some more SFINAE hacks
p33491
as(dp33492
g15
V34509
p33493
stp33494
a((dp33495
g2
(lp33496
VFirst code, then what I think should happen
p33497
aV(In what follows, I will ignore the first parameter, since we are interested only into the second parameter
p33498
aVThe first one is always an exact match in your example)
p33499
aVPlease note that the rules are currently in flux in the spec, so I wouldn't say that one or the other compiler has a bug
p33500
aVThis code cannot call the  constructor in C++11, because  is an aggregate and  has no data member of type  (of course) or something else initializable by it (this is something ugly, and is worked on to be fixed - the C++14 CD doesn't have wording for this yet, so I am not sure whether final C++14 will contain this fix)
p33501
aVThe constructor with the  parameter can be called -  will be taken as the argument to the constructor of , and will initialize that constructor's
p33502
aVHence - second constructor called successfully
p33503
aVHere, the basically same argument counts counts for the constructor with the  parameter
p33504
aVFor the constructor with parameter type , it is a bit more complicated
p33505
aVThe rule for conversion cost in overload resolution computing the cost of initializing an  requires every element of the braced list to be convertible to
p33506
aVHowever we before said that  cannot be converted to  (as it is an aggregate)
p33507
aVIt is now important to know whether  is an aggregate or not
p33508
aVFrankly, I have no idea whether or not it must be considered to be an aggregate according to the Standard library clauses
p33509
aVIf we take it to be a non-aggregate, then we would be considering the copy constructor of , which however again would trigger the exact same sequence of tests (leading to "infinite recursion" in overload resolution checking)
p33510
aVSince this is rather weird and non-implementable, I don't think any implementation takes this path
p33511
aVIf we take  to be an aggregate, we will be saying "nope, no conversion found" (see the above aggregates-issue)
p33512
aVIn that case since we cannot call the initializer constructor with the single initializer list as a whole,  will be split up into multiple arguments, and the constructor(s) of  will be taking each of those separately
p33513
aVHence, in this case, we would end up with  initializing a  as the single parameter - which is perfectly fine and work like a charm
p33514
aVSo under the assumption that  is an aggregate, this is fine and call the second constructor successfully
p33515
aVIn this case and the next case, we don't have the aggregate issue like above with  anymore, since  has a user-provided constructor
p33516
aVFor the  parameter constructor, that parameter will be initialized by
p33517
aVAs  has no initializer lists, the list will be split up into individual argumets and call the move-constructor of  with an rvalue object of
p33518
aVFor the  parameter constructor, it is the same as the above case with  initialized by : Since  can be initialized by , the argument list is not split, and hence the braces are used to initializer that constructor'S
p33519
aVNow, both constructors work fine
p33520
aVThey are acting like overloaded functions here, and their second parameter in both cases requires a user defined conversion
p33521
aVUser defined conversion sequences can only be compared if in both cases the same conversion function or constructor is used - not the case here
p33522
aVHence, this is ambiguous in C++11 (and in the C++14 CD)
p33523
aVNote that here we have a subtle point to explore
p33524
aVThis counter intuitive result will probably be fixed in the same run with fixing the aggregate-initialization weirdness mentioned above (both will call the first f)
p33525
aVThis is implemented by saying that  becomes an identity conversion (as is )
p33526
aVCurrently, it is a user-defined conversion
p33527
aVSo, ambiguity here
p33528
aVFor the constructor with parameter , we again split the arguments and get  argument passed to the constructor(s) of
p33529
aVRemember that  has a copy constructor
p33530
aVBut the complication here is that we are not allowed to use it (see 13
p33531
ag1037
ag1037
aV1p4), because it would require a user defined conversion
p33532
aVThe only constructor left is the one taking , but an  cannot be initialized by
p33533
aVFor the constructor with parameter , the  can initialize a , because  is convertible to  (other than with  above - dang, aggregates)
p33534
aVSo, second constructor called successfully
p33535
aVSummary for all 4
p33536
aVsecond constructor called successfully
p33537
aVunder the assumption that  is an aggregate, this is fine and call the second constructor successfully
p33538
aVambiguity here
p33539
aVsecond constructor called successfully
p33540
as(dp33541
g15
V34509
p33542
stp33543
a((dp33544
g2
(lp33545
VThis issue was discussed on the MSVC++ bugstracker page some years ago (so if it is not fixed yet, it is a known issue on MSVC++)
p33546
aVThe Standard says
p33547
aVthe base or member is direct-initialized with the corresponding base or member of x
p33548
aVI did test various compilers when I read the bugreport, and all of them "magically casted"
p33549
aVThe Standard appears to be quiet on the very details (also about the value category and c/v qualifiers), and just says "with the corresponding base
p33550
aVof x", which IMO makes much more sense if you take it to mean "with not x, but with the corresponding base
p33551
aVof x" rather than that you pass it the complete object (I would even go as far as saying that it can only make sense that way)
p33552
as(dp33553
g15
V34509
p33554
stp33555
a((dp33556
g2
(lp33557
VYou can use dynamic_cast
p33558
aVIf the dynamic type of  is a  or derives from it, the code within the  will be executed with  being readily available (the static type of  is )
p33559
aVIf you already know that it is a , you can use references
p33560
aVFor this to work, there must at least be one  function (if only the destructor) in
p33561
as(dp33562
g15
V34509
p33563
stp33564
a((dp33565
g2
(lp33566
VThis is a known problem with the C++11 wording
p33567
aVThe C++14 CD doesn't have this problem fixed either (see http://www
p33568
aVopen-std
p33569
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33570
aVhtml#1467 for the corresponding DR)
p33571
aVWe can hope for compilers to implement a future fix for this in their C++11 and C++14 mode retroactively
p33572
aVThe next issues list revision should contain proposed wording for issue 1467 that fixes this issue
p33573
as(dp33574
g15
V34509
p33575
stp33576
a((dp33577
g2
(lp33578
VGCC is right according to C++11
p33579
aVIn C++14, this will be allowed
p33580
aVSee http://www
p33581
aVopen-std
p33582
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p33583
aVhtml#482
p33584
as(dp33585
g15
V34509
p33586
stp33587
a((dp33588
g2
(lp33589
VThe "universal reference" deduces the parameter to
p33590
aVThe first template also deduces the parameter to
p33591
aVC++ has a partial ordering rule for function templates that makes  be more specialized than
p33592
aVHence the first template must be chosen in your example code
p33593
as(dp33594
g15
V34509
p33595
stp33596
a((dp33597
g2
(lp33598
VA qualified name in C++ always must refer to a previously declared name
p33599
aVThis is specified in clause 8
p33600
aV3 and 3
p33601
ag2670
ag1037
ag976
aVYou cannot firstly declare a variable or member by using a qualified name - it will end up in a "cannot resolve identifier"-liky compiler error
p33602
aVSuch qualifiers are designed to be used for redeclaration
p33603
aVHence the requirement that these names must find previously declared entities
p33604
as(dp33605
g15
V34509
p33606
stp33607
a((dp33608
g2
(lp33609
g2790
aVHere is how I think your first case,  works
p33610
aVFirst, I believe (means, I am not totally sure) that 14
p33611
ag488
ag976
aV1p5 should say "unqualified-id" instead of "id-expression"
p33612
aVBut independent of that, your name  is actually composed out of two names (in the Standard, each nested nested-name-specifier followed by a member name is called "qualified-id", even if grammatically, these are not qualified-id productions
p33613
aVSo a name  is a qualified-id but also contains 1 other "qualified-id" aswell)
p33614
aVand
p33615
aVThe former is not "An id-expression denoting the member in a class member access expression", so you can't simply apply the rule that applies to  to apply also to
p33616
aVis therefor non-dependent and albeit it will need to be looked up within a dependent type will have to be found at definition time
p33617
aVI personally think that we should have a clause that says "When looking up a qualified-id where the qualifier is type-dependent, name lookup yields an empty result
p33618
aV, to handle these "force name-lookup to be done immediately" gracefully
p33619
aVSo anyway, in the end, I think your first case is ill-formed by not finding  (clause 3
p33620
aV4 can't just decide by itself over the head of clause 14 that the name is actually dependent anyway)
p33621
ag976
aVFor your other case, , things are easier
p33622
aVYou again have two names,  and
p33623
aVAgain, I found nothing that says that  is a dependent name here (I am not sure whether that would be wrong or not
p33624
aVThat's beyond me)
p33625
aVName lookup comparison (say, the equality function of the name lookup hash table) for operator function names is "they are conversion-function-ids formed with the same type" (3
p33626
aV8)
p33627
aVThis means that in order to form the name itself (not yet doing name lookup
p33628
aV, you not only have to give the lexical spelling as is the case for identifiers, but you have to provide a type identity, which needs to be provided by
p33629
aVThat the lookup of the dependent id-expression in  is delayed simply means that the semantic type comparison is delayed
p33630
aVTry this one, which should work fine
p33631
aVYour followup
p33632
aVIf it is intended that such a name is not dependent, what is the rationale for this decision
p33633
aVI can see that it makes life easier for the implementor if they do not have to defer evaluation of a construct like t
p33634
aVoperator X::Dependent* or t
p33635
aVX::Dependent::f where X could be either a namespace or a type name
p33636
aVI don't know the rationale, but I think you already have given a good point
p33637
aVThis looks very much to the rule that skips dependent base classes when looking up unqualified names
p33638
aVAnd I think what rationale applies for that case applies for this case aswell
p33639
aVIt makes it easier to reason on the function template for the programmer, especially
p33640
aVThe code looks fine, but if  happens to have a  member, suddenly  would have a different binding (because first we are told to look into 's class, and then into the surrounding scope)
p33641
aVUnder my current understanding of the templating rules, the above always refers to the surrounding scope's , so the above code is "safe", regarding to that pitfall
p33642
as(dp33643
g15
V34509
p33644
stp33645
a((dp33646
g2
(lp33647
VSlots don't belong to any particular thread, as they are just plain functions
p33648
aVBut objects do
p33649
aVIf you connect a signal to a slot by , the signal emission will create an event and send that into the event queue of the target
p33650
aVQt will arrange that your slot will be called when internally processing that event
p33651
aVAs for all events, they are processed in the thread of the object's thread affinity
p33652
aVYou can change that thread by calling  on the target object
p33653
as(dp33654
g15
V34509
p33655
stp33656
a((dp33657
g2
(lp33658
VThe substitution and deduction is not lexically like with a macro
p33659
aVwill not become  but
p33660
aVThe second volatile comes from the template
p33661
aVThat makes T equal  for the first parameter
p33662
aVTry to free yourself from sticking the volatile always at the beginning, but put it qhere it belongs according to the actual type
p33663
aVA volatile pointer has the volatile after the star, not before it
p33664
as(dp33665
g15
V34509
p33666
stp33667
a((dp33668
g2
(lp33669
VThis happes when general object oriented terms are mixed with C++ related terms
p33670
aVsubobject: Any object that is stored within another object (array elements, base class objects and data member objects)
p33671
aVsub-class: A general object orientation term refering to what in C++ is called the "derived class"
p33672
aVsuper-class: A general object orientation term refering to what in C++ is called the "base class"
p33673
aVcomplete object: Any object that is not stored within another object
p33674
aVJust a little hint - When talking in C++ land, I try to use the C++ terminology
p33675
aVWhen talking in Java land, I'm trying to talk with the Java terminology
p33676
as(dp33677
g15
V34509
p33678
stp33679
a((dp33680
g2
(lp33681
VTo fix the code, cast to  instead of to
p33682
aVWhen casting to the reference, the subsequent creation of a  wont allow explicit constructors
p33683
aVDirectly specifying the class type will directly create an object of it and allow explicit constructors to be used
p33684
as(dp33685
g15
V34509
p33686
stp33687
a((dp33688
g2
(lp33689
VWhen in your code either you don't know the type of  and want to stay generic, or in your code it is absolutely clear what type  has (definition right at the line above, etc), so that the  will not add confusion
p33690
aVThe form of the initialization, parens or not, is irrelevant (only relevant to language lawyers, as there are subtle differences)
p33691
aVUse what you feel more comfortable with
p33692
aVIf in your code it is not clear what  is (definition too far apart, etc
p33693
aV, or if you don't know the type of  but want  to be of the type
p33694
aVUse the first form if you want to keep working with the "kind of value" that "expr" has (i
p33695
aVe if  is a string and  is of a string type)
p33696
aVIf you build up a whole new kind of value (i
p33697
aVe a , and  is the widget's color), use the second form
p33698
aVNever use this in current C++ (and probably within the next few years)
p33699
aVIt will declare  to be an
p33700
aVIf you want that, use the type directly and write it out
p33701
aVIt is way too subtle (and there are proposals for beyond-C++14 to change this fact, so there is hope that you can write this in C++17 or something like that)
p33702
aVIf you want to protect yourself from narrowing conversions (i
p33703
aVe going from  to  accidentally), or if you want to initialize a class that has an initializer list constructor, or if you have an aggregate the member(s) of which you want to initialize, use this form
p33704
aVAlternatively, you may use the following if you are dealing with an initializer list constructor, an aggregate or simple non-class type
p33705
aVI would not use it for calling an arbitrary constructor
p33706
aVI would use the following form for that
p33707
aVHowever, there are people who prefer to use the braces form for that too
p33708
aVI like to know for sure what my code is doing, hence when I want to call a constructor, and don't want to randomly do an aggregate or list initialization constructor call instead, I use parens instead of braces
p33709
ag26105
as(dp33710
g15
V34509
p33711
stp33712
a((dp33713
g2
(lp33714
VYou can transform these to
p33715
aVThe first is special - it is a , but still accepts rvalues, unlike other non-const lvalue references
p33716
aVIn all other regards, it is the same as any other function with a  parameter
p33717
aVThere is no difference in overload resolution between the second () and the fourth (, except if they respectively compete against a ()
p33718
aVI don't think that can happen for normal functions, but only for conversion functions, because the Standard forbids this case (in general, if there is any function in the current scope with a ref qualifier, all functions must)
p33719
aVBut with conversion functions, you can still have an overload resolution set with both  and
p33720
aVIn that case, even if the object on which they are invoked is  (an rvalue), if you need to convert to  then the first conversion function would be used
p33721
as(dp33722
g15
V34509
p33723
stp33724
a((dp33725
g2
(lp33726
VThis is a defect in the Standard, handled as http://www
p33727
aVopen-std
p33728
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33729
aVhtml#325
p33730
aVThe problem is that name lookup in default arguments within classes should consider all class members (including the class members declared later), but when the default argument is , we only know what the default argument is once we have completely parsed the class (the default argument could be  or could be , with the comma terminating the default argument if  is not a template in the complete scope of the class)
p33731
aVIn working around this problem, GCC and Clang apparently take differnet approaches on this
p33732
aVYou can simply fix your code by parenthesizing your default argument
p33733
as(dp33734
g15
V34509
p33735
stp33736
a((dp33737
g2
(lp33738
VIs this GCC 4
p33739
aV8 bug, or C++11 standard design flaw, or it is expected to be so
p33740
aVThis is expected to be so
p33741
aVActually, ironically, the Standard (draft) initially contained examples that suggested examples like yours to work
p33742
aVBut the normative text didn't allow that and the example was revised to not suggest this anymore
p33743
aVSee http://www
p33744
aVopen-std
p33745
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p33746
aVhtml#1244
p33747
aVIs there way to create "real" template alias in C++11
p33748
aVIn C++14
p33749
aVNo
p33750
aVIt was decided that this is a very special case of the general alias template and if at all this should be solved with a cleaner syntax that directly expresses the alias, when the above linked issue was discussed
p33751
aVAlias templates ultimately yield types (and are templated over types/"typedefs") and are not "template aliases" like they were called at some point in early drafting
p33752
as(dp33753
g15
V34509
p33754
stp33755
a((dp33756
g2
(lp33757
VThe type of an expression does not have any traces of references
p33758
aVSo if for a moment we assume that references could have reference type, then we would have the following
p33759
aVIn the above, the expression  would have type , and the expression  would have type
p33760
aVI think that in nearly all the rules of the spec that relate expressions to type, for example rules that say "expression E must be of type X", we would have to add "
p33761
aVor reference to type X" (think about cast operators)
p33762
aVSo my educated guess is that this would be too much of a burden to be useful
p33763
aVC++ has the following types
p33764
aVstatic type of an expression
p33765
aVJust called "type of the expression" (if not otherwise specified that the dynamic one is meant)
p33766
aVThis is a property of expressions that designate the type of expressions abstracted away of what the expression refers to at compile time
p33767
aVFor example if  refers to an  or  variable, or is a literal , all those expression have type
p33768
aVdynamic type of an lvalue expression
p33769
aVThis is the type that the non-base-class object that an lvalue expression refers to has
p33770
aVIn this,  has the static type  and the dynamic type
p33771
aVtype of an object or reference
p33772
aVThis is the type that an object or reference actually has
p33773
aVAn object always has a single type and its type never changes
p33774
aVBut what object exists at what location is something only known at runtime, so generally, "type of an object" is a runtime thing too
p33775
aVThe type of the object denoted by  (and the dynamic type of the lvalue  aswell) is  known only at runtime
p33776
aVHere, the type of the array that was created by operator new is only known at runtime too, and (thanksfully) does and can not escape to the static C++ type system
p33777
aVThe infamous aliasing rule (that forbids reading objects from incompatible lvalues, roughly speaking) speaks of "dynamic type" of objects, presumably because it wants to highlight that runtime concerns are of interests
p33778
aVBut strictly speaking, saying "dynamic type" of an object is weird, because an object doesn't have a "static type"
p33779
aVdeclared type of a variable or member
p33780
aVThis is the type that you gave in a declaration
p33781
aVIn relation to the type of an object or the type of an expression, this sometimes can be subtly different
p33782
aVHere, the expression  has type , but the declared type of the member that  resolves to has type  (the member entity)
p33783
aVThe type of the object denoted by  has type , because we created a  object with the  expression, and therefore all non-static data members are implicitly  subobjects
p33784
aVIn , the expression has type , and the declared type of the variable still has type  and the type of the object referred to still has type
p33785
aVWhen you say "type of a" and you declared "a" as "int &a;" you therefor always have to say what you mean by "type of a"
p33786
aVDo you mean the expression
p33787
aVThen "a" has type
p33788
aVIt can even become nastier
p33789
aVImagine "int a[10];"
p33790
aVHere the expression "a" has type  or  depending on whether you consider the array to pointer conversion to have taken place in your expression or not, when you ask for the "type of a"
p33791
aVIf you ask for the type of the variable referred to by "a", then the answer uniquely is  and  respectively
p33792
aVSo what type can an rvalue be of
p33793
aVRvalues are expressions
p33794
aVHere, we have rvalues , and
p33795
aVBoth rvalues have type
p33796
aVThe expression  appearing in the initializer for  is an lvalue, even though it refers to the same object that the rvalue  refers to
p33797
aVYour last point in your question about the overloaded function called with an rvalue or lvalue respectively is interesting
p33798
aVJust because rvalue references are written as  does not mean that rvalues have type
p33799
aVThey are called rvalue references because you can initialize them with rvalues and the language prefers that initialization over initializing an lvalue reference with an rvalue
p33800
aVAlso, it may be useful to see expressions in name-form that are rvalues
p33801
aVIf you use  or , they are rvalues
p33802
aVBut those cases are the only one that I can think of
p33803
as(dp33804
g15
V34509
p33805
stp33806
a((dp33807
g2
(lp33808
VBecause the syntax says , not expression or some other non-terminal matching
p33809
aVFor all the time only  has worked
p33810
aVEven  would be ill-formed because it does not match the syntax
p33811
aVEdit
p33812
aVClang allows ,  and  (31
p33813
aV12
p33814
aV2013)
p33815
aVThat is incorrect and should be fixed in the compiler, of course
p33816
as(dp33817
g15
V34509
p33818
stp33819
a((dp33820
g2
(lp33821
VAs to why GCC allows it - sure because the Standard requires it to be valid
p33822
aVBuilding the transitive closure to the rationale of the rule in the Standard, I'm pretty sure that GCC allows this because it's useful in the event of templates
p33823
aVAs you see,  did not need to do a special case for  in the return statement
p33824
aVSort of similar to how  is allowed even if  ends up as
p33825
as(dp33826
g15
V34509
p33827
stp33828
a((dp33829
g2
(lp33830
VThere is no integral promotion from  to , therefor it is still illformed
p33831
aVThat would be an integral conversion
p33832
as(dp33833
g15
V34509
p33834
stp33835
a((dp33836
g2
(lp33837
VThis is a known bug and will hopefully be fixed in C++17 (not for C++14, see http://www
p33838
aVopen-std
p33839
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33840
aVhtml#1467)
p33841
aVYour struct is an aggregate, so to initialize it with  there needs to be at least one data member, as you have discovered
p33842
aVTry providing an  and you will see it compiles
p33843
as(dp33844
g15
V34509
p33845
stp33846
a((dp33847
g2
(lp33848
VThe spec says
p33849
aVAn instance of each object with automatic storage duration (3
p33850
ag3311
aV3) is associated with each entry into its block
p33851
aVSuch an object exists and retains its last-stored value during the execution of the block and while the block is suspended (by a call of a function or receipt of a signal)
p33852
aVis an object with automatic storage duration
p33853
aVSo, when you are outside the object's block, the object does not exist anymore
p33854
aVYou can jump before it and continue write to it, I believe, but not if you jump outside its block
p33855
aVThat's too much stretching it
p33856
as(dp33857
g15
V34509
p33858
stp33859
a((dp33860
g2
(lp33861
VA good (IMO) thing to remember is that it is called operator overloading because you overload the meaning, so that  doesn't necessarily need to have the same meaning as the builtin  operator
p33862
aVExpression template libraries are an example where it is useful to be able to declare different return types
p33863
as(dp33864
g15
V34509
p33865
stp33866
a((dp33867
g2
(lp33868
VMight be artificial, but it does make a little difference
p33869
aVWhether it's a practical difference
p33870
aVI don't really know
p33871
aVIf  is a template parameter and you say , it might happen in practice
p33872
as(dp33873
g15
V34509
p33874
stp33875
a((dp33876
g2
(lp33877
VThe compiler is not allowed to issue an error for this code, because nowhere the copy constructor of  is used
p33878
aVUnless used somewhere and in need of an instantiation, a compiler is not allowed to instantiate the body of a member function of a class template (the initializer list counts as belonging to the constructor function body)
p33879
aVHence you are allowed to put code into such bodies that is only valid for some, but not all, template arguments
p33880
aVIt then depends on the user of the template whether ultimately his program becomes invalid or not
p33881
aVIf you would try to copy a , you would notice that you get an error because that would trigger the implicit definition of 's copy constructor and then would instantiate 's constructor
p33882
as(dp33883
g15
V34509
p33884
stp33885
a((dp33886
g2
(lp33887
VA "namespace-scope function" is a function that is a member of a namespace (i
p33888
aVe the "scope" here means the "home scope" of the function)
p33889
aVThe later statement links to 3
p33890
ag2670
aV1, which has to say
p33891
aVName lookup for a name used in the definition of a friend function (11
p33892
aV3) defined inline in the class granting friendship shall proceed as described for lookup in member function definitions
p33893
as(dp33894
g15
V34509
p33895
stp33896
a((dp33897
g2
(lp33898
VThat's a defective warning
p33899
aVYou did initialize all the members, you just didn't have the initializers for each member separately appear in the code
p33900
aVJust ignore that warning, if you know what you are doing
p33901
aVI regularly get such warnings too, and I'm upset regularly
p33902
aVBut there's nothing I can do about it but to ignore it
p33903
aVWhy is the uninitialized struct not giving a warning
p33904
aVI don't know, but most probably that is because you didn't try to initialize anything
p33905
aVSo GCC has no reason to believe that you made a mistake in doing the initialization
p33906
as(dp33907
g15
V34509
p33908
stp33909
a((dp33910
g2
(lp33911
VFor the first, you are hitting http://www
p33912
aVopen-std
p33913
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33914
aVhtml#1673 (see the last testcase): If list initialization passes only a single element to a copy/move constructor of some class , user defined conversions are not allowed on that single element to convert it to the  parameter
p33915
aVAlso see http://llvm
p33916
aVorg/bugs/show_bug
p33917
aVcgi
p33918
aVid=12117 which made Clang implement this rule
p33919
aVFor the second: You are hitting http://www
p33920
aVopen-std
p33921
aVorg/jtc1/sc22/wg21/docs/cwg_active
p33922
aVhtml#1467 (but instead of using an object of the same type, you use an object of an unrelated type)
p33923
aVYour aggregate simply doesn't provide a data member of type
p33924
aVFor the third: Neither of the above two situations apply, so the list initialization works and calls the  constructor of
p33925
aVThe  initialization fails because it is only allowed to try converting the  to an  in a single user defined conversion sequence
p33926
aVBut here you would need to first convert to  and then to  again
p33927
aVFor list initialization, this restriction of doing only one user defined conversion does not exist
p33928
as(dp33929
g15
V34509
p33930
stp33931
a((dp33932
g2
(lp33933
VNo
p33934
aVThe compiler can first call  twice and then do the two  calls in the first example code
p33935
aVBut not in the second example code
p33936
aVThere is nothing that stops the compiler from sticking something in between the evaluation of function arguments and the call of the function
p33937
aVAs long as the call actually happen after the evaluation of the call arguments (of that function)
p33938
aVIn Standardese terms
p33939
aVWhen calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function
p33940
aVDifferent expressions generally are unsequenced (unless there is explicit wording that sequences them)
p33941
aVYour two calls to  are such unsequenced cases, so that one of the calls to  can appear after the other (and before the call to any of the )
p33942
as(dp33943
g15
V34509
p33944
stp33945
a((dp33946
g2
(lp33947
VIn http://www
p33948
aVopen-std
p33949
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p33950
aVhtml#654 , Jason Merril argues
p33951
aVAnything we can do with an arbitrary pointer, we ought to be able to do with nullptr_t as well
p33952
aVI think the following (slightly artificial) example supports that argument (although I am not totally sure if it was intended for this case)
p33953
aVWhich would allow passing  along with other pointer types compatible with whatever  accepts
p33954
as(dp33955
g15
V34509
p33956
stp33957
a((dp33958
g2
(lp33959
VTry this
p33960
aVSo that the optional parameters in  (which have default arguments because your boost's tuple implementation uses that to simulate variadic templates) don't make the first  contradict with the later  expansion that only has the required explicitly passed arguments
p33961
as(dp33962
g15
V34509
p33963
stp33964
a((dp33965
g2
(lp33966
VI have been asked to create an answer
p33967
aVYou need to wrap the number in a type
p33968
as(dp33969
g15
V34509
p33970
stp33971
a((dp33972
g2
(lp33973
VI remember a WG21 core discussion about this, and one of the Clang developers defended their position by citing 14
p33974
ag3311
aV1p7
p33975
aVIf the overload resolution process can determine the correct function to call without instantiating a class template definition, it is unspecified whether that instantiation actually takes place
p33976
aVOn the other hand, for an ill-formed program (which is the case here when doing the required instantiation), there is no such notion of "the correct function to call", so I agree to the position of another guy in that discussion who said that he can't see that this allows Clang to go that route
p33977
aVIn the example of p7 it shows code that is well-formed both with and without doing the additional instantiation
p33978
aVIn any case, even if Clang is allowed to do it, the well-formedness of your program would then rely on particular happenstances (unspecified behavior)
p33979
aVThe Standard therefore doesn't anymore require your program to be accepted, and honestly I don't know what that means
p33980
aVI regard such code as being ill-formed
p33981
as(dp33982
g15
V34509
p33983
stp33984
a((dp33985
g2
(lp33986
VEvery function in C++ is a member
p33987
aVMember of a namespace
p33988
aVThese are sometimes called "global functions", although that termis not completely correct
p33989
aVThey consist of all functions in the global namespace and any functions in user defined namespaces, hence they are called namespace-scope functions
p33990
aVMember of a class
p33991
aVThese are called member functions (even though they are not the only functions that are members
p33992
aVThey can be further separated by non-static member functions and static member functions (I take it you know the difference of this from Java)
p33993
as(dp33994
g15
V34509
p33995
stp33996
a((dp33997
g2
(lp33998
VWhen I have functions, I prefer to stay with functions (which is more beneficial with member functions, because you still have access to )
p33999
as(dp34000
g15
V34509
p34001
stp34002
a((dp34003
g2
(lp34004
VWhat I've summarized is the process described at 14
p34005
ag14557
ag976
aV1p1
p34006
aVTemplate argument deduction is done by comparing each function template parameter type (call it P) with the type of the corresponding argument of the call (call it A) as described below
p34007
aVIn our case, we have for P  and for A, we have
p34008
aVFor the first pair of P/A, which is  against , we can match  to  (by the process described in 14
p34009
ag14557
ag976
aV5)
p34010
aVBut for the second "pair", we have  but have no counterpart
p34011
aVThus deduction cannot be made for this "pair"
p34012
aVThereby, by 14
p34013
ag14557
ag976
aV5p2, "If type deduction cannot be done for any P/A pair,
p34014
aV, template
p34015
aVargument deduction fails
p34016
aVYou then won't ever come to the point where you substitute template arguments into the function template
p34017
aVThis can all probably described more precisely in the Standard (IMO), but I believe this is how one could implement things to match the actual behavior of Clang and GCC and it seems a reasonable interpretation of the Standardese
p34018
as(dp34019
g15
V34509
p34020
stp34021
a((dp34022
g2
(lp34023
VThe syntax when using them in one case means different things
p34024
aVIn the first case, we are defining a struct called , and in the second case we are defining an object called
p34025
as(dp34026
g15
V34509
p34027
stp34028
a((dp34029
g2
(lp34030
VHere's how it could work (using the  of C++1y)
p34031
aVNot sure of your design of using that reference parameter, though
p34032
aVThis is how I would change it
p34033
aVThis is completely compatible with a layer of indirection
p34034
aVI reversed the order, so that I multiple parameters could be given as simply a sequence without wrapping them
p34035
aVBut that's just a matter of taste
p34036
as(dp34037
g15
V34509
p34038
stp34039
a((dp34040
g2
(lp34041
VIt is not entirely correct that you can't have array temporaries
p34042
aVYou can
p34043
aVStarting with C++14, you are also allowed to pass a braced init list directly to the rvalue overload
p34044
as(dp34045
g15
V34509
p34046
stp34047
a((dp34048
g2
(lp34049
VOverloads the function by delegating
p34050
aVYou need to be careful not to define  in another namespace than , because then the call in the first  would not find the second  case when it is instantiated (this is because of a rule called ADL)
p34051
aVTo not think about this, you can also write a class template to delegate to
p34052
aVIn general I prefer the technique without a class, because it allows for member functions to still access  and its private members if  were a member function
p34053
aVTo be complete, there is also "explicit specialization" for functions, but because of its limits and pitfalls, I would not recommend it
p34054
aVIn this case it would work and would be
p34055
as(dp34056
g15
V34509
p34057
stp34058
a((dp34059
g2
(lp34060
V is equivalent to  if  is a class object and an overloaded member  is found
p34061
aVI hope it gets clearer from that
p34062
as(dp34063
g15
V34509
p34064
stp34065
a((dp34066
g2
(lp34067
VAdvantages over macros
p34068
aVDebuggers can print names for values
p34069
aVYour constants will be scoped (if you want, you can put them also in a namespace in C++)
p34070
aVThe compiler can warn if you forget an enum constant in a switch
p34071
aVValues for the constants are automatically assigned, if you don't give explicit values
p34072
aVThe enum type is always large enough to hold all the constants
p34073
aVWhen using , you have to commit to  or some typedef and ensure that all the constants fit manually
p34074
as(dp34075
g15
V34509
p34076
stp34077
a((dp34078
g2
(lp34079
VThat is the behavior required by the Standard and it's perfectly logical
p34080
aVA alias template is not a template alias (despite intended by some to be)
p34081
aVInitially there appears to have been some confusion even in the Standard about this, see http://www
p34082
aVopen-std
p34083
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p34084
aVhtml#1244
p34085
aVIn the currently Standardized form, an alias template is like its non-templated counter part: It aliases a type
p34086
aVIn the template version, the type may be dependent
p34087
aVAnd it is immediately substituted
p34088
aVFor example  with  being itself a template parameter will be the dependent type  - in this sense the name alias template might be a bit confusing, because it suggests that there will be alias declaration instantiated at some point
p34089
aVBut actually the alias pattern is substitued immediately - in this sense the templated version is more like a dependent alias declaration that always exists and does not need to be instantiated, rather than being an alias declaration template
p34090
aVOn that end, it becomes a bit philosophical what precisely we mean with those terms, though
p34091
as(dp34092
g15
V34509
p34093
stp34094
a((dp34095
g2
(lp34096
VThe reason is that the Standard has been unclear what happens with non-deduced contexts that have part of compound types (pointer stars for example), thereby mismatching an argument but that still can accept the argument by implicit conversions
p34097
aVIssue http://www
p34098
aVopen-std
p34099
aVorg/jtc1/sc22/wg21/docs/cwg_defects
p34100
aVhtml#1184 did fix this by adding a note that says that similar to the situation where a function parameter contains no template parameters that are deduced, implicit conversions should be allowed aswell to bridge a mismatch
p34101
aVSince then, other issues have been found regarding the treatment of these "implicit conversions" during argument deduction for template parameters, and handled by http://www
p34102
aVopen-std
p34103
aVorg/jtc1/sc22/wg21/docs/cwg_active
p34104
aVhtml#1391
p34105
aVOverall, I think the effect of 1184 is that GCC should accept your code, but because of the issues in other cases reflected in #1391, they may have delayed their implementation of #1184  until the exact details are worked out
p34106
as(dp34107
g15
V34509
p34108
stp34109
a((dp34110
g2
(lp34111
VI don't know the official rational
p34112
aVBut surely it could lead to confusion
p34113
aVI, for one, can't see what it means for a non-static data member to be
p34114
aVAre you able to do the following
p34115
aVOr does it mean that the initializer must be constant always, i
p34116
aVe you are not allowed to write the above (because  is not constant/could potentially non-constant) but allowed to say
p34117
aVThe rule that  is simply ill-formed rather than being implicitly  seems good to me, as its semantics would not be clear IMO
p34118
as(dp34119
g15
V34509
p34120
stp34121
a((dp34122
g2
(lp34123
VYou should do "pass by value and then move construct" if your type's move constructor is cheap, and use "Pass by reference and then copy construct" otherwise
p34124
aVFor lvalues
p34125
aVPass by value and then move construct
p34126
aVYou will be doing one copy followed by one move
p34127
aVPass by reference and then copy construct
p34128
aVYou will be doing one copy
p34129
aVFor Rvalues
p34130
aVPass by value and then move construct
p34131
aVIn the best case (when the rvalue is a temporary expression) you will be doing no copy/no move, followed by a move
p34132
aVIn the normal case (when the rvalue is not a temporary expression) you will be doing a move followed by another move
p34133
aVPass by reference and then copy construct
p34134
aVYou will be doing one copy
p34135
as(dp34136
g15
V34509
p34137
stp34138
a((dp34139
g2
(lp34140
VClang supports lambda that operate on pack expansion elements directly, unfortunately GCC can't handle this yet
p34141
as(dp34142
g15
V34509
p34143
stp34144
a((dp34145
g2
(lp34146
VI covered a similar issue here: http://stackoverflow
p34147
aVcom/a/2450157/34509
p34148
aVRepasting my code because this seems to be what you are after
p34149
aVPlease see the referred answer for a detailed explanation
p34150
aVFor example
p34151
as(dp34152
g15
V34509
p34153
stp34154
a((dp34155
g2
(lp34156
VThe default run function then calls exec, which enters an event loop
p34157
aVThe loop sleeps if it doesnt have an event to process
p34158
aVThe object that you move to the thread is not the QThread object itself
p34159
aVIt is another object
p34160
aVThe QThread object itself just has the event loop and is still associated with the main thread (its affinity is the main thread)
p34161
aVIf the thread operates in the background, you best use QString as the filename and then call a respective "processFile" function or similar of that object that you pass the file name
p34162
aVThe invocation can either be by a signal slot connection or an explicit QMetaObject::invokeMethod, using the connection type QueuedConnection (which passes an event into the event loop of the thread of the object, so your file names are automagically queued by being contained in that internal slot call event)
p34163
as(dp34164
g15
V34509
p34165
stp34166
a((dp34167
g2
(lp34168
VThis is valid
p34169
aVIn unevaluated operands (decltype, sizeof among others) you can name nonstatic datamembers without an object expression, within arbitrary subexpressions
p34170
aVNote that that this does not apply to nonstatic member functions, but only to data members
p34171
as(dp34172
g15
V34509
p34173
stp34174
a((dp34175
g2
(lp34176
VThe use of  in this code yields either undefined behavior or is redundant:
p34177
aVIf the object pointed to by  is not volatile, then accesses (including reads) with the addition of  is statically deemed as causing a side effect (to accomodate cases where the compiler cannot statically find out whether an access really uses a volatile object), but is not required to be carried out at all costs, since the side effect on the nonvolatile object does not constitute observable behavior
p34178
aVIf the object that you call  on is volatile, then the code has undefined behavior because it accesses a volatile object through an lvalue of nonvolatile type before that call in the previous lines
p34179
aVThe code probably relies on an implementation not optimizing away the volatile access because of compatibility with existing code
p34180
as(dp34181
g15
V34509
p34182
stp34183
a((dp34184
g2
(lp34185
VI think Clang might be right in rejecting this
p34186
aV14
p34187
aV2p2 says about
p34188
aVIf an expression e involves a template parameter, decltype(e) denotes a unique dependent type
p34189
aVIn DR #2, the discussion trace says
p34190
aVMy opinion (which I think matches several posted on the reflector recently) is that the out-of-class definition must match the declaration in the template
p34191
aVIn general, if you can match the declarations up using only information from the template, then the declaration is valid
p34192
aVI think it still matches if one of them uses a typedef (as demonstrated in the DR), because  is a member of the current instantiation and the type aliased can be looked up directly
p34193
aVBut a , as specified above, will always denote a unique type (during template parse time) except with respect to another  that specifies an equivalent expression
p34194
aVWhy did I say might
p34195
aVBecause of 14
p34196
aV6p8
p34197
aVNo diagnostic shall be issued for a template for which a valid specialization can be generated
p34198
aVOne could read this as saying the type equivalence check is simply delayed till after instantiation
p34199
aVThis, however, would contradict the discussion trace in the DR I think, because they say "if you can match the declarations up using only information from the template, then the declaration is valid" (and I assume the author of this statement meant to be exhaustive about the situations when the declaration is valid)
p34200
as(dp34201
g15
V34509
p34202
stp34203
a((dp34204
g2
(lp34205
VA declarative region is a place where names can be declared in
p34206
ag1388
ag1992
aVthey can be declared in a block,  a class body, or in the bodies of a namespace, etc
p34207
aVA scope is just some snippet of program text
p34208
aVIf you say "the scope of this name", this phrase refers to the part of the program text that this name can be found using the names unqualified form
p34209
aVCurrently these two terms are in defective form in the standard, and there is a long standing active issue to fix these defects
p34210
as(dp34211
g15
V34509
p34212
stp34213
a((dp34214
g2
(lp34215
VNo, because rvalue references don't need to be , so the Standard quote is correct
p34216
aVThe lifetime is still enlargened
p34217
aVThe constraints that make the code invalid for non-const lvalue reference is at clause 8 (notice that it is not the right place to just add "const" and "rvalue reference" etc in the paragraph you quoted
p34218
aVYou need an active rejection of such bindings, not just saying that the lifetime of such bindings are not enlarged because you would leave the binding itself still wellformed)
p34219
as(dp34220
g15
V34509
p34221
stp34222
a((dp34223
g2
(lp34224
VThe name that you use as the typedef is not dependent (see the clauses that define dependent names) and the namelookup in definition context at that place will not find a declaration
p34225
aVThat in itself is an error already
p34226
aVBut since there is no declaration for the name yet, the name is also not a member of a class that is the current instantiation or a base class thereof
p34227
aVTherefore the name is not a member of the current instantiation and therefore we have another reason to reject it by a rule that says that if the qualifier is the current instantiation, the name either must refer to a member of that instantiation, or to a member of an unknown specialization (which would be the case if the class had dependent base classes)
p34228
aVNote the notion of "current instantiation": the meaning of the qualifier is fixed to refer to the result of instantiating the surrounding template, we don't wait for resolving the template arguments
p34229
aVHence the term is not called "current specialization", since we know that it refers to an instantiated specialization, as opposed to a later declared explicit specialization
p34230
aVThe thing is different for C++03 I think
p34231
aVThe name will be dependent and the template definition is harder to deem illformed with the rules available
p34232
aVThe illformed, no diagnostic required, behavior will however happen when you try to instantiate the template before providing the explicit specialization
p34233
aVI think such code refering to itself makes no sense because you never are able to actually instantiate the template validly (and there is a rule that allows rejecting a template straight away in such cases)
p34234
as(dp34235
g15
V34509
p34236
stp34237
a((dp34238
g2
(lp34239
VImagine you have this one
p34240
aVis zero when we return that value, because the object was zero-initialized
p34241
aVBut that is not enough, because  also contains a string member which has a constructor
p34242
aVFor that constructor to be called, the standard arranges that 's constructor is called, which will eventually lead to constructing the member
p34243
as(dp34244
g15
V34509
p34245
stp34246
a((dp34247
g2
(lp34248
VThat would be a syntax error
p34249
aVThe syntax for a function definition is
p34250
aVThere's no room for  before  (I'm basing this on a random C11 draft)
p34251
aVFor C89 it looks similar, except that  is optional (because of the implicit-int rule)
p34252
as(dp34253
g15
V34509
p34254
stp34255
a((dp34256
g2
(lp34257
VYou could pass the variable as a reference template argument
p34258
aVThen the object is needed which causes an instantiation
p34259
as(dp34260
g15
V34509
p34261
stp34262
a((dp34263
g2
(lp34264
VThere was a discussion here: https://groups
p34265
aVgoogle
p34266
aVcom/a/isocpp
p34267
aVorg/forum/#
p34268
aVtopic/std-discussion/lk1qAvCiviY with utterances by various committee members
p34269
aVThe general consensus appears to be
p34270
aVThere is no normative difference
p34271
aVill-formed; no diagnostic required is used only for compile-time rule violations, never for runtime rule violations
p34272
aVAs I said in that thread, I did once heard in a discussion (I can't remember anymore in which one, but I'm certain there were insightful committee members involved)
p34273
aVill-formed; no diagnostic required for cases that clearly are bad rule violations and that can in principle be diagnosed at compile time, but would require huge efforts from an implementation
p34274
aVundefined behavior for things that implementations could find useful meanings for, so don't neccessarily are pure evil, and for any runtime violations that results in arbitrary consequences
p34275
aVThe rough guide for me is: If it is at compile time, it tends to be "ill-formed; no diagnostic required" and if it is at runtime, it always is "undefined behavior"
p34276
as(dp34277
g15
V34509
p34278
stp34279
a((dp34280
g2
(lp34281
VYes, this code is valid
p34282
aVBut your  should be
p34283
aVCurrently in your code, it is as if an  function had been declared at global scope (because that is the smallest enclosing scope that encloses both  and
p34284
aVAll declarations become visible at that scope for a  directive)
p34285
aVHad you moved the other  overload before , it would fail for Clang and GCC aswell
p34286
aVIn the original code, on a Standards conforming compiler, this should lookup  one time, and find  at the global namespace
p34287
aVThen when instantiating it should look at the call again, and note that the call arguments are , and there is no ADL possible with
p34288
aVAt instantiation time, normal lookup is not allowed to be done again, but only ADL
p34289
aVTherefore, the result will remain the global  and things will work
p34290
aVBut MSVC appears to be doing the normal lookup for the call at instantiation time aswell (pobably because of its template parsing model
p34291
aVMSVC does not parse templates when they are defined, but only when they are instantiated with concrete types)
p34292
aVProbably the then-visible  overload within namespace  interferes and blocks the lookup from considering the global
p34293
as(dp34294
g15
V34509
p34295
stp34296
a((dp34297
g2
(lp34298
VExamples for such values are all non-array, non-class non-temporary prvalues (a temporary prvalue corresponds to a temporary object)
p34299
aVExamples include  and
p34300
aVCounterexamples include  (which is an array),  (which is a class object) or the  prvalue temporary initialized from  that is bound to the reference in  (the reference itself is an lvalue
p34301
aVI think that this simple rule covers the rules accurately
p34302
aVA C++ Standard's footnote on the lvalue to rvalue conversion says (a little bit outdated, because it was not amended to mention array types)
p34303
aVIn C ++ class prvalues can have cv-qualified types (because they are objects)
p34304
aVThis differs from ISO C, in which non-lvalues never have cv-qualified types
p34305
aVSo the deeper reason that  still is type  is that it does not refer to an object
p34306
aVSo because there is no object, there is nothing to make const, and consequently the expression will never be const either
p34307
as(dp34308
g15
V34509
p34309
stp34310
a.