(lp0
((dp1
S'text'
p2
(lp3
VThanks a lot Charles for your answer and helpful comments
p4
aVI've now pieced together a Delphi/COM version of what I need which is as follows:
p5
as(dp6
S'author'
p7
V505088
p8
stp9
a((dp10
g2
(lp11
VIf you create a file it will simply inherit the permissions of its parent container, in other words the folder in which it resides
p12
aVSo you simply need to create it in a folder which has the necessary rights
p13
as(dp14
g7
V505088
p15
stp16
a((dp17
g2
(lp18
VYou can use a neat trick to fool the compiler
p19
aVDefine a library function as so:
p20
aVYou can then write your function as:
p21
aVThe compiler thinks you've written to Result since it's a var parameter and it stops bleating
p22
as(dp23
g7
V505088
p24
stp25
a((dp26
g2
(lp27
VIn practice Embarcadero will always zero initialise new elements simply because to do otherwise would break so much code
p28
aVIn fact it's a shame that they don't officially guarantee the zero allocation because it is so useful
p29
aVThe point is that often at the call site when writing SetLength you don't know whether you are growing or shrinking the array
p30
aVBut the implementation of SetLength does know \u2013 clearly it has to
p31
aVSo it really makes sense to have a well-defined action on any new elements
p32
aVWhat's more, if they want people to be able to switch easily between managed and native worlds then zero allocation is desirable since that's what fits with the managed code
p33
as(dp34
g7
V505088
p35
stp36
a((dp37
g2
(lp38
VHave you looked at User-Mode Scheduling which was introduced in Windows 7
p39
aVFibers basically don't really work
p40
aVThere's lots of information on this on the MSDN site and I seem to recall a few videos on Channel 9
p41
as(dp42
g7
V505088
p43
stp44
a((dp45
g2
(lp46
VCreate an instance of TPngImage, PngImage: PngImage
p47
aVLoad the image into this instance, PngImage
p48
aVLoadFromFile(
p49
aVCreate an instance of TBitmap, Bitmap: TBitmap
p50
aVAssign the PNG to the bitmap, Bitmap
p51
aVAssign(PngImage)
p52
aVAdd the bitmap to the image list
p53
aVJob done
p54
as(dp55
g7
V505088
p56
stp57
a((dp58
g2
(lp59
VSurely you could take the source from ThemedDBGrid and re-work it for a stringgrid
p60
aVOr you could use a DBGrid and wrap your strings up so that they can be accessed through a dataset
p61
as(dp62
g7
V505088
p63
stp64
a((dp65
g2
(lp66
VWindows have thread affinity \u2013 see Raymond Chen's article on this matter
p67
as(dp68
g7
V505088
p69
stp70
a((dp71
g2
(lp72
VThe Delphi TListView control is a wrapper around the Windows list view component
p73
aVIn its default mode of operation copies of the list data are transferred from your app to the Windows control and this is slow
p74
aVThe alternative to this is known as a virtual list view in Windows terminology
p75
aVYour app doesn't pass the data to the Windows control
p76
aVInstead, when the control needs to display data it asks your app for just the data that is needed
p77
aVThe Delphi TListView control exposes virtual list views by use of the OwnerData property
p78
aVYou'll have to re-write your list view code somewhat but it's really the only solution
p79
as(dp80
g7
V505088
p81
stp82
a((dp83
g2
(lp84
VNumerical Recipes has a routine that will do the job for you
p85
as(dp86
g7
V505088
p87
stp88
a((dp89
g2
(lp90
VUsually these settings are made in BIOS so that's going to be difficult to achieve
p91
as(dp92
g7
V505088
p93
stp94
a((dp95
g2
(lp96
VTry IOUtils
p97
aVTDirectory
p98
as(dp99
g7
V505088
p100
stp101
a((dp102
g2
(lp103
VYour matrix [1 2; 3 4] isn't positive so there is no solution to the problem in the domain of real matrices
p104
as(dp105
g7
V505088
p106
stp107
a((dp108
g2
(lp109
VYou can't do this reliably with a regex
p110
aVYou need to parse the code with a proper parser
p111
as(dp112
g7
V505088
p113
stp114
a((dp115
g2
(lp116
VNo doubt you could do this but it's almost surely a really bad idea to do so
p117
aVUI works well when it is predictable and consistent
p118
aVHow will you deal with different OS versions, themed/unthemed, future versions of the OS that may be quite different in the way they paint non-client regions
p119
aVPrograms that do their own thing are generally annoying because of it, for example iTunes, Safari, QuickTime for Windows which try to con you into believing that you are running on a Mac, or Firefox 4 with its bizarro menus
p120
aVMy recommendation is to let the system draw the non-client area as nature intended, and to put your UI in the client area
p121
as(dp122
g7
V505088
p123
stp124
a((dp125
g2
(lp126
VIEEE754 is the standard that defines floating point operations in this instance
p127
aVThis standard defines the compare operation of operands, at least one of which is a NaN, to be an error
p128
aVHence, this is not a bug
p129
aVYou need to deal with the NaNs before operating on your array
p130
as(dp131
g7
V505088
p132
stp133
a((dp134
g2
(lp135
VClick File | Options | Advanced | File Locations and you get the same dialog as in older verions
p136
as(dp137
g7
V505088
p138
stp139
a((dp140
g2
(lp141
VIf you haven't read it, you should devour Herb Sutter's Effective Concurrency series which covers this topic and many many more
p142
as(dp143
g7
V505088
p144
stp145
a((dp146
g2
(lp147
VThis seems like an odd request
p148
aVWindows programs should be responsive
p149
aVIf call_a_function takes any serious amount of time then your app will get the "This Windows is not responding" treatment
p150
aVAlso, GetMessage goes into a wait state if there are no posted messages in the queue
p151
aVI don't understand why your message loop looks so different from the canonical message loop
p152
aVI think to answer this question well it would be helpful to know the purpose of your call_a_function routine
p153
as(dp154
g7
V505088
p155
stp156
a((dp157
g2
(lp158
VHave you considered MS Visual Studio
p159
as(dp160
g7
V505088
p161
stp162
a((dp163
g2
(lp164
VThere is an MSDN library article that describes the
p165
aVcur and
p166
aVico file formats in great detail
p167
aVIt's pretty easy \u2013 I wrote some Delphi code to read
p168
aVico files not so long ago using this article as my reference
p169
as(dp170
g7
V505088
p171
stp172
a((dp173
g2
(lp174
VA message box is the wrong solution
p175
aVYou need a hint window
p176
as(dp177
g7
V505088
p178
stp179
a((dp180
g2
(lp181
VCan't you use WNDCLASS
p182
aVcbWndExtra to declare whatever private storage your class needs and then it will be allocated by Windows whenever it creates a window of that class
p183
as(dp184
g7
V505088
p185
stp186
a((dp187
g2
(lp188
VI do this in my Delphi app
p189
aVWhat happens is that whenever a change is made that could affect the control state, a message is posted to that effect
p190
aVThat message will get processed when the app becomes idle, i
p191
aVe
p192
aVafter any pre-existing messages complete their processing
p193
aVThe processing of this message then sets the UI state for all controls and the jobs is done
p194
aVIt's all very easy in Delphi of course because the VCL wraps up the underlying Win32 API very conveniently
p195
as(dp196
g7
V505088
p197
stp198
a((dp199
g2
(lp200
VI've done quite a bit of this with my FE product OrcaFlex
p201
aVYou have two options to link to your C code from Delphi: static or dynamic
p202
aVI link statically because it makes distribution and versioning much easier
p203
aVBut it's really quite a trick to get it to work statically and you have to rely on a number of undocumented aspects of Delphi
p204
aVI suspect that for your needs dynamic linking is best
p205
aVBasically you need to compile and link your C code into a DLL
p206
aVI recommend using the Borland C compiler to do this
p207
aVYou can use the free command line version BCC55 to do this
p208
aVThe advantage of using Borland C is that it makes the same assumptions about the 8087 floating point unit as Delphi does
p209
aVIf you build with MSVC then you will find that MS have elected not to raise floating point exceptions
p210
aVBorland C does raise floating point exceptions
p211
aVThis is a bit of a corner case but it becomes relevant if you are trying to ship a product that you need to be robust
p212
aVYou should know that the C code will, by default, use the C calling convention and I'd just stick with that
p213
aVYou bring it into Delphi by declaring the external routine as cdecl calling convention
p214
aVThe other thing you need to take care on is defining a clear interface between the two modules
p215
aVYou need to make sure that exceptions don't cross the module boundary and that you don't pass any special types (e
p216
aVg
p217
aVDelphi strings) across the boundary
p218
aVSo for a string use a PChar (or even better PAnsiChar or PWideChar to be sure that it won't change meaning when you upgrade to Delphi 2009 and later)
p219
as(dp220
g7
V505088
p221
stp222
a((dp223
g2
(lp224
VThe correct solution is to call InvalidateRect when you resize
p225
aVWindows will then post you a WM_PAINT message
p226
aVFor reference you should pull Petzold off the shelf and read his chapter on painting
p227
as(dp228
g7
V505088
p229
stp230
a((dp231
g2
(lp232
VIt's a memory leak if an exception is raised in between your allocate/deallocate pairs
p233
aVIt is normal to protect them as such:
p234
as(dp235
g7
V505088
p236
stp237
a((dp238
g2
(lp239
VThe problem is that when you do it this way you get a cached version of the icon, the first one that the system loaded
p240
aVThat will be the large sized icon, typically 32x32
p241
aVIt matters not what size you specify
p242
aVWhat you can do is find the ID of the desired resource in user32
p243
aVdll and use something like this:
p244
aVYou would be better to call  to get hold of the icon size rather than to hard code 16, but you probably already know that
p245
aVI'm not sure where you get the resource IDs from for the resources in user32, or even if they is any guarantee that they will stay constant across different Windows versions
p246
aVMy guess is that they will because too many programs would break, but that's just pure guesswork
p247
as(dp248
g7
V505088
p249
stp250
a((dp251
g2
(lp252
VWell, a variable of type TManagerType has to be in that range since that's how Pascal enumerated types work
p253
aVThe only way it could not be is if you have done something naughty behind the compiler's back
p254
aVAnother way to write this would be:
p255
as(dp256
g7
V505088
p257
stp258
a((dp259
g2
(lp260
VIf you have a Delphi string variable and are using D2009 or later so that PChar maps to PWideChar then you can just call your function with
p261
aVThen inside your DLL, you take a copy of the string by declaring a string variable and simply assigning to the string
p262
aVFor example the DLL code would look like this:
p263
aVThe code as you have it is quite unnecessarily complex
p264
aVDoing it the way I suggest avoids having to use any explicit memory allocation routines
p265
aVIf you want to write C code then why use Delphi
p266
aV;-)
p267
aVIf you wanted to be more explicit then you could write PWideChar rather than PChar
p268
as(dp269
g7
V505088
p270
stp271
a((dp272
g2
(lp273
VI think your only hope is to do it through something like out-of-process COM because each process has to be all 32 bit or all 64 bit
p274
as(dp275
g7
V505088
p276
stp277
a((dp278
g2
(lp279
Vbitmaps aren't antialiased, text and vector images are - perhaps your problem is that the images are being stretched and resized
p280
as(dp281
g7
V505088
p282
stp283
a((dp284
g2
(lp285
VIt won't fit into a 64 bit integer
p286
aVYou have 64 squares and you need more than 1 bit to record each square
p287
aVWhy do you need it to fit into a 64 bit int
p288
aVAre you targetting the ZX81
p289
as(dp290
g7
V505088
p291
stp292
a((dp293
g2
(lp294
Vf2c really is the way to go, provided you have F77 code
p295
aVIf you have F90 or later then f2c won't help
p296
aVI've used f2c many many times with great success, so long as you remember the -a switch
p297
aVAs an aside I would rate f2c as one of the all time great codes
p298
as(dp299
g7
V505088
p300
stp301
a((dp302
g2
(lp303
VDon't do it at all, common blocks are an anathema in the modern day
p304
as(dp305
g7
V505088
p306
stp307
a((dp308
g2
(lp309
VThe 4 will be the size of the pointer you have passed rather than the size of the struct to which it refers
p310
as(dp311
g7
V505088
p312
stp313
a((dp314
g2
(lp315
VI just wrote my own sleep which called the Win32 Sleep API function
p316
as(dp317
g7
V505088
p318
stp319
a((dp320
g2
(lp321
VYou don't need to handle messages to implement this
p322
aVYou just need to implement  and call /
p323
aVIt's really very very simple
p324
aVYou can actually implement  in your form code but I prefer to do it in a helper class that looks like this:
p325
aVThe idea here is to wrap up the complexity of the Windows  in
p326
aVAll you need to do is to implement  which is much simpler
p327
aVAnyway, I think this should get you going
p328
as(dp329
g7
V505088
p330
stp331
a((dp332
g2
(lp333
VYou now need to define functions called malloc free and realloc which you pass to this C library
p334
aVYou can implement them in Delphi by calling GetMem, FreeMem and ReallocMem
p335
as(dp336
g7
V505088
p337
stp338
a((dp339
g2
(lp340
VI think you need to call GetMonitorInfo for the monitor of interest
p341
aVYou then need to read the work area out of MONITORINFO
p342
aVrcWork
p343
aVThis will exclude any part of the monitor reserved for taskbar and indeed any other reserved areas
p344
aVI don't believe you need to worry yourself about autohide because GetMonitorInfo should account for that
p345
aVIn other words when autohide is enabled the work area will equal the monitor area
p346
as(dp347
g7
V505088
p348
stp349
a((dp350
g2
(lp351
VCheck the format with
p352
aVExtract the text with
p353
aVSplit into rows with
p354
aVEach item in the string list is now a row from the clipboard
p355
aVSplit each row into individual cells using a Split function:
p356
as(dp357
g7
V505088
p358
stp359
a((dp360
g2
(lp361
VIf you are at student level you probably won't even notice the differences
p362
as(dp363
g7
V505088
p364
stp365
a((dp366
g2
(lp367
VYou want a modal dialog and I think you need
p368
as(dp369
g7
V505088
p370
stp371
a((dp372
g2
(lp373
VWhy don't you just compare the two images
p374
aVOpen them in a raster editing program and compare the pixels
p375
aVWhy do you care how big the files are
p376
aVSurely what's important is whether or not the image is the right one
p377
as(dp378
g7
V505088
p379
stp380
a((dp381
g2
(lp382
VThis is a known bug in D2010 which has been reported in QualityCentral and fixed in XE
p383
as(dp384
g7
V505088
p385
stp386
a((dp387
g2
(lp388
VA linked list is just about the worst data structure imaginable for sorting
p389
aVIf you do insertion then you have to do linear traversal across the list
p390
aVAre you sure you've asked the right question
p391
as(dp392
g7
V505088
p393
stp394
a((dp395
g2
(lp396
VA DLL is a library of code, and API is an interface to a library of code
p397
as(dp398
g7
V505088
p399
stp400
a((dp401
g2
(lp402
VNo
p403
aV@codinghorror: why must my post have >= 15 characters
p404
as(dp405
g7
V505088
p406
stp407
a((dp408
g2
(lp409
VSystem Center is the Microsoft way of pushing out standard desktops
p410
aVIt's quite heavyweight mind you
p411
as(dp412
g7
V505088
p413
stp414
a((dp415
g2
(lp416
Vconstant address and present in any
p417
aVprocess
p418
aVYou won't be able to achieve that
p419
aVWin32 uses paged memory so different processes can access the same memory addresses even though it is different memory
p420
as(dp421
g7
V505088
p422
stp423
a((dp424
g2
(lp425
VIf you are set on Delphi and don't want to use Free Pascal then you can use Wine on the Linux side to run your Win32 app
p426
as(dp427
g7
V505088
p428
stp429
a((dp430
g2
(lp431
VI do this as well and I use the following routine to make it happen:
p432
aVI have no problems with this
p433
aVThe only difference that I could possibly imagine could be relevant is the assignment of BorderIcons, but I would doubt that causes a problem
p434
as(dp435
g7
V505088
p436
stp437
a((dp438
g2
(lp439
VYou could load the source bitmap into an HBITMAP, create a destination bitmap with the desired pixel format and then draw the source onto the destination
p440
aVThat would be the easiest way to do it
p441
aVIf you wanted to work directly with the bits then that would be possible but it's easier to let the system worry about it for you
p442
aVIt's probably quicker when the system does it because it will be well optimised
p443
as(dp444
g7
V505088
p445
stp446
a((dp447
g2
(lp448
VI don't know of anything like this, although there probably is such a thing
p449
aVI'd be concerned about the usability issues of moving one of the markers on top of the other
p450
aVWhen I ask for ranges in my app I just ask the user to type the numbers in
p451
as(dp452
g7
V505088
p453
stp454
a((dp455
g2
(lp456
VI've just realised a reason why this may not be such a great idea
p457
aVIt's true that the calling code becomes much simpler with operator overloading
p458
aVBut you may have performance problems
p459
aVConsider, for example, the simple code  and suppose you use the idea in Barry's accepted answer
p460
aVUsing operator overloading this simple operation will result in a new dynamic array being allocated
p461
aVIn reality you would want to perform this operation in place
p462
aVSuch in-place operations are very common in linear algebra matrix algorithms for the simple reason that you don't want to hit the heap if you can avoid it - it's expensive
p463
aVFor small value types (e
p464
ag217
aVcomplex numbers, 3x3 matrices etc
p465
aVthen operator overloading inside records is efficient, but I think, if performance matters, then for large matrices operator overloading is not the best solution
p466
as(dp467
g7
V505088
p468
stp469
a((dp470
g2
(lp471
VI don't see that the approach you espouse, whilst correct, is actually better than good old Try/Finally
p472
aVYou have taken a solution that is clear and explicit and replaced it with one that is obscure and opaque
p473
aVReal work Delphi code is full of Try/Finally and so it should be a natural idiom
p474
aVI can't see the downside of writing:
p475
as(dp476
g7
V505088
p477
stp478
a((dp479
g2
(lp480
VSince you can't load 32 bit and 64 bit images into the same process, you'll have to use a multi-process solution
p481
as(dp482
g7
V505088
p483
stp484
a((dp485
g2
(lp486
V defines  and  properties
p487
aVThese have protected visibility but you can always get at them by either subclassing or using the standard trick to get at protected members:
p488
as(dp489
g7
V505088
p490
stp491
a((dp492
g2
(lp493
VI don't think you would solve this by duplicating
p494
aVWhat you need is a function like this:
p495
as(dp496
g7
V505088
p497
stp498
a((dp499
g2
(lp500
VYou need to add the unit in which FormB is declared to your uses clause
p501
as(dp502
g7
V505088
p503
stp504
a((dp505
g2
(lp506
VYour app likely installs under the program files directory and you have to assume that you can't write to that directory
p507
aVYou also should run without admin rights since some users won't have them
p508
aVThus you should follow the platform guidelines and store files that you need to modify in a location where standard uses can modify them
p509
aVThis issue will also affect you on Vista
p510
as(dp511
g7
V505088
p512
stp513
a((dp514
g2
(lp515
VGenerate two 32 bit randoms and splice them together
p516
aVEDIT
p517
aVSimilar to @Andreas's answer I like the following (equivalent) implementation:
p518
as(dp519
g7
V505088
p520
stp521
a((dp522
g2
(lp523
VI'd get your threads to post a message back to the dialog when they complete
p524
aVOnce all three messages have been received you can close the dialog
p525
as(dp526
g7
V505088
p527
stp528
a((dp529
g2
(lp530
VYou just need to remove the var in the Control parameter and make it a value parameter
p531
aVBecause Delphi objects are actually implemented as reference types, you can call methods on them, change member fields etc
p532
aVeven if you pass them to a procedure as a value or const parameter
p533
as(dp534
g7
V505088
p535
stp536
a((dp537
g2
(lp538
VI would recommend CSparse by Tim Davis
p539
as(dp540
g7
V505088
p541
stp542
a((dp543
g2
(lp544
VYou can loop around the CustomForms property (there are CustomFormCount of them) of the global Screen object
p545
aVThis simply enumerates all the VCL forms in the app which may be what you want
p546
aVIf you are looking for code it would be something like this:
p547
as(dp548
g7
V505088
p549
stp550
a((dp551
g2
(lp552
VThe place to start is the MSDN documentation: Introduction to the Shell Namespace
p553
aVNaturally this is written from a C++ perspective but it's not too hard to map that across to Delphi
p554
aVAnother excellent resource for such tasks is Code Project
p555
aVFor example: The Complete Idiot's Guide to Writing Namespace Extensions - Part I by Mike Dunn
p556
aVIn fact this is just part of an excellent series of articles on shell extensions
p557
aVAt present Delphi is a poor choice because it does not produce 64 bit executables
p558
aVThis means that your shell extension will not run on 64 bit Windows which is now a serious limitation
p559
aVWith the recent release of Delphi XE2 this limitation has been removed
p560
aVXE2 is capable of producing 64 bit executables and can therefore be used to produce 64 bit shell extensions
p561
as(dp562
g7
V505088
p563
stp564
a((dp565
g2
(lp566
VI'm no expert on this, but I do know that GDI+ supports anti-aliasing, whereas GDI does not
p567
aVWithout anti-aliasing, rounded corners will not look smooth
p568
as(dp569
g7
V505088
p570
stp571
a((dp572
g2
(lp573
VI use the following to give me a color that contrasts the specified color:
p574
as(dp575
g7
V505088
p576
stp577
a((dp578
g2
(lp579
VYou could regard Decimal as an opaque type if you wish
p580
aVTo do so you would export from your C# code the helpers you need to synthesise Decimal values and then call that code from Delphi
p581
aVMy guess is that you would want a Double -> Decimal helper and perhaps vice versa
p582
aVAlternatively you could modify the C#/COM interface to use doubles and convert to Decimal on the C# side of the fence
p583
as(dp584
g7
V505088
p585
stp586
a((dp587
g2
(lp588
VA much better way to do this is to use a timer
p589
aVIn Delphi that means an object of class TTimer
p590
aVEach time the timer fires you just increment the Left property
p591
aVYou probably want a counter that disables the timer once it has fired as many times as you desire
p592
as(dp593
g7
V505088
p594
stp595
a((dp596
g2
(lp597
VThis question seems to get asked regularly here
p598
aVI don't recommend reverse engineering your dependencies as you propose
p599
aVThe problem is the on different platforms the dependencies may differ
p600
aVIf you can you should work it out from the source
p601
aVThis is not as hard as it may seem at first glance
p602
as(dp603
g7
V505088
p604
stp605
a((dp606
g2
(lp607
VThe synchronisation object that works across processes is a mutex
p608
as(dp609
g7
V505088
p610
stp611
a((dp612
g2
(lp613
VThis cannot be done
p614
aVCode like that you have given can only be run on instances and not on class references
p615
as(dp616
g7
V505088
p617
stp618
a((dp619
g2
(lp620
VCompilers are at liberty to lay out memory as they see fit in the interests of better performance, for example, or whatever it is that is motivating the code generation
p621
aVOn an OS with very limited resources the compiler may elect to pack rather than align for access speed
p622
aVPerhaps there are some implicit local variables being produced by the compiler
p623
aVThere are lots of possible reasons for this
p624
as(dp625
g7
V505088
p626
stp627
a((dp628
g2
(lp629
VWell, you could just elect not to worry about it
p630
aVAlternatively a very quick hack would be to free the form each time it closes since the animation appears to run only on the first time the form is shown
p631
aVEDIT: Another approach would be to call DestroyHandle on your form whenever it closes
p632
aVI'm guessing now, but I imagine that Windows records somewhere in the window a flag indicating that the animation has been shown
p633
aVOnce this flag has been set the animation is never shown again
p634
as(dp635
g7
V505088
p636
stp637
a((dp638
g2
(lp639
VOf course, it's always worth remembering that Double-Checked Locking is Broken
p640
aVThis issue turns out not to apply to the x86 memory model but it's always worth bearing in mind for the future
p641
aVI'm sure there will be Delphi version at some point that will run on a platform with a memory model that is afflicted by this issue
p642
aVEmbarcadero have started using a lock-free version of this pattern with interlocked compare/exchange
p643
aVFor example:
p644
aVI realise this isn't an answer to the question but it didn't really fit in a comment
p645
as(dp646
g7
V505088
p647
stp648
a((dp649
g2
(lp650
VI use the following as a memory manager
p651
aVI do so because it performs much better under thread contention than FastMM which is actually rather poor
p652
aVI know that a scalable manager such as Hoard would be better, but this is works fine for my needs
p653
aVThis isn't an answer to your question, but it's too long to fit into a comment and you may find it interesting to run your app against this MM
p654
aVMy guess is that it will perform the same way as FastMM
p655
as(dp656
g7
V505088
p657
stp658
a((dp659
g2
(lp660
VI've never known FastMM to fail to detect a memory leak
p661
as(dp662
g7
V505088
p663
stp664
a((dp665
g2
(lp666
VYou can check whether themes are active by calling IsAppThemed/IsThemeActive and then check for Aero by calling DwmIsCompositionEnabled
p667
aVThere may well be other ways of doing this
p668
aVEDIT
p669
aVThe logic would be:
p670
aVCan I import  and
p671
aVIf no then I must be in Windows Classic (Win9x or Win2k)
p672
aVWhat does  return
p673
aVIf false then I must be in Windows Classic
p674
aVCan I import
p675
aVIf no then I must be XP themed
p676
aVWhat does  return
p677
aVIf true then I am Aero, otherwise I am Windows Basic
p678
as(dp679
g7
V505088
p680
stp681
a((dp682
g2
(lp683
VYou could try Graphics32
p684
aVI've been very impressed with it for my needs
p685
as(dp686
g7
V505088
p687
stp688
a((dp689
g2
(lp690
VWhat you want to do is to localize your application
p691
aVDelphi has support for this, based around the  keyword
p692
aVHowever, I've never done any localization myself so I recommend that you do some websearch for this topic or perhaps wait for the other experts here to supply more detailed help
p693
as(dp694
g7
V505088
p695
stp696
a((dp697
g2
(lp698
VIn my view, sometimes compilers spew out warnings for issues that I regard as not problematic
p699
aVIn that case the solution may be to switch off those particular warnings
p700
aVBut you must exercise caution and be sure that you aren't also hiding significant warnings
p701
aVFor implicit type conversion warnings you want them some of the time, but not all the time
p702
aVTypically you want to ignore int to float conversions, but hear about others
p703
aVIdeally the compiler would allow you to configure warning reporting at that level of granularity
p704
as(dp705
g7
V505088
p706
stp707
a((dp708
g2
(lp709
VWhy can't you just release the mutex before attempting to restart
p710
aVIf by some chance another instance gets going before the one you explicitly invoke with the restart that doesn't matter, you'll still have your app up and running again with whatever changes effected that required the restart
p711
aVI don't think you need any of the complexity of the other solutions
p712
as(dp713
g7
V505088
p714
stp715
a((dp716
g2
(lp717
VThe biggest problem, to my mind, is that you can sometimes get caught out by Delphi scoping rules
p718
aVIf you have two identifiers with the same name in different units, then using this name refers to the one declared in the unit declared latest in the uses clause
p719
aVIf you suffer from a problem due to this you can always fully specify the identifier
p720
aVWhat I would really love to see would be compiler warnings to tell you if you are naming an identifier that whose identity is only determined by this latest declaration in uses clause scoping rule
p721
as(dp722
g7
V505088
p723
stp724
a((dp725
g2
(lp726
VThat will only result in it starting when the user running the installation process connects
p727
aVIf you want it to start when Windows starts then try under HKLM
p728
as(dp729
g7
V505088
p730
stp731
a((dp732
g2
(lp733
VThe largest possible finite value
p734
aVAs a mathematician, I find that ridiculous
p735
aVPerhaps the problem could be explained better
p736
as(dp737
g7
V505088
p738
stp739
a((dp740
g2
(lp741
VAs has been pointed out by others you need to specify the C calling convention in your P/Invoke and also use string on the managed side to marshal the null terminated char*
p742
aVHowever you should rejig the C++ routine to take a char* as an input parameter, together with a buffer length parameter
p743
aVYou then write into this buffer in the native code
p744
aVThis avoids the current problem that the data, as you presently have the code, is returned from the stack which, of course, is unwound as the function returns
p745
aVThe suggestion to use static will make this memory global and so avoid stack unwind problems, at the expense of thread safety
p746
aVYes it will likely work for this use case but its a bad habit to get into
p747
as(dp748
g7
V505088
p749
stp750
a((dp751
g2
(lp752
VThe benefit is that you can get the compiler to enforce where state can be modified
p753
aVFor example if you make a class with private data and all its methods, except, say, the constructor, are const, then you have an immutable data type
p754
aVThe benefit of this is not one of performance, but one of semantics
p755
as(dp756
g7
V505088
p757
stp758
a((dp759
g2
(lp760
VIf you remove the click handler from the code above then the double click handler should fire
p761
aVBecause the click handler shows a dialog, there is no way for the second click of the double click to reach the double click handler
p762
as(dp763
g7
V505088
p764
stp765
a((dp766
g2
(lp767
VThe following 3 liner works as expected on my newly minted ActivePerl 5
p768
aV12
p769
aV2:
p770
aVI think the culprit is cmd
p771
aVexe
p772
as(dp773
g7
V505088
p774
stp775
a((dp776
g2
(lp777
VI don't think you'll be able to achieve this
p778
aVIn a 32 bit process your pointers will be too short
p779
aVI believe that VirtualAllocEx will fail when called from a 32 bit process and with a 64 bit process handle as its first parameter
p780
aVI think you would see this if you added error checking to your code
p781
aVYour only solution will be to have 2 versions, x86 and x64
p782
aVThat should be no real trouble - usually it can be done with single source
p783
as(dp784
g7
V505088
p785
stp786
a((dp787
g2
(lp788
VIt's in the Conditional Defines slot under Project | Options, which looks like this on D2010:
p789
as(dp790
g7
V505088
p791
stp792
a((dp793
g2
(lp794
VWhat's wrong with the basic native Win32 components, as exposed by the VCL delivered with Delphi
p795
aVThey look great and everyone knows how to use them
p796
aVFor the majority of apps they are all you need
p797
as(dp798
g7
V505088
p799
stp800
a((dp801
g2
(lp802
VHeader files (
p803
aVh) are meant to be used to define the interface so that your classes and code can be used in other translation units
p804
aVIf you place implementation in the
p805
aVh file then you end up with multiple copies of the same code, compiled into each translation unit that includes that
p806
aVh file
p807
aVThat defeats the point of splitting your code into small pieces that can be studied and developed in isolation
p808
as(dp809
g7
V505088
p810
stp811
a((dp812
g2
(lp813
VYou say that you want to
p814
aVintercept stdout/err and send it into
p815
aVa memory buffer
p816
aVThis would indicate that you don't want to introduce an API for the SCM program and instead wish to carry on parsing the textual output without changing your existing code
p817
aVIf that is so then I see no point in changing from your current approach
p818
aVWhat exactly is to be gained by using a memory buffer and static linking over the current approach
p819
as(dp820
g7
V505088
p821
stp822
a((dp823
g2
(lp824
VYou could use a 3rd party graphics library such as Graphics32
p825
aVYou'd build each frame into an in memory bitmap and then blit it to the screen
p826
aVAchieving flicker free 15fps at 320x120 would be easy \u2013 I reckon you could get more than 10 times the frame rate with some ease
p827
aVOn the other hand I don't think it would be too hard to just draw it onto a TPaintBox with plain GDI commands
p828
as(dp829
g7
V505088
p830
stp831
a((dp832
g2
(lp833
VThe principal benefit is access to the
p834
aVnet framework and other code written in other
p835
aVnet languages
p836
as(dp837
g7
V505088
p838
stp839
a((dp840
g2
(lp841
VSince Chrome is based on the open source project Chromium you can download the source code and see exactly how Google have done it
p842
as(dp843
g7
V505088
p844
stp845
a((dp846
g2
(lp847
VThis is why, on Windows, you do not use ALT+key shortcuts
p848
aVYou should not attempt to subvert the native system behaviour
p849
aVThe solution is to choose a different shortcut combination
p850
as(dp851
g7
V505088
p852
stp853
a((dp854
g2
(lp855
VI don't think that 100 lines should take that long to draw
p856
aVIs there something else that you aren't telling us
p857
aVAre you drawing direct to a screen DC
p858
aVHave you tried drawing to offscreen bitmap and then blt-ing to the screen
p859
as(dp860
g7
V505088
p861
stp862
a((dp863
g2
(lp864
VWith a full map file you can identify the exact point in the code where this occurs
p865
aVI hope you have a full map file for this image
p866
aVSubtract $00401000 from the address at which the exception is raised ($007ADE8B in your case) and that corresponds to the values in the map file
p867
aVHaving done that you know which object is nil and from there it is usually not too hard to work out what is going on
p868
aVOne of the most common ways for this to occur is when a constructor raises an exception
p869
aVWhen this occurs the destructor runs
p870
aVIf you access, in a destructor, a field that has not been initialised, and do anything other than call Free on it, then you will get an exception like this
p871
as(dp872
g7
V505088
p873
stp874
a((dp875
g2
(lp876
VYou can do this with two classes
p877
aVThe matrix class overrides [] and returns a row object
p878
aVThe row object overrides [] and returns a scalar
p879
as(dp880
g7
V505088
p881
stp882
a((dp883
g2
(lp884
VYou could try the  option of RC to specify the directory in which your XML files live
p885
aVYou'd have to run RC as a pre-build action in order to get that much control over its execution environment
p886
as(dp887
g7
V505088
p888
stp889
a((dp890
g2
(lp891
VYou do this with P/Invoke
p892
aVAn excellent resource is pinvoke
p893
aVnet
p894
aVA simple example would be GetTickCount:
p895
aVSomething more complex, MessageBox:
p896
as(dp897
g7
V505088
p898
stp899
a((dp900
g2
(lp901
VI'm guessing that your native DLL is written in C++, your
p902
aVNET host is written in C# and you used Visual Studio, since you didn't provide the information
p903
aVIn this case you can open up your DLL project in Visual Studio and use the Attach to Process action on the Debug menu to debug an already running instance of your host application
p904
aVAlternatively, you can set the project up to start the app when you Run from within the DLL project
p905
aVI would imagine that you could also step through and land on breakpoints if you started out debugging from the
p906
aVNET host application, but I've never done that
p907
as(dp908
g7
V505088
p909
stp910
a((dp911
g2
(lp912
VOther examples where it would make sense could be to have a concise shorthand for a data type that was implemented as a pointer to struct, say
p913
as(dp914
g7
V505088
p915
stp916
a((dp917
g2
(lp918
VWhy don't you just send a Windows message in the WM_USER range
p919
aVYou'll need to do a bit of marshalling of the information but you can do that with GlobalAlloc, GlobalLock, etc
p920
aVquite easily
p921
as(dp922
g7
V505088
p923
stp924
a((dp925
g2
(lp926
VThis is very simple
p927
aVYou just type 18:30 into a cell and Excel does the rest for you
p928
as(dp929
g7
V505088
p930
stp931
a((dp932
g2
(lp933
VMost modern hardware include floating point units that implement these functions very efficiently
p934
as(dp935
g7
V505088
p936
stp937
a((dp938
g2
(lp939
VYour problem is that argc<5 and so you are attempting to access elements of argv that are not defined
p940
as(dp941
g7
V505088
p942
stp943
a((dp944
g2
(lp945
VYou can use %COMPUTERNAME% as others have pointed out
p946
aVYou may want to make your script more readable by defining a local variable containing the path that varies between the machines and then using that subsequently to avoid repetition
p947
as(dp948
g7
V505088
p949
stp950
a((dp951
g2
(lp952
Vresult := Index+1 should do it if I understand correctly your needs
p953
as(dp954
g7
V505088
p955
stp956
a((dp957
g2
(lp958
VAn obvious approach would be to use textual representation of the number as the interchange format
p959
as(dp960
g7
V505088
p961
stp962
a((dp963
g2
(lp964
VNot wishing to steal the thunder of RRUZ, I offer the following variant, taken from my codebase, with some observations
p965
aVI've done this as an answer rather than a comment in order to include code
p966
aVThere are a couple of points to make
p967
aVThere is no need to call WSAStartup/WSACleanup
p968
aVEDIT  As RRUZ points out in a comment, the winsock documentation does not explictly exempt inet_addr from WSAStartup/WSACleanup so I retract this point
p969
aVOn Vista it is simpler just to call RtlIpv4StringToAddress
p970
aVHaving said all that, inet_addr is so easy to implement it may just be easier to roll your own
p971
aVSecondly the declaration of inet_addr in WinSock
p972
aVpas is incorrect
p973
aVIt declares the return value to be of a type u_long which is defined in WinSock
p974
aVpas as Longint
p975
aVThis is a signed 4 byte integer but it should be an unsigned 4 byte integer, ULONG
p976
aVWithout the explicit cast you can get range errors
p977
as(dp978
g7
V505088
p979
stp980
a((dp981
g2
(lp982
VWhat I believe this to mean is that you should validate data that could be invalid as soon as you receive it
p983
aVOnce it has been validated then no more checks are needed
p984
aVIf you wait until the bottom of the call stack then you may have to validate many times because your call tree may have many branches
p985
aVI would whole-heartedly agree with this advice, but not on the grounds of performance
p986
aVBy validating at the point of entry you are in a much better position to give a meaningful error message to the client who supplied the data
p987
aVAnd by reducing the amount of validation that you do, you will end up with much clearer code
p988
as(dp989
g7
V505088
p990
stp991
a((dp992
g2
(lp993
VYou just get hold of the window handle of the list box and send some LB_GETTEXT messages
p994
aVAs far as tools go you might be thinking of Spy
p995
as(dp996
g7
V505088
p997
stp998
a((dp999
g2
(lp1000
VIf the only explicit synchronisation code in your app is through critical sections then it shouldn't be too difficult to track this down
p1001
aVYou indicate that you have only seen the deadlock on termination
p1002
aVOf course this doesn't mean that it cannot happen during normal operation of your app, but my guess (and we have to guess without more information) is that it is an important clue
p1003
aVI would hypothesise that the error may be related to the way in which threads are forcibly terminated
p1004
aVA deadlock such as you describe would happen if a thread terminated whilst still holding the lock, but then another thread attempted to acquire the lock before it had a chance to terminate
p1005
aVA very simple thing to do which may fix the problem immediately is to ensure, as others have correctly said, that all uses of the lock are protected by Try/Finally
p1006
aVThis really is a critical point to make
p1007
aVThere are two main patterns for resource lifetime management in Delphi, as follows:
p1008
aVThe other main pattern is pairing acquisition/release in Create/Destroy, but that is far less common in the case of locks
p1009
aVAssuming that your usage pattern for the locks is as I suspect (i
p1010
ag192
aVacquireand release inside the same method), can you confirm that all uses are protected by Try/Finally
p1011
as(dp1012
g7
V505088
p1013
stp1014
a((dp1015
g2
(lp1016
VYou tagged your question C++
p1017
aVI believe that in C++ the address at 0 is reserved and is normally referred to as NULL
p1018
aVOther than that you cannot assume anything
p1019
aVIf you want to ask about a particular implementation on a particular OS then that would be a different question
p1020
as(dp1021
g7
V505088
p1022
stp1023
a((dp1024
g2
(lp1025
VYou can't do this
p1026
aVWhat you can do efficiently is append to a file
p1027
aVYou'd need to build some structure into your file format if you wanted to take advantage of this, as Thanatos has described
p1028
aVAs usual, Raymond Chen has something to say on the matter
p1029
aVHe's talking about deleting from the beginning of the file but the issues are essentially the same as for this question
p1030
as(dp1031
g7
V505088
p1032
stp1033
a((dp1034
g2
(lp1035
VThere only is one clipboard that is shared between all programs, whether they are 32 or 64 bit
p1036
aVIn other words you can just use the same clipboard code on 64 bit Windows as you do on 32 bit
p1037
aVEDIT: I've just read \u0130smail's answer and I wonder if that is in fact what the OP is struggling with
p1038
aVMy statement above is still true, but I may have misinterpreted the question
p1039
as(dp1040
g7
V505088
p1041
stp1042
a((dp1043
g2
(lp1044
VThe early versions of C++ were built on top of C and in fact the compiler translated C++ code to C which was in turn compiled by the local C compiler
p1045
aVBjarne Stroustrup is a great believer in backwards compatibility and would, I'm sure, resist any attempt to take functionality away
p1046
aVYou can read all about in in Bjarne's book The Design and Evolution of C++
p1047
as(dp1048
g7
V505088
p1049
stp1050
a((dp1051
g2
(lp1052
VIt's done with something called a shell extension
p1053
aVIn the case of the
p1054
aVpsd files Photoshop probably installs a small DLL which is loaded by the shell to display the thumbnails on demand
p1055
aVThe shell extension knows how to read the
p1056
aVpsd file to get a thumbnail which may even have been stored in the file when it was saved as an optimisation
p1057
as(dp1058
g7
V505088
p1059
stp1060
a((dp1061
g2
(lp1062
VYou can't do this as you have found out
p1063
aVYou have to seek from the beginning or current
p1064
aVUse DeviceIoControl to find out the size of the device
p1065
as(dp1066
g7
V505088
p1067
stp1068
a((dp1069
g2
(lp1070
VA function can only have a single return value
p1071
aVYou could either pack multiple values into a compound data type (e
p1072
ag217
aVa struct), or you could return values via function parameters
p1073
aVOf course, such parameters would have to be passed using pointers to memory declared by the caller
p1074
as(dp1075
g7
V505088
p1076
stp1077
a((dp1078
g2
(lp1079
VYou normally do this by calling CreateFontIndirect and then getting the system to render
p1080
aVPerhaps you could explain why you can't use this standard approach
p1081
as(dp1082
g7
V505088
p1083
stp1084
a((dp1085
g2
(lp1086
VI don't see that this is a limitation, it's part of the security design of the system
p1087
aVOne common way to handle such a scenario would be as follows:
p1088
aVImplement the main task as a service
p1089
aVImplement a small UI program that presents an icon in the notification area (the tray)
p1090
aVCommunicate between the UI and the service over a named pipe, TCP/IP or some other communication mechanism
p1091
aVIf you do it this way then it is quite possible to run the UI on a different computer which sounds like it might make life easier for you
p1092
as(dp1093
g7
V505088
p1094
stp1095
a((dp1096
g2
(lp1097
VYou need to make sure you don't use the built-in memory manager and use something that can support addresses >2GB
p1098
ag192
ag217
aVFastMM
p1099
aVYou may have other code, typically 3rd party code, in your codebase that will fall foul of addresses >2GB
p1100
aVI personally deal with this by running under 64 bit Windows and forcing the system to use top-down memory allocation via a registry setting
p1101
aVWhen you do this you may run into some bugs in Windows
p1102
aVFor example GetCursorPos on Vista fails when the address of its parameter is >2GB
p1103
aVI work around that by patching Windows
p1104
aVGetCursorPos with a version that goes through GetCursorInfo
p1105
aVThis bug is fixed in Windows 7 but MS elected not to back-port it to Vista
p1106
aVI can't stress enough how important it is to run with top-down memory allocation enabled
p1107
as(dp1108
g7
V505088
p1109
stp1110
a((dp1111
g2
(lp1112
VWhy don't you use a list view in virtual mode
p1113
aVThat will look and feel right and perform great
p1114
aVThe Delphi TListView control is a wrapper around the Windows list view component
p1115
aVIn its default mode of operation copies of the list data are transferred from your app to the Windows control and this is slow
p1116
aVThe alternative to this is known as a virtual list view in Windows terminology
p1117
aVYour app doesn't pass the data to the Windows control
p1118
aVInstead, when the control needs to display data it asks your app for just the data that is needed
p1119
aVThe Delphi TListView control exposes virtual list views by use of the OwnerData property
p1120
aVYou'll have to re-write your list view code somewhat but it's not too hard
p1121
aVI also offer a link to another question here that covered similar ground
p1122
aVRather oddly, the accepted answer for that question talked about list boxes even though the question was about list view controls
p1123
as(dp1124
g7
V505088
p1125
stp1126
a((dp1127
g2
(lp1128
VThis is the code that I use
p1129
aVYou should be able to find what you need in here:
p1130
as(dp1131
g7
V505088
p1132
stp1133
a((dp1134
g2
(lp1135
VThey are called Thumbnail toolbars
p1136
aVI'm not aware of any Delphi code to wrap this up, but I'm probably wrong
p1137
aVIf I'm right, then you'll need to declare some COM interfaces and drive them appropriately - not really too difficult
p1138
as(dp1139
g7
V505088
p1140
stp1141
a((dp1142
g2
(lp1143
VYou need to use byref when you declare your double parameter
p1144
aVOr even better define your C function to receive the double value as a value parameter
p1145
as(dp1146
g7
V505088
p1147
stp1148
a((dp1149
g2
(lp1150
V*A functions used the active ANSI codepage
p1151
aV*W function use UTF-16
p1152
aVMulti-byte refers to whatever is passed in the CodePage parameter
p1153
aVIt is most commonly either the active ANSI codepage or UTF-8
p1154
aVLPWSTR is a UTF-16 string which may or may not be null-terminated (see MSDN)
p1155
aVI don't know anything about wcstombs, I always use WideCharToMultiByte
p1156
aVFile paths are in UTF-16
p1157
aVIn fact all text is UTF-16 internally in Windows
p1158
aVFor ANSI encoding you will need to read up on that in some detail
p1159
aVYou could do worse than to start with Wikipedia and follow the links from there
p1160
aVI hope that helps and that if I've got anything wrong, anyone who knows more please do edit this to correct any errors
p1161
as(dp1162
g7
V505088
p1163
stp1164
a((dp1165
g2
(lp1166
VProbably the easiest way to do this is to define a windows message in the WM_APP range and send it from one instance to the other
p1167
aVYou'd have to do your own marshalling though with something like GlobalAlloc
p1168
as(dp1169
g7
V505088
p1170
stp1171
a((dp1172
g2
(lp1173
VI doubt that this is possible
p1174
aVWhen you press CTRL+ALT+DEL Windows handles that key press and you can't get a look in
p1175
aVWhat you could do would be to put a shortcut on you desktop that locked the computer, but only after having shown the message you so desire
p1176
aVI have a Lock Workstation shortcut on my desktop which is implemented with the following target:
p1177
aVYou could quite easily write your own script, or maybe even a small app
p1178
aVIf the latter then you simply need to call the  function that is exported from
p1179
as(dp1180
g7
V505088
p1181
stp1182
a((dp1183
g2
(lp1184
VThe primary source for the file format of an
p1185
aVico file is on MSDN
p1186
aVYou should be able to work it out from this
p1187
aVThe  procedure in Graphics
p1188
aVpas may be of use but I imagine that you only need to find 16x16 since you are looking for favicons
p1189
aVIf you wanted to get really cute, you could download the source to, say, Firefox, and see exactly how they handle favicons
p1190
as(dp1191
g7
V505088
p1192
stp1193
a((dp1194
g2
(lp1195
VIn a comment on Mason's own blog, in response to a comment of mine, Mason answered this question
p1196
aVTry putting these two lines at the top
p1197
aVof your DPR, before the USES clause:
p1198
aVThis will make sure that no RTTI gets
p1199
aVgenerated for your own code or any
p1200
aVthird-party libraries you use, unless
p1201
aVthey\u2019re in a unit where RTTI
p1202
aVgeneration is explicitly enabled
p1203
aVYou
p1204
aVcan\u2019t turn it off for the RTL or VCL,
p1205
aVbut that shouldn\u2019t add very much to
p1206
aVyour size anyway
p1207
as(dp1208
g7
V505088
p1209
stp1210
a((dp1211
g2
(lp1212
VOne word: performance
p1213
aVFloating point arithmetic is typically implemented on hardware and is many orders of magnitude faster than other approaches
p1214
aVWhat's more your example of MATLAB is bogus
p1215
aVMATLAB uses double precision floating point arithmetic just like C#
p1216
as(dp1217
g7
V505088
p1218
stp1219
a((dp1220
g2
(lp1221
VI'm not a great fan of cygwin and personally prefer natively compiled versions of the GNU tools, e
p1222
ag217
aVGnuWin32
p1223
aVI also wonder why you would be using ,  etc
p1224
aVfrom a Perl script
p1225
aVMost of that functionality can be handled natively by Perl and this usually results in much better portability and robustness
p1226
as(dp1227
g7
V505088
p1228
stp1229
a((dp1230
g2
(lp1231
VI don't take this belt and braces approach
p1232
aVThe problem is that you have violated the DRY principle with the double use of some_condition
p1233
aVIt's all to easy to change this in one place and not the other
p1234
aVOf course some_condition is quite simple in this made-up example but in reality it's often be much more complex
p1235
aVIf you can't trust your GUI framework to block actions when you request them to be blocked, then you need to fix the framework
p1236
as(dp1237
g7
V505088
p1238
stp1239
a((dp1240
g2
(lp1241
VI use code as follows, but you may need to knock it around some
p1242
aVThe only thing very obviously missing is  which essentially wraps up the Windows API function
p1243
aVYou'll want some way to abbreviate very long file names and that's my preferred choice
p1244
aVSorry for such a huge dump of code, but somebody may find something of use within
p1245
as(dp1246
g7
V505088
p1247
stp1248
a((dp1249
g2
(lp1250
VThe approach with properties is pointless
p1251
aVYou can't use polymorphism properly since the functions take different parameters
p1252
aVYou should just have distinct methods in the subclasses with the appropriate parameters
p1253
aVNow, if you come back with a more complex version in which you only hold a reference to the base class then a different design would be called for, but it would be neither of the ones you have offered so far
p1254
as(dp1255
g7
V505088
p1256
stp1257
a((dp1258
g2
(lp1259
VYou can use user-specific file associations in situations where you do not have access to HKLM
p1260
aVAlternatively you can manifest your app to require administrator rights
p1261
aVMore normally file associations are set during application install where admin rights are normally available
p1262
as(dp1263
g7
V505088
p1264
stp1265
a((dp1266
g2
(lp1267
VYou could create a series of overloaded versions with 2, 3, 4 etc
p1268
aVparameters
p1269
aVFor example:
p1270
aVIf I were doing this, I'd write a script to generate the code
p1271
aVAs an aside, in my own code, I would write  at the start of that function, and  in the exception handler
p1272
aVand  are functions generated by a very simple Python script that is included in the codebase as a comment so that it can be re-run
p1273
aVA routine like  as defined above is only useful if you have a matching routine to free them all in one shot
p1274
aVThis allows you to write:
p1275
aVFinally, I'm not saying that I would necessarily do this, but this is meant as a naive and direct answer to the question
p1276
aVAs @T
p1277
aVE
p1278
aVD
p1279
aVstates, the need to do this suggests deeper problems in the codebase
p1280
as(dp1281
g7
V505088
p1282
stp1283
a((dp1284
g2
(lp1285
VI suspect the same as you, namely that MATLAB doesn't like a struct return type
p1286
aVTry returning a simple type and see if that works
p1287
aVThen I suggest contacting the excellent MATLAB support people
p1288
as(dp1289
g7
V505088
p1290
stp1291
a((dp1292
g2
(lp1293
VI don't know if DUnit supports it yet, but this is a perfect use case for anonymous methods which were introduced in Delphi 2010
p1294
aVIf DUnit doesn't support it then you can easily modify the source yourself
p1295
as(dp1296
g7
V505088
p1297
stp1298
a((dp1299
g2
(lp1300
VIt's a UTF-8 Byte Order Mark (BOM) and is to be expected
p1301
as(dp1302
g7
V505088
p1303
stp1304
a((dp1305
g2
(lp1306
VProject JEDI have done a lot of C header conversions for Delphi
p1307
aVThey have an excellent set of resources, tutorials etc
p1308
aVon their website
p1309
aVThey also have a tool that can automate this which was actually derived from original code by Bob Swart
p1310
as(dp1311
g7
V505088
p1312
stp1313
a((dp1314
g2
(lp1315
VOK, this should do it:
p1316
aVAll I did was wrote some C code to do the same, but for a float to double conversion, looked at the dissasembly and then modified as necessary
p1317
aVNote that I am no expert with MSVC and I'm not 100% sure that I can use the EAX and ECX registers like that without saving/restoring them
p1318
aVOthers may know more and offer corrections
p1319
as(dp1320
g7
V505088
p1321
stp1322
a((dp1323
g2
(lp1324
VYour problem is that since the list view exists in another process, the memory you allocate is not valid in that other process
p1325
aVI refer you to an article over at The Code Project which offers a solution
p1326
aVWhat's more, you do not appear to have allocated any memory for lpText so it would fail in your own process
p1327
as(dp1328
g7
V505088
p1329
stp1330
a((dp1331
g2
(lp1332
VI think I would do the following:
p1333
aVPut a reference to ThemeServices in the initialization section of ThemeSrv
p1334
aVpas
p1335
aVPut a reference to DwmServices in the initialization section of DwmSrv
p1336
aVpas (I'm guess the name of your unit)
p1337
aVSince units are finalised in reverse order from the order of initialisation, your problem will be solved
p1338
as(dp1339
g7
V505088
p1340
stp1341
a((dp1342
g2
(lp1343
VThere's nothing to do here
p1344
aVAs soon as the call to SendMessage returns, you can free the data
p1345
aVAs it happens, the other app isn't looking at your memory anyway since it's in a different process
p1346
aVInstead Windows marshals the data across the process boundary
p1347
aVWhat's more, if you are receiving the data in a WndProc, you can't take a copy of the pointer to the string
p1348
aVInstead you must take a copy of the contents of the string since that pointer is only valid for the duration of that call to WndProc
p1349
aVThe other point to make is that you have a confusion about the message queue
p1350
aVWhen you send a message, that happens synchronously and the queue is not involved
p1351
aVThe message queue is where posted messages are placed
p1352
aVThey are process asynchronously
p1353
as(dp1354
g7
V505088
p1355
stp1356
a((dp1357
g2
(lp1358
VThe dialog doesn't have a relationship with the instance of TForm1
p1359
aVIt would not be hard to set the position of the form manually, but I bet someone who is more familiar with this area of the VCL will know how to do it a cleaner way
p1360
aVPersonally I never use the Position property and use my own code to position all my forms because I've never been satisfied with the performance of the Position property
p1361
aVUPDATE: You can change the owner of the dialog using
p1362
aVYou'd have to store your dialog into a local variable, say, , for this to work:
p1363
as(dp1364
g7
V505088
p1365
stp1366
a((dp1367
g2
(lp1368
VI believe that the answer is no it does not have an integer square root function and that your solution is reasonable
p1369
aVI'm a bit surprised at the need to multiple by 1
p1370
aV0 to convert to a floating point value
p1371
aVI think that must be a Delphi bug and more recent versions certainly behave as you would wish
p1372
as(dp1373
g7
V505088
p1374
stp1375
a((dp1376
g2
(lp1377
VThis is a very poor way, in terms of performance, to check that a list is ordered
p1378
aVYou should instead iterate over it checking that each element is greater or equal to the previous
p1379
as(dp1380
g7
V505088
p1381
stp1382
a((dp1383
g2
(lp1384
VWhy are you even using these
p1385
aVButtons don't need icons
p1386
aVThey have enough visual cues without with the advent of uxtheme
p1387
aVPerhaps that's the explanation: why update something that is now legacy
p1388
as(dp1389
g7
V505088
p1390
stp1391
a((dp1392
g2
(lp1393
VIf you are talking about IEEE754 then the standard defines +0
p1394
aV0 to double precision as 8 zero bytes
p1395
aVIf you know that you are backed by IEEE754 floating point then this is well-defined
p1396
aVAs for Intel, I can't think of a compiler that doesn't use IEEE754 on Intel x86/x64
p1397
as(dp1398
g7
V505088
p1399
stp1400
a((dp1401
g2
(lp1402
VYou need to create Form2 first and this will be your main form
p1403
aVYou want it to start hidden and be shown after Form1 has done its job
p1404
aVSomething like this:
p1405
aVThe reason is that the app terminates when your main form closes
p1406
aVAnd your main form is typically the first one that you create
p1407
as(dp1408
g7
V505088
p1409
stp1410
a((dp1411
g2
(lp1412
VThere is no standard
p1413
aVI would avoid making it too big and I'd definitely let the user switch it off if they wanted too - they often perceive that it slows down the startup
p1414
as(dp1415
g7
V505088
p1416
stp1417
a((dp1418
g2
(lp1419
VWhen you create the DLL there should be a
p1420
aVlib file created for the purpose of dynamic linking
p1421
aVYou can use these just as you would static
p1422
aVlib files
p1423
as(dp1424
g7
V505088
p1425
stp1426
a((dp1427
g2
(lp1428
VSomething like:
p1429
as(dp1430
g7
V505088
p1431
stp1432
a((dp1433
g2
(lp1434
VI doubt many viruses are written in assembly
p1435
aVAs for Lisp and Scheme, if there is access to the system then there's the possibility of writing a virus
p1436
aVAre you looking for advice as to what language to choose
p1437
aV;-)
p1438
as(dp1439
g7
V505088
p1440
stp1441
a((dp1442
g2
(lp1443
VYou are looking for  (analogous to LoadLibrary),  (analogous to FreeLibrary) and  (analogous to GetProcAddress)
p1444
as(dp1445
g7
V505088
p1446
stp1447
a((dp1448
g2
(lp1449
VYou could try using srvany but be warned that it doesn't always work
p1450
as(dp1451
g7
V505088
p1452
stp1453
a((dp1454
g2
(lp1455
VCode in the initialization sections of the units in the DLL will run when the DLL is first loaded in to the process
p1456
aVThe finalization sections fire when the DLL is unloaded from the process
p1457
aVEugene is right that you can have more fine-grained control using DLLProc but this is usually only needed for per-thread resources, e
p1458
ag217
aVthread local storage
p1459
aVI would point out that there are serious limitations on what can be done during DLLMain which is ultimately where these initialization/finalization sections originate when inside a library
p1460
aVThe MSDN documentation basically says that you can do some things, but that there is no list of acceptable behaviour
p1461
aVThe closest it comes is to saying that you can call functions in kernel32
p1462
aVOtherwise, all bets are off
p1463
aVThere are lots of articles on the web that describe the issue, but beyond the MSDN topic for DLLMain that I've linked above, I would recommend reading Microsoft's Best Practices for Creating DLLs
p1464
aVThe helpful advice that MSDN offers is that the library can mandate that its users call an initialization function before using the DLL
p1465
aVA corresponding finalization function would be called once you were finished with the DLL
p1466
aVThe use of comctl32
p1467
aVdll adopts this idiom, see InitCommonControlsEx
p1468
aVIn my own code I prefer an alternative approach
p1469
aVThe initialization sections of all my units register initialization and finalization methods
p1470
aVThen, on the first call to any exported function from my library, the initialization methods are run, in the order in which they were registered
p1471
aVThis is not a problem for me to implement because I am already controlling all entry/exit points to my library
p1472
aVI realise this is more than you asked for, but you may find it helpful to avoid some rather hard to debug problems
p1473
as(dp1474
g7
V505088
p1475
stp1476
a((dp1477
g2
(lp1478
VIn short, using units that you don't need to will result in larger executables
p1479
aVUsually it makes little difference to performance of the code
p1480
aVTools like Gexperts and CnPack have wizards to automatically remove unused units
p1481
aVThe main thing you can do to reduce executable size is to disable RTTI
p1482
aVEDIT: In older versions of Delphi, the linker removes unused methods from the executable
p1483
aVEven then, code in the initialization/finalization sections of unused methods can result in extra code being linked into the executable and thus increasing its size
p1484
aVDelphi 2010 introduced a new improved version of RTTI
p1485
aVOne of the side effects of this is that unused functions are no longer removed by the linker
p1486
aVThis behaviour can be customised to some degree
p1487
as(dp1488
g7
V505088
p1489
stp1490
a((dp1491
g2
(lp1492
VIf you really want to do this then you should extract into a separate protected method the part of the inheritance hierarchy that you want to be able to reference directly
p1493
aVThis will allow you to call it from anywhere without virtual method dispatch defeating you
p1494
aVHowever, as I have commented, it seems like there is something awry with your class design
p1495
as(dp1496
g7
V505088
p1497
stp1498
a((dp1499
g2
(lp1500
VB states that the variable  is defined elsewhere, typically in a different translation unit
p1501
aVThe Wikipedia article would not be a bad place to continue your research
p1502
as(dp1503
g7
V505088
p1504
stp1505
a((dp1506
g2
(lp1507
VI don't think you need to call VarToStr, you can just assign to the string as so:
p1508
as(dp1509
g7
V505088
p1510
stp1511
a((dp1512
g2
(lp1513
VIf you link dynamically to the MSVC runtime then you need to install that runtime on every machine that will run your app
p1514
aVNote that in this case you appear to be linking to the debug version of the runtime, it is not normal to distribute apps linked against the debug version of the runtime
p1515
as(dp1516
g7
V505088
p1517
stp1518
a((dp1519
g2
(lp1520
VI refer you to the follows MS KB article on the subject
p1521
aVYou would typically debug the dump file using one of the Windows debugging tools, e
p1522
ag217
aVWinDbg
p1523
aVThere are many articles on the web describing how to do this
p1524
as(dp1525
g7
V505088
p1526
stp1527
a((dp1528
g2
(lp1529
VIt's kind of hard to say, but I'd start by looking for a BOM
p1530
aVMost Windows programs that write Unicode files emit BOMs
p1531
aVIf these files exist in your codebase presumably they compile
p1532
aVYou might ask yourself whether you really need to do this "tidying up"
p1533
aVIf you do need to do it then I would ask how the tool chain that processes these files discovers their encoding
p1534
aVIf you know that then you'll be able to use the same diagnostic
p1535
as(dp1536
g7
V505088
p1537
stp1538
a((dp1539
g2
(lp1540
VIt's a simple answer, and as you suspect, you do need to write a device driver in order to run in kernel mode
p1541
aVI'm afraid I don't know of a particularly good reference for kernel mode programming but a quick websearch reveals:
p1542
aVen
p1543
aVwikibooks
p1544
aVorg/wiki/Windows_Programming/User_Mode_vs_Kernel_Mode
p1545
aVhttp://www
p1546
aVnetomatix
p1547
aVcom/Development/Kernelmode
p1548
aVaspx
p1549
aVhttp://technet
p1550
aVmicrosoft
p1551
aVcom/en-us/library/cc750820
p1552
aVaspx
p1553
aVhttp://msdn
p1554
aVmicrosoft
p1555
aVcom/en-us/library/ff553208(VS
p1556
aV85)
p1557
aVaspx
p1558
as(dp1559
g7
V505088
p1560
stp1561
a((dp1562
g2
(lp1563
VOne possibility would be to subscribe to the notification of the workstation being unlocked and then do the deed at that point
p1564
as(dp1565
g7
V505088
p1566
stp1567
a((dp1568
g2
(lp1569
VIt provides local scope to that which is inside the macro
p1570
as(dp1571
g7
V505088
p1572
stp1573
a((dp1574
g2
(lp1575
VThe Delphi TBitmap is just a wrapper around the Windows BITMAP object
p1576
aVSo, yes it does support alpha channels, but clearly you must set the PixelFormat property appropriately
p1577
as(dp1578
g7
V505088
p1579
stp1580
a((dp1581
g2
(lp1582
VSorry, you can't do this
p1583
aVWhat's more you can't have a  parameter with a default as you have with
p1584
aVIf your parameters had sufficiently different parameter types, then you could use overloaded methods as an alternative to default parameters, which is a technique that I personally prefer
p1585
aVBut your parameters are all Boolean and so you can't do that here
p1586
aVOther posters have suggested something like this:
p1587
aVThis will compile and work but would be counter to the principle of least surprise
p1588
aVFor overloaded procedures like this, you would expect, for the procedure with only a single parameter, for that single parameter to be the first parameter of the procedure with multiple parameters
p1589
aVIn other words you would expect:
p1590
as(dp1591
g7
V505088
p1592
stp1593
a((dp1594
g2
(lp1595
VI've always used Parallel Python but it's not a complete analog since I believe it typically uses separate processes which can be expensive on certain operating systems
p1596
aVStill, if the body of your loops are chunky enough then this won't matter and can actually have some benefits
p1597
as(dp1598
g7
V505088
p1599
stp1600
a((dp1601
g2
(lp1602
VThe ISO-8859-1 encoding for the character  is indeed 233
p1603
aVMystery solved
p1604
as(dp1605
g7
V505088
p1606
stp1607
a((dp1608
g2
(lp1609
VIn your form you can override the  method like so:
p1610
aVThere are likely numerous other ways to do this, but this is how I do it
p1611
aVEDIT: Inspecting  suggests the hack that Mason recalls
p1612
aVThe first line sets
p1613
aVSo I suspect that by changing the declaration in the pas file from  to  will result in your button being created
p1614
aVOr perhaps the hack was to add  to the uses clause right at the end so that your version of TButton is the one that is in scope
p1615
aVHowever, none of this sounds very practical
p1616
as(dp1617
g7
V505088
p1618
stp1619
a((dp1620
g2
(lp1621
VI think the answer to your question can be found in the following Stack Overflow question: How to get the cpu usage per thread on windows (win32)
p1622
aVHowever, I would advise you to endeavour to understand why your program is behaving as it does and attack the root of the problem rather than killing any threads that you take a dislike to
p1623
aVOf course, if the program in question is purely for your own private use then your approach may be perfectly expedient and pragmatic
p1624
aVBut if you are writing professional software then I can't see a situation where killing busy threads sounds like a reasonable approach
p1625
as(dp1626
g7
V505088
p1627
stp1628
a((dp1629
g2
(lp1630
VIf it used an interface of normal Windows controls then you could enumerate the child windows and find the one which contained that text
p1631
aVHowever, this looks like a custom drawn window and so I suspect that you only chance would be to do a screen scrape to a bitmap and process that
p1632
aVYou could use Spy to inspect the app and see whether or not there are child windows
p1633
as(dp1634
g7
V505088
p1635
stp1636
a((dp1637
g2
(lp1638
VI think the acknowledged leader in this field is AQtime
p1639
aVIf you have no money then you can try Sampling Profiler
p1640
aVI'm sure others will be along in due course to offer yet more suggestions
p1641
as(dp1642
g7
V505088
p1643
stp1644
a((dp1645
g2
(lp1646
VI'm not aware that such a capability is exposed in an API
p1647
aVI expect the app draws it directly which it is of course perfectly entitled to do
p1648
as(dp1649
g7
V505088
p1650
stp1651
a((dp1652
g2
(lp1653
VYes it is possible
p1654
aVDirectX exposes a COM interface and C is capable of consuming them
p1655
aVIt won't be a whole boat load of fun though
p1656
as(dp1657
g7
V505088
p1658
stp1659
a((dp1660
g2
(lp1661
VIt's kind of hard to see how you could do this
p1662
aVA control could just paint scroll bars in its own canvas, do its own hit testing and how would you possibly know
p1663
aVYou could do all this without creating separate HWNDs for the scroll bars
p1664
aVWhat would be more interesting would be if you could say why you would wish to know this
p1665
as(dp1666
g7
V505088
p1667
stp1668
a((dp1669
g2
(lp1670
VNormally you'd collect all your strings into a list and then sort it
p1671
aVYou can then loop through and check adjacent items for equality
p1672
aVThat's O(n log n) assuming a reasonable sort algorithm as opposed to the naive algorithm which is O(n^2)
p1673
aVIf you don't have loads of items then the naive will work perfectly well though
p1674
as(dp1675
g7
V505088
p1676
stp1677
a((dp1678
g2
(lp1679
VDelphi's TWebBrowser is a wrapper around the IWebBrowser2 component which, in current versions of Windows, is based on Internet Explorer
p1680
aVSo it would seem exceedingly unlikely to me that any Delphi code could be used to modify the controls rendering
p1681
aVMore recent versions of Internet Explorer do now highlight the active/focused input field but I doubt you will have much control over which versions of IE are installed on your target machines
p1682
aVThe obvious alternative would be to use CSS styling to draw the active/focused input fields differently
p1683
as(dp1684
g7
V505088
p1685
stp1686
a((dp1687
g2
(lp1688
VAlthough the OP has explicitly stated in comments that he does not wish to use scheduled tasks, some people reading this may be interested to know that it is possible with scheduled tasks
p1689
aVThis can be done from the task scheduler's GUI interface, from the command line or even in code using the Task Scheduler Interfaces
p1690
as(dp1691
g7
V505088
p1692
stp1693
a((dp1694
g2
(lp1695
VIf I understand you correctly, you need TRttiMember
p1696
aVParent
p1697
aVFor example see this article by Rob Love
p1698
aVYou'll need Delphi 2010 or later I think
p1699
aVIn fact this is just part of an excellent series of articles - these articles will also tell you how to get hold of the fields, properties etc
p1700
aVwithout having to know their names
p1701
as(dp1702
g7
V505088
p1703
stp1704
a((dp1705
g2
(lp1706
VI'd just get hold of the HWND for the control, send it a WM_GETTEXTLENGTH and compare the answer with zero
p1707
as(dp1708
g7
V505088
p1709
stp1710
a((dp1711
g2
(lp1712
VI'm not sure this is a real SO question that Jeff would approve of, but here is the output from D2010:
p1713
aVDelphi 6 produces the same output
p1714
as(dp1715
g7
V505088
p1716
stp1717
a((dp1718
g2
(lp1719
VI'm sure this question has been asked here a million times before
p1720
aVBut, you merely need to use EnumWindows to get the top-level windows and then EnumChildWindows for all the children
p1721
as(dp1722
g7
V505088
p1723
stp1724
a((dp1725
g2
(lp1726
VEasy, call  just before you call , and then call  just as soon as it is done
p1727
as(dp1728
g7
V505088
p1729
stp1730
a((dp1731
g2
(lp1732
VThe code should read something like this:
p1733
aVI guess your problem is to do with Char now being 2 bytes wide (in Delphi 5 it was 1 byte wide) although I have never used SizeOf on an open array and don't even know what it does
p1734
aVThere are a couple of other issues with this code
p1735
aVThe return value seems a little pointless since it can only ever return True
p1736
aVIt could also be somewhat compressed like so:
p1737
as(dp1738
g7
V505088
p1739
stp1740
a((dp1741
g2
(lp1742
VThe reason for this is that MS completely re-organised the file dialogs for Vista
p1743
aVHooks are used to extend a file dialog by supplying a resource file
p1744
aVThis gives the customiser too much power
p1745
aVThey can all too easily modify standard elements of the dialog and indeed many apps did so
p1746
aVThe reorganisation of the dialogs would have broken many apps that used hooks
p1747
aVThose would have tried to manipulate elements of the dialog that were not there, or were implemented differently
p1748
aVLegacy versions of the dialogs remain for such apps to "get their hooks into"
p1749
aVYou are correct that it is impossible to get the new look when you use a hook
p1750
aVInstead you need to use the IFileDialogCustomize interface to customise the dialog
p1751
aVThis is less powerful but does result in appearance and behaviour that is more consistent with the standard part of the dialog
p1752
as(dp1753
g7
V505088
p1754
stp1755
a((dp1756
g2
(lp1757
VWhat's wrong with
p1758
aVIt does everything for you with no need for streams, poking at bytes, dealing with null terminators etc
p1759
aVAs for the precise question you raised, I would simply write:
p1760
as(dp1761
g7
V505088
p1762
stp1763
a((dp1764
g2
(lp1765
VYou can link against msvcrt
p1766
aVdll to get C runtime functions
p1767
aVThis is a Windows component and not part of the Visual Studio runtime
p1768
aVThus it can be relied upon to be present
p1769
aVIf you do so be careful if you happen to use a function that does heap allocation
p1770
aVIf you need to do that then you will need to free that memory with the same memory manager
p1771
aVOne trick is to use malloc from msvcrt
p1772
aVdll to replace the Delphi memory manager
p1773
aVI'm not saying this is the best way to solve your current problem
p1774
aVIn the long run you may be better off with a native Delphi solution that is portable when Delphi supports platforms other than Windows
p1775
as(dp1776
g7
V505088
p1777
stp1778
a((dp1779
g2
(lp1780
VThe problem you face is how to test it rather then whether it should be tested
p1781
aVThis is a wrapper to a number of COM calls which could fail for many different reasons
p1782
aVThose possible COM failure conditions are the most important aspects to test for this routine
p1783
aVBut you can't easily provoke the COM routines to fail
p1784
aVIn order to test these COM failure modes you'd need to use a mock and that's quite a leap from where you are
p1785
as(dp1786
g7
V505088
p1787
stp1788
a((dp1789
g2
(lp1790
VThe registry setting you refer to selects top-down memory allocation
p1791
aVYou state that this setting will "place program in high address space"
p1792
aVIt won't do that
p1793
aVWhat this does is force the Windows memory manager to allocate memory from the top of the address space
p1794
aVWhat's more since you are running under 64 bit Windows, I fail to see where PAE comes into play
p1795
aVThat would be something used on a 32 bit platform
p1796
aVI would guess that you are compiling a 32 bit app and so inevitably your pointers are 32 bits wide
p1797
aVBut that is only a guess due to the lack of information
p1798
aVIn short your question is impossible to answer because you haven't told us what you are doing
p1799
as(dp1800
g7
V505088
p1801
stp1802
a((dp1803
g2
(lp1804
VIt sounds like you are looking for GetCursorInfo and GetKeyState
p1805
aVThe latter you call with virtual key codes that specify the mouse button of interest
p1806
as(dp1807
g7
V505088
p1808
stp1809
a((dp1810
g2
(lp1811
VIt might be easier to build this in a MATLAB script
p1812
aVFor example a MATLAB command like this:
p1813
aVwill do the job
p1814
aVYou would obviously have one line per MEX file
p1815
aVThe  file is based on a template supplied in the MATLAB installation folder under
p1816
aVFor my build process I then wrap these calls to  up into a function and then invoke that from the command line using:
p1817
as(dp1818
g7
V505088
p1819
stp1820
a((dp1821
g2
(lp1822
VYou appear to have an infinite recursion together which will lead to a stack overflow (how fitting that you ask this question here)
p1823
aVYou could instead write:
p1824
aVI've had to fully qualify Now and DecodeDate because you use the same names in your code
p1825
aVYou shouldn't really do that and should choose non-clashing names
p1826
aVI don't really understand your aims and there are clearly many other problems in this code
p1827
aVFollow the comment trail of another answer I ran the following program:
p1828
aVwhile resulted in this output:
p1829
aVIf your call to  and  really results in the year 2002, then I can only conclude that the time on your computer is wrong
p1830
as(dp1831
g7
V505088
p1832
stp1833
a((dp1834
g2
(lp1835
VYour original code passes a class (TForm2) to a procedure which receives an instance (aForm)
p1836
aVIndeed this instance is not even initialised but that's not actually your problem here
p1837
aVWhat you need to do is to receive, in MakeAform, a class rather than an instance
p1838
aVYour code should be:
p1839
aVA couple more points:
p1840
aVWhat is the purpose of a
p1841
aVSetFocus
p1842
aVI wasn't aware that a form could hold the focus
p1843
aVIf you don't intend to re-parent this form after constructing it then you may as well do away with the Owner parameter and let the Parent own the form
p1844
as(dp1845
g7
V505088
p1846
stp1847
a((dp1848
g2
(lp1849
VYou should switch to streams
p1850
aVA  will handle this without problems
p1851
aVNote that if you use random access then you must ensure you use the 64 bit versions of  and
p1852
aVAfter you have opened the file stream you can seek to the end:
p1853
aVThen you can write lines as so:
p1854
aVHopefully, that should give you enough clues to fill in the rest of the details
p1855
as(dp1856
g7
V505088
p1857
stp1858
a((dp1859
g2
(lp1860
VYou need a solution which includes two projects
p1861
aVHave a read of the Visual Studio documentation on solutions and projects
p1862
as(dp1863
g7
V505088
p1864
stp1865
a((dp1866
g2
(lp1867
VYou are returning a buffer allocated on the stack of center_string and that will no longer be valid once you leave that routine
p1868
aVI'm sure there are other problems but I guess that's the main one right now
p1869
as(dp1870
g7
V505088
p1871
stp1872
a((dp1873
g2
(lp1874
VI suggest that you create a blank template and link that to your app
p1875
aVYou can then create the property sheet with CreatePropertySheetPage and then add and remove controls to that property sheet as you please
p1876
aVIf you absolutely have to use a template built on the fly in memory, and you can't bring yourself to link a resource to your app, then you need the DLGTEMPLATE structure
p1877
as(dp1878
g7
V505088
p1879
stp1880
a((dp1881
g2
(lp1882
VThe normal way to do this is to use  from Microsoft's HTML Help Workshop to build a help project, specified in a  file
p1883
aVYou can write the  file yourself, and all its auxiliary files
p1884
aVOr, more commonly, you can use a 3rd party help authoring tool of which there are many
p1885
aVI don't see where Delphi comes into the building of the  file, but if I've missed something then please update your question to add more details
p1886
as(dp1887
g7
V505088
p1888
stp1889
a((dp1890
g2
(lp1891
VArrays are not, in general, automatically zero-terminated
p1892
aVC strings are zero-terminated, but this is not a C string
p1893
as(dp1894
g7
V505088
p1895
stp1896
a((dp1897
g2
(lp1898
VUnit testing with complete coverage is really the only way to handle any development work which relies on dynamic languages
p1899
aVClearly it's very beneficial to have strong coverage tests for statically typed languages but in my experience it's even more important when you have dynamic typing
p1900
aVIf you aren't covering all the code that can run in your tests, then really you are asking for trouble
p1901
aVSo you want to use a coverage analysis tool in tandem with your unit tests to prove that you are reaching all of your code
p1902
aVEven that won't guard against all pitfalls \u2013 your tests really need to exercise all the possibly erroneous input data errors your program may receive
p1903
as(dp1904
g7
V505088
p1905
stp1906
a((dp1907
g2
(lp1908
V is declared as:
p1909
aVis defined as:
p1910
aVYou are instantiating  and so you need to pass an  to
p1911
aVIn order to do this you will need an object to provide a concrete implementation of that interface
p1912
aVOne obvious way to do this would be to subclass  and implement the interface there
p1913
aVAnother way to do this is to use  to create an  on demand using its  class function
p1914
aVYou would need to supply a comparison function:
p1915
aVLeonardo's answer demonstrates how to do this
p1916
as(dp1917
g7
V505088
p1918
stp1919
a((dp1920
g2
(lp1921
VYes it does and it is called
p1922
aVIn Python it is called , for what it's worth
p1923
as(dp1924
g7
V505088
p1925
stp1926
a((dp1927
g2
(lp1928
VAnother option to consider is to place Mediator and Colleague in the same unit
p1929
aVIn many situations that is the idiomatic Delphi way to avoid circular references
p1930
aVUsing  is often a good approach to this sort of problem but sometimes it can result in extra complexity for no real gain
p1931
aVIt's hard to know where the tradeoffs would fall for your code so I wouldn't like to state that one approach is better than the other as a general rule
p1932
as(dp1933
g7
V505088
p1934
stp1935
a((dp1936
g2
(lp1937
VI don't think there's a problem here
p1938
aVYou are referring to the  which does indeed return filenames limited in length to
p1939
aVBut since this is only the filename part, and the path is omitted, there is no limitation
p1940
aVWithin a directory, an object (file or folder) is limited in length, typically to 255 characters
p1941
aVYou can determine what this limit is with the  parameter of
p1942
aVI'd be surprised if any volume mounted in Windows could have a maximum component length in excess of 255
p1943
aVThe call to  receives a null-terminates string,  which specifies the directory and filename (e
p1944
ag217
aV"*
p1945
aVtxt", say) to search
p1946
aVThe documentation states:
p1947
aVIn the ANSI version of this function,
p1948
aVthe name is limited to MAX_PATH
p1949
aVcharacters
p1950
aVTo extend this limit to
p1951
aV32,767 widecharacters, call the
p1952
aVUnicode version of the function and
p1953
aVprepend "\u005c\u005c
p1954
aV\u005c" to the path
p1955
as(dp1956
g7
V505088
p1957
stp1958
a((dp1959
g2
(lp1960
VThe answer to this lies in the fact that , which is a , is now considered a legacy type
p1961
aVEmbarcadero took the decision not to convert  to have support for Unicode
p1962
aVSince the long string was introduced, if my memory serves correctly, in Delphi 2, that seems a reasonable decision to me
p1963
aVIf you really want fixed length arrays of WideChar then you can simply declare
p1964
as(dp1965
g7
V505088
p1966
stp1967
a((dp1968
g2
(lp1969
VMy guess at to what is happening here is that the  clause in your implementation section is declaring a ,  or  that is different from the one used in your interface section where you declare the constructor
p1970
aVA quick way to check would be to fully qualify those types in the implementation of
p1971
as(dp1972
g7
V505088
p1973
stp1974
a((dp1975
g2
(lp1976
VYou can achieve this by calling  passing  as the  field of the  struct and including  in
p1977
aVThis method is a little brittle because you may find your app running on a machine with a version of  that has a different output format
p1978
aVIf you want a list of all processes that are running you can call
p1979
as(dp1980
g7
V505088
p1981
stp1982
a((dp1983
g2
(lp1984
VFirst of all I am assuming that you are using C linkage with  in case this function is defined in a C++ translation unit
p1985
aVIf you are using Delphi 2009 or later, you need to be aware that PChar is a pointer to a null-terminated wide character string
p1986
aVTo interop with your ANSI C function you need to use:
p1987
aVThe C  type is probably best mapped to  since it's not quite the same as a Delphi :
p1988
aVYou don't need to escape  in strings so you can write:
p1989
aVYou probably ought to check for errors on the call to LoadLibrary and, technically,  is an  rather than a , although that won't cause you any problems
p1990
aVIdiomatic Delphi would be to write:
p1991
aVBasically it looks reasonable to me but I'm most suspicious of the character width
p1992
aVHope that helps
p1993
as(dp1994
g7
V505088
p1995
stp1996
a((dp1997
g2
(lp1998
VI'd be very surprised if calls to MulDiv, which is implemented using integer operations, were inefficient and the source of your performance problems
p1999
aVHave you timed your program
p2000
aVHave you used a profiler to identify the hot spots in your app
p2001
aVPersonally I think it is unlikely that a switch from integer to double precision floating point operations is likely to yield performance improvements
p2002
aVIn any case, my guess would be that you have other code which you call after the code you have shown, which uses  and  and which consumes orders of magnitude more CPU than this little snippet
p2003
aVYou presumably don't calculate  and  and then discard them: what do you do with them
p2004
aVEDIT: The Wine implementation of MulDiv is presumably very close to the Windows one, and the guts of that is so:
p2005
as(dp2006
g7
V505088
p2007
stp2008
a((dp2009
g2
(lp2010
VThe following EDN link looks like it will give you what you need: How to hook ShellExecute calls (IShellExecuteHook)
p2011
aVBe aware that it won't work in 64 bit Windows because that requires 64 bit shell extensions and because Delphi only produces 32 bit images you would need to use a different language
p2012
aVI also note that IShellExecuteHook is deprecated as of Vista
p2013
as(dp2014
g7
V505088
p2015
stp2016
a((dp2017
g2
(lp2018
VThose parameters don't actually fully define a distribution
p2019
aVFor that you need a density or equivalently a distribution function
p2020
as(dp2021
g7
V505088
p2022
stp2023
a((dp2024
g2
(lp2025
VYou can't mix 32 and 64 bit code in the same process
p2026
aVIf you absolutely must run this 32 bit control from a 64 bit app then you'd need to do it as an out of process server
p2027
aVWhilst this is probably feasible I don't believe it to be trivial
p2028
aVAnyway, you may very well not need to do this
p2029
aVSince 64 bit Windows runs 32 bit apps you can make sure that your app targets x86 instead of AnyCPU and then it will run on 64 bit Windows
p2030
as(dp2031
g7
V505088
p2032
stp2033
a((dp2034
g2
(lp2035
VI think you can compare it with the first release of the Unicode version of Delphi, Delphi 2009
p2036
aVWhen Delphi 2009 came out the 3rd party component vendors all supplied Unicode aware components pretty rapidly
p2037
aVMany had components ready at release
p2038
aVIn many ways, I suspect that the changes needed for 3rd party components to support Unicode will have been more onerous than will be needed for 64 bit
p2039
aVThe 3rd party vendors will already be looking ahead and making use of  and  types
p2040
aVAs for different versions, the normal practice from 3rd party component vendors is for their source code to compile on all supported platforms
p2041
aVIf you are using packages then clearly you need different versions for different compilers but that's true today as well \u2013 components are delivered with packages for each supported Delphi version
p2042
aVOne point I would stress would be that if you have not already moved to a Unicode Delphi, then you should do that as soon as possible
p2043
aVYou won't be able to move to the 64 bit version of Delphi without doing so and since you can port to Unicode Delphi now you really should get that out of the way
p2044
aVIn short, I have little apprehension over this issue
p2045
as(dp2046
g7
V505088
p2047
stp2048
a((dp2049
g2
(lp2050
VThe  function is at libery to return its value at any point at which it pleases
p2051
aVYou simply write:
p2052
aVand it's game over
p2053
as(dp2054
g7
V505088
p2055
stp2056
a((dp2057
g2
(lp2058
VIf I understand it's pretty simple
p2059
aVDeclare an AnsiString with affinity for Cyrillic 1251:
p2060
aVThen assign your Unicode string to one of these:
p2061
aVYou can then write  to a stream in the traditional manner:
p2062
aVThere should be no BOM for an ANSI encoded text file
p2063
as(dp2064
g7
V505088
p2065
stp2066
a((dp2067
g2
(lp2068
VI think you want to do something like this:
p2069
aVYou want to play your cash register sound if any single one of the 33 options matches, otherwise you click the fold button
p2070
aVI've moved the  code out of the loop because it evaluates the same every time round and that was just confusing the heck out of us all
p2071
aVDoes this to it
p2072
as(dp2073
g7
V505088
p2074
stp2075
a((dp2076
g2
(lp2077
VYou use both on Windows because that's the custom on Windows
p2078
aVIt's that simple
p2079
aVBut you only write both for files destined for Windows
p2080
as(dp2081
g7
V505088
p2082
stp2083
a((dp2084
g2
(lp2085
VFrom the console you would write:
p2086
aVIf you want to do it in Python then you would write:
p2087
aVObviously this is just a trivial example
p2088
aVYou'd clearly do more inside the with block
p2089
as(dp2090
g7
V505088
p2091
stp2092
a((dp2093
g2
(lp2094
VIf you want to be multi-lingual in Delphi then you should just move up to the latest version
p2095
aVWorking with code pages is a world of pain that disappears entirely when you embrace Unicode
p2096
as(dp2097
g7
V505088
p2098
stp2099
a((dp2100
g2
(lp2101
VI'm not aware of any limitation on the size of images that  can hold
p2102
aVIt sounds to me that your problem is that you have icons of different sizes and you can't hold icons of different sizes in the same image list
p2103
aVIf you are working with icons of different sizes then you are going to need to grow the smaller ones in size
p2104
aVYou'll have to build it up in code, using a bitmap
p2105
aVYou fill the bitmap with pure transparent alpha channel and then blt the smaller icon onto the centre of the bitmap
p2106
aVAnother option would be to maintain two separate image lists but if you need to draw the icons into the same list view then I think that won't get the job done
p2107
aVMy guess is that you'll need to grow the small icons
p2108
aVFor alpha, you're going to need to create the image list handle yourself because the ColorDepth property doesn't exist in D7
p2109
aVBecause of this, a vanilla D7  simply cannot support icons with alpha channels
p2110
aVYou work around this limitation by calling , passing  and assigning the result to
p2111
aVDo this before you add any images
p2112
aVYou'll have to populate the list at run time rather than design time, but it sounds like you are already doing that
p2113
aVHere's a screen shot of a 48x48 tool button with a 32bpp icon with alpha transparency:
p2114
aVIt's true that I made this in D2010, but my above workaround will work for D7 \u2013 I used that mechanism until quite recently with D6
p2115
aVI'm just showing this to prove that the image list can hold 48px icons
p2116
aVSince  is just a wrapper around the system image list component, I believe what you are attempting should be perfectly feasible
p2117
as(dp2118
g7
V505088
p2119
stp2120
a((dp2121
g2
(lp2122
VI'd expect any sensible scheduler to prefer running threads on different physical processors if possible
p2123
aVThen I'd expect it to prefer different physical cores
p2124
aVFinally, if it must, it would start using the hyperthreaded second thread on each physical core
p2125
aVBasically when threads have to share processor resources they slow down
p2126
aVSo the optimal strategy is usually to minimise the amount of processor resource sharing
p2127
aVThis is the right strategy for CPU bound processes and that's normally what an OS assumes it is dealing with
p2128
as(dp2129
g7
V505088
p2130
stp2131
a((dp2132
g2
(lp2133
VThat code compiles and appears to run successfully for me in Delphi 2010
p2134
aVThe output is:
p2135
aVIs it possible that enumerators with records are not supported in Delphi 2007
p2136
as(dp2137
g7
V505088
p2138
stp2139
a((dp2140
g2
(lp2141
VI indented your code to reflect the meaning of the  statements
p2142
aVHopefully it will now be clear to you what is going on
p2143
aVI recommend that you start indenting your code yourself
p2144
aVPresumably what you mean is:
p2145
aVBut, assuming that  is never negative, then I would use the  property which is a short-hand for /:
p2146
aVThis declarative approach typically results in clearer, more expressive code
p2147
aVAdditionally it allows you to express concisely the fact that the visibility of these controls is tied together
p2148
as(dp2149
g7
V505088
p2150
stp2151
a((dp2152
g2
(lp2153
VThe Python threading library that has brought me most joy is Parallel Python (PP)
p2154
aVIt is trivial with PP to use a thread pool approach with a single queue to achieve what you need
p2155
as(dp2156
g7
V505088
p2157
stp2158
a((dp2159
g2
(lp2160
VAll you need is the Shell_NotifyIcon function
p2161
aVYou ought to be able to work it out from MSDN, but if you need more help I'm sure there are a million places on the web that give samples
p2162
aVNow that you know the name of the API, web search will fill in the gaps
p2163
as(dp2164
g7
V505088
p2165
stp2166
a((dp2167
g2
(lp2168
VYou can just use standard string formatting:
p2169
as(dp2170
g7
V505088
p2171
stp2172
a((dp2173
g2
(lp2174
Vzlib would get the job done, if you indeed want compression
p2175
aVIf you don't want compression, then I'm afraid that my mind-reading skills are on the wane
p2176
as(dp2177
g7
V505088
p2178
stp2179
a((dp2180
g2
(lp2181
VI managed to get the following to work:
p2182
aVNote that I am using early binding through the  import unit
p2183
aVI think you are perhaps using late binding with
p2184
aVI don't understand your  syntax \u2013 that doesn't seem to meet the requirements of the Excel object model
p2185
aVI hope this helps
p2186
as(dp2187
g7
V505088
p2188
stp2189
a((dp2190
g2
(lp2191
VHow about something like:
p2192
aVIssue this with  as your working directory
p2193
aVHave a read of  to understand why this works
p2194
aVWhen I work on  statements I tend to try them out first like so:
p2195
as(dp2196
g7
V505088
p2197
stp2198
a((dp2199
g2
(lp2200
VIt would seem that  is not defined, since I can't imagine you are compiling for Itanium ()
p2201
as(dp2202
g7
V505088
p2203
stp2204
a((dp2205
g2
(lp2206
VWell, how could you stop it being a folder separator
p2207
aVIt is a folder separator
p2208
aVIf you could just decide for yourself what was and what wasn't a folder separator, then the whole system would come crashing down
p2209
as(dp2210
g7
V505088
p2211
stp2212
a((dp2213
g2
(lp2214
VFirst of all I would say that you should not attempt any optimisation without first timing
p2215
aVIn this case I don't mean timing alternative algorithms, I mean timing the code in question and assessing what proportion of the total time is spent there
p2216
aVMy instincts tell me that the code you show will run for a tiny proportion of the overall time and so optimising it will yield no discernible benefits
p2217
aVI think if you do anything meaningful with each element of this array then that must be true since the cost of converting from single to double will be small compared to floating point operations
p2218
aVFinally, if perchance this code is a bottleneck, you should consider not converting it at all
p2219
aVMy assumption is that you are using standard Delphi floating point operations which map to the 8087 FPU
p2220
aVAll such floating point operations happen inside the 8087 floating point stack
p2221
aVValues are converted on entry to either 64 or more normally 80 bit precision
p2222
aVI don't think it would be any slower to load a single than to load a double \u2013 in fact it may even be faster due to memory read performance
p2223
as(dp2224
g7
V505088
p2225
stp2226
a((dp2227
g2
(lp2228
VI don't believe there is a reliable way to detect this
p2229
as(dp2230
g7
V505088
p2231
stp2232
a((dp2233
g2
(lp2234
VI don't think there is a way to do this without resorting to custom drawing your non-client area which is very difficult when glass is involved
p2235
aVConsider this method
p2236
aVYes it succeeds in getting rid of the close item from the system menu, but it also results in the close button being disabled
p2237
aVSo it would seem that you can't have one without the other
p2238
as(dp2239
g7
V505088
p2240
stp2241
a((dp2242
g2
(lp2243
VAndreas is correct in pin-pointing double-buffering
p2244
aVThis is the most important aspect to consider that I am aware of
p2245
aVAs a mild counter point, I don't like double-buffering in general because it's very hard to get it right
p2246
aVMany components don't succeed
p2247
aVI'm thinking of VCL drop down list boxes which don't draw right under Windows Basic
p2248
aVThere are others
p2249
aVBut some controls really do need double-buffering to avoid flicker, so what do you do
p2250
aVYou want the benefit of double buffering when the user is locally connected, but you don't want to tax them with the network bandwidth when they are remote
p2251
aVSo, here's what I do:
p2252
aVAll forms in my app descend from  and so inherit this behaviour
p2253
aVThe  and  methods are  so individual forms can take specific actions
p2254
aVIn particular, all my forms call :
p2255
aVis an enumerator that walks the children of a component
p2256
aVThe Old New Thing reference is to an article entitled Taxes: Remote Desktop Connection and painting which was my inspiration for much of this code
p2257
aVI'm sure that there are other issues relating to remote desktop, but double-buffering is certainly one of the more important ones
p2258
as(dp2259
g7
V505088
p2260
stp2261
a((dp2262
g2
(lp2263
VThis is determined by the presence or otherwise of the UNICODE conditional which is determined by the project configuration: either Unicode or Multi-byte character set
p2264
as(dp2265
g7
V505088
p2266
stp2267
a((dp2268
g2
(lp2269
VI'd probably look to use tools like Process Explorer and madExcept, but there are lots of tools around that can be helpful
p2270
aVI don't believe that Delphi uses Turbo Debugger
p2271
aVWhat's more Delphi is perfectly capable of setting break points on kernel32 entry points like CreateThread
p2272
aVI would run with Debug DCUs enabled and set a break point on the implementation of CreateThread in Windows
p2273
aVpas
p2274
aVOnce you break there switch to the CPU window and step into the routine
p2275
aVYou'll see a  instruction
p2276
aVStep over this and hey presto, you are now debugging in kernel32
p2277
aVYou can set a breakpoint here
p2278
aVNow if you reset your app and start debugging again you will break at all calls to kernel32
p2279
aVCreateThread that originate from your process
p2280
aVInspection of the call stack will tell you how you got there
p2281
aVIt looks something like this:
p2282
aVFinally, I'm not certain why you are troubled by your app creating threads
p2283
aVMost decent sized apps create plenty of threads \u2013 it is perfectly normal to do so
p2284
aVWhat problems are you encountering
p2285
as(dp2286
g7
V505088
p2287
stp2288
a((dp2289
g2
(lp2290
VYou don't need to use hooking to get across the process boundary
p2291
aVYou can use WriteProcessMemory/ReadProcessMemory as described in the following Code Project article: http://www
p2292
aVcodeproject
p2293
aVcom/KB/threads/int64_memsteal
p2294
aVaspx
p2295
aVWhat you have to watch out for is crossing a 32/64 bit boundary
p2296
aVI know of now way to achieve that
p2297
as(dp2298
g7
V505088
p2299
stp2300
a((dp2301
g2
(lp2302
VPerhaps it's not this obvious, but your code appears to show the splash screen and then immediately close it
p2303
aVWhat happens if you comment out the line that says
p2304
as(dp2305
g7
V505088
p2306
stp2307
a((dp2308
g2
(lp2309
VI mostly use interfaces when I want objects with different ancestry to offer a common service
p2310
aVThe best example I can think of from my own experience is an interface called :
p2311
aVI have a bunch of custom controls derived from standard VCL controls
p2312
aVThey each implement this interface
p2313
aVWhen a clipboard operation reaches one of my forms it looks to see if the active control supports this interface and, if so, dispatches the appropriate method
p2314
aVFor a very simple interface you can do this with an  event handler, but once it gets sufficiently complex an interface works well
p2315
aVIn fact I think that is a very good analogue
p2316
aVUse an interface where you a single  event won't fit the functionality
p2317
as(dp2318
g7
V505088
p2319
stp2320
a((dp2321
g2
(lp2322
VI don't use auto-create and I never use global variables containing form references
p2323
aVIt works just fine
p2324
as(dp2325
g7
V505088
p2326
stp2327
a((dp2328
g2
(lp2329
VIn the commentary to Rob's excellent answer, the question of showing UI whilst waiting was raised
p2330
aVIf you need to show UI whilst waiting, then you will need a more advanced wait that
p2331
aVThis is what I use in its place, relying on
p2332
as(dp2333
g7
V505088
p2334
stp2335
a((dp2336
g2
(lp2337
VThe _TLB is stands for type library
p2338
aVIt looks like you are trying to implement  and have so far found some code here
p2339
aVHowever, I'm guessing because you didn't tell us
p2340
aVYou are likely to get better answers if you are able to to spend more effort describing what it is you are trying to achieve
p2341
aVIf my guess is correct you should take a look at this question: IShellExecuteHook
p2342
aVExecute which I believe will explain how to solve your actual problem
p2343
as(dp2344
g7
V505088
p2345
stp2346
a((dp2347
g2
(lp2348
VThere is no event in  (so far as I know) that fires as you edit the location (I don't think  has a search bar so I presume that's what you mean)
p2349
aVWhen I have tried to keep a host app in sync with a  I have used the  event
p2350
as(dp2351
g7
V505088
p2352
stp2353
a((dp2354
g2
(lp2355
VThe short answer is that you can just place the libraries (i
p2356
ag192
aVDLL files I presume) in the same directory as the executable file and they will be found
p2357
aVThe long answer is very much longer indeed, but for now you can get away with just knowing the above
p2358
as(dp2359
g7
V505088
p2360
stp2361
a((dp2362
g2
(lp2363
VYour macro substitution means that you write
p2364
as(dp2365
g7
V505088
p2366
stp2367
a((dp2368
g2
(lp2369
VYou can use  instead of  which will allow you to specify the size
p2370
as(dp2371
g7
V505088
p2372
stp2373
a((dp2374
g2
(lp2375
VThe way I do this is to make use of the  event
p2376
aVThis allows you to customise the  parameter and in you can do this based on the position contained in the  parameter
p2377
aVAs Remy points out in the comments, you can also handle  to achieve the same effect and this can be cleaner to implement in some ways if you are already subclassing the standard VCL controls
p2378
aVI have implemented a interface based framework to make use of this throughout my app
p2379
aVBasically in ,  is asked if it supports this interface
p2380
aVIf so then it is given an opportunity to customise the hint text
p2381
aVIt works beautifully
p2382
aVBasing hints off raw  events works perfectly well but it seems a little wasteful to call ItemAtPos on every  event rather than waiting until it's actually time to show the hint
p2383
aVThat's why I have a slight preference for the approach described above
p2384
as(dp2385
g7
V505088
p2386
stp2387
a((dp2388
g2
(lp2389
VYou can't fix it
p2390
aVServices now run in a different session and without access to the user's desktop
p2391
aVThe solution is a named pipe
p2392
as(dp2393
g7
V505088
p2394
stp2395
a((dp2396
g2
(lp2397
VYou can't zero system RAM
p2398
aVThe system owns it
p2399
aVIf you want to run a system which zeros the RAM then you need to write your own OS
p2400
as(dp2401
g7
V505088
p2402
stp2403
a((dp2404
g2
(lp2405
VI think you should be able to do this with the  function
p2406
aVYou use  for the  parameters
p2407
aVI expect you could also achieve this with
p2408
aVI'm still curious as to the value of the  property of your TPNGImage instances
p2409
as(dp2410
g7
V505088
p2411
stp2412
a((dp2413
g2
(lp2414
VOn the description presented here I regard this as mildly smelly
p2415
aVHowever, it seems easy to fix
p2416
aVI'd be inclined to pass the  object into the constructor of any component that needs it
p2417
aVThis makes the contract clear at compile time rather than enforcing it at runtime as you currently do
p2418
aVAs it currently stands, the contract you enforce is stronger than it needs to be
p2419
aVAlthough  only requires a  instance, it will only function if it can get that instance from a  report object
p2420
aVMaking this change would also allow  and  to have a divorce and still function successfully
p2421
aVAnd as @Lieven points out in the comments, this would likely make testing easier
p2422
as(dp2423
g7
V505088
p2424
stp2425
a((dp2426
g2
(lp2427
VIs there really some rationale towards
p2428
aVdoing this sort of thing
p2429
aVNo
p2430
as(dp2431
g7
V505088
p2432
stp2433
a((dp2434
g2
(lp2435
VThe functions  and  convert between screen and client coordinate systems
p2436
aVMouse messages are delivered to windows in client relative coordinates
p2437
aVHowever, your question isn't terribly clear, so if I've not provided the answer you are looking for, please edit your question to explain exactly what you are looking for
p2438
as(dp2439
g7
V505088
p2440
stp2441
a((dp2442
g2
(lp2443
VThe following gets the job done:
p2444
aVYou were probably missing
p2445
as(dp2446
g7
V505088
p2447
stp2448
a((dp2449
g2
(lp2450
VIf you want to track down a memory leak, and you can't find it by reading the code, then you probably need a real tool that is designed for the job
p2451
aVNeither Task Manager nor Process Explorer are appropriate tools for debugging memory leaks \u2013 you want something that will tell you where you allocate the memory that is not being returned
p2452
as(dp2453
g7
V505088
p2454
stp2455
a((dp2456
g2
(lp2457
VEr, don't you mean
p2458
as(dp2459
g7
V505088
p2460
stp2461
a((dp2462
g2
(lp2463
VThe character is in position 34935 in the file
p2464
aVThe helpful traceback tells you that
p2465
as(dp2466
g7
V505088
p2467
stp2468
a((dp2469
g2
(lp2470
VI think you need the mouse to be over your window before you all TrackMouseEvent
p2471
aVTry calling whilst you handle a mouse move message
p2472
as(dp2473
g7
V505088
p2474
stp2475
a((dp2476
g2
(lp2477
VI've got some code that does this
p2478
aVI've hacked out various irrelevant bits, so this may not compile as is
p2479
aVBut you should get the idea:
p2480
aVYou'll want to clean up the temp files at some point
p2481
as(dp2482
g7
V505088
p2483
stp2484
a((dp2485
g2
(lp2486
VYou can do this using the  parameter of
p2487
aVBehind the scenes this calls  which in turn calls the Windows  API function
p2488
aVAn easy way to implement this is with a :
p2489
aVIf you are using an older version of Delphi without the  parameter of  you can use  directly
p2490
aVThanks to Giel for suggesting the  parameter of , and for Sertac for pointing out that it is quite a recent addition to
p2491
as(dp2492
g7
V505088
p2493
stp2494
a((dp2495
g2
(lp2496
VIt is an integer that is the same size as a pointer
p2497
aV32 bits wide in 32 bit images, 64 wide in 64 bit images
p2498
as(dp2499
g7
V505088
p2500
stp2501
a((dp2502
g2
(lp2503
VUsing  you could do something like this:
p2504
aVIt feels somewhat revolting mind you, but it does the job
p2505
as(dp2506
g7
V505088
p2507
stp2508
a((dp2509
g2
(lp2510
VThe answer is that there is a single instance of global variable in each process
p2511
aVIt's all explained at MSDN: Dynamic-Link Library Data
p2512
as(dp2513
g7
V505088
p2514
stp2515
a((dp2516
g2
(lp2517
VYou register the window class because that's how the system works
p2518
aVThink of it as defining a type
p2519
aVGetMessage blocks until a message arrives in the queue
p2520
aVYou really need to read Charles Petzold's book, Programming Windows
p2521
as(dp2522
g7
V505088
p2523
stp2524
a((dp2525
g2
(lp2526
VAfter the edit and comments made the question more clear, I think the normal way to handle this is to use multiple panels rather than tabs
p2527
as(dp2528
g7
V505088
p2529
stp2530
a((dp2531
g2
(lp2532
VYou can use  if you have an instance, or  if you have a class
p2533
aVNormally thought its a bad idea
p2534
aVNormally in Python you work out if an object is capable of something by attempting to do that thing to it
p2535
as(dp2536
g7
V505088
p2537
stp2538
a((dp2539
g2
(lp2540
VAdding two functions is perfectly meaningful in mathematics
p2541
aVWhen you take the view that functions are operators then the space of all such operators is a linear space (under certain conditions)
p2542
aVThis is a very productive standpoint that yields a lot of useful mathematical insight
p2543
aVOf course, that's not what's happening here, but I wanted to put you right on the mathematical side of your question
p2544
as(dp2545
g7
V505088
p2546
stp2547
a((dp2548
g2
(lp2549
VYou need to start both the threads first, and then join with them once they are both running
p2550
as(dp2551
g7
V505088
p2552
stp2553
a((dp2554
g2
(lp2555
VReturn the object from the function and then pass it on to the next function
p2556
as(dp2557
g7
V505088
p2558
stp2559
a((dp2560
g2
(lp2561
VIronPython and IronRuby stand out as obvious candidates since they are
p2562
aVnet languages
p2563
aVThe only downside is that they are no longer actively developer by Microsoft
p2564
aVThat may not matter since they won't stop working, but they may not move on to new
p2565
aVnet versions too rapidly
p2566
as(dp2567
g7
V505088
p2568
stp2569
a((dp2570
g2
(lp2571
VI think the accepted solution is to upgrade to VS 2008
p2572
as(dp2573
g7
V505088
p2574
stp2575
a((dp2576
g2
(lp2577
VArrays are passed using pointers rather than the entire array being copied by value on the stack
p2578
aVYour two dimensional array makes explaining this tricky, but consider a one dimensional version:
p2579
aVYou could equivalently write this as:
p2580
aVThese two declarations are identical, but I'm sure you can see that modifications made in the the second version are propagated back to the caller
p2581
as(dp2582
g7
V505088
p2583
stp2584
a((dp2585
g2
(lp2586
VMy guess is that you are compiling it to a 32 bit target
p2587
aVYou need to build it on your 64 bit machine with 64 bit tools
p2588
aVYou can't load a 32 bit DLL into a 64 bit process, and vice versa
p2589
as(dp2590
g7
V505088
p2591
stp2592
a((dp2593
g2
(lp2594
VThe code you present works in the context of a plain vanilla form
p2595
aVThere must be something else interfering
p2596
aVThe most obvious is that your form has  set  and so your form handles
p2597
aVNote that I stand by my reservations expressed in the comment to your question
p2598
as(dp2599
g7
V505088
p2600
stp2601
a((dp2602
g2
(lp2603
VPerhaps you are looking for
p2604
aVIt is referenced from the  documentation and appears to return what you desire
p2605
as(dp2606
g7
V505088
p2607
stp2608
a((dp2609
g2
(lp2610
VYou can get all you need from the Wikipedia page
p2611
aVIf you have any difficulty understanding that, then please as question on that specific point
p2612
as(dp2613
g7
V505088
p2614
stp2615
a((dp2616
g2
(lp2617
VYou can certainly do this on Win32 but I don't know how well this maps over to
p2618
aVnet
p2619
aVThe essential issue is that window handles have thread affinity
p2620
aVSo you really need all interaction with them to happen in that thread
p2621
aVEssentially this means that you create all the window handles associated with that form in its thread
p2622
aVYou also need to run a message loop in the thread
p2623
aVThe reason that people usually run all the UI out of the main thread and handle long-running actions in separate threads is that it is easier that way
p2624
aVYou should ask yourself again why you want to do it this non-standard way
p2625
aVI suspect you are not quite seeing the full picture
p2626
aVThe need for threads in a desktop app principally arises when you have long running actions
p2627
aVUsually you want to keep your UI responsive and providing feedback for the long running action
p2628
aVDoing so leads to threads
p2629
aVHowever, in your proposed solution you now have a multitude of extra threads and complexity, and you are still faced with the original problem
p2630
aVA long running action on one of your forms will hang it unless you perform that action in a separate thread, and once again we reach the standard solution to the problem
p2631
as(dp2632
g7
V505088
p2633
stp2634
a((dp2635
g2
(lp2636
VI don't know about HPUX, but on Windows, if you have an exe and a DLL, and they each declare global variables, then there will be two distinct variables
p2637
aVIf you are only getting a single variable then one image must be importing the variable from the other
p2638
as(dp2639
g7
V505088
p2640
stp2641
a((dp2642
g2
(lp2643
VGiven that you are still using the tree view control as a container, the ideal solution offered by Smasher is not available to you
p2644
aVOne rather obvious solution, given that your tree view has no hierarchy (i
p2645
ag192
aVit's a list) would be to use the  method with your own compare function ()
p2646
aVThe other blindingly obvious strategy would be to add the node that you want at the bottom last
p2647
aVIf you need to add other nodes later, then insert them above the special last node with
p2648
aVThis simple approach will probably suffice for the problem as you have described it
p2649
as(dp2650
g7
V505088
p2651
stp2652
a((dp2653
g2
(lp2654
VThat's not going to be possible because different time zones can share the same offset from GMT (or UTC to be more correct)
p2655
as(dp2656
g7
V505088
p2657
stp2658
a((dp2659
g2
(lp2660
VThe MSDN documentation for  states:
p2661
aVIt is not an error to set a file
p2662
aVpointer to a position beyond the end
p2663
aVof the file
p2664
aVThe size of the file does
p2665
aVnot increase until you call the
p2666
aVSetEndOfFile, WriteFile, or
p2667
aVWriteFileEx function
p2668
aVA write
p2669
aVoperation increases the size of the
p2670
aVfile to the file pointer position plus
p2671
aVthe size of the buffer written, which
p2672
aVresults in the intervening bytes
p2673
aVuninitialized
p2674
aVThis is how the file system is designed to work
p2675
as(dp2676
g7
V505088
p2677
stp2678
a((dp2679
g2
(lp2680
VI think you are looking for some automated GUI testing
p2681
aVYou could try Test Complete from Smart Bear, for example
p2682
aVDUnit does offer some basic GUI testing facilities (in the GUITesting unit) but I don't think it may not be comprehensive enough for your needs
p2683
as(dp2684
g7
V505088
p2685
stp2686
a((dp2687
g2
(lp2688
VHow to free memory to struct when not
p2689
aVhaving a pointer to it anymore
p2690
aVGood luck with that
p2691
aVIf you don't know where it is, how can you hope to free it
p2692
aVSolution: remember where you put it
p2693
as(dp2694
g7
V505088
p2695
stp2696
a((dp2697
g2
(lp2698
VThe suggestion of using a signed 2 byte integer will greatly aid you
p2699
aVAnother useful tactic is to mark your exe as being  by adding  to your
p2700
aVdpr file
p2701
aVThis will only help if you are running on 64 bit Windows and will increase your address space from 2GB to 4GB
p2702
aVIt may not work on Delphi 7 (I seem to recall you are using D7) and you must be using FastMM since the old Borland memory manager isn't compatible with large address space
p2703
aVIf  isn't available you can still mark the exe with
p2704
aVIf you still encounter difficulties then yet another trick is to do allocate smaller sub-blocks of memory and use a wrapper class to handle mapping indices to the appropriate sub-block and offset within
p2705
aVYou can use a default index property to make this transparent to the calling code
p2706
aVNaturally a block allocated approach like this does incur some processing overhead but it's your best bet if you are having troubles with getting contiguous blocks
p2707
as(dp2708
g7
V505088
p2709
stp2710
a((dp2711
g2
(lp2712
VSend the  message to the control once you know its handle
p2713
aVTo work out its handle first of all use Spy++ or some such tool to find the name of the top level window and its window class name
p2714
aVSend this to  to get the top level window handle
p2715
aVFinally call  to walk the children
p2716
aVSpy++ can also tell you how to identify which child is of interest
p2717
aVOf course you may be unlucky and find that the control of interest is implemented without its own window handle, but Spy++ will tell you that too
p2718
as(dp2719
g7
V505088
p2720
stp2721
a((dp2722
g2
(lp2723
VNo you can't do this
p2724
aVWhat's more it would be a giant security hole if you could
p2725
aVProfiles are private to each user
p2726
as(dp2727
g7
V505088
p2728
stp2729
a((dp2730
g2
(lp2731
VThis is trivially easy with a scheduled task which is the native Windows way to schedule tasks
p2732
aVThere's no need for cygwin or Python or anything like that
p2733
aVI have such a task running on my machine which pokes my Wordpress blog every few hours
p2734
aVThe script is just a
p2735
aVbat file which calls
p2736
aVThe task is configured to "Run whether user is logged on or not" which ensures that it runs when I'm not logged on
p2737
aVThere's no "black cmd window"
p2738
aVYou didn't say which version of Windows you are on and if you are on XP (unlucky for you if you are) then the configuration is probably different since the scheduled task interface changed quite a bit when Vista came out
p2739
as(dp2740
g7
V505088
p2741
stp2742
a((dp2743
g2
(lp2744
VYou can install both 32 and 64 bit Python on the machine and use the py2exe associated with each installation
p2745
aVHowever, unless you actually need the extra address space of 64 bit, then you may as well just stick to 32 bit Python for compatibility
p2746
aVYou may well find that 3rd party modules will have better availability if you are using 32 bit
p2747
aVUpdate: Three years have passed since I wrote this
p2748
aVWould I stick to the advice about 64 bit Python
p2749
aVProbably
p2750
aVIt is certainly true that 64 bit third party modules are easier to come by
p2751
aVNot least thanks to Christoph Gohlke's wonderful site
p2752
aVBut it is still the case the every now and again you'll find it hard to get a 64 bit version of an extension that you need
p2753
aVSo, if your program works perfectly well in a 32 bit process, then it is perfectly sound to stick to 32 bit
p2754
as(dp2755
g7
V505088
p2756
stp2757
a((dp2758
g2
(lp2759
VThis is exactly the same as in C/C++ etc
p2760
aVYou can't use something until it exists
p2761
aVIn C/C++ you can't refer to something until it has been declared
p2762
aVRemember that a Python file is processed from top to bottom so if you attempt to call a function or reference a variable that does not exist, then it fails
p2763
as(dp2764
g7
V505088
p2765
stp2766
a((dp2767
g2
(lp2768
VAs written above, all three lines will execute
p2769
aVI imagine that the second and third lines are failing
p2770
aVYou should capture the output which will explain why those lines failed
p2771
as(dp2772
g7
V505088
p2773
stp2774
a((dp2775
g2
(lp2776
VWhen you link to a DLL there are two ways to do this, implicit linking and explicit linking
p2777
aVWhat you are encountering is a failure of implicit linking
p2778
aVImplicit linking operates through something called the import table contained in the executable image which uses the PE (Portable Executable) format
p2779
aVThe PE format defines both import and export tables
p2780
aVThe export table contains the list of functions exported by a DLL, and their entry points
p2781
aVThe import table contains the implicit dependencies on other modules
p2782
aVWhen an executable starts the loader reads the import table and then tries to load all the DLLs referenced and all the functions in those DLLs
p2783
aVThis can fail if the DLL is not found, if the DLL fails to load properly, or if the DLL does not contain the referenced functions
p2784
aVIn your case it is failing because the loader did not find  in the DLL search path
p2785
aVThe linker will generate the import table
p2786
aVIn C++ this is typically done via the
p2787
aVlib file for that DLL
p2788
aVExplicit linking is where your code calls  and  to load a DLL and its functions
p2789
aVTypically this approach is used when you want to write an app that can run on different systems
p2790
aVFor example you may wish to use certain functions that are only present on certain versions of the OS, but degrade to some other behaviour when run on an older version of the OS
p2791
aVThe term static should not be used when referring to linking to DLLs
p2792
aVStatic linking is when the implementation of a function is included in an image rather than contained in an external library
p2793
aVThe MSDN article on the topic explains all this and more
p2794
as(dp2795
g7
V505088
p2796
stp2797
a((dp2798
g2
(lp2799
VTry it this way round:
p2800
as(dp2801
g7
V505088
p2802
stp2803
a((dp2804
g2
(lp2805
VThe correct solution is to pass  whenever you call a method that expects an
p2806
aVWhat are you passing to such functions
p2807
aVIf you do that then you don't need any of this MUI magic
p2808
as(dp2809
g7
V505088
p2810
stp2811
a((dp2812
g2
(lp2813
VI came across the following link which seems to back up Hans's comment: http://weblogs
p2814
aVasp
p2815
aVnet/joberg/archive/2005/05/03/405283
p2816
aVaspx
p2817
aVThe article states:
p2818
aVThe Internet Controls Library contains
p2819
aVthe \u201cShellWindowsClass\u201d which is
p2820
aVbasically a collection of all the
p2821
aVshell windows (e
p2822
ag217
aV: IE) spawned
p2823
aVacross the desktop
p2824
aVThat component
p2825
aVprovides an event handler called
p2826
aV\u201cWindows Registered\u201d that we are going
p2827
aVto hook up to
p2828
aVOnce the process has
p2829
aVbeen launched, we will wait until the
p2830
aVcorresponding window is registered
p2831
aVthen we are going to connect our
p2832
aVInternet Explorer control to the shell
p2833
aVwindow found
p2834
aVTo determine if the
p2835
aVwindow is found, we iterate through
p2836
aVthe registered windows and we try to
p2837
aVfind a handle that matches the handle
p2838
aVof the process we previously launched
p2839
aVWe will use the \u201cManualResetEvent\u201d
p2840
aVsynchronization primitive to wait a
p2841
aVcertain amount of time for the window
p2842
aVto be registered
p2843
aVI expect you'd be able to map these ideas across to your problem relatively easily
p2844
as(dp2845
g7
V505088
p2846
stp2847
a((dp2848
g2
(lp2849
VYou don't actually need to rebase it
p2850
aVIf you don't then the DLL will be rebased automatically whenever it is loaded
p2851
aVThis will have a mild impact on start-up speed but I would guess that it won't even be detectable
p2852
aVHowever, it seems that you cannot redistibute GDI+ 1
p2853
aV1 to XP: How do I install GDI+ version 1
p2854
aV1 on Windows XP
p2855
as(dp2856
g7
V505088
p2857
stp2858
a((dp2859
g2
(lp2860
VYou can't write to that part of the registry without admin rights which you don't have with UAC
p2861
aVIt works in XP because you presumably run as an admin there
p2862
aVYou may also need to account for registry redirection
p2863
as(dp2864
g7
V505088
p2865
stp2866
a((dp2867
g2
(lp2868
VI'd do it something like this:
p2869
as(dp2870
g7
V505088
p2871
stp2872
a((dp2873
g2
(lp2874
VThere's a perfectly good Wikipedia page that explains this
p2875
aVWhy don't you read that and then ask a specific question if you can't understand something
p2876
aVIf you really want to learn all about COM then you should read "Effective COM" by Don Box which is one of the finest technical books I have ever read
p2877
as(dp2878
g7
V505088
p2879
stp2880
a((dp2881
g2
(lp2882
VDefine an interface with a method called something like:
p2883
aVImplement it for all your components (you may need to derive your own versions of some of these components)
p2884
aVThis allows different controls to have quite different behaviour
p2885
aVWhen a control needs to make sure it is visible it walks its parents and calls  if the interface is implemented
p2886
aVIf you don't like interfaces then do it with a custom Windows message, but you get the basic idea
p2887
as(dp2888
g7
V505088
p2889
stp2890
a((dp2891
g2
(lp2892
VIt would seem that you are passing a matrix as Matlab tells you
p2893
as(dp2894
g7
V505088
p2895
stp2896
a((dp2897
g2
(lp2898
VBecause in  you have an array and in the function you have a pointer to that array
p2899
aVis equivalent to
p2900
as(dp2901
g7
V505088
p2902
stp2903
a((dp2904
g2
(lp2905
V doesn't raise exceptions
p2906
aVIt returns  in case of an error
p2907
aVIt's hard to see how user permissions could come into this function since it is just an integer to string conversion
p2908
as(dp2909
g7
V505088
p2910
stp2911
a((dp2912
g2
(lp2913
VSorry that makes no sense
p2914
aVWithout the wndproc how can you even get hold of the message
p2915
aVA window without a window proc is not a window
p2916
as(dp2917
g7
V505088
p2918
stp2919
a((dp2920
g2
(lp2921
VYou can't
p2922
aVWhoever supplies the DLL must supply the auxiliary files too
p2923
as(dp2924
g7
V505088
p2925
stp2926
a((dp2927
g2
(lp2928
VI'm adding this as an answer because I want to format code
p2929
aVIt's not an attempt to answer the question and I'll likely delete in due course, especially if I get lots of down-votes (peer pressure)
p2930
aVWhat I wanted to show is how to create, show and destroy a form
p2931
aVYou do it like this:
p2932
aVIn your code:
p2933
aVThere is no need to pass an owner to the constructor since you are determining the life of the form
p2934
aVThe return variable of the function is pointless since you always return
p2935
aVThe only failure mode is via an exception but then the function has no return value
p2936
aVDon't call  where you did, plain old  is what you want
p2937
aVYou call  when handling a message and you want the form to go away once any messages currently in the queue are dealt with
p2938
as(dp2939
g7
V505088
p2940
stp2941
a((dp2942
g2
(lp2943
VThis wouldn't work for me because I have UAC enabled
p2944
aVI'd just stick it somewhere outside the program files folders
p2945
as(dp2946
g7
V505088
p2947
stp2948
a((dp2949
g2
(lp2950
VThe RTL/VCL that ships with Delphi 6 contains some memory leaks
p2951
aVIn later releases of Delphi the use of FastMM led to these memory leaks being removed from the RTL/VCL
p2952
aVWhat you need to do is register these known and expected memory leaks with FastMM
p2953
aVOnce you have registered the leaks that FastMM won't report them
p2954
aVAlthough these leaks are real, they are best ignored for various reasons:
p2955
aVThe leaked memory from these known VCL leaks is tiny and doesn't grow during the lifetime of the process
p2956
aVThe memory returned to the system as soon as the process terminates anyway
p2957
aVSince the leaks are in code beyond your control, there's not a huge amount you can do
p2958
aVYou could fix them and use your own version of the VCL units in question, but is it worth it
p2959
aVThe only time these leaks could matter is if you had a DLL which was loaded and unloaded from the same process thousands of times during the lifetime of that process
p2960
aVI don't believe this is a very realistic scenario
p2961
aVIf you don't register the leaks then the FastMM leak reporting becomes largely ineffective because it shows every time
p2962
aVIf it shows every time you learn to ignore it
p2963
aVThis leak reporting is very valuable, but it is only valuable if it shows leaks that you have some control over
p2964
aVIn my Delphi 6 project I have the following code in my
p2965
aVdpr file:
p2966
aVI also have the following in a  descendant from which all forms in my app descend:
p2967
aVDepending on exactly which units you use in the RTL/VCL and how you use them, you may need to register different memory leaks
p2968
as(dp2969
g7
V505088
p2970
stp2971
a((dp2972
g2
(lp2973
VThe bind is that you would like to modify  in place, but you can't
p2974
aVWhen I'm working with a  that holds records I actually sub-class  and replace the  property with one that returns a pointer to the item, rather than a copy of the item
p2975
aVThat allows for inplace modification
p2976
aVEDIT
p2977
aVLooking at my code again I realise that I don't actually sub-class  because it the class is too private to extract pointers to the underlying data
p2978
aVThat's probably a good decision
p2979
aVWhat I actually do is implement my own generic list class and that allows me the freedom to return pointers to records if needed
p2980
as(dp2981
g7
V505088
p2982
stp2983
a((dp2984
g2
(lp2985
VIf you want to fake input you need to use the  API
p2986
aVHowever, that's going to require you to make sure that field in question has the input focus
p2987
aVI suspect you would be better off poking the data in through the DOM ()
p2988
as(dp2989
g7
V505088
p2990
stp2991
a((dp2992
g2
(lp2993
VAs I understand your question you want to pass a range rather than a character that is within some specified range
p2994
aVIf that is a correct understanding then you would need to pass two parameters (min and max) or perhaps wrap them up in a record
p2995
as(dp2996
g7
V505088
p2997
stp2998
a((dp2999
g2
(lp3000
VYou have to define both  and
p3001
aVAnd you probably ought to consider implementing  too
p3002
as(dp3003
g7
V505088
p3004
stp3005
a((dp3006
g2
(lp3007
VIt turns out that this issue is in fact solely a limitation in the Explorer shell dialog
p3008
aVThe generated shortcut file does not have a 260 character limitation
p3009
aVIt's simply that the dialog refuse to display a Target with more characters than that
p3010
aVPresumably it calls  with a fixed length buffer
p3011
aVMy  looks like this:
p3012
aVThe resulting  goes right the way to _the_end
p3013
as(dp3014
g7
V505088
p3015
stp3016
a((dp3017
g2
(lp3018
VI do believe you are looking for this:
p3019
as(dp3020
g7
V505088
p3021
stp3022
a((dp3023
g2
(lp3024
VI don't think you need a database for this
p3025
aVIf you use a database I don't see how it solves the problem of your data structure changing
p3026
aVI personally would store to YAML format which is very easily extensible
p3027
aVThat requires quite a bit of work linking to some LIBYAML so a very lightweight alternative would be to store to INI files
p3028
aVThese are easily extensible whilst maintaining compatibility with old files
p3029
aVYou can quite easily roll your own binary format that is extensible
p3030
aVWhat you do is you write each record to a block
p3031
aVEach block has a short header which includes its length
p3032
aVWhen you read the data you read up to the end of the block and then if you are expecting more data you simply stop reading and use default values for the data
p3033
aVIf you have read all the data you know about but are not at the end of the block, the file must have come from a later version of your program and you just skip to the end of the block
p3034
aVPerhaps you warn that the file contained data which you didn't know about
p3035
aVExtensibility is achieved by always writing data out in the same order as previous versions
p3036
aVAny new data goes at the end of each block
p3037
as(dp3038
g7
V505088
p3039
stp3040
a((dp3041
g2
(lp3042
VI'm writing this as an answer because it's too long to fit into a comment
p3043
aVAssuming your grid really is irregular (you give no examples of a typical pattern of grid coordinates), then triangulation only partially helps
p3044
aVOnce you have triangulated you would then use that triangulation to do an interpolation, and there are different choices that could be made
p3045
aVBut you've not said anything about how you want to interpolate, what you want to do with that interpolation
p3046
aVIt seems to me that you have asked for some code, but it's not clear that you know what algorithm you want
p3047
aVThat's really the question you should have asked
p3048
aVFor example since you appear to have no criteria for how you should do the interpolation, why don't you choose the nearest neighbour for your missing values
p3049
aVOr why don't you use the overall mean for the missing values
p3050
aVBoth of these choices meet all the criteria you have specified since you haven't specified any
p3051
aVReally I think you need to spend some more time explaining what properties you want this interpolation to have, what you are going to do with it etc
p3052
aVI also think you should stop thinking about code for now and think about algorithms
p3053
aVSince you have mentioned statistics you should consider asking at http://stats
p3054
aVstackexchange
p3055
aVcom/
p3056
as(dp3057
g7
V505088
p3058
stp3059
a((dp3060
g2
(lp3061
VI think you want to transpose your output which you can do by reversing the order of the loops
p3062
aVAs a special bonus I have formatted the output so that it appears in nice neat colums
p3063
aVOutput:
p3064
aVI am guessing, to a degree, that this is what you want because what you state to be the output of the program in your question is not what that program actually outputs
p3065
aVI hope I've understood correctly
p3066
as(dp3067
g7
V505088
p3068
stp3069
a((dp3070
g2
(lp3071
VYou can do this with "Batch Build", although it's not available in the Express version
p3072
aVAnyway, you don't want to be building from the GUI anyway, you should be using  or something of that nature to automate your build process
p3073
as(dp3074
g7
V505088
p3075
stp3076
a((dp3077
g2
(lp3078
VIt looks to me like the label is set on creation
p3079
aVSo you'd need to create a new item with the appropriate label and replace the old one with the new one
p3080
as(dp3081
g7
V505088
p3082
stp3083
a((dp3084
g2
(lp3085
VYou aren't initialising  and so it contains random stack noise
p3086
aVThis in turn will lead to 'hInstance` being references which also contains stack noise
p3087
aVWhen calling a function like this you should first of all zero out the struct and only fill in the fields that are non-zero
p3088
aVSomething like this:
p3089
aVThere was no need to exclude  explicitly since you were not including it in the first place
p3090
aVEDIT
p3091
aVYou state in a comment that this doesn't work
p3092
aVCalling  is a good idea and should tell you why it fails
p3093
aVYou could also try to run the minimal possible  which is this:
p3094
as(dp3095
g7
V505088
p3096
stp3097
a((dp3098
g2
(lp3099
VYour filename is wrong in the Delphi version
p3100
aVYou don't escape \u005c in Delphi, a single one will do
p3101
aVBut that wouldn't lead to an access violation
p3102
aVMy guess is that your GetProcAddress call is failing
p3103
aVBut that is a guess
p3104
aVI'd like to see more code and the full error message
p3105
aVEDIT
p3106
aVIt seems that we were on the right track
p3107
aVCosmin's answer will solve the problem for you
p3108
aVAn alternative would be to switch to inplicit linking by removing the definition of the condition  in
p3109
as(dp3110
g7
V505088
p3111
stp3112
a((dp3113
g2
(lp3114
VGiven that there is no way to pass the input focus to these embedded buttons, and given that they display glyphs, how could there be keyboard access
p3115
aVHow would the user discover it
p3116
aVOn a modal dialog you can press enter and so long as the focus control is not a button, then the default button is pressed and the form closes
p3117
aVThat is part of the platform UI standard
p3118
aVSimilarly for escape and cancel
p3119
aVMany other controls have standard keyboard access (lists, drop downs, edits etc
p3120
aVThis is not a standard control and so it would be wrong to impose some default keyboard access beyond what is expected in an edit control
p3121
aVIt's fine for the designer to add access because they know what is reasonable on their form, but the VCL designers got it right by not including a default behaviour that would apply to every instance of this control
p3122
as(dp3123
g7
V505088
p3124
stp3125
a((dp3126
g2
(lp3127
VIt means you are dereferencing a pointer that is set to  and the code that is attempting this illegal act is located at  in your process
p3128
aVIf you can't solve it from this, then if showed us the code we could tell you why your pointer is set to
p3129
as(dp3130
g7
V505088
p3131
stp3132
a((dp3133
g2
(lp3134
VYou are not going to be able to achieve what you desire, in full generality it is not realistically possible
p3135
aVA window's type (or class) is essentially determined by its
p3136
aVYou can use  and its ilk to help you identify some standard window classes, but as you have already discovered, most real-world apps will not use these standard classes
p3137
aVSo, although in theory, you could analyse the code behind the  at runtime, in practice this is not remotely feasible
p3138
as(dp3139
g7
V505088
p3140
stp3141
a((dp3142
g2
(lp3143
VYou can get what you need from  from the JEDI project
p3144
as(dp3145
g7
V505088
p3146
stp3147
a((dp3148
g2
(lp3149
VIf you want to read or write memory that is owned by a different process you need to use  and
p3150
aVThat's the only way to do it
p3151
aVFor what you are trying to do, it won't be enough to write the memory values into the other process
p3152
aVYou'd likely need to invoke some methods as well
p3153
aVIf these variables that you are modifying are properties, then the property access method would need to be called
p3154
aVIf the variable holds something dynamic (e
p3155
ag217
aVa list, a string), then  is not going to get the job done
p3156
aVThis sort of thing is usually done with a well-defined interface (and API), some sort of plug-in architecture etc
p3157
as(dp3158
g7
V505088
p3159
stp3160
a((dp3161
g2
(lp3162
VYou have tagged your question with both C and C++
p3163
aVTherefore, I suggest that you consider using pass by reference in C++ which supports this feature and that you do not consider using it in C which does not support this feature
p3164
as(dp3165
g7
V505088
p3166
stp3167
a((dp3168
g2
(lp3169
VAssuming you are using the COM interface to Excel, and you are working on a single workbook, you can only read/write from/to of Excel from a single thread
p3170
as(dp3171
g7
V505088
p3172
stp3173
a((dp3174
g2
(lp3175
VYes those terms are synonyms as I understand them
p3176
aVHowever, I think you are asking the wrong audience
p3177
aVIf your colleague regards them as different, then you and they have a mismatch of understanding
p3178
aVWhether or not I think they are the same is irrelevant, what counts is what your colleague actually means
p3179
as(dp3180
g7
V505088
p3181
stp3182
a((dp3183
g2
(lp3184
VWhy doesn't it print Hello World
p3185
aVIt does in my Python (ActiveState, 2
p3186
aV6), when run from the console:
p3187
as(dp3188
g7
V505088
p3189
stp3190
a((dp3191
g2
(lp3192
VMy code to do this very thing looks like this:
p3193
aVThere's no need to set any properties on , you can simply ignore
p3194
as(dp3195
g7
V505088
p3196
stp3197
a((dp3198
g2
(lp3199
VThe only thing that changes size between 32 and 64 are pointers
p3200
aVSo DWORD stays 32 bits wide
p3201
aVSome things are not immediately obviously pointers, e
p3202
ag217
aVHANDLE, LPARAM, WPARAM
p3203
aVBut these three change width as they actually hold pointers
p3204
as(dp3205
g7
V505088
p3206
stp3207
a((dp3208
g2
(lp3209
VUsually when things "crash" there is an error message
p3210
aVThis error message is often useful
p3211
aVIn the absence of this message I am reduced to guessing
p3212
aVI guess that your
p3213
aVnet app targets "AnyCPU" and so on the 64 bit machine it runs as a 64 bit process
p3214
aVA 64 bit process cannot load a 32 bit DLL
p3215
aVIf you switch it to target "32 bit" then it will all work again
p3216
aVOr you could compile your DLL to 64 bit but that may be more tricky
p3217
as(dp3218
g7
V505088
p3219
stp3220
a((dp3221
g2
(lp3222
VIn your code you would also to test that the remainder is 0:
p3223
aVEDIT
p3224
aVAs Sjoerd pointed out, I was being particularly bone-headed and you may as well just test  as so:
p3225
aVI realise that this is C++ but you get the picture
p3226
as(dp3227
g7
V505088
p3228
stp3229
a((dp3230
g2
(lp3231
VWho says it is
p3232
aVOn some operating systems there is little difference
p3233
aVAre you thinking of Windows where threads are much lighter weight than processes
p3234
aVI suspect you would learn more by consulting this Stack Overflow question
p3235
as(dp3236
g7
V505088
p3237
stp3238
a((dp3239
g2
(lp3240
VFar and away the simplest solution will be to take the source of the 3rd party component (you should only consider using 3rd party Delphi components that come with source) and modify it to call  rather than
p3241
as(dp3242
g7
V505088
p3243
stp3244
a((dp3245
g2
(lp3246
VYou call
p3247
as(dp3248
g7
V505088
p3249
stp3250
a((dp3251
g2
(lp3252
VThis is not a limitation of Windows which in fact supports arbitrarily long file names and has done so for as long as I can remember
p3253
aVI see that you are using
p3254
aVAccording to the documentation you should use
p3255
aVWhen using  the forward slash is not converted to a backwards slash
p3256
as(dp3257
g7
V505088
p3258
stp3259
a((dp3260
g2
(lp3261
VNo, you need to deploy
p3262
aVnet properly
p3263
as(dp3264
g7
V505088
p3265
stp3266
a((dp3267
g2
(lp3268
VI suspect that your problem is that you are declaring these types twice in separate units
p3269
aVDoing so results in distinct, incompatible types
p3270
aVWhat you need to do is to:
p3271
aVDeclare the types, in the interface section, of one unit only (unit A, say)
p3272
aVIn another unit (unit B, say) that wants to use these types you add unit  to the  clause
p3273
as(dp3274
g7
V505088
p3275
stp3276
a((dp3277
g2
(lp3278
VYou'll need to use owner-draw for this sub item so that it uses different font properties than the rest of the list  view
p3279
as(dp3280
g7
V505088
p3281
stp3282
a((dp3283
g2
(lp3284
VThere's nothing built in to  to do what you ask
p3285
aVYou could implement yourself although you would probably not start from
p3286
aVOr perhaps you might have some fortune searching for a 3rd party painting component that offered the functionality you need
p3287
as(dp3288
g7
V505088
p3289
stp3290
a((dp3291
g2
(lp3292
VThe way Windows paints is that the system posts your window  messages instructing you to paint
p3293
aVYou can elect to ignore these messages if you so wish, whilst you are modifying the layout, and then force a paint cycle once you have finished modifying the layout
p3294
aVHowever, my experience of writing UI on Windows is that you usually don't need to take such steps
p3295
aVSince you are in charge of pumping your message queue, if the window is being refreshed whilst you are in the middle of modifying the layout, then you must have taken action that led to the message queue being pumped
p3296
aVPut simply, stop pumping the queue whilst modifying the layout and your problems will vanish
p3297
as(dp3298
g7
V505088
p3299
stp3300
a((dp3301
g2
(lp3302
VThis can be done relatively easily as documented on MSDN: How to set a Thread Name in Native Code
p3303
aVEssentially you send the debugger a magic exception containing the name and the thread ID, and the debugger then keeps track of and displays the name you sent it
p3304
aVThe sample code from the MSDN article is included below:
p3305
as(dp3306
g7
V505088
p3307
stp3308
a((dp3309
g2
(lp3310
VIt's almost always preferable to regard the entity that create an object also to be its owner (i
p3311
ag192
aVresponsible for destroying it)
p3312
aVTo understand why I say this, consider the alternative
p3313
aVSuppose that object A creates object B
p3314
aVAt some point later it passes B to object C which becomes the owner
p3315
aVIn the period between creating B and handing it over to C, A is responsible for destruction in case of exceptions, or perhaps the selection of a branch that bypasses C
p3316
aVOn the other hand, once it has handed off B, A must not attempt to destroy C
p3317
aVAll this can be handled with sufficient care
p3318
aVOne approach is that taken by the  with
p3319
aVHowever, if you can find a way to stick to the two standard patterns of ownership then do so
p3320
aVWhat are the two standard patterns
p3321
aVCreate in a constructor and assign to a field; destroy in the matching destructor
p3322
aVCreate and destroy inside a single method, with protection provided by  /
p3323
aVI would strongly recommend that you try to shape your code so that all resource acquisition uses one of these two options
p3324
aVHow can you do so in your example
p3325
aVThe option that leaps out at me is to use a factory to create your  object
p3326
aVThis allows  to manage the lifetime of the  object, but gives you the flexibility of injecting different behaviour into
p3327
as(dp3328
g7
V505088
p3329
stp3330
a((dp3331
g2
(lp3332
VYou already know the answer to this, use the  command line option
p3333
aVSimply change your file association for
p3334
aVdproj,
p3335
aVgroupproj,
p3336
aVdpr etc
p3337
aVto include this option and it's all good
p3338
as(dp3339
g7
V505088
p3340
stp3341
a((dp3342
g2
(lp3343
VThe solution to this is to use
p3344
aVI can't imagine why you wouldn't want to use the perfect tool for the job
p3345
as(dp3346
g7
V505088
p3347
stp3348
a((dp3349
g2
(lp3350
VYou can do this in any program other than , e
p3351
ag217
aV,  etc
p3352
aVYou just can't do it in Explorer, and Raymond Chen has offered an explanation as to why not
p3353
as(dp3354
g7
V505088
p3355
stp3356
a((dp3357
g2
(lp3358
VBoth of your variables  and  should be declared as
p3359
aVYou actually declare  as  although that is equivalent
p3360
aVYou are correct that since they are  parameters you should not include the  address operator
p3361
aVIt's hard to say why you are getting the error message without actually knowing what you pass for the other parameters
p3362
aVEDIT
p3363
aVAs commentators have pointed out, the JEDI translation is incorrect and , because it is an optional parameter, should be passed by value and typed as  so that you are able to pass
p3364
as(dp3365
g7
V505088
p3366
stp3367
a((dp3368
g2
(lp3369
VPersonally, I'd just do it like this:
p3370
aVIf you don't have  then you should get it and learn how to use it
p3371
aVI recommend the version from GnuWin32
p3372
as(dp3373
g7
V505088
p3374
stp3375
a((dp3376
g2
(lp3377
VRunning this on multiple threads, with that big an array will net linear speed-up
p3378
aVIt's embarrassingly parallel as they say
p3379
as(dp3380
g7
V505088
p3381
stp3382
a((dp3383
g2
(lp3384
VThe scalar product equation you calculate is zero if and only if the three points are co-linear
p3385
aVHowever, on a finite precision machine you don't want to test for equality to zero but instead you test for zero up to some small tolerance
p3386
aVSince the equation can be negative as well as positive your test isn't going to work
p3387
aVIt will return false positives when the equation evaluates to a large negative value
p3388
aVThus you need to test that the absolute value is small:
p3389
aVExactly how to choose tolerance depends on information you haven't provided
p3390
aVWhere do the values come from
p3391
aVAre they dimensional
p3392
as(dp3393
g7
V505088
p3394
stp3395
a((dp3396
g2
(lp3397
VThe most likely reason for you error is that you are overflowing the accumulators  or
p3398
aVI know nothing about neural networks so I can't offer any explanation as to why this is so
p3399
aVAs a side issue, I question the use of  floating point variables
p3400
aVNormally this simply results in extremely slow performance, much slower than when using
p3401
aVYou may think it gives you more headroom for large numbers, but in reality, if this is a run-away overflow of the nature that I suspect, then using  would never save you
p3402
aVUPDATE OP points out that overflow results in a different exception class
p3403
aVSo for  I suspect some square root or trig failure or something like that
p3404
aVOr perhaps a signaling NaN, but since you don't obviously use uninitialised data I'll not persue that
p3405
aVI can see now that you have been affected by Embarcadero's bizarre decision to break their implementation of
p3406
aVThis used to work perfectly on older versions of Delphi (e
p3407
ag217
aVD6), but was broken recently
p3408
aVThe version you use isn't quite right for large negative input, and uses two calls to  when one suffices
p3409
aVI use this version:
p3410
as(dp3411
g7
V505088
p3412
stp3413
a((dp3414
g2
(lp3415
VThe correct answer to this question, in my view, is to start at the source rather than to reverse engineer the solution with Dependency Walker, awesome and useful tool though it undoubtedly is
p3416
aVThe problem with Dependency Walker is that it only tells you what one particular run of the program requires on the OS on which you run it
p3417
aVIf you have any dynamic loading dependencies in your app then you would only pick those up if you made sure you profiled the app with Dep
p3418
aVWalker and forced it through those dynamic loads
p3419
aVMy preferred approach to this problem is to start with your own source code and analyse and understand what it depends upon
p3420
aVIt's often easy enough to do so because you know it well
p3421
aVYou need to understand what are the deployment requirements for your compiler
p3422
aVYou usually have options of linking statically and dynamically to the C++ runtime
p3423
aVObviously a dynamic link results in a deployment requirement
p3424
aVYou will also likely link to 3rd party code
p3425
aVOne example would be Windows components
p3426
aVThese typically don't need deployment, you can take them as already being in place
p3427
aVSometimes that's not true, e
p3428
ag217
aVGDI+ on Windows 2000
p3429
aVSometimes you will link statically to 3rd party code (again easy), but if you link dynamically then that implies a deployment requirement
p3430
as(dp3431
g7
V505088
p3432
stp3433
a((dp3434
g2
(lp3435
VI take this question to mean that you wish to develop a custom component and to do so visually rather than in code
p3436
aVIf that is your question then I'm afraid that you can't do it
p3437
as(dp3438
g7
V505088
p3439
stp3440
a((dp3441
g2
(lp3442
VWhilst you can do this, you should not
p3443
aVShortcuts using the Windows key belong to Windows and should never be used by other application
p3444
aVIn fact, even global system wide shortcuts are a problem because they may well clash with another applications shortcuts
p3445
aVThis is the main reason Windows is able to use system wide shortcuts associated with the Windows key because the contract is that it reserves those shortcuts for its use and your app doesn't, thus avoiding clashes
p3446
aVIf you do decide to do this, and I ever run into your software, then I will hate you with a passion for as long as I live
p3447
as(dp3448
g7
V505088
p3449
stp3450
a((dp3451
g2
(lp3452
VYou need to store dates and times in a standard format (e
p3453
ag217
aVa Delphi )
p3454
aVYou only convert them to human readable forms when you display them
p3455
aVAfter your edit to clarify, what you need to do is to convert the date and time separately and then add together the two resulting  values
p3456
aVSo your code should be:
p3457
as(dp3458
g7
V505088
p3459
stp3460
a((dp3461
g2
(lp3462
VI tried with two TDateTimePickers, one set to hold a data, and one to hold a time
p3463
aVIs that what you are doing
p3464
aVI find that the following works for me with no errors:
p3465
aVThe output is:
p3466
as(dp3467
g7
V505088
p3468
stp3469
a((dp3470
g2
(lp3471
VWhen you copy a shell object (e
p3472
ag217
aVa file or a folder) to the clipboard, the shell places data into the clipboard in a variety of different formats
p3473
aVThe clipboard viewer for such an operation shows the following formats:
p3474
aVI honestly don't know which one is used when you subsequently paste, but my guess would be the
p3475
aVThe point is that the files and folders don't go into the clipboard, only references to them
p3476
aVI believe that there is comprehensive documentation of this on MSDN: Shell Clipboard Formats
p3477
aVThat should give you enough orientation to conduct a further web search for Python wrappers to such functionality (I'm sure they will exist)
p3478
as(dp3479
g7
V505088
p3480
stp3481
a((dp3482
g2
(lp3483
VAs Mikael suggested, there are a many ways to do this
p3484
aVTo re-cap you wish to store a  to a file in textual format and be able to restore this value successfully irrespective of the locale on which the restoration happens
p3485
aVOption 1
p3486
aVWhen storing, call , say, but force a '
p3487
aVfor the decimal separator through the  parameter
p3488
aVOn restore, use  with the same
p3489
aVOption 2
p3490
aVEncode the 8 byte  value using base 64
p3491
aVThis has the downside that it renders the value unreadable
p3492
aVOption 3
p3493
aVSimilar to option 1, but encode the  by calling  and explicitly passing a  that does not rely on anything in the locale \u2013 so do not rely on the locale's date or time separators, instead force your own
p3494
aVTo reverse call  with an identical  record
p3495
as(dp3496
g7
V505088
p3497
stp3498
a((dp3499
g2
(lp3500
VWhy don't you just stuff it into a rich text control and print that
p3501
aVNo more than 10-15 lines of code should get it done
p3502
as(dp3503
g7
V505088
p3504
stp3505
a((dp3506
g2
(lp3507
VWindows doesn't maintain separate current directories for separate drives
p3508
aVThat's something that DOS used to do and cmd
p3509
aVexe emulates by remembering values for each drive
p3510
aVWhen you change drive in cmd
p3511
aVexe it sets the current directory, including the drive
p3512
aVIf you want the same functionality you'll have to do it yourself
p3513
aVRaymond Chen blogged about this: http://blogs
p3514
aVmsdn
p3515
aVcom/b/oldnewthing/archive/2010/10/11/10073890
p3516
aVaspx
p3517
as(dp3518
g7
V505088
p3519
stp3520
a((dp3521
g2
(lp3522
VThe official line is that shell extensions should not be written in managed code
p3523
aVFor example, see what Raymond has to say
p3524
aVOr the official line from MSDN
p3525
as(dp3526
g7
V505088
p3527
stp3528
a((dp3529
g2
(lp3530
VI guess you could always just ask for  and take it from there
p3531
aVBut I think your question is a bit confused and the way you use certain terminology makes me suspect your basic knowledge of COM is lacking somewhat
p3532
as(dp3533
g7
V505088
p3534
stp3535
a((dp3536
g2
(lp3537
VThe sharing of static resources between all threads attached to a single DLL within a process conspires against you here
p3538
aVHowever, there is a trick to achieve this
p3539
aVSo long as DLLs have different names, then the system regards them as being different and so separate instances of code and data are created
p3540
aVThe way to achieve this is, for each thread, copy the DLL to a temporary file and load from there with
p3541
aVYou have to use explicit linking () rather than lib files but that's really the only way
p3542
as(dp3543
g7
V505088
p3544
stp3545
a((dp3546
g2
(lp3547
VThe  function is documented at MSDN
p3548
aVUser mode programs use it to interact with device drivers
p3549
aVConverting this code is pretty simple
p3550
aVThe call to  maps across trivially
p3551
aVThe only area that you are likely to struggle with is the C bitwise operations
p3552
aVIf you don't have a copy of K&R; to hand, then you should
p3553
as(dp3554
g7
V505088
p3555
stp3556
a((dp3557
g2
(lp3558
VIt's the address or location of the memory to which the pointer refers
p3559
aVHowever, it's best if you regard this as an opaque quantity - you are never interested in the actual value of the pointer, only that to which it refers
p3560
aVHow the address then relates to physical memory is a service that the system provides and actually varies across systems
p3561
as(dp3562
g7
V505088
p3563
stp3564
a((dp3565
g2
(lp3566
VThe compiler emits a hint if it can't inline your function
p3567
aVThe documentation explains the rules for what can and cannot be inlined
p3568
aVAs for the discretionary decisions that the compiler takes as to whether or not to inline (as opposed to whether or not inlining is possible), they are not documented and can be considered an implementation detail
p3569
aVI recall that you recently commented on one of my answers to a different question that a particular function was 10 times faster once inlined
p3570
aVClearly you are interested in inlining but in that particular case I cannot believe such an enormous gain for a function with so many floating point operations
p3571
aVI suspect that inlining is not actually giving you the performance improvements that you think it does
p3572
as(dp3573
g7
V505088
p3574
stp3575
a((dp3576
g2
(lp3577
VIt seems that you don't actually want to test whether the thread is finished, but instead want to know whether or not it has started
p3578
aVYou would normally do this as follows:
p3579
aVOnce you know it has started ( not ) then you can test for it being completed with the  method that you are already aware of, or with
p3580
as(dp3581
g7
V505088
p3582
stp3583
a((dp3584
g2
(lp3585
VI think the problem lies with R
p3586
aVI can happily source UTF-8 files, or UCS-2LE files with many non-ASCII characters in
p3587
aVBut some characters cause it to fail
p3588
aVFor example the following
p3589
aVis fine in both UTF-8 and UCS-2LE without the Russian line
p3590
aVBut if that is included then it fails
p3591
aVI'm pointing the finger at R
p3592
aVYour Chinese text also appears to be too hard for R on Windows
p3593
aVLocale seems irrelevant here
p3594
aVIt's just a file, you tell it what encoding the file is, why should your locale matter
p3595
as(dp3596
g7
V505088
p3597
stp3598
a((dp3599
g2
(lp3600
VIt's freed automatically once it is no longer needed
p3601
aVThe compiler generates code to do that so that you don't need to
p3602
aVWhen the disposal happens is an implementation detail
p3603
as(dp3604
g7
V505088
p3605
stp3606
a((dp3607
g2
(lp3608
VYou shouldn't return an error
p3609
aVYou should succeed, fill the buffer with what you can, and return through another parameter how big the buffer needs to be
p3610
aVIf you don't do it this way, how does the caller discover how big a buffer to allocate
p3611
aVYou don't seriously want them to call repeatedly, with progressively bigger buffers, until they hit upon a value that suffices
p3612
aVI would hate to have to use such an interface
p3613
as(dp3614
g7
V505088
p3615
stp3616
a((dp3617
g2
(lp3618
VHave a read of Effective minidumps at DebugInfo
p3619
aVcom looks like it would guide you to a solution
p3620
as(dp3621
g7
V505088
p3622
stp3623
a((dp3624
g2
(lp3625
VOne bug that I am aware of occurs when you have a class which declares a record inline, as so:
p3626
aVIf you have any code like this then many of the IDE's code insight/completion/whatever features stop working
p3627
aVThis fault stretches right back to Delphi 6 and possibly beyond
p3628
aVI fix it with an class private type declaration:
p3629
aVBut if that syntax is not available in D2007 then you'd need to declare the record type outside the class
p3630
aVAnother factor which I find can confuse the IDE is if you are using a lot of conditional statements ( and the like)
p3631
aVFinally I'd recommend installing Andreas Hausladen's IDEFixPack which does improve IDE behaviour
p3632
aVOf course, your problem may be caused by something else, but without being able to experiment with your actual code, we have to guess to a degree
p3633
as(dp3634
g7
V505088
p3635
stp3636
a((dp3637
g2
(lp3638
VYour best bet is to declare it as  using the new anonymous methods feature and then you can keep everything nicely encapsulated
p3639
aVThis gets around the issues that Mason describes by capturing any variables local to the anonymous function
p3640
as(dp3641
g7
V505088
p3642
stp3643
a((dp3644
g2
(lp3645
VYour best bet is just to use locks/mutexex
p3646
aVIt's a simple approach, it works and you can easily understand it and reason about it
p3647
aVWhen it comes to synchronization it often pays to start with the simplest solution that could work and only try to refine if you hit problems
p3648
as(dp3649
g7
V505088
p3650
stp3651
a((dp3652
g2
(lp3653
VIt adds a string value and associated integer to a combo box
p3654
aVThe aspect you may be missing is that list boxes, combos etc
p3655
aVstore an integer value (the same size as a pointer) in a list parallel to the list of text labels
p3656
aVYou can put whatever you like in the integer value
p3657
aVFor example you could put in a pointer to some  containing further information
p3658
aVWhen you need to respond to the user's selection, you simply read out the selected integer value, cast it to a pointer, and do something with that information
p3659
aVOf course, many lists and combos don't need any of this (a simple string suffices) and so  would typically be passed
p3660
as(dp3661
g7
V505088
p3662
stp3663
a((dp3664
g2
(lp3665
VYou need to pipe it rather than redirect it:
p3666
aVOf course, DebugView needs to read from standard input for this to work
p3667
as(dp3668
g7
V505088
p3669
stp3670
a((dp3671
g2
(lp3672
VYou can print the arguments without transferring them into character arrays
p3673
aVThey are null-terminated C strings and  eats them for breakfast:
p3674
as(dp3675
g7
V505088
p3676
stp3677
a((dp3678
g2
(lp3679
VProgram:
p3680
aVOutput:
p3681
as(dp3682
g7
V505088
p3683
stp3684
a((dp3685
g2
(lp3686
VWhat you are looking for is known as a dictionary, if I understand you correctly
p3687
aVIn other languages it is known as an associative array or sometimes a hash
p3688
aVYou are going to want a modern version of Delphi, I'd guess 2010 or XE
p3689
aVIf you can't access those then you'd need a 3rd party library, or a home grown based off a
p3690
aVIn fact  can operate in a dictionary like mode but it's a bit clunky
p3691
aVYou declare the dictionary as follows:
p3692
aVYou can add do it as follows:
p3693
aVThe first parameter is the key
p3694
aVThe second is the value
p3695
aVThink of this as an array but indexed with a string rather than an integer
p3696
aVIf you want to recover a value then you use:
p3697
aVIn your case you would write:
p3698
aVIf you want to save to a file then you would iterate over the dict:
p3699
aVI've ignored all error handling issues, dealing with adding keys that already exist, asking for keys that are not in the dict, and so on
p3700
aVBut this should give you a flavour
p3701
aVI'd recommend reading up on associative arrays if you aren't already familiar with them
p3702
aVI'm sure there will be a page on Wikipedia and you would do worse than read an tutorial on Python which is sure to cover them \u2013 the issues are really the same no matter what language you consider
p3703
as(dp3704
g7
V505088
p3705
stp3706
a((dp3707
g2
(lp3708
VThe VCL property  maps onto the GDI function
p3709
aVThis has no option for what you describe and so I believe that what you ask is not possible
p3710
aVTo achieve the sort of effect you are looking for is likely going to require some hand-crafting
p3711
as(dp3712
g7
V505088
p3713
stp3714
a((dp3715
g2
(lp3716
VThe function you need is called
p3717
aVYou need to e-mail saslib@microsoft
p3718
aVcom and ask for it
p3719
aVMicrosoft don't appear to document this, but just do a websearch for  and you'll see what I mean
p3720
aVOthers have explained why it's actually not a security issue to allow apps to trigger CTRL+ALT+DEL, but you certainly can't do it with
p3721
as(dp3722
g7
V505088
p3723
stp3724
a((dp3725
g2
(lp3726
VYou send it a WM_GETTEXT message
p3727
aVIf it's your form in your process then you will know the window handle
p3728
aVOtherwise you've got to get hold of it by some means
p3729
as(dp3730
g7
V505088
p3731
stp3732
a((dp3733
g2
(lp3734
VIt would seem that the problem was introduced by recent changes in your custom component
p3735
aVYou should use your revision control system to go back to a known good version
p3736
aVThen advance to intermediate versions of the code, perhaps using a binary search for efficiency
p3737
aVOnce you've isolated the revision which introduced the bug then you should be able to study the code changes in that revision and identify the problem
p3738
as(dp3739
g7
V505088
p3740
stp3741
a((dp3742
g2
(lp3743
VIt kind of depends on what you are trying to learn
p3744
aVIf you want to learn about how GUI libraries work as opposed to how to use them then you want to look at plain Win32
p3745
aVIf you want to learn how to use them then you'll find C# or VB with WinForms the easiest to pick up
p3746
aVAnd of course they let you use a great designer
p3747
aVDon't worry about issues like cross platform whilst you are learning the basics
p3748
aVYou should focus on learning principles rather than specifics
p3749
as(dp3750
g7
V505088
p3751
stp3752
a((dp3753
g2
(lp3754
VI can't imagine how this would help you achieve anything but the way to do it is to modify the affinity after the processes start
p3755
aVEnumerate the processes and do to them what you wish
p3756
aVYou can easily do this with
p3757
aVI expect you would encounter security restrictions when you attempt this for services
p3758
aVWhich services ever consume significant CPU anyway
p3759
aVModifying affinity is very rarely a good idea
p3760
as(dp3761
g7
V505088
p3762
stp3763
a((dp3764
g2
(lp3765
VYou are presumably talking about an app that runs in a RTL culture
p3766
aVBut you want to inject some text from a LTF culture
p3767
aVThere are Unicode characters that indicate that certain parts of a block of text are LTR or RTL
p3768
aVCan you do it that way
p3769
as(dp3770
g7
V505088
p3771
stp3772
a((dp3773
g2
(lp3774
VYou question is "how do I use RTTI to access record fields in Delphi 2007
p3775
aVThe answer is that you can't, you need Delphi 2010
p3776
as(dp3777
g7
V505088
p3778
stp3779
a((dp3780
g2
(lp3781
VThe only way you could hope to achieve this would be if you kept the sensitive parts in modules that were delivered to unprivileged developers in binary form
p3782
aVIf you expect them to compile and run this sensitive code then they can see it
p3783
aVWhat the compiler sees, so does the developer
p3784
as(dp3785
g7
V505088
p3786
stp3787
a((dp3788
g2
(lp3789
VYou are looking for  but good luck with getting anything out of the MSDN documentation
p3790
aVI suggest a web search for ITrayDeskBand and looking at the top hits that aren't on MSDN
p3791
aVFor example, this from the Code Project looks useful
p3792
aVNote that since this is a shell extension, most of the code you find will be native because
p3793
aVNET shell extensions are somewhat frowned upon
p3794
as(dp3795
g7
V505088
p3796
stp3797
a((dp3798
g2
(lp3799
VI don't quite understand what your problem is
p3800
aVYou link to DLLs using header and lib files
p3801
aVI think you already know this
p3802
aVIf you want to share an instance between code in different DLLs you need to export that instance just like you export the classes and functions
p3803
aVYou can export the symbol directly, or provide a function to obtain a reference to the instance
p3804
aVYou seem to be saying that DLL A refers to DLL B and vice versa
p3805
aVIn which case, despite your protestations to the contrary in the comments, it would be easier to combine them into one DLL
p3806
as(dp3807
g7
V505088
p3808
stp3809
a((dp3810
g2
(lp3811
VYou need it this way:
p3812
aVI'm assuming that your intention is to consume the ,  and  in your  routine and then pass the remaining parameters to
p3813
aVI don't believe that this is actually what you want (I can see that  wants to receive ,  and  and so they should not be consumed)
p3814
aVI had deleted this answer but since your posted code apparently works, I'll leave this visible for a little while and see if it provokes the real question to be revealed
p3815
as(dp3816
g7
V505088
p3817
stp3818
a((dp3819
g2
(lp3820
VI now have the solution for you
p3821
aVCalling  (your call to  in ) results in the action being transferred back into the main thread which is why your UI becomes unresponsive
p3822
aVInstead you should call  which performs no such machinations and works as you intend: the download runs on the worker thread
p3823
as(dp3824
g7
V505088
p3825
stp3826
a((dp3827
g2
(lp3828
V is being sent rather than posted which is why it never lands in the message queue
p3829
aVIf it ends up in the , and it doesn't come through the message pump, what other explanation could there be
p3830
aVWindow handles are destroyed by calling  which, in turn, sends the  message directly to the
p3831
aVI think you will need to find some other way for your potential main windows to decide which one is the one that brings the curtain down when it is destroyed
p3832
as(dp3833
g7
V505088
p3834
stp3835
a((dp3836
g2
(lp3837
VYou need the API functions for critical sections:
p3838
aVCall once, from any thread, but typically the main thread, to initialize the lock
p3839
aVInitialize before you do anything else with it
p3840
aVCall from any thread to acquire the lock
p3841
aVIf another thread has the lock, it will block until it can acquire the lock
p3842
aVCritical sections are re-entrant meaning a thread successfully acquires the lock even if it already holds it
p3843
aVRelease the lock
p3844
aVEach call to  must be paired with a matching call to
p3845
aVDon't let exceptions stop these acquire/release calls being paired up
p3846
aVCall once, from any thread, but typically the main thread, to finalize the lock
p3847
aVDo this when no threads hold the lock
p3848
aVAfter you call this the lock is invalid and you can't attempt to acquire it again
p3849
aVMSDN helpfully provide a trivial example
p3850
aVIf you are using MFC then you would probably use  which wraps up the Win32 critical section APIs in a class
p3851
aVAs for how you do it with your array
p3852
aVWell, your threads will only execute blocks of code protected by the lock one at a time
p3853
aVYou need the lock to stop race conditions where two threads try to read/write to the same memory location simultaneously, or indeed other more subtle conditions that can break your algorithm
p3854
aVIf you were to describe the array, its contents, and how you operate on it, then it might be possible to give you some specific advice
p3855
aVExactly how you operate on this array will have a large bearing on the ideal synchronisation strategy, and in certain cases you may be able to use lock-free methods
p3856
as(dp3857
g7
V505088
p3858
stp3859
a((dp3860
g2
(lp3861
VI do this by responding to WM_KILLFOCUS messages sent to the inplace editor
p3862
aVI have to subclass the inplace editor to make this happen
p3863
aVI understand from Raymond Chen's blog that this is not appropriate if you then perform validation that changes the focus
p3864
as(dp3865
g7
V505088
p3866
stp3867
a((dp3868
g2
(lp3869
VHere's some very basic code that should get you on your way
p3870
aVThere's no error checking, and you'll no doubt want to develop it and modify it further
p3871
aVThe point is that there should be some ideas to help you write code that works for you
p3872
aVNow that I have comma-separated the fields, but made no attempt to handle the appearance of commas in any of the values
p3873
aVIf this is a problem then choose a different delimiter, or escape the commas
p3874
aVI had toyed with writing each field on its own line (effectively using a newline as the separator), but this makes the reading code more tricky to write
p3875
aVAgain, the main point is that this is not final production code, but is intended to give you a starting point
p3876
aVNote that you don't attempt to search the file on disk
p3877
aVYou simply load it into memory, into the dictionary and look things up from there
p3878
aVA dictionary is great when you always use the same key
p3879
aVIf you have multiple keys then a dictionary is less convenient, but who cares about the performance impact if you've only got 15 records
p3880
aVDisclaimer: I've not run the code, I've not tested it, etc
p3881
aVetc
p3882
as(dp3883
g7
V505088
p3884
stp3885
a((dp3886
g2
(lp3887
VI can't see how this could possibly work well
p3888
aVPresumably you'd have to have your own intermediate directories where your output files went
p3889
aVIf you both wrote object files to the same folders then that would be a disaster
p3890
aVHow would you synchronize
p3891
aVOne of you, person A, starts to compile but person B carries on editing
p3892
aVWhat version of the file that B is editing does A's compile use
p3893
aVWould B be blocked from editing just because A was compiling
p3894
aVThis would require significant support from tool vendors and I can't imagine that ever happening because nobody would want to use it
p3895
as(dp3896
g7
V505088
p3897
stp3898
a((dp3899
g2
(lp3900
VThe simple answer is that you cannot figure out what that is from this information
p3901
aVYou need to ask whoever generated it to tell you the code
p3902
aVIf you have a lot of such numbers and you know that they are all encoded the same way, then you might feel more confident to take an educated guess
p3903
as(dp3904
g7
V505088
p3905
stp3906
a((dp3907
g2
(lp3908
VIf you've correctly defined the function in the DLL, and it is exported properly, then the only plausible explanation is that there is something wrong with your use of the
p3909
aVlib file in the application that uses the DLL
p3910
as(dp3911
g7
V505088
p3912
stp3913
a((dp3914
g2
(lp3915
VYou need the message queue to be pumped to make the paint cycle works
p3916
aVIt seems that there is some pumping occurring (you say that some controls re-draw)
p3917
aVSince modal dialogs run their own message pump, I'm going to take a wild guess that the host for your plugin has some special treatment of messages, quite possibly erroneous, in its message pump and that your standard dialog box message pump does things differently
p3918
aVI'm guessing and making large leaps of faith, but I suspect your host app's message loop isn't of the standard  /  form
p3919
aVIf so then you are truly hosed
p3920
aVWithout more details it's really impossible to say anything with much certainty
p3921
aVAs Hans says, a minimal reproduction would make the problem easy to solve
p3922
as(dp3923
g7
V505088
p3924
stp3925
a((dp3926
g2
(lp3927
VI store, in my
p3928
aVdproj files, settings that are used by  for my build process
p3929
aVFor example, conditional defines, compiler settings, etc
p3930
aVIf you do the same then you need to version them
p3931
aVIf you are using a version of Delphi where the IDE breaks the
p3932
aVdproj file on a regular basis, then surely revision control will help you fight back
p3933
aVI can't see any advantage in not versioning them
p3934
as(dp3935
g7
V505088
p3936
stp3937
a((dp3938
g2
(lp3939
VYou are using some devexpress components and the problem is that you are using versions of the code that pre-date C++ Builder XE
p3940
aVThe particular problem is that the conditional defines declared in cxVer
p3941
aVinc do not know about XE
p3942
aVConsequently, this cxClasses
p3943
aVpas file does not know which version of Delphi it is targeting
p3944
aVIn most circumstances you could simply add the necessary defines and the code would start working
p3945
aVHowever, your version of the devexpress code is for RAD Studio 2007 which uses ANSI strings, but you are trying to compile on XE which uses Unicode strings
p3946
aVThis difference needs major changes to the rest of the source code
p3947
aVUnfortunately, to get this code to work on XE you will need to get hold of the latest versions of all your 3rd party components
p3948
aVThe updated versions have had the necessary changes to support Unicode text
p3949
aVWhat's more, your code may also need some significant re-work to support Unicode but I am less sure on that point because my experience is with Delphi rather than C++ Builder
p3950
as(dp3951
g7
V505088
p3952
stp3953
a((dp3954
g2
(lp3955
VCall the
p3956
aVNET equivalents to Win32 API functions  and , and the system will tell you why it's not letting you do this
p3957
aVCody is probably right in guessing that it is related to UAC, but without knowledge of where you are trying to write this file, we can only guess
p3958
aVUpdate
p3959
aVAs has been explained to me in the comments,  is the
p3960
aVNET way to get hold of the error code rather than calling  directly
p3961
aVCalling  directly will return the error code of the latest call to the Win32 API, which is likely to have been from a
p3962
aVNET runtime call to Win32 rather than your P/Invoke
p3963
as(dp3964
g7
V505088
p3965
stp3966
a((dp3967
g2
(lp3968
VThis change was made for a reason and not simply to annoy developers
p3969
aVThe correct approach is to put your UI in a different program and communicate with the session through a pipe, or some other IPC mechanism
p3970
aVThe recommendation that services do not present UI is more than 10 years old now
p3971
aVYou should really try to follow these rules, even though it may seem inconvenient to begin with
p3972
aVOn the plus side you will enjoy the benefit of keeping your service logic and UI logic separate
p3973
aVIf your services runs under the LOCALSYSTEM account then you can check "Allow service to interact with desktop", for the benefit of legacy services that would fail if they could not show UI
p3974
aVBut it won't help you anyway because the UI will show in session 0 where it is never seen
p3975
aVI recommend you take a read of the official Microsoft document describing session 0 isolation
p3976
as(dp3977
g7
V505088
p3978
stp3979
a((dp3980
g2
(lp3981
VYou won't get that event to fire because that key press is interpreted as form navigation
p3982
aVThe top level message loop recognises that this is a navigation key and diverts the message to perform that navigation
p3983
aVIf you want to handle this event then your only opportunity to do so is in  which fires before the message is diverted
p3984
aVUPDATE
p3985
aVIn a comment you indicate that you want to intercept this event in order to perform navigation
p3986
aVSince the event is not firing because default navigation is being performed, perhaps the ideal solution is to override the default navigation
p3987
aVI believe that the key routine that drives this is
p3988
aVReading through this code, I think you just need to handle  in your form and persuade the navigation to behave the way you want it to
p3989
aVYour code should look something like this:
p3990
as(dp3991
g7
V505088
p3992
stp3993
a((dp3994
g2
(lp3995
VI'm going to talk about Windows in this answer
p3996
aVI know nothing substantial about other operating systems so I'll not embarrass myself by not talking about them
p3997
aVI'm not making any judgements about which of Windows or Linux is better or worse than the other
p3998
aVNowadays, you always want to be using the 64 bit version of Windows rather than the 32 bit version
p3999
aVThe 64 bit version of Windows runs 32 bit programs perfectly (sometimes even a little faster than the 32 bit version of Windows manages)
p4000
aVWhen you run a 32 bit program under 64 bit Windows, it can get access to 4GB address space
p4001
aVUnder 32 bit Windows it only gets a 2GB address space
p4002
aVSo even if you stick to 32 bit R you'll have more head-room under 64 bit Windows
p4003
aVHowever, there is nowadays a 64 bit version of R
p4004
aVThis is less mature than the 32 bit version but it will most likely meet your needs
p4005
aVYou may need to check for package compatibility since some packages may not yet support 64 bit R on Windows yet
p4006
aVYou may actually experience a drop-off in performance with the 64 bit version of R because pointer width doubles and so the memory footprint is bigger
p4007
aVHowever, I'd be surprised if this was at all significant
p4008
aVYou can install both 32 and 64 bit versions side-by-side, but if you can get away with just one version I'd always recommend doing so - it makes maintenance so much easier
p4009
aVAs your machine only has 4GB of memory anyway, there's probably not that much to be gained from using the 64 bit version of R
p4010
aVThe 64 bit version of Windows will make a big difference, but if you go to the 64 bit version of R as well, and actually use 4GB of memory then you are likely to see lots of disk thrashing and your calculations will take forever
p4011
aVFinally, when faced with memory resource shortages it is often possible to find alternative ways to organise your code so that you simply avoid the issue altogether
p4012
aVSince we don't have the details of your R code, we can't tell if that is the case here, but it may be worth thinking about
p4013
as(dp4014
g7
V505088
p4015
stp4016
a((dp4017
g2
(lp4018
VPage faults are normal
p4019
aVMemory gets swapped out and when you next access it that's a page fault and the system brings it back
p4020
aVThis is by design
p4021
aVI've got an app running on my machine right now with 500 million page faults
p4022
aVThere's nothing to worry about
p4023
as(dp4024
g7
V505088
p4025
stp4026
a((dp4027
g2
(lp4028
VThe referrer is part of the HTTP protocol
p4029
aVShellExecute opens an app which then processes the URL, by sending an HTTP request
p4030
aVIt's that app that specifies the referrer
p4031
aVThe very best you could do would be to include something in the URL and process it at the HTTP server end (presumably you are in control of the server end)
p4032
as(dp4033
g7
V505088
p4034
stp4035
a((dp4036
g2
(lp4037
VAn integer value cannot be empty
p4038
aVIt always holds a value
p4039
aVIt's not like a nullable type in certain modern languages
p4040
aVSometimes, by convention, certain values are used as sentinels, but you obviously need to apply this convention consistently across all uses of the variable
p4041
aVWhat's more, a sentinel is only viable if you have some spare values that do not have a meaning in whatever calculation you are performing
p4042
as(dp4043
g7
V505088
p4044
stp4045
a((dp4046
g2
(lp4047
VFirst of all, you haven't shown enough code for us to be able to help you with any great certainty of correctness
p4048
aVBut, having made that proviso, I'm going to try anyway
p4049
aVYour use of the word fork suggests to me that you are approaching Windows threading from a pthreads background
p4050
aVWindows threads are a little different
p4051
aVRather confusingly, the most effective in-process mutex object in Windows is not the mutex, it is in fact the critical section
p4052
aVThe interface for the critical section is much simpler to use, it being essentially an acquire function and a corresponding release function
p4053
aVIf you are synchronizing within a single process, and you need a simple lock (rather than, say, a semaphore), you should use critical sections rather than mutexes
p4054
aVIn fact, only yesterday here on Stack Overflow, I wrote a more detailed answer to a question which described the standard usage pattern for critical sections
p4055
aVThat post has lots of links to the pertinent sections of MSDN documentation
p4056
aVHaving said that, it would appear that all you are trying to do is to synchronize the decrementing of an array of integer values
p4057
aVIf that is so then you can do this most simply in a lock free manner with  or one of its friends
p4058
aVYou only need to use a mutex when you are performing cross process synchronization
p4059
aVIndeed you should only use a mutex when you are synchronizing across a process because critical sections perform so much better (i
p4060
ag192
aVfaster)
p4061
aVSince you are updating a simple array here, and since there is no obviously visible IPC going on, I can only conclude that this really is in-process
p4062
aVIf I'm wrong and you really are doing cross-process work and require a mutex then we would need to see more code
p4063
aVFor example I don't see any calls to
p4064
aVI don't know exactly how you are creating your mutexes
p4065
aVIf this doesn't help, please edit your question to include more code, and also a high level overview of what you are trying to achieve
p4066
as(dp4067
g7
V505088
p4068
stp4069
a((dp4070
g2
(lp4071
VYou just need to create the dialog as you would create any other dialog
p4072
aVPerhaps the root of your question is that you aren't sure how to create the  control that shows a password
p4073
aVThe trick is to create it with the  style so that the text the user enters is hidden when they type
p4074
aVYou'll probably not want to store the password in your executable in plain text format
p4075
aVYour question doesn't give us much to go on
p4076
aVIt would be better if you stated what your problem is, where you are stuck, what you don't understand, etc
p4077
as(dp4078
g7
V505088
p4079
stp4080
a((dp4081
g2
(lp4082
VHow would you stop it being a free-for-all
p4083
aVIn my experience, when developing code you want to control change, not have it forced upon you when you aren't ready for it
p4084
aVConsider this scenario
p4085
aVYou have a hard to explain defect in your code
p4086
aVYou are steadily debugging it, throwing different data at it, looking at intermediate values etc
p4087
aVYou are just about to trap it when BOOM, somebody else changes some other code and your results change because of that
p4088
aVSpacedman is right, use a revision control system of your choice and keep in control of change
p4089
aVIf you want to do something like pair programming, but remotely, then use a remote screen, e
p4090
ag217
aVVNC, with Skype so that you can explain to the other what you are trying to achieve
p4091
as(dp4092
g7
V505088
p4093
stp4094
a((dp4095
g2
(lp4096
VThis smacks of poor design to me
p4097
aVOne of the points of generics is to get away from dynamic type decisions like this
p4098
aVIf you really are using the generics feature then it would make more sense to me to have a subclass with a type parameter that is constrained take only  descendents
p4099
aVSince you have to decide statically how you are going to instantiate the generic class, it is no trouble whatsoever to use a  when  is a class and to use  elsewhere
p4100
aVI guess you'd be forced to take the approach you are taking if a single container needs to contain both objects and non-objects
p4101
aVBut if that's not the case then something just feels off to me
p4102
as(dp4103
g7
V505088
p4104
stp4105
a((dp4106
g2
(lp4107
VThis is called a context menu handler, if I understand you correctly
p4108
aVYou need to register it in the registry and, typically, associate it with a file extension
p4109
aVIt's all explained over at MSDN
p4110
aVIf you need to write code to support your context menu handler, then you will be able to find numerous samples of such on the web using the keywords contained in the MSDN documentation
p4111
as(dp4112
g7
V505088
p4113
stp4114
a((dp4115
g2
(lp4116
VIf you declare them as  where they were previously global, then you have changed the meaning of the program, as well as its performance characteristics
p4117
aVWhen the variable was a global there was a single copy that each thread referred to
p4118
aVAs a thread local, each separate thread has its own variable and changes to that thread local variable are only visible in that thread
p4119
aVAssuming that you really want thread local then it is true that reading and writing thread local variables is more expensive than normal variables
p4120
aVWhenever you are faced with an operation that takes a long time to perform, the best solution is to stop doing it at all
p4121
aVIn this case there are two obvious ways to do so:
p4122
aVPass the variable around as a parameter so that it resides on the stack
p4123
aVAccessing stack variables is quick
p4124
aVIf you have functions that read and write this variable a lot, then take a copy of it at the start of the function (into a local variable), work on that local variable, and then on return, write it back to the thread local
p4125
aVOf these options the former is usually to be preferred
p4126
aVOption 2 has the big weakness that it can't easily be applied if the function calls another function that uses this variable
p4127
aVOption 1 basically amounts to not using global variables (thread locals are a form of global)
p4128
aVThis all may be completely wide of the mark of course, because you have said so little about what your code is actually doing
p4129
aVIf you want to solve a performance problem, you first have to identify where it is, and that means you need to measure
p4130
as(dp4131
g7
V505088
p4132
stp4133
a((dp4134
g2
(lp4135
VJust show the window with a z-order that places it on top of the full screen window
p4136
aVI think you can do this by calling  passing
p4137
aVSomething like this:
p4138
aVYou may want to include  as well, or possibly some of the other  options
p4139
aVYou can check the uFlags parameter in the SetWindowPos function for the different  messages
p4140
as(dp4141
g7
V505088
p4142
stp4143
a((dp4144
g2
(lp4145
Vrundll32 does not give you any return value, its exit code is always zero
p4146
aVI think you'll have to find another way
p4147
as(dp4148
g7
V505088
p4149
stp4150
a((dp4151
g2
(lp4152
VHere's a crude solution that assumes that tab and space are the only white space characters:
p4153
aVHere's a more advanced version that will detect any whitespace:
p4154
aVYou'll need one of the Unicode versions of Delphi and you'll need to use the  unit
p4155
aVIf you are using a non-Unicode version of Delphi then you would replace the if with:
p4156
as(dp4157
g7
V505088
p4158
stp4159
a((dp4160
g2
(lp4161
VYou need to manifest that your app is DPI aware with a section like this:
p4162
aVIf you do this then you won't get DPI virtualization
p4163
aVYou aren't meant to use DPI virtualization so I think there's little point trying to work out how it works
p4164
aVIt could easily be dependent on graphics card drivers
p4165
aVIt's almost impossible for us to explain why virtualization is behaving this way: you haven't even given any screenshots, hardware details etc
p4166
aVHowever, you simply shouldn't bother trying to diagnose this
p4167
aVManifest as dpiaware and it's a non-problem
p4168
aVFor reference I offer you:
p4169
aVWriting High-DPI Win32 Applications
p4170
aVhttp://www
p4171
aVrw-designer
p4172
aVcom/DPI-aware
p4173
as(dp4174
g7
V505088
p4175
stp4176
a((dp4177
g2
(lp4178
VYou need to define  as well to get this to work
p4179
aVis reverse add
p4180
aVWhen Python tries to evaluate  it first attempts to call
p4181
aVIf this fails then it falls back to
p4182
aVThis allows you to override addition by only touching one class
p4183
aVConsider for example how Python would have to evaluate
p4184
aVA call to  is attempted but  knows nothing about your class
p4185
aVYou can't very well change the  method in , hence the need for
p4186
aVI suppose it is a form of dependency inversion
p4187
aVAs Steven pointed out,  operates in place, but starts from 0
p4188
aVSo the very first addition is the only one that would need to use
p4189
aVAs a nice exercise you could check that this was the case
p4190
as(dp4191
g7
V505088
p4192
stp4193
a((dp4194
g2
(lp4195
VTry using XN Resource Editor to recover the DFM from the
p4196
aVexe
p4197
as(dp4198
g7
V505088
p4199
stp4200
a((dp4201
g2
(lp4202
VMy psychic debugging powers tell me that this unit imports  after it imports  and so the  variable in  takes the one that you want in  out of scope
p4203
aVOr perhaps the culprit is  or
p4204
aVYou can work out which it is by CTRL clicking on the  variable at the point of the first error and you'll land in a unit that isn't
p4205
aVThe solution is just to reorder your imports so that  comes in after the others
p4206
aVOn the other hand, my psychic debugging powers could be broken today
p4207
as(dp4208
g7
V505088
p4209
stp4210
a((dp4211
g2
(lp4212
VOn my 64 bit machine I can find  in  (the 64 bit system directory) but not in  (the 32 bit system directory)
p4213
aVI suspect that you are running 64 bit Windows and 32 bit Perl and so, under WOW64 emulation, the 32 bit Perl process redirects  to
p4214
aVSince  should be in your path you ought to be able to execute it by executing  without any path
p4215
aVIf you absolutely have to refer to the 64 bit system folder then you can do so from a 32 bit process with
p4216
aVIf my suspicions are correct I recommend you do some reading up on WOW64 because it can be pretty confusing until you get on top of it
p4217
aVOn the other hand, if you already know all about it I apologise for being patronising
p4218
as(dp4219
g7
V505088
p4220
stp4221
a((dp4222
g2
(lp4223
VYou don't have write access to the program files folder
p4224
aVTo get it on a temporary basis start Notepad++ as administrator from the right click menu of the shortcut you use to start it
p4225
aVThen you will be able to write this file
p4226
as(dp4227
g7
V505088
p4228
stp4229
a((dp4230
g2
(lp4231
VI'm going to take your question at face value, with a few provisos:
p4232
aVWhether you are using a Unicode Delphi or not is essential to know for interop code using  because  floats between  and  depending on the version of Delphi
p4233
aVI've assumed that you use Unicode Delphi
p4234
aVIf not then you'd need to change the string marshalling at the P/Invoke side
p4235
aVI've modified your DLL code
p4236
aVI've removed the length parameters and am working on the assumption that that you are only going to let trusted code call this DLL
p4237
aVUntrusted code could produce buffer overruns but you aren't going to let untrusted code run on your machine, are you
p4238
aVI've also changed  so that it can receive an untyped pointer
p4239
aVThere's no need for it to be types as , it's just calling
p4240
aVHere's the modified Delphi code:
p4241
aVAnd here's the C# code on the other side:
p4242
aVusing System;
p4243
aVusing System
p4244
aVRuntime
p4245
aVInteropServices;
p4246
aVThis should get you started
p4247
aVSince you are new to C# you are going to need to do quite a bit of reading up on P/Invoke
p4248
aVEnjoy
p4249
as(dp4250
g7
V505088
p4251
stp4252
a((dp4253
g2
(lp4254
VThe easiest way to solve this is to run under the debugger and have it configured to Notify on language exceptions, Tools | Options:
p4255
aVIgnore the big list of exceptions to ignore that come from my own codebase
p4256
aVJust make sure the checkbox I have highlighted is marked
p4257
aVThen when you run your program, it will stop at the line that causes the exception
p4258
as(dp4259
g7
V505088
p4260
stp4261
a((dp4262
g2
(lp4263
VYou need:
p4264
aVYou were missing the equals sign in the formula
p4265
as(dp4266
g7
V505088
p4267
stp4268
a((dp4269
g2
(lp4270
VI may as well post this this as an answer, because it seems like the answer
p4271
aVThe code that you say is D6 code will work fine unmodified in D2010, and have the same meaning
p4272
aVThere are two  overloads in Windows
p4273
aVpas
p4274
aVOne of them converts from Unicode to ANSI
p4275
aVSo you can just call  just like you always did
p4276
aVThe magic one looks like this:
p4277
as(dp4278
g7
V505088
p4279
stp4280
a((dp4281
g2
(lp4282
VThe most recent versions of  use , although you have to configure it to do so
p4283
aVHans has explained about the alternative journaling hook method of
p4284
aVis the officially sanctioned API call for faking input
p4285
aVThe documentation to  states:
p4286
aVNote  This function has been
p4287
aVsuperseded
p4288
aVUse SendInput instead
p4289
aVYou should probably use  because its lots easier
p4290
as(dp4291
g7
V505088
p4292
stp4293
a((dp4294
g2
(lp4295
VYou are looking for  and the  method:
p4296
aVThe documentation describes optional parameters that allow you to control how the process that is created is shown, and whether or not you wait for it to complete
p4297
as(dp4298
g7
V505088
p4299
stp4300
a((dp4301
g2
(lp4302
VIf you've got grep, then just call grep directly:
p4303
as(dp4304
g7
V505088
p4305
stp4306
a((dp4307
g2
(lp4308
VThis is probably failing because you are running on a machine with UAC and you don't have rights to write to
p4309
aVYou aren't going to find a satisfactory solution using the  switch because it will always try to write there
p4310
aVYou could switch to registry free COM, although it might just be better to do the registration as part of installation
p4311
aVThat's when you are expected to do it because that's when you know that you will have sufficient rights
p4312
as(dp4313
g7
V505088
p4314
stp4315
a((dp4316
g2
(lp4317
VAndreas Hausladen has a Delphi plugin that offers this sort of functionality (compile in an IDE using a different version of dcc32 than native to that IDE)
p4318
aVIt's called IDE Compiler Plugin
p4319
aVHowever, it's only available Delphi 2007 and 2009
p4320
aVTo be frank I think you are better keeping both versions of Delphi installed side by side
p4321
as(dp4322
g7
V505088
p4323
stp4324
a((dp4325
g2
(lp4326
VThe key press is Shift+Tab and if plain Tab works then Shift+Tab will too
p4327
aVThis is the keypress that all apps use to cycle the focus backwards through your controls
p4328
aVYou request in a comment that you want it to use Ctrl+Tab instead
p4329
aVThis will destroy the usability of your app
p4330
aVDon't do it
p4331
aVEspecially not when the option of doing no coding gives you the right solution
p4332
as(dp4333
g7
V505088
p4334
stp4335
a((dp4336
g2
(lp4337
V is treated as an implicit  parameter to your function
p4338
aVImagine if you wrote it out explicitly this way:
p4339
aVThen you would expect it to append to
p4340
aVThe fact that you are throwing away  each time you call it is why the compiler sometimes decides to finalise it
p4341
aVAs @gabr points out, it elects not to finalize this implicit variable when inside a loop as an optimisation
p4342
aVIf you were to assign the result of  to a string every time you called  then you'd see the string get longer each time, it would never be re-initialized
p4343
aVThis is why you should always initialize your result variable
p4344
aVIt looks like a local variable, but it is best thought of as a  parameter
p4345
as(dp4346
g7
V505088
p4347
stp4348
a((dp4349
g2
(lp4350
VI think you are looking for Visual Studio Tools for Office: VSTO
p4351
aVThis allows you to develop using VB
p4352
aVNET (or indeed C#) but with full access to the Office automation facilities
p4353
as(dp4354
g7
V505088
p4355
stp4356
a((dp4357
g2
(lp4358
VThe first thing you need to do is to use  on the C# side:
p4359
aVI'd also want to be sure that the Delphi side is post Delphi 2009 and so uses wide characters
p4360
aVIf so, then there's no issue there
p4361
aVIf you are using a non-Unicode Delphi then you'd need
p4362
aVI'd probably also return a  on the Delphi side and marshal it with
p4363
aVback on the
p4364
aVNET side
p4365
aVFinally, the fixed length array needs to be marshalled differently
p4366
aVThe standard approach for fixed length character arrays is to use a  on the
p4367
aVNET side which is marshalled as you desire
p4368
aVPutting it altogether, and fixing your Delphi syntax, gives:
p4369
aVDelphi
p4370
aVC#
p4371
aVFinally, make sure that you null-terminate your string when you return it from your DLL
p4372
as(dp4373
g7
V505088
p4374
stp4375
a((dp4376
g2
(lp4377
VI didn't read your code
p4378
aVI just elected to write some myself with a blank slate
p4379
aVHere's my version:
p4380
aVBig long pile of code
p4381
aVUses brute force approach, not that performance matters for Connect 4
p4382
aVDon't like the four identical  lines, but you can surely think of a cleaner way
p4383
aVCode has not been run
p4384
aVIt might not even work
p4385
aVJust the way my brain attempted to solve the problem
p4386
as(dp4387
g7
V505088
p4388
stp4389
a((dp4390
g2
(lp4391
VThe problem here is that your thread function has the wrong calling convention
p4392
aVYou need to declare it with the  convention:
p4393
aVHaving said that, it would be more idiomatic to just use a  descendant which handles the OOP to C function back to OOP transitioning for you
p4394
aVThat would look like this:
p4395
aVIncidentally, does anyone know why Windows
p4396
aVpas declares  as  rather than a proper typed function pointer
p4397
as(dp4398
g7
V505088
p4399
stp4400
a((dp4401
g2
(lp4402
VThis is simply not possible
p4403
aVWindows are rendered by window procedures, WndProcs
p4404
aVThese WndProcs can, and invariably are, implemented in many different DLLs
p4405
aVTypically the code which registers the DLL also implements the window procedure
p4406
aVA window procedure is called whenever a message needs to be processed
p4407
aVThe window procedure will process some windows messages, in a switch statement, say
p4408
aVThen for those messages for which the default system processing suffices, will call
p4409
aVBut  is in a different DLL (user32) to the rest of the window procedure
p4410
aVIndeed it will no doubt call lots of routines in all sorts of different DLLs
p4411
as(dp4412
g7
V505088
p4413
stp4414
a((dp4415
g2
(lp4416
VI suppose it's feasible that you might be able to do this
p4417
aVBut since you can just build a static library rather than a shared library, I don't imagine you will find a tool to convert
p4418
as(dp4419
g7
V505088
p4420
stp4421
a((dp4422
g2
(lp4423
VIn principle SetThreadExecutionState() should do what you need
p4424
aVBut I have found it not to work with the system required flag in some situations on some modern Windows
p4425
aVSorry, I can't remember exact details
p4426
aVAs a fallback you can just fake some input by calling SendInput() with a null mouse move message for example
p4427
aVMy guess is that your input faking failed because you called SendMessage or PostMessage
p4428
as(dp4429
g7
V505088
p4430
stp4431
a((dp4432
g2
(lp4433
VSince windows have thread affinity and since messages are delivered to windows, you need your code in the thread associated with the window
p4434
aVThat implies hooks
p4435
as(dp4436
g7
V505088
p4437
stp4438
a((dp4439
g2
(lp4440
VI'm interpreting this question, quite generally, as a request for an overview of lists and dictionaries
p4441
aVA list, as almost everyone knows, is a container that is indexed by contiguous integers
p4442
aVA hash map, dictionary or associative array is a container whose index can be of any type
p4443
aVVery commonly, a dictionary is indexed with strings
p4444
aVFor sake of argument let us call our lists  and our dictionaries
p4445
aVLists have true random access
p4446
aVAn item can be looked-up in constant time if you know its index
p4447
aVThis is not the case for dictionaries and they usually resort to hash-based algorithms to achieve efficient random access
p4448
aVA sorted list can perform binary search when you attempt to find a value
p4449
aVFinding a value, V, is the act of obtaining the index, I, such that
p4450
aVBinary search is very efficient
p4451
aVIf the list is not sorted then it must perform linear search which is much less efficient
p4452
aVA sorted list can use insertion sort to maintain the order of the list \u2013 when a new item is added, it is inserted at the correct location
p4453
aVYou can think of a dictionary as a list of  pairs
p4454
aVYou can iterate over all pairs, but more commonly you use index notation to look-up a value for a given key:
p4455
aVNote that this is not the same operation as finding a value in a list \u2013 it is the analogue of reading  when you know the index I
p4456
aVIn older versions of Delphi it was common to coax dictionary behaviour out of string lists
p4457
aVThe performance was terrible
p4458
aVThere was little flexibility in the contents
p4459
aVWith modern Delphi, there is , a generic class that can hold anything
p4460
aVThe implementation uses a hash and although I have not personally tested its performance I understand it to be respectable
p4461
aVThere are commonly used algorithms that optimally use all of these containers: unsorted lists, sorted lists, dictionaries
p4462
aVYou just need to use the right one for the problem at hand
p4463
as(dp4464
g7
V505088
p4465
stp4466
a((dp4467
g2
(lp4468
VI added the following code into the default Visual Studio C++ GUI project, right at the start of
p4469
aVWhen I run the GUI program from the debugger, or from Explorer, no message box shows
p4470
aVIn other words we can't attach a console
p4471
aVWhen I run from cmd I see the "Valid Handle" message
p4472
aVI conclude that there is in fact no problem with this basic approach, but that something that you are not showing us is causing the problem
p4473
as(dp4474
g7
V505088
p4475
stp4476
a((dp4477
g2
(lp4478
VWhen I first tried to replicate your problem, I could not do so
p4479
aVYou then updated your question to indicate that the problem lies with the AltGr key
p4480
aVA quick scan of the  documentation seems to imply that there is not support for such an esoteric (
p4481
aVkey
p4482
aVI therefore recommend that you switch to using  through P/Invoke
p4483
aVThis is morally equivalent to  and gives you total flexibility to fake just about any input
p4484
aVI wouldn't be at all surprised if there was available C# code to wrap this up for you
p4485
as(dp4486
g7
V505088
p4487
stp4488
a((dp4489
g2
(lp4490
VIt returns when it has finished calling your callback functions
p4491
aVSo the sequence of events looks like this:
p4492
aVAll the Windows API routines of this ilk behave this way, e
p4493
ag217
aV,  etc
p4494
aVCode has to run in the context of a thread and if such an enumeration routine were to return immediately and call the callbacks asynchronously, it would have to spawn a thread to do so
p4495
aVYou can apply the principle of least surprise here
p4496
as(dp4497
g7
V505088
p4498
stp4499
a((dp4500
g2
(lp4501
V is per-user and roams
p4502
aVThat doesn't sound like what you want
p4503
aVYou appear to want machine wide settings and so should use
p4504
aVBecause  is shared between all users, the default access control is limited
p4505
aVBy default standard users cannot write in this location
p4506
aVThe recommended practise is to create a sub-folder of  at installation time and assign it suitably permissive access control settings
p4507
as(dp4508
g7
V505088
p4509
stp4510
a((dp4511
g2
(lp4512
VIt's hard to imagine that you could have one solution that would work on Windows and OS X
p4513
aVThe windowing frameworks are completely different
p4514
aVIt would be harder to try to come up with one solution that to write two
p4515
aVOn Windows at least, I'm not convinced you'll have much luck taking a screenshot of a hidden or obscured window
p4516
aVWhen you search for this on the web, there are a gazillion hits for people asking that very question
p4517
aVNone of them appear to have succeeded
p4518
aVIf you factor in DWM and Aero glass then I think your chances of success are limited
p4519
as(dp4520
g7
V505088
p4521
stp4522
a((dp4523
g2
(lp4524
VOn x64 architecture, if you only need 32 bit wide integers, then using 32 bit wide integers will result in faster code, even when running 64 bit code
p4525
as(dp4526
g7
V505088
p4527
stp4528
a((dp4529
g2
(lp4530
VIt all depends what you do inside
p4531
aVSince the documentation refuses to state what can and cannot be done, and since the CRT doesn't make any promises, this always feels like a risky area
p4532
aVPersonally I would move all my global initialization into a single routine which is exported from the DLL and insist that all clients call this before calling any other function
p4533
as(dp4534
g7
V505088
p4535
stp4536
a((dp4537
g2
(lp4538
VDownload it from here
p4539
aVI'm not sure about that site you referred to, but I always start at: http://www
p4540
aVscipy
p4541
aVorg
p4542
as(dp4543
g7
V505088
p4544
stp4545
a((dp4546
g2
(lp4547
VYou appear to be asking if web servers can serve, and web browsers display text files
p4548
aVThe answer is yes
p4549
aVPut the text file underneath  and it's all good
p4550
aVOr did I misunderstand the question
p4551
as(dp4552
g7
V505088
p4553
stp4554
a((dp4555
g2
(lp4556
VThe formula bar, and indeed most of the controls in Office are non-standard
p4557
aVSending standard  messages will not yield success
p4558
aVI imagine the only option will be to reverse-engineer the executable code
p4559
as(dp4560
g7
V505088
p4561
stp4562
a((dp4563
g2
(lp4564
VI suspect you are trying to implement mutual exclusion within a single process
p4565
aVIf that is so then the correct synchronization object is the critical section
p4566
aVThe naming of these objects is a little confusing because both mutexes and critical sections peform mutual exclusion
p4567
aVThe interface for the critical section is much simpler to use, it being essentially an acquire function and a corresponding release function
p4568
aVIf you are synchronizing within a single process, and you need a simple lock (rather than, say, a semaphore), you should use critical sections rather than mutexes
p4569
aVIn fact, very recently here on Stack Overflow, I wrote a more detailed answer to a question which described the standard usage pattern for critical sections
p4570
aVThat post has lots of links to the pertinent sections of MSDN documentation
p4571
aVYou only need to use a mutex when you are performing cross process synchronization
p4572
aVIndeed you should only use a mutex when you are synchronizing across a process because critical sections perform so much better (i
p4573
ag192
aVfaster)
p4574
as(dp4575
g7
V505088
p4576
stp4577
a((dp4578
g2
(lp4579
VIf you actually want to learn the underlying API then you should start off without one of the frameworks
p4580
aVLearn it the way we did it all those years ago with Charles Petzold's book, Programming Windows
p4581
aVA really good foundation of knowledge of how windows and messages work will serve you well
p4582
aVIn the longer term, a good framework, e
p4583
ag217
aVWinForms, Qt, VCL etc
p4584
aVwill increase productivity
p4585
aVBut if you start with one of them, then you are in danger of not knowing the difference between sent and queued messages, not knowing the difference between an , an  and a , and so on
p4586
aVA good framework, is great, but you'll get more out of it if you understand what's underneath it
p4587
as(dp4588
g7
V505088
p4589
stp4590
a((dp4591
g2
(lp4592
VIn the old days computers only ever had a single screen attached
p4593
aVNow they often have more than one attached and a desktop that spans those screens
p4594
aVYou need to make sure that your app:
p4595
aVMaximises to the monitor that it is most closely associated
p4596
aVA badly written app might always maximise a window to the primary monitor
p4597
aVRemember which monitor it was displayed on when last run, and restore to that monitor when it starts up again
p4598
aVAvoid displaying on a monitor that is no longer available
p4599
aVFor example, consider a laptop with an attached screen
p4600
aVIf you show the window at coordinates for a screen that has been disconnected (e
p4601
ag217
aVlaptop user on the move) then they won't be able to see it
p4602
as(dp4603
g7
V505088
p4604
stp4605
a((dp4606
g2
(lp4607
VYou have to do this yourself
p4608
aVWork out the coordinates of the windows based on the size of the work area
p4609
aVDivide the width by 2 and do the math
p4610
aVThere are no in-built shortcuts
p4611
aVI don't understand your other question about switching window
p4612
as(dp4613
g7
V505088
p4614
stp4615
a((dp4616
g2
(lp4617
VYou aren't calling DefWindowProc for the messages that you don't handle
p4618
as(dp4619
g7
V505088
p4620
stp4621
a((dp4622
g2
(lp4623
VYou need to P/Invoke to call  passing the window handle of the tree and use "explorer" as the theme
p4624
aVPaste the following code into a new class in your project, compile, and use this custom control instead of the built-in  control
p4625
aVNote that this trick also works exactly the same way for the  control
p4626
as(dp4627
g7
V505088
p4628
stp4629
a((dp4630
g2
(lp4631
VI've done this for my COM add-in
p4632
aVI used activation contexts
p4633
aVIt's pretty easy for a COM add-in because the surface area of the add-in interface is so small
p4634
aVI could post code but I won't be at a machine with it on until tomorrow
p4635
aVHope this helps
p4636
aVUPDATE
p4637
aVAs promised, here is the code that I use:
p4638
aVWhen you want to use this, you simply write code like so:
p4639
aVYou need each entry point that does GUI work to be wrapped in such code
p4640
aVNote that in my COM add-in DLL I have taken special measures to avoid running code during , and so my calls to  and  are not in unit initialization/finalization sections
p4641
aVHowever, I see no reason why this code would not be safe to place there
p4642
as(dp4643
g7
V505088
p4644
stp4645
a((dp4646
g2
(lp4647
VYou don't actually need to add it the uses clause of the
p4648
aVdpr file \u2013 you just need to use it from some unit in your project
p4649
aVHaving said that, you may actually prefer to add it to your
p4650
aVdpr file, and if so then do it like this:
p4651
aVI'm guessing that you have something like this:
p4652
aVThis will fail because you are asking XE to compile D6 source
p4653
aVFor RTL/VCL units its best to omit the path to the file and let the compiler find it (it knows where to look)
p4654
as(dp4655
g7
V505088
p4656
stp4657
a((dp4658
g2
(lp4659
VIn C++ you would write:
p4660
aVThis achieves the same as your Delphi example
p4661
aVThe key is to create the C++ object on the heap and maintain a reference to it, which is of course the only way to do things in Delphi which does not support stack based objects
p4662
as(dp4663
g7
V505088
p4664
stp4665
a((dp4666
g2
(lp4667
VHere's some code I use to draw a progress bar in a status bar panel:
p4668
aVThis code runs in an  event handler, but you'd want to use something like the  event for a grid
p4669
aVis the client area of the status bar panel in my code, you'd want the entire grid cell for your code
p4670
aVI also draw a percentage text over the top by running this code after the code above
p4671
aVNot exactly the same as you want to do, but hopefully the ideas will carry across
p4672
as(dp4673
g7
V505088
p4674
stp4675
a((dp4676
g2
(lp4677
VThe system already comes with such functionality
p4678
aVOn the screen saver configuration page you simply check the box titled "On resume, display logon screen"
p4679
aVIt can be configured with group policy
p4680
aVThere's absolutely no point re-implementing this
p4681
as(dp4682
g7
V505088
p4683
stp4684
a((dp4685
g2
(lp4686
VBy default the p/invoke system wraps your delegate in a stdcall function
p4687
aVYou can change the generated wrapper's calling convention by using the  attribute:
p4688
as(dp4689
g7
V505088
p4690
stp4691
a((dp4692
g2
(lp4693
VThe problem is that the R process that runs the httpd server terminates before it has a chance to serve up the content
p4694
aVYou'd need to find a way to keep the R process alive until it had served what you need, or run the R httpd server in service/daemon mode, if that is in fact possible
p4695
aVFor example, the following will keep the R process alive a little longer so that it can finish handling the http request:
p4696
aVI can't find an abvious way to get the R httpd server running as a service/daemon, but I'm not really an expert
p4697
aVPerhaps someone else will know how to do it
p4698
as(dp4699
g7
V505088
p4700
stp4701
a((dp4702
g2
(lp4703
VDelphi 64 bit will target x86-64, a
p4704
aVk
p4705
aVa
p4706
aVAMD64, a
p4707
ag4705
ag4706
aVEM64T
p4708
aVIt will not target the Itanium architecture IA64
p4709
aVI consider the possibility of Delphi ever supporting Itanium to be vanishingly small since the Itanium platform has been deprecated
p4710
as(dp4711
g7
V505088
p4712
stp4713
a((dp4714
g2
(lp4715
VI suspect that you are seeing the icon from explorer's icon cache
p4716
as(dp4717
g7
V505088
p4718
stp4719
a((dp4720
g2
(lp4721
VI don't believe this to be possible
p4722
aVCertainly Spy++ reports that the Notification area is a single window named "User Promoted Notification Area"
p4723
aVThis window is ultimately parented with the desktop window and has no obvious association with the process that created the notification icon
p4724
aVWell, by possible I mean possible without resorting to hacks like Anders suggests which is no doubt feasible, but not what I imagine the OP is looking for
p4725
as(dp4726
g7
V505088
p4727
stp4728
a((dp4729
g2
(lp4730
VMany programs set their main window titles repeatedly during their execution
p4731
aVA good example is Firefox which changes its main window title whenever you browse to a new page
p4732
aVLikewise Notepad will change its main window title whenever you open or save a file to include the name of the latest file
p4733
aVThe only way you can realistically expect to exert control like this is to poll
p4734
as(dp4735
g7
V505088
p4736
stp4737
a((dp4738
g2
(lp4739
VReal MDI child forms do not minimize to the taskbar
p4740
aVTherefore I can only conclude that you are not using an MDI child form and that your solution is to start doing so
p4741
as(dp4742
g7
V505088
p4743
stp4744
a((dp4745
g2
(lp4746
VIs there a message that I can send to a window that will have the same effect as  or
p4747
aVNo
p4748
as(dp4749
g7
V505088
p4750
stp4751
a((dp4752
g2
(lp4753
VThere is nothing built in already that can be enabled with a "secret key" or suchlike
p4754
aVYou have to modify the DUnit source to achieve this
p4755
aVLook in  and add an item to the  popup menu which calls
p4756
as(dp4757
g7
V505088
p4758
stp4759
a((dp4760
g2
(lp4761
VIf you allocate/deallocate/access memory correctly, then you will never see this
p4762
aVYou will only encounter this when you have done something wrong
p4763
aVTypically, malloc is implemented with a sub-allocating memory manager
p4764
aVIf you ask malloc for 4 bytes of heap memory, say, then the memory manager in the C runtime will allocate a larger block and then sub-allocate 4 bytes within that block to you
p4765
aVSubsequent requests for small amounts of memory will then be sub-allocated from one of these larger blocks
p4766
aVYou can read and write into areas of these large blocks of memory that have not yet been sub-allocated by malloc
p4767
aVDoing so is of course undefined behaviour
p4768
aVPlease don't do this
p4769
aVYou can also read and write into sub-blocks that have been freed, so long as the larger block has not been returned to the system
p4770
aVAgain, please don't do this
p4771
aVMost commonly a program will fault with a non-readable memory error (a
p4772
ag4705
ag4706
aVsegmentation fault or access violation) when it tries to access an address that has been freed and the block of memory containing that address has been returned to the system
p4773
aVThis is known as a stale pointer
p4774
as(dp4775
g7
V505088
p4776
stp4777
a((dp4778
g2
(lp4779
VYou didn't actually state the exact error message, and which line it occurs on
p4780
aVIs it possible that you are erroneously linking to the 32 bit version of
p4781
aVIn fact, your P/Invokes are wrong, which may or may not be the cause of your problem
p4782
aVThe most important error is that  specifies the procedure name as an ANSI string
p4783
aVThey should read:
p4784
aVI'm not sure that these errors are actually causing you problems
p4785
aVEDIT
p4786
aVYou state in a comment that the failure occurs at the call to
p4787
aVIf this raises an exception then the only explanation that I can come up with is that the fault lies in the  of the DLL and not in the C# code
p4788
aVIf the DLL was the wrong bitness, or not found, then  would return
p4789
aVI think to solve this you need to look to the DLL and not the C# code
p4790
as(dp4791
g7
V505088
p4792
stp4793
a((dp4794
g2
(lp4795
VJust click on the link marked "Make me a Favorite":
p4796
as(dp4797
g7
V505088
p4798
stp4799
a((dp4800
g2
(lp4801
VThe simplest way to sidestep this limitation is to switch to 64 bit R
p4802
as(dp4803
g7
V505088
p4804
stp4805
a((dp4806
g2
(lp4807
VTry adding something like this:
p4808
as(dp4809
g7
V505088
p4810
stp4811
a((dp4812
g2
(lp4813
VCritical section calls only transition to kernel mode if there is contention and only then if they can't relieve the contention by spinning
p4814
aVIn that case the thread blocks and calls a wait function \u2013 that's a system call
p4815
as(dp4816
g7
V505088
p4817
stp4818
a((dp4819
g2
(lp4820
VAs I understand it, VS2003 targets
p4821
aVnet 1
p4822
aV1 and this only supports 32 bit x86 targets
p4823
aVRemember that the first 64 bit version of Windows was released after VS2003
p4824
aVSo, you can't set target platform on VS2003, it always targets x86
p4825
as(dp4826
g7
V505088
p4827
stp4828
a((dp4829
g2
(lp4830
VThis should do it:
p4831
as(dp4832
g7
V505088
p4833
stp4834
a((dp4835
g2
(lp4836
VYou should use  \u2013 that's what it's for
p4837
aVThe behaviour of floating point arithmetic
p4838
aVThat's just what it does
p4839
aVIt has limited finite precision
p4840
aVNot all numbers are exactly representable
p4841
aVIn fact, there are an infinite number of real valued numbers, and only a finite number can be representable
p4842
aVThe key to , for this application, is that it uses a base 10 representation \u2013  uses base 2
p4843
as(dp4844
g7
V505088
p4845
stp4846
a((dp4847
g2
(lp4848
VIf there was a getter or a setter behind  then it could have side effects
p4849
aVFor example:
p4850
aVIt's exceedingly bad practice to have a getter with side-effects
p4851
aVHowever, it is very common to have setters wide side-effects, although less common for those side-effects to be as drastic as in my example
p4852
as(dp4853
g7
V505088
p4854
stp4855
a((dp4856
g2
(lp4857
VCalling VCL methods in threads other than the main thread is not supported
p4858
aVYou need to find a way to keep all your VCL access in the main thread
p4859
aVOne commonly used technique is the  method
p4860
aVYou could also send windows messages since they will always be marshalled across to the thread that owns the window
p4861
aVI imagine that it's the same in C++ Builder as it is in Delphi, but in Delphi it is preferable to call  rather than
p4862
aVis a lightweight wrapper of  but the main thing it does for you is to set the  global variable
p4863
aVIf you do insist on calling  then you must set  true first
p4864
as(dp4865
g7
V505088
p4866
stp4867
a((dp4868
g2
(lp4869
VWell for a start the code with the  is invalid syntax
p4870
aVA  needs to have unit scope rather than local scope
p4871
aVLocal variable
p4872
aVEach invocation (including from different threads, and re-entrant calls) of a function results in different instances of that function's local variables
p4873
aVThread local variable
p4874
aVA thread local variable has separate instances for each thread in the process
p4875
aVThere is a one-to-one mapping between instances of the variable and threads
p4876
aVDiscussion
p4877
aVIf your procedure is not re-entrant, and it is the only procedure that refers to the variable then there will be no semantic difference between a local variable and a  \u2013 but if a local variable can be used then it should be
p4878
aVIn terms of performance the  is slower than a local variable and may not even work in the context of a DLL
p4879
aVMy recommendation is to use a local variable wherever it is possible to do so
p4880
aVUse a  (or Thread Local Storage (TLS) when in a DLL) if you need a variable of global scope that has a single instance per thread
p4881
aVHowever, such need is rare and has the severe downside that thread local variables have many of the same drawbacks as true global variables
p4882
as(dp4883
g7
V505088
p4884
stp4885
a((dp4886
g2
(lp4887
V is a wrapper around the system's common dialog,
p4888
aVThe common dialog does not offer easy customisation of its colour drop-down
p4889
as(dp4890
g7
V505088
p4891
stp4892
a((dp4893
g2
(lp4894
VIt may not actually matter which is faster
p4895
aVIf so then choose the method that will be the most convenient to develop and maintain
p4896
aVIt may be possible to save your own time even if you can't save any measurable runtime
p4897
as(dp4898
g7
V505088
p4899
stp4900
a((dp4901
g2
(lp4902
VHow about:
p4903
aVThat said I always find it limiting that this syntax does not accept open arrays
p4904
aVSo I have a bunch of functions that look like this:
p4905
aVI believe that the various generics enhancements in XE mean that this could be done with generics and without duplicating routines like  for each different scalar
p4906
as(dp4907
g7
V505088
p4908
stp4909
a((dp4910
g2
(lp4911
VI'm not aware of built-in support that would allow dynamic conversion checking that failed with an error code rather than an exception
p4912
aVYou could hand-code it yourself but doing so would produce an intolerable amount of duplication of the code in the Variants unit
p4913
aVIn this case I think that using exceptions is less bad than the alternative of duplicating implementation dependent code
p4914
aVAs a counter-example to RRUZ's most ingeneous answer, I offer the following code:
p4915
aVOutput:
p4916
as(dp4917
g7
V505088
p4918
stp4919
a((dp4920
g2
(lp4921
VNo, both 32 and 64 bit versions support more than 65536 rows, and have done since Excel 2007 was released
p4922
aVThe main difference is that you can work with very large workbooks in the 64 bit version
p4923
aVThe downside of the 64 bit version is that, at present, there is poor support from 3rd party add-ins
p4924
as(dp4925
g7
V505088
p4926
stp4927
a((dp4928
g2
(lp4929
VThe compiler transforms this into:
p4930
aVWhen written out this way I'm sure you'll agree it looks perfectly natural
p4931
aVThis is a very common idiom
p4932
as(dp4933
g7
V505088
p4934
stp4935
a((dp4936
g2
(lp4937
VFor what it's worth, the following is flicker-free for me:
p4938
as(dp4939
g7
V505088
p4940
stp4941
a((dp4942
g2
(lp4943
V87
p4944
aV285 is not exactly representable and the nearest double is slightly smaller
p4945
aVThe classic reference on floating point is What Every Computer Scientist Should Know About Floating-
p4946
aVPoint Arithmetic
p4947
aVFor currency based calculations, if indeed this is, you should use a base 10 number type rather than base 2 floating point
p4948
aVIn Delphi that means
p4949
as(dp4950
g7
V505088
p4951
stp4952
a((dp4953
g2
(lp4954
VAn application does not have a single
p4955
aVEach window within the app has its own handle, an
p4956
aVYou will need to use  or one of its friends
p4957
as(dp4958
g7
V505088
p4959
stp4960
a((dp4961
g2
(lp4962
VThere's no realistic hope of achieving this in full generality
p4963
aVFunctions don't need to be loaded from files, they can be created dynamically by code, loaded from workspaces and so on
p4964
as(dp4965
g7
V505088
p4966
stp4967
a((dp4968
g2
(lp4969
VWell, I can't be sure because you've not given all your code
p4970
aVHowever, it looks like  is a local variable, defined on the stack of the main thread
p4971
aVYou are passing the address of this variable to the threads, but you should be passing the value, or passing some heap allocated memory
p4972
aVWhat you are doing is morally equivalent to returning from a function a pointer to a local variable, e
p4973
ag217
aVThe simplest way to make your code behave is to make the following changes:
p4974
as(dp4975
g7
V505088
p4976
stp4977
a((dp4978
g2
(lp4979
VIt's the size of the array which has five elements: S, \u005c065, A, B, \u005c0
p4980
as(dp4981
g7
V505088
p4982
stp4983
a((dp4984
g2
(lp4985
VThis is a known limitation of static TLS
p4986
aVAlthough you aren't explicitly calling , the VB runtime does so on your behalf
p4987
aVNote that this limitation has been lifted from Vista
p4988
aVThe most comprehensive reference that I know of is on Ken Johnson's blog
p4989
aVYou may be able to get around the problem if you could get the DLL included in the imports table of the generated
p4990
aVexe, which would likely involve some PE hacking and I'm far from certain it's a viable strategy
p4991
aVOtherwise you'll need to change the DLL
p4992
as(dp4993
g7
V505088
p4994
stp4995
a((dp4996
g2
(lp4997
VWell, I suppose you could read the manifest resource at startup and then terminate the process if it didn't match what you expect it to be
p4998
aVYou might check against a hashed version to make it a little harder for someone to defeat the test
p4999
aVBut if someone really wants to defeat this sort of test then they'll find a way
p5000
as(dp5001
g7
V505088
p5002
stp5003
a((dp5004
g2
(lp5005
VThe solution is to register for the  and respond to it in your WndProc
p5006
aVAccording to the documentation of , the minimum supported OS is XP
p5007
aVNow, the since Windows 2000 is no longer supported, the documentation often says XP is the minumum when in fact the functionality is available on earlier versions
p5008
aVIn this case, a quick web search suggests that you may be disappointed
p5009
aVTo be notified about session logoff (rather then the screen lock), you should be able to use the  value of the  message
p5010
aVLook for the presence of the  flag
p5011
as(dp5012
g7
V505088
p5013
stp5014
a((dp5015
g2
(lp5016
VI'm on Delphi 2010, and I found a couple of issues with your code
p5017
aVFirst of all, I couldn't get the RTTI methods to work with the inline declaration of the character array
p5018
aVI changed it to:
p5019
aVIf you declare the array inline, the way you had done, the call to  raise an AV
p5020
aVThat's probably fixed in XE, or quite possibly I'm using RTTI incorrectly
p5021
aVSecondly, you need special treatment for arrays as opposed to scalar values:
p5022
aVOutput:
p5023
aVThis obviously isn't production code, but it should at least get you back on the road
p5024
aVP
p5025
aVS
p5026
aVThis is the first time I've looked at the new RTTI functionality
p5027
aVIt looks pretty nifty
p5028
as(dp5029
g7
V505088
p5030
stp5031
a((dp5032
g2
(lp5033
VHere's how I'd write a linked list:
p5034
aVWhen you need to deallocate your list you do this:
p5035
aVIt is my belief that this is the canonical way of writing linked list type code in Pascal
p5036
aVI've intentionally written this code for this simplest linked list imaginable
p5037
aVThat allows you to focus on the allocation, use of pointers etc
p5038
aVYou appear to already know how to maintain the references in your more complex list and so I believe you will have no trouble adapting this style of code to your needs
p5039
as(dp5040
g7
V505088
p5041
stp5042
a((dp5043
g2
(lp5044
VThe  parameter to OnDrawCell specifies the bounds of the particular cell, relative to the grid's client coordinate system
p5045
aVSo you need to draw to coordinates that lie within this rectangle
p5046
aVTry something like this in your event handler:
p5047
as(dp5048
g7
V505088
p5049
stp5050
a((dp5051
g2
(lp5052
VUsing  systematically will mean that you don't fall into a trap of referring to a local variable when in fact you want a member of
p5053
aVThe downside: using  will make your code more verbose
p5054
aVIt's really up to personal preference
p5055
as(dp5056
g7
V505088
p5057
stp5058
a((dp5059
g2
(lp5060
VNo, a timer runs in the thread in which it was created
p5061
aVI'm assuming you are talking about  which is implemented using the thread message loop
p5062
aVUnderlying a WinForms timer is the Win32 API  which operates by posting  messages to the message queue of the thread which
p5063
aVOne of the consequences of this is that if you have an event handler that takes longer than your timer interval then your timer will not fire at the desired interval
p5064
aVIf this was a problem then you'd need to house your timer in another thread
p5065
aVAs a thought experiment, imagine what would happen if your timer event did execute in a different thread
p5066
aVNow you have a synchronisation problem to handle
p5067
aVYour timer event is likely to want to access objects from the other thread
p5068
aVBut to do so will result in race conditions
p5069
as(dp5070
g7
V505088
p5071
stp5072
a((dp5073
g2
(lp5074
VIf you can't use something like  and you really do need to implement it yourself in C then I think I'd probably opt for a recursive solution based on  and
p5075
aVThese are the native Windows APIs for enumerating directories
p5076
aVNot remotely portable, but it doesn't seem that's a requirement
p5077
aVBasically the idea is that you write a function, , say, whose job it is to delete the contents of a directory
p5078
aVThe function uses  and  to walk the contents of the directory
p5079
aVWhen a file is encountered it is deleted
p5080
aVWhen a directory is encountered,  is called recursively
p5081
aVThe last job of , before it returns, is to delete the now empty directory
p5082
as(dp5083
g7
V505088
p5084
stp5085
a((dp5086
g2
(lp5087
VYou're into owner-draw territory here and that's not totally trivial to do well once you take into account themes
p5088
aVIf you do go that route then I wouldn't bother with Wingdings, I'd just paint the box will a
p5089
aVPersonally I'd look into a Unicode Delphi and use U+2587 (\u2587) or one of its friends
p5090
as(dp5091
g7
V505088
p5092
stp5093
a((dp5094
g2
(lp5095
VLet's start with a definition, taken from Wikipedia:
p5096
aVA pointer is a programming language
p5097
aVdata type whose value refers directly
p5098
aVto (or "points to") another value
p5099
aVstored elsewhere in the computer
p5100
aVmemory using its address
p5101
aVAll computers address memory and to do so the machine language that they execute must do so using pointers
p5102
aVHowever, high level languages do not need to include pointers explicitly
p5103
aVSome examples of those that do not are LISP, Java, C#, Perl, Python, but there are many more
p5104
aVI'm interpreting your question to be why languages support explicit pointer use, since all languages use pointers implicitly
p5105
aVDelphi descends from Pascal which is a rather primitive language when viewed from the 21st century
p5106
aVPascal pointers are the only way to use references
p5107
aVIn modern Pascal derivatives, e
p5108
ag217
aVDelphi, have many types of data that are reference based, but implicitly so
p5109
aVFor example I'm thinking of strings, object instances, interfaces and so on
p5110
aVIt is perfectly possible to write any program in Delphi without resorting to explicit pointers
p5111
aVThe modern trend away from explicit pointers is down to the observation that explicit pointer code is more prone to errors than the alternatives
p5112
aVI don't think there's any real reason to carry on using explicit pointer code in Delphi
p5113
aVPerhaps very time critical algorithms may push you that way, but I'm really struggling to think of anything that is significantly better implemented with pointers than with the alternatives
p5114
aVPersonally I avoid using explicit pointers wherever feasible
p5115
aVIt generally makes code easier to write, verify and maintain, in my experience
p5116
as(dp5117
g7
V505088
p5118
stp5119
a((dp5120
g2
(lp5121
VFaking input is rather hard to achieve, in full generality, without using
p5122
aVYes you can try , but the answer from eznme is misleading at best when it talks about
p5123
aVAs I, and others, seem to say many times a day here, input is posted to the message queue rather than sent to a window handle
p5124
aVAll that said, if you don't want to give the Notepad window input focus then it's going to be hard to get the text in there by faking
p5125
aVThe very simple alternative that works better and is easier to use, is to find the window handle of the Notepad  window and use  and , for example, to modify its contents directly
p5126
aVIn fact there is an enormous multitude of functionality available once your have this window handle at your mercy
p5127
as(dp5128
g7
V505088
p5129
stp5130
a((dp5131
g2
(lp5132
VYou want an empty C string
p5133
aVIs this what you are looking for:
p5134
aVUPDATE
p5135
aVAfter you posted some code it is clear that you have forgotten to allocate the buffer
p5136
aVSimply run around the arguments first, counting up the length required (using strlen), and then allocate
p5137
aVDon't forget space for the zero terminator
p5138
as(dp5139
g7
V505088
p5140
stp5141
a((dp5142
g2
(lp5143
VHere's my version
p5144
aVI'm not saying you'll get a great mark in your assignment if you hand this in
p5145
as(dp5146
g7
V505088
p5147
stp5148
a((dp5149
g2
(lp5150
VYou are looking for  which does exactly what you need
p5151
aVThe documentation states:
p5152
aVRecursive directory creation function
p5153
aVLike mkdir(), but makes all
p5154
aVintermediate-level directories needed
p5155
aVto contain the leaf directory
p5156
aVRaises
p5157
aVan error exception if the leaf
p5158
aVdirectory already exists or cannot be
p5159
aVcreated
p5160
aVBecause it fails if the leaf directory already exists you'll want to test for existence before calling
p5161
as(dp5162
g7
V505088
p5163
stp5164
a((dp5165
g2
(lp5166
VQuestion 1: No that is not correct
p5167
aVThere's nothing special about a file installed by MSI
p5168
aVQuestion 2: Don't attempt to write application settings files under the Program Files directory
p5169
aVInstead put them in  \u2013 see
p5170
aVYou really should try to get out of the habit of expecting to write to the Program Files directory at any time other than install time
p5171
aVThat's why the system provides the various other special folder locations
p5172
as(dp5173
g7
V505088
p5174
stp5175
a((dp5176
g2
(lp5177
VOndrej has answered the first part of your question
p5178
aVYou also asked:
p5179
aVI have another question if I run my
p5180
aVwin form with windows service and if I
p5181
aVdon't close my form ,it will be close
p5182
aVif the user logoff,is it true
p5183
aVWell, first of all, a service runs without any UI, without any forms
p5184
aVIf your service needs to communicate to your user, then that's what you need your app for
p5185
aVBut to answer the question I think you are asking, when a user logs off, any apps that are running will close, but services continue to run
p5186
as(dp5187
g7
V505088
p5188
stp5189
a((dp5190
g2
(lp5191
VI originally thought that ImageMagick will extract icons from
p5192
aVexe files
p5193
aVHowever, it seems my memory is failing me
p5194
aVInstead, since you are prepared to accept the use of  I think the quickest and easiest solution will be to use a tool like ResHacker
p5195
aVThe can be driven in command-line mode
p5196
aVThen if you need to convert from
p5197
aVico to
p5198
aVpng, as per your last question, you can reach for ImageMagick
p5199
as(dp5200
g7
V505088
p5201
stp5202
a((dp5203
g2
(lp5204
VI'm struggling to understand what you are doing here
p5205
aVI think your basic problem is that  is an  and so is a value type
p5206
aVYou take a copy of it so that there are two copies rather than one
p5207
aVThe author has elected to use  rather than a class but doing so requires you to be very alert to the value semantics rather than reference semantics of  descendants
p5208
aVThe quick hack to get this to work is to change  to  and in  change  to
p5209
aVWith that change the ellipse is drawn
p5210
aVNow, I think you need to re-consider your design
p5211
aVIf you want to wrap up an Agg2D object in a rendering class, then that would be fine, but you must not take copies of the Agg2D object
p5212
aVHere's how I would write your code to deal with the problem:
p5213
aVThe idea is to put everything to do with the Agg2D object inside
p5214
aVIf you do this then I think you'll be golden
p5215
as(dp5216
g7
V505088
p5217
stp5218
a((dp5219
g2
(lp5220
s(dp5221
g7
V505088
p5222
stp5223
a((dp5224
g2
(lp5225
VYes you can do this
p5226
aVYou need to get hold of the window handle of the main form in the other process (call )
p5227
aVThen call  to make that window a child of your window
p5228
aVYou'll likely want to modify window style, position etc
p5229
aVAlso call  before trying to find a window handle in the new process
p5230
aVYou've got to give the new process a chance to get started
p5231
aVWhat you now have is a pretty queer beast
p5232
aVInside one container you have two processes
p5233
aVEach process has its own UI thread
p5234
aVYou can show and interact with two modal dialogs at once
p5235
aVThere's really no end to the fun you can have with this
p5236
aVEDIT
p5237
aVJust for a bit of fun I had a go at writing a simple Delphi app to do this
p5238
aVIt's rather brittle and only seems to work for very basic apps
p5239
aVI think you could spend a long time trying to make this work well and still end up with an unsatisfactory result
p5240
aVIf I were you I'd look for other solutions, especially as you have the source for this C# app
p5241
aVSurely you could expose its functionality as an ActiveX
p5242
aVAnyway, for your amusement I offer the following exceedingly un-polished piece of code:
p5243
as(dp5244
g7
V505088
p5245
stp5246
a((dp5247
g2
(lp5248
VYou don't have write access to HKLM
p5249
aVIf you want to write here then you need to either:
p5250
aVrun the process as an elevated user, or
p5251
aVonly attempt to write to HKLM during install
p5252
as(dp5253
g7
V505088
p5254
stp5255
a((dp5256
g2
(lp5257
VTry changing your code as follows:
p5258
aVI think your  function is truncating
p5259
aVdocx to
p5260
aVdoc
p5261
aVIt's all guesswork though
p5262
aVThe  function does not modify the contents of the file
p5263
as(dp5264
g7
V505088
p5265
stp5266
a((dp5267
g2
(lp5268
VYou don't need to use a lock file
p5269
aVYou can use the built in file system sharing mechanism
p5270
aVWhen you open the file by calling  you determine the sharing access for subsequent attempts to open the file with the  parameter
p5271
aVFor example, set this to 0 and no other process will be able to open the file
p5272
as(dp5273
g7
V505088
p5274
stp5275
a((dp5276
g2
(lp5277
VIf this was plain win32 you would try to open the file, with , and a share mode that denied write access to others
p5278
aVThat would have to fail if the other program was still writing the file since you can't deny write access when the file is already opened with write access
p5279
aVIf it succeeds, you know that the other process has finished
p5280
aVIn
p5281
aVnet you could, for example, create a  using one of the constructors that receives a  parameter
p5282
aVThis will ultimately map down to the underlying  API
p5283
as(dp5284
g7
V505088
p5285
stp5286
a((dp5287
g2
(lp5288
VYou can call
p5289
aVIf the file does not exist then you will need to use the  flag:
p5290
aVIf the uFlags parameter includes the
p5291
aVSHGFI_USEFILEATTRIBUTES flag, this
p5292
aVparameter does not have to be a valid
p5293
aVfile name
p5294
aVThe function will proceed
p5295
aVas if the file exists with the
p5296
aVspecified name and with the file
p5297
aVattributes passed in the
p5298
aVdwFileAttributes parameter
p5299
aVThis
p5300
aVallows you to obtain information about
p5301
aVa file type by passing just the
p5302
aVextension for pszPath and passing
p5303
aVFILE_ATTRIBUTE_NORMAL in
p5304
aVdwFileAttributes
p5305
aVAs usual, pinvoke
p5306
aVnet has the necessary information to get to this from managed code
p5307
as(dp5308
g7
V505088
p5309
stp5310
a((dp5311
g2
(lp5312
VIt would certainly be possible write your own installation program with Delphi, but it would be very unusual to do so
p5313
aVStandard practice is to use a 3rd party tool to generate an installation program
p5314
aVMost modern Windows programs come in the form of an
p5315
aVmsi which is a Windows Installer database
p5316
aVThere are many tools for creating installation programs:
p5317
aVInstallShield
p5318
aVInstallAware
p5319
aVNSIS
p5320
aVWiX
p5321
aVWise
p5322
aVInnoSetup
p5323
aVetc
p5324
aVYou also talk about writing and reading program configuration files
p5325
aVYou need to be careful about where these are placed
p5326
aVYou should not put them under the Program Files directory because modern versions of Windows do not permit users to write to those folders
p5327
aVThis is why you are used to seeing UAC dialogs when you install software \u2013 they need to gain elevated rights in order to install
p5328
aVInstead you should save program configuration files in one of the assortment of possible locations designed for just this situation, for example, the  folder
p5329
as(dp5330
g7
V505088
p5331
stp5332
a((dp5333
g2
(lp5334
VMost likely this is a hardware fault
p5335
aVRun diagnostics on your disk
p5336
aVHope that your backup works
p5337
as(dp5338
g7
V505088
p5339
stp5340
a((dp5341
g2
(lp5342
V is the size of a pointer, which just happens to be the twice the size of an  on your platform
p5343
aVThere's no way to get the length of an array in C
p5344
aVYou just have to remember it yourself
p5345
as(dp5346
g7
V505088
p5347
stp5348
a((dp5349
g2
(lp5350
VThat's not possible with  which wraps the native system dialog
p5351
aVYou'll need to produce your own dialog or even better see if there is a way to configure the system to give your app (and all others) bigger buttons
p5352
aVThe downside of rolling your own is that you lose all the functionality that the native one provides
p5353
as(dp5354
g7
V505088
p5355
stp5356
a((dp5357
g2
(lp5358
VYou don't have write access to HKLM
p5359
aVYou would need to run with elevated privileges in order for this to succeed
p5360
aVIt's always been the case that rights to HKLM have been restricted to members of the administrators group
p5361
aVThe thing that changed was in Vista when UAC was introduced and users habitually started running without admin rights
p5362
aVIt may not be what you want to hear, but you need to get out of the habit of writing to this area of the registry, and find a different way to achieve your goals
p5363
aVThe only time it is reasonable for a desktop app to expect write access to HKLM (or indeed Program Files directory) is at install time
p5364
aVOnce you fix your code as described by arx, you'll then have to tackle this issue
p5365
as(dp5366
g7
V505088
p5367
stp5368
a((dp5369
g2
(lp5370
VWikipedia, it say:
p5371
aVIn C and C++, untagged unions are
p5372
aVexpressed nearly exactly like
p5373
aVstructures (structs), except that each
p5374
aVdata member begins at the same
p5375
aVlocation in memory
p5376
aVI'm sure the documentation for whatever tools you have will tell you all about unions, you just haven't found that section yet
p5377
as(dp5378
g7
V505088
p5379
stp5380
a((dp5381
g2
(lp5382
VThere is official documentation of which windows appear in the taskbar
p5383
aVAnyway, something like this should get across the general idea
p5384
aVYou can sort the details out yourself now that you know where to look
p5385
as(dp5386
g7
V505088
p5387
stp5388
a((dp5389
g2
(lp5390
VYour only option is to re-write in VBA since Office for Mac doesn't support
p5391
aVNET add-ins
p5392
aVThere is something called Automator but it's much less capable than VBA
p5393
as(dp5394
g7
V505088
p5395
stp5396
a((dp5397
g2
(lp5398
VThe problem here is how you are marshalling the  fields
p5399
aVThese are single bytes in C++ and so need to be marshalled so:
p5400
aVMatch this up on the C++ side:
p5401
aVI removed the packing settings so that the structures will have alignment natural to the platform
p5402
aVYou should also make sure that your calling conventions agree
p5403
aVAs it stands it looks like the C++ code uses , and the C# code uses
p5404
aVFor example
p5405
aVwould align the two sides of the interface
p5406
as(dp5407
g7
V505088
p5408
stp5409
a((dp5410
g2
(lp5411
VI'm 99% sure that you can solve this by granting the Log on as service privilege to the administrator user
p5412
as(dp5413
g7
V505088
p5414
stp5415
a((dp5416
g2
(lp5417
Vdefines an empty
p5418
aVdefines an empty
p5419
aVThese are fundamentally different types
p5420
aVA  is an associative array, a  is a standard array with integral indices
p5421
aVI recommend you consult your reference material to become more familiar with these two very important Python container types
p5422
as(dp5423
g7
V505088
p5424
stp5425
a((dp5426
g2
(lp5427
VThe system draws both of these controls
p5428
aVYou really ought to let the system decide how to draw them
p5429
aVIf you don't want to do that then you'll have to override the  method and draw the controls yourself
p5430
aVBe warned that this is non-trivial once you factor in all the possible themes that you app may encounter (Windows Classic, Windows Basic, Aero)
p5431
aVOr you could look for a 3rd party component that has already done this
p5432
as(dp5433
g7
V505088
p5434
stp5435
a((dp5436
g2
(lp5437
VTake a look at mpmath
p5438
as(dp5439
g7
V505088
p5440
stp5441
a((dp5442
g2
(lp5443
VWhilst this is perfectly legal, it may be prudent to find another way
p5444
aVYou pinpoint the issue when you said:
p5445
aVI presume I would need to create it
p5446
aVbefore using the record
p5447
aVNot only that, but you need to find a good time to destroy it too
p5448
aVIf you forget to do so there will be no errors but your program will leak memory
p5449
aVIf the record is the owner of the string list then you may be better off containing it inside a class
p5450
aVThat way the construction and destruction of the string list will follow the constructor/destructor pattern that all Delphi developers are familiar with
p5451
aVIf the record does not own the string list, but just takes a reference to it during the lifetime of the string list, then a record is fine
p5452
aVBut if you do it this way make sure that the record's lifetime is contained within the string list's lifetime so that you don't carry around a stale reference
p5453
as(dp5454
g7
V505088
p5455
stp5456
a((dp5457
g2
(lp5458
VA function like this will do what you need:
p5459
aVYou can call it with any type of string and the RTL will convert from the encoding of the string that is passed to UTF-8
p5460
aVSo don't be tricked into thinking you must convert to UTF-8 before calling, just pass in any string and let the RTL do the work
p5461
aVAfter that it's a fairly standard array copy
p5462
aVNote the assertion that explicitly calls out the assumption on string element size for a UTF-8 encoded string
p5463
aVIf you want to get the zero-terminator you would write it so:
p5464
as(dp5465
g7
V505088
p5466
stp5467
a((dp5468
g2
(lp5469
VTake a look at Audio Components Suite
p5470
as(dp5471
g7
V505088
p5472
stp5473
a((dp5474
g2
(lp5475
VWell, you can just read the data right out of
p5476
aVIt's that simple
p5477
aVYou might need to work at some of the more esoteric data formats, but once the data is in the clipboard, you are free to read it
p5478
aVFor Word you might find that the HTML format that it places in the clipboard quite amenable to your needs
p5479
aVThere's no security or privacy issues here because the user has consented to run your program
p5480
aVIt would be wrong to allow you to read the clipboard of another logged in user, but you can't do that
p5481
aVYou've updated the question and now are asking something a little more specific
p5482
aVSo I copied some widgets to the clipboard and then used the Clipboard Viewer to see what formats were in there
p5483
aVThe one that jumped out was
p5484
aVA quick websearch for this lead me to this website:
p5485
aVhttp://www
p5486
aVwindowsdevelop
p5487
aVcom/windows-forms-designer/for-designer-copycutpaste-what-type-data-format-does-ms-set-the-clipboard-dataobject-to-8507
p5488
aVshtml
p5489
aVThere is some code there, apparently from Reflector, which shows how the designer handles the Copy command:
p5490
aVThis ought to get you started
p5491
as(dp5492
g7
V505088
p5493
stp5494
a((dp5495
g2
(lp5496
VAnonymous has asked for code that demonstrates disabled check boxes showing their checked state
p5497
as(dp5498
g7
V505088
p5499
stp5500
a((dp5501
g2
(lp5502
VI believe that this is simply not possible
p5503
aVEven if you could get the dialog to show the files, what would their names be when they were returned to your 32 bit process
p5504
aVSysnative is a bit of a hack and in any case not available on XP 64
p5505
aVThis is just a consequence of overloading the system32 name
p5506
aVAnother thought experiment
p5507
aVIf it were to be possible, you'd need the thread that does the enumeration to disable redirection
p5508
aVSince that thread is out of your control then there would have to be a published option to disable it
p5509
aVThere isn't
p5510
aVIt would be no good allowing you to disable redirection from the outside because that would result in DLL load failures when the 32 bit process tried to load shell extensions - you can't disable redirection if you are going to load DLLs because you'll get the wrong ones
p5511
aVI imagine that you are expected to write a 64 bit program if you want to get around this limitation
p5512
as(dp5513
g7
V505088
p5514
stp5515
a((dp5516
g2
(lp5517
VYou can't mix 32 and 64 bit images in the same process
p5518
aVEnd
p5519
aVOf
p5520
aVStory
p5521
as(dp5522
g7
V505088
p5523
stp5524
a((dp5525
g2
(lp5526
VThis is quite a general question, so I'll give you a general answer
p5527
aVYou are going to need to do the following:
p5528
aVEnumerate all the processes by calling
p5529
aVFor each process ID,  to obtain a process handle
p5530
aVWith each process handle call  to obtain the process's main executable file name
p5531
aVFinally call  and perhaps some of its friends to retrieve the information
p5532
aVThis will give you binary version information rather than marketing versions
p5533
aVFor example Windows XP is version 5
p5534
aV1, Windows Vista is 6
p5535
aV0, Windows 7 is version 6
p5536
aV1
p5537
aVIf you need marketing versions then that's probably not achievable in a general manner
p5538
as(dp5539
g7
V505088
p5540
stp5541
a((dp5542
g2
(lp5543
VI think you have a fundamental misunderstanding of how threads are meant to be used
p5544
aVFunctions like  and  and functions to terminate threads are not how you are meant to control threads
p5545
aVIn fact, the Windows API functions that  and  map onto are documented as being intended for debuggers
p5546
aVIt would be nice if the MFC documentation also said this, but it doesn't
p5547
aVIf you use  to pause a thread then you've no idea what it is doing when you pause it
p5548
aVIf it just happens to hold a lock then you can deadlock your program
p5549
aVThe normal mechanism for controlling threads is to use event objects to signal to the thread that you want it to pause or resume
p5550
aVThe reason event objects are used rather than simple boolean flags, say, is that events can be waited on
p5551
aVThis means that you can put a thread into a non-busy state, not consume CPU and have it start-up when signalled by the controlling thread
p5552
aVRegarding termination, it is absolutely a last resort to call
p5553
aVDoing so leaves your synchronisation objects (e
p5554
ag217
aVcritical sections, mutexes etc
p5555
aVin an undefined state and is highly likely to lead to horrible defects in your software
p5556
aVAgain for termination you should signal to a thread that you wish it to quit, and then wait until it has done so
p5557
as(dp5558
g7
V505088
p5559
stp5560
a((dp5561
g2
(lp5562
VThe call to  does work and in your case it did work
p5563
aVis contracted to delete the file you specify, if it can be deleted
p5564
aVIf the file could be deleted, then it will be
p5565
aVIf the file could not be deleted then it will not be
p5566
aVIf  returns false, what the documentation refers to as failure, then the file was not deleted, for a good reason
p5567
aVYou can call  to find out why the file was not deleted
p5568
as(dp5569
g7
V505088
p5570
stp5571
a((dp5572
g2
(lp5573
VThat can't work because the Python code can't see into the C code to stop it running
p5574
aVThat approach could only work with pure Python code
p5575
aVEven if it would work, it would be the wrong way to stop a threads
p5576
aVYou should think of threading as a co-operative endeavour
p5577
aVIf you want a thread to stop, then you need to ask it to stop, and then wait until it has done so
p5578
aVUsing co-operation rather than force avoids all sorts of horrible problems
p5579
aVWhat you will need to do is to modify your C code and allow it to be signalled to cancel
p5580
aVThe C code will need to regularly check for this signal
p5581
aVYou could implement that with a ctypes callback or indeed many other ways
p5582
aVBut fundamentally you need to provide an explicit cancelling mechanism in your C code
p5583
as(dp5584
g7
V505088
p5585
stp5586
a((dp5587
g2
(lp5588
VI think you know how to define your formula for matching, so the trick is the format
p5589
aVJust select a custom format and enter a space
p5590
aVThe dialog looks like this (I'm on Windows but I'm sure it will be similar on a Mac)
p5591
as(dp5592
g7
V505088
p5593
stp5594
a((dp5595
g2
(lp5596
VYou need to define a Windows target version of XP or greater to have access to this
p5597
aVYou are probably targeting Windows 2000
p5598
aVIn targetver
p5599
aVh (or wherever you define ) you need this:
p5600
as(dp5601
g7
V505088
p5602
stp5603
a((dp5604
g2
(lp5605
VI expect this is just a calling convention problem
p5606
aVYour C++ code assumes cdecl, but the C# code assumes stdcall
p5607
aVSimply specify cdecl in the P/Invoke and you should be golden
p5608
as(dp5609
g7
V505088
p5610
stp5611
a((dp5612
g2
(lp5613
VIf you want something so simple, then I'd just forget all about MFC and start with a basic console app from the New Project Wizard
p5614
aVMFC seems rather heavy duty for something so simple
p5615
as(dp5616
g7
V505088
p5617
stp5618
a((dp5619
g2
(lp5620
VIf you don't want to put everything into a local package, then I'd go for option 2
p5621
as(dp5622
g7
V505088
p5623
stp5624
a((dp5625
g2
(lp5626
VI wrote the following trivial win32gui app:
p5627
aVI then sent the window a  message from another app (written in Delphi):
p5628
aVThe output was:
p5629
aVSo it seems that it works trivially, pretty much as you coded it
p5630
aVThe only thing that I can think of is that the text in Spotify's  is not null-terminated
p5631
aVYou should be able to check that quite easily by reading out the data
p5632
aVMake use of the  member
p5633
as(dp5634
g7
V505088
p5635
stp5636
a((dp5637
g2
(lp5638
VYou have to return a value
p5639
aVI would expect your compiler to be warning you that you are not
p5640
aVIf it is not warning you then you should change the options to make it do so
p5641
aVThe documentation states:
p5642
aVTo continue enumeration, the callback
p5643
aVfunction must return TRUE; to stop
p5644
aVenumeration, it must return FALSE
p5645
aVThis capability to terminate enumeration exists to allow you to short-circuit an enumeration
p5646
aVOnce you have found the item you want there is no need to continue receiving callbacks
p5647
aVThere are numerous Windows API functions that follow this idiom
p5648
as(dp5649
g7
V505088
p5650
stp5651
a((dp5652
g2
(lp5653
VYou should call  when you want to know the path corresponding to a CSIDL
p5654
aVI don't know what  is, I can't find it in my Delphi
p5655
aVDid you mean
p5656
aVI also can't find , but that doesn't change my answer
p5657
as(dp5658
g7
V505088
p5659
stp5660
a((dp5661
g2
(lp5662
VYou need :
p5663
aVAs others have pointed out, your actual problem would be better solved with ranges
p5664
aVYou could try something like this:
p5665
as(dp5666
g7
V505088
p5667
stp5668
a((dp5669
g2
(lp5670
VGet the row number of the active cell:
p5671
aVGet the value in column 1 of that row:
p5672
aVRead the name of the active worksheet (there is an error here, should read  rather than ):
p5673
aVTest if  is greater than 0, and the cell A4 contains "#" and the active worksheet is equal to a variable or constant called
p5674
aVAnd if so, a subroutine called  is called with parameters  and
p5675
aVNow, that subroutine first of all checks to see if the  column of the active row is empty
p5676
aVActually it's a rather lame way to test emptyness, but it will probably do
p5677
aVAnd if it is empty then we show a file dialog to obtain a file name:
p5678
aVIf a filename has been selected (i
p5679
ag192
aVthe dialog is not cancelled) then we save that file name in the  column of the active row for future reference:
p5680
aVAnd that's it
p5681
as(dp5682
g7
V505088
p5683
stp5684
a((dp5685
g2
(lp5686
V is just a wrapper around the Windows  API which I believe will run forever
p5687
aVI suspect that the timer still runs, but the event handler that it fires is failing to operate as desired
p5688
as(dp5689
g7
V505088
p5690
stp5691
a((dp5692
g2
(lp5693
V is defined:
p5694
aVYou then write  which is effectively a null operation since  already was a
p5695
aVWhat you need is something like this:
p5696
aVThis explains why your attempts to call  does not compile, but I simply have no idea what you are trying to achieve
p5697
aVEven after your clarification I'm struggling to understand the problem
p5698
as(dp5699
g7
V505088
p5700
stp5701
a((dp5702
g2
(lp5703
VAt least on my Windows system (Windows 7), there seems to be no trivial way to achieve this
p5704
aVI found that a naive call to ShellExecute appeared to do nothing
p5705
aVThen I tried this:
p5706
aVWith the addition of the call to  the dialog appeared, but when the python process terminated, the print dialog closed too
p5707
aVSince the print dialog runs in-process I don't see an easy wait to wait on it
p5708
aVIf it were to run as a separate process then it would be trivial to wait on that process
p5709
aVI suppose a hacky solution would be to run this through  so that no console appeared, and put in a long sleep
p5710
aVYou might end up with some stray Python processes that were aimlessly sleeping, but that might not matter
p5711
as(dp5712
g7
V505088
p5713
stp5714
a((dp5715
g2
(lp5716
VYou've tagged the question ctypes and so it sounds like you already know the answer
p5717
aVThe ctypes tutorial is excellent
p5718
aVOnce you've read and understood that you'll be able to do it easily
p5719
aVFor example:
p5720
aVAnd an example from my own code:
p5721
as(dp5722
g7
V505088
p5723
stp5724
a((dp5725
g2
(lp5726
VWith Delphi's limitation to 32 bit address space, such problems are becoming more common
p5727
aVThe first and simplest thing you can do is to run on a 64 bit OS and move from 2GB available address space (as you get on a 32 bit OS) to 4GB address
p5728
aVThis doesn't happen automatically
p5729
aVYou need to mark your application as being LARGEADDRESSAWARE
p5730
aVDo this by adding the following to your
p5731
aVdpr file:
p5732
aVThe other common reason for out of memory errors is not that there is a shorage of memory, but that you are asking for a large block of contiguous memory and there is no single contiguous block of address space available
p5733
aVDealing with this problem is more difficult
p5734
aVYou first need to identify the parts of your code that are currently demanding large contiguous blocks of memory
p5735
aVNext you have to modify the objects that are doing so and arrange that they instead ask for small chunks of memory which you can then "stitch together" to give the appearance of a larger block
p5736
aVThis typically happens with code that uses dynamic arrays, in my experience
p5737
as(dp5738
g7
V505088
p5739
stp5740
a((dp5741
g2
(lp5742
VGood practice in object-oriented programming states that this should not be done
p5743
aVWhat you are describing is a direct violation of the Liskov substitution principle which states that:
p5744
aVobjects in a program should be
p5745
aVreplaceable with instances of their
p5746
aVsubtypes without altering the
p5747
aVcorrectness of that program
p5748
aVI think you should explain what problem you are attempting to solve and then a better approach might become apparent
p5749
as(dp5750
g7
V505088
p5751
stp5752
a((dp5753
g2
(lp5754
VThere are a multitude of ways to tackle this, but they are all rather more complex than what you currently have
p5755
aVProbably the easiest way to pass a string allocated in C++ to C# is as a
p5756
aVThat allows you to allocate the string down in your C++ and let the C# code deallocate it
p5757
aVThis is the biggest challenge you face and marshalling as  solves it trivially
p5758
aVSince you want a list of strings you could change to marshalling it as an array of
p5759
aVThat's one way, it's probably the route I would take, but there are many other approaches
p5760
as(dp5761
g7
V505088
p5762
stp5763
a((dp5764
g2
(lp5765
VYou have to set the Style to
p5766
aVThe other property to set is  which controls the animation speed
p5767
aVI don't believe it is possible with the plain Delphi progress bar to have the progress indicator move from left to right, and then return from right to left, like KITT
p5768
aVOnce it gets to the right it then starts again from the left
p5769
as(dp5770
g7
V505088
p5771
stp5772
a((dp5773
g2
(lp5774
VThe official documentation of which windows appear in the taskbar tells you the answer to this question:
p5775
aVThe Shell creates a button on the taskbar whenever an application creates a window that isn't owned
p5776
aVTo ensure that the window button is placed on the taskbar, create an unowned window with the WS_EX_APPWINDOW extended style
p5777
aVTo prevent the window button from being placed on the taskbar, create the unowned window with the WS_EX_TOOLWINDOW extended style
p5778
aVAs an alternative, you can create a hidden window and make this hidden window the owner of your visible window
p5779
aVHowever, the rules stated there are a little opaque
p5780
aVRaymond Chen summarises the rules as follows:
p5781
aVThere are some basic rules on which
p5782
aVwindows go into the taskbar
p5783
aVIn short:
p5784
aVIf the WS_EX_APPWINDOW extended style is set, then it will show (when
p5785
aVvisible)
p5786
aVIf the window is a top-level unowned window, then it will show
p5787
aV(when visible)
p5788
aVOtherwise it doesn't show
p5789
aVSetting WndParent in CreateParams in the linked question means that the window is no longer a top-level windowbecomes an owned top-level window
p5790
aVThanks for Sertac and Rob for correcting me
p5791
as(dp5792
g7
V505088
p5793
stp5794
a((dp5795
g2
(lp5796
VI can't think of anything better than :
p5797
aVSent to a window whose size, position,
p5798
aVor place in the Z order has changed as
p5799
aVa result of a call to the SetWindowPos
p5800
aVfunction or another window-management
p5801
aVfunction
p5802
aVThat looks ideal
p5803
aVWhat do you have against using it
p5804
as(dp5805
g7
V505088
p5806
stp5807
a((dp5808
g2
(lp5809
VYour DLL is almost certainly calling something that tries to obtain the loader lock from inside its
p5810
aVWhat you describe is called deadlock and these symptoms fit this particular issue perfectly
p5811
as(dp5812
g7
V505088
p5813
stp5814
a((dp5815
g2
(lp5816
VIf you've got a common ancestor for all your dialogs, which you seem to imply you have, then you can simply put the code in that common ancestor in a suitable location of your choice
p5817
aVFor example  is virtual
p5818
as(dp5819
g7
V505088
p5820
stp5821
a((dp5822
g2
(lp5823
VYou can't
p5824
aVCalling SendInput ultimately results in posted messages which are delivered asynchronously
p5825
aVWhy fake input to Notepad when you can send the text direct to the edit window
p5826
aVNot only would it be way simpler it would be robust and synchronous
p5827
as(dp5828
g7
V505088
p5829
stp5830
a((dp5831
g2
(lp5832
VWithout access to the source of Windows we can only guess
p5833
aVHere's my guess at what could go wrong:
p5834
aVThe handle is not a valid handle to an event object
p5835
aVThe handle does not have the necessary access rights
p5836
aVThe documentation states that the handle must have the EVENT_MODIFY_STATE access right
p5837
aVThe OS runs out of memory or has some other critical failure
p5838
aVReading the WINE source reveals no other explicit failure modes
p5839
as(dp5840
g7
V505088
p5841
stp5842
a((dp5843
g2
(lp5844
VIf you want a black box then I would look no further than Aspose
p5845
aVWords
p5846
as(dp5847
g7
V505088
p5848
stp5849
a((dp5850
g2
(lp5851
VYour problem is that PyOpenSSL is not installed
p5852
aVYou don't say, but I infer from your question that you have installed a 32 bit version of PyOpenSSL but are using a 64 bit version of Python
p5853
aVThat won't work
p5854
aVIf you really can't get a 64 bit version of PyOpenSSL, then the simplest, and possibly the only, solution will be to install 32 bit versions of Python, Scrapy and all its dependencies
p5855
aVIf you are feeling brave then you could attempt to compile from source for 64 bit but I don't know enough about PyOpenSSL to say whether or not that's practical
p5856
as(dp5857
g7
V505088
p5858
stp5859
a((dp5860
g2
(lp5861
VYou can get the HTML, and indeed set it, with
p5862
aVSheng is correct,  returns the streamed document before scripts run
p5863
aVHis code doesn't compile, but it's essentially correct
p5864
aVI found that you need:
p5865
as(dp5866
g7
V505088
p5867
stp5868
a((dp5869
g2
(lp5870
VYou probably got the calling conventions mixed up
p5871
aVI'm guessing you have a C function declared something like this:
p5872
aVThis will use the C calling convention by default
p5873
aVThe simplest approach would be to change the calling convention in your ctypes code:
p5874
aVIf you wanted to change the calling convention in the C code to  (to match ) then you would do this:
p5875
aVWhatever you do, only do one of these changes
p5876
aVIf you do both you'll have the reverse failure
p5877
aVIf it were me, I'd just change the Python code to use C calling convention (use )
p5878
aVThat change has the least impact
p5879
as(dp5880
g7
V505088
p5881
stp5882
a((dp5883
g2
(lp5884
VIf the source code that calls  is within your control then you can provide an alternative  which delegates to the real one most of the time, but does something different for your special case
p5885
aVIf the source code that calls  is outside your control then you will need to use hooks
p5886
aVIn this situation you need to modify how  behaves which is entirely outside your codebase
p5887
as(dp5888
g7
V505088
p5889
stp5890
a((dp5891
g2
(lp5892
VAssuming that stripping the beginning of the file really does solve your problem, all you need are fopen, fread, fwrite and fclose
p5893
aVYou open the file for reading in binary mode
p5894
aVRead up until you find the magic %PDF string
p5895
aVOpen the output file for binary writing
p5896
aVWrite out to that file, starting with your new %PDF string
p5897
aVWhen you are done writing, close both files
p5898
as(dp5899
g7
V505088
p5900
stp5901
a((dp5902
g2
(lp5903
VIf this component shows any forms then it is using VCL components
p5904
aVAll use of the VCL in an application must be done in the same thread, it's a requirement of the VCL
p5905
aVYou need to find a design that runs all the VCL code in the main application thread
p5906
aVHaving said all that, this doesn't explain why you see crashes only away from the test environment
p5907
aVThe advice about threading is valid, but you most probably have a different problem
p5908
as(dp5909
g7
V505088
p5910
stp5911
a((dp5912
g2
(lp5913
VYou are looking for
p5914
as(dp5915
g7
V505088
p5916
stp5917
a((dp5918
g2
(lp5919
VWriting a unit testing framework with the complexity, capability and dynamic nature of a true XUnit clone would be utterly horrendous in Fortran which is really designed for numerical analysis
p5920
as(dp5921
g7
V505088
p5922
stp5923
a((dp5924
g2
(lp5925
VFortran's focus has always been high performance numerical computing
p5926
aVRemember that Fortran first appeared in 1957 and so carries a lot of historical baggage
p5927
aVThere has been lots of development to the Fortran language over the years, but those that have been developing it have concentrated on functionality that enables high performance numerical computing
p5928
aVFundamentally Fortran is not intended to be a general purpose programming language with the breadth of applications of, say, C++
p5929
as(dp5930
g7
V505088
p5931
stp5932
a((dp5933
g2
(lp5934
VIf the file is locked when you try to delete it then the deletion will fail
p5935
aVIf you need the file to be deleted, then you need whatever is locking it to release the lock
p5936
aVThat's really all there is to it
p5937
aVThere are no shortcuts here
p5938
as(dp5939
g7
V505088
p5940
stp5941
a((dp5942
g2
(lp5943
VFor calculation of integer factorial, the recursive implementation is slower and more complex
p5944
aVInvariably, iteration is used in production code
p5945
aVThe  function you refer to is in the base package
p5946
aVIt operates on real values rather than integers, hence that implementation
p5947
aVIts documentation states:
p5948
aVfactorial(x) (x
p5949
aVfor non-negative
p5950
aVinteger x) is defined to be gamma(x+1)
p5951
aVA more interesting example is code to implement the Fibonnaci series which is extraordinarily wasteful when implemented with a naive recursion
p5952
aVThe recursive approach can be made efficient through memoization but simple iteration is always to be preferred if performance is at stake
p5953
aVAnother common algorithm that is expressed naturally in a recursive way is Quicksort
p5954
aVThis can, like all algorithms be implemented without recursion, but it quite complex to do so
p5955
aVThere is little benefit in using a non-recursive Quicksort and so it's common to use the naive recursive implementation
p5956
aVRecursion is a good implementation choice:
p5957
aVif performance is not compromised, and
p5958
aVif it is more natural (hence easier to verify and maintain) to implement recursively
p5959
as(dp5960
g7
V505088
p5961
stp5962
a((dp5963
g2
(lp5964
VThe application name that Task Manager shows is the Window text of the taskbar window
p5965
aVIf you want to hide it you'll just have to set that text to an empty string
p5966
aVIf a blank string is no good, and you don't want your app to appear in the list at all, then don't register a taskbar button
p5967
aVIf you don't want your app to appear in the process list, then don't start it
p5968
as(dp5969
g7
V505088
p5970
stp5971
a((dp5972
g2
(lp5973
VI'd normally write it like this:
p5974
aVThe function raises an error if no item can be found
p5975
aVPretty soon you'll be looking to wrap all this up in classes
p5976
as(dp5977
g7
V505088
p5978
stp5979
a((dp5980
g2
(lp5981
VI think you want logic like this:
p5982
aVIn your code the expression ("Cat" or "Dog" or "Fish" or "Bird") is treated as a logical expression which I'm sure you don't want
p5983
aVAs it happens this expression evaluates to "Cat" which explains your observed behaviour
p5984
aVThese are logical operations on strings
p5985
aVNon-empty strings are regarded as True values
p5986
aVEmpty strings are regarded as False
p5987
aVPython's logical operators return values of the same type as the operands (assuming both operands are the same type)
p5988
aVShort-circuit evaluation explains the behaviour for  and  here
p5989
aVIn any case, it makes very little sense to perform logical operations on strings
p5990
as(dp5991
g7
V505088
p5992
stp5993
a((dp5994
g2
(lp5995
VYou should not expect to be able to modify INI files stored on remote machines
p5996
aVWhatever your problem is, this is not the solution
p5997
as(dp5998
g7
V505088
p5999
stp6000
a((dp6001
g2
(lp6002
VThe variables that are shown in the GUI dialog are the ones that the user can modify
p6003
aVOthers like  have values that are determined by the system and so Windows doesn't show them in the dialog that allows you to edit them
p6004
as(dp6005
g7
V505088
p6006
stp6007
a((dp6008
g2
(lp6009
VThat's not how you are supposed to do it
p6010
aVYou are meant to mark your
p6011
aVmsi as requiring administrator rights and then the system will show the user a UAC elevation dialog when they install
p6012
aVThis article has more details on Trusted Installer
p6013
aVThe bottom line is that it's not actually a user but a service
p6014
aVIn any case, it's not the solution to your problem
p6015
as(dp6016
g7
V505088
p6017
stp6018
a((dp6019
g2
(lp6020
VI'd recommend looking at something like tpShellShock when you want to show shell like controls in your Delphi app
p6021
aVIt offers tree views, list views etc
p6022
aVthat can be connected together much like an Explorer Windows
p6023
aVIt will display the appropriate icons for the files
p6024
aVI'm sure it offers the facilities you talk about too
p6025
aVIt might need some porting work if you are on a modern Unicode Delphi, but when I have done that it proved relatively straightforward
p6026
aVNo doubt there are other libraries that offer shell controls, this is just the one I am familiar with
p6027
aVOtherwise if you want to stick with your current solution it's easiest to implement your own menu actions
p6028
aVOpen and Properties are just simple calls to ShellExecute with the appropriate verb
p6029
aVDelete is a call to DeleteFile and Rename is a call to MoveFile
p6030
as(dp6031
g7
V505088
p6032
stp6033
a((dp6034
g2
(lp6035
VEach call to  get's its own set of local variables
p6036
aVWhen you assign to  you are assigning to the copy of  at the current level of the call stack
p6037
aVAny algorithm like this is going to need you to pass values back down the call stack
p6038
aVYour fundamental problem is that you are ignoring the value returned from the recursive calls to
p6039
aVI've not studied your algorithm in detail, but since you understand the algorithm, you ought to be able to work it out from here
p6040
as(dp6041
g7
V505088
p6042
stp6043
a((dp6044
g2
(lp6045
VNo this is not possible
p6046
aVYou'll have to find a way to get the new process ID into any lists which hold out-of-date references
p6047
aVYou can see why it can't be possible by reading the documentation for the  structure returned by :
p6048
aVA value that can be used to identify a
p6049
aVprocess
p6050
aVThe value is valid from the
p6051
aVtime the process is created until all
p6052
aVhandles to the process are closed and
p6053
aVthe process object is freed; at this
p6054
aVpoint, the identifier may be reused
p6055
aV(emphasis mine)
p6056
aVSince these IDs can be reused, there's no guarantee that the system won't have re-used it
p6057
as(dp6058
g7
V505088
p6059
stp6060
a((dp6061
g2
(lp6062
VNative Delphi only produces 32 bit Windows executables
p6063
aVThese can only run on Mac with some form of emulation layer
p6064
aVDelphi Prism targets
p6065
aVnet and can produce Mac apps using Mono
p6066
aVIt sounds like you have an existing native Win 32 Delphi app which means this option would not be terribly attractive
p6067
aVEmbarcadero are working on a version of Delphi that will produce native Mac executables but my impression is that this is still some way off release
p6068
aVEven when it is released there will be a significant porting effort required, especially if your app has significant amounts of GUI code
p6069
aVThe VCL will not be available in the same form as on Windows
p6070
as(dp6071
g7
V505088
p6072
stp6073
a((dp6074
g2
(lp6075
VYou have read an ANSI or UTF-8 text file into a UTF-16 string
p6076
as(dp6077
g7
V505088
p6078
stp6079
a((dp6080
g2
(lp6081
VThe mechanism for classes to grant access to their private members is called friendship
p6082
as(dp6083
g7
V505088
p6084
stp6085
a((dp6086
g2
(lp6087
V"Unable to find vcvarsall
p6088
aVbat" means that you haven't got the necessary Visual Studio directories in your path
p6089
aVHowever, if you are using 64 bit Python then you'll need a 64 bit compiler and Express doesn't come in 64 bit flavours
p6090
aVYou could download the SDK MSVC compiler and get that configured but its very hard work
p6091
aVIf I was you I'd switch to 32 bit Python and you can almost surely get pre-built binaries
p6092
aVEDIT
p6093
aVPre-built 64 bit binaries as found by piquadrat would be even simpler
p6094
as(dp6095
g7
V505088
p6096
stp6097
a((dp6098
g2
(lp6099
VYou don't put each form in its own thread
p6100
aVYou put each form in the main thread
p6101
aVA thread only has one message loop
p6102
aVThe exception to this is the special message loop that is run when a form is shown modally
p6103
aVruns your message loop
p6104
aVWhen posted messages are processed they get dispatched to the appropriate window procedure
p6105
aVWhen messages are sent they are delivered synchronously direct to the window procedure
p6106
aVYou can create and show as many forms as you like and service them all from the same message loop
p6107
aVNot only can you do this, it is the way to do things
p6108
aVHow you map this knowledge onto your MVP framework is another matter, but running your GUI out of a single thread is a fixed point in any solution
p6109
aVEDIT
p6110
aVYou ask how, with VCL, to run a message loop if you don't have a visible main form
p6111
aVYou have two options:
p6112
aVCreate an invisible form before you call
p6113
aVRun your own message loop
p6114
aVIn my view option 1 is by far the better option
p6115
as(dp6116
g7
V505088
p6117
stp6118
a((dp6119
g2
(lp6120
VSomething like this should give you the basic idea:
p6121
as(dp6122
g7
V505088
p6123
stp6124
a((dp6125
g2
(lp6126
VThat's a byte order mark
p6127
aVIf you find one at the beginning of the file, just strip it
p6128
aVAnd the spaces in between letters are probably because the console isn't very wide char friendly
p6129
as(dp6130
g7
V505088
p6131
stp6132
a((dp6133
g2
(lp6134
VThese two errors are the same error, code 193, reported two different ways
p6135
aVIt is caused because your 64 bit Python is trying to load a 32 bit DLL
p6136
aVIt's hard to say exactly why this has happened
p6137
aVPerhaps you installed some 32 bit Python modules by mistake
p6138
aVPerhaps there is some confusion in paths
p6139
aVHowever, often the easiest way to get around this sort of problem is to switch to 32 bit Python which runs impeccably on 64 bit Windows
p6140
aVA side benefit is that you will sometimes want to use modules that are only available in 32 bit form \u2013 64 bit module support is still a little patchy
p6141
as(dp6142
g7
V505088
p6143
stp6144
a((dp6145
g2
(lp6146
VThere are Debugger Visualizers that allow you to customise the debugger's visualization capabilities
p6147
aVI've never used them, but it is my understanding that you could combine them with some RTTI and give richer information about a  instance
p6148
aVHowever, using generics is what you want here
p6149
aVIt gives compile time typing which has manifest advantages
p6150
aVI'd simply do it that way
p6151
as(dp6152
g7
V505088
p6153
stp6154
a((dp6155
g2
(lp6156
VYou can't get a plain vanilla  to allow in-place editing
p6157
aVYou'll have to either write your own or look for a 3rd party that offers that functionality (there must be many that do)
p6158
as(dp6159
g7
V505088
p6160
stp6161
a((dp6162
g2
(lp6163
VThe comparison is being done as strings
p6164
aVWrap the  calls around the values in the  statement and you'll be good
p6165
as(dp6166
g7
V505088
p6167
stp6168
a((dp6169
g2
(lp6170
VThe initial array length (length and size are not the same) is , not
p6171
aVAdding  elements
p6172
aVI don't think you are
p6173
aVArrays are zero-based in C
p6174
aVYou loop should be
p6175
aVis a terrible name for a loop variable
p6176
aVshould hold the number of elements and not be a loop variable
p6177
aVIt's hard to imagine what  could be
p6178
aVSince you use it as the element size in your call to  it ought be at least be a multiple of 4, the size of in int
p6179
aVWhat is it
p6180
aVThe  doesn't seem to bear any relation to the
p6181
aVI'm sure there are lots of other problems
p6182
aVIf you want more help then a clear statement of what your goal is would be required
p6183
aVEDIT
p6184
aVIt sounds like you want something like this:
p6185
aVNotes:
p6186
aVNo error checking
p6187
aVIn production code you would check that the allocations succeeded, and the realloc done this way would leak if it failed
p6188
aVBut there's no point confusing the message with error checking when you are still at this level of understanding
p6189
aVNo reading input - you can do that
p6190
aVNo writing output - you can do that
p6191
as(dp6192
g7
V505088
p6193
stp6194
a((dp6195
g2
(lp6196
VYou should follow the rules specified in the MSDN documentation for
p6197
aVIt's painless to do so and it's not as if you have large numbers of message loops scattered about your code
p6198
aVThe Visual Studio team are separate to the Windows team and they make the same mistakes as everyone else
p6199
aVI reality I can't ever imagine  returning an error, but that is the nature of error handling \u2013 that doesn't mean you shouldn't handle errors properly
p6200
as(dp6201
g7
V505088
p6202
stp6203
a((dp6204
g2
(lp6205
VYou have two options:
p6206
aVDelete them and then re-insert them at the new location
p6207
aVUse a virtual list view and move them in your data structure
p6208
aVMy routine for doing the first of these options is like this:
p6209
aVThe method  is used to populate the columns of the list view
p6210
aVThis is a perfect example of why virtual controls are so great
p6211
as(dp6212
g7
V505088
p6213
stp6214
a((dp6215
g2
(lp6216
VNo it is not because you have allowed a reference the element to leak out of the function and away from the safety of the lock
p6217
aVWhat's more, thread-safety questions are a little hard to answer without a harder specification of just what flavour of thread-safety you are desirest
p6218
aVAt the very least you would need to show us every other access of  and
p6219
as(dp6220
g7
V505088
p6221
stp6222
a((dp6223
g2
(lp6224
VIf you are using Windows with the standard cmd
p6225
aVexe console (and it would have been helpful for you to have stated this up front) then you can use the TAB and arrow keys exactly as you desire
p6226
as(dp6227
g7
V505088
p6228
stp6229
a((dp6230
g2
(lp6231
VThe problem is that the container for the the MDI children is a sibling of the panel
p6232
aVThe panel is either on top of that container or behind it
p6233
aVYou want the panel to be in the same container as the MDI children, but I don't believe that to be possible
p6234
aVThe MDI container holds MDI children and nothing else
p6235
aVIn short, I don't think MDI is going to give you what you need
p6236
as(dp6237
g7
V505088
p6238
stp6239
a((dp6240
g2
(lp6241
VOutput:
p6242
aVNot very Pythonic I know, but in its favour it does actually work
p6243
as(dp6244
g7
V505088
p6245
stp6246
a((dp6247
g2
(lp6248
VAs specified, this is indeed a hard problem with no magic shortcuts
p6249
aVIn order to find the minimum available number you need to use trial and error, exactly as you are doing
p6250
aVWhilst the implementation could be speeded up, there is a fundamental limitation in the algorithm
p6251
aVI think I would relax the constraints to the problem a little
p6252
aVI would be prepared to choose numbers that weren't the minimum available
p6253
aVI would store a hidden file in the directory which contained the last number used when creating a file
p6254
aVEvery time you come to create another one, read this number from the file, increment it by 1, and see if that name is available
p6255
aVIf so you are good to go, if not, start counting up from there
p6256
aVRemember to update the file when you do settle on a name
p6257
aVIf no humans are reading these names, then you may be better off using randomly generated names
p6258
as(dp6259
g7
V505088
p6260
stp6261
a((dp6262
g2
(lp6263
VNo, it's still there
p6264
aVYou need to follow the instructions
p6265
aVPresumably you missed on of these steps somehow
p6266
aVPerhaps you were running a RELEASE build by mistake
p6267
aVKind of hard to tell from here
p6268
as(dp6269
g7
V505088
p6270
stp6271
a((dp6272
g2
(lp6273
VSince this is inside your own app there is absolutely no reason to fake input, a notoriously delicate area
p6274
aVSimply call the methods you need directly
p6275
aVEDIT
p6276
aVSince you seem very keen on faked input, I'll try to explain what is hard about it
p6277
aVFirst of all input is not sent synchronously to windows, instead it it posted asynchronously to the message queue of the thread which owns the input focus
p6278
aVWhen that thread pumps its messages it delivers the input messages to the appropriate window
p6279
aVThe main complication with input messages is that the system holds hidden keyboard state information with them that you cannot fake through
p6280
aVFor example, read the documentation of
p6281
aVIf you want to fake a SHIFT+TAB key combination then you simply can't do it with  because that would not put the SHIFT in the keyboard state
p6282
aVIt can only be done with
p6283
as(dp6284
g7
V505088
p6285
stp6286
a((dp6287
g2
(lp6288
VFont smoothing works with partial transparency using an alpha channel
p6289
aVThe  and  properties of  are therefore not applicable
p6290
aVYou haven't said which version of the C++ Builder/VCL you are using, but more modern versions have better support for partial transparency than some of the older ones
p6291
aVTo get this to work you will need to set the  of your bitmap to be
p6292
aVYou may also need to set  to
p6293
aVIf you can't get  to do what you need then you'll have to revert to GDI commands to create a suitable
p6294
aVYou can at least assign that to the  property of a  and usually from there everything behaves
p6295
aVNote that I am not a user of C++ Builder but do know the VCL from Delphi
p6296
aVUPDATE
p6297
aVI tried this out in Delphi and the following worked fine for me:
p6298
aVThe output looks like this, blown up somewhat to see the anti-aliasing:
p6299
aVI hope this helps, because it looks like you are very nearly there
p6300
as(dp6301
g7
V505088
p6302
stp6303
a((dp6304
g2
(lp6305
VThe way I usually describe the issues of thread termination is to stress co-operation
p6306
aVYou should not terminate a thread
p6307
aVInstead you should notify the thread that you want it to terminate
p6308
aVYou then politely wait until it has terminated
p6309
aVThe reasons for this are manifest
p6310
aVOnly the thread knows how to terminate itself
p6311
aVOnly the thread knows what locks it holds, what resources it needs to free etc
p6312
aVThe same arguments apply if you wish to pause or suspend a thread's execution
p6313
aVYou should ask to it do so and then let the thread find a convenient moment when it is safe to do so
p6314
aVWith a Delphi  the standard way to request termination is to call
p6315
aVThis does nothing more than to set a flag in the thread object
p6316
aVThat is the request
p6317
aVThe response is initiated by the thread code inside
p6318
aVThat should regularly check the value of its  property
p6319
aVWhen that is found to be true, it should exit from the function
p6320
aVNaturally any tidy up (release locks, return resources etc
p6321
aVshould be performed before calling exit
p6322
as(dp6323
g7
V505088
p6324
stp6325
a((dp6326
g2
(lp6327
VI think you are 99% of the way there
p6328
aVHashing sounds like the right solution
p6329
aVThe obvious way to take advantage of the special nature of the GUID is to supply your own hash function which combines into a single 32 bit integer the 4 32 bit integers that make up a GUID
p6330
aVI'd just XOR the 4 integers
p6331
aVI presume you are using Generics
p6332
aVCollections
p6333
aVTDictionary
p6334
aVYou can supply your own hash function by passing a custom comparer to the constructor
p6335
aVI wouldn't worry about storing spare values, I don't think it will affect performance in a discernible way
p6336
aVI trust that you are storing your GUIDs as 128 bit integers and not as strings
p6337
aVFinally, it has occurred to me that the default comparer for a GUID might indeed already do the hash code generation this way
p6338
aVIt's worth checking that out before making any changes
p6339
aVEDIT
p6340
aVDefault hash code uses Bob Jenkins hash applied to the binary data
p6341
aVAn XOR would be faster, but the default hash code doesn't seem like it would be a performance bottleneck
p6342
aVIn other words, I think that  will serve your needs perfectly adequately
p6343
as(dp6344
g7
V505088
p6345
stp6346
a((dp6347
g2
(lp6348
VHere's my code to do this:
p6349
aVis quite nifty
p6350
aVIt works for any control with a vertical scroll bar
p6351
aVI use it with tree views, list views, list boxes, memos, rich edits, etc
p6352
aVYou'll be missing my  routine but you can substitute your own method for checking that the wheel event is not modified
p6353
aVThe reason you want to do this is the, for example, CTRL+mouse wheel means zoom rather than scroll
p6354
aVFor what it's worth, it looks like this:
p6355
as(dp6356
g7
V505088
p6357
stp6358
a((dp6359
g2
(lp6360
VFirst of all, as others have pointed out, your C++ is broken even before trying interop
p6361
aVYou are returning a pointer to 's buffer
p6362
aVBut because  is destroyed as soon as the function returns, the return value is not valid
p6363
aVWhat's more, even if you fixed this, you need to do more
p6364
aVIt won't work allocating memory in your C++ code which you would need the C# code to deallocate
p6365
aVThere are a few options to do it right
p6366
aVYour C# code can ask the C++ code how long the string is
p6367
aVThen a C# StringBuilder is created and allocated to the appropriate size
p6368
aVNext the StringBuilder object is passed to the C++ code and its default marshalling is as a LPWSTR
p6369
aVIn this approach the C# code allocates the string and your C++ code receives a C string to which it must copy the buffer
p6370
aVAlternatively you can return a BSTR from the C++ which allows allocation in the native C++ code and deallocation in the C# code
p6371
aVThe BSTR approach is probably how I would do it
p6372
aVIt looks like this:
p6373
aVC++
p6374
aVC#
p6375
aVUpdate
p6376
aVHans Passant added a couple of useful observations in the comments
p6377
aVFirst of all, most P/Invoke interop is done against an existing interface which cannot be changed and you do not have the luxury of picking your preferred interop interfacing approach
p6378
aVIt would appear that is not the case here, so which approach should be chosen
p6379
aVOption 1 is to allocate the buffer in the managed code, after having first asked the native code how much space is needed
p6380
aVPerhaps it is enough to use a fixed size buffer that both parties agree on
p6381
aVWhere option 1 falls down is when assembling the string is expensive and you don't want to do it twice (e
p6382
ag217
aVonce to return its length, and once again for the contents)
p6383
aVThis is where option 2, the  comes into play
p6384
aVHans pointed out one drawback of the , namely that it carries a UTF-16 payload but your source data may well , which is a "bit of a hassle"
p6385
aVTo overcome the hassle you can wrap up the conversion from  to  like this:
p6386
aVThat's the hardest one out of the way, and now it's easy to add other wrappers to convert to  from , ,  etc
p6387
as(dp6388
g7
V505088
p6389
stp6390
a((dp6391
g2
(lp6392
VServices run in a different session (session 0) from interactive users
p6393
aVThis is known as session 0 isolation
p6394
aVYou can't access the logged in user's desktop from a service
p6395
aVYou'll have to attack this problem by enumerating processes rather than windows
p6396
as(dp6397
g7
V505088
p6398
stp6399
a((dp6400
g2
(lp6401
VThe following works for me:
p6402
aVNote that I'm using early binding which makes life much easier
p6403
aVJust include the Excel2000 unit and this code will work for you
p6404
aVUsing early binding will allow you to catch errors like this at compile time rather than getting hard to diagnose runtime errors
p6405
aVIf you want to continue with late binding then, as Sertac states, this works:
p6406
aVDon't forget to create a workbook first though
p6407
as(dp6408
g7
V505088
p6409
stp6410
a((dp6411
g2
(lp6412
VIt's hard to say for sure because you haven't given all the details yet, but your problem is quite possibly that you are using a 32 bit compiler producing 32 bit executables and you are simply running out of address space
p6413
aVAlthough your operating system supports 64 bit address space, your 32 bit process is still limited to 32 bit addresses
p6414
aVYou have found a limit at 3300*78805*8 which is just under 2GB and this supports my theory
p6415
aVNo matter what is the cause of your immediate problem, your fundamental problem is that you appear to be loading everything into memory at once
p6416
aVI've not closely studied your algorithm but on first inspection it seems likely that you could re-arrange it to avoid having everything in memory at once
p6417
as(dp6418
g7
V505088
p6419
stp6420
a((dp6421
g2
(lp6422
VMy take on this is that you only need the Delphi unit in the Delphi version of the project
p6423
aVIn the C++ builder version you just compile and link foolib
p6424
aVc as if it was a C file (it is
p6425
aVIn the Delphi version of the program you create the
p6426
aVobj with bcc32, use ctrl etc
p6427
aVas described
p6428
aVWhy do you want to wrap it up a C library up in a Delphi wrapper to be consumed in C++
p6429
aVEDIT 1
p6430
aVYou've added clarifications in the comments
p6431
aVAnother option to consider would be to avoid crtl and implement the missing functions in FooWrapper
p6432
aVI do it that way rather than using crtl because that gives me more control and I understand what is being called
p6433
aVFor example, I don't want any calls to  leaking into my GUI app or my DLL
p6434
aVThis might be an attractive option if you are only missing a handful of functions
p6435
aVOften the neatest way to get them is to link them in from msvcrt
p6436
aVdll which is a standard system component these days
p6437
aVOf course it seems a bit heavyweight to link in msvcrt
p6438
aVdll just to get at ,  etc
p6439
aVHow many missing functions are there when you compile the Delphi unit without crtl
p6440
aVEDIT 2
p6441
aVI'm adding this to the answer to show some code
p6442
aVFrom my own code base I offer this:
p6443
aVFor  I link in ftol
p6444
aVobj which I presume I extracted from one of the lib files in the BCC55 compiler that I use
p6445
aVI think  should be pretty routine to implement in plain Pascal
p6446
aVis more difficult in full generality, but you might find that it is only used for something trivial like integer to string
p6447
aVIn which case you could fudge the C code to call a routine dedicated for that and implement it trivially
p6448
aVTo be honest with you, I think 'msvcrt
p6449
aVdll' looks pretty attractive
p6450
aVEDIT 3
p6451
aVDid I speak to soon
p6452
aVYou can pull a perfectly serviceable  out of user32
p6453
aVdll which almost all processes have loaded anyway
p6454
aVMake sure you pick out  if it's an ANSI version you need
p6455
aVEDIT 4
p6456
aVI notice
p6457
aVYou say this is defined in a different Delphi unit
p6458
aVIn order to get the compiler to see it you need to redeclare it in AbCtrl
p6459
aVpas and from there call the real version in AbLzma
p6460
aVpas
p6461
aVWhen you include a
p6462
aVobj in a Delphi
p6463
aVpas file the compiler has to be able to resolve all the references in the
p6464
aVobj file from within the Delphi unit which links to the
p6465
aVobj
p6466
aVThis whole game is dealt with by the compiler rather than the linker
p6467
aVSometimes you get tangled in knots with the order in which you include the
p6468
aVobj files and the solution is to use forward declarations, but that's another story
p6469
as(dp6470
g7
V505088
p6471
stp6472
a((dp6473
g2
(lp6474
VBoth Windows and Linux should use  which results in the C calling convention
p6475
aVThe Python code at present calls your Windows DLL using  but it's really a  function
p6476
aVThe difference between  and  is just the calling convention used
p6477
aVThat error message is a textbook calling convention mismatch error, for what it's worth
p6478
as(dp6479
g7
V505088
p6480
stp6481
a((dp6482
g2
(lp6483
VHere's a very simple example:
p6484
aVI've tried to show the various options for dealing with optional parameters which are important issues with Excel COM programming
p6485
aVYou can use positional parameter passing and omit parameters from the end
p6486
aVOr you can pass  which is equivalent
p6487
aVFinally, you can used named parameters
p6488
as(dp6489
g7
V505088
p6490
stp6491
a((dp6492
g2
(lp6493
s(dp6494
g7
V505088
p6495
stp6496
a((dp6497
g2
(lp6498
VI'd do it with a  since it means you don't have to call into native twice per string, once to get the length and then once to get the contents
p6499
aVWith a  the marshaller will take care of deallocating the  with the right memory manager so you can safely pass it out of your C++ code
p6500
aVC++
p6501
aVC#
p6502
aVThere is one minor drawback of the , namely that it carries a UTF-16 payload but your source data may well be
p6503
aVTo overcome this you can wrap up the conversion from  to  like this:
p6504
aVThat's the hardest one out of the way, and now it's easy to add other wrappers to convert to  from , ,  etc
p6505
as(dp6506
g7
V505088
p6507
stp6508
a((dp6509
g2
(lp6510
VThe WideString is compatible with COM BSTR and so the
p6511
aVnet marshaller should be able to consume it quite happily:
p6512
as(dp6513
g7
V505088
p6514
stp6515
a((dp6516
g2
(lp6517
VYou can specify calling convention by:
p6518
aVDo nothing and you get the default of cdecl
p6519
aVSpecify  explicitly (or perhaps through a macro)
p6520
aVElect to use cdecl throughout a translation unit by compiling with /Gd
p6521
aVThere's no pragma or anything similiar to control calling convention
p6522
as(dp6523
g7
V505088
p6524
stp6525
a((dp6526
g2
(lp6527
VIn case you haven't found it, these can very easily be controlled from the Project Options dialog:
p6528
as(dp6529
g7
V505088
p6530
stp6531
a((dp6532
g2
(lp6533
VIn Delphi XE, there is no reason not to use generic containers
p6534
aVSwitching from the old method with casting will give you:
p6535
aVcleaner, type-safe, less error-prone code,
p6536
aVenumerators, for in loops,
p6537
aVthe samebetter performance characteristics
p6538
as(dp6539
g7
V505088
p6540
stp6541
a((dp6542
g2
(lp6543
VDynamic arrays are managed types and so are always initialized to , equivalent to
p6544
aVYou never need to do this
p6545
aVThe only time you can get caught out is when you are returning a dynamic array from a procedure as a function return value
p6546
aVIn fact a function return value is in fact just an implicit var parameter
p6547
aVConsider the following code:
p6548
aVOutput
p6549
aVWhat's going on here is that the compiler, as an optimization is electing not to re-initialize the implicit local variable inside the loop
p6550
aVThis can catch you out from time to time so I recommend setting to nil return values that are dynamic arrays, strings, interfaces etc
p6551
aVYou don't need to do so for class members and it's more idiomatic to let the constructor zero-initialise them automatically
p6552
as(dp6553
g7
V505088
p6554
stp6555
a((dp6556
g2
(lp6557
VThe default implementation will perform extremely well with a TObject key
p6558
aVEquality is defined to be object identity, the same as testing
p6559
aVThe hash is simply the address of the reference \u2013 it could not be more efficient
p6560
aVThe code looks like this:
p6561
aVLooking up in a hashed dictionary does not involve searching
p6562
aVIt is a highly efficient O(1) operation
p6563
aVI think you should take a read of the Wikipedia article
p6564
as(dp6565
g7
V505088
p6566
stp6567
a((dp6568
g2
(lp6569
VMy recommendation: never keep images in
p6570
aVdfm files
p6571
aVAlways put them in resource files and regain control of your app
p6572
as(dp6573
g7
V505088
p6574
stp6575
a((dp6576
g2
(lp6577
VYou appear to have been misled into the belief that Delphi strings do not come with a default hash code implementation
p6578
aVThis is not the case
p6579
aVWhen you create a  with a string value as a key, the hash is calculated based on the contents of the string
p6580
aVIf  is a string variable then the code looks like this:
p6581
aVI think this answers the part of your question concerning string hashing
p6582
aVThe comments to the other answers, and the ones I have deleted were an interesting discussion on the design problem you are contemplating
p6583
aVI'm still sceptical of your belief that the right solution is to allow a many-to-one relationship between TVehicle instances and VIN
p6584
aVYou have confirmed that you must not have multiple TVehicle instances with the same VIN but differing data
p6585
aVIt seems to me that the best way to achieve this is to ensure that you have a one-to-one relationship between TVehicle instances and VIN
p6586
aVThis one-to-one relationship is quite easy to achieve
p6587
aVYou need to make the instantiation of TVehicle instances a function private to a factory class
p6588
aVThis factory class holds a dictionary containing the existing vehicle instances,
p6589
aVIf you need to get hold of a vehicle you ask the factory for it
p6590
aVIt returns either an existing one that was located in its dictionary, or synthesises a new one
p6591
aVThere are no doubt a number of other ways to achieve this effect, but I would strongly urge you to consider an approach that results in only a single vehicle instance per VIN
p6592
as(dp6593
g7
V505088
p6594
stp6595
a((dp6596
g2
(lp6597
VThe
p6598
aVpas file is generated from the type library, which is typically contained within the COM DLL
p6599
aVThe
p6600
aVpas file defines the interface to the COM DLL
p6601
aVCOM DLL's which come with embedded type libraries have self-describing interfaces
p6602
aVYou still need documentation to understand what the interfaces and methods do, and how the parameters are used
p6603
aVBut you don't need to write the boiler plate interface code yourself
p6604
aVWhen a COM DLL has an embedded type library, you can create import units in your programming language of choice, not just Delphi
p6605
aVIf you want to know COM there is no better reference than Don Box's Essential COM, one of the finest computing books I have ever read
p6606
as(dp6607
g7
V505088
p6608
stp6609
a((dp6610
g2
(lp6611
VI think the quickest way to check on Windows is to call
p6612
aVYou could try this through ctypes and see if it is any faster
p6613
aVIf it is not faster then you'll probably just have to suck it down
p6614
aVAnd if it is faster then you have your solution
p6615
as(dp6616
g7
V505088
p6617
stp6618
a((dp6619
g2
(lp6620
VWWW_GetWindowInfo is supported in IE and has been since version 3
p6621
aV02 back in the 16 bit days
p6622
aVWorks for Firefox and Opera
p6623
aVI believe that Chrome is in fact the odd one out
p6624
aVI've got no knowledge of how things are beyond those four
p6625
as(dp6626
g7
V505088
p6627
stp6628
a((dp6629
g2
(lp6630
VImport the type library with the Type Library Importer
p6631
aVSince you are using C++, it's probably easiest to do this with
p6632
aVThis Code Project article gives step-by-step procedures
p6633
as(dp6634
g7
V505088
p6635
stp6636
a((dp6637
g2
(lp6638
VI suspect your real problem is that you have the Professional version of Delphi rather than Enterprise
p6639
aVAs far as I know, BDE can still be used with Delphi 2010
p6640
aVWith Delphi 6 the Professional version allowed connections to remote databases
p6641
aVSomewhere between Delphi 6 and Delphi 2010 that policy was changed
p6642
aVAnyway, you really need to give up on BDE and move forward
p6643
aVEdit: (jeroen)
p6644
aVThe BDE for relational access (aka the ) has been deprecated since 2002, about 2 years after the introduction of dbExpress in Kylix and Delphi 6
p6645
as(dp6646
g7
V505088
p6647
stp6648
a((dp6649
g2
(lp6650
VYou don't need to free it since it is static
p6651
aVBut you have to take a copy of the string contents before you call the function again, otherwise you'll overwrite the contents from the first call
p6652
as(dp6653
g7
V505088
p6654
stp6655
a((dp6656
g2
(lp6657
VIt doesn't show beyond the 10th in design-time:
p6658
aVBut at run-time is looks like this:
p6659
aVAll properties set in the
p6660
aVdfm file
p6661
aVAs to why it is like this I've no idea
p6662
aVBut since it behaves fine at run-time I don't think will cause any serious problems
p6663
aVAs requested by Warren, here's my
p6664
aVdfm:
p6665
as(dp6666
g7
V505088
p6667
stp6668
a((dp6669
g2
(lp6670
VYour question is still a little vague, but it's better than the one that was closed yesterday
p6671
aVI'm assuming that you want the barcode in a file so that it can be printed and then scanned
p6672
aVThere's absolutely no point of having a barcode if it is not going to be scanned
p6673
aVI'm also assuming that a text file is something that will be printed as text, e
p6674
ag217
aVby Notepad
p6675
aVWith these assumptions then the answer to your question is that a scannable barcode cannot be stored in a text file
p6676
aVYou have a number of options to solve your problem:
p6677
aVCreate a PDF and print that
p6678
aVThere are many 3rd party tools for PDF creation
p6679
aVUse Office automation (very heavy duty and somewhat brittle solution)
p6680
aVBut very quick to implement - only a few lines of code
p6681
aVPrint to the printer directly using GDI commands
p6682
as(dp6683
g7
V505088
p6684
stp6685
a((dp6686
g2
(lp6687
VYou can be certain that the message will be in the queue if the call to  succeeds
p6688
aVwill fail if the receiving queue is full
p6689
aVMSDN says:
p6690
aVThere is a limit of 10,000 posted
p6691
aVmessages per message queue
p6692
aVThis limit
p6693
aVshould be sufficiently large
p6694
aVIf your
p6695
aVapplication exceeds the limit, it
p6696
aVshould be redesigned to avoid
p6697
aVconsuming so many system resources
p6698
aVTo
p6699
aVadjust this limit, modify the
p6700
aVfollowing registry key
p6701
aVYou can't be certain that posted messages will ever be processed because it's up to the other app to decide whether or not to pump its message queue
p6702
aVThis is being a little pedantic because in reality an app that doesn't ever pump its queues never gets run by anyone through a process of natural selection
p6703
as(dp6704
g7
V505088
p6705
stp6706
a((dp6707
g2
(lp6708
VI'm going to take a wild guess since you haven't given much information
p6709
aVThe dialog doesn't close because it isn't a modal dialog
p6710
aVTry showing it with  rather than
p6711
as(dp6712
g7
V505088
p6713
stp6714
a((dp6715
g2
(lp6716
VMany 3D games were written with graphics provided by software
p6717
aVBoth Open GL and Direct 3D have modes that allow for software rendering
p6718
aVThe original version of Half Life can run without graphics hardware and this was one of the reasons for its success
p6719
aVBack when Windows 95 was current, very few machines had graphics cards with 3D accelerators and so this was how PC games worked
p6720
as(dp6721
g7
V505088
p6722
stp6723
a((dp6724
g2
(lp6725
VIf you want to know that the column widths have changed then you can override
p6726
aVI'm not aware of a corresponding event
p6727
aVFor detecting columns having moved you can either override  or attach a handler to the  event
p6728
as(dp6729
g7
V505088
p6730
stp6731
a((dp6732
g2
(lp6733
VYou probably ought to raise a bug in the Slony-I bug database or e-mail their mailing list
p6734
aVSince it is open source you could even re-build it and remove the unwanted event logging
p6735
aVAlso, you don't need to register to receive event logs but you probably want errors
p6736
aVYou appear to be using Windows XP which is rather decrepit now \u2013 it's 10 years old
p6737
aVThe modern versions of Windows have much more resilient event logs
p6738
aVFinally, you could reconfigure the event log settings to try to avoid the problem
p6739
aVYou could make the log much bigger (512KB default is quite small) and there appear to be other settings available
p6740
aVOpen the event viewer, right click one of the event logs and select properties
p6741
as(dp6742
g7
V505088
p6743
stp6744
a((dp6745
g2
(lp6746
VI would use neither in Delphi \u2013 I would use streams
p6747
aVLow level file handling is messy and error-prone, it's much better to use higher level routines if you can
p6748
aVYou ask which is faster,  or
p6749
aVThey are basically the same, but any method of opening a file is going to map onto the system call anyway so the performance will be the same no matter how you do it
p6750
aVWhat's more, when does performance for opening a file matter, it's when reading or writing that time is expended
p6751
aVAny questions about performance are hard to answer without context
p6752
aVThe answer for an app which reads thousands of small text files is different from one which streams backups to a tape drive, for example
p6753
aVAnyway, to stress my original point, take advantage of the excellent high-level framework that Delphi provides, use streams, avoid low-level I/O and enjoy
p6754
aVSo, how does one use a Delphi stream
p6755
aVI'll try to illustrate this with a made up example of writing some text, in a string, to a file
p6756
aVIt's pretty self-explanatory
p6757
aVThe second parameter to the TFileStream constructor determines the file mode
p6758
aVHere we want to create a brand new file and so if any contents exist, they are removed
p6759
aVYou can also specify file sharing with this parameter
p6760
aVThe code to write the buffer out has a little boiler-plate but again is very simple
p6761
aVLoading it back results in an almost identical routine:
p6762
aVIf you wish to seek around the file then you can set the  property of the stream, or call the  method
p6763
aVThe advantage of the latter is that you can seek from current position or end position
p6764
aVStreams are idiomatic Delphi
p6765
aVThey are used pervasively in the RTL and VCL and by 3rd party libraries
p6766
aVThey signal errors with exceptions in the native Delphi manner
p6767
aVThere are many different stream classes that all derive from a common ancestor and many routines accept this common ancestor
p6768
as(dp6769
g7
V505088
p6770
stp6771
a((dp6772
g2
(lp6773
VFor what it's worth, my codebase uses  in one direction and the following home-grown wrapper coming back:
p6774
aVThe call to  means that the routine is robust to absolute paths being specified
p6775
aVSo,  can be your  only the parameters are reversed
p6776
aVAnd my  will serve as your
p6777
as(dp6778
g7
V505088
p6779
stp6780
a((dp6781
g2
(lp6782
VThe component is usually called TWebBrowser \u2013 no doubt this is a variant
p6783
aVPerhaps they renamed it to avoid clashes with existing TWebBrowser components
p6784
aVTWebBrowser is an OCX wrapper around IWebBrowser2
p6785
aVIt's very hard to imagine that TWebBrowserEx is implemented in any other way
p6786
aVThe documentation is on MSDN but you'll get better hits searching for TWebBrowser
p6787
aVThe best source of information is Brian Cryer's site
p6788
aVNote that once you get into programming the DOM (through the  property) it becomes highly dynamic and so what documentation there is takes quite a bit of getting used to if you are used to more static class interfaces
p6789
aVUPDATE
p6790
aVAccording to @jachguate, TWebBrowserEx derives from TWebBrowser and adds a bunch of extra interfaces
p6791
aVI don't believe this changes anything substantial in the answer
p6792
aVThe documentation sources are still going to be as listed above
p6793
as(dp6794
g7
V505088
p6795
stp6796
a((dp6797
g2
(lp6798
VYou are looking for something like this:
p6799
aVThis is the most simple Windows program
p6800
aVIt does absolutely nothing and does not consume CPU
p6801
aVI can't imagine why you want it, but this is what you describe
p6802
as(dp6803
g7
V505088
p6804
stp6805
a((dp6806
g2
(lp6807
VRegarding why  executes a lot, every single time an object is destroyed, any object, that method will be called
p6808
aVAll classes derive from TObject, it's the common ancestor, so almost any action in a Delphi program involves large numbers of object create/destroy pairs and consequently will hit
p6809
aVRegarding detection of memory leaks, you have all you need built in to Delphi to solve this
p6810
aVThe FastMM memory manager can be run in "report memory leaks" mode and it will give you loads of diagnostics of any memory that you leak
p6811
aVConsider the following trivial program:
p6812
aVThis results in the following output:
p6813
aVYou just need to set  to True somewhere in your app (the start of the
p6814
aVdpr file is as good a place as any)
p6815
aVIf you wish to receive more information in the report then you can download the full version of FastMM and configure it to your heart's content
p6816
aVThen you get output like this:
p6817
aVIt's truly wonderful
p6818
aVIt tells me that the leaking memory was allocated in Main
p6819
aVpas line 997, and that's precisely where I put my intentional leak
p6820
as(dp6821
g7
V505088
p6822
stp6823
a((dp6824
g2
(lp6825
VThis animation feature was introduced in Vista with the Aero theme
p6826
aVThere is a workaround though
p6827
aVIf you move the progress backwards, the animation is not shown
p6828
aVSo if you want it to advance by 50 instantly, increment Value by 51, then immediately decrement by 1
p6829
aVYou get into strife when close to 100% because you can't set Value to 101 (I'm assuming Maximum is set to 100)
p6830
aVInstead set Maximum to 1000, say, increase to 1000, decrease to 999, and then move back to 1000
p6831
aVAnyway, it's kind of weird, but it does have the benefit of giving you the desired effect
p6832
as(dp6833
g7
V505088
p6834
stp6835
a((dp6836
g2
(lp6837
VYou won't be able to do it with  on many platforms because it will have 16 bit elements
p6838
aVInstead you should use , but this requires a compiler with some C++0x support
p6839
as(dp6840
g7
V505088
p6841
stp6842
a((dp6843
g2
(lp6844
VYou would normally implement this by returning the local IP address, for example by calling
p6845
as(dp6846
g7
V505088
p6847
stp6848
a((dp6849
g2
(lp6850
VYour problem is that whilst the iteration part of your algorithm is fine, the termination is not what you think it is
p6851
aVThe Taylor series expansion you are using is exact when the infinite sum is evaluated
p6852
aVHowever, you cannot evaluate that infinite sum and are truncating
p6853
aVI suppose you are assuming that when  becomes smaller than your desired tolerance, then the error in  is also less than that tolerance
p6854
aVHowever, this is not true
p6855
aVThe error, at each iteration is the infinite sum of the remaining terms
p6856
aVIt is the sum of the infinite number of terms that you are throwing away
p6857
aVThe first one of these, the value of  at the point of termination, may be less that your tolerance, but the sum of them all may be greater than your tolerance
p6858
aVYou happen to get away with it when (-x) is negative because the alternating sign of  works in your favour
p6859
aVAnd when (-x) is positive you get away with it when  is close to zero
p6860
aVHowever, I'm not convinced there is an easy way to come up with a simple general purpose stopping criteria
p6861
aVYou'd have to be able to put some bounds on the terms which you are throwing away
p6862
aVThis now becomes a mathematical problem rather than a programming problem
p6863
as(dp6864
g7
V505088
p6865
stp6866
a((dp6867
g2
(lp6868
VThere are a gazillion tools for authoring help files
p6869
aVThese help files can then be displayed by one of the standard help viewer applications
p6870
aVYour WinForm application (I'm assuming its WinForms) will be able to hook into them with context sensitive help when you press F1
p6871
aVI strongly urge you not to re-invent this particular wheel
p6872
as(dp6873
g7
V505088
p6874
stp6875
a((dp6876
g2
(lp6877
VA function return value of type  is actually treated by the compiler as an implicit var parameter
p6878
aVWhen the function begins execution, the  variable contains whatever is in the local variable to which the return value will subsequently be assigned
p6879
aVAccordingly you should always initialise function return values
p6880
aVThis advice holds not only for strings, but for all data types
p6881
aVThis issue was discussed only yesterday here on Stack Overflow
p6882
as(dp6883
g7
V505088
p6884
stp6885
a((dp6886
g2
(lp6887
V is the most convenient Windows API to call
p6888
aVIt's the fastest and unlike  does not require you to obtain a file handle
p6889
aVWrap it up like so:
p6890
aVIf you happen to have a file handle then  is probably best:
p6891
as(dp6892
g7
V505088
p6893
stp6894
a((dp6895
g2
(lp6896
VBoth parties have good support for COM
p6897
aVI can't tell from your question whether or not the call comes from
p6898
aVnet or VB6, but either way it will be simplest to communicate with good old fashioned COM
p6899
as(dp6900
g7
V505088
p6901
stp6902
a((dp6903
g2
(lp6904
VHere is a short example from my own codebase which shows the most basic hooking technique:
p6905
as(dp6906
g7
V505088
p6907
stp6908
a((dp6909
g2
(lp6910
VTo do this you need to declare a pointer type as a nested type in the generic class:
p6911
aVAnd if you want a class method (i
p6912
ag192
aVnot an instance method) you can do it this way:
p6913
aVOr using a var parameter:
p6914
aVIt seems to be common to use records rather than classes for generic types that don't ever get instantiated
p6915
aVFinally, you cannot have, in Delphi, a generic method without making the class generic
p6916
aVIn other words there is no analogue of the following C++ template code:
p6917
aVThorsten's answer shows how to implement a generic method without making the class generic, that is the Delphi analogue of of the following C++ template code:
p6918
aVThorsten's answer gives you a class function but in the comments you state you are looking for a normal member function
p6919
aVHowever, what I'm struggling with is how exactly you could do anything very useful with this, in Delphi, that could not be done just as effectively without a generic solution
p6920
aVI'd appreciate any suggestions and would be happy to edit the answer to accommodate them
p6921
as(dp6922
g7
V505088
p6923
stp6924
a((dp6925
g2
(lp6926
VAs far as I am aware, there is no official programmatic way to show the services control panel UI to the user
p6927
aVConsequently I believe that you must look for another solution
p6928
as(dp6929
g7
V505088
p6930
stp6931
a((dp6932
g2
(lp6933
VI'm assuming the input is in a file
p6934
aVAnd I'm also assuming that the file is UTF-8 encoded, otherwise this won't work
p6935
aVMy solution is a simple Perl script
p6936
aVNo doubt it can be done with MATLAB, but different tools have different strengths
p6937
aVI wouldn't attempt numerical analysis with Perl, that's for sure
p6938
aVconvert
p6939
aVpl
p6940
aVinput
p6941
aVtxt
p6942
aVCommand line
p6943
aVoutput
p6944
aVtxt
p6945
as(dp6946
g7
V505088
p6947
stp6948
a((dp6949
g2
(lp6950
VI feel I just need like a "chill out"
p6951
aVfunction to cause Python to stop
p6952
aVwhatever it is it's doing, let the
p6953
aVtargeted UI recover and refresh and
p6954
aVprocess input, then bring it back to
p6955
aVPython
p6956
aVWhat function would do that
p6957
aVCalling  (any variant of it) will block execution of the thread from which you call it
p6958
aVThis is simply the last thing you want to do if you wish to have responsive UI in that thread
p6959
aVPut simply, once you go to sleep, you can't do anything
p6960
aVWhen you have non-responsive user interface, that indicates that a long-running task is executing in the thread which processes the UI, or the UI thread is blocking
p6961
aVSo, to follow the logic through, if your 1 second sleeps (they are really dozes rather than proper sleeps
p6962
aVare causing the UI to hang, they must be occurring in the same thread as the UI, or a thread which the UI is waiting
p6963
aVI don't really know how you are using PIL and how you interact with the app whose image you are scraping, but it doesn't seem too likely that you are injecting into that other process
p6964
aVSo I'd guess that process is waiting on your thread
p6965
aVIf that is so then there is no real shortcut to solving your problem
p6966
aVYou simply need to spend less time doing whatever it is you are doing
p6967
aVCalling  can only make things worse
p6968
aVCalling  can't help much either
p6969
aVAll it will do is allow another thread to run (if there's one waiting and ready to run), but you want the thread you are in to run
p6970
aVIt won't make much difference anyway because the system will know that your thread wants to run and will schedule it again in due course
p6971
aVThe bottom line is that you have code running in a UI process that is blocking that process
p6972
aVYou simply need to make it happen as quickly as possible to minimize the interference
p6973
as(dp6974
g7
V505088
p6975
stp6976
a((dp6977
g2
(lp6978
VI don't understand why is Windows creating a dialog in your app
p6979
aVWhich API call resulted in that happening
p6980
aVNormal file operations don't show UI
p6981
aVMost likely you were using an API function that can show UI, perhaps from the shell API
p6982
aVAny function that can show a modal dialog will request an owner
p6983
aVFor example consider , a function that you know will show a modal dialog in your app
p6984
aVIts first parameter is called  and is documented
p6985
aVA handle to the owner window of the
p6986
aVmessage box to be created
p6987
aVIf this
p6988
aVparameter is NULL, the message box has
p6989
aVno owner window
p6990
aVRaymond Chen has a whole series of articles on modality which explain why setting this is important
p6991
aVI have a hunch that you are calling some Win32 API function that shows modal UI, and are not setting the owner  correctly
p6992
aVOf course, I could be completely wrong, but there's not more information to go on
p6993
as(dp6994
g7
V505088
p6995
stp6996
a((dp6997
g2
(lp6998
VThe other answers tell you how to build a generic linked list of classes
p6999
aVIf you ever need to build a generic linked list of records, you cannot do so at present:
p7000
aVdoes not compile
p7001
aVNor does:
p7002
aVI believe that the reason for this is that the single-pass compiler does not support forward declarations of methods
p7003
aVThis is actually more of a practical problem for operator overloading than for generics because classes can be used for generic linked lists
p7004
as(dp7005
g7
V505088
p7006
stp7007
a((dp7008
g2
(lp7009
VI'm struggling to understand exactly what I need but you seem to want to map between two coordinate spaces in GDI
p7010
aVWhilst you can use the fully general , I suspect you are better off with the following functions:
p7011
aV,
p7012
ag7012
aVThe MSDN documentation also includes a full list of functions related to coordinate space transformations
p7013
as(dp7014
g7
V505088
p7015
stp7016
a((dp7017
g2
(lp7018
VSince they are stored in a single file which presumably does little else (well done
p7019
aV, there's no reason not to try it out
p7020
aVI predict it won't make any discernible difference to performance, but I guess it depends on what else you are doing in your app
p7021
as(dp7022
g7
V505088
p7023
stp7024
a((dp7025
g2
(lp7026
VIn order to get the shield icon onto the buttons of a system provided message dialog you are going to need to handle a callback from the dialog
p7027
aVFor example, I will illustrate with the  API introduced in Vista
p7028
aVThe basic dialog allows you to specify the main icon, but not the shield icon for the buttons on the dialog
p7029
aVTo do this you need to provide a callback function that responds to the  notification
p7030
aVThat callback might look like this:
p7031
aVThe magic is contained in the  message
p7032
aVAs far as I can tell, this is the way you are intended to achieve the effect you desire
p7033
as(dp7034
g7
V505088
p7035
stp7036
a((dp7037
g2
(lp7038
VYes they are both correct and both the same
p7039
aVTypically you would have created  in the constructor and the destructor would read:
p7040
aVAlways remember to include  when you declare your destructor, as you have done
p7041
aVIf you forget this then it won't run
p7042
aVThat's a classic source of memory/resource leaks
p7043
aVYou should call  as the first action in a constructor and as the last action of the destructor
p7044
aVThis arranges that creation and destuction happen in reverse order which is invariably what is needed
p7045
aVFor example you might create two objects, A and B, and B has a reference to A which is passed in to the constructor of B
p7046
aVClearly you have to create A first:
p7047
aVWhen destroying you want to destroy B first in case it does anything with the reference to A that it holds
p7048
aVIf you did it the wrong way round, B would be calling methods on A which had already been destroyed
p7049
aVSo your destructor reads:
p7050
as(dp7051
g7
V505088
p7052
stp7053
a((dp7054
g2
(lp7055
VWell, it's unusual to have a form that you don't show
p7056
aVNormally you separate your business logic from the UI
p7057
aVTo answer your question, I don't think you need to call ShowModal at all
p7058
aVJust define a method on the form class and call that
p7059
aVUltimately forms are just Delphi objects and you can use them as such
p7060
aVIf you don't want to show them, don't call ShowModal or Show
p7061
as(dp7062
g7
V505088
p7063
stp7064
a((dp7065
g2
(lp7066
VYou ask:
p7067
aVDoes the following code work only by
p7068
aVluck
p7069
aVWell, yes, you are relying on implementation specific details
p7070
aVIn fact the correct way to write it is perfectly natural and simple:
p7071
aVYou need to declare an intermediate type for the row, TDoubleArray, so that you can perform the assignment to Temp in the swap routine
p7072
aVA 2D constant size array
p7073
aVis a contiguous block of memory
p7074
aVA 2D dynamically size array as you have is not
p7075
aVIndeed it can even be ragged in the sense that the rows have different numbers of columns
p7076
aVSo you can have, say, a triangular matrix
p7077
as(dp7078
g7
V505088
p7079
stp7080
a((dp7081
g2
(lp7082
VYou don't have to do anything special
p7083
aVThe underlying Windows API is the same irrespective of whether you are on 32 or 64 bit
p7084
aVData types that hold pointer sized things, e
p7085
ag217
aVwindow handles, float between 32 and 64 bit depending on which platform is targeted
p7086
aVFor that reason they are declared as  for P/Invoke
p7087
aVSo long as you get that right, your code will work on both platforms
p7088
as(dp7089
g7
V505088
p7090
stp7091
a((dp7092
g2
(lp7093
VIf you use  and there's no need for casting
p7094
aVPerformance should be fine for the usage that you describe
p7095
aVInserting is more demanding than adding to the end because you need to shift the items after the insertion point up the list
p7096
aVSo long as you avoid  and opt for a more sensible allocation strategy dynamic arrays are equivalent to all of the  like classes
p7097
aVOn occasions I have had problems with performance and memory fragmentation when trying to maintain large lists as contiguous blocks of memory
p7098
aVThen I have resorted to a sub-allocation scheme
p7099
aVBut since your lists contain object references which are essentially pointers, you already have implicit sub-allocation
p7100
aVIt's all somewhat speculative and you really need to measure \u2013 otherwise we can only guess
p7101
as(dp7102
g7
V505088
p7103
stp7104
a((dp7105
g2
(lp7106
VYou are into reverse engineering territory here
p7107
aVI think that if I were you I would just step through in the CPU view of the debugger, following a call to the method of interest, and find the entry point address
p7108
aVI'd subtract it from the base address of the DLL and that would be the offset
p7109
aVThen to calculate the address at runtime you just add the offset it to the base address of the DLL in memory at that time
p7110
aVYou can find out the base address with calls to LoadLibrary or GetModuleHandle
p7111
aVWhy hard code the offset
p7112
aVWell, since you can't modify your DLL it doesn't seem to be too limiting
p7113
aVIf hard coding the offset is not viable then there are other means of locating entry points, but I must admit I'm not the world's greatest expert on that
p7114
aVFinally, when you implement the replacement method, you will need to replace it with a global function/procedure with an extra parameter, the first parameter, which takes the place of Self
p7115
as(dp7116
g7
V505088
p7117
stp7118
a((dp7119
g2
(lp7120
VNo that it not correct
p7121
aVYou can add an interface to any class you like as follows:
p7122
as(dp7123
g7
V505088
p7124
stp7125
a((dp7126
g2
(lp7127
VThis is most easy to do with the win32gui module and its friends, win32api and win32con
p7128
aVThere's no need to write your own ctypes wrappers to the Windows API
p7129
aVThe simplest Petzold style app comes out something like this:
p7130
as(dp7131
g7
V505088
p7132
stp7133
a((dp7134
g2
(lp7135
VWhat you are describing is known as a Foreign Function Interface (FFI) and is not for the feint of heart
p7136
aVI would not recommend that you attempt to develop your own FFI from scratch
p7137
aVA very common choice of FFI is libffi
p7138
aVThe Wikipedia page for libffi lists the following projects as users of libffi:
p7139
aVPython, Dalvik, F-Script, PyPy,
p7140
aVPyObjC, RubyCocoa, JRuby, Rubinius,
p7141
aVMacRuby, gcj, GNU Smalltalk, IcedTea,
p7142
aVCycript, Pawn, Squeak, Java Native
p7143
aVAccess, PLT Scheme, Embeddable
p7144
aVCommon Lisp and Mozilla
p7145
aVI personally make extensive use of libffi through a Python/ctypes interface to my Delphi DLL, although thankfully Python/ctypes wraps it up at quite a high level
p7146
aVIf I were setting off down the route you describe, I would strongly consider using libffi
p7147
aVIf you take that route you'll have to do some work to be able to use it from Delphi since it is written in C/asm
p7148
as(dp7149
g7
V505088
p7150
stp7151
a((dp7152
g2
(lp7153
VWell, that's not a menu, it's a tree view
p7154
aVYou can use the WinForms tree view, but out of the box it won't look exactly like the Explorer tree view
p7155
aVYou need to apply the Explorer window theme
p7156
aVYou need to P/Invoke to call  passing the window handle of the tree and use "explorer" as the theme
p7157
aVPaste the following code into a new class in your project, compile, and use this custom control instead of the built-in  control
p7158
aVNote that this trick also works exactly the same way for the  control
p7159
as(dp7160
g7
V505088
p7161
stp7162
a((dp7163
g2
(lp7164
VTwo things spring to my mind:
p7165
aVCall grep with the  option so that only the text that matches is emitted
p7166
aVDepending on your regex, this may or may not help
p7167
aVWrite a very simple executable, call it trunc, which reads from stdin line by line and output the first n characters to stdout
p7168
aVThen simply pipe the output from grep to trunc
p7169
aVThe latter option is relatively simple
p7170
aVIf you didn't want to go the whole hog and produce a proper native exe it could be quite easily achieved with a Perl/Python/Ruby etc
p7171
aVscript
p7172
as(dp7173
g7
V505088
p7174
stp7175
a((dp7176
g2
(lp7177
VYou have to declare procedures before routines that call them
p7178
aVAlthough you haven't shown how the other routines are defined, I deduce that they are declared after the routine you have shown
p7179
aVSo you can simply re-order your code so that add, multiply, subtraction and division are defined before they procedure that calls them
p7180
aVSo this will work:
p7181
aVBut this will not compile:
p7182
aVPascal and its variants are compiled in a single pass and if the compiler does not know about a routine at the point at which it is mentioned, it cannot continue
p7183
aVPascal does support co-routines where A calls B and B calls A, by the use of a *forward declaration`
p7184
aVFor example:
p7185
aVNaturally this is an infinite loop as written which will terminate with a stack overflow (how appropriate
p7186
aVbut there are of course real examples where this is necessary
p7187
aVHowever, forward declarations are rarely needed and should be avoided if possible since they increase complexity
p7188
aVInvariably a solution can be found by simply re-ordering your declarations
p7189
aVAs a final aside, the ordering constraint that declaration occurs before use is explicitly mentioned in Brian Kernighan famous article, Why Pascal is Not My Favorite Programming Language
p7190
as(dp7191
g7
V505088
p7192
stp7193
a((dp7194
g2
(lp7195
VUsually in a GUI there is a message loop for handling asynchronous input messages
p7196
aVAssuming you have such a thing, the normal approach is to post a message to this queue which will result in the control being deleted
p7197
aVBecause the message queue is pumped after your event handler completes you have no problems
p7198
as(dp7199
g7
V505088
p7200
stp7201
a((dp7202
g2
(lp7203
VIt sounds like you haven't initialized COM, which you are required to do by calling
p7204
aVFrom the documentation:
p7205
aVCoInitializeEx must be called at least
p7206
aVonce, and is usually called only once,
p7207
aVfor each thread that uses the COM
p7208
aVlibrary
p7209
aVMultiple calls to
p7210
aVCoInitializeEx by the same thread are
p7211
aVallowed as long as they pass the same
p7212
aVconcurrency flag, but subsequent valid
p7213
aVcalls return S_FALSE
p7214
aVTo close the COM
p7215
aVlibrary gracefully on a thread, each
p7216
aVsuccessful call to CoInitialize or
p7217
aVCoInitializeEx, including any call
p7218
aVthat returns S_FALSE, must be balanced
p7219
aVby a corresponding call to
p7220
aVCoUninitialize
p7221
as(dp7222
g7
V505088
p7223
stp7224
a((dp7225
g2
(lp7226
VYou are looking for :
p7227
aVRetrieves a handle to a window that
p7228
aVhas the specified relationship
p7229
aV(Z-Order or owner) to the specified
p7230
aVwindow
p7231
as(dp7232
g7
V505088
p7233
stp7234
a((dp7235
g2
(lp7236
VYou can't marshal std::string from C++ to C#
p7237
aVInstead either use a zero-terminated string marshalled with StringBuilder, or return a BSTR
p7238
aVThe BSTR approach is quite simple
p7239
aVIf you prefer zero-terminated string then look on the web for sample P/Invokes from Win32 APIs, e
p7240
ag217
aVGetWindowText()
p7241
aVYou are exporting from C++ with cdecl calling convention, but using stdcall in the C# code
p7242
aVYou'll need to match those up once you have sorted the data type marshalling out
p7243
aVIt doesn't matter which you use, so long as it's the same at both ends
p7244
aVYou will also need to broach the fact that your C++ code uses char (8 bit encoding) and C# uses Windows native UTF-16
p7245
aVIf it was me, I'd do it with a BSTR, as I outline in this answer to another question
p7246
as(dp7247
g7
V505088
p7248
stp7249
a((dp7250
g2
(lp7251
VI believe you will be best served by finding an existing library containing a general tree implementation which you can then re-use to serve your needs
p7252
aVTo give you an idea why, here is some code I wrote to illustrate the most simple operation on the most simple tree structure imaginable
p7253
aVNote: I have not tested this code and so cannot vouch for its correctness
p7254
aVI expect it has defects
p7255
aVAll this does is add an new node to the tree
p7256
aVIt gives you little control over where in the tree the node is added
p7257
aVIf simply adds a new node as the last sibling of a specified parent node
p7258
aVTo take this sort of approach you would likely need to deal with:
p7259
aVInserting after a specified sibling
p7260
aVActually this is quite a simple variant of the above
p7261
aVRemoving a node
p7262
aVThis is somewhat more complex
p7263
aVMoving existing nodes within the tree
p7264
aVWalking the tree
p7265
aVConnecting the tree to your VST
p7266
aVIt's certainly feasible to do this, but you may be better advised to find a 3rd party library that already implements the functionality
p7267
as(dp7268
g7
V505088
p7269
stp7270
a((dp7271
g2
(lp7272
VClearly if the sub-window has not title and its classname is different every time you have but one method remaining
p7273
aVYou are first going to have to find the top level window of this app using either EnumWindows or FindWindowEx, the latter if you can identify it by class name and/or window title
p7274
aVOnce you have the top level window you can walk through the children to locate the sub-window that you are looking for
p7275
aVPresumably you already know the relationships between the top level window and the sub-window you are targetting
p7276
aVIn any case Spy++ can tell you this
p7277
as(dp7278
g7
V505088
p7279
stp7280
a((dp7281
g2
(lp7282
VThe default calling convention for DLLImport is stdcall, but the default of your C++ code is cdecl
p7283
aVThe error message you have seen is what is shown when the calling conventions don't match
p7284
aVThe parameter stack cleanup requirements are different for these two calling conventions, and the P/Invoke marshaller detects and reports this
p7285
aVThe fix is to make your calling conventions match
p7286
aVFor example you could change your P/Invoke like so:
p7287
aVThe other option is to change your C++:
p7288
aVClearly you should only do one of these
p7289
aVIf you change both C# and C++ you'll have the same problem in reverse
p7290
aVIf I were you I would leave the C++ code as cdecl and change the C# to match
p7291
as(dp7292
g7
V505088
p7293
stp7294
a((dp7295
g2
(lp7296
VThe following program runs perfectly and does not result in a stack overflow error
p7297
aVIt produces the following output:
p7298
aVThe penultimate apparently blank line is in fact the directory named Alt+255
p7299
aVConsequently I believe that your problem is not related to the code you have shown and is in fact elsewhere in some code that you have not presented to us
p7300
aVI'm running on Windows 7 with VS 2010 Express targeting
p7301
aVnet 3
p7302
aV5
p7303
aVNow that your update shows all your code, I can see what is happening
p7304
aVThe
p7305
aVnet code is presumably trimming the directories and so the folders with white space get lost
p7306
aVSo  is trimmed to
p7307
aVI found the following trivial modification avoided the infinite loop:
p7308
aVAdding a trailing path separator stops the trimming that appears to occur in the call to DirectoryInfo
p7309
aVIn the example above this means that  is passed to DirectoryInfo which yields the expected results
p7310
aVI guess you should probably use a routine that only adds a trailing path separator if one is not already present
p7311
aVAnd you may want to avoid hardcoding the @"\u005c" as path separator, but that's for you to work out now that you know what the underlying cause of your problem is
p7312
as(dp7313
g7
V505088
p7314
stp7315
a((dp7316
g2
(lp7317
VI'd probably do it with a COM BSTR and avoid having to mess with buffer allocation
p7318
aVSomething like this:
p7319
aVC++
p7320
aVC#
p7321
aVBSTR is the native COM string type
p7322
aVThe advantage of using it here is that the memory can be allocated on the native side of the interface (in C++) with the COM allocator, and then destroyed on the managed side of the interface with the same allocator
p7323
aVThe P/Invoke marshaller knows all about BSTR and handles everything for you
p7324
aVWhilst you can solve this problem by passing around buffer lengths, it results in rather messy code, which is why I have a preference for BSTR
p7325
aVFor your second question, about P/Invoking , I think you'll find what you need from Chris Taylor's answer to another question here on Stack Overflow
p7326
as(dp7327
g7
V505088
p7328
stp7329
a((dp7330
g2
(lp7331
VYou have clarified that you are trying to read items from a list view control in a 32 bit process into a different 64 bit process
p7332
aVI have seen many questions on this topic in various forums and not one ever seemed to achieve a successful outcome
p7333
aVI think your best option is to create a 32 bit executable which will be able to read out of the other program's list view
p7334
as(dp7335
g7
V505088
p7336
stp7337
a((dp7338
g2
(lp7339
VYou need the Windows API function
p7340
aVEDIT
p7341
aVInspired by @Free Consulting, the above API is what you would use in an older non-Unicode Delphi
p7342
aVAs @Free Consulting correctly points out, the new versions of Delphi offer extensive code page translation services
p7343
aVAs a more modern variant of the old-style Pascal I/O, you could use a TStringList saved with a specified encoding
p7344
as(dp7345
g7
V505088
p7346
stp7347
a((dp7348
g2
(lp7349
VA TImage does not have a window associated with it and that's the difference between it and the panel
p7350
aVAdd a panel, and put the image inside the panel, i
p7351
ag192
aVthe image's parent is the panel
p7352
aVThen you can bring the image to the front by bringing the panel to the front
p7353
aVDid you think about hiding your VST
p7354
as(dp7355
g7
V505088
p7356
stp7357
a((dp7358
g2
(lp7359
VYou are almost surely reading registry settings of a different user
p7360
aVThe service likely runs as one of the built-in service user accounts: SYSTEM, LOCALSERVICE or NETWORKSERVICE
p7361
aVThese are not interactive users
p7362
aVYour design is fundamentally flawed and I suspect you will need to move these settings into a file which is not part of a user profile
p7363
as(dp7364
g7
V505088
p7365
stp7366
a((dp7367
g2
(lp7368
VA virtual function is one where the callee decides the behaviour
p7369
aVA non-virtual function is one where the caller decides the behaviour
p7370
aVIs that concise enough
p7371
as(dp7372
g7
V505088
p7373
stp7374
a((dp7375
g2
(lp7376
VWhen demonstrating with a concrete example how not to implement a sort routine
p7377
as(dp7378
g7
V505088
p7379
stp7380
a((dp7381
g2
(lp7382
VYou report that the line:
p7383
aVresults in two errors:
p7384
aVThe only explanation that makes sense is that:
p7385
aVis a function or procedure which expects parameters \u2013 the first error
p7386
aVall the extra 1 parameters result in the second error
p7387
aVThe following code behaves exactly as you report in your question and in comments to RRUZ's deleted answer:
p7388
aVI can't think what else could explain what you report
p7389
as(dp7390
g7
V505088
p7391
stp7392
a((dp7393
g2
(lp7394
VI don't believe this is possible in the VCL
p7395
aVAs I understand it the MDI form is assumed to be the main form (Application
p7396
aVMainForm)
p7397
aVI imagine the underlying Windows routines will not have any such assumption, but I think the VCL will not let you do this without some serious hacking
p7398
aVAt various points in the VCL framework, the important MDI messages are sent to
p7399
aVNow,  is the MDI container, but for some reason the container for the main form has been singled out
p7400
as(dp7401
g7
V505088
p7402
stp7403
a((dp7404
g2
(lp7405
VThat code works perfectly for me in my app
p7406
aVBy that I mean that I have the same code in my app, with the sole exception that I am not setting
p7407
aVMy guess is that somehow the images in your image list have lost their alpha channel
p7408
aVI'm surprised to see that you set  because I believe it has no effect for images with alpha
p7409
as(dp7410
g7
V505088
p7411
stp7412
a((dp7413
g2
(lp7414
VI don't believe that using WaitForMultipleObjects rather than CoWaitForMultipleHandles will result in memory leaks
p7415
aVWhich function you use is really up to you but should have no impact on whether or not you leak
p7416
aVTo solve this I think you need to get some detailed diagnostics about your leaks
p7417
as(dp7418
g7
V505088
p7419
stp7420
a((dp7421
g2
(lp7422
VHit test messages doesn't seem to me to be the appropriate way to do this
p7423
aVFor example, what if the user closes the form through the system menu, or through the Alt+F4 shortcut
p7424
aVI think that you should be responding to  messages with
p7425
aVWindows Aero is fundamentally different when it comes to the handling of the non-client area which explains why it works in 2000/XP and when you disable DWM
p7426
aVBut using  works in all versions of Windows
p7427
aVNote that you need to read the MSDN documentation for  quite carefully because the message parameters contain extra information that needs to be masked out
p7428
aVTo detect the close button you need code like this:
p7429
aVIf you want to change the behaviour when the user closes the form, why don't you handle the  event
p7430
as(dp7431
g7
V505088
p7432
stp7433
a((dp7434
g2
(lp7435
VYou've got two options:
p7436
aVWrite your own dialog form
p7437
aVIntercept the Windows messages directed to the dialog and set the position when the dialog is first shown
p7438
aVThe latter of these is probably easiest done by avoiding  altogether and P/Invoking to the native message dialog API
p7439
aVThat said, I can't imagine why you'd want to avoid using the system default behaviour
p7440
as(dp7441
g7
V505088
p7442
stp7443
a((dp7444
g2
(lp7445
VThe difference between an Inf and any finite value is either Inf or -Inf
p7446
aVThat's part of the IEEE754 specification
p7447
aVSince  uses subtraction this explains the behaviour
p7448
aVHere's the relevant table from the Intel x86 documentation for FSUB:
p7449
aVTo solve your problem you are going to need special case handling for Inf
p7450
as(dp7451
g7
V505088
p7452
stp7453
a((dp7454
g2
(lp7455
VI think there's a little confusion here
p7456
aVThe greyed out drop-down is title "Visual Styles and colors" in my English version of VS2008
p7457
aVBeing greyed out means that you can't modify its value, but it still reports that the resulting app will use "Windows Native/Default"
p7458
aVWhen you go on and create the app and run it, themes are fully supported
p7459
aVFor the other application type options (single document, multiple document, multiple top-level documents), and select other non-system themes
p7460
aVThe list is: Office 2003, VS 2005, Office 2007 of various different colors
p7461
aVSo whilst you don't get these non-standard Office themes, your app will have visual styles and themes as determined by the Windows settings
p7462
as(dp7463
g7
V505088
p7464
stp7465
a((dp7466
g2
(lp7467
VAccording to the C# documentation for out:
p7468
aVThe out keyword causes arguments to be
p7469
aVpassed by reference
p7470
aVThis is similar
p7471
aVto the ref keyword, except that ref
p7472
aVrequires that the variable be
p7473
aVinitialized before being passed
p7474
aVSo, use a  parameter when you need to pass a value in to the method, as well as receive a value from the method
p7475
aVUse an  parameter when the flow of information is only from the method to the caller
p7476
aVTo complete the story there is the unadorned value parameter which passes information in to the method but cannot receive information back from the method
p7477
aVI don't really buy the idea that  and  are only to be used when you need to return more than one item from a method
p7478
aVI always prefer using  to return values from methods that have side-effects
p7479
aVTo me that's the answer to your question
p7480
aVReturn a single value from a function through the function return value if the method does not have side-effects, and if the name of the method is a noun matching the meaning of the return value
p7481
aVOtherwise return values through  or  parameters
p7482
as(dp7483
g7
V505088
p7484
stp7485
a((dp7486
g2
(lp7487
VIt uses a hash like practically every other dictionary implementation
p7488
as(dp7489
g7
V505088
p7490
stp7491
a((dp7492
g2
(lp7493
VYou don't need to search for all combinations
p7494
aVA rough outline of a simple naive implementation would be:
p7495
aVConsider each integer i in the range [1
p7496
aVtrunc(sqrt(p))]
p7497
aVCalculate sqrt(p-i^2) and check if it is an integer
p7498
aVIf so you are done
p7499
aVIf not continue to the next i
p7500
aVWould this suffice for your needs
p7501
aVIt will work fine for relatively small p, but obviously would be slow for the sort of large primes used in cryptography
p7502
as(dp7503
g7
V505088
p7504
stp7505
a((dp7506
g2
(lp7507
VThe behaviour you describe I can reproduce only by passing a bogus value for the OwnerHwnd to the dialog's Execute method
p7508
aVThis window handle is then passed on to the underlying Windows common control and in fact you will have other problems with your dialogs if you do not set it to the handle of the active form when the dialog is shown
p7509
aVFor example when I call Execute and pass , the dialog always appears on the same window, in a rather bizarre location, irrespective of where my main form is
p7510
aVWhen I call Execute and pass the handle to my main form, the dialog appears on top of the main form, slightly shifted to the right and down
p7511
aVThis is true no matter which monitor the form is on
p7512
aVI am using Delphi 2010 and I don't know whether or not you have the overloaded version of Execute available on your version of Delphi
p7513
aVEven if you don't have that available, you should still be able to create a derived class that will pass a more sensible value for OwnerHwnd
p7514
aVAlthough I don't have conclusive 100% evidence that this is your problem, I think that this observation will lead you to a satisfactory resolution
p7515
as(dp7516
g7
V505088
p7517
stp7518
a((dp7519
g2
(lp7520
VI have found FastMM to be exceedingly reliable in this regard
p7521
aVIf you run in release mode you'll have no problems with calling methods on freed objects 99
p7522
aV9% of the time
p7523
aVThe 0
p7524
aV1% of the time will invariably occur only on your most valuable customers machine
p7525
aVSo, I'd bet money that this is a problem
p7526
aVIt's actually quite easy to track down because FastMM gives you all the call stacks that show exactly how it occurred
p7527
aVYou just need to follow through the details carefully
p7528
aVNow, you may well ask, how can I call a method on an object that has been freed
p7529
aVWell, when you free an object, you return the memory to the memory manager
p7530
aVBut the memory manager typically holds on to that memory and waits for an opportune moment to re-use it
p7531
aVCrucially it doesn't immediately return it to the system because doing so is expensive (it takes a significant amount of time)
p7532
aVThis is what makes the memory manager fast, but it also leads to errors such as calling methods on free objects being masked
p7533
aVIf the memory had been returned to the system then such an action would result in a real access violation
p7534
aVThis is what I mean by saying the most of the time, with the memory manager in release mode, such a bug will not surface
p7535
aVThis is one of the best features of FastMM in my view and heeding this warning will save you pain in the future
p7536
aVTrying to track down such a problem in the field is exceedingly difficult
p7537
aVFixing it with the information FastMM has provided is usually simple
p7538
as(dp7539
g7
V505088
p7540
stp7541
a((dp7542
g2
(lp7543
VIn  right near the top, the code reads:
p7544
aVIf you comment this out then the behaviour is closer to what you are looking for
p7545
aVThe hint window won't show again if you move the mouse within the same cell, but if you click then it will
p7546
aVI can't seem to find any way to make the hint window show in the same cell without that mouse click though
p7547
as(dp7548
g7
V505088
p7549
stp7550
a((dp7551
g2
(lp7552
VYou just need to call  when you want the paint box to re-draw itself
p7553
aVOr am I misunderstanding your question
p7554
as(dp7555
g7
V505088
p7556
stp7557
a((dp7558
g2
(lp7559
VMy guess is that the files created on Windows have a BOM that is confusing matters
p7560
as(dp7561
g7
V505088
p7562
stp7563
a((dp7564
g2
(lp7565
VWell, my app has forms with far more than that on and so I feel your pain
p7566
aVI would avoid scroll bars
p7567
aVIt's much harder for the user to be sure that they have seen everything when you have scroll bars
p7568
aVI'd recommend page controls (i
p7569
ag192
aVtabs)
p7570
aVI'm sure if you try hard enough you'll find some sort of grouping that makes sense
p7571
aVThe other approach you sometimes see used which is similar to a page control is pages but with Next/Back buttons
p7572
aVThe problem with this is that it is needlessly linear
p7573
aVIt's harder to advise on validation
p7574
aVIf the validation only depends on the value of the single value in question, then validate on entry
p7575
aVConsider using colour highlighting rather than dialog boxes
p7576
aVOnly show hard fail dialogs when the user tries to dismiss the dialog
p7577
aVValidation for values whose validity depend on other user input is harder
p7578
aVI'd postpone that to dialog dismiss time
p7579
as(dp7580
g7
V505088
p7581
stp7582
a((dp7583
g2
(lp7584
VIt is because you are creating a Unicode window with CreateWindowExW but then calling the ANSI DefWindowProcA
p7585
aVYou are passing Unicode strings which typically have zero for every other byte since your text is in the ASCII range which explains what you observe
p7586
aVThe solution
p7587
aVCall DefWindowProcW instead
p7588
aVActually, a better solution would be to use win32gui instead which wraps this up a bit more for you
p7589
as(dp7590
g7
V505088
p7591
stp7592
a((dp7593
g2
(lp7594
VCall the Windows  API instead and pass in the handle to the active form
p7595
aVActually, my code uses  all the time which I am therefore sure is a reasonable and simple approach
p7596
aVThis will have the benefit of being the system native dialog rather than the home-grown Delphi version
p7597
aVIt supports clipboard operations also
p7598
aVIf you want to get very fancy then you can use the Vista task dialog, but that's much more complex and you clearly don't need it for such a simple dialog
p7599
as(dp7600
g7
V505088
p7601
stp7602
a((dp7603
g2
(lp7604
VLOCAL SERVICE doesn't have rights to network shares
p7605
aVYou need to run your service as a user with appropriate permissions, most likely a domain user with rights to the shares
p7606
as(dp7607
g7
V505088
p7608
stp7609
a((dp7610
g2
(lp7611
VI think if I wanted an object-like thing that didn't have any means of being constructed I'd probably use an interface with the implementing object contained in the implementation section of a unit
p7612
aVI'd expose the interface by a global function (declared in the interface section)
p7613
aVThe instance would be tidied up in a finalization section
p7614
aVTo get thread-safety I'd use either a critical section (or equivalent) or possibly carefully implemented double-checked locking but recognising that naive implementations only work due to the strong nature of the x86 memory model
p7615
aVIt would look something like this:
p7616
as(dp7617
g7
V505088
p7618
stp7619
a((dp7620
g2
(lp7621
VThe answers to this question lie in the very useful Window Features MSDN topic
p7622
aVThe pertinent information is:
p7623
aVAn overlapped or pop-up window can be
p7624
aVowned by another overlapped or pop-up
p7625
aVwindow
p7626
aVBeing owned places several
p7627
aVconstraints on a window
p7628
aVAn owned window is always above its owner in the z-order
p7629
aVThe system automatically destroys an owned window when its owner is
p7630
aVdestroyed
p7631
aVAn owned window is hidden when its owner is minimized
p7632
aVThe main form in your app is the owner (in Windows terminology rather than Delphi terminology) of the other popup windows
p7633
aVThe first bullet point above implies that the owned windows always appear above the main form (the owner)
p7634
aVTry creating an app with 3 forms and show them all
p7635
aVThe
p7636
aVdpr would look like this:
p7637
aVYou will see that the main form is always underneath the other two forms, but these other owned forms can be above or below each other
p7638
aVWhen you minimize the main form they all disappear
p7639
aVYou could if you want make all of your forms top-level unowned windows:
p7640
aVAnd like wise for TPopupForm2 in my example
p7641
aVThis would result in all 3 windows having taskbar buttons
p7642
aVOne other approach is to revert to the pre-Vista way of things and make the Application's hidden window be the top-level owner window
p7643
aVYou do this by making sure that Application
p7644
aVMainFormOnTaskbar is False
p7645
aVSkip all the CreateParams code and you'll now have a single window on the taskbar and any of your windows can be above any other because the top-level owner window is the hidden window Application
p7646
aVHandle
p7647
aVOf course the downside is that you lose your Aero Peek
p7648
aVSo, I guess what you need to do is to make the main form appear on the taskbar as usual, but ensure that the other forms are not owned (in the Windows sense) by the main form
p7649
aVBut they need to be owned to avoid having them in the taskbar
p7650
aVSo you can make the hidden application window be the owner using the CreateParams method, like so:
p7651
aVAlthough you state otherwise in the comments, when I do this I find that the popup form is indeed hidden when I minimize the main form
p7652
aVAnd it is shown again when the main form is restored
p7653
aVThus I think this does solve your problem completely
p7654
as(dp7655
g7
V505088
p7656
stp7657
a((dp7658
g2
(lp7659
VIt's the same in Lazarus as in any Windows development environment
p7660
aVYou need to add yourself into the chain of clipboard viewers
p7661
aVThere are many articles on the web describing how to do it
p7662
aVFor example:
p7663
aVhttp://delphi
p7664
aVabout
p7665
aVcom/od/windowsshellapi/a/clipboard_spy_2
p7666
aVhtm
p7667
aVhttp://www
p7668
aVdeveloper
p7669
aVcom/net/csharp/article
p7670
aVphp/3359891/C-Tip-Monitoring-Clipboard-Activity-in-C
p7671
aVhtm
p7672
aVhttp://www
p7673
aVradsoftware
p7674
aVcom
p7675
aVau/articles/clipboardmonitor
p7676
aVaspx
p7677
as(dp7678
g7
V505088
p7679
stp7680
a((dp7681
g2
(lp7682
VThis is perfectly possible without recourse to any of the hacks you describe
p7683
aVFor example:
p7684
aVYou can put pretty much anything you like in
p7685
aVOn the other side create a Delphi app and add the following code to call the DLL:
p7686
aVThis behaves just perfectly
p7687
aVSo, I'm afraid it's not obvious what your problem is
p7688
aVIf you can supply more details, then please do so
p7689
as(dp7690
g7
V505088
p7691
stp7692
a((dp7693
g2
(lp7694
VYou want:
p7695
aVBy the way, there's no  in team
p7696
as(dp7697
g7
V505088
p7698
stp7699
a((dp7700
g2
(lp7701
VNo, you just have to follow the rules and define your message text files, build them into resources, link them to your app etc
p7702
aVThe example provided at MSDN leads you through everything you need to do
p7703
as(dp7704
g7
V505088
p7705
stp7706
a((dp7707
g2
(lp7708
VIt's all about reparse points
p7709
aVThis Code Project article should give you the information you need
p7710
aVYou'll have to translate it into Python with either ctypes or win32api
p7711
as(dp7712
g7
V505088
p7713
stp7714
a((dp7715
g2
(lp7716
VA couple of things jump out at me
p7717
aVFirst of all I don't see why you need to use unsafe
p7718
aVSecondly, you probably have a calling convention mismatch, cdecl in the C++ and stdcall in the C#
p7719
aVI'd do it like this:
p7720
aVC++
p7721
aVC#
p7722
aVI'm not sure how big the enum is on the C++ size
p7723
aVThat's why I've put an explicit MarshalAs in the C# code
p7724
aVIf it's just a single byte, then use UnmanagedType
p7725
aVU1 instead
p7726
aVI trust you get the idea
p7727
aVIf your C++ function treats its parameter as an in/out parameter then using ref on the C# side is correct
p7728
aVIf its actually an out parameter then change the code to be like this:
p7729
as(dp7730
g7
V505088
p7731
stp7732
a((dp7733
g2
(lp7734
VPlease don't do this
p7735
aVThe user is used to where these buttons appear
p7736
aVIf you try to change their layout then you will just make you app feel wrong
p7737
aVIf you have to do this then should make sure you use the legacy file dialogs (which will make your dialogs look even more odd on Vista/7)
p7738
aVUse the lpfnHook field in the  struct to obtain hooks in to the dialog procedure
p7739
aVRespond to the CDN_INITDONE notification and move the buttons around with MoveWindow or SetWindowPos
p7740
aVYou'll have to hunt for the button window handles
p7741
aVBut really, please don't do this, you'll just make your app worse
p7742
as(dp7743
g7
V505088
p7744
stp7745
a((dp7746
g2
(lp7747
VIn the menus select Tools | Editor Options
p7748
aVSelect the Code Insight page
p7749
aVMake sure that Code completion is checked
p7750
aVYou can invoke it from the keyboard with CTRL+space
p7751
aVNote: This is all from Delphi 6 but Delphi 7 is pretty much the same as I recall
p7752
as(dp7753
g7
V505088
p7754
stp7755
a((dp7756
g2
(lp7757
VRaymond Chen has the answer, based on the Tool Help Library
p7758
aVFor the sake of completeness, his sample code is as follows:
p7759
as(dp7760
g7
V505088
p7761
stp7762
a((dp7763
g2
(lp7764
VThis is a relatively simple misunderstanding
p7765
aVOverriding is a means to change behaviour of a routine in a subclass
p7766
aVAn overridden method has the same parameters as the original
p7767
aVOverloading is when you have methods with the same name but different parameters
p7768
aVThe compiler works out which one you mean by matching the parameters
p7769
aVI can't see enough of your code to know if your basic design is sound, but on the face of it it would seem that you need to use overloading
p7770
as(dp7771
g7
V505088
p7772
stp7773
a((dp7774
g2
(lp7775
VThis is weird, as you know
p7776
aVBut, so long as the method is static and doesn't refer to Self, then this will work
p7777
aVOf course, such a thing is better known as a class method
p7778
aVPerhaps that's what you want
p7779
aVEDIT
p7780
aVYou edited your question
p7781
aVApparently you know all about static methods
p7782
aVYou don't want to call a method on an uninitialized object
p7783
aVIn fact, you now state that you want the act of calling a method on an un-initialized object instance to result in the instance being created and the method being called
p7784
aVThis is not possible
p7785
aVThere's no magic anywhere that calls constructors for you
p7786
as(dp7787
g7
V505088
p7788
stp7789
a((dp7790
g2
(lp7791
VFirst of all  accepts
p7792
aVSince 32 bit versions of the OS do not support >32 cores, this means that you are talking about 64 bit OS
p7793
aVAnd so the actual limit for  is therefore 64
p7794
aVAs for how to handle >64 I think the Supporting Systems That Have More Than 64 Processors whitepaper will tell you what you need to know
p7795
aVEDIT
p7796
aVYou state in the comments that your code is 32 bit running on 64 bit OS
p7797
aVAs I understand it, there is limited support for very fine-grained control if you are running inside the 32 bit emulator on a 64 bit OS
p7798
aVThe assumption is that if you want to take advantage of these new capabilities you are expected to stop using the emulator
p7799
as(dp7800
g7
V505088
p7801
stp7802
a((dp7803
g2
(lp7804
VYou could try sympy since you appear to be after symbolic computation and are amenable to using Python
p7805
as(dp7806
g7
V505088
p7807
stp7808
a((dp7809
g2
(lp7810
VThis is how I would do it:
p7811
aVC++
p7812
aVC#
p7813
aVCall it as follows:
p7814
as(dp7815
g7
V505088
p7816
stp7817
a((dp7818
g2
(lp7819
V is not a function, it's an exported value
p7820
aVYou need to use
p7821
aVSee Accessing values exported from dlls
p7822
as(dp7823
g7
V505088
p7824
stp7825
a((dp7826
g2
(lp7827
VIf you don't want your app to be virtualized then you use a manifest to indicate that
p7828
aVIf you use  on your key then all that will happen is that all the writes will fail because your users won't have write access to HKLM
p7829
aVIf you want all your users to share configuration then you'll have to store the configuration in a file rather than the registry
p7830
aVThere's nowhere appropriate in the registry that is shared by all users and allows standard users write access
p7831
as(dp7832
g7
V505088
p7833
stp7834
a((dp7835
g2
(lp7836
VThis is exactly what you would expect when you leave the safety and comfort of 96 or 120 DPI
p7837
aVAlthough Microsoft have been nagging developers for years about high DPI, the standard of support for DPI > 120 is still depressingly poor
p7838
aVApplication developers need to do a lot of testing in order for their applications to work well at a wide range of DPI values
p7839
aVI can see how it happens that applications fail at some DPI values and for a browser which renders all sorts of weird and wonderful content it must be even hard to come up with comprehensive tests
p7840
aVAll the same, this is clearly a bug in Firefox and you should submit a bug report and hope for the best
p7841
aVAs an aside, I recently performed some high DPI testing on my app and took at all the way up to 192 DPI
p7842
aVThe app worked a treat but it looked really weird
p7843
aVDon't try this unless you've got a high resolution monitor because on a small monitor it can be hard to change the settings back to something more manageable
p7844
as(dp7845
g7
V505088
p7846
stp7847
a((dp7848
g2
(lp7849
VHow about something like this:
p7850
as(dp7851
g7
V505088
p7852
stp7853
a((dp7854
g2
(lp7855
VYou could do this in the old days
p7856
aVIt was called a system modal dialog and you used the now obsolete  function
p7857
aVThey were utterly repugnant and so sense and order was restored when Windows NT based versions of Windows took over
p7858
as(dp7859
g7
V505088
p7860
stp7861
a((dp7862
g2
(lp7863
VNo, you can't do this
p7864
aVThe message loop runs in its thread and processes your message queue
p7865
aVThere isn't really any official distinction between background and foreground threads
p7866
aVThe thread that processes your message is typically called the foreground but it's not really any different from any other thread
p7867
aVIt's only convention that leads us to refer to threads foreground or background
p7868
aVUltimately, that main thread with the message loop in has the message loop at the top of its call stack and that's just the way it has to be
p7869
aVIt is possible to start a long running task and get it to frequently process messages, but this way requires a keen understanding of re-entrancy issues and often leads to insanity
p7870
aVIf you want long running background tasks then you probably need threads
p7871
as(dp7872
g7
V505088
p7873
stp7874
a((dp7875
g2
(lp7876
VYour update is no better
p7877
aVIf you want to do this in an RAII style then you need to work a bit harder
p7878
aVThe key is that you need to separate the critical section object which is statically allocated, and the lock which is local to all blocks that need protection
p7879
aVThe following is lifted from Jonathan Dodds but it is a classic pattern
p7880
aVWhilst you could do this with inheritance of CRITICAL_SECTION, I feel encapsulation is more appropriate
p7881
aVNext the lock is defined:
p7882
aVFinally, an example of usage:
p7883
aVThe point is that there is a single instance of the critical section, shared across all threads
p7884
aVThis is what makes a critical section work
p7885
aVIn counterpoint, there may be many instances of , all taken on the same critical section, in simultaneous existence
p7886
aVThis allows the  method to be called by many threads, but have its code is serialized over the lifetime of the  instance taken on the single shared critical section
p7887
as(dp7888
g7
V505088
p7889
stp7890
a((dp7891
g2
(lp7892
VMy advice to you is to stop exporting the variable from the DLL
p7893
aVInstead you should export two functions from your DLL: one to read the variable, and one to write the variable
p7894
as(dp7895
g7
V505088
p7896
stp7897
a((dp7898
g2
(lp7899
VYou can just override the MouseDown and MouseUp methods
p7900
aVRemember to check the value of the Button parameter
p7901
as(dp7902
g7
V505088
p7903
stp7904
a((dp7905
g2
(lp7906
VYou could make this work by adding the IID/GUID as Craig states, and then changing  to:
p7907
aVThis only works with more modern versions of Delphi
p7908
aVI think Delphi 2010 was where the ability to cast an interface to its implementing object was added
p7909
aVHowever, I'd be inclined to avoid this solution and go for something like this:
p7910
aVWhen you find yourself asking an object what type it is, that's usually indicative of a design weakness
p7911
as(dp7912
g7
V505088
p7913
stp7914
a((dp7915
g2
(lp7916
VThe code would benefit from the I/O and the calculation being separated
p7917
aVYou problems are with the calculation
p7918
aVI'd write it something like this:
p7919
aVThis is still a little unpolished and I'm not very happy with the variable names for pay rates, overtime etc
p7920
aVOnce have such a utility function available, then putting it together with the rest of your program becomes a lot easier
p7921
aVThe biggest weakness in your current program is that everything is housed in one giant routine
p7922
aVBreak it down into small pieces and you'll be able to verify those small pieces more readily than hunting for problems in a single large routine
p7923
as(dp7924
g7
V505088
p7925
stp7926
a((dp7927
g2
(lp7928
VI usually see string leaks when they are contained inside other objects that have not been destroyed properly
p7929
aVFor example an object that has not been freed
p7930
aVHowever, you would expect to see that object reported too
p7931
aVThe way to resolve this is to download and use the full version of FastMM and configure it to report stack traces when it detects leaks
p7932
aVWhen you do that you will get a full stack trace of the code that allocated the leaked object and at that point it is usually clear what the problem is
p7933
as(dp7934
g7
V505088
p7935
stp7936
a((dp7937
g2
(lp7938
VThese files are the MS C runtime
p7939
aVIf you don't want to redistribute them then you should just use static linking
p7940
aVYou get static linking with the /MT linker option
p7941
aVOn the other hand, its no real trouble to install the runtime re-distributable
p7942
aVIn fact you should have been doing so before with your older version of Visual Studio, but you were getting away with it because some other programs would have installed it before
p7943
as(dp7944
g7
V505088
p7945
stp7946
a((dp7947
g2
(lp7948
VPolling is a bad idea since it means a busy loop
p7949
aVThe normal way to do this on Windows is with a timer
p7950
aVSee
p7951
as(dp7952
g7
V505088
p7953
stp7954
a((dp7955
g2
(lp7956
VYou need to know the ID of the window to use
p7957
aVI suspect you are passing in an HWND that you got from Spy++
p7958
aVIt looks like you are poking around in another app because if it was your own app then you wouldn't need to call FindWindow, and you'd know the control ID
p7959
aVProbably the easiest way to find this window, once you have got the top-level window from FindWindow, is to call
p7960
as(dp7961
g7
V505088
p7962
stp7963
a((dp7964
g2
(lp7965
V as everyone, including Larry Wall, knows
p7966
as(dp7967
g7
V505088
p7968
stp7969
a((dp7970
g2
(lp7971
VFirst of all, I'm sorry it took me so long to understand your question
p7972
aVThe message I see is when I try this is:
p7973
aVCannot operate on
p7974
aV'Libraries\u005cDocuments' because it is
p7975
aVnot part of the file system
p7976
aVThere's not much more to say
p7977
aVA library is a virtual folder that is an amalgamation of various different real folders
p7978
aVThere's no real way to avoid this error
p7979
aVYou have asked the dialog to return a folder and the user has not selected a folder
p7980
aVThe dialog therefore cannot fulfil its part of the deal
p7981
aVIf you descend further into the folder structure, into real folders, then the dialog will return you a real value
p7982
as(dp7983
g7
V505088
p7984
stp7985
a((dp7986
g2
(lp7987
VYou need to link a manifest to your app that specifies v6 common controls
p7988
aVWebsearch will do the rest for you
p7989
as(dp7990
g7
V505088
p7991
stp7992
a((dp7993
g2
(lp7994
VLook in the  bin\u005cdebug folder under your project directory
p7995
as(dp7996
g7
V505088
p7997
stp7998
a((dp7999
g2
(lp8000
VBuild compiles all source files in the project
p8001
aVMake compiles those that have changed since the last make or build
p8002
aVNote that make is actually a little more complex
p8003
aVA unit, let us say unitA, can require re-compilation during a make even if unitA has not changed
p8004
aVThis happens when unitA uses another unit, unitB, and the interface section of unitB has changed since the last make or build
p8005
aVThe documentation for Build states:
p8006
aVRebuilds all files in your current
p8007
aVproject regardless of whether they
p8008
aVhave changed
p8009
aVBuilding is useful when
p8010
aVyou are unsure which files have
p8011
aVchanged, or if you have changed
p8012
aVproject or compiler options
p8013
aVThe documentation for Make states:
p8014
aVCompiles only those files that have
p8015
aVchanged since the last build, as well
p8016
aVas any files that depend on them
p8017
as(dp8018
g7
V505088
p8019
stp8020
a((dp8021
g2
(lp8022
VThe documentation states:
p8023
aVThe WriteFile function returns when
p8024
aVone of the following conditions occur:
p8025
aVThe number of bytes requested is written
p8026
aVA read operation releases buffer space on the read end of the pipe (if
p8027
aVthe write was blocked)
p8028
aVFor more
p8029
aVinformation, see the Pipes section
p8030
aVAn asynchronous handle is being used and the write is occurring
p8031
aVasynchronously
p8032
aVAn error occurs
p8033
aVOnly the first one of these meets your criteria so the answer is that the documentation is clear  is always equal to  when the function returns when called as you specify
p8034
as(dp8035
g7
V505088
p8036
stp8037
a((dp8038
g2
(lp8039
VNo, if you don't initialise a value type function result then it's value is undefined
p8040
aVIt could be False (0), True (1), or indeed some other integer value
p8041
aVYou can view a function return variable in the same light as a local variable which of course need to be initialized before use
p8042
aVThe moral of the tale
p8043
aVAlways initialize your function return values
p8044
as(dp8045
g7
V505088
p8046
stp8047
a((dp8048
g2
(lp8049
VNo, you should use the multiplication operator and let the optimizing compiler decide how to do it fastest
p8050
aVYou will find that the compiler knows how to do this best for whatever platform it is targeting
p8051
aVWhat's more, if you start writing bit shift operations instead of multiplication or division your code will rapidly become unmaintainable
p8052
as(dp8053
g7
V505088
p8054
stp8055
a((dp8056
g2
(lp8057
VI think you are going to have to move away from inheritance which is already a rather fragile tool when applied across module boundaries
p8058
aVI'd point you towards COM
p8059
aVManaged code can expose their interfaces as COM objects and C++ can consume them
p8060
aVAnd vice versa
p8061
as(dp8062
g7
V505088
p8063
stp8064
a((dp8065
g2
(lp8066
VIt can't be done
p8067
aVThere is no option to highlight function names
p8068
as(dp8069
g7
V505088
p8070
stp8071
a((dp8072
g2
(lp8073
VWrite some code
p8074
aVCompile it
p8075
aVLook at the disassembly
p8076
aVCount the instructions
p8077
aVThe answer will vary as you vary the number and type of parameters, calling conventions etc
p8078
as(dp8079
g7
V505088
p8080
stp8081
a((dp8082
g2
(lp8083
VThat works absolutely fine for me
p8084
aVMy guess is that you have no screensaver selected
p8085
aVWhen I changed my settings and selected "(None)" as my screensaver then the call to SystemParametersInfo had no effect
p8086
as(dp8087
g7
V505088
p8088
stp8089
a((dp8090
g2
(lp8091
VThere is no difference for
p8092
aVThe VCL code is:
p8093
aVBut  is a bit different:
p8094
as(dp8095
g7
V505088
p8096
stp8097
a((dp8098
g2
(lp8099
VTo add to what Rob and RRUZ have already said, you could consider an extra helper using open array parameters:
p8100
aVYou can then call this as:
p8101
aVwhich is, in my view, more readable at the call-site than:
p8102
aVNote that I passed the open array as a const parameter because that is more efficient when dealing with arrays
p8103
aVBecause each element of the array is itself a reference to the button, you are able to modify the actual button
p8104
aVThe const just means that you cannot change the reference
p8105
as(dp8106
g7
V505088
p8107
stp8108
a((dp8109
g2
(lp8110
VWell, I think you should leave the full version of FastMM around because presumably you will continue developing your program and you may inadvertently introduce more memory leaks
p8111
aVHaving FastMM to tell you about these helps
p8112
aVHowever, what you don't want to do is release to your users a version using the FastMM debug options
p8113
aVThis is much slower and consumes much more memory, and also reports diagnostics which you presumably don't want your users to see
p8114
aVWhat one normally does is have two build configurations, DEBUG and RELEASE
p8115
aVWhen you build DEBUG you have all the diagnostics options
p8116
aVWhen you build RELEASE you switch that all off
p8117
aVYou would typically configure it through conditional defines which control settings in the FastMM include file, FastMMOptions
p8118
aVinc
p8119
aVThe way I configure it is that the DEBUG configuration defines a condition called  and the RELEASE configuration does not
p8120
aVThen in FastMMOptions
p8121
aVinc I respond to that conditional by enabling all the debug features if it is defined
p8122
aVHaving said all that, what I actually release to my clients does not use FastMM at all because I find it doesn't perform terribly well under thread contention
p8123
aVInstead I use a custom memory manager that simply delegates to the  to be found in  which I find performs better
p8124
aVBut it's all controlled with conditionals and it's well worth getting the project well configured so that you can easily experiment if you need to
p8125
as(dp8126
g7
V505088
p8127
stp8128
a((dp8129
g2
(lp8130
VYour best bet is to write a trivial driver that calls  as you yourself suggest
p8131
aVYou can take the most simple example from the Windows Driver Kit and cut it down to the barebones
p8132
as(dp8133
g7
V505088
p8134
stp8135
a((dp8136
g2
(lp8137
VYou can't really expect this to work with an in memory binary
p8138
aVAny function calls to imported DLLs will get modified by the loader to point to the actual locations of the target procedures in the DLL that is loaded
p8139
aVFor example suppose you call a function in kernel32
p8140
aVdll
p8141
aVThen a Windows update happens which changes kernel32
p8142
aVdll
p8143
aVThe next time you run your app, the jump to the function in kernel32
p8144
aVdll is going to be to a different memory address than the before the Windows update was applied
p8145
aVAnd of course this all assumes that DLLs load at their preferred address
p8146
aVAnd then you may have some self-modifying code
p8147
aVAnd so on, and so on
p8148
as(dp8149
g7
V505088
p8150
stp8151
a((dp8152
g2
(lp8153
VI think I might be able to answer this
p8154
aVI don't have XE and so I don't appear to have
p8155
aVHowever, the other  methods in my ToolsAPI unit suggest it will be declared as:
p8156
aVYou call this routine this way:
p8157
aVThe problem is that nothing takes a reference to the interface returned by
p8158
aVYou need to do so, like this:
p8159
aVYou'd need to do likewise in the initialization/finalization code
p8160
aVI believe that this really should be considered a bug in the interface reference counting implementation
p8161
aVIt has been discussed here on Stack Overflow many times
p8162
as(dp8163
g7
V505088
p8164
stp8165
a((dp8166
g2
(lp8167
VYou just need to call
p8168
as(dp8169
g7
V505088
p8170
stp8171
a((dp8172
g2
(lp8173
VYou can't do this
p8174
aVIf you are tricking Windows into thinking you have only a single monitor then you have to accept the consequences
p8175
aVYou might dock the taskbar vertically
p8176
aVI'd be inclined to go back to 3 monitors
p8177
as(dp8178
g7
V505088
p8179
stp8180
a((dp8181
g2
(lp8182
VIt's impossible to answer this question in any meaningful way
p8183
aVThe Win32 interface makes no guarantees about what happens when you pass invalid window handles to routines
p8184
aVIt is an error to do so
p8185
aVPlease refrain
p8186
aVHaving said all that, passing  to  is an error even with a valid window handle
p8187
as(dp8188
g7
V505088
p8189
stp8190
a((dp8191
g2
(lp8192
VSounds like you are looking for a Foreign Function Interface, for example libffi
p8193
as(dp8194
g7
V505088
p8195
stp8196
a((dp8197
g2
(lp8198
VYou haven't allocated any storage, only a pointer
p8199
aVThe pointer needs something to point at
p8200
aVYou should do it like this:
p8201
aVI also took the liberty of making the declaration of  valid, and returning a value
p8202
aVIf you want to learn about pointers, then try like this:
p8203
aVOr if you want heap allocation rather than stack allocation:
p8204
as(dp8205
g7
V505088
p8206
stp8207
a((dp8208
g2
(lp8209
VYou need to call , then  and then  to get the status
p8210
aVWhen you're done call  twice, once on the service handle, and then on the handle returned by
p8211
as(dp8212
g7
V505088
p8213
stp8214
a((dp8215
g2
(lp8216
VThreads don't automatically propagate exceptions into other threads
p8217
aVSo you must deal with it yourself
p8218
aVRafael has outlined one approach, but there are alternatives
p8219
aVThe solution Rafael points to deals with the exception synchronously by marshalling it into the main thread
p8220
aVIn one of my own uses of threading, a thread pool, the threads catch and take over the ownership of the exceptions
p8221
aVThis allows the controlling thread to handle them as it pleases
p8222
aVThe code looks like this
p8223
aVIf the controlling thread elects to raise the exception it can do so like this:
p8224
aVSometimes you may have code that cannot call Synchronize, e
p8225
ag217
aVsome DLLs and this approach is useful
p8226
aVNote that if you don't raise the exception that was captured, then it needs to be destroyed otherwise you have a memory leak
p8227
as(dp8228
g7
V505088
p8229
stp8230
a((dp8231
g2
(lp8232
VIf you want to allow different compilers for the plug-ins from what you use for the app then you need to use COM exclusively across the boundary between app and plug-ins
p8233
aVThat is precisely the problem that COM was designed to solve
p8234
as(dp8235
g7
V505088
p8236
stp8237
a((dp8238
g2
(lp8239
VFor Windows API you should start with Petzold's Programming Windows
p8240
aVIf you don't master Windows at that level then it's always a struggle
p8241
aVOn the other hand, once you do get it at that level, MFC, ATL etc
p8242
aVare pretty obvious wrappers around Win32 that don't need much learning
p8243
aVFor COM there is simply nothing better than Don Box's Essential COM
p8244
as(dp8245
g7
V505088
p8246
stp8247
a((dp8248
g2
(lp8249
VIf you are exporting with mangled names then you can do this with no difficulty
p8250
aVIf you have disabled mangling with  then you have to export the functions with different names
p8251
aVThe reason for this is that DLL import using lib files is name based
p8252
as(dp8253
g7
V505088
p8254
stp8255
a((dp8256
g2
(lp8257
VUse of  switches off name mangling
p8258
aVIf you don't do this you may make if hard for a client of your DLL to import your symbols
p8259
aVRemember that different C++ compilers have different name mangling rules and so your mangled exported names may differ from the names used on import
p8260
aVHowever, since it is wrong to import a class from a DLL if you are using a different compiler than that used for the DLL, this is rather a moot point
p8261
aVSo, if you are exporting classes (usually a bad idea anyway) it is easier to leave mangling on
p8262
aVOtherwise switch it off with
p8263
as(dp8264
g7
V505088
p8265
stp8266
a((dp8267
g2
(lp8268
VThat's name decoration rather than mangling
p8269
aVYou should declare the undecorated name in a DEF file and then you'll get the behaviour you are seeking
p8270
as(dp8271
g7
V505088
p8272
stp8273
a((dp8274
g2
(lp8275
VYour code is incomplete but from what you have included there is one obvious flaw
p8276
aVYou appear to be exporting a class (TInterfacedClass) from a DLL
p8277
aVThis is going to cause problems when clients try to consume your class with a different version of Delphi
p8278
aVWhat's more it's going to leave them helpless if they want to write plug-ins in a different language
p8279
aVPersonally I'd go for a COM based interface which will allow plug-in authors to create plug-ins in any language
p8280
aVThis is in fact the very problem that COM was invented to solve
p8281
aVIf you are happy to be constrained to using the same compiler for plug-ins and host app, and you prefer to expose classes to COM interfaces, then you need to make sure that all deallocation is performed with the same memory manager as allocated the memory
p8282
aVThe simplest way is to use ShareMem and then you'll be safe
p8283
aVUPDATE
p8284
aVCosmin points out in a comment another flaw with exporting classes across module boundaries
p8285
aVIt's basically something that you shouldn't do
p8286
aVCOM was designed for this very purpose and it still should be the first choice for you
p8287
aVDelphi interfaces which are COM compatible so you can get the same benefits of binary interoperability without having to create servers, register CLSID's etc
p8288
aVI think your plug-in should look like this:
p8289
as(dp8290
g7
V505088
p8291
stp8292
a((dp8293
g2
(lp8294
VThere is a long list of such things on the JSON homepage
p8295
aVTake your pick
p8296
as(dp8297
g7
V505088
p8298
stp8299
a((dp8300
g2
(lp8301
VMail servers have to protect themselves against spammers and others with malicious intent
p8302
aVThey are not going to give up their secrets easily
p8303
aVIt is common for mail servers to be configured to black hole messages sent to non-existent recipients
p8304
aVThey don't respond to the sender saying, "sorry, that user doesn't exist, please try again
p8305
aVSo, if you want to verify whether or not an e-mail address has a human behind it I think the only way to be sure is to send an e-mail requesting a response
p8306
as(dp8307
g7
V505088
p8308
stp8309
a((dp8310
g2
(lp8311
VSurely you mean:
p8312
as(dp8313
g7
V505088
p8314
stp8315
a((dp8316
g2
(lp8317
VI'd guess everything is running out of a single thread
p8318
aVThe user probably invokes this algorithm by clicking on a button, or some such
p8319
aVThis is handled by your main thread's message queue
p8320
aVUntil this event handler returns, your app's GUI cannot update
p8321
aVIt needs the message queue to be pumped on regular basis in order to stay responsive
p8322
aVSleeping is almost never a good idea, and definitely not a good idea in the GUI thread
p8323
aVI'm not going to recommend that you continue to use sleep and make your GUI responsive by calling Application
p8324
aVDoEvents
p8325
aVInstead, you should run this algorithm in a background thread and when it completes it should signal so to the main thread
p8326
as(dp8327
g7
V505088
p8328
stp8329
a((dp8330
g2
(lp8331
VThe equivalent of  in Qt is
p8332
as(dp8333
g7
V505088
p8334
stp8335
a((dp8336
g2
(lp8337
VI'm not quite sure what you are doing because you haven't included your formula
p8338
aVMy guess is that you are using a function like this:
p8339
aVAlthough it has an optional parameters to control how many digits are returned, that doesn't work when the input is negative
p8340
aVInstead you should use some VBA:
p8341
as(dp8342
g7
V505088
p8343
stp8344
a((dp8345
g2
(lp8346
VI can see that you are struggling a little with this
p8347
aVIf I were you I would declare a point struct to hold x,y pairs
p8348
aVI would also declare a large fixed size buffer to hold the values as input by the user
p8349
aVSomething like this:
p8350
as(dp8351
g7
V505088
p8352
stp8353
a((dp8354
g2
(lp8355
VIt looks like you haven't found the Python dict yet
p8356
aVPerhaps you mean:
p8357
aVis a dictionary that itself contains dictionaries
p8358
aVYou can then look them up with:
p8359
aVOf course, there's little point in storing 'count' since you can just use  if you need to
p8360
aVYou could do it like so:
p8361
as(dp8362
g7
V505088
p8363
stp8364
a((dp8365
g2
(lp8366
VThere's nothing quite as concise as Python's , but you can use Linq, as blogged by Eric Lippert
p8367
as(dp8368
g7
V505088
p8369
stp8370
a((dp8371
g2
(lp8372
VYou need a C compiler and linker
p8373
aVYour friend is confused
p8374
as(dp8375
g7
V505088
p8376
stp8377
a((dp8378
g2
(lp8379
VBy far the simplest strategy is to decide on an encoding for a particular file, e
p8380
ag217
aVUTF-8, and use it exclusively, both when you write it and then when you read it
p8381
aVTrying to detect what encoding is in use is decidedly error prone so it's best not to have to do this detection
p8382
aVUPDATE
p8383
aVIn the comments below you clarify that you wish to write to a file that is created by somebody else with an unknown encoding
p8384
aVIn full generality this is impossible to do with 100% reliability
p8385
aVIf you are lucky then you may find that the file comes with a Byte Order Mark (BOM)
p8386
aVIn which case you can read the BOM and thus infer the encoding
p8387
aVThere's no requirement for a text file to contain a BOM and they frequently don't
p8388
aVHowever, I would urge you to agree an interchange format with whoever is creating these files
p8389
aVPick a single encoding and always use it
p8390
as(dp8391
g7
V505088
p8392
stp8393
a((dp8394
g2
(lp8395
VOnce you declare the type of a variable, you don't need to cast it to that same type
p8396
aVSo you can write
p8397
aVFinally, you declared  incorrectly
p8398
aVSince you assign it to be the address of , where  is a pointer to , you must declare it to be a pointer to a pointer to
p8399
as(dp8400
g7
V505088
p8401
stp8402
a((dp8403
g2
(lp8404
VTrying to fight the syntax of a language like C# is simply a bad idea
p8405
aVThe tools you use will fight back with determination
p8406
aVJust go with the flow and stop trying to swim against the current
p8407
aVYou'll soon get used to the syntax and it will make sense to everyone else who works with the code
p8408
as(dp8409
g7
V505088
p8410
stp8411
a((dp8412
g2
(lp8413
VAssign an empty string to it, set it to nil or call  on it
p8414
aVThey are all equivalent and they will deallocate the storage thus removing your memory leak
p8415
aVIn response to Marco's comment, the documentation is explicit on this:
p8416
aVDynamic variables that are ordinarily
p8417
aVmanaged by the compiler (long strings,
p8418
aVwide strings, dynamic arrays,
p8419
aVvariants, and interfaces) can be
p8420
aVdeclared with threadvar, but the
p8421
aVcompiler does not automatically free
p8422
aVthe heap-allocated memory created by
p8423
aVeach thread of execution
p8424
aVIf you use
p8425
aVthese data types in thread variables,
p8426
aVit is your responsibility to dispose
p8427
aVof their memory from within the
p8428
aVthread, before the thread terminates
p8429
aVFor example:
p8430
aVRather bizarrely the documentation contains a clear error in the final line which should read
p8431
aVIt is of course easy to see for yourself that thread local variables are not disposed automatically:
p8432
as(dp8433
g7
V505088
p8434
stp8435
a((dp8436
g2
(lp8437
VYou need to remove the  window style
p8438
as(dp8439
g7
V505088
p8440
stp8441
a((dp8442
g2
(lp8443
VI interpret your question to be about Optional Arguments
p8444
aVIf so then I believe they are CLS-Compliant and you can check by using the CLSCompliant attribute:
p8445
aVThis compiles with no warnings
p8446
as(dp8447
g7
V505088
p8448
stp8449
a((dp8450
g2
(lp8451
VUse  to concatenate strings
p8452
aVBut  doesn't allow overlapping so you'd need to create a new string to hold the output
p8453
as(dp8454
g7
V505088
p8455
stp8456
a((dp8457
g2
(lp8458
VYou need:
p8459
aVOr more idiomatically:
p8460
as(dp8461
g7
V505088
p8462
stp8463
a((dp8464
g2
(lp8465
VDoes the new Delphi IDE help me to
p8466
aVwrite less code
p8467
aVIs the package
p8468
aVmanagement better
p8469
aVDo you feel that
p8470
aVthe IDE gives more automation
p8471
aVNo real changes there I think
p8472
aVThe area with possibly the most noticeable differences is generics
p8473
aVIf you use generics at all then you should upgrade
p8474
aVThe versions that followed 2009 have far fewer bugs and wrinkles in the implementation of generics
p8475
as(dp8476
g7
V505088
p8477
stp8478
a((dp8479
g2
(lp8480
VAn icon resource typically contains many different versions of an icon
p8481
aVFor an application icon you would expect 16x16, 32x32, 48x48 and 256x256
p8482
aVYou'd also expect to see the 3 smaller ones at 32 bit colour, 8 bit colour 4 bit colour
p8483
aVOr some variant on that
p8484
aVMicrosoft publishes guidelines
p8485
aVWhy so many different versions of the same icon
p8486
aVWell, the icon will be drawn in different settings
p8487
aVOn a window caption bar, the 16px version will typically be shown
p8488
aVOn the Windows 7 taskbar the 48px version will be shown
p8489
aVWhen usint ALT+TAB in XP the 32px will be shown
p8490
aVIn Vista/7 explorer with ultra large icon view, the 256px will be shown
p8491
aVTo obtain the best visual appearance you must have different versions of the image for different sizes because small raster images aren't easy to scale
p8492
aVWhat's more, you may present a slightly different version of the icon at different resolutions
p8493
aVFor example you may use 3D effects only on larger resolution, partial transparency versions
p8494
aVWhen using remote desktop, lower colour depths may be used if the connection is bandwidth challenged
p8495
aVThe MS guidelines go into these issues in detail
p8496
aVThe normal practice of for the graphic designer to design the icon and once you are happy with it the designer will produce rasterised versions for all the required sizes and colour depths, typically in a single
p8497
aVico file
p8498
as(dp8499
g7
V505088
p8500
stp8501
a((dp8502
g2
(lp8503
VYou need to set the FileDescription and CompanyName fields of your version resource
p8504
as(dp8505
g7
V505088
p8506
stp8507
a((dp8508
g2
(lp8509
VYour understanding of range check errors is correct
p8510
aVThey arise when you access an array outside it's bounds
p8511
aVFor example:
p8512
aVOr for a dynamic array:
p8513
aVI've illustrated this with assignment, but reading an array with an index out of bounds will also produce a range error
p8514
aVThe range error should report an address at which it occurs which you can then translate into a code location with your map file
p8515
aVEven better would be if you were using madExcept or some such tool
p8516
aVUPDATE
p8517
aVPrompted by Ken, the documentation states what is affected by the range checking option as follows:
p8518
aVIn the {$R+} state, all array and
p8519
aVstring-indexing expressions are
p8520
aVverified as being within the defined
p8521
aVbounds, and all assignments to scalar
p8522
aVand subrange variables are checked to
p8523
aVbe within range
p8524
as(dp8525
g7
V505088
p8526
stp8527
a((dp8528
g2
(lp8529
VIn short, you get what you want by calling
p8530
aVTo work out all the details it would be much easier for you to write a sample app in C++ to get to know how to drive the theme API from the ground up
p8531
aVThere are many tutorials and lots of sample code on the web
p8532
aVBut do it in C++ where you will have all the functions readily available
p8533
aVThe last thing you want to get doing is fighting with P/Invokes whilst you are also getting to grips with low-level theme API
p8534
aVOnce you get it cracked in C++, then move on to the P/Invokes and if you have trouble it will be easy to refer back to the C++ code  that works
p8535
as(dp8536
g7
V505088
p8537
stp8538
a((dp8539
g2
(lp8540
VWhen you have a pointer to a record, then you can omit the ^
p8541
aVThe following are equivalent:
p8542
aVThis is also the case for the deprecated Turbo Pascal
p8543
aVI would expect it to be so for Delphi classes, although I have never tried with them since they are already reference types
p8544
aVSadly, this is not the explanation for your AV
p8545
as(dp8546
g7
V505088
p8547
stp8548
a((dp8549
g2
(lp8550
VCall  passing the full path to the file
p8551
aVSo, just the same as you would do for any file
p8552
as(dp8553
g7
V505088
p8554
stp8555
a((dp8556
g2
(lp8557
VSome of your questions are easy
p8558
aVWell, one of them anyway
p8559
aVWhy is there some FastMM-allocated
p8560
aVmemory and some "System-allocated"
p8561
aV(and reserved) memory
p8562
aVSince FastMM is
p8563
aVthe memory manager, why is the system
p8564
aVin charge of allocating some of the
p8565
aVmemory
p8566
aVThe code that you write in Delphi is only part of what runs in your process
p8567
aVYou use 3rd party libraries in the form of DLLs, most notably the Windows API
p8568
aVAnytime you create a Delphi form, for example, there are a lot of windows objects behind it that consume memory
p8569
aVThis memory does not get allocated by FastMM and I presume is what is termed "system-allocated" in your question
p8570
aVHowever, if you want to go any deeper then this very rapidly becomes an extremely complex topic
p8571
aVIf you do want to go deeper into the implementation of Windows memory management then I think you need to consult a serious reference source
p8572
aVI suggest Windows Internals by Mark Russinovich, David Solomon and Alex Ionescu
p8573
as(dp8574
g7
V505088
p8575
stp8576
a((dp8577
g2
(lp8578
V tells you about the operating system version
p8579
aVIf you want to know whether the underlying system is 32 bit or 64 bit then I recommend reading how Raymond Chen explains it
p8580
as(dp8581
g7
V505088
p8582
stp8583
a((dp8584
g2
(lp8585
VI don't believe that there is a handy function in the API to answer this for you
p8586
aVBut I also don't think it's too hard to write a robust function to do this
p8587
aVHere's the outline:
p8588
aVMakes sure that Path1 and Path2 are absolute paths
p8589
aVCheck if Path1 and Path2 refer to the same file system object (more on this below)
p8590
aVIf so then your function returns true
p8591
aVIf not strip the last name off Path2, i
p8592
ag192
aVremove the final path separator (\u005c or /) and everything that follows it
p8593
aVIf step 4 failed to remove any text (e
p8594
ag217
aVthere are no path separators left) then you have reached the root level and your function returns false
p8595
aVGo to 2
p8596
aVNow, how to check that two names refer to the same file system object
p8597
aVThe safest way to do so is to call  for both names, and compare , ,
p8598
aVIf all are equal then the two names refer to the same object
p8599
aVNote that it's not enough to compare strings because a single file system object can have many different names
p8600
aVFor example hardlinks, symlinks, junctions, UNC vs mapped drive letters and so on
p8601
as(dp8602
g7
V505088
p8603
stp8604
a((dp8605
g2
(lp8606
VFind the taskbar windows owned by the process (there's usually only one) and send them WM_CLOSE messages
p8607
as(dp8608
g7
V505088
p8609
stp8610
a((dp8611
g2
(lp8612
VWhy do you need to use palettes these days
p8613
aVJust use RGB values as you please
p8614
aVPalettes date back to the days of 8 bit (and lower) colour devices
p8615
aVNow that we have all moved to 16 bit colour and more recently 32 bit colour they have become a relic
p8616
as(dp8617
g7
V505088
p8618
stp8619
a((dp8620
g2
(lp8621
VYou can't use  in the way you want
p8622
aVWelcome to C
p8623
aVC++ I/O stream operators are typesafe and use operator overloading to achieve their magic
p8624
aVThat's not available in C so you have to stick to unsafe format string approaches
p8625
as(dp8626
g7
V505088
p8627
stp8628
a((dp8629
g2
(lp8630
VYou run the risk of fragmenting your memory if you do this
p8631
aVThis causes performance degredation and for 32 bit systems can lead to memory shortages due to lack of availability of large contiguous blocks of memory
p8632
aVI'm guessing you are increasing the length of an array by 1 each time round
p8633
aVIf so then you are far better keeping track of a capacity and length and only increasing the capacity when you need a length that exceeds the current capacity
p8634
aVWhen you increase the capacity do so by a larger amount than just 1
p8635
aVOf course, the standard containers will do this sort of thing for you so if you can use them, it's best to do so
p8636
as(dp8637
g7
V505088
p8638
stp8639
a((dp8640
g2
(lp8641
VThe normal approach is to post a message to the control that is to be freed
p8642
aVSee how  is implemented for example
p8643
aVIn fact I see no reason why you can't even re-use the  message
p8644
aVThe point about posting the message is that is goes to the back of the queue and only gets processed once any synchronous messages (i
p8645
ag192
aVthose delivered by ) have completed processing
p8646
aVThis avoids calling methods on an object after it has been freed which is obviously an error that you are clearly well aware of
p8647
as(dp8648
g7
V505088
p8649
stp8650
a((dp8651
g2
(lp8652
VThe easiest way is to fake a mouse move event with x=y=0 by calling SendInput()
p8653
as(dp8654
g7
V505088
p8655
stp8656
a((dp8657
g2
(lp8658
VJust rename the replacement and put it in the same directory as your executable
p8659
as(dp8660
g7
V505088
p8661
stp8662
a((dp8663
g2
(lp8664
VYou need to cast the interface with a dynamic cast using the  operator
p8665
aVYour code, , is a certain point of failure
p8666
aVYou should instead write
p8667
aVBut why not make your list  and thus avoid the cast
p8668
aVThat said, are you sure everything in your list implements
p8669
aVIt's not obvious from these excerpts
p8670
aVYou can check for interface support with the  operator, or the rather more functional  function
p8671
aVAlso, you don't need to inherit from IInterface, that is implicit
p8672
aVSo you can replace  with  and so on
p8673
as(dp8674
g7
V505088
p8675
stp8676
a((dp8677
g2
(lp8678
VAssuming you can fit the entire data structure into a contiguous block of memory, you can do the allocation in one shot and then take over the indexing
p8679
aVNote: Even if you can't fit the data into a single contiguous block of memory, you can still use this technique by allocating multiple large blocks and then piecing them together
p8680
aVFirst off form a helper array, , which is to contain the index of the first column of each row
p8681
aVSet the length of  to
p8682
aVYou build this by setting  and then
p8683
aVDo this in a for loop which runs up to and including
p8684
aVSo, in the final entry, , you store the total number of elements
p8685
aVNow set the length of a to be
p8686
aVThis may take a little while, but it will be quicker than what you were doing before
p8687
aVNow you need to write a couple of indexers
p8688
aVPut them in a class or a record
p8689
aVThe getter looks like this:
p8690
aVThe setter is obvious
p8691
aVYou can inline these access methods for increased performance
p8692
aVExpose them as an indexed property for convenience to the object's clients
p8693
aVYou'll want to add some code to check for validity of  and
p8694
aVYou need to use  for the latter
p8695
aVYou can make this checking optional with  if you want to mimic range checking for native indexing
p8696
aVOf course, this is a total non-starter if you want to change any of your column counts after the initial instantiation
p8697
as(dp8698
g7
V505088
p8699
stp8700
a((dp8701
g2
(lp8702
VIt tries to create the file in the current working directory for the process, since you specified a relative path
p8703
aVBecause there is no way to specify the working directory in the  registry setting, the working directory is inherited from the parent process
p8704
aVThe parent process is the shell, explorer
p8705
aVexe which has a working directory of
p8706
aVSince (assuming UAC is enabled) your user doesn't have rights to that folder, no file is created
p8707
as(dp8708
g7
V505088
p8709
stp8710
a((dp8711
g2
(lp8712
VI see absolutely nothing wrong with a recursive delete
p8713
aVYou could use an iterative approach, but it wouldn't have any discernible benefits and would be harder to write
p8714
aVBy the way, you can simplify the code a little and remove the two local variables as so:
p8715
as(dp8716
g7
V505088
p8717
stp8718
a((dp8719
g2
(lp8720
VMy guess: you need to install
p8721
aVnet 4
p8722
aV0 on those XP machines to get that executable to work
p8723
aVC# executables run inside a virtual machine, but that virtual machine is not necessarily installed on all target machines
p8724
aVIn the case of VS2010, it targets the latest version of
p8725
aVnet, 4
p8726
aV0, which will often not be present on older XP machines
p8727
aVYour VS2010 will have come with re-distributable packages for
p8728
aVnet 4
p8729
aV0 so it should be easy enough to push them out to wherever's needed
p8730
aVHowever, exactly how you do that all depends on your local arrangements
p8731
as(dp8732
g7
V505088
p8733
stp8734
a((dp8735
g2
(lp8736
VThe canonical example of this is
p8737
aVYou have to make the users of your DLL call your initialization and finalization routines in just the same way
p8738
as(dp8739
g7
V505088
p8740
stp8741
a((dp8742
g2
(lp8743
VI do it with the following
p8744
aVvbs script
p8745
aVIf you need it in Delphi code then it would be easy enough to convert:
p8746
as(dp8747
g7
V505088
p8748
stp8749
a((dp8750
g2
(lp8751
VYou appear to be trying programmatically to get Acrobat Read to print your document
p8752
aVYour problem is that you can't persuade it to do so without it asking for user interaction
p8753
aVYour current code cannot work because you are waiting for the process to terminate
p8754
aVOnce you start with a simple call to WaitForSingleObject, none of your code can run until the process terminates
p8755
aVYou do not get an opportunity for you code to click that button
p8756
aVSo what you need to do is to use a different waiting strategy
p8757
aVSince this appears to be a fairly crude hack, I'll suggest something I would not normally suggest: polling
p8758
aVInstead of waiting with an infinite timeout you should wait, in a loop, with a timeout value of, say, 250ms
p8759
aVEach time the wait terminates you check to see whether the process has terminated or alternatively whether wait timed out
p8760
aVWhen the wait has timed out, you have an opportunity to look for the dialog window that you want to find
p8761
aVYou should be able to locate it with
p8762
aVYou can discover its class name using Spy++
p8763
aVOnce you have found the dialog window then you need to locate the window handle for the edit control and the button you want to click:  should do the trick
p8764
aVOnce you have the handles of the controls you want to manipulate you need to work out how to manipulate them
p8765
aVIf you are lucky you can send the string with a call to  if it is an EDIT control or similar
p8766
aVOtherwise you may have to fake the key-presses or maybe send it a WM_PASTE
p8767
aVThe button may be more troublesome
p8768
aVClicking it involves sending a WM_COMMAND to the buttons parent
p8769
aVAgain Spy++ can show you what messages are sent when you click a button
p8770
aVOf course, you may not find your window when you call  because it hasn't shown yet
p8771
aVWhen that happens you go round the loop again with a call to
p8772
aVFinally, a much better way to handle this would be to use a software library dedicated to printing PDF
p8773
as(dp8774
g7
V505088
p8775
stp8776
a((dp8777
g2
(lp8778
VThere's nothing built in that will perform a deep-clone for you
p8779
aVI'm sure you could write a deep-clone based on the new RTTI, but I'd expect it to be a non-trivial amount of work
p8780
aVIf you were dealing with simple enough types it would work fine, but you could easily run into serious challenges
p8781
aVFor example, off the top of my head:
p8782
aVSome groups of objects need to be created in a specific order
p8783
aVSome members of a class should not be cloned, e
p8784
ag217
aVreference counts
p8785
aVHow do you recognise those with RTTI
p8786
aVHow do you deal with singletons
p8787
aVWhat about any extrinsic references that need to be set up
p8788
aVSuppose you clone an object that is normally created by a factory
p8789
aVIf that factory holds a reference to the objects it creates then going behind its back may break your design
p8790
aVYou could implement your prototype pattern by defining a basic  method which uses RTTI for simple types and then you have to override it for anything more complex
p8791
aVPersonally though, I'd inherit from  and make my  method based on
p8792
as(dp8793
g7
V505088
p8794
stp8795
a((dp8796
g2
(lp8797
VUse of virtual machines is the normal way to solve this problem
p8798
aVThey work fantastically well on modern hardware
p8799
aVA VM will give you, by far, the most convenience of available options
p8800
as(dp8801
g7
V505088
p8802
stp8803
a((dp8804
g2
(lp8805
VActually, I think you have the wrong function
p8806
aVYou should be looking at  which will give you an array of  structs, one for each job
p8807
aVInside  is the command associated with the task
p8808
as(dp8809
g7
V505088
p8810
stp8811
a((dp8812
g2
(lp8813
V is a Windows specific flag and so you can read it out of
p8814
aVIf you don't have that module installed, you can simply define it for yourself
p8815
as(dp8816
g7
V505088
p8817
stp8818
a((dp8819
g2
(lp8820
VI'm assuming that  is wide
p8821
aVIf not then you can work it out since it's the same as the  field
p8822
aVThe struct wants to be declared like this:
p8823
aVThe only difficult bit is that compact framework doesn't make it easy to convert from Unicode to ANSI
p8824
aVSo to assign to DID you need:
p8825
as(dp8826
g7
V505088
p8827
stp8828
a((dp8829
g2
(lp8830
VThat code returns the target address of a CALL instruction
p8831
aVThe test is just to check that it really is a CALL instruction that has been passed to the routine
p8832
aVIt's not fool proof because you could be passing the address of the middle of an instruction, or even something that isn't code
p8833
aVSo yes, the test should always succeed, if the function is called correctly
p8834
aVThese two routines are presumably used in tandem
p8835
aVFirst of all you get the address of the CALL instruction, and then the code at that site is replaced with a JMP ($E9)
p8836
as(dp8837
g7
V505088
p8838
stp8839
a((dp8840
g2
(lp8841
VThe error messages tell you that you've got two  functions, the one you define and the one in the run time to which you are linking
p8842
aVOn the other hand you've not defined  at all
p8843
aVMehrdad is correct, you should call your main function
p8844
aVAre you compiling with the same toolset (compiler, linker etc
p8845
aVas the book which you are using as a reference
p8846
aVDifferent toolsets have slightly different names, although there will always be a main function of some sort or other
p8847
aVYou shouldn't be trying to get your code's main function naming to agree exactly with the book
p8848
aVYou should be getting it to match what your toolset expects
p8849
as(dp8850
g7
V505088
p8851
stp8852
a((dp8853
g2
(lp8854
VYou probably haven't come across formatted output yet
p8855
aVtakes a string as its first parameter and then a variable number of extra parameters
p8856
aVSpecial strings found in the first parameters are replaced by the values provided in the extra parameters
p8857
aVFor example:
p8858
aVoutputs 42
p8859
aVOr you could write:
p8860
aVWell, you can imagine what happens
p8861
aVNow if you look back at your problem, it's easy to see what is happening
p8862
aVYou are effectively writing:
p8863
aVbut since you don't provide any values for the 3 placeholders, the result is garbage - technically known as undefined behaviour
p8864
as(dp8865
g7
V505088
p8866
stp8867
a((dp8868
g2
(lp8869
VUse :
p8870
aVCall it like so:
p8871
aVFor interop like this, I'd prefer to use  rather than  as the equivalent to
p8872
as(dp8873
g7
V505088
p8874
stp8875
a((dp8876
g2
(lp8877
VYour best bet is to define two versions, one for 32 bit and one for 64 bit
p8878
aVThe 64 bit version is just the same but with  on the reserved bytes array
p8879
aVThen you need to switch between them at runtime
p8880
aVYour C# code will have to detect whether it's running as a 32 or 64 bit process
p8881
as(dp8882
g7
V505088
p8883
stp8884
a((dp8885
g2
(lp8886
VYou should be able to locate it with the help of a map file
p8887
aVYou may need to tweak some of your compiler/linker options to get the map file generated with sufficient detail
p8888
aVIf you are using the MS compiler then you need /MAP linker option
p8889
as(dp8890
g7
V505088
p8891
stp8892
a((dp8893
g2
(lp8894
VBoth  and  deliver messages to window handles, asynchronously or synchronously
p8895
aVWindow handles have thread affinity
p8896
aVThat means that any code that interacts with a window handle must be run from the thread that owns the window, that is the thread that created the window
p8897
aVand  deal with this by ensuring that when the message is processed, it is processed by the thread that owns the window
p8898
aVFor  it is a simple task
p8899
aVEach thread has its own personal message queue
p8900
aVWhen you call  the system simply places the message on the message queue belonging to the thread which owns the window
p8901
aVThe message is then processed at some later point in time when the thread pumps its message queue
p8902
aVFor  it is more difficult to arrange that the message is handled by the right thread
p8903
aVIf you call  from the thread that owns the window then the window procedure is called directly
p8904
aVOtherwise the system notifies the other thread that a synchronous message needs to run and then blocks
p8905
aVThe other thread, the one that owns the window, only processes the message when it makes certain system calls that detect the fact that a message is waiting
p8906
aVThis means that cross-thread calls to  can lead to performance problems
p8907
as(dp8908
g7
V505088
p8909
stp8910
a((dp8911
g2
(lp8912
VNeither C not C++ support atomic types in their current standards
p8913
aVC++11 will introduce support for atomic types
p8914
as(dp8915
g7
V505088
p8916
stp8917
a((dp8918
g2
(lp8919
VThe documentation of StringBuilder explains its purpose:
p8920
aVThe String object is immutable
p8921
aVEvery
p8922
aVtime you use one of the methods in the
p8923
aVSystem
p8924
aVString class, you create a new
p8925
aVstring object in memory, which
p8926
aVrequires a new allocation of space for
p8927
aVthat new object
p8928
aVIn situations where
p8929
aVyou need to perform repeated
p8930
aVmodifications to a string, the
p8931
aVoverhead associated with creating a
p8932
aVnew String object can be costly
p8933
aVThe
p8934
aVSystem
p8935
aVText
p8936
aVStringBuilder class can be
p8937
aVused when you want to modify a string
p8938
aVwithout creating a new object
p8939
aVFor
p8940
aVexample, using the StringBuilder class
p8941
aVcan boost performance when
p8942
aVconcatenating many strings together in
p8943
aVa loop
p8944
as(dp8945
g7
V505088
p8946
stp8947
a((dp8948
g2
(lp8949
VA Delphi short string contains more than just the string contents
p8950
aVThe initial byte in the data structure contains the length of the string
p8951
aVThis is why short strings are limited to 255 characters
p8952
aVSo, you can't use short strings in your variant array the way you propose
p8953
aVWhat you could do is adapt your second approach based on getter and setter methods to be a bit more readable
p8954
aVFor example:
p8955
aVYou might consider using a string rather than a char array, but it's a little hard to be 100% sure of that advice without knowing exactly what your underlying problem is
p8956
aVAs a final thought, why not turn the problem around
p8957
aVStore 3 strings: ,  and
p8958
aVThen have a property backed with a getter and setter called
p8959
aVWhen you read  it pieces it together from the 3 individual parts, and when you write to it it pulls the individual parts out
p8960
aVI suspect it would be easier that way around
p8961
as(dp8962
g7
V505088
p8963
stp8964
a((dp8965
g2
(lp8966
VYou'll have to write a custom control and paint it yourself
p8967
aVIf this is a real check box then it's a bad idea to avoid the system's default drawing
p8968
aVHowever, if you want to do something like a voting form then I could see why you might opt to do this
p8969
as(dp8970
g7
V505088
p8971
stp8972
a((dp8973
g2
(lp8974
VThere's no official way to do this
p8975
aVThere are hacks but they are very hard to make work across a wide variety of Windows machines
p8976
aVGetting such hacks to work in VBA sounds exceedingly challenging
p8977
aVThe new file dialogs introduced in Vista remember settings like list view mode, which column was sorted and so on
p8978
aVI think Microsoft took note of the frustrations people had with the older versions when they designed the new versions
p8979
as(dp8980
g7
V505088
p8981
stp8982
a((dp8983
g2
(lp8984
VIt seems to me that you are worrying about something that is not in fact a problem
p8985
aVIf the user could run a program rather than a URL from your app, then they could just as well run a program themselves
p8986
aVIt's only a security concern if you accept input from some entity other than the logged on user
p8987
as(dp8988
g7
V505088
p8989
stp8990
a((dp8991
g2
(lp8992
VI'd probably stick with TListView but turn it into a virtual list view
p8993
aVLike this:
p8994
aVYou can put millions of items in there in an instant
p8995
as(dp8996
g7
V505088
p8997
stp8998
a((dp8999
g2
(lp9000
VThere is no shell command to close it
p9001
aVYou could hunt for the window and send it a WM_CLOSE, or you could display the image in a window of your own making and then you'd have full control
p9002
aVGenerally speaking though, using this sort of approach to display an image gives up an awful lot of control
p9003
as(dp9004
g7
V505088
p9005
stp9006
a((dp9007
g2
(lp9008
VIt sounds to me as though you are looking for templates
p9009
as(dp9010
g7
V505088
p9011
stp9012
a((dp9013
g2
(lp9014
VThis
p9015
aVworks for me
p9016
aVI added an @ before the strings to disable escape characters and I had to double up any quotes so that they did not get interpreted as the end of the string
p9017
aVSo, if you write
p9018
aVthen that gets interpreted as a newline
p9019
aVBut
p9020
aVwill emit  to the console
p9021
aVSimilarly you can't write
p9022
aVThat's probably the cause of the errors you have seen
p9023
aVHence you would write:
p9024
aVAnyway, although that makes it work it's much better to put the ASCII art in a text file or a resource and get at it that way \u2013 that avoids all these pitfalls
p9025
as(dp9026
g7
V505088
p9027
stp9028
a((dp9029
g2
(lp9030
VThe first character of your path is  which makes this path relative to the root level of the drive on which the current working directory lives
p9031
aVBut you probably want a relative path so just remove the initial
p9032
aVWhat's more, relative paths are relative to the working directory
p9033
aVBut the working directory is not necessarily the application directory
p9034
aVFor example, if you navigate in a file dialog that can change your working directory
p9035
aVIf I were you I would probably pre-pend the path with the app directory and make it a fully-specified absolute path, exactly as HABJAN suggests
p9036
as(dp9037
g7
V505088
p9038
stp9039
a((dp9040
g2
(lp9041
VThere's  but that goes in the other direction, from a large image to a smaller one
p9042
aVAnd even then 32 down to 16 is probably on the edge of what will work well
p9043
aVOtherwise I think you are asking for something verging on the impossible
p9044
aVTo get a decent 32px icon from a 16px icon isn't possible in general
p9045
aVAnti-aliasing is something you do to vector graphics, but you have a raster image
p9046
aVWhat you really need to do is get a group of icons at the appropriate sizes
p9047
as(dp9048
g7
V505088
p9049
stp9050
a((dp9051
g2
(lp9052
s(dp9053
g7
V505088
p9054
stp9055
a((dp9056
g2
(lp9057
VOffice 2007 is 32 bit only so there is no issue there
p9058
aVYour problems arise only with Office 64 bit which has both 32 and 64 bit versions
p9059
aVYou cannot hope to support users with 64 bit Office 2010 when you only have Office 2007
p9060
aVThe solution is to upgrade
p9061
aVIf the only  that you have is that  then you won't have much to do once you get hold of 64 bit Office, but it's not really viable to support users when you can't run the program that you ship
p9062
aVJust think what you would do you do when they report a bug
p9063
as(dp9064
g7
V505088
p9065
stp9066
a((dp9067
g2
(lp9068
VNo, you can process such data on a 32 bit machine
p9069
aVSo long as your compiler supports those  data types you are fine
p9070
aVint64_t is just its name, as defined in the standard
p9071
aVI think all versions of GCC and MSVC this century support 64 bit integers on 32 bit architecture
p9072
aVA 64 bit integer is just twice the size of a 32 bit integer
p9073
as(dp9074
g7
V505088
p9075
stp9076
a((dp9077
g2
(lp9078
VThere is no difference when FLT_RADIX == 2
p9079
as(dp9080
g7
V505088
p9081
stp9082
a((dp9083
g2
(lp9084
VIt's funny that you mention GetCursorPos since that fails on Wow64 processes when the address passed is >2Gb
p9085
aVIt fails every time
p9086
aVThe bug was fixed in Windows 7
p9087
aVSo, yes, I think it's wise to check for errors even when you don't expect them
p9088
as(dp9089
g7
V505088
p9090
stp9091
a((dp9092
g2
(lp9093
VYour first bullet point is the solution
p9094
aVWrap it up in a method so that you don't duplicate code
p9095
as(dp9096
g7
V505088
p9097
stp9098
a((dp9099
g2
(lp9100
VYou'd need to use an untyped parameter:
p9101
aVor
p9102
aVOf course, you are somewhat limited in what you could do inside such a routine because you have abandoned the type system
p9103
as(dp9104
g7
V505088
p9105
stp9106
a((dp9107
g2
(lp9108
VCall GetThreadTimes()
p9109
aVAdd together kernel time and user time
p9110
aVSubtract creation time from now
p9111
aVSubtract value found in step 2 from that found in step 3 and you have your answer
p9112
as(dp9113
g7
V505088
p9114
stp9115
a((dp9116
g2
(lp9117
VI think by far your easiest solution would be to switch to CPython
p9118
aVI don't think it would be any less integrated than your existing solution and you'd avoid all the headaches with missing modules
p9119
as(dp9120
g7
V505088
p9121
stp9122
a((dp9123
g2
(lp9124
VA value has to exist before you can assign to it
p9125
aVThe first time round the loop,  is 0 and  does not exist yet
p9126
as(dp9127
g7
V505088
p9128
stp9129
a((dp9130
g2
(lp9131
VYou appear to be using an old version of Delphi without support for Unicode
p9132
aVThe solution is to upgrade Delphi
p9133
as(dp9134
g7
V505088
p9135
stp9136
a((dp9137
g2
(lp9138
VYou'd need a pre-build event rather than a post-build event since you'd want to get the
p9139
aVres file built before linking
p9140
aVI do something very similar with a simple Perl script that reads an include file (
p9141
aVinc) containing constant declarations of the version numbers
p9142
aVI read them in using a regex and then create my
p9143
aVrc file which I pass to brcc32
p9144
aVIt's all invoked as a pre-build action
p9145
as(dp9146
g7
V505088
p9147
stp9148
a((dp9149
g2
(lp9150
VI would say that WM_COPYDATA is the perfect way to do this
p9151
aVYou just need to get your Delphi main form, say, to implement a message handler for WM_COPYDATA
p9152
aVAt the Delphi end it looks something like this:
p9153
aVYour VB code will need to obtain the window handle of your Delphi main form
p9154
as(dp9155
g7
V505088
p9156
stp9157
a((dp9158
g2
(lp9159
VIn general you can't write a simple fix decorator as you might imagine
p9160
aVFor example, a general function need not have a finite limiting value at a singularity as this particular example does
p9161
aVNormal practice is to implement special handling on a case by case basis
p9162
as(dp9163
g7
V505088
p9164
stp9165
a((dp9166
g2
(lp9167
VNumpy/SciPy will do all this
p9168
aVForm sub-matrices by removing rows and columns
p9169
aVCalculate determinants with
p9170
as(dp9171
g7
V505088
p9172
stp9173
a((dp9174
g2
(lp9175
VIt's been with us for ages and MS doesn't make a habit of removing things because it breaks old programs
p9176
as(dp9177
g7
V505088
p9178
stp9179
a((dp9180
g2
(lp9181
VIf the  branch is executed then it can only be the case that  evaluates to false
p9182
aVWithout knowing what the values are I can't say why this is a surprise to you but I am sure that VBA's if statement works perfectly
p9183
as(dp9184
g7
V505088
p9185
stp9186
a((dp9187
g2
(lp9188
VYou can use those functions directly
p9189
aVThe
p9190
aVnet wrappers  of the memory mapped file API were only introduced in
p9191
aVnet 4
p9192
aV0
p9193
as(dp9194
g7
V505088
p9195
stp9196
a((dp9197
g2
(lp9198
VYou have a mismatch of calling conventions, cdecl on one side and stdcall on the other
p9199
aVMake them match and you should be back in business
p9200
as(dp9201
g7
V505088
p9202
stp9203
a((dp9204
g2
(lp9205
VYou could always use the Visual Studio service template to create a small service host that called your Delphi code compiled into a DLL
p9206
aVSlightly untidy but probably the simplest way to cut the size down starting from where you are
p9207
aVThe simple do nothing service is a 91KB using static linking or 36KB with dynamic linking to the C runtime
p9208
as(dp9209
g7
V505088
p9210
stp9211
a((dp9212
g2
(lp9213
VThere's no mechanism to detect this as it happens
p9214
aVEveryone is expected to play by the rules
p9215
as(dp9216
g7
V505088
p9217
stp9218
a((dp9219
g2
(lp9220
V is defined as , i
p9221
ag192
aVsomething the size of a pointer
p9222
aVThe equivalent in the managed world is
p9223
as(dp9224
g7
V505088
p9225
stp9226
a((dp9227
g2
(lp9228
VAn  is the handle to the brush
p9229
aVReturn
p9230
as(dp9231
g7
V505088
p9232
stp9233
a((dp9234
g2
(lp9235
VYour best bet is probably going to be to set the PATH variable in the script and invoke python by writing
p9236
aVFile associations are global and shared between processes
p9237
aVEnvironment variables are local to a process and that's why I suggest this solution
p9238
as(dp9239
g7
V505088
p9240
stp9241
a((dp9242
g2
(lp9243
VWindows can do this but an app has got no hope of doing this robustly
p9244
as(dp9245
g7
V505088
p9246
stp9247
a((dp9248
g2
(lp9249
VThe standard approach to receiving windows messages in the absence of a visible window is to create a non-visible window to receive messages
p9250
as(dp9251
g7
V505088
p9252
stp9253
a((dp9254
g2
(lp9255
VThis isn't how it works in GUI programming
p9256
aVYou don't call a method to check for a key press
p9257
aVInstead you get sent messages when keys are pressed
p9258
aVAssuming that you have a window that is receiving input then you need to respond to the  message arriving in your window procedure, or message map in Python win32api terms
p9259
aVYour edit shows that you are not using the message queue which is rather unusual
p9260
aVYou may be able to achieve what you wish by calling
p9261
as(dp9262
g7
V505088
p9263
stp9264
a((dp9265
g2
(lp9266
VYou can't really avoid creating extra strings
p9267
aVYour example at the end of your question creates strings
p9268
aVYour call to  in this code creates a dynamic string implicitly from the parameter you pass and then this string is passed to
p9269
aVThe solution with  is probably the way to go since I don't see any easy way to avoid the copying of memory if you wish to do anything with the split strings
p9270
as(dp9271
g7
V505088
p9272
stp9273
a((dp9274
g2
(lp9275
VYou can't do this
p9276
aVAll the calls to the Word COM interfaces have be made from the thread that created the object
p9277
aVYou should be fine if you create the Word application from the background thread and then do all the work from that thread
p9278
as(dp9279
g7
V505088
p9280
stp9281
a((dp9282
g2
(lp9283
VCall  and you will get hold of the key and the value, but the value will not have been freed
p9284
aVYou can then add it back in with a different key
p9285
aVThe  method returns a  which is simply a record containing a key and its associated value
p9286
aVThe code might look something like this:
p9287
as(dp9288
g7
V505088
p9289
stp9290
a((dp9291
g2
(lp9292
VYour comments indicate that you are trying to install multiple instances of a product from a single
p9293
aVmsi by specifying different parameters to msiexec
p9294
aVThis will not work
p9295
aVAs you have discovered, Windows Installer regards your
p9296
aVmsi as being a single product and won't allow it to be installed multiple times
p9297
aVWhat you need to do is to get your
p9298
aVmsi to install all the different service instances at once
p9299
aVYou'll need to specify all the different configuration options for each service in the call to msiexec, and effectively loop inside your installer
p9300
as(dp9301
g7
V505088
p9302
stp9303
a((dp9304
g2
(lp9305
VCreate a hidden form that you pass to
p9306
aVWhen you decide it's time for the app to go down, close that hidden form
p9307
as(dp9308
g7
V505088
p9309
stp9310
a((dp9311
g2
(lp9312
VThe scheduler typically works at the thread level
p9313
aVIn simplest terms the scheduler gives each runnable thread its timeslice in turn
p9314
aVSo a process with two threads will get twice as much CPU time as a process with one thread
p9315
as(dp9316
g7
V505088
p9317
stp9318
a((dp9319
g2
(lp9320
VThis is a bad idea
p9321
aVThe standard UI is for TAB to move between input fields
p9322
aVYou make your app less useable when you elect not to follow well known standards
p9323
aVThese standards are what makes UI intuitive
p9324
as(dp9325
g7
V505088
p9326
stp9327
a((dp9328
g2
(lp9329
VThe operating system will reclaim the memory so you don't need to free it
p9330
aVMost programs do free memory though because if you don't free any memory then you are liable to have problems caused by these intentional leaks
p9331
as(dp9332
g7
V505088
p9333
stp9334
a((dp9335
g2
(lp9336
VThe typical cause for something like this is an event handler that performs some action that triggers the same event handler
p9337
aVHence the infinite recursion and resulting stack overflow
p9338
aVThere's a very high probability that's your problem
p9339
aVTo work it out, I'd look back right to the base of the call stack and find where it starts repeating itself
p9340
aVThere should be clues there
p9341
as(dp9342
g7
V505088
p9343
stp9344
a((dp9345
g2
(lp9346
VA directory is a location in the file system
p9347
aVA folder is a location in the shell namespace
p9348
aVA directory is a kind of folder
p9349
aVA virtual folder is not necessarily backed by a directory
p9350
aVFor example consider libraries or search folders
p9351
aVThe user's desktop directory is a location in the file system
p9352
aVThe desktop folder merges that with virtual items like all users items, recycle bin, shortcut to documents folder etc
p9353
as(dp9354
g7
V505088
p9355
stp9356
a((dp9357
g2
(lp9358
VYou simply need to call  on the tree view
p9359
as(dp9360
g7
V505088
p9361
stp9362
a((dp9363
g2
(lp9364
VThere's no built in sort facility for TStringGrid, so you need to roll your own
p9365
aVPersonally, I use some general purpose sorting code that can sort anything provided a compare function and an exchange function:
p9366
aVYou could look at how Generics
p9367
aVCollections
p9368
aVTArray
p9369
aVQuicksort is implemented to see how to fill in the missing code above
p9370
aVThe essential point is that your  and  functions, which are methods of objects, contain the knowledge of how to compare items in the string grid, and then how to swap them
p9371
as(dp9372
g7
V505088
p9373
stp9374
a((dp9375
g2
(lp9376
VYour basic problem is that you are storing large arrays of data on the stack
p9377
aVThis is bad design and is probably due to the way the Fortran code is implemented
p9378
aVLarge arrays need to be stored on the heap and dynamically allocated there
p9379
aVTo solve this problem you will need to understand and modify your Fortran code accordingly
p9380
aVThe  keyword is how you create heap allocated data in Fortran 90
p9381
aVHowever, many compilers have options that for arrays to be allocated on the heap and that may be the most expedient route for you right now
p9382
as(dp9383
g7
V505088
p9384
stp9385
a((dp9386
g2
(lp9387
VIt would appear that you have omitted the declaration of the struct type in the file which declares the extern variable
p9388
as(dp9389
g7
V505088
p9390
stp9391
a((dp9392
g2
(lp9393
VThe documentation for  states:
p9394
aVTo prevent the system from
p9395
aVtransitioning to a low-power state in
p9396
aVWindows Vista, an application must
p9397
aVcall SetThreadExecutionState to inform
p9398
aVthe system that it is in use
p9399
aVThis whole area of Windows changed drastically from XP to Vista so any solutions based on  won't work on modern Windows
p9400
aVSo, the recommended solution is to call
p9401
aVYou could fake mouse messages using, e
p9402
ag217
aVor some more Java native equivalent, but I'd probably go for
p9403
as(dp9404
g7
V505088
p9405
stp9406
a((dp9407
g2
(lp9408
VYou call
p9409
aVThe MSDN documentation contains a comprehensive example of how to call it
p9410
as(dp9411
g7
V505088
p9412
stp9413
a((dp9414
g2
(lp9415
VYou need to  your object instance like this:
p9416
aVThat's just the C# syntax for creating new object instances
p9417
as(dp9418
g7
V505088
p9419
stp9420
a((dp9421
g2
(lp9422
VAccording to Wikipedia:
p9423
aVIn Python, the term monkey patch only
p9424
aVrefers to dynamic modifications of a
p9425
aVclass or module at runtime, motivated
p9426
aVby the intent to patch existing
p9427
aVthird-party code as a workaround to a
p9428
aVbug or feature which does not act as
p9429
aVyou desire
p9430
as(dp9431
g7
V505088
p9432
stp9433
a((dp9434
g2
(lp9435
VYou need to add back the  style which is removed with  border style
p9436
as(dp9437
g7
V505088
p9438
stp9439
a((dp9440
g2
(lp9441
VWindows sends the messages to the window which is represented by the taskbar button
p9442
aVIn your app, and I'm guessing a bit here, it is one of the hidden windows which is represented by the taskbar button
p9443
aVThe window manager won't send any of these messages to a hidden window
p9444
aVYou can solve the problem by arranging that the main window is the one represented in the taskbar
p9445
aVYou can read all about the gory details of which windows appear in the taskbar in the excellent MSDN topic titled Window Features
p9446
as(dp9447
g7
V505088
p9448
stp9449
a((dp9450
g2
(lp9451
VThe Generics units were added in Delphi 2009 and could be of no use to you since your Delphi doesn't support generics
p9452
aVIcePack is not part of Delphi and no doubt can be located with a web search
p9453
as(dp9454
g7
V505088
p9455
stp9456
a((dp9457
g2
(lp9458
VYou should not pass the StringBuilder by ref
p9459
aVWhen you do that you say you only get one character back
p9460
aVThat's the hallmark of expecting ANSI encoding but actually receiving Unicode (UTF-16)
p9461
aVFix it by specifying the character set:
p9462
as(dp9463
g7
V505088
p9464
stp9465
a((dp9466
g2
(lp9467
VCall  passing
p9468
as(dp9469
g7
V505088
p9470
stp9471
a((dp9472
g2
(lp9473
VWindows file caching is very effective, especially if you are using Vista or later
p9474
aVis a loose wrapper around the Windows  and  API functions and for many use cases the only thing faster is a memory mapped file
p9475
aVHowever, there is one common scenario where  becomes a performance bottleneck
p9476
aVThat is if you read or write small amounts of data with each call to the stream read or write functions
p9477
aVFor example if you read an array of integers one item at a time then you incur a significant overhead by reading 4 bytes at a time in the calls to
p9478
aVAgain, memory mapped files are an excellent way to solve this bottleneck, but the other commonly used approach is to read a much larger buffer, many kilobytes say, and then resolve future reads of the stream from this in memory cache rather than further calls to
p9479
aVThis approach only really works for sequential access
p9480
aVFrom the use pattern described in your updated question, I think you may find the following classes would improve performance for you:
p9481
as(dp9482
g7
V505088
p9483
stp9484
a((dp9485
g2
(lp9486
VYou can't stop anyone calling a destructor or , but you can make sure that doing so has no effect:
p9487
aVI can't imagine why you would want to do this though
p9488
as(dp9489
g7
V505088
p9490
stp9491
a((dp9492
g2
(lp9493
VThe simple answer is that you don't
p9494
aVExceptions are not part of the COM interop specification and so should not cross module boundaries
p9495
aVYou indicate errors with status codes
p9496
aVCatch the exception just before your method exits (in each COM interface method)
p9497
aVTurn the result into an error code
p9498
aVIf you use an  then you can consume it as  and get the Delphi compiler to re-raise an exception on the other side of the fence
p9499
aVThe always knowledgeable Rob Kennedy points out in a comment that  can be used "both sides of the fence" which makes life even easier than outlined above
p9500
aVI'm not an expert on this at all (hence the need to be educated by Rob's comment)
p9501
aVHowever, the documentation indicates that when you are implementing  routines you should override  to convert exceptions into  error codes
p9502
aVSome of the standard COM related classes provide overriden versions but you may need to add some of your own logic to the mix
p9503
aVThe compiler writes implicit Try/Except blocks in safecall routines that handle exceptions by calling this virtual function
p9504
as(dp9505
g7
V505088
p9506
stp9507
a((dp9508
g2
(lp9509
VCOM very likely is what you want
p9510
aVIt is very broad but you don't need to use all the functionality
p9511
aVFor example, you don't need to require participants to register GUIDs, you can define your own mechanism for creating instances of interfaces
p9512
aVThere are a number of templates and other mechanisms to make it easy to create COM interfaces
p9513
aVWhat's more, since it is a standard, it is easy to document the requirements
p9514
aVOne very important thing to bear in mind is that importing/exporting C++ objects requires all participants to be using the same compiler
p9515
aVIf you think that ever could be a problem to you then you should use COM
p9516
aVIf you are happy to accept that restriction then you can carry on as you are
p9517
as(dp9518
g7
V505088
p9519
stp9520
a((dp9521
g2
(lp9522
VThe stack is allocated when the thread is created and then extended on demand, possibly terminating with a stack overflow
p9523
as(dp9524
g7
V505088
p9525
stp9526
a((dp9527
g2
(lp9528
VThe most commonly used is DUnit
p9529
aVIt's actually included in modern versions of Delphi but if your version doesn't come with it you can download it from Sourceforge
p9530
as(dp9531
g7
V505088
p9532
stp9533
a((dp9534
g2
(lp9535
V is the character with code 9, TAB
p9536
aVIf you want to convert a floating point value to a string with 2 decimal places you use one of the formatting functions, e
p9537
ag217
aV:
p9538
as(dp9539
g7
V505088
p9540
stp9541
a((dp9542
g2
(lp9543
VAnd here's a variant of Cosmin's that only walks the string once, but uses an efficient allocation pattern:
p9544
as(dp9545
g7
V505088
p9546
stp9547
a((dp9548
g2
(lp9549
VYou don't really need the string stream
p9550
aVYou can just call  to create a Delphi string containing the contents of  and then assign that string to
p9551
aVIf you have UTF8 data then pass a UTF8 string to
p9552
aVUsing  still involves an intermediate buffer allocation so I guess what would really be nice would be a read-only  descendant which you could pass a pointer and a size
p9553
aVYou could that pass that stream to
p9554
aVIt would be easy enough to write such a thing
p9555
aVDo you actually have performance problems though
p9556
aVIf not then why change from your current approach
p9557
as(dp9558
g7
V505088
p9559
stp9560
a((dp9561
g2
(lp9562
V is what you want
p9563
aVPerhaps you are using it recursively but not creating a recursive mutex
p9564
aVThat's the only explanation for a deadlock in single thread code
p9565
as(dp9566
g7
V505088
p9567
stp9568
a((dp9569
g2
(lp9570
VDWORD constants are typically written in hex when they are used as flags that can be OR'd together in bitwise fashion
p9571
aVIt makes it easier to see that is so
p9572
aVThat's why you see 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 etc
p9573
aVProgrammers just recognise those values as having binary representations with just a single bit set
p9574
aVWhen it's an enumeration you'd see 0x01, 0x02, 0x03 etc
p9575
aVThey'd often still be written in hex because programmers tend to get into these habits
p9576
as(dp9577
g7
V505088
p9578
stp9579
a((dp9580
g2
(lp9581
VIt's documented in the language guide
p9582
as(dp9583
g7
V505088
p9584
stp9585
a((dp9586
g2
(lp9587
VThat's game over
p9588
aVTell your user what happened and terminate your app
p9589
as(dp9590
g7
V505088
p9591
stp9592
a((dp9593
g2
(lp9594
VI'd pass an HBITMAP between native and managed worlds
p9595
aVDetach the handle from the Delphi  by calling
p9596
aVCreate a
p9597
aVnet  by calling
p9598
as(dp9599
g7
V505088
p9600
stp9601
a((dp9602
g2
(lp9603
VYou just need to call  instead of  and the dialog will be modal
p9604
aVModal dialogs disable the other windows in an application so that the modal dialog, and only the modal dialog, can receive input
p9605
as(dp9606
g7
V505088
p9607
stp9608
a((dp9609
g2
(lp9610
VOne situation where 64 bit will matter is for data-parallel, multi-threaded numerical applications on many-core machines
p9611
aVFor such an app the 32 bit address space can be constraining if the data cannot be split into small enough pieces
p9612
aVOther than that the biggest push to 64 bit is for extensions to other programs
p9613
aVFor example shell extensions, Excel add-ins, MATLAB extensions etc
p9614
as(dp9615
g7
V505088
p9616
stp9617
a((dp9618
g2
(lp9619
VYour C++ code returns a double but your C# code declares the function as having void return value
p9620
aVYou also may have a calling convention mismatch
p9621
aVC++ default is cdecl, C# default is stdcall
p9622
aVOtherwise it's fine
p9623
as(dp9624
g7
V505088
p9625
stp9626
a((dp9627
g2
(lp9628
VThe 3 by 3 rotation part could be represented as 3 Euler angles
p9629
aVBut then you've got to do quite a bit of trig to convert back and forth
p9630
aVMaybe your problem is easier since you hint that you only have 1 degree of freedom
p9631
aVIn any case why not send the 16 floats
p9632
as(dp9633
g7
V505088
p9634
stp9635
a((dp9636
g2
(lp9637
VAeroSnap is just another type of resize sent to your app by the window manager
p9638
aVAs such you don't get to know that it was snap rather than any other type of resize
p9639
aVThe best you can hope for is to detect that opposite edges have been moved in the course of a size event
p9640
aVYou'd need to check that height or width changed to so as to distinguish it from a move event
p9641
aVThe reason why you don't get told that this is a snap is that it's hard to imagine why an app would care what the mechanism for resizing is
p9642
aVThe comments have revealed more about your problem
p9643
aVYou are trying to persist your apps position and size when the app closes down so that you can restore it when it restarts
p9644
aVYou are using  to do so and have discovered that it returns an incorrect position when the last sizing of the Window was an Aero Snap
p9645
aVMy own app does exactly the same and I have encountered the exact same problem
p9646
aVThe solution I used was to call  in place of  to obtain the window position and size
p9647
aVYou state that this fails for you, in which case I have no idea what to suggest
p9648
aVI must say I find it a little hard to believe that  does not return the correct window rect
p9649
as(dp9650
g7
V505088
p9651
stp9652
a((dp9653
g2
(lp9654
VIt's probably easiest to use  to adapt a  instance into an
p9655
aVThe other approach that leaps out is to pass an  to  but that would be somewhat inefficient for large streams
p9656
as(dp9657
g7
V505088
p9658
stp9659
a((dp9660
g2
(lp9661
VI think you just want this:
p9662
as(dp9663
g7
V505088
p9664
stp9665
a((dp9666
g2
(lp9667
VThe most common pitfall is use of global variables
p9668
aVSo long as you don't use any global variables (or properly synchronise access to the ones you do use) you will be a long way towards thread safety
p9669
aVis used by, for example, the memory manager to make optimisations in the single threaded case
p9670
aVPersonally I don't feel this is a worthwhile optimisation these days since practically all useful code has threads of some description
p9671
aVI'd just set  to True at the start of your DLL, e
p9672
ag217
aVin the / block of your DLL
p9673
aVdpr file, or in one of your unit's initialization sections which amounts to the same thing
p9674
aVTo answer your question directly, the instance of  in your DLL will not be set true unless you create a thread in that DLL
p9675
aVSince you create the threads in your EXE you need to do it yourself in the DLL
p9676
aVMore generally, it's simply impossible to say much about thread safety of your code without knowing what it does and what you actually mean by thread safe
p9677
aVThe latter point may sound odd, but what I'm referring to is the issue discussed in Eric Lippert's famous What is this thing you call "thread safe"
p9678
aVarticle
p9679
as(dp9680
g7
V505088
p9681
stp9682
a((dp9683
g2
(lp9684
VThis cannot be done
p9685
aVYou'll need to port it to a supported language for that platform
p9686
as(dp9687
g7
V505088
p9688
stp9689
a((dp9690
g2
(lp9691
VNo, there is no way to do this
p9692
aVYou should write your own dialog which validates the input to an edit control
p9693
as(dp9694
g7
V505088
p9695
stp9696
a((dp9697
g2
(lp9698
VI suspect this happens when you have done a release build, with debug disabled
p9699
aVThen you switch back to debug configuration and do a compile rather than a build
p9700
aVThe files where you can't set breakpoints correspond to those with DCUs produced by a compile with debug disabled
p9701
aVSimply doing a build to re-generate all DCU files will make your breakpoints work again
p9702
as(dp9703
g7
V505088
p9704
stp9705
a((dp9706
g2
(lp9707
VThe problem is that you are obliterating the window style
p9708
aVThe error is the line:
p9709
aVThis sets the  style flag, but removes all other flags, most definitely not what you intend
p9710
aVInstead you should use bitwise OR like so:
p9711
aVI'm know next to nothing about C++ type rules so there will probably be wrinkles with this code, but I'm sure that this is your problem
p9712
aVIn fact, since you set the window style in the call to  I don't see why you need to modify it at all
p9713
aVOne final hunch at why your marquee progress bar is not working
p9714
aVDid you include a manifest for common controls v6
p9715
aVThe marquee style is only supported in common controls v6 and up
p9716
aVYou can do this most simply by including the following in, for example, stdafx
p9717
aVh:
p9718
aVI tested this with the following code added to the blank Win32 project in Visual Studio:
p9719
aVI needed to add the manifest pragma to get v6 comctl32 and without the pragma there was no marquee
p9720
as(dp9721
g7
V505088
p9722
stp9723
a((dp9724
g2
(lp9725
VIn general there could be no such tool
p9726
aVFor such a tool to exist it would need to know about the internals of any general COM object and I think that's too much to ask
p9727
aVIn this example,  is part of  and so the memory use for the application is somewhat more pertinent
p9728
aVWhat you could do is work out how much memory the instance of Word that hosts  is consuming
p9729
aVProcess Explorer will tell you that
p9730
as(dp9731
g7
V505088
p9732
stp9733
a((dp9734
g2
(lp9735
VYou can read the information you need out of the  property
p9736
aVThe AutoScrollPosition property
p9737
aVrepresents the location of the visible
p9738
aVportion of a scrollable control
p9739
aVSo, the label's position relative to the top left corner of the visible area of the panel is given by
p9740
as(dp9741
g7
V505088
p9742
stp9743
a((dp9744
g2
(lp9745
VThe stack imbalance is because you have mis-matching calling conventions or mis-matching function declarations
p9746
aVI'd be very surprised if  was using  calling convention
p9747
aVSurely that uses
p9748
aVI'd want to see your C++ declaration of that function before giving firmer advice
p9749
aVLeave the warning on because it's finding bugs in your code, and fix the mis-matches, whatever they are
p9750
as(dp9751
g7
V505088
p9752
stp9753
a((dp9754
g2
(lp9755
VThere's lots of ways to do this, and I'm not sure how you intend to handle newlines
p9756
aVHowever, all routes lead to  which is a  instance that wraps up the windows messages needed to interact with the underlying Windows edit control
p9757
aVFor example, these routines should get you started
p9758
as(dp9759
g7
V505088
p9760
stp9761
a((dp9762
g2
(lp9763
VIt seems odd to me that you are painting during the track bar change event
p9764
aVWhy don't you paint in an overridden  method
p9765
aVThat would allow you to do double-buffering if all other attempts at flicker reduction failed
p9766
aVThat said, I'd probably avoid custom painting if possible
p9767
aVI'd use a  to display the text and it will paint as part of the paint cycle
p9768
aVIf you still had flicker problems then you might find  flickers less that
p9769
as(dp9770
g7
V505088
p9771
stp9772
a((dp9773
g2
(lp9774
VYour description is a little unclear, but I interpret it that you are sending  message (via the  macro) to a window in a different process
p9775
aVThis simply does not work for this particular Windows message since it passes a pointer to a struct in the calling process which is meaningless when interpreted in the context of the other process (the payroll app that owns the list view)
p9776
aVTo solve your problem you could allocate memory in the other process although this is quite a complex task
p9777
aVA commonly cited example of the technique is to be found in the Code Project article, Stealing Program's Memory
p9778
aVPerhaps a simpler approach would be to use WM_COPYDATA which will marshal string data between processes
p9779
aVIf that doesn't have enough flexibility then you'd need to find another IPC mechanism, e
p9780
ag217
aVnamed pipes
p9781
as(dp9782
g7
V505088
p9783
stp9784
a((dp9785
g2
(lp9786
VI can't tell you what your problem is from this information, but I can tell you how to work it out
p9787
aVCreate an event handler and attach it to
p9788
aVThis will get called whenever any queued message is pulled of your apps message queue
p9789
aVKeyboard messages are input messages and thus queued so the WM_KEYDOWN message will arrive in this event handler
p9790
aVImplement the handler like this:
p9791
aVEnable Debug DCUs and then set a break point on the  line
p9792
aVRun your app, select the spin edit and press ENTER
p9793
aVThe code will break and you can now step through to see where the WM_KEYDOWN message is routed
p9794
aVAfter the event handler returns you should step until you find a call to DispatchMessage
p9795
aVPress F7 to step into this and keep following the trail until you can find out where it lands and why it doesn't land in your intended event handler
p9796
as(dp9797
g7
V505088
p9798
stp9799
a((dp9800
g2
(lp9801
VThe only viable way to do this is to understand the design of the system and you are not going to do that with any tool
p9802
aVYou will only be able to do this by reading the code
p9803
as(dp9804
g7
V505088
p9805
stp9806
a((dp9807
g2
(lp9808
VThe process owns the heap
p9809
aVEach thread owns its own stack
p9810
aVWhen an EXE calls a function in a DLL the same stack is used because the function call is within the same thread
p9811
aVThe other point to make is that the process has the address space into which the EXE and DLL are loaded
p9812
as(dp9813
g7
V505088
p9814
stp9815
a((dp9816
g2
(lp9817
VWith your background I'd suggest a Delphi app using the TWebBrowser component
p9818
aVDelphi's GUI building tools are more akin to what you are used to than MFC
p9819
aVYou could likely get it built in a matter of hours
p9820
aVRegarding the resources I'd just handle that with a build script that linked different resources for different versions
p9821
aVIf you want to avoid rebuilding for each version there are many tools for replacing resources in an existing executable
p9822
aVI somewhat misunderstood your requirements
p9823
aVYou want to update the EXE's resources programmatically which can be achieved using the UpdateResource() Windows API function
p9824
as(dp9825
g7
V505088
p9826
stp9827
a((dp9828
g2
(lp9829
VThe embedded resources are stored inside the DLL or EXE files
p9830
as(dp9831
g7
V505088
p9832
stp9833
a((dp9834
g2
(lp9835
VYou can't insert into a file and push the existing contents back
p9836
aVYou can only overwrite or extend
p9837
aVYou therefore can't write a piece of the file until you know the contents of all that precedes it
p9838
as(dp9839
g7
V505088
p9840
stp9841
a((dp9842
g2
(lp9843
VThe structs are probably all next to each other in memory and so the hardware caching works better for the smaller struct
p9844
aVWhen you ask to read from main memory an entire cache line is read
p9845
aVSince you can fit more small structs in a cache line you can fulfill subsequent reads from the cache rather than having to go out to main memory which is much slower
p9846
as(dp9847
g7
V505088
p9848
stp9849
a((dp9850
g2
(lp9851
VUnicode output from Python to the  Windows console just doesn't work
p9852
aVPython can't be persuaded to emit the native Windows encoding which expects wide characters and UCS2
p9853
as(dp9854
g7
V505088
p9855
stp9856
a((dp9857
g2
(lp9858
VYou can use  if you know the position of the character(s) you want to remove
p9859
aVI'd imagine that it would be easier not to add it in the first place
p9860
aVYour updated question talks about removing the last comma character
p9861
aVI'm guessing you want to do this to avoid creating a message that looks like this:
p9862
aVMy shopping list contained milk, eggs,
p9863
aVbutter, and fish
p9864
aVYou'd assemble this in a loop, iterating over an array
p9865
aVUsually you can write the loop so that you simply choose (e
p9866
ag217
aVwith an if statement) not to add the command when you are in the final iteration of the loop
p9867
as(dp9868
g7
V505088
p9869
stp9870
a((dp9871
g2
(lp9872
VDrop a  onto a Delphi form
p9873
aVSet the timer's interval property to 100 (measured in milli-seconds)
p9874
aVAssign an event handler for the  event that checks your database
p9875
aVSet the  property to
p9876
aVWhen you want the timer to start firing events set  to True
p9877
aVWhen you want it disabled, set  back to
p9878
aVOne thing to be careful of is if your timer event handler takes more time to run than the timer interval
p9879
aVIf that happens then there will be no pause in between invocations of the handler
p9880
aVThis won't do any terrible harm, but it may result in your app consuming 100% CPU
p9881
aVA defensive technique is to set the timer's Enabled property to False at the beginning of your event handler, and then back to True just before you exit the handler
p9882
aVRe-reading your question, it occurs to me that perhaps you are asking how to do the database access, starting Media Player, sleeping during the video, waiting for it finish, opening IE etc
p9883
aVYou can't ask how to do all of that in one question (please see the FAQ for a description of what is a valid question on Stack Overflow)
p9884
aVIf you really want answers to all of that then we'll just close the question as being too broad
p9885
aVMy answer above gives you some orientation for the timer part of your question
p9886
as(dp9887
g7
V505088
p9888
stp9889
a((dp9890
g2
(lp9891
VYou can't rely on the garbage collector's implementation details when planning lifetime dependencies
p9892
aVYou need to do this explicitly one way or another
p9893
aVContext managers spring to mind, for example:
p9894
aVThis produces the following output:
p9895
as(dp9896
g7
V505088
p9897
stp9898
a((dp9899
g2
(lp9900
VYou are passing a process handle to a function, , that expects a window handle
p9901
aVNaturally, this fails
p9902
aVYou should send  instead
p9903
as(dp9904
g7
V505088
p9905
stp9906
a((dp9907
g2
(lp9908
VIn native code, use a directory change notification
p9909
aVIf you prefer
p9910
aVnet, then use
p9911
as(dp9912
g7
V505088
p9913
stp9914
a((dp9915
g2
(lp9916
VIt's impossible to say what the problem is based on this information
p9917
aVI'd debug this by setting Debug DCUs to True, setting a breakpoint on  and trying to work out why it lands there when ENTER is pressed
p9918
as(dp9919
g7
V505088
p9920
stp9921
a((dp9922
g2
(lp9923
VYou need to use  in your header file declarations of the imported procedures so that C linkage is used
p9924
aVAt the moment what is happening is that the C++ compiler is expecting mangled names for your imported functions
p9925
aVUsing  switches off the C++ name mangling
p9926
aVFor example:
p9927
aVSince you have control over the header file it makes more sense to place the  in the header file
p9928
aVThis means that anyone that consumes your header file does not need to concern themselves with such issues
p9929
aVHowever, when including header files over which you do not have control, then @Nawaz's suggestion is a slick way to to it
p9930
aVI also forgot to mention that excellent point that @bcsanches makes which is that  is C++ rather than C
p9931
aVThus it needs to be included conditionally if you want a single header file to work for both C and C++
p9932
as(dp9933
g7
V505088
p9934
stp9935
a((dp9936
g2
(lp9937
VThat's a special feature of Delphi of which there is no analogue in C#
p9938
aVIn C# you need to override
p9939
as(dp9940
g7
V505088
p9941
stp9942
a((dp9943
g2
(lp9944
VThe problem is that you are putting around 100MB on the stack and your stack isn't that big
p9945
aVYou need to start using pointers to this  struct and heap allocation rather than trying to copy it onto the stack
p9946
as(dp9947
g7
V505088
p9948
stp9949
a((dp9950
g2
(lp9951
VThat is a non-queued message and so it does not arrive via the message queue
p9952
aVYou don't get it by calling
p9953
aVRather it is delivered directly to a window
p9954
aVI recommend that you read the MSDN overview topic for Windows messages: About Messages and Message Queues
p9955
aVThe documentation for WM_DEVICECHANGE states how the message is delivered as follows:
p9956
aVA window receives this message through
p9957
aVits WindowProc function
p9958
aVYou need to override a  method to receive this message
p9959
aVI think you should be able to derive from  and override  to get this notification
p9960
aVWhat's more you don't need to do this in a background thread
p9961
as(dp9962
g7
V505088
p9963
stp9964
a((dp9965
g2
(lp9966
VThe call to  happens first
p9967
aVThen the finally block
p9968
aVThen control leaves the function (that's the )
p9969
as(dp9970
g7
V505088
p9971
stp9972
a((dp9973
g2
(lp9974
VYour C code uses cdecl calling convention
p9975
aVThe C# code uses stdcall
p9976
aVAll the  attributes should be:
p9977
aVOf course you could alternatively switch the C code to stdcall using
p9978
aVBut make sure you only do one of these
p9979
aVdoesn't need the
p9980
aVYou should declare it:
p9981
as(dp9982
g7
V505088
p9983
stp9984
a((dp9985
g2
(lp9986
VAs a point of terminology you are attempting to link implicitly rather than statically which means something quite different
p9987
aVIf you really can't get hold of a
p9988
aVlib file then one easy way to generate one is to create a dummy DLL with empty stubs for each function
p9989
aVCall the DLL mspatcha
p9990
aVdll
p9991
aVMake sure you use a
p9992
aVdef file and stdcall
p9993
aVWhen you've built the DLL, throw it away but keep the
p9994
aVlib file
p9995
aVI've done this in the past to generate
p9996
aVlib files for DLLs built with tool chains that don't emit
p9997
aVlib files
p9998
aVThe technique that you used only works for cdecl functions
p9999
as(dp10000
g7
V505088
p10001
stp10002
a((dp10003
g2
(lp10004
VYou can share event handles between different threads in a process
p10005
aVYour bug lies elsewhere
p10006
as(dp10007
g7
V505088
p10008
stp10009
a((dp10010
g2
(lp10011
VCode like this is easiest to write with pointers like this:
p10012
aVNaturally you do need to respect the issue of read-only memory that Sertac highlighted
p10013
aVI'm just adding this code to illustrate what I believe to be the canonical way to walk a buffer that arrives as a void pointer
p10014
as(dp10015
g7
V505088
p10016
stp10017
a((dp10018
g2
(lp10019
VEven if you get your pointer version to work I don't see why it would be faster
p10020
aVCalling  is faster than your loop since  is reasonably optimized
p10021
aVThe allocation patterns are the same with both versions, two heap allocations and a heap deallocation
p10022
aVI'd stick with the version that works
p10023
aVYou can get rid of the local variable  and assign direct to  to skip a bit of reference counting
p10024
as(dp10025
g7
V505088
p10026
stp10027
a((dp10028
g2
(lp10029
VThere's no way to get around this
p10030
aVOne solution is to stop using the WOW64 emulator and write a 64 bit process
p10031
aVAnother solution is to use IPC rather than direct memory reading
p10032
as(dp10033
g7
V505088
p10034
stp10035
a((dp10036
g2
(lp10037
VYou can't write to parts of the registry owned by other user's unless you have admin rights
p10038
aVIf you can get admin rights, you would be much better using
p10039
aVEven if you could iterate over  it is a brittle solution at best
p10040
aVYou probably don't want to require admin rights
p10041
aVIn which case the registry does not have a place where non-admin users can store data to be shared between all users
p10042
aVConsequently you should save to a file in
p10043
aVOn the other hand, perhaps what you are trying to achieve is to set a value at install time which users will pick up
p10044
aVIf they then modify the setting in your app you want it saved under
p10045
aVYou can do this quite easily by writing your default settings to
p10046
aVThen when your app reads the settings it first looks in
p10047
aVIf the setting is not present, it reads it out of
p10048
aVThe app always writes the values to
p10049
aVAnother variant is to build the default settings into the program rather than  which simplifies the installer
p10050
aVThe bottom line is that iterating of  is not a good solution to any problem that I can envisage
p10051
as(dp10052
g7
V505088
p10053
stp10054
a((dp10055
g2
(lp10056
VWell, the buffer overrun leaps out at me \u2013  isn't big enough to receive
p10057
aVWhy not use  since you are using C++
p10058
aVThat makes these issues vanish
p10059
as(dp10060
g7
V505088
p10061
stp10062
a((dp10063
g2
(lp10064
V is a WinForms property, but you are using WPF
p10065
aVIt's all completely different in WPF
p10066
aVFor example, the  class does not support children which is why there is no  property
p10067
aVWithout knowing what you are trying to achieve it's hard to recommend the right solution
p10068
as(dp10069
g7
V505088
p10070
stp10071
a((dp10072
g2
(lp10073
VThe simplest thing to do is to call
p10074
aVis found in  which is quite a recent RTL addition
p10075
aVThe  flag is passed to the  parameter which means that the contents of the directories are empied before the directory is removed, an essential part of deleting directories
p10076
aVIn a comment you tell us that you use Delphi 7 and so this cannot be used
p10077
aVYour code looks mostly fine
p10078
aVHowever, you don't mean:
p10079
aVI think you mean:
p10080
aVI would probably write it as follows:
p10081
as(dp10082
g7
V505088
p10083
stp10084
a((dp10085
g2
(lp10086
VYou would use a mutex (or more likely a critical section) because that would work
p10087
aVThis code does not synchronise
p10088
aVMultiple threads can enter the critical region
p10089
aVAnd of course, real locks don't spin
p10090
aVWell, spin-locks do, but you need a deep understanding of the performance implications of a spin-lock before electing to use one
p10091
as(dp10092
g7
V505088
p10093
stp10094
a((dp10095
g2
(lp10096
VUnless you need the facilities provided by OLE, I would just stick to good old-fashioned clipboard
p10097
aVIt's much easier to use
p10098
as(dp10099
g7
V505088
p10100
stp10101
a((dp10102
g2
(lp10103
VWhat appears to be happening is that when you switch to 32 bit you fail to locate 32 bit versions of some other dependencies
p10104
aVIt appears to be finding the 64 bit versions of those other dependencies
p10105
aVIf you can arrange that all your DLLs and assemblies are 32 bit, what you are attempting should work
p10106
aVAnother option is to use FreePascal to build a 64 bit DLL
p10107
aVThis might work if the interface is plain old functions, but I'm not sure that FreePascal can do COM
p10108
aVYet another route would be to avoid Delphi altogther and use tools that support 64 bit, e
p10109
ag217
aVVisual Studio
p10110
as(dp10111
g7
V505088
p10112
stp10113
a((dp10114
g2
(lp10115
VI would only change versions if you are currently facing problems that the newer version would resolve
p10116
as(dp10117
g7
V505088
p10118
stp10119
a((dp10120
g2
(lp10121
VPass  to
p10122
aVis returned in the screen coordinate system
p10123
aVconverts points into the form's client coordinate system
p10124
aVIn fact all TControl descendants offer the  method, and its inverse, , to convert between coordinate systems
p10125
as(dp10126
g7
V505088
p10127
stp10128
a((dp10129
g2
(lp10130
VRadioButtons are automatically linked if they are inside the same parent
p10131
aVSince you want them to live in different containers you will have to link them manually
p10132
as(dp10133
g7
V505088
p10134
stp10135
a((dp10136
g2
(lp10137
VAdding items to a list involves reading and writing of memory so unless there is synchronization there is a race
p10138
as(dp10139
g7
V505088
p10140
stp10141
a((dp10142
g2
(lp10143
VCall  which is somewhat more forceful than
p10144
aVSpecifically  will focus and activate a form that is inactive which I suspect is your main problem
p10145
aVHaving more than one form active feels wrong
p10146
aVFinally, did you consider using MDI
p10147
aVIt still works
p10148
as(dp10149
g7
V505088
p10150
stp10151
a((dp10152
g2
(lp10153
VI want run my program under a
p10154
aVlimited user account but with
p10155
aVadministrator privileges
p10156
aVThis can't be done
p10157
aVA limited user doesn't have admin privileges
p10158
aVYou need to run it as an admin user with, e
p10159
ag217
aVrunas
p10160
as(dp10161
g7
V505088
p10162
stp10163
a((dp10164
g2
(lp10165
VThere's no such thing
p10166
aVIn fact I'd bet that there are still some completely undocumented parts of the manifest
p10167
aVIndeed, for a long time the only documentation of the DPI aware part was in Raymond Chen's blog and book
p10168
as(dp10169
g7
V505088
p10170
stp10171
a((dp10172
g2
(lp10173
VYou don't need any special handling
p10174
aVJust call DefWindowProc instead of handling these messages
p10175
as(dp10176
g7
V505088
p10177
stp10178
a((dp10179
g2
(lp10180
VThis can be done without any trickery with overlaying buttons by means of   and/or   hooks
p10181
as(dp10182
g7
V505088
p10183
stp10184
a((dp10185
g2
(lp10186
VEverywhere you cast is probably an error
p10187
aVYou've not shown us all the definitions but the very fact that you are casting suggests something is wrong
p10188
aVYou appear to be passing ANSI parameters to a Unicode function
p10189
aVWhy are you using unsigned
p10190
aVshort instead of a wide char
p10191
aVAlso your SID looks all wrong
p10192
as(dp10193
g7
V505088
p10194
stp10195
a((dp10196
g2
(lp10197
VThe first thing to do is read Marco Cant's paper on
p10198
aVUnicode: http://edn
p10199
aVembarcadero
p10200
aVcom/article/38980
p10201
aVQuestion 1
p10202
aVJust use Char all the time with no conditional code and it will work in old and new
p10203
aVChar is a special type that is an 8 bit type in old versions of Delphi and a 16 bit type in new Unicode versions
p10204
aVQuestion 2
p10205
aVChar is an ordinal type so you can write
p10206
aVYou also need to start loops at 1 for strings since they use 1-based indexing
p10207
aVQuestion 3
p10208
aVWriting #0013 is not needed, #13 is fine
p10209
aVIn short almost all well written code will need no changes
p10210
as(dp10211
g7
V505088
p10212
stp10213
a((dp10214
g2
(lp10215
VThe DLL is either corrupt or it is the wrong bitness
p10216
aV32 and 64 bit modules cannot be mixed
p10217
as(dp10218
g7
V505088
p10219
stp10220
a((dp10221
g2
(lp10222
VThe notification is sent to the parent of the edit
p10223
aVYou are probably listening to the notification in the edit control's window proc
p10224
as(dp10225
g7
V505088
p10226
stp10227
a((dp10228
g2
(lp10229
VThe easiest way to resolve this is to allocate the array at the call site and pass it to the fibonacci function to be populated
p10230
as(dp10231
g7
V505088
p10232
stp10233
a((dp10234
g2
(lp10235
VNo there is no such setting
p10236
aVYour best bet is to use bash through cygwin but I expect you already knew that bit
p10237
as(dp10238
g7
V505088
p10239
stp10240
a((dp10241
g2
(lp10242
VFloating point arithmetic cannot represent all numbers exactly
p10243
aVThus rounding errors like you observe are inevitable
p10244
aVOne possible strategy is to use a fixed point format, e
p10245
ag217
aVA decimal or currency data type
p10246
aVSuch types still can't represent all numbers but would behave as you expect for this example
p10247
as(dp10248
g7
V505088
p10249
stp10250
a((dp10251
g2
(lp10252
VBoth will get called
p10253
aVThe advice is sound though since using both is confusing to readers of the code
p10254
as(dp10255
g7
V505088
p10256
stp10257
a((dp10258
g2
(lp10259
VUse the  parameter of the event handler to identify the textbox responsible for the event
p10260
as(dp10261
g7
V505088
p10262
stp10263
a((dp10264
g2
(lp10265
VIt's too big for the stack
p10266
aVInstead you need to allocate it on the heap with malloc
p10267
as(dp10268
g7
V505088
p10269
stp10270
a((dp10271
g2
(lp10272
VFor explicit linking with  I would argue that one should use the absolute path to the DLL if at all possible
p10273
aVFor implicit linking with
p10274
aVlib files then the name of the DLL has to be determined at link time which rules out absolute paths
p10275
aVIt is safest to put the DLL in the same directory as the executable, under %Program Files% and protected by UAC, and to use the new DLL search order
p10276
as(dp10277
g7
V505088
p10278
stp10279
a((dp10280
g2
(lp10281
VTwo ideas occur to me:
p10282
aVuninitiased variables
p10283
aVfloating point arithmetic is not associative
p10284
aVThe latter point can yield machine accuracy level differences under multi-threading
p10285
aVIt's much more likely to be uninitiased variables though
p10286
as(dp10287
g7
V505088
p10288
stp10289
a((dp10290
g2
(lp10291
VIf you want to do this well you need to give up on VBA and write a COM add-in
p10292
as(dp10293
g7
V505088
p10294
stp10295
a((dp10296
g2
(lp10297
VIt would make more sense to me to show your app full screen
p10298
aVPoking at the internals of the taskbar like this is surely going to cause trouble
p10299
aVUsers are likely going to be annoyed at losing their taskbar
p10300
aVThe taskbar belongs to the user not the app
p10301
as(dp10302
g7
V505088
p10303
stp10304
a((dp10305
g2
(lp10306
VThe only explanation for this that I can come up with is that your frame's handle is recreated after you post the message and before the message queue is pumped
p10307
aVTry posting in an OnShow
p10308
as(dp10309
g7
V505088
p10310
stp10311
a((dp10312
g2
(lp10313
VThat's an anti-pattern that results in memory fragmentation
p10314
aVInstead use  and call the Add method to add new items
p10315
aVThere is no one liner to extend an array and add an item
p10316
aVYou could create your own dynamic array wrapper using generics to do this should you so desire
p10317
aVEssentially that's what  is
p10318
as(dp10319
g7
V505088
p10320
stp10321
a((dp10322
g2
(lp10323
VI'd imagine it happens when the mouse is captured: WM_MOUSELEAVE not being generated when left mouse button is held
p10324
as(dp10325
g7
V505088
p10326
stp10327
a((dp10328
g2
(lp10329
VThe very simplest solution is to use  to invoke the installer on the
p10330
aVmsi
p10331
aVYou can customise the installation using command line settings including setting
p10332
aVmsi properties, silent installation etc
p10333
as(dp10334
g7
V505088
p10335
stp10336
a((dp10337
g2
(lp10338
VYou simply assign one variable to another and let the Delphi compiler do all the conversion for you:
p10339
aVIf you want to convert in the other direction, and restricting the discussion to Delphi 7 for which Char, PChar, string are all ANSI data types you would use the following:
p10340
aVThe casts are needed when going in this direction and in the case of the WideString the data must be explicitly converted from Unicode to ANSI before asking for a null-terminated C string pointer
p10341
as(dp10342
g7
V505088
p10343
stp10344
a((dp10345
g2
(lp10346
VThere is no such shortcut, sadly
p10347
aVA rather similar question was asked recently here: How to automatically implement inherited abstract methods in Delphi XE
p10348
as(dp10349
g7
V505088
p10350
stp10351
a((dp10352
g2
(lp10353
VThere is no single method to do this
p10354
aVYou could write your own constructor to do this as so:
p10355
aVThen you could write:
p10356
aVUpdate
p10357
aVAs Uwe correctly points out in his answer, the code I present should use the  method:
p10358
as(dp10359
g7
V505088
p10360
stp10361
a((dp10362
g2
(lp10363
VThe normal way to do this is with virtual constructors
p10364
aVA good example is  which you are no doubt familiar
p10365
aVhas the following constructor:
p10366
aVThe other key to this is  which is declared as
p10367
aVWhen the VCL streams
p10368
aVdfm files it reads the name of the class from the
p10369
aVdfm file and, by some process that we don't need to cover here, converts that name into a variable,  say of type
p10370
aVIt can then instantiate the object with:
p10371
aVThis is the big advantage of having a virtual constructor and I would encourage you to take the same approach
p10372
aVIf you have to use a string to identify the class then you'll still need to come up with a lookup routine to convert from the string class name to a class reference
p10373
aVYou could, if convenient, hook into the same VCL mechanism that  uses, namely
p10374
aVAlternatively if you could replace  in your code with a class reference then you could write:
p10375
as(dp10376
g7
V505088
p10377
stp10378
a((dp10379
g2
(lp10380
VIn C++ nothing is guaranteed to be atomic
p10381
as(dp10382
g7
V505088
p10383
stp10384
a((dp10385
g2
(lp10386
VThe errors are linker errors because you haven't included the corresponding
p10387
aVlib file, Shlwapi
p10388
aVlib
p10389
aVYou can include the
p10390
aVlib file in the project settings, or alternatively by adding this
p10391
aVto, for example, StdAfx
p10392
aVh
p10393
as(dp10394
g7
V505088
p10395
stp10396
a((dp10397
g2
(lp10398
VI think a relatively easy solution would be to switch the form's  to  and position and size it on the parent form's resize event
p10399
aVPresumably you've got a splitter in there whose size events you would also have to listen to
p10400
aVSo long as you only have the inspector and the design form then that's a pretty simple solution to implement
p10401
aVIf you have more tool windows in there then it would get more tricky but the basic idea can be extended
p10402
as(dp10403
g7
V505088
p10404
stp10405
a((dp10406
g2
(lp10407
V in C is a variadic function which can be thought of as a form of overloading
p10408
aVUnlike overloaded functions in languages like C++, Java, C# etc
p10409
aV, a variadic function is not type-safe which is why they are somewhat frowned upon
p10410
as(dp10411
g7
V505088
p10412
stp10413
a((dp10414
g2
(lp10415
VYou have to declare in your  attribute that you want the last error to be captured using the  field
p10416
aVFor example:
p10417
as(dp10418
g7
V505088
p10419
stp10420
a((dp10421
g2
(lp10422
VYou need to declare the function before you call it, otherwise the compiler will try to work out what the function prototype is on your behalf
p10423
aVThe message
p10424
aVprevious implicit declaration of copyToCode
p10425
aVis telling you this
p10426
aVAn implicit declaration is one that the compiler makes because you haven't yet given it an explicit declaration
p10427
aVIn your update to the question you say that  is intended to be an array of strings but you define it as:
p10428
aVThat allocates a single string
p10429
aVAn array of strings would be held in a , just like
p10430
aVYou would need to allocate the array first, which would contain  strings, each being a
p10431
aVThen you'd have to allocate each  one by one in a loop
p10432
aVThis sort of coding is so much easier in C++ with the standard library string and vector classes
p10433
as(dp10434
g7
V505088
p10435
stp10436
a((dp10437
g2
(lp10438
VYou can do the following using the slice syntax on the left hand side of an assignment:
p10439
aVThat's about as Pythonic as it gets
p10440
as(dp10441
g7
V505088
p10442
stp10443
a((dp10444
g2
(lp10445
VThe answer depends on how you prefer to store the value in C#
p10446
aVYou should choose whichever is most convenient
p10447
aVIf you store it in your C# variable as an unsigned value, then marshal it as
p10448
aVIf you store it in your C# variable as a signed value, then marshal it as
p10449
aVThe point being that once that byte crosses the module boundary it's the bitwise representation that matters and not the logical representation in the C# code
p10450
aVAn unsigned value of 255 is equivalent to a signed value of -1 once you have reached the C++ code
p10451
aVOf course, this assumes that you are using  as a character type
p10452
aVIn a comment to the question you state that you are using it as a integer type, in which case you need to decide whether or not it is signed and marshal accordingly
p10453
as(dp10454
g7
V505088
p10455
stp10456
a((dp10457
g2
(lp10458
VIn my opinion the best way to do this is to make the following simple API call:
p10459
aVThis not only deals with Windows 7 jump lists but also adds your file into the system's list of recently used documents which has an effect on early versions of Windows too
p10460
aVCall the function whenever you open or save a file
p10461
aVFor your convenience, a link to the documentation of
p10462
as(dp10463
g7
V505088
p10464
stp10465
a((dp10466
g2
(lp10467
VPersonally I always write
p10468
aVrather than
p10469
aVbecause I believe it reads better, and not just for dynamic arrays
p10470
aVThat answers the question for dynamic arrays, but your example is an open array, so there are two possible questions here
p10471
aVFor open arrays I would use  or  to take decision based on the size of the array
p10472
aVI would not be seduced by arguments that  is quicker than
p10473
aVThe difference in speed between these options will not be discernible and so you should use the most clear and readable option
p10474
as(dp10475
g7
V505088
p10476
stp10477
a((dp10478
g2
(lp10479
VYou need to place the  line before the code whose errors you wish to handle
p10480
aVWhat's more you only need to have one  line
p10481
aVThe error handler then stays active until the subroutine exits or you execute another  statement
p10482
as(dp10483
g7
V505088
p10484
stp10485
a((dp10486
g2
(lp10487
VYou don't appear to have allowed space for the zero-terminator
p10488
aVYou should be allocating an extra  for that
p10489
aVI'm assuming that the  in the  is for the path separator
p10490
aVMake it  and you'll have space for the terminating null character
p10491
as(dp10492
g7
V505088
p10493
stp10494
a((dp10495
g2
(lp10496
VAndreas has you covered for question 1
p10497
aVQuestion 2
p10498
aVI would arrange that your event handler called another method:
p10499
aVThat way you can just call  directly
p10500
aVI'd guess that you want to call it with no parameters because you want code to run when the edit control's text is modified
p10501
aVYou could perhaps use the  event instead
p10502
aVAnd it may be that  is more appropriate because pressing a key is not the only way to get text into an edit control
p10503
aVBy the way, it's better to ask one question at a time here on Stack Overflow
p10504
as(dp10505
g7
V505088
p10506
stp10507
a((dp10508
g2
(lp10509
VIt's not meaningful to compare references looking for order relationships
p10510
aVIt's only meaningful to look for equality
p10511
as(dp10512
g7
V505088
p10513
stp10514
a((dp10515
g2
(lp10516
VCall GetOpenFileNameW
p10517
aVYou can do this without converting your entire app to Unicode which may be the most expedient solution
p10518
aVWindows API comes in 2 flavours, ANSI and Unicode
p10519
aVThe former has functions with an A suffix
p10520
aVThe latter have a W suffix
p10521
aVYou are currently using the former
p10522
as(dp10523
g7
V505088
p10524
stp10525
a((dp10526
g2
(lp10527
VYou are returning a stack allocated variable, , from
p10528
aVThis is illegal since stack allocated memory is only valid in the function in which the variable is declared
p10529
aVInstead you need to return a heap allocated string
p10530
aVYour compiler should be warning you of this
p10531
aVYou could write it like this:
p10532
aVRemember to  the memory after you are finished with it
p10533
as(dp10534
g7
V505088
p10535
stp10536
a((dp10537
g2
(lp10538
VNo, by declaring  in , you have taken the global  out of scope
p10539
aVInside  when you refer to  you get the local variable
p10540
as(dp10541
g7
V505088
p10542
stp10543
a((dp10544
g2
(lp10545
VThere's little point in trying to create hard links in a parallel fashion
p10546
aVThis is not a CPU bound operation, it is I/O bound
p10547
aVI would not expect any performance benefit from this approach when compared against the naive serial approach
p10548
aVYour question about managed and unmanaged code relating to hardlink creation is interesting
p10549
aVYou must remember that any I/O access from managed code will at some point call into unmanaged code
p10550
aVThe OS is not managed and the only way to create a hardlink is to go through the OS
p10551
aVI think you need to be more precise about exactly what this restriction of the CTP to managed code really means
p10552
as(dp10553
g7
V505088
p10554
stp10555
a((dp10556
g2
(lp10557
VYou are probably running your time consuming task in the main thread
p10558
aVOne option is to move it to a background thread which will allow your message queue to be serviced
p10559
aVYou need it to be serviced in order for your progress bar, and indeed any UI, to work
p10560
as(dp10561
g7
V505088
p10562
stp10563
a((dp10564
g2
(lp10565
VThere's no API call for this
p10566
aVAssuming that you can't modify the target app to provide the information on demand, the only solution I can see is a global hook
p10567
aVThis allows you to inject your code into the thread in question
p10568
as(dp10569
g7
V505088
p10570
stp10571
a((dp10572
g2
(lp10573
VWithout code we have to guess
p10574
aVMy guesses are:
p10575
aVYou failed to escape the  as
p10576
aVYou are passing an ANSI string to the Unicode version of the API, or vice versa
p10577
aVIt's very hard to see how the API could fail unless it was a coding error of this nature
p10578
aVHaving added code to your question it is now clear that the second of these bullet points is the explanation
p10579
aVYou are passing ANSI string data to a Unicode API and this, of course, fails
p10580
aVTo fix this you are probably best switching all the code to use Unicode strings
p10581
aVIn addition to the Unicode/ANSI issues, I think the buffer handling code is suspect
p10582
aVI don't know why you are assuming 4 characters for a drive
p10583
aVI think it is possible for GetLogicalDriveStrings to return un-mapped drives
p10584
as(dp10585
g7
V505088
p10586
stp10587
a((dp10588
g2
(lp10589
VTo display these supplementary code points you need to use UTF-16 surrogate pairs
p10590
aVA surrogate pair is a way of representing single code points beyond  as two wide characters
p10591
aVYou simply pass a surrogate pair to  and it will be displayed
p10592
as(dp10593
g7
V505088
p10594
stp10595
a((dp10596
g2
(lp10597
VSince you are so memory constrained, the best solution I can envisage is to use a pointer to the first element
p10598
aVIt's hard to imagine that there could be a more space-efficient solution
p10599
as(dp10600
g7
V505088
p10601
stp10602
a((dp10603
g2
(lp10604
VYou can't display UI from a service
p10605
aVThe normal approach to this problem is to run a standard app in the user's desktop and have the service communicate with that app using your preferred form of IPC
p10606
as(dp10607
g7
V505088
p10608
stp10609
a((dp10610
g2
(lp10611
VC++ is a much much more complex language than C# which makes it very hard for a tool to parse and provide Intellisense feedback
p10612
as(dp10613
g7
V505088
p10614
stp10615
a((dp10616
g2
(lp10617
VThe backslash is treated as an escape character
p10618
aVEither escape the backslash itslef in the string like so:
p10619
aVor disable escaping altogether using a verbatim string literal:
p10620
as(dp10621
g7
V505088
p10622
stp10623
a((dp10624
g2
(lp10625
VFirst of all I fixed your indentation a little and added some annotations
p10626
aVThe problem is that when the  statement is true you run a second while loop which leaves  equal to
p10627
aVThe subsequent attempt to de-reference is the seg fault
p10628
as(dp10629
g7
V505088
p10630
stp10631
a((dp10632
g2
(lp10633
VCall  passing
p10634
aVThen read  from the returned process
p10635
aVP/Invoke  passing  or  to hide/show the window
p10636
aVThe P/Invoke signature is:
p10637
aVThe  topic lists the numeric values for the  flags
p10638
aVThanks to @Alex K for suggesting as a comment the use of  rather than
p10639
aVFrom the documentation:
p10640
aVThis function posts a show-window
p10641
aVevent to the message queue of the
p10642
aVgiven window
p10643
aVAn application can use
p10644
aVthis function to avoid becoming
p10645
aVnonresponsive while waiting for a
p10646
aVnonresponsive application to finish
p10647
aVprocessing a show-window event
p10648
as(dp10649
g7
V505088
p10650
stp10651
a((dp10652
g2
(lp10653
VEquality is simple: test for  and  being equal
p10654
aVFor the hash code the simplest approach is to use xor to combine the hash codes from  and
p10655
aVThere are lots of alternative ways of calculating the hash code
p10656
aVIf performance is a bottleneck then you should consider something more tailored than xor
p10657
aVFor example, Stack Overflow offers these links (and many more):
p10658
aVCustom type GetHashCode
p10659
aVWhat is the best algorithm for an overridden System
p10660
aVObject
p10661
aVGetHashCode
p10662
as(dp10663
g7
V505088
p10664
stp10665
a((dp10666
g2
(lp10667
VUsing const prevents an implicit try/finally block which on x86 is rather more expensive than reference counting
p10668
aVThat's really a separate issue to the semantic meaning of const
p10669
aVIt's a shame that performance and semantics are mixed up in this way
p10670
as(dp10671
g7
V505088
p10672
stp10673
a((dp10674
g2
(lp10675
VYour question is:
p10676
aVCan a Delphi string literal span multiple lines
p10677
aVThe answer is no
p10678
as(dp10679
g7
V505088
p10680
stp10681
a((dp10682
g2
(lp10683
VFor X you need a mapping from (0, 300) to (-5, +5)
p10684
aVTherefore you need a linear function f(x) such that f(0)=-5 and f(300)=+5
p10685
aVYou can write that down by inspection as:
p10686
aVYou can apply the same logical trivially to the other axis
p10687
aVThis problem is simplified by the fact that the top left of your screen rectangle is at (0,0) but even if this was not the case, the same principle can be followed
p10688
as(dp10689
g7
V505088
p10690
stp10691
a((dp10692
g2
(lp10693
VHow to cancel propagating (LEGACY)
p10694
aVevents from particular HID (mouse)
p10695
aVdevice
p10696
aVMouse messages are posted to the input thread's message queue
p10697
aVMouse messages are in the range  to
p10698
aVThe simplest approach is to modify your message pump so that it swallows messages in this range
p10699
aVArrange that your message pump looks like this:
p10700
as(dp10701
g7
V505088
p10702
stp10703
a((dp10704
g2
(lp10705
VThe only way to force a particular thread to run is by using process/thread affinity, but I can't imagine ever having a problem for which this was a reasonable solution
p10706
aVThe only way to force a context switch is to force a thread onto a different processor using affinity
p10707
aVIn other words, what you are trying to do isn't really viable
p10708
aVCalling  will result in a context switch if there is another thread ready to run that are eligible to run on this processor
p10709
aVThe documentation states it as follows:
p10710
aVIf calling the SwitchToThread function
p10711
aVcauses the operating system to switch
p10712
aVexecution to another thread, the
p10713
aVreturn value is nonzero
p10714
aVIf there are no other threads ready to
p10715
aVexecute, the operating system does not
p10716
aVswitch execution to another thread,
p10717
aVand the return value is zero
p10718
as(dp10719
g7
V505088
p10720
stp10721
a((dp10722
g2
(lp10723
VRather than using division, it would be easier to construct a pair of numbers that can be divided with no remainder
p10724
aVPick the first number at random,  say, then pick another number at random,  say, and then set
p10725
as(dp10726
g7
V505088
p10727
stp10728
a((dp10729
g2
(lp10730
VYou entire string handling code is wrong
p10731
aVYou allocate memory for a single character only
p10732
aVYou then leak that memory
p10733
aVBefore tackling code like this you need to go back to basics and learn how to use  and
p10734
aVFor example, a routine that might help you would be this:
p10735
aVThis allocates memory for a new string based on the length of the input parameter, and then copies the contents of the input parameter to the new string
p10736
aVEvery time you assign to the  field of your struct you need to use code like this
p10737
aVThere are a lot of other bugs in your code but right now I think you need to step back and improve your understanding of pointers, memory allocation/deallocation etc
p10738
aVCan you find a simpler problem to work with because at your current level, trying to debug this code is likely to be very inefficient
p10739
aVNote: There is no error checking in this sample for ease of exposition
p10740
as(dp10741
g7
V505088
p10742
stp10743
a((dp10744
g2
(lp10745
VC++ doesn't have special syntax for an interface, e
p10746
ag217
aVan  keyword because that just happens to be the design decision taken by the language designer
p10747
aVBut C++ does indeed offer full support for interfaces
p10748
aVInterfaces are not going to become obsolete
p10749
aVIn fact the technique of using interfaces is becoming more and more widely used
p10750
as(dp10751
g7
V505088
p10752
stp10753
a((dp10754
g2
(lp10755
VThere is a flaw in your design
p10756
aVYou have two top-level Windows, the main form and the child modal dialog
p10757
aVThe child modal dialog is what is known as, in Win32 terminology, an owned window
p10758
aVThe main form is un-owned
p10759
aVWhen a top-level un-owned Window is minimized, all the windows that it owns are hidden
p10760
aVThat is functionality provided by the desktop window manager
p10761
aVThe documentation states:
p10762
aVAn owned window is hidden when its
p10763
aVowner is minimized
p10764
aVWhat you are trying to do sounds unusual anyway
p10765
aVNormally when a form shows a modal dialog, the modal dialog is shown on top of the other form
p10766
aVWhy are you wanting to hide the main form
p10767
aVIf you are dead-set on this design you need to arrange that your modal dialog is an un-owned window
p10768
aVWhen you do so it will appear as an item in the taskbar separate from your main form
p10769
aVIs this what you want
p10770
as(dp10771
g7
V505088
p10772
stp10773
a((dp10774
g2
(lp10775
VYou simply cannot mix iterators and  this way
p10776
aVYou should pick one method and stick to it
p10777
as(dp10778
g7
V505088
p10779
stp10780
a((dp10781
g2
(lp10782
VYou can do this using the  module rather than the  statement
p10783
aVThe problem with the  statement is that the test for  runs as part of the import statement before you get a chance to assign to
p10784
aVFor example, you could use  like so:
p10785
aVThe first parameter is assigned to  of the imported module
p10786
as(dp10787
g7
V505088
p10788
stp10789
a((dp10790
g2
(lp10791
VThe easiest way that I know is to use Process Explorer on the running app
p10792
aVJust double-click on the process and read it out of this dialog:
p10793
as(dp10794
g7
V505088
p10795
stp10796
a((dp10797
g2
(lp10798
VHandle the OnKeyDown event and test for
p10799
as(dp10800
g7
V505088
p10801
stp10802
a((dp10803
g2
(lp10804
VSince you have now stated that you can't use @nightcracker's solution, I think you need to use  to assign to the string
p10805
aVI guess that in a real program you wouldn't be using a string literal, hence the need for
p10806
as(dp10807
g7
V505088
p10808
stp10809
a((dp10810
g2
(lp10811
VYou need to call  including the  flag
p10812
as(dp10813
g7
V505088
p10814
stp10815
a((dp10816
g2
(lp10817
VIt's inefficient to write and overwrite the same value
p10818
aVJust wait until you know what value you want to write to the file, and write it
p10819
aVI presume you mean  rather than  since you are writing to the file in this question
p10820
aVIf you absolutely have to go back in the file then you need to call
p10821
aVIn order to do this you need to remember the point in the file to start writing to which you can get by calling
p10822
aVSo, if you want my advice, try not to have to re-write the value
p10823
as(dp10824
g7
V505088
p10825
stp10826
a((dp10827
g2
(lp10828
VDepending on the exact requirements you may wish to trim whitespace
p10829
aVI have not done that here since it was not mentioned in the question
p10830
aVUpdate
p10831
aVI fixed the bug that Serg identified in the original version of this answer
p10832
as(dp10833
g7
V505088
p10834
stp10835
a((dp10836
g2
(lp10837
VThis is a Delphi bug
p10838
aVdoes not assign
p10839
aVRRUZ located the bug in QC
p10840
aVThe code reads:
p10841
aVshould be assigned when the call to  is made
p10842
aVIt's quite hard to work around this bug
p10843
aVis the only way to get an item out of the dictionary without destroying the key and so you have to call it
p10844
aVBut since it won't return the extracted item, you need to first read the item, remember the value, and then call
p10845
as(dp10846
g7
V505088
p10847
stp10848
a((dp10849
g2
(lp10850
VYou will only be able to read this text programmatically if it is contained in a windowed control
p10851
aVYou can easily check this with Spy++
p10852
aVMany GUI frameworks don't use windowed controls for their child controls, or only use windowed controls for some children
p10853
aVIf it is a windowed control then you can identify it by calling  and walking the child structure (obviously you need to use the win32gui equivalent)
p10854
as(dp10855
g7
V505088
p10856
stp10857
a((dp10858
g2
(lp10859
VRaymond Chen answered this question just the other day: How do I make a window remain visible even when the user selects Show Desktop
p10860
as(dp10861
g7
V505088
p10862
stp10863
a((dp10864
g2
(lp10865
VActually most of what you are complaining about is in fact the design of Windows rather than the VCL
p10866
aVSee Windows Features for all the details
p10867
aVThe crux of the matter is the owner property, and I mean the windows owner rather than the VCL owner
p10868
aVAn owned window is hidden when
p10869
aVits owner is minimized
p10870
aVIf you wish to be able to minimise the main form without other windows being hidden then you need to get on top of how owned windows work
p10871
as(dp10872
g7
V505088
p10873
stp10874
a((dp10875
g2
(lp10876
VYour best bet is the  API function
p10877
as(dp10878
g7
V505088
p10879
stp10880
a((dp10881
g2
(lp10882
VThe taskbar icon is a 32 pixel icon
p10883
aVYou are setting both small and large icons to be a 16 pixel icon
p10884
aVUse a 32 pixel icon for ICON_BIG
p10885
as(dp10886
g7
V505088
p10887
stp10888
a((dp10889
g2
(lp10890
VIt fails because it is something that cannot be done
p10891
aVThe documentation states that this error code is returned if:
p10892
aVThe csidl value is not valid
p10893
aVThe csidl value does not refer to a virtual folder
p10894
aVThe csidl value does not refer to a system folder
p10895
aVThe csidl value refers to a folder that cannot be renamed or moved
p10896
aVThe dwFlags value is not 0 (zero)
p10897
aVThe pszPath value is NULL
p10898
aVThe string pointed to by pszPath value is an empty string ("") of
p10899
aVlength zero
p10900
aVI have highlighted the item that is pertinent to your question
p10901
aVThis function exists to allow you to renamed things like the "My Documents" folder
p10902
aVIt doesn't make sense to rename the system directory
p10903
aVClearly you have a problem that needs to be solved but this is not the problem
p10904
aVPerhaps if you expanded on the problem we could help with it
p10905
as(dp10906
g7
V505088
p10907
stp10908
a((dp10909
g2
(lp10910
VYou need arbitrary-precision arithmetic
p10911
as(dp10912
g7
V505088
p10913
stp10914
a((dp10915
g2
(lp10916
VYou write it exactly the same way in C# as you do in C++
p10917
as(dp10918
g7
V505088
p10919
stp10920
a((dp10921
g2
(lp10922
VThe accepted way to do this in Delphi is to use packages rather than DLLs
p10923
aVPackages are essentially DLLs but with Delphi specific capabilities that allow VCL objects to be used across package boundaries
p10924
aVTrying to do this with DLLs will lead to a variety of problems that packages deal with
p10925
aVOne downside of packages is that all modules must be compiled with the same version of Delphi
p10926
aVBut if you are wanting to share objects across module boundaries then you would face the same restriction if you used DLLs
p10927
aVThe Delphi documentation has extensive coverage of packages
p10928
aVHaving said all that, I would add that if you can put all your code into a single module (
p10929
aVexe or
p10930
aVdll) then it does make life a lot simpler
p10931
as(dp10932
g7
V505088
p10933
stp10934
a((dp10935
g2
(lp10936
VFor C++ Builder if you don't use runtime packages and you link against the static RTL then you don't need to supply anything beyond the compiled
p10937
aVexe
p10938
aVI couldn't say what you need for the database connection, but I imagine it is documented and Johan has provided you with an answer that addresses this part of your question
p10939
aVDependency Walker can be used to investigate the dependencies
p10940
as(dp10941
g7
V505088
p10942
stp10943
a((dp10944
g2
(lp10945
VThe point of Direct3D is to move rendering off the CPU and onto the GPU
p10946
aVIf there were to be a significant performance difference it would be for that code that runs on the CPU
p10947
aVTherefore I don't see that there should be any significant performance difference between native and managed code for the part of your code that interfaces with Direct3D
p10948
aVDirect3D itself is not managed code
p10949
as(dp10950
g7
V505088
p10951
stp10952
a((dp10953
g2
(lp10954
VWhat you are asking for cannot be done with generics as implemented in
p10955
aVnet
p10956
aVYour best bet is to define an interface that specifies the operations you need and apply a constraint to
p10957
aVYou could do it with C++ templates for integral values
p10958
aVIt would also be trivial in a language that used duck typing
p10959
as(dp10960
g7
V505088
p10961
stp10962
a((dp10963
g2
(lp10964
VMost random number generators are repeatable
p10965
aVYou need to seed the generator before using it which you typically do using the system time
p10966
as(dp10967
g7
V505088
p10968
stp10969
a((dp10970
g2
(lp10971
VYou need to use the Mono project which supports all these platforms
p10972
aVYou may need to re-work your project to deal with any Windows specific code or features specific to the MS
p10973
aVnet implementation
p10974
as(dp10975
g7
V505088
p10976
stp10977
a((dp10978
g2
(lp10979
VIt would appear from the image that your code is setting the size of the tabs to be wider than they need to be
p10980
aVThe extra padding is present in all your tabs but it is just more visible in the tabs with longer text
p10981
aVI can't be sure why this is but I'd guess that the code to calculate the size of the tabs (based on font metrics) is using a different font from that used to draw the tabs
p10982
as(dp10983
g7
V505088
p10984
stp10985
a((dp10986
g2
(lp10987
VIf you are prepared to use another language (you mention Java) then you may find C++ and Qt to be a good fit
p10988
aVLinking to the existing C code will be trivial and Qt works well on a great many platforms should you ever wish to support other platforms in addition to Linux
p10989
as(dp10990
g7
V505088
p10991
stp10992
a((dp10993
g2
(lp10994
VSplitting the communication up into smaller pieces is actually a pretty good way to solve this problem
p10995
aVYou need to have an initial handshaking communication to establish how many pieces are to be used, but then you can give an accurate estimate of the time to go
p10996
aVMake sure that you don't break it up into pieces that are so small that the communication overhead degrades performance
p10997
as(dp10998
g7
V505088
p10999
stp11000
a((dp11001
g2
(lp11002
VYou could replace  with a macro that calls your unit-testing framework when unit-testing but evaluates to  otherwise
p11003
as(dp11004
g7
V505088
p11005
stp11006
a((dp11007
g2
(lp11008
VThis looks like the classic producer/consumer pattern
p11009
aVThe normal way to solve this is with what is known as a blocking queue
p11010
aVVersion 4
p11011
aV0 of
p11012
aVnet introduced a set of efficient, well-designed, concurrent collection classes for this very type of problem
p11013
aVI think  will serve your present needs
p11014
aVIf you don't have access to
p11015
aVnet 4
p11016
aV0 then there are many websites containing implementations of blocking queues
p11017
aVPersonally my standard reference is Joe Duffy's book, Concurrent Programming on Windows
p11018
aVA good start would be Marc Gravell's blocking queue presented here in Stack Overflow
p11019
aVThe first advantage of using a blocking queue is that you stop using busy wait loops, hacky calls to  etc
p11020
aVUsing a blocking queue to avoid this sort of code is always a good idea
p11021
aVHowever, I perceive a more important benefit to using a blocking queue
p11022
aVAt the moment your code to produce work items, consume them, and handle the queue is all intermingled
p11023
aVIf you use a blocking queue correctly then you will end up with much better factored code which keeps separate various components of the algorithm: queue, producer and consumer
p11024
as(dp11025
g7
V505088
p11026
stp11027
a((dp11028
g2
(lp11029
VMy approach is to use the default compiler calling convention for internal code and to use a well-defined explicitly stated calling convention for any methods which are exported across a module boundary
p11030
aVThe default calling convention for most compilers makes good use of registers for performance reasons so there are advantages to using it where appropriate
p11031
aVIt also makes your code easier on the eye since you don't need to specify the convention to get the default
p11032
aVFor exported functions you clearly need to specify the convention
p11033
aVIf you are making a library that you anticipate will be called from languages other than C or C++ it would be conventional to use stdcall
p11034
aVIf you only expect C or C++ clients then cdecl is probably the most common convention
p11035
as(dp11036
g7
V505088
p11037
stp11038
a((dp11039
g2
(lp11040
VThe way to signal your thread to cancel is to arrange for your thread to check the status of a boolean flag and respond to that
p11041
aVThe flag is set by the controlling thread and then the worker thread does what is needed to abort
p11042
aVYou must check the status of the flag regularly
p11043
aVSuch a solution would be a re-implementation of the built-in Terminated method, but you state that you can't use Terminated
p11044
aVI think this leaves you in a bind
p11045
aVThreads can't safely and reliably be terminated by force so you need a co-operative method
p11046
aVI strongly advise you to re-work your architecture so that use of Terminated is viable
p11047
as(dp11048
g7
V505088
p11049
stp11050
a((dp11051
g2
(lp11052
VThat is a Devexpress component for GDI+
p11053
aVDevexpress units invariably have  or  prefixes
p11054
as(dp11055
g7
V505088
p11056
stp11057
a((dp11058
g2
(lp11059
VClearly there is a name mismatch
p11060
aVYou therefore need to make sure that both sides of the interface use the same name:
p11061
aVWhen exporting the function from the DLL as stdcall it will be decorated
p11062
aVYou can avoid this decoration by using a
p11063
aVdef file
p11064
aVWhen importing using P/Invoke you need to suppress the addition of a  or  suffix
p11065
aVDo so by setting the  field of the  to
p11066
as(dp11067
g7
V505088
p11068
stp11069
a((dp11070
g2
(lp11071
VThere are no ordering guarantees on a  so iterating is the only solution
p11072
aVAny performance improvement by necessity would have to involve a different data structure
p11073
as(dp11074
g7
V505088
p11075
stp11076
a((dp11077
g2
(lp11078
VMy answer to the question you link to still applies
p11079
aVThe objects must know by means of a private boolean flag that they are cached objects
p11080
aVThen they can elect not to destroy themselves in  and
p11081
aVThere really is no alternative if you want to allow  to be called
p11082
aVTo deal with finalization you would want to add the cached objects to a list of cached objects
p11083
aVThat list of objects can be freed at finalization time
p11084
aVOf course the flag to disable freeing would have to be reset whilst you walked the list
p11085
aVHaving made this point regarding finalization, I would advise you to register an expected memory leak and just leak this memory
p11086
aVIt makes the code much simpler and there's nothing to lose
p11087
aVAny memory you don't free will be reclaimed by the OS as soon as your executable closes
p11088
aVOne word of caution: if your code is compiled into a DLL then leaking could be troublesome if your DLL is loaded, unloaded, loaded again etc
p11089
aVWhat all this is telling you is that you are swimming against the current
p11090
aVIs it possible that you could achieve your goals with a different solution that fitted better with the way Delphi is steering you
p11091
as(dp11092
g7
V505088
p11093
stp11094
a((dp11095
g2
(lp11096
VIs there any problem with this code
p11097
aVIt's C++ not C
p11098
aVThe indentation is broken
p11099
aVStick to one statement per line
p11100
aVIt is full of inexplicable magic constants
p11101
aVSort those problems out first and then ask again
p11102
as(dp11103
g7
V505088
p11104
stp11105
a((dp11106
g2
(lp11107
VPNG images do partial transparency using alpha channels
p11108
aVThey do not use masks
p11109
aVI imagine that your problem is that you are not retaining the alpha in your image list
p11110
aVYou should set your image list's  to
p11111
aVI would expect the bitmap's properties to be set correctly when you assign your PNG image to it so remove the line which sets AlphaFormat
p11112
aVAs an aside it is intended that you use  rather than
p11113
aVis an internal method that enables a mild form of double dispatch for
p11114
as(dp11115
g7
V505088
p11116
stp11117
a((dp11118
g2
(lp11119
VYou are making life harder for yourself than necessary
p11120
aVThe way you are expected to do this is with a  window with the  style
p11121
aVI realise this is not an indirect answer to your question but I offer it since it will make your task much simpler - let the system do the heavy lifting for you
p11122
as(dp11123
g7
V505088
p11124
stp11125
a((dp11126
g2
(lp11127
VIf you use  to open the folder then Explorer will do the work for you and re-use an open Explorer window if one exists
p11128
aVThe
p11129
aVnet way to call  is to set the  property of the  object that is passed to
p11130
aVUpdate
p11131
aVHaving now posted your code I can see the problem
p11132
aVYou should ask the system to open the folder rather than trying to start a new explorer
p11133
aVexe process, as so:
p11134
as(dp11135
g7
V505088
p11136
stp11137
a((dp11138
g2
(lp11139
VIf you are set on using Python them I think Qt would be am excellent choice
p11140
aVIt's a fantastic framework that looks good and runs on many platforms
p11141
aVYou won't be limited to Windows
p11142
aVQt can be a bit intimidating but you won't be limited in terms of functionality
p11143
aVThe Qt designer works well with Python
p11144
aVSQLAlchemy works on all common desktop platforms, including Windows
p11145
as(dp11146
g7
V505088
p11147
stp11148
a((dp11149
g2
(lp11150
V returns an  which you can use to wait
p11151
as(dp11152
g7
V505088
p11153
stp11154
a((dp11155
g2
(lp11156
VOnce you have created the string list, you can simply call
p11157
aVOr for older versions of Delphi that do not support the  overloads that accept arrays, you can roll your own
p11158
aVUsing an open array parameter affords the maximum flexibility for the caller
p11159
as(dp11160
g7
V505088
p11161
stp11162
a((dp11163
g2
(lp11164
VIt's pretty implausible that the  API function has a bug
p11165
aVYour next step must be to check error codes and call  when the function fails
p11166
as(dp11167
g7
V505088
p11168
stp11169
a((dp11170
g2
(lp11171
VI'd imagine you need something like this:
p11172
as(dp11173
g7
V505088
p11174
stp11175
a((dp11176
g2
(lp11177
VEach  message overwrites the previous one
p11178
aVThat's why you only observe the effects of the final message
p11179
aVAlthough you state that you don't want to concatenate the buffer before sending the  message, that's the only option with
p11180
aVIf you have an edit control then you can insert text using the  message
p11181
as(dp11182
g7
V505088
p11183
stp11184
a((dp11185
g2
(lp11186
VYou haven't allocated the  pointer before you assign to
p11187
aVFor example, if  is intended to be an array then you would need to write something like this:
p11188
aVwhere  is the length of the  array
p11189
aVOnly after you have done this can you assign to
p11190
as(dp11191
g7
V505088
p11192
stp11193
a((dp11194
g2
(lp11195
VIn pseudo-code you want something like this:
p11196
aVYou'll need to define an array names  that contains the cost of each item
p11197
aVYou'll also want to tackle validation of the user input so that you don't erroneously attempt to read outside the range of the  array
p11198
as(dp11199
g7
V505088
p11200
stp11201
a((dp11202
g2
(lp11203
VYour code will work if you remove the  parameter to
p11204
aVWhen you call it with  the instance is ignored
p11205
aVBut you want this method to work as both a static method and a method that receives an instance
p11206
aVYou can't have it both ways
p11207
as(dp11208
g7
V505088
p11209
stp11210
a((dp11211
g2
(lp11212
VI'd prefer the second option because it allows the function to decide how big a buffer is needed
p11213
aVOften the caller is not in a position to take that decision
p11214
as(dp11215
g7
V505088
p11216
stp11217
a((dp11218
g2
(lp11219
VIn your application's main function:
p11220
aVCreate the login form and use  to show it modally
p11221
aVGet the requested action from the value returned by
p11222
aVIf the user pressed cancel, then return from the main form and thus close the application
p11223
aVOtherwise create the main form and pass it to
p11224
aVIf you do it in this order then the main form won't be shown until your user has finished with the login form
p11225
as(dp11226
g7
V505088
p11227
stp11228
a((dp11229
g2
(lp11230
VYou are outputting 64 in hex format,
p11231
aVSince 64=0x40, the mystery is solved
p11232
as(dp11233
g7
V505088
p11234
stp11235
a((dp11236
g2
(lp11237
VThe MSDN documentation for environment variables tells you what to do:
p11238
aVTo programmatically add or
p11239
aVmodify system environment variables,
p11240
aVadd them to the
p11241
aVHKEY_LOCAL_MACHINE\u005cSystem\u005cCurrentControlSet\u005cControl\u005cSession
p11242
aVManager\u005cEnvironment registry key, then
p11243
aVbroadcast a WM_SETTINGCHANGE message
p11244
aVwith lParam set to the string
p11245
aV"Environment"
p11246
aVThis allows
p11247
aVapplications, such as the shell, to
p11248
aVpick up your updates
p11249
aVYou will of course need admin rights to do this
p11250
aVI know of no way to broadcast a windows message from Windows batch so you'll need to write a small program to do this
p11251
as(dp11252
g7
V505088
p11253
stp11254
a((dp11255
g2
(lp11256
VI think I would use stdout to communicate this
p11257
aVWhen you call the process create a file in a temporary location and pass its handle to the new process as stdout
p11258
aVThen wait on the newly created process handle
p11259
aVOnce the process finishes read the information out of the file
p11260
as(dp11261
g7
V505088
p11262
stp11263
a((dp11264
g2
(lp11265
VCalling convention influences code generation and so it is the compiler that deals with it
p11266
aVThe linker doesn't need to know about that
p11267
as(dp11268
g7
V505088
p11269
stp11270
a((dp11271
g2
(lp11272
VYou can do this exactly the same way in C#
p11273
aVYou need to use P/Invoke to call the unmanaged Windows API from managed code
p11274
aVThere are lots of articles on the web that show how to use P/Invoke
p11275
aVIn fact you can do it in an even easier fashion using the  class as explained here
p11276
aVThe code looks like this:
p11277
aVAnother way to use a delegate in place of a function pointer is:
p11278
as(dp11279
g7
V505088
p11280
stp11281
a((dp11282
g2
(lp11283
VIn Windows, kernel mode drivers live in the kernel and share the kernel's address space
p11284
as(dp11285
g7
V505088
p11286
stp11287
a((dp11288
g2
(lp11289
VYou need to allocate  with a call to  before you can assign to it
p11290
aVI would also advise you to avoid using a global variable
p11291
aVInstead make  local
p11292
as(dp11293
g7
V505088
p11294
stp11295
a((dp11296
g2
(lp11297
VIf you have the string  then you already have the answer
p11298
aVThis string contains four code points in the BMP which in UTF-16 are represented by 8 bytes
p11299
aVYou can access them by index with , with a  loop etc
p11300
aVIf you want the underlying 8 bytes you can access them as so:
p11301
as(dp11302
g7
V505088
p11303
stp11304
a((dp11305
g2
(lp11306
VHow about this:
p11307
as(dp11308
g7
V505088
p11309
stp11310
a((dp11311
g2
(lp11312
VYou don't actually say what your problem is, but my guess is that you are having problems working out how each forked process will consume the parameters
p11313
aVI guess what you do is that each time you fork you need to advance the  pointer to the next command/arg pair
p11314
aVThis forking loop terminates when the command is the zero terminator
p11315
aVI hope I have understood your question because you haven't actually stated what aspect of this problem you are stuck on
p11316
as(dp11317
g7
V505088
p11318
stp11319
a((dp11320
g2
(lp11321
VYou just need to assign to  in the  and, presumably,  events
p11322
as(dp11323
g7
V505088
p11324
stp11325
a((dp11326
g2
(lp11327
VThe standard Windows colour for a tab sheet is white
p11328
aVThat standard came into being when XP themes were introduced
p11329
aVIf a user switches back to Windows Classic then they will get a grey background
p11330
aV[You do mean grey rather than beige don't you
p11331
aVBeige would be truly vile
p11332
aVA panel inside a tab sheet can never be behind the page since it is inside the page
p11333
aVWhat is actually happening is that the panel is being drawn transparently so that the standard tab sheet colour prevails
p11334
as(dp11335
g7
V505088
p11336
stp11337
a((dp11338
g2
(lp11339
VI think it will do what you want if you use  rather than
p11340
aVThat said, I can't see what is wrong with using the window returned by
p11341
as(dp11342
g7
V505088
p11343
stp11344
a((dp11345
g2
(lp11346
VGet process B to write to  which can then be read by process A
p11347
as(dp11348
g7
V505088
p11349
stp11350
a((dp11351
g2
(lp11352
VIn a traditional producer/consumer queue, each consumer thread takes one item off the queue
p11353
aVWhen you enqueue a single item you only need to wake up a single consumer thread
p11354
aVSince any of the consumer threads can handle the task, it does not matter which one is woken up, so long as one is
p11355
aVThus a call to  rather than  suffices
p11356
as(dp11357
g7
V505088
p11358
stp11359
a((dp11360
g2
(lp11361
VIt used to be possible in Vista, but in Windows 7 you can't hide it
p11362
aVWell, you can always switch to Windows Basic theme but I'm sure that's not a practical option
p11363
aVIt only shows when the mouse is over the taskbar button so your users will have to put the mouse on your app's window instead
p11364
as(dp11365
g7
V505088
p11366
stp11367
a((dp11368
g2
(lp11369
VSince a Delphi object is a reference type,  returns the size of a reference, which is the same as the size of a pointer, 4 bytes in current Delphi versions
p11370
aVIf you had the data in a record which is a value type then  would return the size of the contents
p11371
aVHowever, since your structure contains managed types, i
p11372
ag192
aVthe string, you cannot simply save it in one big glob like this
p11373
aVYou need special handling for the string
p11374
aVIf I were you I would save the information item by item
p11375
aVIn particular this gives you control of issues like alignment and allows you to cater for versioning
p11376
aVYou can easily enough write your own very basic code to do this
p11377
aVHowever, you may want to consider using a 3rd party framework if:
p11378
aVThere are a lot of fields to persist and handling them individually would result in very laborious code
p11379
aVYou want to build in some flexibility for versioning of the file format
p11380
aVFor example you may wish to think about what happens in a future version of the software when you add a new field, change the meaning of an existing field etc
p11381
as(dp11382
g7
V505088
p11383
stp11384
a((dp11385
g2
(lp11386
VSince SASS (and indeed any such tool) provides functionality that is orthogonal to that of basic CSS I think the dangers are much reduced in comparison to the C pre-processor
p11387
aVFor example a C macro can be made to look exactly like a C function
p11388
aVYou can't tell the difference between them in the source code but their semantics are very different
p11389
aVIn SASS this is not the case because variables, mixins etc
p11390
aVhave special syntax that is clearly not CSS
p11391
as(dp11392
g7
V505088
p11393
stp11394
a((dp11395
g2
(lp11396
VI guess that you are concerned about the network activity of the file transfer getting in the way of the interactive user
p11397
aVYou don't need to worry about whether or not the user is typing on the keyboard
p11398
aVReally all that matters is whether or not there are competing network activities
p11399
aVOn Windows, for example, you can use Background Intelligent Transfer Service
p11400
aVThis is the same service that Windows Update uses to deliver updates to your desktop without getting in the way of your use of the machine
p11401
aVTo script it you might consider Powershell
p11402
aVIf you are dead set on using Python you can do it with
p11403
aVOther platforms will, no doubt, have similar offerings
p11404
as(dp11405
g7
V505088
p11406
stp11407
a((dp11408
g2
(lp11409
VYou don't need recursion if you have :
p11410
as(dp11411
g7
V505088
p11412
stp11413
a((dp11414
g2
(lp11415
VThe only explanation I have is that your long running handler is pumping the message queue
p11416
aVSo long as you don't pump the queue you can take as long as you like handling an event
p11417
aVIt might look messy since you are neglecting the queue but it will work normally
p11418
as(dp11419
g7
V505088
p11420
stp11421
a((dp11422
g2
(lp11423
VManaged foreground/background threads, the Windows thread quantum and thread priority are orthogonal concepts
p11424
aVBeing a foreground thread means that the process cannot be stopped until it (and all other foreground threads) are stopped
p11425
aVThe quantum is the length of time a thread gets to run before the system will consider scheduling another thread on that processor
p11426
aVThe thread priority determines the pecking order within all ready to run, waiting threads
p11427
aVOf these three items, only foreground/background pertains to managed code
p11428
aVNow to your questions
p11429
aVThe foreground process is a Windows concept
p11430
aVIt is unrelated to foreground/background threads in
p11431
aVnet
p11432
aVThread priority does not affect the quantum
p11433
as(dp11434
g7
V505088
p11435
stp11436
a((dp11437
g2
(lp11438
VYou can do this with a template but this leads to the legacy dialogs in Vista/7
p11439
aVOn those platforms you should make use of IFileDialogCustomize
p11440
aVOf course to support XP you need to implement the template approach too
p11441
as(dp11442
g7
V505088
p11443
stp11444
a((dp11445
g2
(lp11446
VThe solution proposed by ScruffyDuck uses a home-grown approach to UAC that is non-standard and less functional than the standard facilities that are built-in to Windows and that developers are expected to use
p11447
aVApplications that require administrator rights should be marked as such with a manifest:
p11448
aVNote: this is not a complete manifest, I have removed everything other than the  setting
p11449
aVDoing so means that an app will show a UAC elevation dialog when run
p11450
aVFinally, none of this helps non-admin users
p11451
aVFor this reason I would have opted for per-user file associations
p11452
as(dp11453
g7
V505088
p11454
stp11455
a((dp11456
g2
(lp11457
VYou appear to be setting affinity to all 12 processors which is not what you intend
p11458
aVI would, in the main thread, loop over all 12 threads setting affinity
p11459
aVDon't set the affinity inside the thread because that requires the thread to know its index which it often does not need to know
p11460
aVI'd declare a mask variable and assign it the value 1
p11461
aVEach time round the loop you set the thread affinity and then shift by 1
p11462
aVYou should not change the process affinity
p11463
aVA word of caution
p11464
aVSetting affinity is dangerous
p11465
aVIf the user changes process affinity then you may end up with a thread that is not able to run on any processor
p11466
aVBe careful
p11467
aVAlso, it is my experience that manually setting affinity has no performance benefits and sometimes is slower
p11468
aVUsually the system does a good job
p11469
as(dp11470
g7
V505088
p11471
stp11472
a((dp11473
g2
(lp11474
VIt's pretty hard to say anything with certainty since you have not told us about the hardware, the compiler or your code
p11475
aVHowever, a priori, I'd expect the standard library from your compiler to be more efficient than your code
p11476
as(dp11477
g7
V505088
p11478
stp11479
a((dp11480
g2
(lp11481
VI'm not aware of any feature like this in any version of Delphi
p11482
aVHowever, GExperts has such a feature
p11483
as(dp11484
g7
V505088
p11485
stp11486
a((dp11487
g2
(lp11488
V returns the thread ID
p11489
aVYou are erroneously assigning the thread ID to the process ID variable
p11490
aVInstead write:
p11491
as(dp11492
g7
V505088
p11493
stp11494
a((dp11495
g2
(lp11496
VOne key advantage of interfaces in a single inheritance language is that interfaces can be implemented on classes that do not share a common root
p11497
aVAnother point is that interfaces allow what is known as interface inheritance rather than implementation inheritance
p11498
aVThis can sometimes be very useful but proponents of true multiple inheritance regard the lack of multiple implementation inheritance a crucial weakness of C#, Java etc
p11499
as(dp11500
g7
V505088
p11501
stp11502
a((dp11503
g2
(lp11504
V is the officially sanctioned way to fake input
p11505
aVThe limitation is that it sends input to the window that has input focus which may not be what you need
p11506
aVAnother option would be to send a , or similar, if the target window responds appropriately
p11507
aVExactly what the best option is will depend on exactly what type of window you are targetting, which you have not said
p11508
as(dp11509
g7
V505088
p11510
stp11511
a((dp11512
g2
(lp11513
VOnce you elect to draw the non-client area yourself, you have to draw it all
p11514
aVThere are no hybrid options
p11515
as(dp11516
g7
V505088
p11517
stp11518
a((dp11519
g2
(lp11520
VAll you seem to be doing is obfuscating your code
p11521
aVJust use the property directly
p11522
aVThere are no implications beyond making your code easier to follow
p11523
as(dp11524
g7
V505088
p11525
stp11526
a((dp11527
g2
(lp11528
VSince the form is showing modally the correct solution is to set  in your button click handler
p11529
aVThe shortcut is to set the  property of the button to  and then you don't even need the event handler
p11530
aVNote that your form is being created incorrectly
p11531
aVYou are passing the unassigned variable  as the  parameter to the constructor
p11532
aVI expect this is the cause of the access violation
p11533
aVYou should pass another form,  or , for example
p11534
aVIn fact in this case you may as well pass nil so that the code should read:
p11535
aVIf you pass an owner then the form will be destroyed when the owner is destroyed
p11536
aVSince you are destroying it yourself, you don't need to pass an owner
p11537
aVThat said, it is sometimes useful to set the owner, for example if you are using one of the  property values that sets the form's position based on the owner's position
p11538
aVIf so then I recommend passing  in this instance which is a  object reference
p11539
as(dp11540
g7
V505088
p11541
stp11542
a((dp11543
g2
(lp11544
VYes they are identical
p11545
aVwas included in C (and thus inherited into C++) as a notational convenience
p11546
aVin that context is used to dereference a pointer
p11547
as(dp11548
g7
V505088
p11549
stp11550
a((dp11551
g2
(lp11552
VYou should store hashed passwords
p11553
aVFor example you could use one of the SHA algorithms from the Delphi Cryptography Package
p11554
aVWhen you check passwords hash the password that the user supplies and compare against that saved in the file
p11555
aVHave you considered using Windows security rather than attempting to roll your own
p11556
aVAs an aside, you are liable to encounter problems writing to your program directory if your program resides under the program files directory and UAC is in use
p11557
as(dp11558
g7
V505088
p11559
stp11560
a((dp11561
g2
(lp11562
VIt sounds very much as though the author of the original program has invented their own character encoding and provided a font to go with it
p11563
aVMaybe the development tools were restricted to ANSI text and the developers came up with this extreme solution
p11564
aVTest out the hypothesis by writing some English text in the custom
p11565
aVfont and see if Arabic
p11566
aVcharacters appear
p11567
aVIf this is so then you will have to work out what the encoding is and translate the strings character by character
p11568
as(dp11569
g7
V505088
p11570
stp11571
a((dp11572
g2
(lp11573
VTraverse the parents using  passing
p11574
aVThis differs from calling  which will return the owner if the window is a top-level window
p11575
as(dp11576
g7
V505088
p11577
stp11578
a((dp11579
g2
(lp11580
VYou can't export a C++ class from a DLL and use it from a different compiler
p11581
aVWhat you can, and should, do is to export a COM object
p11582
as(dp11583
g7
V505088
p11584
stp11585
a((dp11586
g2
(lp11587
VIf I recall correctly, a partially transparent icon (which I think is what want) has a monochrome bitmap for its mask
p11588
aVThis mask happens to be ignored but you still have to supply it
p11589
aVYou aren't creating a monochrome bitmap, you appear to be creating a 32bpp bitmap
p11590
aVI also don't see anywhere where you initialise the alpha values for you main bitmap so that the areas which you don't write to are transparent
p11591
aVAn example with code is provided here: How To Create an Alpha Blended Cursor or Icon in Windows XP
p11592
as(dp11593
g7
V505088
p11594
stp11595
a((dp11596
g2
(lp11597
Vk1 and k2 contain the same values
p11598
aVWhy are you surprised that they have the same hash code
p11599
aVIt is contracted to return the same value for two objects that compare as equal
p11600
as(dp11601
g7
V505088
p11602
stp11603
a((dp11604
g2
(lp11605
VFor bubble sort you just need to look at an implementation and count how many comparisons there are
p11606
aVThen I think you'll understand
p11607
as(dp11608
g7
V505088
p11609
stp11610
a((dp11611
g2
(lp11612
VYou are allocating one element too few
p11613
aVYour code to delete  never runs because it follows the return
p11614
aVYou also leak  because you overwrite the pointer with that returned by
p11615
aVIf I were you I would probably pass  to  and get  to fill out the array
p11616
aVObviously this code requires  but I will leave error checking as an exercise to the reader
p11617
aVTo call it use code like this:
p11618
aVIf you want to print out values between i1 and i2, say, do it like this:
p11619
aVSince you are using C++, all this code would be simpler with the C++ vector class
p11620
as(dp11621
g7
V505088
p11622
stp11623
a((dp11624
g2
(lp11625
VWhy don't you wrap the access to the file in a mutex or a read/write lock
p11626
aVThen you wouldn't need to rely on a brittle approach like this
p11627
aVIt also sounds like you are polling a file as an inter process communication mechanism
p11628
aVSomething like a pipe is likely to be much more effective
p11629
as(dp11630
g7
V505088
p11631
stp11632
a((dp11633
g2
(lp11634
VIt makes very little difference but my experience is that a 64 bit OS runs some 32 bit apps very slightly better than a 32 bit OS
p11635
aVBut it's marginal at best
p11636
as(dp11637
g7
V505088
p11638
stp11639
a((dp11640
g2
(lp11641
VIt seems unlikely that you would be able to achieve this with
p11642
aVrequires a window handle and I don't believe that  has a suitable window handle to receive the message
p11643
aVMy advice is to look for a method that solves your problem rather than deciding what solution you want and trying to make it fit the problem
p11644
as(dp11645
g7
V505088
p11646
stp11647
a((dp11648
g2
(lp11649
VOpen a communication channel between your app and your service and arrange for the app to tell the service that it is closing because of a logoff event
p11650
as(dp11651
g7
V505088
p11652
stp11653
a((dp11654
g2
(lp11655
VSurely you can detect that an object has been inserted or deleted and make the necessary change
p11656
aVFor example, for a deletion, find the node associated with the deleted object and then delete it
p11657
aVFor an insertion, find the object associated with the parent, and then insert a new node in the right place
p11658
aVIf there are performance problems with walking the tree to find the node associated with the object, then you could use a dictionary
p11659
aVFor a virtual tree view it's easier because you just get the tree view to reflect the object structure
p11660
aVWhen a change is made you request an update and it all happens naturally
p11661
as(dp11662
g7
V505088
p11663
stp11664
a((dp11665
g2
(lp11666
VYour problem is that you are setting  incorrectly
p11667
aVThis is the number of bytes and not the number of characters
p11668
aVThe  is needed since your receiver is interpreting it as a null-terminated string
p11669
aVTherefore your code should read:
p11670
aVAlternatively you could, at the receiving end, make use of  and  to avoid the need for the
p11671
as(dp11672
g7
V505088
p11673
stp11674
a((dp11675
g2
(lp11676
VYou need to use a lower level API, the tool help API
p11677
aVA basic outline of how to get what you need is as follows:
p11678
aVCall  passing
p11679
aVNext walk the processes with  and  until you find the process you want
p11680
aVCall  to close the snapshot
p11681
aVCall  again, this time passing  and the desired process ID found in step 2
p11682
aVWalk the modules with  and  until you find the module you want
p11683
aVCall  to close the snapshot
p11684
as(dp11685
g7
V505088
p11686
stp11687
a((dp11688
g2
(lp11689
VI think it is more conventional to have a one-to-one relationship between header files and source files
p11690
aVThat way you can, in another project, include just a portion of the code, without including header declarations for lots of functions that do not have definitions in the project
p11691
aVSo, for each  file have a corresponding  file with the same name that declares each function in the  file
p11692
aVYou will need to add what is known as a guard to each header file to ensure it is only included once
p11693
aVGuards look like this:
p11694
aVAs for , there's no need for that in what you describe
p11695
aVJust stick to header files
p11696
as(dp11697
g7
V505088
p11698
stp11699
a((dp11700
g2
(lp11701
VThis isn't something you solve with an always on process
p11702
aVYou should use a scheduled task for this
p11703
aVIt solves all the problems for you
p11704
aVIf you absolutely had to do this in your own code the simplest solution is the  function
p11705
aVBut I strongly advise against that approach
p11706
as(dp11707
g7
V505088
p11708
stp11709
a((dp11710
g2
(lp11711
VYou have two top level windows
p11712
aVThe main form is the owner of the child form
p11713
aVOwned windows always appear above their owners, that's just one of the rules of Windows
p11714
aVNote that by owner I am referring to the Windows concept rather than the Delphi concept
p11715
aVThe Windows Features topic explains the rules
p11716
aVThe key statement is:
p11717
aVAn owned window is always above its owner in the z-order
p11718
aVAs for how to make you app behave differently I'm not so sure
p11719
aVIf you make your child form unowned then it will have its own taskbar button and it won't be minimised when the main form is minimised, for example
p11720
as(dp11721
g7
V505088
p11722
stp11723
a((dp11724
g2
(lp11725
VIf the DLL contains C functions then you should avoid
p11726
aVnet and the CLR
p11727
aVThat's a needless overhead
p11728
aVInstead use a C compiler, MSVC for example, to build the DLL and export the functions you need from that DLL
p11729
aVThen import the DLL functions into VBA with  statements
p11730
aVWhen you build the C functions into a DLL make sure that you use the  calling convention since that is the only option with
p11731
aVYou may also need to use a
p11732
aVdef file when building the DLL to avoid name decoration
p11733
aVA very simple example:
p11734
aVC
p11735
aVVBA
p11736
as(dp11737
g7
V505088
p11738
stp11739
a((dp11740
g2
(lp11741
V in C is simply a pointer which you would typically declare as  in C#
p11742
aVThat's the easy part of the process
p11743
aVThe hard part is how to assign to the pointer
p11744
aVIs the pointer to memory owned by the C code
p11745
aVOr is it memory owned by the C# code
p11746
aVAnd who writes to that memory, the C code or the C# code
p11747
aVYou need to know the answers to those questions before you can make forward progress
p11748
as(dp11749
g7
V505088
p11750
stp11751
a((dp11752
g2
(lp11753
VYou can't consume C++ classes in a C# project
p11754
aVIn fact you can't consume C++ classes in any project compiled with a different compiler, e
p11755
ag217
aVa different version of MSVC
p11756
aVYour best approach here is to use COM which is a binary interface standard designed to solve exactly this problem
p11757
as(dp11758
g7
V505088
p11759
stp11760
a((dp11761
g2
(lp11762
VYes,
p11763
aVnet is free in the sense that you can distribute programs built against
p11764
aVnet without paying any licensing money to Microsoft
p11765
as(dp11766
g7
V505088
p11767
stp11768
a((dp11769
g2
(lp11770
VThe troublesome code is most likely this one
p11771
aVI'm assuming that  is of string type
p11772
aVA string variable is in fact nothing more than a pointer to the data structure that holds the string
p11773
aVYou don't need to use pointer syntax because the compiler takes care of that for you
p11774
aVSo what this code does is overwrite the variable holding that pointer with 4 space characters and then write 1031 more spaces over the top of whatever follows the variable
p11775
aVIn short you will completely corrupt your memory
p11776
aVThat would explain why the  works but the very next line of code dies a painful and dramatic death
p11777
aVIf your string indeed had space for 1035 characters your could instead write:
p11778
aVHowever, if may be more idiomatic to write:
p11779
as(dp11780
g7
V505088
p11781
stp11782
a((dp11783
g2
(lp11784
VThat sounds like the some sort of factory pattern
p11785
aVI can't refrain myself from being sceptical about the need for a pattern to describe something so trivial
p11786
as(dp11787
g7
V505088
p11788
stp11789
a((dp11790
g2
(lp11791
VThe syntax is:
p11792
aVAs Eric Lippert points out in a comment, the algorithm which looks up type names on the right side of a  alias declaration does not take keywords, it takes identifiers
p11793
aVHence the need for  rather than
p11794
as(dp11795
g7
V505088
p11796
stp11797
a((dp11798
g2
(lp11799
VFirst of all, I am assuming that the particular threading configuration that is causing the problem reported is that there are multiple  instances, possibly even in different processes, being saved simultaneously from different threads
p11800
aVis not thread-safe
p11801
aVTo avoid any race conditions you need to write (pseudo-)code like this:
p11802
aVIt's not enough to lock around just the file operations because then you may lose changes due to a race
p11803
aVYou have to lock the entire read/modify/write cycle
p11804
as(dp11805
g7
V505088
p11806
stp11807
a((dp11808
g2
(lp11809
VYes, that will work fine
p11810
aVRemember that  escapes any quotes in S by doubling them up
p11811
aVSince you don't have any single quotes in your string you are fine
p11812
aVI presume you mean  rather than
p11813
aVYou've missed an  too
p11814
as(dp11815
g7
V505088
p11816
stp11817
a((dp11818
g2
(lp11819
VRather than handle low-level keypress events, it is best to handle such keyboard actions with accelerators
p11820
as(dp11821
g7
V505088
p11822
stp11823
a((dp11824
g2
(lp11825
VThe byte with code  is invalid in UTF-8 encoded text
p11826
aVI don't know where this text is coming from, but it is either invalid UTF-8, or your code is erroneously trying to treat it as UTF-8
p11827
as(dp11828
g7
V505088
p11829
stp11830
a((dp11831
g2
(lp11832
VFor what it's worth I'd probably reverse the logic and write the troublesome test like this:
p11833
as(dp11834
g7
V505088
p11835
stp11836
a((dp11837
g2
(lp11838
VWhy don't you build it all into a single
p11839
aVmsi and then arrange that the bootstrapper passes a parameter to the installer to specify which of the configs you desire
p11840
aVThat would give a nice decoupling and make maintenance easier
p11841
as(dp11842
g7
V505088
p11843
stp11844
a((dp11845
g2
(lp11846
VBecause this code runs on a different thread from the UI and must be marshalled across to the UI thread with
p11847
aVThe documentation for  states:
p11848
aVExecutes the specified delegate on the thread that owns the control's underlying window handle
p11849
aVThis is all necessary because the underlying Windows framework requires that operations on a window handle are performed by the thread that owns the window handle
p11850
as(dp11851
g7
V505088
p11852
stp11853
a((dp11854
g2
(lp11855
VThe important information is contained in the MSDN topic describing the taskbar
p11856
aVEssentially you need to enumerate the top-level windows and pick out those that are visible, unowned and have the  window style
p11857
aVThis program shows you how it is done:
p11858
as(dp11859
g7
V505088
p11860
stp11861
a((dp11862
g2
(lp11863
VI think your main problem relates to what a Delphi object reference is
p11864
aVConsider the following artificial example:
p11865
aVAt this point we have instances of two, essentially identical, structured types
p11866
aVHowever, the way Delphi presents these instances is quite different
p11867
aVThe record is what is known as a value type and the object is a reference type
p11868
aVWhen you assign to a variable of a reference type, the value is copied
p11869
aVFor example:
p11870
aVExamples of value types include integers, enumerated types, floating point types, records, objects etc
p11871
aVIn contrast, assigning to a reference type variable copies the reference so that both variables refer to the same object
p11872
aVFor example:
p11873
aVOne feature of reference types is that they are all heap allocated, whereas value types can be either heap or stack allocated
p11874
aVExamples of reference types include classes, interfaces, dynamic arrays
p11875
aVDelphi strings are a funny hybrid
p11876
aVAlthough they are implemented as references, copy-on-write makes them behave like value types
p11877
aVDelphi's syntax for objects hides the fact that they are implemented as a reference, i
p11878
ag192
aVa pointer
p11879
aVWhat all this means is that your code is needlessly complicated
p11880
aVThere is no need for you to allocate storage for an object reference since an object variable is already a reference
p11881
aVYou can write it like this:
p11882
aVNote that I am using  since it is an integer type that is defined to be at least the same size as a pointer
p11883
aVThis will become relevant when the 64 bit version of Delphi appears
p11884
as(dp11885
g7
V505088
p11886
stp11887
a((dp11888
g2
(lp11889
VMIDL  is a signed, 64 bit integer
p11890
aVThe Delphi type for this is
p11891
aVDelphi has supported 64 bit integers for as long as I can remember, certainly since Delphi 5 and probably earlier
p11892
as(dp11893
g7
V505088
p11894
stp11895
a((dp11896
g2
(lp11897
VUse
p11898
aVPass in your UTF-8 encoded text, as a byte array
p11899
aVThe function returns a standard
p11900
aVnet string which is encoded in UTF-16
p11901
as(dp11902
g7
V505088
p11903
stp11904
a((dp11905
g2
(lp11906
VFirst of all, you need to wait for the thread to finish before returning from
p11907
aVAnother problem with this code is that the array  is allocated on the stack of the  routine and is thus potentially invalid in the context of a different thread
p11908
aVYou should heap allocate  with a call to
p11909
aVIf you wait for the thread to finish in  then  is probably valid since the stack frame for  will still exist
p11910
aVHowever, any future refactorings are liable to cause you grief so please switch to using
p11911
as(dp11912
g7
V505088
p11913
stp11914
a((dp11915
g2
(lp11916
VThe problem is that the header file contains functions that are not defined in the
p11917
aVlib file
p11918
aVMost likely you have a new header file and an out of date
p11919
aVlib file
p11920
aVPossible solutions:
p11921
aVContact the library vendor to obtain a
p11922
aVlib file that matches the header file and DLL that you are using
p11923
aVCreate the
p11924
aVlib file yourself
p11925
as(dp11926
g7
V505088
p11927
stp11928
a((dp11929
g2
(lp11930
VUse
p11931
aVThe documentation states:
p11932
aVReturn true if the object is a bound method written in Python
p11933
aVThis means that it will work as you intend for classes that you define in Python
p11934
aVHowever, for methods of built-in classes like  or classes implemented in extension modules it will return
p11935
as(dp11936
g7
V505088
p11937
stp11938
a((dp11939
g2
(lp11940
V needs to be performed as a floating point division
p11941
aVI'd write it like this:
p11942
aVThe way you wrote it, the division will be performed as an integer division, and then promoted to a floating point value
p11943
aVThe integer division results in 0 which explains what you are seeing
p11944
as(dp11945
g7
V505088
p11946
stp11947
a((dp11948
g2
(lp11949
VThey are expensive in the sense that they will move the cached file from memory to disk
p11950
aVGenerally you use memory mapped files to avoid doing that
p11951
aVThe normal strategy is to flush as infrequently as your program requirements allow
p11952
as(dp11953
g7
V505088
p11954
stp11955
a((dp11956
g2
(lp11957
VYou can do this with MATLAB objects but you must make sure you use handle objects and not value objects because your nodes will contain cross-references to other nodes (i
p11958
ag192
aVparent, next sibling, first child)
p11959
as(dp11960
g7
V505088
p11961
stp11962
a((dp11963
g2
(lp11964
VThe compiler/linker can't find the Windows lib files
p11965
aVThere are lots of ways to resolve this
p11966
aVFor example, you can add the paths to the locations of the lib files to the  environment variable
p11967
aVOr you can pass the  option to the linker
p11968
aVFinally, it doesn't look like you are compiling V8 here
p11969
aVIt would appear that you are just trying to link to the V8 library that has already been compiled
p11970
as(dp11971
g7
V505088
p11972
stp11973
a((dp11974
g2
(lp11975
VThis is a bit of a messy P/Invoke because you can't (to the best of my admittedly limited knowledge) use any of the built-in easy marshalling techniques
p11976
aVInstead you need to use  like this:
p11977
aVC#
p11978
aVDelphi
p11979
aVI've implemented it with a wrapper function that calls your  function but you'll no doubt want to re-work it
p11980
aVI've assumed you are using a Delphi with Unicode strings
p11981
aVIf not then change  to
p11982
as(dp11983
g7
V505088
p11984
stp11985
a((dp11986
g2
(lp11987
VThe  is for list and the  is for path
p11988
aVCheck out all the other variants, e
p11989
ag217
aVexecl, execlp, execle, execv, execvp
p11990
as(dp11991
g7
V505088
p11992
stp11993
a((dp11994
g2
(lp11995
VIt's easiest to do this recursively, something like this:
p11996
aVCall it like this:
p11997
aVThis example adds to a list but you can replace that action with one of your choosing
p11998
aVNow that we can walk one tree, it's time to walk two trees in tandem
p11999
aVYou can call it like so:
p12000
as(dp12001
g7
V505088
p12002
stp12003
a((dp12004
g2
(lp12005
VHere's an implementation of
p12006
aVNote that for it to work well, you also need a good implementation of
p12007
aVIf you haven't got an implementation of  then you can try this one converted to Pascal from Numerical Recipes
p12008
aVIt's not accurate to double precision though
p12009
as(dp12010
g7
V505088
p12011
stp12012
a((dp12013
g2
(lp12014
VThe CLR immediately commits the full stack space for each thread, as soon as it is created
p12015
aVThe default stack size is 1MB
p12016
aVIf you push your stack over that size, that's a stack overflow and an error is raised
p12017
aVThe CLR adopts a different policy from native code which merely reserves 1MB but commits it on demand
p12018
aVThose are implementation details
p12019
aVIt is best to simply view the stack as a fixed size data structure
p12020
aVThis view fits with both
p12021
aVnet and native stack implementations
p12022
aVA recursive function is the absolute worst way to calculate Fibonacci because its complexity is exponential
p12023
aVInstead you should use an iterative algorithm which is linear in time and constant in space
p12024
aVFor example:
p12025
aVOf course, in reality, you'd overflow your result variable long before you reached a stack overflow
p12026
aVBut the performance of a recursive algorithm is untenable for values of  in the region of 30-40
p12027
aVYet another sensible approach is to fill a static array with pre-calculated values
p12028
aVAgain since the values grow so fast you don't need a very large array for it to contain all values that fit into an  or even a
p12029
as(dp12030
g7
V505088
p12031
stp12032
a((dp12033
g2
(lp12034
VThe convention is to install 32 bit software to  on a 64 bit system
p12035
aVI don't think you want to install your 32 bit software to  \u2013 that would go against the grain
p12036
aVAs to what the fix is, I wonder why Excel thinks your DLLs are installed in
p12037
aVIs it possible that you are using hard-coded paths somewhere
p12038
aVFrom your comment to this answer it does indeed appear that you are hard-coding the installation path
p12039
aVThis sounds like it could be a problem in many ways
p12040
aVYou've discovered the 64 bit OS issue, but what if your user's system drive is D
p12041
aVAnd what if they have a localized version of Windows
p12042
aVIn Germany, for example, the program files folder is typically
p12043
aVFrom what I can glean on how to deploy a VSTO add-in you simply write a bunch of registry keys which include details of where the DLL is located
p12044
aVMy guess is that you currently have this location hard-coded and you need to change your installer to write the location based on the location that the user chooses when installing the VSTO
p12045
as(dp12046
g7
V505088
p12047
stp12048
a((dp12049
g2
(lp12050
VThis setting is the screen DPI, or dots per inch
p12051
aVRead it like so:
p12052
aVI don't think it's possible at the moment for the X and Y values to be different
p12053
aVA value of 96 corresponds to 100% font scaling (smaller), 120 corresponds to 125% scaling (medium) and 144 corresponds to 150% scaling (larger)
p12054
aVHowever, users are able to set values other than these standard ones
p12055
as(dp12056
g7
V505088
p12057
stp12058
a((dp12059
g2
(lp12060
VThe calling convention should be , but since that is the default you can just drop it
p12061
aVI think your SendMessage P/Invoke looks a bit odd but that's probably not the cause of the issue
p12062
aVIn any case I would do it like this:
p12063
aVI think what's happening here is that  is working but isn't assigning the last error
p12064
aVThe only thing that the documentation for  mentions about errors is:
p12065
aVWhen a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied)
p12066
aVThe return value for  is dependent on the message sent
p12067
aVIn the case of  there is apparently no message sent
p12068
aVIn other words you simply do not get any feedback
p12069
as(dp12070
g7
V505088
p12071
stp12072
a((dp12073
g2
(lp12074
VWhen it's in virtual mode you can't get the items out of the list view because the items aren't in the list view
p12075
aVThat's the whole point of virtual mode
p12076
aVInstead, you hold the items and the list view asks for the information it needs to display the items
p12077
aVIf you are operating a list view successfully in virtual mode then you almost certainly already have the items in a list somewhere
p12078
aVQuoting from the documentation:
p12079
aVSetting the VirtualMode property to
p12080
aVtrue puts the ListView into virtual
p12081
aVmode
p12082
aVIn Virtual mode, the normal
p12083
aVItems collection is unused
p12084
aVInstead,
p12085
aVListViewItem objects are created
p12086
aVdynamically as the ListView requires
p12087
aVthem
p12088
aVVirtual mode can be useful under many
p12089
aVcircumstances
p12090
aVIf a ListView object
p12091
aVmust be populated from a very large
p12092
aVcollection already in memory, creating
p12093
aVa ListViewItem object for each entry
p12094
aVcan be wasteful
p12095
aVIn virtual mode, only
p12096
aVthe items required are created
p12097
aVIn
p12098
aVother cases, the values of the
p12099
aVListViewItem objects may need to be
p12100
aVrecalculated frequently, and doing
p12101
aVthis for the whole collection would
p12102
aVproduce unacceptable performance
p12103
aVIn
p12104
aVvirtual mode, only the required items
p12105
aVare calculated
p12106
as(dp12107
g7
V505088
p12108
stp12109
a((dp12110
g2
(lp12111
VA 32 bit process with LARGEADDRESSAWARE set can address 4GB on 64 bit Windows
p12112
aVIt can do so because that's how the wonderful engineers at Microsoft implemented it
p12113
aVIt's documented here
p12114
as(dp12115
g7
V505088
p12116
stp12117
a((dp12118
g2
(lp12119
VFor XP you don't have UAC and so you can't use the  verb
p12120
aVInstead the best you can do is set the  and  properties of
p12121
aVThis pretty much sucks because you'd have to show an authentication dialog or hard code the values
p12122
aVIf I were in your position I'd look very hard for a way to can avoid having to gain admin rights
p12123
aVIf that fails then I'd probably make it a pre-condition for your app to run on XP that the user had admin rights
p12124
as(dp12125
g7
V505088
p12126
stp12127
a((dp12128
g2
(lp12129
VFirst off, that's not mangling, that's decoration
p12130
aVMangling is something that happens with C++ compilers because C++ was originally designed to to support overloading using C style link tools
p12131
aVAs to your question, you can't have two functions with the same name
p12132
aVFor the purposes of applying that rule, the un-decorated name is used
p12133
aVWhy is this so
p12134
aVI'd imagine it is because decoration and calling conventions are not part of the C standard and are specific to each compiler
p12135
aVI'm pretty sure that C compilers supporting multiple calling conventions only came in to being a number of years after C was invented
p12136
as(dp12137
g7
V505088
p12138
stp12139
a((dp12140
g2
(lp12141
VYou can't do this in Vista and up
p12142
aVServices run in a different session and so don't have access to the speaker
p12143
as(dp12144
g7
V505088
p12145
stp12146
a((dp12147
g2
(lp12148
VYou've probably forgotten to assign  to
p12149
aVPersonally I'd do it by overriding the constructor and so keeping the
p12150
aVdfm form out of the way
p12151
aVAs an aside I would like to comment on the code you wrote:
p12152
aVYou don't need to assign an owner to  since you are taking on the task of cleaning up, although it generally does no harm to assign an owner
p12153
aVWhat's more the  is try to do two jobs but it can only really do one
p12154
aVThe call to  is not needed, you can just call
p12155
aVI'd write it like this:
p12156
as(dp12157
g7
V505088
p12158
stp12159
a((dp12160
g2
(lp12161
VEven in Java with , both threads could enter the block with the
p12162
aVIf you want mutual exclusion you need to use a real synchronisation object such as a lock
p12163
as(dp12164
g7
V505088
p12165
stp12166
a((dp12167
g2
(lp12168
VYou may be best to hook the call to PeekMessages and replace it with a version that does what you need
p12169
aVYou could use madshi's hooking routines but it's not hard - I've published a simple hook routine here on Stack Overflow
p12170
aVIf the code was running in an executable module that you compile then you could compile a customised version of Windows
p12171
aVpas that replaced PeekMessage
p12172
aVOf course I'm guessing that you code is Delphi
p12173
as(dp12174
g7
V505088
p12175
stp12176
a((dp12177
g2
(lp12178
VI've written you some sample code for 2D arrays
p12179
aVIt's a bit messy because the marshaller won't naturally handle 2D arrays
p12180
aVInstead I've opted for flattening the arrays, i
p12181
ag192
aVmarshall them as 1D arrays
p12182
aVThis won't have great performance characteristics but perhaps that won't be significant for you
p12183
aVOnly you can know that
p12184
aVDelphi
p12185
aVC#
p12186
aVThe code passes a 2D array from C# to Delphi where it is stored
p12187
aVThen the C# code asks for it back
p12188
aVThe  statements show that the same values are returned as were passed
p12189
aVI have arranged for  to return the dimensions of the array even though this code already knows them
p12190
aVIn reality your C# code is likely going to want to ask the Delphi code for the array size so that it can allocate memory in which to store the values
p12191
aVI won't go on and on about why I've done certain things
p12192
aVFrom previous questions I think you have enough expertise to work it out from this code
p12193
aVIf you do have any questions, leave a comment and I'll do my best to shed some light
p12194
as(dp12195
g7
V505088
p12196
stp12197
a((dp12198
g2
(lp12199
VFor the Unicode conversion functions you need to allocate memory to hold the converted strings
p12200
aVYou are in charge of the lifetime of this memory
p12201
aVFor GetCommandLine you don't need to free the returned block of memory
p12202
aVA very basic rule of thumb is that you have to deallocate if and only if you allocated the memory
p12203
as(dp12204
g7
V505088
p12205
stp12206
a((dp12207
g2
(lp12208
VIf your script runs fine as an interactive user but not as a service then there are a couple of obvious possible causes:
p12209
aVYour service is running under a user account that is unable to perform the actions in the script
p12210
aVYour script tries to interact with the desktop but can't because of session 0 isolation
p12211
aVThese suggestions are essentially guesses but with so little information it's hard to do better
p12212
as(dp12213
g7
V505088
p12214
stp12215
a((dp12216
g2
(lp12217
VYou don't get the z order directly
p12218
aVYou are expected to call passing  or  to walk the z order hierarchy
p12219
aVStart at one of your windows and walk until you find either the other window or your walk terminates
p12220
aVThis then tells you the relationship between the two windows
p12221
as(dp12222
g7
V505088
p12223
stp12224
a((dp12225
g2
(lp12226
VYou don't need your own buffer and indeed it would be dangerous to have one since it will likely get out of synchronisation
p12227
aVBut you don't need to set the entire edit text at once
p12228
aVFrom the documentation:
p12229
aVAlso, if an edit control is multiline, get and set part of the control's text by calling the CEdit member functions GetLine, SetSel, GetSel, and ReplaceSel
p12230
aVis what you are looking for I think
p12231
aVAlthough this text talks about multiline edit controls, ,  etc
p12232
aVwork fine with single line edit controls
p12233
as(dp12234
g7
V505088
p12235
stp12236
a((dp12237
g2
(lp12238
VThe units in a dialog resource are dialog units which are normalized by the dimensions of the dialog font by a rather convoluted process
p12239
aVYou can convert from dialog units to screen pixels with
p12240
aVThere are lots more details in the documentation for  but the recommended approach is to call  and let it do the hard work for you
p12241
as(dp12242
g7
V505088
p12243
stp12244
a((dp12245
g2
(lp12246
VThe documentation states:
p12247
aVIf the function fails, the return
p12248
aVvalue is 0 (zero)
p12249
aVTo get extended
p12250
aVerror information, call GetLastError
p12251
aVThe function fails if the requested
p12252
aVwrite operation crosses into an area
p12253
aVof the process that is inaccessible
p12254
aVI recommend you do what it says to find out why this has failed
p12255
aVHaving made that point, it seems likely that the cause of the failure is that the address 2000, which you are attempting to write to, is not a valid address in that process
p12256
aVThe  parameter is a pointer and you are passing the integer value 2000 as that parameter
p12257
aVThis is therefore interpreted and being a memory address
p12258
aVI suspect you actually intended to pass the address of
p12259
as(dp12260
g7
V505088
p12261
stp12262
a((dp12263
g2
(lp12264
VI submitted a QC report for a related issue over a year ago, but that was for menus
p12265
aVI've never seen this for  since it is a wrapper to the common control and the drawing is handled by Windows
p12266
aVHowever, the images you are seeing are clearly as result of the VCL calling  and passing  \u2013 nothing else looks that bad
p12267
aVAre you 100% sure this really is a
p12268
aVThe fix will surely be to avoid  and call  with the
p12269
aVYou may need to modify some VCL source
p12270
aVFirst find the location where the toolbar is being custom drawn and call this routine instead of the calls to
p12271
aVAn even better fix would be to work out why the toolbar is being custom drawn and find a way to let the system do it
p12272
aVEDIT 1
p12273
aVI've looked at the Delphi source code and I'd guess that you are custom drawing the toolbar, perhaps because it has a gradient
p12274
aVI never even knew that TToolbar could handle custom drawing but I'm just a plain vanilla kind of guy
p12275
aVAnyway, I can see code in  calling the  so I think the explanation above is on the right track
p12276
aVI'm fairly sure that calling my  function above will give you better results
p12277
aVIf could find a way to make that happen when you call  then that would, I suppose, be the very best fix since it would apply wholesale
p12278
aVEDIT 2
p12279
aVCombine the function above with @RRUZ's answer and you have an excellent solution
p12280
as(dp12281
g7
V505088
p12282
stp12283
a((dp12284
g2
(lp12285
VTry this:
p12286
aVAlthough this would seem more normal:
p12287
aVCalling the function with  gives the expected result of 10
p12288
aVYour code wasn't advancing  so you checked the same character each time round the loop
p12289
aVIt also calls  each time round the loop which makes the algorithm O(n^2) which is not ideal
p12290
aVYou may as well walk the string once as per the code above
p12291
aVAs to why your code produced an access violation that must be due to the parts of the code that you haven't shown
p12292
aVOne can only imagine that  must point to an invalid memory address or is not null-terminated
p12293
as(dp12294
g7
V505088
p12295
stp12296
a((dp12297
g2
(lp12298
VActually I think it's the other way around
p12299
aVWikipedia says this:
p12300
aVIn computer operating systems, a
p12301
aVlight-weight process (LWP) is a means
p12302
aVof achieving multitasking
p12303
aVIn the
p12304
aVtraditional meaning of the term, as
p12305
aVused in Unix System V and Solaris, an
p12306
aVLWP runs in user space on top of a
p12307
aVsingle kernel thread and shares its
p12308
aVaddress space and system resources
p12309
aVwith other LWPs within the same
p12310
aVprocess
p12311
aVMultiple user level threads,
p12312
aVmanaged by a thread library, can be
p12313
aVplaced on top of one or many LWPs -
p12314
aVallowing multitasking to be done at
p12315
aVthe user level, which can have some
p12316
aVperformance benefits
p12317
aVSo LWPs share address space within the same process
p12318
aVIn other words an LWP is a sub-process
p12319
as(dp12320
g7
V505088
p12321
stp12322
a((dp12323
g2
(lp12324
VThis is done by design in the VCL code
p12325
aVThe pertinent code is  in XPActnCtrls
p12326
aVpas
p12327
aVThe easiest way to change the behaviour is to register your own version of the XP action bar style based on
p12328
aVThere are plenty of hooks that would allow you to override
p12329
as(dp12330
g7
V505088
p12331
stp12332
a((dp12333
g2
(lp12334
VCreate a
p12335
aVdcr file in the Delphi Image Editor
p12336
aVAdd a bitmap to this with the same name as your control
p12337
aVIt needs to be 24 pixels square, and use 16 colours
p12338
aVLink this
p12339
aVdcr, which is really just a resource file, to your package with a $R in your
p12340
aVdpk for example
p12341
as(dp12342
g7
V505088
p12343
stp12344
a((dp12345
g2
(lp12346
VThe Windows phone team have recently blogged about their work adding clipboard functionality to the next release of the OS
p12347
aVSo you'll have to wait until then
p12348
as(dp12349
g7
V505088
p12350
stp12351
a((dp12352
g2
(lp12353
VIt is code that runs in kernel mode rather than user mode
p12354
aVKernel mode code has direct access to the internals of the OS, hardware etc
p12355
aVInvariably you write kernel mode modules to implement device drivers
p12356
as(dp12357
g7
V505088
p12358
stp12359
a((dp12360
g2
(lp12361
VThe  is susceptible to buffer overrun exploits
p12362
aVThe compiler is recommending that you use an alternative version that deals with that threat
p12363
aVPlease refer to the remarks in the MSDN documentation for
p12364
aVIf you have complete control of the data which is passed to  then you have no cause for concern
p12365
aVIf the data passed to  could be supplied by the user then that creates the potential for a buffer overrun attack
p12366
as(dp12367
g7
V505088
p12368
stp12369
a((dp12370
g2
(lp12371
VI doubt this is easily achieved
p12372
aVWhat if the other apps took the same view
p12373
aVSuppose another app decided that it wanted its sound to play and mute all other apps
p12374
aVWhich app would win
p12375
as(dp12376
g7
V505088
p12377
stp12378
a((dp12379
g2
(lp12380
VC++11 doesn't change the meaning of that implementation of double-checked locking
p12381
aVIf you want to make double-checked locking work you need to erect suitable memory barriers/fences
p12382
as(dp12383
g7
V505088
p12384
stp12385
a((dp12386
g2
(lp12387
VThese two technologies are not comparable
p12388
aVIf you want to draw complex 3D scenes effectively you need Direct3D or OpenGL
p12389
as(dp12390
g7
V505088
p12391
stp12392
a((dp12393
g2
(lp12394
VYou're returning a pointer to memory that lives on the stack
p12395
aVUse heap allocated memory instead
p12396
as(dp12397
g7
V505088
p12398
stp12399
a((dp12400
g2
(lp12401
VIf you have a lot of items then you can use a HashSet to keep the performance acceptable
p12402
aVLoop over the items starting with the HashSet empty
p12403
aVFor each item check if the tag is in the HashSet
p12404
aVIf so this is a duplicate
p12405
aVIf not add the tag to the HashSet
p12406
aVThis approach avoids an N^2 algorithm which is what you get with a nested loop
p12407
aVThe HashSet makes the algorithm linear complexity providing the removal phase is carefully implemented
p12408
aVOf course this may not matter to you depending on how many items you have
p12409
aVIf the list is small use nested loops and keep it simple
p12410
as(dp12411
g7
V505088
p12412
stp12413
a((dp12414
g2
(lp12415
VYou could certainly add your own  for this but in my view it's perfectly valid to return  in this instance
p12416
aVIt's never been my understanding that  implied an intention to implement at some later date
p12417
as(dp12418
g7
V505088
p12419
stp12420
a((dp12421
g2
(lp12422
VI'd avoid all arithmetic (your code has additions and shifts) and do it like this:
p12423
aVis defined in SysUtils like this:
p12424
aVIf you stored your bytes in an array then you could wrap it all up in a  loop
p12425
as(dp12426
g7
V505088
p12427
stp12428
a((dp12429
g2
(lp12430
VAs well as the problem with the read-only memory, you need to return  rather than
p12431
aVBy the time your loop has finished,  points to the null-terminator
p12432
as(dp12433
g7
V505088
p12434
stp12435
a((dp12436
g2
(lp12437
VYou can't write to  unless you have administrator rights
p12438
aVThat has always been true for Windows versions based on NT
p12439
aVWhat changes with UAC is that the admin users run with a standard user token by default and only elevate to gain admin rights for operations that need elevated rights
p12440
aVYou have two options:
p12441
aVFind a way to achieve your goals without writing to
p12442
aVRequire that the user obtains admin rights for the portions of the app that write to
p12443
aVOf these options the first is by far to be preferred
p12444
as(dp12445
g7
V505088
p12446
stp12447
a((dp12448
g2
(lp12449
VIf you want virtualization you need a 32 bit process without a manifest
p12450
aVYou appear to already have a 32 bit process so you need to get rid of the manifest
p12451
aVI expect this will be inconvenient for your nice shiny WinForms app since you'd be abandoning the modern themed look
p12452
aVA simple workaround would be to code this up in a separate process for handling just the part of app that needs virtualization
p12453
aVThe added benefit of this is that the rest of your process wouldn't have to be virtualized
p12454
as(dp12455
g7
V505088
p12456
stp12457
a((dp12458
g2
(lp12459
VBy and large it's hard to find this out in a meaningful way
p12460
aVYour thread will often run on many different processors during its life
p12461
aVYou could call a function to ask which processor you are on and get a context switch whilst the function is executing
p12462
aVWhat should the function return
p12463
as(dp12464
g7
V505088
p12465
stp12466
a((dp12467
g2
(lp12468
VWhen your entry point begins execution, you can rely on the values in the registers and the stack just as you would for any other function with that calling convention
p12469
aVIn other words there's nothing special about an entry point function as compared to any other function
p12470
as(dp12471
g7
V505088
p12472
stp12473
a((dp12474
g2
(lp12475
VThe simplest way to do this is to add a public property to your form class to return the string
p12476
aVAssign to this property as your dialog closes and then read the property from the code that called :
p12477
as(dp12478
g7
V505088
p12479
stp12480
a((dp12481
g2
(lp12482
VYour understanding is not quite right
p12483
aVis an unsigned integer type that is at least as wide as a pointer
p12484
aVThis means that you can cast from any pointer to  and back again without losing information
p12485
aVThe naming of  has clearly tricked you into believing that it represents a pointer when in fact the intention is to indicate that it is as wide as a pointer
p12486
aVYou can think of  as the C++ equivalent to
p12487
aVMy guess is that your function is returning from native to managed a  value
p12488
aVYou would P/Invoke it like this:
p12489
aVI'm electing to use  rather than  since I guess you never need to do anything with the value because this is probably an opaque handle
p12490
aVAnd  is generally to be preferred to  since it is CLS-compliant
p12491
as(dp12492
g7
V505088
p12493
stp12494
a((dp12495
g2
(lp12496
VYou'll need to do the paste manually ensuring that the formatting is ignored
p12497
aVRun this code from a message handler for
p12498
aVI currently do not know how to intercept the CTRL+V keypress and replace it with this code
p12499
aVThe  message is not sent to rich edit controls
p12500
aVAs Cody suggests in the comment, one solution is as follows:
p12501
aVMake sure that all the text in the edit control is marked as protected
p12502
aVSubclass  and override
p12503
aVHandle the  message, and if  then use the paste as text code above and return 1 from the message handler to indicate that the requested operation (a rich paste) is rejected
p12504
as(dp12505
g7
V505088
p12506
stp12507
a((dp12508
g2
(lp12509
VYou should be able to wrap up the conversion at the interface between this unit and its clients
p12510
aVUse AnsiString internally and string everywhere else and you should be fine
p12511
as(dp12512
g7
V505088
p12513
stp12514
a((dp12515
g2
(lp12516
VYou can't use Pascal I/O with huge files like this, not in any version of Delphi
p12517
aVYour best bet is to use a  which has no such limitations
p12518
as(dp12519
g7
V505088
p12520
stp12521
a((dp12522
g2
(lp12523
VIt sounds like each project has a single app type so it seems logical to differentiate in either the
p12524
aVdpr file or the
p12525
aVdproj files
p12526
aVCall a function to set a private global variable from the
p12527
aVdpr file
p12528
aVOr use a conditional defined in the
p12529
aVdproj as you do now
p12530
aVIf it was me I'd stick to a conditional but use the trick of converting it into a Delphi enum with a shared helper method to make it read better
p12531
as(dp12532
g7
V505088
p12533
stp12534
a((dp12535
g2
(lp12536
VMost likely the answer is found in this extract from the documentation:
p12537
aVWindows XP Home Edition,
p12538
aVWindows XP Professional x64
p12539
aVEdition, Windows Server 2003
p12540
aVPlatform Note: The Marquee style is supported only on these platforms
p12541
aVI guess you are on a different platform
p12542
as(dp12543
g7
V505088
p12544
stp12545
a((dp12546
g2
(lp12547
VIt sounds to me like your design is flawed
p12548
aVFor syntax highlighting it is better to keep the text and the formatting separate
p12549
aVBy mixing them up as you have done you have made implementing undo very difficult
p12550
aVYou can no longer rely on the control to do it because you are conflating the text edits with your  formatting edits
p12551
aVHave you considered using something like Scintilla rather than trying to solve this problem again
p12552
as(dp12553
g7
V505088
p12554
stp12555
a((dp12556
g2
(lp12557
VYou need to run your service under a user account that has rights to the network volumes
p12558
aVTypically this means one of your domain accounts
p12559
aVNone of the built in service accounts will have such rights
p12560
as(dp12561
g7
V505088
p12562
stp12563
a((dp12564
g2
(lp12565
VIdiomatic coding would be like this:
p12566
aVThe problem with that is that when non-expert C++ programmers read the samples they most likely will not understand that particular syntax
p12567
aVRaymond Chen wrote about this recentlyway back in 2005
p12568
as(dp12569
g7
V505088
p12570
stp12571
a((dp12572
g2
(lp12573
VThis is the moral equivalent of pretending to the operating system that your machine is an permanent state of RAM crisis
p12574
aVThe system knows how to manage its memory far better than you do, just let it get on with its job
p12575
aVIt is, sadly, a very common mistake for people to worry when their system is using all of its RAM and all of its CPU
p12576
aVIn reality you should be concerned if your system fails to make full use of its resources
p12577
as(dp12578
g7
V505088
p12579
stp12580
a((dp12581
g2
(lp12582
VYou appear to have hit a cache size limit, or perhaps have some problems of repeatability in your timings
p12583
aVWhatever the issue is, you simply should not write matrix multiplication yourself in C# and instead use an optimized version of the BLAS
p12584
aVThat size of matrix should be multiplied in under a second on any modern machine
p12585
as(dp12586
g7
V505088
p12587
stp12588
a((dp12589
g2
(lp12590
VIf I were you I would take the opportunity to wrap this function call up in a more Delphi like wrapper
p12591
aVNotes:
p12592
aVI'm using an implicit DLL import (using ) rather than an explicit
p12593
aVThis reduces the amount of boilerplate code considerably
p12594
aVI'm converting the C style integer code error handling into a Delphi exception
p12595
aVBased on your comment I'm guessing that a non-zero return value means success
p12596
aVOlder versions of C do not have a boolean type and use 0 to mean false and every non-zero value evaluates as true
p12597
aVThe natural way to map this to a Delphi boolean type is with
p12598
aVThis means that your calling code doesn't need to worry about error codes
p12599
aVAll the conversion to and from null-terminated strings is handled in one routine and your calling code again need not concern itself over such trivia
p12600
aVI've written the code so that it is portable between both ANSI and Unicode versions of Delphi
p12601
aVThis allows your calling code to read much more clearly:
p12602
as(dp12603
g7
V505088
p12604
stp12605
a((dp12606
g2
(lp12607
VThis is a 32 bit DLL and a 32 bit process running in the WOW64 emulator on 64 bit Windows
p12608
aVFile redirection is in play and so when a 32 bit process looks in  it is actually redirected to the 32 bit system directory
p12609
aVThe simple and quick solution is to move the DLL to
p12610
aVHowever, as Cody Gray points out in a comment, it is not recommended for you to place application DLLs in the system directory
p12611
aVNormal practice is to place the DLLs in your application folder in the program files directory and make sure that folder is in the DLL search path when the DLL needs to be loaded
p12612
as(dp12613
g7
V505088
p12614
stp12615
a((dp12616
g2
(lp12617
VUse  and the timer event will fire on a worker thread
p12618
aVThe timer delegate is specified when the timer is constructed, and cannot be changed
p12619
aVThe method does not execute on the thread that created the timer; it executes on a ThreadPool thread supplied by the system
p12620
aVI am assuming that what you mean by "should be controlled by a separate thread" is that the event handler runs on a thread other than the UI thread
p12621
as(dp12622
g7
V505088
p12623
stp12624
a((dp12625
g2
(lp12626
VCreate a child window and do its painting in its
p12627
aVCall  when you want to force a re-paint
p12628
as(dp12629
g7
V505088
p12630
stp12631
a((dp12632
g2
(lp12633
VOne minor point, all interfaces have to be fully implemented
p12634
aVAll methods and properties of an interface must be implemented by any implementor \u2013 otherwise the compiler
p12635
aVYou are referring to the runtime errors that can be thrown when you call some methods of an interface
p12636
aVThe documentation for  states:
p12637
aVIList is a descendant of the ICollection interface and is the base interface of all non-generic lists
p12638
aVIList implementations fall into three categories: read-only, fixed-size, and variable-size
p12639
aVA read-only IList cannot be modified
p12640
aVA fixed-size IList does not allow the addition or removal of elements, but it allows the modification of existing elements
p12641
aVA variable-size IList allows the addition, removal, and modification of elements
p12642
aVWhen you call a method that cannot be satisfied by a particular implementation then you get an exception
p12643
aVWhy was the interface designed this way
p12644
aVOne can only speculate, but this particular design allows for the ,  etc
p12645
aVproperties to change during the lifetime of an instance of the interface
p12646
aVShould you design your interfaces this way
p12647
aVThat depends on whether such a design is desirable and meets your needs
p12648
as(dp12649
g7
V505088
p12650
stp12651
a((dp12652
g2
(lp12653
VThis is just how the Vista/7 progress bar is designed
p12654
aVWhen you change the value of the progress bar, the bar is animated to that value progressively
p12655
aVThe only way I know of avoiding this problem is to go backwards when updating the progress bar, as follows:
p12656
aVFor a more complete discussion see Disabling
p12657
aVNET progressbar animation when changing value
p12658
as(dp12659
g7
V505088
p12660
stp12661
a((dp12662
g2
(lp12663
VIf your app can accommodate GPL licensed code, then I'd recommend Hoard
p12664
aVYou'll have to write your own wrapper to it but that is very easy
p12665
aVIn my tests, I found nothing that matched this code
p12666
aVIf your code cannot accommodate the GPL then you can obtain a commercial licence of Hoard, for a significant fee
p12667
aVEven if you can't use Hoard in an external release of your code you could compare its performance with that of FastMM to determine whether or not your app has problems with heap allocation scalability
p12668
aVI have also found that the memory allocators in the versions of msvcrt
p12669
aVdll distributed with Windows Vista and later scale quite well under thread contention, certainly much better than FastMM does
p12670
aVI use these routines via the following Delphi MM
p12671
aVIt is worth pointing out that your app has to be hammering the heap allocator quite hard before thread contention in FastMM becomes a hindrance to performance
p12672
aVTypically in my experience this happens when your app does a lot of string processing
p12673
aVMy main piece of advice for anyone suffering from thread contention on heap allocation is to re-work the code to avoid hitting the heap
p12674
aVNot only do you avoid the contention, but you also avoid the expense of heap allocation \u2013 a classic twofer
p12675
as(dp12676
g7
V505088
p12677
stp12678
a((dp12679
g2
(lp12680
VThat's a rather odd way of writing a test for the return of a null pointer which indicates an error in
p12681
aVI'd write it like this:
p12682
as(dp12683
g7
V505088
p12684
stp12685
a((dp12686
g2
(lp12687
VThat's undefined behaviour
p12688
aVYou are asking ctypes to read a return value that is simply not there
p12689
aVIt reads something off the stack, but what comes back is ill-defined
p12690
as(dp12691
g7
V505088
p12692
stp12693
a((dp12694
g2
(lp12695
VThis is a chained comparison
p12696
aVIt returns true if each pairwise comparison in turn is true
p12697
aVIt is the equivalent to
p12698
aVThis is equivalent to  which evaluates to True
p12699
aVThis is equivalent to  which evaluates to True
p12700
aVEquivalent to  which, as above, evaluates to True
p12701
as(dp12702
g7
V505088
p12703
stp12704
a((dp12705
g2
(lp12706
VYou can call your dynamically obtained methods like this:
p12707
aVBut the problem you will have is that this code will only work for methods that don't take any parameters
p12708
as(dp12709
g7
V505088
p12710
stp12711
a((dp12712
g2
(lp12713
VAre there any functions built into the C language or C-Runtime to extract the base path from a pathname in C
p12714
aVNo there are not
p12715
aVRules for path names are platform specific and so the standard does not cover them
p12716
as(dp12717
g7
V505088
p12718
stp12719
a((dp12720
g2
(lp12721
VThis bit at the start of  can't be right:
p12722
aVWhen you enter this block you delete the first item in the list but don't update the head pointer
p12723
aVI would not be surprised for there to be other problems in the code
p12724
as(dp12725
g7
V505088
p12726
stp12727
a((dp12728
g2
(lp12729
VYou do it by assigning to the Boolean variable
p12730
aVThis will allow you to control the single most important setting, the reporting of memory leaks
p12731
aVIf you want more fine grained control of the FastMM settings then include FastMM in your project just as you did in Delphi 7
p12732
as(dp12733
g7
V505088
p12734
stp12735
a((dp12736
g2
(lp12737
VPull down an older version, e
p12738
ag217
ag5537
ag9193
aV66
p12739
aV0 and it's all good
p12740
aVIt just appears to be some teething trouble whilst the project shifts to its new home
p12741
as(dp12742
g7
V505088
p12743
stp12744
a((dp12745
g2
(lp12746
VThe best you could do would be something like  etc
p12747
aVBut what can you do with  anyway
p12748
aVSince the enumerated types from the different units are different, it's hard to imagine being able to anything with
p12749
aVIn fact how would you even define
p12750
aVThe only thing I could imagine would be possible would be to return the type info but I'm letting my imagination run wild now
p12751
as(dp12752
g7
V505088
p12753
stp12754
a((dp12755
g2
(lp12756
VThe array is too big to fit on your stack
p12757
aVUse the heap with  instead
p12758
as(dp12759
g7
V505088
p12760
stp12761
a((dp12762
g2
(lp12763
VUse  passing  to load the module and then  to save the resource
p12764
aVI am of course assuming that you don't want to extract the resource from the running executable
p12765
aVIf that were the case you could go straight to
p12766
as(dp12767
g7
V505088
p12768
stp12769
a((dp12770
g2
(lp12771
VSince you want an array of bytes then  is wrong \u2013 that's a pointer to a pointer to
p12772
aVYou want  for an array, but if it's fixed length I'd declare it as
p12773
aVIt seems like you want to write something like this:
p12774
aVOr if you want heap allocation use
p12775
aVSince we are reduced to guessing, I think that you meant to say that  is an array of bytes
p12776
aVIn which case the code would be like so:
p12777
as(dp12778
g7
V505088
p12779
stp12780
a((dp12781
g2
(lp12782
VI presume that  is a
p12783
aVSince you say that you are using Delphi 2010, you should be aware that  is actually synonymous with  and is 2 bytes wide
p12784
aVI suspect you really want to be using
p12785
aVThe most glaring problem is that you allocate memory for  and then discard it with the assignment to
p12786
aVWhat's more, the memory that  refers to is destroyed when the procedure ends
p12787
aVI think that you should probably do the following:
p12788
aVSwitch to  for the  calls
p12789
aVChange  into
p12790
aVStop using  altogether and use stack allocation
p12791
aVPerhaps something like this:
p12792
as(dp12793
g7
V505088
p12794
stp12795
a((dp12796
g2
(lp12797
VWell-written Windows programs check that a window is visible before they paint themselves
p12798
aVYou are telling these windows not to render themselves, and then expecting them to render themselves
p12799
aVThat is simply not going to work
p12800
as(dp12801
g7
V505088
p12802
stp12803
a((dp12804
g2
(lp12805
VYou just need to trim  before streaming it to
p12806
aVUse your favourite  function from a library, or write your own
p12807
aVYou can find some options for trim functions here: What's the best way to trim std::string
p12808
aVOnce you have a trim function, and Evan Teran's versions look rather fine, you then can write:
p12809
as(dp12810
g7
V505088
p12811
stp12812
a((dp12813
g2
(lp12814
VTo get precisely what you ask for do this:
p12815
aVBut perhaps what you really want is this:
p12816
as(dp12817
g7
V505088
p12818
stp12819
a((dp12820
g2
(lp12821
VThis is how GDI works and Delphi's  merely mirrors the underlying framework
p12822
aVFor example, consider :
p12823
aVThe LineTo function draws a line from the current position up to, but not including, the specified point
p12824
aVOr :
p12825
aVThe FillRect function fills a rectangle by using the specified brush
p12826
aVThis function includes the left and top borders, but excludes the right and bottom borders of the rectangle
p12827
aVOr :
p12828
aVThe rectangle that is drawn excludes the bottom and right edges
p12829
aVAnd so on and so on
p12830
aVConsider now the API function
p12831
aVRetrieves the dimensions of the bounding rectangle of the specified window
p12832
aVThe dimensions are given in screen coordinates that are relative to the upper-left corner of the screen
p12833
aVThe  and  values in the returned  are 1 pixel beyond the boundary of the window
p12834
aVSo the width of the window really is  and likewise for the height
p12835
aVIt is my guess that the convention was chosen so that this equality holds
p12836
aVThe behaviour you report is not a bug in Delphi's  code \u2014 the code works correctly and exactly as designed
p12837
aVBy far the best approach for developers working with Windows UI is to follow the same conventions
p12838
aVAttempting to adopt your own different conventions will simply lead to confusion and bugs
p12839
as(dp12840
g7
V505088
p12841
stp12842
a((dp12843
g2
(lp12844
VYou need some form of IPC, for example a memory mapped file
p12845
as(dp12846
g7
V505088
p12847
stp12848
a((dp12849
g2
(lp12850
VThere are many hooking libraries that will let you do this, for example Detours or madCodeHook on Windows
p12851
aVNo doubt there are similar libraries on OSX, I just don't know them
p12852
aVIt's very easy to hook a routine and replace it with your own implementation
p12853
aVIt's less easy to retain the option of running the original routine in some circumstances, and that's where using a hooking library will take the pain away for you
p12854
as(dp12855
g7
V505088
p12856
stp12857
a((dp12858
g2
(lp12859
VOn XP you need to use the hook procedure method and the GetOpenFileName API
p12860
aVOn Vista and later this will result in a horrid looking file dialog with limited utility, e
p12861
ag217
aVno search
p12862
aVOn Vista you should use IFileDialog and to customise the dialog you need the IFileDialogCustomize interface
p12863
aVBecause the new Vista dialogs are exposed as COM interfaces they are quite easy to consume in
p12864
aVnet
p12865
as(dp12866
g7
V505088
p12867
stp12868
a((dp12869
g2
(lp12870
VQuoth the documentation (empahsis mine):
p12871
aVWhen this method is invoked on a thread, the system throws a ThreadAbortException in the thread to abort it
p12872
aVThreadAbortException is a special exception that can be caught by application code, but is re-thrown at the end of the catch block unless ResetAbort is called
p12873
aVResetAbort cancels the request to abort, and prevents the ThreadAbortException from terminating the thread
p12874
aVUnexecuted finally blocks are executed before the thread is aborted
p12875
aVThe thread is not guaranteed to abort immediately, or at all
p12876
aVThis situation can occur if a thread does an unbounded amount of computation in the finally blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort
p12877
aVTo wait until a thread has aborted, you can call the Join method on the thread after calling the Abort method, but there is no guarantee that the wait will end
p12878
aVSo the answer is yes, the finally blocks will be executed
p12879
as(dp12880
g7
V505088
p12881
stp12882
a((dp12883
g2
(lp12884
VI've done a bit of digging around and I think you need to marshal the return value as a  interface
p12885
aVI'm sure the P/Invoke marshaller won't magically convert your Delphi  into a
p12886
aVnet  class instance
p12887
aVSo I think you can write it something like this:
p12888
aVCall it like this
p12889
aVI'm assuming that the  and  parameters are input parameters, in which case the default marshalling for string is just fine
p12890
aVYou don't need to specify ANSI character set because that is the default too
p12891
aVYou don't need to name the entry point if it has the same name as the C# function
p12892
aVYou don't need to specify the calling convention because  is the default
p12893
aVThe  interface resides in the ADODB namespace
p12894
aVAs an aside, the use of  in your Delphi function import is spurious
p12895
aVThe  keyword stopped having any effect once we left the 16 bit world behind
p12896
as(dp12897
g7
V505088
p12898
stp12899
a((dp12900
g2
(lp12901
VYou are looking for , perhaps something like this:
p12902
aVwhere ,  and  are integer variables holding values 2000, 3000 and 2 in your example
p12903
as(dp12904
g7
V505088
p12905
stp12906
a((dp12907
g2
(lp12908
VDouble-click to zoom and backspace to zoom out do not seem like an intuitive choice
p12909
aVI'd say that +/- would make sense as zoom keys, like browsers do, but only if you combined them with a CTRL modifier
p12910
aVArrow keys are an absolute no-no for zoom
p12911
aVArrow keys mean move caret, or scroll when there is no caret
p12912
aVNever use them for zoom
p12913
as(dp12914
g7
V505088
p12915
stp12916
a((dp12917
g2
(lp12918
VWay back in older versions of Delphi which did not support records with methods then using  was the way to get your objects allocated on the stack
p12919
aVVery occasionally that would yield worthwhile performance benefits
p12920
aVNowadays  is better
p12921
aVThe only feature missing from  is the ability to inherit from another
p12922
aVYou give up a lot when you change from  to  so only consider it if the performance benefits are overwhelming
p12923
as(dp12924
g7
V505088
p12925
stp12926
a((dp12927
g2
(lp12928
VBoth versions perform an identical job and quite probably the compiler will emit identical object code
p12929
aVThe version using reference parameters is much easier to read
p12930
aVYou can pass a NULL pointer to the version that uses pointers which leads to a memory violation
p12931
aVThe same mistake cannot be made with reference parameters
p12932
as(dp12933
g7
V505088
p12934
stp12935
a((dp12936
g2
(lp12937
VThe only way I know to debug such an app is to run the IDE as administrator
p12938
aVI wouldn't recommend doing this routinely, just for debugging sessions
p12939
as(dp12940
g7
V505088
p12941
stp12942
a((dp12943
g2
(lp12944
VHere's a screenshot from my app:
p12945
aVThis form has a single  located to the right of the tree view in the left-hand pane
p12946
aVTo the right of the splitter is a  which contains the button
p12947
aVHere it is at design time and you can see the splitter drawn with a dashed line:
p12948
aVThe trick is that the splitter doesn't contain controls\u2014for that you use a panel
p12949
aVSo, using your naming you need to replace Splitter1 with a panel to contain the buttons and add a splitter between Panel1 and the new panel
p12950
aVThe left and middle panels and the splitter are aligned  and the right handle panel is aligned
p12951
aVSet
p12952
as(dp12953
g7
V505088
p12954
stp12955
a((dp12956
g2
(lp12957
VYou could always enumerate the modules in your process and if it's a C runtime then get hold of the invalid parameter handler with a call to GetProcAddress
p12958
aVBut you'd be better off trying to fix the bugs at root
p12959
aVTrying to ignore such problems mostly just leads to further problems because memory gets corrupted and so on
p12960
as(dp12961
g7
V505088
p12962
stp12963
a((dp12964
g2
(lp12965
VYou aren't showing enough code but clearly what is happening is that you are redefining the offending types ( and ) between the declaration of  in the interface section and the implementation of the methods
p12966
aVThis redeclaration is either in the form of another unit that you , or in the implementation section of the  unit
p12967
aVFind those other declarations and you'll be able to solve your problem
p12968
aVYour comment at the end of your question is telling:
p12969
aVIf I define these types in the second unit, I get the same error but it's shown in the declaration of the class
p12970
aVThe fact that you tried to re-define the types indicates a problem of understanding
p12971
aVTypes need to be declared once and once only
p12972
aVOnce you define them twice you now have two distinct incompatible types
p12973
aVWhat's even worse, they have the same name
p12974
aVDefine a type once and import it into other units via a  statement
p12975
as(dp12976
g7
V505088
p12977
stp12978
a((dp12979
g2
(lp12980
VIf you want to do as Chrome does put them under
p12981
as(dp12982
g7
V505088
p12983
stp12984
a((dp12985
g2
(lp12986
VThis is the 21st century
p12987
aVModern hardware and compilers know how to produce highly optimised code
p12988
aVWriting multiplication using shifts won't help performance but it will help you to produce code with bugs in
p12989
aVYou have demonstrated this yourself with code that multiplies by 12 rather than 10
p12990
as(dp12991
g7
V505088
p12992
stp12993
a((dp12994
g2
(lp12995
VThe  array holds  elements and you accessing the array with out of bounds indices
p12996
aVHence the seg violation
p12997
aVI think your fundamental problem is that you have not fully grasped how sparse matrices are stored in MATLAB
p12998
aVI'm not an expert on the MATLAB implementation details but my recollection is that it uses compressed column storage
p12999
aVIn essence there are 3 arrays as follows:
p13000
aVwhich contains the  non-zero values
p13001
aVwhich contains the row number of each value in
p13002
aVwhich indexes into  and  identifying the first item in each of the  columns
p13003
aVThat's the executive summary, but I recommend that you read up on the details more carefully
p13004
as(dp13005
g7
V505088
p13006
stp13007
a((dp13008
g2
(lp13009
VYou haven't stated which platform you are using, so I'm going to assume that whatever platform it is, it follows the common rules that only the UI thread can access UI controls
p13010
aVWith that rule in place you have the obvious corollary that the other threads can't read the check box state directly
p13011
aVThe solution is as follows:
p13012
aVCreate some private boolean fields corresponding to the check boxes in the object representing the dialog
p13013
aVWhenever the user modifies a check-box, update the corresponding boolean field
p13014
aVExpose those fields as read-only properties for the other threads to read
p13015
aV(optional) Protect all access to the boolean fields with a mutex
p13016
aVItem 4 is optional because on all architectures I know there is no danger of tearing when accessing a boolean field
p13017
aVThe whole point of this is to avoid the problem that reading and writing UI control state is not thread-safe
p13018
aVBut in the overall design you outline you are never going to be free of a data race
p13019
aVWhen your worker thread reads the state the user may just have changed it, or may be just about to change it
p13020
aVYou can't know and once you allow the worker thread to operate in parallel with the UI thread you must embrace that fact
p13021
as(dp13022
g7
V505088
p13023
stp13024
a((dp13025
g2
(lp13026
VI believe you are looking for radix sort
p13027
as(dp13028
g7
V505088
p13029
stp13030
a((dp13031
g2
(lp13032
VYou can't place the decorator in the parameter list, it has to be around the function or class
p13033
aVYou might want to use an existing decorator as the starting point for your decorator
p13034
as(dp13035
g7
V505088
p13036
stp13037
a((dp13038
g2
(lp13039
VI think you've answered the question yourself
p13040
aVThese directives make the compiler emit warnings, but only if warnings are enabled at that point in the compilation
p13041
aVNote that these symbols produce warnings rather than hints
p13042
aVI personally configure the compiler to treat the use of  symbols as an error rather than a warning
p13043
as(dp13044
g7
V505088
p13045
stp13046
a((dp13047
g2
(lp13048
VThis is a feature of Vista themes
p13049
aVThe only known way to work around this feature is to go backwards during an update
p13050
aVEvery time you set the progress bar counter to N immediately afterwards set it to N-1
p13051
aVThere's nothing wrong with the Delphi code, it's a feature of the common control
p13052
as(dp13053
g7
V505088
p13054
stp13055
a((dp13056
g2
(lp13057
VThe statement you make is false
p13058
aVDelphi is not particularly more easy to decompile than code produced by other mainstream compilers
p13059
aVFor
p13060
aVnet languages there is Reflector
p13061
aVC++ is covered in this Stack Overflow question
p13062
aVPython/Perl/Ruby etc
p13063
aVare interpreted
p13064
aVIf you were able to prove that the results of decompiling a Delphi executable were of significantly higher quality than in other widely used languages then your question would carry more weight
p13065
as(dp13066
g7
V505088
p13067
stp13068
a((dp13069
g2
(lp13070
VYou create instances like this:
p13071
aVThis is the canonical way to instantiate Python objects
p13072
as(dp13073
g7
V505088
p13074
stp13075
a((dp13076
g2
(lp13077
V must be sent rather than posted
p13078
aVI'm not sure that your byte[] marshaling is right either
p13079
as(dp13080
g7
V505088
p13081
stp13082
a((dp13083
g2
(lp13084
VI would recommend Numerical Recipes
p13085
aVIf you are only using a handful of the recipes you can send them an email asking for permission to use commercially, listing the recipes you use
p13086
aVThey are happy to oblige in my experience
p13087
as(dp13088
g7
V505088
p13089
stp13090
a((dp13091
g2
(lp13092
VYou just need to mark your auto updater as requiring elevated privileges in your application manifest
p13093
aVThat said you might want to consider installing somewhere the user has write privileges
p13094
as(dp13095
g7
V505088
p13096
stp13097
a((dp13098
g2
(lp13099
VYou can't do that with the standard theme engine
p13100
aVTo achieve that you'll need to use a third party skinning engine
p13101
as(dp13102
g7
V505088
p13103
stp13104
a((dp13105
g2
(lp13106
VRather than writing a program in C++, it would be much simpler to write a simple
p13107
aVbat script to kill these processes, using the  utility supplied with Windows
p13108
aVFor example
p13109
as(dp13110
g7
V505088
p13111
stp13112
a((dp13113
g2
(lp13114
VSome C compilers treat void pointer arithmetic as they do char*
p13115
aVIt's invalid in C++
p13116
aVNo matter, you really should only be incrementing non void pointers since pointer arithmetic relies on knowledge of the size and alignment of the data type
p13117
as(dp13118
g7
V505088
p13119
stp13120
a((dp13121
g2
(lp13122
VThese switches are documented: http://docwiki
p13123
aVembarcadero
p13124
aVcom/RADStudio/en/IDE_Command_Line_Switches_and_Options
p13125
as(dp13126
g7
V505088
p13127
stp13128
a((dp13129
g2
(lp13130
VAdd a button to the form and write an OnClick event handler like this:
p13131
as(dp13132
g7
V505088
p13133
stp13134
a((dp13135
g2
(lp13136
VYou need to find which package the OCX was installed into, remove it from that package, and then re-install that package
p13137
as(dp13138
g7
V505088
p13139
stp13140
a((dp13141
g2
(lp13142
VYou're not doing anything wrong
p13143
aVThat's just how windows console apps behave
p13144
aVIn normal operation your server apps would surely run as headless services so there should be no issue in production
p13145
as(dp13146
g7
V505088
p13147
stp13148
a((dp13149
g2
(lp13150
VIf you have multiple implementations of an interface that all implement one of its methods in identical fashion then you can use the extract method refactoring
p13151
aVPut the duplicated code into a static method somewhere and call it from your interface implementations
p13152
aVIf the duplication is more pervasive and spans the entire interface then you would be better off writing a helper class to implement that interface
p13153
aVYou can strip out the duplicated code and delegate to an instance of the helper class
p13154
aVThis latter idea is similar to what you tried with inheritance, but instead is a form of composition, delegation
p13155
aVThis is needed because C# only supports single inheritance for implementations
p13156
as(dp13157
g7
V505088
p13158
stp13159
a((dp13160
g2
(lp13161
VFor floating point m, so long as your standard library implementation is well written, then  will be efficient
p13162
aVIf m is an integer, and you hinted that it is, then you could use an array of pre calculated values
p13163
aVYou should only be worrying about this kind of thing if that routine is a bottleneck in your code
p13164
aVThat is if the calls to that routine take a significant proportion of the total running time
p13165
as(dp13166
g7
V505088
p13167
stp13168
a((dp13169
g2
(lp13170
VThe stack size is determined by your linker
p13171
aVPresumably you actually mean whether or not the emitted code is larger or not
p13172
aVIncluding a header file whose declarations are never referenced in that translation unit will not affect the size of the generated objects
p13173
aVOf course, it will slow down compilation
p13174
as(dp13175
g7
V505088
p13176
stp13177
a((dp13178
g2
(lp13179
VWhilst I am sure that you can reduce the thread stacksize in your app, I don't think it will address the root cause of the problem
p13180
aVYou are using an 8 core machine now, but what happens on a 16 core, or a 32 core etc
p13181
aVWith 32 bit Delphi you have a maximum address space of 4GB and so this does limit you to some degree
p13182
aVYou may well need to use smaller stacks for some or all of your threads, but you will still face problems on a big enough machine
p13183
aVIf you help your app scale better to larger machines you may need to take one or other of the following steps:
p13184
aVAvoid creating significantly more threads than cores
p13185
aVUse a thread pool architecture that is available to your plug-ins
p13186
aVWithout the benefit of the
p13187
aVnet environment to make this easy you will be best coding against the Windows thread pool API
p13188
aVThat said, there must be a good Delphi wrapper available
p13189
aVDeal with the memory allocation patterns
p13190
aVIf your threads are allocating contiguous blocks in the region of 200MB then this is going to cause undue stress on your allocator
p13191
aVI have found that it is often best to allocate such large amounts of memory in smaller, fixed size blocks
p13192
aVThis approach works around the fragmentation problems you are encountering
p13193
as(dp13194
g7
V505088
p13195
stp13196
a((dp13197
g2
(lp13198
VThis is normally achieved using Device Input and Output Control (IOCTL)
p13199
aVYou can define your own private control code and then send information in both directions
p13200
aVThe function is called from user mode, i
p13201
ag192
aVthe service in your case
p13202
as(dp13203
g7
V505088
p13204
stp13205
a((dp13206
g2
(lp13207
VThat basically looks fine with one proviso
p13208
aVTrying to use an integer type to hold a pointer is not a great idea\u2014much better to use  since that, by definition, is the width of a pointer
p13209
aVActually, I think @DeadMG's answer is a cleaner approach than this
p13210
as(dp13211
g7
V505088
p13212
stp13213
a((dp13214
g2
(lp13215
VIt's O(1) for both list and tuple
p13216
aVThey are both morally equivalent to an integer indexed array
p13217
as(dp13218
g7
V505088
p13219
stp13220
a((dp13221
g2
(lp13222
VBehind this WinForms control is a Win32 edit control
p13223
aVThe Win32 edit control exposes its text through the  and  messages
p13224
aVYou need to send  first so that you know how big a buffer to allocate
p13225
aVThen you can send  to populate the buffer
p13226
aVIf you just want the length of the text you can obtain it without allocating a buffer by sending just the  message
p13227
aVThe
p13228
aVnet control is simply reflecting this underlying control's behaviour
p13229
aVFor a multi-line control with a lot of text, being able to obtain the text length without having to allocate and populate the buffer could be a very useful for performance
p13230
as(dp13231
g7
V505088
p13232
stp13233
a((dp13234
g2
(lp13235
VBased on your comments I think you need to run Windows DLLs on OSX without using a Windows VM
p13236
aVAssuming that you can't recompile the DLLs to target OSX, I think that your only realistic solution is to use Wine
p13237
as(dp13238
g7
V505088
p13239
stp13240
a((dp13241
g2
(lp13242
VYou should be passing  to the  parameter of
p13243
aVBy passing  you are asking the marshaller to delete the contents of
p13244
aVSince you are filling this out for the first time, this results in a memory access failure because the memory is not yet valid
p13245
aVThe documentation states:
p13246
aVStructureToPtr copies the contents of
p13247
aVstructure to the pre-allocated block of
p13248
aVmemory that the ptr parameter points
p13249
aVto
p13250
aVIf the fDeleteOld parameter is true,
p13251
aVthe pre-allocated buffer is deleted with
p13252
aVthe appropriate deletion method on the embedded pointer, but the buffer
p13253
aVmust contain valid data
p13254
aVThe emphasis is mine
p13255
aVIncidentally I think the loop code looks neater like this:
p13256
as(dp13257
g7
V505088
p13258
stp13259
a((dp13260
g2
(lp13261
VYou aren't checking your Win32 return codes
p13262
aVMy guess is that  fails for some reason and so doesn't assign any values to the rect
p13263
aVThus its values remain uninitialised
p13264
aVCheck the return value and if the call fails use  to find out why
p13265
aVYou'll need to update your P/Invokes too:
p13266
as(dp13267
g7
V505088
p13268
stp13269
a((dp13270
g2
(lp13271
VThis answer assumes you want the messages to be received by controls on a form
p13272
aVThese messages are non-queued and are sent directly to the control
p13273
aVThat explains why your two attempts to receive them have failed
p13274
aVThe only way to receive them is through the window procedure of the control
p13275
aVYou have the following options
p13276
aVSubclass the control and handle the message
p13277
aVThis is perhaps most easily done with and interposer class
p13278
aVUse the  property of the control to replace the window procedure without deriving a new class
p13279
aVYou might find that  could help
p13280
aVIt is called in response to a control receiving  messages, as well as being called in some other situations (see the VCL code for details)
p13281
aVOption 1: Interposer
p13282
aVOption 2: WindowProc
p13283
as(dp13284
g7
V505088
p13285
stp13286
a((dp13287
g2
(lp13288
VI'm a little confused by your question but since you've ruled out everything else I can only imagine you are looking for
p13289
as(dp13290
g7
V505088
p13291
stp13292
a((dp13293
g2
(lp13294
VModern versions of Windows have their users running without admin rights by default
p13295
aVThis is controlled by UAC
p13296
aVThe solution is usually not to attempt to gain admin rights
p13297
aVInstead you should stop attempting things that need admin rights unless you really do need to
p13298
aVTypically only install programs need admin rights
p13299
aVYou don't say why you are writing to a restricted area of the registry but you should be able to find an alternative to doing so
p13300
as(dp13301
g7
V505088
p13302
stp13303
a((dp13304
g2
(lp13305
VThis is a stack allocation rather than static
p13306
aVThe failure mode is stack overflow
p13307
aVThe most rational policy for stack overflow is to regard it as terminal
p13308
aVDesign your code so that it won't overflow the stack rather than trying to make it resilient to stack overflow
p13309
as(dp13310
g7
V505088
p13311
stp13312
a((dp13313
g2
(lp13314
V can be an awkward customer in this regard
p13315
aVYou need to handle the EN_VSCROLL and EN_HSCROLL notification messages in conjunction with the WM_VSCROLL and WM_HSCROLL messages
p13316
aVI found a C++ Builder article that shows what is needed: http://bcbjournal
p13317
aVcom/bcbcaq/
p13318
aVloc=edits&caq;=29
p13319
as(dp13320
g7
V505088
p13321
stp13322
a((dp13323
g2
(lp13324
VC# operator++ does not use interlocked semantics
p13325
aVIt is equivalent to
p13326
as(dp13327
g7
V505088
p13328
stp13329
a((dp13330
g2
(lp13331
VThe term enumerator is often used as a synonym for iterator
p13332
aVAn enum, or enumeration, is something else altogether
p13333
as(dp13334
g7
V505088
p13335
stp13336
a((dp13337
g2
(lp13338
VMy recollection, and it's been a while since I last tried this, is that you need the C++ Builder IDE to do this
p13339
as(dp13340
g7
V505088
p13341
stp13342
a((dp13343
g2
(lp13344
VFor the window handle it is easiest to use  and the  property
p13345
aVYou don't state how you want to identify the other process but the  class has lots of options for that
p13346
aVRegarding the notification area icon, there is no API for what you are asking
p13347
aVYou'd need to either hook the  API or modify the other process to cooperate
p13348
as(dp13349
g7
V505088
p13350
stp13351
a((dp13352
g2
(lp13353
VDelphi doesn't have abstract classes as such, only abstract methods
p13354
aVYou will get an abstract method exception raised if you call an abstract method
p13355
aVPut simply you must not call abstract methods
p13356
aVThe compiler emits a warming if it detects you instantiating a class with abstract methods
p13357
aVGood practise is to ask the compiler to turn these warnings into errors
p13358
as(dp13359
g7
V505088
p13360
stp13361
a((dp13362
g2
(lp13363
VSounds like you have an old version of graphics32 which doesn't have up to date conditional definitions for recent Delphi versions in the GR32
p13364
aVinc include file
p13365
aVSimplest solution is to download the latest graphics32 which has been updated for XE
p13366
aVIt seems you have to get the latest development version for XE compatibility
p13367
as(dp13368
g7
V505088
p13369
stp13370
a((dp13371
g2
(lp13372
VI think for an ISBN you would be much better using a string
p13373
aVYou won't need to perform arithmetic on the value, you can store leading zeroes and you'll want a string to store the X that you can get in an ISBN 10 checksum
p13374
as(dp13375
g7
V505088
p13376
stp13377
a((dp13378
g2
(lp13379
VWhat is happening here is that there are still messages for the dud window in the queue when you show the message box
p13380
aVThe message box runs a modal window message pump and dispatches the troublesome messages
p13381
aVRemember that all windows created from the same thread share a single message queue
p13382
aVI have no idea how to fix your problem but that's what's going on
p13383
aVBy the way, passing a null owner isn't a great idea as it will result in your message box not being minimised when your main app is minimised, for example
p13384
as(dp13385
g7
V505088
p13386
stp13387
a((dp13388
g2
(lp13389
VYou can't just magically make sparse matrix algebra routines scalably parallel
p13390
aVTackling these issues involves some of the most complex numerical analysis algorithms around and is still the subject of intense research
p13391
aVYou don't say what you want to do with these matrices but I imagine that you want solution to systems of linear equations
p13392
aVIf you want that in parallel then you'll need a 3rd party library, very large matrices, and likely some money
p13393
aVThe most common way to assemble sparse matrices is to assemble them in triplet format and convert to compressed row or column format
p13394
aVThe assembly can be expensive but it is easy to do in parallel
p13395
aVJust let each thread have its own list of triplets and splice them together before converting to compressed format
p13396
as(dp13397
g7
V505088
p13398
stp13399
a((dp13400
g2
(lp13401
VSend the window handle, obtained by calling , a  message
p13402
aVOr if you prefer call
p13403
as(dp13404
g7
V505088
p13405
stp13406
a((dp13407
g2
(lp13408
VAn excellent maxim is that the fastest code is that which never runs
p13409
aVSince copying is expensive you should look to avoid the cost of copying
p13410
aVYou can do this with a virtual array
p13411
aVCreate a class which holds an array of
p13412
aVIn your example the outer array would hold two string arrays
p13413
aVAdd a  property that returns the total number of strings in all of the arrays
p13414
aVAdd a default indexed property that operates by working out which of the outer arrays the index refers to and then returns the appropriate value from the inner array
p13415
aVFor extra points implement an enumerator to make for in work
p13416
as(dp13417
g7
V505088
p13418
stp13419
a((dp13420
g2
(lp13421
VPre build actions do run before every compile
p13422
aVYou state in a comment that the actions sometimes don't run when you press F9
p13423
aVThat makes sense because F9, or Run, only invokes a compile if source is deemed to have changed
p13424
aVA BeforeCompile notifier plug in will behave in exactly the same way
p13425
aVYour solution is to make sure that you compile before running using Ctrl+F9
p13426
as(dp13427
g7
V505088
p13428
stp13429
a((dp13430
g2
(lp13431
VIt's very common for open source code to rely on closed source components
p13432
aVFor example any open source code relying on Microsoft
p13433
aVnet relies on very large amounts of closed source code
p13434
aVIn turn, any code that targets Windows itself depends on the closed source Windows code
p13435
aVThere's no conceptual difference between your examples and mine above
p13436
as(dp13437
g7
V505088
p13438
stp13439
a((dp13440
g2
(lp13441
VIt probably makes little difference because 24bpp in memory storage uses 4 bytes per pixel for alignment reasons
p13442
aVAlgorithms can ignore the alpha channel which will be a smidgen more efficient but in terms of storage there's no difference
p13443
as(dp13444
g7
V505088
p13445
stp13446
a((dp13447
g2
(lp13448
VResizing child windows in a WM_PAINT is simply wrong and I suspect this to be a big part of your problems
p13449
aVThe code to position the child windows should be run in response to the WM_WINDOWPOSCHANGED message
p13450
as(dp13451
g7
V505088
p13452
stp13453
a((dp13454
g2
(lp13455
VIn the code you have given,  is called in the context of the thread  and not its creator
p13456
aVAlso, aborting threads is morally equivalent to killing puppies
p13457
as(dp13458
g7
V505088
p13459
stp13460
a((dp13461
g2
(lp13462
VIf you want to expose your objects in a runtime neutral way then I can't see any solution other than COM
p13463
as(dp13464
g7
V505088
p13465
stp13466
a((dp13467
g2
(lp13468
VI think you have 3 options:
p13469
aVRun it through Wine which is very capable nowadays
p13470
aVBuild it with Kylix if you can get hold of a copy
p13471
aVBuild it with FreePascal
p13472
as(dp13473
g7
V505088
p13474
stp13475
a((dp13476
g2
(lp13477
VYou don't need to do anything
p13478
aVTypically the user will have a keyboard that lets them enter the characters that they need for their language
p13479
aVFor some languages they will use a system provided IME but again you need to do nothing special to support this
p13480
as(dp13481
g7
V505088
p13482
stp13483
a((dp13484
g2
(lp13485
VI'd just find the first zero in the array and strip off everything that follows
p13486
as(dp13487
g7
V505088
p13488
stp13489
a((dp13490
g2
(lp13491
VThere's no magic switch built into the compiler to do this
p13492
aVYou'll have to do it with the pre-processor and I can't see any alternative to wrapping all such blocks in
p13493
as(dp13494
g7
V505088
p13495
stp13496
a((dp13497
g2
(lp13498
VTrying to read data out of a Delphi grid control is not going to work out for you
p13499
aVIt's not like a standard Windows edit control which you could just call GetWindowText on
p13500
aVIf you really want to get the information from this existing program then you'd need to poke at its internal memory or do an OCR on a screen grab
p13501
aVAll pretty horrible to contemplate
p13502
as(dp13503
g7
V505088
p13504
stp13505
a((dp13506
g2
(lp13507
VI don't understand why you don't like iterating
p13508
aVIt seems like a good solution to me
p13509
aVI'd take the opportunity to build a reusable recursive control iterator
p13510
aVHowever, if you don't want to do that then you can try a simple variant on your current solution
p13511
aVBefore you make the form visible set its position so that it does not appear on any monitor
p13512
aVThen when you hide it again restore the correct position
p13513
as(dp13514
g7
V505088
p13515
stp13516
a((dp13517
g2
(lp13518
VI think you have already found the right way to read stdin
p13519
aVIt is meant to block when there's nothing more to be read
p13520
aVThe standard way to handle this is to use a separate thread to handle the pipe
p13521
aVWhen it receives new data from stdin it signals this to the processing thread, for example with a message passing mechanism
p13522
aVHaving said all that, if you really want to poll you can call PeekNamedPipe to check if there is data in the pipe
p13523
as(dp13524
g7
V505088
p13525
stp13526
a((dp13527
g2
(lp13528
VIt's unlikely you'll write code where the performance of typeof is significant so you should choose the style of code that is most clear and maintainable
p13529
as(dp13530
g7
V505088
p13531
stp13532
a((dp13533
g2
(lp13534
VOlder versions of Delphi don't support 256px Vista icons
p13535
aVI believe that 2010 does not support them so I guess the limitation was fixed in XE
p13536
aVWhen working with an older Delphi you'll need to keep the 256px icon out of the IDE
p13537
aVYou can still build an executable with a 256px icon from the command line compiler - I used to do just this before upgrading from Delphi 6
p13538
aVBut to do this requires the use of a competent resource compiler, for example the Microsoft one
p13539
as(dp13540
g7
V505088
p13541
stp13542
a((dp13543
g2
(lp13544
Vnet consumes COM objects with ease
p13545
aVThere's no need for interop, just import the type libraries and off you go
p13546
aVMSDN has a comprehensive tutorial
p13547
as(dp13548
g7
V505088
p13549
stp13550
a((dp13551
g2
(lp13552
VEmbedded resources aren't meant to be this big and you are apparently hitting the limits
p13553
aVYou should deliver this file as a standalone file alongside your executable
p13554
as(dp13555
g7
V505088
p13556
stp13557
a((dp13558
g2
(lp13559
VI'm guessing the problem is that the service is running in a different session and thus a different desktop from the app whose status it is trying to report on
p13560
aVThis DLL probably calls EnumWindow to find the app and this would fail to locate it when run from a different desktop
p13561
as(dp13562
g7
V505088
p13563
stp13564
a((dp13565
g2
(lp13566
VFor native DLLs your options are P/invoke or COM
p13567
aVThe latter is easier once you have got over the not insignificant hurdle of making a COM server
p13568
as(dp13569
g7
V505088
p13570
stp13571
a((dp13572
g2
(lp13573
VEnum definitions are not exported so your current solution is the only one available
p13574
aVIn any case, C enum values are nothing much more than integer constants
p13575
aVThere's no type safety on the C side, you can pass any integer values to an enum parameter
p13576
aVSo it's not like the C compiler is doing much anyway
p13577
as(dp13578
g7
V505088
p13579
stp13580
a((dp13581
g2
(lp13582
VYou already know about P/invoke from your previous question
p13583
aVRegarding the header file, it's not used for managed interop
p13584
aVInstead the P/invoke declarations specify the function parameters, calling conventions etc
p13585
as(dp13586
g7
V505088
p13587
stp13588
a((dp13589
g2
(lp13590
VThere's no point obfuscating since the compiler already does that for you
p13591
aVThere is no way to re-create the source code from the binary
p13592
aVAnd components can be distributed in a useful way without having to distribute the source code
p13593
aVSo there usually is no (technical) reason for distributing the source code
p13594
as(dp13595
g7
V505088
p13596
stp13597
a((dp13598
g2
(lp13599
VYou seem to me to be asserting that local variables of a static method are themselves static
p13600
aVThis is not true
p13601
aVLocal variables are always local for both instance and static methods and so, excluding special cases like variable capture, live on the stack
p13602
aVThus they are private to each separate invocation of the method
p13603
as(dp13604
g7
V505088
p13605
stp13606
a((dp13607
g2
(lp13608
VYou should add the entire manifest
p13609
aVYou'll need to disable the IDE generated version in the project
p13610
aVThe advantage of this is that you will have full and transparent control of your manifest
p13611
aVFor example you may want to add a DPI aware entry so that your app looks good at higher font scaling values
p13612
as(dp13613
g7
V505088
p13614
stp13615
a((dp13616
g2
(lp13617
VIt's pointless to try to do this
p13618
aVIf the browser can display the image then the user can also download it
p13619
aVYou may be best off putting a watermark on the images
p13620
as(dp13621
g7
V505088
p13622
stp13623
a((dp13624
g2
(lp13625
VYou need to run Dependency Walker in dynamic mode because the are some dependencies that will be resolved by explicit linking
p13626
aVI believe that you do this from the Profile menu
p13627
as(dp13628
g7
V505088
p13629
stp13630
a((dp13631
g2
(lp13632
VNo you can't do this and a good job too
p13633
aVThis style of coding leads to complex and hard to read code
p13634
as(dp13635
g7
V505088
p13636
stp13637
a((dp13638
g2
(lp13639
VThere's nothing really to be gained by using MDI once you have tabs
p13640
aVMDI is designed to handle multiple forms residing inside the same container
p13641
aVHowever, with tabs each form is in a different container
p13642
aVI can't see any benefit to using MDI in this scenario and would avoid it
p13643
as(dp13644
g7
V505088
p13645
stp13646
a((dp13647
g2
(lp13648
VI'm not asking about allocateResource throwing an exception, but a situation
p13649
aVin which you get an exception after
p13650
aVthat function has returned, but before resource is assigned
p13651
aVIt gets very messy to try to handle this aspect of exception safety, not least because the language constructs don't allow you to install your finally handler in the middle of an assignment statement
p13652
aVMy rationale for all this is that if you can't get from the end of a function call to assigning to a variable then your system is already hosed
p13653
aVWho cares if you leak memory when you can't assign to a variable
p13654
as(dp13655
g7
V505088
p13656
stp13657
a((dp13658
g2
(lp13659
VR works with the underlying system's floating point data type which typically have around 16 significant decimal figures
p13660
aVIf you want lots of digits of pi then you'll need to hold them in a character array of some such construct
p13661
aVYou simply can't fit more than a handful into an R numeric value
p13662
aVIf you wish to generate the digits yourself then a websearch will reveal many articles outlining algorithms to do the job
p13663
aVOr you can find plenty of sites that just list pi to a gazillion digits
p13664
as(dp13665
g7
V505088
p13666
stp13667
a((dp13668
g2
(lp13669
VC doesn't even have support for threads, that's implementation specific
p13670
aVYou'll need to use a library for your monitor
p13671
as(dp13672
g7
V505088
p13673
stp13674
a((dp13675
g2
(lp13676
Vwraps the traditional
p13677
aVIt works on all versions of Windows
p13678
aVwraps the new COM based dialog that was introduced in Vista
p13679
aVIt therefore only works on Vista or later
p13680
aVIt has more functionality than the older dialogs, most notably the tight integration with search
p13681
aVVista common dialog
p13682
aVCompatibility common dialog
p13683
aVThe  API will in fact produce the new dialogs in most situations, if called correctly, so you can't actually tell the difference
p13684
aVThat said, historically the VCL's wrapper for  was implemented imprecisely and always resulted in the compatibility dialog being shown
p13685
aVBut what does the new COM dialog have to offer then
p13686
aVThe new dialog offers a much easier customisation interface at the loss of some generality
p13687
aVIf you use the old dialog template based customisation with  on Vista or later then the dialogs degrade to ugly compatibility versions that lack functionality
p13688
aVThe other big advantage of the new dialogs is the ability to select unlimited number of files
p13689
aVThe old  interface returned multi-select filenames in a fixed size buffer
p13690
aVThis can be a real limitation and in my own code I have had to hack the VCL code to make this buffer larger for when my app runs on XP
p13691
aVwill delegate the work to  if possible
p13692
aVThe test it uses requires all of the following to be true:
p13693
aVRunning on Windows Vista or later
p13694
aVglobal boolean variable is true (default is true)
p13695
aVThis allows you to disable the use of the new COM dialog should you elect to do so
p13696
aVNo dialog template is specified
p13697
aV,  and  events are all not assigned
p13698
aVPresumably these cannot be fired by
p13699
aVSummary
p13700
aVIf you continue to use  then you will reap the benefit of unlimited number of file in multi-select mode
p13701
aVHowever, if you wish to customise the dialog, and have the new dialogs rather than the ugly compatibilty dialogs, then you need to do the following:
p13702
aVOn XP use  and the dialog template method
p13703
aVOn Vista and later use  and implement customisation with
p13704
as(dp13705
g7
V505088
p13706
stp13707
a((dp13708
g2
(lp13709
VYou'd still need to declare the function in order to call it, and you'd need to link with kernel32
p13710
aVlib
p13711
aVThe header file isn't anything magic, it's basically just a lot of function declarations
p13712
as(dp13713
g7
V505088
p13714
stp13715
a((dp13716
g2
(lp13717
VYou should not include  in the string you pass to
p13718
aVInstead use
p13719
as(dp13720
g7
V505088
p13721
stp13722
a((dp13723
g2
(lp13724
VRecent versions of Delphi support PNG natively, amongst many other enhancements, and you would be well advised to upgrade
p13725
as(dp13726
g7
V505088
p13727
stp13728
a((dp13729
g2
(lp13730
VYou've declared a pointer to a C string but not allocated any memory for it
p13731
aVIf you want stack allocated memory use
p13732
aVIf you prefer heap allocation use
p13733
aVI know the question is tagged C++ but your code looks more like C to me
p13734
aVHence the use of malloc
p13735
as(dp13736
g7
V505088
p13737
stp13738
a((dp13739
g2
(lp13740
VI don't know the answer to your question
p13741
aVHowever, you could avoid needing to know by using code like this in a global include file or a unit that is used by all other units in your code:
p13742
as(dp13743
g7
V505088
p13744
stp13745
a((dp13746
g2
(lp13747
VIt seems that you want to make an MDI app
p13748
aVThis is much easier using a higher level framework such as MFC, WinForms, VCL etc
p13749
aV, but can, of course, be done with plain Win32
p13750
aVThe MSDN documentation can be found here: Multiple Document Interface
p13751
as(dp13752
g7
V505088
p13753
stp13754
a((dp13755
g2
(lp13756
VThe normal practise is to have both 32 bit and 64 bit install packages
p13757
aVOn the 32 bit machine you just run the 32 bit package, on the 64 bit machine you run both
p13758
aVTrying to handle all the registry and file redirection yourself is a nightmare and it's much better to install a 32 bit package on a 64 bit machine and let the system do the redirection for you
p13759
aVYou've got to produce the 32 bit package anyway for 32 bit machines, so it's no extra work
p13760
as(dp13761
g7
V505088
p13762
stp13763
a((dp13764
g2
(lp13765
VIt seems to me that you should just use a virtual method
p13766
aVIt will result in efficient code that's more readable too
p13767
as(dp13768
g7
V505088
p13769
stp13770
a((dp13771
g2
(lp13772
VYou do seem to be getting rather tied up
p13773
aVTry this:
p13774
as(dp13775
g7
V505088
p13776
stp13777
a((dp13778
g2
(lp13779
V won't run a script from the memory of your process
p13780
aVThe options which seem most obvious to me are:
p13781
aVRelax the constraint that stops you extracting the script to a temporary file
p13782
aVCompress your script into a single line and use  to execute it
p13783
aVYou'll need to use the command separator
p13784
aVWrite your own batch command interpreter
p13785
aVUse a different scripting language
p13786
aVOptions 3 and 4 aren't really very attractive
p13787
aVOption 1 looks pretty good to me but I don't know what's leading to your constraint
p13788
as(dp13789
g7
V505088
p13790
stp13791
a((dp13792
g2
(lp13793
VThis is the code I use
p13794
aVIt will work for any  descendent: list box, tree view, list view etc
p13795
aVThen to use it you add an  event handler for the control and implement it like this:
p13796
as(dp13797
g7
V505088
p13798
stp13799
a((dp13800
g2
(lp13801
VBecause those are the rules of the language, as others have explained
p13802
aVI'd write it like this though and avoid declaring up-front how many characters there are
p13803
as(dp13804
g7
V505088
p13805
stp13806
a((dp13807
g2
(lp13808
V@therefromhere's solution is more elegant and faster, but if you need to do this with a number that isn't a power of 2 then you can use this approach
p13809
as(dp13810
g7
V505088
p13811
stp13812
a((dp13813
g2
(lp13814
VThere are many options, but all will involve settings that require admin rights
p13815
aVThese options include:
p13816
aVPut your routine in a service that is set to start automatically
p13817
aVThis will start up when the system starts up and before any user has logged on
p13818
aVAdd an entry to
p13819
aVThis will execute when an interactive user logs on
p13820
aVAdd a scheduled task with an appropriate trigger, e
p13821
ag217
as(dp13822
g7
V505088
p13823
stp13824
a((dp13825
g2
(lp13826
VSee the MSDN document, Font Installation and Deletion, for full details
p13827
aVIn summary:
p13828
aVCopy the font file to the fonts directory ()
p13829
aVCall  to ensure the font is immediately available
p13830
aVBroadcast the  message
p13831
aVThanks to @Alex K for cleaning this up and adding the fine detail
p13832
as(dp13833
g7
V505088
p13834
stp13835
a((dp13836
g2
(lp13837
VThe  line in  is blocking the app from shutting down
p13838
aVYou can solve this easily enough by adding a boolean field to your form class, named
p13839
aVSet this to true before calling
p13840
aVInside  check for the value of  and only set  if  is false
p13841
aVSomething like this:
p13842
as(dp13843
g7
V505088
p13844
stp13845
a((dp13846
g2
(lp13847
VCheck the return value of your call to
p13848
aVIf it is false then the call failed
p13849
aVCall  to find out the Win32 error code
p13850
aVThis sometimes helps narrow the problem down (although not always)
p13851
aVIf that sheds no more light then you'll need to tell us the full path names for the file you are moving, and for its new destination
p13852
aVIn your comments you state that you are passing the  flag
p13853
aVThe documentation for  states:
p13854
aVThis value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account
p13855
aVIt seems likely that this is the root cause of the problem
p13856
aVThanks to @Logan for pointing this out
p13857
as(dp13858
g7
V505088
p13859
stp13860
a((dp13861
g2
(lp13862
VIn fact it is  that detects file type, and it just uses the file extension
p13863
aVSo you'll need to read the header of the stream to detect the file type
p13864
aVOn the other hand, if you know what the format is when you put the BLOB into the database you could always include that information as your own private header to the BLOB
p13865
as(dp13866
g7
V505088
p13867
stp13868
a((dp13869
g2
(lp13870
VWe all suffer from this from time to time
p13871
aVWhat I sometimes do is add some spurious code at the point at which I need to debug the variable that references the variable but does nothing
p13872
aVFor example:
p13873
aVOr if it is a boolean then:
p13874
aVSomething along these lines is usually enough to get the compiler to write out code that keeps the variable alive so that the debugger can inspect it
p13875
aVMake sure you put the code right at the bottom of the routine
p13876
aVAnd make sure that you remember to remove it before checking the code in
p13877
as(dp13878
g7
V505088
p13879
stp13880
a((dp13881
g2
(lp13882
VThe code as you present it does not compile because you have not specified parameter types
p13883
aVIf you do so then it will work fine, so long as the parameter lists differ
p13884
aVFor example this compiles fine:
p13885
aVBut this does not:
p13886
aVOverloading is where you have multiple methods with the same name, but different parameter lists
p13887
aVWhenever you call an overloaded method, the compiler selects the method whose parameter lists matches the parameters being passed
p13888
aVI suspect you trying to overload the method using the same parameter lists for both versions of the method, but a different calling convention
p13889
aVThis will not work
p13890
aVOverloaded method resolution can not be performed on the basis of calling convention (or function return value type for that matter)
p13891
aVSimply use the  version internally as well as externally
p13892
as(dp13893
g7
V505088
p13894
stp13895
a((dp13896
g2
(lp13897
VOn a machine with UAC you need to include a manifest resource to specify that you want the process to run as administrator
p13898
aVOn a machine without UAC you will simply have to instruct your users that they need to run it as a user in the administrators group
p13899
aVAlmost all users of XP (the version that you will most commonly encounter without UAC) are in the administrators group so you won't encounter many problems
p13900
as(dp13901
g7
V505088
p13902
stp13903
a((dp13904
g2
(lp13905
VThe efficient way to do this using pure VCL is to use ,  and
p13906
aVYou'll likely want to save away the selection before modifying it, and then restore it once you have read the character
p13907
aVThis is however a rather messy way to read a character
p13908
aVIf you are prepared to use raw Win32 API then you can make use of
p13909
as(dp13910
g7
V505088
p13911
stp13912
a((dp13913
g2
(lp13914
VIf you have a preference for MS tools then your sole option is Visual Studio and C++
p13915
aVYou can program the Win32 API directly without any frameworks, but life will be a lots easier with a framework like MFC
p13916
aVIf you are prepared to take a broader look then you should consider Delphi which comes with a framework, the VCL, that is very powerful and easy to use
p13917
aVThe VCL is very similar to WinForms and in fact WinForms was clearly inspired by the VCL
p13918
aVDelphi VCL apps can be distributed without installing a run time on the target machine
p13919
as(dp13920
g7
V505088
p13921
stp13922
a((dp13923
g2
(lp13924
V16 bit signed int () takes values between -32,768 and 32,767
p13925
aVNegating -32768, or getting the absolute value, is impossible to do inside a 16 bit signed integer
p13926
aVThe value (32,768) is greater than the maximum possible positive value (32,767)
p13927
aVI would not like to advise you how to solve the problem without knowing more details of the algorithms you are using
p13928
as(dp13929
g7
V505088
p13930
stp13931
a((dp13932
g2
(lp13933
VBoth options are poor
p13934
aVThey are polling methods and so will use CPU for no reason when there is no data
p13935
aVIf you can't use an event driven approach then you should look for a solution based on a blocking queue
p13936
as(dp13937
g7
V505088
p13938
stp13939
a((dp13940
g2
(lp13941
V can add, modify and delete a resource
p13942
aVIf lpData is NULL and cbData is 0, the specified resource is deleted from the file indicated by hUpdate
p13943
as(dp13944
g7
V505088
p13945
stp13946
a((dp13947
g2
(lp13948
V is a loose wrapper around , the documentation of which states:
p13949
aVThe calling process must have the  privilege enabled
p13950
aVFor more information, see Running with Special Privileges
p13951
aVUser tokens do not normally have the  privilege enabled
p13952
aVIn order to meet this requirement you need to:
p13953
aVRun as administrator
p13954
aVAdd the  privilege to your user token
p13955
aVThe other requirement you must adhere to is that the output file must not exist before you call
p13956
aVSee this EDN article for C++ code illustrating the method
p13957
as(dp13958
g7
V505088
p13959
stp13960
a((dp13961
g2
(lp13962
VA 32 bit process will load the 32 bit COM server and a 64 bit process will load the 64 bit COM server
p13963
aVIn other words, so long as you install the right COM server on the target machine, you should have to do precisely nothing for this to just work
p13964
as(dp13965
g7
V505088
p13966
stp13967
a((dp13968
g2
(lp13969
VAlthough this doesn't directly answer the question, it is probably better to call the built in RTL method
p13970
as(dp13971
g7
V505088
p13972
stp13973
a((dp13974
g2
(lp13975
VYour best bet, in my view, is to upgrade to the latest Delphi which fully supports XP themes out of the box
p13976
aVTrying to get a Delphi 5 app to look native on modern Windows is quite a labour (I have done it myself so I speak from experience) and if you can upgrade it will be the least painful route
p13977
as(dp13978
g7
V505088
p13979
stp13980
a((dp13981
g2
(lp13982
VThis is a known issue: "As" operator for constrained generic types
p13983
aVHowever, I don't understand why you can't write it like this:
p13984
as(dp13985
g7
V505088
p13986
stp13987
a((dp13988
g2
(lp13989
VOn Windows Vista, UAC means that users run without admin rights and don't have write access to the program files directories
p13990
aVThe correct solution is to write to a folder for which standard users do have write permissions
p13991
aVThe solution you are looking for is to make your app's folder within program files writeable to all users
p13992
aVYou can do this by adding a DACL when installing
p13993
aVIt is extremely bad practice to allow standard users to write inside the program files directory and I urge you instead to re-code your app so that it does not need to write there
p13994
as(dp13995
g7
V505088
p13996
stp13997
a((dp13998
g2
(lp13999
V is scientific notation and so base 10
p14000
aVis natural exponentiation, i
p14001
ag192
aVInstead of writing  you simply write
p14002
as(dp14003
g7
V505088
p14004
stp14005
a((dp14006
g2
(lp14007
VThe rules for which top level windows appear in the taskbar are documented here
p14008
aVIn summary:
p14009
aVThe Shell creates a button on the
p14010
aVtaskbar whenever an application
p14011
aVcreates a window that isn't owned
p14012
aVTo
p14013
aVensure that the window button is
p14014
aVplaced on the taskbar, create an
p14015
aVunowned window with the WS_EX_ APPWINDOW extended style
p14016
aVTo prevent the window button from
p14017
aVbeing placed on the taskbar, create
p14018
aVthe unowned window with the WS_EX_ TOOLWINDOW extended style
p14019
aVAs an alternative, you can create a hidden
p14020
aVwindow and make this hidden
p14021
aVwindow the owner of your visible
p14022
aVwindow
p14023
aVFor more discussion take a look at Raymond Chen's article on the matter
p14024
as(dp14025
g7
V505088
p14026
stp14027
a((dp14028
g2
(lp14029
VThe WM_NC messages are for the non-client area, i
p14030
ag192
aVthe window border and caption
p14031
aVFor your needs you are not interested in these non-client messages
p14032
as(dp14033
g7
V505088
p14034
stp14035
a((dp14036
g2
(lp14037
VYou can't really attempt to stop this
p14038
aVIt's the user's computer and if they want to rename files on their computer they can do
p14039
as(dp14040
g7
V505088
p14041
stp14042
a((dp14043
g2
(lp14044
VDelphi 7, and indeed all released Delphi Win32 versions, only produce 32 bit executables
p14045
aVHowever, 32 bit executables run perfectly well on 64 bit operating systems through the WOW64 emulator
p14046
aVAlthough this is an emulator, a word that usually implies degraded performance, WOW64 performance is not readily distinguishable from native 64 bit performance
p14047
aVIf you wish to port your Delphi app to 64 bit you need to wait for the next version of Delphi to be released which will produce 64 bit executables
p14048
aVThen you will have to port your app from Delphi 7 to the latest version of Delphi
p14049
aVThis will be a big job because you will also have to port from ANSI string code to Unicode string code
p14050
aVIn my view this part of the port will be more time consuming than the 32 to 64 bit part and if you wanted to get a head start you would be wise to start the Unicode port now by upgrading to Delphi XE
p14051
as(dp14052
g7
V505088
p14053
stp14054
a((dp14055
g2
(lp14056
VI expect (and hope) that this is impossible
p14057
aVIf my browser is transmitting information that identifies my machine, then I want a new browser
p14058
aVLikewise, you should probably not be expecting to be able to receive such information
p14059
aVUpdate
p14060
aVSeems like I have to update my expectations: https://panopticlick
p14061
aVeff
p14062
aVorg/
p14063
aVYou can use browser finger printing to do a pretty darn good job of distinguishing between computers that visit your site
p14064
aVIt won't be 100% perfect but not far short
p14065
as(dp14066
g7
V505088
p14067
stp14068
a((dp14069
g2
(lp14070
VThis should do the job for you:
p14071
aVMake sure you are using  in your DLLImport which is the default
p14072
as(dp14073
g7
V505088
p14074
stp14075
a((dp14076
g2
(lp14077
VI want to get different number every time when call this function even with same seed
p14078
aVThat's not how seeds work
p14079
aVThe whole point of a seed is that using the same seed will result in the same series of pseudo-random numbers
p14080
aVThe series is deterministic
p14081
as(dp14082
g7
V505088
p14083
stp14084
a((dp14085
g2
(lp14086
VMy guess is that your app is compiled for Unicode and so the window is interpreting your ANSI C string as a Unicode C string, hence the characters from another language
p14087
as(dp14088
g7
V505088
p14089
stp14090
a((dp14091
g2
(lp14092
VUp-Down controls don't have values, their buddy controls do
p14093
aVIf you want to know the value, ask the buddy control
p14094
as(dp14095
g7
V505088
p14096
stp14097
a((dp14098
g2
(lp14099
VCreate a  and assign your comma separated string to
p14100
aVThis parses your input and returns the split strings as the items of the string list
p14101
as(dp14102
g7
V505088
p14103
stp14104
a((dp14105
g2
(lp14106
VRather than create your own caching algorithms why don't you write the data to a file with the  attribute and make use of the client machine's own cache
p14107
aVAlthough this approach appears to imply that you use a file, if there is memory available in the system then the file will never leave the cache and will remain in memory the whole time
p14108
aVSome advantages:
p14109
aVYou don't need to write any code
p14110
aVThe system cache takes account of all the other processes running
p14111
aVIt would not be practical for you to take that on yourself
p14112
aVOn 64 bit Windows the system can use all the memory available to it for the cache
p14113
aVIn a 32 bit Delphi process you are limited to the 32 bit address space
p14114
aVEven if your cache is full and your files to get flushed to disk, local disk access is much faster than querying the database and then transmitting the files over the network
p14115
as(dp14116
g7
V505088
p14117
stp14118
a((dp14119
g2
(lp14120
VThe code doesn't compile
p14121
aVI think you mean
p14122
aVA  is a value type and it makes no difference to its storage how you assign to a  value
p14123
aVThe two code samples (once fixed), result in exactly the same memory layout for
p14124
aVIt would be very much clearer to always write
p14125
aVNote that Visual Studio always represents negative zero as  which does tend to shake your confidence in the existence of
p14126
aVThere is some relevant discussion of negative zero here: How can I test for negative zero
p14127
as(dp14128
g7
V505088
p14129
stp14130
a((dp14131
g2
(lp14132
VOpaque pointers are best declared as
p14133
aVThis is often known as the Pimpl idiom
p14134
as(dp14135
g7
V505088
p14136
stp14137
a((dp14138
g2
(lp14139
VStack imbalance indicates that the C++ code uses  and your C# uses  calling convention
p14140
aVChange your  to this:
p14141
aVThe function signature in C# (return value and parameters) is otherwise correct
p14142
as(dp14143
g7
V505088
p14144
stp14145
a((dp14146
g2
(lp14147
VThe canonical form is:
p14148
aVNever call , always call  instead
p14149
aVis a total red herring
p14150
aVSometimes, if there are queued messages destined for your form or its children, then you might elect to call  although often that's indicative of design problems
p14151
as(dp14152
g7
V505088
p14153
stp14154
a((dp14155
g2
(lp14156
VAll released versions of Delphi following the 16 bit Delphi 1 emit 32 bit targets
p14157
aVAt the moment your options are:
p14158
aVWait until the upcoming 64 bit Delphi release
p14159
aVWe anticipate this some time this year, but your port will be non-trivial
p14160
aVPort to FreePascal
p14161
aVAgain, a non-trivial port
p14162
aVPort to a completely different language: even more work than porting to Free Pascal
p14163
aVCarry on running 32 bit code
p14164
as(dp14165
g7
V505088
p14166
stp14167
a((dp14168
g2
(lp14169
VIf the DLL can be loaded at the same base virtual address in two processes then there will only be one copy of the DLL in physical memory
p14170
aVSince Windows does not use position independent code, if a DLL cannot load at its preferred base address it will be rebased and thus not be able to share physical memory with other instances
p14171
as(dp14172
g7
V505088
p14173
stp14174
a((dp14175
g2
(lp14176
VYou need to convert your Unicode string to ANSI
p14177
aVDo it like this
p14178
aVYou would be better off calling the Unicode version though
p14179
as(dp14180
g7
V505088
p14181
stp14182
a((dp14183
g2
(lp14184
VWindows uses UTF16 still and most likely always will
p14185
aVYou need to use  rather than  therefore
p14186
aVWindows APIs don't offer support for UTF8 directly largely because Windows supported Unicode before UTF8 was invented
p14187
aVIt is thus rather painful to write Unicode code that will compile on both Windows and Unix platforms
p14188
as(dp14189
g7
V505088
p14190
stp14191
a((dp14192
g2
(lp14193
VDelphi produces Windows apps only so you are probably looking at using Wine or perhaps compiling with FreePascal
p14194
as(dp14195
g7
V505088
p14196
stp14197
a((dp14198
g2
(lp14199
VThis is not practical in any of the common operating systems
p14200
as(dp14201
g7
V505088
p14202
stp14203
a((dp14204
g2
(lp14205
VIf you can use local variables then do so and you invariably can use locals
p14206
aVOnly as a last resort should you use thread local storage which suffers from almost all the same disadvantages as global variables
p14207
aVAlthough you are looking for a reason to use thread local storage, in fact best practice is to search for ways to avoid it
p14208
as(dp14209
g7
V505088
p14210
stp14211
a((dp14212
g2
(lp14213
VYou can't do this with static text
p14214
aVIn particular you can't highlight text
p14215
aVInstead you should use a read only edit control
p14216
as(dp14217
g7
V505088
p14218
stp14219
a((dp14220
g2
(lp14221
VYou can't do that in a standard edit control
p14222
aVYou need a rich edit control for that
p14223
aVBased on your previous question I do wonder if what you really need is a hyperlink which you can do with the SysLink control
p14224
as(dp14225
g7
V505088
p14226
stp14227
a((dp14228
g2
(lp14229
VNot only is  clearer it certainly will be at least as fast as
p14230
as(dp14231
g7
V505088
p14232
stp14233
a((dp14234
g2
(lp14235
VYou could use any of the following (non-exhaustive) methods:
p14236
aVPass the object reference as a parameter to any methods that need it
p14237
aVOf course you need to get hold of Candle_Data so the suitability of this approach really depends who the caller is
p14238
aVPass the Candle_Data object reference to the constructor of the other object and then store it in a private member field
p14239
aVMake the object reference a public property of the single instance of the main form and access it that way
p14240
aVWe don't really have enough information to advise you which is best but the starting point is always to prefer parameters and local variables over global state
p14241
as(dp14242
g7
V505088
p14243
stp14244
a((dp14245
g2
(lp14246
VYou're not using virtual constructors correctly
p14247
aVTry it like this:
p14248
aVAs an aside I do not think you need to reintroduce the constructor in the code you listed
p14249
as(dp14250
g7
V505088
p14251
stp14252
a((dp14253
g2
(lp14254
V is null when you call:
p14255
aVSo naturally the assertion fails
p14256
aVYou need to instantiate class1 before you attempt to pass it to the  constructor
p14257
aVNow, that's not trivial to achieve since you have circular references
p14258
aVWhat you need to do therefore is create the objects first, and then fix up the references
p14259
aVDecouple the construction from the assignment of the references to the other objects
p14260
aVWhat's more, you should not name object instances , since they are objects rather than classes
p14261
aVThe distinction is important
p14262
as(dp14263
g7
V505088
p14264
stp14265
a((dp14266
g2
(lp14267
VTo solve this problem you need to move away from ANSI strings and start using Unicode strings and the corresponding Unicode versions of the Windows API
p14268
aVAt the moment you are reliant on the computer locale and that's an enormous world of pain
p14269
aVMoving from  to  takes a little effort but the benefits make the effort well worthwhile
p14270
aVEmbrace Unicode and forget all about the bad old days
p14271
as(dp14272
g7
V505088
p14273
stp14274
a((dp14275
g2
(lp14276
VYou don't need C# for this
p14277
aVJust use the command shell:
p14278
aVI'm assuming of course that this is a one time operation
p14279
as(dp14280
g7
V505088
p14281
stp14282
a((dp14283
g2
(lp14284
V has 12 parameters
p14285
aVYou are only passing 6
p14286
aVI can't understand how that even compiles\u2014perhaps you are providing your own definition of  rather than the one from the windows header files
p14287
aVPerhaps you are getting confused by the fact that many of the parameters to  are marked as optional
p14288
aVThis only means that you can pass  into the function and not that you can omit the parameters altogether
p14289
as(dp14290
g7
V505088
p14291
stp14292
a((dp14293
g2
(lp14294
V is available in modern versions of Delphi in exactly the same was as it was in Delphi 7
p14295
aVIn my view it is easier to use early binding with  than the late bound  approach
p14296
as(dp14297
g7
V505088
p14298
stp14299
a((dp14300
g2
(lp14301
VTo find the other program's main window I recommend using  or
p14302
aVWhich one you use depends on just what you know about the other process
p14303
aVOnce you have that the easiest way to send text data is via a  windows message
p14304
aVTo show an error message, use
p14305
as(dp14306
g7
V505088
p14307
stp14308
a((dp14309
g2
(lp14310
VServices are not notified of these events since they run in a different session from the interactive users
p14311
aVThis has been true since Vista introduced what is known as Session 0 isolation
p14312
aVWithout knowing exactly what you are trying to achieve it's hard to give accurate advice
p14313
aVThat said, a very common approach to this sort of issue is to run a standard app on the logged in users desktop that communicates with your service using, for example, a named pipe
p14314
as(dp14315
g7
V505088
p14316
stp14317
a((dp14318
g2
(lp14319
VThis approach won't work and so is not going to solve your problem
p14320
aVYou should instead extend your framework to allow you to specify which attributes were to be omitted from the save/load
p14321
aVHowever, it seems odd that you aren't using one of the built in persistence techniques, e
p14322
ag217
aVpickle, that already offer such features
p14323
as(dp14324
g7
V505088
p14325
stp14326
a((dp14327
g2
(lp14328
VYou only need to use  if you are assigning to the global name
p14329
aVWithout , an assignment creates a new local
p14330
aVThere's nothing special about how  applies to a list\u2014 simply influences scope and name resolution
p14331
as(dp14332
g7
V505088
p14333
stp14334
a((dp14335
g2
(lp14336
VThose are K&R; style prototypes which were used in the original versions of C
p14337
aVThe are now largely forgotten and have been replaced by ANSI prototypes:
p14338
aVAs others have stated, the K&R; prototypes are problematic when used in function declarations because they do not include type information
p14339
aVPresumably a compiler could parse a K&R; function definition for type information but I bet no compiler ever did
p14340
as(dp14341
g7
V505088
p14342
stp14343
a((dp14344
g2
(lp14345
VNo that's not possible through the taskbar API
p14346
aVThe system has been designed with the intention that you'll only work on taskbar buttons that you own
p14347
aVIn which case there's no need for getters since you can remember for yourself what value you last passed to a setter, should you need to
p14348
as(dp14349
g7
V505088
p14350
stp14351
a((dp14352
g2
(lp14353
VI would use some indirection:
p14354
aVNow you can call  directly from anywhere in your code
p14355
aVI realise that you can call  and pass a  but that solution somehow makes me feel dirty
p14356
aVDoing it as suggested above also allows you to name the method more specifically and not be so tightly coupled with the UI events that drive it
p14357
as(dp14358
g7
V505088
p14359
stp14360
a((dp14361
g2
(lp14362
VYou have two obvious options:
p14363
aVPut the entire app inside a single process
p14364
aVThis would typically involve something like Windows DLLs (native, COM, managed assemblies etc
p14365
aVor Unix shared objects
p14366
aVCommunicate between the two parts of the app using IPC mechanisms
p14367
aVGenerally option 1 is preferable if the languages in question are amenable
p14368
as(dp14369
g7
V505088
p14370
stp14371
a((dp14372
g2
(lp14373
VI'm assuming you already know how to add controls in the form designer and how to implement event handlers
p14374
aVQuestion 1
p14375
aVThe button click handler simply toggles the visibility of the two controls
p14376
aVQuestion 2
p14377
aVThis time the button handler instantiates a new form an then shows it as a modal dialog
p14378
aVCall  if you don't want to show modally
p14379
as(dp14380
g7
V505088
p14381
stp14382
a((dp14383
g2
(lp14384
VAs an aside, the function you give returns nothing which is an error
p14385
aVA function can have only a single return value
p14386
aVIf you want to return multiple values you can:
p14387
aVReturn a struct containing the values
p14388
aVPass the return values as parameters using pointers
p14389
aVAn example of the option 2:
p14390
aVCall the function like this:
p14391
aVI intentionally chose a different example because I couldn't work out what you want to do with your  return value
p14392
as(dp14393
g7
V505088
p14394
stp14395
a((dp14396
g2
(lp14397
VThe problem with this is that the C# marshaller passes a temporary block of memory into the function as
p14398
aVThis memory is the destroyed when the function returns
p14399
aVBut you are also asking the C# marshaller to marshal this same block of memory into a C# string
p14400
aVIt's not good practice to return a null-terminated string from a native DLL function anyway
p14401
aVYou have a couple of options:
p14402
aVUse a  on the C# side to pre-allocate the memory for the string
p14403
aVThis requires you to get hold of the required size somehow
p14404
aVThis is the most common way to interop strings
p14405
aVReturn the string as a COM  and the C# marshaller knows how to marshall and dispose a , and has access to the COM allocator to do so
p14406
aVI have no knowledge about using  in FreePascal but in Delphi you simply use
p14407
aVYou also need to tell the C# marshaller that you are returning a
p14408
aVI personally have a preference for option 2
p14409
aVThere is one wrinkle though and that is that different compilers use a different ABI for function return values, as discussed at this question: Why can a WideString not be used as a function return value for interop
p14410
aVThe easy way around that is to return the string in a parameter rather than using the function return value
p14411
aVThe code looks like this:
p14412
aVPascal
p14413
aVC#
p14414
as(dp14415
g7
V505088
p14416
stp14417
a((dp14418
g2
(lp14419
VThere are three obvious possibilities for this problem:
p14420
aVYou are running the 64 bit version of regsvr32
p14421
aVYou have UAC enabled and when the OCX self-registers, its attempts to write to HKLM fail
p14422
aVThe OCX does not run under Windows 7
p14423
aVI think the latter is unlikely and anyway I can't do much to help
p14424
aVTo get around issues 1&2 I do the following:
p14425
aVOpen a Command Prompt as administrator (right click on a shortcut to the Command Prompt and select "Run as Administrator")
p14426
aVRun this command:
p14427
as(dp14428
g7
V505088
p14429
stp14430
a((dp14431
g2
(lp14432
VThis is not true and there is nothing to expand on
p14433
aVThe
p14434
aVnet framework can interop with COM, but that's it
p14435
aVYour friend should stick to Java
p14436
as(dp14437
g7
V505088
p14438
stp14439
a((dp14440
g2
(lp14441
VIt calls the method of self whose name is held in  and passing  as the arguments to the function
p14442
aVis a tuple and  is special syntax that allows you to call a function and expand a tuple into a list of arguments
p14443
aVSuppose that  contained the string , and  was , then  would be equivalent to:
p14444
as(dp14445
g7
V505088
p14446
stp14447
a((dp14448
g2
(lp14449
VIf you want to match some part of the string, without any fancy wildcards, as you indicate in a comment to another answer, then you can use a simple function like this:
p14450
aVIf you want a case-insensitive match then you can use this:
p14451
aVand  are defined in the  RTL unit and follow the standard convention of  to indicate case sensitive comparison, and  to indicate case insensitive
p14452
as(dp14453
g7
V505088
p14454
stp14455
a((dp14456
g2
(lp14457
VYes it's still well worth rebasing your DLL so that it doesn't clash with other DLLs in the host process
p14458
aVI won't list the benefits since you do so in the links in your question
p14459
as(dp14460
g7
V505088
p14461
stp14462
a((dp14463
g2
(lp14464
VThe documentation states:
p14465
aVFile types (including type Text), and the type Variant cannot be initialized, that is, you cannot declare typed constants or initialized variables of these types
p14466
aVSo your problem is with your variant record member
p14467
aVThis means that you need a different approach and you will have to abandon the use of a constant array
p14468
as(dp14469
g7
V505088
p14470
stp14471
a((dp14472
g2
(lp14473
VAdd up the file size for all the files before you start
p14474
aVThen you can manually convert the progress for each individual file into an overall progress
p14475
aVOr use  and get the native OS file copy progress dialogs
p14476
as(dp14477
g7
V505088
p14478
stp14479
a((dp14480
g2
(lp14481
VI would always use a  for this because it makes the responsibility of memory allocation/deallocation transparent
p14482
aVC++
p14483
aVC#
p14484
aVYou don't say how your strings are being allocated, but as soon as you use a dynamically allocated string you need to tackle that issue
p14485
aVThe great thing about  is that it uses the shared COM allocator which enables the C# marshaller to deallocate the string with the same allocator as the C++ code that allocated it
p14486
as(dp14487
g7
V505088
p14488
stp14489
a((dp14490
g2
(lp14491
VThere are built in facilities in Windows and simplest is the  window class
p14492
aVIf you need more precise control then the full smrgsbord of facilities are summarised here
p14493
aVHaving said that I do suspect that a pre-existing 3rd party Delphi wrapper would make life much easier, but you clearly state you don't want to do that
p14494
as(dp14495
g7
V505088
p14496
stp14497
a((dp14498
g2
(lp14499
VIn the Delphi  you can't hide columns in  view style
p14500
aVYour only option is to delete the column when you need to hide it, and create it again when you need to show it
p14501
aVThis is yet another example of why virtual list views are much more desirable than non-virtual list views
p14502
aVWith a virtual list view you can insert new columns without having to iterate across all items in the list and re-populate their sub items
p14503
as(dp14504
g7
V505088
p14505
stp14506
a((dp14507
g2
(lp14508
VIn the code as given in your question, there is no good reason for using a floating point value
p14509
as(dp14510
g7
V505088
p14511
stp14512
a((dp14513
g2
(lp14514
VYou can do this like so:
p14515
aVCall it like this:
p14516
aVAs normal, make sure your calling conventions match (C# defaults to stdcall, C++ defaults to cdecl)
p14517
aVAs an aside, why return the  separate from the stream since  knows its size and will tell you if you ask it to
p14518
as(dp14519
g7
V505088
p14520
stp14521
a((dp14522
g2
(lp14523
VBoth versions are wrong\u2014you just got lucky with the one that worked
p14524
aVYou've declared a pointer but not allocated any storage for it
p14525
aVTry this:
p14526
aVOr using :
p14527
as(dp14528
g7
V505088
p14529
stp14530
a((dp14531
g2
(lp14532
VI don't think this is a realistic proposal
p14533
aVTo have any real chance of doing this you'd need to get inside the implementation of the renderer
p14534
aVFor that I think you'd need to start with a browser engine whose source you could modify, e
p14535
ag217
aVWebkit or Gecko
p14536
as(dp14537
g7
V505088
p14538
stp14539
a((dp14540
g2
(lp14541
VYes indeed that would be down to the stack space for the recursive calls
p14542
as(dp14543
g7
V505088
p14544
stp14545
a((dp14546
g2
(lp14547
VI can't answer definitively, but my best suggestion is that something in the system, either in the
p14548
aVnet framework classes or the file system, is implementing a timeout/retry mechanism in case of file sharing failures
p14549
aVThis would explain the inordinate delay you report
p14550
as(dp14551
g7
V505088
p14552
stp14553
a((dp14554
g2
(lp14555
VI don't see any evidence of any significant improvements on code generation
p14556
aVI'm not aware that there has been anything very significant in terms of code generation improvements since Delphi 5
p14557
aVIn fact I've never found my code running faster following an upgrade and that's stretching back to Delphi 2
p14558
as(dp14559
g7
V505088
p14560
stp14561
a((dp14562
g2
(lp14563
VProbably your easiest approach is to download MS Visual Studio Express for C#
p14564
aVIf you want a GUI app then use the WinForms framework
p14565
as(dp14566
g7
V505088
p14567
stp14568
a((dp14569
g2
(lp14570
VIt sounds like you just want the  event:
p14571
aVSometimes this method can be a bit crude and offer up a  that you aren't obviously hovering over
p14572
aVIf you want more control you can use  and :
p14573
aVThe definition of  is as follows:
p14574
aVAs you can see this gives you a lot of fine grained control over when and what you show as a hint
p14575
as(dp14576
g7
V505088
p14577
stp14578
a((dp14579
g2
(lp14580
VCalling the native method will never raise an exception
p14581
aVIf the file deletion fails, for whatever reason, the call to  returns false
p14582
aVYour P/Invoke code is good
p14583
aVYou are correctly using Unicode characters, setting  to  and the parameter marshalling is correct
p14584
aVTo check for errors look for the value of the boolean return from
p14585
aVIf it is false (i
p14586
ag192
aVthe call failed) then call  to find out the Win32 error code
p14587
aVThe most obvious causes for the function to fail are:
p14588
aVThe file does not exist
p14589
aVThe alternate stream is not present
p14590
aVThe process does not have sufficient rights to delete the alternate stream
p14591
aVFor 1 and 2 an error code of  will be returned
p14592
aVFor 3 you will be given an error code of
p14593
as(dp14594
g7
V505088
p14595
stp14596
a((dp14597
g2
(lp14598
VWithout support from the compiler you don't have many options
p14599
aVI'm presuming that you wish to pass a value to a function in some external DLL
p14600
aVYou'll have to declare the parameter as a signed 64 bit integer,
p14601
aVThen all you can do is pass in the signed value that has the same bit pattern as the desired unsigned value
p14602
aVBuild yourself a little converter tool with a compiler that has support for unsigned 64 bit integers
p14603
as(dp14604
g7
V505088
p14605
stp14606
a((dp14607
g2
(lp14608
VUse  which is declared in ShellAPI
p14609
as(dp14610
g7
V505088
p14611
stp14612
a((dp14613
g2
(lp14614
VIn this case you would be better to use  to start the process
p14615
aVThis allows you to obtain the newly created process handle which is not returned by
p14616
aVOnce you have that you simply call
p14617
aVAs yet another alternative, you may consider creating the process with
p14618
as(dp14619
g7
V505088
p14620
stp14621
a((dp14622
g2
(lp14623
VYou can't do this without painting the control yourself
p14624
aVBut there's no point to do that because a combo box that can't be dropped down is an edit box
p14625
aVUse one of those instead, perhaps supporting auto suggest
p14626
as(dp14627
g7
V505088
p14628
stp14629
a((dp14630
g2
(lp14631
VIs there a way to keep the Python secret codes secret
p14632
aVNo there is not
p14633
aVPython is particularly easy to reverse engineer, but other languages, even compiled ones, are easy enough to reverse
p14634
as(dp14635
g7
V505088
p14636
stp14637
a((dp14638
g2
(lp14639
VThe standard file dialogs offered by WinForms and WPF are merely wrappers around the native dialogs
p14640
aVSo it makes most sense to use these managed C# classes
p14641
aVIf you wish to customise the dialogs in any way (e
p14642
ag217
aVadding controls to the dialog) then there may be a case for using the native API
p14643
aVBut that's mainly because you need to use a different customisation technique for XP from that used for Vista/7
p14644
aVEven in pure native code, customising file dialogs is non-trivial and you should really avoid doing it if you reasonably can
p14645
as(dp14646
g7
V505088
p14647
stp14648
a((dp14649
g2
(lp14650
VYou'll have to stick to copy/paste
p14651
aVIf there was a slick way to do this then every single Delphi programmer on the planet would have used it to turn this
p14652
aVinto this
p14653
as(dp14654
g7
V505088
p14655
stp14656
a((dp14657
g2
(lp14658
VThe error message is telling you that the COM class with CLSID 56A9ADF8-604D-40B7-A696-990FCFAD1E46 is not registered on the target machine
p14659
aVTo solve this work out what object that CLSID refers to and make sure it is installed and registered
p14660
as(dp14661
g7
V505088
p14662
stp14663
a((dp14664
g2
(lp14665
VThe problem is presumably that the marshaller is doing something it should not with the return value
p14666
aVThe MSDN documentation states:
p14667
aVThe returned pointer must not be freed
p14668
aVBut the C# marshaller doesn't know that
p14669
aVInstead you'll need to take control over the marshalling of the return value
p14670
aVFor simplicity I've ignored error handling, but this is the essence of your problem
p14671
aVThe documentation for  states:
p14672
aVPtrToStringUni is useful for custom marshaling or for use when mixing managed and unmanaged code
p14673
aVBecause this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate
p14674
aVIn other words, it doesn't free the return value from  and that's exactly what you want in this situation
p14675
as(dp14676
g7
V505088
p14677
stp14678
a((dp14679
g2
(lp14680
VThe update region is passed in message's
p14681
aVThe non client area of the window isn't rectangular so you don't get a single
p14682
aVI presume you are aware that  is not compatible with Vista DWM glass
p14683
as(dp14684
g7
V505088
p14685
stp14686
a((dp14687
g2
(lp14688
VYou can't intercept CTRL+ALT+DEL
p14689
aVIt's known as the secure attention key and if an app could intercept it then the computer's security would be compromised
p14690
aVWhat you can do is to configure
p14691
aVWindows to ignore Ctrl+Alt+Del by disabling task manager: http://msdn
p14692
aVmicrosoft
p14693
aVcom/en-us/library/ms811991
p14694
aVaspx
p14695
aVThere's no reason why you shouldn't be able to intercept ALT+F4 but it's hard to advise you since you haven't been completely clear in your question
p14696
aVIn particular the code you present is out of context and I can't guess to which events it runs in response
p14697
aVIf you are looking for the key code for F4 then it is
p14698
aVI strongly recommend you use the standard named constants rather than hard coded literal values, e
p14699
ag217
as(dp14700
g7
V505088
p14701
stp14702
a((dp14703
g2
(lp14704
VRather than polling and calling , which is seldom an effective approach, arrange for the event of interest to send you a message or fire an event
p14705
as(dp14706
g7
V505088
p14707
stp14708
a((dp14709
g2
(lp14710
VThe flat scroll bar functions are not implemented in v6 comctl32 which you are presumably linking against
p14711
aVFlat scroll bar functions are implemented in Comctl32
p14712
aVdll versions 4
p14713
aV71 through 5
p14714
aV82
p14715
aVComctl32
p14716
aVdll versions 6
p14717
aV00 and higher do not support flat scroll bars
p14718
aVThe VCL code won't be using these functions so I think you need to locate the 3rd party component that is doing so
p14719
aVI guess that the move to XE introduced the comctl32 v6 manifest and brought this issue to light
p14720
aVOn the other hand, you could always remove the v6 manifest which will get over this particular issue but your app will use the classic theme and look like your are running Windows 2000 again
p14721
as(dp14722
g7
V505088
p14723
stp14724
a((dp14725
g2
(lp14726
V is what you want if you need to deal with the file on a per-line basis
p14727
aVIf you just want to treat it as a single string blob then there is
p14728
as(dp14729
g7
V505088
p14730
stp14731
a((dp14732
g2
(lp14733
VThe simplest solution would appear to be to use themed Tk with the tkinter
p14734
aVttk module included in Python 2
p14735
aV7 and 3
p14736
ag5537
aVThe Progressbar widget is what you want
p14737
aVSince you appear to be considering other frameworks you might look at Qt or wxWidgets which look native and have excellent Python bindings
p14738
as(dp14739
g7
V505088
p14740
stp14741
a((dp14742
g2
(lp14743
VIf there was a new local variable frame for each method call then you would not need a stack
p14744
aVYou could do it all with heap memory
p14745
aVIn reality, for performance reasons all practical implementations will use a stack and have a one to one correspondence between stacks and threads
p14746
as(dp14747
g7
V505088
p14748
stp14749
a((dp14750
g2
(lp14751
VYou are compiling the app targetting Unicode strings but declaring ANSI string variables
p14752
aVIf you want Unicode then you need to use wide chars,  and the corresponding string handling routines in the standard library
p14753
aVIf you aren't ready to tackle that change yet then change the project options from Unicode to MBCS which is the slightly counter intuitive way to get an ANSI build
p14754
as(dp14755
g7
V505088
p14756
stp14757
a((dp14758
g2
(lp14759
VThis is a known bug in the  component that has been submitted to Quality Central: QC#10877
p14760
aVThe fault was reported way back in 2005 and since it hasn't been fixed yet I don't hold out much hope that it ever will be fixed
p14761
aVI doubt very much that there is an easy workaround and suspect that you may need to resort to
p14762
aVYou're only hope would be to include the ActnMenus VCL unit into your own project and then find and fix the bug
p14763
aVI've done this time and time again for the numerous bugs in  and  but I'm afraid I have no experience with  and none with right to left drawing
p14764
as(dp14765
g7
V505088
p14766
stp14767
a((dp14768
g2
(lp14769
VI think this will do what you want but I must admit I'm not that familiar with C# so I'd expect there to be a more idiomatic form with less looping:
p14770
aVRegarding your update, that is handled by passing a negative value for
p14771
aVFor your example pass
p14772
as(dp14773
g7
V505088
p14774
stp14775
a((dp14776
g2
(lp14777
VLet's take the code for  from Wikipedia:
p14778
aVYou could implement this alternatively as:
p14779
aVOr alternatively as:
p14780
as(dp14781
g7
V505088
p14782
stp14783
a((dp14784
g2
(lp14785
VYou are going about this the wrong way
p14786
aVWhat you are really trying to do is to replace the shell
p14787
aVWindows provides for this so you should just take advantage of it
p14788
aVWrite your own shell to replace explorer
p14789
as(dp14790
g7
V505088
p14791
stp14792
a((dp14793
g2
(lp14794
VYou don't need unsafe code and fixed here
p14795
aVThe standard P/Invoke marshaller is more than up to the task:
p14796
aVI don't know for sure what the protocol of the function is, but it is normal for such functions to be able to receive  if the output array has size 0
p14797
as(dp14798
g7
V505088
p14799
stp14800
a((dp14801
g2
(lp14802
VYou can use whatever extensions you feel like using
p14803
aVNo change there
p14804
as(dp14805
g7
V505088
p14806
stp14807
a((dp14808
g2
(lp14809
VYou can't do what you describe
p14810
aVJust imagine what would happen if a client requests the  interface
p14811
aVWhich one should be returned
p14812
aVIt sounds to me like each action should be implemented by separate objects
p14813
as(dp14814
g7
V505088
p14815
stp14816
a((dp14817
g2
(lp14818
VI think you are using a 16 bit compiler and that  can't allocate that much memory in a single contiguous block
p14819
aVI've just noticed that you are using  as your loop variable rather than the more commonly used  which further backs up my wild guess
p14820
as(dp14821
g7
V505088
p14822
stp14823
a((dp14824
g2
(lp14825
VOne way to do this is to use a mutex to ensure that only a single thread is executing in the function at any one time
p14826
aVOf course, this presumes that this is the type of thread safety you are referring to
p14827
aVBeing thread-safe could mean many different things
p14828
aVFor example, take a read of Eric Lipperts post titled What is this thing you call "thread safe"
p14829
aVIf those 5 threads are called at the same time then are they executed concurrently or do they wait until a thread that currently works in the function to be finished
p14830
aVUnless you impose some synchronisation mechanism (e
p14831
ag217
aVa mutex) then the threads execute the function concurrently
p14832
aVWhether or not this is a problem for your function, and what the solution is, depends on the data access patterns of that function
p14833
as(dp14834
g7
V505088
p14835
stp14836
a((dp14837
g2
(lp14838
VI'd always use the second one which maintains type safety
p14839
aVI don't really buy the performance argument since you are about to hit the disk at worst, or file cache, or main memory, all of  which are going to make a handful of CPU operations look somewhat trivial
p14840
aVCorrectness should be given higher priority than performance
p14841
aVHowever, I would add that this is not something that should be bothering you too much since you should write this particular piece of code once and once only
p14842
aVPut it in a helper class and wrap it up well
p14843
aVFeel free to care about optimisation, re-write it as assembler, whatever takes your fancy
p14844
aVBut don't repeat yourself
p14845
as(dp14846
g7
V505088
p14847
stp14848
a((dp14849
g2
(lp14850
VYou've got your row/column loops the wrong way round
p14851
aVInstead of:
p14852
aVyou need:
p14853
aVYour code was effectively transposing the matrix
p14854
aVIn fact for the input you give this doesn't matter since the matrix is symmetric and so you get away with it for now
p14855
aVAlso see @Banthar's answer for another mistake
p14856
as(dp14857
g7
V505088
p14858
stp14859
a((dp14860
g2
(lp14861
VAlthough MSVC is definitely not POSIX compliant,  is implemented in the MSVC runtime (at least as of MSVC2008) in a threadsafe manner
p14862
aVAlthough the documentation states that it is  it's actually implemented as a  to a function which allows thread-safety to be imposed
p14863
aVIf you step through this function in the disassembly window, it is clear that thread local storage is used
p14864
aVSadly I can't point to any official documentation that confirms this but such is life
p14865
as(dp14866
g7
V505088
p14867
stp14868
a((dp14869
g2
(lp14870
VYou can't do this in standard C\u2014the language does not cater for specifying integer literals in binary
p14871
as(dp14872
g7
V505088
p14873
stp14874
a((dp14875
g2
(lp14876
VThe classic take on this is by Hallvard Vassbotn: Hack #7: Interface to Object
p14877
aVMore recently Barry Kelly, a Delphi compiler engineer, also provided an implementation: An ugly alternative to interface to object casting
p14878
aVI think both approaches should work
p14879
aVIncidentally, does anyone know if Hallvard is still active
p14880
aVI've not come across him in the past few years
p14881
as(dp14882
g7
V505088
p14883
stp14884
a((dp14885
g2
(lp14886
VThat's just slightly sloppy code
p14887
aVIt should be written like this:
p14888
aVThe variable  is not needed, but since it is managed it is initialised to  and so the meaning of the code is correct
p14889
aVSo in the code in your question,  and thus that code is equivalent to calling the parameterless constructor
p14890
aVEven if the reason is as Mason hypothesises (and it's certainly plausible), the code should have been written  to work on older versions of Delphi that lacked the parameterless constructor
p14891
aVOne side effect of declaring  in the code in your question is that an unnecessary implicit try/finally block is added around the method
p14892
aVAgain this is benign but you may as well avoid it
p14893
as(dp14894
g7
V505088
p14895
stp14896
a((dp14897
g2
(lp14898
VSince you are in control of the uninstall process you can notify yourself however you please during that process
p14899
aVBut there's no magic API to do the work for you I'm afraid
p14900
as(dp14901
g7
V505088
p14902
stp14903
a((dp14904
g2
(lp14905
VYou can use the functions that are declared in the interface section, that is the section of code before the  section
p14906
aVYou are probably trying to call functions that are defined only in the implementation section, that is that code that appears after the  keyword
p14907
aVThese different sections are how Delphi implements public and private visibility at the unit level
p14908
aVUsually, in well written units, there will be a reason for functions being made private to the unit
p14909
aVBut if you feel it reasonable to override the author's decision then you need to redeclare the function in the interface section
p14910
aVThis will make it available to your code which uses the 3rd party unit
p14911
as(dp14912
g7
V505088
p14913
stp14914
a((dp14915
g2
(lp14916
VIf uses short circuit boolean evaluation to find the first non-null string in the list
p14917
aVFor strings, the empty string  evaluates to  and everything other string is regarded as a  value
p14918
aVSections 5
p14919
aV1 and 5
p14920
aV2 from the documentation tell you all you need to know to understand this
p14921
aVIn particular:
p14922
aVThis is a short-circuit operator, so it only evaluates the second argument if the first one is False
p14923
as(dp14924
g7
V505088
p14925
stp14926
a((dp14927
g2
(lp14928
VIf non-representability is resulting in bugs in your code then your algorithms are flawed in some way
p14929
aVIt's hard to say how they are flawed because you have not shared any details, but using a representable number won't fix it
p14930
aVIn fact 0
p14931
aV11 is not representable either and so if it solves your problem, it does so for some reason other than this
p14932
as(dp14933
g7
V505088
p14934
stp14935
a((dp14936
g2
(lp14937
VThere's no such method in  but you don't need the  tests
p14938
aVYou can simply write it like this:
p14939
aVIf the string in the first parameter to  is not found then the call to  is a null operation\u2014exactly what you want
p14940
aVThe documentation states:
p14941
aVReplaces all occurrences of a specified string in this instance with another specified string
p14942
aVThe way you read this is that when there are no occurrences, nothing is done
p14943
as(dp14944
g7
V505088
p14945
stp14946
a((dp14947
g2
(lp14948
VYou get the cursor position by calling
p14949
aVThis returns the cursor position relative to screen coordinates
p14950
aVCall  to map to window coordinates
p14951
aVYou hide and show the cursor with
p14952
aVYou must ensure that every call to hide the cursor is matched by one that shows it again
p14953
as(dp14954
g7
V505088
p14955
stp14956
a((dp14957
g2
(lp14958
VThe issue is nothing to do with Windows versions
p14959
aVYou will have the same problem on XP if you use font scaling
p14960
aVWhat you want to do is to arrange that your form scales itself automatically when it is opened on a machine with font scaling different from 100%
p14961
aVThis can be achieved by setting the form's  to  or
p14962
as(dp14963
g7
V505088
p14964
stp14965
a((dp14966
g2
(lp14967
VIf you want to format it differently you can do, but this is the bare bones
p14968
aVFor example, adding line breaks every 10 items:
p14969
aVOr perhaps you want tab separators:
p14970
as(dp14971
g7
V505088
p14972
stp14973
a((dp14974
g2
(lp14975
VCall  or  on the text box passing a delegate that sets the Text property
p14976
aVwill execute the delegate on the thread associated with the text box
p14977
aVdoes the same but asynchronously
p14978
as(dp14979
g7
V505088
p14980
stp14981
a((dp14982
g2
(lp14983
VIt couldn't be simpler
p14984
as(dp14985
g7
V505088
p14986
stp14987
a((dp14988
g2
(lp14989
VPointer to string, zero terminated
p14990
aVIt is known as Hungarian notation which is something that tends to stir up strong feelings amongst programmers
p14991
as(dp14992
g7
V505088
p14993
stp14994
a((dp14995
g2
(lp14996
VYou seem to be asking about what are called benign races
p14997
aVFor example consider an integer variable representing a progress value in the range 0 to 100
p14998
aVYou read it from one thread at the same time as you are incrementing from another
p14999
aVYou don't mind whether you read the value before the write or the value after the write
p15000
aVYou'll read it again soon and then you'll get the value from after the write
p15001
aVIn that scenario the race is benign
p15002
aVHowever what may not be benign is something called tearing
p15003
aVThe hardware may allow you to read the value whilst only some part of the memory has been written to by the other thread
p15004
aVFor example the writing thread may write the low word, then the read of both words occurs and then the high word is written
p15005
aVTearing can lead to incorrectness
p15006
aVThe hardware does provide guarantees about tearing but they vary between architectures
p15007
aVFor example x86 has atomic access, i
p15008
ag192
aVno tearing, for 4 byte wide data that is 4 byte aligned
p15009
aVIf you are writing portable code then you are in quite tricky waters because the current standard gives no guarantees about atomicity
p15010
aVIf you can make assumptions on your hardware platform then you may be able to take advantage of benign races
p15011
as(dp15012
g7
V505088
p15013
stp15014
a((dp15015
g2
(lp15016
VA websearch for JNI delphi invocation turned up this as the first hit: Using the Java Native Interface with Delphi
p15017
aVIt appears to be exactly what you are looking for
p15018
aVThe part that is relevant to your needs is Introduction and Tutorial: Part Three - The Invocation API
p15019
as(dp15020
g7
V505088
p15021
stp15022
a((dp15023
g2
(lp15024
VI don't think anyone nowadays would design an error handling system like
p15025
aVEven if  is implemented using thread-local storage it is still far from ideal\u2014it is still a global variable at heart
p15026
aVSince you don't have grown up error handling based on exceptions I would recommend returning error codes as function return values
p15027
aVThis allows you to use the stack, avoid global state, and therefore be resilient to threads and re-entrant calling patterns
p15028
as(dp15029
g7
V505088
p15030
stp15031
a((dp15032
g2
(lp15033
VYour problem is most likely the Fortran code
p15034
aVIt's not uncommon for Fortran code to use shared global state variables, especially for older code
p15035
aVThat's just one possibility, but there are plenty of other reasons why the Fortran code may not be thread-safe for your usage
p15036
aVIf this is indeed the problem then you have a few options that may help:
p15037
aVSerialise calls to the Fortran code with a mutex/lock
p15038
aVRe-factor the Fortran code to remove global shared state, e
p15039
ag217
aVmoving it onto the stack
p15040
aVArrange that each thread uses a separate instance of the DLL
p15041
aVThe last option is a rather gross hack, but it may be the most effective short term solution
p15042
aVTo arrange that you have separate instances you just need to copy and rename the DLL so that each thread loads a DLL with a different name
p15043
aVEven if they are identical this is enough to persuade Windows to load separate instances of the DLL module and therefore separate instances of all global data
p15044
aVOne final thought: make sure that you are linking the Fortran to the multi-threaded version of the Fortran runtime
p15045
as(dp15046
g7
V505088
p15047
stp15048
a((dp15049
g2
(lp15050
VYou can set the caret position with the  and  properties of the rich text box
p15051
aVSet  to 0 and then set  to the location where you want the caret to appear
p15052
aVThe documentation for  says:
p15053
aVIf no text is selected in the control, this property indicates the insertion point, or caret, for new text
p15054
aVThe Win32 API function  is much too low level for your needs
p15055
as(dp15056
g7
V505088
p15057
stp15058
a((dp15059
g2
(lp15060
VNo, it's probably more like this:
p15061
aVBut you've not included the labels in your assembler so I can't be sure
p15062
aVI've assumed the labels are like this:
p15063
as(dp15064
g7
V505088
p15065
stp15066
a((dp15067
g2
(lp15068
VIf you have the INI section in a string list you can just use the  property:
p15069
aVString list contents
p15070
aVCode to read into record
p15071
aVNaturally you would want to handle errors one way or another, but this the the basic idea
p15072
as(dp15073
g7
V505088
p15074
stp15075
a((dp15076
g2
(lp15077
VThe VB6 code is most probably single threaded
p15078
aVThe re-entrancy is presumably limited to the VB6 code
p15079
aVThe VB6 code can't inject re-entrant events into the C++ code
p15080
aVSo long as the C++ code does not call back into the VB6 code then the C++ code itself will not be called in re-entrant fashion
p15081
aVIf these presumptions are correct then your current code with a single global buffer will operate correctly
p15082
aVThat said you would be better off switching to  in my view because it would allow for future linking against caller's that were multi-threaded
p15083
as(dp15084
g7
V505088
p15085
stp15086
a((dp15087
g2
(lp15088
VOr directly with a  to cut down on the number of intermediate objects created:
p15089
aVI don't believe using  is helpful here since it just involves an extra unnecessary heap allocation/deallocation
p15090
as(dp15091
g7
V505088
p15092
stp15093
a((dp15094
g2
(lp15095
VIt's just so happens that the most commonly used components in that part of the stack all happened to begin with a P
p15096
aVIt's nothing more than a coincidence
p15097
aVThe LAMP acronym was coined before Ruby gained its current popularity levels and there's no reason why you couldn't stick Ruby in the P slot
p15098
as(dp15099
g7
V505088
p15100
stp15101
a((dp15102
g2
(lp15103
VYou need modern versions of Delphi to do what you ask for without resorting to manually coding the lookups, e
p15104
ag217
aVvia a table
p15105
aVThe updated RTTI introduced in Delphi 2010 can support what you are looking for, but there's nothing in Delphi 7 that will do this for records
p15106
as(dp15107
g7
V505088
p15108
stp15109
a((dp15110
g2
(lp15111
VThese messages are posted to the message queue rather than sent synchronously
p15112
aVThis is clear because you are tracing them back to  which is the routine that pumps your main thread's message queue
p15113
aVThat's why you don't see the call site on the stack
p15114
aVThey are generated by calls to PostMessage, either in the 3rd party component or possibly more likely by Windows
p15115
aVI don't know these components so I doubt I can help solve your problem
p15116
aVI think you should contact the component vendor who should know what to do
p15117
as(dp15118
g7
V505088
p15119
stp15120
a((dp15121
g2
(lp15122
VIrrespective of which one is faster, and it's unlikely that it would ever matter,  is to be preferred because it makes your intent clear
p15123
aVPrefer it for the same reason that you prefer writing  to bit shifts
p15124
as(dp15125
g7
V505088
p15126
stp15127
a((dp15128
g2
(lp15129
VIf your problem in UAC then simply arrange that your app doesn't do anything that requires administrator rights
p15130
aVIn particular:
p15131
aVDon't write to the HKLM part of the registry
p15132
aVDon't save files in restricted folders system32, Program Files etc
p15133
aVWhatever you do don't ask users to turn off UAC and don't ask them to run as administrator
p15134
as(dp15135
g7
V505088
p15136
stp15137
a((dp15138
g2
(lp15139
VThe code below results in visible groups
p15140
aVAre you perhaps forgetting to set  to
p15141
aVThere is an code example in the Delphi documentation
p15142
as(dp15143
g7
V505088
p15144
stp15145
a((dp15146
g2
(lp15147
VThere's no such function
p15148
aVNo such function could possibly exist
p15149
aVWindows cannot possibly know which resources are to be tidied up by that thread, and it couldn't know how to do so
p15150
aVThat is the responsibilty of your app
p15151
aVIt sounds to me like your are going about this the wrong way
p15152
aVYou ought to be terminating the thread in a co-operative fashion without using force
p15153
aVAnything else is bound to lead to leaks and most likely other more serious problems
p15154
as(dp15155
g7
V505088
p15156
stp15157
a((dp15158
g2
(lp15159
VYour structs are marshalled incorrectly because you didn't declare the arrays quite right
p15160
aVYou need to tell the marshaller that they are fixed length arrays
p15161
aVEDIT
p15162
aVIn my original answer I missed the addition error that the  members were not marshalled correctly
p15163
aVThe default marshalling is for the 4 byte Windows  but you need 1 byte C++
p15164
aVThe code below now handles that correctly
p15165
aVSorry for the confusion
p15166
as(dp15167
g7
V505088
p15168
stp15169
a((dp15170
g2
(lp15171
VI don't know what event you intend to use to invoke validation, but the validation can be done like this:
p15172
as(dp15173
g7
V505088
p15174
stp15175
a((dp15176
g2
(lp15177
VHere's a Delphi translation of a C# answer to an identical question:
p15178
aVOutput:
p15179
as(dp15180
g7
V505088
p15181
stp15182
a((dp15183
g2
(lp15184
VPerhaps you are looking for
p15185
aVIf the caller resides in a single-thread
p15186
aVapartment, CoWaitForMultipleHandles enters the COM modal loop, and the thread's
p15187
aVmessage loop will continue to dispatch
p15188
aVmessages using the thread's message
p15189
aVfilter
p15190
aVIf no message filter is registered
p15191
aVfor the thread, the default COM
p15192
aVmessage processing is used
p15193
as(dp15194
g7
V505088
p15195
stp15196
a((dp15197
g2
(lp15198
VThe standard way to do this is to use the Delphi  property
p15199
aVIt's best to do it this way so that the VCL is aware that you want right-to-left
p15200
aVYou need to change the  property on the popup menu too
p15201
aVNow, the correct way to do this is not to change the properties on the individual components
p15202
aVDoing it that way is laborious and very error prone
p15203
aVSet  somewhere in your application's initialization and the change will propagate through to all your components
p15204
aVFor example you can make the change in your application's
p15205
aVdpr file:
p15206
aVYou need to make sure that you have not modified any component's  or  in any
p15207
aVdfm file
p15208
aVIf you have simply remove those lines from your
p15209
aVdfm file and that will allow the single application wide  setting to control everything
p15210
aVYour approach of setting  is problematic
p15211
aVThe VCL is in control of that setting and if you do need to change it, doing so in  will lead to strange bugs
p15212
aVSometimes windows need to be re-created and when this happens your code to set  will not run and your tree view will revert to left-to-right
p15213
aVIf you do need to modify the window styles then you need to override  for the component
p15214
aVHowever, in this case the VCL has direct support for BiDi and that is the best solution
p15215
as(dp15216
g7
V505088
p15217
stp15218
a((dp15219
g2
(lp15220
VThe Delphi compiler emits 32 bit object code
p15221
aVIt doesn't matter how you slice it, that code cannot be linked into a 64 bit module
p15222
aVAt the moment your best bet is to use FreePascal which can produce 64 bit DLLs
p15223
aVThere is an upcoming 64 bit version of Delphi but its release date is unknown
p15224
aVAnother option would be to enforce the use of the 32 bit version of the JVM, if that is possible for you
p15225
as(dp15226
g7
V505088
p15227
stp15228
a((dp15229
g2
(lp15230
VAs a complement to Cosmin's answer, I offer this version of Utf16 -> Ansi converstion:
p15231
aVIt is robust in the face of empty files, files that aren't null-terminated which is in fact the norm
p15232
aV(Cosmin has probably fixed his version by now
p15233
aVYou can use it like this:
p15234
aVIf you wanted to get cute you could look for the BOM in the file and then decide to load UTF-16, UTF-8 and so on depending on what the BOM was
p15235
aVIn this code I have made the assumption that the file is encoded as UTF-16 with a BOM, as is your file
p15236
as(dp15237
g7
V505088
p15238
stp15239
a((dp15240
g2
(lp15241
V is the function you need to call
p15242
aVYou never send or post  messages\u2014the Window manager does that for you when they are needed (e
p15243
ag217
aVwindows dragged over your window)
p15244
aVIf the repaint is due to changes that the Window manager does not know about then you force a repaint cycle by calling
p15245
aVPass  for  and the entire client area will be repainted
p15246
aVPass  for  to force the background to be erased when the repaint cycle begins
p15247
aVWhen you call  what happens is that a  message is placed in your message queue and the  function call returns
p15248
aVWhen you next clear your message queue you the process the  message
p15249
aVI suggest that you get hold of a copy of Petzold's Programming Windows book and read all about it
p15250
as(dp15251
g7
V505088
p15252
stp15253
a((dp15254
g2
(lp15255
V is raised when the hardware objects to you trying to run a privileged instruction in user mode
p15256
aVThese privileged instructions are restricted to supervisor mode, a
p15257
ag4705
ag4706
aVring 0
p15258
aVThe hardware raises the error and then the RTL catches it and maps it to a RTL exception, just like all the  exceptions, e
p15259
ag217
aV,  etc
p15260
aVAdmin rights are not relevant here
p15261
aVThat is something that is enforced by the OS software
p15262
aVInstruction privilege is controlled at the hardware level
p15263
aVYou see such an error if you attempt to execute garbage (i
p15264
ag192
aVcorrupted function pointer) which just happens to spell a privileged instruction
p15265
aVMemory corruption is the only sane explanation
p15266
aVOnly compilers that target kernel mode code will emit privileged instructions
p15267
as(dp15268
g7
V505088
p15269
stp15270
a((dp15271
g2
(lp15272
VAll COM interfaces must implement :
p15273
aVprovides two services
p15274
aVFirst of all,  allows for clients to obtain the other interfaces that the object may implement
p15275
aVThe second service is that of lifetime management
p15276
aVEvery time you take a reference to a COM object it is your responsibility to call
p15277
aVEvery time you give up a reference to a COM object, you are contracted to call
p15278
aVThe canonical implementation of  and  is for the implementing object to maintain a reference count variable which is incremented and decremented as references are taken and released
p15279
aVIf a call to  sets this reference count to 0 then the object destroys itself
p15280
aVThe Delphi implementation of interfaces manages the calls to  and  on your behalf
p15281
aVWhen you assign to an interface variable the compiler emits code that:
p15282
aVCalls  on the interface that the variable previously referred to, if indeed it did previously refer to something
p15283
aVCalls  on the interface that the variable now refers to
p15284
aVThe compiler also arranges for  to be called whenever the variable leaves scope
p15285
aVWhat this means is that you need to take no special action whatsoever to ensure that your COM objects will be destroyed
p15286
aVThey will naturally be destroyed when the last reference to the object leaves scope
p15287
aVIf however, you do wish to destroy an object ahead of time, then you simply assign  to the variable holding the interface
p15288
aVNote that this is of course presuming that no other references are held to that interface
p15289
as(dp15290
g7
V505088
p15291
stp15292
a((dp15293
g2
(lp15294
VAll options you present other than the first one are exceedingly user-hostile
p15295
aVJust ignore the double clicks and in time the users will realise that only one suffices
p15296
as(dp15297
g7
V505088
p15298
stp15299
a((dp15300
g2
(lp15301
VOptions 1 and 2 will result in identical code being produced by the compiler
p15302
aVOption 3 will be much slower
p15303
aVIt's a fallacy that  is faster than  or even
p15304
aVAll decent compilers will turn those three instructions into the same code
p15305
aVFor such a trivial operation as addition, write the clearest code and let the compiler worry about making it fast
p15306
as(dp15307
g7
V505088
p15308
stp15309
a((dp15310
g2
(lp15311
VPlease don't tell me to recompile it
p15312
aVunder windows
p15313
aVYou'll have to recompile it under Windows
p15314
aVSorry
p15315
aVIf you really can't find a compiler with support for 128 bit integers you should use some assembler to replicate the instructions that you Linux compiler emits
p15316
as(dp15317
g7
V505088
p15318
stp15319
a((dp15320
g2
(lp15321
VYour screenshot clearly shows that the object is not null since you can see the values of its properties
p15322
aVThose properties are all null which is what is confusing you
p15323
as(dp15324
g7
V505088
p15325
stp15326
a((dp15327
g2
(lp15328
VThere's nothing to be gained from this
p15329
aVYou are only changing the scale but you'd don't get any more significant figures in your calculation
p15330
aVThe Wikipedia article on variance explains at a high level some of the options for calculation variance in a robust fashion
p15331
as(dp15332
g7
V505088
p15333
stp15334
a((dp15335
g2
(lp15336
VThis is how I would do it:
p15337
aVWhile you can do it with , and  is the newer and more capable API,  is just easier to call
p15338
as(dp15339
g7
V505088
p15340
stp15341
a((dp15342
g2
(lp15343
VIt will in general be quickest to declare  as an
p15344
aVI can't imagine why you want to loop with an 8 bit integer
p15345
aVPerhaps you think it will be quicker than  but it won't
p15346
as(dp15347
g7
V505088
p15348
stp15349
a((dp15350
g2
(lp15351
VHere's a simple program that integrates $f(x) = x^2$ over the range [0
p15352
aV10]
p15353
aVIt should send you in the right direction
p15354
as(dp15355
g7
V505088
p15356
stp15357
a((dp15358
g2
(lp15359
VYou are calling  multiple times
p15360
aVThe second time round, in the  call, returns a different value from the first call because the file pointers have been used
p15361
aVCall  once and store the returned value in a local
p15362
aVI don't know whether the rest of your logical is correct or not
p15363
aVActually, your logic is not correct
p15364
aVIt enters an infinite loop when presented with identical files
p15365
aVI'm sure you'll be able to track down the problem
p15366
as(dp15367
g7
V505088
p15368
stp15369
a((dp15370
g2
(lp15371
VYour code works fine in that it blocks 'a' to 'z'
p15372
aVPerhaps your problem is that it doesn't block upper case characters
p15373
aVFor that you would need:
p15374
as(dp15375
g7
V505088
p15376
stp15377
a((dp15378
g2
(lp15379
VLike so:
p15380
aVOr perhaps you want to set the client area to those dimensions:
p15381
aVOf course, you most commonly set these properties in the Object Inspector at design time and then they are written to your form's
p15382
aVdfm file
p15383
aVIf you want such a change to occur on a button click add a handler for the button click that looks like this:
p15384
aVIn this last excerpt you don't need to specify the  object instance because the event handler is a member of the  class and so the  is implicit
p15385
aVIf you wish to follow Ulrich Gerhardt's advice (see comment) and use  then you would write:
p15386
aVFinally, if your form has  then you need to deal with font scaling
p15387
aVHard coded pixel dimensions like this will not be appropriate for machines with font scaling set to a different value from your machine
p15388
as(dp15389
g7
V505088
p15390
stp15391
a((dp15392
g2
(lp15393
VThe simple solution is to move the declaration of  to the Utils unit
p15394
aVYou can't declare it twice because then you have two distinct types
p15395
aVThat's no use to you, you need only a single type
p15396
aVThis solution will work so long as the Main unit does not need to reference  in its interface section
p15397
aVSince the Utils unit clearly needs to do so then that would create a circular dependency between unit interface sections which is illegal
p15398
aVIf both the Main and Utils units need to reference  in their interface sections then you need to create another unit that just contains type declarations
p15399
aVThat unit could be used by both Utils and Main in their  sections
p15400
as(dp15401
g7
V505088
p15402
stp15403
a((dp15404
g2
(lp15405
VThe system ignores any bits that do not correspond to processors
p15406
aVFor your example, therefore, you are attempting to set the thread to have affinity with none of the available processors in the process affinity mask and the call to  fails
p15407
as(dp15408
g7
V505088
p15409
stp15410
a((dp15411
g2
(lp15412
VAccording to the documentation for  you can include the  flag which looks like it will be needed for what you desire
p15413
aVIt requires the  privilege
p15414
as(dp15415
g7
V505088
p15416
stp15417
a((dp15418
g2
(lp15419
VIt's best, if you can do so, to allocate the memory in C# and let your C code fill out the array:
p15420
ag11735
aVC#
p15421
aVIt seems that your question missed the crucial information that you need to allocate the memory in your C code and then hold the pointer in your C# code so that in turn you can hand it on to CUDA
p15422
aVDo it like this:
p15423
ag11735
aVC#
p15424
as(dp15425
g7
V505088
p15426
stp15427
a((dp15428
g2
(lp15429
VYou can't fake input with
p15430
aVInstead you need to use
p15431
as(dp15432
g7
V505088
p15433
stp15434
a((dp15435
g2
(lp15436
VBut I think I'd probably prefer to do the pointer arithmetic outside a helper function
p15437
as(dp15438
g7
V505088
p15439
stp15440
a((dp15441
g2
(lp15442
VIf your testing is going to require modifier keys like ALT and CTRL then SendInput is the only way
p15443
aVRaymond's article makes this quite clear
p15444
as(dp15445
g7
V505088
p15446
stp15447
a((dp15448
g2
(lp15449
VAnybody know if VFW support has been dropped from the 64-bit OSes
p15450
aVVFW works in 64 bit Windows just the same as it ever did on 32 bit Windows
p15451
aVYou probably don't have the codecs installed but that's just a guess because you didn't give any details of error messages
p15452
as(dp15453
g7
V505088
p15454
stp15455
a((dp15456
g2
(lp15457
VThe bottom line here is that you can't generate input quick enough to make the computer even notice
p15458
aVThe computer would not be troubled if you produced input messages at rates hundreds or even thousands greater than you typically do
p15459
aVYou won't be able to measure the difference between handling something in  and using
p15460
aVSo the decision as to which to use comes down to which is most convenient
p15461
aVIf you need handling to happen at an application wide level, and you don't have a common base class for all your forms, then you use
p15462
aVIf you want different behaviour for different forms then you need to use
p15463
aVPersonally I strongly recommend refactoring so that all forms in your projects derive from a common base (a subclass of )
p15464
aVThis allows you much more flexibility
p15465
aVDone this way you can, for example, use the  mechanism to apply intervention points for all forms in your applications
p15466
aVAs for how  is implemented, the input messages get redirected in ,  etc
p15467
aVin
p15468
aVTo learn more read the source code
p15469
as(dp15470
g7
V505088
p15471
stp15472
a((dp15473
g2
(lp15474
VThe only solution that meets your specifications is COM
p15475
as(dp15476
g7
V505088
p15477
stp15478
a((dp15479
g2
(lp15480
V calls  to do the work
p15481
aVThe last part of  runs around all the items calling  passing
p15482
aVYour analysis of the code is thus incorrect
p15483
aVThe  notification is duly delivered and owned objects are freed
p15484
as(dp15485
g7
V505088
p15486
stp15487
a((dp15488
g2
(lp15489
VSuch a list doesn't exist and in fact you can't ever have such a list
p15490
aVIn some future version of Windows a function may well start returning an error code that did not exist when you compiled your program
p15491
aVThe standard way to deal with this is handle any error codes that you know about that need special treatment, and let all others fall through to a default handler
p15492
aVCall  to get a descriptive text string for the error
p15493
as(dp15494
g7
V505088
p15495
stp15496
a((dp15497
g2
(lp15498
VYou just need to use a lock
p15499
aVThere's no call for  in what you describe
p15500
as(dp15501
g7
V505088
p15502
stp15503
a((dp15504
g2
(lp15505
VThat's either ASCII or UTF-8 or one of the 8 bit supersets of ASCII
p15506
aVImpossible to say for sure
p15507
aVYour best bet is to read the documentation of whatever function or program you are trying to pass it to
p15508
as(dp15509
g7
V505088
p15510
stp15511
a((dp15512
g2
(lp15513
V is a pointer and you should declare it as , or as a  parameter
p15514
aVYou are running a 32 bit process and were formerly passing a 64 bit integer, , when a pointer was expected
p15515
aVThe newer version of the
p15516
aVnet runtime detects the error
p15517
aVThe solution is most definitely not to declare the parameter as
p15518
aVThat will then be wrong if you ever compile to a 64 bit target
p15519
aVSince you appear not to be using overlapped I/O I would just use  and pass
p15520
as(dp15521
g7
V505088
p15522
stp15523
a((dp15524
g2
(lp15525
VTo do this properly I think you really need to go beyond a simple batch file
p15526
aVThe MSDN documentation states:
p15527
aVTo programmatically add or modify system environment variables, add them to the HKEY_LOCAL_MACHINE\u005cSystem\u005cCurrentControlSet\u005cControl\u005cSession Manager\u005cEnvironment registry key, then broadcast a  message with lParam set to the string "Environment"
p15528
aVThis allows applications, such as the shell, to pick up your updates
p15529
aVFirst of all you won't be able to write to that key without a UAC elevation prompt
p15530
aVThat's best arranged by adding the appropriate manifest to an executable file
p15531
aVSecondly, broadcasting  isn't simple from a batch file
p15532
aVIn your position I'd write a short and simple console app to do the job
p15533
as(dp15534
g7
V505088
p15535
stp15536
a((dp15537
g2
(lp15538
VTaken from the PHP manual entry for rmdir:
p15539
aVThis solves the problem using recursion
p15540
as(dp15541
g7
V505088
p15542
stp15543
a((dp15544
g2
(lp15545
VYou most likely don't want to be doing this in Python
p15546
aVAs an aside you probably shouldn't be exporting mangled names from your DLLs since it makes it hard to use for anyone with a different compiler
p15547
aVIf you have to use mangled names then just hard code them in your Python code
p15548
aVIf you were going to do mangling in Python code then you'd have to:
p15549
aVKnow the implementation specific rules for the compiler in question
p15550
aVSpecify in Python the C++ function signature for each function
p15551
aVIt seems highly unlikely to me that coding all this up in Python would be better than simply hard coding the mangled names
p15552
as(dp15553
g7
V505088
p15554
stp15555
a((dp15556
g2
(lp15557
VThis code
p15558
aVprints the text "found newline" to the console
p15559
aVTherefore I can only conclude that your list does not contain a newline in the last item
p15560
aVWe can only guess why that is because we can't see your code that populates the list
p15561
as(dp15562
g7
V505088
p15563
stp15564
a((dp15565
g2
(lp15566
VThe standard way to handle this is to use a mutex to ensure that only a single instance of your program runs
p15567
aVThen when the shell attempts to start up a new instance to open each file, the new instance simply passes the message on to the already running instance and lets it open the file
p15568
as(dp15569
g7
V505088
p15570
stp15571
a((dp15572
g2
(lp15573
VYou can't remove content from a file and have the remaining content shifted down
p15574
aVYou can only append, truncate or overwrite
p15575
aVYour best option is to read the file in to memory, process it in memory and then write it back to disk
p15576
as(dp15577
g7
V505088
p15578
stp15579
a((dp15580
g2
(lp15581
VOne of the unit testing frameworks you list is just what you need
p15582
aVTesting is hard and takes time
p15583
aVIf you try to do it without putting in sufficient time and thought your testing won't be worth very much
p15584
aVIt sounds like you are wanting a list of inputs and outputs that your test loops through
p15585
aVThat's easy
p15586
aVJust declare such a list in your test case and run a loop across it
p15587
aVThat's the easy bit
p15588
aVThe hard bit is working out the test data
p15589
as(dp15590
g7
V505088
p15591
stp15592
a((dp15593
g2
(lp15594
VIn a nutshell, if you have multiple threads accessing shared state, and at least one is writing, then you need to worry about thread safety
p15595
aVIf not then you're golden
p15596
as(dp15597
g7
V505088
p15598
stp15599
a((dp15600
g2
(lp15601
VVersion 21 is D2010
p15602
aVD2009 was version 20
p15603
as(dp15604
g7
V505088
p15605
stp15606
a((dp15607
g2
(lp15608
VCalling  doesn't open the key which is why the write fails
p15609
aVThe easiest solution is to replace the call to  with one to  passing  for the  parameter
p15610
aVThis will create the key if it does not already exist, and then open it for you to use in subsequent method calls
p15611
aVAnd for the sake of completeness you should include error handling, try/finally around the lifetime of  etc
p15612
aVI would also recommend that you explicitly set  since at the moment you are relying on its default value of
p15613
as(dp15614
g7
V505088
p15615
stp15616
a((dp15617
g2
(lp15618
VYou are nearly there:
p15619
aVNote that  is a  which is an untyped 32 bit integer
p15620
as(dp15621
g7
V505088
p15622
stp15623
a((dp15624
g2
(lp15625
V and  are  macro versions of C standard library functions  and  for copying and concatenating C strings
p15626
aVThey evaluate to ANSI or Unicode versions depending on whether or the type of project you are targeting
p15627
aVIt's really C code rather than C++ code in my view
p15628
aVIn Delphi you would simply use string variables like this:
p15629
aVPresumably in the C code there is a call to another Windows API function that receives an
p15630
aVThe C code will pass  but you can simply pass  as I have shown above
p15631
aVThe C code is using a fixed length buffer because it doesn't have available a dynamically allocated string class like Delphi's  or  in C++
p15632
aVFixed length buffers like this often lead to buffer overruns
p15633
aVIn Delphi don't use a fixed length buffer if you can avoid it
p15634
aVThis is a classic example of why languages with built in string handling are so much easier to work with than C
p15635
as(dp15636
g7
V505088
p15637
stp15638
a((dp15639
g2
(lp15640
VExit code 0 is customarily used to signal successful termination
p15641
aVExit code 1 would seem to indicate an error
p15642
aVOnly someone in possession of the specification of  could be sure
p15643
aVThat would be you
p15644
as(dp15645
g7
V505088
p15646
stp15647
a((dp15648
g2
(lp15649
V is the holy grail of performance seeking coders, namely code that results in zero clock cycles
p15650
as(dp15651
g7
V505088
p15652
stp15653
a((dp15654
g2
(lp15655
VYou will need to read the folder location from a configuration file, or the registry
p15656
aVThere's no analogue of starting directory
p15657
as(dp15658
g7
V505088
p15659
stp15660
a((dp15661
g2
(lp15662
VYou are on the right lines but the most obvious problem that I can see is the use of  variables
p15663
aVThese are heap allocated and since you have two separate memory managers you will be allocating on one heap (in the DLL) and then freeing on a different heap (in the app)
p15664
aVThere are a few options
p15665
aVOne options would be to share memory managers but I don't recommend this for a variety of reasons
p15666
aVWithout going into them you state in a comment that you want non Delphi applications to be able to use your DLL which would preclude the use of a shared memory manager
p15667
aVAnother option would be to force the calling app to allocate the memory for the string and then let your DLL copy into that memory
p15668
aVThis works fine but is somewhat labour intensive
p15669
aVInstead I would use a string type which can be allocated in one module but freed in a different module
p15670
aVThe COM  is such a type and in Delphi terms this is
p15671
aVChange the code to use  for any exported functions
p15672
aVI would also simplify the importing/exporting process and use implicit dynamic linking
p15673
aVDLL
p15674
aVApp
p15675
as(dp15676
g7
V505088
p15677
stp15678
a((dp15679
g2
(lp15680
VYou can't apply a restriction to the file extension in the call to
p15681
aVIf you did so then directories do not get enumerated
p15682
aVInstead you must check for matching extension in your code
p15683
aVTry something like this:
p15684
as(dp15685
g7
V505088
p15686
stp15687
a((dp15688
g2
(lp15689
VYou can probably achieve what you need by calling  on each process handle returned by
p15690
aVWaits until the specified process has finished processing its initial input and is waiting for user input with no input pending, or until the time-out interval has elapsed
p15691
as(dp15692
g7
V505088
p15693
stp15694
a((dp15695
g2
(lp15696
VI don't think you have much chance of succeeding with your current approach
p15697
aVI'm pretty sure there's no single general purpose API for getting hold of the current selection
p15698
aVI believe this because each application can implement text selection in its own way
p15699
aVAs an alternative solution you should consider using a clipboard listener
p15700
aVListen for changes to the clipboard contents and whenever text is added you can suck it out of the clipboard and put it in your app's window
p15701
as(dp15702
g7
V505088
p15703
stp15704
a((dp15705
g2
(lp15706
VYou are passing the address of a pointer
p15707
aVI think you want this:
p15708
as(dp15709
g7
V505088
p15710
stp15711
a((dp15712
g2
(lp15713
VI find it a little surprising that this ever worked but since you say it did I'm sure you are right
p15714
aVI'd guess the change was made without consideration for record methods
p15715
aVWithout the ability to call methods then this construct would be rather pointless
p15716
aVAnyway, the compiler isn't going to let you off the hook on this one so you'll have to do this:
p15717
as(dp15718
g7
V505088
p15719
stp15720
a((dp15721
g2
(lp15722
VYou need to recalibrate your expectations
p15723
aVLaunch your service automatically when the system starts
p15724
aVLaunch your app when a user logs in (e
p15725
ag217
aV)
p15726
aVArrange that the service is resilient to being started before the app
p15727
aVAlso ensure that the service can survive the app stopping (e
p15728
ag217
aVcrashing) and being restarted
p15729
aVWhy do I say all this
p15730
aVWell, services are intended to run at all times, even if there are no interactive users connected
p15731
aVIf that is so then you simply cannot expect your interactive app to be running before the service starts
p15732
as(dp15733
g7
V505088
p15734
stp15735
a((dp15736
g2
(lp15737
VThe third parameter,  is  which means it must be writeable memory
p15738
aVYou need to copy the command line into a writeable string before calling
p15739
aVThe documentation for  states:
p15740
aVIt is not safe to modify the value of the environment variable using the returned pointer
p15741
aVYou therefore cannot pass this as the  parameter of
p15742
aVYour first call to  appears to be wrong too since you also are not passing writeable memory for
p15743
aVOf course it's most likely that your immediate problem is that you are mixing ANSI and Unicode
p15744
aVIf your app is Unicode then you need to call , or  if you really do want to target both ANSI and Unicode from the same source
p15745
aVBut make sure you copy it into a writeable buffer before passing it on
p15746
aVFinally, as Adam commented, every time you write a cast, there is a strong possibility that you are making a mistake
p15747
as(dp15748
g7
V505088
p15749
stp15750
a((dp15751
g2
(lp15752
VYou can't fit the entire file into a single contiguous block of 32 bit address space
p15753
aVHence the out of memory error
p15754
aVRead the file in smaller pieces and process it piece by piece
p15755
as(dp15756
g7
V505088
p15757
stp15758
a((dp15759
g2
(lp15760
VIt's not possible to stop screenshots
p15761
as(dp15762
g7
V505088
p15763
stp15764
a((dp15765
g2
(lp15766
VThe advice you have received in the other answers is correct
p15767
aVMake sure that you pair up each object instantiation with a corresponding  in the destructor
p15768
aVI'd like to point out why you can't use RTTI to look up all the object instances and free them
p15769
aVSome of the object instances may not be owned by the object that is being destroyed
p15770
aVIf you have a field containing a reference to an object that is owned by some other entity in your system, then you are not at liberty to destroy it
p15771
aVRTTI cannot tell you who owns the object, only you can know that
p15772
as(dp15773
g7
V505088
p15774
stp15775
a((dp15776
g2
(lp15777
VIf you have a stack overflow then your variable doesn't fit on the stack
p15778
aVYou are clearly using a local variable
p15779
aVSolve the problem by using the heap instead
p15780
aVEither  or
p15781
as(dp15782
g7
V505088
p15783
stp15784
a((dp15785
g2
(lp15786
VMy concise explanation is this
p15787
aVThere are many forms of thread safety and code that satisfies one form does not automatically satisfy all the others
p15788
as(dp15789
g7
V505088
p15790
stp15791
a((dp15792
g2
(lp15793
VYou can't suspend modules
p15794
aVYou can suspend threads although you should not do so
p15795
aVA module does not have a main thread
p15796
aVA process has a main thread
p15797
aVSuspending a thread is not something that should be done in
p15798
aVa forceful way
p15799
aVDoing so leads to deadlocks
p15800
aVYou should instead signal the thread to pause and then wait until it can do so
p15801
aVLet
p15802
aVthe thread pause when it knows it is in a safe state to do so
p15803
aVSorry if this sounds unhelpful but you need to explain your real problem
p15804
as(dp15805
g7
V505088
p15806
stp15807
a((dp15808
g2
(lp15809
VIt's against the rules to assign to  which has a very special meaning in Python
p15810
aVChoose a different name
p15811
as(dp15812
g7
V505088
p15813
stp15814
a((dp15815
g2
(lp15816
VI guess you want the taskbar button to be removed when you minimise the main form
p15817
aVYou achieve this by petting its visible property to false, however you do that with your Java framework
p15818
as(dp15819
g7
V505088
p15820
stp15821
a((dp15822
g2
(lp15823
VOn a 32 bit OS, all processes are 32 bit and so no issues arise
p15824
aVOn a 64 bit OS your AnyCPU process runs 64 bit and the only possible mismatch is then with 32 bit processes
p15825
aVBut it's no problem to store a 32 bit address in a 64 bit pointer
p15826
aVIf you were trying to read/write memory in a 64 bit process from a 32 bit process you would be stuck
p15827
aVBut since you are doing the opposite there's no trouble
p15828
as(dp15829
g7
V505088
p15830
stp15831
a((dp15832
g2
(lp15833
VYou need a lock or a CAS type operation
p15834
aVNo amount of  is going to help here
p15835
aVNeither will a true atomic data type
p15836
as(dp15837
g7
V505088
p15838
stp15839
a((dp15840
g2
(lp15841
VOn Windows 7 you can call
p15842
aVOn earlier versions of Windows all you can do is to use rather grotesque hacks
p15843
as(dp15844
g7
V505088
p15845
stp15846
a((dp15847
g2
(lp15848
VFor the static instance of the class I imagine the constructor runs before the debug console is ready to receive output from
p15849
aVThis sort of code is probably very implementation specific
p15850
as(dp15851
g7
V505088
p15852
stp15853
a((dp15854
g2
(lp15855
VYou probably meant:
p15856
aVThe equality operator tests for equality
p15857
aVYou were using it as a kind of set membership test
p15858
aVIf would be great to be able to write
p15859
aVbut that's the preserve of higher level languages
p15860
as(dp15861
g7
V505088
p15862
stp15863
a((dp15864
g2
(lp15865
VTypically the pointer will be held in a stack variable
p15866
aVOr traced back through heap allocated pointers to a stack variable
p15867
aVThe stack is statically allocated and freed when the process terminates
p15868
aVThus nothing is leaked
p15869
as(dp15870
g7
V505088
p15871
stp15872
a((dp15873
g2
(lp15874
VI can't reproduce the missing Code Explorer menu item
p15875
aVIt works fine for me
p15876
aVRegarding the non-dockable windows have you tried right clicking on the troublesome floating window and making sure that Dockable is ticked
p15877
aVOne thing to try when Delphi's IDE is giving you grief is to delete any
p15878
aVdsk files
p15879
aVFinally, Delphi 6 pre-dates UAC and assumes that you can write to the installation directory
p15880
aVHave you made sure that Delphi is able to do this one way or another
p15881
aVSorry I don't have a definitive answer, but this is all I can think of
p15882
as(dp15883
g7
V505088
p15884
stp15885
a((dp15886
g2
(lp15887
VWhenever a process is created, start a timer associated with that process with a timeout of 1s
p15888
aVThe  is set to true and so the row is painted green
p15889
aVWhen the timer fires the handler sets  to false and forces a repaint of that row which removes the green highlight
p15890
aVNow that the timer has done its work it should be deleted
p15891
aVThe exact same approach can be used for deletion
p15892
as(dp15893
g7
V505088
p15894
stp15895
a((dp15896
g2
(lp15897
VButtons generally have a fixed height and width
p15898
aVThis in turn implies that they should be anchored to top or bottom, but not both
p15899
aVLikewise they should be anchored to left or right, but not both
p15900
aVYour buttons are anchored to both top and bottom which seems wrong
p15901
aVI'd guess your solution is to pick just one of top or bottom anchors
p15902
as(dp15903
g7
V505088
p15904
stp15905
a((dp15906
g2
(lp15907
V operates synchronously
p15908
aVThe most obvious causes of the problem are:
p15909
aVYou are not calling
p15910
aVThe file name is invalid (perhaps the path doesn't exist)
p15911
aVThe file name is in a folder to which your user doesn't have write access (e
p15912
ag217
aVthe program files folder)
p15913
as(dp15914
g7
V505088
p15915
stp15916
a((dp15917
g2
(lp15918
VThat is a compiler bug
p15919
aVIf the  is removed then the warning is not emitted
p15920
aVThe compiler has long been able to recognise that a  absolves the coder of the obligation to assign the return value
p15921
aVFor whatever reason the  appears to confuse its analysis
p15922
aVOn second thoughts perhaps it's not a compiler bug
p15923
aVWhat if the code in the  block stopped the exception propagating
p15924
aVClearly there's not an  handler, but I rather suspect that one of the exception support routines in the  or  unit may be able to stop the exception progressing further
p15925
as(dp15926
g7
V505088
p15927
stp15928
a((dp15929
g2
(lp15930
VThat is called token concatenation
p15931
aVIt allows you to glue arguments together
p15932
aVFor your example,  expands like this:
p15933
aVIt's easy enough to try this out yourself by using your compiler's pre-processor
p15934
aVYou don't generally need to go to the trouble of writing a fully-fledged C program\u2014the pre-processor can generally be invoked by itself
p15935
as(dp15936
g7
V505088
p15937
stp15938
a((dp15939
g2
(lp15940
VYou read this that  and  point to
p15941
aVParameters in C are passed by value
p15942
aVSo when you pass two memory addresses (i
p15943
ag192
aVpointers) to  you are assigning those addresses to  and
p15944
aVPerhaps the confusion is due to the heavy overloading of  in C
p15945
aVIn a parameter list  means that the parameter is a pointer to the type to the left
p15946
aVIn the implementation of a function,  is used to dereference a pointer
p15947
as(dp15948
g7
V505088
p15949
stp15950
a((dp15951
g2
(lp15952
VI use this sort of approach in some of my testing code
p15953
aVI want to test output from one version of a module against a different versions of the same module
p15954
aVBeing able to iterate over different module instances makes the code cleaner
p15955
aVBut this sort of code is the exception to the rule
p15956
aVIt's very infrequently that this approach is the cleanest solution to a problem
p15957
as(dp15958
g7
V505088
p15959
stp15960
a((dp15961
g2
(lp15962
VOn many systems a  is 8 bytes wide and a pointer is 4 bytes wide
p15963
aVThe former, therefore, would not fit into the latter
p15964
aVYou would appear to be abusing
p15965
aVYour solution is going to involve allocating storage space at least as big as the largest type you need to store in some variant-like structure, e
p15966
ag217
ag4706
as(dp15967
g7
V505088
p15968
stp15969
a((dp15970
g2
(lp15971
VCalling  in a calculation thread can't be a good solution to any problem
p15972
aVYou want your threads to be doing useful work rather than blocking for no good reason
p15973
aVI think your basic problem can be expressed as a serial algorithm of this basic form:
p15974
aVYou are in the happy position that calls to  are independent of each other\u2014what you have here is a parallel for
p15975
aVThis means that you can implement this without a mutex
p15976
aVThere are a variety of ways to achieve this
p15977
aVOpenMP would be one; a threadpool class another
p15978
aVIf you are going to roll your own thread based solution then use  on a shared variable to iterate through the array
p15979
aVYou may hit some false sharing problems, as @DeadMG suggests, but quite possibly not
p15980
aVIf you do have false sharing then yet another approach is to stride across larger sub-arrays
p15981
aVEssentially the increment (i
p15982
ag192
aVstride) passed to  would be greater than one
p15983
aVThe bottom line is that the way to make the code faster is to remove both the the critical section (and hence the contention on it) and the
p15984
as(dp15985
g7
V505088
p15986
stp15987
a((dp15988
g2
(lp15989
VThere's not going to be a single answer to that question
p15990
aVIn fact there's not even a single answer on Windows
p15991
aVDifferent executables specify different stack limits
p15992
aVAnd even within a single process, individual threads can have different stack limits
p15993
aVAnd it gets even more complicated when you factor in the differences between
p15994
aVnet and native executables
p15995
aVRather strangely
p15996
aVnet executables commit the entire stack allocation for each thread as soon as the thread starts
p15997
aVOn the other hand, native executables reserve the stack allocation and then commit memory on demand using guard pages
p15998
as(dp15999
g7
V505088
p16000
stp16001
a((dp16002
g2
(lp16003
VDeclare  as  rather than  and then use  to get it into a string variable
p16004
aVI'm ignoring the fact that the string contents are UTF-8
p16005
aVIf your text is pure ASCII that's fine
p16006
aVIf not then you need to copy to a  array and then translate from UTF-8 with
p16007
as(dp16008
g7
V505088
p16009
stp16010
a((dp16011
g2
(lp16012
VThe normal approach is to wrap  in a  statement
p16013
aVHowever, this is inconvenient if you want  to live for the duration of your app since you most likely won't want the  statement wrapping around your app's  method
p16014
aVIn which case you must make sure that you call  on  before the app terminates which is exactly what  does for you behind the scenes
p16015
as(dp16016
g7
V505088
p16017
stp16018
a((dp16019
g2
(lp16020
VIt's well worth trying DelphiSpeedUp from Andreas Hausladen but that will only help IDE performance rather than compilation as I understand it
p16021
aVThe other idea that nobody has suggested yet is to use high spec solid state disks
p16022
aVI recommend using 64 bit Windows 7 with a large amount of RAM for the best file caching performance
p16023
aVJust be thankful your project isn't written in C++
p16024
as(dp16025
g7
V505088
p16026
stp16027
a((dp16028
g2
(lp16029
VI'd imagine that at least one reason why the compiler is blocking this is that  is not a managed type and so you would be bypassing interface reference counting
p16030
aVAnother reason why this would be disallowed is that the invoking mechanism for an interface method is different from the invoking mechanism for
p16031
as(dp16032
g7
V505088
p16033
stp16034
a((dp16035
g2
(lp16036
VYou are falling foul of registry redirection
p16037
aVThe best solution is to open a 64 bit view of the registry, like this:
p16038
aVIf you want your code to work on both 32 and 64 bit machines then you'll need to code some switching between registry views
p16039
aVNote: The capability of accessing 64 bit views from 32 bit processes was only added to the
p16040
aVnet libraries in
p16041
aVnet 4
p16042
aVIt seems that prior to that you needed to use native APIs, e
p16043
ag217
aVwith P/Invoke
p16044
as(dp16045
g7
V505088
p16046
stp16047
a((dp16048
g2
(lp16049
VI think you are going about this the wrong way
p16050
aVYou should simply check for errors on each API call and raise an exception as soon as you encounter one
p16051
aVThat way you get the error message appropriate to the error that produces the exception
p16052
aVYou simply can't expect to carry on  calling other API functions and then raise an exception for an error that happened some time ago
p16053
aVI think you want something along these lines:
p16054
aVNote that you didn't include any error checking for
p16055
aVI've attempted to write it for you
p16056
as(dp16057
g7
V505088
p16058
stp16059
a((dp16060
g2
(lp16061
VIn general you cannot obtain this information
p16062
aVYou should use  to switch behaviour of your script
p16063
as(dp16064
g7
V505088
p16065
stp16066
a((dp16067
g2
(lp16068
VThe COM interface to Excel is a Unicode API
p16069
aVExcel works internally with Unicode strings
p16070
aVJust pass your special character to Excel in a Delphi WideString
p16071
aVYou don't need an Excel formula
p16072
aVIf you are using a Unicode version of Delphi (i
p16073
ag192
aV2009 or later) then you can include the Unicode character in your source code if you make your source code a UTF-8 file
p16074
aVThe IDE will convert your source file to UTF-8 if you start adding non-ANSI characters
p16075
as(dp16076
g7
V505088
p16077
stp16078
a((dp16079
g2
(lp16080
VWhilst you can debug a Delphi service there are a number of hoops that you need to jump through to make it work
p16081
aVI never bother and simply ensure that my services can run either as a service or as a standard app
p16082
aVWhen I want to debug I run as a standard app and so sidestep all the headaches
p16083
aVI've hacked out all the code into a single file for the purpose of this answer, but you'd want to structure it a bit differently
p16084
aVTo use this you need to create a new class, inherited from , and implement  and
p16085
aVis the key
p16086
aVIn my services this creates an object which in turn opens a listening socket ready for clients to communicate over
p16087
aVThe standard app code is pretty basic
p16088
aVIt doesn't even have a mechanism to terminate\u2014it runs inside a  loop
p16089
aVThat doesn't matter for my debugging needs
p16090
as(dp16091
g7
V505088
p16092
stp16093
a((dp16094
g2
(lp16095
VApplications are in control of their own cursors
p16096
aVCalling  cannot from A cannot possibly work
p16097
aVNotice that  has no parameters specifying which application the change is to be made to
p16098
aVThis is because the change is made in the calling application
p16099
aVYou will need to inject code into B to effect the desired change
p16100
as(dp16101
g7
V505088
p16102
stp16103
a((dp16104
g2
(lp16105
VIf you are concerned about all the needless heap allocations caused by  then you could write it this way:
p16106
aVCall it like this:
p16107
as(dp16108
g7
V505088
p16109
stp16110
a((dp16111
g2
(lp16112
VYou just need two  blocks:
p16113
aVThe guideline to follow is that you should use  rather than  for protecting resources
p16114
aVAs you have observed, if you attempt to do it with  then you are forced to write the finalising code twice
p16115
aVOnce you enter the  block, the code in the  section is guaranteed to run, no matter what happens between  and
p16116
aVSo, in the code above, the outer  ensures that  is restored in the face of any exceptions
p16117
aVLikewise the inner  ensures that  is destroyed in case of any exceptions being raised during its lifetime
p16118
aVIf you want to handle an exception then you need a distinct  block
p16119
aVHowever, in most cases you should not attempt to handle exceptions
p16120
aVJust let it propagate up to the main application exception handler which will show a message to the user
p16121
aVIf you handle the exception to low down the call chain then the calling code will not know that the code it called has failed
p16122
as(dp16123
g7
V505088
p16124
stp16125
a((dp16126
g2
(lp16127
VBack of the envelope calculation gives 6 mega pixels
p16128
aVAssuming 32 bit colour this takes you to 24MB
p16129
aVYou aren't going to do any better than your current code
p16130
as(dp16131
g7
V505088
p16132
stp16133
a((dp16134
g2
(lp16135
VAdd the unit in which  is defined to the uses clause of the frame unit
p16136
as(dp16137
g7
V505088
p16138
stp16139
a((dp16140
g2
(lp16141
VI think I can finally see what's wrong with your code
p16142
aVThe issue is that  is 64 bits wide in C#
p16143
aVIn a 32 bit process this is incorrect since those parameters should be 32 bits wide
p16144
aVI would have expected you to have seen a stack imbalance warning when run through the debugger
p16145
aVThe correct declaration is:
p16146
aVYou most definitely don't need to switch to native C++ code to get this to work
p16147
as(dp16148
g7
V505088
p16149
stp16150
a((dp16151
g2
(lp16152
VSend  to put the caret to the end of the edit window
p16153
aVThen send  to append text
p16154
aVThis is much better than reading the entire contents, appending your addition and then setting the entire contents if the edit control contains a large amount of text
p16155
aVThese methods can cross 32/64 bit process boundaries without difficulty
p16156
as(dp16157
g7
V505088
p16158
stp16159
a((dp16160
g2
(lp16161
VI personally have my search path blank and include all units in my
p16162
aVdpr files
p16163
aVThe main advantages of this as I see it:
p16164
aVI know precisely which files are included in my project
p16165
aVView Units (Ctrl+F12), View Forms (Shift+F12) offer all units and forms in the project
p16166
aVI don't really see any significant disadvantages to this approach
p16167
aVYes you have to add files to the
p16168
aVdpr file when you include a new 3rd party component, but in my experience that doesn't happen all that often for it to be a big burden
p16169
as(dp16170
g7
V505088
p16171
stp16172
a((dp16173
g2
(lp16174
VYes it is possible: http://www
p16175
aVcodingthewheel
p16176
aVcom/archives/how-to-inject-a-managed-assembly-dll
p16177
aVSince that link appears to be down, here's a cached version: http://web
p16178
aVarchive
p16179
aVorg/web/20101224064236/http://codingthewheel
p16180
aVcom/archives/how-to-inject-a-managed-assembly-dll
p16181
as(dp16182
g7
V505088
p16183
stp16184
a((dp16185
g2
(lp16186
VStop using  and get rid of the  attributes and your code will work
p16187
aVYour offsets were not correctly aligning the fields
p16188
aVDeclare the function in C# like this:
p16189
aVThe default marshalling will match your C++ declaration (your code is C++ rather than C in fact) but you must make sure that your allocate the  parameter in the C# code before calling the function
p16190
aVNormally you would also pass the length of the array as a parameter so that the C++ code knows how many structs there are
p16191
aVPlease don't try to return the array of structures from the function
p16192
aVUse the  parameter as an in/out parameter
p16193
aVI know of no book with an emphasis on P/Invoke
p16194
aVIt appears to be something of a black art
p16195
as(dp16196
g7
V505088
p16197
stp16198
a((dp16199
g2
(lp16200
VUse  on Vista and up, and the solution from the other question for all other operating systems
p16201
as(dp16202
g7
V505088
p16203
stp16204
a((dp16205
g2
(lp16206
VThis is factually incorrect
p16207
aVEach process has a single working directory
p16208
aVThere is no separate working directory for different drives
p16209
aVFor a historical perspective, have a read of this article by Raymond Chen
p16210
as(dp16211
g7
V505088
p16212
stp16213
a((dp16214
g2
(lp16215
VAn  needs to be closed
p16216
aVNobody else is going to close this one for you, so you need to do so
p16217
as(dp16218
g7
V505088
p16219
stp16220
a((dp16221
g2
(lp16222
VTry something like this:
p16223
aVNaturally you'd need to add in some logic about the extra numbers, but the basic idea should be clear from the above
p16224
as(dp16225
g7
V505088
p16226
stp16227
a((dp16228
g2
(lp16229
VSimple approach is, in essence, as follows:
p16230
aVStart with the Delphi 2007 code
p16231
aVChange  to
p16232
aVChange  to
p16233
aVPossibly change  to
p16234
aVThere may be more nuances to your code
p16235
aVIdeally I'd like to see the original Delphi 2007 version of the code
p16236
aVHaving posted the original code, I think you should can use this routine in XE:
p16237
aVNote that I changed the code to take input as a  string and to use  as the working buffer
p16238
aVThis is not necessary for your ANSI/Unicode needs, but feels more natural to me
p16239
as(dp16240
g7
V505088
p16241
stp16242
a((dp16243
g2
(lp16244
VYou can do this with a macro but only if the type can be determined at compile time
p16245
aVOtherwise you're out of luck
p16246
aVSince you are trying to declare a variable it follows that  must be known at compile time
p16247
as(dp16248
g7
V505088
p16249
stp16250
a((dp16251
g2
(lp16252
VTwo reasons spring to my mind:
p16253
aVArrays that live beyond this stack frame
p16254
aVArrays that are bigger than the stack
p16255
as(dp16256
g7
V505088
p16257
stp16258
a((dp16259
g2
(lp16260
V needs to be declared as  in the code that imports the DLL
p16261
as(dp16262
g7
V505088
p16263
stp16264
a((dp16265
g2
(lp16266
VYou appear to be looking for
p16267
aVI don't think you want to hook all keyboard input
p16268
aVYou simply want an app with a hidden window listening for
p16269
aVI don't think you even need to write it yourself
p16270
aVThere are a lots of utilities that will do it for you and let you associate system-wide hot keys with actions of your specification, e
p16271
ag217
aVAutoHotKey
p16272
as(dp16273
g7
V505088
p16274
stp16275
a((dp16276
g2
(lp16277
VYou can use a profiler to tell you where the time is being spent
p16278
as(dp16279
g7
V505088
p16280
stp16281
a((dp16282
g2
(lp16283
VWhen you call  the following code from  is run:
p16284
aVCalling  on a thread will thus terminate the thread synchronously
p16285
aVMy guess is that the call to  never returns
p16286
aVPerhaps  doesn't check  and exit
p16287
aVPerhaps  is waiting on the main thread and so the wait on the thread deadlocks
p16288
aVIt's pretty hard to do anything other than guess, based on your question, but I'd want to check whether or not your code gets past the  call in the destruction of
p16289
aVEnable Debug DCUs, set a breakpoint one the call to  and see for yourself
p16290
as(dp16291
g7
V505088
p16292
stp16293
a((dp16294
g2
(lp16295
V is compiled, on all systems that I know, to multiple instructions
p16296
aVThus it is not atomic
p16297
aVEven  can be non atomic although you have to work hard to construct a situation where it is not atomic
p16298
aVIn fact C has no concept of threads and so there is nothing that is atomic in C
p16299
aVYou need to rely on implementation specific details of your compiler and tools
p16300
as(dp16301
g7
V505088
p16302
stp16303
a((dp16304
g2
(lp16305
VAs far as I can see a template solution would result in the same compiled object but no repetition in the source
p16306
aVA clear win for templates
p16307
aVI don't understand the point about templates needing more memory
p16308
aVThat sounds like a misthink
p16309
as(dp16310
g7
V505088
p16311
stp16312
a((dp16313
g2
(lp16314
VYou can use  and  from the  module to load a module whose name and/or location is determined at execution time
p16315
aVThe example at the end of the documentation topic explains how:
p16316
as(dp16317
g7
V505088
p16318
stp16319
a((dp16320
g2
(lp16321
VNo, those are the names of some classes registered by the system
p16322
aVA great many Windows applications will be built with classes registered by those applications
p16323
aVIf you wish to find the name of the window class used by a particular window, use
p16324
as(dp16325
g7
V505088
p16326
stp16327
a((dp16328
g2
(lp16329
VYes you can create a message queue on a worker thread
p16330
aVYou will need to run a message pump on that thread
p16331
as(dp16332
g7
V505088
p16333
stp16334
a((dp16335
g2
(lp16336
VWithout  the file would not be closed when it was finished with
p16337
as(dp16338
g7
V505088
p16339
stp16340
a((dp16341
g2
(lp16342
VThis is not going to be a compiler bug
p16343
aVSet a data breakpoint on the field and you'll find the code that is overwriting the field
p16344
as(dp16345
g7
V505088
p16346
stp16347
a((dp16348
g2
(lp16349
VWhilst you can do this by using a hidden window as your taskbar window, there are problems with that approach
p16350
aVFor sure it allows you to have different text in the taskbar from the text in the main window caption bar
p16351
aVHowever, taskbar thumbnail previews, flip 3D etc
p16352
aVon Vista and up will show your hidden window which doesn't look very impressive
p16353
as(dp16354
g7
V505088
p16355
stp16356
a((dp16357
g2
(lp16358
V is a function and does not modify its parameter in-place
p16359
aVYou mean to write:
p16360
as(dp16361
g7
V505088
p16362
stp16363
a((dp16364
g2
(lp16365
V is a thin wrapper around the Windows list view common control
p16366
aVRun it in virtual mode with report view style to achieve what I believe you are asking for
p16367
aVIn order to set up a virtual list view you need to set  to  and supply an  event handler
p16368
aVFor your needs an  may be needed to implement the progressive text search
p16369
as(dp16370
g7
V505088
p16371
stp16372
a((dp16373
g2
(lp16374
VThere is no officially supported API for doing this because the Quick Launch area is owned by the user and applications are expected not to change the order behind the user's back
p16375
aVThe user has a perfectly reasonable mechanism to re-order the buttons and you should leave it to them to do so, should they so wish
p16376
as(dp16377
g7
V505088
p16378
stp16379
a((dp16380
g2
(lp16381
VRecords are value types
p16382
aVThe  loop is returning a copy of each record in the array and so the compiler error is actually telling you that modifying it is futile
p16383
aVYou'll need to use an old fashioned for loop:
p16384
as(dp16385
g7
V505088
p16386
stp16387
a((dp16388
g2
(lp16389
VBecause you are calling  on the current thread, the system is able to create the message queue on demand
p16390
aVIf you were calling  and passing the ID of a thread other than the calling thread, then it would fail if that thread did not have a message queue
p16391
aVFor example, consider the following variant of your code:
p16392
aVBecause we are now attempting to post the message from the main thread, to the worker thread,  comes back as 0 (i
p16393
ag192
aVan error), and  is set to  as described by the documentation for
p16394
aVIf the function fails, the return value is zero
p16395
aVTo get extended error information, call GetLastError
p16396
aVGetLastError returns  if  is not a valid thread identifier, or if the thread specified by  does not have a message queue
p16397
as(dp16398
g7
V505088
p16399
stp16400
a((dp16401
g2
(lp16402
VYou aren't testing whether or not  is  before calling
p16403
aVYou should only call  if the API call failed, as described in the documentation
p16404
aVMy guess is that  actually succeeds and you are getting the error code from the failure of another API call that happened earlier in the execution of your program
p16405
as(dp16406
g7
V505088
p16407
stp16408
a((dp16409
g2
(lp16410
V, for example, gives you the answer to the puzzle
p16411
aVIt returns the thread ID and the documentation states:
p16412
aVIf the function fails, the return value is zero
p16413
aVTherefore, zero can never be a valid thread ID
p16414
as(dp16415
g7
V505088
p16416
stp16417
a((dp16418
g2
(lp16419
VThe threads do in fact all start immediately
p16420
aVYou can write to any data structure from the threads so long as you correctly synchronize access to that structure
p16421
as(dp16422
g7
V505088
p16423
stp16424
a((dp16425
g2
(lp16426
VIf you are linking to standard Windows DLLs then there's no issue because the DLLs are already present on the target systems
p16427
aVFor other DLLs, if you have to distribute the DLL then your total executable code size will be greater than if you had used static linking
p16428
aVYou only end up with smaller executable code size if you have multiple applications that use common libraries
p16429
aVIn other words, although dynamic linking sounds seductive, old fashioned static linking may be better for you
p16430
aVNow, if you are concerned about linking to a C runtime then you could consider using mingw which can link against the Windows C runtime which is present on all systems
p16431
as(dp16432
g7
V505088
p16433
stp16434
a((dp16435
g2
(lp16436
VThere's nothing built in to the common control to achieve this so you'll need to do it yourself
p16437
aVUse a  and each time it fires, change whatever property of the node you need to achieve the blinking effect
p16438
as(dp16439
g7
V505088
p16440
stp16441
a((dp16442
g2
(lp16443
VI'd do it like this:
p16444
aVDelphi
p16445
aVC#
p16446
aVYou need to get the calling conventions to match
p16447
aVI've gone for  which is the default for P/invoke (that's why it's not specified in the P/invoke signature)
p16448
aVI'd avoid returning the array as a function return value
p16449
aVIt's easier to marshall it this way as a parameter
p16450
aVIn fact in general, if you want to get away from fixed size buffers you could do it like this:
p16451
aVDelphi
p16452
aVThen, to fill out the buffer, you'd need to use some pointer arithmetic or something equivalent
p16453
as(dp16454
g7
V505088
p16455
stp16456
a((dp16457
g2
(lp16458
VThese K&R; definitions are the historically traditional way to define functions
p16459
aVIn the original C this was the only way to define a function
p16460
aVDon't use K&R; definitions any more
p16461
aVWhy not
p16462
aVBecause doing so stops the compiler being able to check for type mismatches
p16463
as(dp16464
g7
V505088
p16465
stp16466
a((dp16467
g2
(lp16468
VYou'd need support from the P/invoke marshaller for this to be possible
p16469
aVThe marshaller does not provide such support
p16470
aVThus it cannot be done
p16471
as(dp16472
g7
V505088
p16473
stp16474
a((dp16475
g2
(lp16476
VIt depends on your idea of what is elegant
p16477
aVIf your idea of elegance to being able to write  where  and  are of the generic type, and that would be my idea of elegant, then this cannot be done
p16478
aVSadly, C# generics cannot achieve the elegance of C++ templates for this type of code
p16479
as(dp16480
g7
V505088
p16481
stp16482
a((dp16483
g2
(lp16484
VYou shouldn't let exceptions propagate out of your thread function
p16485
aVTypically you would have a catch all exception handler around the body of your thread function
p16486
aVHow you handle these exceptions is then down to you
p16487
as(dp16488
g7
V505088
p16489
stp16490
a((dp16491
g2
(lp16492
VYou assign  to  and then test the truth of
p16493
aVis truthy whenever it is non-zero
p16494
aVThe loop terminates when  (and hence ) has been decremented to equal 0, which is falsy
p16495
as(dp16496
g7
V505088
p16497
stp16498
a((dp16499
g2
(lp16500
VFrom your app you'd be better to use the per-user store for file associations
p16501
aVIf you use the system wide registry location then you'd need to elevate in order to apply changes
p16502
aVThat's not something you should do in a standard user app
p16503
aVStore the registry settings under:
p16504
aVThe format of entries under there is exactly the same as under
p16505
as(dp16506
g7
V505088
p16507
stp16508
a((dp16509
g2
(lp16510
VMany people would argue that it is better practice to write  rather than
p16511
aVThere are many reasons for this, but the most compelling to me is that I can look at the code and know immediately, without stretching my brain, what type  is
p16512
aVThis allows my brain to concentrate on the harder problems
p16513
aVIn fact  was introduced to declare variables whose types could not easily be named
p16514
aVIt was not introduced as a convenience, although it can be used that way
p16515
as(dp16516
g7
V505088
p16517
stp16518
a((dp16519
g2
(lp16520
VThe problem is in the  parameter
p16521
aVI suspect you are doing something like this:
p16522
aVThis results in an access violation because  is not writeable memory
p16523
aVThe string is a constant string stored in read-only memory
p16524
aVInstead you can do this:
p16525
aVThis is enough to make  be backed by writeable memory
p16526
aVIt is not enough just to make the variable holding the string non-const, you need to make the memory that backs the string writeable too
p16527
aVWhen you assign a string literal to a string variable, the string variable points at read-only memory
p16528
as(dp16529
g7
V505088
p16530
stp16531
a((dp16532
g2
(lp16533
VA simple solution is to create an invisible control in the main thread on which your worker threads can call
p16534
as(dp16535
g7
V505088
p16536
stp16537
a((dp16538
g2
(lp16539
VYou are missing the  calling convention:
p16540
aVThe default calling convention for  is  but I'd bet that the WinPcap library is exported as
p16541
as(dp16542
g7
V505088
p16543
stp16544
a((dp16545
g2
(lp16546
VYou accepted the answer giving a regex for
p16547
aVThe entire string up to the fourth-to-last position before the final dot
p16548
aVIf that's what you want then you do it best without a regex:
p16549
aVThis more efficient than a regex and, much more importantly, it is much clearer and more intelligible
p16550
aVRegexes are not the only fruit
p16551
as(dp16552
g7
V505088
p16553
stp16554
a((dp16555
g2
(lp16556
VIf you are wanting to translate the UI into different languages then you may benefit from having all your text in a single file, or perhaps a number of files dedicated to declaring string constants
p16557
aVHowever, if you do this change without such a strong motivation, then you may just make your code hard to read
p16558
aVGenerally you have to ask what the benefits of such a major refactoring are, and if they are not self-evident, then you may well be changing things just for the sake of change
p16559
as(dp16560
g7
V505088
p16561
stp16562
a((dp16563
g2
(lp16564
VYou need to use the 32 bit version of ODBC
p16565
aVYou can't mix 32 and 64 bit code in the same process
p16566
aVHowever, that may not be your problem
p16567
aVThat error code is, I think,  and there could be all sorts of reasons why you get that, and no necessarily down to 32/64 bit driver issues
p16568
aVFor example, did you define the ODBC connection (DSN) with 32 bit admin tools
p16569
aVFinally, I would recommend that you quote precise error messages rather than using phrases like "rambling about incompatible architectures"
p16570
aVPrecise information will help track down the problem
p16571
as(dp16572
g7
V505088
p16573
stp16574
a((dp16575
g2
(lp16576
VIt's easiest just to use the facility built into Windows
p16577
aVFor example on Windows 7 it looks like this:
p16578
aVThis capability is present in older versions of Windows too but is not exposed in such a simple interface
p16579
aVInstead you have to set it with a PowerToy or through
p16580
aVAs Raymond Chen explains, this is a user preference which should not be changed without the user's consent
p16581
as(dp16582
g7
V505088
p16583
stp16584
a((dp16585
g2
(lp16586
VYou can simply assign to
p16587
aVHowever, in a console application you will need to add references to the WinForms assemblies because console application projects do not include references to WinForms by default
p16588
aVYou will need to add  and , the latter to gain access to the  class
p16589
as(dp16590
g7
V505088
p16591
stp16592
a((dp16593
g2
(lp16594
VThe port numbers are given in network byte order
p16595
aVNetwork byte order is big endian and so you have to reverse the order of the bytes to make sense of it
p16596
aVThe documentation for  contains this important point
p16597
aVThe dwLocalPort, and dwRemotePort members are in network byte order
p16598
aVIn order to use the dwLocalPort or dwRemotePort members, the ntohs or inet_ntoa functions in Windows Sockets or similar functions may be needed
p16599
aVSimply pass the port numbers through  and they will make sense to you again
p16600
aVFor example:
p16601
as(dp16602
g7
V505088
p16603
stp16604
a((dp16605
g2
(lp16606
VOthers have pointed out that a C# DLL cannot be treated the same way as a native DLL
p16607
aVOne option you have is to export your C# functionality as a COM object which can be readily consumed by Python
p16608
aVPersonally I'd consider a native code solution but you may well be too committed to C# to change course at this stage
p16609
as(dp16610
g7
V505088
p16611
stp16612
a((dp16613
g2
(lp16614
VListen for
p16615
as(dp16616
g7
V505088
p16617
stp16618
a((dp16619
g2
(lp16620
VFor a general, non right angle triangle, you need what is known as the Law of Cosines
p16621
aVThis allows you to calculate the internal angles at each corner of the triangle given the lengths of each side
p16622
aVYou can calculate the length of each side using the Pythagorean equality
p16623
aVThe second part of your question is not clearly specified
p16624
as(dp16625
g7
V505088
p16626
stp16627
a((dp16628
g2
(lp16629
VI think  will meet your needs
p16630
aVOnce you have the windowed control under the cursor you can walk the parent chain to find the form on which the window lives
p16631
as(dp16632
g7
V505088
p16633
stp16634
a((dp16635
g2
(lp16636
VCatch the error in the thread, handle it there and then let the thread continue the work
p16637
aVTo handle the error you could simply queue a method to the main thread to report the error, for example
p16638
aVI hope you aren't letting exceptions leave your thread Execute method
p16639
as(dp16640
g7
V505088
p16641
stp16642
a((dp16643
g2
(lp16644
VThis happens when the system can't communicate with the application that owns the notification icon
p16645
aVNormally this is because the process has terminated abnormally
p16646
aVIn your case you state that the process is running the whole time
p16647
aVThus I can only conclude that the window handle associated with the notification icon has been destroyed, or is not responding to messages correctly
p16648
aVThat diagnosis also tallies with your observation that you do not receive
p16649
as(dp16650
g7
V505088
p16651
stp16652
a((dp16653
g2
(lp16654
VYou are very nearly there
p16655
aVThe problem is this part of your P/invoke for :
p16656
aVThe default marshalling for  is for the array contents to marshalled in both directions, from managed to unmanaged, and then back again when the function returns
p16657
aVThe C definition of  is annotated with  but that means that the array contents are  rather than the pointer being
p16658
aVChange your P/invoke to
p16659
aVand similarly in the call to  change  to  and you should be good to go
p16660
aVBe warned that your code as it stands will return an status code of  so don't be tricked into thinking that this non-zero return value indicates failure
p16661
aVOne final point, the first parameter to both P/invokes, , should be declared as
p16662
as(dp16663
g7
V505088
p16664
stp16665
a((dp16666
g2
(lp16667
VThere may well be a managed way to do this, but I would probably just P/invoke to
p16668
aVIf you use this function, rather than rolling your own comparison function, you'll get the same behaviour as Explorer and other system components that use logical comparison
p16669
aVNote, however, that this will not work in environments where WinAPI is inaccessible (such as Windows Phone, Mono or Silverlight), might work differently on different systems and should be decorated with a comment so the future maintainer of your code knows why P/Invoke is used for sorting
p16670
as(dp16671
g7
V505088
p16672
stp16673
a((dp16674
g2
(lp16675
VVBA functions that are called from cell formulae are not allowed to modify cell contents
p16676
aVThis restriction is in place so that Excel can keep track of dependencies
p16677
aVIf you need to modify cell contents then you'll have to invoke your VBA through some other mechanism, e
p16678
ag217
aVa user form
p16679
as(dp16680
g7
V505088
p16681
stp16682
a((dp16683
g2
(lp16684
VYou are clearly not doing what you say you are doing:
p16685
aVUse  on strings and you get concatenation
p16686
aVUse  on integers and you get addition
p16687
aVIf you are getting concatenation then you must be operating on strings rather than integers
p16688
as(dp16689
g7
V505088
p16690
stp16691
a((dp16692
g2
(lp16693
VIt's unsigned so map it to
p16694
as(dp16695
g7
V505088
p16696
stp16697
a((dp16698
g2
(lp16699
VThat's not
p16700
aVAs part of the Windows GUI it's clearly not a Delphi component
p16701
aVWhat's more it is quite different in functionality
p16702
aVWhat you have highlighted is a page control with the tabs at the bottom
p16703
aVIn Delphi terms it is
p16704
as(dp16705
g7
V505088
p16706
stp16707
a((dp16708
g2
(lp16709
VI have attempted this in the past and concluded that it was effectively impossible to achieve successful Office automation from a service
p16710
as(dp16711
g7
V505088
p16712
stp16713
a((dp16714
g2
(lp16715
VYou are using  to do the file copy
p16716
aVIf you want it to be silent then include
p16717
aVin
p16718
as(dp16719
g7
V505088
p16720
stp16721
a((dp16722
g2
(lp16723
VStandard users (and that includes administrators when UAC is active) do not have delete rights to that location
p16724
aVYou need to find a different location to store the file if you need standard users to be able to delete it
p16725
as(dp16726
g7
V505088
p16727
stp16728
a((dp16729
g2
(lp16730
VYou appear to want to write some C code that will compile to executable code of size that is independent of target platform
p16731
aVThat is quite simply an unrealistic goal
p16732
as(dp16733
g7
V505088
p16734
stp16735
a((dp16736
g2
(lp16737
VYou are asking for more precision than your C floating point variables can provide
p16738
aVYou need to use arbitrary precision arithmetic rather than fixed precision floating point
p16739
aVOr at the very least use fixed precision arithmetic with a precision value greater than your desired calculation precision
p16740
aVThe Python code sets the precision to 100 to achieve this
p16741
aVWell, @yi_H also found a bug in your code but even when you fix that you won't get the same precision from your C code as from your Python code for the reasons above
p16742
as(dp16743
g7
V505088
p16744
stp16745
a((dp16746
g2
(lp16747
VBy far the simplest way to do this is to pass your  to the C# code and use
p16748
as(dp16749
g7
V505088
p16750
stp16751
a((dp16752
g2
(lp16753
V is a special value that is guaranteed to be an invalid pointer
p16754
aVAny other value could be valid
p16755
as(dp16756
g7
V505088
p16757
stp16758
a((dp16759
g2
(lp16760
VYour options as I see them:
p16761
aVCompile the DLL with the /MT option to use static linking to the C runtime
p16762
aVContinue with dynamic linking to the runtime, but distribute the C runtime with your app
p16763
as(dp16764
g7
V505088
p16765
stp16766
a((dp16767
g2
(lp16768
VI'd extract the node creation into a function of this sort of form:
p16769
aVFor convenience you would probably want to pass in the other fields in the struct and get this routine to fill out the new node with those values
p16770
aVBut this routine gives you the idea of how to do the allocation and next pointer code
p16771
as(dp16772
g7
V505088
p16773
stp16774
a((dp16775
g2
(lp16776
VThis happens when you pass the  flag to
p16777
aVSolve the problem by removing this flag
p16778
as(dp16779
g7
V505088
p16780
stp16781
a((dp16782
g2
(lp16783
VYou can't mix 32 bit code and 64 bit code in the same process
p16784
aVYou'll need to use two processes by one means or another, or find a way to use all 32 bit or all 64 bit
p16785
aVThe express versions of Visual Studio do not support 64 bit targets
p16786
aVIf you purchase the standard version then you may be able to recompile the plug-in in 64 bit mode
p16787
aVNote however, that it may not be that simple because you may need to modify the code in case it contains assumptions about bitness
p16788
aVA possibly easier option would be to use the 32 bit version of 3ds
p16789
as(dp16790
g7
V505088
p16791
stp16792
a((dp16793
g2
(lp16794
V is called from the default
p16795
aVBut since you have overridden , the onus is on you to call  from inside your
p16796
as(dp16797
g7
V505088
p16798
stp16799
a((dp16800
g2
(lp16801
VWe have worked out from the comments above that the issue is related to the Virtual Store which is used when your application is virtualized
p16802
aVThe virtual store was introduced with Windows Vista as part of the move to running applications without administrator rights
p16803
aVThese files are appearing in the virtual store because your application is writing to the program files directory, to which standard users do not have write privileges
p16804
aVVirtualization was introduced to help deal with legacy applications that were not going to be recompiled to take account of the new Vista policies
p16805
aVNowadays you simply should not be building a virtualized application
p16806
aVYou can disable virtualization by linking an application manifest to your application that includes the  section
p16807
aVWhen you do this, you will no doubt find some other problems because your application may attempt to write to the program files directory, the HKLM section of the registry, etc
p16808
aVWhilst it may seem painful to make these changes, they are worth the effort
p16809
as(dp16810
g7
V505088
p16811
stp16812
a((dp16813
g2
(lp16814
VThe compiler is clearly using an implicit local interface variable for the return value from
p16815
aVThis is then released at the end of the routine, too late for you
p16816
aVThere are a couple of ways to defeat this
p16817
aVFirst of all you could be explicit about the  interface reference returned by
p16818
aVThis allows you to control its lifetime
p16819
aVAn alternative would be to move the code that called  into a separate routine with its own scope
p16820
aVSince the implicit local reference is within the scope of  it is released at the end of  and therefore before you run
p16821
aVMy recommendation is to use the second option which is cleaner and forces the compiler to do the work on your behalf
p16822
as(dp16823
g7
V505088
p16824
stp16825
a((dp16826
g2
(lp16827
VYour declaration of  is incorrect
p16828
aVIt does not have the  member
p16829
aVThat's the cause of the error
p16830
aVAlso, there's no , instead you should have
p16831
as(dp16832
g7
V505088
p16833
stp16834
a((dp16835
g2
(lp16836
VWhilst Robocopy can be persuaded to copy a single file it is much simpler to use copy or xcopy
p16837
as(dp16838
g7
V505088
p16839
stp16840
a((dp16841
g2
(lp16842
VI suspect that best solution is to let the users of the component do whatever they want with manifests for their applications
p16843
aVTo do otherwise would place a serious constraint on any users of this component
p16844
aVInstead use the activation context API to activate the manifests that your component needs, as and when it needs
p16845
aVYour current idea to write manifest files in the executable directory sounds extremely brittle and liable to fail whenever that directory cannot be written to
p16846
aVOn the other hand the activation context API does exactly what you really need with none of the drawbacks
p16847
as(dp16848
g7
V505088
p16849
stp16850
a((dp16851
g2
(lp16852
VYou should assign the button's  property and control everything via the action
p16853
aVSet the action to be disabled, invisible etc
p16854
aVand the button follows suit
p16855
aVDon't set the OnClick event handler of the button, instead use the corresponding event of the action
p16856
aVUse the action's OnUpdate event to set properties like Visible, Enabled etc
p16857
aV, basically everything that changes at runtime
p16858
as(dp16859
g7
V505088
p16860
stp16861
a((dp16862
g2
(lp16863
VIf you want to continue using P/invoke as you indicate in comments, then your only option is to catch the exceptions at the DLL boundary
p16864
aVYou can then pass the details on to the managed application using error codes rather than exceptions
p16865
aVIf you want to use P/invoke then you can't allow exceptions to cross the DLL boundary
p16866
as(dp16867
g7
V505088
p16868
stp16869
a((dp16870
g2
(lp16871
VYou haven't given any details so we need to guess at the exact cause of the problem
p16872
aVI'm going to assume that you are using C# on Windows
p16873
aVI'd guess that you are trying to perform user interface code from a worker thread which is an error
p16874
aVUser interface code should run in the main thread
p16875
aVWhilst this could be solved with  a much better approach is to avoid any threads, use a timer for your 5 second wait and perform the UI update in the main thread
p16876
as(dp16877
g7
V505088
p16878
stp16879
a((dp16880
g2
(lp16881
VYou need to delete the following registry key:
p16882
aVOn a 64 bit system delete this key also:
p16883
as(dp16884
g7
V505088
p16885
stp16886
a((dp16887
g2
(lp16888
VIf the form is shown modally then you just need to test the value of
p16889
aVA value of mrCancel indicates that the cross was clicked
p16890
aVI would be inclined to arrange that your buttons used their  properties to effect closing of the form
p16891
aVSet the OK button's  to  and that for the cancel button to
p16892
as(dp16893
g7
V505088
p16894
stp16895
a((dp16896
g2
(lp16897
VThat is a destructor
p16898
as(dp16899
g7
V505088
p16900
stp16901
a((dp16902
g2
(lp16903
VThe error message indicates that  is returning  for some reason
p16904
as(dp16905
g7
V505088
p16906
stp16907
a((dp16908
g2
(lp16909
VThe simple answer is that you should not create this thread suspended since you want it to start immediately
p16910
aVRemove the call to  and pass  to the inherited constructor
p16911
aVNote that the thread isn't started until all constructors have run to completion so the meaning is identical to your posted code
p16912
aVAs to why your code fails, look at the following excerpts from the source:
p16913
aVYour code calls the inherited constructor with
p16914
aVThis sets  to be
p16915
aVYou then call  before  runs
p16916
aVThis succeeds in starting the thread, but, crucially it resets  to
p16917
aVThen when  it tries to resume the thread which fails because it is already running
p16918
aVI think the Delphi code is fine because it is incorrect to call  from the constructor
p16919
aVYou need to be sure that all constructors have run and derived class constructors run after your call to
p16920
aVYou don't have any derived classes yet but that's not the point\u2014the point is that calling  from a constructor is not supported
p16921
aVThe bottom line is that you should create this thread not suspended and let  be called, on your behalf, from
p16922
as(dp16923
g7
V505088
p16924
stp16925
a((dp16926
g2
(lp16927
VI guess your problem is that the 32 bit application can't see the 64 bit system32 directory
p16928
aVYou can use  instead if you have to specify a full path
p16929
aVAlternatively you should just be able to name the program without its path, i
p16930
ag192
aVrather han
p16931
as(dp16932
g7
V505088
p16933
stp16934
a((dp16935
g2
(lp16936
VI don't know C# either, so this is probably seriously non-idiomatic
p16937
aVI have assumed that your ANSI strings are encoded with Windows 1252, but it you happen to have encoded your legacy data with a different code page it is obvious enough how to change it
p16938
aVSince C# doesn't have the equivalent of Delphi's 8 bit string types, I personally would be sorely tempted to use  rather than
p16939
aVDone that way it looks like this:
p16940
aV@Groo makes the excellent point that the hash can be initialised more cleanly list this:
p16941
as(dp16942
g7
V505088
p16943
stp16944
a((dp16945
g2
(lp16946
VDon't do this
p16947
aVModal dialogs should be closed by user intervention
p16948
aVDeviating from this pattern is just confusing and non-standard
p16949
aVIf you want a message windows that closes itself, then use a balloon window
p16950
as(dp16951
g7
V505088
p16952
stp16953
a((dp16954
g2
(lp16955
VWhat has happened here, with >99% probability is that you have written the stream from a string variable
p16956
aVUnicode strings with UTF-16 encoding have two bytes per character whereas older versions of Delphi using ANSI encodings with one byte per character
p16957
aVEnglish text, when encoded with UTF-16 have the pattern you observe of every second  byte being zero
p16958
aVIn order to solve this you will need to investigate the section of code that writes to the stream
p16959
as(dp16960
g7
V505088
p16961
stp16962
a((dp16963
g2
(lp16964
VTo run a console app and hide the console window, call  passing  in the creation flags parameter
p16965
as(dp16966
g7
V505088
p16967
stp16968
a((dp16969
g2
(lp16970
VYou have to allocate sufficient space in  before calling
p16971
aVAnd then when that call returns you need to deallocate it, although  will do that for you
p16972
aVIf you have obtained  by calling  with  as  then you have nothing special to do
p16973
aVYou create an instance of  and sufficient buffer is created for you
p16974
as(dp16975
g7
V505088
p16976
stp16977
a((dp16978
g2
(lp16979
VYou are justified in doubting this
p16980
aVYou should only stream POD types with  and  and  is not
p16981
as(dp16982
g7
V505088
p16983
stp16984
a((dp16985
g2
(lp16986
VYou do need to exercise some care
p16987
aVis true because integers are exactly representable
p16988
aVif b == c
p16989
aVif b == 10
p16990
aV0 which is what I think you meant
p16991
aVThe last two examples compare two different instances of the same calculation
p16992
aVWhen you have different calculations with non representable numbers then exact equality testing fails
p16993
aVIf you are testing the results of a calculation that is subject to floating point approximation then equality testing should be done up to a tolerance
p16994
aVDo you have any specific real world examples
p16995
aVI think you will find that it is rare to want to test equality with floating point
p16996
as(dp16997
g7
V505088
p16998
stp16999
a((dp17000
g2
(lp17001
VWhilst you can implement multi-cast events yourself, they are not directly supported in the the language unlike in C# and VB
p17002
aVNET
p17003
aVLack of language support makes any attempt to emulate multi-cast events rather clumsy
p17004
aVInterestingly, C++ lacks support for signals and slots and the Qt solution involves an extra process in the compilation tool chain, the Meta Object Compiler
p17005
as(dp17006
g7
V505088
p17007
stp17008
a((dp17009
g2
(lp17010
VHandle the  event of the popup menu like this:
p17011
aVDon't try and use the mouse cursor in your logic because the popup menu may be invoked from the keyboard
p17012
aVIt turns out that you want to disable certain items on the menu dependent on the selection
p17013
aVYou should use actions for this and then you can centralise control of UI properties
p17014
aVAn action can be linked to a button, a popup menu item, a main menu item and so on
p17015
aVYou don't want to write code that enables and disables all of these separately\u2014actions solve this problem
p17016
aVUse the  event for this
p17017
aVOr sometimes you want the same  for many actions which you would code list this:
p17018
as(dp17019
g7
V505088
p17020
stp17021
a((dp17022
g2
(lp17023
VUse  with  rather than :
p17024
as(dp17025
g7
V505088
p17026
stp17027
a((dp17028
g2
(lp17029
VYou appear to be referring to the 2gb limit on virtual memory in 32 bit Windows
p17030
aVYou can't get around this limit on a 32 bit system
p17031
as(dp17032
g7
V505088
p17033
stp17034
a((dp17035
g2
(lp17036
VCompatibility settings are not inherited
p17037
aVThey are associated with individual executable files
p17038
as(dp17039
g7
V505088
p17040
stp17041
a((dp17042
g2
(lp17043
VYou should return an  from each COM method and return the data in  parameters
p17044
aVHowever, the COM interop layer shields this from you by automatically translating between COM  error codes and C# exceptions
p17045
aVI think your code should really look like this:
p17046
aVMIDL
p17047
aVC#
p17048
aVThe key point is that the COM function return value is always an
p17049
aVIf the function succeeds then  is returned\u2014otherwise you an appropriate error code that describes the reason for failure is returned
p17050
aVThe true return value,  in this example, is returned through an out parameter rather than the return value
p17051
aVBut of course, the COM interop layer hides that implementation detail from you
p17052
aVYour question appears to suggest that you wish for the return value to be either an  in case of failure, or a string in case of success
p17053
aVThis is not possible since function return values are statically typed
p17054
as(dp17055
g7
V505088
p17056
stp17057
a((dp17058
g2
(lp17059
VThe trick is to run the loop in reverse order:
p17060
aVThis way, the act of deleting an item only changes the indices of elements later in the list, and those elements have already been processed
p17061
as(dp17062
g7
V505088
p17063
stp17064
a((dp17065
g2
(lp17066
VIt's perfectly reasonable for the DLL to access memory that resides on the calling applications heap
p17067
aVIf you couldn't do that then DLLs would be essentially useless
p17068
aVYour problem must lie elsewhere
p17069
aVMost likely your aren't quite setting up the parameters for the call to the DLL correctly
p17070
as(dp17071
g7
V505088
p17072
stp17073
a((dp17074
g2
(lp17075
VI would use
p17076
aVSince this is typesafe due to the use of generics, it will correctly handle the lifetime issues of its members
p17077
as(dp17078
g7
V505088
p17079
stp17080
a((dp17081
g2
(lp17082
VFurther to the error that SLaks identified, your remaining problem is that the size of  is incorrect
p17083
aVThis means that  fails since it receives a parameter of type
p17084
aVYou can't specify the size with  since you want code that handles both x86 and x64
p17085
aVThis all stems from the fact that you have only included the the  struct in
p17086
aVThe  struct is larger than  which is the cause of your problem
p17087
aVThe best solution is to define the INPUT structure correctly, including the union part
p17088
aVDo this like so (declarations taken from pinvoke
p17089
aVnet)
p17090
as(dp17091
g7
V505088
p17092
stp17093
a((dp17094
g2
(lp17095
VFrom the comments to your question it is clear that you are not linking to the package correctly at runtime and  is being linked statically to your executable rather than being linked dynamically from the package
p17096
aVYou can solve this one of two ways:
p17097
aVFix the linking problems so that you do indeed link to the package at runtime
p17098
aVThis is configured in Project | Options | Packages in the Delphi IDE
p17099
aVIf you want to link statically then you need to link the
p17100
aVres file to your executable too
p17101
aV@TOndrej's answer gives a neat way to arrange that
p17102
as(dp17103
g7
V505088
p17104
stp17105
a((dp17106
g2
(lp17107
VAs an addition to the answers of iamjoosy and Rob Kennedy, I would code this like so:
p17108
aVIt is clearer, in my view, to call  just once
p17109
aVYou do not need to assign  in the constructor since that happens automatically
p17110
aVAll fields are zero-initialised when an object is instantiated
p17111
aVThat said,  should not raise an error
p17112
aVIf it does it is probably a result of a memory corruption due to the out-of-bounds array accessing
p17113
aVA further point to make is that enabling range checking would have resulted in an informative error that would have explained the problem
p17114
aVThis is much more helpful than relying on access violations
p17115
aVI can't recommend range checking highly enough
p17116
aVFinally, the  pattern typically leads to very inefficient memory usage and can lead to performance problems for large lists
p17117
aVIf you have Delphi 2009+, I would recommend using  instead
p17118
as(dp17119
g7
V505088
p17120
stp17121
a((dp17122
g2
(lp17123
VYou would appear to have a compiler bug, or perhaps a language extension, since this is not valid C
p17124
aVYou need an lvalue in order to apply the  operator, and  is not an lvalue
p17125
as(dp17126
g7
V505088
p17127
stp17128
a((dp17129
g2
(lp17130
VThe problem is actually at  and isn't related to the type of
p17131
aV[Aside: I agree that  should not be  but I think that is not your current problem
p17132
aVSince  is defined to be , the code should in fact read
p17133
aVrather than
p17134
aVThe latter code fails because IDC_ARROW is  but  expects
p17135
aVThat explains the error message you see
p17136
aVIn fact  is already a resource type and needs no further processing
p17137
aVLikewise, all the other calls to  are in error
p17138
as(dp17139
g7
V505088
p17140
stp17141
a((dp17142
g2
(lp17143
VThat's not possible in general because parameters are typically passed in registers
p17144
aVwhich are overwritten each time a procedure call is made
p17145
as(dp17146
g7
V505088
p17147
stp17148
a((dp17149
g2
(lp17150
VStrings are immutable so this line is wrong:
p17151
aVThis returns the string after the replacement has been made, but  is unchanged
p17152
aVYou need this:
p17153
as(dp17154
g7
V505088
p17155
stp17156
a((dp17157
g2
(lp17158
VI suppose the only thing you can really do without using comments is to add method resolution clauses:
p17159
aVI don't think this really adds very much to the mix, and I personally would consider this worse than without the method resolution clauses
p17160
as(dp17161
g7
V505088
p17162
stp17163
a((dp17164
g2
(lp17165
VYou should signal to the thread that you wish it to stop work, and then wait for it to do so
p17166
aVFor example, you could set a boolean flag that the thread tests regularly
p17167
aVIf that flag indicates that work has been cancelled, then the thread should return from the thread function
p17168
aVDon't attempt to forcibly terminate the thread from the outside because this will leave synchronisation objects in indeterminate state, lead to deadlocks etc
p17169
as(dp17170
g7
V505088
p17171
stp17172
a((dp17173
g2
(lp17174
VBy default, Visual Studio includes the most commonly used Win32
p17175
aVlib files, e
p17176
ag217
aVkernel32
p17177
aVlib, user32
p17178
aVlib, advapi32
p17179
aVlib etc
p17180
aVFor more esoteric libraries, you need to add the
p17181
aVlib files yourself
p17182
as(dp17183
g7
V505088
p17184
stp17185
a((dp17186
g2
(lp17187
VIt seems to me that you are looking for all selected nodes which have a parent node
p17188
aVThe easiest way to do that is as follows:
p17189
aVThis routine will give you nodes at levels 2, 3, 4 etc
p17190
aVSince you only have level 0 and level 1 this is fine
p17191
aVIf you really did need the nodes that are direct descendants of top-level nodes then you can modify the test like this:
p17192
as(dp17193
g7
V505088
p17194
stp17195
a((dp17196
g2
(lp17197
VThe best you can do is to make your window "always on top"
p17198
aVYou can't reserve part of the desktop exclusively for your application
p17199
as(dp17200
g7
V505088
p17201
stp17202
a((dp17203
g2
(lp17204
VI think you will find it hard to use  to link to the right runtime
p17205
aVThis is because your executable will be missing the necessary manifest to make the WinSxS magic work
p17206
aVI would declare some delegates for the functions you need to import
p17207
aVUse  to obtain the function pointers
p17208
aVYou convert the function pointers into delegates with
p17209
aVIn order to get the module handle to pass to  you can use  since you know that this is loaded into your process
p17210
aVGet hold of  and  with P/invoke
p17211
aVIt seems calling  will not work
p17212
aVCalling  with the full path would work, but that's not really a tenable solution
p17213
aVInstead it is easy enough to enumerate the loaded modules like this:
p17214
as(dp17215
g7
V505088
p17216
stp17217
a((dp17218
g2
(lp17219
VThere is nothing wrong with passing a literal to
p17220
as(dp17221
g7
V505088
p17222
stp17223
a((dp17224
g2
(lp17225
VAll Windows GUI apps have to run a message pump based on , ,
p17226
aVFrameworks typically shield you from the implementation details, but somewhere in the framework will be a message pump
p17227
aVThe same is true for window procedures
p17228
aVAlthough you may never have to write one or interact with one, the framework will have to provide window procedures for top-level windows, and possibly for child windows depending on how the framework is implemented
p17229
as(dp17230
g7
V505088
p17231
stp17232
a((dp17233
g2
(lp17234
VThis happens when the
p17235
aVpas file that the editor has loaded is not the one used to generate the
p17236
aVdcu used by the debugger
p17237
aVDelete all your
p17238
aVdcu files and rebuild
p17239
as(dp17240
g7
V505088
p17241
stp17242
a((dp17243
g2
(lp17244
VHow can I do the same thing without using double-pointer to the struct
p17245
aVYou have to use the double pointer
p17246
aVCan you explain me why and how this works (both with pointer and double-pointer)
p17247
aVThe double-pointer is necessary
p17248
aVYour data structure is a pointer to a structure
p17249
aVYou then call a function that needs to modify that pointer
p17250
aVSince parameters are passed by value you have to pass a pointer to the pointer
p17251
aVI don't understand how a struct is represented in main memory
p17252
aVTypically structs are laid out sequentially
p17253
aVSo the first member will be placed at the beginning of the memory reserved for the struct, the second member will follow it and so on
p17254
aVThere are issues of padding and alignment as well, but that's a bit more complex and is something best left to the compiler
p17255
as(dp17256
g7
V505088
p17257
stp17258
a((dp17259
g2
(lp17260
VI personally prefer using  mostly because I shun unsafe code
p17261
aVAs to which is faster, I'm not sure but I am certain that operating pixel by pixel is liable to be slow however you do it
p17262
aVMuch better is to read an entire scanline into a C# array and work on that
p17263
as(dp17264
g7
V505088
p17265
stp17266
a((dp17267
g2
(lp17268
VYou have to do something like this:
p17269
aVAlthough when you read that, it does sound as though there are some design flaws in your code
p17270
aVIn the comments you make it clear that you want to implement the interface, but not implement a method named
p17271
aVThat's not possible
p17272
aVIn order to implement an interface, you need to implement all the methods
p17273
aVMy guess is that your choice of name for  is too constraining
p17274
aVYou are probably objecting to having to implement it with a method name
p17275
aVHow can a credit be a debit
p17276
aVI guess you'll need to generalise the underlying interface to remove this impedance
p17277
as(dp17278
g7
V505088
p17279
stp17280
a((dp17281
g2
(lp17282
VThere is nothing fundamentally wrong with your  function
p17283
aVThe case where  needs no special treatment
p17284
aVAs others have noticed, your error checking is not correct because you need to return from the function in case  fails
p17285
aVAs it stands your  function carries on an attempts to assign to  when  is
p17286
aVThe code you showed with such special treatment is bogus
p17287
aVThe  clause in that code works perfectly well when
p17288
as(dp17289
g7
V505088
p17290
stp17291
a((dp17292
g2
(lp17293
VYou are building it with the AnyCPU target
p17294
aVIf you want it to be x86 even on a 64 bit system, then you must target x86
p17295
aVWhen you target AnyCPU, the loader runs the process as a 64 bit process on a 64 bit system, but a 32 bit process on a 32 bit system
p17296
as(dp17297
g7
V505088
p17298
stp17299
a((dp17300
g2
(lp17301
VArrange that the  button  does the call to
p17302
aVOnly if the user is sure do you then go on to close the dialog
p17303
aVYour current approach of asking the question after the dialog has closed is incorrect
p17304
aVYou can effect the change by making sure that  is set in code rather than by the No button's  property
p17305
aVThen in the click handler for the button you run the message box
p17306
aVIf the user confirms the action, then set the forms  to
p17307
as(dp17308
g7
V505088
p17309
stp17310
a((dp17311
g2
(lp17312
VGenerally the key distinction is whether or not you want to deliver a
p17313
aVmsi Windows Installer package or not
p17314
aVCorporates prefer that because it makes large scale deployment easier for them
p17315
aVBut
p17316
aVmsi packages are harder to create and have a steep learning curve
p17317
as(dp17318
g7
V505088
p17319
stp17320
a((dp17321
g2
(lp17322
VAs I understand your question, you want to extract the Id from the formatted text that you put into the list box
p17323
aVIf I'm correct, you can do it like this:
p17324
aVThis code relies on an assumption that your Id strings do not contain  or
p17325
aVYou can use it in your code like this:
p17326
as(dp17327
g7
V505088
p17328
stp17329
a((dp17330
g2
(lp17331
VYes it is possible
p17332
aVYou can do it with logical operators
p17333
aVAfter all, that's all that the hardware does when you use an arithmetic operator
p17334
as(dp17335
g7
V505088
p17336
stp17337
a((dp17338
g2
(lp17339
VThe base 64 character set is
p17340
aVSo you can't use 0 since it is already in use
p17341
as(dp17342
g7
V505088
p17343
stp17344
a((dp17345
g2
(lp17346
VYou can't do this because the Microsoft compiler targets a different architecture from the architectures that iOS runs on
p17347
aVAnd that's just for starters
p17348
aVThere are no doubt a gazillion other reasons that it won't work, but the architecture is the most obvious block
p17349
as(dp17350
g7
V505088
p17351
stp17352
a((dp17353
g2
(lp17354
VThis version, using the Windows API function , handles the memory allocation for arbitrarily long input strings
p17355
as(dp17356
g7
V505088
p17357
stp17358
a((dp17359
g2
(lp17360
VThe naive double for loop is pretty close to optimal for portable code, so long as you get your two for loops in the right order
p17361
aVYou need to be accessing the memory sequentially to get best performance
p17362
aVYou could unroll the loops but this won't make very much difference to performance
p17363
aVIf you want best performance then don't write it yourself and instead use a BLAS that has been optimised for your platform
p17364
as(dp17365
g7
V505088
p17366
stp17367
a((dp17368
g2
(lp17369
VCall  passing  as the verb and  as the filename
p17370
as(dp17371
g7
V505088
p17372
stp17373
a((dp17374
g2
(lp17375
VIn order to answer this definitively we would need to know what your DLL contains
p17376
aVBut supposing that it contains a  class with a  method, you can run your program by calling
p17377
as(dp17378
g7
V505088
p17379
stp17380
a((dp17381
g2
(lp17382
VThe  property on  isn't the way to go here
p17383
aVYou really should use image lists instead
p17384
aVThis will allow you to share images between your UI elements in a manageable fashion
p17385
aVAdd the icon to a
p17386
aVSet the  property on the menu (i
p17387
ag192
aV) to refer to the image list
p17388
aVSet the image index of the menu item to the index of the icon in the list, i
p17389
ag192
aV0 if it's the first image
p17390
aVOf course, you really ought to be using actions too, in which case you simply need to set the  for the action and the framework takes care of assigning it to the menu item
p17391
aVAs an aside, I would note that the Delphi implementation of Vista themed menus has a large number of subtle bugs, many related to drawing of images
p17392
aVHowever, these bugs are relatively minor in visual impact
p17393
as(dp17394
g7
V505088
p17395
stp17396
a((dp17397
g2
(lp17398
VAdd a method to your form class that returns all the values that you wish to make available
p17399
aVFor example, put all the values that you wish to return to the other class into a struct, and return that struct
p17400
as(dp17401
g7
V505088
p17402
stp17403
a((dp17404
g2
(lp17405
VMy guess is that your virus scanner is getting in the way
p17406
aVTry to disable real time scanning and if that helps
p17407
as(dp17408
g7
V505088
p17409
stp17410
a((dp17411
g2
(lp17412
VYou have already hit upon the idiomatic way to do it
p17413
as(dp17414
g7
V505088
p17415
stp17416
a((dp17417
g2
(lp17418
VYour best bet will be to use an optimised BLAS which will take advantage of whatever is available on your target platform
p17419
as(dp17420
g7
V505088
p17421
stp17422
a((dp17423
g2
(lp17424
V is available on Windows and Unix
p17425
aVMax OSX counts as Unix so you can use  on Mac OSX
p17426
aVFrom the documentation that you linked to:
p17427
aVIf not separately noted, all functions that claim \u201cAvailability: Unix\u201d are supported on Mac OS X, which builds on a Unix core
p17428
as(dp17429
g7
V505088
p17430
stp17431
a((dp17432
g2
(lp17433
VHere's what is happening
p17434
aVYour code is returning  from
p17435
aVCalling  results in error code 6, The handle is invalid
p17436
aVThe only handles you are passing to  are the thread handles, ergo one of the thread handles is invalid
p17437
aVThe only way one of the thread handles could become invalid is if it has been closed
p17438
aVAs others have indicated, you are closing the handles by setting
p17439
aVThe moral of the story is to check your return values correctly from all functions, and let  lead you to the root cause of the problem
p17440
as(dp17441
g7
V505088
p17442
stp17443
a((dp17444
g2
(lp17445
VAssuming you are writing to an ASCII or ANSI file then I would code it as follows:
p17446
aVNotes:
p17447
aVThe  assertion is to justify the assumption, in the following line, that  has single byte character elements
p17448
aVThe definition of  use  explicitly
p17449
aVIf your Delphi is pre-Unicode then this line will not compile and you can remove it
p17450
aVis the correct way to write a new line to an ASCII/ANSI file
p17451
aVOn Windows it is defined to be , i
p17452
ag192
aVa CR+LF pair
p17453
aVOn Unix based platforms it is defined to be , i
p17454
ag192
aVa single LF
p17455
aVUse  to express logically what you are doing and let the compiler deal with the implementation
p17456
aVThe call to  is not needed since  moves the file pointer to the end of the buffer that  writes
p17457
as(dp17458
g7
V505088
p17459
stp17460
a((dp17461
g2
(lp17462
VYou should use the  function
p17463
aVPass in a  in dialog units, and the equivalent  in pixel units is returned
p17464
aVNote that you need a handle to a dialog in order to give  sufficient context
p17465
aVThe function needs to know the font in order to perform the conversion
p17466
aVIn case you are tempted to use , remember what Raymond Chen said, GetDialogBaseUnits is a crock
p17467
aVAs you can guess from the title of this entry, GetDialogBaseUnits is a
p17468
aVcrock
p17469
aVSince there is no HWND parameter to GetDialogBaseUnits, it
p17470
aVdoesn't know which dialog box's DLUs you want to retrieve
p17471
aVSo it
p17472
aVguesses
p17473
aVAnd it always guesses wrong
p17474
aVGetDialogBaseUnits returns the dialog base units for dialog boxes that
p17475
aVuse the default system font
p17476
aVBut nobody uses the default system font
p17477
aVany more
p17478
aVIt screams "old and dorky"
p17479
aVBut it remains the default for
p17480
aVcompatibility reasons
p17481
aV(And therefore so too does GetDialogBaseUnits
p17482
aVIf you have to calculate pixel dimensions from DLUs, and you don't have a handle to a dialog, then you must use the method outlined here: How To Calculate Dialog Base Units with Non-System-Based Font
p17483
aVHowever, you made it clear in the comments that, for your problem, you do not actually need to convert from DLUs to pixels
p17484
aVYou can use Delphi's built in form scaling to ensure that your forms are sized appropriately for the prevailing font scaling
p17485
as(dp17486
g7
V505088
p17487
stp17488
a((dp17489
g2
(lp17490
VI think it's easiest to read the NUMBER_OF_PROCESSORS environment variable
p17491
as(dp17492
g7
V505088
p17493
stp17494
a((dp17495
g2
(lp17496
VI think you are mistaken
p17497
aVThe copy method sends a WM_COPY message to the control
p17498
aVThis will place formatted text as well as plain text on the clipboard
p17499
aVLook through all the formats on the clipboard and you will find RTF is present
p17500
as(dp17501
g7
V505088
p17502
stp17503
a((dp17504
g2
(lp17505
VWell, on Windows I happily run  and many other of the GNU tools
p17506
aVYou can do it with cygwin, but I personally prefer GnuWin32 because it is a much lighter installation experience
p17507
aVSo, my answer is that the Windows equivalent of , is none other than  itself
p17508
as(dp17509
g7
V505088
p17510
stp17511
a((dp17512
g2
(lp17513
VIf you want to set every single bit of the struct to 0 then you should use
p17514
aVThis is safe to do for any POD type, and it may even be what you want to do to the struct
p17515
aVIf it's not a POD type, then all bets are off
p17516
aVOn the other hand, I can't imagine what you have against  which is easier to write and safe no matter what is contained in
p17517
aVIf you want to initialize something then surely you should use the initialization constructs built into the language
p17518
as(dp17519
g7
V505088
p17520
stp17521
a((dp17522
g2
(lp17523
VYou have a few options
p17524
aVRun all the UI out of the main thread and get the worker thread to synchronize reporting back to the main thread to display, for example via  or
p17525
aVDon't wait at all and get the worker thread to post a message to the main thread when the worker is done
p17526
aVUse  for your wait
p17527
aVTo elaborate on , it's a wait function that can be configured to return when messages arrive in the queue
p17528
aVThus you can keep your message pump alive whilst also using a blocking wait in between processing queued messages
p17529
aVIn pseudo-code you would write it like this:
p17530
as(dp17531
g7
V505088
p17532
stp17533
a((dp17534
g2
(lp17535
VFirstly, don't do anything on a mouse event because the popup menu can be invoked from the keyboard
p17536
aVThe best way to do this, in my view, is to handle the  event
p17537
aVIf you want the menu not to appear call
p17538
as(dp17539
g7
V505088
p17540
stp17541
a((dp17542
g2
(lp17543
VIt is currently failing because you aren't allocating memory for the filenames
p17544
aVEither use strdup or malloc+strcpy (I'd use strdup)
p17545
aVYour filename field is an array of pointers to zero terminated string
p17546
aVYou need to allocate the memory for the string and copy the string to that memory
p17547
aVYou save the address of the new string in one of the pointers, e
p17548
ag217
aVfilename[0]
p17549
aVThe direct memory address code doesn't work
p17550
aVIt just doesn't crash, yet
p17551
aVThat code just overwrites the array of pointers
p17552
aVDon't ever write code like that
p17553
aVNever ever ever
p17554
aVWriting code like that is morally equivalent to eating baby unicorns
p17555
as(dp17556
g7
V505088
p17557
stp17558
a((dp17559
g2
(lp17560
VYou have two main options:
p17561
aVStore the settings in a file under the user profile
p17562
aVIf your settings are simple enough then INI files work perfectly adequately
p17563
aVStore the settings in the registry, under  which is also part of the profile
p17564
aVPersonally I prefer to use the registry since it provides hierarchical storage for free
p17565
aVIf you use a file, then you have to do that yourself which can be a bind for more complex data
p17566
aVOn the other hand, if you want to write a portable app, i
p17567
ag192
aVone that can live on a memory stick, then a user settings file that sits alongside the executable is the way to go
p17568
as(dp17569
g7
V505088
p17570
stp17571
a((dp17572
g2
(lp17573
VPage faults are normal
p17574
aVIt's part of the process of allocating memory
p17575
aVThis is nothing to worry about
p17576
as(dp17577
g7
V505088
p17578
stp17579
a((dp17580
g2
(lp17581
VThere's a lot of text here, and not much code
p17582
aVYour question would probably be better with more code and less text
p17583
aVAnyway, I can offer some hints
p17584
aVFirstly, calling  directly is a rather laborious way to do threading in Delphi
p17585
aVIt's easier to use  which wraps up some of the low-level Windows API issues in a manner more native to typical Delphi code style
p17586
aVOf course, you could go further and use a threading library like OmniThreadLibrary, but for now it may be better just to stick to  and work out how to do it that way
p17587
aVNow, that won't be your problem here
p17588
aVAlmost certainly your problem will be cause by one of two common issues with threading:
p17589
aVAll VCL and GUI code should run in the main thread
p17590
aVWindows controls have affinity with the thread that creates them
p17591
aVMany parts of the VCL are not thread-safe
p17592
aVThese issues strongly push you to putting all VCL/GUI code in the main thread
p17593
aVIt's quite possible that you have a race condition due to lack of synchronisation
p17594
aVThe most common way to deal with issue 1 is to call  or  from the worker threads in order to force all the VCL/GUI code to run on the main thread
p17595
aVOf course you need to be sure that none of the time-consuming code in your worker thread uses VCL/GUI objects since that is doomed to failure
p17596
aVIssue 2 can be dealt with by synchronisation objects like critical sections or lock-free methods using the InterlockedXXX family of functions
p17597
aVExactly what your problem is I can't say
p17598
aVIf you want more detailed help then please post more code, most probably cut down from what you are currently running
p17599
as(dp17600
g7
V505088
p17601
stp17602
a((dp17603
g2
(lp17604
VYou do need the d14 version for Delphi 2010
p17605
aVThe d15 version is for XE
p17606
aVNot sure why there is only the d15 version in the zip
p17607
aVThe DLL is not located on your DLL search path
p17608
aVOnce you get hold of the right DLL then you need to make sure it's on the path
p17609
aVHaving browsed around this component I'm not convinced it's terribly polished
p17610
aVIf you can afford it, the Devart drivers come highly recommended
p17611
as(dp17612
g7
V505088
p17613
stp17614
a((dp17615
g2
(lp17616
VOne option would be to put your icons in a separate module, i
p17617
ag192
aVa DLL
p17618
aVThis would stop the system using them for application icons and avoid the need to add your own copy of the default system application icon
p17619
as(dp17620
g7
V505088
p17621
stp17622
a((dp17623
g2
(lp17624
VYou can't do this for good reason
p17625
aVDifferent implementations of interfaces are meant to be used interchangeably
p17626
aVYour proposed design violates this principle
p17627
aVIf you want help solving the conflict I think you need to explain what led you to this design
p17628
as(dp17629
g7
V505088
p17630
stp17631
a((dp17632
g2
(lp17633
VWhen you are using debug DCUs you need to use the call stack to see how execution reached the throw
p17634
aVThere's no way for the debugger to break any earlier than the point at which the exception is raised
p17635
aVWithout debug DCUs the debugger can only break at a line of code for which it has debug information
p17636
aVThat has to be somewhere in your code
p17637
as(dp17638
g7
V505088
p17639
stp17640
a((dp17641
g2
(lp17642
VAs Andreas says, put the labels into a dynamic array, rather than sorting the values
p17643
aVOnce you have them in such an array, sort them like this:
p17644
as(dp17645
g7
V505088
p17646
stp17647
a((dp17648
g2
(lp17649
VThis happens because you have defined a Debug Desktop
p17650
aVYou can either switch off the Debug Desktop feature, or define a different desktop view to be your Debug Desktop
p17651
aVThe settings are under the View | Desktops menu if I recall correctly
p17652
aVI find this feature very powerful, especially combined with my multiple monitors
p17653
aVThe debug desktop lives on a separate monitor so it doesn't overlap with my app window
p17654
aVAnd I can also configure the layout of call stack, watches, locals windows that I don't show in my standard desktop
p17655
as(dp17656
g7
V505088
p17657
stp17658
a((dp17659
g2
(lp17660
VThe problem is that your  doesn't return anything for attributes other than  and  and doesn't raise an AttributeError
p17661
aVHence when the  method is looked up,  returns  and hence your error
p17662
aVYou could fix this by making  return values for other attributes
p17663
aVIn fact you have to ensure that  calls the method from its superclass for all attributes that are not handled
p17664
aVBut really  is the wrong thing to use here
p17665
aVIt should be used sparingly, and when there aren't more obvious, higher level solutions available
p17666
aVFor example,  is essential for dynamic dispatch
p17667
aVBut in your case, the  and  values are well known and well defined before the code runs
p17668
aVThe right solution is to make  and  properties and not implement  at all
p17669
as(dp17670
g7
V505088
p17671
stp17672
a((dp17673
g2
(lp17674
VDefine a const static instance of the struct with the initial values and then simply assign this value to your variable whenever you want to reset it
p17675
aVFor example:
p17676
aVHere I am relying on static initialization to set my initial values, but you could use a struct initializer if you want different initial values
p17677
aVThen, each time round the loop you can write:
p17678
as(dp17679
g7
V505088
p17680
stp17681
a((dp17682
g2
(lp17683
VBest you can do is try to decode it
p17684
aVIf the decode fails then the input was not base64 encoded
p17685
aVIt the string successfully decodes then the input might have been base64 encoded
p17686
as(dp17687
g7
V505088
p17688
stp17689
a((dp17690
g2
(lp17691
VIf you are using a critical section for your lock then the equivalent is
p17692
aVIf you are using a mutex for your lock then the equivalent is to call  passing  as the timeout
p17693
aVIf you are unfamiliar with Windows synchronisation objects, don't be fooled into preferring the mutex because it has a name that you are most familiar with from a pthreads background
p17694
aVSo long as your synchronisation is within process, critical sections are more efficient and easier to use
p17695
as(dp17696
g7
V505088
p17697
stp17698
a((dp17699
g2
(lp17700
VI do it with this function:
p17701
aVIt works, but if someone knows a less hacky way to do it then I'd love to hear about it
p17702
as(dp17703
g7
V505088
p17704
stp17705
a((dp17706
g2
(lp17707
VIn the code you posted,  will never return
p17708
aVThat waits until the thread has terminated, i
p17709
ag192
aVits  method has completed
p17710
aVBut that can't happen because it stops and waits for itself
p17711
aVYou should simply remove the call to
p17712
aVI also wonder whether or not  is the correct way to terminate the form
p17713
aVIf it really is a modal form then you should use
p17714
aVI've just seen your edit which includes the definition of
p17715
aVThis function doesn't return a value
p17716
aVYou should receive a compiler warning telling you of this\u2014read the compiler warnings, they are very valuable
p17717
aVWrite  like this:
p17718
as(dp17719
g7
V505088
p17720
stp17721
a((dp17722
g2
(lp17723
VError code 122 is
p17724
aVThe documentation for  states that this error code is returned when the following occurs
p17725
aVThe buffer pointed to by the pIpForwardTable parameter is not large enough
p17726
aVThe required size is returned in the DWORD variable pointed to by the pdwSize parameter
p17727
aVThe solution is to read the value of  that is returned, and call again with a buffer of that size
p17728
aVThe other problem with your code is that you do not pass in a valid buffer
p17729
aVNotice that the variable  is never assigned to
p17730
aVIn your edit, you do call  to allocate it, but in the wrong place
p17731
aVYou need something like this:
p17732
as(dp17733
g7
V505088
p17734
stp17735
a((dp17736
g2
(lp17737
VIf possible, it is always better the function a pointer to the memory in which the returned value can be written
p17738
aVI say so because you allow your clients (the callers of the function) the choice of where to locate the memory: on the stack or the heap, or perhaps even somewhere more exotic
p17739
aVNow, the kicker in this is the if possible clause
p17740
aVSometimes the size of the memory can only be determined during the implementation of the function
p17741
aVA typical example would be a function that null-terminated string
p17742
aVWhen you come across this scenario you are typically best resorting to allocating the memory on the heap inside the function, and requiring your clients to free the memory when they are done with it
p17743
as(dp17744
g7
V505088
p17745
stp17746
a((dp17747
g2
(lp17748
VProbably the first step to tracing this is to detect what part of your code actually creates the thread
p17749
aVCreating a thread during application shutdown sounds to me like bad news in the making so I'd be looking to make sure that simply doesn't happen
p17750
aVAs for how to do it, I'd use debugger breakpoints
p17751
aVFirst of all I'd set a breakpoint on the implementation of  in Windows
p17752
aVpas and run with debug DCUs
p17753
aVSee if that breakpoint triggers during shutdown
p17754
aVIf it doesn't break in there during shutdown then the thread is created by non-Delphi code
p17755
aVMy next step would be to open the CPU view and step into
p17756
aVThe disassembly for  will start with a  instruction
p17757
aVStep into this and you will be at
p17758
aVNow set a breakpoint here and see what the call stack is when you trigger this during shutdown
p17759
as(dp17760
g7
V505088
p17761
stp17762
a((dp17763
g2
(lp17764
VAppending text
p17765
aVSend an  message to move the selection to the end of the rich edit control
p17766
aVUse  to find out how many characters are in the edit control
p17767
aVSend an  message to replace the selection
p17768
aVIf the selection point is at the end of the control, then replacing is the same as appending
p17769
aVDon't attempt to use  &  since it rapidly becomes inefficient, not to mention the fact that the formatting is not preserved
p17770
aVFormatting text
p17771
aVUse the  to format text
p17772
aVMore details over at MSDN
p17773
as(dp17774
g7
V505088
p17775
stp17776
a((dp17777
g2
(lp17778
VIt turns out that this is quite difficult to achieve
p17779
aVThe problem is that the  passes a structure by reference
p17780
aVThe  is not one of the common Windows messages, it's in the  range
p17781
aVThe memory pointed to by  is not marshalled across the process boundary
p17782
aVThe receiver of the message receives a pointer to memory that is only meaningful in the sender's process
p17783
aVThis means that your only solution will be to use  to write the  buffer into a block of memory allocated in the target process
p17784
aVThis is all possible but quite cumbersome, especially in Python
p17785
aVIf I were you, I would consider an alternative solution to your problem
p17786
as(dp17787
g7
V505088
p17788
stp17789
a((dp17790
g2
(lp17791
VWe experience this too
p17792
aVThe system puts some of the executable pages out to swap and then fails to page it back some time later
p17793
aVIt appears to be related to network connections being restored after sleep
p17794
aVThe only viable solution that we have found is to locate executables on the local machine
p17795
as(dp17796
g7
V505088
p17797
stp17798
a((dp17799
g2
(lp17800
VThis behaviour is by design and the design is sound
p17801
aVWere the class to take responsibility for not freeing duplicates, it would have to iterate over the whole container every time a modification was made, both adding and removing
p17802
aVThe iteration would check for any duplicate values and check accordingly
p17803
aVIt would be disasterous to impose this diabolical performance drain on all users of the class
p17804
aVIf you wish to put duplicates in the list then you will have to come up with a bespoke lifetime management policy that suits your specific needs
p17805
aVIn this case it is unreasonable to expect the general purpose container to support your particular usage pattern
p17806
aVIn the comments to this answer, and many of the others, it has been suggested that a better design would have been to test in  whether or not the value being set was already assigned to the specified key
p17807
aVIf so, then  could return immediately
p17808
aVI think it's clear to anyone that checking for duplicates in full generality is too expensive to contemplate
p17809
aVHowever, I contend that there are good design reasons why checking for duplicate K and V in  would also be poor design
p17810
aVRemember that  is derived from
p17811
aVFor the more general class, comparing equality of  is potentially an expensive operation because we have no constraints on what  is, it being generic
p17812
aVSo for  there are performance reasons why we should not include the putative  test
p17813
aVIt could be argued that we make a special exception for
p17814
aVThat would certainly be possible
p17815
aVIt would require a little re-engineering of the coupling between the two classes, but it is quite feasible
p17816
aVBut now you have a situation where   and  have different semantics
p17817
aVThis is a clear downside and must be weighed against the potential benefit from the  test
p17818
aVThese generic container classes are so fundamental that design decisions have to take into account a huge spread of use cases, consistency considerations and so on
p17819
aVIt is not, in my view, reasonable to consider  in isolation
p17820
as(dp17821
g7
V505088
p17822
stp17823
a((dp17824
g2
(lp17825
VYou can't search in the sub-columns
p17826
aVYou can only search in the primary column
p17827
aVThe  value specifies which row to start searching from
p17828
aVYou are mistaken in thinking that it allows you to specify which column to search
p17829
as(dp17830
g7
V505088
p17831
stp17832
a((dp17833
g2
(lp17834
VYou can't remove an individual item from an environment variable
p17835
aVYou have to read in the current value, parse it, remove what you want to remove, and then reset the variable
p17836
aVIf you aren't doing this in code then I can recommend Rapid Environment Editor as an excellent tool to make this work easy
p17837
as(dp17838
g7
V505088
p17839
stp17840
a((dp17841
g2
(lp17842
VI think you are mistaken
p17843
aVNot all
p17844
aVdoc and
p17845
aVxls files are saved with thumbnails
p17846
aVCertainly
p17847
aVtxt files are not saved with thumbnails
p17848
aVI downloaded the demo code and tried it out
p17849
aVIt successfully shows thumbnails for
p17850
aVdoc and
p17851
aVxls that showed thumbnails in Explorer
p17852
aVIt shows standard icons for those files that do not have thumbnails when viewed in Explorer
p17853
as(dp17854
g7
V505088
p17855
stp17856
a((dp17857
g2
(lp17858
VI think I've worked out a way of handling it
p17859
aVI make sure that I always create  rather than  by hooking the form streaming mechanism with
p17860
aVDealing with  descendents is more messy
p17861
aVFor them I resorted to copying the source code of  into my descendent and making use of  again
p17862
aVNext task is to write it up as a QC report
p17863
as(dp17864
g7
V505088
p17865
stp17866
a((dp17867
g2
(lp17868
VYou have two possible approaches:
p17869
aVAttach to Process
p17870
aVMake the test2 project active in Visual Studio
p17871
aVStart test1, which in turn starts the test2 process
p17872
aVUse Debug | Attach to Process and select the test2 process
p17873
aVThis is fine if you don't need to debug the startup of the process
p17874
aVProject Configuration
p17875
aVMake the test2 project active in Visual Studio
p17876
aVOpen Project | Configuration | Configuration Properties | Debugging
p17877
aVSet Command to the full path to test1
p17878
aVexe
p17879
aVGenerally this alternative is much more productive and allows you to debug startup
p17880
as(dp17881
g7
V505088
p17882
stp17883
a((dp17884
g2
(lp17885
VI believe your solution to be the most efficient and also the most readable
p17886
aVEven if you can find an implementation in LINQ it will surely be tortuous
p17887
aVBy excluding  checks I presume you mean that the real code doesn't throw in the event of  running off the end of the list
p17888
as(dp17889
g7
V505088
p17890
stp17891
a((dp17892
g2
(lp17893
VThe DLL will typically come with a header file (
p17894
aVh) and an associated import library (
p17895
aVlib) that deal with the calling conventions, exported function prototypes etc
p17896
aVSimply include the header file, link to the import library, and you will be able to call the functions directly
p17897
aVThat header file will specify that the functions use the  calling convention
p17898
aVYou most definitely do not, and should not, write a separate wrapper DLL
p17899
aVThat would be adding a completely gratuitous layer of complexity
p17900
aVHaving re-read your question, and your comment, I believe that you have the following architecture:
p17901
aVThe legacy DLL exports its function using
p17902
aVThe application imports function from the plugin using
p17903
aVIf that synopsis is correct then of course you must import from the legacy DLL using  and export to the application using
p17904
aVSince those parts of the interface are outside your control you have no option
p17905
aVHowever, I am finding the question and comments very hard to follow
p17906
aVPerhaps I have not fully understood
p17907
aVFeel free to add more information to clarify in an edit to the question
p17908
aVFollowing the update I suspect that your problems are all concerning how to interface the VB6 legacy DLL with your C++ DLL
p17909
aVSince you don't have a header file (
p17910
aVh) for the VB6 DLL you are presumably writing your own translations
p17911
aVIf I recall correctly, VB6 only supports  which is what you are currently using
p17912
aVYour problems are therefore most likely to be due to erroneous translations of the exported VB functions into C++ prototypes
p17913
aVI think your best course of action is to focus on getting these prototype translations correct
p17914
aVPerhaps you could consider doing that in the context of a separate standalone test project to avoid the complexity of the full application
p17915
aVIf you want further help from Stack Overflow I think you will need to supply the VB6 function declarations and your attempted translations, but I think that would be the subject of new question(s)
p17916
as(dp17917
g7
V505088
p17918
stp17919
a((dp17920
g2
(lp17921
VIf you use a value type like a record then you need to assign the final returned result to a variable:
p17922
aVIf you use a reference type like a class instance, then you can use the syntax that you used in your question
p17923
aVThe reference type approach treats the data type as mutable, whereas for value types you are best implementing an immutable data type
p17924
as(dp17925
g7
V505088
p17926
stp17927
a((dp17928
g2
(lp17929
VUse  or Dependency Walker to check that you are exporting the function since it would seem that you are not
p17930
aVMy guess is that you didn't configure the build to pass the
p17931
aVdef file to the linker
p17932
aVDo it like in this screenshot:
p17933
as(dp17934
g7
V505088
p17935
stp17936
a((dp17937
g2
(lp17938
VYou can use pretty much any IPC mechanism
p17939
aVIf your service and app are
p17940
aVnet based, then the most common solution is to use WCF
p17941
aVFor native code service and app, a very common solution is a named pipe
p17942
aVBut what choice is best depends on your specific usage needs
p17943
as(dp17944
g7
V505088
p17945
stp17946
a((dp17947
g2
(lp17948
VInstalling your own component in the IDE is tried and tested
p17949
aVMany thousands of developers around the globe do it
p17950
aVI do it too
p17951
aVIt works fine
p17952
aVYou actually know this yourself since you do exactly that with the devexpress components
p17953
aVHowever, if you are dead set against registering your own components in the IDE, you can use an interposer as Sertac suggested
p17954
aVThis works so long as you don't need to publish any new properties, which I believe is the case in the situation you describe
p17955
aVIt's possible that the problems you have with registering components in the IDE are actually faults in your code
p17956
aVThat's not meant as criticism, coding for design time behaviour is quite challenging
p17957
aVSince you don't need to publish new properties, and since the component in question is a third party component, an interposer or similar seems to be quite a reasonable approach
p17958
as(dp17959
g7
V505088
p17960
stp17961
a((dp17962
g2
(lp17963
VMy guess is that you are creating the window in the main thread (the GUI thread), but then calling functions on that window from the worker thread
p17964
aVThat would be against the rules since windows have affinity to the thread on which they are created
p17965
aVMake sure that all your API calls that use the window handle are made from the main thread
p17966
aVNote that  calls are marshalled onto the correct thread, but in any case, for performance reasons, they are also better to be send from the main thread
p17967
as(dp17968
g7
V505088
p17969
stp17970
a((dp17971
g2
(lp17972
VIf you have a single method call that takes a long time, then the best solution is to make changes inside that single method call to regularly check for termination
p17973
aVForcibly terminating a thread leads to resource leaks, deadlocks, and the mass slaughter of innocent babies
p17974
aVActually, I'm not 100% certain on the veracity of that final point, but I think you can understand what I'm trying to say\u2014don't forcibly terminate threads
p17975
aVIf you don't have access to the internals of this long running method then you really are in a bind
p17976
aVI have been in that situation in the past and managed to solve the problem by corrupting the input data that was passed to the method
p17977
aVFor example, in my case, I was passing large arrays of floating point values
p17978
aVSetting all of those floating point values to signalling NaN proved sufficient to make the long running method gag and return
p17979
aVPerhaps you will be able to use a similar method
p17980
as(dp17981
g7
V505088
p17982
stp17983
a((dp17984
g2
(lp17985
VI don't think this logic is exposed in any way for you to call at runtime
p17986
aVI believe it is design time only
p17987
aVTo handle this I would create a dummy form in the designer which had one of each control you worked with
p17988
aVAlign them all the way you have in your screenshots
p17989
aVAt runtime instantiate this form, but don't show it and read out the  property for each type of control
p17990
aVFinally you can work out the vertical offset of the  property from each type of control to each other type of control
p17991
as(dp17992
g7
V505088
p17993
stp17994
a((dp17995
g2
(lp17996
VThe runtime function  can arrange this for you
p17997
aVYou just need to do this:
p17998
aVAll errors (including those provoked by assertion failuees) will print their messages to  rather than an interactive message box
p17999
aVThis means that your application won't block waiting for input and will proceed to terminate itself immediately
p18000
as(dp18001
g7
V505088
p18002
stp18003
a((dp18004
g2
(lp18005
VThis is not a compiler bug
p18006
aVYou need to initialize the struct first, like the compiler says
p18007
aVPresumably your error is actually in the code which invokes the delegate since nothing else makes sense
p18008
aVWhen you were invoking the delegate with your 16 parameter double version, the double parameters were initialized
p18009
aVIf you had not initialized them, then the compiler would have emitted the same error
p18010
aVFor example:
p18011
aVThis fails to compile with the following error:
p18012
aVThere is nothing special about structs in this regard
p18013
aVAs a general rule, your first guess when you encounter a syntax error should never be that this is a compiler bug
p18014
aVCompiler bugs are exceedingly rare, especially in a compiler as widely used as this one
p18015
aVUpdate following the edit to the question which added real code
p18016
aVThe compiler is not sure that  is fully initialized
p18017
aVIt does not do program flow analysis
p18018
aVYou can fix the problem by making sure that the compiler knows that the struct is fully initialized
p18019
as(dp18020
g7
V505088
p18021
stp18022
a((dp18023
g2
(lp18024
VHere's a wild guess
p18025
aVYou are running the application that receives the messages as administrator
p18026
aVIn Vista and up, integrity level protection stops processes delivering messages to processes with higher integrity levels
p18027
aVFrom the  documentation:
p18028
aVMessage sending is subject to UIPI (User Interface Privilege Isolation)
p18029
aVThe thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level
p18030
as(dp18031
g7
V505088
p18032
stp18033
a((dp18034
g2
(lp18035
VYou can't get any technical documentation yet because XE2 has been announced but not released
p18036
as(dp18037
g7
V505088
p18038
stp18039
a((dp18040
g2
(lp18041
VOnly one of the three ways to implement a destructor that you list actually involves a destructor, and that's
p18042
aVIf you implement , and dispose of your object, then the code in  will run, but there's no reason to think that your destructor will
p18043
aVI think you chasing the impossible here
p18044
aVDestructors run as and when the garbage collector so decrees
p18045
aVIt's not something that you have any control over
p18046
aVThe GC is well within its rights to form the opinion that running destructors simply wastes time, and if there is plenty of memory it will form that opinion
p18047
aVIf you need predictable disposal, finalization etc
p18048
aV, then use
p18049
as(dp18050
g7
V505088
p18051
stp18052
a((dp18053
g2
(lp18054
VProcesses are 32 bit or 64 bit
p18055
aVThere is no running a 64 bit process in 32 bit mode
p18056
aVYou need to install the 32 bit packages
p18057
as(dp18058
g7
V505088
p18059
stp18060
a((dp18061
g2
(lp18062
V has an address because you create it in order to pass it to
p18063
aVYou haven't yet bound it to a name, but the object still exists
p18064
aVPython caches and reuses short strings
p18065
aVBut if you assemble strings by concatenation, then the code that searches the cache and attempts re-use is bypassed
p18066
aVNote that the inner workings of the string cache is pure implementation detail and should not be relied upon
p18067
as(dp18068
g7
V505088
p18069
stp18070
a((dp18071
g2
(lp18072
VWhen you run the process redirect stderr to stdout like this:
p18073
as(dp18074
g7
V505088
p18075
stp18076
a((dp18077
g2
(lp18078
VYou can't call that member function from C in a portable way
p18079
aVYou need to expose your C++ interface by flattening it
p18080
as(dp18081
g7
V505088
p18082
stp18083
a((dp18084
g2
(lp18085
VMake the first parameter of the Delphi  be  and you should be good to go
p18086
aVAn open array, as you have it, expects to be passed both the pointer to the first element and the length which explains what you describe in your question
p18087
as(dp18088
g7
V505088
p18089
stp18090
a((dp18091
g2
(lp18092
VI think your diagnosis that the component is written in an Embarcadero product is very likely to be true
p18093
aVDelphi's runtime library does indeed enable floating point exceptions, same for C++ Builder
p18094
aVOne of the nice things about Embarcaderos tools is that floating point errors get converted into language exceptions which makes numerical coding a lot easier
p18095
aVThat is going to be of little consolation to you
p18096
aVThis entire area is a colossal PITA
p18097
aVThere are no rules whatsoever regarding the FP controls word
p18098
aVIt's a total free-for-all
p18099
aVI don't believe that catching unhandled exceptions isn't going to get the job done because the MS C++ runtime will presumably already be catching these exceptions, but I'm no expert in that area and I may be wrong
p18100
aVI believe that your only realistic solution is to set the FPU to what you want it to be whenever execution arrives in your code, and restore it when execution leaves your code
p18101
aVI don't know enough about COM event sinks to understand why they present an obstacle to doing this
p18102
aVMy product includes a DLL implemented in Delphi and I suffer from the reverse problem
p18103
aVMostly the clients that call in have an FPU control word that disables exceptions
p18104
aVThe strategy we adopt is to remember the 8087CW on entry, set it to the standard Delphi CW before executing code, and then restore it at the exit point
p18105
aVWe take care to deal with callbacks too by restoring the caller's 8087CW before making the callback
p18106
aVThis is a plain DLL rather than a COM object so it's probably a bit simpler
p18107
aVIf you decide to attempt to get the COM supplier to modify their code then they need to call the  function
p18108
aVHowever, since there are no rules to the game, I believe that the COM object vendor would be justified in refusing to change their code and to put the onus back on you
p18109
aVSorry if this is not a 100% conclusive answer, but I couldn't get all these thoughts into a comment
p18110
as(dp18111
g7
V505088
p18112
stp18113
a((dp18114
g2
(lp18115
VThe only way I know that a web browser could host VCL code would be through an ActiveX
p18116
aVI wouldn't really advise you to take that approach
p18117
as(dp18118
g7
V505088
p18119
stp18120
a((dp18121
g2
(lp18122
VThere is no memory leak there
p18123
aVYour pointer  points to a block of memory that is owned by the string  and so you do not need to free
p18124
aVThe string class manages all allocation and deallocation for you
p18125
aVWhat can happen though is that if the string does not contain at least one of those 4 characters your loop will run off the end and eventually raise an access violation
p18126
aVYou should consider terminating the loop when it reaches a null terminator
p18127
aVIt's just simpler to avoid pointers altogether:
p18128
aVThe replicates the logic of your code, and removes the risk of access violations
p18129
aVHowever, your code was returning the portion of the string starting from, and including, the first instance of , ,  or
p18130
aVIs that really what you wanted
p18131
as(dp18132
g7
V505088
p18133
stp18134
a((dp18135
g2
(lp18136
VThe GUI app needs a desktop and you only get one of those for a logged in user
p18137
as(dp18138
g7
V505088
p18139
stp18140
a((dp18141
g2
(lp18142
VYou can do the checking yourself since your need to customise beyond that what the standard functions offer
p18143
aVCall  to get a list of top-level windows
p18144
aVRemove your semi-transparent window from this list
p18145
aVFor each window in the list use  to determine whether or not the mouse is over the window
p18146
aVRemove any windows that don't fit the bill
p18147
aVUse , starting from one of the remaining windows to walk the z-order and find out which of the candidates is at the top
p18148
as(dp18149
g7
V505088
p18150
stp18151
a((dp18152
g2
(lp18153
VThere's no public interface to work with notification icons other than the ones you own
p18154
aVYou can only do this by hacking and reverse engineering the shell
p18155
as(dp18156
g7
V505088
p18157
stp18158
a((dp18159
g2
(lp18160
VI believe that most highly performant MD codes are written in native languages like Fortran, C or C++
p18161
aVModern GPU programming techniques are also finding favour more recently
p18162
aVA language like Python would allow for much more rapid development that native code
p18163
aVThe flip side of that is that the performance is typically worse than for compiled native code
p18164
aVA question for you
p18165
aVWhy are you writing your own MD code
p18166
aVThere are many many libraries out there
p18167
aVCan't you find one to suit your needs
p18168
as(dp18169
g7
V505088
p18170
stp18171
a((dp18172
g2
(lp18173
VI agree that you should not use the  property
p18174
aVNot least because you may at some point in time wish to use the  property for something else
p18175
aVI am also somewhat dubious of solutions that use
p18176
aVI think I would use an instance of  to map between buttons and the application details
p18177
aVHere I'm imagining that  is a record containing two strings, one for the left click and one for the right click, e
p18178
ag217
aVFor sake of argument, let us suppose that this instance is called
p18179
aVWhen ever you add a new button you write code like this:
p18180
aVThen in the form's mouse event handler you write it like this:
p18181
aVAnd now  has both paths ready for you to use
p18182
aVThis idea can easily be extended to include as much information as you like in the  record
p18183
aVAs an aside, I think you should be handling  rather than  since in Windows, buttons are clicked when you release the mouse button rather than when you press it
p18184
as(dp18185
g7
V505088
p18186
stp18187
a((dp18188
g2
(lp18189
VYou can do this by calling the system() function
p18190
as(dp18191
g7
V505088
p18192
stp18193
a((dp18194
g2
(lp18195
VUpgrade to the very latest version, 15
p18196
aV01, which appears to have fixed this bug
p18197
as(dp18198
g7
V505088
p18199
stp18200
a((dp18201
g2
(lp18202
VUse
p18203
aVNote that I use  to suppress echoing of the command line at each iteration of the for loop
p18204
aVThis is optional
p18205
aVThe above syntax is appropriate for use at the interactive console
p18206
aVWhen executing in a batch file, the  must be replaced with
p18207
as(dp18208
g7
V505088
p18209
stp18210
a((dp18211
g2
(lp18212
VAre you looking for
p18213
aVIf you want the selected item not to be highlighted even when the list view has the focus, then that's going to be pretty confusing for the users and would require some custom painting
p18214
as(dp18215
g7
V505088
p18216
stp18217
a((dp18218
g2
(lp18219
V is incorrect
p18220
as(dp18221
g7
V505088
p18222
stp18223
a((dp18224
g2
(lp18225
VOn the contrary, it does execute the  block
p18226
aVThis is the output:
p18227
as(dp18228
g7
V505088
p18229
stp18230
a((dp18231
g2
(lp18232
VIn our application we use  which works rather well
p18233
aVYou may need to tweak it a little for Unicode Delphi, but if I recall correctly that was pretty simple to do
p18234
aVHere's what it looks like:
p18235
as(dp18236
g7
V505088
p18237
stp18238
a((dp18239
g2
(lp18240
VIn many other languages, the equivalent of the header file is all you need
p18241
aVBut the common C linkers on Windows have always used import libraries, C++ linkers followed suit, and it's probably too late to change
p18242
aVAs a thought experiment, one could imagine syntax like this:
p18243
aVArmed with that information the compiler/linker tool chain could do the rest
p18244
aVAs a further example, in Delphi one would import this function, using implicit linking, like so:
p18245
aVwhich just goes to show that import libraries are not, a priori, essential for linking to DLLs
p18246
as(dp18247
g7
V505088
p18248
stp18249
a((dp18250
g2
(lp18251
VI recommend that you avoid using a dynamic array of WideChar which is not at all convenient to work with
p18252
aVInstead use  if you have Delphi 2009 or later, or  for earlier Delphi versions
p18253
aVBoth of these are dynamic string types with  elements
p18254
aVYou can assign to them and Delphi deals with all the allocation
p18255
aVSo, assuming that you now have the following record:
p18256
aVyou can simplify things considerably
p18257
as(dp18258
g7
V505088
p18259
stp18260
a((dp18261
g2
(lp18262
VYou are not notified of such an event
p18263
aVIf you were there would be an entry for middle mouse button click in the list of menu notifications
p18264
aVSo perhaps you could use some sort of hack behind the back of the menu system if you really want to do this
p18265
aVHowever, as discussed in the comments, there are good reasons for thinking that your proposed UI may not be very appropriate
p18266
as(dp18267
g7
V505088
p18268
stp18269
a((dp18270
g2
(lp18271
VI have converted ARPACK to C using
p18272
aVWhenever you use  and you care about thread-safety you must use the  switch
p18273
aVThis makes local variables have automatic storage, i
p18274
ag192
aVbe stack based locals rather than statics which is the default
p18275
aVEven so, ARPACK itself is decidedly not threadsafe
p18276
aVIt uses a lot of common blocks (i
p18277
ag192
aVglobal variables) to preserve state between different calls to its functions
p18278
aVIf memory serves, it uses a reverse communication interface which tends to lead developers to using global variables
p18279
aVAnd of course ARPACK probably was written long before multi-threading was common
p18280
aVI ended up re-working the converted C code to systematically remove all the global variables
p18281
aVI created and handful of C structs and gradually moved the global variables into these structs
p18282
aVFinally I passed pointers to these structs to each function that needed access to those variables
p18283
aVAlthough I could just have converted each global into a parameter wherever it was needed it was much cleaner to keep them all together, contained in structs
p18284
aVEssentially the idea is to convert global variables into stack variables
p18285
as(dp18286
g7
V505088
p18287
stp18288
a((dp18289
g2
(lp18290
VYou need to run this from the same thread that owns the window to which the menu is attached
p18291
aVThe threading rule in Windows is that windows have affinity to the thread that creates the window
p18292
aVSince TrackPopupMenu receives a window handle, you can assume that it must be called from that window's thread
p18293
aVIn practice on Windows (and all GUI frameworks that I have ever come across), everything related to the GUI should happen in the main thread
p18294
as(dp18295
g7
V505088
p18296
stp18297
a((dp18298
g2
(lp18299
VI would not advise you to use the  routine to help with VB6 legacy code
p18300
aVYou should simply write your own dialog to do the work
p18301
aVThis question has been asked many times here in the context of C# and that always seems to be the answer
p18302
as(dp18303
g7
V505088
p18304
stp18305
a((dp18306
g2
(lp18307
VThe performance will be same either way
p18308
aVThe entire module is compiled, if needed, and the code executed, the first time you import a module, no matter how you import it
p18309
as(dp18310
g7
V505088
p18311
stp18312
a((dp18313
g2
(lp18314
VThat is how it meant to be drawn
p18315
aVThe 3D effect is as if there was a light source shining from the top left
p18316
aVThat's why the bottom and right edges are in a shadow cast by the raised panel
p18317
aVRegarding your updated question, it sounds like you want your application to run without themes
p18318
aVThe easiest way is to uncheck "Enable runtime themes" in the Application pane of the project settings
p18319
aVBut of course that would look odd nowadays
p18320
aVIf you are using the panel to group related controls, perhaps a group box would be better
p18321
aVMy instincts are that panels with raised borders will look poor on modern themed Windows
p18322
as(dp18323
g7
V505088
p18324
stp18325
a((dp18326
g2
(lp18327
VThe documentation describes  as so:
p18328
aVMoves the current position of a typed or untyped file to a specified component
p18329
aVNot used with text files
p18330
aVHerein lies your problem
p18331
as(dp18332
g7
V505088
p18333
stp18334
a((dp18335
g2
(lp18336
VThe Windows function that drives these notifications is
p18337
aVYou should find an example of how to use it from Python in the
p18338
as(dp18339
g7
V505088
p18340
stp18341
a((dp18342
g2
(lp18343
VUpdated: fixed the structure marshalling which has to be done manually
p18344
aVThis is quite a messy P/invoke
p18345
aVEven when you have the structs and the union defined, it's non-trivial to call the function because you have to marshal the structures manually
p18346
as(dp18347
g7
V505088
p18348
stp18349
a((dp18350
g2
(lp18351
Vmakes all names in the  namespace visible without qualification
p18352
aVjust makes  visible without qualification
p18353
as(dp18354
g7
V505088
p18355
stp18356
a((dp18357
g2
(lp18358
VYou just assign to the field:
p18359
as(dp18360
g7
V505088
p18361
stp18362
a((dp18363
g2
(lp18364
VUse a QTimer
p18365
aVThis will allow you to control the speed of your animation and keep your UI responsive
p18366
as(dp18367
g7
V505088
p18368
stp18369
a((dp18370
g2
(lp18371
VThe dict class is implemented purely in C as a built-in
p18372
aVIts data storage is private to that implementation
p18373
aVAs a thought experiment, imagine if it put the name/value pairs into a Python dict, how would that dict store them
p18374
aVIn another Python dict
p18375
aVAnd then, well, you get the idea
p18376
as(dp18377
g7
V505088
p18378
stp18379
a((dp18380
g2
(lp18381
VYou free  twice
p18382
aVOnce as a result of the message and once from the destructor
p18383
aVYou think you are setting  to  when you call  but you are not
p18384
aVYou are in fact setting  to 0
p18385
aVis a variable holding a reference to an object
p18386
aVYou are passing the value of  and when you pass by value you cannot modify the variable whose value you passed
p18387
aVSo you need to pass a reference to
p18388
aVTo do so you need to add an extra level of redirection and pass a pointer to , like so:
p18389
aVYou don't need , you can just call  directly
p18390
aVAnd you don't need to pass an instance in the message
p18391
aVI hope your real code isn't quite as weird as this
p18392
aV;-)
p18393
as(dp18394
g7
V505088
p18395
stp18396
a((dp18397
g2
(lp18398
VExecute each calculation thousands of times, in a loop, so that you can overcome the low resolution of  and obtain meaningful results
p18399
aVRemember to divide by the number of iterations when reporting results
p18400
aVThis is not particularly accurate but that probably does not matter for this assignment
p18401
as(dp18402
g7
V505088
p18403
stp18404
a((dp18405
g2
(lp18406
VThe RTL function  will extract the file name from a path
p18407
aVExactly how to split the 3 fields in your example depends very much on what the rules are for forming that line of text
p18408
aVHow is it delimited
p18409
aVIs is delimited by spaces
p18410
aVIf so, how do you escape spaces in the file path
p18411
aVUntil you specify that information, that part of your question is unanswerable
p18412
as(dp18413
g7
V505088
p18414
stp18415
a((dp18416
g2
(lp18417
VProcesses receive their token at startup and then cannot change them
p18418
aVThus if you want an app that appears to elevate for some subset of its functionality, that functionality must involve a new process
p18419
aVWhat you cannot do is elevate an existing process
p18420
as(dp18421
g7
V505088
p18422
stp18423
a((dp18424
g2
(lp18425
VYou can't have a desktop without a logged in user, so you likewise can't have notification icons without a logged in user
p18426
aVA service is the answer-it's the way to run code that executes even when there is no user logged in
p18427
as(dp18428
g7
V505088
p18429
stp18430
a((dp18431
g2
(lp18432
VFormatting in rich edit controls works by first selecting text, then applying formatting to that selection
p18433
aVSelect the text with the  and  properties
p18434
aVApply formatting with the  property, for example
p18435
as(dp18436
g7
V505088
p18437
stp18438
a((dp18439
g2
(lp18440
VI have (finally) found a difference between the two codes
p18441
aVThe following line of the Pascal translation is incorrect:
p18442
aVThe C version reads:
p18443
aVNote that  is truncated into a single , whereas the Pascal version above says  and so the index of  can exceed 255
p18444
aVYou should translate this line as:
p18445
aVI've changed to use  and  which are cosmetic changes but I feel they are cleaner
p18446
aVThe substantive change is in  where I force the  addition to be in the context of a byte data type
p18447
aVRather tellingly, this bug results in an out of bounds array access of the array
p18448
aVIf you had been running with range checking enabled, the bug would have been highlighted immediately
p18449
aVI can't stress enough how valuable Delphi's range checking feature is
p18450
as(dp18451
g7
V505088
p18452
stp18453
a((dp18454
g2
(lp18455
VTry this:
p18456
as(dp18457
g7
V505088
p18458
stp18459
a((dp18460
g2
(lp18461
VThe differences between a struct and class in C++ are:
p18462
aVMembers of a class are private by default, whereas members of a struct are public by default
p18463
aVSimilarly, inheritance between classes is also private by default, and inheritance between structs is public by default
p18464
aVBut basically anywhere you use a struct you could use a class, and vice versa, so it's really up to you what to use
p18465
aVConventionally, when you have methods, it is more common to use a class, and when you only have data, structs are more commonly used
p18466
aVI would say that if you want all the data members to be public, and you have no methods, then use a struct
p18467
aVOtherwise use a class
p18468
aVBut that's just personal preference
p18469
as(dp18470
g7
V505088
p18471
stp18472
a((dp18473
g2
(lp18474
VI think you need to mark your application as being high DPI aware by including this in your application manifest:
p18475
aVDetails on declaring DPI awareness are given here
p18476
aVIt seems like you are currently falling back to what is calling DPI Virtualization
p18477
as(dp18478
g7
V505088
p18479
stp18480
a((dp18481
g2
(lp18482
VFirst of all you need to have admin rights to write there
p18483
aVMostly it's just installers that write to this key and they generally run elevated
p18484
aVAdd this to your application manifest if that's the way you want to go:
p18485
aVIf this write to  is being made from an application that doesn't otherwise need elevation then please consider separating out the write to  into a separate process so that only that registry key write needs elevation
p18486
aVThis is best practise with UAC
p18487
aVThe other thing that might bite you is that your Delphi app will be 32 bit and so subject to registry redirection
p18488
aVAccesses of  will get redirected to
p18489
aVOn a 64 bit system I think you should endeavour to write to  and so you'll need to disable redirection
p18490
aVDo this by including  in the  property of your  instance
p18491
aVWindows will merge both views of the registry when it processes  and  keys but your application will leave clearer trails if you write to the 64 bit area of the registry for this particular key
p18492
as(dp18493
g7
V505088
p18494
stp18495
a((dp18496
g2
(lp18497
VJust because you've cast away const, doesn't mean that you will succeed in writing to that memory
p18498
aVAll that  does is remove the const-ness of the variable from the compiler's perspective
p18499
aVThat lets the compiler go ahead and emit code to write to the variable
p18500
aVBut at runtime, if the compiler/linker happened to put the variable in read-only memory, then the hardware will stop you writing there no matter how you cast it
p18501
as(dp18502
g7
V505088
p18503
stp18504
a((dp18505
g2
(lp18506
VArrange for your application to be sent a command line argument to indicate that the caller wants the alternative dialog
p18507
aVWhen the application starts, it should check for this argument and switch behaviour accordingly
p18508
aVNote that an application has exactly one entry point so the above is in fact the only solution bar creating separate applications
p18509
as(dp18510
g7
V505088
p18511
stp18512
a((dp18513
g2
(lp18514
VIt's most likely that the C long double actually mapped to a double and so without knowing more about the calculations I'd assume you were fine to use double in C#
p18515
aVIn my experience it's very rare to find a scientific or engineering calculation for which 64 bit double is not sufficient
p18516
aVThe only way to be 100% certain that double is sufficient would be to study the algorithm so this advice is based on instinct and experience alone
p18517
as(dp18518
g7
V505088
p18519
stp18520
a((dp18521
g2
(lp18522
VC# arrays cannot be resized
p18523
aVThis means that you can't insert items
p18524
aVYou have two options:
p18525
aVUse a  instead
p18526
aVCreate a new array, with one extra item in, copy the contents of the old one across and so on
p18527
aVOption 1 is invariably to be preferred
p18528
aVThere is
p18529
aVOn the face of it this contradicts what I state above
p18530
aVHowever, the documentation for this method states:
p18531
aVThis method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one
p18532
as(dp18533
g7
V505088
p18534
stp18535
a((dp18536
g2
(lp18537
VPython is not like C++, Java, C# etc
p18538
aVYou can do pretty much anything you like to anything
p18539
aVYou can't make anything private
p18540
aVYou can't enforce const-ness
p18541
aVThere are benefits and downsides to these aspects of Python, but it is the way it is
p18542
aVBecause so little can be checked statically, you need to very strong runtime tests for your code, with excellent coverage
p18543
aVWithout strong tests that have complete coverage, development in Python can become a little like herding cats
p18544
as(dp18545
g7
V505088
p18546
stp18547
a((dp18548
g2
(lp18549
VIn fact the limit on path strings is 260 characters
p18550
aVThe underlying OS, these days, can support much longer path names, up to  32,767 characters
p18551
aVIn order to name a path with a long name you need to use the magic  prefix, and use the Unicode version of the API
p18552
aVHowever, many tools don't support such long names
p18553
aVA classic example of such a tool is Explorer which won't let you create objects with names longer than 260 characters
p18554
aVBecause of this I strongly advise you to avoid creating such long names\u2014doing so will save you much heartache in the long run
p18555
as(dp18556
g7
V505088
p18557
stp18558
a((dp18559
g2
(lp18560
VOnce the program has been compiled, behaviour is defined
p18561
aVIf you want to detect undefined behaviour you need to start earlier in the toolchain
p18562
aVUndefined behaviour means that it is up to the compiler implementation to decide how to implement behaviour, the standard does not dictate what the behaviour must be
p18563
aVIn other words, it's only meaningful to ask about UB for source code rather than compiled code
p18564
as(dp18565
g7
V505088
p18566
stp18567
a((dp18568
g2
(lp18569
VIn addition to the excellent observation that Henning made, you may also be surprised by the output once you fix that problem
p18570
aVThe circular symmetry makes this a somewhat unusual sorting algorithm when compared with normal sorts on totally ordered domains
p18571
aVSince there is circular symmetry, there are n valid clockwise orderings, given n points and it may matter to you which of those orderings you prefer
p18572
aVAs it stands, use of atan2 unmodified will result in a cut-line with coordinates (x,0) where x<0
p18573
aVConsider coordinates A = (-10, 1) and B = (-10, -1), measured relative to the reference
p18574
aVYou probably imagine that A should appear before B in the result, but in fact it will be the other way around since atan2 returns just less than \u03c0 for A, but just more than -\u03c0 for B
p18575
aVIf you want a cut-line with coordinates (x,0) where x>0 simply add 2\u03c0 to any negative values returned from atan2
p18576
as(dp18577
g7
V505088
p18578
stp18579
a((dp18580
g2
(lp18581
V is not called automatically
p18582
aVThe compiler generates calls to  when you write , or call  directly
p18583
as(dp18584
g7
V505088
p18585
stp18586
a((dp18587
g2
(lp18588
VWell, the direct answer to your question is that you can call
p18589
aVHowever, it would be much better to address the root of the problem rather than suppress the symptoms
p18590
aVYour window is being ghosted because you aren't pumping the message queue
p18591
aVYou aren't doing that for the admirable reason that your application is busy doing work
p18592
aVThe accepted way to do work and keep your queue pumped, is to do the work in a separate thread
p18593
as(dp18594
g7
V505088
p18595
stp18596
a((dp18597
g2
(lp18598
VI'm not familiar with Prism but this looks like the WinForms button to me
p18599
aVIf so then you can call
p18600
aVnet events are much more complex than VCL events
p18601
aVMost significantly they are multi-cast which means that multiple handlers can be attached
p18602
aVOne consequence of this is that invoking events is much more complex
p18603
as(dp18604
g7
V505088
p18605
stp18606
a((dp18607
g2
(lp18608
VYou are passing an instance method
p18609
aVYou need to pass a plain function rather than a method bound to an instance
p18610
aVIt has to be declared like this:
p18611
aVPass the instance of the  to the  parameter of  and it will in turn be passed to your callback
p18612
aVLike this:
p18613
as(dp18614
g7
V505088
p18615
stp18616
a((dp18617
g2
(lp18618
VSomething like this:
p18619
aVTo call it, pass  as your initial guess for the  parameter
p18620
aVYou can easily make this fail with a stack overflow by passing in bad data, but you probably aren't going to be tested on that in this assignment
p18621
as(dp18622
g7
V505088
p18623
stp18624
a((dp18625
g2
(lp18626
VCall the  method on the dict
p18627
as(dp18628
g7
V505088
p18629
stp18630
a((dp18631
g2
(lp18632
VThe documentation for   explains that the   flag is not accepted by that function (although it is for
p18633
aVInstead it states:
p18634
aVTo set a file's compression state, use the DeviceIoControl function with the FSCTL_SET_COMPRESSION operation
p18635
aVThe FSCTL_SET_COMPRESSION link in particular explains precisely how to do it
p18636
aVIt goes something like this:
p18637
as(dp18638
g7
V505088
p18639
stp18640
a((dp18641
g2
(lp18642
VSince you have two processes you need a cross-process synchronisation object
p18643
aVI think this means that you need to use a mutex
p18644
as(dp18645
g7
V505088
p18646
stp18647
a((dp18648
g2
(lp18649
VIf you wish to write to keys under , you need an elevated process
p18650
aVThis is achieved by setting  to  in the application's manifest
p18651
aVMaking this change means that your application will present a UAC elevation dialog every time it runs
p18652
aVThis will no doubt be irritating and so here are some options of avoiding that irritation:
p18653
aVWrite to somewhere other than  where standard users have write access
p18654
aVPerform the writes to  in your install program
p18655
aVArrange that you elevate on demand if writing to  is only needed for occasionally used functionality in your program
p18656
aVOption 3 needs a little elaboration
p18657
aVYou can't elevate a process once it has started
p18658
aVYou can only elevate at process start time
p18659
aVSo in order to implement option 3, you need that functionality to exist in a separate process or out of process COM server
p18660
aVIf you go down this route remember to include the shield icon on any UI element that results in a UAC dialog
p18661
as(dp18662
g7
V505088
p18663
stp18664
a((dp18665
g2
(lp18666
V returns the memory to the system
p18667
aVIt is the partner operation to
p18668
aVEverything block of memory that you allocate with  should be returned to the system by calling
p18669
aVAfter you call  you are no longer allowed to access that memory
p18670
aVIt's generally considered wise to set the pointer to  after you have called , at least in debug builds, so that you can be sure that an error will be raised if you later attempt to dereference the pointer by mistake
p18671
aVSo, why can you still access memory that has been freed
p18672
aVWell, you can't reliably do so
p18673
aVIt just so happens that the implementation of most memory management systems mean that you can sometimes get away with such abuses
p18674
aVMany memory managers allocate large blocks of memory from the operating systems and then, in turn, allocate small sub-blocks to the application
p18675
aVWhen you call , the allocator returns that block back to its pool of readily available memory, but does not necessarily give the memory back to the OS, since OS memory allocation routines are typically expensive
p18676
aVHence accessing it may still appear to work, because the memory is still allocated in your process
p18677
aVIt's just that its now owned by the memory manager rather than by your app
p18678
aVSomething like that is happening to you here
p18679
aVOf course, sometimes you won't get away with abuses like this, most likely once you have deployed your software onto your most important client's machine
p18680
as(dp18681
g7
V505088
p18682
stp18683
a((dp18684
g2
(lp18685
VYou can't turn a
p18686
aVlnk file into an install program with uninstall instructions
p18687
aVYou need to write a simple installer if you want the application to appear in Window's list of installed programs, and be available for uninstall
p18688
aVThere are many very simple tools that will let you build an install package\u2014you should use one of these
p18689
as(dp18690
g7
V505088
p18691
stp18692
a((dp18693
g2
(lp18694
VMeasure the text first using
p18695
aVPass  to specify that word wrapping is enabled
p18696
aVThis will allow you to find the required height for your text
p18697
aVThen you can, in your code, calculate the vertical offset that gives you vertically centred text, and draw to that offset
p18698
as(dp18699
g7
V505088
p18700
stp18701
a((dp18702
g2
(lp18703
VWhen an action has no  handler, the action is always disabled
p18704
aVIf you want to assign an action to an object, and have that object be enabled, then you need to provide an  handler
p18705
aVThe question sounds a little odd though
p18706
aVWhy would you have a button which, when pressed, does nothing
p18707
aVDo you perhaps, have an  handler that is defined in the button rather than the action
p18708
aVIf so then you should simply move that handler into the action and all will be well
p18709
aVUpdate
p18710
aVUlrich helpfully points out that the  of  can be used to change the behaviour described above
p18711
aVSince this has public visibility and is not published, you have to make the change in code which is why I think I forgot about it
p18712
as(dp18713
g7
V505088
p18714
stp18715
a((dp18716
g2
(lp18717
VI don't believe that either  or  will operate the way you want
p18718
aVTherefore the possible solutions are:
p18719
aVOverride  as you suggest
p18720
aVOverride  and remove all empty sections at that point
p18721
as(dp18722
g7
V505088
p18723
stp18724
a((dp18725
g2
(lp18726
VI believe that you just need to add a  attribute:
p18727
aVand the default marshaller should do the rest for you
p18728
as(dp18729
g7
V505088
p18730
stp18731
a((dp18732
g2
(lp18733
V doesn't generate random numbers
p18734
aVIt's next sample is known deterministically from its state
p18735
aVFor a true random number generator, that was producing iid samples, then there previous value would of course have no bearing on the next value
p18736
aVThat's the independent part of iid
p18737
as(dp18738
g7
V505088
p18739
stp18740
a((dp18741
g2
(lp18742
VYou can't write to hardware registers in a managed language like C#
p18743
aVYou may need to use C or assembler
p18744
aVThe chip will probably come with a devkit and instructions on how to program it
p18745
as(dp18746
g7
V505088
p18747
stp18748
a((dp18749
g2
(lp18750
VYour problem is that you are passing an incorrect value for
p18751
aVYou are passing the number of bytes but you should be passing the number of characters,
p18752
aVThese values differ because a wide character has a size of 2 bytes
p18753
aVSo, yes there is an error in your code
p18754
aVIf the module name is sufficiently long, Windows will attempt to write up to 520 characters to a buffer that only has room for 260
p18755
as(dp18756
g7
V505088
p18757
stp18758
a((dp18759
g2
(lp18760
VYou can't use stdout redirection in the command line passed to
p18761
aVTo redirect stdout you need to specify a file handle for the output in the  structure
p18762
aVYou are also making another, more subtle, mistake
p18763
aVThe second parameter,  must point to writeable memory because  overwrites the buffer
p18764
aVIf you happen to be using the ANSI version of the function then you will get away with this, but not for the Unicode version
p18765
aVThe Unicode version of this function, CreateProcessW, can modify the contents of this string
p18766
aVTherefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string)
p18767
aVIf this parameter is a constant string, the function may cause an access violation
p18768
as(dp18769
g7
V505088
p18770
stp18771
a((dp18772
g2
(lp18773
VYes it's a bug
p18774
aVFor some reason the  property of the  is not being streamed correctly from the
p18775
aVdfm file when the edit resides in a frame
p18776
aVThe streaming is resulting in  being  instead of
p18777
aVThen, in  the following code executes:
p18778
aVThis is what is shifting the position of your button 2 pixels right and down
p18779
aVYou can work around the bug by manually setting Ctl3D in code and forcing  to be called again
p18780
aVI did this with an interposer:
p18781
aVYou can include this in your frame, but make sure that the declaration of the interposed  is before your frame is declared
p18782
aVOr if the bug afflicts many frames, declare it in a common unit and use that unit in your frame after you use
p18783
aVNow, as for the obvious question as to why the streaming doesn't set  correctly, I have no answer for that
p18784
aVPerhaps someone more knowledgeable than I am about form streaming could enlighten us
p18785
as(dp18786
g7
V505088
p18787
stp18788
a((dp18789
g2
(lp18790
VAll GUI code should be run from the main thread, and it looks like you are following that rule
p18791
aVIf you call  then the calling thread will not execute code until the timeout elapses
p18792
aVIf you call  from the main thread, then the message queue will not be pumped until the timeout elapses
p18793
aVHence the entire app appears frozen
p18794
aVWhy does calling  from one form affect another form
p18795
aVBecause all GUI components are served from the single message queue of the main thread
p18796
aVOnce you stop pumping that queue, all GUI components stop receiving queued messages like ,  etc
p18797
aVAs I understand it your problem is that your application appears hung when you are loading a 3MB text file into an edit control
p18798
aVThat size of file doesn't sound very large to me and one obvious solution would be to find an edit control that performs the load better
p18799
aVFor example I'm pretty sure that Notepad, Notepad++ etc
p18800
aVdo not take steps like showing progress when loading such files
p18801
aVI rather suspect that those apps don't pump the queue when loading files but you just don't notice because of the short time taken
p18802
aVWhat you don't want to happen is for you to pump your queue to keep your GUI responsive and in turn allow the user to start loading another file whilst the first one is still loading
p18803
aVYou need to disable your UI whilst processing a load operation
p18804
aVA modal progress dialog is one way to do that
p18805
aVIf you can't switch to a better performing control, you could show a modal progress dialog and use a background thread like this
p18806
aVThe background thread would have load the file in small chunks, say into a string list
p18807
aVAfter each chunk of the file was ready it would then call Synchronize and get the main thread to add the contents of the string list to the edit control, and then clear the string list
p18808
aVThe thread would then continue and load the next chunk
p18809
aVAdding to the edit control in small chunks would allow you to keep the message queue serviced
p18810
aVYou could show progress in a status bar rather than a modal dialog which would be less intrusive
p18811
aVBut just remember to disable any UI that would cause re-entrant execution
p18812
as(dp18813
g7
V505088
p18814
stp18815
a((dp18816
g2
(lp18817
VI assume you want the ordinal value rather than the enumerated value
p18818
aVYou get that with
p18819
aVSo,  is an integer expression with a value of  when  equals
p18820
as(dp18821
g7
V505088
p18822
stp18823
a((dp18824
g2
(lp18825
V is a tuple
p18826
aVWhen used on the left hand side of an assignment  it is equivalent to:
p18827
aVIn your example,  is equivalent to:
p18828
aVThis technique of writing a tuple on the left hand side of an assignment is known as tuple unpacking
p18829
as(dp18830
g7
V505088
p18831
stp18832
a((dp18833
g2
(lp18834
VBecause you are using Python 3 which is treating  as a Unicode string which ctypes encodes with UTF-16
p18835
aVBut you then cast it assuming it is a single byte ANSI string
p18836
aVYou can make the program behave the way you want by one of the following methods:
p18837
aVUse Python 2
p18838
aVx
p18839
aVCall  like so:
p18840
aVUse  in the case:
p18841
as(dp18842
g7
V505088
p18843
stp18844
a((dp18845
g2
(lp18846
V is a really
p18847
aVnet term and so is specific to MS C++/CLI
p18848
as(dp18849
g7
V505088
p18850
stp18851
a((dp18852
g2
(lp18853
VThe only thing wrong with the P/invoke is that you are using C#  which is 64 bits, but an  is only 32 bits
p18854
aVYou have matching calling conventions, default marshalling for managed  is  on the unmanaged side
p18855
aVMismatching return value size would not explain why your C# code receives a string message  so your main problem most likely lies in the code that you haven't shown us
p18856
as(dp18857
g7
V505088
p18858
stp18859
a((dp18860
g2
(lp18861
VIt looks like you are compiling a C header file in C++ and suffering from the C++ compiler mangling your names
p18862
aVThe DLL should export non-mangled names
p18863
aVTry wrapping the include of the header file in an  block
p18864
as(dp18865
g7
V505088
p18866
stp18867
a((dp18868
g2
(lp18869
VYou are trying to implement method overloading rather than inheritance and polymorphism
p18870
aVPython does not support overloading in the way that C++, Java, C# etc
p18871
aVdo
p18872
aVInstead, to achieve what you want in Python, you need to use optional parameters
p18873
as(dp18874
g7
V505088
p18875
stp18876
a((dp18877
g2
(lp18878
VThis problem is, in general, much harder than you think
p18879
aVNot all classes are laid out like that
p18880
aVSome won't have  sections and rely on the default visibility
p18881
aVSome might not have public sections
p18882
aVSome might have multiple  and/or  sections
p18883
aVHow will you know when the class declaration has finished
p18884
aVYou don't want to move code around from another class
p18885
aVSome classes might use macros which will throw you
p18886
aVAnd so on
p18887
aVTo do this properly and reliably you need a proper C++ parser which is notoriously hard to get right
p18888
aVDon't try to implement one of those yourself using simple text search
p18889
as(dp18890
g7
V505088
p18891
stp18892
a((dp18893
g2
(lp18894
VThere are no shared locations in the registry that can be written to without admin rights
p18895
aVSo your conditions 2 and 4 cannot both be fulfilled
p18896
aVYou need to do this with a file I believe
p18897
aVIf you are prepared to drop condition 4 then you need to store it under  so that it is shared
p18898
aVThe obvious place is
p18899
aVNaturally you would encrypt the data to avoid tampering
p18900
aVOnce you have done that then you don't really care whether or not your users discover it
p18901
as(dp18902
g7
V505088
p18903
stp18904
a((dp18905
g2
(lp18906
VI don't know what you mean about the  functions being no good
p18907
aVWhy not
p18908
aVDon't you have the feeling an ugly mistake was made when we were forced upon using 16-bit deficient W functions
p18909
aVShouldn't the problem have been recognized in a much earlier stage and let all original API functions take on UTF-8 strings and incorporate proper string manipulation routines
p18910
aVOr is that already possible and am I horribly mistaken
p18911
aVUTF-8 was developed well after the Windows Unicode interface was written
p18912
aVHad they added a UTF-8 version there would now be 3 versions of every function
p18913
aVI'm sure they would not use UTF-16 if they were to start again\u2014hindsight is truly wonderful
p18914
aVRegarding UTF-32, hardly any software uses that internally
p18915
aVI wouldn't recommend it, especially not on a platform which has no support for it whatsoever
p18916
aVUsing UTF-32 would just be creating work for yourself
p18917
as(dp18918
g7
V505088
p18919
stp18920
a((dp18921
g2
(lp18922
VYou'll have a very hard time doing this in Delphi 7
p18923
aVThe latest versions of Delphi have excellent support for PNG including transparency
p18924
aVI know it's not a simple answer to your question but I think it would be the best solution
p18925
as(dp18926
g7
V505088
p18927
stp18928
a((dp18929
g2
(lp18930
VIt's called the right margin
p18931
aVIt is intended as a guide to help you avoid writing lines that are too long and exceed your coding standards
p18932
aVYou can switch it off from the Editor Options, as I have done here:
p18933
as(dp18934
g7
V505088
p18935
stp18936
a((dp18937
g2
(lp18938
VProbably it translates to ref double or out double or double[]
p18939
aVWhich it should be depends on the semantics of the code
p18940
aVC++ double* can actually mean a number of things
p18941
aVIt's highly unlikely that unsafe code is needed
p18942
as(dp18943
g7
V505088
p18944
stp18945
a((dp18946
g2
(lp18947
VIn order to achieve this you would need the services MMC snap in to close and reopen its handle to the service control manager
p18948
aVIt won't do this and thus you have to accept the behaviour as is
p18949
as(dp18950
g7
V505088
p18951
stp18952
a((dp18953
g2
(lp18954
VThis is a Python list comprehension
p18955
aVIt forms the Cartesian product of splits and alphabets
p18956
aVEach item of splits is a tuple which is unpacked into a and b
p18957
aVEach item of alphabet is put into a variable called c
p18958
aVThen the 3 variables are concatenated, assuming that they are strings
p18959
aVThe result of the list comprehension expression is a list containing elements of the form a + c + b, one element for each item in the Cartesian product
p18960
aVIn Python it could be written equivalently as
p18961
aVIn Delphi it would be
p18962
aVI suggest you read up on Python list comprehensions to get a better understanding of this very powerful Python feature
p18963
as(dp18964
g7
V505088
p18965
stp18966
a((dp18967
g2
(lp18968
VCall  to get all the top level windows
p18969
aVThen call  to find out the window class name for each window
p18970
aVIf you also wish to probe child windows then call  on each top level window
p18971
aVCall GetClassName like this:
p18972
as(dp18973
g7
V505088
p18974
stp18975
a((dp18976
g2
(lp18977
VCurrency is not an IEEE754 float type and does not have NAN or INF values
p18978
aVThe documentation explains that Currency is implemented as a 64 bit integer with implicit scale of 10000 and that the range of possible values is -922337203685477
p18979
aV5808 to 922337203685477
p18980
aV5807
p18981
aVSince this covers the full range of a 64 bit integer it follows that there are no bit patterns available for sentinel values like NAN or INF
p18982
as(dp18983
g7
V505088
p18984
stp18985
a((dp18986
g2
(lp18987
VThere is nothing built in that allows dynamic arrays to be concatenated
p18988
aVYou may consider using one of the generic container classes found in Generics
p18989
aVCollections, TList
p18990
aVIn your case you would have 3 instances of TList, say A, B and C
p18991
aVThen you could write
p18992
aVI think this is as close as you can get to what you want with what is delivered out of the box
p18993
aVIf you are prepared to do a bit of coding yourself then you could make use of operator overloading to use the exact syntax you requires
p18994
aVDeclare a record containing an array of TPerson with private visibility
p18995
aVYou then need to implement an Add operator, a Count property and a default Items[] property
p18996
aVThis could be made generic too so you only need write it once
p18997
aVThis idea can be extended into a very powerful data structure as you see fit
p18998
as(dp18999
g7
V505088
p19000
stp19001
a((dp19002
g2
(lp19003
VIt sounds like you are looking for an asynchronous IPC mechanism
p19004
aVSockets are probably the easiest way to achieve this
p19005
aVPipes would be another obvious alternative, and there are many higher level libraries available, but I think sockets sound like the best fit
p19006
as(dp19007
g7
V505088
p19008
stp19009
a((dp19010
g2
(lp19011
VClipboard
p19012
aVHasFormat works fine
p19013
aVYour problem lies elsewhere
p19014
as(dp19015
g7
V505088
p19016
stp19017
a((dp19018
g2
(lp19019
VWhen you load a DLL the loader will load all the dependencies for you
p19020
aVThese dependencies are listed in the import tables of each DLL and the loader resolves them
p19021
aVYou don't need to do anything
p19022
aVTherefore I can't understand how you came to the conclusion that you yourself needed to process DLL dependencies
p19023
aVAre you loading this DLL in a non-standard way
p19024
aVDo you need a manifest for WinSxS dependencies, i
p19025
ag192
aVif the MS C runtime is needed
p19026
aVIs there something else we need to know
p19027
aVAll that said, having this DLL loaded into your process is not likely, in my view, to help much in extracting text from a different process which has its own separate virtual memory
p19028
aVIn other words, I am quite confident that your current attempt to extract the text will fail
p19029
aVThe way to get around the virtual memory barrier is to run your code in the other process using a hook
p19030
as(dp19031
g7
V505088
p19032
stp19033
a((dp19034
g2
(lp19035
VMy bet is that your call to GetLastError is returning an error code for an earlier API call unrelated to this routine
p19036
aVAs far as I can recall (no source at hand where I am) FileExists doesn't set error code
p19037
aVBut if the first call to FileExists fails then you go ahead and call GetLastError anyway
p19038
as(dp19039
g7
V505088
p19040
stp19041
a((dp19042
g2
(lp19043
VI'm not 100% sure this is what you mean, but I think you are referring to the GetSysColor setting for COLOR_HOTLIGHT
p19044
aVThis is described as:
p19045
aVColor for a hyperlink or a hot-tracked item
p19046
aVBut as you observe, themed painting doesn't use these settings
p19047
aVThe best way to match themed painting is to simply draw with the theme API and the appropriate color will be used
p19048
as(dp19049
g7
V505088
p19050
stp19051
a((dp19052
g2
(lp19053
VDelphi isn't the natural choice for writing an installer
p19054
aVInstead you should use one of the many products dedicated to creating install packages, e
p19055
ag217
aVInstallShield
p19056
aVInstallAware
p19057
aVNSIS
p19058
aVWiX
p19059
aVWise
p19060
aVInnoSetup
p19061
aVetc
p19062
aVOf these InnoSetup uses a Pascal variant as its scripting language and so is a very popular choice amongst Delphi developers
p19063
as(dp19064
g7
V505088
p19065
stp19066
a((dp19067
g2
(lp19068
VThe simplest approach to this, and fully general, is a finite element model using a lumped mass model
p19069
aVDiscretise the rubber band into nodes
p19070
aVInternal forces are weight and a spring force between each adjacent node
p19071
aVYou already know the external forces
p19072
aVSolve the static equilibrium equation with a non-linear solver
p19073
aVThis is acutally harder than dynamics because there is no inertia to help convergence
p19074
aVIf you need to solve the dynamic problem, the simplest approach is explicit integration, just naive forward Euler
p19075
aVMy business is in fact based on a software code that models this exact problem
p19076
aVIf you want to find out more, in general, search for dynamic finite element catenary solvers
p19077
as(dp19078
g7
V505088
p19079
stp19080
a((dp19081
g2
(lp19082
VI think you are trying to be too cute here
p19083
aVJust call SuspendThread/ResumeThread alternately on a timer
p19084
aVI know it's ugly, but you aren't going to enter your solution in any beauty pageant I suspect
p19085
as(dp19086
g7
V505088
p19087
stp19088
a((dp19089
g2
(lp19090
VYes that is possible
p19091
aVAccording to the details given here you can share desktops, regions or individual applications
p19092
aVIt sounds like regions is what you want to share
p19093
as(dp19094
g7
V505088
p19095
stp19096
a((dp19097
g2
(lp19098
VExecutive summary: encapsulate the song in a class
p19099
aVIt sounds to me like a song is a primary data type in your code and is worthy of having a dedicated class to represent it
p19100
aVBy all means use a dict internal to the class to store the data but try and move to a higher level of abstraction than a dict
p19101
aVYou should be aiming for this class to provide all the services needed to support the operations you perform on songs
p19102
aVHouse all the formatting code in the class so that it isn't scattered about your code that uses the song items
p19103
aVIndeed you will find all sorts of operations that want to become methods of this class
p19104
aVAs for the implementation of the formatting, it doesn't matter if it's a little long-winded since you write it in one place only
p19105
as(dp19106
g7
V505088
p19107
stp19108
a((dp19109
g2
(lp19110
VVariables don't change by themselves
p19111
aVIf a == b at one point in time then a == b for ever more until you modify a or b
p19112
aVYou may well have a problem related to representability in floating point data types, but it's not clear what the problem is
p19113
aVWhat is clear is that your current solution is almost certainly not a good idea
p19114
as(dp19115
g7
V505088
p19116
stp19117
a((dp19118
g2
(lp19119
VBecause typeOfState is  a variable rather than a type
p19120
aVThe as operator must be passed a type that is known at compile time
p19121
as(dp19122
g7
V505088
p19123
stp19124
a((dp19125
g2
(lp19126
VSince your records don't appear to be sorted by author you need to use linear search
p19127
aVAdapt your Show_All routine to achieve this, iterating through each record looking for the author
p19128
aVIf you have a large database then performance will be a problem and you should consider using a real database
p19129
as(dp19130
g7
V505088
p19131
stp19132
a((dp19133
g2
(lp19134
VSimply loop through the array in linear fashion
p19135
aVKeep a variable for the min value and one for the max values
p19136
aVInitialise both to the first value in the array
p19137
aVThen for each element, update the min or max value if that element is less than or greater than the min or max value respectively
p19138
aVObviously this code assumes Count>0
p19139
aVNote that you could equally use the MinValue and MaxValue routines from the Math unit
p19140
as(dp19141
g7
V505088
p19142
stp19143
a((dp19144
g2
(lp19145
VI recommend that you use the Microsoft resource compiler rc
p19146
aVAccording to the documentation for rc, the first token of a resource definition should be a name or a 16 bit integer
p19147
aVWhy brcc32 wants to interpret this as a real value is quite beyond me
p19148
aVIf this doesn't work try enclosing the GUID in quotes, " rather than '
p19149
as(dp19150
g7
V505088
p19151
stp19152
a((dp19153
g2
(lp19154
VYour code correctly assigns esi to p and then s
p19155
aVThus I can only assume your problem is not in fact related to this step
p19156
aVAs an aside I don't see why you need p, just assign esi directly to s
p19157
as(dp19158
g7
V505088
p19159
stp19160
a((dp19161
g2
(lp19162
VPackages are an easy solution but they have one huge drawback
p19163
aVUsing packages forces plugin authors to use not only Delphi, but the same version of the compiler as you do
p19164
aVI personally would prefer to expose the functionality of the app through a number of interfaces
p19165
aVThis allows accessibility from languages other than Delphi
p19166
aVTypically the plugin would be implemented in a DLL and would export a function that the app would call to pass in the root interface representing the app
p19167
aVThe plugin would then call methods of that interface thus establishing two-way interaction
p19168
as(dp19169
g7
V505088
p19170
stp19171
a((dp19172
g2
(lp19173
VIt's a generic container class whose elements have to be Book instances
p19174
aVThe key word is generic and every C# text book will cover this concept
p19175
as(dp19176
g7
V505088
p19177
stp19178
a((dp19179
g2
(lp19180
VMy guess, and guessing is all we can do, is that you have an uninitialised local variable
p19181
aVOr an object that you access after having freed it
p19182
aVI'm not sure how that leads to your stack overflow but almost anything is possible with such a scenario
p19183
aVAs well as madExcept you should be using FastMM with full debug settings
p19184
as(dp19185
g7
V505088
p19186
stp19187
a((dp19188
g2
(lp19189
VThis proposed approach is likely to fail in my view
p19190
aVUsing the shell verbs to print is going to invoke the associated applications to perform the printing
p19191
aVFor many of these file types, this will result in UI being displayed which will fail in a service
p19192
aVAll the file types you mention can be printed direct from your service without recourse to other applications
p19193
aVIt will require more coding but I believe it is the most viable solution for a service
p19194
aVAlternatively you could do this from a standard app running on an interactive desktop
p19195
aVThat should work fine and I presume you will be in control of the hardware and software configuration of the machines that run this code
p19196
aVOtherwise using shell verbs would be a terribly fragile and brittle approach-who knows what file associations are in place on a random customer's machine
p19197
as(dp19198
g7
V505088
p19199
stp19200
a((dp19201
g2
(lp19202
VIs the idiom you need
p19203
aVYour code is slow because it performs memory allocation and copying on every iteration
p19204
aVThis approach of pre-allocating the buffer avoids that
p19205
as(dp19206
g7
V505088
p19207
stp19208
a((dp19209
g2
(lp19210
VMy company solves that problem by giving all customers all features
p19211
aVThis keeps development simpler and allows us to spend more time working on improving the product and not have to spend time dealing with the complexities of optional features
p19212
aVWe sometimes meet mild resistance from clients who want a cheaper version with less functionality but that's never been a sales problem
p19213
aVOn the other hand if you sell clients cheaper less functional versions, they are liable to try to get away with these cheaper versions
p19214
aVThis can then lead to them not liking the software as much they should because they bought the cheap crippled version
p19215
aVI strongly believe in getting the best product possible to the user
p19216
aVThis advice may not be appropriate to your personal situation, but you did say that any opinions would be welcome
p19217
as(dp19218
g7
V505088
p19219
stp19220
a((dp19221
g2
(lp19222
VThe same problem could arise in any application that deals with text
p19223
aVHow to avoid it depends on what operations the application is performing and the question lacks specific details
p19224
aVMostly I think you'd solve such problems by normalizing the text
p19225
aVThis involves using a single preferred representation whenever you encounter ambiguity of encoding
p19226
as(dp19227
g7
V505088
p19228
stp19229
a((dp19230
g2
(lp19231
VI'm not sure if it's a bug or by design but I think you will get into trouble trying to overload based on different integer types
p19232
aVFor example, the compiler can't distinguish between integer literals, e
p19233
ag217
aVis 1 an integer or an int64 or a byte or a word or a shortint etc
p19234
aVIt could be any of those
p19235
aVWhilst the compiler can make rules to distinguish, I don't think they would be intuitive
p19236
aVIn your example, when you pass an integer variable, either routine could be called
p19237
aVI prefer to keep overloading to a minimum which you can do here by having just an int64 version
p19238
as(dp19239
g7
V505088
p19240
stp19241
a((dp19242
g2
(lp19243
VAn object does not have any knowledge, a priori, of which fields or variables refer to it
p19244
aVSo without more information you can't write such a function
p19245
aVIf your function knew which object had a reference to the column, then it could use RTTI to find its name
p19246
aVWithout RTTI you cannot hope to do this
p19247
aVI think the fundamental problem you are having is that, although you name the function GetFieldName, you are not passing a field
p19248
aVYou are passing an object reference
p19249
as(dp19250
g7
V505088
p19251
stp19252
a((dp19253
g2
(lp19254
VYour decision to use extern "C" is sound in my view because it allows access from other languages, compilers etc
p19255
aVBut doing so means you can't use namespaces so you simply must prefix your functions with something to identify them as being from your library, a poor man's namespace if you will
p19256
aVThis is the compromise you must make if you want to use extern "C"
p19257
as(dp19258
g7
V505088
p19259
stp19260
a((dp19261
g2
(lp19262
VIt is dangerous to stop threads pre-emptively
p19263
aVDoing so leads to deadlocks, resource leaks and so on
p19264
aVInstead you should use a cooperative signaling mechanism
p19265
aVSignal to the thread that you want it to stop, and then wait for it to do so
p19266
aVThe thread should regularly check whether it needs to stop and react accordingly
p19267
as(dp19268
g7
V505088
p19269
stp19270
a((dp19271
g2
(lp19272
VYou can just modify the class directly, sometimes known as monkey patching
p19273
aVI'm not 100% sure you can do this on a special class like str, but it's fine for your user-defined classes
p19274
aVUpdate
p19275
aVYou confirm in a comment my suspicion that this is not possible for a builtin like str
p19276
aVIn which case I believe there is no analogue to C# extension methods for such classes
p19277
aVFinally, the convenience of these methods, in both C# and Python, comes with an associated risk
p19278
aVUsing these techniques can make code more complex to understand and maintain
p19279
as(dp19280
g7
V505088
p19281
stp19282
a((dp19283
g2
(lp19284
VThis is C++/CLI which runs under
p19285
aVNET
p19286
aVYou need plain C++ for your Qt project, presumably
p19287
as(dp19288
g7
V505088
p19289
stp19290
a((dp19291
g2
(lp19292
VLet k = floor(b/a) and then n must equal either k or k+1
p19293
aVTry the 2 candidates and see which one wins
p19294
aVThis is O(1)
p19295
aVThat this is true follows from the fact that 1/(k+1) <= a/b <= 1/k which in turn follows from the inequalities k <= b/a <= k+1
p19296
as(dp19297
g7
V505088
p19298
stp19299
a((dp19300
g2
(lp19301
VIf a program in a hosted environment doesn't have a main then it's not C or C++, as per the standards
p19302
as(dp19303
g7
V505088
p19304
stp19305
a((dp19306
g2
(lp19307
VGet each thread, as the last thing it does, to signal that it is done
p19308
aVThat way there needs to be no waiting at all
p19309
aVEven better move to a higher level of abstraction, e
p19310
ag217
aVthreadpool and let someone else worry about such details
p19311
as(dp19312
g7
V505088
p19313
stp19314
a((dp19315
g2
(lp19316
VThis has all the hallmarks of a memory corruption
p19317
aVIt only appears when you run under a one particular environment, and occurs at a different location each time
p19318
aVBoth classic symptoms
p19319
aVThe best way I know to debug this is to download the full FastMM and run with full debugging options enabled
p19320
aVIf that doesn't help then you are reduced to removing parts of code, one by one, until you can isolate the problem
p19321
aVAnother problem I have seen in D2010 is a problem when mixing local class definitions (i
p19322
ag192
aVclass inside class) with generics
p19323
aVThe code generated is fine but the debug DCUs are wrong and when stepping through the code the debugger jumps to the wrong file and dies shortly after
p19324
aVYou don't seem to have quite the same problem but there are similarities in the IDE deaths
p19325
aVFinally I would advise you to suspect your own code rather than VMware
p19326
aVIt's always tempting to blame something else but in my experience, whenever I have done so, it was always my code in the end
p19327
as(dp19328
g7
V505088
p19329
stp19330
a((dp19331
g2
(lp19332
VDisclaimer: what is written below refers to the original version of the question before it was completely changed
p19333
aVIn the original version the floating point parameters were all float
p19334
aVI would urge Mike to post the real code using copy/paste in order to avoid wasting people's time
p19335
aVC float is equivalent to Delphi Single, the 4 byte floating point type
p19336
aVThat's the main problem you have
p19337
aVI personally would declare the arrays as PSingle or PInteger in the import declaration, rather than using var parameters
p19338
aVWhen passing single values by reference then var parameters is appropriate
p19339
aVWhen calling the function I wouldn't use fixed dimensioned arrays
p19340
aVI would use dynamic arrays and SetLength
p19341
aVPass the array then with PSingle(MyArray), or @MyArray[0], whichever you prefer
p19342
aVI would prefer Integer to Longint since I believe that Integer most closely matches C int
p19343
aVYour arrays are 1001 elements in size, you only need them to be 1000
p19344
aVThe struct is best passed by var as you have it in the import declaration, but not as you have it in the call
p19345
aVSince the code in your question doesn't quite match up I don't want to say anything more
p19346
as(dp19347
g7
V505088
p19348
stp19349
a((dp19350
g2
(lp19351
VRefactor your code so that it doesn't show at all until you are ready
p19352
aVEither refrain from calling Show, or set Visible to False if you have not yet done so
p19353
aVI suspect it's too late by the time you reach OnShow but even so doing it that way would be indicative of poor design
p19354
aVMoving code out of OnShow into a different method really should not be very much trouble at all
p19355
as(dp19356
g7
V505088
p19357
stp19358
a((dp19359
g2
(lp19360
VGiven everything else that happens at process startup, and how simple and elegant your existing code is, assuming you don't hash a gazillion types, I'd leave your existing solution exactly as it is
p19361
as(dp19362
g7
V505088
p19363
stp19364
a((dp19365
g2
(lp19366
VSomething like this:
p19367
as(dp19368
g7
V505088
p19369
stp19370
a((dp19371
g2
(lp19372
VWindows uses the two byte encoding UTF-16
p19373
aVYour problem is most likely that you are using single byte ANSI versions of whatever archive tool you are using
p19374
aVUntil you give more details of the code and tools you are using it's hard to give specific advice
p19375
aVHowever, the are no limitations on using the full range of Unicode characters in modern Windows file systems
p19376
as(dp19377
g7
V505088
p19378
stp19379
a((dp19380
g2
(lp19381
VMy guess is that you have declared the first parameter incorrectly in the C#
p19382
aVYou have declared it as ref IntPtr which is equivalent to EMI** in C++
p19383
aVBut I bet the C++ declaration, which you unfortunately did not include, reads EMI*
p19384
aVSo simply remove the ref and all should be well
p19385
aVI expect that emi_init does not read from the EMI parameter, i
p19386
ag192
aVit has out semantics
p19387
aVIn which case you don't need the StructureToPtr call before you call emi_init
p19388
as(dp19389
g7
V505088
p19390
stp19391
a((dp19392
g2
(lp19393
VThe fundamental problem is that this API was introduced in Vista and is not available in XP
p19394
aVThe whole point of the delayed keyword is to allow functions like this to be made available easily to developers who want to take advantage of newer API functions
p19395
aVBut to do so the developer typically must also provide fallback implementations for older OS versions, which DevExpress appear to have failed to do
p19396
aVThe bug is therefore not in UxTheme
p19397
aVpas, but in the DevExpress component that calls an API that is not implemented on the platform
p19398
aVThe fix is to re-work the DevExpress code to avoid calling this API on XP
p19399
aVI suggest you contact DevExpress who quite probably already have a fix in their latest versions
p19400
as(dp19401
g7
V505088
p19402
stp19403
a((dp19404
g2
(lp19405
VIf you wish to do this in place, without creating a new list, simply use a for loop with index running from len(map)-1 down to 0
p19406
aVNot very Pythonic, I admit
p19407
as(dp19408
g7
V505088
p19409
stp19410
a((dp19411
g2
(lp19412
VUTF-8 is not a subset of Latin-1
p19413
aVUTF-8 encodes ASCII with the same single bytes
p19414
aVFor all other code points, it's all multiple bytes
p19415
aVPut simply, \u005cxf1 is not valid UTF-8, as Python tells you
p19416
aV"Unexpected end of input" indicates that this byte marks the beginning of a multi-byte sequence which is not provided
p19417
aVI recommend you read up on UTF-8
p19418
as(dp19419
g7
V505088
p19420
stp19421
a((dp19422
g2
(lp19423
VI'd guess that you don't have sufficient rights to control services due to UAC
p19424
aVTry running as admininstrator, i
p19425
ag192
aVelevating your priviliges
p19426
as(dp19427
g7
V505088
p19428
stp19429
a((dp19430
g2
(lp19431
VI think your basic design is brittle and flawed
p19432
aVYou should not be deleting and creating services as part of normal service operation
p19433
aVWhat I would do would be to arrange that any service that needs updating in place was capable of doing it by itself
p19434
aVBasically put all the code that is subject to update in a DLL
p19435
aVThe code in the service EXE is just a thin host in charge of loading the main DLL and invoking it's main processing loop
p19436
aVWhen the EXE determines that it is time to update it downloads the new DLL, presumably checking via a hash that it downloaded correctly
p19437
aVNext the processing loop is terminated, the old DLL is unloaded, the new DLL is loaded and the processing loop started again
p19438
aVThis approach is much less intrusive and avoids all permission and rights issues
p19439
aVYou can write a single service host EXE and have multiple DLLs containing the logic
p19440
as(dp19441
g7
V505088
p19442
stp19443
a((dp19444
g2
(lp19445
VYou need SetProgressState and SetProgressValue from the ITaskbarList3 interface
p19446
aVFrom Java you could try BridJ
p19447
as(dp19448
g7
V505088
p19449
stp19450
a((dp19451
g2
(lp19452
VIt sounds to me as though you should be using a pthread condition variable as your signaling mechanism
p19453
aVThis takes care of all the issues you describe
p19454
as(dp19455
g7
V505088
p19456
stp19457
a((dp19458
g2
(lp19459
Vp is a local variable and typically resides on the stack
p19460
aVThe string is stored wherever the compiler decides to store it
p19461
aVTypically it will be in neither stack nor heap but rather in a read only area of the data segment of the executable image
p19462
as(dp19463
g7
V505088
p19464
stp19465
a((dp19466
g2
(lp19467
V refers to the array which has  elements of type
p19468
aVHence the output
p19469
aVThe code would be a lot easier to understand if you didn't overload the name
p19470
aVTechnically what you have here is a variable length array, a VLA
p19471
aVThis is because C  actually means read-only and has to be evaluated at run time
p19472
aVHence , in this case, is evaluated at runtime
p19473
aVIf you had used a literal to size your array instead, i
p19474
ag192
aVthen  would have been evaluated at compile time
p19475
aVIf the code had been compiled as C++ then the const would be a true const, and so available for evaluation at compile time
p19476
as(dp19477
g7
V505088
p19478
stp19479
a((dp19480
g2
(lp19481
VIt is perfectly valid for a statement to consist of just an expression
p19482
aVNothing is achieved by doing so in your examples, but it's perfectly valid all the same
p19483
as(dp19484
g7
V505088
p19485
stp19486
a((dp19487
g2
(lp19488
VBy default you need to have admin privileges to start, stop, install and delete services
p19489
aVYou will have to arrange for your service to expose its own Active property, distinct from what Windows terms as running
p19490
aVArrange that it is running in Windows terms all the time, but inert when its Active property is false
p19491
aVYou'll have to implement a control mechanism for your user app
p19492
aVI've done this with named pipes but the are other IPC methods available
p19493
as(dp19494
g7
V505088
p19495
stp19496
a((dp19497
g2
(lp19498
VYour problem is that you aren't using the sorted index in all access of Sol_list
p19499
aVThis one is wrong:
p19500
aVIt should say:
p19501
as(dp19502
g7
V505088
p19503
stp19504
a((dp19505
g2
(lp19506
s(dp19507
g7
V505088
p19508
stp19509
a((dp19510
g2
(lp19511
VRaymond Chen gives the full gory details here: http://blogs
p19512
aVmsdn
p19513
aVcom/b/oldnewthing/archive/2007/10/08/5351207
p19514
aVaspx
p19515
as(dp19516
g7
V505088
p19517
stp19518
a((dp19519
g2
(lp19520
VI find it hard to see any benefit with this
p19521
aVI can see plenty of problems:
p19522
aVNo type checking across a DLL boundary
p19523
aVAny version mismatches will result in runtime failures, harder to detect than compile time failures
p19524
aVExtra deployment headaches
p19525
aVYou may be tempted to update some but not all modules and so deal with complex dependencies
p19526
aVAll clients that want to use these DLLs must use the same compiler
p19527
aVOnly make this change if you can identify benefits that outweigh the negatives
p19528
as(dp19529
g7
V505088
p19530
stp19531
a((dp19532
g2
(lp19533
VGenerally, good solutions to problems with sleep() involve stopping using sleep()
p19534
aVBlocking the UI thread is always a very bad idea
p19535
aVIt makes you application's UI non-responsive
p19536
aVIn your case you want an event to run every second
p19537
aVThe correct way to implement that is with a timer
p19538
as(dp19539
g7
V505088
p19540
stp19541
a((dp19542
g2
(lp19543
VUse ctypes
p19544
aVAnd similarly with ShutdownBlockReasonDestroy
p19545
as(dp19546
g7
V505088
p19547
stp19548
a((dp19549
g2
(lp19550
VWhat you are describing is called hot-tracking and is performed for flat style toolbars
p19551
aVIf you want to disable it then remove the TBSTYLE_FLAT style
p19552
as(dp19553
g7
V505088
p19554
stp19555
a((dp19556
g2
(lp19557
VSince you are running on a 64 bit system, and you haven't signed the driver, the most likely explanation for error 1275 is that Windows blocked the driver due to it being unsigned
p19558
as(dp19559
g7
V505088
p19560
stp19561
a((dp19562
g2
(lp19563
VWhat you have done there is stream the reference, i
p19564
ag192
aVa pointer
p19565
aVWhat you need to stream is the contents
p19566
aVYou can that with SaveToFile and LoadFromFile
p19567
aVRegarding your update, assign s
p19568
aVSize to a local variable of type Integer and then use WriteBuffer to save it
p19569
aVIn reverse, use ReadBuffer to read into a local variable
p19570
aVIf I were you I would write direct to the file and avoid the memory streak
p19571
aVUse the Position property of TStream to seek around the file
p19572
aVSo write 0 for then length, write the graphic, seek back to the beginning and write the true length accounting for the 4 bytes of the length
p19573
as(dp19574
g7
V505088
p19575
stp19576
a((dp19577
g2
(lp19578
VCreate a hidden window and use it to listen for WM_DEVICECHANGE messages
p19579
aVWhatever you do, don't poll
p19580
aVThat's horribly wasteful and inefficient
p19581
as(dp19582
g7
V505088
p19583
stp19584
a((dp19585
g2
(lp19586
VThe object that owns the object should free it
p19587
aVTypically the object that creates it is the owner
p19588
aVThat's the case in 99% or more of situations
p19589
aVSometimes ownership is transferred to another object and when that happens it is the responsibility of the new owner to free the object
p19590
aVAlthough I would point out that in your example, it doesn't matter what you put in Destroy since it will never be called - you forgot to mark it with the override directive
p19591
as(dp19592
g7
V505088
p19593
stp19594
a((dp19595
g2
(lp19596
VOnce the try/finally is entered, the finally block will execute before execution leaves the try/finally
p19597
as(dp19598
g7
V505088
p19599
stp19600
a((dp19601
g2
(lp19602
VYou are correct
p19603
aVWhen you write s1 := s2 with two string variables, there is one string in memory with (at least two) references to it
p19604
aVYou also ask whether trying to reduce the number of strings in memory is a good idea
p19605
aVThat depends on how many strings you have in comparison to other memory consuming objects
p19606
aVOnly you can really answer that
p19607
as(dp19608
g7
V505088
p19609
stp19610
a((dp19611
g2
(lp19612
VFor what it's worth, answering the direct question, IFileOpenDialog is not available in XP which is why it failed
p19613
aVThe equivalent API for XP is GetOpenFileName
p19614
as(dp19615
g7
V505088
p19616
stp19617
a((dp19618
g2
(lp19619
VYou are probably falling foul of registry redirection
p19620
aVPerhaps you have a 32 bit process on a 64 bit system and writes to HKLM\u005cSoftware get redirected to HKLM\u005cSoftware\u005cWow6432Node
p19621
aVYou need to open the 64 bit key directly, or compile for AnyCPU
p19622
as(dp19623
g7
V505088
p19624
stp19625
a((dp19626
g2
(lp19627
VThere is no equivalent since the ImageIndex property for list views has no analogue for list boxes (unless you implement it yourself and custom draw)
p19628
as(dp19629
g7
V505088
p19630
stp19631
a((dp19632
g2
(lp19633
VYou don't want to wait for 1 second or indeed any length of time
p19634
aVYou cannot predict how long the other thread will run
p19635
aVWhat you want to do is to wait for the other thread to complete
p19636
aVAll threading libraries have methods for doing this sort of synchronization
p19637
aVIn Windows you use WaitForSingleObject, in pthreads you call pthread_join and so on
p19638
aVThese functions will block execution until the other thread has completed its work, exactly what you need
p19639
as(dp19640
g7
V505088
p19641
stp19642
a((dp19643
g2
(lp19644
VPut loader
p19645
aVexe somewhere in the search path, or provide the full path
p19646
aVThat is how to avoid this file not found error
p19647
aVWindows error codes are all documented on MSDN
p19648
as(dp19649
g7
V505088
p19650
stp19651
a((dp19652
g2
(lp19653
VYou've got a circular reference
p19654
aVYou import module a which then imports module b
p19655
aVBut module b imports function a from module a
p19656
aVBut at the time it tries to do so, a has not been defined
p19657
aVRemember that Python import effectively executes the module
p19658
aVThe solution would appear to be to move the function definitions so that they appear before the imports
p19659
aVOr, as @lazyr suggests, move the import statements to be inside the functions so that the import happens when the function is called, not at module import time
p19660
as(dp19661
g7
V505088
p19662
stp19663
a((dp19664
g2
(lp19665
VIf you export memory allocated with malloc, it needs to be freed with free from the same runtime as the malloc
p19666
aVYou could export free from your DLL but that may not be the most elegant solution
p19667
aVMarshal
p19668
aVFreeCoTaskMem is for use on memory allocated by the COM allocated
p19669
aVSo you would use this in managed code to free memory allocated by an unmanaged call to CoTaskMemAlloc
p19670
aVThis is a good solution to your problem
p19671
aVAnother answer suggests freeing memory with Marshal
p19672
aVFreeHGlobal which will work provided it was allocated with GlobalAlloc
p19673
aVThis is a rather tiresome API to use and I would always prefer the COM allocator for its convenience
p19674
aVIf you are exporting strings consider using a BSTR which is allocated by the COM allocator and can be marshalled automatically by the
p19675
aVnet marshaller
p19676
as(dp19677
g7
V505088
p19678
stp19679
a((dp19680
g2
(lp19681
VNo you cannot do this
p19682
aVThe other direction is possuble through an emulator, e
p19683
ag217
aVon Windows it is called WOW64
p19684
aVIt is standard practise on platforms that still have large install base of the 32 versions of the OS to ship either just a 32 bit version, or both 32 and 64 bit versions
p19685
as(dp19686
g7
V505088
p19687
stp19688
a((dp19689
g2
(lp19690
VSet each form's Scaled property to true
p19691
aVEach form will be resized according to the font scaling prevailing on the machine which shows the form
p19692
as(dp19693
g7
V505088
p19694
stp19695
a((dp19696
g2
(lp19697
VRather than round the value, which you may not want to do, you can do the rounding just as part of the output formatting:
p19698
as(dp19699
g7
V505088
p19700
stp19701
a((dp19702
g2
(lp19703
VFastMM with full debug will notify you when your code accesses an object after it has been freed
p19704
aVObviously you can't ship with that setting on, but switch it on when you run your test suite and such bugs will be flushed into open sight
p19705
as(dp19706
g7
V505088
p19707
stp19708
a((dp19709
g2
(lp19710
VInheritance is for when you need to inherit implementation
p19711
aVOtherwise, if you want to inherit interface, bit not implementation, uses interfaces
p19712
as(dp19713
g7
V505088
p19714
stp19715
a((dp19716
g2
(lp19717
VEvery client of the vtable needs to know the correct order so that they can find the right method to call
p19718
aVBut so long as all parties agree on the order, it doesn't matter what that order is
p19719
as(dp19720
g7
V505088
p19721
stp19722
a((dp19723
g2
(lp19724
VThis appears to be a heap corruption, just as the message says
p19725
aVThey aren't too easy to track down
p19726
aVYour best bet is to use a memory profiling tool to help find the cause
p19727
as(dp19728
g7
V505088
p19729
stp19730
a((dp19731
g2
(lp19732
VClearly, as you found, it's essential to zero-terminate your input data
p19733
aVRegarding the final paragraph, I would convert from wide to UTF8 and call PyUnicode_FromString
p19734
aVNote that I am assuming you are using Python 2
p19735
aVx, it's presumably all different in Python 3
p19736
ag18839
as(dp19737
g7
V505088
p19738
stp19739
a((dp19740
g2
(lp19741
VMy guess is that you have a letter case error in the real code
p19742
aVYou define Number but print number, or vice versa
p19743
aVNames in Python are case sensitive
p19744
aVOr perhaps you have code in a function which tries to access number which was declared outside the function
p19745
aVWithout seeing your actual code it's hard to say and we have to guess
p19746
as(dp19747
g7
V505088
p19748
stp19749
a((dp19750
g2
(lp19751
VYou need to declare a character array, i
p19752
ag192
aVchar filename[260]
p19753
as(dp19754
g7
V505088
p19755
stp19756
a((dp19757
g2
(lp19758
VNote: This answer addresses the following question
p19759
aVIs it possible to get source line number at runtime in Delphi
p19760
aVYou can't do this without a map file or something equivalent
p19761
aVThe process of compilation leaves the source code behind
p19762
aVIt's not practical to litter your source code with pre-emptive checks for errors
p19763
aVWhat's more, doing so will only give you very limited information for a very limited number of faults in your code
p19764
aVGenerally, if you can anticipate an error, you won't get it wrong
p19765
aVIt's the errors that you don't anticipate that make it into production code
p19766
aVReally you are best off using madExcept, EurekaLog or JclDebug
p19767
as(dp19768
g7
V505088
p19769
stp19770
a((dp19771
g2
(lp19772
VUpdate
p19773
aVThe solution offered by @TOndrej is far superior to what I wrote below, apart from one situation
p19774
aVIf you need to take runtime decisions as to what class to create, then the approach below appears to be the optimal solution
p19775
aVI've refreshed my memory of my own code base which also deals with this exact problem
p19776
aVMy conclusion is that what you are attempting to achieve is impossible
p19777
aVI'd be delighted to be proved wrong if anyone wants to rise to the challenge
p19778
aVMy workaround is for the generic class to contain a field  which is of type
p19779
aVThen I can call my virtual constructor with
p19780
aVI test that  in an assertion
p19781
aVIt's all depressingly non-generic
p19782
aVAs I said, if anyone can prove my belief wrong I will upvote, delete, and rejoice
p19783
aVIn your setting the workaround might look like this:
p19784
aVAnother more elegant solution, if it is possible, is to use a parameterless constructor and pass in the extra information in a virtual method of , perhaps called
p19785
as(dp19786
g7
V505088
p19787
stp19788
a((dp19789
g2
(lp19790
VIf your existing code was appropriate before the new standard, then it will continue to be
p19791
aVThe new random number generators were added for applications which require a higher quality of pseudo-randomness, e
p19792
ag217
aVstochastic simulation
p19793
as(dp19794
g7
V505088
p19795
stp19796
a((dp19797
g2
(lp19798
VYou can do this in C so long as you use a C99 compiler
p19799
aVThe restriction was lifted in C99
p19800
aVPresumably the restriction was originally there because compilers were less capable, or perhaps simply because nobody thought of allowing such a convenience for the programmer
p19801
aVWhen answering a question like this it is sometimes worth turning it around
p19802
aVWhy would the original designers of C have done it the other way
p19803
aVThey didn't have C++ to guide them
p19804
as(dp19805
g7
V505088
p19806
stp19807
a((dp19808
g2
(lp19809
VThe library becomes part of the process when it is loaded
p19810
aVRegarding tidy up of memory, handles, resources etc
p19811
aV, the system doesn't distinguish whether they were created in the executable image or the library
p19812
as(dp19813
g7
V505088
p19814
stp19815
a((dp19816
g2
(lp19817
VI would implement this with a for loop over an  variable
p19818
aVUsing integers avoids rounding problems due to the limitations of floating point arithmetic
p19819
aV[See What Every Computer Scientist Should Know About Floating-Point Arithmetic
p19820
aVLet  run from  to  and set  equal to
p19821
aVThe value of  can be found by rounding  to the nearest int
p19822
aVMajor axis updates can be handled in a similar way
p19823
aVRound  to the nearest , say
p19824
aVThen update major axis marks every k-th iteration
p19825
aVIn terms of code it looks like this:
p19826
as(dp19827
g7
V505088
p19828
stp19829
a((dp19830
g2
(lp19831
VIf you want software implemented memory protection, then you will need support from your compiler and its associated libraries
p19832
aVI expect that there is one compiler only on this platform and so you should contact the vendor
p19833
aVI wouldn't hold out much hope for a positive response
p19834
aVEven if they had such tools, I would expect the performance of software memory protection to be unacceptable
p19835
as(dp19836
g7
V505088
p19837
stp19838
a((dp19839
g2
(lp19840
VYou would be far better of using a programmatic interface linked to your application
p19841
aVFor example look at the following questions for some pointers:
p19842
aVHow to play MP3 files in C
p19843
aVHow to play mp3 file in c++
p19844
aVPlaying sounds with C++
p19845
aVTrying to control mp3 player apps in different processes is akin to herding cats
p19846
as(dp19847
g7
V505088
p19848
stp19849
a((dp19850
g2
(lp19851
VTo output Unicode text on Windows you need to encode it in UTF-16 and call the wide character version of the  or  Win32 functions
p19852
aVIn case you aren't familiar, the Windows API is natively UTF-16 and has parallel 8 bit ANSI versions for legacy support
p19853
aVI know nothing of the Win32 wrapper you are using but rather suspect that  is calling the ANSI version of whichever one of these Win32 functions is doing the work
p19854
aVYour solution will likely involve finding a way to invoke  or
p19855
aVYou could do it with ctypes, and these functions must surely be available through PyWin32 also
p19856
aVHowever, I would probably opt for something higher level, like PyQt
p19857
as(dp19858
g7
V505088
p19859
stp19860
a((dp19861
g2
(lp19862
VYou need to escape special characters with a
p19863
aVFor example, to search for  escape it like this,
p19864
aVSo your regex match becomes:
p19865
aVThe following characters all have special meaning in regex and need to be escaped if you want them to be interpreted literally:
p19866
as(dp19867
g7
V505088
p19868
stp19869
a((dp19870
g2
(lp19871
VFirst of all I recommend you read Marco Cant's whitepaper on Unicode in Delphi
p19872
aVI am also assuming from your question (and previous questions), that you are using a Unicode version of Delphi, i
p19873
ag192
aVD2009 or later
p19874
aVYou can first of all define an AnsiString with codepage 1251 to match your input data
p19875
aVThis is an important step
p19876
aVIt says that any data contained inside a variable of this type is to be interpreted as having been encoded using the 1251 codepage
p19877
aVThis allows Delphi to perform correct conversions to other string types, as we will see later
p19878
aVNext copy your input data into a string of this variable
p19879
aVOf course, there may be other, more convenient ways to get the data in
p19880
aVPerhaps it comes from a stream
p19881
aVWhatever the case, make sure you do it with something equivalent to a memory copy so that you don't invoke code page conversions and thus lose the 1251 encoding
p19882
aVFinally you can simply assign a  to a plain Unicode  variable and the Delphi runtime performs the necessary conversion automatically
p19883
aVThe runtime is able to perform this conversion because you specified the codepage when defining  and because  maps to  which is encoded with UTF-16
p19884
as(dp19885
g7
V505088
p19886
stp19887
a((dp19888
g2
(lp19889
VPEP 3114 renamed  to
p19890
aVThis was implemented in version 3
p19891
ag9193
aVThe link above contains all the gory details
p19892
as(dp19893
g7
V505088
p19894
stp19895
a((dp19896
g2
(lp19897
VFirst of all, according to the language standards, volatile doesn't do what the article says it does
p19898
aVThe acquire and release semantics of volatile are MSVC specific
p19899
aVThis can be a problem if you compile with other compilers or on other platforms
p19900
aVC++11 introduces language supported atomic variables which will hopefully, in due course, finally put an end to the (mis-)use of volatile as a threading construct
p19901
aVCritical sections and mutexes are indeed implemented so that reads and writes of protected variables will be seen correctly from all threads
p19902
aVI think the best way to think of critical sections and mutexes (locks) is as devices to bring about serialization
p19903
aVThat is, blocks of code protected by such locks are executed serially, one after another without overlap
p19904
aVThe serialization applies to memory access also
p19905
aVThere can be no problems due to cache coherence or read/write reordering
p19906
aVInterlocked functions are implemented using hardware based locks on the memory bus
p19907
aVThese functions are used by lock free algorithms
p19908
aVWhat this means is that they don't use heavy weight locks like critical sections, but rather these light weight hardware locks
p19909
aVLock free algorithms can be more efficient than those based on locks, but lock free algorithms can be very much harder to write correctly
p19910
aVPrefer critical sections over lock free unless the performance implications are discernable
p19911
aVAnother article well worth reading is The "Double-Checked Locking is Broken" Declaration
p19912
as(dp19913
g7
V505088
p19914
stp19915
a((dp19916
g2
(lp19917
VSurely the correct approach here is to include the header file and use
p19918
aVI assume that you have not included the Python C API header file because you don't want to use implicit linking
p19919
aVBut you are making life hard for yourself by trying to work without the header file
p19920
aVJust because you include the header file, doesn't mean that the DLL functions will be implicitly linked to your program
p19921
aVThis will only happen if you actually call some of the functions in the DLL
p19922
aVIf you want to be 100% sure that you don't implicitly link to the DLL then simply ensure that you don't link the
p19923
aVlib file
p19924
as(dp19925
g7
V505088
p19926
stp19927
a((dp19928
g2
(lp19929
VMarshal
p19930
aVPtrToStringAnsi and Marshal
p19931
aVPtrToStringUni are what you are looking for
p19932
aVThe Marshall class contains lots of other methods for performing similar native/managed marshalling tasks
p19933
as(dp19934
g7
V505088
p19935
stp19936
a((dp19937
g2
(lp19938
VThese are also known as multi-cast events and Allen Bauer wrote a nice article titled Multicast events using generics giving good coverage of the topic
p19939
aVIn short, multi-cast events are not baked into the language/framework like in Java C#, but can be simulated with some extra work
p19940
aVThe introduction of generics has made this somewhat simpler
p19941
as(dp19942
g7
V505088
p19943
stp19944
a((dp19945
g2
(lp19946
VEasy:
p19947
aVYou just need to make sure that you don't access the Data parameter from inside , but presumably that's what the 0 size parameter is for
p19948
aVTo my mind this is the best solution because it very explicitly states that you are passing something that cannot be accessed
p19949
as(dp19950
g7
V505088
p19951
stp19952
a((dp19953
g2
(lp19954
VAndroid is Linux based and so presumably uses UTF-8
p19955
aVOn the other hand, Android is also very Java-like and so possibly prefers UTF-16
p19956
aVIf you need the file to be UTF-8, you can do it like this, assuming you have your text in a
p19957
aVThis will include a BOM in the file which I imagine Android won't like\u2014Windows UTF-8 apps tend to use BOMs, but not Linux
p19958
aVIf you want to output without a BOM do it like this:
p19959
aVIf you discover you need UTF-16 then use  for UTF-16LE or  for UTF-16BE
p19960
aVIf you need to strip the BOM then that's easy enough with the same technique as above
p19961
aVSummary
p19962
aVWork out what encoding you need, and its endianness
p19963
aVFind an appropriate
p19964
aVUse  with that  instance
p19965
as(dp19966
g7
V505088
p19967
stp19968
a((dp19969
g2
(lp19970
Vis bitwise OR
p19971
aVis bitwise AND
p19972
aVis bitwise shift
p19973
aVis modulus
p19974
aVformat string prints an integer
p19975
as(dp19976
g7
V505088
p19977
stp19978
a((dp19979
g2
(lp19980
VI have a strong preference for option 1
p19981
aVDoing it this way allows you to keep the images in your revision control repository in their native format
p19982
aVWith option 2 you store images in
p19983
aVdfm files which I find exceedingly unsatisfactory
p19984
aVThe downside is that you lose design time viewing of the images
p19985
aVI personally prefer to make that trade-off
p19986
aVIn my software I have a single global image list which I populate at runtime by loading from resources, and of course also assign image indices at runtime
p19987
aVThe other benefit that this brings is the ability to choose image sizes appropriate to font scaling
p19988
aVOtherwise you need to have separate image lists for 16px icons, 20px icons, 24px icons, 32px icons etc
p19989
as(dp19990
g7
V505088
p19991
stp19992
a((dp19993
g2
(lp19994
VI'm guessing a little, but I suspect you need to call  passing the  flag to suppress this dialog appearing
p19995
aVInstead  will return a failure code and you can move on to the next drive in the enumeration
p19996
aVEdit:  For Windows 7 and up, consider  instead
p19997
aVThat limits the effect of the mode
p19998
aVAlso remember to restore the original mode as soon as possible
p19999
as(dp20000
g7
V505088
p20001
stp20002
a((dp20003
g2
(lp20004
VThis is what is happening:
p20005
aVThe  block is not being entered
p20006
aVThe  variable is not defined
p20007
aVYou then attempt to refer to the  variable in the  statement
p20008
aVAs to how to fix it, that's really for you to decide
p20009
aVWhat the fix is depends on what you want your code to do in case the request method is not
p20010
as(dp20011
g7
V505088
p20012
stp20013
a((dp20014
g2
(lp20015
VThe 256px sized icon should be a compressed PNG icon
p20016
aVI suspect that the resource compiler shipped with Delphi 2007 won't like that format so you'll need to use the MS resource compiler, rc
p20017
aVThe icon should be named
p20018
aVThat said, I suspect that a 256px bitmap will work, it will just be exceedingly large
p20019
aVWhat's more, IIRC, the Delphi IDE doesn't like 256px PNG icons so it's no good adding the icon to the project through the IDE
p20020
aVYou need to build the
p20021
aVres file yourself and link it with a  directive
p20022
aVFinally, its possible that your
p20023
aVico file may not be correct
p20024
aVThe 256px image is actually stored with width and height equal to 0 because that field is byte sized and 0 was formerly invalid
p20025
aVPerhaps this is what the IDE gags on
p20026
aVCheck the
p20027
aVico file out in a different tool, e
p20028
ag217
aVIcoFX
p20029
aVThere may be other problems\u2014these are just the ones I can recall encountering over the years
p20030
aVIf I had to guess as to which issue was biting you, I'd say it was the inability of the IDE to handle 256px icons
p20031
aVI believe that the IDE has got progressively better in this area in more recent versions, but even in D2010 which I currently use, it's not perfect
p20032
as(dp20033
g7
V505088
p20034
stp20035
a((dp20036
g2
(lp20037
VI always install the Active State Python distro which installs the win32 packages for you and gets it right
p20038
as(dp20039
g7
V505088
p20040
stp20041
a((dp20042
g2
(lp20043
VNot all programs use separate windowed controls for all their logical children
p20044
aVMostly this depends on the GUI framework used
p20045
aVAs an extreme example, Qt uses a single window for each top-level window
p20046
aVIt then paints all the widgets on the form from the form's WM_PAINT message handler
p20047
aVPrograms that take this approach are typically impossible to automate through generic methods
p20048
aVIt sounds like you have encountered an application that uses some windowed controls but also uses custom controls with a single window for what appears to be multiple widgets
p20049
aVAgain this is quite common
p20050
as(dp20051
g7
V505088
p20052
stp20053
a((dp20054
g2
(lp20055
VRaymond Chen from the Windows shell team discusses this in a blog article
p20056
aVIn short there is no documented, supported way to do this on XP
p20057
aVYou'll need to continue using the hack you've found
p20058
aVIn Vista you can use ITrayDeskBand
p20059
aVWindows 7 task bar is, of course, different again
p20060
aVRaymond also points out that programs should not be changing the user's choice of visibility for the Quick Launch bar
p20061
aVThat's not something a program should be doing
p20062
aVWhether
p20063
aVthe Quick Launch bar is shown or hidden is an end user
p20064
aVsetting, and programs should not be overriding the user's
p20065
aVpreferences
p20066
aVExplorer consciously does not expose an
p20067
aVinterface for showing and hiding taskbar bands because it
p20068
aVwould just be a target for abuse
p20069
aVMuch like the program that wants to uninstall other programs, the taskbar would become a battleground among programs that each wanted
p20070
aVto force themselves on and force their opponents off
p20071
aVThe user is the arbiter of what goes into the Taskbar
p20072
as(dp20073
g7
V505088
p20074
stp20075
a((dp20076
g2
(lp20077
VYou need to use a different format specifier to indicate that your integer is 64 bits wide
p20078
aVAs it stands, your code interprets the input as a 32 bit integer
p20079
aVIn MSVC this would be , on some platforms it would be  and there are indeed other specifiers
p20080
aVIn summary, you need to choose a specifier appropriate for your particular toolset
p20081
as(dp20082
g7
V505088
p20083
stp20084
a((dp20085
g2
(lp20086
VYou are passing  by
p20087
aVThis has in/out semantics
p20088
aVIn other words, the protocol is that recipient can expect the object to have been initialised, which you did not do
p20089
aVIt seems as though you simply want  semantics
p20090
aVChange  to use  rather than  for , and also change the calling code to use
p20091
aVNote that when you pass using , the callee is not allowed to read until the object has been initialized
p20092
aVThe callee also has the responsibility of performing that inialization before returning
p20093
as(dp20094
g7
V505088
p20095
stp20096
a((dp20097
g2
(lp20098
V is a macro defined in the Windows header files
p20099
aVYou need to  to gain access to it
p20100
aVHans's comment is spot on
p20101
aVIf you have  and  then presumably you have
p20102
aVIn which case the lack of the macro is presumably because the architecture conditional has not been defined
p20103
as(dp20104
g7
V505088
p20105
stp20106
a((dp20107
g2
(lp20108
VThe optimal alignment for a struct is equal to the largest alignment for any of the struct's members
p20109
aVIn this case that is 4
p20110
aVUpdate
p20111
aVThe above assumes that the primary operation you perform on the struct is accessing its members
p20112
aVSee the comments to Necrolis's answer for more discussion
p20113
aVIn short I suspect that the real answer to your question depends strongly on the hardware involved and the algorithms you are using
p20114
as(dp20115
g7
V505088
p20116
stp20117
a((dp20118
g2
(lp20119
VYou must not include type declarations at the call site
p20120
aVInstead it should read something like this:
p20121
as(dp20122
g7
V505088
p20123
stp20124
a((dp20125
g2
(lp20126
VTypes are fixed at compile time in Delphi\u2014it is, after all, a statically typed language
p20127
aVYou can, at compile time, define subranges of an enumeration:
p20128
as(dp20129
g7
V505088
p20130
stp20131
a((dp20132
g2
(lp20133
VIf you really do want the square of the magnitude of the vector then that's not possible
p20134
aVThat really is an overflow
p20135
aVIf you actually want the magnitude, then you can avoid the overflow like this:
p20136
aVIn my experience, using the inefficient, non-standard  type rather than  is usually indicative of a problem with your algorithm
p20137
aVInvariably there is a way to express the algorithm using  arithmetic
p20138
as(dp20139
g7
V505088
p20140
stp20141
a((dp20142
g2
(lp20143
VC++ code can be compiled quite happily on Linux, Windows and a gazillion other platforms
p20144
aVWhere you will have problems is with the libraries that you link to
p20145
aVSo long as you stick to the standard library of C++ or highly portable libraries like boost then you should have relatively few issues
p20146
aVIf you link to a library that is only available on one of the platforms, then you will hit trouble
p20147
as(dp20148
g7
V505088
p20149
stp20150
a((dp20151
g2
(lp20152
VFollowing discussion in the comments to the question, it appears that you would be satisfied with writing a small utility to generate a fake
p20153
aVdsk file (desktop file) and possibly a matching fake
p20154
aVdproj file (project file)
p20155
aVThe
p20156
aVdsk file would contain just enough information to trick the IDE into opening the required file and moving to the desired location within that file
p20157
as(dp20158
g7
V505088
p20159
stp20160
a((dp20161
g2
(lp20162
VDelphi has no features in the program that warn or indicate constants that are not used
p20163
aVIt can do unused local variables or unused private fields, but not unused constants
p20164
aVYou need to look at one of the 3rd party static code analysis tools, e
p20165
ag217
aVPeganza Pascal Analyzer
p20166
aVHowever, I would not be surprised if there were no tools that reported what you want
p20167
as(dp20168
g7
V505088
p20169
stp20170
a((dp20171
g2
(lp20172
VThe best advice for you is not to start trying to build the actual GUI
p20173
aVLearning GUI programming is not trivial and you should start slowly and work up to the real thing
p20174
aVPick a framework (Tkinter, wxPython, Qt) and start with the simplest tutorial you can find
p20175
aVThen try progressively harder tasks until you have enough experience to do a good job with your real task
p20176
as(dp20177
g7
V505088
p20178
stp20179
a((dp20180
g2
(lp20181
VYou can't, so far as I know, call a bound method because it is missing the self parameter
p20182
aVI solve this problem using a closure, like this:
p20183
as(dp20184
g7
V505088
p20185
stp20186
a((dp20187
g2
(lp20188
VI guess you are having to use  rather than implicit linking because you want your app to run on XP where task dialog is not available
p20189
aVI can see three options for you:
p20190
aVUse implicit linking, but use delay loading as supported by the MS tool chain
p20191
aVI'm not 100% certain that will give you the correct comctl32 but it's worth a try
p20192
aVUse the activation context API to make sure that the comctl32 v6 manifest is in play when you call
p20193
aVCall  rather than  to make sure that you get the manifest magic
p20194
aVEnumerate all the modules in the process and select the correct version of comctl32
p20195
aVThere is a comprehensive example of how to do this on MSDN
p20196
aVThe activation context approach is the cleanest solution, but the activation context API can be tricky to get into
p20197
aVI personally have used it to ensure that an Excel COM add-in links to comctl32 v6
p20198
aVThe module enumeration approach is quick to implement, somewhat dirty, but will work well
p20199
as(dp20200
g7
V505088
p20201
stp20202
a((dp20203
g2
(lp20204
VPersonally I'd always separate this into two statements
p20205
aVThis way you don't need to think about what order things happen\u2014there is no scope for confusion
p20206
aVIt makes no difference to the generated code and when that is so, readability and maintainability concerns are always king
p20207
as(dp20208
g7
V505088
p20209
stp20210
a((dp20211
g2
(lp20212
VThe documentation states:
p20213
aVIf the application is running under a debugger, the function will throw an exception if it receives either a handle value that is not valid or a pseudo-handle value
p20214
aVThis can happen if you close a handle twice, or if you call CloseHandle on a handle returned by the FindFirstFile function instead of calling the FindClose function
p20215
as(dp20216
g7
V505088
p20217
stp20218
a((dp20219
g2
(lp20220
VYou can't use array initializers as assignments
p20221
aVYou'll need to do the assignments element wise:
p20222
as(dp20223
g7
V505088
p20224
stp20225
a((dp20226
g2
(lp20227
VThe most obvious problem that an  handler solves, is tidy up for global objects
p20228
aVThis is a C feature and of course C doesn't have automatic deallocation like C++
p20229
aVIf you have access to the implementation of  you can write your own such code, but otherwise  can be helpful
p20230
as(dp20231
g7
V505088
p20232
stp20233
a((dp20234
g2
(lp20235
VYou certainly don't want to use  in C++, as you say that's what exceptions are for
p20236
aVYou don't want to use them in C either because it's exceedingly hard to get right
p20237
aVTry very hard to find other solutions
p20238
as(dp20239
g7
V505088
p20240
stp20241
a((dp20242
g2
(lp20243
VI would read the file into a string list and then process it item by item
p20244
aVThe even ones are put into the list of strings, and the odd ones go into the numbers
p20245
aVI'd probably use some helper functions called  and  in my own code
p20246
aVIf you wanted the numbers in a list of integers, rather than a string list, then you would use  and add  on the odd iterations
p20247
aVI've used lists rather than dynamic arrays for the ease of writing this code, but GolezTrol shows you how to do it with dynamic arrays if that's what you prefer
p20248
aVThat said, since your state that the number is associated with the string, you may actually be better off with something like this:
p20249
aVThe advantage of this approach is that you now have assurance that the association between name and ID will be maintained
p20250
aVShould you ever wish to sort, insert or remove items then you will find the above structure much more convenient than two parallel arrays
p20251
as(dp20252
g7
V505088
p20253
stp20254
a((dp20255
g2
(lp20256
VThere's absolutely no way to query a Windows timer for information of this nature
p20257
aVYou will simply have to keep track of this yourself
p20258
aVI would do this by wrapping up the  with composition and not inheritance
p20259
aVYou can then be sure that you will capture all modifications to the timer state
p20260
as(dp20261
g7
V505088
p20262
stp20263
a((dp20264
g2
(lp20265
VYou can't gain administrator rights on a system with UAC without passing through UAC elevation
p20266
aVYour options are:
p20267
aVManifest your app so that it always runs as administrator
p20268
aVThe user sees the UAC dialog every time they start the app
p20269
aVSeparate the part of the app that needs admin rights into a separate process and just require elevation for that part
p20270
aVRe-work your app so that it doesn't need admin rights
p20271
aVOf these options you should prefer 3
p20272
aVIf you can't achieve that then 2 is better than 1
p20273
as(dp20274
g7
V505088
p20275
stp20276
a((dp20277
g2
(lp20278
VYou need to use a bit more of the Win33 API through P/invoke to obtain the window handles for the other top-level windows
p20279
aVCall  to get the thread ID of the main window
p20280
aVCall  to enumerate all the top-level windows of that thread
p20281
aVIt is possible that there are windows associated with a different thread in the process but the probabilities of that are vanishingly small
p20282
as(dp20283
g7
V505088
p20284
stp20285
a((dp20286
g2
(lp20287
VGive up on trying to get  to work from a scheduled task, it's not going to happen
p20288
aVInstead simply pass the login and password on the command line:
p20289
aVAlternatively do it with a session file and use
p20290
aVIf you are then going to execute commands over this connection then I believe you actually want  rather than
p20291
as(dp20292
g7
V505088
p20293
stp20294
a((dp20295
g2
(lp20296
VMake sure that you have enabled runtime packages for your project and that the devExpress packages are listed
p20297
aVDo this in the project options dialog
p20298
aVIf you had the full version of devExpress then you could optionally link the source files directly into your application without using runtime packages
p20299
aVHowever, that is not possible for the trial version
p20300
as(dp20301
g7
V505088
p20302
stp20303
a((dp20304
g2
(lp20305
VYour C# code is using the base 10 decimal type which by default uses bankers rounding
p20306
aVThe Javascript code uses base 2 floating point arithmetic
p20307
aVThese two forms of computer arithmetic will inherently give different results
p20308
aVThe solution must be to use the same arithmetic methods in both codes
p20309
as(dp20310
g7
V505088
p20311
stp20312
a((dp20313
g2
(lp20314
VAre there any consequences to having the UI thread call Invoke on a method which it will itself end up executing
p20315
aVThe only difference that I know of is that using  will fail if called before the control's handle has been created
p20316
aVThis article discusses the issues in more detail
p20317
as(dp20318
g7
V505088
p20319
stp20320
a((dp20321
g2
(lp20322
VThe Intel website says:
p20323
aVYou are strongly encouraged to dynamically link in the compatibility OpenMP* run-time library libiomp (i
p20324
aVe libiomp5md
p20325
aVlib and libiomp5md
p20326
aVdll , located in the [Compiler Dir]\u005clib directory), even if other libraries are linked statically
p20327
aVLinking to static OpenMP* run-time library (i
p20328
aVe libiomp5mt
p20329
aVlib) is not recommended
p20330
aVBecause multiple OpenMP libraries in one appliation causes performance problems (too many threads) and may cause correctness problems if more than one copy is initialized
p20331
aVSo although you can configure OpenMP to link statically, and this configuration is independent of the C runtime, you are recommended not to
p20332
aVIntel's OpenMP licence allows for royalty free redistribution as far as I can tell
p20333
aVYou should check the licence that came with your OpenMP just to be on the safe side
p20334
as(dp20335
g7
V505088
p20336
stp20337
a((dp20338
g2
(lp20339
VThe way to do this involves calling the underlying API,
p20340
aVSince you want the entire shell namespace to be available you need to pass  as
p20341
aVIn order to select your desired folder you will need to provide a callback in
p20342
aVMake this callback respond to  by setting the selected folder
p20343
aVThis selection is performed by sending the  message to the dialog's window handle (passed to the callback function)
p20344
aVNo code because I don't have VB6, but hopefully this outline of the method is enough to get you on your way
p20345
as(dp20346
g7
V505088
p20347
stp20348
a((dp20349
g2
(lp20350
VThe default calling convention is cdecl
p20351
aVYes, you can override this and specify the calling convention
p20352
aVIn this regard there is nothing special about static member functions
p20353
as(dp20354
g7
V505088
p20355
stp20356
a((dp20357
g2
(lp20358
VI have a couple of suggestions
p20359
aVFirst of all  is a union and should look like this:
p20360
aVSecondly,  simply can't be handled by the P/invoke marshaller
p20361
aVYou will have to use manual marshalling, i
p20362
ag192
aVto get anywhere
p20363
aVThe documentation for the  parameter of  states:
p20364
aVA pointer to a pointer variable that receives a pointer to a system-allocated, read-only buffer
p20365
aVCall the FreePrinterNotifyInfo function to free the buffer when you are finished with it
p20366
aVThis parameter can be NULL if no information is required
p20367
aVYou should pass an  as an  parameter and then use  to read out the contents into your own data structures
p20368
aVSomething like this:
p20369
aVI've not attempted to compile this but hopefully it gets the idea across
p20370
as(dp20371
g7
V505088
p20372
stp20373
a((dp20374
g2
(lp20375
VThat returns the file's contents in a string which can be indexed and so could be considered to be an array
p20376
aVOr perhaps you want an array of strings rather than an array of characters, in which case it's easiest just to use the string list directly:
p20377
as(dp20378
g7
V505088
p20379
stp20380
a((dp20381
g2
(lp20382
VI'm going to take a wild guess that if you are running from within the IDE on computer #2
p20383
aVI bet that if you compile on computer #2 but start the executable from explorer rather than from the IDE, it works
p20384
aVThe final piece of the jigsaw is that I bet you are running your IDE on computer #2 as administrator
p20385
aVOn Vista and Windows 7 you can't send messages to a process with a higher integrity level
p20386
aVIf your process is being run as administrator then it will have a higher integrity level than explorer and so won't accept the dropped files
p20387
aVIf my guess is correct I recommend that you stop running Delphi as administrator, it doesn't need this
p20388
aVAs for whether or not  is a reasonable approach, I see no problems with using it
p20389
as(dp20390
g7
V505088
p20391
stp20392
a((dp20393
g2
(lp20394
VThe concept of packages is orthognal to that of frameworks so yes, packages can be used with FMX
p20395
aVFor example, the newly minted documentation describes the process of creating a package for an FMX component
p20396
as(dp20397
g7
V505088
p20398
stp20399
a((dp20400
g2
(lp20401
VIt seems that perhaps you have text in an
p20402
aVIf so then you can do this:
p20403
aVOn the other hand, maybe you're asking a completely different question
p20404
as(dp20405
g7
V505088
p20406
stp20407
a((dp20408
g2
(lp20409
VWhat your example shows is the classic behavior of a reference type which string is
p20410
as(dp20411
g7
V505088
p20412
stp20413
a((dp20414
g2
(lp20415
VI'm sure there is plenty of code around to do this sort of thing, but it's easy enough to do it yourself with the help of
p20416
aVOutput:
p20417
aVNote: I'm working with Delphi 2010 and don't have  available
p20418
as(dp20419
g7
V505088
p20420
stp20421
a((dp20422
g2
(lp20423
VThe only thing that makes sense is that your C# code is actually:
p20424
aVWhen you do this you pass a wide character based string to your C++ code and since it expects single byte characters it interprets the 0 byte in the second half of the first two byte character as a string terminator
p20425
aVYou should write:
p20426
aVOr in fact you could write it exactly as in your question because  is the default
p20427
aVAnd in fact it turns out that you are on CE which does not support  character set and so the only reasonable solution is to make your C++ code accept wide character strings
p20428
as(dp20429
g7
V505088
p20430
stp20431
a((dp20432
g2
(lp20433
VAll of the above can produce such a GUI
p20434
aVFrom your list,
p20435
aVnet with WinForms is the simplest
p20436
as(dp20437
g7
V505088
p20438
stp20439
a((dp20440
g2
(lp20441
VYou have not provided enough parameters to your second call to  and have invoked undefined behaviour
p20442
aVPlease refrain from doing this
p20443
aVYour compiler should warn about this if you configure its warnings appropriately,
p20444
as(dp20445
g7
V505088
p20446
stp20447
a((dp20448
g2
(lp20449
VYou need to use the DOM to do this
p20450
aVThe best online resource for learning this in a Delphi setting is at Brian Cryer's site
p20451
aVTake a look at How to read and write form elements
p20452
as(dp20453
g7
V505088
p20454
stp20455
a((dp20456
g2
(lp20457
VIn order to see a performance boost there must be support at the file system level
p20458
aVIf this does not exist then the system must enumerate every single object in the directory
p20459
aVIn principle, you can use  specifying the  flag
p20460
aVHowever, the documentation states (emphasis mine):
p20461
aVThis is an advisory flag
p20462
aVIf the file system supports directory filtering, the function searches for a file that matches the specified name and is also a directory
p20463
aVIf the file system does not support directory filtering, this flag is silently ignored
p20464
aVIf directory filtering is desired, this flag can be used on all file systems, but because it is an advisory flag and only affects file systems that support it, the application must examine the file attribute data stored in the lpFindFileData parameter of the FindFirstFileEx function to determine whether the function has returned a handle to a directory
p20465
aVHowever, from what I can tell, and information is sparse,  flag is not widely supported on desktop file systems
p20466
aVYour best bet is to use  with
p20467
aVYou must still perform your own filtering in case you meet a file system that doesn't support directory filtering at file system level
p20468
aVIf you get lucky and hit upon a file system that does support it then you will get the performance benefit
p20469
as(dp20470
g7
V505088
p20471
stp20472
a((dp20473
g2
(lp20474
VIn order to understand how button styles work we need to look at the values used by the style constants:
p20475
aVThe other essential reference is the Button Styles topic at MSDN
p20476
aVHowever, what that document does not explain is that the  to  flags, the type flags, are mutually exclusive
p20477
aVThe other flags can be used in combination with one of the type flags
p20478
aVThis can be inferred from the bit patterns of the values
p20479
aVThe documentation for  states:
p20480
aVWindows 2000: A composite style bit that results from using the OR operator on BS_* style bits
p20481
aVIt can be used to mask out valid BS_* bits from a given bitmask
p20482
aVNote that this is out of date and does not correctly include all valid styles
p20483
aVThus, you should not use this style
p20484
aVHowever I think this is misleading and endorse what ybungalobill said in his answer
p20485
aVNo harm can come of following that advice
p20486
aVIn other words you should mask the style with  and then test for a particular button type
p20487
as(dp20488
g7
V505088
p20489
stp20490
a((dp20491
g2
(lp20492
VThe machine on which this fails doesn't have the necessary redistributable files for OpenCV
p20493
aVYou need to provide them, or use static linking
p20494
aVContrary to your assertion, cv210
p20495
aVdll is not in the list of files in your question
p20496
aVStatic linking is a good option in terms of convenience
p20497
aVFor dynamic linking the easiest option, if OpenCV supports this, is just to place the required DLLs in the same folder as the executable
p20498
aVHowever, since the debug folder you listed doesn't contain the DLL, I suspect that you are, for dynamic linking, expected to install it to some common location rather than alongside your executables
p20499
aVFor definitive advice, consult the OpenCV documentation
p20500
as(dp20501
g7
V505088
p20502
stp20503
a((dp20504
g2
(lp20505
VDo it like this:
p20506
aVThe title of your question is the clue
p20507
aVRepeating is achieved by iteration, and in this case you can do it simply with a nested
p20508
as(dp20509
g7
V505088
p20510
stp20511
a((dp20512
g2
(lp20513
VThe Windows API is, almost exclusively, a C API so there's absolutely no need to look at C++
p20514
aVWhat's more, you don't need to learn the entire language
p20515
aVFor interop with Win32 API you need to understand:
p20516
aVBasic C syntax (variable declarations, parameter passing etc
p20517
aVwhich is not that far removed from Java
p20518
aVBasic macros
p20519
aVArrays and pointers
p20520
aVC strings
p20521
aVMemory allocation
p20522
aVRegarding how to go about learning JNI, I'm not sure that's what you need
p20523
aVJNA is probably what you are looking for if you want to call Win32 APIs
p20524
as(dp20525
g7
V505088
p20526
stp20527
a((dp20528
g2
(lp20529
VSince you have not posted full code that we can run to reproduce the problem we have to guess
p20530
aVThe only way that I can see for the call to  to fail is if  is somehow corrupted
p20531
aVHave you destroyed it by mistake before calling
p20532
aVHas there been a memory corruption perhaps
p20533
aVI would look at this under the disassembly view in the debugger
p20534
aVThat should tell you what has gone wrong and then you need to follow the clues to find out why
p20535
as(dp20536
g7
V505088
p20537
stp20538
a((dp20539
g2
(lp20540
VPersonally I think this is most easily done using a  and thus avoiding the need to export a deallocator
p20541
aVC++
p20542
aVOf course, if you are working with Unicode strings its even easier
p20543
aVC#
p20544
aVAnd on the C# side that's it
p20545
aVYou just call  and it returns a
p20546
aVnet  and you don't need to marshall anything or call a deallocator
p20547
as(dp20548
g7
V505088
p20549
stp20550
a((dp20551
g2
(lp20552
V is WPF
p20553
aVSince you are using WinForms you won't have one of these at hand and I suggest you stick to the tried and tested Windows API Code Pack
p20554
as(dp20555
g7
V505088
p20556
stp20557
a((dp20558
g2
(lp20559
VYou are freeing the memory before calling
p20560
aVIn any case, there's no need to use , just use
p20561
aVIn fact, since  has a maximum buffer size of , it's easiest to do this with stack allocated buffers
p20562
as(dp20563
g7
V505088
p20564
stp20565
a((dp20566
g2
(lp20567
VYou need to take the following steps
p20568
aVDecide which logged on user you want to pick on, there could be more than one
p20569
aVI would identify them using a process, e
p20570
ag217
aVthe explorer process
p20571
aVCall  passing the process handle
p20572
aVMake sure you specify
p20573
aVCall  to get an impersonation token
p20574
aVCall  as before but passing the token rather than
p20575
aVTidy up
p20576
as(dp20577
g7
V505088
p20578
stp20579
a((dp20580
g2
(lp20581
VWhen you write
p20582
aVyou are simply assigning a reference
p20583
aVBehind the scenes the compiler generates code to instantiate the string object that holds
p20584
aVThat instantiation probably happens long before the assignment but the full details of that are another story
p20585
aVIn summary, the code above does not instantiate an object
p20586
aVLikewise, in your example:
p20587
aVno object is instantiated
p20588
aVAll that happens is that a reference to an existing object is copied
p20589
as(dp20590
g7
V505088
p20591
stp20592
a((dp20593
g2
(lp20594
VThe documentation you are referring to is for
p20595
aVnet
p20596
aVC# does not cater for global functions but
p20597
aVnet does
p20598
as(dp20599
g7
V505088
p20600
stp20601
a((dp20602
g2
(lp20603
VThose const declarations, in C, just define some read only memory, they are not true constants
p20604
aVThey can't be evaluated until runtime which is too late for the array declarations
p20605
as(dp20606
g7
V505088
p20607
stp20608
a((dp20609
g2
(lp20610
VBasically anything whose implementation involves a window handle has affinity with the thread that created that window handle
p20611
aVThis restriction is inherited from the underlying Windows API
p20612
aVSince you can't know the implementation, you have to assume that everything needs Invoke unless the documentation specifically calls out an exception
p20613
as(dp20614
g7
V505088
p20615
stp20616
a((dp20617
g2
(lp20618
VThe SysLink control requires v6 of comctl32 as explained by the documentation
p20619
aVYou are linking to v5 comctl32 and I suspect this is the cause of your error
p20620
aVYou need to include the v6 comctl32 application manifest
p20621
as(dp20622
g7
V505088
p20623
stp20624
a((dp20625
g2
(lp20626
VBest practice is to put the tests in separate units that use the unittest module
p20627
aVThis separation allows you to keep the main code clean (no need for lots of testing helper functions) and encourages you to write good comprehensive tests since you are not inhibited by cluttering the main code
p20628
as(dp20629
g7
V505088
p20630
stp20631
a((dp20632
g2
(lp20633
VI don't want to use UTF-8 strings
p20634
aVWell, you will need to overcome that reluctance, at least when calling the APIs
p20635
aVLinux uses single byte string encodings, invariably UTF-8
p20636
aVClearly you should use a single byte string type since you obviously can't pass wide characters to a function that expects
p20637
aVUse  rather than
p20638
as(dp20639
g7
V505088
p20640
stp20641
a((dp20642
g2
(lp20643
VOn the whole, bubble sort will be slower than almost anything else, including  which is implemented with a quick sort algorithm
p20644
as(dp20645
g7
V505088
p20646
stp20647
a((dp20648
g2
(lp20649
VThe C standard dictates what each library function must do rather than how it is implemented
p20650
aVAlmost all known implementations of C are compiled into machine language
p20651
aVIt is up to the implementers of the C compiler/library how they choose to implement functions like
p20652
aVThey could choose to implement it in C and compile it to an object, or they could choose to write it in assembly and assemble it to an object
p20653
aVOr they could implement it some other way
p20654
aVIt doesn't matter so long as you get the right effect and result when you call
p20655
aVNow, as it happens, many C toolsets do allow you to write inline assembly, but that is absolutely not part of the standard
p20656
aVAny such facilties have to be included as extensions to the C standard
p20657
as(dp20658
g7
V505088
p20659
stp20660
a((dp20661
g2
(lp20662
VThat's just a modal form
p20663
aVInvoke it with ShowDialog
p20664
aVI can't answer that, but you did ask two questions at once
p20665
as(dp20666
g7
V505088
p20667
stp20668
a((dp20669
g2
(lp20670
VWell, you can hide it, by removing the entire system menu:
p20671
aVOf course, doing so removes the minimize and maximize buttons
p20672
aVIf you keep the system menu but remove the close item then the close button remains but is disabled
p20673
aVThe final alternative is to paint the non-client area yourself
p20674
aVThat's pretty hard to get right
p20675
as(dp20676
g7
V505088
p20677
stp20678
a((dp20679
g2
(lp20680
VThe error is because there is no MessageBox
p20681
aVYou presumably mean MessageBoxA
p20682
as(dp20683
g7
V505088
p20684
stp20685
a((dp20686
g2
(lp20687
VI guess the problem is that you are allocating memory with your C++ runtime's allocator but then the C# marshaller attempts to deallocate it
p20688
aVThat cannot work
p20689
aVYou need to allocate and deallocate with the same allocator
p20690
aVThe best way I know to solve your problem is to marshal with a
p20691
aVThat uses the COM allocator which is happy to be shared between native and managed modules
p20692
aVOn the C# side you do this:
p20693
aVOne other benefit of this is that your code is now thread-safe because you no longer need a global variable
p20694
as(dp20695
g7
V505088
p20696
stp20697
a((dp20698
g2
(lp20699
VThe memory pointed to by lpvBits must be the size of one scan line times the height
p20700
aVEach scan line must be aligned on a DWORD boundary
p20701
aVSince you are using 32 bit colour then each scanline will naturally satisy that requirement, so long as you ensure that the first scanline, i
p20702
ag192
aVthe start of the memory block, is 4 byte aligned
p20703
aVSo the answer, measured in bytes, is 4*width*height, aligned to start on a 4 byte boundary
p20704
as(dp20705
g7
V505088
p20706
stp20707
a((dp20708
g2
(lp20709
VYou certainly can use the  data type in your Qt app
p20710
aVIt will, however, make the app non-portable
p20711
as(dp20712
g7
V505088
p20713
stp20714
a((dp20715
g2
(lp20716
VThere is no such thing as an unsigned double in any language or system that I have ever heard of
p20717
aVI need to give the ability to pass a variable that can be a fraction and must be positive
p20718
aVI wanted to use it in my Function signature to enforce it
p20719
aVIf you want to enforce a constraint that the parameter is positive, then you need to do that with a runtime check
p20720
as(dp20721
g7
V505088
p20722
stp20723
a((dp20724
g2
(lp20725
VYes, MinGW is most definitely stable and reliable for production code
p20726
as(dp20727
g7
V505088
p20728
stp20729
a((dp20730
g2
(lp20731
VI worked this out by recording a VBA macro and then pasting it into your Delphi routine:
p20732
aVThere is no Delphi documentation of Office COM automation
p20733
aVYou have to use the MSDN documentation and translate it into Delphi yourself
p20734
as(dp20735
g7
V505088
p20736
stp20737
a((dp20738
g2
(lp20739
VThe very simplest code that I know of uses  from the  unit:
p20740
aVactually returns a dynamic array containing the names of the directories so this is somewhat inefficient
p20741
aVIf you want the most efficient solution then you should use  to enumerate
p20742
as(dp20743
g7
V505088
p20744
stp20745
a((dp20746
g2
(lp20747
VThey are small icons ()
p20748
aVYou can find out the size by calling:
p20749
aVI think it's pretty safe to assume that they are square, but if you are paranoid then you can always inquire about
p20750
aVOn my Windows 7 machine they are 16px in size
p20751
aVBut if you are using font scaling then they will be larger
p20752
aVFor a 125% font scaling (e
p20753
ag217
aVlarge fonts) you will need a 20px icon
p20754
aVIf you don't have a 20px version at hand then the best approach is to generate one on the fly and put your 16px version in the middle of the new 20px icon
p20755
aVUpdate
p20756
aVThe documentation of  recommends using  passing  which is equivalent to the approach I outline above
p20757
aVHowever, the  topic also says to use an icon resource containing  just16px and 32px versions of the icon
p20758
aVThat advice is bogus because, as anyone can see for themselves, notification icons under large fonts are 20px icons and  will have scale from 32 to 20
p20759
aVI would recommend supplying 16, 20, 24, 32px versions
p20760
aVOn XP  doesn't exist so you'd need to implement a fallback routine
p20761
as(dp20762
g7
V505088
p20763
stp20764
a((dp20765
g2
(lp20766
VYou need an assignable variable for a ref or out param
p20767
as(dp20768
g7
V505088
p20769
stp20770
a((dp20771
g2
(lp20772
VThe error message indicates you are trying to access a member with private or protected visibility, which is not allowed
p20773
aVThis library is not part of
p20774
aVnet and so it's hard for me to work out how it is meant to be used
p20775
aVI can't immediately find any documentation
p20776
as(dp20777
g7
V505088
p20778
stp20779
a((dp20780
g2
(lp20781
VAs I understand your question, you can't use  with  because your real struct has a large number of such arrays which results in the stack overflowing
p20782
aVYou opine that maybe you need to use pointers in your structs and I agree with you
p20783
aVHere is how to do it
p20784
aVOn the C++ side you should declare each array as a pointer to the element type:
p20785
aVYou may also wish to include the length of the arrays in the struct to avoid excessive amounts of hard-coded constants
p20786
aVAll the hard work happens on the C# side
p20787
as(dp20788
g7
V505088
p20789
stp20790
a((dp20791
g2
(lp20792
VYou need to open the key using RegistryView
p20793
aVRegistry64
p20794
aVYou specify this in the OpenBaseKey method so you'll need to rejig your code a little
p20795
as(dp20796
g7
V505088
p20797
stp20798
a((dp20799
g2
(lp20800
VFirst of all, there is no leak in the code you publish
p20801
aVYou dispose of the icon and of course the
p20802
aVnet garbage collector does not leak
p20803
aVIn a comment to the question you state:
p20804
aVI just see the memory increase in taskmgr
p20805
aVexe and not
p20806
aVgetting released back
p20807
aVThis is the source of your problem
p20808
aVWindows memory management is exceedingly complex, and task manager is not an appropriate tool to diagnose leaks
p20809
aVCombine this with the
p20810
aVnet garbage collector and the picture is even muddier
p20811
aVThe garbage collector is perfectly at liberty to hold on to all allocated memory for as long as it can, so long as that does not impact on the rest of the system
p20812
aVDetecting memory leaks in
p20813
aVnet is a complex task and requires dedicated tools
p20814
as(dp20815
g7
V505088
p20816
stp20817
a((dp20818
g2
(lp20819
VYou are calling  to write a bunch of zeros over the top of an object instance
p20820
aVDo not do this
p20821
aVYou may get away with it if your class is a true POD class
p20822
aVYou might end up just setting the ID to 0
p20823
aVBut maybe there is more to your class that you aren't showing
p20824
aVIn anycase, even if it isn't POD, don't use  like that
p20825
aVYou can either store pointers to object and use the null pointer to indicate there is nothing there
p20826
aVI'd do this with
p20827
aVOr you use a sentinel object instance, for example with ID of -1
p20828
aVThe other thing that could be a problem is that you appear to be using 1-based indices
p20829
aVC++ arrays are 0-based, so the first element is  and not
p20830
as(dp20831
g7
V505088
p20832
stp20833
a((dp20834
g2
(lp20835
VYou've got your declaration of  wrong
p20836
aVIt should be:
p20837
aVOne thing that is crucial to remember is that methods in an interface must be declared in the correct order\u2014you declared them in the wrong order
p20838
aVI also don't know where you got your GUID from
p20839
aVI obtained this interface declaration by importing the type library for Microsoft Add-In Designer
p20840
aVI strongly recommend that you do the same
p20841
as(dp20842
g7
V505088
p20843
stp20844
a((dp20845
g2
(lp20846
V/SUBSYSTEM:CONSOLE results in a process with a console and /SUBSYSTEM:WINDOWS does not
p20847
as(dp20848
g7
V505088
p20849
stp20850
a((dp20851
g2
(lp20852
VThere's no practical way to achieve what you are looking for
p20853
aVThe compiler is going to emit the calls to  and in order to whack them you would need to find all the call sites
p20854
aVThat's not practical
p20855
aVI'm afraid the only viable approach when reference counted lifetime management is disabled is to ensure that you finalize (i
p20856
ag192
aVset to ) all your interface references before calling
p20857
as(dp20858
g7
V505088
p20859
stp20860
a((dp20861
g2
(lp20862
VYou appear to have copied the function declaration from pinvoke
p20863
aVnet
p20864
aVYou also need to include the user defined types declared further down that page
p20865
as(dp20866
g7
V505088
p20867
stp20868
a((dp20869
g2
(lp20870
VI can't see where you are using , but that should be declared like this:
p20871
aVThe other problem you have is in the declaration of
p20872
aVThat should be:
p20873
aVAs I read it,  is actually an out parameter, i
p20874
ag192
aVyou supply a buffer and  writes to it
p20875
aVYou then call this like so
p20876
as(dp20877
g7
V505088
p20878
stp20879
a((dp20880
g2
(lp20881
VSince your class is not holding onto any unmanaged resources like files, window handles, database connections etc
p20882
aVyou need do nothing beyond letting the
p20883
aVnet garbage collector free the memory when it decides the time is right
p20884
aVTrying to force the garbage collector to run ahead of time typically leads to worse performance than simply letting it do its job
p20885
aVIf you had a class with unmanaged resources then you should follow the IDisposable pattern
p20886
as(dp20887
g7
V505088
p20888
stp20889
a((dp20890
g2
(lp20891
VI think you are looking for
p20892
aVYou don't really need a  method, you can just write  directly
p20893
aVHowever, it is not generally recommended that you terminate processes in such a brutal way
p20894
aVDoing so can leave shared objects in an undefined state
p20895
aVIf you can find a way to co-operatively close the process that is to be preferred
p20896
as(dp20897
g7
V505088
p20898
stp20899
a((dp20900
g2
(lp20901
VYou have a problem here
p20902
aVNon admin processes cannot start services
p20903
aVThe very simplest thing to do is to arrange that the service starts automatically
p20904
aVI'd strongly recommend you take that route
p20905
aVWhat you are thinking of doing would involve creating a helper application that includes the UAC manifest with  set to
p20906
aVThis helper app could then start the service
p20907
aVThe problem with this is that it requires that the logged on user is in the administrators group which you cannot guarantee will be the case
p20908
aVAll in all, starting the service automatically is to be preferred
p20909
as(dp20910
g7
V505088
p20911
stp20912
a((dp20913
g2
(lp20914
VYou should be able to get everything you need from the  namespace
p20915
aVFor example, the following sample is lifted from MSDN and does what you asked for in the original version of the question
p20916
aVIt displays the physical addresses of all interfaces on the local computer
p20917
as(dp20918
g7
V505088
p20919
stp20920
a((dp20921
g2
(lp20922
VIf you return to
p20923
aVnet memory allocated with your native malloc, then you also have to export the deallocator
p20924
aVI don't regard that to be a desirable action and instead prefer to export the text as a
p20925
aVThis can be freed by the C# runtime because it knows that the  was allocated by the COM allocator
p20926
aVThe C# coding becomes a lot simpler
p20927
aVThe only wrinkle is that a  uses Unicode characters and your C++ code uses ANSI
p20928
aVI would work around that like so:
p20929
aVC++
p20930
aVC#
p20931
as(dp20932
g7
V505088
p20933
stp20934
a((dp20935
g2
(lp20936
VYour question boils down to, how do I use regular expressions in C#
p20937
aVThe answer is the  class
p20938
aVTo perform a replacement you need
p20939
aVThere is no need to explicitly compile the regex because that is done when you create the  instance
p20940
aVThe following example from MSDN illustrates how to use the class:
p20941
as(dp20942
g7
V505088
p20943
stp20944
a((dp20945
g2
(lp20946
VYou just want to remove the NA values
p20947
aVDo it like this:
p20948
aVThis will be pretty much instant
p20949
aVOr as Joshua suggests, a more readable alternative:
p20950
aVYour code was slow because:
p20951
aVIt uses explicit loops which tend to be slow under the R interpreter
p20952
aVYou reallocate memory every iteration
p20953
aVThe memory reallocation is probably the biggest handicap to your code
p20954
as(dp20955
g7
V505088
p20956
stp20957
a((dp20958
g2
(lp20959
VYou can't distribute setx so you would have to rely on it being present of the target system
p20960
aVI strongly recommend you use a dedicated tool to build your installer rather than trying to do it with a
p20961
aVbat file
p20962
as(dp20963
g7
V505088
p20964
stp20965
a((dp20966
g2
(lp20967
VYou can read  to discern this
p20968
aVMultiply  by 100 and divide by 96 and you will have the percentage font scaling
p20969
aVThis is true because 100% font scaling equates to 96dpi
p20970
aVBe warned that if your application is not marked as DPI aware then when the user sets font scaling to 150% the  property will report 96
p20971
aVOff the top of my head I do not know whether or not standard WinForms apps are marked as DPI aware
p20972
as(dp20973
g7
V505088
p20974
stp20975
a((dp20976
g2
(lp20977
VI know it's not the answer to your direct question (Uwe and Nat have that covered), but you would be much better off building with msbuild
p20978
aVThat way you'll pick up all the settings in your
p20979
aVdproj file
p20980
aVThe build command should look like this:
p20981
aVIf you are building this from a batch script, you'll need to make sure it can see the right
p20982
aVDo it like this:
p20983
as(dp20984
g7
V505088
p20985
stp20986
a((dp20987
g2
(lp20988
VJust use whichever is more convenient and natural
p20989
aVShort comments, a handful of words, at the end of a short line work well with
p20990
aVLonger comments, spread over multiple lines, are perhaps better with the tradition  style
p20991
aVWhatever, it all comes down to personal preference and your teams's coding standards
p20992
aVIt makes no difference to the compilation process
p20993
as(dp20994
g7
V505088
p20995
stp20996
a((dp20997
g2
(lp20998
VYou can't prevent the OS from using the disk
p20999
as(dp21000
g7
V505088
p21001
stp21002
a((dp21003
g2
(lp21004
VYou won't be able to do this in an automated way
p21005
aVThat hotfix is not available for download
p21006
aVYou must contact MS directly to obtain it, as can be gleaned from the hotfix description
p21007
as(dp21008
g7
V505088
p21009
stp21010
a((dp21011
g2
(lp21012
s(dp21013
g7
V505088
p21014
stp21015
a((dp21016
g2
(lp21017
VI can't immediately try this out, but so far as I recall, you don't need owner draw
p21018
aVYou need to do this:
p21019
aVReturn 1 from
p21020
aVCall  from  to draw the background there
p21021
aVReturn  from
p21022
as(dp21023
g7
V505088
p21024
stp21025
a((dp21026
g2
(lp21027
VMFC is widely considered to be poorly designed but it has been updated recently and appears to be alive and well
p21028
aVYou may decide not to use it for other reasons, but you should not reject it for being outdated
p21029
as(dp21030
g7
V505088
p21031
stp21032
a((dp21033
g2
(lp21034
VThe Mac OSX compiler is, at present, only 32 bit
p21035
aVA 64 bit version will be included in a future release
p21036
aVAs for the VCL, I'm afraid you are to be disappointed
p21037
aVThe VCL is a Windows only framework and will remain so
p21038
aVThe VCL is hugely reliant on the architecture of Windows
p21039
aVFor cross-platform (Windows, OSX, iOS), the new framework being shipped with XE2 is called FireMonkey
p21040
aVPorting a large VCL app to FireMonkey is a significant task
p21041
aVThere have been a lot of blog articles just recently discussing FireMonkey and a bit of websearch will lead you to them
p21042
aVI would warn you that FireMonkey is very different from the VCL
p21043
aVThis is brand new technology and so expect some teething troubles
p21044
aVIt will take time for the framework to mature and for 3rd party vendors to get fully up-to-speed with it
p21045
aVAt the moment, you should not be expecting to ship a GUI heavy app for Mac compiled with Delphi any time soon
p21046
aVWhat you should be doing is getting hold of XE2, learning about FireMonkey and planning a strategy for porting to FireMonkey
p21047
as(dp21048
g7
V505088
p21049
stp21050
a((dp21051
g2
(lp21052
VYou have two distinct instances of the VCL
p21053
aVYou have set the style in the  instance owned by the executable, but your DLL has no knowledge of that
p21054
aVYou could solve this by either:
p21055
aVPassing the style settings to a function in your DLL that applies those settings to the other  instance
p21056
aVUse packages so that you only have a single VCL instance
p21057
as(dp21058
g7
V505088
p21059
stp21060
a((dp21061
g2
(lp21062
V reads values from
p21063
aVini files
p21064
aVWay back when, in the days of 16-bit Windows, it was the way to read and write application configuration data
p21065
aVBack then applications stored their configuration in a shared
p21066
aVini file that lived in the system directory, called win
p21067
aVini
p21068
aVBad times
p21069
aVTo read from win
p21070
aVini you called
p21071
aVThe private in  is indicative of the fact that this wonderful function allowed you to access an
p21072
aVini file other than win
p21073
aVini, i
p21074
ag192
aVone private to your application
p21075
aVIf I recall correctly (and my memory is hazy), most applications carried on using win
p21076
aVini for years and years after it was officially frowned upon to do so
p21077
aVIt so happens that  is an incredibly wrinkly beast with terrible performance characteristics and hard to understand oddities
p21078
aVI personally avoid it like the plague and if I have to process
p21079
aVini files I use bespoke code to do so
p21080
aVRaymond Chen has a nice article about why
p21081
aVini files were deprecated in favour of the registry
p21082
as(dp21083
g7
V505088
p21084
stp21085
a((dp21086
g2
(lp21087
VYou have to keep track of the size of the array yourself
p21088
aVThere is nothing in the language that will do that for you
p21089
aVSorry
p21090
aVThis is one of the reasons why people use higher level languages that contain more powerful data structures, e
p21091
ag217
as(dp21092
g7
V505088
p21093
stp21094
a((dp21095
g2
(lp21096
VThe call stack lives on the stack
p21097
aVEach thread or fiber has its own private stack and that's what the topic you link to is discussing
p21098
as(dp21099
g7
V505088
p21100
stp21101
a((dp21102
g2
(lp21103
VYou are using an assignment rather than an initializer
p21104
aVIt should be:
p21105
aVI presume that in the second example the  is meant to be a function
p21106
aVIf so then the initializer there is fine
p21107
as(dp21108
g7
V505088
p21109
stp21110
a((dp21111
g2
(lp21112
VI think a quite simple heuristic would be to check that the various sections in the PE file start and finish at the same place:
p21113
aVFor example, here's the top of a map file
p21114
aVI also looked at what  had to say about these sections:
p21115
aVLook at the
p21116
aVtext section
p21117
aVAccording to dumpbin it starts at  and finishes at  which is a length of , exactly as in the
p21118
aVmap file
p21119
aVNaturally you'd read the PE file directly rather than running dumpbin, but this illustrates the point
p21120
aVI'd expect a vanishingly small number of false positives with this approach
p21121
as(dp21122
g7
V505088
p21123
stp21124
a((dp21125
g2
(lp21126
VYour main problem is that you forgot to add an  to your component's constructor
p21127
aVThis means it is not being called because the VCL framework takes advantage of the virtual constructor of
p21128
aVThat explains why your font instance is nil
p21129
aVYou also need a  method that calls  to copy the properties of the font, rather than replacing the instance which inevitably leads to memory corruption errors
p21130
aVThe VCL source has countless examples of this pattern
p21131
aVIt looks like this:
p21132
as(dp21133
g7
V505088
p21134
stp21135
a((dp21136
g2
(lp21137
VUsing  means that the manifest cannot be used if you target 64 bit platforms
p21138
aVI'd say that this was a disadvantage
p21139
aVI think using  is better
p21140
as(dp21141
g7
V505088
p21142
stp21143
a((dp21144
g2
(lp21145
VBy default, those operators test for equality of reference
p21146
as(dp21147
g7
V505088
p21148
stp21149
a((dp21150
g2
(lp21151
VIn addition to the point that @CodeInChaos makes, floating point calculations vary on different hardware architectures
p21152
aVThat's simply the nature of floating point units
p21153
aVEven two FP units that both adhere to IEEE754 can give different results to each other
p21154
aVObviously the differences will be vanishingly small
p21155
aVSo even without any JIT differences, you may see different results on a different machine
p21156
aVIn your case you simply need to compare floating point values in a different way
p21157
aVInstead of testing for exact equality, test for equality up to a small tolerance, i
p21158
ag192
aVwhere  is a small number
p21159
as(dp21160
g7
V505088
p21161
stp21162
a((dp21163
g2
(lp21164
VIn Vista and later, services cannot interact with the desktop
p21165
aVServices run under what is known as session 0 isolation
p21166
aVWhat you are attempting is simply impossible
p21167
aVYou will have to re-write your application so that the UI part resides in a standard Windows application that runs on the logged in user's desktop
p21168
aVThis UI part can communicate with the service by whatever IPC mechanism you prefer
p21169
as(dp21170
g7
V505088
p21171
stp21172
a((dp21173
g2
(lp21174
VYour regex should be:
p21175
aVThe problem is that there is no word boundary () where you were trying to match
p21176
aVYou can add the grouping in if you need it, but it seems unlikely that you do since you know that the first group contains  and the second contains
p21177
aVPerhaps you meant to group the word inside:
p21178
as(dp21179
g7
V505088
p21180
stp21181
a((dp21182
g2
(lp21183
VJust use a uint passed by ref:
p21184
as(dp21185
g7
V505088
p21186
stp21187
a((dp21188
g2
(lp21189
VThis might help, but it's very much applying a sticking plaster to a severed head
p21190
aVSwitch to a 64 bit machine
p21191
aVMake your program
p21192
aVSwitch to FastMM (needed to make step 2 work due to bugs in old Borland MM)
p21193
aVThen cross your fingers and hope that 4GB address space, as opposed to 2GB, is enough
p21194
as(dp21195
g7
V505088
p21196
stp21197
a((dp21198
g2
(lp21199
VUse the  operator to test membership
p21200
aVUse the  operator in place of
p21201
aVA method like  could not exist in Prism since sets are immutable in Prism
p21202
aVSee here for full details
p21203
as(dp21204
g7
V505088
p21205
stp21206
a((dp21207
g2
(lp21208
VThey are not interchangeable and serve different purposes
p21209
aVA critical section is a mutex
p21210
aVBlocks of code wrapped in a critical can be entered by one thread at a time
p21211
aVThis is also known as serialization because protected blocks are executed serially
p21212
aVThe  function and its various relatives are used to block until a synchronisation object is signaled
p21213
aVThis could be an event becoming signaled, a thread completing, a process completing, a mutex becoming available, etc
p21214
aVTypically wait functions are used to ensure dependencies are correctly handled
p21215
aVFor example, if a calculation can only proceed when other calculations have completed, a wait function will be used to block until those other calculations have completed
p21216
aVUsing a proper wait function rather than a busy spin look avoids wasting clock cycles
p21217
as(dp21218
g7
V505088
p21219
stp21220
a((dp21221
g2
(lp21222
VInclude the header file in the calling program
p21223
aVLink the calling program to the
p21224
aVlib file associated with the library
p21225
aVMake sure that the library is in the library search path
p21226
as(dp21227
g7
V505088
p21228
stp21229
a((dp21230
g2
(lp21231
VOK, here's how to do what I think you mean, and I'm sorry it took me so long to work it out
p21232
aVYou will need to use manual marshalling for the pointer to
p21233
aVI've simplified your struct for convenience
p21234
aVI doubt that the  is correct
p21235
aVIt's pretty rare to pack structs in C
p21236
aVAnother problem is that  is 64 bits in C# but , ,  are all 32 bits in C++ on Windows
p21237
aVFinally, the  parameter is an opaque pointer and you should declare it as  in your C# struct
p21238
as(dp21239
g7
V505088
p21240
stp21241
a((dp21242
g2
(lp21243
VFrom the language specification:
p21244
aVDuring the run-time processing of a function member invocation, the expressions or variable references of an argument list are evaluated in order, from left to right
p21245
as(dp21246
g7
V505088
p21247
stp21248
a((dp21249
g2
(lp21250
V is typically used to force a redraw of the entire window (or some specified region within) right now
p21251
aVwill force a redraw of only the update region of the window, i
p21252
ag192
aVthat part of the window that has been invalidated (e
p21253
ag217
aVby calling ) since the last paint cycle
p21254
as(dp21255
g7
V505088
p21256
stp21257
a((dp21258
g2
(lp21259
VThe problem is that you are leaking memory
p21260
aVThe call to  allocates memory which is not freed
p21261
aVThe pointer to the memory that is passed to  is never saved anywhere and the compiler can therefore prove that it is leaked
p21262
aVI'm not sure what you are trying to do since  performs both allocation and copying, the call to  seems superfluous
p21263
as(dp21264
g7
V505088
p21265
stp21266
a((dp21267
g2
(lp21268
VWaiting for the window to finish its painting is not the solution to the problem
p21269
aVOr, put another way, the problem is not that  is called whilst the target window is part way through its paint cycle
p21270
aVfunctions by posting a  (or ) message to the target window and then waiting for the target window's message queue to process that message
p21271
aVQueued messages do not interleave
p21272
aVIn order to get to the bottom of the actual problem I think you will need to supply more details
p21273
as(dp21274
g7
V505088
p21275
stp21276
a((dp21277
g2
(lp21278
VYou can't use this method to poke text into Word
p21279
aVIt uses custom controls and just won't yield to this approach
p21280
aVInstead you should use UIAutomation or Office PIA
p21281
as(dp21282
g7
V505088
p21283
stp21284
a((dp21285
g2
(lp21286
VWell, that works
p21287
aVThe memory is allocated on the heap and is deallocated correctly
p21288
aVThere is no need to manually add a null-terminator since  does so
p21289
aVBut it's not really C++
p21290
aVIn C++ you would use
p21291
as(dp21292
g7
V505088
p21293
stp21294
a((dp21295
g2
(lp21296
VSince you have two dense matrices then the double for loop is the only option you have
p21297
aVYou don't need a sparse matrix class at all since you only want to know the list of indices  for which
p21298
aVIn languages like R and Python the double for loop will perform poorly
p21299
aVI'd probably write this in native code for a double for loop and add the indices to a list object
p21300
aVBut no doubt the wizards of interpreted code (i
p21301
ag192
aVR, Python etc
p21302
aVknow efficient ways to do it without resorting to native coding
p21303
as(dp21304
g7
V505088
p21305
stp21306
a((dp21307
g2
(lp21308
VI've read about GIL, is there a way to bypass it with out calling a C\u005cC++ code
p21309
aVNot really
p21310
aVFunctions called through ctypes will release the GIL for the duration of those calls
p21311
aVFunctions that perform blocking I/O will release it too
p21312
aVThere are other similar situations, but they always involve code outside the main Python interpreter loop
p21313
aVYou can't let go of the GIL in your Python code
p21314
as(dp21315
g7
V505088
p21316
stp21317
a((dp21318
g2
(lp21319
VDoes BinaryWriter "Write method" work the same as Writeln method from Delphi
p21320
aVNo it does not
p21321
aVHow does it know how many bytes or characters length to read or write when it is a string data type without giving it a specific numbers of length to read
p21322
aVIn many ways you don't really need to know how  and  does it
p21323
aVYou are using it correctly
p21324
aVYou just need to pair each  call with a matching  call of the appropriate type
p21325
aVThe documentation does describe the underlying binary file format
p21326
aVYou don't need to write or read the length of the string since the Binary I/O classes do exactly that on your behalf
p21327
aVA length-prefixed string represents the string length by prefixing to the string a single byte or word that contains the length of that string
p21328
aVThis method first writes the length of the string as a UTF-7 encoded unsigned integer, and then writes that many characters to the stream by using the BinaryWriter instance's current encoding
p21329
aVSo you can safely write a string which contains linefeeds and when it is read those linefeeds will be preserved
p21330
as(dp21331
g7
V505088
p21332
stp21333
a((dp21334
g2
(lp21335
Vfor a
p21336
aVxlsx macro free workbook
p21337
aVfor a
p21338
aVxlsm macro enabled workbook
p21339
aVThe key piece of knowledge is that the new Office 2007 file formats are called Office Open XML
p21340
as(dp21341
g7
V505088
p21342
stp21343
a((dp21344
g2
(lp21345
VNo, there is only a single thread
p21346
aVEach iteration of the for loop runs your  function until it yields something, or returns
p21347
aVAfter the yield, the body of the for loop runs again and then, when a new iteration starts, the  function picks up exactly where it left off and runs again until it yields (or returns)
p21348
aVThis modified version of your example will helpfully make it clearer what path execution takes
p21349
aVOutput
p21350
as(dp21351
g7
V505088
p21352
stp21353
a((dp21354
g2
(lp21355
VNo this cannot be done
p21356
aVThe user token is assigned as part of the process creation mechanism and is then fixed for the duration of that process
p21357
aVThis is one of the reasons why UAC elevation has to involve separate processes
p21358
as(dp21359
g7
V505088
p21360
stp21361
a((dp21362
g2
(lp21363
VYou should declare it like this:
p21364
aVAnd call it like this:
p21365
aVNo need for unsafe or fixed
p21366
aVDo remove all of that
p21367
as(dp21368
g7
V505088
p21369
stp21370
a((dp21371
g2
(lp21372
VI think you need to resort to the native API and call
p21373
aVI'm afraid I can't help you call the rather frightening API, but I don't believe there is anything else that could possibly allow this
p21374
as(dp21375
g7
V505088
p21376
stp21377
a((dp21378
g2
(lp21379
VPierre Le Riche committed changes to the SVN repository yesterday to add support for both 32 and 64 bit targets of XE2
p21380
as(dp21381
g7
V505088
p21382
stp21383
a((dp21384
g2
(lp21385
VIt's a reserved parameter
p21386
aVYou should set it to 0
p21387
as(dp21388
g7
V505088
p21389
stp21390
a((dp21391
g2
(lp21392
VI'd do this by changing the PATH environment variable
p21393
aVMake it point to the 5
p21394
aV12 version and you may find that the VMware code continues working because it knows where to find it its Perl
p21395
aVIf not, make a
p21396
aVbat file that sets PATH to refer to the 5
p21397
aV12 installation and use that to launch into a cmd window from which calls to perl invoke 5
p21398
aV12
p21399
as(dp21400
g7
V505088
p21401
stp21402
a((dp21403
g2
(lp21404
VThat's just the nature of the batch file interpreter
p21405
aVIt is going to put a console window up, and include it in the taskbar
p21406
aVInstead of a batch file ship a shortcut whose target is your msiexec command
p21407
aVIt's just a different way to invoke the command but it won't lead to any windows being shown, beyond what msiexec may show
p21408
as(dp21409
g7
V505088
p21410
stp21411
a((dp21412
g2
(lp21413
VSoftware floating point is inherently 1 or 2 orders of magnitude slower than hardware floating point
p21414
aVCouple this with the fact that you are looking for much greater precision and you probably have another order of magnitude
p21415
aVYour expectations are probably unrealistic
p21416
as(dp21417
g7
V505088
p21418
stp21419
a((dp21420
g2
(lp21421
VThe only explanations that makes sense are that you don't have permissions to create the file in the working directory, or the working directory is not where you are looking for the file to be created
p21422
aVnot working
p21423
aVWell, of course it works
p21424
aVYou shouldn't get in the mindset that the standard library doesn't work
p21425
aVNo warnings/notices or otherwise stuff to give me any idea of what is wrong
p21426
aVYou did not check for errors after calling
p21427
aVIf you don't check for errors, how do you expect them to be delivered to you
p21428
as(dp21429
g7
V505088
p21430
stp21431
a((dp21432
g2
(lp21433
VThere should be no discernible difference in performance, especially for the type of code you describe which is essentially going to be C code compiled by the Objective-C compiler
p21434
as(dp21435
g7
V505088
p21436
stp21437
a((dp21438
g2
(lp21439
VThe documentation states:
p21440
aVDefault parameter values are evaluated when the function definition is executed
p21441
aVThis explains why the instance cannot be referenced
p21442
aVAs others have said, use None as your default and fix up the value at function execution time when the instance is available
p21443
as(dp21444
g7
V505088
p21445
stp21446
a((dp21447
g2
(lp21448
VMemory allocation always happens at run time
p21449
aVMemory reservation, for objects that reside on the stack, or for static variables, happens at compile time (or at run time for C99 VLAs)
p21450
aVMemory for an object's members is always in place before the constructor runs
p21451
aVIt is the job of the compiler and its runtime support to ensure that is so
p21452
as(dp21453
g7
V505088
p21454
stp21455
a((dp21456
g2
(lp21457
VFloating point data types have a special value reserved to represent infinity, integer values do not
p21458
aVIn your code  is an integer division that, of course, fails
p21459
aVHowever,  is a floating point division and so results in
p21460
as(dp21461
g7
V505088
p21462
stp21463
a((dp21464
g2
(lp21465
VIf a Python function does not explicitly  a value, it returns
p21466
aVThat implicit  is analagous to  in C like languages
p21467
as(dp21468
g7
V505088
p21469
stp21470
a((dp21471
g2
(lp21472
VControl
p21473
aVFromHandle can only work for controls in your process that are implemented by Control descendents
p21474
aVI'd guess this window is outside your process
p21475
aVYou need to use Win32 API methods to modify it
p21476
as(dp21477
g7
V505088
p21478
stp21479
a((dp21480
g2
(lp21481
VI think there's reasonable evidence that someone made a simple mistake when they wrote the original  struct definition
p21482
aVThis mistake escaped into the wild and so it was too late to fix it
p21483
aVThe definition in the header file is:
p21484
aVThe documentation reads:
p21485
aVIf DetectionType is DetectInt13, the union is a DISK_INT13_ INFO structure
p21486
aVIf DetectionType is DetectExInt13, the union is a DISK_EX_ INT13_INFO structure
p21487
aVSo it seems very likely that the original intention was for the  and  to be placed in a union since they are mutually exclusive
p21488
as(dp21489
g7
V505088
p21490
stp21491
a((dp21492
g2
(lp21493
VIf heap allocation performance is an issue then you can retain the stack allocated buffer for when bar<1024, but use a heap allocated buffer otherwise
p21494
aVI would recommend profiling your app to see if using a heap allocation is actually discernibly slower than the constant sized array on the stack
p21495
aVModern heaps peform very well
p21496
aVDon't optimise your code in a way that obfuscates it unless there is a significant benefit
p21497
as(dp21498
g7
V505088
p21499
stp21500
a((dp21501
g2
(lp21502
VThe first issue is that the file is only created when you write something to the ini file
p21503
aVI suspect that at present you aren't calling one of the  methods
p21504
aVThe other issue is that if you don't qualify your path then  will attempt to locate it in the Windows directory and of course you don't have rights to write there
p21505
aVThe underlying API that  is based on is the private profile API which has been long deprecated, performs terribly, and is full of strange wrinkles
p21506
aVThe documentation states:
p21507
aVIf the lpFileName parameter does not contain a full path and file name for the file, WritePrivateProfileString searches the Windows directory for the file
p21508
aVIf the file does not exist, this function creates the file in the Windows directory
p21509
aVClearly you should fully qualify your path
p21510
aVHowever, I strongly recommend that you consider using  rather than  since  avoids all the pitfalls of the private profile API
p21511
aVIf you do switch to  then remember to call  before destroying the ini file since this is what will save the settings to the disk
p21512
aVOtherwise  is a drop-in replacement for
p21513
as(dp21514
g7
V505088
p21515
stp21516
a((dp21517
g2
(lp21518
VI'm guessing you are passing  as the parent window
p21519
aVPass the window handle of your main application's window
p21520
aVWhen you pass  the created window is an unowned top-level window and they get taskbar buttons
p21521
as(dp21522
g7
V505088
p21523
stp21524
a((dp21525
g2
(lp21526
VGet the process ID by calling
p21527
aVYou don't need to convert that into a binary representation since integral types are already stored in binary
p21528
aVJust write it to the file
p21529
as(dp21530
g7
V505088
p21531
stp21532
a((dp21533
g2
(lp21534
VStandard users don't have write access to HKLM
p21535
aVYou need to run this process elevated
p21536
as(dp21537
g7
V505088
p21538
stp21539
a((dp21540
g2
(lp21541
VYes this is very easy to do
p21542
aVYou just need to buy the full version
p21543
aVThat doesn't have the nag messages
p21544
as(dp21545
g7
V505088
p21546
stp21547
a((dp21548
g2
(lp21549
VYou can try  for keyboard input
p21550
aVFor more control, and mouse events too, you should P/invoke
p21551
aVBe warned that this is difficult to get right and you may find alternative approaches more amenable
p21552
as(dp21553
g7
V505088
p21554
stp21555
a((dp21556
g2
(lp21557
VCall  passing 2 as the radix
p21558
aVMake sure you don't overrun your buffer
p21559
aVNote: This isn't part of any C or C++ standard so be warned it is not portable
p21560
aVBut you asked for ease rather than portability
p21561
as(dp21562
g7
V505088
p21563
stp21564
a((dp21565
g2
(lp21566
VNo, the framework doesn't do this
p21567
aVYou would have to build your API to minimise the managed-to-unmanaged switches
p21568
as(dp21569
g7
V505088
p21570
stp21571
a((dp21572
g2
(lp21573
VProbably the easiest approach is to use the boost memory mapped file classes which give the additional benefit of being portable
p21574
as(dp21575
g7
V505088
p21576
stp21577
a((dp21578
g2
(lp21579
VUse tkinter
p21580
aVttk to get the the themed version of Tk
p21581
as(dp21582
g7
V505088
p21583
stp21584
a((dp21585
g2
(lp21586
VYour dialog procedure looks all wrong
p21587
aVYou are attempting to send WM_SETTEXT every single time the dialog procedure runs
p21588
aVThat probably sets up an infinite recursion and probably all sorts of other issues
p21589
aVYour  call is absolutely fine, you just can't make it every time the dialog procedure runs
p21590
aVI don't understand what the  function is all about
p21591
aVThe design of your framework is very odd
p21592
aVI suggest you look at some other frameworks (e
p21593
ag217
aVATL) first to get some ideas on how to write a framework around Win32
p21594
aVOr, even better, just use an existing framework
p21595
as(dp21596
g7
V505088
p21597
stp21598
a((dp21599
g2
(lp21600
VYou should use the  method of
p21601
aVThe equivalent to your Delphi code is:
p21602
as(dp21603
g7
V505088
p21604
stp21605
a((dp21606
g2
(lp21607
VYou can't mix HTML and an image in the same document like that
p21608
aVUse the  tag to embed images in your HTML
p21609
as(dp21610
g7
V505088
p21611
stp21612
a((dp21613
g2
(lp21614
VThe  parameter is wrong here:
p21615
aVYou should pass  because of the zero-terminator
p21616
as(dp21617
g7
V505088
p21618
stp21619
a((dp21620
g2
(lp21621
VUse
p21622
aVFor example,
p21623
as(dp21624
g7
V505088
p21625
stp21626
a((dp21627
g2
(lp21628
VIs it safe/practical to manually update shell32
p21629
aVdll in
p21630
aVWindows XP
p21631
aVNo
p21632
as(dp21633
g7
V505088
p21634
stp21635
a((dp21636
g2
(lp21637
VYour fundamental problem is the hard address space limit of 4GB for 32 bit processes
p21638
aVSince you are hitting problems at 3GB I can only presume that you are using  running on 64 bit Windows or 32 bit Windows with the /3GB boot switch
p21639
aVI think you have a few options, including but not limited to the following:
p21640
aVUse less memory
p21641
aVPerhaps you can process in smaller chunks or push some of the memory to disk
p21642
aVUse 64 bit Delphi (just released) or FreePascal
p21643
aVThis relieves you of the address space constraint but constrains you to 64 bit versions of Windows
p21644
aVUse memory mapped files
p21645
aVOn a machine with a lot of memory this is a way of getting access to the OS memory cache
p21646
aVMemory mapped files are not for the faint hearted
p21647
aVI can't advise definitively on a solution since I don't know your architecture but in my experience, reducing your memory footprint is often the best solution
p21648
aVUsing a different allocator is likely to make little difference
p21649
aVYes it is true that there are low-fragmentation allocators but they surely won't really solve your problem
p21650
aVAll they could do would be make it slightly less likely to arise
p21651
as(dp21652
g7
V505088
p21653
stp21654
a((dp21655
g2
(lp21656
VThat's determined by the system when it registers the window class
p21657
aVIt is presumably implemented in comctl32
p21658
aVThere's nothing special about one of the built-in window classes in this regard
p21659
aVJust as is the case for a user defined class, the default window proc is whatever was specified when the class was registered
p21660
as(dp21661
g7
V505088
p21662
stp21663
a((dp21664
g2
(lp21665
VThe documentation for  states:
p21666
aVThe file name used to initialize the File Name edit control
p21667
aVThe first character of this buffer must be NULL if initialization is not necessary
p21668
aVWhen the GetOpenFileName or GetSaveFileName function returns successfully, this buffer contains the drive designator, path, file name, and extension of the selected file
p21669
aVYou are not initializing  and therein lies the problem
p21670
aVYou can solve the problem by writing  before you call
p21671
as(dp21672
g7
V505088
p21673
stp21674
a((dp21675
g2
(lp21676
VStop using ExactSpelling and then you will link to GetJobA or GetJobW as appropriate
p21677
as(dp21678
g7
V505088
p21679
stp21680
a((dp21681
g2
(lp21682
VPerhaps you are thinking of SWIG
p21683
as(dp21684
g7
V505088
p21685
stp21686
a((dp21687
g2
(lp21688
VI have heard - not tested - that some programs perform better on startup when compressed because reading from the harddisk is more expensive than decompressing
p21689
aVSometimes the opposite is true because the program only needs to load code pages on demand
p21690
aVBut it can't do this is the exe is compressed
p21691
aVIf you have multiple instances of your executable running, then the memory will be shared between each instance
p21692
aVBut if you compress them this is no longer the case
p21693
aVAs for downloading, surely what is downloaded is an install package which is compressed
p21694
aVIn short, I really don't think executable compressors are worthwhile
p21695
as(dp21696
g7
V505088
p21697
stp21698
a((dp21699
g2
(lp21700
VYou appear to be omitting the version resource when linking your executable
p21701
aVThat MSDN article includes the following sample resource:
p21702
as(dp21703
g7
V505088
p21704
stp21705
a((dp21706
g2
(lp21707
VIf you aren't using RTTI you can add this to the top of your
p21708
aVdpr file (immediately after ) to remove the extra RTTI information:
p21709
aVIf you want to strip it out of all the RTL/VCL units then you'd need to include those in your project file too so that the settings above could take effect
p21710
aVI don't think I would recommend doing that since I don't believe the reduction in executable size is worth the complications of compiling your own RTL/VCL
p21711
aVYou can also add the following, again somewhere in your
p21712
aVdpr file:
p21713
aVThis will strip the relocation information which is not needed in a
p21714
aVexe
p21715
aVDon't add this to a DLL or package
p21716
as(dp21717
g7
V505088
p21718
stp21719
a((dp21720
g2
(lp21721
VA thread function is just the entry/exit point of a thread
p21722
aVThe execution of that function is no different from what you refer to as a normal function
p21723
as(dp21724
g7
V505088
p21725
stp21726
a((dp21727
g2
(lp21728
VAccording to Hans' comment in your other question, you can use GetModuleHandle to get the handle to the already loaded CRT
p21729
aVLike this:
p21730
aVFor what it's worth,  actually refers to the Windows system supplied C runtime, which is named  and resides in your  directory
p21731
as(dp21732
g7
V505088
p21733
stp21734
a((dp21735
g2
(lp21736
VYou have to walk the directory structure adding each file individually
p21737
aVUse whichever directory walker technique you prefer
p21738
as(dp21739
g7
V505088
p21740
stp21741
a((dp21742
g2
(lp21743
VEffect this change by modifying the position of the panels:
p21744
as(dp21745
g7
V505088
p21746
stp21747
a((dp21748
g2
(lp21749
VIt's undefined behaviour according to the C++ standard:
p21750
aVThe value of E1 << E2 is E1
p21751
aVleft-shifted E2 bit positions; vacated
p21752
aVbits are zero-filled
p21753
aVIf E1 has an
p21754
aVunsigned type, the value of the result
p21755
aVis E1  2E^2, reduced modulo one more
p21756
aVthan the maximum value representable
p21757
aVin the result type
p21758
aVOtherwise, if E1
p21759
aVhas a signed type and non-negative
p21760
aVvalue, and E12E^2 is representable in
p21761
aVthe result type, then that is the
p21762
aVresulting value; otherwise, the
p21763
aVbehavior is undefined
p21764
as(dp21765
g7
V505088
p21766
stp21767
a((dp21768
g2
(lp21769
VCreate the form like this:
p21770
aVAssuming you have implemented a method on  to update the values, call it:
p21771
aVShow the form in the usual way:
p21772
as(dp21773
g7
V505088
p21774
stp21775
a((dp21776
g2
(lp21777
VDon't bother with RTTI, just use a cast:
p21778
aVIf casting is not an option then use an interface
p21779
as(dp21780
g7
V505088
p21781
stp21782
a((dp21783
g2
(lp21784
VYou probably won't be able to invoke the function directly because an XLL will expect the Excel interfaces to be driving
p21785
aVYou'd have to do some serious faking
p21786
aVAutomating it through Excel will work though
p21787
as(dp21788
g7
V505088
p21789
stp21790
a((dp21791
g2
(lp21792
VCall GetModuleInformation()
p21793
as(dp21794
g7
V505088
p21795
stp21796
a((dp21797
g2
(lp21798
VYou need to create a hidden (i
p21799
ag192
aVnon-visible) window to be the parent
p21800
aVHere is a sample console app that proves that this approach works
p21801
as(dp21802
g7
V505088
p21803
stp21804
a((dp21805
g2
(lp21806
VNegative lock count is normal behaviour on some Windows versions
p21807
aVNote that the meaning of this field has changed during the lifetime of Windows (see below)
p21808
aVInterpreting these private fields is a tricky business and you may benefit from using dedicated critical section debugging tools
p21809
aVFor example, see this MSDN article gives some details
p21810
aVIn particular I think it shows why a value of -6 is perfectly plausible
p21811
aVSome pertinent excerpts:
p21812
aVCritical sections can be displayed in user mode by a variety of different methods
p21813
aVThe exact meaning of each field depends on the version of Microsoft Windows version you are using
p21814
aVIn Microsoft Windows 2000, and Windows XP, the LockCount field indicates the number of times that any thread has called the EnterCriticalSection routine for this critical section, minus one
p21815
aVThis field starts at -1 for an unlocked critical section
p21816
aVEach call of EnterCriticalSection increments this value; each call of LeaveCriticalSection decrements it
p21817
aVFor example, if LockCount is 5, this critical section is locked, one thread has acquired it, and five additional threads are waiting for this lock
p21818
aVIn Microsoft Windows Server 2003 Service Pack 1 and later versions of
p21819
aVWindows, the LockCount field is parsed as follows:
p21820
aVThe lowest bit shows the lock status
p21821
aVIf this bit is 0, the critical
p21822
aVsection is locked; if it is 1, the critical section is not locked
p21823
aVThe next bit shows whether a thread has been woken for this lock
p21824
aVIf
p21825
aVthis bit is 0, then a thread has been woken for this lock; if it is 1,
p21826
aVno thread has been woken
p21827
aVThe remaining bits are the ones-complement of the number of threads
p21828
aVwaiting for the lock
p21829
aVIt then goes on to explain how to interpret a lock count of
p21830
aVSo, in summary, it's trickier than you might think
p21831
as(dp21832
g7
V505088
p21833
stp21834
a((dp21835
g2
(lp21836
VThe calling code should be written with a using block and that will ensure  is called
p21837
aVIDisposable is the way to control when disposal of resources happen, so returning an object that implements IDisposable is a standard idiom
p21838
as(dp21839
g7
V505088
p21840
stp21841
a((dp21842
g2
(lp21843
VIn C++ code there is no reason whatsoever to use void in this way
p21844
aVWhat's more it is very much not the idiomatic way to declare parameterless functions
p21845
as(dp21846
g7
V505088
p21847
stp21848
a((dp21849
g2
(lp21850
VThere is no  operator in C
p21851
as(dp21852
g7
V505088
p21853
stp21854
a((dp21855
g2
(lp21856
VQuestion 1
p21857
aVYour problem is not with , it is simply that you have not defined
p21858
aVQuestion 2
p21859
aVOne simple way to enumerate files in a directory is
p21860
as(dp21861
g7
V505088
p21862
stp21863
a((dp21864
g2
(lp21865
VThe best you can do in C is to use a single macro to define both the string and the variable
p21866
aVThere's no runtime inspection that would allow you to rediscover the name of a variable
p21867
as(dp21868
g7
V505088
p21869
stp21870
a((dp21871
g2
(lp21872
VThe most common approach is to use the Windows API Code Pack
p21873
aVI wouldn't recommend trying to P/invoke this yourself
p21874
as(dp21875
g7
V505088
p21876
stp21877
a((dp21878
g2
(lp21879
V never places any restrictions on method calls in Delphi, be they on records or instances of classes
p21880
aVSo I don't think there is anything inconsistent with the treatment of method calls
p21881
aVIf methods could not be called on record passed as a  parameter, then that would pretty much render records with methods useless
p21882
aVIt would mean, for example, that a property getter could not be called
p21883
aVIn order to place restrictions on such records passed as , there would need to be an equivalent concept to the const member functions of C++
p21884
aVThat would allow the compiler to know that certain methods were non-mutating
p21885
as(dp21886
g7
V505088
p21887
stp21888
a((dp21889
g2
(lp21890
VThe scoped name you need is
p21891
as(dp21892
g7
V505088
p21893
stp21894
a((dp21895
g2
(lp21896
VYou can't show UI from a service
p21897
aVServices run in session 0 and there is no desktop
p21898
aVWhat's more services run when there are no logged on users
p21899
aVAgain there is no desktop
p21900
aVYou have a couple of options:
p21901
aVLog your messages rather than attempt to show them
p21902
aVHave a helper application that runs as a standard user app on the logged on user's desktop
p21903
aVThis app can show UI
p21904
aVCommunicate between the service and the app via an IPC mechanism of your choice
p21905
as(dp21906
g7
V505088
p21907
stp21908
a((dp21909
g2
(lp21910
VYou need a member field to hold the reference to the form
p21911
aVThen check whether that reference is assigned
p21912
aVLike this:
p21913
as(dp21914
g7
V505088
p21915
stp21916
a((dp21917
g2
(lp21918
VThe manifest is fine
p21919
aVTherefore the problem must be in your code
p21920
aVCreating a themed application isn't quite the same as a non-themed one
p21921
as(dp21922
g7
V505088
p21923
stp21924
a((dp21925
g2
(lp21926
VThat's quite a large surface area
p21927
aVI think C++/CLI will be easier than P/invoke
p21928
aVYou don't need to use any C++ features, you can write what is essentially C and compile and export it with C++/CLI
p21929
as(dp21930
g7
V505088
p21931
stp21932
a((dp21933
g2
(lp21934
VIn WinForms the standard way to do this is to add a group box and then add radio buttons to that group box
p21935
aVThe radio buttons will automatically be grouped
p21936
aVBut there's nothing like the VCL  property so you'll have to use the  property of each radio button to determine which item is selected
p21937
aVI believe that most of the 3rd party component vendors (e
p21938
ag217
aVdevexpress) fill this gap in the standard component set by providing radio group controls similar to that found in the VCL
p21939
as(dp21940
g7
V505088
p21941
stp21942
a((dp21943
g2
(lp21944
VAll the buffer allocation and pointer arithmetic is getting in the way of understanding
p21945
aVEssentially the issue is that char has a limited range, typically -127 to 128 or 0 to 255
p21946
aVThe simplest way to see your problem is with code like this:
p21947
aVFrom what you have said in the comments, it sounds like you want to cast the char* to int* and write over the buffer that way
p21948
aVI hope you know what you are doing
p21949
as(dp21950
g7
V505088
p21951
stp21952
a((dp21953
g2
(lp21954
VMy guess is that your assembly stomps over something (possibly a register) which means that the  fails and the buffer just contains random stack noise
p21955
aVCheck this out by removing the assembly
p21956
as(dp21957
g7
V505088
p21958
stp21959
a((dp21960
g2
(lp21961
VThat's technically impossible for window that is not an child of the MDI container
p21962
aVThe MDI children are child windows of the MDI container which is a child of the main form
p21963
aVIf a window is in front of the main form, then it is in front of the MDI children
p21964
aVIf it is behind the main form, then it is behind the MDI children
p21965
as(dp21966
g7
V505088
p21967
stp21968
a((dp21969
g2
(lp21970
VSertac has explained why your code doesn't work
p21971
aVIn order to implement a list of such things in Delphi 7 you can do something like this
p21972
aVDisclaimer: completely untested code, use at your own risk
p21973
as(dp21974
g7
V505088
p21975
stp21976
a((dp21977
g2
(lp21978
VThe Windows shell has full and comprehensive support for this
p21979
aVCall  to get an  for the desktop
p21980
aVCall  to get the contents
p21981
aVThis Code Project article gives some usage examples from a C# perspective
p21982
as(dp21983
g7
V505088
p21984
stp21985
a((dp21986
g2
(lp21987
VI can reproduce this and it is very clearly a bug in the default comparer for methods
p21988
aVI have filed QC#98942
p21989
aVHere's my code:
p21990
aVOutput
p21991
aVExpected output
p21992
aVThe default comparer in  is implemented like this:
p21993
aVI can understand what this is attempting to do, but it fails miserably
p21994
aVI still can't work out how these casts pan out
p21995
aVI believe that the 32 bit version of  should have been written this way:
p21996
aVAnd this does lead to the expected output
p21997
aVClearly for a 64 bit target (i
p21998
ag192
aVin XE2) no approach based on aliasing with a 64 bit integer will work
p21999
aVSo, in order to workaround the bug, you can add the following functions:
p22000
aVAnd then create the list like this:
p22001
as(dp22002
g7
V505088
p22003
stp22004
a((dp22005
g2
(lp22006
VWhen a process is started, there is no information passed that identifies the shortcut that was used to invoke the new process
p22007
aVYou need to use command-line arguments to pass startup parameters to the new process
p22008
as(dp22009
g7
V505088
p22010
stp22011
a((dp22012
g2
(lp22013
VNow that I finally understand the question, I believe that the most efficient solution is to use interlocked operations
p22014
aVThis approach will not permit re-entrant calls
p22015
aVIf you need to cater for re-entrant calls then the solution is to use
p22016
aVCritical sections are much easier to use than mutexes, and they are faster too
p22017
aVDelphi wraps up the critical section API in the  object in the SyncObjs unit
p22018
aVSo your code would look like this:
p22019
as(dp22020
g7
V505088
p22021
stp22022
a((dp22023
g2
(lp22024
VOne simple approach, commonly used, is to set the  property of the action
p22025
aVIt should be different for each action, obviously
p22026
aVThen you change your execute handler like so:
p22027
as(dp22028
g7
V505088
p22029
stp22030
a((dp22031
g2
(lp22032
VIt is true that  is not quite enough to match the functionality of
p22033
aVBut you just need to use  as well
p22034
aVmatches  called with the  parameter set to ,
p22035
aVmatches it with  set to
p22036
as(dp22037
g7
V505088
p22038
stp22039
a((dp22040
g2
(lp22041
V and its various RTL descendents do not have any bugs that result in buffer overruns, to the best of my knowledge
p22042
aVHowever, your code using Delphi streams could easily overrun a buffer
p22043
as(dp22044
g7
V505088
p22045
stp22046
a((dp22047
g2
(lp22048
VSince you are compiling it from source you can just add the source files to your project and build it right into your executable
p22049
as(dp22050
g7
V505088
p22051
stp22052
a((dp22053
g2
(lp22054
VThere is no way to have a single native executable compiled from C++ source that works on different platforms
p22055
aVI don't believe you that the same executable file is run on Windows and Linux, as you state in your second paragraph
p22056
as(dp22057
g7
V505088
p22058
stp22059
a((dp22060
g2
(lp22061
V has one member,
p22062
aVThis is called when you choose to call it
p22063
aVMost typically that's done for you by the framework with the  block syntactic sugar
p22064
as(dp22065
g7
V505088
p22066
stp22067
a((dp22068
g2
(lp22069
VAll popular C++ compilers support XP up
p22070
aVYou can statically link the runtime, or, for mingw, you can link against the runtime supplied with Windows
p22071
as(dp22072
g7
V505088
p22073
stp22074
a((dp22075
g2
(lp22076
VYou need to take into account registry redirection, that's the real issue here
p22077
aVOn a 32 bit machine, the key you need doesn't have WoW6432Node in the path
p22078
aVWhat you are trying to do is to delete
p22079
aVfrom the 32 bit view of the registry
p22080
aVMicrosoft are very clear that you should not hard code WoW6432Node in your apps
p22081
aVRedirected keys are mapped to physical locations under Wow6432Node
p22082
aVFor example, HKEY_LOCAL_MACHINE\u005cSoftware is redirected to HKEY_LOCAL_MACHINE\u005cSoftware\u005cWow6432Node
p22083
aVHowever, the physical location of redirected keys should be considered reserved by the system
p22084
aVApplications should not access a key's physical location directly, because this location may change
p22085
aVSo delete that key by calling
p22086
aVBut use the redirector to ensure that you operate on the 32 bit view of the registry
p22087
aVIn
p22088
aVnet you can achieve what you need in two ways
p22089
aVTarget x86 and let redirection do the work for you
p22090
aVIf you target x64 or AnyCPU you need to use  (new in
p22091
aVnet 4) to open a 32 bit view of the registry
p22092
aVIf you don't have
p22093
aVnet 4 then you have to P/invoke
p22094
as(dp22095
g7
V505088
p22096
stp22097
a((dp22098
g2
(lp22099
V is
p22100
aVAs for why  is in 1753, that's answered here: SqlDateTime
p22101
aVMinValue
p22102
aV= DateTime
p22103
aVMinValue, why
p22104
aVand here: What is the significance of 1/1/1753 in SQL Server
p22105
as(dp22106
g7
V505088
p22107
stp22108
a((dp22109
g2
(lp22110
VI'd start by looking at libffi
p22111
as(dp22112
g7
V505088
p22113
stp22114
a((dp22115
g2
(lp22116
V is pointing to memory allocated by the compiler, typically read-only memory
p22117
aVThe compiler will emit  into a read-only section of the executable and then arrange that the assignment to  makes  point to that location
p22118
as(dp22119
g7
V505088
p22120
stp22121
a((dp22122
g2
(lp22123
VYou cannot do this by fair means
p22124
aVNo such API exists
p22125
aVThere are, of course, various hacky ways to find it out, but I won't get into that
p22126
aVNormally what you want to do is show a menu in response to a click on the tray icon
p22127
aVThe message that Windows sends you when this happens contains the cursor coordinates where the click occurred
p22128
aVThat's usually enough information to show whatever it is you show in response to the click
p22129
aVIn C# this translates to reading the coordinates out of the  in
p22130
as(dp22131
g7
V505088
p22132
stp22133
a((dp22134
g2
(lp22135
VYou aren't using the correct editor, so far as I can tell
p22136
aVis described thus:
p22137
aVAn editor that provides default behavior for the double-click that will iterate through the properties looking the the most appropriate method property to edit
p22138
aVThis is an editor that responds to double clicks on the form by dropping you into the code editor with a newly created event handler
p22139
aVThink of what happens when you double click a  and you are dropped in to the  handler
p22140
aVIt's been a long time since I wrote a design time editor (I hope my memory is working today) but I believe your editor should be derived from
p22141
aVIn order to show the collection editor you call  from the  unit
p22142
aVYou can override the  method of  and call  from there
p22143
aVIf you want to be more advanced, as an alternative you can declare some verbs with ,  and
p22144
aVIf you do it this way then you extend the context menu and the default  implementation will execute verb 0
p22145
as(dp22146
g7
V505088
p22147
stp22148
a((dp22149
g2
(lp22150
VYour 32 bit pointers are not wide enough to store addresses in the 64 bit address space of the target process and will be truncated
p22151
aVThus, what you are attempting is impossible
p22152
aVThis is one of the situations where Raymond Chen would advise you to stop using the emulator
p22153
aVHaving invoked Raymond Chen's name, I did a quick search to see if he had any useful nuggets
p22154
aVThat search turned up this article: Why is there no supported way to get the command line of another process
p22155
aVThe useful nugget is the observation that  gives you what you need (somehow)
p22156
aVSo, my advice is to give WMI a go
p22157
as(dp22158
g7
V505088
p22159
stp22160
a((dp22161
g2
(lp22162
VIt's exceedingly unlikely that you could achieve this
p22163
aVYou can use  and keyboard hooks to intercept the hot key and subsequent typing
p22164
aVThat's not too bad
p22165
aVWhat you won't be able to manage is to arrange that the text you type will appear highlighted
p22166
aVYou'd have to special case many of the target applications
p22167
aVApplications like web browsers often don't use windowed controls for their input fields
p22168
aVThere's no easy way to highlight the text as it is typed into those fields
p22169
aVYour question used terms like "system-wide" and "any given text field"
p22170
aVThat's just not a realistic goal
p22171
aVMaking this work for a single class of fields in a certain apps sounds more plausible
p22172
aVYou may be able to do it when the text is going to land in a windowed edit control
p22173
aVAlthough even that sounds fraught with potential threading conflicts
p22174
aVYou may also be able to make some headway with apps that support UIautomation, but again it doesn't seem like it would be very easy and many apps don't support UIautomation
p22175
as(dp22176
g7
V505088
p22177
stp22178
a((dp22179
g2
(lp22180
VThis addresses the original question before the extensive edit
p22181
aVIt fails because, the way you have written it can only work when you call from the process that owns the target window handle
p22182
aVThis is because you pass a pointer, but that is only valid in your process
p22183
aVAs soon as it lands in the other process it refers to an address that is meaningless
p22184
aVAnd even if it did mean something, a process can't read another processes memory with help from the system
p22185
aVNaturally explorer bombs
p22186
aVThe solution is to use  to allocate memory in the explorer process
p22187
aVThen send the message
p22188
aVThen use  to marshal the contents of the rect back into your process
p22189
aVThe most commonly cited code sample for this is this Code Project article
p22190
aVThat example is using  but the principles are identical
p22191
as(dp22192
g7
V505088
p22193
stp22194
a((dp22195
g2
(lp22196
VWhich is semantically correct
p22197
aVSemantically they are identical
p22198
aVTherefore which you use is a matter of taste
p22199
aVWhich taste should you prefer
p22200
aVWell, you can write  and think that you have declared two pointers
p22201
aVOf course you have not, you have declared  to be a pointer and  as an object
p22202
aVSo you should certainly prefer  to
p22203
aVHowever, I believe it is better still to have a single line for each variable declaration:
p22204
aVThis approach has no scope for confusion and is recommended by many coding style guidelines
p22205
as(dp22206
g7
V505088
p22207
stp22208
a((dp22209
g2
(lp22210
VThreads that kill themselves present problems
p22211
aVYou have to synchronise with the main thread when the thread does kill itself
p22212
aVIt sounds to me as though you would be better off with a single dedicated thread that did the work
p22213
aVUse a blocking queue and implement the producer/consumer pattern
p22214
aVRather than kill the thread when it has nothing to do, let it sit idle until more work arrives
p22215
as(dp22216
g7
V505088
p22217
stp22218
a((dp22219
g2
(lp22220
V is not exactly representable to double precision
p22221
aVThe closest double precision number (as found here) is , which agrees with your findings
p22222
aVYou ask why the conversion to decimal does not contain more precision
p22223
aVThe documentation for  has the answer:
p22224
aVThe Decimal value returned by this method contains a maximum of 15 significant digits
p22225
aVIf the value parameter contains more than 15 significant digits, it is rounded using rounding to nearest
p22226
aVThe following example illustrates how the Convert
p22227
aVToDecimal(Double) method uses rounding to nearest to return a Decimal value with 15 significant digits
p22228
aVThe double value, rounded to nearest at 15 significant figures is , exactly as you show above
p22229
as(dp22230
g7
V505088
p22231
stp22232
a((dp22233
g2
(lp22234
VIs there a way to change the session of a windows service and get the desktop screen of another user's session like session 1, session 2
p22235
aVNo
p22236
aVIs there a way to start a console application which runs in an another session other than session 0 from a windows service
p22237
aVThis can be done but it's messy
p22238
aVIt involves impersonation of the logged on user, manipulation of user tokens, and launching a process into a different session with
p22239
aVThis article describes what is needed
p22240
aVAs an aside, you don't want a console application because that will splat a console window on your screenshot
p22241
aVYou just want a standard Windows app (using the GUI subsystem) but one that does not show any visible windows
p22242
as(dp22243
g7
V505088
p22244
stp22245
a((dp22246
g2
(lp22247
VBy far the easiest way to be sure that you have access to a file system object is to attempt to access it
p22248
aVIf it fails with an Access Denied error, then you don't have access
p22249
aVJust detect that error condition and proceed with the next item in the search
p22250
aVIn other words, delegate checking access to the system which is, after all, the ultimate arbiter of access rights
p22251
as(dp22252
g7
V505088
p22253
stp22254
a((dp22255
g2
(lp22256
VYou could sort them in the dfm file
p22257
aVYou would want to write a little utility script to do it
p22258
aVOr a workaround would be to use categories to make the list of actions more manageable
p22259
as(dp22260
g7
V505088
p22261
stp22262
a((dp22263
g2
(lp22264
VThe tool is confused somehow
p22265
aVThere's no casting here
p22266
aVThose parentheses just indicate precedence
p22267
as(dp22268
g7
V505088
p22269
stp22270
a((dp22271
g2
(lp22272
VYou can call CreateProcess with the CREATE_NO_WINDOW
p22273
aVflag
p22274
aVThis is obviously non portable but it does get the job done
p22275
as(dp22276
g7
V505088
p22277
stp22278
a((dp22279
g2
(lp22280
VYou are missing the C++ runtime on the target machine
p22281
aVYou can either:
p22282
aVInstall the redistributable package for the runtime on the target machine
p22283
aVLink to the runtime statically using the /MT switch
p22284
as(dp22285
g7
V505088
p22286
stp22287
a((dp22288
g2
(lp22289
VFor a Windows file manager SHFileOperation() is possible a better fit than CopyFileEx()
p22290
aVThis will result in the native sheall dialogs for progress, conflict resolution etc
p22291
aVThe levels of progress and error reporting can all be controlled
p22292
as(dp22293
g7
V505088
p22294
stp22295
a((dp22296
g2
(lp22297
VIf you have a console process you can call GetConsoleWindow and then GetWindowRect
p22298
as(dp22299
g7
V505088
p22300
stp22301
a((dp22302
g2
(lp22303
VBy and large you can't do this in a meaningful way
p22304
aVYou might be pre-empted by the scheduler mid way through asking the question and resume on a different processor
p22305
as(dp22306
g7
V505088
p22307
stp22308
a((dp22309
g2
(lp22310
VUse the DownloadFile method from System
p22311
aVNet
p22312
aVWebClient
p22313
as(dp22314
g7
V505088
p22315
stp22316
a((dp22317
g2
(lp22318
VWindows trims the working set of a process when its main window is minimized
p22319
aVThe working set isn't necessarily the best indicator of how much system resources a process is using
p22320
as(dp22321
g7
V505088
p22322
stp22323
a((dp22324
g2
(lp22325
VThe extern "C" is inappropriate for DllImport
p22326
aVThat's the source of the error
p22327
aVThe problem is that you are declaring your P/invoke inside a class
p22328
aVAs far as I can tell, in C++ they are meant to be declared as free functions outside any classes
p22329
aVI've not found much documentation for P/invoke from C++/CLI, probably because P/invoke is not needed from C++/CLI
p22330
aVYou don't need P/invoke with C++/CLI because the compiler can include standard C++ header files and link against native libraries
p22331
aVJust include windows
p22332
aVh and call the Win32 APIs with no futher effort
p22333
aVThat's one of the best points of C++/CLI
p22334
as(dp22335
g7
V505088
p22336
stp22337
a((dp22338
g2
(lp22339
VAssuming that your issue is simply that Notepad++ is incorrectly guessing the encoding you can  solve the problem by manually setting the encoding in Notepad++, like this:
p22340
as(dp22341
g7
V505088
p22342
stp22343
a((dp22344
g2
(lp22345
VYou can't pass Delphi objects between modules unless you take steps to ensure that those modules share the same runtime and memory allocator
p22346
aVIr appears you have not taken such steps
p22347
aVThe basic problem is that a Delphi object is both data and code
p22348
aVIf you naively call a method on an object that was created in a different module then you execute code from this module on data from that module
p22349
aVThat typically ends in runtime errors
p22350
aVYou have at least the following options:
p22351
aVUse runtime packages
p22352
aVThis will enforce a shared runtime
p22353
aVUse COM interop
p22354
aVCOM was designed for sharing components across module boundaries
p22355
aVLink all code into a single executable
p22356
aVPass HBITMAPs between the modules since they can be shared in such a manner
p22357
as(dp22358
g7
V505088
p22359
stp22360
a((dp22361
g2
(lp22362
VIn a multi-threaded setting, with thread reading and writing, your first and second examples have different meaning
p22363
aVYour third example could have yet another meaning if "do something with item" interacts with other threads
p22364
aVYou need to decide what you want the code to do before deciding how to do it
p22365
as(dp22366
g7
V505088
p22367
stp22368
a((dp22369
g2
(lp22370
VIt's quite plausible that wcstombs will do what you need if what you actually want to do is convert from wide characters to the current locale
p22371
aVIf not then you probably need to look to ICU, boost or similar
p22372
as(dp22373
g7
V505088
p22374
stp22375
a((dp22376
g2
(lp22377
VYes it is fine to call  from the thread that owns the handle
p22378
aVThe overwhelming majority of code samples suggest that you should test  before deciding whether or not to call
p22379
aVHowever, this leads to rather cluttered code and if you must support calls from non-GUI threads then I recommend that you simply call  directly in all cases
p22380
aVThere is a small overhead versus calling  and then the delgate directly - see Hans Passant's comments to the question
p22381
aVHowever, so long as the delegate is performing significant work, or this code is not in a hot spot, the overhead should matter less than the code clarity
p22382
aVWhat's more  can give misleading results in the control's handle has not yet been allocated
p22383
aVThe documentation states:
p22384
aVIf the control's handle does not yet exist, InvokeRequired searches up
p22385
aVthe control's parent chain until it finds a control or form that does
p22386
aVhave a window handle
p22387
aVIf no appropriate handle can be found, the
p22388
aVInvokeRequired method returns false
p22389
aVThis means that InvokeRequired can return false if Invoke is not
p22390
aVrequired (the call occurs on the same thread), or if the control was
p22391
aVcreated on a different thread but the control's handle has not yet
p22392
aVbeen created
p22393
aVIn the case where the control's handle has not yet been created, you
p22394
aVshould not simply call properties, methods, or events on the control
p22395
aVThis might cause the control's handle to be created on the background
p22396
aVthread, isolating the control on a thread without a message pump and
p22397
aVmaking the application unstable
p22398
aVYou can protect against this case by also checking the value of
p22399
aVIsHandleCreated when InvokeRequired returns false on a background
p22400
aVthread
p22401
aVIf the control handle has not yet been created, you must wait
p22402
aVuntil it has been created before calling Invoke or BeginInvoke
p22403
aVTypically, this happens only if a background thread is created in the
p22404
aVconstructor of the primary form for the application (as in
p22405
aVApplication
p22406
aVRun(new MainForm()), before the form has been shown or
p22407
aVApplication
p22408
aVRun has been called
p22409
aVSo I would take the advice from the final quoted paragraph above and replace the risky  code above with:
p22410
as(dp22411
g7
V505088
p22412
stp22413
a((dp22414
g2
(lp22415
VThat code doesn't produce what you say it does on any version of Python
p22416
aVOn Python 2,  prints a tuple
p22417
aVOn Python 3,  is a function and so there is no tuple
p22418
aVOn Python 2 the output is:
p22419
aVOn Python 3 the output is:
p22420
aVIt's impossible to help much more than that until you post the code you are really using
p22421
as(dp22422
g7
V505088
p22423
stp22424
a((dp22425
g2
(lp22426
VThe technique of debugging a DLL is described here on MSDN
p22427
aVYou'll need to do this from Visual Studio 6 (i
p22428
ag192
aVthe tool that developed the DLL) and so the terminology will have changed
p22429
aVBut the principles remain the same
p22430
as(dp22431
g7
V505088
p22432
stp22433
a((dp22434
g2
(lp22435
VI've downloaded that demo project from Code Project and I think the most likely cause of the problem is that the Visual Studio C++ 2008 runtime dependency is missing
p22436
aVSolve this by installing the runtime redistributable package on the machine
p22437
aVNote: I checked the dependencies of this DLL using Dependency Walker
p22438
aVYou can even run this in profiling mode so that it will tell you at runtime exactly which dependency is proving troublesome
p22439
as(dp22440
g7
V505088
p22441
stp22442
a((dp22443
g2
(lp22444
VWhy is x += 1 more efficient than x = x+1
p22445
aVIt isn't
p22446
aVWhy is x++ more efficient than x += 1
p22447
aVIt isn't
p22448
aVThe reason for preferring  to  comes about when  is replaced with a much longer identifier, or perhaps a field in a class or struct
p22449
aVIn that situation, the  version is more readable and even more importantly avoids the pitfalls of repeating yourself
p22450
as(dp22451
g7
V505088
p22452
stp22453
a((dp22454
g2
(lp22455
VDelphi 7 doesn't support Unicode VCL components
p22456
aVYou need to upgrade to the latest version of Delphi where all the available shell components have good support for Unicode
p22457
aVTrying to do this in Delphi 7 is simply impractical and nobody is going to invest time doing that nowadays
p22458
as(dp22459
g7
V505088
p22460
stp22461
a((dp22462
g2
(lp22463
VDeclare Unicode string literals with  prefix
p22464
aVThe  or  macros were for the bad old days when you wanted single source to compile for both Unicode and non-Unicode versions of Windows (Windows 9x)
p22465
aVThankfully you can safely ignore Windows 9x today
p22466
as(dp22467
g7
V505088
p22468
stp22469
a((dp22470
g2
(lp22471
VThis transition happened around the turn of the century
p22472
aV64 bit versions of Windows using the 64 bit version of Win32 have been in use for a long time now
p22473
aVHowever, the 64 bit version of Win32 is still known as Win32 since it is essentially an identical interface with the only major difference being different sized pointers
p22474
as(dp22475
g7
V505088
p22476
stp22477
a((dp22478
g2
(lp22479
VFrom your comment above, you describe calling the draw procedure of your application object form your main message loop
p22480
aVThis is almost certainly the source of your problem
p22481
aVNot only will it lead to flickering, it sounds like you are running your application at 100% CPU utilization which is not good
p22482
aVWhat you should do is handle the  message and only paint in response to that message
p22483
aVThat is how Windows GUI apps are meant to work
p22484
aVI recommend you read up in any introductory Windows GUI book
p22485
aVThe canonical such book is Petzold's Programming Windows
p22486
as(dp22487
g7
V505088
p22488
stp22489
a((dp22490
g2
(lp22491
VYet another Delphi language is Delphi Prism which is an object Pascal variant which targets
p22492
aVnet
p22493
aVYou can develop Visual Studio and MonoDevelop
p22494
as(dp22495
g7
V505088
p22496
stp22497
a((dp22498
g2
(lp22499
VUse
p22500
aVC# does not have a dedicated exponentiation operator and  fills the gap
p22501
as(dp22502
g7
V505088
p22503
stp22504
a((dp22505
g2
(lp22506
VYou are accessing the string out-of-bounds
p22507
aVString access is 1-based in Delphi
p22508
aVYou should be getting a range check error
p22509
aVAlso, I think you should prefer using  and  instead of the casts
p22510
aVI don't see that the code could work in earlier versions of Delphi
p22511
aVIndeed Delphi 2010 behaves exactly as you describe XE2 behaving once range checking is disabled
p22512
aVThis is yet another example of why range checking is so valuable
p22513
as(dp22514
g7
V505088
p22515
stp22516
a((dp22517
g2
(lp22518
VThere is nothing built in to C# to support modular arithmetic
p22519
aVYou need to implement it yourself, or better still, find a library
p22520
as(dp22521
g7
V505088
p22522
stp22523
a((dp22524
g2
(lp22525
VThese are two closely related terms in object oriented programming
p22526
aVThe standard meaning is that an object is an instance of a class
p22527
as(dp22528
g7
V505088
p22529
stp22530
a((dp22531
g2
(lp22532
VNote: I am assuming 8 bit char types
p22533
aVYou will overflow when you perform  for  equal to 255
p22534
aVAt that point the language standard decrees that  becomes 0, a phenomenon commonly known as wraparound
p22535
aVSo, you have an infinite loop, since  for all values of
p22536
as(dp22537
g7
V505088
p22538
stp22539
a((dp22540
g2
(lp22541
VSince you have chosen to use C++/CLI rather than P/invoke the natural way to handle this is to pass a
p22542
aVnet string rather than a
p22543
as(dp22544
g7
V505088
p22545
stp22546
a((dp22547
g2
(lp22548
VThere aren't any system wait functions that timeout at micro-second resolution
p22549
aVYou would need a busy loop and a high resolution timer
p22550
aVOf course, the system may preempt your thread anyway so you can forget about realtime guarantees on Windows
p22551
as(dp22552
g7
V505088
p22553
stp22554
a((dp22555
g2
(lp22556
VHaving given you advice about your data structure, and seen the ensuing struggles, I want to put things straight and explain more clearly what I mean
p22557
aVYou original code had two arrays that were essentially unconnected
p22558
aVYou could swap items in one array and easily forget to do so for the other array
p22559
aVIt looks to me like the name/age pairs really should not be split apart
p22560
aVThis leads to the following type declaration
p22561
aVNow you need to hold an array of
p22562
aVIn order to perform a sort you need to be able to compare two items, and swap them
p22563
aVNow we can put this all together with a bubble sort
p22564
aVNow, if you wanted to use a more complex comparison operator then you could simply replace
p22565
aVFor example, if you wanted to order by age any people that have the same name, then you use a lexicographic comparison function
p22566
aVI have written this answer piece by piece and that is how you should approach a larger problem like this
p22567
aVTry to break it down in to smaller pieces, each of which is manageable
p22568
as(dp22569
g7
V505088
p22570
stp22571
a((dp22572
g2
(lp22573
VThe address space is not limited to 2^31
p22574
aVThe address space is 2^32
p22575
aVWhat you are referring to is that the kernel reserves the upper 2GB leaving applications the lower 2GB
p22576
aVThat's simply an implementation detail of 32 bit Windows
p22577
aVIn fact you can run Windows in /3GB mode in which case applications can access 3GB of memory
p22578
as(dp22579
g7
V505088
p22580
stp22581
a((dp22582
g2
(lp22583
VYour drawing is not correct
p22584
aVThe local stack variables for a function are all below any return addresses
p22585
aVOtherwise, as you have observed, the locals would get lost when you call a function
p22586
aVIt should be like this:
p22587
aVI think the confusion is that you believe that variable declarations are treated as statements and executed in order
p22588
aVIn fact the compiler will typically analyse a function to decide how much stack space is needed for all the local variables
p22589
aVThen it emits code to adjust the stack pointer accordingly and that adjustment is made on entry to the function
p22590
aVAny calls to other functions can then push onto the stack without interfering with this function's stack frame
p22591
as(dp22592
g7
V505088
p22593
stp22594
a((dp22595
g2
(lp22596
VDelphi dynamic arrays are managed types that have automatic lifetime management
p22597
aVThey are reference counted and when the reference count goes to 0, there are disposed
p22598
aVYou can think of them as being equivalent in that regard to strings, interfaces and variants
p22599
aVYou can explicitly release a reference to a dynamic array in one of three ways:
p22600
aVHowever, it's very common simply to do nothing and let the reference be released when the variable leaves scope
p22601
aVOne thing to watch out for with dynamic arrays is when you have two references to the same dynamic array
p22602
aVIn that situation, changes applied via one reference are visible from the other reference since there is only one object
p22603
aVYou ask if this is correct:
p22604
aVNo it is not
p22605
aVWhat you have done here is to copy the contents of  onto the reference
p22606
aVIf you want to copy with  then you can write:
p22607
aVOr if you prefer to be a bit more verbose and avoid the cast you can write:
p22608
aVI personally don't feel too bad about the cast since  has absolutely no type safety anyway
p22609
aVWould it be legal to reuse FData now
p22610
aVPerhaps by copying new (different) data into it
p22611
aVI don't feel I could answer this without more context
p22612
aVFor example I don't know why  is a field since it is only used locally to that function
p22613
aVIt would make more sense as a local variable
p22614
aVPresumably there is a reason it is declared as a field but it cannot easily be discerned from this code
p22615
aVYou about using the producer/consumer pattern
p22616
aVNormally this is done to decouple the production from the consumption
p22617
aVHowever, your example code does not do this, presumably because decoupled code would be too complex to include here
p22618
aVFor a true producer/consumer implementation you need to transfer ownership of the data from the producer to the consumer
p22619
aVFrom what we have described above, a very simple and effective way to do this is to use reference counting
p22620
aVWhen the data is transferred to the consumer, the producer should release its reference to it
p22621
as(dp22622
g7
V505088
p22623
stp22624
a((dp22625
g2
(lp22626
VFirst of all, don't use a static for
p22627
aVA local is what you want
p22628
aVSecondly the factorial recurrence relationship you use is incorrect
p22629
aVYou should do it like this
p22630
as(dp22631
g7
V505088
p22632
stp22633
a((dp22634
g2
(lp22635
VIf you were writing Java or C# then you would implement these functions as static methods
p22636
aVIn those languages all methods have to be part of a class due to the design of the language
p22637
aVIn Python, whilst you can emulate a static method, there is absolutely no need to do so for this example
p22638
aVPython's creator, Guido van Rossum, has argued in favour of the use of functions rather than methods
p22639
aVFirst of all, I chose len(x) over x
p22640
aVlen() for HCI reasons (def
p22641
aV__len__() came much later)
p22642
aVThere are two intertwined reasons
p22643
aVactually, both HCI:
p22644
aV(a) For some operations, prefix notation just reads better than
p22645
aVpostfix \u2014 prefix (and infix
p22646
aVoperations have a long tradition in
p22647
aVmathematics which likes notations where the visuals help the
p22648
aVmathematician thinking about a problem
p22649
aVCompare the easy with which we
p22650
aVrewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of
p22651
aVdoing the same thing using a raw OO notation
p22652
aV(b) When I read code that says len(x) I know that it is asking for the
p22653
aVlength of something
p22654
aVThis tells me two things: the result is an
p22655
aVinteger, and the argument is some kind of container
p22656
aVTo the contrary,
p22657
aVwhen I read x
p22658
aVlen(), I have to already know that x is some kind of
p22659
aVcontainer implementing an interface or inheriting from a class that
p22660
aVhas a standard len()
p22661
aVWitness the confusion we occasionally have when
p22662
aVa class that is not implementing a mapping has a get() or keys()
p22663
aVmethod, or something that isn\u2019t a file has a write() method
p22664
aVSaying the same thing in another way, I see \u2018len\u2018 as a built-in
p22665
aVoperation
p22666
aVI\u2019d hate to lose that
p22667
aV/\u2026/
p22668
aVWhilst this is not directly related to your question it does challenge the sometimes dogmatic stance that methods are always to be preferred to functions
p22669
aVIn my opinion, in Python, using functions is a better solution than creating classes
p22670
as(dp22671
g7
V505088
p22672
stp22673
a((dp22674
g2
(lp22675
VIt is perfectly reasonable and valid for a compiler to inline a function that throws
p22676
as(dp22677
g7
V505088
p22678
stp22679
a((dp22680
g2
(lp22681
VCall  passing
p22682
aVCall  to check if the module has any icon resources
p22683
aVNote that this is not exhaustive since some applications (e
p22684
ag217
aVmodern Office) store their image assets in custom form and not icon resources
p22685
as(dp22686
g7
V505088
p22687
stp22688
a((dp22689
g2
(lp22690
VYes, your first block of code valid
p22691
aVIt will catch all exceptions
p22692
as(dp22693
g7
V505088
p22694
stp22695
a((dp22696
g2
(lp22697
VTransactional memory is one such method
p22698
as(dp22699
g7
V505088
p22700
stp22701
a((dp22702
g2
(lp22703
VI think gcc is your best option
p22704
aVOn Windows the best port is probably MinGW
p22705
aVYou edited your question to request an IDE too
p22706
aVTry Code::Blocks
p22707
as(dp22708
g7
V505088
p22709
stp22710
a((dp22711
g2
(lp22712
VSince it is not possible to redefine the division operator for built in types, you need to implement your version of division in a function
p22713
as(dp22714
g7
V505088
p22715
stp22716
a((dp22717
g2
(lp22718
VThe only explanation that makes sense to me is that the OnShow event is not correctly connected to your handler
p22719
aVCheck in the Object Inspector or the
p22720
aVdfm form
p22721
aVIf you are connecting in code, make sure you connect early enough
p22722
as(dp22723
g7
V505088
p22724
stp22725
a((dp22726
g2
(lp22727
VCreateProcess and its variants are all you've got
p22728
aVIf the blocking hurts you then a different thread is the only solution
p22729
as(dp22730
g7
V505088
p22731
stp22732
a((dp22733
g2
(lp22734
VYou can't create an object in one module and call its methods in a different module
p22735
aVBy module I mean
p22736
aVexe/
p22737
aVdll
p22738
aVIf you wish to cross boundaries like this, then you need to use packages, COM or free functions
p22739
aVPackages look alluring but bind you into using the same compiler for all packages in the system
p22740
aVIf that is not restrictive to you then go ahead and use packages
p22741
aVOtherwise use  COM or free functions
p22742
as(dp22743
g7
V505088
p22744
stp22745
a((dp22746
g2
(lp22747
VYou are free to use the fonts supplied with Windows, free to write software that uses them, but you cannot distribute them
p22748
as(dp22749
g7
V505088
p22750
stp22751
a((dp22752
g2
(lp22753
VUse  to remove the words from the filename
p22754
aVThen call  to perform the rename
p22755
as(dp22756
g7
V505088
p22757
stp22758
a((dp22759
g2
(lp22760
VIf you wish to override  and  then you pretty much have to use  and
p22761
aVThat's how it is meant to be done
p22762
aVDo not be afraid
p22763
aVThe downsides of using  outside of the implementation of  remain
p22764
as(dp22765
g7
V505088
p22766
stp22767
a((dp22768
g2
(lp22769
VSome messages (i
p22770
ag192
aVinput messages) arrive through the message queue and the rest are delivered straight to the recipient windows
p22771
aVWhat you are asking to do therefore requires you to do all of the following:
p22772
aVImplement a top level message loop that retrieves messages from the queue and sends them to the other app
p22773
aVReimplement all modal window loops to pass all messages on
p22774
aVReplace the window procedure for all windows in your process with one that passes all messages on to the other app
p22775
aVLook for other opportunities for messages to arrive that I have not covered
p22776
aVI can't imagine that this is really going to be the solution to your problem, whatever that problem is
p22777
as(dp22778
g7
V505088
p22779
stp22780
a((dp22781
g2
(lp22782
VThat's not at all surprising
p22783
aVYou are returning a C string that was actually created by the C# marshaller
p22784
aVThe marshaller then tries to free that memory twice
p22785
aVOnce as the return value and once for the parameter passed to the DLL
p22786
aVThe first free will fail because the memory was not allocated with the allocator that the C# marshaller assumes
p22787
aVAnyway, you simply don't want to return a  from your DLL
p22788
aVI'm not sure what you really want to do but the normal patterns with string P/invokes are:
p22789
aVFor marshalling strings from C# to C++ declare them as  in your C# and  in C++
p22790
aVWhen going the other way use
p22791
aVAllocate a buffer before you call and use
p22792
aVThere are a gazillion examples on the web of this pattern
p22793
as(dp22794
g7
V505088
p22795
stp22796
a((dp22797
g2
(lp22798
VThere's no need to fight against linking windowscodecs
p22799
aVlib
p22800
aVLinking against it doesn't result in implicit linking as you would get for a non-COM library
p22801
aVYou still need to call  just as you would for any COM object
p22802
aVThink of this as being runtime binding equivalent to
p22803
as(dp22804
g7
V505088
p22805
stp22806
a((dp22807
g2
(lp22808
VHere is my advice
p22809
aVFirst of all port the application to 32 bit Unicode
p22810
aVThen, port to 64 bit
p22811
aVI would expect step 1 to be harder than step 2
p22812
aVFor step 1 there is Marco Cant's Unicode whitepaper
p22813
aVI'm not aware of anything similar yet for 64 bit
p22814
aVI strongly urge you to keep these two porting tasks separate
p22815
aVSmaller independent tasks are always easier than one bigger combined task
p22816
aVRegarding the 64 bit port I can think of the following issues to deal with:
p22817
aVAll 3rd party libraries need updating
p22818
aVAll inline assembler will need attention
p22819
aVAccess to Windows API functions need looking at
p22820
aVA common idion is to pass
p22821
aVThat needs to be replaced with
p22822
aVOther than that I don't think there is much to be concerned about
p22823
aVThe Unicode port is likely to be far more problematic
p22824
aVBarry Kelly's answer here puts some more flesh on this
p22825
as(dp22826
g7
V505088
p22827
stp22828
a((dp22829
g2
(lp22830
V won't help you here
p22831
aVI think you need
p22832
as(dp22833
g7
V505088
p22834
stp22835
a((dp22836
g2
(lp22837
VI think I would implement it with an  so that calling code can use either the new RTL function, or fall back on the older deprecated version
p22838
aVSince the new  returns a UnicodeString I think it is safe to assume that it was introduced in Delphi 2009
p22839
as(dp22840
g7
V505088
p22841
stp22842
a((dp22843
g2
(lp22844
VUse a dict to store the tuples:
p22845
aVOr you can use the intializer syntax:
p22846
aVAlthough you may well want to read the data in from a file
p22847
aVThen you can write a distance function:
p22848
aVThen you can call it like this:
p22849
as(dp22850
g7
V505088
p22851
stp22852
a((dp22853
g2
(lp22854
VThat first  dereferences the pointer
p22855
aVIn other words  is the contents of the memory at
p22856
as(dp22857
g7
V505088
p22858
stp22859
a((dp22860
g2
(lp22861
VA possible explanation is that the service runs as a user that does not have read rights to the other server's volumes
p22862
aVAuthenticating with NETWORKSERVICE does not help you
p22863
aVThat's just a user that has access to TCP etc
p22864
aVWhat you need to do is to run your service as a user which has read access to the other server's volumes
p22865
aVAs a test try your personal login, but in the longer run you may wish to use a dedicated user just for this task
p22866
as(dp22867
g7
V505088
p22868
stp22869
a((dp22870
g2
(lp22871
VTMemIniFile is what you need and should always be preferred to TIniFile
p22872
aVYou choose whether or not to save to file
p22873
aVWhat you can't do directly is initialize it from a resource, but it's not too hard to put it together yourself
p22874
aVUse a resource stream to extract your resource
p22875
aVCreate a string list and call load your resource stream into the string list
p22876
aVCreate a TMemIniFile and call SetStrings passing the string list
p22877
as(dp22878
g7
V505088
p22879
stp22880
a((dp22881
g2
(lp22882
VThere is no such thing as a whole screen paint
p22883
aVThe system optimises and only updates invalid regions
p22884
aVI don't know what you are trying to achieve (you didn't say) but it sounds like a remote desktop type application
p22885
aVThey typically use mirror drivers
p22886
as(dp22887
g7
V505088
p22888
stp22889
a((dp22890
g2
(lp22891
VClearly pointers to different variables must have different values
p22892
aVJust watch out if you choose to derive a subclass of A
p22893
aVYou need to decide what your policy is for id
p22894
aVIf you did nothing then the subclass would have the same id
p22895
as(dp22896
g7
V505088
p22897
stp22898
a((dp22899
g2
(lp22900
VYes you can do this
p22901
aVYou need to use the activation context API which allows you to activate different manifests at runtime
p22902
aVI have used it to enable themes in an Excel add-in
p22903
as(dp22904
g7
V505088
p22905
stp22906
a((dp22907
g2
(lp22908
VWell, you need an lvalue, i
p22909
ag192
aVsomething that can be assigned to
p22910
aVYou can't assign to the return value of a function
p22911
aVYou need to do something like this:
p22912
as(dp22913
g7
V505088
p22914
stp22915
a((dp22916
g2
(lp22917
VYou need to create instances for  and , and use  to pass them
p22918
as(dp22919
g7
V505088
p22920
stp22921
a((dp22922
g2
(lp22923
VDon't fake keyboard input when you don't have to
p22924
aVCall
p22925
as(dp22926
g7
V505088
p22927
stp22928
a((dp22929
g2
(lp22930
VYes you can process each file by itself
p22931
aVTake a look at the tutorial here
p22932
aVFor your needs you can do something like this example from that tutorial:
p22933
aVThis will iterate over each file in the archive and print out its name, length and the first 10 bytes
p22934
aVThe comprehensive reference documentation is here
p22935
as(dp22936
g7
V505088
p22937
stp22938
a((dp22939
g2
(lp22940
VThere's no hope of implementing custom calling conventions in C#
p22941
aVYou must do this in either a native DLL or a C++/CLI DLL
p22942
as(dp22943
g7
V505088
p22944
stp22945
a((dp22946
g2
(lp22947
VYou can read all about the changes introduced in Vista here
p22948
aVYou really should read that article very carefully
p22949
aVThe APIs you are looking for are ,  and
p22950
aVRemember that these APIs are only available on Vista/2008 server up
p22951
aVYou'll have to implement fall back behaviour on 2000/XP
p22952
aVIf you need to block shutdown you call  passing the handle to your main window and the reason as a string
p22953
aVThis string is what is displayed in the shutdown blocked dialog, i
p22954
ag192
aV"1 virtual machine is in use" in your screenshot
p22955
aVIf the operation that blocks shutdown completes then you call
p22956
aVNote that you must still implement  to make all the pieces fit together
p22957
aVThis is the part that actually blocks the shutdown
p22958
aVOn XP you should also respond to  and if your app blocked shutdown it is polite to show a message indicating why
p22959
aVIf you don't do so then the user is left scratching his/her head as to why the computer is ignoring the instruction to shutdown
p22960
as(dp22961
g7
V505088
p22962
stp22963
a((dp22964
g2
(lp22965
VThe display indicates that the culprit is java
p22966
aVexe
p22967
aVThat indication is correct
p22968
aVThe child process is not consuming CPU
p22969
as(dp22970
g7
V505088
p22971
stp22972
a((dp22973
g2
(lp22974
VOption 1 is easier to use since there is no need for the caller to worry about multiple evaluations of
p22975
aVOption 1 also keeps the scope of the  variable as small as possible
p22976
aVOption 2 leaks the status variable into the scope of the caller
p22977
aVOption 3 which doesn't use a macro at all is even better
p22978
as(dp22979
g7
V505088
p22980
stp22981
a((dp22982
g2
(lp22983
VYou've got your versions wrong
p22984
aVVista/2008 server are version 6
p22985
ag9193
aVYour test should be:
p22986
aVI believe that you are using Delphi 2010 or later in which case you should simply call the  function from the built-in  unit
p22987
aVThis organises the version check and the delayed binding for you
p22988
aVNo need for JEDI
p22989
aVEdit: Text below was written before the question was edited
p22990
aVProbably the easiest approach is to check the Windows version
p22991
aVYou need  (i
p22992
ag192
aVVista or 2008 server) in order to call
p22993
aVIf you were binding yourself then you would call  with  and if that succeeded you would then call  to bind
p22994
aVIf that succeeded you are good
p22995
aVBut, as I said, since you aren't handling the binding yourself then a version check is probably the simplest
p22996
aVSo the function would be:
p22997
aVNote, I'm assuming that your library is doing late binding, i
p22998
ag192
aVexplicit linking
p22999
aVIf not then you'll need LoadLibrary/GetProcAddress, exactly as is done in @RRUZ's code to which you link
p23000
as(dp23001
g7
V505088
p23002
stp23003
a((dp23004
g2
(lp23005
VI believe that @TOndrej has spotted the main cause of the problem
p23006
aVHowever, I think you have a second more subtle bug
p23007
aVYour app which receives the  message is, I think, treating  as a null-terminated string
p23008
aVIf the data is malformed then you will have a buffer overrun
p23009
aVI believe that is exactly what is happening in your examples but it just turns out to be benign
p23010
aVThe marshalling of  copies just the size of buffer specified in
p23011
aVYou must make sure you don't read beyond it
p23012
aVA malicious app could send you a  message with data to make you do just that
p23013
aVInstead I recommend you use  when reading
p23014
aVSo to send the string you write:
p23015
aVAnd then when you receive it you allocate a buffer and copy to that buffer based on the value of
p23016
as(dp23017
g7
V505088
p23018
stp23019
a((dp23020
g2
(lp23021
VYou can use  to do this
p23022
as(dp23023
g7
V505088
p23024
stp23025
a((dp23026
g2
(lp23027
VThe VCL raises exceptions when it encounters errors
p23028
as(dp23029
g7
V505088
p23030
stp23031
a((dp23032
g2
(lp23033
VYou can't get around UAC for a process started in an interactive session
p23034
aVYou could use a service running as a privileged user but you would be far better off finding a way to do whatever you do without requiring admin rights
p23035
as(dp23036
g7
V505088
p23037
stp23038
a((dp23039
g2
(lp23040
VYou've clearly got a version of pthreads for Windows
p23041
aVYou just haven't included the
p23042
aVlib file in your linker settings
p23043
aVDo that and you should be golden
p23044
as(dp23045
g7
V505088
p23046
stp23047
a((dp23048
g2
(lp23049
VDon't do this
p23050
aVLet the system schedule the threads
p23051
aVIf you affinitise the threads to distinct cores you just handicap the scheduler
p23052
aVWhen your app is the only one consuming CPU, the scheduler will naturally schedule each thread on a separate core
p23053
as(dp23054
g7
V505088
p23055
stp23056
a((dp23057
g2
(lp23058
VNot all floating point numbers are exactly representable on a finite machine
p23059
aVNeither 0
p23060
aV1 nor 0
p23061
aV2 are exactly representable in binary floating point
p23062
aVAnd nor is 0
p23063
aV3
p23064
aVA number is exactly representable if it is of the form a/b where a and b are an integers and b  is a power of 2
p23065
aVObviously, the data type needs to have a large enough significand to store the number also
p23066
aVI recommend Rob Kennedy's useful webpage as a nice tool to explore representability
p23067
as(dp23068
g7
V505088
p23069
stp23070
a((dp23071
g2
(lp23072
VThe best approach is to attempt the operation and let the system decide whether or not it is allowed
p23073
aVDuplicating the checks that the system performs would be terribly hard to get right
p23074
aVJust let the system decide, it is the ultimate arbiter
p23075
as(dp23076
g7
V505088
p23077
stp23078
a((dp23079
g2
(lp23080
VSimply put, a user needs administrator rights to write to HKLM
p23081
aVLikewise for writing to system directories (system32, program files)
p23082
aVThis has always been true for Windows versions that implemented security (NT, 2k, XP, Vista, 7)
p23083
aVUnder UAC, users in the administrators group run processes, by default, with a standard user token
p23084
aVSo they do not get write access to HKLM etc
p23085
aVYou really need to read up on UAC before going much further
p23086
aVStart here
p23087
aVOnce you are familiar with the issues you have two principal options:
p23088
aVAdd a  manifest to your application so that it always runs with elevated privileges
p23089
aVThis means that the user will have to negotiate the UAC dialog every time they start your application
p23090
aVRework your application so that it does not write to HKLM
p23091
aVA common approach is to do everything that needs admin rights during installation which typically happens elevated
p23092
aVAnother variant is to hive off the small part of your app that needs admin rights to a separate process so that you only present UAC dialogs when necessary
p23093
aVOf these two options, number 2 is most definitely to be preferred
p23094
aVBear in mind that your application already did not work on 2000/XP for non-administrator users
p23095
as(dp23096
g7
V505088
p23097
stp23098
a((dp23099
g2
(lp23100
VThere's no issue with
p23101
aVnet or XP
p23102
aVThe problem is with the font
p23103
aVYou need to make sure that you are using a font which contains all the glyphs that you wish to display
p23104
as(dp23105
g7
V505088
p23106
stp23107
a((dp23108
g2
(lp23109
V requires a string as its input parameter
p23110
aVThe first sample fails because there is no implicit conversion from integer to string
p23111
aVThe second sample succeeds because  evaluates to a string
p23112
aVThis happens because the C# language defines an addition operator which accepts a  and an
p23113
aVThe  is converted to a  by calling
p23114
aVThis string addition operator is always selected when one of the operands to the addition is a
p23115
as(dp23116
g7
V505088
p23117
stp23118
a((dp23119
g2
(lp23120
VYou could try using a PE editor to increase the stack size of IDE or dcc32
p23121
aVBut make backups first
p23122
aVEditbin should do the trick
p23123
as(dp23124
g7
V505088
p23125
stp23126
a((dp23127
g2
(lp23128
V introduces a lambda expression
p23129
aVIf the lambda expression received parameters then they would be listed inside the parentheses
p23130
aVYour lambda is equivalent to
p23131
as(dp23132
g7
V505088
p23133
stp23134
a((dp23135
g2
(lp23136
VI think the main problem is that you need to use the  namespace which is where  is defined
p23137
aVIn fact it looks like that  is not needed (see below)
p23138
aVYou also need to make the method a class method
p23139
aVAnd likewise in the implementation
p23140
aVNote that  and  are deprecated in Prism and you should use  instead
p23141
aVThis information was gleaned from the docwiki
p23142
aVI downloaded the command line compiler for Prism XE
p23143
aVThis is version 4
p23144
aV0 and so supports the  attribute
p23145
aVI successfully compiled the following unit:
p23146
aVThe output was:
p23147
aVThis produced a DLL which I verified contained a single exported function named
p23148
aVNext I called the DLL from Python via ctypes:
p23149
aVThus I can only conclude that your problem is not with the code
p23150
aVYou perhaps have a mis-configured Prism installation
p23151
aVCould you try to repeat my command line above
p23152
aVCould you perform a re-installation of Prism
p23153
as(dp23154
g7
V505088
p23155
stp23156
a((dp23157
g2
(lp23158
VThe documentation says:
p23159
aVIf AfxGetMainWnd is called from the application's primary thread, it returns the application's main window according to the above rules
p23160
aVIf the function is called from a secondary thread in the application, the function returns the main window associated with the thread that made the call
p23161
aVSo you need to make the call from the main thread
p23162
aVDo this just before you call  and store the resulting window handle in a member of
p23163
aVThen your thread can gain access to the window handle via its  reference
p23164
as(dp23165
g7
V505088
p23166
stp23167
a((dp23168
g2
(lp23169
VSort the numbers in ascending order of magnitude
p23170
aVSum them, low magnitude first
p23171
aVDivide by the count
p23172
as(dp23173
g7
V505088
p23174
stp23175
a((dp23176
g2
(lp23177
VYes, you can use the tool in CnPack or the one in Peganza
p23178
aVBeware that even if you do not refer to a symbol defined in a unit, the inclusion of that unit can have an impact on your project
p23179
aVIncluding a unit means that code in any  or  sections runs and that can, of course, change the meaning of your program
p23180
aVThe canonical example of this is a replacement memory manager
p23181
aVThe FAQ for GExperts discusses this issue and explains why they do not offer such a facility
p23182
as(dp23183
g7
V505088
p23184
stp23185
a((dp23186
g2
(lp23187
VFind the formats on the clipboard by calling
p23188
aVCall  to get a  that contains the clipboard data for a particular format
p23189
aVYou can get the size of the memory by calling
p23190
aVTo read the memory wrapped by the  use  and
p23191
as(dp23192
g7
V505088
p23193
stp23194
a((dp23195
g2
(lp23196
VThe licence allows that
p23197
aVYou aren't actually embedding a font when you rasterize it so that section of the FAQ simply is not relevant
p23198
as(dp23199
g7
V505088
p23200
stp23201
a((dp23202
g2
(lp23203
VThe limitation is imposed by the decimal representation and the 28 significant digits refer to 28 decimal digits
p23204
as(dp23205
g7
V505088
p23206
stp23207
a((dp23208
g2
(lp23209
VDelphi strings reside on the heap and are always passed by pointer
p23210
aVYour first example of pass by value is incorrect
p23211
aVStrings passed by value are not copied
p23212
aVOnly the reference is copied
p23213
aVThis is possible for strings because they have magic copy-on-write behaviour
p23214
aVA dynamic array passed by value is copied
p23215
aVUsing const when passing a string has the best performance because the compiler can optimise out reference counting code
p23216
aVYour C code is somewhat confused
p23217
aVYou don't want , rather you want
p23218
aVRemember that a C string, a , is just a pointer to a null-terminated block of memory
p23219
aVYou don't need to take a pointer to a C string since it is already a pointer
p23220
aVAnd you mean  rather than  surely
p23221
aVTo pass a C string starting at the 5th character write
p23222
as(dp23223
g7
V505088
p23224
stp23225
a((dp23226
g2
(lp23227
VWhich is the right answer
p23228
aVBoth answers are correct
p23229
aVIt's merely a matter of convention which value is returned
p23230
as(dp23231
g7
V505088
p23232
stp23233
a((dp23234
g2
(lp23235
VYou simply need to remove the  block
p23236
aVA  block always goes with a
p23237
aVYou can then include a  construct in your
p23238
as(dp23239
g7
V505088
p23240
stp23241
a((dp23242
g2
(lp23243
VThe window rect includes the non-client area, i
p23244
ag192
aVthe window borders, caption bar etc
p23245
aVThe client rect does not
p23246
aVGetWindowsRect returns a rect in screen coordinates whereas GetClientRect returns a rect in client coordinates
p23247
aVInvalidateRect receives a rect in client coordinates
p23248
aVIf you want to invalidate your entire client area then pass NULL to InvalidateRect
p23249
aVYou could pass in the rect returned by GetClientRect but it is far simpler and clearer to pass NULL
p23250
as(dp23251
g7
V505088
p23252
stp23253
a((dp23254
g2
(lp23255
VThese properties have type double
p23256
aVYou are passing single precision values, floats
p23257
aVPass doubles and all will be well
p23258
as(dp23259
g7
V505088
p23260
stp23261
a((dp23262
g2
(lp23263
VLooking at this question, and your previous one, I would say that your basic problem is that you are not using runtime packages
p23264
aVIf you were using runtime packages then you would have a single instance of the VCL and module boundaries would not matter
p23265
aVWithout runtime packages you have separate VCL instances
p23266
aVFor the VCL form navigation to work correctly you need each control to be recognised as a VCL control
p23267
aVThis is not possible when you have multiple VCL instances
p23268
as(dp23269
g7
V505088
p23270
stp23271
a((dp23272
g2
(lp23273
VThere's no problem doing that from the point of view of the underlying system (for all systems I know)
p23274
aVHowever, typically you would need to have completely separate file descriptors/handles
p23275
aVThis is because the file descriptor maintains state, e
p23276
ag217
aVthe current file position
p23277
aVYou also need to check the thread-safety of the particular C++ interface to the filesystem that you are using
p23278
aVThis is needed in addition to the thread-safety of the underlying filesystem
p23279
aVYou should also consider the possibility that threaded I/O will be slower
p23280
aVThe system may have to serialise access to the bus
p23281
aVYou may get better performance from overlapped I/O or a dedicated I/O thread fed through a producer/consumer pipeline
p23282
as(dp23283
g7
V505088
p23284
stp23285
a((dp23286
g2
(lp23287
VIt's absolute if it begins with a , otherwise relative
p23288
as(dp23289
g7
V505088
p23290
stp23291
a((dp23292
g2
(lp23293
VThere is no such thing as an empty char
p23294
aVYou would need to use nullable types to introduce that concept
p23295
as(dp23296
g7
V505088
p23297
stp23298
a((dp23299
g2
(lp23300
VWhat type do you want  to be
p23301
aVDo you want it to be an  reference or a  reference
p23302
aVOnce you make that decision, the rest follows
p23303
aVIn other words, only you can answer the question
p23304
as(dp23305
g7
V505088
p23306
stp23307
a((dp23308
g2
(lp23309
VObviously you are using a rather lax compiler
p23310
aVThis is what the standards king Comeau makes of it:
p23311
aVAs to what your compiler is doing that's hard to say since you didn't say what your compiler is
p23312
aVYou say you wish to adhere to C89
p23313
aVIn that case a parameter with no type information is assumed to have type
p23314
aVYour  function is interpreted like this:
p23315
aVOf course this is still not valid C
p23316
aVValid  functions in C are:
p23317
as(dp23318
g7
V505088
p23319
stp23320
a((dp23321
g2
(lp23322
VYou can format each item individually by supplying a handler for the  event
p23323
aVThe event handler looks like this:
p23324
aVYou can then modify  as you so wish
p23325
as(dp23326
g7
V505088
p23327
stp23328
a((dp23329
g2
(lp23330
VYou can't assign to a character array with , you can only initialize it
p23331
aVWhen you write
p23332
aVthat is a initialization
p23333
aVWhen you write
p23334
aVthat is an assignment
p23335
aVAnd, as I said, assignment to character arrays is not allowed
p23336
aVYou need to copy to the character array using , e
p23337
ag217
as(dp23338
g7
V505088
p23339
stp23340
a((dp23341
g2
(lp23342
VThis usually happens when you have an incorrect parameter list or mismatching calling convention
p23343
aVYou really ought to know what calling convention the other DLL is
p23344
aVIf it is  then you change your P/invoke to:
p23345
aVYou need to do this for all imports
p23346
aVThe other thing to check is that your parameter lists match
p23347
aVYou only showed one side of the boundary so we can't check that for you
p23348
aVIf you added the other side then we may be able to spot something
p23349
aVUpdated following addition of C code
p23350
aVI have the following comments on your code:
p23351
aVThe parameters for the C# declaration of  match the C declaration so I'm pretty confident that the issue is that your C code uses  calling convention
p23352
aVThe C# P/invoke defaults to
p23353
aVChange the calling convention in one or the other, but not both
p23354
aVYou are matching  with
p23355
aVI'm not sure about this since I don't know JNI
p23356
aVHowever, I suspect you should be returning  and matching with
p23357
aVIt looks to me as though  is a class type and not something that you can marshal to C#
p23358
aVFinally, one of your methods returns a
p23359
aVThat just won't work
p23360
aVThe C# marshaller will attempt to deallocate it with a call to
p23361
aVThat will leak or bomb, dependent on which Windows version you have
p23362
aVYou should return an  and use  to marshal it into a C# string
p23363
aVThen you need to deallocate the memory returned by the JNI code
p23364
aVNot sure how you plan to do that
p23365
aVOf course, if your strings are really UTF-8 then you would need to copy to a byte array and then use Encoding
p23366
aVUTF8 to convert to a C# string
p23367
as(dp23368
g7
V505088
p23369
stp23370
a((dp23371
g2
(lp23372
VYou'll need to hope that the system search path includes the path where the executable lives, or that it has registered an
p23373
as(dp23374
g7
V505088
p23375
stp23376
a((dp23377
g2
(lp23378
VWell, the solution is to declare the function in functions
p23379
aVh and then define it in functions
p23380
aVcpp, the way nature intended
p23381
as(dp23382
g7
V505088
p23383
stp23384
a((dp23385
g2
(lp23386
VThere is a difference between semi-colons in Pascal and in C and their derivatives
p23387
aVIn C the semi-colon is a statement terminator
p23388
aVIn Pascal the semi-colon is a statement separator
p23389
aVWikipedia explains the implications of this:
p23390
aVThis difference manifests itself primarily in two situations:
p23391
aVthere can never be a semicolon directly before else in Pascal
p23392
aVwhereas it is mandatory in C (unless a block statement is used)
p23393
aVthe last statement before an end is not required to be followed by
p23394
aVa semicolon
p23395
aVA superfluous semicolon can be put on the last line before end,
p23396
aVthereby formally inserting an empty statement
p23397
as(dp23398
g7
V505088
p23399
stp23400
a((dp23401
g2
(lp23402
VNeither
p23403
aVUse a guard clause instead:
p23404
aVDone this way you can deal with all the exceptional behaviour up-front and avoiding excessive levels of indentation for the normal execution path
p23405
as(dp23406
g7
V505088
p23407
stp23408
a((dp23409
g2
(lp23410
VThere is no difference
p23411
aVThe two versions are interchangeable
p23412
as(dp23413
g7
V505088
p23414
stp23415
a((dp23416
g2
(lp23417
VYou have a number of options
p23418
aVYou can install cygwin for a Unix like environment
p23419
aVYou can run the GNU software compiled for Windows with GnuWin32
p23420
aVHigher level scripting with Perl, Python, Ruby etc
p23421
aVis easy since those languages all have good Windows versions
p23422
aVThere is Windows PowerShell but that will probably feel very alien to you
p23423
as(dp23424
g7
V505088
p23425
stp23426
a((dp23427
g2
(lp23428
VThere are two issues with using strings
p23429
aVFirst of all you want to use  so that you ensure the use of byte sized character elements \u2013 a Unicode string has elements that are two bytes wide
p23430
aVAnd secondly you need to dereference the string which is really just a pointer
p23431
aVBut I wonder why you would prefer strings to the stack allocated byte array
p23432
aVNote: Your previous code declared a buffer of 65536 bytes, but you only ever used 65535 of them
p23433
aVProbably not what you intended
p23434
as(dp23435
g7
V505088
p23436
stp23437
a((dp23438
g2
(lp23439
VYou can't specify general constructor constraints on generic types
p23440
aVAll you can do is specify that they have a single parameterless constructor, as you have done
p23441
aVWork around it like this:
p23442
aVYou'll want to use a virtual constructor on  to make this work as you intend
p23443
aVThe other option is to use a parameterless constructor and use a separate routine for initialization
p23444
as(dp23445
g7
V505088
p23446
stp23447
a((dp23448
g2
(lp23449
VYou need to use a forward declaration:
p23450
as(dp23451
g7
V505088
p23452
stp23453
a((dp23454
g2
(lp23455
VThe granularity of accessibility in C++ is the class
p23456
aVSo if you need to make a variable accessible to only two methods you need to move the variable and the two methods into a separate class, dedicated to maintaining privacy
p23457
as(dp23458
g7
V505088
p23459
stp23460
a((dp23461
g2
(lp23462
VUsing  is incorrect
p23463
aVThe fields do not match
p23464
aVYour definition of  is correct
p23465
aVI'm guessing a little, but your problem could be related to the comment at the bottom of the  MSDN topic
p23466
aVApps under Vista that are not linked with WINVER=6 will receive a misleading set of values here, that do not account for the extra padding of "glass" pixels Vista Aero applies to the window
p23467
aVThis appears to happen even in Aero Basic (without Glass) to retain sizing consistency
p23468
aVThe workaround (if you don't want to set WINVER=6) seems to be to dynamically bind to dwmapi
p23469
aVdll and use GetProcAddress() to obtain the DwmGetWindowAttribute() function, and call it with the DWMWA_EXTENDED_FRAME_BOUNDS argument to request the genuine window frame dimensions
p23470
as(dp23471
g7
V505088
p23472
stp23473
a((dp23474
g2
(lp23475
VThe key sentence from the documentation is this:
p23476
aVThis function has been deprecated in the
p23477
aVNET Framework version 4
p23478
aVAs to what it does, I would make an educated guess that it calls  or  and was meant to be invoked by
p23479
as(dp23480
g7
V505088
p23481
stp23482
a((dp23483
g2
(lp23484
VUse
p23485
as(dp23486
g7
V505088
p23487
stp23488
a((dp23489
g2
(lp23490
VGenerally you choose object inheritance when you want to share implementation and reduce what would otherwise be duplication
p23491
aVOtherwise interfaces win because they are more flexible since there is no need for a common base class
p23492
aVAs for overriding a method and modifying the parameter list that's just not possible
p23493
aVImagine how you would call that method on a base class or an interface reference
p23494
as(dp23495
g7
V505088
p23496
stp23497
a((dp23498
g2
(lp23499
V is a function that is used to draw to a device context
p23500
aVAs such it cannot receive inupt
p23501
aVYou need a windowed control to do that
p23502
aVHandle the input in your window and use a hit test to check if you are inside the polygon
p23503
as(dp23504
g7
V505088
p23505
stp23506
a((dp23507
g2
(lp23508
Vincrements the value of
p23509
aVThe expression evaluates to  before it has been incremented
p23510
aVincrements the value of
p23511
aVThe expression evaluates to , before  has been incremented
p23512
aVAn illustration
p23513
aVSuppose that  contains three integers, 0, 1, 2, and that  is equal to 1
p23514
aVchanges  to 2, evaluates to 1 and leaves  equal to 1
p23515
aVdoes not modify , evaluates to 1 and changes  to 2
p23516
aVA suffix operators, which you are using here, evaluates to the value of the expression before it is incremented
p23517
as(dp23518
g7
V505088
p23519
stp23520
a((dp23521
g2
(lp23522
VTry this for the case where your lists are monotone increasing
p23523
as(dp23524
g7
V505088
p23525
stp23526
a((dp23527
g2
(lp23528
VYour understanding is correct
p23529
aVYou need to supply a 32 bit version for users on 32 bit Windows as well as for common dialogs for 32 bit processes under WOW64
p23530
aVHow to deploy depends on your installation tool
p23531
aVWhen I have done this I created separate MSIs for the two versions, from the same source, and used a bootstrapper setup
p23532
aVexe that installed them both
p23533
aVRecommended practice is to set the registry settings from the MSI
p23534
aVThen you let registry redirection do it's magic under WOW64
p23535
as(dp23536
g7
V505088
p23537
stp23538
a((dp23539
g2
(lp23540
VYou are using integer arithmetic for the calculation of  and suffering from truncation
p23541
aVChange your program like this to use floating point arithmetic
p23542
as(dp23543
g7
V505088
p23544
stp23545
a((dp23546
g2
(lp23547
VNo need to allocate here since  was allocated by
p23548
aVNo need to allocate here since  was allocated by the caller
p23549
aVThis writes into the contents of the string
p23550
aVThe assignment  assigns pointers but not contents
p23551
as(dp23552
g7
V505088
p23553
stp23554
a((dp23555
g2
(lp23556
VI believe you can use  and  but I can't find documentation for them on MSDN, and I don't have the DDK headers at hand
p23557
as(dp23558
g7
V505088
p23559
stp23560
a((dp23561
g2
(lp23562
VThe implementor of the class decides what it contains
p23563
aVExtension methods are often used by developers other than the implementor
p23564
aVOnly the implementor knows why they took the decisions that led to a class being the way it is
p23565
as(dp23566
g7
V505088
p23567
stp23568
a((dp23569
g2
(lp23570
VDelphi cannot create Android apps at present
p23571
aVThis is being worked on for a future release
p23572
aVUpdate: As of the release of XE5, Delphi now supports Android development using the mobile Delphi compiler
p23573
as(dp23574
g7
V505088
p23575
stp23576
a((dp23577
g2
(lp23578
VYou could possibly write a credential provider to do this but why
p23579
aVThis would effectively give credential free access to your computer
p23580
aVIf you want to do that then don't bother locking it in the first place
p23581
as(dp23582
g7
V505088
p23583
stp23584
a((dp23585
g2
(lp23586
VIt's the dimensions of the scroll bar rather than the thumb
p23587
as(dp23588
g7
V505088
p23589
stp23590
a((dp23591
g2
(lp23592
VSince Vista, services run in session 0 and the user's desktop is always in a different session
p23593
aVThus you need to work hard to start a service on the user's desktop
p23594
aVIt can be done but it is pretty tricky
p23595
aVDetails can be found here: http://blogs
p23596
aVmsdn
p23597
aVcom/b/winsdk/archive/2009/07/14/launching-an-interactive-process-from-windows-service-in-windows-vista-and-later
p23598
aVaspx
p23599
aVwa=wsignin1
p23600
ag9193
as(dp23601
g7
V505088
p23602
stp23603
a((dp23604
g2
(lp23605
VSince you mention automation I assume you want a SendKeys for Python
p23606
aVTry this: http://rutherfurd
p23607
aVnet/python/sendkeys/
p23608
as(dp23609
g7
V505088
p23610
stp23611
a((dp23612
g2
(lp23613
VYou can't
p23614
aVYou have to remember when you put the thread to sleep and do the calculation yourself
p23615
as(dp23616
g7
V505088
p23617
stp23618
a((dp23619
g2
(lp23620
VThe simple low-tech solution to this is to register your service to run with command line arguments that identify it as a service
p23621
as(dp23622
g7
V505088
p23623
stp23624
a((dp23625
g2
(lp23626
VA static class can only contain static members
p23627
aVSo you cannot create an instance of a static class
p23628
as(dp23629
g7
V505088
p23630
stp23631
a((dp23632
g2
(lp23633
VYet another option is to use Microsoft's Windows Ribbon Framework
p23634
aVThis is the most onerous option for the programmer, but yields the best results for the user
p23635
aVOn the other hand, this component is not available for XP so that often presents an insurmountable hurdle
p23636
aVKudos to Ulrich for pointing out Erik van Bilsen's Delphi wrapper
p23637
as(dp23638
g7
V505088
p23639
stp23640
a((dp23641
g2
(lp23642
VI think you are looking for a function like this:
p23643
aVI trust it will be obvious how to call this function
p23644
as(dp23645
g7
V505088
p23646
stp23647
a((dp23648
g2
(lp23649
VYou need to do it like this:
p23650
aVYou would prefer to write the final declaration as
p23651
aVBut that results in
p23652
aV[DCC Error] Unit1
p23653
aVpas(38): E2026 Constant expression expected
p23654
aVSome Delphi constants are not as constant as you would like them to be
p23655
aVThe documentation for record constants states that
p23656
aVThe values must be represented by constant expressions
p23657
aVThe documentation for typed constants states that
p23658
aVTyped constants cannot occur in constant expressions
p23659
aVPut these two rules together and we have
p23660
as(dp23661
g7
V505088
p23662
stp23663
a((dp23664
g2
(lp23665
VThere's no version available for 64 bit Python on Windows
p23666
aVYou appear to have the following options:
p23667
aVDownload the source to PyPy and port it to 64 bit
p23668
aVSwitch to 32 bit Python
p23669
aVOption 2 looks more tractable
p23670
as(dp23671
g7
V505088
p23672
stp23673
a((dp23674
g2
(lp23675
VYour  is receiving UTF-16 characters which, when fed Latin text, have a 0 in every other byte
p23676
aVYou are interpreting them as single byte characters
p23677
aVYou need to interpret them as wide characters
p23678
aVI would write it something like this:
p23679
aVIf you don't want to use UTF-16 then you can stick with  like this:
p23680
aVNote the change in the naming of the  function
p23681
aVIn MS world,  receives  and  receives
p23682
aVIf you do switch to  then you should also update your project configuration to target MBCS rather than Unicode
p23683
aVMore information on the main function handling of the MS compiler can be found here: main: Program Startup
p23684
as(dp23685
g7
V505088
p23686
stp23687
a((dp23688
g2
(lp23689
VThe Microsoft C++ compiler is not capable of producing Linux executables
p23690
aVYou will need to use a more portable compiler for your Linux executables, e
p23691
ag217
aVgcc
p23692
aVPerhaps you may benefit from a cross-platform IDE like Code Blocks or Eclipse rather than Visual Studio
p23693
as(dp23694
g7
V505088
p23695
stp23696
a((dp23697
g2
(lp23698
VJust use negative offset to jump backwards
p23699
aVAnd remember to account for the size of the  instruction
p23700
aVThe offset is relative to the end of the  instruction and not the beginning
p23701
aVIf the current address is where you are about to write the  then you need an offet of 5+dest-current since the size of the  instruction plus the offset if 5 bytes
p23702
as(dp23703
g7
V505088
p23704
stp23705
a((dp23706
g2
(lp23707
VProbably one of your  calls failed
p23708
aVYou didn't bother to check whether or not they succeeded
p23709
aVWhen  fails a null pointer is returned
p23710
aVIf you try to use that subsequently then your program will likely bomb
p23711
aVYou will then have to fix the bug that Blagovest describes, and you should, of course, close your files
p23712
as(dp23713
g7
V505088
p23714
stp23715
a((dp23716
g2
(lp23717
VJust rename the file
p23718
aVA
p23719
aVscr file is identical in format to a
p23720
aVexe but by convention has the
p23721
aVscr extension
p23722
aVI expect that you can configure a WPF project to output a target with
p23723
aVscr extension which would save the renaming step
p23724
as(dp23725
g7
V505088
p23726
stp23727
a((dp23728
g2
(lp23729
VI'd guess that you are actually doing currency calculations
p23730
aVIn which case using a binary data type like  is probably the root cause of your problems
p23731
aVSwitch to a decimal type and you should be able to side-step such issues
p23732
as(dp23733
g7
V505088
p23734
stp23735
a((dp23736
g2
(lp23737
VYou are looking for  which requires Vista
p23738
aVOn 2000/XP you will need to poll
p23739
as(dp23740
g7
V505088
p23741
stp23742
a((dp23743
g2
(lp23744
VPEP8 covers this:
p23745
aVIn addition, the following special forms using leading or trailing
p23746
aVunderscores are recognized (these can generally be combined with any
p23747
aVcase convention):
p23748
aV_single_leading_underscore: weak "internal use" indicator
p23749
ag1278
ag217
aV"from M
p23750
aVimport *" does not import objects whose name starts with an
p23751
aVunderscore
p23752
aVsingle_trailing_underscore_: used by convention to avoid
p23753
aVconflicts with
p23754
aVPython keyword, e
p23755
ag217
aVTkinter
p23756
aVToplevel(master, class_='ClassName')
p23757
aV__double_leading_underscore: when naming a class attribute,
p23758
aVinvokes name
p23759
aVmangling (inside class FooBar, __boo becomes FooBar_boo; see
p23760
aVbelow)
p23761
aV__double_leading_and_trailing_underscore__: "magic" objects or
p23762
aVattributes that live in user-controlled namespaces
p23763
ag1278
ag217
aV__init__,
p23764
aV__import__ or __file__
p23765
aVNever invent such names; only use them
p23766
aVas documented
p23767
aVThe final bullet point is pertinent
p23768
aVIs there a list of these variables
p23769
aVI doubt that there is an official list of all such double leading and trailing underscore names, but I could not say so for sure
p23770
as(dp23771
g7
V505088
p23772
stp23773
a((dp23774
g2
(lp23775
VWhat appears to be missing is that you need to tell the image which control is its parent so that it can appear on screen
p23776
aVDo that like this:
p23777
aVObviously your form variable will have a different name, but I'm sure you know what it's called
p23778
aVWhen you do this you will find that they all end up on top of each other
p23779
aVAssign to the  and  properties to position then
p23780
aVFinally you will likely want to set the  and  properties of the images to match the dimensions of the images,  and
p23781
aVI can't imagine why your code produces an access violation but it's presumably unrelated to the question you asked
p23782
aVThe following code proves that what I say above is correct:
p23783
aVWithout your full code I cannot debug your AV
p23784
as(dp23785
g7
V505088
p23786
stp23787
a((dp23788
g2
(lp23789
VI guess that you have a 32 bit process and a 64 bit machine
p23790
aVWhen this happens, registry redirection confounds matters
p23791
aVAttempts to read  get redirected to
p23792
aVSo you need to open the 64 bit view of the registry with the  enumeration
p23793
as(dp23794
g7
V505088
p23795
stp23796
a((dp23797
g2
(lp23798
VYes there is
p23799
aVThe standard dictates that  always points to invalid memory
p23800
aVBut it does not state that the integer representation of the pointer must be 0
p23801
aVI've never come across an implementation for which  was other than 0, but that is not mandated by the standard
p23802
aVNote that assigning the literal  to a pointer does not mean that the pointer assumes the integer representation of 0
p23803
aVIt means that the special null pointer value is assigned to the pointer variable
p23804
as(dp23805
g7
V505088
p23806
stp23807
a((dp23808
g2
(lp23809
VYou can define  to a lower value, suitable for 2000 or XP
p23810
aVBut then you will need to use explicit linking for Vista only APIs
p23811
aVChanging  will also result in missing type declarations for the Vista only APIs
p23812
aVSo, if you know which APIs you need you could leave  at  and use explicit linking for those APIs
p23813
aVObviously you would need a version check too to give a helpful message to the user
p23814
aVPersonally I'd take a different route to solving this
p23815
aVI'd check the version at install time and block it there
p23816
aVThat allows you to carry on with  and all the conveniences that affords
p23817
as(dp23818
g7
V505088
p23819
stp23820
a((dp23821
g2
(lp23822
VThat's a Windows implementation detail
p23823
aVThe 2 least significant bits of the PID are ignored
p23824
aVSo in your example, 2084-2087 all refer to the same process
p23825
aVRaymond Chen wrote about this already: Why does OpenProcess succeed even when I add three to the process ID
p23826
aVYou would do well to heed the following caveat:
p23827
aVAgain, I wish to emphasize that the behavior you see in Windows NT-based kernels is just an implementation artifact which can change at any time
p23828
as(dp23829
g7
V505088
p23830
stp23831
a((dp23832
g2
(lp23833
VThe answer is not to use  and instead use a high resolution timer
p23834
aVYou'll need to do your fade in a busy loop, but it sounds like that would be no problem
p23835
aVYou simply cannot expect high resolution from  and it is notorious for behaving differently on different hardware
p23836
aVYou can use the  class on
p23837
aVnet which uses high-resolution performance counters if they are supported on the hardware
p23838
as(dp23839
g7
V505088
p23840
stp23841
a((dp23842
g2
(lp23843
VYour understanding is correct
p23844
aVSo long as you change the logic but not the interface then you will not run into compatibility issues
p23845
aVWhere you have to be careful is if the interface to the DLL is more than just the function signatures
p23846
aVFor example if the original DLL accepted an  parameter but the new DLL enforced a constraint that the value of this parameter must be positive, say, then you would break old programs
p23847
as(dp23848
g7
V505088
p23849
stp23850
a((dp23851
g2
(lp23852
VYou can use
p23853
aVThis is implemented by Mono
p23854
as(dp23855
g7
V505088
p23856
stp23857
a((dp23858
g2
(lp23859
VJust replace the file writing with a call to  on a list
p23860
aVFor example:
p23861
aVAs an aside you would normally write
p23862
aVAlso it looks like  uses 1-based indexing
p23863
aVThat seems pretty unusual for Python
p23864
as(dp23865
g7
V505088
p23866
stp23867
a((dp23868
g2
(lp23869
VYour code would work if you were assigning to a
p23870
aVHowever,  is not a , it is declared as
p23871
aVSo you need to copy the contents of the string to the buffer
p23872
aVLike this:
p23873
aVDo you really need to support both ANSI and Unicode builds
p23874
aVIf not then stop using  and switch to Unicode
p23875
aVThen you could write a more readable version
p23876
as(dp23877
g7
V505088
p23878
stp23879
a((dp23880
g2
(lp23881
VYou are not changing values of a variable when you write
p23882
aVYou are binding an object to a name
p23883
aVIn your example
p23884
aVYou have one object (a list) with two names bound to that object
p23885
aVNaturally, mutating changes on that object are reflected when the same object is accessed by each different name
p23886
aVIn your example
p23887
aVYou have 2 objects in play, integers with values  and
p23888
aVWhen you write  you are simply re-binding the name  to the other object
p23889
aVThe name  is still bound to
p23890
as(dp23891
g7
V505088
p23892
stp23893
a((dp23894
g2
(lp23895
VYou are going to struggle to find anything better than PostMessage
p23896
aVMy guess is that your problem is that you are updating UI too frequently and your queue is becoming saturated because you cannot service it quickly enough
p23897
aVHow about skipping updates if you updated less than a second ago say
p23898
aVIf that restores responsiveness then you can consider a more robust solution
p23899
as(dp23900
g7
V505088
p23901
stp23902
a((dp23903
g2
(lp23904
VYou can't create a  in managed code
p23905
aVSo clearly you need an extra layer between the managed code and the native code
p23906
aVThis gives you an opportunity to make a C++/CLI DLL which sits between
p23907
aVYou can call this code from your managed assembly without needing P/invoke
p23908
aVAnd from the C++/CLI middle layer you can create a
p23909
aVHowever, there is one caveat
p23910
aVYou must be using the same C++ runtime as the native DLL
p23911
aVThis may be possible but it is quite likely that it will be a stumbling block
p23912
aVFor example if the DLL was written with MSVC6 then you will need to build your intermediate layer with MSVC6 too and that rules out C++/CLI
p23913
aVBack to P/invoke and  in that case
p23914
aVI would stress that it is terrible practice to export a DLL interface based on  and I'd be looking for alternatives to the DLL
p23915
as(dp23916
g7
V505088
p23917
stp23918
a((dp23919
g2
(lp23920
VUse the  verb when starting the process:
p23921
aVThis assumes that you are running as a user in the administrator group
p23922
aVIn that case the UAC dialog will be shown when the process starts
p23923
as(dp23924
g7
V505088
p23925
stp23926
a((dp23927
g2
(lp23928
VDevart have a dbExpress driver for sqlite that supports XE2 64 bit targets
p23929
as(dp23930
g7
V505088
p23931
stp23932
a((dp23933
g2
(lp23934
VYour approach sounds deeply flawed from a software development perspective
p23935
aVCode like  is essentially unreadable and unmaintainable
p23936
aVYou should create properties for the commonly used boolean values and give them meaningful names
p23937
aVIf you find it hard to name a property then don't be afraid to write
p23938
aVThe performance benefits of caching the results of these tests will be unmeasurable in my experience
p23939
aVYour current approach is sure to result in defects and incorrect code
p23940
as(dp23941
g7
V505088
p23942
stp23943
a((dp23944
g2
(lp23945
VYour question is somewhat incomplete because you are comparing two different operations
p23946
aVIf you need to add two things together then testing  isn't going to get you anywhere
p23947
aVSo presumably you want to compare
p23948
aVwith
p23949
aVIt's a lot more complex for interpreted languages like Python, but on the hardware a test for non-zero introduces a branch and that in itself can be expensive
p23950
aVBut I wouldn't want to say which would be faster without timing
p23951
aVThrow into the equation different performance characteristics of different architectures and you have another confounding factor
p23952
aVAs always, you are best to write your code in the most natural maintainable way first and then time it
p23953
aVIf you feel you need to extract more performance use a profiler to find hot spots and then optimise
p23954
as(dp23955
g7
V505088
p23956
stp23957
a((dp23958
g2
(lp23959
VIf you are targetting
p23960
aVnet 4 then your code will work
p23961
aVFor earlier versions you need to use
p23962
aVUse  rather than  so that your code works for both 32 and 64 bit
p23963
as(dp23964
g7
V505088
p23965
stp23966
a((dp23967
g2
(lp23968
VI would write it like this:
p23969
aVThe pertinent documentation is here
p23970
as(dp23971
g7
V505088
p23972
stp23973
a((dp23974
g2
(lp23975
VYes, the function is called
p23976
aVThe  function applies the function to every item and returns a list of the results
p23977
as(dp23978
g7
V505088
p23979
stp23980
a((dp23981
g2
(lp23982
VYou were lucky
p23983
aVThis is undefined behaviour, specifically the call to
p23984
aVThe program could do anything
p23985
aVYour implementation happens to write "LiTtLeDoT"
p23986
aVThe really is the nature of undefined behaviour
p23987
aVThe compiler can do anything it wants
p23988
aVIf you really want to know why it does what it does then you will need to look at the emitted object code
p23989
aVLooking at the C code will yield nothing because of the aforementioned undefined behaviour
p23990
as(dp23991
g7
V505088
p23992
stp23993
a((dp23994
g2
(lp23995
VYes that it possible
p23996
aVThese are just pointers after all
p23997
aVYou can have as many variables as you like containing the same pointer and nobody can tell them apart
p23998
as(dp23999
g7
V505088
p24000
stp24001
a((dp24002
g2
(lp24003
VI'm guessing that you have a 64 bit machine and  is 32 bit
p24004
aVIn that situation  is the 64 bit version of winsock
p24005
aVTry it this way:
p24006
aVto pick up winsock from the 32 bit system directory
p24007
as(dp24008
g7
V505088
p24009
stp24010
a((dp24011
g2
(lp24012
VThe actual value of EOF is system defined and not part of the standard
p24013
aVis an  with negative value and if you want to print it you should use the  format string
p24014
aVNote that this will only tell you its value on your system
p24015
aVYou should not care what its value is
p24016
as(dp24017
g7
V505088
p24018
stp24019
a((dp24020
g2
(lp24021
VCall
p24022
aVYou will need a brush rather than a pen and you must put your points into a point array
p24023
aVThe sample code from MSDN is like this:
p24024
as(dp24025
g7
V505088
p24026
stp24027
a((dp24028
g2
(lp24029
V is read as a string
p24030
aVFirst convert it to an integer:
p24031
aVNote that  works because that concatenates Hours with itself 60 times
p24032
aVBut that certainly is not what you want so you have to convert to  at the first opportunity
p24033
as(dp24034
g7
V505088
p24035
stp24036
a((dp24037
g2
(lp24038
VYou need to put the logging line inside the try/catch so that the compiler knows that  has been initialised
p24039
as(dp24040
g7
V505088
p24041
stp24042
a((dp24043
g2
(lp24044
VYou have no need to worry about performance
p24045
aVOn any machine from the past 10 years you will have no performance issues with filling a screen with windowed controls
p24046
aVAs for the control to use, I think SysLink sounds like the most appropriate choice
p24047
aVIf you are looking for easier ways to manage dynamic GUIs then you may want to contemplate a higher level framework
p24048
aVProgramming the raw Windows API from C is pretty labour intensive
p24049
as(dp24050
g7
V505088
p24051
stp24052
a((dp24053
g2
(lp24054
VThere is no equivalent in WinForms
p24055
aVThis is one of the most common complaints when a Delphi developer switches to WinForms
p24056
aVThere are various third party options but I have no personal experience with which to make a recommendation
p24057
aVYou could take a look at this for starters: http://www
p24058
aVcodeproject
p24059
aVcom/KB/miscctrl/actionlist
p24060
aVaspx
p24061
as(dp24062
g7
V505088
p24063
stp24064
a((dp24065
g2
(lp24066
VMost likely this is down to file redirection
p24067
aVYou have a 64 bit machine but from the 32 Delphi process,  actually redirects to
p24068
aVSo when you think you are asking for the existence of a file in , the system is actually reporting the existance (or otherwise) of a file in
p24069
aVIf you really do need to see into the true 64 bit system32 then you need to disable file redirection
p24070
aVYou can do this with the  function
p24071
aVDon't forget to switch it back on with
p24072
aVBeware that disabling the redirector has wide reaching effects and can result in very strange behaviour so do so with care
p24073
as(dp24074
g7
V505088
p24075
stp24076
a((dp24077
g2
(lp24078
VYour  function should call  to show the preview window
p24079
aVIt should also do whatever is needed to the main form, e
p24080
ag217
aVdisabling it
p24081
aVWhen your preview window receives  it should delete the C++ object that wraps it
p24082
aVSome part of this process also needs to call  on the underlying window handle
p24083
aVThe default handling of  would do this, but perhaps you would want this in the C++ object's destructor
p24084
as(dp24085
g7
V505088
p24086
stp24087
a((dp24088
g2
(lp24089
VSince you don't want to use , your byte arrays are best declared as , allocated with  and filled with data using
p24090
aVThere's no way to get the P/invoke marshaller to do what you need using
p24091
as(dp24092
g7
V505088
p24093
stp24094
a((dp24095
g2
(lp24096
VThis is incorrect since you only allocated max characters for result
p24097
aVI've not studied the logic in detail but allocating max+1 characters would fix this particular problem
p24098
as(dp24099
g7
V505088
p24100
stp24101
a((dp24102
g2
(lp24103
s(dp24104
g7
V505088
p24105
stp24106
a((dp24107
g2
(lp24108
VYou can add to a list recursively like this:
p24109
aVThen call this routine passing in the root node:
p24110
as(dp24111
g7
V505088
p24112
stp24113
a((dp24114
g2
(lp24115
Vis wrong
p24116
aVThat just assigns  to
p24117
aVYou mean
p24118
aVI've not looked beyond this
p24119
aVNo doubt there are more problems, but this is the most significant
p24120
aVThis is the kind of thing you can work out very easily with a debugger
p24121
as(dp24122
g7
V505088
p24123
stp24124
a((dp24125
g2
(lp24126
VI think  in the  package uses the same algorithm as that NAG routine you link to
p24127
as(dp24128
g7
V505088
p24129
stp24130
a((dp24131
g2
(lp24132
VYou don't need to resume threads after the system resumes
p24133
aVThat happens automatically
p24134
aVIf your thread or process doesn't resume operation properly it is probably mis-handling the standby or hibernate
p24135
as(dp24136
g7
V505088
p24137
stp24138
a((dp24139
g2
(lp24140
VThere are a few problems here
p24141
aVYou don't want to use a hard-coded value like (0,0)
p24142
aVThat might not even be visible on a multi-monitor system
p24143
aVAs you have discovered, you should try to avoid  overlapping with the taskbar or other appbars
p24144
aVIf there are multiple monitors you should try and start on the monitor where the user has most recently interacted
p24145
aVThere is a simple way to make much of this happen for free
p24146
aVPass  as the  and  coordinates when you call
p24147
aVThis will let the window manager do the hard work of making your window appear in a sensible location
p24148
aVYou can get the system to tell you the coordinates of the work area
p24149
aVThe work area is that part of the desktop that does not contain the taskbar or other appbars
p24150
aVCall  passing
p24151
aVRetrieves the size of the work area on the primary display monitor
p24152
aVThe work area is the portion of the screen not obscured by the system taskbar or by application desktop toolbars
p24153
aVThe pvParam parameter must point to a  structure that receives the coordinates of the work area, expressed in virtual screen coordinates
p24154
aVTo get the work area of a monitor other than the primary display monitor, call the  function
p24155
as(dp24156
g7
V505088
p24157
stp24158
a((dp24159
g2
(lp24160
VYou can't do this in user mode, it needs to be kernel mode and so that means a driver
p24161
aVYou need a File System Filter Driver
p24162
as(dp24163
g7
V505088
p24164
stp24165
a((dp24166
g2
(lp24167
VYou are only counting swaps and not counting comparisons
p24168
aVIf you want to count comparisons then you need to add an extra counter that you increment every time you pass an  comparison
p24169
as(dp24170
g7
V505088
p24171
stp24172
a((dp24173
g2
(lp24174
VClearly  is an invalid path
p24175
aVThe error message tells you that
p24176
aVPerhaps  contains characters that are not allowed
p24177
aVPerhaps it is a  format user name
p24178
aVPerhaps the file name really is too long
p24179
aVOr perhaps something else is up
p24180
aVTake a look at the actual value of   and you will have your explanation
p24181
aVAs an aside, your code is mistaken in using  and  to get the filename without the extension
p24182
aVFilenames can have multiple periods in them
p24183
aVThe extension is simply that text after the final period
p24184
aVConsider these file names and how your code will deal with them:
p24185
aVInstead you should use
p24186
as(dp24187
g7
V505088
p24188
stp24189
a((dp24190
g2
(lp24191
VYou can call
p24192
aVThat said, there is something to be said for spinning up a dedicated thread for the impersonation task, and terminating it when the impersonation work is complete
p24193
aVThis will segregate the impersonation work so that if any callbacks or messages are processed on the main thread they will be performed in the context of the principal user rather than the impersonated user
p24194
aVIn fact, the more I think about this the stronger I feel that a dedicated thread is the solution
p24195
as(dp24196
g7
V505088
p24197
stp24198
a((dp24199
g2
(lp24200
VYou can't modify a file inplace like that
p24201
aVFiles do not support insertion
p24202
aVYou have to read it all in and then write it all out again
p24203
aVYou can do this line by line if you wish
p24204
aVBut in that case you need to write to a temporary file and then replace the original
p24205
aVSo, for small enough files, it is just simpler to do it in one go like this:
p24206
as(dp24207
g7
V505088
p24208
stp24209
a((dp24210
g2
(lp24211
VI'd probably make life a bit easier for yourself by using an  param of type  rather than
p24212
aVLike this:
p24213
aVThen to call the function you can write this:
p24214
as(dp24215
g7
V505088
p24216
stp24217
a((dp24218
g2
(lp24219
V shows the form modally
p24220
aVThis means that the form will show, all other forms will be disabled, and the  function will not return until the modal dialog is closed
p24221
aVUse  instead
p24222
aVThis shows the form modeless
p24223
aVWhen you do that the  function returns immediately and the form stays open
p24224
aVYou can think of  as being synchronous and  as being asynchronous
p24225
aVMake sure that any methods in the thread which need to update progress on the form are called using  or  to ensure that they run in the context of the main UI thread
p24226
aVFinally, your code as it stands does not wait until the thread has done its work
p24227
aVThe try/catch block only wraps the form show and the beginning of the thread's execution ()
p24228
aVWhen you call  on a thread that call returns asynchronously and the thread continues to do its work
p24229
aVI'm not quite sure what your code is trying to do, but I suspect that the  block should be inside the thread
p24230
as(dp24231
g7
V505088
p24232
stp24233
a((dp24234
g2
(lp24235
VI'd guess that the problem is with your benchmark
p24236
aVProbably the first loop brings everything into the cache
p24237
aVThen the second loop runs identical code but it happens to be faster because the cache is fresh
p24238
aVAs a quick check of this, try reversing the order of the two loops
p24239
as(dp24240
g7
V505088
p24241
stp24242
a((dp24243
g2
(lp24244
VThe sender is the timer object, not the object associated with the handling delegate
p24245
aVFor a start, events can have multiple handlers
p24246
aVWhat you could do is create a delegate which has access to the  using variable capture
p24247
as(dp24248
g7
V505088
p24249
stp24250
a((dp24251
g2
(lp24252
VSomething like this is a direct answer to your question:
p24253
aVThis event handler should be connected to each menu item that you wish to behave this way
p24254
aVIt seems that you want some centralised logging or monitoring of the execution of menu items
p24255
aVIf you use actions and associate these with your menu items then you can get an application wide notification that an action has been executed
p24256
aVDrop a  object onto your main form and handle its  event
p24257
aVLike this:
p24258
aVThis will fire whenever any event in your app is executed
p24259
as(dp24260
g7
V505088
p24261
stp24262
a((dp24263
g2
(lp24264
s(dp24265
g7
V505088
p24266
stp24267
a((dp24268
g2
(lp24269
VThe first thing you yield from  is the empty list,
p24270
aVNaturally you can't access an element on that which is why  fails
p24271
as(dp24272
g7
V505088
p24273
stp24274
a((dp24275
g2
(lp24276
VYou are including the
p24277
aVc file which contains the definition of the function parse_file
p24278
aVThus it is defined twice, once in each translation unit, which is not allowed
p24279
as(dp24280
g7
V505088
p24281
stp24282
a((dp24283
g2
(lp24284
VProtected members can be accessed by other members of the class just like private members
p24285
aVProtected members can also be accessed by members of derived classes
p24286
aVThis is the sole difference between private and protected
p24287
aVIn this case the author of  intended for the protected properties to be available to any derived classes
p24288
aVIt is not a particularly good example without a concrete demonstration of a derived class
p24289
aVPerhaps the details of  that you omitted contain that demonstration \u2013 I certainly hope that is the case
p24290
aVHere's an artificial example of a situation where you may use protected
p24291
aVBy making the  and  methods protected we can make sure they are not called from outside the  class or one of its descendants
p24292
aVBut we can call  and  from the base class and yet have the actual implementations supplied by derived classes that know how to handle the persistence
p24293
aVI hope you have covered virtual methods already
p24294
as(dp24295
g7
V505088
p24296
stp24297
a((dp24298
g2
(lp24299
VTwo problems:
p24300
aVYou need to escape the backslash character
p24301
aVWrite
p24302
aVYou need to use a relative path
p24303
aVBy starting a path with  you mean start from the root directory
p24304
aVPutting these together, I think you should write:
p24305
as(dp24306
g7
V505088
p24307
stp24308
a((dp24309
g2
(lp24310
VIn fact  fails if you attempt to move a directory to a different volume
p24311
aVIf you want to perform such a move you have to do the Copy/Delete yourself
p24312
aVI think you can safely assume that  will only ever succeed if the operation can be performed without copying files
p24313
as(dp24314
g7
V505088
p24315
stp24316
a((dp24317
g2
(lp24318
VYou are about to enter a world of pain
p24319
aVInvariably *nix consoles prefer you to send them UTF-8 encoded char* data
p24320
aVWindows on the other hand uses UTF-16 for its Unicode APIs and for console APIs I believe it is limited to UCS2
p24321
aVYou need probably need to find some library code that abstracts away the differences for you
p24322
aVI don't have a good recommendation for you but I am sure that  and  are not the solution
p24323
as(dp24324
g7
V505088
p24325
stp24326
a((dp24327
g2
(lp24328
VUse the  property
p24329
as(dp24330
g7
V505088
p24331
stp24332
a((dp24333
g2
(lp24334
VReference counting for interfaces
p24335
aVYour original question and the follow up in the comments to this answer all hinge on Delphi's interface reference counting mechanism
p24336
aVThe compiler emits code to arrange that all references to an interface are counted
p24337
aVWhenever you take a new reference, the count is increased
p24338
aVWhenever a reference is released (set to , goes out of scope etc
p24339
aVthe count is decreased
p24340
aVWhen the count reaches zero, the interface is released and in your case this is what calls  on your objects
p24341
aVYour problem is that you are cheating the reference counting by putting interface references into and out of the  by casting to  and back
p24342
aVSomewhere along the way the references are miscounted
p24343
aVI'm sure your code's behaviour (i
p24344
ag192
aVthe stack overflows) could be explained but I am disinclined to attempt to do so since the code uses such obviously incorrect constructs
p24345
aVSimply put you should never cast an interface to an unmanaged type like
p24346
aVWhenever you do so you also need to take control of the missing reference counting code
p24347
aVI can assure you this is something you do not want to take on
p24348
aVYou should use a proper type-safe container like  or even a dynamic array and then the reference counting will be handled correctly
p24349
aVMaking this change to your code solves the problems you describe in the question
p24350
aVCircular references
p24351
aVHowever, there still remains one big problem, as you have discovered for yourself and detailed in the comments
p24352
aVOnce you follow the reference counting rules, you are faced with the problem of circular references
p24353
aVIn this case a node holds a reference to the container which in turn holds a reference to the node
p24354
aVCircular references like this cannot be broken by the standard reference counting mechanism and you have to break them yourself
p24355
aVOnce you break one of the two individual references that make up a circular reference, the framework can do the rest
p24356
aVWith your current design you must break the circular references by explicitly calling  on every  that you create
p24357
aVThe other problem with the code as it stands is that you are using data fields of the form to hold ,  etc
p24358
aVBecause you never set  to  then two executions of your event handler will result in a leak
p24359
aVIn made the following changes to your code to prove that it will run without leaking:
p24360
aVWith these changes the code runs without memory leaks \u2013 set  at the start of the
p24361
aVdpr file to check
p24362
aVIt is going to be something of a bind to have to call  on every node so I suggest that you simply add a method to  to do that
p24363
aVOnce you arrange that the container is capable of dropping its references then you will have a much more manageable system
p24364
aVYou will not be able to let reference counting do all the work for you
p24365
aVYou will need to call  explicitly
p24366
aVYou can implement this new method like this:
p24367
aVReference counting bugs
p24368
aVAlthough the Delphi reference counting mechanism is very well implemented in general, there is, to my knowledge, one long-standing and very well-known bug
p24369
aVWhen  called in this way no code is generated to add a reference to the interface
p24370
aVThe interface is thus released as soon as it is created and  acts on an invalid interface
p24371
aVBecause  receives the parameter as ,  does not take a reference to the interface
p24372
aVThe bug is in the codegen for the call to  which mistakenly does not take a reference to the interface
p24373
aVMy preferred way to work around this particular problem is like this:
p24374
aVThis succeeds because we explicitly take a reference
p24375
aVNote that I have explained this for future reference \u2013 your current code does not fall foul of this problem
p24376
as(dp24377
g7
V505088
p24378
stp24379
a((dp24380
g2
(lp24381
VIf the header is at the beginning of the file then it is simply impossible to remove that header without completely re-writing the entire file
p24382
aVThat's simply the nature of file systems
p24383
aVThe obvious solution to the conundrum is to put the header right at the end of the file
p24384
aVIt's a trivial operation to strip off the end of a file
p24385
aVAnother option would be to put the header in a separate file or even an alternate file stream
p24386
as(dp24387
g7
V505088
p24388
stp24389
a((dp24390
g2
(lp24391
VAs I'm sure everyone knows, the standard way to manage an object is like this:
p24392
aVIf there is an exception in  then the destructor will be called and then the exception raised
p24393
aVIn that case  will not be assigned to
p24394
aVWhen you have multiple objects you can repeat the pattern:
p24395
aVThis very quickly becomes a mess and hence the question
p24396
aVA standard trick is to take advantage of the fact that  can safely be called on a  object reference
p24397
aVThis does have the minor weakness that it is not resilient to exceptions being raised in  but it is not unreasonable to regard this as a failure condition that can be ignored
p24398
aVDestructors should not raise exceptions
p24399
aVIf they do then your system is probably broken irredeemably
p24400
aVThis pattern above can become a little messy as more objects are added so I personally use the following helper methods
p24401
aVIn fact my code has versions with even more parameters
p24402
aVFor ease of maintenance this code is all automatically generated from a short Python script
p24403
aVThese methods are implemented in the obvious way, e
p24404
ag217
aVThis allows us to re-write the sample above like this:
p24405
as(dp24406
g7
V505088
p24407
stp24408
a((dp24409
g2
(lp24410
VIn the comments you state that  returns
p24411
aVThis is because you request write access to a key to which you do not have sufficient rights because of UAC
p24412
aVYou will need to run your process elevated to write to this key
p24413
aVAs others have correctly pointed out, you should not call  since  does not set the last error value and instead returns the error code directly
p24414
aVMore importantly you should be using the power management API rather than hacking the registry
p24415
aVEven when you switch to the power management API you will still require administrator rights
p24416
aVYou can arrange this by setting  to  in your application manifest
p24417
aVIn Visual Studio you can make this change in the project configuration under Linker | Manifest File | UAC Execution Level
p24418
as(dp24419
g7
V505088
p24420
stp24421
a((dp24422
g2
(lp24423
VThere is no such limit
p24424
aVYou are mistaken
p24425
aVClearly you are limited by address space and the requirement that the buffer is a contiguous block of virtual memory
p24426
aVOn a 32 bit system each process can only address 2GB of virtual memory
p24427
aVWhat's more you will not be able to allocate a 2GB contiguous block of memory
p24428
aVBut these are general limitations
p24429
aVThe  API will happily read into as big a buffer as your can allocate
p24430
aVYou claim to have hit a limit of 8KB but I have just successfully written and read a 1GB file using  and
p24431
aVClearly you have some problem but it's just not what you think it is
p24432
aVIf you could show the rest of the code, especially that which calls your p/invoke then I'm sure it would become obvious
p24433
aVAnd now that you have posted your full code we can see what the issue is
p24434
aVYou are not reading a file but instead performing read of the physical disk
p24435
aVI see now that's what you meant by "reading directly from a disk" but I think you could have been a bit more specific
p24436
aVAnyway, I don't know the details of what's happening here, but the issue is clearly not  per se, but that fact that your handle is to the physical disk rather than a file
p24437
aVThe documentation for  states:
p24438
aVA volume contains one or more mounted file systems
p24439
aVVolume handles can be opened as noncached at the discretion of the particular file system, even when the noncached option is not specified in CreateFile
p24440
aVYou should assume that all Microsoft file systems open volume handles as noncached
p24441
aVThe restrictions on noncached I/O for files also apply to volumes
p24442
aVA file system may or may not require buffer alignment even though the data is noncached
p24443
aVHowever, if the noncached option is specified when opening a volume, buffer alignment is enforced regardless of the file system on the volume
p24444
aVIt is recommended on all file systems that you open volume handles as noncached, and follow the noncached I/O restrictions
p24445
aVI think you should consider asking a new question about how to read from physical disks
p24446
as(dp24447
g7
V505088
p24448
stp24449
a((dp24450
g2
(lp24451
VSimply put  is not an , rather it is an
p24452
aVYou cannot assign an  to a pointer since they are different things
p24453
aVThe code  succeeds because string literals are assignment compatible with  pointers
p24454
aVNote however that   has the effect of making  point to a string literal
p24455
aVString literals are generally stored in read-only memory so any attempts to modify them fail
p24456
aVSo you would be better to write
p24457
as(dp24458
g7
V505088
p24459
stp24460
a((dp24461
g2
(lp24462
VIf you don't deploy to a folder that is subject to file redirection (i
p24463
ag192
aVsystem32) then you pretty much need to give the DLLs different names
p24464
aVThe reason for this is that the DLL search path is shared between 32 and 64 bit processes and if you are relying on the search path to locate the DLL, that forces you to use different names
p24465
aVNote that I am ruling out any solutions that rely on SxS versioning
p24466
aVAttempting to go down that route leads to all sorts of complications and headaches for anyone attempting to use your DLL
p24467
as(dp24468
g7
V505088
p24469
stp24470
a((dp24471
g2
(lp24472
VThe alpha values are retained in the pixel data and are available for use
p24473
aVBut the pixel intensities are not the true value, but have been multiplied by the alpha
p24474
aVThe Wikipedia article has a good discussion of the pros and cons
p24475
as(dp24476
g7
V505088
p24477
stp24478
a((dp24479
g2
(lp24480
VInclude a
p24481
aVdef file to defeat stdcall name decoration
p24482
aVThen you can get rid of the __declspec(dllexport) clutter
p24483
as(dp24484
g7
V505088
p24485
stp24486
a((dp24487
g2
(lp24488
VYou are saying that the function is external, defined in a Dll
p24489
aVAnd then you are defining it in your code
p24490
aVThis is illegal since is has to be one or the other, but not both external and internal
p24491
aVMy guess is that you simply need to change dllimport to dllexport
p24492
aVI assume that you are building this code into a library
p24493
as(dp24494
g7
V505088
p24495
stp24496
a((dp24497
g2
(lp24498
VYou simply need to set the  property of the child form
p24499
aVAnd you also need to have set  for your main form
p24500
aVThere is a walkthrough of the basics on MSDN
p24501
as(dp24502
g7
V505088
p24503
stp24504
a((dp24505
g2
(lp24506
VThe only scripting languages supported out of the box are the batch interpreter, vbscript and jscript
p24507
aVOther than that you are into compiled languages
p24508
aVA good option could be C# but make sure you target the
p24509
aVnet version that shipped with XP
p24510
as(dp24511
g7
V505088
p24512
stp24513
a((dp24514
g2
(lp24515
VYou need to be logged on to access the task manager
p24516
aVWhen the screen is locked you are to all intents and purposes not logged on
p24517
as(dp24518
g7
V505088
p24519
stp24520
a((dp24521
g2
(lp24522
VThis should do it:
p24523
aVThis version allows you to specify the separator, you would obviously pass
p24524
aVIf you ask for an item beyond the end then the function will return the empty string
p24525
aVYou could change that to an exception if you preferred
p24526
aVFinally, I have arranged that this uses 1-based indexing as per your example, but I personally would choose 0-based indexing
p24527
as(dp24528
g7
V505088
p24529
stp24530
a((dp24531
g2
(lp24532
VThere's no way to check whether or not a raw pointer is valid
p24533
aVInvalid pointers are not guaranteed to fail when you access them
p24534
aVInstead of using a raw pointer, you need to use some form of smart pointer
p24535
as(dp24536
g7
V505088
p24537
stp24538
a((dp24539
g2
(lp24540
VThree problems that I can see:
p24541
aVYou are returning  but the function is declared to return
p24542
aVThe latter is just a single character rather than a string
p24543
aVYou are attempting to return memory that is only valid on the stack frame of the function
p24544
aVThis is an error
p24545
aVYour function is declared so that it can receive any number of arguments
p24546
aVBetter to explicitly declare it to receive none with
p24547
aVFix like this:
p24548
aVHere I am using  to allocate the string on the heap
p24549
aVIf you really wanted a buffer that was 20 characters long then you would need to use  followed by
p24550
aVEither way the responsibility for freeing the returned string is passed onto the caller
p24551
as(dp24552
g7
V505088
p24553
stp24554
a((dp24555
g2
(lp24556
VIs there any difference between the ways of memory allocating used in the code above
p24557
aVThe first one allocates memory
p24558
aVThe second one does not
p24559
as(dp24560
g7
V505088
p24561
stp24562
a((dp24563
g2
(lp24564
VYour Delphi function is using an open array for the string parameter
p24565
aVThis is not something that should be exposed across a DLL boundary
p24566
aVThe protocol for calling an Delphi open array is implementation specific
p24567
aVYou should change your Delphi code to receive a
p24568
aVIf the data is being passed from C# to the Delphi DLL then your P/invoke is fine
p24569
aVIf the DLL is meant to return data to the C# code then you need to declare the text parameter as  in the P/invoke
p24570
aVThe only other thing to watch out for is what the meaning of  is in Delphi
p24571
aVIf the DLL is built with Delphi 2009 or later then  is a Unicode character and you need to specify the  in your P/invoke
p24572
as(dp24573
g7
V505088
p24574
stp24575
a((dp24576
g2
(lp24577
VNo this is not thread-safe at all
p24578
aVThe lock has no effect since the object is local to the thread
p24579
aVIt needs to be shared by all calling threads
p24580
aVOnce you fix that you don't need to use interlocked increment because the lock serialises execution
p24581
aVAs a general rule you should place  at the same level as the resource you are protecting
p24582
aVIf the resource is owned by the instance then so should be
p24583
aVSimilarly if the resource is owned by the class
p24584
aVAs for re-entrancy, the  keyword uses a re-entrant lock, i
p24585
ag192
aVone that lets the same thread in if the lock is held by that thread
p24586
aVThat's probably not what you want
p24587
aVBut if you had a non re-entrant lock then you would just deadlock yourself with a re-entrant call
p24588
aVAnd I don't think you'd want that either
p24589
aVYou look like you want a wrap around increment
p24590
aVSo long as the collection is not being modified, this can be achieved with interlocked operations, i
p24591
ag192
aVlock free
p24592
aVIf so then it can be written like this:
p24593
aVNote: You should declare  as volatile
p24594
as(dp24595
g7
V505088
p24596
stp24597
a((dp24598
g2
(lp24599
VThe line
p24600
aVis not doing what you thing it is
p24601
aVThat code simply changes the local copy of the pointer to the buffer
p24602
aVIt does not change the buffer's contents
p24603
aVYou need to call
p24604
aVjust before the function returns, i
p24605
ag192
aVwhere your  is now
p24606
aVLooking at your logic, I believe it will fail for more complex inputs
p24607
aVI'm not going to attempt to debug it for you because I am not 100% sure of what you want the code to do
p24608
as(dp24609
g7
V505088
p24610
stp24611
a((dp24612
g2
(lp24613
VYou failed to show the average method but my guess is that you do a divide by zero in there
p24614
aVWackiness ensues
p24615
as(dp24616
g7
V505088
p24617
stp24618
a((dp24619
g2
(lp24620
VYou didn't create
p24621
aVAllocate the structs with  rather than  and this will create  for you
p24622
aVRemember to dispose with  rather than
p24623
aVIn fact, since you are using C++ you should simply stop using
p24624
as(dp24625
g7
V505088
p24626
stp24627
a((dp24628
g2
(lp24629
VWindows does not define a CSIDL for the Downloads folder and it is not available through the  enumeration
p24630
aVHowever, the new Vista Known Folder API does define it with the ID of
p24631
aVProbably the easiest way to obtain the actual value is to P/invoke
p24632
aVNote that the P/invoke given on pinvoke
p24633
aVnet is incorrect since it fails to use Unicode character set
p24634
aVAlso I have taken advantage of the fact that this API returns memory allocated by the COM allocator
p24635
aVThe default marshalling of the P/invoke above is to free the returned memory with  which is perfect for our needs
p24636
aVBe careful that this is a Vista and up API and do not attempt to call it on XP/2003 or lower
p24637
as(dp24638
g7
V505088
p24639
stp24640
a((dp24641
g2
(lp24642
VYou need to call  passing
p24643
aVThe  is a slightly tricky API to use since you need to merge the new mode with the existing modes
p24644
aVRaymond Chen explains how to do it correctly
p24645
as(dp24646
g7
V505088
p24647
stp24648
a((dp24649
g2
(lp24650
VI imagine that the problem is that this will only find objects that match
p24651
aVYou are wanting a recursive search that descends into directories
p24652
aVBut it will only descend into directories that match
p24653
aVFor a recursive search like this you have to enumerate all the directories without the  wildcard
p24654
aVIt may be easier to do the wildcard testing yourself
p24655
aVSo change the code to:
p24656
aVand test each file individually for the extension
p24657
aVAs others have pointed out, you are failing to check the first file that is found
p24658
aVYou must move the  to the end of the loop
p24659
as(dp24660
g7
V505088
p24661
stp24662
a((dp24663
g2
(lp24664
VC++ enums are not type-safe
p24665
aVYou can, as you say, ram any value down an enums throat
p24666
aVThis feature is not implementation dependent, it is enshrined in the standard
p24667
aVC++11 introduces strongly-typed enumerations which are declared with a different syntax so as not to break your old code with type unsafe enumerations
p24668
as(dp24669
g7
V505088
p24670
stp24671
a((dp24672
g2
(lp24673
VIf you can't allow the two values to be equal then pretty much your only option it to raise an exception in that case
p24674
as(dp24675
g7
V505088
p24676
stp24677
a((dp24678
g2
(lp24679
VThere's not much to choose I don't think
p24680
aVThe Argp webpage says this:
p24681
aVArgp provides features unavailable in the more commonly used getopt
p24682
aVinterface
p24683
aVThese features include automatically producing output in
p24684
aVresponse to the \u2018--help\u2019 and \u2018--version\u2019 options, as described in the
p24685
aVGNU coding standards
p24686
aVUsing argp makes it less likely that programmers
p24687
aVwill neglect to implement these additional options or keep them up to
p24688
aVdate
p24689
aVArgp also provides the ability to merge several independently defined
p24690
aVoption parsers into one, mediating conflicts between them and making
p24691
aVthe result appear seamless
p24692
aVA library can export an argp option parser
p24693
aVthat user programs might employ in conjunction with their own option
p24694
aVparsers, resulting in less work for the user programs
p24695
aVSome programs
p24696
aVmay use only argument parsers exported by libraries, thereby achieving
p24697
aVconsistent and efficient option-parsing for abstractions implemented
p24698
aVby the libraries
p24699
as(dp24700
g7
V505088
p24701
stp24702
a((dp24703
g2
(lp24704
VI'll answer the first question
p24705
aVThe second question involves code at a different site and you should only ask one question at a time
p24706
aVPerhaps someone else will answer the second question
p24707
aVThe code you included will work correctly
p24708
aVThe members  and  are unused and not needed
p24709
aVThe  method has no implementation but you can just delete it
p24710
aVPersonally I would raise an exception if  is not assigned
p24711
aVThat's a clear error condition
p24712
aVSilently continuing and pretending that the resource is protected is an obvious danger
p24713
as(dp24714
g7
V505088
p24715
stp24716
a((dp24717
g2
(lp24718
VIt's probably a function defined by the author of the script
p24719
aVSearch for it in the code you have
p24720
as(dp24721
g7
V505088
p24722
stp24723
a((dp24724
g2
(lp24725
VAssuming that there has been no change in window title from XP to Vista, there's not much that can go wrong here
p24726
aVI'd hazard a guess that the problem is due to UIPI
p24727
aVThis is part of the security enhancements of Vista and it means that processes can only send messages to other processes that have equal or lower integrity level
p24728
aVIs this other process running elevated
p24729
aVOther than that your best bet is to run this under the debugger
p24730
aVDelphi 6 most certainly does run on Vista
p24731
aVIt was written before UAC and so doesn't get on well with having no rights to write to its install directory
p24732
aVSo, install it to somewhere in your user profile or C:\u005cDelphi6 \u2013 basically anywhere that standard users have write access
p24733
aVFinally, don't fall into the trap of running Delphi elevated
p24734
aVThis will confound the UIPI issue if indeed that is an issue here
p24735
aVGood luck
p24736
as(dp24737
g7
V505088
p24738
stp24739
a((dp24740
g2
(lp24741
VIf you make h too small then your derivative will be innaccurate due to floating point roundoff
p24742
aVYour code would benefit from using double precision rather than single, especially as you are doing differentiation by finite difference
p24743
aVWith double precision your value of h would be fine
p24744
aVIf you stick to single precision you will need to use a larger value
p24745
aVOnly allowing 2 iterations seems rather restrictive
p24746
aVMake N larger and get your program to print out the number of iterations used
p24747
aVAlso, no need to use pow
p24748
aVSimply write 1e-7
p24749
as(dp24750
g7
V505088
p24751
stp24752
a((dp24753
g2
(lp24754
VYou can use ,  or  depending on your exact needs
p24755
as(dp24756
g7
V505088
p24757
stp24758
a((dp24759
g2
(lp24760
VThis function will strip leading zeros:
p24761
as(dp24762
g7
V505088
p24763
stp24764
a((dp24765
g2
(lp24766
VThat is the behaviour as designed
p24767
aVHere's what my app looks like, for example:
p24768
aVIf you want to add some padding you'll need to add it to your icon
p24769
as(dp24770
g7
V505088
p24771
stp24772
a((dp24773
g2
(lp24774
VTwo questions in one
p24775
aVI don't know about the first, but the critical section part is easy to explain
p24776
aVThe background thread isn't trying to claim the lock and so, of course, is not blocked
p24777
aVYou need to make the critical section object  visible to the thread so that it can lock it
p24778
aVThe way to use this lock class is that each section of code that you want serialised must create a  object and hold on to it until the end of the serialised block:
p24779
aVThread 1:
p24780
aVThread 2:
p24781
aVNote that it has to be the same critical section instance  that is used in each block of code that is to be serialised
p24782
as(dp24783
g7
V505088
p24784
stp24785
a((dp24786
g2
(lp24787
VYou missed out the instance parameter, usually named :
p24788
as(dp24789
g7
V505088
p24790
stp24791
a((dp24792
g2
(lp24793
VMost likely you are being caught out by registry redirection
p24794
aVYou have a 32 bit process running on a 64 bit system
p24795
aVSo  is redirected to
p24796
aVWhen the key does not exist, the  returns  rather than the default value and so the exception is thrown
p24797
aVIf the name is not found in the specified key, returns a default value that you provide, or null if the specified key does not exist
p24798
as(dp24799
g7
V505088
p24800
stp24801
a((dp24802
g2
(lp24803
VNo can do
p24804
aVYou can't have two variables in the same scope with the same name
p24805
as(dp24806
g7
V505088
p24807
stp24808
a((dp24809
g2
(lp24810
VYou are looking for the  overload of :
p24811
as(dp24812
g7
V505088
p24813
stp24814
a((dp24815
g2
(lp24816
VWhilst  will get the job done I would rather cast it to :
p24817
aVSince  is a pointer, casting to another pointer is more natural \u2013 it's not possible for there to be a pointer width error now or in the future
p24818
as(dp24819
g7
V505088
p24820
stp24821
a((dp24822
g2
(lp24823
VC++ is case-sensitive
p24824
aVYou typed  but the method is called
p24825
aVAnd, of course, you need to pass that method a node pointer
p24826
as(dp24827
g7
V505088
p24828
stp24829
a((dp24830
g2
(lp24831
VI'd guess that you simply need to explicitly set the color for the other cases
p24832
aVSince you aren't doing so the canvas state persists
p24833
aVTry this:
p24834
as(dp24835
g7
V505088
p24836
stp24837
a((dp24838
g2
(lp24839
VAnother excellent option is C++Builder with the VCL
p24840
aVThis is very similar to WinForms (whose design it clearly inspired) and much more productive than MFC in my opinion
p24841
as(dp24842
g7
V505088
p24843
stp24844
a((dp24845
g2
(lp24846
VYou are looking for something like this:
p24847
aVThe key part that I believe you are missing is that the array is terminated by a  entry
p24848
aVThat's what the test in the for loops checks
p24849
as(dp24850
g7
V505088
p24851
stp24852
a((dp24853
g2
(lp24854
VYour test is happening before  is assigned
p24855
aVThus its results are undefined
p24856
aVThis test should be moved to the end of the iteration, i
p24857
ag192
ag4706
aVWhilst you could assign  to some non-zero value this feels slightly untidy to me
p24858
aVAnd surely you mean to use logical AND rather than logical OR
p24859
aVYou only want to continue iterating if both  is non-zero AND
p24860
aVOf course, if you did move the test to the end of the iteration then you would have to account for the fact that  had been incremented inside the loop
p24861
as(dp24862
g7
V505088
p24863
stp24864
a((dp24865
g2
(lp24866
V is one of the most widely used functions in existence
p24867
aVI'd be simply astounded if it did not work
p24868
aVThe most likely explanation is that you have different values for
p24869
aVInspect the values of that string and I'm sure you will see what is going on
p24870
as(dp24871
g7
V505088
p24872
stp24873
a((dp24874
g2
(lp24875
VCreate a window but don't show it
p24876
aVUse  to create the icon in the notification area
p24877
aVIn order to perform step 2 you will need the window created in step 1
p24878
aVIf you have never programmed in C before and never used the Win32 API before this is an ambitious first project
p24879
aVFirst of all you should master the basics of showing windows, programming a message loop, handling messages etc
p24880
aVI recommend Programming Windows by Petzold
p24881
as(dp24882
g7
V505088
p24883
stp24884
a((dp24885
g2
(lp24886
VIt sounds very much like you have a straightforward 32/64 bit mismatch
p24887
aVSince your COM DLL is 32 bit you need to:
p24888
aVMake sure that the applications that consume this COM DLL target x86
p24889
aVRegister the COM DLL with the 32 bit version of regsvr32 which resides in the  folder on a 64 bit machine
p24890
aVMy guess is that you are attempting to register with the 64 bit version of
p24891
aVIf you make sure everything involved with the registration and consumption is 32 bit then you should be fine
p24892
as(dp24893
g7
V505088
p24894
stp24895
a((dp24896
g2
(lp24897
VYou can use
p24898
aVRemoves all the elements that match the conditions defined by the specified predicate
p24899
aVThere's no need for explicit iteration over the list
p24900
aVYou can just call it like this:
p24901
aVYou also forgot to write the list back to the file
p24902
aVI think you want code like this:
p24903
as(dp24904
g7
V505088
p24905
stp24906
a((dp24907
g2
(lp24908
VHow  and  work is implementation defined
p24909
aVCommonly the info about the memory block would be stored in a header just below
p24910
aVBut not necessarily
p24911
aVThe great thing about  and  is that you don't need to know how they work
p24912
aVThe system takes care of the details for you
p24913
aVI read somewhere that calling free twice using the same pointer argument causes undefined behavior
p24914
aVIn order to understand this I must first know how free works
p24915
aVI'm not sure I agree with this statement
p24916
aVYou simply need to follow the rule
p24917
aVDoes the heap always allocate contiguous memory when we call malloc/calloc/realloc
p24918
aVIf you mean that the block of memory returned is contiguous in the address space, then yes that is so
p24919
aVIf you mean that successive allocations are sequential, then no
p24920
as(dp24921
g7
V505088
p24922
stp24923
a((dp24924
g2
(lp24925
VScreen grabbing is not a good option
p24926
aVYou should be able to use  based methods to get hold of the radio button if the app uses windowed controls
p24927
aVIf not then UI Automation may very well be able to get the value of the radio button
p24928
aVWhatever it's usually possible to read UI state out of another application with methods like this, and much easier than screen scraping
p24929
as(dp24930
g7
V505088
p24931
stp24932
a((dp24933
g2
(lp24934
VIn Python you don't generally use quite the same approaches to OOP as in statically typed languages
p24935
aVSpecifically you don't actually need an object to implement a specific interface or derive from an abstract base class and so on
p24936
aVRather that object just needs to be able to do the required operations
p24937
aVThis is colloquially known as duck typing
p24938
aVIf it walks like a duck and talks like a duck then, to all intents and purposes it is a duck
p24939
aVSo just decide what methods are required for your objects and make sure that they always have them
p24940
aVShould you wish to share implementation between different actors in your system then you can consider class inheritance
p24941
aVBut if not then you may as well implement disjoint class hierarchies
p24942
as(dp24943
g7
V505088
p24944
stp24945
a((dp24946
g2
(lp24947
VYou have to pass  a plain old function, i
p24948
ag192
aVone that is not bound to an instance
p24949
aVYou must pass the instance in separately
p24950
aVLike this:
p24951
aVThe reason it must be done this way is that an instance method does not match the required signature for
p24952
aVAn instance method has an extra, implicit, parameter containing the instance reference, i
p24953
ag192
aVThis is how you are able to refer to instance members
p24954
aVBut the signature for  does not cater for this
p24955
as(dp24956
g7
V505088
p24957
stp24958
a((dp24959
g2
(lp24960
VSince you are using Python 2
p24961
aVx, I believe you simply need to use  rather than  and  will do the rest
p24962
aVHowever, I would have expected  to automatically convert  to  for you
p24963
aVYou should write it like this:
p24964
aVIf this does not work then I think your problem lies elsewhere
p24965
as(dp24966
g7
V505088
p24967
stp24968
a((dp24969
g2
(lp24970
VYou need to P/invoke the  API
p24971
aVThat accepts username, domain and password and returns a token
p24972
as(dp24973
g7
V505088
p24974
stp24975
a((dp24976
g2
(lp24977
VThe C++ binding may introduce a small overhead, but it's on the CPU side
p24978
aVRemember that these examples serve as tutorials
p24979
aVThere's nothing to stop you writing your code in C
p24980
aVI'd guess that it's easier to write example applications in C++ because the use of a higher level language allows the reader to see the important details more easily and not be drowned in the morass of low-level memory management that blights C code
p24981
as(dp24982
g7
V505088
p24983
stp24984
a((dp24985
g2
(lp24986
V is declared like this:
p24987
aVYou are assuming that  is packed and contains no padding
p24988
aVI don't know how XLLs are meant to be compiled but I think it is very likely that there is padding between  and  to arrange that  is 8 byte aligned
p24989
aVWith default settings, MSVC returns 16 for  which supports my hypothesis
p24990
aVChange your allocation to this:
p24991
aVEven if this isn't the cause of your problem, the allocation above is the logically correct form
p24992
aVOtherwise I cannot see anything wrong with your code
p24993
aVI think you could be more explicit in initialising  to  but that's a minor point
p24994
as(dp24995
g7
V505088
p24996
stp24997
a((dp24998
g2
(lp24999
VYou can't do what you want with
p25000
aVIt wraps up the common Windows component which has special treatment for file names that contain wildcards
p25001
aVThose are interpreted as filters for the file list view
p25002
as(dp25003
g7
V505088
p25004
stp25005
a((dp25006
g2
(lp25007
VThe compiler will produce identical code for these two options
p25008
aVYour example is quite trivial since the array involves plain-old-data (POD)
p25009
aVThe standard says that option 1 will be initialized each time  is run, but option 2 will be initialized the first time  is run
p25010
aVHowever, implementations are allowed to deviate from that so long as the result is indistinguishable to that specified in the standard, the so-called as-if rule
p25011
aVIn this case compilers write the arrays into read-only memory of the executable and there is no initialization at all at runtime
p25012
aVThey can do this with POD types
p25013
aVIf you had an object that required runtime instantiation then things would be different
p25014
aVConsider the behaviour of the following program:
p25015
aVThe constructor for  runs 3 times
p25016
as(dp25017
g7
V505088
p25018
stp25019
a((dp25020
g2
(lp25021
VThe font you are using does not contain a glyph for that character
p25022
aVYou will likely need to install some new fonts to overcome this deficiency
p25023
aVThe character you have picked out is 'SAMARITAN MODIFIER LETTER EPENTHETIC YUT' (U+081A)
p25024
aVPerhaps you were after U+2074, i
p25025
ag192
aV'SUPERSCRIPT FOUR' (U+2074)
p25026
aVYou need hex for that: 0x2074
p25027
aVNote you changed the question to read  but the original version read
p25028
aVEither way, if you see a box that indicates your font is missing that glyph
p25029
as(dp25030
g7
V505088
p25031
stp25032
a((dp25033
g2
(lp25034
VI think this topic from the documentation has the most complete list of characters
p25035
aVThe same topic can be found in your Delphi 7 help file by searching for TMaskEdit
p25036
aVI just checked the Delphi 6 help file and the list of mask characters is identical to the XE2 version so, as @afrazier says, nothing much appears to have changed
p25037
as(dp25038
g7
V505088
p25039
stp25040
a((dp25041
g2
(lp25042
V places input in the message queue which is queued and so will get processed after you have reconnected the events
p25043
aVHence the wackiness
p25044
aVMy advice is to stop using  to update the contents of your own controls
p25045
aVSimply modify the contents of the text boxes directly
p25046
as(dp25047
g7
V505088
p25048
stp25049
a((dp25050
g2
(lp25051
VThe two operators have different meaning
p25052
aVtests object identity
p25053
aVDo the two operands refer to the same object
p25054
aVtests equality of value
p25055
aVDo the two operands have the same value
p25056
aVWhen it comes to comparing  and  you invariably are interested in the value rather than the object holding the value
p25057
as(dp25058
g7
V505088
p25059
stp25060
a((dp25061
g2
(lp25062
VCasting away const here might shut the compiler up but will lead to runtime failures
p25063
aVMake a copy of the string and work on that
p25064
aVCasting away const does not copy the contents of the memory
p25065
aVIt just creates a pointer to the same memory and tells the compiler that it can go right ahead and write to that memory
p25066
aVIf the memory is read only you have a protection fault
p25067
aVMore seriously you can have correctness problems which are hard to debug
p25068
aVDon't cast away const
p25069
aVOf course, if you need to modify a variable and have those modifications visible to the caller, then you should not make it const in the first place
p25070
aVOn the other hand, if the modifications are meant to be private to the function, then duplication of the const parameter is best
p25071
aVAs a broad rule you should attempt to avoid casts if at all possible
p25072
aVCasts are one of the most frequent sources of errors
p25073
as(dp25074
g7
V505088
p25075
stp25076
a((dp25077
g2
(lp25078
VThe declaration of  omits the calling convention
p25079
aVYou need to include
p25080
aVWhen you don't specify a calling convention the default calling convention is used
p25081
aVThe default calling convention is
p25082
aVThis has different semantics for parameter passing and clean up which leads to the type of runtime error you have experienced
p25083
aVPractically all Windows API functions used
p25084
as(dp25085
g7
V505088
p25086
stp25087
a((dp25088
g2
(lp25089
V means that the contents of the string are constant
p25090
aVYou can have different pointers referring to the same constant memory
p25091
aVIn other words, the pointers are different variables with the same value
p25092
aVRemember that the value of a pointer is the address of the memory to which it refers
p25093
aVSo, yes, the assignment above is perfectly valid
p25094
aVI wonder if this question is related to your previous question
p25095
aVYou say here:
p25096
aVCan we assign one const char * to another and modify the value
p25097
aVIf by "modify the value" you mean modify the contents of the string (that's what you wanted to do in the previous question), then no you cannot
p25098
aVIn the example you give here, you have two pointers referring to the same constant block of memory
p25099
aVIf one of the pointers cannot modify that memory, then neither can the other
p25100
as(dp25101
g7
V505088
p25102
stp25103
a((dp25104
g2
(lp25105
VYou are almost there
p25106
aVYou just need to pass a pointer to the first element of the array:
p25107
aVIn fact, as @Serg points out, this is equivalent to your existing code
p25108
aVSo it seems that, as you have commented below, the issue you are facing is unrelated to the passing of this parameter
p25109
aVAs an aside, I think I would use  rather than , but that's not the issue here since they are equivalent
p25110
as(dp25111
g7
V505088
p25112
stp25113
a((dp25114
g2
(lp25115
VThis is guaranteed to work by the standard
p25116
aVMembers in structs are layed out sequentially in the order you specify and the first member always appears at offset 0
p25117
aVRelevant excerpts from the ANSI C standard:
p25118
aVA structure is a type consisting of a sequence of members, whose storage is allocated in an ordered sequence
p25119
aVThis states that the members are laid out sequentially
p25120
aVThere may be unnamed padding within a structure object, but not at its beginning
p25121
aVThe means that the first member is placed at offset 0
p25122
aVNote: Standard excerpts taken from section 6
p25123
aV7
p25124
aV2
p25125
aV1 of ISO/IEC 9899:TC3 September 2007 draft
p25126
as(dp25127
g7
V505088
p25128
stp25129
a((dp25130
g2
(lp25131
VI presume you are actually looking for the last used row
p25132
aVIn that case you need to write it like this:
p25133
as(dp25134
g7
V505088
p25135
stp25136
a((dp25137
g2
(lp25138
VThis is quite simple
p25139
aVThe  directory is not subject to file redirection
p25140
aVYou probably would be best using the  and  CSIDL values but you'll have to work out for yourself whether you need the x64 or x86 folders
p25141
as(dp25142
g7
V505088
p25143
stp25144
a((dp25145
g2
(lp25146
VYou didn't write to the copy of  in
p25147
aVAll you did was allocate the memory, store it to a local variable in  and then forget about it when  returned
p25148
aVYou need  to receive a
p25149
aVOnly if you do it this way can  return the newly allocated memory to the caller
p25150
aVOf course, since this is C++ I wonder why you don't use references and , but perhaps this is illustrative code
p25151
as(dp25152
g7
V505088
p25153
stp25154
a((dp25155
g2
(lp25156
VThis is so that when  returns , you can distinguish  from a real, valid
p25157
as(dp25158
g7
V505088
p25159
stp25160
a((dp25161
g2
(lp25162
VIf you were to use  you need to remember to make room for the null-terminator
p25163
aVSo use  before calling
p25164
aVBut in this case you should just use  which does the allocation and copying in one go:
p25165
aVThe memory returned by  has been allocated with  and hence must be disposed of with a call to
p25166
as(dp25167
g7
V505088
p25168
stp25169
a((dp25170
g2
(lp25171
VSplit the project into two, one of which contains  and the other containing
p25172
aVThen if you need to link to both  files you have to link to two  files
p25173
aVBut if you want to link to just one, then you can do so
p25174
as(dp25175
g7
V505088
p25176
stp25177
a((dp25178
g2
(lp25179
VI don't believe that there is any such limit in Delphi or COM+
p25180
aVI'm not sure what caused your error but I think you'd need to describe what you did in more detail
p25181
aVNo matter what, it is not sensible to have methods with that many parameters
p25182
aVMore than about 4 or 5 is already stretching it
p25183
aVTake this incident as a gentle hint to rethink your design in a more manageable manner
p25184
as(dp25185
g7
V505088
p25186
stp25187
a((dp25188
g2
(lp25189
VUsing  this way is incorrect since  may be smaller than the pointer size of your system and will thus lead to truncation
p25190
aVI'd use  to keep track of your current buffer size and there's no need for any pointer arithmetic
p25191
aVThe reallocation is also completely broken
p25192
aVWhy are you calling  and then ignoring the return value
p25193
aVThat's like a leaking version of
p25194
aVYou could write it something like this:
p25195
as(dp25196
g7
V505088
p25197
stp25198
a((dp25199
g2
(lp25200
VIt's part of the Microsoft DirectX SDK
p25201
aVThis Code Project tutorial goes over getting yourself up-and-running in Visual Studio
p25202
as(dp25203
g7
V505088
p25204
stp25205
a((dp25206
g2
(lp25207
VSince a service is machine-wide rather than per-user, store the configuration file under
p25208
aVCall  passing  to find out where that folder is
p25209
aVThe command line arguments  come from the command line specified when the service was registered
p25210
aVThis is what you can see from the service control manager
p25211
aVI've not addressed the second set of questions
p25212
aVYou should really only ask one question at a time
p25213
aVI do know a bit about installing services though
p25214
aVYou certainly don't need any
p25215
aVnet
p25216
aVPrecisely how you should do it probably depends on which install tool you are using
p25217
as(dp25218
g7
V505088
p25219
stp25220
a((dp25221
g2
(lp25222
VWith session 0 isolation introduced in Vista, services cannot show UI since they run in a separate, non-interactive session
p25223
aVYou need to run a standard app on the interactive desktop and use an IPC mechanism to communicate with the service in order to show UI on behalf of the service
p25224
as(dp25225
g7
V505088
p25226
stp25227
a((dp25228
g2
(lp25229
VThese assignments are all perfectly valid as I and others have explained in your recent run of near identical questions
p25230
aVA  is a pointer to memory that cannot be modified using that pointer
p25231
aVNothing here can circumvent that
p25232
aVThe compiler would object if you assigned  since then that would circumvent the const
p25233
as(dp25234
g7
V505088
p25235
stp25236
a((dp25237
g2
(lp25238
VYour question is rather unclear but it appears that you are asking how to show a form as an MDI child
p25239
aVI assume that you have already set  to  for your main form
p25240
aVIn order to show an MDI child you need to set the  property for the child form
p25241
aVLike this:
p25242
as(dp25243
g7
V505088
p25244
stp25245
a((dp25246
g2
(lp25247
VYou didn't register the class
p25248
aVYou need to call
p25249
aVHow can I register class if I have only the name in string
p25250
aVTypically you would place a call to  in the initialization section unit that declares the class
p25251
aVWhen you come to call  you will discover that the class needs to derived from :
p25252
as(dp25253
g7
V505088
p25254
stp25255
a((dp25256
g2
(lp25257
VA Windows bitmap file is indeed stored as little endian
p25258
aVThus you will need to reverse the endianness of each 2 or 4 byte int value after loading, assuming that your system is big-endian
p25259
aVThis IBM article describes various ways to do that
p25260
as(dp25261
g7
V505088
p25262
stp25263
a((dp25264
g2
(lp25265
VYou need to make sure that the Python installation directory is in your  environment variable
p25266
aVI thought that the ActiveState installer did that for you, but in any case, that seems to be the problem here
p25267
aVYou can set the  enviroment variable in:
p25268
aVJust add python folder at the end of the list (separated with semicolon)
p25269
as(dp25270
g7
V505088
p25271
stp25272
a((dp25273
g2
(lp25274
VYou need more that just the manifest if I recall correctly
p25275
aVYou also need Mike Lischke's theme manager component
p25276
aVThis code eventually found its way into Delphi 7
p25277
as(dp25278
g7
V505088
p25279
stp25280
a((dp25281
g2
(lp25282
VYou can use the standard edit control and call
p25283
aVLike this:
p25284
aVThe system will do the rest for you
p25285
as(dp25286
g7
V505088
p25287
stp25288
a((dp25289
g2
(lp25290
VMy guess is that this is a graphics device driver bug
p25291
aVTry updating your drivers or perhaps sticking in a different card if you have one spare
p25292
as(dp25293
g7
V505088
p25294
stp25295
a((dp25296
g2
(lp25297
VWhen does an Action get garbage collected
p25298
aVWhen the garbage collector feels like it
p25299
aVThe  class is descibed thus:
p25300
aVRepresents a weak reference, which references an object while still allowing that object to be reclaimed by garbage collection
p25301
aVIn other words you explicitly said that you don't mind if the object gets collected
p25302
aVYou can't have your cake and eat it
p25303
aVEither take a strong reference or be prepared to recreate the object in case it has been collected
p25304
as(dp25305
g7
V505088
p25306
stp25307
a((dp25308
g2
(lp25309
VYou need to P/invoke  on Vista and up, or  on XP
p25310
as(dp25311
g7
V505088
p25312
stp25313
a((dp25314
g2
(lp25315
VNow I know that VB
p25316
aVNET and C# are quite different, but I suppose I always assumed that strings were strings
p25317
aVStrings are immutable in
p25318
aVnet
p25319
aVAsk yourself why it is that  passing of an immutable data type can result in the value changing
p25320
aVThat doesn't happen for normal functions, just for
p25321
aVI'd guess it all has to do with maintaining some backwards compatibility with  statements from classic VB6 which were done this way
p25322
aVTo my mind the black sheep here is the VB
p25323
aVnet code rather than the C# code
p25324
as(dp25325
g7
V505088
p25326
stp25327
a((dp25328
g2
(lp25329
VIt's called a fluent interface
p25330
aVThe code does not call methods during the call to the constructor
p25331
aVIt calls methods on the object returned by the constructor, after the constructor has completed
p25332
aVEach of those method calls finish with  and that is the key
p25333
aVThat's what allows the calls to be chained together
p25334
as(dp25335
g7
V505088
p25336
stp25337
a((dp25338
g2
(lp25339
VCall  to find out where the cursor is
p25340
aVCall  to find the window under the cursor
p25341
aVSend an  message to replace the selection in that window
p25342
aVIf nothing is selected then the text will be inserted at the caret
p25343
aVNote: Be prepared for this to fail more commonly than it succeeds
p25344
aVMany applications don't used windowed edit controls
p25345
aVFor a more robust solution you should look into UI Automation
p25346
aVYou asked for some code
p25347
aVHere's what it would look like:
p25348
aVIf the window underneath the cursor is not an edit window, this will, probably, be benign
p25349
as(dp25350
g7
V505088
p25351
stp25352
a((dp25353
g2
(lp25354
VYou didn't initialize the local variable  before you used it
p25355
aVIt's Undefined Behaviour
p25356
aVAnything goes
p25357
as(dp25358
g7
V505088
p25359
stp25360
a((dp25361
g2
(lp25362
VThe very simplest way to achieve this is to show your form modally
p25363
aVCall ShowModal to show the form and the main form will not be disabled and unable to receive any input
p25364
as(dp25365
g7
V505088
p25366
stp25367
a((dp25368
g2
(lp25369
VThat's a rather tortuous approach
p25370
aVYou are supposed to do as little as possible in the DllMain function
p25371
aVThe canonical solution is to create a dedicated function to perform initialization
p25372
aVArrange for the host app to call the initialization function before calling anything else
p25373
aVThe most likely reason your version fails is that there are a lot of windows with that class name
p25374
aVEvery window created by AllocHwnd has that class name
p25375
aVFindWindow probably just finds the wrong one
p25376
aVOn the other hand, you mention in passing in a comment that this DLL is injected
p25377
aVIn that case you can make your method work by using a unique class name or giving the window a unique title so that you can find it
p25378
aVFinally the call to ProcessMessages looks to be gratuitous
p25379
as(dp25380
g7
V505088
p25381
stp25382
a((dp25383
g2
(lp25384
VIt's up to the compiler how to implement it and typically it's done with the same mechanism as other virtual methods
p25385
aVIn other words there's nothing special about destructors that requires a virtual method dispatch mechanism that is distinct from that used by normal methods
p25386
as(dp25387
g7
V505088
p25388
stp25389
a((dp25390
g2
(lp25391
VDoes a union always have default value of zero
p25392
aVThe language standard says this:
p25393
aVIf an object that has static or thread storage duration is not initialized
p25394
aVexplicitly, then:
p25395
aVif it has pointer type, it is initialized to a null pointer;
p25396
aVif it has arithmetic type, it is initialized to (positive or unsigned) zero;
p25397
aVif it is an aggregate, every member is initialized (recursively) according to these rules,
p25398
aVand any padding is initialized to zero bits;
p25399
aVif it is a union, the first named member is initialized (recursively) according to these
p25400
aVrules, and any padding is initialized to zero bits;
p25401
aVSo, in your first code sample,  will be initialised to zero
p25402
aVI'm not sure about the second code sample at all
p25403
aVI cannot see the point of the  there
p25404
aVI rather suspect that you meant to use a  rather than a
p25405
aVBut note that the two code examples are very different because the  in this first has static storage duration and in the second the  has automatic storage duration
p25406
aVThis results in completely different semantics for uninitialized variables
p25407
as(dp25408
g7
V505088
p25409
stp25410
a((dp25411
g2
(lp25412
VYou are not allocating enough memory
p25413
aVYou need to leave room for the zero-terminator
p25414
aVYou also must copy the contents of the string, not assign the pointer to the string
p25415
aVBoth of these errors will lead to heap corruption and would explain your error
p25416
aVThe code should be like this:
p25417
aVYou could of course use  if your system has it available, but note that it is not part of standard C
p25418
as(dp25419
g7
V505088
p25420
stp25421
a((dp25422
g2
(lp25423
VSomething else is the explanation to your problem because  does indeed acquire a lock on the mutex object
p25424
aVThe implementation of  looks like this:
p25425
aVAnd  calls  passing the mutex handle
p25426
aVMost likely is that you actually have more than one mutex somehow but I can't tell for sure since I can't see all of your code
p25427
aVFinally, for within process synchronisation you should prefer the Windows critical section which performs better than the Windows mutex object
p25428
aVThat is  in the RTL
p25429
aVFollowing your update it is easy to see what is happening
p25430
aVAll use of the lock happens in the main thread
p25431
aVYou call  which results in the method executing on the main thread
p25432
aVIf you call  directly from your  method then you will deadlock as intended
p25433
aVYou need to use  for all GUI calls
p25434
aVIt works, broadly, by signaling the main thread that there is something in the synchronize queue and then waiting until the main thread has completed the work
p25435
aVIt is an asynchronous method
p25436
as(dp25437
g7
V505088
p25438
stp25439
a((dp25440
g2
(lp25441
VThere's nothing built in to Delphi to do that form of day
p25442
aVYou will have to do it yourself
p25443
aVLike this:
p25444
as(dp25445
g7
V505088
p25446
stp25447
a((dp25448
g2
(lp25449
VThe dialog will use the contents of  as the caption
p25450
aVSo you could set this before calling
p25451
aVHowever, if you want to show multiple dialogs with different captions, it would be more convenient to call the Windows  function
p25452
aVCertainly if you have an older version of Delphi this will result in a more native feel to your dialog
p25453
aVIf you wish to control color and size then the most obvious option is to create your own dialog as a  descendent
p25454
as(dp25455
g7
V505088
p25456
stp25457
a((dp25458
g2
(lp25459
VI know of no way to do this
p25460
aVThe only thing I could imagine that would work would be  but that needs to be inside a function
p25461
as(dp25462
g7
V505088
p25463
stp25464
a((dp25465
g2
(lp25466
VYou are probably forgetting to create the string list properly with code like this:
p25467
aVor
p25468
aVBut without seeing your code all we can do is guess as to what your problem is
p25469
aVThat said, the first sample of code above is correct
p25470
as(dp25471
g7
V505088
p25472
stp25473
a((dp25474
g2
(lp25475
VI would consider the use of the  method to be an improvement on the  version
p25476
as(dp25477
g7
V505088
p25478
stp25479
a((dp25480
g2
(lp25481
VCode to do this looks like the following:
p25482
as(dp25483
g7
V505088
p25484
stp25485
a((dp25486
g2
(lp25487
VI think you've already answered most of the question
p25488
aVYou know that you want to use a log scale
p25489
aVSo you would have the tick marks, equally spaced, 0
p25490
aV01, 0
p25491
aV1, 1
p25492
aV0, 10
p25493
aV0, 100
p25494
aV0, say
p25495
aVRather than a scroll bar you should use a track bar
p25496
aVThe values on the track bar are in log scale
p25497
aVSo you want something like 0 to correspond to 0
p25498
aV01, 100 to correspond to 0
p25499
aV1, 200 to correspond to 1
p25500
aV0 and so on
p25501
aVThis gives you a track bar with minimum of 0, maximum of 400 and an initial position of 200, i
p25502
ag192
ag5537
ag9193
aVNow it remains to map from track bar position to scale
p25503
aVYou need  to equal 0
p25504
aV01,  to equal 0
p25505
aV1 and so on
p25506
aVYou do this using exponentiation to the power 10
p25507
aVGoing the other way involves taking logarithms and rearranging
p25508
aVNaturally if the figures and min/max values I have selected don't suit you can easily enough rejig so that they do
p25509
as(dp25510
g7
V505088
p25511
stp25512
a((dp25513
g2
(lp25514
VCode::Blocks + mingw
p25515
as(dp25516
g7
V505088
p25517
stp25518
a((dp25519
g2
(lp25520
VIf you are running on Windows the third option (the one missing from your list) is best
p25521
aVLeave the code in C++ and compile it with C++/CLI
p25522
aVThen your C# code can consume it directly without need for P/invoke or translation
p25523
as(dp25524
g7
V505088
p25525
stp25526
a((dp25527
g2
(lp25528
VI debugged this with Notepad++
p25529
aVI copied the correct strings into Notepad++
p25530
aVI used Encoding | Convert to UTF-8
p25531
aVThen I selected Encoding | Encode as ANSI
p25532
aVThis has the effect of interpreting the UTF-8 bytes as if they were ANSI
p25533
aVAnd when I did this I end up with the same erroneous values as you
p25534
aVSo clearly when you read the file you are interpreting is as ANSI rather than UTF-8
p25535
aVThe solution then is that your file has been encoded as UTF-8
p25536
aVMake sure that the file is interpreted as UTF-8 when you read it
p25537
aVI can't tell you exactly how to do that since you didn't show how you were reading the file in the first place
p25538
aVIt's possible that your file does not contain a byte-order-mark (BOM)
p25539
aVIf so then specify the encoding when you read the file by passing
p25540
as(dp25541
g7
V505088
p25542
stp25543
a((dp25544
g2
(lp25545
VThe call to  is incorrect
p25546
aVAlthough the documentation explicitly states that the parameter is the length in bytes, that is not the case
p25547
aVYou should use  instead because the function actually expects units of  rather than units of
p25548
as(dp25549
g7
V505088
p25550
stp25551
a((dp25552
g2
(lp25553
VA null terminated string is never , it always points to valid memory with a null terminator
p25554
aVThe empty string is just a single
p25555
aVSince  is contracted to return a null terminated string it can never return
p25556
aVThe correct way to test for an empty string is indeed
p25557
as(dp25558
g7
V505088
p25559
stp25560
a((dp25561
g2
(lp25562
VI agree with eran's point that you should just wait directly on the process handle
p25563
aVAs to why your code does not enter the  loop when you think it should that is easy enough to work out
p25564
aVThe  loop terminates when  returns 0
p25565
aVThat is when it returns , or in other words when it has acquired ownership of the mutex
p25566
aVThat happens when the previous owner releases it
p25567
as(dp25568
g7
V505088
p25569
stp25570
a((dp25571
g2
(lp25572
VAs you have discovered,  will do the job but it is a little tricky to call
p25573
aVThe documentation states:
p25574
aVThe EnumDisplayMonitors function enumerates display monitors (including invisible pseudo-monitors associated with the mirroring drivers) that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a device context
p25575
aVEnumDisplayMonitors calls an application-defined MonitorEnumProc callback function once for each monitor that is enumerated
p25576
aVNote that GetSystemMetrics (SM_CMONITORS) counts only the display monitors
p25577
aVThis leads us to an easier solution:
p25578
aVIndeed this may be even better than  if you have psuedo-monitors
p25579
aVAs illustration of calling  try this:
p25580
as(dp25581
g7
V505088
p25582
stp25583
a((dp25584
g2
(lp25585
VBecause structs are value types and classes are reference types
p25586
aVSo structs fall into the same category as int, double etc
p25587
as(dp25588
g7
V505088
p25589
stp25590
a((dp25591
g2
(lp25592
VI strongly suspect that the problem lies in some P/invoke code of yours, or perhaps a direct  bind in your DLL
p25593
aVThe thing is,  is not part of
p25594
aVIt is exported by
p25595
aVI can't believe that you have a
p25596
aVlib file that is tries to import it from  so I think you should look for a P/invoke or a  in your code or perhaps third party code that you are including
p25597
as(dp25598
g7
V505088
p25599
stp25600
a((dp25601
g2
(lp25602
VFollowing on from my comment, here is how I think this could be implemented:
p25603
as(dp25604
g7
V505088
p25605
stp25606
a((dp25607
g2
(lp25608
VSince we don't know what your program is doing we have to guess a little
p25609
aVSo long as there is no I/O I'd expect  to consume 0% CPU
p25610
aVSo I hypothesise that you are printing a lot of text to the console
p25611
aVFor example, the following program has the same symptoms as you report:
p25612
as(dp25613
g7
V505088
p25614
stp25615
a((dp25616
g2
(lp25617
VYou are passing the node pointer  by value when you call
p25618
aVYou need to pass a pointer to the node pointer
p25619
aVSo you need to pass  rather than  in order for the modifications to be made to the global
p25620
aVMake these changes:
p25621
aVWhenever you refer to  in  you need  rather than
p25622
aVCall  like this:
p25623
as(dp25624
g7
V505088
p25625
stp25626
a((dp25627
g2
(lp25628
VIf  really does equal  then your code will indeed allocate  bytes and then read the entire contents of the file
p25629
aVIf you believe that only 4 bytes are being read it is probably because the 5th byte is a zero
p25630
aVThus when buffer is interpreted as a zero terminated string, it terminates at that point
p25631
aVYou can inspect the rest of your buffer by looking at , , etc
p25632
aVAs an aside, you don't need to cast the return from , and  by definition
p25633
aVBest practice is to write the  like this:
p25634
aVBut that will not change your results
p25635
as(dp25636
g7
V505088
p25637
stp25638
a((dp25639
g2
(lp25640
VHere's an old school way of doing it and getting your separators included in the file:
p25641
as(dp25642
g7
V505088
p25643
stp25644
a((dp25645
g2
(lp25646
V is almost never the correct solution to a problem
p25647
aVInvariable you want to be declaring things in header files and then defining them in just a single source file
p25648
aVfile1
p25649
ag10393
aVfile1
p25650
aVc
p25651
aVfile2
p25652
ag25651
aVHaving said all of this, I would strongly council you to pass values as parameters rather than use global state
p25653
aVGlobal state is evil
p25654
aVAvoid it like the plague
p25655
as(dp25656
g7
V505088
p25657
stp25658
a((dp25659
g2
(lp25660
VYou can call  instead
p25661
aVHowever, be prepared for the results to be less than impressive
p25662
aVTrying to scale a raster image in this way will lead to very blocky results
p25663
aVVector images are what you need in order to be able to scale to printer resolutions
p25664
aVThe scaling I chose here will preserve the aspect ratio and make the image as large as possible when printed
p25665
as(dp25666
g7
V505088
p25667
stp25668
a((dp25669
g2
(lp25670
VLogical expressions in C evaluate to false if they are 0, otherwise they evaluate to true
p25671
aVThus your loop will terminate when  is equal to 0
p25672
aVIn the context of a  that is when the null-terminating character is encountered
p25673
aVNote that  has a higher precedence than pointer dereferencing  and so the  is bound to the pointer rather than the  to which it points
p25674
aVThus the body of your loop will call  for the character that  points to, and then increment the pointer
p25675
as(dp25676
g7
V505088
p25677
stp25678
a((dp25679
g2
(lp25680
VThis is homework and as such I won't give you a full solution
p25681
aVI will attempt to guide you towards finding a solution yourself
p25682
aVThe problem is that you have only followed part of your teacher's advice
p25683
aVOur teacher said we have to use the Top and left properties to limit the image
p25684
aVYou have only followed half of the advice presented here
p25685
aVFollow it all and you will solve your problem
p25686
as(dp25687
g7
V505088
p25688
stp25689
a((dp25690
g2
(lp25691
VC++11 does not add support for
p25692
aVThe decision makers (especially Stroustrup) have for many many years expressed a preference for other idioms, i
p25693
ag192
aVRAII
p25694
aVI think it is exceptionally unlikely that C++ will ever include
p25695
as(dp25696
g7
V505088
p25697
stp25698
a((dp25699
g2
(lp25700
VTo run an application every 15 minutes use a scheduled task
p25701
aVThe very simple way to avoid any window being shown is to make this a normal GUI app rather than a console app, but arrange that you do not show any windows in your GUI app
p25702
as(dp25703
g7
V505088
p25704
stp25705
a((dp25706
g2
(lp25707
VI believe you are looking for
p25708
aVUse it like this:
p25709
aVNote 1: I'm assuming that you mean  rather than
p25710
aVNote 2: I've only compiled this in my head; I hope it works on a real compiler
p25711
as(dp25712
g7
V505088
p25713
stp25714
a((dp25715
g2
(lp25716
VYou are performing division on two integer operands and in Python 2
p25717
aVx this means integer division
p25718
aVThat is, the result is an integer
p25719
aVYou need what is known as floating point division
p25720
aVTo force this you just need at least one of the operands to the division to be a float
p25721
aVFor example:
p25722
aVor
p25723
as(dp25724
g7
V505088
p25725
stp25726
a((dp25727
g2
(lp25728
VSo far as I can tell, your solution is good and will be hard to improve upon
p25729
aVThe only suggestion I would make would be to use hashing for the dictionary rather than a sorted list of keys and binary search
p25730
aVYou could use Delphi's  assuming its performance was reasonable
p25731
aVFor  you would use a custom record implementing your map (position and length)
p25732
aVSimilarly for
p25733
aVYou would have to implement your own comparer which could be done easily enough without incurring heap allocations
p25734
aVHaving said all of this, are you 100% sure that heap allocations are as evil as you think they are for this application
p25735
aVYou should try a naive implementation using  and profile the app to prove that it is spending significant time in the dictionary code
p25736
aVAnother benefit of such an approach would be that, if indeed heap allocation was a problem, you could use the  based version as a reference implementation for testing purposes
p25737
aVYour pointer offset+length based version is sure to be a bug factory
p25738
as(dp25739
g7
V505088
p25740
stp25741
a((dp25742
g2
(lp25743
VSince in your setting you desire a console in both modes the simplest solution is to call  all the time
p25744
aVA process can be associated with only one console, so the AllocConsole function fails if the calling process already has a console
p25745
aVA process can use the FreeConsole function to detach itself from its current console, then it can call AllocConsole to create a new console or AttachConsole to attach to another console
p25746
as(dp25747
g7
V505088
p25748
stp25749
a((dp25750
g2
(lp25751
VWhat you describe, faking input, is implemented by the SendInput function
p25752
aVInput goes to the thread which has input focus
p25753
as(dp25754
g7
V505088
p25755
stp25756
a((dp25757
g2
(lp25758
VAssuming your code to import the module into  works then the final step is simply:
p25759
as(dp25760
g7
V505088
p25761
stp25762
a((dp25763
g2
(lp25764
VThe compiler passes through the file from top to bottom
p25765
aVAt the point where it needs to deal with the call to , you have not yet declared
p25766
aVSince you have a circular reference ( calls  and vice versa) you need to break that with what is known as a forward reference
p25767
aVAdd this line before
p25768
aVSo the organisation of the code should look like this:
p25769
aVIf you did not have a circular reference then you could simply reorder the procedures so that the  was declared before
p25770
as(dp25771
g7
V505088
p25772
stp25773
a((dp25774
g2
(lp25775
VSomething in your real code is adding extra null characters to the end of the string
p25776
aVYour bug lies in that code
p25777
aVString concatenation works perfectly well
p25778
aVis not null terminated and so concatenation just adds on to the end of the buffer
p25779
aVThis makes  somewhat different from a C string because it can hold null characters
p25780
aVI suspect this nuance is the source of all the confusion
p25781
as(dp25782
g7
V505088
p25783
stp25784
a((dp25785
g2
(lp25786
VI think here you mean to increment  by  elements
p25787
aVThat is achieved with
p25788
aVThere are no methods available on a
p25789
aVCannot call  here
p25790
aVYou only call  on something made with
p25791
aVWhat's more you cannot delete characters from the middle of a  C string
p25792
aVNot really sure what you are trying to do here
p25793
aVThere is no
p25794
aVI think we need to know more about
p25795
aVAt the moment we don't even know what type it is
p25796
aVYou did not allocate  with  so you cannot and should not call  on it
p25797
aVNo need to do this, a void function will do this when it reaches the end
p25798
aVMore generally I think you need to go back to your textbook and brush up on the basics
p25799
aVSince you are using C++ you can make use of higher level constructs like  and
p25800
aVOnce you start using C++ you should really be avoiding  work altogether
p25801
aVIt's messy and hard to get right
p25802
aVThe native C++ constructs are much simpler
p25803
aVI'd strongly recommend you simply throw all this code away and try to come up with a  based version
p25804
as(dp25805
g7
V505088
p25806
stp25807
a((dp25808
g2
(lp25809
VThe function you are calling expects a pointer to a modifiable buffer,
p25810
aVYou are passing a pointer to a non-modifiable buffer,
p25811
aVSince your  function does not modify its input you should change its declaration to receive
p25812
as(dp25813
g7
V505088
p25814
stp25815
a((dp25816
g2
(lp25817
VMost likely you are using the Unicode version of the structure and thus are passing wide characters to
p25818
aVSince you use a format string that implies  data there is a mis-match
p25819
aVThe UTF-16 encoding results in every other byte being 0 for characters in the ASCII range and so  thinks that the second byte of the first two byte character is actually a null-terminator
p25820
aVThis is the sort of problem that you get with  which of course has no type-safety
p25821
aVSince you are using C++ it's probably worth switching to  based I/O
p25822
aVHowever, if you want to use ANSI text, as you indicate in a comment, then the simplest solution is to use the ANSI  version of the struct and the corresponding  versions of the API functions, e
p25823
ag217
ag7012
as(dp25824
g7
V505088
p25825
stp25826
a((dp25827
g2
(lp25828
VThe description field that is displayed by the task manager is read from the version resource of the executable file
p25829
aVSo you can't change it (tag it) when you start the process
p25830
aVIf you want to influence what appears there then you need to modify the executable which I don't believe is what you are looking to do
p25831
as(dp25832
g7
V505088
p25833
stp25834
a((dp25835
g2
(lp25836
VYou can use  and pass zero as the second parameter
p25837
aVSo far as I can tell this does not have a requirement of Vista, presumably as it is implemented with compiler intrinsics
p25838
as(dp25839
g7
V505088
p25840
stp25841
a((dp25842
g2
(lp25843
VMost likely you have calling convention mismatch
p25844
aVChange the  in the Delphi to  to match your C++/CLI code
p25845
aVAs an aside, you will need to be careful with the lifetime of your strings if ever you attempt to return a value from the DLL that is not a literal stored in read-only memory in the data segment
p25846
aVBut that's not the problem here because  has the same lifetime as the DLL
p25847
as(dp25848
g7
V505088
p25849
stp25850
a((dp25851
g2
(lp25852
VBasically, if you want to install to Program Files then you will need to show the UAC prompts
p25853
aVOf course, you could modify the access control settings (i
p25854
ag192
aVwhat you set in the security page of Explorer properties dialog) for your install folder to make it writeable
p25855
aVBut that would be against all known best practice
p25856
aVI would not advocate it
p25857
aVOne alternative is to do what Chrome does and install under the user profile
p25858
aVThere are downsides to this approach
p25859
aVDoing it this way requires every user on the machine to install the software, and then each user would need to update individually
p25860
aVYou also lose some of the protection that UAC affords
p25861
as(dp25862
g7
V505088
p25863
stp25864
a((dp25865
g2
(lp25866
VThis code leaks brushes
p25867
aVIf you really wish to create new brushes each time round the loop then you have to get the previous value (returned by ) and dispose of it
p25868
aVA much better approach would be to create two brushes that have the same lifetime as the application
p25869
aVIt's wasteful to be creating new brushes so frequently
p25870
aVWith this approach you would dispose of the brushes at shutdown
p25871
aVAs to the actual implementation of animation, your code is, as you admit, rather poor
p25872
aVis very seldom the solution to any problem and it certainly isn't here
p25873
aVYou would be better off with a timer
p25874
aVAnd as Hans correctly points out, you should handle  to set the background brush
p25875
aVOnce you switch to a timer then you don't need to call UpdateWindow
p25876
as(dp25877
g7
V505088
p25878
stp25879
a((dp25880
g2
(lp25881
VAnonymous methods are not implemented in FreePascal
p25882
aVThe list of such features is here
p25883
as(dp25884
g7
V505088
p25885
stp25886
a((dp25887
g2
(lp25888
V and  are two 32 bit values that are combined to form a single 64 bit value
p25889
aVThis function was implemented this way because it pre-dates widespread compiler support for 64 bit values
p25890
aVI think your misunderstanding is in believing that the high and low mean upper and lower limits
p25891
aVIn your case your value (assuming  is around 1KB) is nowhere near requiring 64 bits so you should pass  for  and  for
p25892
aVHowever, if you are attempting to map the entire file you can simply pass  for both parameters
p25893
aVFrom the documentation:
p25894
aVdwMaximumSizeHigh [in]
p25895
aVThe high-order DWORD of the maximum size of the
p25896
aVfile mapping object
p25897
aVdwMaximumSizeLow [in]
p25898
aVThe low-order DWORD of the maximum size of the
p25899
aVfile mapping object
p25900
aVIf this parameter and dwMaximumSizeHigh are 0 (zero), the maximum size
p25901
aVof the file mapping object is equal to the current size of the file
p25902
aVthat hFile identifies
p25903
aVAn attempt to map a file with a length of 0 (zero) fails with an error
p25904
aVcode of ERROR_FILE_INVALID
p25905
aVApplications should test for files with a
p25906
aVlength of 0 (zero) and reject those files
p25907
as(dp25908
g7
V505088
p25909
stp25910
a((dp25911
g2
(lp25912
VI'd write it like this:
p25913
aVFirst of all cast  to be of type
p25914
aVThen dereference the pointer
p25915
aVThen double it
p25916
aVThe problem with your code is that you are assigning the pointer rather than the pointee
p25917
as(dp25918
g7
V505088
p25919
stp25920
a((dp25921
g2
(lp25922
VYou need to get the 64 bit ActiveX DLLs to go with your 64 bit runtime
p25923
aVDesigntime Delphi is still always 32 bit
p25924
aVIf ChartFX doesn't supply 64 bit version you are stuck
p25925
aVHaving looked on the website it seems that the vendor does not yet supply a 64 bit ChartFX ActiveX and is soliciting feedback as to how much demand there is for it
p25926
aVI would recommend transitioning to TeeChart which is native Delphi code and has a very strong tradition on Delphi
p25927
aVYou can be confident of future support for other platforms as and when they become available
p25928
as(dp25929
g7
V505088
p25930
stp25931
a((dp25932
g2
(lp25933
VThat other window is another a top-level window in the same process that implements one of the visible windows in the app
p25934
aVThis is an old Delphi 7 app which implements a hidden top-level window that is outside the visible window hierarchy
p25935
aVThat hidden window is the one you have found, highlighted in black, with class name TApplication
p25936
aVIf I were you I would p/invoke a call to EnumWindows to get all the top level windows which will include the visible main windows for that app
p25937
aVThis would be implemented in a very similar way to your GetChildWindows method
p25938
as(dp25939
g7
V505088
p25940
stp25941
a((dp25942
g2
(lp25943
VYou need to work harder to read and write the  memory since you are working with a control owned by another process
p25944
aVYou therefore need to read and write memory in that process
p25945
aVYou can't do that without calling ,  etc
p25946
aVThe most commonly cited example of the techniques involved is this Code Project article: Stealing Program's Memory
p25947
aVWatch out for 32/64 bit gotchas
p25948
as(dp25949
g7
V505088
p25950
stp25951
a((dp25952
g2
(lp25953
VIt is two ternary operators
p25954
aVRead it from left to right
p25955
aVIt is equivalent to
p25956
as(dp25957
g7
V505088
p25958
stp25959
a((dp25960
g2
(lp25961
V has static storage
p25962
aVIt will be initialized when the program starts
p25963
aValso has static storage because you said so
p25964
aVIt will be initialized when  executes the first time
p25965
as(dp25966
g7
V505088
p25967
stp25968
a((dp25969
g2
(lp25970
VThe NSIS documentation lists the various possibilities
p25971
aVYou simply need to pick the one most suitable to your needs
p25972
aVIt's much easier to get NSIS to do this than to script it yourself by calling the service control manager API
p25973
as(dp25974
g7
V505088
p25975
stp25976
a((dp25977
g2
(lp25978
VYou need this syntax:
p25979
as(dp25980
g7
V505088
p25981
stp25982
a((dp25983
g2
(lp25984
VLike this:
p25985
as(dp25986
g7
V505088
p25987
stp25988
a((dp25989
g2
(lp25990
VC++ references cannot be null
p25991
aVThe bug is dereferencing a null pointer
p25992
aVThat's undefined behaviour
p25993
as(dp25994
g7
V505088
p25995
stp25996
a((dp25997
g2
(lp25998
VA dictionary is also known as an associative array, or a map
p25999
aVIt is a generic container just like  and it contains items of type
p26000
aVYou can thus use the generic type  to determine the type of each element
p26001
aVThe key is what you use to index each item
p26002
aVThe difference between a dictionary and a list or array is that the index for a dictionary is not restricted to being an integer
p26003
aVIt also does not need to be contiguous
p26004
aVThus the type you specify for  does not need to be an integer
p26005
aVVery often  is used
p26006
aVThis allows you to write something like:
p26007
aVIf you then need to retrieve this value you can write:
p26008
aVIf someone upvotes then you can write:
p26009
aVand so on
p26010
as(dp26011
g7
V505088
p26012
stp26013
a((dp26014
g2
(lp26015
VThe main complicating factor here is multiple monitors
p26016
aVWith multiple monitors there may be no point on the desktop which is both top and right
p26017
aVWhat I would assume you might mean in that case would be the top of the right-most monitor
p26018
aVDo it like this:
p26019
as(dp26020
g7
V505088
p26021
stp26022
a((dp26023
g2
(lp26024
VYou simply need to add an extra layer of indirection
p26025
aVYou have to override  with a C# method that in turn calls the external method
p26026
as(dp26027
g7
V505088
p26028
stp26029
a((dp26030
g2
(lp26031
VThis is indeed a very common solution to the problem
p26032
aVIt is generally much easier to do it this way than using P/invoke
p26033
aVBoth approaches require you to wrap the static library
p26034
aVSo you are almost certainly better off using C++/CLI for that wrapper since that is much easier to connect to your C# code than P/invoke
p26035
as(dp26036
g7
V505088
p26037
stp26038
a((dp26039
g2
(lp26040
VI expect that your OK button has  set to
p26041
aVIf you want to add error checking to the OK button then change that to
p26042
aVAdd an  handler to the button which does whatever checking or processing you need
p26043
aVIf it determines that the form can close, set  in the  handler
p26044
as(dp26045
g7
V505088
p26046
stp26047
a((dp26048
g2
(lp26049
VDouble precision arithmetic gives you precision of 15-16 decimal significant figures
p26050
aVThese two values agree to that precision
p26051
aVNothing worry about here
p26052
aVNote that I say decimal to contrast with the 53 binary bits used for the significand in the binary representation of a double precision value
p26053
as(dp26054
g7
V505088
p26055
stp26056
a((dp26057
g2
(lp26058
VThese two versions are equivalent
p26059
aVThe  operator short-circuits, but  does not
p26060
aVSince you evaluate  and  before testing , that comes to the same as
p26061
aVNow, if you had compared
p26062
aVwith
p26063
aVthen they would be different
p26064
aVHowever, your prior evaluation into  and  was sufficient to render the two tests equivalent
p26065
as(dp26066
g7
V505088
p26067
stp26068
a((dp26069
g2
(lp26070
VCan't say for sure, but one obvious possibility is that you are on a 64 bit machine and  is the wrong type for
p26071
aVIt needs to be a 64 bit value in a 64 bit process
p26072
aVWe also have no idea how you have declared
p26073
aVYou are meant to pass a pointer to a  struct
p26074
aVIt doesn't look as though you have done that
p26075
aVThe correct signature is:
p26076
aVYour edit clarifies that  is a struct
p26077
aVThis then is clearly wrong
p26078
aVYou could simply pass the  as an  parameter
p26079
aVThat would be the simplest solution
p26080
aVIf you wanted a more general  signature then you should use  as I stated above and use
p26081
as(dp26082
g7
V505088
p26083
stp26084
a((dp26085
g2
(lp26086
VThe  is a cast
p26087
aVIt says to treat the return value of  as a pointer to
p26088
aVHowever, this is not necessary since , the return type of  is assignment compatible with all pointer variables in C
p26089
aVWhat's more the  is spurious since  by definition
p26090
aVFinally this allocation almost certainly allocates one element too few
p26091
aVThere needs to be space for the zero terminator
p26092
aVSo, it should probably be written:
p26093
aVAs for , this is a  literal
p26094
aVIt has type
p26095
aVThis is not too be confused with  which is a string literal, of type , a pointer to a block of memory containing two chars,  followed by
p26096
aVAs for question 3, it's not clear to me what you mean and in any case I will invoke the one question at a time rule to justify not addressing it
p26097
aVOthers have answered that for you
p26098
as(dp26099
g7
V505088
p26100
stp26101
a((dp26102
g2
(lp26103
VThe plain Python stuff is exceptionally unlikely to lead to seg fault
p26104
aVWhat sticks out here is
p26105
aVNo idea what that is or where it comes from, but I bet it's the culprit
p26106
as(dp26107
g7
V505088
p26108
stp26109
a((dp26110
g2
(lp26111
VProcess Explorer is just reporting the AnyCPU DLLs as 32 bit
p26112
aVThere slot in the PE header that contains this information doesn't have a setting for AnyCPU so the compiler marks them as 32 bit
p26113
aVBut rest assured that a 64 bit process will only load 64 bit DLLs, or AnyCPU DLLs which it forces into 64 bit mode
p26114
aVThe native DLLs, comctl32, gdi32 are marked as 64 bit and that's proof that your process and all the code within is running as 64 bit
p26115
aVIt's just the AnyCPU DLLs that are misleading
p26116
as(dp26117
g7
V505088
p26118
stp26119
a((dp26120
g2
(lp26121
VThat's undefined behaviour
p26122
aVAnything can happen
p26123
aVYou were lucky this time
p26124
aVOr perhaps unlucky since it would be preferable to get a runtime error
p26125
aVNext time round maybe you'll get a runtime error
p26126
aVIt's not really very useful to reason about why you see a particular manifestation of undefined behaviour
p26127
aVIt's best to stick to the well-defined behaviour about which you can reason
p26128
as(dp26129
g7
V505088
p26130
stp26131
a((dp26132
g2
(lp26133
VThe VCL  mechanism relies on the other forms in the application all running with the  same version of the VCL
p26134
aVThis is clearly not the case here and you will have to position the form manually
p26135
aVFind out the position of the main form by calling  passing the main form handle
p26136
aVThen you need to work out where your form needs to go to be in the center of that form
p26137
aVBy the way, the handle you are passing is an  rather than a
p26138
aVYou should change you code accordingly
p26139
aVIt won't change behaviour, but it is logically correct to do so
p26140
as(dp26141
g7
V505088
p26142
stp26143
a((dp26144
g2
(lp26145
VIn general, no
p26146
aVFor a start, you don't know the calling convention so you have no idea how the parameters were passed and who is supposed to clean them up
p26147
aVEven if you do know the calling convention I don't believe there is a fool proof way to determine what you ask for
p26148
as(dp26149
g7
V505088
p26150
stp26151
a((dp26152
g2
(lp26153
VThere are a few problems here
p26154
aVYou cannot nest functions inside other functions like you can in languages like Java, C#, Python
p26155
aVYou are passing the struct array incorrectly
p26156
aVYour main declaration is incorrect
p26157
aVYou want code something like this:
p26158
aVNote that you are missing initialization of
p26159
aVWhat's more you really ought to pass the length of the array as a parameter to
p26160
aVThat will then allow you more flexibility to use arrays of any length
p26161
as(dp26162
g7
V505088
p26163
stp26164
a((dp26165
g2
(lp26166
VC does not have pass by reference as such so this method of passing a pointer to a variable is the only way to achieve the same semantics
p26167
aVMany other languages allow you to pass by reference directly
p26168
aVFor example in C++ you could do it like this:
p26169
aVThen when you call the function you do it like so:
p26170
aVBut without this sort of help from the language your only option is pointers
p26171
as(dp26172
g7
V505088
p26173
stp26174
a((dp26175
g2
(lp26176
VYou can't do this with an instance function because the C code will not have an instance available or even the knowledge of what to do with one
p26177
aVYou need to use a static function instead
p26178
as(dp26179
g7
V505088
p26180
stp26181
a((dp26182
g2
(lp26183
VSomething of a sledgehammer to crack a nut, but here's a solution based on a recursive approach:
p26184
aVYou can get the same output as you had before by simply moving the  one line up
p26185
as(dp26186
g7
V505088
p26187
stp26188
a((dp26189
g2
(lp26190
VYour current solution is the cleanest solution
p26191
aVThe only alternative is to work out where the variable is stored in the DLL and modify it directly
p26192
aVBut that's a gross hack that is incredibly brittle
p26193
aVFor example, if the 3rd party DLL changes then your hack may stop working with unpredictable effects
p26194
as(dp26195
g7
V505088
p26196
stp26197
a((dp26198
g2
(lp26199
VThe C++ language designers have a strong presumption against adding new keywords since introducing a new keyword breaks existing code
p26200
aVHence the sometimes strange overloading of certain keywords
p26201
aVThat's why static is the way it is
p26202
aVAs to your two examples
p26203
aVThe first one really contrasts with automatic storage rather than dynamic storage
p26204
aVAnd the second one is less about static vs dynamic dispatch and more about the availability or otherwise of an instance variable
p26205
as(dp26206
g7
V505088
p26207
stp26208
a((dp26209
g2
(lp26210
V is a macro (all upper case is convention for macro) that typically resolves to something like  when you are building the DLL and resolves to  when you are using the DLL
p26211
aVYou can find out exactly what it is by reading your include files
p26212
as(dp26213
g7
V505088
p26214
stp26215
a((dp26216
g2
(lp26217
VYou have to read and write the shared variable inside the lock
p26218
aVYou are reading it outside of the lock and thus rendering the lock irrelevant
p26219
aVBut even that's not enough since your shared variable is a loop variable that you are writing to without protection of the lock
p26220
aVA much better example would run like this:
p26221
aVIf you can, use a critical section rather than a mutex because they are simpler to use and more efficient
p26222
aVBut they have the same semantics in that they only protect code inside the locking block
p26223
aVNote: Jerry has pointer out some other problems, but I've concentrated on the high level trheading and serialization concerns
p26224
as(dp26225
g7
V505088
p26226
stp26227
a((dp26228
g2
(lp26229
VThat's not possible at the pre-processor stage because what you want depends on values that are only known later, at runtime
p26230
aVWhat you need is an array and the index operator,
p26231
as(dp26232
g7
V505088
p26233
stp26234
a((dp26235
g2
(lp26236
VGuard blocks are used to prevent a header file being included multiple times in a single translation unit
p26237
aVThis is often a problem when you include a number of header files that in turn include common standard header files
p26238
aVThe problem with multiple inclusions of the same file is that it results in the same symbol being defined multiple times
p26239
aVGuard clauses can be handled with  and  statements but are much simpler with the non-standard, but universal,
p26240
as(dp26241
g7
V505088
p26242
stp26243
a((dp26244
g2
(lp26245
VNot all programs need to call
p26246
aVAnd those that do need dynamic memory allocation may prefer to do it a different way
p26247
aVC does not try to force a single way of working on programmers
p26248
as(dp26249
g7
V505088
p26250
stp26251
a((dp26252
g2
(lp26253
VYou can't have C++ without support for exceptions which is part of the standard
p26254
aVWhether or not it has much impact on you executable I cannot say
p26255
aVI'd get a more modern C compiler if I were you
p26256
aVOn Windows you should try mingw
p26257
aVWith C99 you can declare variables wherever you like
p26258
aVThat Borland compiler is ancient
p26259
as(dp26260
g7
V505088
p26261
stp26262
a((dp26263
g2
(lp26264
VYou are wanting to change the parameter list of a virtual method in a derived class
p26265
aVThis cannot be done
p26266
aVUsually when you find yourself wanting to do this it indicates that your class hierarchy design is incorrect
p26267
aVThe naive attempts to tackle this usually involve adding something to the base class which is only meaningful for certain derived classes
p26268
aVThis violates the principles of good design
p26269
aVThere are many different ways to tackle the issue more properly, but it's hard to advise on the basis of this artificially constructed example
p26270
as(dp26271
g7
V505088
p26272
stp26273
a((dp26274
g2
(lp26275
VQuoting Mark Russinovich's Inside Windows 2000 (what is now called Windows Internals),
p26276
aVThe section object, which the Win32 subsystem calls a file mapping object, represents a block of memory that two or more processes can share
p26277
aVSo, it's a memory mapped file
p26278
aVThey'd leak if you created a memory mapped file and failed to close it
p26279
aVPretty hard to be much more specific
p26280
as(dp26281
g7
V505088
p26282
stp26283
a((dp26284
g2
(lp26285
VThe task dialog functionality introduced in Vista does exactly what you want and follows the prevailing system theme
p26286
aVHowever, if you have to support XP, then this will be of little comfort to you
p26287
as(dp26288
g7
V505088
p26289
stp26290
a((dp26291
g2
(lp26292
VYou are using the post-increment operator
p26293
aVThis evalutates to the original value, and then increments
p26294
aVTo do what you want in a one-liner you can use the pre-increment operator instead
p26295
aVBut even better would be to avoid all such pitfalls and do it like this:
p26296
aVWith the first version you have to think about the order in which things happen
p26297
aVIn the second version no thought is required
p26298
aVAlways value code clarity more highly than conciseness
p26299
aVIt's easy to believe that the one-line version is somehow faster, but that's not true
p26300
aVIt might have been true back in the day in 1970s C systems, but even then that I doubt
p26301
as(dp26302
g7
V505088
p26303
stp26304
a((dp26305
g2
(lp26306
VRVA is the address relative to the image base address, after having been loaded into memory
p26307
aVThe MS PE/COFF specification says:
p26308
aVRelative virtual address
p26309
aVIn an image file, the address of an item after it is loaded into memory, with the base address of the image file subtracted from it
p26310
aVThe RVA of an item almost always differs from its position within the file on disk (file pointer)
p26311
as(dp26312
g7
V505088
p26313
stp26314
a((dp26315
g2
(lp26316
VI'm assuming that you wish for the  function to return , for the benefit of clients of this interface
p26317
aVHowever, the implementation code sometime has a valid reason to access the implementing object
p26318
aVOf course doing so does create a coupling that may be undesirable
p26319
aVAs of Delphi 2010 you are able to use the  operator to gain access to the implementing object
p26320
aVBeware that you are now subverting the lifetime management of the object
p26321
aVIf you access  after the interface reference has gone to zero, then you are in trouble
p26322
aVFinally, I would comment that using such an approach has the whiff of bad design
p26323
aVIt is usually better to find an approach that does not us  in this way
p26324
as(dp26325
g7
V505088
p26326
stp26327
a((dp26328
g2
(lp26329
VYes that is correct
p26330
aVThat is true for all declarations within a particular scope
p26331
aVThey are only available within the defining scope
p26332
aVOf course, you can declare the same function in another scope, but I don't think that's what you meant
p26333
as(dp26334
g7
V505088
p26335
stp26336
a((dp26337
g2
(lp26338
VThat's just how the standard library of your compiler treats those special values
p26339
aVIf you want different treatment you need to write your own print function that detects the special values and prints the text that you desire
p26340
as(dp26341
g7
V505088
p26342
stp26343
a((dp26344
g2
(lp26345
VIt was that way because it had always been done that way, it made writing compilers a little easier, and nobody had really thought of doing it any other way
p26346
aVIn time people realised that it was more important to favour making life easier for language users rather than compiler writers
p26347
aVI assume the language designers wouldn't have added such a limitation if it had absolutely no purpose at all
p26348
aVDon't assume that the language designers set out to restrict the  language
p26349
aVOften restrictions like this arise by chance and circumstance
p26350
as(dp26351
g7
V505088
p26352
stp26353
a((dp26354
g2
(lp26355
VYou are misusing
p26356
aVThe documentation for the constructor states:
p26357
aVInitializes a new instance of the WindowInteropHelper class for a specified Windows Presentation Foundation (WPF) window
p26358
aVThe notepad window is not a WPF window which is why  returns
p26359
aVIn fact, I don't believe it could ever work for a window in a separate process, even if the other window was a WPF window
p26360
as(dp26361
g7
V505088
p26362
stp26363
a((dp26364
g2
(lp26365
VThe fundamental problem is that you are mixing decimal and double in this line:
p26366
aVis decimal and 4
p26367
aV2 is a double literal
p26368
aVTo write a decimal literal use the  suffix
p26369
as(dp26370
g7
V505088
p26371
stp26372
a((dp26373
g2
(lp26374
VThe alignment correction is wrong
p26375
aVYou need to add  to correct the alignment
p26376
aVSo the code should read:
p26377
aVHowever, I would recommend that you test the function in a native setting first
p26378
aVOnce you know it works there you can move to the managed setting and know that any problems are due to the managed code
p26379
as(dp26380
g7
V505088
p26381
stp26382
a((dp26383
g2
(lp26384
VIs there a way to avoid linking zlib obj files into the binary
p26385
aVmore than once
p26386
aVNo there is not
p26387
aVThe linking
p26388
aVobj files is private to each unit
p26389
aVThere is no way for you to detect from one unit that some other unit has linked a
p26390
aVobj file
p26391
as(dp26392
g7
V505088
p26393
stp26394
a((dp26395
g2
(lp26396
VWhen the shell is asked to perform a verb on a file, the shell does not use the contents of the file to determine which app to pass it to
p26397
aVThe file extension is what determines how the file will be treated
p26398
aVYou wish to use the contents of the file to influence which app processes a shell verb
p26399
aVIn order to do so you would need to create a launcher app that reads the file header and then decides which app to pass the file on to
p26400
aVYou would assign your launcher app as the handler app for all file extensions that you were interested in
p26401
aVAlthough you could do this, it would be much easier just to set the file extension appropriately
p26402
as(dp26403
g7
V505088
p26404
stp26405
a((dp26406
g2
(lp26407
VThe buffer used by the standard libraries input routines is private to the implementation of the standard library
p26408
aVYou cannot access it other than through the published interface to the standard library
p26409
as(dp26410
g7
V505088
p26411
stp26412
a((dp26413
g2
(lp26414
VThat mixer control looks more like a hyperlink control than a button
p26415
aVI'd go for the  control if that's what you need
p26416
as(dp26417
g7
V505088
p26418
stp26419
a((dp26420
g2
(lp26421
VThe two versions are identical in terms of the code that the compiler generates
p26422
aVThis is because an instance reference is implemented as a pointer
p26423
aVThe difference is that for the version based on pointers, the compiler does not know that the array contents are instance references
p26424
aVThat's why you have to cast to  in order to be able to invoke a method, and why the debugger insight is only able to show you an address
p26425
as(dp26426
g7
V505088
p26427
stp26428
a((dp26429
g2
(lp26430
VThere is nothing wrong with your current approach
p26431
aVis written to once only and then all future accesses are reads
p26432
aVIt effect it is a module wide constant
p26433
aVYou run into problems with shared global state when you have multiple threads accessing an object and at least one of the threads is writing
p26434
aVThat's not happening here and you have nothing to be concerned about
p26435
as(dp26436
g7
V505088
p26437
stp26438
a((dp26439
g2
(lp26440
VPeganza Pascal Analyzer offers both call tree and reverse call tree reports
p26441
aVThere are a number of other static code analyzers available, but this is the one I am familiar with
p26442
aVSo far as I know, there is nothing of this nature built in to Delphi
p26443
as(dp26444
g7
V505088
p26445
stp26446
a((dp26447
g2
(lp26448
VYou want to use  here
p26449
aVTo convert to degrees multiply by
p26450
aVThis will give you a result in the range -180 to 180
p26451
aVIf you want it in the range 0 to 360 then you will have to shift any negative angles by 360
p26452
aVI also strongly recommend that you do not return your polar coordinates in the same parameters that you used to pass in cartesian coordinates
p26453
aVMake your function like this:
p26454
aVYour  method also uses  parameters incorrectly
p26455
aVOnly use  parameters for values that are passed into a method, modified, and then need to be passed back to the caller
p26456
as(dp26457
g7
V505088
p26458
stp26459
a((dp26460
g2
(lp26461
VYou've got three problems that I can see
p26462
aVThe calling conventions don't match
p26463
aVYour C++ code is  and your C# code is
p26464
aVThe C++ code uses wide strings, but the C# code marshals ANSI strings
p26465
aVThe second parameter doesn't match
p26466
aVYour C# code assumes that the C++ code returns a new pointer to a C string which the C# code then deallocates with the COM allocator
p26467
aVYour C++ code doesn't do this
p26468
aVNow, dealing with these in more detail
p26469
aVCalling conventions
p26470
aVThis is pretty easy to fix
p26471
aVSimple change the C++ code to , or the C# code to
p26472
aVBut don't do both
p26473
aVI'd change the C# code:
p26474
aVUnicode/ANSI strings
p26475
aVI presume you are wanting to use Unicode strings since you have explicitly selected them in the C++ code
p26476
aVBut P/invoke defaults to marshalling ANSI strings
p26477
aVYou can change this again in the  like so:
p26478
aVReturning a string from C++ to C#
p26479
aVYour current C++ function declaration is so:
p26480
aVThe  decorator has no real effect, other than documenting that you want to modify the buffer pointed to by  and have those modifications returned to the caller
p26481
aVYour C# declaration is:
p26482
aVNow,  simply does not match
p26483
aVA  string parameter matches this in C++:
p26484
aVIn other words the C# code is expecting you to return a new pointer
p26485
aVIn fact it will then proceed to deallocate the buffer you returned in  by calling
p26486
aVI'm confident that's not what you want
p26487
aVYour original C++ code can only return a string to the C# code by modifying the buffer that was passed to it
p26488
aVThat code would look like this:
p26489
aVIf this is what you want then you should allocate a sufficient buffer in C# in a  object
p26490
aVIf you simply cannot decide in the C# code how big a buffer you need then your best bet is to use a  to marshal strOut
p26491
aVSee this answer for details
p26492
as(dp26493
g7
V505088
p26494
stp26495
a((dp26496
g2
(lp26497
VIn the call to  at the end of  you refer to a variable named  that has not been defined in
p26498
aVHence the error
p26499
aVPerhaps you meant to retain the value returned from  the call to :
p26500
aVI must admit to finding your code a little difficult to follow, not least because the error message you posted does not quite match the code you posted
p26501
aVI think your basic misunderstanding concerns how functions return values
p26502
aVWhen you call a function that returns a value, you must assign that value to something in the calling scope's namespace
p26503
aVSo when you wrote
p26504
aVa value was returned but because you did not assign it to anything, that value was forgotten
p26505
aVInstead you have to assign it to something in order to use it
p26506
as(dp26507
g7
V505088
p26508
stp26509
a((dp26510
g2
(lp26511
VMicrosoft has explicitly taken the stance that this is a decision for the user and not one that can be made programmatically
p26512
aVYes there are various utilities around that hack at the internals to achieve this, but there is no supported way to achieve what you desire
p26513
as(dp26514
g7
V505088
p26515
stp26516
a((dp26517
g2
(lp26518
VLike this:
p26519
aVSee this MSDN article for details of the references you need to add and the  statements
p26520
aVOnce you get past the boiler-plate, the C# code will be pretty much identical to what you are used to with VBA
p26521
as(dp26522
g7
V505088
p26523
stp26524
a((dp26525
g2
(lp26526
VThis feature, Enumerated Types with Explicitly Assigned Ordinality, was added in Delphi 6 which is why the code will not compile in Delphi 5
p26527
aVIn your example the code is equivalent to
p26528
aVand you can use that safely
p26529
aVI don't quite understand why the author of the code explicitly assigned 0 to the first ordinal since it has no effect on the meaning of the type
p26530
aVIf you encounter code that explicitly sets ordinals whose lowest value is not 0, or has non-contiguous ordinality, then it is more complex to workaround
p26531
aVNote that you typically only need to explicitly set ordinality when you are interoperating with something external, e
p26532
ag217
aVfile formats, calls to or from other libraries
p26533
aVIf the variables of an enumerated type only ever exist in memory, and in your code, then you most likely don't care what ordinality they have
p26534
aVI'm not 100% sure why this feature was added but I seem to recall that it was needed to support the Kylix product
p26535
as(dp26536
g7
V505088
p26537
stp26538
a((dp26539
g2
(lp26540
VOverloading is based on the parameter types rather than the parameter names
p26541
aVYou cannot have overloaded functions which have parameter lists with identical types
p26542
as(dp26543
g7
V505088
p26544
stp26545
a((dp26546
g2
(lp26547
VYou can't create a Delphi  from
p26548
aVnet
p26549
aVYou can't create a Delphi  from
p26550
aVnet
p26551
aVThis DLL appears to be inaccessible from anything other than Delphi or C++ Builder
p26552
aVThe only way you could hope for it to work from
p26553
aVnet would be if the DLL also exported functions that created instances of  or , which you could then pass on to the function in your question
p26554
aVThe  class is a VCL class representing the application
p26555
aVIt is the equivalent of the WinForms  class
p26556
aVLikewise  is a VCL class wrapping file I/O in a stream-like interface
p26557
aVThe
p26558
aVnet  class is similar
p26559
aVBut you simply cannot synthesise working instances of Delphi/VCL classes from
p26560
aVnet
p26561
as(dp26562
g7
V505088
p26563
stp26564
a((dp26565
g2
(lp26566
V is from CLX, the Qt based cross-platform library that was introduced with Delphi 6/Kylix
p26567
aVSo far as I know, CLX is no longer shipped with Delphi
p26568
aVYou need to do one of the following:
p26569
aVStick with Delphi 7
p26570
aVPort the code to VCL
p26571
aVThis will tie you to the Windows platform
p26572
aVGet Delphi XE2 and use FireMonkey since clearly at some point in time this code was intended to be cross-platform
p26573
as(dp26574
g7
V505088
p26575
stp26576
a((dp26577
g2
(lp26578
VIt's pretty hard to avoid using the new  which is what  is now aliased to
p26579
aVYou can write all your code with  if you wish, but why bother
p26580
aVAs soon as you use any non-trivial library (e
p26581
ag217
aVRTL, VCL, third-party) you are swimming against the tide
p26582
aVIf you do attempt to continue with  you'll actually make life more difficult for yourself in my view
p26583
aVIf you give it a go you should find that it's not that big a job to move to the new Unicode string type
p26584
aVThe vast majority of existing code will work unchanged
p26585
as(dp26586
g7
V505088
p26587
stp26588
a((dp26589
g2
(lp26590
VYou call  on an uninitialized buffer
p26591
aVThis is undefined behaviour
p26592
aVYou need to zero-terminate the initial contents of
p26593
aVIt looks like you get away with that error, but then immediately commit another one
p26594
aVYour  makes space for  but you have forgotten to allocate room for the zero terminator
p26595
aVPresumably that's what causes  to bomb
p26596
aVFix that problem by adding one to the size parameter to
p26597
aVAs @Lou points out the performance of your realloc strategy may be poor
p26598
aVYou may be better to allocate the buffer once at the beginning of the function since presumably you can put a relatively tight upper bound on its size
p26599
aVAnd you also should not ever write  since you won't be able to recover from a failure of  and will always leak
p26600
aVBut that's really a nuance in comparison to the other faults
p26601
as(dp26602
g7
V505088
p26603
stp26604
a((dp26605
g2
(lp26606
VYour callback function appears to be a C function with prototype:
p26607
aVYou don't need to do anything special to be able to access
p26608
aVThe  magic arranges that for you
p26609
aVThe code you need is something like this:
p26610
as(dp26611
g7
V505088
p26612
stp26613
a((dp26614
g2
(lp26615
VI can't see how it could be possible to do this with generics
p26616
aVThe compiler needs to know that an instance of type  can be assigned to a  for any possible
p26617
aVThere's no way for you to tell that compiler that is possible
p26618
aVIf this were templates as in C++ then it would be trivial
p26619
as(dp26620
g7
V505088
p26621
stp26622
a((dp26623
g2
(lp26624
VIt's quite complex
p26625
aVThe documentation says the following:
p26626
aVThe server-based Timer is designed for use with worker threads in a multithreaded environment
p26627
aVServer timers can move among threads to handle the raised Elapsed event, resulting in more accuracy than Windows timers in raising the event on time
p26628
aVand then this:
p26629
aVIf the SynchronizingObject property is null, the Elapsed event is raised on a ThreadPool thread
p26630
aVIf processing of the Elapsed event lasts longer than Interval, the event might be raised again on another ThreadPool thread
p26631
aVIn this situation, the event handler should be reentrant
p26632
aVand then this:
p26633
aVIf you use the Timer with a user interface element, such as a form or control, without placing the timer on that user interface element, assign the form or control that contains the Timer to the SynchronizingObject property, so that the event is marshaled to the user interface thread
p26634
aVSo, there's no simple answer to your question "is it raised in an independent thread
p26635
aVIt depends on many things
p26636
as(dp26637
g7
V505088
p26638
stp26639
a((dp26640
g2
(lp26641
VNo you need to do them all
p26642
aVThose that don't get specified are given a default value,  for a float
p26643
aVYou may find that a simple  loop will result in the most maintainable code
p26644
aVI certainly would not encourage the use of  here
p26645
as(dp26646
g7
V505088
p26647
stp26648
a((dp26649
g2
(lp26650
VThere is no xor pen mode in
p26651
aVnet graphics
p26652
as(dp26653
g7
V505088
p26654
stp26655
a((dp26656
g2
(lp26657
VWell, you could use  to compare
p26658
aVobj files but I think you'd be foolish to go down this route
p26659
aVAll it would take is one small change of the source code to render your optimised build process invalid
p26660
aVI would not contemplate doing something like this
p26661
as(dp26662
g7
V505088
p26663
stp26664
a((dp26665
g2
(lp26666
VYou are putting the same object in the list  five times
p26667
aVSo each of the 5 items of  are in fact bound to the same object
p26668
aVBecause  is a mutable type, you are able to modify it and every other reference to that same object appear to be modified also
p26669
aVOf course it's only one object being modified, it just looks to you as though each item in  has been modified
p26670
aVThat's not the case, the same object appears there five times
p26671
aVIn order to fix this you need to create a new list object each time you append to
p26672
aVThere are lots of ways to do this, for example you could do it like this:
p26673
aVThe most simple example I can think of that illustrates the behaviour of mutable objects is this:
p26674
as(dp26675
g7
V505088
p26676
stp26677
a((dp26678
g2
(lp26679
VUse
p26680
aVThe documentation for  is as follows:
p26681
aVReturn a copy of the string with leading and trailing characters removed
p26682
aVIf chars is omitted or None, whitespace characters are removed
p26683
aVIf given and not None, chars must be a string; the characters in the string will be stripped from the both ends of the string this method is called on
p26684
as(dp26685
g7
V505088
p26686
stp26687
a((dp26688
g2
(lp26689
VIf you want to point to the same string your code is fine, assuming pointers are always 4 bytes wide
p26690
aVIf you want to copy the contents of the string use malloc and strcpy to create a new string
p26691
as(dp26692
g7
V505088
p26693
stp26694
a((dp26695
g2
(lp26696
VThe default ctypes result type is a 32 bit integer but a file handle is pointer width, i
p26697
ag192
aV64 bits
p26698
aVYou are therefore losing half of the information in the file pointer
p26699
aVBefore you call fopen you must state that the result type is a pointer:
p26700
as(dp26701
g7
V505088
p26702
stp26703
a((dp26704
g2
(lp26705
VYour string buffer is read only memory
p26706
aVString literals cannot be modified
p26707
aVUse strcpy or strdup to make a buffer of writeable memory
p26708
aVRemember to free the string when you are done with it
p26709
as(dp26710
g7
V505088
p26711
stp26712
a((dp26713
g2
(lp26714
VIt's a consequence of the generics implementation in Delphi
p26715
aVWhen you instantiate a class by supplying a concrete T in another unit, code for the concrete class is written into that other unit
p26716
aVBut that other unit can no longer see your private string constant
p26717
aVIt's rather frustrating
p26718
aVMy understanding of the generics implementation suggests that Mikael's workaround will solve the problem because the class const will be visible when you instantiate your concrete type in another unit
p26719
as(dp26720
g7
V505088
p26721
stp26722
a((dp26723
g2
(lp26724
VIf the DLL is in the same directory as the executable it will be found
p26725
aVThe name exported by the Delphi DLL is HW rather than _HW
p26726
aVThe calling conventions likely do not match
p26727
aVIt's register in Delphi and cdecl in C++ I suspect
p26728
aVNote that I'm not 100% sure C++ Builder defaults to cdecl here, you can check
p26729
aVThe more serious problem is that you simply cannot pass a TForm across a DLL boundary like this
p26730
aVWhen you call a method on the object in your DLL you are calling code in the DLL rather than code in the host exe
p26731
aVBut it's the code in the exe that you need to be called since that's the code that belongs with the object
p26732
aVYou need to switch to runtime packages or interfaces
p26733
as(dp26734
g7
V505088
p26735
stp26736
a((dp26737
g2
(lp26738
VAll variant fields in a variant record are accessible at all times, irrespective of the value of the tag
p26739
aVIn order to achieve the accessibility control you are looking for you would need to use properties and have runtime checks to control accessibility
p26740
as(dp26741
g7
V505088
p26742
stp26743
a((dp26744
g2
(lp26745
VThere can be no least efficient algorithm for anything
p26746
aVThis can easily be proved by contradiction so long as you accept that, starting from any algorithm, another equivalent but less efficient algorithm can be constructed
p26747
as(dp26748
g7
V505088
p26749
stp26750
a((dp26751
g2
(lp26752
VCoTaskMemAlloc is part of the COM memory allocator
p26753
aVIt is used with CoTaskMemRealloc and CoTaskMemFree
p26754
aVThe COM memory allocator is designed to allow a COM client to allocate memory that is later freed by the COM server or vice versa
p26755
aVYou only need to use it when ownership of the memory is transferred across the COM client/server boundary
p26756
aVThis solves a very common interop problem
p26757
aVDifferent programming systems have different implementations for heaps
p26758
aVConsequently memory allocated on one heap can only be deallocated on the same heap
p26759
aVIf you have a COM method that returns a string, say, you have a problem
p26760
aVIf the server and client use different heaps you now need to ask the server to deallocate the string when you are done with it
p26761
aVThe COM allocator solves this by virtue of being a single, shared heap that all participants can use
p26762
aVHaving said this it should come as no surprise to learn that a BSTR, i
p26763
ag192
aVwhat is called WideString in Delphi, is allocated with the COM allocator
p26764
aVI'm not familiar with the DirectShow interfaces but the principles of COM are universal
p26765
aVWhen you implement GetMediaType in your server you must allocate the struct that is returned
p26766
aVSince the client has to free that struct, as specified in the documentation, clearly you must use the COM allocator since that is what your clients will use
p26767
aVYou also mentioned ReadFile
p26768
aVNo point at all using COM allocator here since the caller is responsible for both allocating and freeing the buffer
p26769
aVThe bottom line is that COM is an interface contract
p26770
aVIf a pointer crosses the interface boundary and has ownership transferred from client to server, or vice versa, then the COM allocator must be used
p26771
as(dp26772
g7
V505088
p26773
stp26774
a((dp26775
g2
(lp26776
VMost likely this is a 32/64 bit issue
p26777
aVIs the Mac version the only 64 bit process that you've tested
p26778
aVOr perhaps you got lucky in the Windows and Linux versions in that they happen to return pointers of the form 0x00000000xxxxxxxx
p26779
aVNewMagickWand returns a pointer but you have not told ctypes to expect a pointer
p26780
aVAs it stands ctypes defaults to a 32 bit integer for the return value
p26781
aVAdd this line before you call NewMagickWand
p26782
aVThis tells ctypes that NewMagickWand returns a pointer
p26783
as(dp26784
g7
V505088
p26785
stp26786
a((dp26787
g2
(lp26788
Vis an associative array, or map
p26789
aVIt is a container that can be indexed by values of any type
p26790
aVis an integer indexed array
p26791
aVIt is a container that is indexed by contiguous integers
p26792
aVThe essential difference therefore is in how the containers are indexed
p26793
aVDon't fall into the trap of believing that  is semantically equivalent to
p26794
aVThe difference is that the indexing of  is contiguous whereas there can be gaps in the indexing for
p26795
as(dp26796
g7
V505088
p26797
stp26798
a((dp26799
g2
(lp26800
VTo detect a managed debugger you can call
p26801
aVIf you want to detect native debuggers the function you need is called
p26802
aVP/invoke it like this:
p26803
aVAs @tenfour says, neither of these approaches is particularly effective against a resolute attacker \u2013 but then nothing is
p26804
as(dp26805
g7
V505088
p26806
stp26807
a((dp26808
g2
(lp26809
VYou are asking for your array of objects to be automatically created for you
p26810
aVThis is not how the language works
p26811
aVYou need to construct each object individually, or in a loop
p26812
aVIf you do not initialize an array when you declare it, the members are initialized to the default initial value for the array type
p26813
aVFor a reference type this is
p26814
as(dp26815
g7
V505088
p26816
stp26817
a((dp26818
g2
(lp26819
VSo far as I know, you cannot exert any control over the class name of your user control
p26820
as(dp26821
g7
V505088
p26822
stp26823
a((dp26824
g2
(lp26825
VCall Process
p26826
aVStart() passing just the document file name
p26827
aVBy default this uses the UseShellExecute option which means that the shell is asked to perform the open verb on the document
p26828
aVThat's the same as double clicking the document from the shell UI
p26829
as(dp26830
g7
V505088
p26831
stp26832
a((dp26833
g2
(lp26834
VYou need to use a different  for each icon
p26835
aVThe documentation says:
p26836
aVThe application-defined identifier of the taskbar icon
p26837
aVThe Shell uses either (hWnd plus uID) or guidItem to identify which icon to operate on when Shell_NotifyIcon is invoked
p26838
aVYou can have multiple icons associated with a single hWnd by assigning each a different uID
p26839
aVIf guidItem is specified, uID is ignored
p26840
aVIn other words you need to pick a value for
p26841
aVThis is how the shell knows which icon you are referring to each time you call
p26842
aVClearly you must use a different value for each icon
p26843
aVSo, use  for icon ,  for icon  etc
p26844
as(dp26845
g7
V505088
p26846
stp26847
a((dp26848
g2
(lp26849
VCalling  at the end of the thread method is fine
p26850
aVIt is also optional
p26851
aVIf you just leave the thread method normally, then  is called for you
p26852
aVYou can call _endthread or _endthreadex explicitly to terminate a thread; however, _endthread or _endthreadex is called automatically when the thread returns from the routine passed as a parameter to _beginthread or _beginthreadex
p26853
aVref
p26854
aVSending a termination task is the correct way to get a blocked thread pool thread to unblock and quit
p26855
aVSo, to summarise:
p26856
aVYour strategy is good and the implementation of  is correct
p26857
aVYou can remove the harmless call to  at the end of
p26858
as(dp26859
g7
V505088
p26860
stp26861
a((dp26862
g2
(lp26863
VHere is a very inelegant old school approach to solving the problem
p26864
aVAlthough I'm sure some of the code could be more efficient, it avoids enumerating all permutations of the search set (as is done in the answer you accepted)
p26865
aVDoing that could get expensive
p26866
as(dp26867
g7
V505088
p26868
stp26869
a((dp26870
g2
(lp26871
VRemy's approach is good so long as the caller knows how big a buffer to allocate
p26872
aVAn alternative approach is to allocate memory in the DLL and have the caller free the memory
p26873
aVThis only works if both parties use the same allocator
p26874
aVAn example of a shared allocator is the COM allocator and COM  of course uses this
p26875
aVIn Delphi a  maps to WideString which gives us the following approach
p26876
aVDelphi
p26877
aVC++
p26878
aVObviously in this simple example, the required buffer size for the concatenated string is simple to calculate
p26879
aVBut if the actual function in the DLL was more complex then this approach would become more obviously advantageous
p26880
as(dp26881
g7
V505088
p26882
stp26883
a((dp26884
g2
(lp26885
VOne approach to solve your problem is to change your code so that you only ever refer to the object through an interface reference
p26886
aVIn other words instead of
p26887
aVyou write
p26888
aVThis can be inconvenient, so instead it can be more convenient to disable automatic lifetime management
p26889
aVYou need to do this for your implementing object:
p26890
aVYou can then derive your classes from this class
p26891
aVThere is one very major caveat with this approach
p26892
aVSuppose that you hold in variables (local, global, class member) any interfaces that are implemented by a class derived from
p26893
aVAll such interface variables must be finalised before you call  on the implementing object
p26894
aVIf you do not follow this rule you will find that when those interface variables go out of scope, the compiler still emits code to call  and it's an error to call a method on an object after it has been destroyed
p26895
aVThis is a particularly nasty type of error because it commonly will not manifest itself with a runtime failure until your code runs on your most important client's machine
p26896
aVIn other words such errors can be of intermittent nature
p26897
as(dp26898
g7
V505088
p26899
stp26900
a((dp26901
g2
(lp26902
VThe OpenCV library you refer to says this at the top of the header:
p26903
aVBorland Delphi 4,5,6,7 API for Intel Open Source Computer Vision Library
p26904
aVThis code presents a Delphi wrapper around the OpenCV DLLs
p26905
aVFor these older Delphi versions, ,  and  map to ,  and  respectively
p26906
aVThis matches the OpenCV DLLs which are pure ANSI
p26907
aVThere are no Unicode APIs in OpenCV (at least so far as I can discern)
p26908
aVIf you wish to use this unit from Delphi 2009 and up you need to recognise that in Delphi 2009, Unicode support was added
p26909
aVThis changed the mapping of ,  and  map to ,  and  respectively
p26910
aVThis is the cause of the incompatibility you have encountered because the DLL behind this unit is still processing single byte ANSI text
p26911
aVProbably the most sensible approach with this unit is to change it to use ,  and
p26912
aVYou can do this with a global search and replace in the unit
p26913
aVThis will make the OpenCV
p26914
aVpas unit match the DLLs again
p26915
aVYou now need to be careful how you interface with this OpenCV
p26916
aVpas unit
p26917
aVThe functions that receive  parameters need special treatment
p26918
aVFor example consider the following example:
p26919
aVThis is the original declaration
p26920
aVAfter your search and replace it will read like this:
p26921
aVWhen you come to call it you need to ensure you pass a proper
p26922
aVLike this:
p26923
aVYou must convert from  (which maps to ) to  and only then can you cast to
p26924
aVDo not write
p26925
aVThis will not convert the Unicode string to ANSI and will fail
p26926
aVFortunately for you the OpenCV library has a relatively small number of APIs that receive text
p26927
as(dp26928
g7
V505088
p26929
stp26930
a((dp26931
g2
(lp26932
VCall
p26933
aVIf you need to restore the cursor later, call
p26934
aVNote that the cursor visibility is reference counted so you need to match every call passing  to one passing
p26935
aVThis function sets an internal display counter that determines whether the cursor should be displayed
p26936
aVThe cursor is displayed only if the display count is greater than or equal to 0
p26937
aVIf a mouse is installed, the initial display count is 0
p26938
aVIf no mouse is installed, the display count is \u20131
p26939
as(dp26940
g7
V505088
p26941
stp26942
a((dp26943
g2
(lp26944
VThe  library doesn't offer anything of that nature so an  statement is just what you need
p26945
as(dp26946
g7
V505088
p26947
stp26948
a((dp26949
g2
(lp26950
VThere's no need to change anything at all
p26951
aVCarry on using  and  exactly as before
p26952
aVThese work in exactly the same way with the new wide  type
p26953
aVYour first block of code is still the idiomatic way to write this in Unicode Delphi
p26954
aVAlthough the documentation for  and  implies that these function use  as the integral type, don't believe the documentation
p26955
aVIt is wrong
p26956
as(dp26957
g7
V505088
p26958
stp26959
a((dp26960
g2
(lp26961
VThe regular expression you need to search for  or  is
p26962
aVThe  symbol means  in regex speak
p26963
aVSearching for a file containing both  and  is more difficult since the search is line-oriented
p26964
aVYou could search for  and  on the same line like this:
p26965
as(dp26966
g7
V505088
p26967
stp26968
a((dp26969
g2
(lp26970
VThose P/invoke declarations are correct for all versions of Windows
p26971
aVNo problems with XP/Vista/7 and no 32/64 bit issues
p26972
aVfloats between 32 and 64 bit depending on the bitness of the process
p26973
aVThat's exactly what you need to happen for an
p26974
as(dp26975
g7
V505088
p26976
stp26977
a((dp26978
g2
(lp26979
VLike this:
p26980
aVDon't forget to select a font for your console window that supports the characters you need
p26981
aVThis is a screen shot of my console window using the Consolas font
p26982
as(dp26983
g7
V505088
p26984
stp26985
a((dp26986
g2
(lp26987
VIt's a bug, as is shown by this minimal reproduction:
p26988
aVOutput:
p26989
aVNote that the same behaviour can be observed in Delphi 2010, the only other Delphi version i have to hand
p26990
aVTrace through under the debugger and you find yourself in  with the  parameter equal to  so clearly not enough memory is being allocated
p26991
aVAnd just in case there is any doubt, this version fails with an AV
p26992
aVI have submitted this to Quality Central, issue #100561
p26993
aVAs a workaround I suggest you use a dynamic array which you allocate using SetLength in the constructor
p26994
aVI rather imagine that it is the presence of a fixed sized generic array that is making the compiler misbehave
p26995
as(dp26996
g7
V505088
p26997
stp26998
a((dp26999
g2
(lp27000
VI'm suspicious of your declaration of the  parameter and your casts to  and
p27001
aVYou will get range errors if you pretend that the array passed in is a Delphi dynamic array when in fact it is not
p27002
aVDelphi dynamic arrays have a block of memory that precedes the first item of the array and identifies the reference count to the array, and it's length
p27003
aVSince this block is missing in your array, tricking the compiler into believing it is there will result in the error you see
p27004
aVI'd do it as shown below
p27005
aVThis matches the declarations used in MSDN
p27006
aVYou have to use a bit of pointer arithmetic but I believe it is easier to do this since your code now will be easy to relate to any C++ samples you can find online
p27007
as(dp27008
g7
V505088
p27009
stp27010
a((dp27011
g2
(lp27012
Vis an array of length 32, each element being a
p27013
aVI guess you meant to write
p27014
aVThis is an array of 32 char and you can then write:
p27015
aVMake sure, of course,  is not so big that it overflows your buffer
p27016
aVOf course, I'm not sure why you would need to use C strings in a C++ program
p27017
as(dp27018
g7
V505088
p27019
stp27020
a((dp27021
g2
(lp27022
VIf you want to elevate during installation then you can't use ClickOnce
p27023
aVThat's a design choice
p27024
aVYour options therefore are:
p27025
aVUse a standard install package which will allow you to show the UAC elevation dialog
p27026
aVModify the user's  environment rather than the system-wide variable
p27027
aVThis option is perfectly compatible with the per-user philosophy of ClickOnce
p27028
as(dp27029
g7
V505088
p27030
stp27031
a((dp27032
g2
(lp27033
VThere are standard ways of treating overdetermined systems
p27034
aVFor example Wikipedia says this:
p27035
aVA set of linear simultaneous equations can be written in matrix form as Ax = y
p27036
aVIf there are more equations than variables, the system is called overdetermined, and has (in general) no solutions
p27037
aVThe system can then be changed to (ATA)x = ATy
p27038
aVThe new system has as many equations as variables (the matrix ATA is a square matrix) and can be solved in the usual way
p27039
aVThe solution is a least-squares solution of the original, overdetermined system, minimizing the Euclidean norm ||Ax \u2212 y||, a measure of the discrepancy between the two sides in the original system
p27040
aVTherefore you can use any standard square matrix sparse solver
p27041
aVPersonally I use a direct solver from CSparse by Tim Davis
p27042
aVTim has written a number of excellent direct sparse solvers
p27043
aVIndeed, his UMFPACK is another excellent option and is used by MATLAB, for example
p27044
aVNote that both of these solvers offer C interfaces
p27045
aVIf you are looking for something with a native C++ interface then I have nothing to offer
p27046
aVI have had some experience with iterative solvers
p27047
aVHowever, I have found that for the problems I was looking at, the iterative methods became unstable for large matrices
p27048
aVI have had much more success with direct solvers
p27049
aVOf course, it's perfectly plausible that you could have the reverse experience depending on the type of matrix your problem throws up
p27050
as(dp27051
g7
V505088
p27052
stp27053
a((dp27054
g2
(lp27055
VThe STL containers are not thread safe
p27056
aVYou have to impose that yourself, should you so wish, with your own synchronisation
p27057
as(dp27058
g7
V505088
p27059
stp27060
a((dp27061
g2
(lp27062
VInstructions for Windows 7, similar methods work on prior versions too
p27063
aVOpen an explorer window
p27064
aVChoose the view settings you desire to apply to all windows
p27065
aVClick the Tools | Folder options menu item
p27066
aVSelect the View page
p27067
aVClick on Apply to folders
p27068
aVThis will apply the current window's settings to all other folders with the same type of content
p27069
as(dp27070
g7
V505088
p27071
stp27072
a((dp27073
g2
(lp27074
VAs other have said, the C++ language designers have chosen not to allow variable length arrays, VLAs, in spite of them being available in C99
p27075
aVHowever, if you are prepared to do a bit more work yourself, and you are simply desperate to allocate memory on the stack, you can use
p27076
aVThat said, I personally would use
p27077
aVIt is simpler, safer, more maintainable and likely fast enough
p27078
as(dp27079
g7
V505088
p27080
stp27081
a((dp27082
g2
(lp27083
VFind dialog
p27084
aVInclude  in  and the help button will appear
p27085
aVIt's very hard to understand why that would not be working for you
p27086
aVPrint dialog
p27087
aVInclude  in  and the help button will appear
p27088
aVFile dialogs
p27089
aVNow these did change when Vista was introduced
p27090
aVThe new dialogs do not have, built-in, the capability to show a help button
p27091
aVYou can always revert to the legacy XP dialogs by setting  to
p27092
aVIf you do that you can set ,  etc
p27093
aVYou should prefer to use the new dialogs if they available though
p27094
aVFor those dialogs you need to use  to add a help button
p27095
aVIn Delphi, for Vista and up, you would need to use  or  directly rather than  and
p27096
aVYou would create the dialog object and then request the  interface from the  property
p27097
aVThe best place to do this is in the  event of the dialog control
p27098
as(dp27099
g7
V505088
p27100
stp27101
a((dp27102
g2
(lp27103
VA Delphi open array is not a valid interop type
p27104
aVYou can't easily match that up with a C#  through a P/invoke
p27105
aVIn an ideal world a different interface would be exposed by the native DLL but as you have stated in comments, you do not have control over that interface
p27106
aVHowever, you can trick the C# code into passing something that the Delphi DLL will interpret correctly, but it's a little dirty
p27107
aVThe key is that a Delphi open array declared like that has an extra implicit parameter containing the index of the last element in the array
p27108
aVTo be clear, in spite of the parameter lists looking so different, the C# code above will successfully call the Delphi DLL function declared so:
p27109
aVI have no idea whether or not passing an array of length 5 is appropriate, or whether you really meant to just set the second item to a non-zero value
p27110
as(dp27111
g7
V505088
p27112
stp27113
a((dp27114
g2
(lp27115
VThe issue here is that  in C doesn\u2019t result in a true constant
p27116
aVWhen you write  what you have is a read-only variable and not a constant
p27117
aVIn C99 an array dimensioned with  is a variable length array (VLA)
p27118
aVVLAs are only available for stack allocated variables, hence the compilation error you see
p27119
aVIf you need an array with global scope you should switch to a macro
p27120
aVThis is valid because  is a literal which is a true constant
p27121
aVIn fact, even for an array of automatic storage (i
p27122
ag192
aVstack allocated local variable) you should avoid a VLA since they incur a runtime overhead
p27123
as(dp27124
g7
V505088
p27125
stp27126
a((dp27127
g2
(lp27128
VThat's a linker error rather than a compile error
p27129
aVYou have correctly included  but you also need to add the import libraries to your linker options
p27130
aVAll three Win32 functions in your sample code require you to link
p27131
as(dp27132
g7
V505088
p27133
stp27134
a((dp27135
g2
(lp27136
VYou can use :
p27137
as(dp27138
g7
V505088
p27139
stp27140
a((dp27141
g2
(lp27142
VFor a list view in  style I believe the best approach is to use the  and  messages
p27143
aVThe VCL does not wrap this functionality up for you but it should not be too difficult to work it out from the MSDN docs
p27144
aVWhilst it is very simple to use the  property exposed by the VCL, as far as I can tell this does not help you obtain the row height or indeed the coordinates of sub items
p27145
aVUpdate
p27146
aVAs NGLN very helpfully points out, the CommCtrl unit does expose  and  which are more convenient to use than the equivalent Windows messages above
p27147
as(dp27148
g7
V505088
p27149
stp27150
a((dp27151
g2
(lp27152
VThis should do it:
p27153
aVNote: I have only compiled this in my head
p27154
as(dp27155
g7
V505088
p27156
stp27157
a((dp27158
g2
(lp27159
VYou probably did  somewhere earlier
p27160
aVYou can undo this with
p27161
as(dp27162
g7
V505088
p27163
stp27164
a((dp27165
g2
(lp27166
VAs soon as you write some code that actually does something with , then the compiler will stop optimizing it away
p27167
aVFor example, if you had a function called  then writing:
p27168
aVwould (probably) be enough to force the compiler not to optimize  away
p27169
aVOf course, you are probably debugging a release build with optimization enabled
p27170
aVYou should change your project settings so that optimizations are disabled when building for debug
p27171
aVWhen you do that you won't need to resort to tricks to defeat the optimizer
p27172
aVOr perhaps you are just debugging the release build by mistake \u2013 you get the idea I trust
p27173
as(dp27174
g7
V505088
p27175
stp27176
a((dp27177
g2
(lp27178
VAs you know, the correct way to do this is to write , or just to let it go out of scope
p27179
aVThe question you ask is why the compiler accepts  and does not complain at compile time
p27180
aVThe declaration of  is
p27181
aVThis is an untyped parameter
p27182
aVConsequently it will accept anything
p27183
aVYou passed an interface, but you could have passed an integer, a string and so on
p27184
aVWhy did the designers choose an untyped parameter
p27185
aVWell, they needed to use a  parameter since the whole purpose of  is to free the object and set the object reference to
p27186
aVThat can't be done by a method of the target object and so a  parameter of a standalone function is needed
p27187
aVYou might imagine that you could write
p27188
aVsince all objects are descended from
p27189
aVBut this does not do the job
p27190
aVThe reason being that the object you pass to a  parameters must be exactly the type of that parameter
p27191
aVIf  was declared this way you would have to cast to  every time you called it
p27192
aVSo, the designers decided that the best solution to the design problem, the least bad choice, is to use the untyped var parameter
p27193
as(dp27194
g7
V505088
p27195
stp27196
a((dp27197
g2
(lp27198
VAs a wild guess, since you didn't include any sample input or output
p27199
aVIt would be unusual to pay no commission until the base was reached but pay comission calculated on the entire sales figures if the base was reached
p27200
aVDid you mean
p27201
aVrather than
p27202
as(dp27203
g7
V505088
p27204
stp27205
a((dp27206
g2
(lp27207
VThe problem is probably that you are mixing different runtimes and probably different heaps
p27208
aVDelphi strings are not valid interop types because their implementations vary from version to version
p27209
aVIn this case you can simply switch to using null-terminated strings, PAnsiChar
p27210
as(dp27211
g7
V505088
p27212
stp27213
a((dp27214
g2
(lp27215
V is not suitable for an enumeration
p27216
aVIt is a 32 bit integer value for which different ranges of bits carry different meaning
p27217
as(dp27218
g7
V505088
p27219
stp27220
a((dp27221
g2
(lp27222
VPerhaps like this:
p27223
aVNo idea what  is, but, assuming it is a  in your C++ code then you would write it like this:
p27224
as(dp27225
g7
V505088
p27226
stp27227
a((dp27228
g2
(lp27229
VNote that your expansion of  is poorly convergent for values of  with large magnitude
p27230
aVYou should shift  by a multiple of  such that  is in the range  to
p27231
aVThis takes advantage of the fact that  is periodic with period
p27232
aVIf you make such a shift you will be able to use fewer terms in your expansion
p27233
aVI would also recommend writing your expansion as a  loop
p27234
aVThis will make it easier for you to experiment to find out how many terms you need to gain an accurate answer
p27235
as(dp27236
g7
V505088
p27237
stp27238
a((dp27239
g2
(lp27240
VNote: In the rest of this answer the terminology owned takes the meaning used by the Windows documentation
p27241
aVThis differs from the meaning of the same term in the VCL
p27242
aVWhat is happening is that your job list window is a top-level owned window
p27243
aVBeing owned places several constraints on a window
p27244
aVAn owned window is always above its owner in the z-order
p27245
aVThe system automatically destroys an owned window when its owner is destroyed
p27246
aVAn owned window is hidden when its owner is minimized
p27247
aVIf you want your job list window to be capable of being below the main window in the z-order, it cannot be owned by the main window
p27248
aVYou can achieve this as follows:
p27249
aVThis makes the job list window an top-level window owned by the hidden application window
p27250
aVOr alternatively like this:
p27251
aVThis makes the job list window an unowned top-level window
p27252
aVAs such it now receives a button in the taskbar
p27253
aVMaking such changes will have far reaching effects for your application
p27254
aVThe second and third bullet points on the list above are obvious impacts
p27255
aVThe behaviour of your windows when minimised and their interaction with the taskbar would also be affected
p27256
aVI've only scratched at the surface here
p27257
aVYou will probably find that making your job-list window no longer be owned by the main window has quite an impact on your program
p27258
aVYou'll discover that Windows does a lot of work for you behind the scenes for owned window
p27259
aVYou may need to reproduce some of that work if you switch to an unowned window
p27260
as(dp27261
g7
V505088
p27262
stp27263
a((dp27264
g2
(lp27265
VThe Delphi IDE is 32 bit and so can only load 32 bit designtime packages
p27266
aVYou can of course create 64 bit runtime packages
p27267
as(dp27268
g7
V505088
p27269
stp27270
a((dp27271
g2
(lp27272
VIf you know the answer to the function, return it immediately
p27273
as(dp27274
g7
V505088
p27275
stp27276
a((dp27277
g2
(lp27278
VCall  passing the child window handle
p27279
aVYou need to do this from the thread that created the window
p27280
aVIf you aren't in control of that thread then sending  to the child window handle will run  on the window's thread
p27281
aVNot sure why your current efforts failed since you didn't give much detail
p27282
as(dp27283
g7
V505088
p27284
stp27285
a((dp27286
g2
(lp27287
VIt's a boolean value
p27288
aVSet it to  or
p27289
aVIf you do not specify it in the DESCRIPTION file then it defaults to
p27290
aVFor convenience you could alternatively use  or  for these boolean fields
p27291
aVNote that I too could find no documentation for this, or perhaps did not know how to interpret the documentation
p27292
aVI worked it out from the source
p27293
as(dp27294
g7
V505088
p27295
stp27296
a((dp27297
g2
(lp27298
VThat's a feature that the Delphi Object Inspector does not implement
p27299
aVVisual Studio has that capability
p27300
aVPerhaps you are used to that and expected to see the same in Delphi
p27301
aVTo find out information about a property, select it and press F1
p27302
as(dp27303
g7
V505088
p27304
stp27305
a((dp27306
g2
(lp27307
VIt depends what you want
p27308
aVIf you want uniqueness amongst GUIDs that you generate, that can be achieved
p27309
aVJust maintain a list of GUIDs and whenever you need to create a new one, do this is a loop until you find one that is not in your list
p27310
aVIf you want some sort of global uniqueness, whereby global means out of all GUIDs in use across the entire planet, then that can never be achieved
p27311
as(dp27312
g7
V505088
p27313
stp27314
a((dp27315
g2
(lp27316
VCopy-on-write is a technique for making reference types behave like value types
p27317
aVRather than using copy-on-write, the Python designers chose immutability
p27318
aVThere is no copy-on-write here
p27319
as(dp27320
g7
V505088
p27321
stp27322
a((dp27323
g2
(lp27324
VIn C++ this is undefined behaviour as has been discussed here a gazillion times
p27325
aVIn C# the behaviour is well defined
p27326
aVWith undefined behaviour any result is possible
p27327
aVNo matter whether or not the behaviour is well defined or not, you should never write code like this
p27328
as(dp27329
g7
V505088
p27330
stp27331
a((dp27332
g2
(lp27333
VThe way to do this is to call the Windows  API passing the  verb
p27334
aVThere are various high-level Python wrappers of this but I have not succeeded in getting any of them to work with the  verb
p27335
aVInstead I would use good old
p27336
aVThe reason I put in the call to  is that the properties dialog is shown as a window in the calling process
p27337
aVIf the Python executable terminates immediately following the call to , then there is nothing there to service the dialog and it does not show
p27338
as(dp27339
g7
V505088
p27340
stp27341
a((dp27342
g2
(lp27343
V is assignment
p27344
aVYou meant to write
p27345
aVtests true for  or the empty string, as its name indicates
p27346
aVAs it happens, for your example,  will never evaluate to
p27347
as(dp27348
g7
V505088
p27349
stp27350
a((dp27351
g2
(lp27352
VThe most likely cause of your problem is that you have not supplied the import library (
p27353
aVa) to the linker
p27354
aVMake sure that the
p27355
aVa file that comes with OpenRacm is passed to the linker
p27356
as(dp27357
g7
V505088
p27358
stp27359
a((dp27360
g2
(lp27361
VThat is the bitwise complement operator, also known as bitwise negation
p27362
as(dp27363
g7
V505088
p27364
stp27365
a((dp27366
g2
(lp27367
VYou are most probably missing a reference to
p27368
aVFrom the documentation:
p27369
aVAssembly:  PresentationFramework (in PresentationFramework
p27370
aVdll)
p27371
as(dp27372
g7
V505088
p27373
stp27374
a((dp27375
g2
(lp27376
VThat code is not C and in fact it's a Pascal like syntax
p27377
aVThe use of the NOT EQUALS operator <> and the hex literal prefix $ indicate that
p27378
as(dp27379
g7
V505088
p27380
stp27381
a((dp27382
g2
(lp27383
VTo produce 32 bit executables you need to install 32-bit versions of Python and cx_freeze
p27384
as(dp27385
g7
V505088
p27386
stp27387
a((dp27388
g2
(lp27389
VInterfaces don't remove the need for there to be implementing objects
p27390
aVEvery single interface you use has to have an implementing object
p27391
aVSo your code needs to call constructors
p27392
aVFactory patterns and other creational patterns allow you to make the object creation more flexible and modular
p27393
aVThese creational patterns allow you to hide all your implementing class declarations, e
p27394
ag217
aVby putting them in the implementation section of the units
p27395
aVWithout using methods to abstract interface creation, your goal no
p27396
aV2 will be incomplete
p27397
as(dp27398
g7
V505088
p27399
stp27400
a((dp27401
g2
(lp27402
VYour C++ method is allocating an array of integers and returning a pointer to the first element in
p27403
aVTherefore the match C# definition for that parameter is
p27404
aVYou used  which is basically equivalent
p27405
aVI think you are under the impression that  is what you use if the underlying array is unsigned but that is not the case
p27406
aVThis is effectively a  pointer and you will have to use  to transfer to a C# array,
p27407
aVNote that since the  really is an out parameter I think you should declare it as such
p27408
aVYou also have declared the final parameter incorrectly
p27409
aVIt is a 32 bit integer
p27410
aVI would therefore declare the C# function like this:
p27411
as(dp27412
g7
V505088
p27413
stp27414
a((dp27415
g2
(lp27416
V is the correct way to handle this
p27417
aVOf course, the code on the other side of the COM interface may not like empty arrays, but that all depends on the particular contract you have with that interface
p27418
as(dp27419
g7
V505088
p27420
stp27421
a((dp27422
g2
(lp27423
VIn larger routines there might be multiple points in the function which need to  the error handling code
p27424
aVThis routine should be seen in the context of having been written according to code conventions that mandate a common form for error handling
p27425
aVIt's true that  should be considered dangerous but for a language like C which has no exception handling it can be the least bad option for error handling
p27426
as(dp27427
g7
V505088
p27428
stp27429
a((dp27430
g2
(lp27431
VOne very common use of  when you are exporting a function from a library
p27432
aVIf you don't disable C++ name mangling you can otherwise make it very hard for clients of your library to name your function
p27433
aVAnd likewise, when going in the other direction, when you are importing a function that has been exported with C linkage
p27434
as(dp27435
g7
V505088
p27436
stp27437
a((dp27438
g2
(lp27439
VThe  operator converts the right hand side to  and so  is typed as
p27440
aVIn other words your code is identical to:
p27441
aVYour question seems to be
p27442
aVWhy can I use an interface in this way
p27443
aVBut I can't understand why you think this code would behave any other way
p27444
aVPerhaps the disconnect is that you aren't yet familiar with the use of  in C#
p27445
aVIf so I'm sure a quick read of the documentation will make it all clear
p27446
aVLocal variables can be given an inferred "type" of var instead of an explicit type
p27447
aVThe var keyword instructs the compiler to infer the type of the variable from the expression on the right side of the initialization statement
p27448
aVNote that there is no difference in type-safety between  variables and explicitly typed variables
p27449
as(dp27450
g7
V505088
p27451
stp27452
a((dp27453
g2
(lp27454
VThe syntax for deleting an array is like this:
p27455
aVYour  loop to delete the objects pointed to by the elements of the array is fine
p27456
aVThe deletion of the array itself is the only problem
p27457
aVYou need both the  loop and then the  to dispose of the array itself
p27458
aVI suspect that you have tried using the  loop, or the , but not both together
p27459
aVAnd if when you do that you still have leaks or errors, then you would need to show us the code that allocates the pointers that are elements of the array
p27460
aVUsing  instead of an array would mean that you could stop worrying about these nitty gritty details and move to higher level of abstraction
p27461
as(dp27462
g7
V505088
p27463
stp27464
a((dp27465
g2
(lp27466
V returns a string, typed as
p27467
aVYou need to convert that string to an integer using your favourite string to integer function, e
p27468
ag217
aVYour present code will not work since it is merely casting rather than converting
p27469
as(dp27470
g7
V505088
p27471
stp27472
a((dp27473
g2
(lp27474
VWhat can I find out about a struct from just a pointer to it
p27475
aVNothing
p27476
aVThis pattern, opaque pointer, is used to hide implementation
p27477
aVThe fact that you can infer nothing about what is behind the pointer is in fact by design
p27478
as(dp27479
g7
V505088
p27480
stp27481
a((dp27482
g2
(lp27483
VYou do this using the modulus operator,
p27484
aVevaluates true if and only if  is an exact multiple of
p27485
aVIn elementary maths this is known as the remainder from a division
p27486
aVIn your current approach you perform a division and the result will be either
p27487
aValways an integer if you use integer division, or
p27488
aValways a float if you use floating point division
p27489
aVIt's just the wrong way to go about testing divisibility
p27490
as(dp27491
g7
V505088
p27492
stp27493
a((dp27494
g2
(lp27495
VThis approach cannot work
p27496
aVYou have two different instances of the VCL in your app, one from the exe and one from the DLL
p27497
aVThat's one VCL too many
p27498
aVYou can most easily understand this by thinking about what objects are
p27499
aVObjects are both data and code
p27500
aVWhen you pass an object from exe to DLL you pass the data, but not the code
p27501
aVDelphi objects are not viable cross-language interop types
p27502
aVWhen you pass your D5 TApplication instance to your XE DLL the XE code interprets it as if it were an XE TApplication
p27503
aVBut it is not
p27504
aVThe same issue applies for your MDI parent and children
p27505
aVThe former is a D5 form, the latter an XE form and so their interactions cannot succeed
p27506
aVPackages solve this problem by sharing a single instance of the VCL but of course that has the corollary that all packages are built with the same version of Delphi
p27507
aVIf you want to use the VCL, that is a hard constraint
p27508
aVSo, if you want some of your forms built with XE, you need to port the entire application
p27509
as(dp27510
g7
V505088
p27511
stp27512
a((dp27513
g2
(lp27514
VIn the C++ code,  is a union
p27515
aVThat means that all the fields have zero offset, they are overlayed
p27516
aVSimply change your C# declaration to match by using  for all fields in
p27517
as(dp27518
g7
V505088
p27519
stp27520
a((dp27521
g2
(lp27522
V declares its handle parameter as being of type  (signed)
p27523
aVDelphi XE2 changes this by declaring it as  (unsigned)
p27524
aVI'm not sure why this change from signed to unsigned was made
p27525
aVClearly it had to be widened to 64 bit for 64 bit targets but I'm not sure why the change from signed to unsigned needed to be made
p27526
aVSo far as I can tell, there is no way to get around this problem without conditional compilation
p27527
aVYou could contain the damage by declaring a type like this:
p27528
aVThen at your call sites you would write
p27529
aVNote that the conditional  does not exist and you'll have to work out what the condition really should be
p27530
as(dp27531
g7
V505088
p27532
stp27533
a((dp27534
g2
(lp27535
VThe code after the  is unreachable
p27536
aVThe condition  is always, err,
p27537
as(dp27538
g7
V505088
p27539
stp27540
a((dp27541
g2
(lp27542
VI know it's a WinForms component rather than a WPF component but you can still use  in WPF
p27543
aVSet the  or  properties to assign a menu to the icon
p27544
aVEDIT: Judging by your comments and answer I believe that you are trying to use  which does not have built-in support for displaying images
p27545
aVHowever, that deficiency was long ago removed with the introduction of
p27546
aVThis has an  property, or alternatively the  property is you prefer to use image lists
p27547
as(dp27548
g7
V505088
p27549
stp27550
a((dp27551
g2
(lp27552
VI would recommend starting from the Visual Studio service template project
p27553
as(dp27554
g7
V505088
p27555
stp27556
a((dp27557
g2
(lp27558
VYou did not miss anything
p27559
aVThere is nothing in the product to help you
p27560
aVI too find this a little disappointing but I fully expect that the Emba designers thought about this
p27561
aVI can only conclude that their experience was that adding such warnings resulted in more noise than signal
p27562
aVThe Delphi compiler has never warned when assigning to incompatible integer types
p27563
aVFor example it has never been a warning or an error to assign an integer to a byte
p27564
aVIt's time to fire up grep and search for , , , ,  etc
p27565
aVTo respond to Arnaud's comment and answer, I offer the following code which compiles free of warnings and errors when targetting 64 bit
p27566
as(dp27567
g7
V505088
p27568
stp27569
a((dp27570
g2
(lp27571
VThere's no reason at all why a constructor should not take as long as it needs to do its job
p27572
aVThe options proposed by you and others look to me like they will make your code more complex for no discernible benefit
p27573
as(dp27574
g7
V505088
p27575
stp27576
a((dp27577
g2
(lp27578
VIt's a little tricky to be sure quite what you mean
p27579
aVVS2010 can certainly produce output that takes full advantage of such hardware
p27580
aVAnd the IDE itself will run very nicely on such a roomy machine
p27581
aVYour update discusses memory limits imposed by Windows itself
p27582
aVYou say:
p27583
aVIf you want to write an app that will run on Windows 7, and even if you require the 64bit version, you are limited to 16 gb
p27584
aVThe only way to get around that is require users to run Win 7 Professional, Enterprise or Ultimate 64 bit versions
p27585
aVThe reality is that nobody will buy a machine with more than 16GB RAM and then install an OS edition which does not support that amount of RAM
p27586
aVThat would just be a waste of money
p27587
aVIf your app requires more RAM than that and your customers are prepared to get hold of such a machine, then they will be quite happy to put the Pro version of Windows on it
p27588
as(dp27589
g7
V505088
p27590
stp27591
a((dp27592
g2
(lp27593
VI doubt that there is a supported way to change this from code
p27594
aVThat's a system wide option that the user is in control of
p27595
aVMS likes to avoid tempting developers to change such settings
p27596
aVEven if there is a way to change the system wide setting from code I urge you not to do so
p27597
aVInstead write your own message box dialog and feel free to use whatever font you like
p27598
as(dp27599
g7
V505088
p27600
stp27601
a((dp27602
g2
(lp27603
VCreating your own language is possible but very challenging
p27604
aVYou can't do it well without things like lexers
p27605
aVCreating your own language also forces your clients to learn yet another language, and there will be no extant third party code or libraries for this putative language
p27606
aVAn alternative would be to embed an existing language and expose your application's functionality through that
p27607
aVPython is one very common choice for embedding but there are many other options
p27608
aVI strongly recommend that, for this task, you consider embedding an existing language rather than inventing your own
p27609
as(dp27610
g7
V505088
p27611
stp27612
a((dp27613
g2
(lp27614
VYour code is 32 bit code but the target process is a 64 bit process
p27615
aVThis gives you two problems:
p27616
aVYour declaration of  is no longer applicable because all the pointers in it are declared as 32 bit pointers in your code, but they are 64 bit pointers in the target process
p27617
aVYou need to declare your own version of  to fix that
p27618
aVUse a 64 bit compiler to be sure you get the padding and layout of the struct correct
p27619
aVThe values returned from  and  are also 32 bit pointers but again the target process uses 64 bit pointers
p27620
aVI suspect that the WOW64 system will endeavour to reserve addresses that are <4GB so that your 32 bit pointers don't suffer from truncation, but I'm not 100% sure
p27621
aVI'd be tempted to call  requesting a specific address
p27622
as(dp27623
g7
V505088
p27624
stp27625
a((dp27626
g2
(lp27627
VYou are mistakenly using  and  instead of  and
p27628
aVAnd presumably the code in the book has a  statement in order to declare
p27629
as(dp27630
g7
V505088
p27631
stp27632
a((dp27633
g2
(lp27634
VAt the very least, there is heap corruption caused by the fact that  is never initialised
p27635
aVYour code writes to  and this will be where the heap corruption occurs
p27636
aVI would expect your compiler to be warning about this
p27637
aVI've not checked the code carefully and would not be surprised if there were more errors
p27638
aVUpdate: The answer above was written to go with the original question that indeed did not initialise
p27639
aVThe updated code shows how  is initialised but still omits vital parts of code
p27640
aVNo matter, my conclusion is the same
p27641
aVYou will have a heap corruption somewhere due to  being out of bounds at some point in your loop that writes to
p27642
aVSimply add some diagnostics output, or use a debugger, to inspect  and I'm sure the problem will become clear
p27643
as(dp27644
g7
V505088
p27645
stp27646
a((dp27647
g2
(lp27648
VI think you want something like this:
p27649
aVYou can't nest functions like in some other languages
p27650
aVYou had non-matching parentheses in the  function
p27651
aVI fixed the declarations of your functions, use  when there are no parameters,  doesn't return anything
p27652
aVYour division by  was a little messed up
p27653
aVSimply divide by  and the result will be in the closed interval [0,1]
p27654
aVAnd the syntax for the conversion to  was not quite right
p27655
as(dp27656
g7
V505088
p27657
stp27658
a((dp27659
g2
(lp27660
VThe generic TList has a Contains method that can be used to detect duplicates
p27661
aVBut you have to call this yourself as there is no Duplicates property as there is for TStringList
p27662
aVIf your data can be compared with a binary compare then there is nothing more to do
p27663
aVOtherwise you need to supply a custom comparer
p27664
as(dp27665
g7
V505088
p27666
stp27667
a((dp27668
g2
(lp27669
VThere is no equivalent in Windows
p27670
aVThere is just the single global clipboard which contains a single item, albeit in potentially multiple formats
p27671
aVI want to retrieve the current selection in the current window
p27672
aVThat's not trivial in Windows
p27673
aVYou can do it using, for example, UI Automation, for apps that support UI Automation
p27674
aVMost modern apps do support that but more obscure ones will not readily yield the information you are after
p27675
as(dp27676
g7
V505088
p27677
stp27678
a((dp27679
g2
(lp27680
VIn fact the cast is superfluous
p27681
aVYou can just as easily write str := myPAnsiChar
p27682
aVDelphi string types use memory that is managed by the RTL
p27683
aVThis means that they will never reuse the contents of a PChar
p27684
aVThe only time you ever need to take steps to make sure an assignment creates a new copy is when the assignment is between two matching Delphi string types
p27685
aVThat is AnsiString to AnsiString or UnicodeString to UnicodeString
p27686
as(dp27687
g7
V505088
p27688
stp27689
a((dp27690
g2
(lp27691
VIt's impossible to be sure without knowledge of the algorithm and some timing
p27692
aVYou forgot to account for false sharing which is going to be more significant with 16 bit integers
p27693
aVSo, to answer the question, you will have to do some timing
p27694
as(dp27695
g7
V505088
p27696
stp27697
a((dp27698
g2
(lp27699
VThe default calling convention is cdecl
p27700
aVNote that __declspec(dllexport) has no influence on calling convention
p27701
aVThe calling convention can be specified in code, or by a compiler option
p27702
aVI don't recommend using the compiler option, it's a bit too obscure
p27703
aVMake it explicit in code and then anyone reading if knows what convention is used
p27704
aVNote that for 64 bit Windows code, all calling conventions are equivalent which could explain what you see
p27705
as(dp27706
g7
V505088
p27707
stp27708
a((dp27709
g2
(lp27710
VYou cannot assign to arrays
p27711
aVYou have to copy into them with strncpy, memcpy or some such
p27712
as(dp27713
g7
V505088
p27714
stp27715
a((dp27716
g2
(lp27717
VYou have two copies of the reference to the object but are only setting one of them to nil
p27718
aVYour code is equivalent to this:
p27719
aVI'm using integers in this example because I'm sure you are familiar with how they work
p27720
aVObject references, which are really just pointers, behave in exactly the same way
p27721
aVCasting the example in terms of object references makes it look like this:
p27722
aVAside: You should never call Destroy directly and never declare a method called Free
p27723
aVInstead override Destroy and call the static Free defined in TObject, or indeed FreeAndNil
p27724
as(dp27725
g7
V505088
p27726
stp27727
a((dp27728
g2
(lp27729
VYou are compiling for Unicode but passing an ANSI buffer
p27730
aVYour actual code has a cast that you are not showing us
p27731
aVEither pass a wchar_t buffer and use a matching print routine, or call the ANSI version of the function, SHGetFolderPathA
p27732
as(dp27733
g7
V505088
p27734
stp27735
a((dp27736
g2
(lp27737
VWhen exactly does this automatic freeing occur
p27738
aVDoes it happen immediately, or at the end of the containing procedure
p27739
aVDynamic memory associated with managed types (dynamic arrays fall into this class) is freed when the reference count is set to 0
p27740
aVThis can happen at the following points:
p27741
aVThe reference variable is assigned a new value
p27742
aVA call to Finalize can be thought of as the special case where the new values is nil
p27743
aVThe reference variable goes out of scope
p27744
aVFor example:
p27745
aVThe exit of a function is reached; local variables go out of scope
p27746
aVAn object is destroyed and its members go out of scope
p27747
aVA pointer to a record is destroyed with the Dispose function; all fields of the record go out of scope
p27748
aVA unit is finalized and all global variables defined in the unit are finalized
p27749
aVNote that the various cases above only result in memory being freed when the reference that is being finalized or is leaving scope is the last remaining reference
p27750
aVIn other words, when the reference count is 1
p27751
aVIn your specific example, assuming the Finalize is removed, you are creating a new dynamic array and assigning it to a variable that already holds a dynamic array
p27752
aVThis then falls into the class described by item 1 in the list above
p27753
aVSo in that sense the call to Finalize is superfluous
p27754
aVRob has explained the order in which the allocation and deallocation happens which is a good point
p27755
aVTo the best of my knowledge that is an implementation detail that is not explicitly documented
p27756
aVHowever, I'd be astounded if that detail was ever changed
p27757
as(dp27758
g7
V505088
p27759
stp27760
a((dp27761
g2
(lp27762
VUpdate Having clarified in the comments that the errors occur immediately, and not at process shutdown, the only remaining conclusions that I can see are that:
p27763
aVThis is a bug in the compiler/runtime
p27764
aVYou are linking against a single threaded runtime, or perhaps need to initialize the runtime for multi-threading
p27765
aVYou are calling CreateThread but some C++ runtimes require you to use a runtime supplied thread creation function
p27766
aVYour problem is probably that the exception handling runtime support is being unloaded whilst the threads are still active
p27767
aVThe runtime will shut itself down when you exit the main function
p27768
aVI would have expected the runtime to be more robust than this, but there you go
p27769
aVI would expect that your problems would vanish if you made sure that all your threads had terminated before you exited your main function
p27770
aVThis is good practise no matter what, you don't want threads to be forcibly terminated under any circumstances
p27771
as(dp27772
g7
V505088
p27773
stp27774
a((dp27775
g2
(lp27776
VOne obvious problem is that you are failing to initialize your struct
p27777
aVYou should do this:
p27778
aVOther  than that check for errors and call GetLastError to find out what caused any error
p27779
as(dp27780
g7
V505088
p27781
stp27782
a((dp27783
g2
(lp27784
V takes a copy of your string
p27785
aVYou can safely, and indeed should, free the memory as soon as the call to  returns
p27786
as(dp27787
g7
V505088
p27788
stp27789
a((dp27790
g2
(lp27791
VRather than fighting with this this 10 year old code you should simply switch to list view,  and set  to
p27792
aVThis gives you a multi-column list using the native, modern-day Windows list control
p27793
aVThis doesn't directly answer your question, but I believe it solves your problem far better than the code you are trying to use
p27794
as(dp27795
g7
V505088
p27796
stp27797
a((dp27798
g2
(lp27799
VSince this is homework, I will just give you an outline
p27800
aVFirst of all declare your two strings:
p27801
aVNext declare two pointers to :
p27802
aVNow enter a while loop
p27803
aVThe condition should be that  or  are not equal to zero
p27804
aVInside the loop output  if it is not zero and then output  if it is not zero
p27805
aVIncrement each pointer if it refers to a non-zero character
p27806
aVThat's it, you are done
p27807
as(dp27808
g7
V505088
p27809
stp27810
a((dp27811
g2
(lp27812
VIt's much easier than that
p27813
aVJust use the bitwise  operator like this
p27814
as(dp27815
g7
V505088
p27816
stp27817
a((dp27818
g2
(lp27819
VTo be perfectly frank, and considering all the boiler plate required for a comparer based approach, it may just be simplest to write your own search routine:
p27820
as(dp27821
g7
V505088
p27822
stp27823
a((dp27824
g2
(lp27825
VYou need to create a hidden window to use with the notification icon
p27826
aVCall  as usual to create a window, but just refrain from showing it
p27827
aVMake sure that you do not pass  when creating the window
p27828
aVThe other issue is that you need a message loop
p27829
aVSince a console application will not run a message loop by default, the simplest solution is to run the notification icon out of a separate thread which implements the message loop
p27830
aVNaturally this implies that the hidden window needs to be created and destroyed in that thread also
p27831
as(dp27832
g7
V505088
p27833
stp27834
a((dp27835
g2
(lp27836
VFireMonkey is cross platform and runs on Windows, Mac OSX, iOS and no doubt many other platforms in due course
p27837
aVTherefore there are no Windows messages exposed by FireMonkey
p27838
aVWhatever it is you are used to doing with  in the VCL most likely has an equivalent in FireMonkey
p27839
aVExactly what that equivalent is depends very much on what your  handler is trying to achieve
p27840
as(dp27841
g7
V505088
p27842
stp27843
a((dp27844
g2
(lp27845
VThe best reference I know for this is a series of articles by renowned Delphi expert Chris Rolliston
p27846
aVSetting up a custom title bar on Vista/Windows 7
p27847
aVSetting up a custom title bar \u2013 reprise
p27848
as(dp27849
g7
V505088
p27850
stp27851
a((dp27852
g2
(lp27853
VAn array parameter, e
p27854
ag217
aV, is essentially the same as a pointer to the first element
p27855
aVSo pass the pointer to the integer and a length of 1, and you can make a single integer appear just like an array
p27856
as(dp27857
g7
V505088
p27858
stp27859
a((dp27860
g2
(lp27861
VYour declaration  sounds like a stack allocated variable, although it could be heap allocated if part of a struct
p27862
aVAccessing out of bounds of an array is undefined behaviour and is known as a buffer overrun
p27863
aVBuffer overruns on stack allocated memory may corrupt the current stack frame and possibly other stack frames in the call stack
p27864
aVWith undefined behaviour, anything could happen, including no apparent error
p27865
aVYou would not expect a seg fault immediately because the stack is typically when the thread starts
p27866
aVFor heap allocated memory, memory managers typically allocate large blocks of memory and then sub-allocate from those larger blocks
p27867
aVThat is why you often don't get a seg fault when you access beyond the end of a block of memory
p27868
aVIt is undefined behaviour to access beyond the end of a memory block
p27869
aVAnd it is perfectly valid, according to the standard, for such out of bounds accesses to result in seg faults or indeed an apparently successful read or write
p27870
aVI say apparently successful because if you are writing then you will quite possibly produce a heap corruption by writing out of bounds
p27871
as(dp27872
g7
V505088
p27873
stp27874
a((dp27875
g2
(lp27876
VClearly if you declare your array with a fixed size,  then it cannot be resized
p27877
aVWhat you need to do is to declare it as a pointer:
p27878
aVThen you must use  to allocate the array and can use  to resize it whilst preserving the contents of the original array
p27879
as(dp27880
g7
V505088
p27881
stp27882
a((dp27883
g2
(lp27884
VYou included windows
p27885
aVh and the DrawText macro replaced DrawText with DrawTextA
p27886
aVThere's not a whole lot you can do about that other than avoid using names that Windows also uses
p27887
aVNot very appealing
p27888
as(dp27889
g7
V505088
p27890
stp27891
a((dp27892
g2
(lp27893
VThe only thing I have found to work well is to use the  window style
p27894
aVThis is a performance hog so I only enable it when in a sizing loop
p27895
aVIt is my experience that, with the built-in controls, in my app, flickering only occurs when resizing forms
p27896
aVYou should first perform a quick test to see if this approach will help you by simply adding the  window style to all your windowed controls
p27897
aVIf that works you can consider the more advanced approach below:
p27898
aVQuick hack
p27899
aVCall this, for example, in the  for your , passing the form instance
p27900
aVIf that helps then you really should implement it more discerningly
p27901
aVI give you the relevant extracts from my code to illustrate how I did that
p27902
aVFull code
p27903
aVThis won't compile for you, but it should contain some useful ideas
p27904
aVis my utility to turn a recursive walk of the child controls into a flat  loop
p27905
aVNote that I also use a custom splitter that calls BeginSizing/EndSizing when it is active
p27906
aVAnother useful trick is to use  instead of  which you occasionally need to do when you have deep nesting of page controls and panels
p27907
aVI've used this code to make my app 100% flicker free but it took me ages and ages of experimenting to get it all in place
p27908
aVHopefully others can find something of use in here
p27909
as(dp27910
g7
V505088
p27911
stp27912
a((dp27913
g2
(lp27914
VIt looks like it was dropped but has been re-instated
p27915
aVIn my XE2 installation the projpageide160
p27916
aVbpl file is there, as is the  menu
p27917
aVNeither are present in my D2010 installation
p27918
as(dp27919
g7
V505088
p27920
stp27921
a((dp27922
g2
(lp27923
V is defined in  and implemented in
p27924
aVThe import library is
p27925
aVThe information is found towards the bottom of the MSDN topic
p27926
aVAs for , that is also defined when you include
p27927
as(dp27928
g7
V505088
p27929
stp27930
a((dp27931
g2
(lp27932
VThe very simplest way to do this is to use a  rather than battling with character arrays:
p27933
aVI've taken a bit of a leap in assuming that you are really working with strings
p27934
aVIf it really is an array of characters that you want, then perhaps use  instead
p27935
as(dp27936
g7
V505088
p27937
stp27938
a((dp27939
g2
(lp27940
VNo, that's how  is meant to work
p27941
aVTo do it the way you want would be against the standard
p27942
aVIt's rather hard to argue that  is correct in C++
p27943
aVUsing  is the correct way to do this
p27944
aVUpdate As others point out, the standard only mandates that the functions are declared in the std namespace
p27945
aVImplementations are permitted to define them additionally in the global namespace
p27946
as(dp27947
g7
V505088
p27948
stp27949
a((dp27950
g2
(lp27951
VThe simplest way to tackle this is to put the DLL files in the same directory as your executable
p27952
aVThat ensures that the versions that are loaded are exactly the versions you want
p27953
aVThe situation you describe, DLL files present in system32 but not found, is most likely because your app is 32 bit and so looks in the 32 bit system32 folder which is named SysWOW64
p27954
as(dp27955
g7
V505088
p27956
stp27957
a((dp27958
g2
(lp27959
VEach thread has a private stack
p27960
aVEach method has a private stack frame within that thread's stack
p27961
aVStacks are associated with thread in a one-to-one mapping
p27962
aVStacks are absolutely not associated with methods and classes
p27963
aVThe way to reason about all this is that the local variables of a method are private to each  invocation of that method
p27964
as(dp27965
g7
V505088
p27966
stp27967
a((dp27968
g2
(lp27969
VIt is an array of  but you have initialized it with string literals
p27970
aVThese are read-only and attempting to modify them is undefined behaviour
p27971
aVIt is common for a compiler to store literals in a read-only segment of the executable image which is probably why you are seeing segmentation faults when you attempt to modify the contents
p27972
as(dp27973
g7
V505088
p27974
stp27975
a((dp27976
g2
(lp27977
VThat's undefined behaviour
p27978
aVAnything could happen
p27979
as(dp27980
g7
V505088
p27981
stp27982
a((dp27983
g2
(lp27984
VSet PE flags
p27985
aVYou can use  to set the DEP flag, and  to set the ASLR flag
p27986
aVTo set both use
p27987
aVIf you have a version of Delphi with the necessary definitions in the Windows
p27988
aVpas unit you can use the much more readable:
p27989
aVTypically you include the  setting in the
p27990
aVdpr file
p27991
aVAnd so you need to make sure that  is in the
p27992
aVdpr file uses clause for these  constants to be available
p27993
aVSet DEP policy at runtime
p27994
aVFor versions that don't support PE flag based approaches you can call this function early in your app's initialization:
p27995
aVThis will work for any version of Delphi
p27996
aVYou cannot set the ASLR flag at runtime since it influences how the module is loaded
p27997
aVSo ASLR can only be set using PE flags
p27998
aVModifying PE flags for very old versions of Delphi
p27999
aVOlder versions of Delphi do not support  and
p28000
aVFor such versions you need to use an external tool to modify the executable post-build
p28001
aVWhen I originally wrote this answer I assumed that  from the MS toolchain would do the job
p28002
aVFor DEP it will suffice, using the  option
p28003
aVFor ASLR you will need to use a different PE flag editor
p28004
aVMy websearch revealed  from cygwin
p28005
aVI'm sure there are other PE flag editing options available
p28006
as(dp28007
g7
V505088
p28008
stp28009
a((dp28010
g2
(lp28011
VIf you are using Delphi XE or above you can do this trivially in a single line of code, using a regular expression
p28012
aVNaturally this is not the fastest running of the solutions on offer, but maybe that doesn't matter to you
p28013
as(dp28014
g7
V505088
p28015
stp28016
a((dp28017
g2
(lp28018
VMost likely the cause of the error is a mismatch of calling conventions
p28019
aVI'm guessing your C++ DLL exports functions with  convention but your use of  implies
p28020
aVCreate your library like this to use :
p28021
as(dp28022
g7
V505088
p28023
stp28024
a((dp28025
g2
(lp28026
VThis has already been invented and is called
p28027
as(dp28028
g7
V505088
p28029
stp28030
a((dp28031
g2
(lp28032
VIf your buffer allocation is incorrect then it's perfectly possible that the reorganisation of code would change behaviour
p28033
aVBuffer overrun is undefined behaviour and so could well differ with such a reorganisation
p28034
aVI think you need to look again at the buffer allocation code which is not present in the question
p28035
as(dp28036
g7
V505088
p28037
stp28038
a((dp28039
g2
(lp28040
VUAC is designed so that you cannot do what you want
p28041
aVUAC ensures that in order to elevate the user must pass through a UAC dialog (either the admin consent dialog or the over-the-shoulder dialog)
p28042
aVYou need to adapt your expectations to the reality of UAC
p28043
as(dp28044
g7
V505088
p28045
stp28046
a((dp28047
g2
(lp28048
VA good compiler will optimize that about as well as you will ever manage
p28049
aVA good compiler will use SIMD instructions if it deems that they are going to be beneficial
p28050
aVMake sure that you turn on all such possible optimizations for your compiler
p28051
aVUnfortunately, vectors of dimension 3 don't tend to sit well with SIMD units
p28052
aVI suspect that you will simply have to accept that the code produced by the compiler is probably pretty close to optimal and that no significant gains can be made
p28053
as(dp28054
g7
V505088
p28055
stp28056
a((dp28057
g2
(lp28058
VWindows will always show the UAC prompt as part of elevation
p28059
aVIf you want to make the message identify yourself as the supplier of the software then you will need to by a digital certificate with which to sign your install package
p28060
aVYou will need to undergo a degree of vetting in order to obtain a certificate
p28061
as(dp28062
g7
V505088
p28063
stp28064
a((dp28065
g2
(lp28066
VMost likely you are calling  from a busy loop that itself does not terminate
p28067
aVIf you enter an event handler but never return from it then calling  or  would indeed be futile
p28068
aVThese routines that close an application are cooperative
p28069
aVThey post messages to the main message loop requesting that the application gracefully shuts down
p28070
aVFor example, the following code would exhibit the symptoms you describe:
p28071
aVAnother (more likely) possibility is that you are calling this function from inside a modal form but not closing the modal form
p28072
aVUnless you show more code, we are reduced to making guesses like this
p28073
as(dp28074
g7
V505088
p28075
stp28076
a((dp28077
g2
(lp28078
VThat is an excellent idea and a very common solution to the problem
p28079
aVMethods with more than 2 or 3 parameters get exponentially harder and harder to understand
p28080
aVEncapsulating all this in a single class makes for much clearer code
p28081
aVBecause your properties have names you can write self-documenting code like this:
p28082
aVNaturally when you have a lot of parameters the alternative based on positional identication is simply horrid
p28083
aVYet another benefit is that adding extra parameters to the interface contract can be done without forcing changes at all call sites
p28084
aVHowever, this is not always as trivial as it seems
p28085
aVIf different call sites require different values for the new parameter, then it is harder to hunt them down than with the parameter based approach
p28086
aVIn the parameter based approach, adding a new parameter forces a change at each call site to supply the new parameter and you can let the compiler do the work of finding them all
p28087
as(dp28088
g7
V505088
p28089
stp28090
a((dp28091
g2
(lp28092
VI'm assuming this is a VCL app
p28093
aVFor FireMonkey this would not work
p28094
aVAdd an  event handler
p28095
aVIn the event handler look for  or perhaps  and check that the modifier key state is as you desire, e
p28096
ag217
aVCTRL is down
p28097
aVCall  passing the position associated with the mouse event
p28098
aVThis will give you the control under the mouse, if indeed there is one (i
p28099
ag192
aVcheck for )
p28100
aVDo whatever it is you want to that control
p28101
as(dp28102
g7
V505088
p28103
stp28104
a((dp28105
g2
(lp28106
VTo the very best of my knowledge, the common dialogs cannot be operated in a mode where you can select either folder or file from the same dialog
p28107
as(dp28108
g7
V505088
p28109
stp28110
a((dp28111
g2
(lp28112
VPython's  is built-in and set in stone
p28113
aVYou can't change that
p28114
aVYou could use  from numpy
p28115
as(dp28116
g7
V505088
p28117
stp28118
a((dp28119
g2
(lp28120
VI can see a few issues
p28121
aVI assume that  is the address of the original  function
p28122
aVYou really should not hard code this
p28123
aVUse  instead
p28124
aVOf course this will mean that you need to use a different name for your replacement function
p28125
aVThe offset is calculated incorrectly
p28126
aVYou have the sign wrong
p28127
aVWhat's more the offset is applied to the instruction pointer at the end of the instruction and not the beginning
p28128
aVSo you need to shift it by 5 (the size of the instruction)
p28129
aVThe offset should be a signed integer also
p28130
aVIdeally, if you take into account my first point the code would look like this:
p28131
aVThanks to Hans Passant for fixing my own silly sign error in the original version
p28132
aVIf you are working on a 64 bit machine you need to do your arithmetic in 64 bits and, once you have calculated the offset, truncate it to a 32 bit offset
p28133
aVAnother nuance is that you should reset the memory to being read-only after having written the new  instruction, and call
p28134
as(dp28135
g7
V505088
p28136
stp28137
a((dp28138
g2
(lp28139
VSome problems:
p28140
aVYou are using  which attempts to open the key with write access
p28141
aVInstead you should use
p28142
aVIf you really do mean to write to those keys then you will have to run elevated as an administrator
p28143
aVYou are failing to close the keys once you have finished with them
p28144
aVMore seriously, your use of relative registry keys is not sufficient
p28145
aVI believe you will need to pass around the full path to the key
p28146
aVI wrote a little demo console app to show what I mean:
p28147
as(dp28148
g7
V505088
p28149
stp28150
a((dp28151
g2
(lp28152
VThe algorithm and code you have is the simplest and best way to do this
p28153
as(dp28154
g7
V505088
p28155
stp28156
a((dp28157
g2
(lp28158
VThe nature of a dictionary is that you cannot efficiently test whether or not a value is present in the way that you can test whether a key is present
p28159
aVYou need to iterate over the dictionary testing each value, although this can be done transparently using the code that Mark suggests
p28160
aVIf you have large dictionaries then performance may be an issue and you may require a different data structure
p28161
as(dp28162
g7
V505088
p28163
stp28164
a((dp28165
g2
(lp28166
VNesting of function definitions relies on a GCC extension to work
p28167
aVIt is not described by the standard
p28168
aVIf you have any desire for your code to work with other compilers then you should refrain from using such techniques
p28169
aVWhat's more, if you collaborate with other developers, I predict that many of them will dislike the use of such non-standard constructs
p28170
aVI'm not expert with GCC but I'm fairly sure there are compiler options to disable extensions
p28171
aVThis will allow you to get the compiler to make sure you are not writing code that won't compile with other compilers
p28172
aVRegarding your update there are uses for nested functions
p28173
aVThey can aid encapsulation by restricting scope and visibility
p28174
aVHowever, there is no problem that cannot be solved perfectly adequately without nested functions which I think explains why they are a rarely used GCC peculiarity
p28175
as(dp28176
g7
V505088
p28177
stp28178
a((dp28179
g2
(lp28180
VWhat you are attempting to do is not practical
p28181
aVYou'd need to hook into the message queue of all running apps
p28182
aVThat's just not a realistic proposition
p28183
aVI can't guess what's driving this question but I wonder if a system wide hot key might serve your needs
p28184
as(dp28185
g7
V505088
p28186
stp28187
a((dp28188
g2
(lp28189
VThis is UAC
p28190
aVIf you run elevated, you will see the behaviour you expect
p28191
aVBut with a standard token under UAC your user doesn't have administrator rights, even when in the admin group
p28192
aVFor the special Administrator user account, UAC does not apply and processes under that special user are always given a privileged token
p28193
aVSo the difference you see is not with the OS but with the user
p28194
aVLog on as the special Administrator account on Windows 7 and see that it behaves just as the server 2008 box does
p28195
as(dp28196
g7
V505088
p28197
stp28198
a((dp28199
g2
(lp28200
VStatic variables are perhaps marginally better than globals, but not much
p28201
aVBeing not as evil as global variables is not much of a commendation however
p28202
aVWhen you have multiple threads or reentrant functions then they do not suffice
p28203
aVWhat's more using them as parameter passing mechanism will lead to code that is very hard to read and maintain
p28204
aVThere are uses for static variables but I'd never use them for parameter passing
p28205
aVIn some cases it can be better collecting parameters into a struct to be passed around
p28206
as(dp28207
g7
V505088
p28208
stp28209
a((dp28210
g2
(lp28211
VYou should be using 32bpp icons with partial transparency for best effect
p28212
aVThe icon uses the small system size
p28213
aVGet this by calling  passing
p28214
aVIf you use font scaling this can be, for example, 20px rather than the more common 16px
p28215
aVI've never found MS documentation for this fact but you can readily verify it for yourself by trial and error
p28216
aVNot really a happy state of affairs, but it is what it is
p28217
aVUpdate: TOndrej points out that the docs for  gives tacit approval of the notification area icon being small icon size
p28218
aVI don't understand why this information is not included with that for notification icons
p28219
as(dp28220
g7
V505088
p28221
stp28222
a((dp28223
g2
(lp28224
VThat is perfectly well defined and the assertion passes
p28225
aVThe c_str() function will always return a valid zero terminated C string
p28226
aVOne would normally use empty() to test for an empty string
p28227
as(dp28228
g7
V505088
p28229
stp28230
a((dp28231
g2
(lp28232
VYou can only call this function with an array
p28233
aVThat is not something you have any control over
p28234
aVSo you need to use a stack that is capable of exposing its contents as an array
p28235
aVOr an array that is capable of operating like a stack
p28236
aVHowever, it is perfectly plausible that the use of a stack container for your threads is simply inappropriate
p28237
aVWhy does your homework assistant want to use a stack
p28238
as(dp28239
g7
V505088
p28240
stp28241
a((dp28242
g2
(lp28243
VThe code you post is from a
p28244
aVpas file rather than a
p28245
aVdpr file
p28246
aVSo far as I am aware that should be a syntax error so I'm a little confused
p28247
aVAs for how to do it right, I would move
p28248
aVinto the
p28249
aVdpr file's uses clause
p28250
aVThe path is relative to the directory containing the
p28251
aVdpr file
p28252
aVThen you can write
p28253
aVin your
p28254
aVpas files
p28255
as(dp28256
g7
V505088
p28257
stp28258
a((dp28259
g2
(lp28260
VIt's rather hard to answer this since you have not shown the class declarations
p28261
aVIt sounds as though your  statement needs to be inside the for loop:
p28262
aVFor this to work the  field would need to be an instance variable rather than a static variable and that is probably the crux of your problem
p28263
as(dp28264
g7
V505088
p28265
stp28266
a((dp28267
g2
(lp28268
VYou can't create events for a class from the outside
p28269
aVThe reason being that the control itself needs to raise the event which leads to the conclusion that the event code must live inside the control
p28270
aVYou would need to implement your own user control
p28271
aVI suspect that your actual problem is that you want to intercept specific clicks on elements within the webpage that the control is displaying
p28272
aVTo do that requires DOM programming
p28273
as(dp28274
g7
V505088
p28275
stp28276
a((dp28277
g2
(lp28278
VThe modulus operator works on floating point values in the same way as it does for integers
p28279
aVSo consider a simple example:
p28280
aVNow, 4
p28281
aV5/2
p28282
aV1 is approximately equal to 2
p28283
aV142857
p28284
aVSo, the integer part of the division is 2
p28285
aVSubtract 2*2
p28286
aV1 from 4
p28287
aV5 and you have the remainer, 0
p28288
ag23064
aVOf course, this process is subject to floating point representability issues so beware \u2013 you may see unexpected results
p28289
aVFor example, see this question asked here on Stack Overflow: Floating Point Arithmetic - Modulo Operator on Double Type
p28290
aVIs a % b always equivalent to a - b*Math
p28291
aVRound(a/b)
p28292
aVNo it is not
p28293
aVHere is a simple counter example:
p28294
aVAs to the precise details of how the modulus operator is specified you need to refer to the C# specification \u2013 earlNameless's answer gives you a link to that
p28295
aVIt is my understanding that  is essentially equivalent, modulo floating point precision, to
p28296
as(dp28297
g7
V505088
p28298
stp28299
a((dp28300
g2
(lp28301
VYou have just invoked undefined behaviour
p28302
aVThere's little point in reasoning about writing beyond the bounds of an array
p28303
aVJust don't do it
p28304
aVmeans address of address of first element of  which is not sensible
p28305
aVNo, that's perfectly sensible
p28306
aVYour description perfectly describes what is going on
p28307
aVis the same as  which is the same as
p28308
aVWhen you write  you are dereferencing the pointer
p28309
aVWhen you then write  you are taking the address of that variable and thus return to what you started from,
p28310
as(dp28311
g7
V505088
p28312
stp28313
a((dp28314
g2
(lp28315
VI am assuming trust that the DLL has a function that deallocates the  struct
p28316
aVThat's something that you can't possibly hope to do from C#
p28317
aVMore on this point later on
p28318
aVA Delphi dynamic array is not a valid interop type
p28319
aVIt really should only used internally to Delphi code compiled with a single version of the compiler
p28320
aVExposing it publically is akin to exporting C++ classes from a DLL
p28321
aVIn an ideal world you would re-work the Delphi code so that it exported the array using a proper interop type
p28322
aVHowever, in this case it is actually relatively easy for you to do the marshalling without adjusting the Delphi code
p28323
aVDelphi dynamic arrays were introduced way back in Delphi 4 and their implementation has remained unchanged since then
p28324
aVThe  dynamic array variable is effectively a pointer to the first element
p28325
aVThe elements are laid out sequentially in memory
p28326
aVThe dynamic array variable also maintains (at negative offsets) a reference count and the size of the array
p28327
aVYou can safely ignore these since you are neither modifying the dynamic array nor needing to ascertain its size
p28328
aVUsing  for the  field is perfect
p28329
aVBecause  contains just a single 32 bit integer you can use  to copy it straight to an  array
p28330
aVSo, when the Delphi DLL returns, you can do the final marshalling step using
p28331
aVThat deals with the dynamic array, but as it happens you have another problem with your code as it stands
p28332
aVYou are declaring the two strings as  in the C# struct
p28333
aVThis means that the marshaller will take responsibility for freeing the memory returned by the Delphi DLL in the two  fields
p28334
aVIt will do so by calling
p28335
aVI'm fairly sure that's not going to match the allocation of the  fields made in the Delphi code
p28336
aVAs stated above, I would expect that the contract for this interface is that you call a further DLL function to deallocate the heap memory referenced by the  struct
p28337
aVThat is, the two strings, and the dynamic array
p28338
aVTo deal with this issue from C# you need to make sure that the marshaller does not attempt to deallocate the  fields
p28339
aVYou can achieve that by declaring them as  in the C# struct
p28340
aVThen call  to convert to a C# string
p28341
aVI've had to make a few assumptions about the contract between the Delphi code and the C# code in order to write the above
p28342
aVIf any of my assumptions are incorrect please update the question and I'll try to make this answer match
p28343
aVI hope this helps
p28344
as(dp28345
g7
V505088
p28346
stp28347
a((dp28348
g2
(lp28349
VOn Vista and up a number of new functions were added that make this task trivial
p28350
aVThe function that is most appropriate here is
p28351
aVThis function will first search the icon file for an icon having exactly the same size
p28352
aVIf a match is not found, then unless both cx and cy match one of the standard icon sizes\u201416, 32, 48, or 256 pixels\u2014 the next largest icon is selected and then scaled down to the desired size
p28353
aVFor example, if an icon with an x dimension of 40 pixels is requested by the callign application, the 48-pixel icon is used and scaled down to 40 pixels
p28354
aVIn contrast, the LoadImage function selects the 32-pixel icon and scales it up to 40 pixels
p28355
aVIf the function is unable to locate a larger icon, it defaults to the standard behavior of finding the next smallest icon and scaling it up to the desired size
p28356
aVIn my experience this function does an excellent job of scaling and the results show no signs of aliasing
p28357
aVFor earlier versions of Windows there is, to the very best of my knowledge, no single function that can perform this task adequately
p28358
aVThe results obtained from  are of very poor quality
p28359
aVInstead the best approach I have found is as follows:
p28360
aVExamine the available images in the resource to find the image with the largest size that is less than desired icon size
p28361
aVCreate a new icon of the desired size and initialise it to be fully transparent
p28362
aVPlace the smaller icon from the resource in the centre of the new (larger) icon
p28363
aVThis means that there will be a small transparent border around the icon, but typically this is small enough to be insignificant
p28364
aVThe ideal option would be to use code that could scale down just as  does, but that is non-trivial to write
p28365
aVSo, without further ado here is the code I use
p28366
aVUsing these function is quite obvious
p28367
aVThey assume that the resource is located in the same module as the code
p28368
aVThe code could readily be generalised to receive an  in case you needed support for that level of generality
p28369
aVCall  if you wish to load icons of size equal to the system small icon or system large icon
p28370
aVThe  parameter should be either  or
p28371
aVFor toolbars, menus and notification icons,  should be used
p28372
aVIf you wish to specify the icon size in absolute terms use
p28373
aVThese functions return an
p28374
aVYou can of course assign this to the  property of a  instance
p28375
aVMore likely you will wish to add to an image list
p28376
aVThe easiest way to do this is to call  passing the  of the  instance
p28377
aVNote 1: Older versions of Delphi do not have  defined in
p28378
aVFor such Delphi versions you need to call  to load it
p28379
aVNote that this is a Unicode only API and so you must send it a  for the resource name
p28380
aVLike this:
p28381
aVNote 2: The definition of  is flawed
p28382
aVIf you call it after the common controls library has been initialised then you will have no problems
p28383
aVHowever, if you call the function early on in the life of your process then  can fail
p28384
aVI have just submitted QC#101000 to report this problem
p28385
aVAgain, if you are afflicted by this then you have to call  yourself
p28386
as(dp28387
g7
V505088
p28388
stp28389
a((dp28390
g2
(lp28391
VSince C does not support exceptions you don't have any real option other than to return an error code
p28392
aVA failing C  results in  being called which bombs the process
p28393
aVThat's not really comparable with standard error handling
p28394
aVFor floating point operations you can use  to signal error conditions
p28395
aVFor integer operations an error code is simply your only option
p28396
as(dp28397
g7
V505088
p28398
stp28399
a((dp28400
g2
(lp28401
VServices have to have a unique name
p28402
aVYou should register your test service with a different name from the true service
p28403
as(dp28404
g7
V505088
p28405
stp28406
a((dp28407
g2
(lp28408
VThis is what is known as a Method Resolution Clause
p28409
aVTo quote from the documentation:
p28410
aVYou can override the default name-based mappings by including method resolution clauses in a class declaration
p28411
aVWhen a class implements two or more interfaces that have identically named methods, use method resolution clauses to resolve the naming conflicts
p28412
as(dp28413
g7
V505088
p28414
stp28415
a((dp28416
g2
(lp28417
VIf you know how to use , then there's nothing much more to learn about
p28418
aVUse it in exactly the same way
p28419
aVThe only difference you need to be aware of is that any modifications you make are cached in the memory and not written to the file immediately
p28420
aVWhen you are ready to write them to the file just call
p28421
aVThat really is all there is to know
p28422
as(dp28423
g7
V505088
p28424
stp28425
a((dp28426
g2
(lp28427
V@a1ex07 has addressed some of the issues with your current code
p28428
aVHowever, as I stated in comments, I think your code could be implemented more effectively with some more significant changes
p28429
aVI believe you have the following problems:
p28430
aVYou are allocating a buffer on the heap and failing to free it
p28431
aVYour buffer is rather small
p28432
aVIt would likely be more efficient to use a larger buffer
p28433
aVThe use of  and , C string oriented functions is inappropriate for what is a byte-by-byte copy operation
p28434
aVI would write it like this:
p28435
aVNote that this function has no error checking
p28436
aVNeither did yours
p28437
aVI'll leave it to you to add that if you wish
p28438
aVAlso, I've only compiled this in my head
p28439
aVIf there are any glitches I'm sure you can sort them out
p28440
as(dp28441
g7
V505088
p28442
stp28443
a((dp28444
g2
(lp28445
VThe issue is UAC
p28446
aVThis is an operation that requires elevation
p28447
aVAlthough the user is in the administrators group, the process is given a standard user token by default
p28448
aVThe solution is to add the  option to your application's manifest so that the application invokes the UAC elevation dialog
p28449
as(dp28450
g7
V505088
p28451
stp28452
a((dp28453
g2
(lp28454
VIn genral there will be no difference because the compiler expands the instantiated template into the same code as if you wrote it out yourself without templates
p28455
aVIn other words the templates are processed at compile time and not runtime
p28456
as(dp28457
g7
V505088
p28458
stp28459
a((dp28460
g2
(lp28461
VIt is indefined behaviour as you write it since you are accessing the array out-of-bounds
p28462
aVHowever, negative indices do not necessarily mean undefined behaviour
p28463
aVThe following code is well defined:
p28464
aVThis is equivalent to:
p28465
as(dp28466
g7
V505088
p28467
stp28468
a((dp28469
g2
(lp28470
Vis declared with type
p28471
aVThe return value of  is of type
p28472
aVcasts the return value of  to be of type
p28473
aVIn the C++ language this type cast is essential, although in C++ one would normally not be using  and would probably be using C++ casts
p28474
aVIn the C language the type cast is not needed because a  pointer is assignment compatible with all other pointer types
p28475
aVIn a comment you state
p28476
aVBut I want know how  is different from
p28477
aVand I suspect that this is in fact your real question
p28478
aVThe answer is simple enough:  is a pointer-to-T and  is a pointer-to-pointer-to-T
p28479
as(dp28480
g7
V505088
p28481
stp28482
a((dp28483
g2
(lp28484
VUse std::vector<> and you don't need to handle the allocation at all
p28485
aVJust iterate and add to the vector when you need to
p28486
aVIt will grow dynamically to accommodate its contents
p28487
as(dp28488
g7
V505088
p28489
stp28490
a((dp28491
g2
(lp28492
VSegmentation fault means that you are accessing memory which you don't have rights to
p28493
aVIt is usually due to a bounds error on an array or a stale pointer, e
p28494
ag217
aVaccess after free
p28495
aVCalling sleep seems exceedingly unlikely to be related to this unless you are using sleep as a synchronization tool
p28496
aVYou could use valgrind to track down your error
p28497
as(dp28498
g7
V505088
p28499
stp28500
a((dp28501
g2
(lp28502
VOn a 64 bit OS the system32 directory is for 64 bit processes and the SysWOW64 directory is for 32 bit processes
p28503
aVRead that sentence one more time since it is rather counter-intuitive
p28504
aVThe File System Redirector ensures that a process that attempts to access system32 is redirected to the appropriate directory
p28505
aVIf your process is 32 bit then when it writes to system32, the redirector results in the file/directory being created under SysWOW64
p28506
aVUpdate 1 Apparently UAC is disabled
p28507
aVIn this case your writes to system32 from a 32 bit process will be producing output under SysWOW64
p28508
aVRather than checking that UAC is disabled, you should just add the  option to your manifest
p28509
aVUpdate 2 In the comments you state that you want to change the logon screen's background
p28510
aVIn order to do that you'll need to work with the native 64 bit directory since Explorer is a 64 bit process on a 64 bit OS
p28511
aVYou have a number of options to achieve that:
p28512
aVTarget AnyCPU so that you run as a 64 bit process under 64 bit OS
p28513
aVThis is easily the simplest approach
p28514
aVWrite to \u005cWindows\u005csysnative if you find yourself running on a 64 bit OS
p28515
aVThis the sneaky way for a 32 bit process to name the otherwise un-speakable 64 bit system32 folder
p28516
aVDisable the file system redirector (not really to be recommended)
p28517
as(dp28518
g7
V505088
p28519
stp28520
a((dp28521
g2
(lp28522
VYou have two string literals of type
p28523
aVThese can be assigned to a variable of type , which is nothing more than a pointer to a
p28524
aVWhenever you declare a variable of type pointer-to-T you are only declaring the pointer, and not the memory to which it points
p28525
aVThe compiler reserves memory for both literals and you just take your pointer variable and point it at those literals one after the other
p28526
aVString literals are read-only and their allocation is taken care of by the compiler
p28527
aVTypically they are stored in the executable image in protected read-only memory
p28528
aVA string literal typically has a lifetime equal to that of the program itself
p28529
aVNow, it would be UB if you attempted to modify the contents of a literal, but you don't
p28530
aVTo help prevent yourself from attempting modifications in error you would be wise to declare your variable as
p28531
as(dp28532
g7
V505088
p28533
stp28534
a((dp28535
g2
(lp28536
VThere is no equivalent in the MS compiler to this non-standard GCC language extension
p28537
as(dp28538
g7
V505088
p28539
stp28540
a((dp28541
g2
(lp28542
VOn XE2 a new class was introduced to deal with this:
p28543
aVRead  to check for 32 or 64 bit OS
p28544
aVRead  to check for Windows or Mac
p28545
aVRead  and  for version numbers
p28546
aVRead  to obtain the basic product name, e
p28547
ag217
aVWindows 7
p28548
aVRead  to obtain the full product name with version, e
p28549
ag217
aVWindows 7 Service Pack 1 (Version 6
p28550
aV1, Build 7601, 64-bit Edition)
p28551
aVFor older versions of Delphi I recommend the following:
p28552
aVIn order to check for 2000, XP, Vista, 7 I suggest you read  and
p28553
aVmajor
p28554
aVminor = 5
p28555
aV0 => Windows 2000
p28556
aVmajor
p28557
aVminor = 5
p28558
aV1 => Windows XP
p28559
aVmajor
p28560
aVminor = 5
p28561
aV2 => Windows 2003 server or XP64
p28562
aVmajor
p28563
aVminor = 6
p28564
aV0 => Windows Vista/2008 server
p28565
aVmajor
p28566
aVminor = 6
p28567
aV1 => Windows 7/2008 server R2
p28568
aVThe same information is available on MSDN, but the above came from my head
p28569
aVIf you are wanting very detailed product information then that takes a bit more work
p28570
aVWarren's answer gives one good route to obtaining that information
p28571
aVIf you are wanting to test capability then version numbers are fine
p28572
aVUse  to check if the prevailing OS exceeds a certain version level
p28573
aVAlthough you should check that the function works correctly in your Delphi since the implementation of that function in Delphi 6 and earlier was incorrect
p28574
aVTo find out what the native OS architecture is (32 or 64 bit), use the  function
p28575
aVThis function is not available on older operating systems so you should load it explicitly with
p28576
aVTest for  to check for 64 bit OS
p28577
as(dp28578
g7
V505088
p28579
stp28580
a((dp28581
g2
(lp28582
VThat function cannot be reversed
p28583
aVSince it takes input of arbitrary length and returns output of finite length, simple information theory tells you the futility of attempting to write a general inverse
p28584
aVEven for shorter input strings it seems to me that different input strings can result in the same encrypted string
p28585
aVEven as a hash this function seems very brittle to me due to the bizarre use of floating point code
p28586
aVIf I were you I would replace this function with something more fit for purpose
p28587
aVFinally, I recommend that you undertake a review of all code produced by this developer
p28588
aVThe low quality of this code and algorithm suggests to me that everything that this developer touched is liable to have defects
p28589
as(dp28590
g7
V505088
p28591
stp28592
a((dp28593
g2
(lp28594
VThat's not easy to achieve by introspection
p28595
aVYou could investigate the call stack but that is very non-portable and really not to be recommended
p28596
aVOne way to deal with this is to pass a parameter to control the variation of behaviour
p28597
aVThis has the addition benefit of making the function's behaviour more transparent and explicit
p28598
aVAs @blueshift points out, this can place a burden on external callers
p28599
aVSplitting the function into two versions, one for internal use and one for external use relieves that burden
p28600
aVIn light of your edit, I think the design is a little off
p28601
aVThe synchronization responsibility should either be internal to the function, or external
p28602
aVIt's very risky to make that responsibility sometimes be internal and sometimes be external
p28603
aVThat would be one way round the problem
p28604
aVAnother way around it would be to use recursive locks
p28605
as(dp28606
g7
V505088
p28607
stp28608
a((dp28609
g2
(lp28610
VThat field is the file name of the executable
p28611
aVThe only way to change it is to make copies of the executable with different names
p28612
aVI don't imagine you want to do that
p28613
aVI personally use Process Explorer as my task manager
p28614
aVWhen you hover over an entry in Process explorer, a hint window is displayed containing the command line passed to the process
p28615
aVYou could make use of this feature if you passed a benign ID parameter when you created each process
p28616
as(dp28617
g7
V505088
p28618
stp28619
a((dp28620
g2
(lp28621
VIf you want to allocate from the heap in one module, and free in another then you simply have to dynamically link the runtime
p28622
aVWhat's more, all parties must dynamically link the same runtime
p28623
aVOnce you do that then there will be no problems
p28624
aVNow, this is quite a severe constraint to impose on your plugins and you should think twice before doing it
p28625
aVForcing all plugin authors to upgrade in lock-step with you is a heavy imposition
p28626
aVI would recommend that you consider refactoring your interface so that allocations are always paired with deallocations within a single module
p28627
aVThis lifts the constraints I describe above and makes life easier for your plugin authors
p28628
aVAs for why you are still suffering from runtime errors, that's hard to tell
p28629
aVMy guess is that not all modules are linking against the same version of the runtime
p28630
aVIn the comments you state that you control all plugins
p28631
aVThat means the constraints I discuss above are not an imposition since it is easy for you to use the same compiler version for all modules
p28632
aVHowever, the rules for dynamic linking with cross-module heap access remain
p28633
aVYou must use dynamic linking against the same single version of the runtime
p28634
as(dp28635
g7
V505088
p28636
stp28637
a((dp28638
g2
(lp28639
VI think I would opt for the second option, mainly because I prefer to avoid RTTI unless it is the only possible solution to a problem
p28640
aVBut in both your proposed options you state that
p28641
aVthe object which is created here is not assigned to any interface variable
p28642
aVThat's simply not true
p28643
aVIn both cases you assign to  which has type
p28644
aVIf you have a memory leak, it is caused by some other code, not by this code
p28645
aVAnd @RRUZ has found the cause of the leak \u2013 namely using  which does not implement reference counted lifetime management
p28646
aVYour code won't leak for
p28647
aVFor what it is worth, I would assign directly to the interface variable rather than via an object reference, but that is just a matter of stylistic preference
p28648
as(dp28649
g7
V505088
p28650
stp28651
a((dp28652
g2
(lp28653
VR is not that kind of language
p28654
aVThere is no notion of private or public
p28655
as(dp28656
g7
V505088
p28657
stp28658
a((dp28659
g2
(lp28660
VIt's a bug in the Delphi control which I have reproduced
p28661
aVI'm not sure yet what causes the bug
p28662
aVI have submitted this to Quality Central as QC#101104
p28663
aVI found a simple workaround by adding the following code to the form's  event
p28664
aVThe following DFM file is enough to demonstrate the problem:
p28665
aVIt turns out that another way to resolve the problem is to move the  entry in the DFM file so that it appears before the  entry
p28666
aVSo yet another workaround for the problem would be to add the items at runtime
p28667
aVIn fact this probably explains why this bug has not been found since I bet that the overwhelming majority of list view code adds the items at runtime
p28668
as(dp28669
g7
V505088
p28670
stp28671
a((dp28672
g2
(lp28673
VPDF files are generally compressed binary files and so cannot be read as UTF8
p28674
aVDoing so will lead to codec errors
p28675
aVRemember that not all sequences of bytes are valid UTF8 sequences
p28676
aVIt looks like you just need to call CopyFile instead of your complex stream based code, but perhaps this is just a cut down sample
p28677
as(dp28678
g7
V505088
p28679
stp28680
a((dp28681
g2
(lp28682
VIt depends
p28683
aVI don't think there is any single blanket requirement
p28684
aVLet us consider the two examples you give, in the context of
p28685
aVThis parameter is marked with the annotation
p28686
aVThis means that the information is being passed from the caller to
p28687
aVIn that case it is the caller's responsibility to ensure that all fields are suitably initialized
p28688
aVA simple and common way to do so is to initialize the entire structure to zero and then modify just the fields that you want to be different from zero
p28689
aVThis parameter is marked with the annotation
p28690
aVThis means that the information is being passed from  to the caller
p28691
aVAny initialization you perform before calling is ignored
p28692
aVThe contract is that  will not read the contents of the structure that you pass, but will fully initialize that structure
p28693
aVIn such instances I believe it is pointless to zero initialize the structure before passing it to
p28694
aVOf course, if  fails then the values returned are undefined and you should not read them
p28695
aVBut even if you have zero initialized the process information structure before calling, you have no guarantee that  will not have partially written to it
p28696
aVIn case an API function fails, you simply should not read anything returned by it, unless the documentation states otherwise
p28697
aVSummary
p28698
aVIn summary I would advise you to initialize all the input values passed to a function, and not to initialize the output values
p28699
as(dp28700
g7
V505088
p28701
stp28702
a((dp28703
g2
(lp28704
VIn XE2 (and indeed all the recent releases) you don't need to do anything
p28705
aVThe standard controls support mouse wheel scrolling out of the box
p28706
aVJust get rid of this old code
p28707
as(dp28708
g7
V505088
p28709
stp28710
a((dp28711
g2
(lp28712
VDon't ask me why, but you can make this work in old versions of Delphi by setting the  to  immediately after you create the  instance:
p28713
aVThis answer was inspired by the modern versions of the Delphi VCL source
p28714
as(dp28715
g7
V505088
p28716
stp28717
a((dp28718
g2
(lp28719
VUnless you know something more about the file, you can't access specific lines at random
p28720
aVNew lines are delimited by the presence of line end characters and they can, in general, occur anywhere
p28721
aVText files do not come with a map or index that would allow you to skip to the nth line
p28722
aVIf you knew that, say, every line in the file was the same length, then you could use random access to jump to a particular line
p28723
aVWithout extra knowledge of this sort you simply have no choice but to iterate through the entire file until you reach your desired line
p28724
as(dp28725
g7
V505088
p28726
stp28727
a((dp28728
g2
(lp28729
VStarting a process from a service is certainly possible
p28730
aVHowever, services run inside session 0 and have no desktop
p28731
aVInteractive users run their desktops in a different session
p28732
aVConsequently it is very challenging to get a process up and running inside an interactive session when starting from a service
p28733
aVFor an illustration of the issues involved, and how tricky it is to get right, read this: Launching an interactive process from Windows Service in Windows Vista and later
p28734
aVThe simplest approach would be to separate your service into two distinct parts
p28735
aVOne part runs as a service, and the other part runs as a windowless process in the interactive session
p28736
aVThese two processes can communicate by whatever IPC mechanism you prefer
p28737
aVWhen the service wants to start a process it simply sends a message to its other half in the interactive session to request that the new process is started
p28738
as(dp28739
g7
V505088
p28740
stp28741
a((dp28742
g2
(lp28743
V is an integer type, a value type, and is not a class
p28744
aVAccordingly it is does not need to be freed
p28745
aVThe definition of  is
p28746
aVSo your array is pretty much equivlent, for the purposes of alloction, to
p28747
aVThe elements of such an array do not need to be freed
p28748
aVThe array itself will be freed automatically, no matter where you declare it (global, local, class member, record member)
p28749
aVIt is also a value type
p28750
aVThe best clue that you don't need to free  is that you never created it in the first place
p28751
aVAllocations and deallocations are always paired
p28752
aVAs an aside, you should never call  directly
p28753
aVYou write  in code only when implemented the overridden destructor for a class, i
p28754
ag192
aVlike this:
p28755
aVWhen you come to destroy an object you should call  on it
p28756
aVDo not call  directly
p28757
aVWhy not
p28758
aVWell,  is implemented like this:
p28759
aVThe  statement means that if you have an object reference that is , then it is safe to call  on it without fear of an exception being raised
p28760
aVThis is important in case an exception is raised in a constructor
p28761
aVWhen that happens the destructor is called
p28762
aVIf the constructor has only partially completed, then some fields will still be
p28763
aVCalling  allows us to write clean destructor code
p28764
aVWithout this convenience all our destructors would look like this:
p28765
as(dp28766
g7
V505088
p28767
stp28768
a((dp28769
g2
(lp28770
VYou don't need to use a fully qualified path
p28771
aVWhen IE is installed it registers itself in the App Paths registry
p28772
aVConsequently you just need to send  to
p28773
aVNote:  does not use the App Paths mechanism so you must use  rather than
p28774
as(dp28775
g7
V505088
p28776
stp28777
a((dp28778
g2
(lp28779
VThe simplest way to do this is to add a registry entry like this:
p28780
aVWhen the user clicks on this menu item your app will be executed and passed the file name as the first command line argument
p28781
aVWhilst you can write a shell extension for this, that is more difficult
p28782
aVWhat's more, if you are using Delphi 7 then you will not be able to write a shell extension for 64 bit Windows
p28783
as(dp28784
g7
V505088
p28785
stp28786
a((dp28787
g2
(lp28788
VThat is a relative path and the preprocessor will look for the file in a directory called
p28789
aVPrecisely where that directory is depends on your compiler options
p28790
aVFor example the MS compiler searches like this:
p28791
aVThis form instructs the preprocessor to look for include files in the same directory of the file that contains the #include statement, and then in the directories of any files that include (#include) that file
p28792
aVThe preprocessor then searches along the path specified by the /I compiler option, then along paths specified by the INCLUDE environment variable
p28793
aVYou may need to consult the documentation for your particular tools to learn how the search is done
p28794
as(dp28795
g7
V505088
p28796
stp28797
a((dp28798
g2
(lp28799
VIs there a way to declare a constant "pair" data type so that the contained array sizes are determined by the constant array definition
p28800
aVNo, sadly this is not possible
p28801
aVYou have to declare the size of your array inside the square brackets
p28802
as(dp28803
g7
V505088
p28804
stp28805
a((dp28806
g2
(lp28807
VYou can't pass Delphi objects across DLL boundaries
p28808
aVIt simply does not work
p28809
aVThere is no mechanism to export a Delphi class from a DLL
p28810
aVYou are aware of this but passing a handle across the boundary does not help
p28811
aVYou wish to operate on a  on the other side of the boundary
p28812
aVBut the only  instance that can make sense is the only which created the handle, and that instance is trapped by the module boundary
p28813
aVThere are some objects which can be recreated from just a handle
p28814
aVFor example, bitmaps and icons have this property
p28815
aVThis is because they have no state beyond what is stored in the GDI handle
p28816
aVMore complex VCL objects do have such state and therein lies the problem
p28817
aVYour options are:
p28818
aVUse packages
p28819
aVThis works a treat but you must use the same compiler version for all modules
p28820
aVUse interfaces or COM
p28821
aVThis gives you freedom of mixing compiler versions and even different languages
p28822
as(dp28823
g7
V505088
p28824
stp28825
a((dp28826
g2
(lp28827
VIf you want each statement to execute then you have to write it the way you have done
p28828
aVNote that in that case may not need the try/finally because you are swallowing all the exceptions
p28829
aVHowever, the code does look a bit odd to me
p28830
aVI wonder if you really need each and every statement to execute
p28831
aVNormally you would write:
p28832
aVThen, if there is an exception in , the other two lines will not execute
p28833
aVHowever, it would be even more common not to handle exceptions at all and let them float up to some higher level handler
p28834
aVIf you are making routine logic decisions using exceptions then that would be considered bad practice
p28835
aVI think it would be helpful for you to publish some of your code that handles the exceptions and some details of what exceptions you are expecting to occur
p28836
aVThen we could give you some more specific advice
p28837
as(dp28838
g7
V505088
p28839
stp28840
a((dp28841
g2
(lp28842
VIn order to run a progress bar you have to be able to quantify the progress of the long running task
p28843
aVYou have nothing in the code that attempts to quantify this
p28844
aVYou would need there to be communication between the two processes in order to make this progress bar work well
p28845
aVIn other words the external process needs to send messages back to the parent app informing the parent app of the measure of progress
p28846
aVNow, that can be hard to achieve so a marquee style progress bar may be more appropriate
p28847
as(dp28848
g7
V505088
p28849
stp28850
a((dp28851
g2
(lp28852
VThere is probably some further dependency that is failing
p28853
aVMy guess is that  itself has dependencies on other libraries that are missing on the failing machine
p28854
aVThe documentation of  should explain what dependencies are needed
p28855
aVIf the documentation does not make it obvious what is missing, you can diagnose the problem yourself using Dependency Walker
p28856
as(dp28857
g7
V505088
p28858
stp28859
a((dp28860
g2
(lp28861
VThis square bracket notation is used to denote optional arguments
p28862
aVYou can omit them if you wish and thus invoke default behaviour
p28863
aVThe optional arguments will always be described in the documentation
p28864
aVNote that the square brackets used in the documentation are not part of Python itself
p28865
aVYou can never write that in a Python program
p28866
aVIt is purely a notational convention used in documentation
p28867
as(dp28868
g7
V505088
p28869
stp28870
a((dp28871
g2
(lp28872
VI was reading in MSDN that a List is thread safe when used as a public static type
p28873
aVThat statement is not true
p28874
aVYou probably are referring to this text:
p28875
aVPublic static members of this type are thread safe
p28876
aVThat refers to members of the class
p28877
aVIt does not refer to instances of the class
p28878
as(dp28879
g7
V505088
p28880
stp28881
a((dp28882
g2
(lp28883
VI think you already know the answer to this
p28884
aVWindows have thread affinity
p28885
aVAll operations on a window should be performed from the thread that created it
p28886
aVGiven this rule, I can't imagine that the DLL is responsible for moving window access onto a different thread and presume it is your code that does it
p28887
aVThe solution is for you to create and access the window in the same thread that calls the DLL
p28888
as(dp28889
g7
V505088
p28890
stp28891
a((dp28892
g2
(lp28893
VYou are probably just missing the multiplication by 100 to convert to percent:
p28894
aVAssuming  takes values between  and  then your code will always set the progress bar value to  or
p28895
aVShould I use  and  or set  in the second thread to show/hide the progress bar
p28896
aVWhatever you do in the second thread you should not call methods of a GUI control
p28897
aVUse  or  to marshal onto the GUI thread
p28898
as(dp28899
g7
V505088
p28900
stp28901
a((dp28902
g2
(lp28903
VVectors are contiguous
p28904
aVThey must have elements at each index from 0 to size-1
p28905
aVThere cannot be any gaps
p28906
aVThus you cannot insert at an index outside the current bounds of the vector because that would leave holes
p28907
aVSo, if you want to insert at index 10, you have to first ensure that the list is populated with at least 10 items
p28908
aVYou can use setSize to do this (emphasis mine):
p28909
aVSets the size of this vector
p28910
aVIf the new size is greater than the current size, new null items are added to the end of the
p28911
aVvector
p28912
as(dp28913
g7
V505088
p28914
stp28915
a((dp28916
g2
(lp28917
VThe only way I can see that this approach would fail is if you are transforming every point on the perimeter
p28918
aVIf you are doing that, don't
p28919
aVTransform the corners and draw lines between each corner using graphics primitives
p28920
aVUpdate: Your comment gives the game away
p28921
aVYou are rotating repeatedly and accumulating errors every time you digitise by converting to integer
p28922
aVDeal with that by storing your coordinates as double precision values and just convert to integer on demand when you need to draw
p28923
aVIn fact, if I were you I would treat your master data to be a position and an angle, both stored to double precision
p28924
aVI would not store the coordinates of the corners at all
p28925
aVI would store a position (center or one of the corners) and an orientation angle (relative to a fixed global axis system)
p28926
aVThat way you will always draw a true rectangle
p28927
aVAt each integration step increment position and orientation as necessary and then calculate the position of the corners from the master data
p28928
aVDo it like this and you will never suffer from distortion of your shape
p28929
as(dp28930
g7
V505088
p28931
stp28932
a((dp28933
g2
(lp28934
VIt sounds like you know the user's credentials
p28935
aVIf so you should call
p28936
aVHowever, from C# it is simpler to use the  and  properties of
p28937
as(dp28938
g7
V505088
p28939
stp28940
a((dp28941
g2
(lp28942
VWhilst you can use a  declaration, it would be much clearer to pass  as a parameter
p28943
aVGlobal variables are considered to bad practice and where there are good methods to avoid using them you should avail yourself of those methods
p28944
as(dp28945
g7
V505088
p28946
stp28947
a((dp28948
g2
(lp28949
VIt's implementation specific, but I know of no commonly used platform which shrinks committed stack memory
p28950
aVIt is common for stacks to grow on demand but once space is committed it stays committed
p28951
as(dp28952
g7
V505088
p28953
stp28954
a((dp28955
g2
(lp28956
VIn the first sample you are allocating 4 bytes per color component
p28957
aVFor 8 bit color you should allocate just a single byte by using unsigned char
p28958
aVNo need for bitfields here
p28959
aVNote that you have defined a 24 bit pixel here
p28960
aVYou may need to add padding if you are using 32 bit pixels
p28961
as(dp28962
g7
V505088
p28963
stp28964
a((dp28965
g2
(lp28966
VThat would appear to be a bug in the Mac OS compiler
p28967
aVPlease can you submit a report to Quality Central
p28968
as(dp28969
g7
V505088
p28970
stp28971
a((dp28972
g2
(lp28973
VYou can't, using standard techniques, using just a pointer as input, determine where the end of the block lies
p28974
aVIn order to do that
p28975
aVyou would have to instrument your allocator or use an allocator that provided such functionality
p28976
aVWhen you allocate memory with  the responsibility is entirely down to you the programmer to keep track of how much memory you allocated
p28977
aVYou cannot ask the system, at some later point in time, to tell you any information about the memory block
p28978
as(dp28979
g7
V505088
p28980
stp28981
a((dp28982
g2
(lp28983
V is an extended window style that is documented on MSDN
p28984
aVIt is most definitely not deprecated and is a fully supported and widely used style
p28985
aVThe documentation states that the style:
p28986
aVForces a top-level window onto the taskbar when the window is visible
p28987
aVThis is a relatively bland statement that undersells the purpose of this style
p28988
aVNormally the property that forces a top-level window onto the taskbar is the fact that the top-level window is unowned
p28989
aVTop-level owned windows do not, by default, appear on the taskbar
p28990
aVSo, if for some reason you wish to put a top-level owned window onto the taskbar, then  is the solution
p28991
aVAlthough there is an MSDN article that describes the rules for which windows appear in the taskbar, it is not as clear as it should be
p28992
aVRaymond Chen's article describes it much more precisely:
p28993
aVThere are some basic rules on which windows go into the taskbar
p28994
aVIn
p28995
aVshort:
p28996
aVIf the WS_EX_APPWINDOW extended style is set, then it will show (when visible)
p28997
aVIf the window is a top-level unowned window, then it will show (when visible)
p28998
aVOtherwise it doesn't show
p28999
as(dp29000
g7
V505088
p29001
stp29002
a((dp29003
g2
(lp29004
VYou need to either get a Mac or install Mac OSX in a VM
p29005
as(dp29006
g7
V505088
p29007
stp29008
a((dp29009
g2
(lp29010
VYou are getting a bit confused here
p29011
aVIn fact  does return the key state at the instant that  was called
p29012
aVOn the other hand,  returns the key state based on the history of queued messages
p29013
as(dp29014
g7
V505088
p29015
stp29016
a((dp29017
g2
(lp29018
VJust so that the question has a coherent answer for any future visitors, the issue is the
p29019
aVThe following screenshot shows a reproduction of the behaviour described in the question
p29020
aVThis was generated with the following DFM file
p29021
as(dp29022
g7
V505088
p29023
stp29024
a((dp29025
g2
(lp29026
VI suspect the working directory is the Windows directory when you auto start an app
p29027
aVYou don't have permission to write there (unless you disable UAC)
p29028
aVI recommend you use a full absolute path when you open your file rather than a relative path as at present
p29029
aVUse SHGetSpecialFolderPath to find the location of an appropriate folder,
p29030
as(dp29031
g7
V505088
p29032
stp29033
a((dp29034
g2
(lp29035
VA Python program will not give different answers to that obtained at the console, provided that the same calculation is performed on the same input data
p29036
aVI think therefore that if you check carefully you will see that the values used in the program differ slightly from those used on the console
p29037
aVWith the numbers you give the calculation will indeed return precisely zero so I think you'll find that the numbers used in the program are not quite what you believe them to be
p29038
aVAll the same, floating point is not exact
p29039
aVIt is accurate only to finite precision
p29040
aVOnce you start performing arithmetic you should make your comparisons to a specified tolerance rather than exact
p29041
aVTo test for zero you should check that the absolute value of the result is less than some small value of your choosing
p29042
as(dp29043
g7
V505088
p29044
stp29045
a((dp29046
g2
(lp29047
VThis has been possible for a long time with layered windows
p29048
aVUse the   and  window states
p29049
aVYou will want to ensure that the z-order of the window puts it underneath all other top-level windows
p29050
aVThe article I link to has a number of code samples to get you going
p29051
aVAfter I added this answer you added a further requirement that the text be drawn beneath the icons on the desktop
p29052
aVI suspect that this is not possible with layered windows since layered windows cannot be child windows
p29053
as(dp29054
g7
V505088
p29055
stp29056
a((dp29057
g2
(lp29058
VI think you are using the wrong tool to build this
p29059
aVRather than trying to drive the IDE from the command line you should simply use msbuild
p29060
aVIn order to set your environment up for the specific version of MSVC you need to call the vcvar
p29061
aVbat file from that specific version
p29062
aVThis will set up the necessary environment variables needed by the build tools
p29063
as(dp29064
g7
V505088
p29065
stp29066
a((dp29067
g2
(lp29068
VIf you are using
p29069
aVnet 4 you should make use of the  enumeration
p29070
aVPass  when you call
p29071
aVUse   as your key and let the redirector do the work
p29072
aVIf you are using an older version of
p29073
aVnet then I am afraid you will need to p/invoke the native Win32 API
p29074
aVIf you happen to be targetting x86 then you don't need to do anything
p29075
aVThe registry redirector will do the right thing and redirect your registry access to the 32 bit view of the registry
p29076
aVYou only need to take the steps outline above from a 64 bit process
p29077
as(dp29078
g7
V505088
p29079
stp29080
a((dp29081
g2
(lp29082
VYou cannot do what you are hoping to do
p29083
aVThe string stream's data is a Delphi string which is stored as a single memory block
p29084
aVMemory blocks are atomic, they cannot be split
p29085
aVYou cannot free some part of a memory block
p29086
aVIf you really need to return memory to the memory manager then you should create a new string with the already processed data removed
p29087
aVYou can then re-create your string stream with this new input and destroy the previous string stream
p29088
aVHaving said that, it's hard to see that doing much other than increasing your memory fragmentation
p29089
aVIf the sizes of memory involved are large enough, and if the string stream persists for long enough, then this just might be a sensible approach
p29090
aVOtherwise it sounds like an attempt to optimise that actually would hinder performance
p29091
aVPerhaps some class other than string stream could be more appropriate but it's very hard to advise without knowing more details
p29092
as(dp29093
g7
V505088
p29094
stp29095
a((dp29096
g2
(lp29097
VCasting is generally a bad idea
p29098
aVCasting when you don't need to is terrible practice
p29099
aVThink what happens if you change the type of the variable you are casting
p29100
aVSuppose that at some future date you change  to be  rather than
p29101
aVYour code will still compile but will behave incorrectly
p29102
aVOne of your primary goals when writing C code is to minimise the number of casts in your code
p29103
as(dp29104
g7
V505088
p29105
stp29106
a((dp29107
g2
(lp29108
VThe value returned in  includes the null-terminator
p29109
aVAnd you are thus including it in the
p29110
aVWhen the string is send to the Windows edit control behind the , the string is passed as a null-terminated string
p29111
aVAnd so the stray null from the user name terminates the data transfer
p29112
aVChange the code like this:
p29113
aVYou should also check the return value of  in case there is an error, but I will leave that detail to you
p29114
as(dp29115
g7
V505088
p29116
stp29117
a((dp29118
g2
(lp29119
VYour problem here appears to me to be unrelated to using Sharemem or passing  to an  parameter
p29120
aVIt is simply a calling convention mismatch
p29121
aVYou export as  but then import as
p29122
aVWhenever you do that, runtime errors are sure to follow
p29123
aVYou need to do it like this:
p29124
aVAnd for what it is worth, you don't need Sharemem here
p29125
aVYou only need that when you allocate memory in one module but free it in a different one
p29126
aVAnd passing  to an  parameter in a DLL is not a problem
p29127
aVYou do this all then time when you call Windows API functions
p29128
as(dp29129
g7
V505088
p29130
stp29131
a((dp29132
g2
(lp29133
VYou can use the Group Policy API
p29134
as(dp29135
g7
V505088
p29136
stp29137
a((dp29138
g2
(lp29139
VSince you are running inside Excel, it is unrealistic to expect that Excel be run with administrator privileges
p29140
aVTherefore you need to separate the actions that require admin rights into a separate executable, apply the  manifest to the executable, and then invoke the executable from your plugin
p29141
as(dp29142
g7
V505088
p29143
stp29144
a((dp29145
g2
(lp29146
VYou are right that they both allocate memory from a heap
p29147
aVBut there are differences:
p29148
aVis portable, part of the standard
p29149
aVis not portable, it's a Windows API function
p29150
aVIt's quite possible that, on Windows,  would be implemented on top of
p29151
aVI would expect  to be faster than
p29152
aVhas more flexibility than
p29153
aVIn particular it allows you to specify which heap you wish to allocate from
p29154
aVThis caters for multiple heaps per process
p29155
aVFor almost all coding scenarios you would use  rather than
p29156
aVAlthough since you tagged your question C++, I would expect you to be using
p29157
as(dp29158
g7
V505088
p29159
stp29160
a((dp29161
g2
(lp29162
VAlthough the error message reports that the  library is missing, you are adamant that it is present in the same directory as the executable
p29163
aVThus it seems likely that one of the OpenCV dependencies is failing
p29164
aVThe most likely and plausible cause for this is the the Visual C++ redistributable package has not been installed on the target machine
p29165
as(dp29166
g7
V505088
p29167
stp29168
a((dp29169
g2
(lp29170
VStandard practice on Linux is not to redistribute your dependencies
p29171
aVDoing so just creates large amounts of duplication
p29172
aVYou should instead specify the dependencies in your installation package and let the package manager resolve them
p29173
as(dp29174
g7
V505088
p29175
stp29176
a((dp29177
g2
(lp29178
VBecause the parameters are passed by value
p29179
aVIn the first code sample all you do is swap local copies of the pointers
p29180
aVThe second example actually writes to the pointees
p29181
aVBetter still would be to use pass by reference and avoid heap allocation by using a stack allocated temp int
p29182
aVAs others have pointed out, both of your code samples leak memory because temp is never deleted
p29183
aVFor a simple int like this, just use a stack allocated local int variable for your temp
p29184
as(dp29185
g7
V505088
p29186
stp29187
a((dp29188
g2
(lp29189
VThere is no such keyword
p29190
aVYou can trivially change the visibility of a property by redeclaring it with a new visibility level
p29191
aVBut there is nothing analogous for a method
p29192
as(dp29193
g7
V505088
p29194
stp29195
a((dp29196
g2
(lp29197
V does not accept wildcards and indeed I believe that  does not either
p29198
aVWhat happens is that the shell expands the wildcards and then passes the resulting list of files/directories to
p29199
aVYou can do the same with junction by using a  loop
p29200
aVThat said, you talk about linking to files
p29201
aVBe aware that  does not do that
p29202
aVIt can only be used for creating directory symbolic links
p29203
as(dp29204
g7
V505088
p29205
stp29206
a((dp29207
g2
(lp29208
VThe problem is that the fonts on the computers that are failing do not have glyphs for the characters you are displaying
p29209
aVTypically this happens on XP machines
p29210
aVVista comes with much more complete fonts
p29211
aVYou may need to distribute fonts, or encourage users to install language packs, to ensure fidelity
p29212
as(dp29213
g7
V505088
p29214
stp29215
a((dp29216
g2
(lp29217
VYou can use  to undefine a symbol, equivalent to  in C and C++
p29218
aVThe facility to undefine a conditional is only applicable at a unit level and cannot be applied project wide
p29219
aVIn other words you cannot unset conditionals at the command line
p29220
aVThis is no different from the facilities offered by C or C++ toolsets
p29221
aVA very common approach is to locate all your conditional definitions in a shared  file which is then included at the head of every source file that relies on those definitions
p29222
aVIf you arrange things this way then you have all the flexibility that you need
p29223
aVI know it will be of little consolation, but more recent Delphi versions have much stronger support for configuration management
p29224
aVModern Delphi versions make use of the msbuild system
p29225
aVThey allow the same configuration options to be used in the IDE and on the command line
p29226
aVThere is flexibility to define, for example, debug and release build options and switch between them easily
p29227
aVI know I find it a great reassurance to know, for sure, that I am using the same build in the IDE as on the command line
p29228
aVI did not feel anywhere near so secure in legacy Delphi versions
p29229
as(dp29230
g7
V505088
p29231
stp29232
a((dp29233
g2
(lp29234
V is not a valid handle value
p29235
aVYou can discern this from the fact that some Windows API functions return  to indicate a failure
p29236
aVSince there is a single function to dispose of handles, , it follows that  is not a valid  value
p29237
aVHence  cannot ever return
p29238
aVRaymond Chen wrote a blog article touching on this topic: Why are HANDLE return values so inconsistent
p29239
aVNow, I know nothing about  so would like to make no comment on whether or not your idea is appropriate
p29240
aVI am merely answering the direct question that you asked
p29241
as(dp29242
g7
V505088
p29243
stp29244
a((dp29245
g2
(lp29246
VThe  variable is used by the system when loading executables
p29247
aVSo to get the underlying system to do the work for you I believe you would need to attempt to load an executable
p29248
aVIt doesn't sound like this is what you are looking to do
p29249
aVThere may well be some library that will offer such functionality but it is very simple to write your own
p29250
aVYou just need to use  and then iterate
p29251
as(dp29252
g7
V505088
p29253
stp29254
a((dp29255
g2
(lp29256
VYou can use
p29257
aVThis is very convenient, but the string is not copied by
p29258
aVThis means that if you modify it later, then you modify the environment
p29259
aVThat's not an issue for a literal, but the way you are forming your strings, using  is not readily compatible with
p29260
aVThe alternative then is to use
p29261
aVWith , copies of the input are made and you are safe to dispose of the strings after calling
p29262
as(dp29263
g7
V505088
p29264
stp29265
a((dp29266
g2
(lp29267
VThe rules for determining which windows have buttons on the taskbar are documented on MSDN
p29268
aVRaymond Chen gives the following summary of these rules:
p29269
aVThere are some basic rules on which windows go into the taskbar
p29270
aVIn
p29271
aVshort:
p29272
aVIf the WS_EX_APPWINDOW extended style is set, then it will show (when visible)
p29273
aVIf the window is a top-level unowned window, then it will show (when visible)
p29274
aVOtherwise it doesn't show
p29275
aVThe fact that you are trying to modify a window in another app severely hampers you
p29276
aVYou are removing the  extended style
p29277
aVThis is not enough because the window in question will be a top-level unowned window (see bullet point 2)
p29278
aVYou cannot change the owner of a window once it has been created and since the window is controlled by another process you are pretty much stuck
p29279
aVThe only option remaining is to remove the  extended style and replace it with
p29280
aVThis will indeed get the window off the taskbar but it will change the appearance of the window:
p29281
aVThe window is intended to be used as a floating toolbar
p29282
aVA tool window
p29283
aVhas a title bar that is shorter than a normal title bar, and the
p29284
aVwindow title is drawn using a smaller font
p29285
aVA tool window does not
p29286
aVappear in the taskbar or in the dialog that appears when the user
p29287
aVpresses ALT+TAB
p29288
aVIf a tool window has a system menu, its icon is not
p29289
aVdisplayed on the title bar
p29290
aVHowever, you can display the system menu
p29291
aVby right-clicking or by typing ALT+SPACE
p29292
as(dp29293
g7
V505088
p29294
stp29295
a((dp29296
g2
(lp29297
VYour update to the question reports that the call to  works when run from a standard app but fails when run from a service
p29298
aVThe issue is surely related to session 0 isolation of services
p29299
aVWith this information, I can think of the following explanations:
p29300
aVIn the context of the service, the  path is not available
p29301
aVCheck that you can create and open a text file here to see whether or not this diagnosis is true
p29302
aVSession 0 isolation is just incompatible with the  program
p29303
aVIf that is so then you will need to find another program to do the conversion
p29304
aVThat might be hard to do because it a program that processes EMF is liable to use GDI commands and they are very likely to fail in the context of a service
p29305
aVBy far the easiest solution will be to run this process as a standard application
p29306
aVI can see that this might not be a palatable prospect for what appears to be a server service
p29307
as(dp29308
g7
V505088
p29309
stp29310
a((dp29311
g2
(lp29312
VYou can get the buttons easily enough in Delphi 5 by iterating over the  property of the radio group
p29313
aVBut then what are you going to do to make them wrap
p29314
aVThe Delphi 5 radio button does not have a  property
p29315
aVIf I were you I would add a bunch of radio buttons to a group box rather than use a radio group
p29316
aVThis gives you control over exactly what class of radio button you create
p29317
aVThen derive your own radio button class and implement the  property
p29318
aVTo do this you need to add the  style in , just as modern Delphi versions do
p29319
aVOf course, the method outlined in your answer would work too
p29320
as(dp29321
g7
V505088
p29322
stp29323
a((dp29324
g2
(lp29325
VYou can use
p29326
aVOf course, if there is a chance that the searched for text will not be present then you need to write more lengthy code:
p29327
aVWhilst you can make some progress using code like this, more complex situations demand a true URL parser
p29328
as(dp29329
g7
V505088
p29330
stp29331
a((dp29332
g2
(lp29333
VTo convert from a
p29334
aVnet string to base 64, using UTF8 as the underlying encoding:
p29335
aVAnd to reverse the process:
p29336
aVIt is perfectly possible to skip the UTF8 step
p29337
aVHowever, UTF8 typically results in a smaller payload that UTF16 and so I would recommend using UTF8 as the underlying encoding
p29338
aVI'm not sure what you mean when you say that the user can enter UTF8 characters
p29339
aVThe
p29340
aVnet framework uses UTF16 as its working string encoding
p29341
aVThe strings you use in
p29342
aVnet are always encoded with UTF16
p29343
aVPerhaps you are just meaning that the text can contain non-ASCII characters
p29344
as(dp29345
g7
V505088
p29346
stp29347
a((dp29348
g2
(lp29349
VThe main problem is the fact that  has no contents defined in it
p29350
aVThe C# code marshals that as a field of size 1
p29351
aVThe Delphi compiler regards that as having size 0
p29352
aVAnd hence there is a mismatch between the two structures
p29353
aVThe C# code returns 260 for  whereas the Delphi compiler returns 8 for
p29354
aVIn the real code presumably there will be some actual content in that record and when you do that, everything will start to work
p29355
aVNote that @JMarsch and @Ken White make valid points too
p29356
aVYou will need to make sure that the enum is being marshalled correctly and that the  layouts match
p29357
aVBecause of the way structs are padded, you may get away without doing anything to your enum marshalling, but you may equally well be unlucky
p29358
as(dp29359
g7
V505088
p29360
stp29361
a((dp29362
g2
(lp29363
VIt sounds like you want to replace your
p29364
aVwith
p29365
aVThe  in your code is not necessary because this function must return values in the range 0 to 255 provided that  is in the range 0 to 100
p29366
aVI think I would apply the  to  (force it into range 0
p29367
aV0 to 100
p29368
aV0) and then use the following code:
p29369
aVYour first function returns an array whose first color is
p29370
aVMaybe you would be better with this:
p29371
aVThis gives the same behaviour at both ends of the array
p29372
aVOr perhaps you want both  and  included
p29373
aVThen you would use:
p29374
aVBut if you do this remember that Count must be greater than 1 otherwise you will be dividing by zero
p29375
aVThat nevers works out
p29376
aVDon't worry about the performance
p29377
aVThe code could be made slightly faster no doubt but it will certainly not be a bottleneck
p29378
aVYou will take these colors and draw with them
p29379
aVThat's going to consume vastly more resources than these simple routines
p29380
aVOne final point
p29381
aVInterpolation in RGB space will not look particularly smooth or linear to the human eye
p29382
aVUsing floating point percentage cannot evade that fact
p29383
aVFor best results when viewing you would need to interpolate in a different color space
p29384
as(dp29385
g7
V505088
p29386
stp29387
a((dp29388
g2
(lp29389
VGenerics won't help you here if these classes share no common ancestry
p29390
aVThe solution is to arrange that they do share common ancestry by declaring an interface with a  property
p29391
aVMake each class implement that interface and then you can have a single  function
p29392
as(dp29393
g7
V505088
p29394
stp29395
a((dp29396
g2
(lp29397
VBits do not have addresses
p29398
aVThat's why you can't refer to them by address
p29399
aVThe granularity of addressing is the
p29400
aVI guess the reasoning is that the language was design to match the architecture it targeted, and I know of no machine which allows addressing of individual bits
p29401
as(dp29402
g7
V505088
p29403
stp29404
a((dp29405
g2
(lp29406
VI'm not sure on what the conventions of your Fortran compiler are so I'll answer with some general points rather than specifics:
p29407
aVYour calling conventions don't match
p29408
aVThe Fortran code specifies stdcall and the ctypes code specifies cdecl
p29409
aVYou need to make them match up
p29410
aVFor example, change the ctypes to use  rather than
p29411
aVAre you sure that  is right
p29412
aVThat is a pointer to a pointer to null-terminated string
p29413
aVI think you probably have an extra layer of indirection at the Python end, but I'm not 100% sure of that
p29414
aV@eryksun states in a comment that the implicit string length parameter is passed by value rather than by reference
p29415
aVOtherwise I can't see anything wrong, although I know nothing whatsoever about Fortran so I can't vouch for that
p29416
aVIf I were you I would cut this right back to a trivial function that passes a single int parameter
p29417
aVThen I would add an int array and check that you can transfer data both ways for such a parameter
p29418
aVThen move up to a string
p29419
aVDon't attempt such a complicated parameter list from scratch because you just give yourself too many potential pitfalls and it's hard to know where to look first
p29420
as(dp29421
g7
V505088
p29422
stp29423
a((dp29424
g2
(lp29425
VThis line is wrong:
p29426
aVYou mean
p29427
aVIn fact I would change the window class initialisation code so that you make it very clear in the code that the entire struct is initialised
p29428
aVAnd you were missing some error checking:
p29429
aVStepping through under the debugger will allow you to see where in the process things are going wrong
p29430
as(dp29431
g7
V505088
p29432
stp29433
a((dp29434
g2
(lp29435
VI'm assuming that you want to allow health to be greater than 100% when a player gets some sort of power boost but that this bonus health does not show up in the health bar which just runs from 0 to 100%
p29436
aVDon't use the progress bar position property as the source data for the player's health
p29437
aVIt is limited to the range of the progress bar and so simply is not suitable to the task
p29438
aVInstead, use a distinct variable to maintain the player's health
p29439
aVThis value can go above 100 but when you update the progress bar position, you clip it into range of the progress bar
p29440
aVThe most important message, and this is really important, is that you need to get out of the habit of using visual controls to store state
p29441
aVStore the state in a model object and update the view based on the state in the model
p29442
as(dp29443
g7
V505088
p29444
stp29445
a((dp29446
g2
(lp29447
VWhen you use , the class takes care of all the details regarding memory allocation, pointers, resizing and so on
p29448
aVThe  class exposes its contents through iterators and references
p29449
aVMutations of the vector will potentially invalidate iterators and references because reallocation may be necessary
p29450
aVIt is valid to access the contents using pointers because the  class guarantees to store its elements at contiguous memory locations
p29451
aVClearly any mutation of the list will potentially invalidate any pointers to its contents, because of potential reallocation
p29452
aVTherefore, if you ever access an element using pointers, you must regard those pointers as invalid once you mutate the vector
p29453
aVIn short the same rules apply to pointers to the contents as do to references
p29454
aVIf you want to maintain a reference to an item in the vector, and have this reference be valid even after mutation, then you should remember the index rather than a pointer or reference to the item
p29455
aVIn that case it is perfectly safe to add to the end of the vector and your index value still refers to the same element
p29456
as(dp29457
g7
V505088
p29458
stp29459
a((dp29460
g2
(lp29461
VI infer from the equations that  is measured in seconds
p29462
aVSince you are extracting hours into a separate variable, you need to remove them from the minutes tally
p29463
aVAnd of course you need to follow this through the rest of the calculation since the meaning of  is changed from the original code
p29464
aVI think if I was writing this I would modify  as I was going along to reduce the duplication
p29465
aVDoing it this way makes it far easier to see what is going on and also easier to modify in future
p29466
aVFor example, if you wanted to add days into the mix then all you need to do is graft this onto the beginning of the code:
p29467
aVNow, I've written the code here assuming that  is a , which of course it is in your program
p29468
aVIf you were particularly paranoid you would write  before performing the arithmetic
p29469
aVBut I agree with @soulcheck that it's much cleaner to use a library function
p29470
as(dp29471
g7
V505088
p29472
stp29473
a((dp29474
g2
(lp29475
VThat's a linker error
p29476
aVConsult the documentation of the function
p29477
aVAt the bottom of that page (all such pages are laid out the same way) you will find the details of what header, lib and DLL are needed
p29478
aVIn this case you need to link against
p29479
as(dp29480
g7
V505088
p29481
stp29482
a((dp29483
g2
(lp29484
V can indeed fail, no matter when or where you call it
p29485
aVYou ought to take a rather pessimistic view when dealing with the API and be prepared for any API function to fail
p29486
aVAs you suggest, one possible reason for failure is exhaustion of system resources, e
p29487
ag217
aVkernel handles, GDI objects etc
p29488
aVSo you should always check for errors
p29489
aVAnd not just , every single call to an API function should have its return value checked
p29490
aVThe Windows API does not signal errors by raising exceptions
p29491
aVInstead the errors are always signalled through the values returned by the API function
p29492
aVYou need to consult the documentation to understand how each individual function reports errors
p29493
aVIf you encounter a failure in a GDI function like  then there's not a lot you can do
p29494
aVIn the scenario you describe I would log the error or report it to the user, and then terminate execution
p29495
aVThere's generally no recovery from a failure of
p29496
aVThe pain of checking for errors every time an API function is called is one of the reasons why we have so many frameworks that wrap the low level API
p29497
aVA good framework will do the error checking for you and convert any errors into exceptions
p29498
aVUsing a good framework allows you to concentrate on the normal flow of execution and not littering your code with handling code for exceptional cases
p29499
as(dp29500
g7
V505088
p29501
stp29502
a((dp29503
g2
(lp29504
VI find it hard to imagine situations where the code samples you give would have different performance characteristics
p29505
aVI do have a mild curiosity for you though
p29506
aVIn Pascal like languages (e
p29507
ag217
aVDelphi) the loop limits are evaluated only once
p29508
aVThis differs from the C like languages where the loop limits are evaluated each iteration
p29509
aVThis can have performance implications but of course its trivial to write performant code in C like languages by introducing a local outside the loop
p29510
aVFor example:
p29511
aVDelphi
p29512
aVis only evaluated once
p29513
aVC++
p29514
aVHere,  is called every time around the loop
p29515
aVIf it transpires that evaluating the loop limits is expensive then this difference can be relevant
p29516
aVNaturally it is trivial to evaluate  outside the loop and store the result in a local variable
p29517
aVHaving compared the  loops of Pascal and C/C++ I would say that the Pascal version is very simplistic in comparison
p29518
aVThis is not necessarily a bad thing because for more complex there is always  available
p29519
as(dp29520
g7
V505088
p29521
stp29522
a((dp29523
g2
(lp29524
VThat code correctly calculates the square of the Euclidean separation
p29525
aVPresumably it is a small number because the sample values have small magnitude
p29526
aVThere's absolutely no reason not to expect such a value
p29527
aVOnly you can know what the actual value means and what should be done with it
p29528
aVAs a matter of style, I would prefer for a variable to hold the same logical value for its lifetime
p29529
aVIn this code you write  which grates slightly
p29530
aVYou are using ssd to mean sum of squared distances, but when you write , that is no longer the sum of squared distances, it's the similarity measure
p29531
aVI'd write it like this:
p29532
as(dp29533
g7
V505088
p29534
stp29535
a((dp29536
g2
(lp29537
VThis is undefined behaviour (UB)
p29538
aVThe operands to + can be evaluated in any order
p29539
aVThe intent of your code relies on one particular order being chosen but your compiler is choosing the other evaluation order
p29540
aVUnlucky for you
p29541
aVThis experience should be enough to persuade you to avoid writing code like this
p29542
aVAs soon as you start causing side effects in expressions you must be careful to avoid UB
p29543
aVDon't be afraid of using a local temp variable when swapping
p29544
aVAnd be even less afraid of using the swap routine built into the standard library
p29545
aVOne final point
p29546
aVThe fact that you don't declare a variable does not mean that the generated code will not make use of a variable
p29547
aVIt may be in a register, but so what, where do you think a compiler is going to put your temp int in a swap function
p29548
as(dp29549
g7
V505088
p29550
stp29551
a((dp29552
g2
(lp29553
VProcesses can only access the interactive window station and desktops in the same session as the process
p29554
aVSo this means you need one process per session
p29555
as(dp29556
g7
V505088
p29557
stp29558
a((dp29559
g2
(lp29560
VThe MSDN topics that seem most pertinent are:
p29561
aVInside Windows 7:Introducing Libraries
p29562
aVWindows Libraries
p29563
aVWindows 7 Libraries: Developer Resources
p29564
aVThe library features are exposed through COM so there's no need for P/invoke
p29565
aVHowever, since libraries only exist in Windows 7, and since Windows 7 has
p29566
aVnet 3
p29567
aV5 as part of the OS, I would recommend that you put this part of your application in a
p29568
aVnet 3
p29569
aV5 assembly
p29570
aVIn fact the API CodePack assembly already does this for you
p29571
aVOf course, since the CodePack is also delivered as source you could extract the necessary parts from there and do what is needed in order to build it against
p29572
aVnet 2
p29573
ag9193
as(dp29574
g7
V505088
p29575
stp29576
a((dp29577
g2
(lp29578
VThe picture box control is a relatively loose wrapper around Windows paint cycles and the  event
p29579
aVThe  event is a queued message that the system places in your applications message queue whenever it deems that a window's drawing surface is invalid
p29580
aVThis can happen for many reasons:
p29581
aVAnother window is dragged over the top of your window (although modern windows use buffering to alleviate this)
p29582
aVYou invalidate the window by calling  which ultimately calls the Win32  function
p29583
aVSystem wide theme preferences changed
p29584
aVEtc
p29585
aVetc
p29586
aVSo, the natural conclusion of this is that your picture box paint handler needs to be written under the assumption that it will be called multiple times
p29587
as(dp29588
g7
V505088
p29589
stp29590
a((dp29591
g2
(lp29592
VThe use of a user token looks needlessly complex
p29593
aVBut, having said that, when I ran your code on my machine it worked fine with no error
p29594
aVPerhaps the user token for your process doesn't have sufficient rights to that folder
p29595
aVOr perhaps the folder really does not exist
p29596
aVFor what it's worth I think you would be better off using the simpler off API
p29597
aVMy wrapper for that looks like this:
p29598
aVOf course, this may fail in just the same way as your version if the folder really does not exist
p29599
aVOK, I've just re-read this comment in your question:
p29600
aVWhen I'm creating a simple test application and running the same code, it works well
p29601
aVThat sounds like you are running the real code in a different context
p29602
aVPerhaps in a service
p29603
aVOr with user impersonation
p29604
aVMaybe that's the clue to solving this
p29605
aVWhat are you not telling us about the environment/context/setting where the code fails
p29606
aVAnd some very minor comments on your code
p29607
aVYou've defined  with one more element than needed, and  is superfluous for an array:
p29608
aVOr, even better, re-use the type defined in the Delphi RTL,
p29609
as(dp29610
g7
V505088
p29611
stp29612
a((dp29613
g2
(lp29614
VI would store it as an integer and only convert to the formatted version with leading zeros on demand when you need to produce output, for example with ,  etc
p29615
aVIt's far easier that way than storing a string and trying to perform arithmetic on strings
p29616
aVNot least because you have extra formatting requirements about your strings
p29617
aVIf for some reason it is awkward to store an integer as your master data do it like this
p29618
aVStore the string as your master data
p29619
aVWhenever you need to perform arithmetic, convert from string to integer
p29620
aVWhen the arithmetic is complete, convert back to string and store
p29621
as(dp29622
g7
V505088
p29623
stp29624
a((dp29625
g2
(lp29626
VOnce you opt for  then you can't see files in the dialog, only folders
p29627
aVIf you omit  then you can't select folders, only files
p29628
aVThe standard dialog does not support what you are asking
p29629
aVYou could write you own dialog but I'd be inclined to find a way to organise your application to fit around the behaviour of the standard dialog
p29630
as(dp29631
g7
V505088
p29632
stp29633
a((dp29634
g2
(lp29635
VI wonder if the simplest approach in this instance is to switch behaviour on the  conditional
p29636
aVThis conditional is defined if and only if you are using a Unicode version of Delphi, i
p29637
ag192
aVin Delphi 2009 and later
p29638
aVThe big advantage of this is that it is future proof\u2014you don't need to update your code every time a new Delphi is released
p29639
aVWhat's more, the conditional switch will be far more readable since it will clearly express the intent
p29640
aVThe Delphi documentation has an excellent topic listing all the pre-defined conditionals
p29641
aVThe full list of version conditionals is also linked from there
p29642
as(dp29643
g7
V505088
p29644
stp29645
a((dp29646
g2
(lp29647
VYou need to define an  operator:
p29648
aVI guess the implementation should be:
p29649
aVYou will probably also want to implement the  operator
p29650
aVThe definition of these operators is, in fact, enough for the compiler to accept equality comparison with mixed  and  operands
p29651
aVThe full list of operators is provided in the documentation and it's well worth a read once in a while to reacquaint yourself with what is available in way of operator overloading
p29652
as(dp29653
g7
V505088
p29654
stp29655
a((dp29656
g2
(lp29657
VThe basic pattern you are looking for goes like this:
p29658
aVEXE calls a function in DLL
p29659
aVEXE passes parameters as necessary
p29660
aVDLL performs work, starts thread, returns a handle
p29661
aVAnd by handle I mean in the loose sense of the work rather than meaning a Windows handle
p29662
aVEXE can now communicate further with DLL by calling more functions, passing the handle
p29663
aVDLL can communicate with EXE, e
p29664
ag217
aVby callbacks, so long as EXE has supplied callbacks
p29665
aVWhen it is time to stop, the EXE calls a DLL function, passing the handle
p29666
aVAt this point the DLL tidies up
p29667
aVBehind the handle lies whatever state the DLL needs to keep track of between calls
p29668
aVFrom the point of view of the EXE this handle is opaque
p29669
aVThis sort of pattern can work just fine even with non-OOP languages like C
p29670
aVHowever, it's much easier to use OOP facilities
p29671
aVSince you are wishing to cross module boundaries you will be much safer using interfaces rather than Delphi objects
p29672
aVIf you pass Delphi objects across module boundaries then you can only pass the data part of the object, but not the code part
p29673
aVWhen using interfaces, the interface variable returned by the DLL functions as the handle in my numbered list above
p29674
aVIt contains any instance data
p29675
aVUse of interfaces allows for ready extensibility
p29676
aVAs for the threading part, you would do well to use a higher level threading library rather than raw threads
p29677
aVThe library I would recommend is Primo\u017e Gabrijel\u010di\u010d's OmniThreadLibrary
p29678
aVRegarding your edit:
p29679
aVI will wrap the DLL inside of a component, so when an instance of the component is created, DLL will be loaded and a corresponding thread will be created inside the DLL, then when the component is free'd, the DLL is unloaded
p29680
aVAlso need to make sure that if there are for example 2 of these components, that there will be 2 instances of the DLL loaded for each component
p29681
aVWhen you load a DLL into a process there is only ever a single instance of it
p29682
aVIn particular if you intend to use global variables, there will be just a single instance of each global variable, not matter how many times you call
p29683
as(dp29684
g7
V505088
p29685
stp29686
a((dp29687
g2
(lp29688
VYour call to  is made when  is
p29689
aVHence it returns immediately
p29690
aVThe  loop terminates when  equals
p29691
aVYour fundamental problem is that you don't have enough variables
p29692
aVYou need to maintain a variable to point at the beginning of the list, and another variable to use when iterating over the list
p29693
aVYou also seem to be confusing head and tail
p29694
aVThe term tail is used to denote the node for which  is
p29695
aVThe term head denotes the node at the other end of the list
p29696
aVThere are lots of other oddities in this code but I don't want to address them all because you only asked about one specific issue and I rather suspect that this is homework
p29697
as(dp29698
g7
V505088
p29699
stp29700
a((dp29701
g2
(lp29702
VThe  register is used for the return value of the function
p29703
aVYou state in the comments that you are compiling using  and so the function will use
p29704
aVAll the same it would make sense in my view to mark the declaration of your function type  with an explicit  so that there can be no scope for confusion and mis-match
p29705
aVOf course, there's nothing to stop you using one of the other calling conventions supported by your compiler
p29706
aVThe most important point is that whatever calling convention you settle on, you should explicitly specify the calling convention for the function pointer since the compiler is only responsible for one half of the interface
p29707
as(dp29708
g7
V505088
p29709
stp29710
a((dp29711
g2
(lp29712
VAlthough your question is lacking in detail, it sounds to me as though you might be looking for registration free COM
p29713
aVThis excellent MSDN article explains the details: Registration-Free Activation of COM Components: A Walkthrough
p29714
aVif you wish to register an Excel COM add-in without writing to the registry then I'm afraid that's not possible
p29715
as(dp29716
g7
V505088
p29717
stp29718
a((dp29719
g2
(lp29720
VApplications need heaps to allocate dynamic memory
p29721
aVWindows automatically creates one heap for each process
p29722
aVThis is the default heap
p29723
aVMost apps just use this single default heap
p29724
aVCommitting is the act of assigning reserved virtual addresses to specific memory so that it is available for use by the process
p29725
aVI suggest you read this article on MSDN: Managing Virtual Memory
p29726
as(dp29727
g7
V505088
p29728
stp29729
a((dp29730
g2
(lp29731
VWell, this is probably a matter largely for personal taste
p29732
aVMyself I would always opt for the property, even when coding internal to the class that declares the property
p29733
aVFor example, Count rather than FCount reads better, in my view
p29734
aVAnother perspective would be that if you have exposed a property to the public, and it is good enough for public consumption, then it should be fine for private consumption
p29735
aVYet another take would be that if you opt to use the most publicly available interface wherever possible, then it will be more obvious when you are using something private
p29736
aVSo, if you find that you need to write FCount because there is no Count, then you have a gentle reminder that this is a private name that you are using
p29737
aVSo, as I said, no definitive answer, just my own personal opinions and preferences
p29738
as(dp29739
g7
V505088
p29740
stp29741
a((dp29742
g2
(lp29743
VI'm 99% convinced that there is no equivalent solution on x64
p29744
aVOn x86 the code takes advantage of the property of  that all parameters are passed on the stack
p29745
aVThe code that creates the stub does not need to know anything about the parameters that are passed
p29746
aVIt simply pushes an extra parameter, the self pointer, onto the stack
p29747
aVAll the other parameters are shifted down the stack
p29748
aVOn x64, at least on Windows, there is a single calling convention
p29749
aVThis calling convention makes extensive use of registers
p29750
aVWhen the registers are exhausted, the stack is used
p29751
aVBoth integer and floating point registers are used
p29752
aVThe rules for which parameters get passed in which registers are complex to say the least
p29753
aVSo, in order to convert a method into a free standing procedure, it is my belief that the  routine would need to know information about the parameters: how many parameters, what types etc
p29754
aVSince  has none of this information, it is simply not possible to make an x64 conversion of this function, with the same interface
p29755
as(dp29756
g7
V505088
p29757
stp29758
a((dp29759
g2
(lp29760
VIt's an un-terminated loop
p29761
aVIt is sometimes written with a :
p29762
aVor even better:
p29763
aVI would expect to see a  or  inside any such loop, no matter whether it is written with  or
p29764
aVThere has to be some abnormal control flow or it really will be an infinite loop
p29765
as(dp29766
g7
V505088
p29767
stp29768
a((dp29769
g2
(lp29770
VYou can probably make the existing code (sort of) work by simply removing these lines:
p29771
aVRemember that faked input goes to the thread which has the input focus and when you show the print dialog in Notepad, that dialog will gain the input focus
p29772
aVYou simply do not need to set the focus, the system will do that for you
p29773
aVHowever, the approach you are taking is incredibly brittle
p29774
aVI suspect that you would be far better served by using something like UI Automation
p29775
as(dp29776
g7
V505088
p29777
stp29778
a((dp29779
g2
(lp29780
VIf I recall correctly, this happens when your install app does not include an application manifest
p29781
aVWhen UAC was introduced, MS introduced a heuristic detection for installers and shows the UAC elevation dialog
p29782
aVThe heuristic checks for names like setup
p29783
aVexe, install
p29784
aVexe
p29785
aVThe simple solution is to include an application manifest
p29786
aVIf it is an installer you probably want to use the  setting
p29787
aVThe feature is known as Installer Detection and is discussed here
p29788
aVFor what it is worth, I would always build an installer with a dedicated install tool like InnoSetup for example
p29789
as(dp29790
g7
V505088
p29791
stp29792
a((dp29793
g2
(lp29794
VI'm not sure what you are trying to do, but that  function is not valid
p29795
aVA Compare function needs to have the following symmetry property:
p29796
aVYour function does not have this property because you compare  with
p29797
aVYou also run the risk of a range error with the subtraction in your compare function
p29798
aVI would use  and  operators instead
p29799
aVI am al ittle reluctant to suggest what the compare function should be because I'm not sure what your desired ordering criterion is
p29800
aVIf you want a lexicographic comparison (i
p29801
ag192
aVan alphabetical ordering) then compare the  values first and if they compare equal, perform a second compare of the  values
p29802
aVHowever, now that I have looked again at the way in which you build the list, and now that I see that you assert this list is sorted on construction, it is clear what the order function should be
p29803
aVSomething like this:
p29804
aVNote that I have reversed the sign of the compare function from your original, albeit flawed, version
p29805
aVYour secondary problems (see comments to Ville's answer) are because the the list is not be sorted according to the same ordering as you use for the search
p29806
aVYou must sort and search with same compare
p29807
aVThe binary search algorithm is predicated on this
p29808
aVAs an aside I think that  is a poor variable name because it is also a fundamental type
p29809
aVThe use of  to name a record is very confusing because the conventional use for the  prefix is for a pointer
p29810
as(dp29811
g7
V505088
p29812
stp29813
a((dp29814
g2
(lp29815
VYou have not stated what you mean by custom area and you talk about a "selected area"
p29816
aVI don't know what you mean
p29817
aVFor a simple rectangle then you typically would fill the rectangle with
p29818
aVwhere  is a  specifying the rectangle
p29819
aVFor a more complex region then you need to fall back on the Windows GDI function
p29820
aVThis function is not wrapped by  but you can simply call it passing  as the
p29821
as(dp29822
g7
V505088
p29823
stp29824
a((dp29825
g2
(lp29826
VThe question seems a little vague but I understand it that you are asking for a slicker way to query an instance for the value of T, the type argument of the instantiated type
p29827
aVThe only way I know to do this is via a method, exactly as you have done it
p29828
aVI think you already have the best solution
p29829
as(dp29830
g7
V505088
p29831
stp29832
a((dp29833
g2
(lp29834
VShould I keep using Records as I am, or use something else
p29835
aVlike Packed Record
p29836
aVRecords are good for interop
p29837
aVDon't pack them, that just makes interop harder
p29838
aVAny tricks to use something other than String or PChar in
p29839
aVthese Records
p29840
aVDon't use string
p29841
aVThat's Delphi only and even specific to Delphi versions
p29842
aVPChar is fine for interop
p29843
aVSometimes it can be simplest to use fixed length inline char arrays in records
p29844
aVIt depends on the use
p29845
aVHow would I wrap this DLL in C#
p29846
aVCall it from C# using p/invoke
p29847
aVIs it safe to pass types such as TColor in the Records
p29848
aVYes that's easy to work with
p29849
aVMake sure it's a true RGB color rather than a special color like clWindow
p29850
aVDo you foresee any other issues in my code
p29851
aVThe glass rendering may well be incompatible with the rendering used by the C# libraries
p29852
aVIt could very well depend on whether or not your C# code uses WinForms or WPF
p29853
aVIn fact you may well find that the C# developers would find it easier to use native C# code
p29854
aVI expect glass rendering is well supported in the common C# GUI frameworks
p29855
as(dp29856
g7
V505088
p29857
stp29858
a((dp29859
g2
(lp29860
VAssuming I understand you correctly, to escape a  in C# source code, you can do it like this:
p29861
aVor
p29862
aVEither of those literals defines a string containing single double quote character
p29863
aVOn the other hand perhaps you need to know how to escape the quote character in Javascript
p29864
aVThat is done with
p29865
aVYou can use  to effect that but you would be much better off with a proper HTML/JS emitter library
p29866
as(dp29867
g7
V505088
p29868
stp29869
a((dp29870
g2
(lp29871
VHere's an outline solution that avoids OLE:
p29872
aVCreate a hidden worksheet
p29873
aVUse a base 64 encoded to convert the exe to text
p29874
aVStore that text in worksheet cells on the hidden worksheet
p29875
aVSince there is a limit on the number of characters in a cell (32,767) you will need to break the string into chunks
p29876
aVObviously you'll need to reverse this procedure when you want to save and execute the exe file
p29877
as(dp29878
g7
V505088
p29879
stp29880
a((dp29881
g2
(lp29882
VHere is a rather crude ctypes translation of the code you posted
p29883
aVIt even appears to work
p29884
aVNote that I remove the call to  which is simply wrong
p29885
aVYou should not call  on a pseudo-handle, which is what  returns
p29886
as(dp29887
g7
V505088
p29888
stp29889
a((dp29890
g2
(lp29891
VThe only way I know for you to do this without polling is through WMI
p29892
aVThere are plenty of examples on the web, e
p29893
ag217
aVUsing WMI to monitor process creation, deletion and modification in
p29894
aVNET
p29895
aVWMI is well wrapped by the
p29896
aVnet libraries
p29897
aVFor example, the sample above uses  to subscribe to WMI events
p29898
aVThere's a whole treasure trove of WMI goodness in the  namespace
p29899
as(dp29900
g7
V505088
p29901
stp29902
a((dp29903
g2
(lp29904
VYour settings in the
p29905
aVdfm file will be scaled up correctly, so long as  is
p29906
aVIf you are setting dimensions in code then you need to scale them by  divided by
p29907
aVUse  to do this
p29908
aVThis is what the form persistence framework does when  is
p29909
aVIn fact, you can make a cogent argument for replacing this function with a version that hard codes a value of 96 for the denominator
p29910
aVThis allows you to use absolute dimension values and not worry about the meaning changing if you happen to change font scaling on your development machine and re-save the
p29911
aVdfm file
p29912
aVThe reason that matters is that the  property stored in the
p29913
aVdfm file is the value of the machine on which the
p29914
aVdfm file was last saved
p29915
aVSo, continuing the theme, another thing to be wary of is that if your project is developed on multiple machines with different DPI values, you will find that the scaling that Delphi uses when saving
p29916
aVdfm files results in controls wandering over a series of edits
p29917
aVAt my place of work, to avoid this, we have a strict policy that forms are only ever edited at 96dpi (100% scaling)
p29918
aVIn fact my version of  also makes allowance for the possibility of the form font differing at runtime from that set at designtime
p29919
aVOn XP machines my application's forms use 8pt Tahoma
p29920
aVOn Vista and up 9pt Segoe UI is used
p29921
aVThis provides yet another degree of freedom
p29922
aVThe scaling must account for this because the absolute dimension values used in the source code are assumed to be relative to the baseline of 8pt Tahoma at 96dpi
p29923
aVAnother useful trick is to define dimensions in relative units, relative to  or
p29924
aVSo, if you want something to be around 10 vertical lines in size you can use
p29925
aVThis is a very rough and ready metric because it doesn't allow for line spacing and so on
p29926
aVHowever, often all you need to do is be able to arrange that the GUI scales correctly with
p29927
aVYou should also mark your application as being high DPI aware
p29928
aVThe best way to do this is through the application manifest
p29929
aVSince Delphi's build tools don't allow you to customise the manifest you use this forces you to link your own manifest resource
p29930
aVThe resource script looks like this:
p29931
aVwhere  contains the actual manifest
p29932
aVYou would also need to include the comctl32 v6 section and set  to
p29933
aVYou then link this compiled resource to your app and make sure that Delphi doesn't try to do the same with its manifest
p29934
aVIn modern Delphi you achieve that by setting the Runtime Themes project option to None
p29935
aVThe manifest is the right way to declare your app to be high DPI aware
p29936
aVIf you just want to try it out quickly without messing with your manifest, call
p29937
aVDo so as the very first thing you do when your app runs
p29938
aVPreferably in one of the early unit initialization sections, or as the first thing in your
p29939
aVdpr file
p29940
aVIf you don't declare your app to be high DPI aware then Vista and up will render it in a legacy mode for any font scaling above 125%
p29941
aVThis looks quite dreadful
p29942
aVTry to avoid falling into that trap
p29943
aVWindows 8
p29944
aV1 per monitor DPI update
p29945
aVAs of Windows 8
p29946
aV1, there is now OS support for per-monitor DPI settings (http://msdn
p29947
aVmicrosoft
p29948
aVcom/en-ca/magazine/dn574798
p29949
aVaspx)
p29950
aVThis is a big issue for modern devices which might have different displays attached with very different capabilities
p29951
aVYou might have a very high DPI laptop screen, and a low DPI external projector
p29952
aVSupporting such a scenario takes even more work than described above
p29953
as(dp29954
g7
V505088
p29955
stp29956
a((dp29957
g2
(lp29958
VThe error you report is indicative of heap corruption
p29959
aVThese can be hard to track down and tools like valgrind can be extremely helpful
p29960
aVHeap corruptions are often hard to debug with a simple debugger because the runtime error often occurs long after the actual corruption
p29961
aVThat said, the most obvious potential cause of your heap corruption, given the code posted so far, is if  is greater than
p29962
aVIf that occurs then  will write beyond the end of
p29963
as(dp29964
g7
V505088
p29965
stp29966
a((dp29967
g2
(lp29968
VThis typically happens when you have a package installed in the IDE that includes the mysterious unit that cannot be located
p29969
aVExactly what the solution is depends on your precise scenario
p29970
as(dp29971
g7
V505088
p29972
stp29973
a((dp29974
g2
(lp29975
VI'm going to assume that the information is flowing from C# to Delphi and not the other way, largely because that makes life a lot easier when writing the answer, and you didn't state otherwise
p29976
aVIn that case the Delphi function declaration should be:
p29977
aVThe first point is that you can't expect  to be handled by the P/invoke marshaller
p29978
aVDeclare the color as  and use  and  to handle the conversion
p29979
aVThere's nothing to be afraid of with
p29980
aVYou don't need a field with the string length since the length is implicit in a  due to the null-terminator
p29981
aVJust declare the field as  in the C# struct,  in the Delphi record and let the P/invoke marshaller do its magic
p29982
aVDon't try to write to the  content from Delphi
p29983
aVThat will end in tears
p29984
aVIf you want to pass a string back to the C# code then there are ways, but I won't address them here
p29985
aVIt's perfectly fine to have inline structs
p29986
aVNothing to worry about there
p29987
aVDon't allocate them with
p29988
aVJust treat them as value types (which they are) like ,  etc
p29989
aVIn due course you will need to add  attributes and so on, declare your DLL function with  and so on
p29990
aVTo summarise, I would declare your structs like this:
p29991
aVDelphi
p29992
aVC#
p29993
aVI've not marked the  with a  since the default is to marshal it as a  which is the same as a Delphi 7
p29994
aVI've only compiled this in my head so there may be a few wrinkles
p29995
as(dp29996
g7
V505088
p29997
stp29998
a((dp29999
g2
(lp30000
VRecord constructors are runtime only and so for constants your current solution is the only option
p30001
as(dp30002
g7
V505088
p30003
stp30004
a((dp30005
g2
(lp30006
V modules are different from  and  modules
p30007
aVThey do not contain executable code and you cannot  units
p30008
aVTherefore, symbols like  are simply not visible from a package file
p30009
aVYour only option is to use
p30010
as(dp30011
g7
V505088
p30012
stp30013
a((dp30014
g2
(lp30015
VThe authoritative source is the Word Object Model Reference on MSDN
p30016
aVThere is nothing better
p30017
aVIt's not written using Delphi syntax but you just have to live with that
p30018
as(dp30019
g7
V505088
p30020
stp30021
a((dp30022
g2
(lp30023
VThe way I approach this is to define multiple build configurations and then select the appropriate one at build time with
p30024
aVThe works nicely in the IDE too because you can just double click the build config in the project manager to activate it
p30025
aVI personally use inheritance of build configurations when I do this so that I don't have to repeat myself
p30026
aVFor example I have a build configuration named  that inherits from the  configuration and simply changes the  option to
p30027
aVTo help explain what I mean, here is what the build configuration tree looks like in my project:
p30028
aVThe  configuration is effected by means of this option set:
p30029
aVNow, I am sure that you could do this by using  but I think it is cleaner to use the build configurations so that you can be sure that what you get it the IDE is the same as what you get from the command line builds
p30030
aVI would not recommend either approach in your bullet point list
p30031
aVThose approaches look exceedingly brittle to me
p30032
as(dp30033
g7
V505088
p30034
stp30035
a((dp30036
g2
(lp30037
VHere's a rather fun solution reliant on bitsets
p30038
aVAs it stands it's limited to sets of size not greater than 32
p30039
aVI don't think that's a practical limitation since there are a lot of subsets for a set of cardinality greater than 32
p30040
aVThe output is not in the order that you want, but that would be easy enough to remedy if it matters to you
p30041
aVOutput
p30042
aVAnd here is a variant that just lists the subsets of a specified cardinality:
p30043
aVOutput
p30044
as(dp30045
g7
V505088
p30046
stp30047
a((dp30048
g2
(lp30049
VTo make this work with explicit loading (LoadLibrary/GetProcAddress) is easy enough
p30050
aVYou are in control of the binding process and simply pass the full path to LoadLibrary
p30051
aVFor implicit loading you are at the mercy of the system
p30052
aVWhilst you could augment the PATH variable this is extremely draconian
p30053
aVFaced with the choice of putting all DLLs alongside the executable or modifying PATH, I would always choose the former
p30054
aVThere is also the option of DLL redirection but even Microsoft seem to advise you to place your DLLs alongside your executable rather than use redirection
p30055
as(dp30056
g7
V505088
p30057
stp30058
a((dp30059
g2
(lp30060
VYou can make it 10 bytes if you pack it, assuming the underlying hardware does not have any particular alignment requirements
p30061
aVBe aware that once you start packing you are leaving portability behind
p30062
aVHow to affect packing depends on your compiler but most compilers, including gcc, support  type directives
p30063
as(dp30064
g7
V505088
p30065
stp30066
a((dp30067
g2
(lp30068
VYou are not allocating any memory for the array
p30069
aVUndefined behaviour ensues
p30070
aVChange your getarray function to do the allocate and return the newly created and populated array:
p30071
aVor even
p30072
aVfor a more symmetrical interface
p30073
aVIf you want a non-terminating loop use
p30074
aVThere is no need to bring input into your while loop
p30075
aVThere's no point passing the length by reference in any of the other routines since you are not modifying it
p30076
aVIn fact you are asking for trouble passing by reference since a coding error may inadvertently change the value
p30077
aVYou should declare it with const to make the compiler catch any silly mistakes you might make
p30078
aVI most heartily agree with Nawaz's suggestion to tie together the pointer and length variables
p30079
aVIn your average calculation I personally would declare total to be a float and thus avoid the awkward looking casts
p30080
aVYour implementation of median is plain wrong, but that seems to be a side issue
p30081
as(dp30082
g7
V505088
p30083
stp30084
a((dp30085
g2
(lp30086
VRead of address 0000026C
p30087
aVThis very low address is indicative of an offset to a member field of a  object reference
p30088
aVRun under the debugger and make sure the debugger is set to break on exceptions
p30089
aVWhen it does, you should be able to work out which object reference is
p30090
aVQuite possibly the AV happens in VCL code although it will almost certainly be due to an error in your code
p30091
aVIf the debugger doesn't break at a very helpful location, enable Debug DCUs in the project options in order to see the VCL source code at the point where the exception is raised
p30092
aVThe stack trace you provide suggests that the error is in , whilst performing a string comparison
p30093
aVThe first line of  reads:
p30094
aVI bet the offset to the  of  is  and that, somehow, your  variable is set to
p30095
aVThat said, I don't understand why the error would not have been raised earlier at
p30096
aVIt's quite hard to debug this remotely
p30097
aVHaving looked at the layout of , I think we can rule out  being
p30098
aVPerhaps  itself has somehow been corrupted, or perhaps even
p30099
aVI think it's going to take access to the actual code and a debugging environment to track this down
p30100
as(dp30101
g7
V505088
p30102
stp30103
a((dp30104
g2
(lp30105
VAs requested in comments, I have some very simple code that will set the username and password of an already registered service
p30106
aVNaturally this needs to be done at service install time which is when you have elevated rights
p30107
aVThe code happens to be in Delphi but it should be trivial to port it to another language
p30108
aVThe function calls are all Windows API calls and the documentation can be found in MSDN
p30109
aVI'm not sure how you are registering your service (you did not say yet) but it's quite possible that the service registration you are doing is already capable of setting username and password
p30110
aVIf you already happen to be calling  during install then that is the point at which username and password should be set
p30111
as(dp30112
g7
V505088
p30113
stp30114
a((dp30115
g2
(lp30116
VThe equivalent in Delphi is
p30117
aVSo far as I know, there is no equivalent in C++ Builder and of course  is a non-standard MS extension
p30118
as(dp30119
g7
V505088
p30120
stp30121
a((dp30122
g2
(lp30123
VThe combo box control is sent a  when the text is modified
p30124
aVThe VCL control chooses not to surface an event here, but you could
p30125
aVThere's many ways to do so
p30126
aVHere I illustrate the quick and dirty interposer class:
p30127
aVNaturally you would want to do this in a less hacky way in your production code
p30128
as(dp30129
g7
V505088
p30130
stp30131
a((dp30132
g2
(lp30133
VYou can use a variant of the standard  hack
p30134
aVUnit 1
p30135
aVUnit 2
p30136
aVUnit 3
p30137
aVStrict protected only allows you to access the member from the defining class, and subclasses
p30138
aVSo you have to actually implement a method on the cracking class, make it public, and use that method as the route into the target strict protected member
p30139
as(dp30140
g7
V505088
p30141
stp30142
a((dp30143
g2
(lp30144
VThe struct can be declared like this:
p30145
aVNext you need to settle on a calling convention
p30146
aVYour C++ code is almost certainly compiled with
p30147
aVLet's stick with that
p30148
aVThe function first is easy to call from C#:
p30149
aVNote that you should not use  here\u2013that's for Windows API functions
p30150
aVAnd there's no need to set the  since there is no text here
p30151
aVNow, for  things get more complex
p30152
aVIf you can allocate the memory in the C# code then that is definitely the way to go
p30153
aVOn the C# side you declare it like this:
p30154
aVand call it like this
p30155
aVIf you don't want to allocate on the C# side of the fence then do it like this:
p30156
aVReturn a pointer from the C++ code and allocate it with
p30157
aVIn C# declare the return value of the imported function as
p30158
aVUse  and some pointer arithmetic to marshal the return array into a C# array
p30159
aVCall  to free the memory allocated in the native module
p30160
aVBut if you want my advice, try and stick to allocating the array in the managed code
p30161
as(dp30162
g7
V505088
p30163
stp30164
a((dp30165
g2
(lp30166
VAssuming that your compiler uses an ASCII encoding then you can use the following simple arithmetic to get your answer:
p30167
aVYou really don't want to implement this with a long list of  statements or indeed a  statement
p30168
aVNaturally you will have input validation issues if you have non alphabetical characters, numeric characters, upper-case characters and so on
p30169
aVI presume you can simply ignore those for a learning exercise
p30170
as(dp30171
g7
V505088
p30172
stp30173
a((dp30174
g2
(lp30175
VAnswering the direct question that you asked, the  property is precisely what you are looking for
p30176
aVFor some reason it doesn't show up in the  documentation, but it is inherited from
p30177
aVIt sounds to me (following comments to Andreas' answer) as though what you really need to do it as follows:
p30178
aVPull the RTF from the DB into a memory stream or perhaps a blob stream
p30179
aVCall  passing that stream, making sure  is
p30180
aVThen read  to get the unformatted text
p30181
aVAt the moment you are simply putting the RTF into the control as plain text
p30182
aVYou need to put it into the control as rich text, and for that you need
p30183
as(dp30184
g7
V505088
p30185
stp30186
a((dp30187
g2
(lp30188
VHere are some answers to your large list of questions:
p30189
aVUpon attempting to replace a DLL, the DLL might be in use, and therefore 90% of the time fails to replace the DLL
p30190
aVI need something that can check if the DLL is in use and (if possible) either forcefully replace the DLL anyway, or tell Windows to replace the DLL on the next restart
p30191
aVCall  passing
p30192
aVThe EXE name is 'Setup
p30193
aVexe' which Windows 7 automatically recognizes it as an installer (and thinks that it failed to install)
p30194
aVI know there are workarounds for this, in fact, I saw a question here at stackoverflow recently for this exact case
p30195
aVI'd like to see if there's already something ready with whatever it is I get which can take care of this, instead of me doing the work manually
p30196
aVAdd an application manifest to your setup
p30197
aVexe program
p30198
aVThis was indeed discussed here recently: How do I get my Installer Application to behave correctly with Windows
p30199
aVThis is a server/client system I'm working with
p30200
aVIF the installation is on the server, it also needs to update (replace) the service EXE
p30201
aVI know how to start/stop services, but have a lot of difficulties in waiting for the service to stop, then replace the file, then start it again
p30202
aVI'd like to see if this can be automated
p30203
aVAll the standard ways I know to stop a service wait until it has stopped running
p30204
aVExecuting a large SQL script (I mean over 25,000 lines in this script) is hell, and doesn't work half the time
p30205
aVIt includes many instances of 'GO' which cannot be recognized by standard components, such as ADO
p30206
aVI can use a batch file to execute this, but that's getting a little dirtier than I'm comfortable with
p30207
aVThere must be a way to execute such a script without the use of batch files - especially reading the result and trying to identify if there were any errors in the update
p30208
aVThis updater is also going to install another third-party installation, specifically SQL Native Client Drivers
p30209
aVI'd like something that is already ready to launch another installer and wait for the result of it (success or failure)
p30210
aVIf it fails, I need to know to continue the updater differently
p30211
aVI regard these points as being too generic to give advice on
p30212
aVAll of these issues would be trivial with the help of a good third party install program like InnoSetup
p30213
aVI can't understand why you are reluctant to avail yourself of such a useful helping hand
p30214
as(dp30215
g7
V505088
p30216
stp30217
a((dp30218
g2
(lp30219
VLife is far easier if you keep the DLLs in the same folder as the executable
p30220
aVThat's the first folder searched when libraries are loaded
p30221
aVTo move all the DLLs into a sub folder of the executable directory requires cooperation from all DLLs
p30222
aVMost likely you have secondary DLL dependencies that are not cooperating
p30223
aVSo exe loads A fine, but then A fails to load B
p30224
aVYou can debug this further with Dependency Walker running in profile mode
p30225
aVIt's quite possible that a secondary DLL is being loaded with implicit linking and that this throws and exception
p30226
aVWhatever the cause, Depenency Walker will lead you to the problem
p30227
aVWhilst you can modify the PATH variable this is generally not advisable
p30228
aVIf you do choose to go down this route then don't modify system wide, just modify the executable process environment at runtime before the first LoadLibrary
p30229
aVThis is tenable so long as all your DLL linking is explicit using GetProcAddress
p30230
aVAll accepted wisdom recommends that you put your DLLs in the same folder as your executable
p30231
aVI would echo this recommendation
p30232
aVIf you did this then you would be able to use implicit linking which would greatly simplify your code
p30233
aVYet another option may be to abandon DLLs and link everything straight into your executable
p30234
aVUnless you have a plugin type architecture, a single big exe is by far the simplest approach
p30235
as(dp30236
g7
V505088
p30237
stp30238
a((dp30239
g2
(lp30240
VYou are presumably setting the  somewhere in your code
p30241
aVYou can simply stop doing this and instead set the  event
p30242
aVThen you need to supply an event with this signature:
p30243
aVYou would respond to receipt of such an event by updating the  value of the progress bar in your UI
p30244
aVThe method that surfaces this progress event also handles the progress meter version:
p30245
aVSo the designers of the component have simply provided two alternative routes to receiving progress: the meter or a callback
p30246
aVIn order to handle progress from a callback you need to write a method like this:
p30247
aVYou then assign this event handler to , most likely in the IDE
p30248
aVIt's an identical procedure to assigning an  event to a button
p30249
aVNote: I've never used Abbrevia so I may have picked out a different component from the one you are using
p30250
aVHowever, all the components that interact with meters, also offer progress via a callback so this basic approach will work no matter which component you use
p30251
as(dp30252
g7
V505088
p30253
stp30254
a((dp30255
g2
(lp30256
VThis is a trivial operation and you need not consider multi-threading
p30257
aVJust do it with a  in a single thread
p30258
as(dp30259
g7
V505088
p30260
stp30261
a((dp30262
g2
(lp30263
VBecause  is a literal of type  and  has a size of 8 chars on your system
p30264
as(dp30265
g7
V505088
p30266
stp30267
a((dp30268
g2
(lp30269
VIt's a calling convention mismatch
p30270
aVThe C++ code uses  by default but the C# assumes
p30271
aVYou need to make them match, e
p30272
ag217
as(dp30273
g7
V505088
p30274
stp30275
a((dp30276
g2
(lp30277
VYou are sending messages cross-process so you need the system to marshal the data from one virtual address space to the other
p30278
aVThe only way to do so with Windows messages is to send the  message
p30279
aVIf you do that then the system will take care of the cross-process issues
p30280
aVIt cannot work with a custom defined message
p30281
aVBut if you are wishing to do any serious amounts of inter-process communication then you should look for a higher level mechanism, as suggested by others
p30282
as(dp30283
g7
V505088
p30284
stp30285
a((dp30286
g2
(lp30287
VI can't find that function in any of my Delphi's (D6, D2010, DXE2)
p30288
aVI would test for NT like this:
p30289
aVThis test is a little redundant on XE2 since it no longer supports targetting non-NT versions of Windows
p30290
aVI've not actually tried running an XE2 produced executable on Win9x lately so I don't know whether or not it fails when you do so
p30291
aVIn XE2 you can now make use of
p30292
aVFor example, to check that you are running on Windows XP or up you would simply do:
p30293
as(dp30294
g7
V505088
p30295
stp30296
a((dp30297
g2
(lp30298
VDeleting a large range of elements from the beginning of a  is expensive
p30299
aVAlthough the class name flatters to deceive, a  is in fact an array
p30300
aVIn  there is no facility to delete a range\u2013each item must be deleted individually and then the rest of the list is moved down
p30301
aVFor a large range that's going to provoke an awful lot of reallocations and full list moves
p30302
aVIf you had a more modern Delphi you could use the generic list class  and avail yourself of the  method
p30303
aVThe documentation includes this vital note:
p30304
aVThis is an O(ACount) operation
p30305
aVIn Delphi 2006 you can write something with equivalent performance characteristics like this:
p30306
as(dp30307
g7
V505088
p30308
stp30309
a((dp30310
g2
(lp30311
VI can reproduce this easily enough in XE2, and I imagine it will behave the same in all other versions
p30312
aVTo make it simpler I've cut it down to this:
p30313
aVThis also produces E2010
p30314
aVHowever, if you enable the type-checked pointers option, then the code compiles successfully
p30315
aVIn fact the documentation of that compiler options states:
p30316
aVIn the {$T-} state, distinct pointer types other than Pointer are incompatible (even if they are pointers to the same type)
p30317
aVIn the {$T+} state, pointers to the same type are compatible
p30318
aVThanks to Ken White for pointing me at the useful help topic Type Compatibility and Identity
p30319
aVThe pertinent extracts are that types T1 and T2 are assignment compatible if:
p30320
aVT1 and T2 are compatible pointer types
p30321
aVThe documentation also states that types are type compatibile if:
p30322
aVBoth types are (typed) pointers to the same type and the {$T+} compiler directive is in effect
p30323
aVSo this documents the observed behaviour and leads me to this example:
p30324
aVSo, to summarise:
p30325
aVWhen type-checked pointers is disabled, pointers are assignment compatible if the pointers are of the same type
p30326
aVWhen type-checked pointers is enabled, pointers are assignment compatible if the pointers point to the the same type
p30327
aVI have to confess to being ignorant of the history and reasoning behind the type-checked pointer setting, so I can't offer any explanation for why the compiler is the way it is
p30328
as(dp30329
g7
V505088
p30330
stp30331
a((dp30332
g2
(lp30333
VThe documentation on how to do this can be found on MSDN
p30334
aVThe key extract is this:
p30335
aVTo programmatically add or modify system environment variables, add them to the HKEY_LOCAL_MACHINE\u005cSystem\u005cCurrentControlSet\u005cControl\u005cSession Manager\u005cEnvironment registry key, then broadcast a  message with lParam set to the string "Environment"
p30336
aVThis allows applications, such as the shell, to pick up your updates
p30337
aVNote that your application will need elevated admin rights in order to be able to modify this key
p30338
aVYou indicate in the comments that you would be happy to modify just the per-user environment
p30339
aVDo this by editing the values in HKEY_CURRENT_USER\u005cEnvironment
p30340
aVAs before, make sure that you broadcast a  message
p30341
aVYou should be able to do this from your Java application easily enough using the JNI registry classes
p30342
as(dp30343
g7
V505088
p30344
stp30345
a((dp30346
g2
(lp30347
VI can see  in your code which leads me to suspect that you have some leading whitespace
p30348
aVYou can probably best solve the problem by moving the trimming to outside the
p30349
aVIt's pretty safe to assume that something as fundamental as  works correctly
p30350
aVWhen it says your string is a certain length, your string really will be that length
p30351
as(dp30352
g7
V505088
p30353
stp30354
a((dp30355
g2
(lp30356
VFloating point arithmetic with double precision values inherently has finite precision
p30357
aVThere only are 15-16 significant decimal digits of information in a double precision value
p30358
aVThe behaviour you see is exactly to be expected
p30359
aVThe closest representable double precision value to 12345678
p30360
aV12345678 is 12345678
p30361
aV1234567798674106597900390625 which tallies with your observed behaviour
p30362
as(dp30363
g7
V505088
p30364
stp30365
a((dp30366
g2
(lp30367
VThe  inside the function body calls itself leading to an infinite recursion, as you suspected
p30368
aVSome possible solutions:
p30369
aVPut the imported DLL function in a separate namespace so that you can distinguish its name
p30370
aVChange the names of these function to avoid a clash
p30371
aVImport explicitly rather than implicitly by using
p30372
aVThat allows you to call the imported function anything you like
p30373
as(dp30374
g7
V505088
p30375
stp30376
a((dp30377
g2
(lp30378
VYou can use a combination of the generic list  and insertion sort
p30379
aVYour data structure is like this
p30380
aVYou'll need to use  to get the generic list
p30381
aVInstantiate it like this:
p30382
aVUse this function to add to the list:
p30383
aVThis is a simple implementation of insertion sort
p30384
aVThe key to making this algorithm work is to make sure the list is always ordered
p30385
as(dp30386
g7
V505088
p30387
stp30388
a((dp30389
g2
(lp30390
VThe main thing that I see wrong with this code, and I've only really studied the call to , is that you are unconditionally calling
p30391
aVThe documentation for that API function is inadequate because it does not specify how errors are signalled
p30392
aVHowever, I would strongly expect that errors to be signalled by the function returning
p30393
aVSince the documentation does not say anything about calling  it is entirely possible that the API function does not set the last error value
p30394
aVNo matter, even if you can be sure that  can be called, you should only do so after a failure, ie
p30395
aVif the call to  returns
p30396
aVIf you call  after a successful API call you will get the error code for the most recent failed API call, which is unrelated to the current call
p30397
aVThe bottom line is that I'm sure  is carrying all 4 bytes and that your problem is not with that part of the process
p30398
aVThe upshot of all this is the I strongly believe that  is succeeding, but the call to  is failing
p30399
aVYou don't check the return value for that
p30400
aVI bet it returns
p30401
aVTake a look at the C++ declarations for the two functions
p30402
aVreturns the ID list in a parameter typed liked this:
p30403
aVreceives the ID list in  a parameter typed liked this:
p30404
aVI don't know what your declaration of  looks like, but the one supplied in my version of Delphi (XE2) looks plain wrong
p30405
aVIt has this parameter declared like this:
p30406
aVI honestly can't see how a Windows API function can return a Delphi open array as an out parameter
p30407
aVI think it should be declared so:
p30408
aVand you may need to declare  to be
p30409
aVNow,  is an array
p30410
aVIt points to the first element of an array of
p30411
aVSo you would obtain the path of the first element by calling:
p30412
aVThis, I believe, is the real problem you have
p30413
aVFinally I can't understand why you would test for success with
p30414
aVThe correct test is
p30415
aVNow, I know that some of the Delphi types have changed in recent versions, but if  was a signed value in your version of Delphi then you code would be wrong
p30416
aVNo matter what, the correct logical test is
p30417
as(dp30418
g7
V505088
p30419
stp30420
a((dp30421
g2
(lp30422
VYour  function is just fine
p30423
aVIf the binary search fails to work correctly then that can only be because the list is not ordered by the order defined by
p30424
aVCall the  function on the list once you have finished populating, and before you start searching
p30425
aVWhen you call , you must make sure that it use your compare function
p30426
as(dp30427
g7
V505088
p30428
stp30429
a((dp30430
g2
(lp30431
VI suspect that the main problem with your code is that you are requesting overlapped I/O but supplying a buffer that ceases to exist when  returns
p30432
aVIt works on some systems an not others because the system decides whether or not to perform the operation asynchronously, and it may choose not to do async on one system and choose differently on another
p30433
aVI'm sure you don't want overlapped I/O so you should simply pass  to the final parameter of
p30434
aVOn the other hand, perhaps your code isn't working at all on the x64 system and never gets as far as an AV
p30435
aVYour handle types are mis-declared as 32 bit integers
p30436
aVThere are many other minor problems with your code
p30437
aVHere's an edited version of the code that corrects these errors
p30438
aVThe P/invoke signatures were taken from pinvoke
p30439
aVnet
p30440
aVTo summarise the errors in your code:
p30441
aVIncorrect use of 32 bit integers to store handles
p30442
aVYour P/invoke declaration of  declares the  incorrectly
p30443
aVdoes not return a handle, it returns a boolean indicating success of the function call
p30444
aVUse of overlapped I/O which you do not want, and which cannot work with a marshalled  buffer
p30445
aVYou must never call  from managed code (you did so in code shown in a comment)
p30446
aVInstead call
p30447
aVThe reasons are explained in the documentation for that method
p30448
as(dp30449
g7
V505088
p30450
stp30451
a((dp30452
g2
(lp30453
VI can see the following errors:
p30454
aVYou are not checking the return value of  for success or failure
p30455
aVYou are passing the wrong thing to the first parameter of
p30456
aVYou need to pass the handle to the file
p30457
aVYou use overlapped I/O which you do not want, and which cannot work with a marshalled  buffer
p30458
aVPass  for  or perhaps  depending on how your P/invoke is declared
p30459
aVdoes not return a handle, it returns a boolean indicating success of the function call
p30460
aVYou must never call  from managed code
p30461
aVInstead call
p30462
aVThe reasons are explained in the documentation for that method
p30463
aVDo not call  unless the prior API call actually failed
p30464
aVYou did not check whether or not  succeeded
p30465
aVJust like , it returns a boolean to indicate success or failure
p30466
as(dp30467
g7
V505088
p30468
stp30469
a((dp30470
g2
(lp30471
VYou cannot do what you wish with constants or open arrays
p30472
aVis a dynamic array and you cannot have constants that are dynamic arrays
p30473
aVAnd a matrix is 2D but open arrays can't be nested
p30474
aVYou cannot have an open array of open arrays
p30475
aVIf this was just a vector, i
p30476
ag192
aV1 dimensional, then you could indeed use open arrays
p30477
aVHowever, since you have a 2D matrix, open arrays can't help
p30478
aVYou will need to use a variable that is initialised at runtime
p30479
aVYou can do this easily enough in an  section if you truly have a constant
p30480
as(dp30481
g7
V505088
p30482
stp30483
a((dp30484
g2
(lp30485
VThe best way to do this is to get the tool to tell where where the allocation was made that led to a leak
p30486
aVTo do this you need  to download and use the full version of FastMM
p30487
aVThe version supplied with Delphi does not have that capability
p30488
aVWhen using the full FastMM, a report will be produced with all the gory details you need, including stack traces, to tell you what piece of code leaked
p30489
as(dp30490
g7
V505088
p30491
stp30492
a((dp30493
g2
(lp30494
VI'm going to base the notation on your previous question
p30495
aVI'm also going to rename  as
p30496
aVSo,  identifies the primary comparison field,  identifies the secondary comparison field and so on
p30497
aVWith this in place your compare function looks like this:
p30498
aVIt all works much better if the integers in your record are declared as an array rather than individually
p30499
aVThat allows you to index them as I do here
p30500
aVNaturally this could all be generalised to handle arbitrary sized arrays
p30501
as(dp30502
g7
V505088
p30503
stp30504
a((dp30505
g2
(lp30506
VBy default, standard users don't have write access to the common app data folder
p30507
aVIf you wish to allow your users to write there you should create a sub-folder and apply an appropriate ACL
p30508
aVDo this as part of your installation because that's when you have sufficient rights to create the ACL
p30509
aVAnother option is to store these settings on a per-user basis and thereby avoid the issues with security
p30510
as(dp30511
g7
V505088
p30512
stp30513
a((dp30514
g2
(lp30515
VDelphi has no equivalents to any of those operators
p30516
aVIt is the case that  and  are similar to += and  but they differ in that the C/C++ versions evaluate to a value
p30517
aVWhilst in C and C++ you can write
p30518
aVthis is simply not possible with  in Delphi
p30519
aVSo in Delphi I would write it as
p30520
aVHaving witnessed a seemingly endless supply of questions about the meaning of  I for one am happy that these operators do not exist in Delphi
p30521
aVOn a more serious note, you should be very wary about trying to reproduce such operators using, for example, inline functions
p30522
aVOnce you start stringing such operators together into complex expressions you will observe unpredictable behaviour due to the fact that function evaluation order within expressions is undefined in Delphi
p30523
as(dp30524
g7
V505088
p30525
stp30526
a((dp30527
g2
(lp30528
VI'm assuming this is a bignum data type
p30529
aVYou have 10-12 chars to store 80-96 bit integer values
p30530
aVTo make it simple, I'm going to assume unsigned values
p30531
aVIterate through both arrays simultaneously comparing elements from each array
p30532
aVStart at the most significant element
p30533
aVAs soon as you find one element bigger than the other, you have your answer
p30534
aVFor extra speed, do machine word size compares by loop unrolling
p30535
aVBut since you are getting these values over the wire, it seems odd that the bignum class is a bottleneck
p30536
aVSurely the network will be your bottleneck
p30537
aVWhat's more, a good bignum class will be well optimised
p30538
aVWhy would your own code beat it
p30539
as(dp30540
g7
V505088
p30541
stp30542
a((dp30543
g2
(lp30544
VIn an ideal world you would set  to  from the event to block a page change
p30545
aVHowever, this does not appear to be viable because I can find no way of discerning, from within , which page the user is trying to select
p30546
aVEven looking at the underlying Windows notification seems to offer little hope
p30547
aVThe  notification identifies the control, but not says nothing about the pages involved, so far as I can tell
p30548
aVThe best I can come up with is to use  to note the current active page and then do the hard work in
p30549
aVIf the selected page has been changed to something undesirable, then just change it back
p30550
aVRather messy I know, but it has the virtue of working
p30551
as(dp30552
g7
V505088
p30553
stp30554
a((dp30555
g2
(lp30556
VOne very common way to make a wizard is to use a page control
p30557
aVEach distinct page of the wizard is a different page/tabsheet in the page control
p30558
aVI believe that this is effectively how Windows implements wizards
p30559
aVNaturally you want to hide all the tabs
p30560
aVDo this by setting  to  for each tabsheet
p30561
aVWhen you wish to move forwards and backwards through the wizard, e
p30562
ag217
aVwhen the user clicks the next or previous buttons, effect this by setting  or  depending on your preference
p30563
as(dp30564
g7
V505088
p30565
stp30566
a((dp30567
g2
(lp30568
VI don't think the theme API will give you the icon for this
p30569
aVThat's not the way the theme API works
p30570
aVRather you simply ask it to paint the sort icon and identify it by part and state identifiers
p30571
aVIt's listed in the Parts and States MSDN topic: , ,
p30572
aVEdit: Having re-read your question, I see that you already know all about the parts and states
p30573
as(dp30574
g7
V505088
p30575
stp30576
a((dp30577
g2
(lp30578
VThe documentation for mechanize has this sample code:
p30579
aVThat does exactly what you want
p30580
as(dp30581
g7
V505088
p30582
stp30583
a((dp30584
g2
(lp30585
VYou will need to call  from a background thread
p30586
aVAt the moment the call to  is blocking the UI thread
p30587
aVThat's why the UI does not update
p30588
aVThe callback action is indeed called repeatedly
p30589
aVThis is so that you can report to the user the progress of a long running file operation
p30590
aVJust to be clear, this is what happens when you call :
p30591
aVFor the entire duration of the file copy, the executing thread is busy copying the file rather than pumping the message queue
p30592
aVAlthough this is WinForms and not Win32, WinForms is a relatively lightweight wrapper around the standard Win32 GUI framework
p30593
aVYour message queue needs to be serviced regularly and so all long running tasks need to be run away from the UI thread
p30594
aVOne final point: remember that when you get your progress callback, you need to use  or  when updating any UI
p30595
aVThis is because code that updates UI needs to be run from the UI thread
p30596
as(dp30597
g7
V505088
p30598
stp30599
a((dp30600
g2
(lp30601
VThe notify icon has changed behaviour over the years
p30602
aVFor reasons of compatibility with pre-existing code, you must opt-in to the new behaviour
p30603
aVIf you don't opt-in then you don't get sent  messages
p30604
aVInstead you have to respond to
p30605
aVEven if you invoke the context menu from the keyboard, the system still sends
p30606
aVYou have to obtain the cursor position, in order to know where to show the menu, by calling
p30607
aVYou can opt in to the new behaviour (and ) as described in the documentation, by calling  passing  after the  call
p30608
aVPresumably the SDK sample you are looking at does this somewhere
p30609
aVMy guess is that is what is missing from your code
p30610
aVThe key extract from the documentation is in the remarks section:
p30611
aVAs of Windows 2000 (Shell32
p30612
aVdll version 5
p30613
aV0), Shell_NotifyIcon mouse and keyboard events are handled differently than in earlier Shell versions found on Microsoft Windows NT 4
p30614
aV0, Windows 95, and Windows 98
p30615
aVThe differences include the following:
p30616
aVIf a user selects a notify icon's shortcut menu with the keyboard, the Shell now sends the associated application a WM_CONTEXTMENU message
p30617
aVEarlier versions send WM_RBUTTONDOWN and WM_RBUTTONUP messages
p30618
aVIf a user selects a notify icon with the keyboard and activates it with the SPACEBAR or ENTER key, the version 5
p30619
aV0 Shell sends the associated application an NIN_KEYSELECT notification
p30620
aVEarlier versions send WM_RBUTTONDOWN and WM_RBUTTONUP messages
p30621
aVIf a user selects a notify icon with the mouse and activates it with the ENTER key, the Shell now sends the associated application an NIN_SELECT notification
p30622
aVEarlier versions send WM_RBUTTONDOWN and WM_RBUTTONUP messages
p30623
as(dp30624
g7
V505088
p30625
stp30626
a((dp30627
g2
(lp30628
VTree views in post-Vista Windows have two alternative themes
p30629
aVThe theme that you are wanting to avoid is known as the explorer theme
p30630
aVYou want to use the standard theme
p30631
aVA control has to opt-in to get the explorer theme
p30632
aVIt does so via the   API
p30633
aVThe VCL tree view control calls this to opt-in
p30634
aVIt does so at the end of its  method
p30635
aVYou can revert to the standard theme by undoing the change like this:
p30636
aVThis code is written for XE2
p30637
aVIf you have an earlier Delphi then I think you want it like this:
p30638
as(dp30639
g7
V505088
p30640
stp30641
a((dp30642
g2
(lp30643
VThe first thing to try is to remove packages from the IDE
p30644
aVTry this out with your vanilla empty app rather than your real app
p30645
aVIf that doesn't help I'd move straight to a Delphi reinstall
p30646
aVThat really ought to fix it and there's probably nothing to be gained trying to solve the problem with a reinstall
p30647
as(dp30648
g7
V505088
p30649
stp30650
a((dp30651
g2
(lp30652
VWhat I was talking about was growing dynamic arrays 1 element at a time:
p30653
aVIn a loop, and with large arrays, this can lead to memory address fragmentation
p30654
aVWhen this happens you can find yourself unable to allocate a large contiguous block of memory even though the total available address space is large
p30655
aVIf you are constrained by 32 bit address space this can be a very real problem
p30656
aVIn addition, performance can also be an issue
p30657
aVThere are a variety of ways to avoid the problem:
p30658
aVPre-allocate the array
p30659
aVSometimes this involves iterating twice, once to count the items and once to populate the array
p30660
aVThis can be perfectly efficient
p30661
aVIn fact, that is precisely what  in your question does
p30662
aVUse a  or  container
p30663
aVAlthough these use dynamic arrays as their underlying storage they implement a capacity based approach to allocation
p30664
aVWhen they are full, they allocate a large number of extra items in anticipation for future additions
p30665
aVThis again can be perfectly efficient
p30666
aVYet another option, to be used as a last resort, is to move away from contiguously allocated memory
p30667
aVAllocate memory in chunks and use an indexed property of a class or record to map between indices and the actual chunk and location where the storage lives
p30668
aVThis is particularly effective at avoiding address space fragmentation
p30669
as(dp30670
g7
V505088
p30671
stp30672
a((dp30673
g2
(lp30674
VThe documentation describes two options:
p30675
aVIf a function sets the system error property (errno or GetLastError()), the error code will be thrown as a LastErrorException if you declare the exception in your JNA mapping
p30676
aVAlternatively, you can use Native
p30677
aVgetLastError() to retrieve it, providing that Native
p30678
aVsetPreserveLastError(boolean) has been called with a true value
p30679
aVThrowing an exception is preferred since it has better performance
p30680
aVThe problem with calling  is that the JNA framework and indeed the Java runtime may call Windows function which reset the error
p30681
aVSo you should not attempt to call  directly
p30682
as(dp30683
g7
V505088
p30684
stp30685
a((dp30686
g2
(lp30687
VYou need to use Sharemem if and only if memory is allocated in one module (i
p30688
ag192
aVDLL/EXE) and deallocated in a different module
p30689
aVThis commonly happens when you are working passing  between modules
p30690
aVIn the example you give, there is no need to use Sharemem
p30691
aVThe memory for the  is allocated by the called and is not deallocated by the callee
p30692
aVThe string in the callee is allocated and deallocated in the callee
p30693
aVHere's an example where you would need Sharemem:
p30694
aVHere the memory for the string is allocated in the callee but will be deallocated by the caller
p30695
aVThe case of a  is quite special
p30696
aVThe  is a wrapper around the COM  type
p30697
aVIt allocates and deallocates using the shared COM allocator
p30698
aVSo it does not use the Delphi allocator and you are safe to pass  between modules without using Sharemem
p30699
as(dp30700
g7
V505088
p30701
stp30702
a((dp30703
g2
(lp30704
VMost likely is that  has a buffer overrun which is corrupting the value of
p30705
aVOne obvious possibility is that it writes to  with an out-of-bounds index
p30706
aVSince  and  are quite probably next to each other on the stack, that seems a likely explanation
p30707
as(dp30708
g7
V505088
p30709
stp30710
a((dp30711
g2
(lp30712
VThe magic you are talking about can be seen in the
p30713
aVdproj file for a plain vanilla XE2 VCL Forms app
p30714
aVThe key ingredients are these variables:
p30715
aVwhich can be Win32 or Win64 on Windows
p30716
aVwhich is commonly either Debug or Release
p30717
aVThen in the
p30718
aVdproj file the following XML performs the magic:
p30719
aVYou can use such tricks with the  and  variables with any of the project options
p30720
aVSo you just need to use these variables to set whatever option needs to be set for the compiler to find your pre-compiled DCUs
p30721
aVTo the best of my knowledge the option you need to set is the Search Path
p30722
aVAlthough I admit to being hazy about how the search path works since I personally never rely on search path and always explicitly include all source files in my projects
p30723
aVIn your example you would add  to the search path
p30724
as(dp30725
g7
V505088
p30726
stp30727
a((dp30728
g2
(lp30729
VSuch typecasts are perfectly safe in all the Delphi implementations that I have ever encountered
p30730
aVHowever, reinterpretation typecasts like this remove type checking, there is always a risk that future changes to the source code can result in hard to trace errors
p30731
aVI would always try to avoid casting if possible
p30732
aVFor example, the very simplest thing you can do is to avoid using  as a type in your code and switch to
p30733
aVIf you must cast then wrap it up in a function to mitigate the risks I describe above
p30734
as(dp30735
g7
V505088
p30736
stp30737
a((dp30738
g2
(lp30739
VIt's simply a difference in the languages
p30740
aVC++ is more permissive in its struct syntax
p30741
as(dp30742
g7
V505088
p30743
stp30744
a((dp30745
g2
(lp30746
VIt's clearly a bug in the compiler
p30747
aVI have reported the bug to Quality Central, QC#101656
p30748
aVThe bug only affects the 32 bit compiler, not that that will be of much consolation to anyone
p30749
aVYou can work around it by putting your variables in a record like this:
p30750
as(dp30751
g7
V505088
p30752
stp30753
a((dp30754
g2
(lp30755
VI managed to get this to work like this:
p30756
aVDownload the C# Project template
p30757
aVThis requires Visual Studio but you should be fine with the Express version
p30758
aVCreate a new project based on the template
p30759
aVBuild that project
p30760
aVLoad the DLL in Dependency Walker to see that it does indeed export the function
p30761
aVI succeeded in calling the function from Delphi
p30762
aVNote that the path to find the DLL is
p30763
aVThere is a DLL in  but this has no exports
p30764
aVPerhaps that's what you have been looking at
p30765
as(dp30766
g7
V505088
p30767
stp30768
a((dp30769
g2
(lp30770
VNote: This answer refers to the original question
p30771
aVThe local variable  has not been created in the section of code that you label main program
p30772
aVAccordingly the object reference will have some garbage value from the stack
p30773
aVWhen you first come to access the list an access violation occurs
p30774
as(dp30775
g7
V505088
p30776
stp30777
a((dp30778
g2
(lp30779
VDelphi XE2 does not ship with a unit named
p30780
aVIt ships with a pre-compiled DCU file named
p30781
aVYou need to link against the pre-compiled DCU and not attempt to compile a VCL unit
p30782
aVThe error message you are getting can only occur when you attempt to compile a unit from source
p30783
aVYou cannot get this message if you pass a pre-compiled DCU to the linker
p30784
aVI suspect that your
p30785
aVdpr file contains references to a file named
p30786
aVSolve the problem by removing the references to  from your
p30787
aVdpr file
p30788
aVAnother explanation is that you have a source file named  in your search path
p30789
as(dp30790
g7
V505088
p30791
stp30792
a((dp30793
g2
(lp30794
VI don't fully understand the problem but I can see one thing wrong
p30795
aVYou can't expect to paint to the form canvas in a mouse down event and hope that what you draw will remain
p30796
aVPainting in Windows simply does not work that way
p30797
aVYou need to paint the form in response to a  message
p30798
aVThere is no persistent drawing surface associated with a window
p30799
aVWhen a window needs to be painted the system posts a  message to your message queue
p30800
aVYou are then obliged to paint the current state of the window
p30801
aVThe simplest way to achieve that in your case will be to paint to an off screen bitmap in response to mouse messages and then display that bitmap as part of the paint cycle
p30802
aVYou can access the paint cycle by putting a  on your form and handling the  event
p30803
aVIn that event simply draw the bitmap to the paint box canvas
p30804
aVYou'll need to make the paint box repaint itself whenever you update the bitmap
p30805
aVDo this by calling the  method of the paint box
p30806
aVI recommend reading Petzold's book Programming Windows to get a thorough understanding of how painting works in Windows
p30807
as(dp30808
g7
V505088
p30809
stp30810
a((dp30811
g2
(lp30812
VThis error occurs because some other part of your code has corrupted the heap
p30813
aVWe can't tell you what that error is without seeing the rest of the code
p30814
aVThe fact that  is not printed tells you that  is failing
p30815
aVAnd that failure must be because  is invalid due to a heap corruption earlier in the execution
p30816
aVOrthogonal to your actual problem,  is  by definition so it makes sense to remove it from the code
p30817
as(dp30818
g7
V505088
p30819
stp30820
a((dp30821
g2
(lp30822
VEach global variable in a Windows DLL has a single instance for each process that loads the DLL
p30823
aVThere is a one-to-one mapping between processes and global variable instances
p30824
aVProcesses are completely isolated from each other and one process cannot directly access memory in a different process
p30825
aVIf you want to share a variable between processes then you will need some form of inter-process communication (IPC)
p30826
aVFor example you could set up a logging app to which your DLL could send messages
p30827
as(dp30828
g7
V505088
p30829
stp30830
a((dp30831
g2
(lp30832
VThere is no way to influence the behaviour of the  method which is implemented by sending a  message to the MDI container window,
p30833
aVNow, looking at  it has an option to skip disabled MDI children from cascading
p30834
aVSo you could disable certain child windows, send a  message yourself and then re-enable the child windows
p30835
aVI've not attempted to do this but it seems very likely to me that it would work
p30836
aVYour other option is to implement your own MDI child positioning method
p30837
aVThis is actually relatively easy to do
p30838
aVI would suggest that you consult the source code for the Wine project to get an idea how to do this
p30839
aVThe key file is  in the  DLL
p30840
as(dp30841
g7
V505088
p30842
stp30843
a((dp30844
g2
(lp30845
VCall the  Windows API function
p30846
aVPass  for  and  if you only want to modify the creation time
p30847
aVYou will need to obtain a file handle by calling , or one of the Delphi wrappers, so this is not the most convenient API to use
p30848
aVMake life easier for yourself by wrapping the API call up in a helper function that receives the file name and a
p30849
aVThis function should manage the low-level details of obtaining and closing a file handle, and converting the  to a
p30850
aVI would do it like this:
p30851
aVI had to add the declaration of  because it is not present in the Delphi 6 Windows unit
p30852
as(dp30853
g7
V505088
p30854
stp30855
a((dp30856
g2
(lp30857
VGoing the other way is easy using P/invoke
p30858
aVCalling managed code from unmanaged is tricker
p30859
aVOne good option is COM, but there is an alternative
p30860
aVRobert Giesecke has published an excellent project that allows you to expose managed methods as unmanaged DLL exports
p30861
aVIt's very simple to use
p30862
aVYou simply download the Visual Studio template, create a project based on that, add your code, and mark exports with the  attribute
p30863
as(dp30864
g7
V505088
p30865
stp30866
a((dp30867
g2
(lp30868
VFor anyone else who encounters the problem, and thanks to TOndrej and Uwe, here is exactly what I did to get integration of svn 1
p30869
aV7 in XE2
p30870
aVI expect the same would work in XE
p30871
aVInstall Version Insight Plus Beta 7
p30872
ag5537
aVInstall the win32svn client
p30873
aVPoint the Delphi IDE at the appropriate svn client with a registry setting in
p30874
aVAdd a  value named , whose value is the  directory of the win32svn client,  in my case
p30875
aVFor XE this would be
p30876
as(dp30877
g7
V505088
p30878
stp30879
a((dp30880
g2
(lp30881
VYour problem is that you are trying to multiply two strings together which is not allowed
p30882
aVYou would get the same error if you wrote this
p30883
aVwhich maybe makes it easier to see
p30884
aVPerhaps you meant to write
p30885
aVAs a piece of more general advice, the compiler emitted an excellent and informative message:
p30886
aVNot all compilers produce such helpful messages, but when they do it is worth reading them carefully
p30887
aVThis messages takes you straight to the root of the problem
p30888
as(dp30889
g7
V505088
p30890
stp30891
a((dp30892
g2
(lp30893
VHowever, what about (1
p30894
aV000011)binary
p30895
aVwe extract 1 and we're left with 000011, and as we can't store leading zeroes inside zero-initialized bitfield, we get 11
p30896
aVIn fact you do store leading zeros
p30897
aVWhat is stored is 000011 and when the 1 is added back in you are back where you started
p30898
aVStoring the leading zeros (after the leading 1 has been removed) is what makes it work
p30899
as(dp30900
g7
V505088
p30901
stp30902
a((dp30903
g2
(lp30904
V variables are supported by the 32 bit Delphi compiler
p30905
aVAll operations on  operands will give identical results no matter what platform (machine, OS etc
p30906
aVthe code executes on
p30907
aVOn 32 bit platforms the compiler has to use special routines to perform 64 bit arithmetic using the 32 bit machine instructions that are available
p30908
aVWhen targetting a 64 bit machine the compiler can use native 64 bit instructions
p30909
aVNo matter, the end result is indistinguishable to you
p30910
aVNote that if you execute a 32 bit Delphi executable on a 64 bit OS, you will still be using the 32 bit emulator, a
p30911
ag4705
ag4706
aVWOW64
p30912
aVFrom the perspective of the executable, you are running on a 32 bit machine
p30913
aVUnless you are using the new 64 bit compiler introduced in XE2, you will be producing 32 bit executables
p30914
as(dp30915
g7
V505088
p30916
stp30917
a((dp30918
g2
(lp30919
VThat's the C runtime library and you can't build a C++ program without a runtime
p30920
aVFor Visual Studio 2010 you would have msvcr100
p30921
aVdll linked in fact since that is the MSVC runtime for that version of the compiler
p30922
aVPlain old msvcrt
p30923
aVdll is the MSVC6 runtime which is now shipped as a Windows system component
p30924
aVIf your executable is linking to msvcrt
p30925
aVdll then you must be linking to something else that in turn links to msvcrt
p30926
aVdll since nothing in VS2010 will take a dependency on the MSVC6 runtime
p30927
aVYou can remove the dependency on msvcr100
p30928
aVdll by using static linking (/MT) but there are pros and cons of choosing that option
p30929
aVIf you use static linking then you can distribute your application as a single executable
p30930
aVIf you use dynamic linking then you have to install the runtime on each target machine
p30931
aVUsing certain third party libraries will force you to use dynamic linking so that the runtime can be shared between your executable and the third party libraries
p30932
as(dp30933
g7
V505088
p30934
stp30935
a((dp30936
g2
(lp30937
VTo do this without polling requires WMI
p30938
aVThis is well supported in
p30939
aVnet and you can use the  class to subscribe to WMI notifications
p30940
aVThis Code Project article illustrates how it is done
p30941
aVHere's an extract showing how straightforward it is
p30942
aVNote that  is a class implemented in the code attached to that article
p30943
as(dp30944
g7
V505088
p30945
stp30946
a((dp30947
g2
(lp30948
VThis is because the compiler you are using is emitting 32 bit code
p30949
aVIf you use a 64 bit compiler then pointers will be 8 bytes wide
p30950
aVNote that most 64 bit systems have the ability to run 32 bit code under an emulation layer
p30951
aVOn Windows the emulation layer is known as WOW64
p30952
aVThis is clearly what is happening here
p30953
as(dp30954
g7
V505088
p30955
stp30956
a((dp30957
g2
(lp30958
VThat's how  works because it uses an  parameter
p30959
aVAn  parameter is always assigned a value in a method and so whatever you initialise the parameter to, it will be overwritten
p30960
aVThe documentation makes this point by stating:
p30961
aVThis parameter is passed uninitialized
p30962
aVSo you have to use a temporary
p30963
as(dp30964
g7
V505088
p30965
stp30966
a((dp30967
g2
(lp30968
VHere is a very simple example showing how to make use of stream extraction operators and  to do this in a more idiomatic C++ manner:
p30969
as(dp30970
g7
V505088
p30971
stp30972
a((dp30973
g2
(lp30974
VYour best option, given the constraints you list, is to use an out-of-proc COM server
p30975
aVYour 32 bit C++Builder app cannot load 64 bit modules
p30976
aVThat's a hard limitation that cannot be bypassed
p30977
aVThis leaves you with some form of inter-process communication and out-of-proc COM will be the easiest to code
p30978
as(dp30979
g7
V505088
p30980
stp30981
a((dp30982
g2
(lp30983
VThe recommended way to do this is to create a folder at install time, dedicated to your application, underneath "ProgramData" (i
p30984
ag192
aV/)
p30985
aVAs you already know, the  folder is read only for standard users
p30986
aVSo  your install program needs to give the folder that it creates an ACL that permits the access that you require
p30987
aVThis is the solution that meets all the criteria laid out in your bullet points
p30988
aVYou mention the registry
p30989
aVThere is no area of the registry that is shared between all users and yet writeable by standard users
p30990
aVWhilst you can use ACLs to grant more permissive access rights to the registry, it is really not the done thing
p30991
aVPlease forget that I even mentioned this possibility
p30992
as(dp30993
g7
V505088
p30994
stp30995
a((dp30996
g2
(lp30997
VAs Uwe points out in the comments,  in Unicode versions of Delphi is of type
p30998
aVBut you are using pre-Unicode Delphi and so  is simply
p30999
aVThis explains the compilation error
p31000
aVHow to proceed depends on what you are attempting to do
p31001
aVIf you intend to translate these strings into different languages then you may be in a bind
p31002
aVIf you are intending to do that then you would obviously be far better off with a Unicode version of Delphi
p31003
aVSo, since you are sticking with a pre-Unicode Delphi I guess you don't actually need to translate the strings
p31004
aVIn which case just change the declaration of the  array from  to
p31005
aVAs it happens, this array is declared by this code but never once referred to
p31006
as(dp31007
g7
V505088
p31008
stp31009
a((dp31010
g2
(lp31011
VThere are all sorts of problems with your program
p31012
aVI begun by trying to write them all down but I feel that code is irredeemable
p31013
aVIt has indexing errors, parameter passing errors, dubious recursion and so on
p31014
aVThe other answers that point out the error of trying to modify a read-only literal are correct
p31015
aVThat is the cause of the error in the code you posted
p31016
aVThe main reason for your troubles, in my view, is that the code is harder to write when you only have a single buffer
p31017
aVYou have tied yourself in knots trying to get around this limitation in your design, but with a second buffer to work with, the code is trivial
p31018
aVIf you want to get really clever you can in fact manage happily with just a single buffer, so long as you keep two distinct pointers for iteration
p31019
aVNote that we had to take a copy of first character in the buffer, the character being removed, since that may be modified by the iteration
p31020
aVSo now you are back where you started, with a single buffer
p31021
aVBut now the code works and is easy to understand
p31022
aVNote that my answer is written in C as per your tag, but note that your code is C++
p31023
as(dp31024
g7
V505088
p31025
stp31026
a((dp31027
g2
(lp31028
VThis application has requested the Runtime to terminate it in an unusual way
p31029
aVThis occurs when some code linked to the MS C runtime calls the C  function
p31030
aVSince Explorer doesn't rely on the MS C runtime the most logical conclusion is that you have a misbehaving shell extension
p31031
aVShell extensions are loaded into the Explorer process and can quite easily wreak havoc like this
p31032
aVI would try this disk on a different machine to test out that theory
p31033
aVOr find a tool that disables shell extensions
p31034
as(dp31035
g7
V505088
p31036
stp31037
a((dp31038
g2
(lp31039
VWhat RRUZ says is quite correct
p31040
aVTo add a little bit more explanation, in 64 bit Delphi, dynamic array indices can be 64 bits wide
p31041
aVThis is clearly needed, for example, when working with a large TBytes memory block
p31042
aVAnd so the  function must return a value of a type wide enough to hold all possible indices
p31043
aVSo,  when applied to a dynamic array, returns a value of type
p31044
aVOnce you start compiling 64 bit code the  operator is unsuited to the problem you are trying to solve
p31045
aVWhilst you could use the cast that RRUZ suggests, it may be clearer to write the code like this
p31046
aVWhilst the  operator makes for quite readable code, it is my opinion that a cast to  is not acceptable here
p31047
aVThat will simply set a trap for you to fall into when you first have an array with more than  elements
p31048
aVWhen that happens the code with the cast will stop working
p31049
aVBut in fact the problems run far deeper than this
p31050
aVThe  version of the code fails long before you reach  elements
p31051
aVIt turns out that your code, whilst it compiles, does not really work
p31052
aVFor example, consider this program:
p31053
aVYou would expect this program to output  but in fact it outputs
p31054
aVIf instead you were to write
p31055
aVthen the compiler reports:
p31056
aVThe fundamental issue here is that sets are limited to 256 elements so as soon as you have an array with length greater than that, your code stops working
p31057
aVSadly, Delphi's support for sets is simply inadequate and is in urgent need of attention
p31058
aVI also wonder whether you actually meant to write
p31059
aVIf so then I would recommend that you use the  function from
p31060
aVor even better
p31061
as(dp31062
g7
V505088
p31063
stp31064
a((dp31065
g2
(lp31066
VThe  function is in the  unit
p31067
aVAdd that unit to your  clause
p31068
as(dp31069
g7
V505088
p31070
stp31071
a((dp31072
g2
(lp31073
VThere's no direct equivalent of a C static variable in Delphi
p31074
aVA writeable typed constant (see user1092187's answer) is almost equivalent
p31075
aVIt has the same scoping and instancing properties, but does not allow the one-time initialization that is possible with a C or C++ static variable
p31076
aVIn any case it is my opinion that writeable typed constants should be shunned as a quaint historical footnote
p31077
aVYou can use a global variable
p31078
aVYou have to do the one-time initialization in the  section:
p31079
aVOf course this make a mess of the global namespace unlike the limited scope of a C static variable
p31080
aVIn modern Delphi you can wrap it all up in a class and use a combination of class methods, class vars, class constructors to avoid polluting the global namespace
p31081
as(dp31082
g7
V505088
p31083
stp31084
a((dp31085
g2
(lp31086
VWhen you call , passing the same directory name, from different machines, only one call will succeed
p31087
aVThe API function will only return  if it was the called that actually made the directory
p31088
aVThe operating system on the machine which owns the filesystem makes this process atomic
p31089
aVHowever, there's nothing to stop another processing getting in and deleting the directory in between the two calls to
p31090
aVSo whilst you can get a primitive form of locking working, it's not very robust and needs all parties to cooperate
p31091
aVThe same reasoning applies to
p31092
as(dp31093
g7
V505088
p31094
stp31095
a((dp31096
g2
(lp31097
VYou can infer the length of an array if you have an array variable
p31098
aVYou cannot infer the length of an array if you have just a pointer to it
p31099
as(dp31100
g7
V505088
p31101
stp31102
a((dp31103
g2
(lp31104
VC does not have the support for strings that some other languages have
p31105
aVA string is C is just a pointer to an array of  that is terminated by the first null character
p31106
aVThere is no string concatenation operator in C
p31107
aVUse  to concatenate two strings
p31108
aVYou could use the following function to do it:
p31109
aVThis is not the fastest way to do this, but you shouldn't be worrying about that now
p31110
aVNote that the function returns a block of heap allocated memory to the caller and passes on ownership of that memory
p31111
aVIt is the responsibility of the caller to  the memory when it is no longer needed
p31112
aVCall the function like this:
p31113
aVIf you did happen to be bothered by performance then you would want to avoid repeatedly scanning the input buffers looking for the null-terminator
p31114
aVIf you are planning to do a lot of work with strings then you may be better off using a different language that has first class support for strings
p31115
as(dp31116
g7
V505088
p31117
stp31118
a((dp31119
g2
(lp31120
VYou cannot reliably pass objects across DLL boundaries
p31121
aVInstead you should pass interfaces across the boundary and use  or  to query capabilities
p31122
aVInterfaces are designed for binary compatibility across DLL boundaries, but objects are not
p31123
aVYou can readily pass an  from one DLL to another and then query that
p31124
aVOr, if you have a common interface that all plugin objects implement, you could pass that
p31125
aVAll that matters is that you always pass interfaces and never pass objects
p31126
as(dp31127
g7
V505088
p31128
stp31129
a((dp31130
g2
(lp31131
VYou would normally use this option in a release build
p31132
aVIt's safe and mainstream to do so
p31133
aVThere's no reason to be afraid of releasing code with optimizations enabled
p31134
aVEnabling optimization can interfere with debugging which is a good reason to disable it for debug builds
p31135
as(dp31136
g7
V505088
p31137
stp31138
a((dp31139
g2
(lp31140
VIf you want to do this yourself you can
p31141
aVIterate over all files counting the total size to be copied
p31142
aVCall CopyFileEx to do the copying
p31143
aVThis uses a callback mechanism to report progress and that callback includes the number of bytes copied for the current file
p31144
aVKeep track of how many bytes have been copied in total and use that to report an overall progress
p31145
aVThere is quite possibly a
p31146
aVnet managed equivalent to CopyFileEx
p31147
aVHowever, I would recommend calling SHFileOperation and let the system do the hard work for you
p31148
aVAs you are discovering this task is exceedingly hard to do well
p31149
aVAs an added benefit of using the shell to do the work, you'll get the standard system dialog
p31150
as(dp31151
g7
V505088
p31152
stp31153
a((dp31154
g2
(lp31155
VI interpret your question that you would like  exceptions to be raised whenever a Pascal style I/O function fails
p31156
aVIn order to do this you need to enable the I/O checking compiler option
p31157
aVI/O checking: Enables or disables the automatic code generation that checks the result of a call to an I/O procedure
p31158
aVIf an I/O procedure returns a nonzero I/O result when this switch is on, an EInOutError exception is raised (or the program is terminated if exception handling is not enabled)
p31159
aVWhen this switch is off, you must check for I/O errors by calling IOResult
p31160
aVI guess the code you are working with was written under the assumption that the I/O checking option was enabled, but that you are compiling with it not enabled
p31161
aVHere's a bit of code that demonstrates  being raised due to an I/O error
p31162
aVI strongly recommend that you enable I/O checking
p31163
aVThis will allow you to handle errors using exceptions in a manner consistent with the rest of your code
p31164
aVNot using I/O checking forces you to check the value of  after every I/O function
p31165
aVThis is very error prone (it's easy to forget to check) and results in untidy code
p31166
aVIf you are already running with I/O checking enabled then the most likely explanation for you not seeing an error is that in fact no error is occurring
p31167
aVPerhaps the file does in fact exist
p31168
as(dp31169
g7
V505088
p31170
stp31171
a((dp31172
g2
(lp31173
VI have also noticed this behaviour change and find it very annoying
p31174
aVIt forces me to reach for the mouse when I don't want to and never used to
p31175
aVSo far as I can tell there is no way to restore the old behaviour and I suspect that this is in fact a regression in the IDE
p31176
aVOne reinforcement for that view is that it used to work for RTL/VCL units and surely there's no need for me to tell the IDE where to find them
p31177
aVIf nobody comes up with a solution then I think it should be reported to Quality Central
p31178
as(dp31179
g7
V505088
p31180
stp31181
a((dp31182
g2
(lp31183
VI doubt that you need to have one thread per task
p31184
aVIt would probably suffice to create one timer per task
p31185
aVIf a timer fires whilst another task is running then the second task will have to queue up but it doesn't sound like that will be a great problem
p31186
aVIf you are going to use a Delphi  to do this you'll need to make sure that your service has a message queue and runs a message loop on that queue
p31187
aVYou may wish to run that message queue on a separate thread but if you do make sure that the  objects are created on that thread so that they are associated with the right message queue
p31188
aVYou ask in the comments how to run a message loop in a thread
p31189
aVThe following code should suffice:
p31190
aVThis will give you all the bells and whistles of the Delphi message loop
p31191
aVIf you want a very standard message loop you can use this:
p31192
aVIf all you want is to pump  messages both will work but I personally would be inclined to go with the second option, the raw Win32 API version
p31193
as(dp31194
g7
V505088
p31195
stp31196
a((dp31197
g2
(lp31198
VYou have a record containing a static array
p31199
aVThis particular record has a size equal to
p31200
aVJudging by the the fact that your array is sized with a  constant it looks like you have a variable number of points in the array
p31201
aVI think I would be inclined to switch to dynamic arrays like this:
p31202
aVNow if you have a variable, , then a value of  indicates that it is empty or nil
p31203
aVYou can query for the length of the array with
p31204
aVYou can resize the array with
p31205
as(dp31206
g7
V505088
p31207
stp31208
a((dp31209
g2
(lp31210
VYou cannot do that with a  which is a loose wrapper around the  API
p31211
aVIn order to do this you would need to keep track of when the timer started and when you paused it
p31212
aVThen you would know how much time was left
p31213
aVWhen you need to pause, set the timer  property to  and set the interval to be the amount of time remaining
p31214
aVDon't forget that after the timer fires for the first time you need to reset its interval to the true interval
p31215
aVAs you can see from the above, a  is not the best fit for your problem
p31216
aVBut, having said that it would not be terribly difficult, and quite fun, to produce a  variant that supported pausing the way you desire
p31217
as(dp31218
g7
V505088
p31219
stp31220
a((dp31221
g2
(lp31222
VYou can do this with the following sequence of Win32 API calls:
p31223
aVUse Spy++ or something similar to find the class name of the top level window you are targeting
p31224
aVCall  or  to find top-level windows with that class name
p31225
aVCall  to find the process ID of each window of interest
p31226
aVCall  passing the process ID to get a process handle
p31227
as(dp31228
g7
V505088
p31229
stp31230
a((dp31231
g2
(lp31232
VThinking a little outside the box, have you considering showing the Windows password dialog rather than writing your own
p31233
aVThis has the advantage of making your dialog look and feel more native
p31234
aVYou can get the dialog to show, customised for your needs, with the  API
p31235
aVThere are lots of C# wrappers around but it's a pretty straight forward p/invoke if you fancy doing it yourself
p31236
aVI quick websearch revealed this Stack Overflow question with the necessary p/invoke work already done
p31237
as(dp31238
g7
V505088
p31239
stp31240
a((dp31241
g2
(lp31242
VThere's really very little that can go wrong here
p31243
aVIf you set up a test app to try this out then it functions just as you would expect and the event handlers are called
p31244
aVThe most likely cause of the behaviour you report is if the items are added before the event handlers are assigned
p31245
aVThis typically happens if the items are added at design time in the
p31246
aVdfm file
p31247
aVYou say you are adding the items at runtime
p31248
aVPerhaps you are adding them too soon, before the event handlers are assigned
p31249
aVWhat happens if you add items in response to an event, e
p31250
ag217
aVa button click
p31251
aVTry that out because you can be sure then then the event handlers are assigned by that point
p31252
aVIf that doesn't help then clearly you have some code in your app that is interfering with the VCL code
p31253
as(dp31254
g7
V505088
p31255
stp31256
a((dp31257
g2
(lp31258
VWith optimizations enabled, the code above will, at least in some situations, be optimised to remove the first assignment
p31259
aVSo this is probably not a very good example
p31260
aVThat this is so can be seen with this minimal example:
p31261
aVHowever, I've never encountered problems with the compiler optimising global or heap based variables into registers
p31262
aVIt always seems to write it back to the memory
p31263
aVBut I'm sure you won't find anything in the documentation guaranteeing any of that
p31264
aVHowever, this is not the same as MSVC volatile since the cache is in the way and no memory barriers or fences are used
p31265
aVEven when the Delphi compiler emits instructions to write the value to memory, it will first of all go into the cache of the processor on which the code is running
p31266
aVCode executing on other processors will not be able to see that write until the caches have been synchronized
p31267
aVIf you want to share such a variable between threads, probably the easiest approach is to use the InterlockedXXX functions to enforce the necessary barriers and ensure that all threads have a consistent view of the variable
p31268
aVNote: when you talk about volatile, you need to be careful as there are lots of different definitions
p31269
aVThe meaning defined in the C and C++ standards is one
p31270
aVThe MSVC compiler has a standards compliant but stronger definition
p31271
aVAnd it's different again in Java and C#
p31272
aVThere's a lot of complexity here and the InterlockedXXX functions are a great way to hide that complexity
p31273
as(dp31274
g7
V505088
p31275
stp31276
a((dp31277
g2
(lp31278
VNo there is not
p31279
aVThe problem is that once the compiler can't compile one unit, it's in no position to compile the other ones that, more than likely, depend on the unit that could not be compiled
p31280
aVThis is because compilation of a unit requires a
p31281
aVdcu file for all of the used units
p31282
as(dp31283
g7
V505088
p31284
stp31285
a((dp31286
g2
(lp31287
VThis is a classic problem
p31288
aVA  loop evaluates the loop bounds once at the beginning of the loop, so you run off the end which explains your index out of bounds errors
p31289
aVBut even if  loops evaluated loop bounds every time like a  does that would not really help
p31290
aVWhen you delete an element, you reduce the  by 1 and move the remaining elements down one in the list
p31291
aVSo you change the index of all those still to be processed elements
p31292
aVThe standard trick is to loop down the list:
p31293
aVWhen you write it this way, the call to  affects the indices of elements that have already been processed
p31294
as(dp31295
g7
V505088
p31296
stp31297
a((dp31298
g2
(lp31299
VThe color of the interior is determined by
p31300
aVThe perimeter will be drawn in the color specified by
p31301
aVYou will also need to make sure the Set  is set appropriately, e
p31302
ag217
aVto  and likewise for , e
p31303
ag217
aVThe documentation for  states it like this:
p31304
aVThe ellipse is outlined using the value of Pen, and filled using the value of Brush
p31305
as(dp31306
g7
V505088
p31307
stp31308
a((dp31309
g2
(lp31310
VYou cannot obtain, at runtime, the size of an array if you only have a pointer to (the first element of) the array
p31311
aVThere are no constructs at all in C that allow you to do this
p31312
aVYou have to keep track of the length yourself
p31313
aVIf you happen to have an array rather than a pointer then you can find its length, but not for a pointer to an element of the array
p31314
aVIn your code,  is a pointer and so you cannot find out the length of the array to which it points
p31315
aVOn the other hand,  is an array and so you can find out its length with
p31316
as(dp31317
g7
V505088
p31318
stp31319
a((dp31320
g2
(lp31321
VThe thing that jumps out at me is that  is set incorrectly
p31322
aVYou need to account for the zero-terminator at the end of the string
p31323
aVThat would certainly explain the error
p31324
aVWhen you send the message, the  marshalling would not copy the zero terminator and so the recipient would then read beyond the end of the buffer into uninitialized values
p31325
aVI also wonder about
p31326
aVAre you calling the Unicode version of SendMessage
p31327
aVIf not then I'd expect to see access violations in the sending code
p31328
aVYou should also be wary that the recipient application opens itself to buffer overruns
p31329
aVBecause it ignores the value of  and treats the  field as a null-terminated pointer it may be possible for an attacker to force your app to execute arbitrary code
p31330
aVTo defend against this, you should copy the data,  bytes of it, into a byte array and then convert to a string
p31331
aVThe other issue is that you need to declare  as
p31332
aVThe way you have defined the struct, the recipient code treats  as a pointer to a string which will provoke AVs because you have crossed process boundaries
p31333
aVI'd also point out that  is unsigned and should be  but that is a benign error here
p31334
as(dp31335
g7
V505088
p31336
stp31337
a((dp31338
g2
(lp31339
VYou can do this with PATH but I recommend you don't
p31340
aVIt's a brutal and inflexible approach
p31341
aVAnd of course you need to change the system wide PATH for it to have any effect at executable load time
p31342
aVYou can load your DLLs explicitly with  and
p31343
aVThat's no fun if there are a lot of imports but it can be a good option otherwise
p31344
aVAnd remember that if you go down this route, every single DLL must switch to explicit linking
p31345
aVThere is something called DLL Redirection but MS don't recommend you use that
p31346
aVThey recommend that you use side-by-side components
p31347
aVHaving said that, the Visual Studio team moved away from side-by-side components with the MSVC runtime in VS2010 because of the pain that side-by-side had caused in previous release
p31348
aVSo, in spite of all the options, I really believe that the best solution is to put all the DLLs in the same directory as the executable
p31349
aVIf you can get over the folder looking untidy then it will make life much simpler
p31350
aVIt is a trivial no effort solution to the problem
p31351
aVUpdate
p31352
aVThe update to your question provides the extra information that these DLLs are optional add-ons
p31353
aVIn this case you simply have no alternative but to use explicit linking with  and
p31354
as(dp31355
g7
V505088
p31356
stp31357
a((dp31358
g2
(lp31359
VIf you want portability then you should use a regex library written in portable C
p31360
aVFor example PCRE
p31361
aVThere is no regular expression support in the C standard library so you have to look outside that
p31362
as(dp31363
g7
V505088
p31364
stp31365
a((dp31366
g2
(lp31367
VThere are a couple of basic problems here
p31368
aVFirst of all you don't call  with a window handle
p31369
aVIt's not that kind of handle
p31370
aVYou use  when you have a  but an  is not a
p31371
aVIf you want to destroy a window handle you need to call
p31372
aVHowever, the documentation for  states:
p31373
aVA thread cannot use DestroyWindow to destroy a window created by a different thread
p31374
aVSo you can't do that either
p31375
aVWhat you can do is to send a  message to the window
p31376
aVThat should be enough to persuade it to close gracefully
p31377
aVNote that  is sent rather than posted
p31378
aVThis can be discerned by this line from the documentation:
p31379
aVA window receives this message through its WindowProc function
p31380
aVUpdate
p31381
aVJohn Knoller points out that I am misinterpreting the Windows documentation which was not written to cover the situation where one application attempts to close down another application
p31382
aVJohn's advice is:
p31383
aVIn fact it's wiser to send  to another process using  or
p31384
aVIf you use , you will get stuck if the process isn't pumping messages
p31385
aVIt's even better to use / which is basically the same thing as clicking on the window caption's close button
p31386
as(dp31387
g7
V505088
p31388
stp31389
a((dp31390
g2
(lp31391
VFunnily enough I was trying to do the exact same thing yesterday for the executable file of my app
p31392
aVI reached the conclusion that it is not possible to change the name of the output file
p31393
aVThe only way you can influence the output file's name is with the  directive but that just controls the extension of the output which is not what you want
p31394
aVUpdate
p31395
aVThanks to @TOndrej for pointing out the  directive
p31396
aVThis does not appear to be modifiable via the IDE project options for libraries, although there is such support for packages
p31397
aVHowever, it does indeed work when included in the source code of your package
p31398
aVInclude this in your library
p31399
aVdpr file
p31400
aVThis does not have any effect for projects that produce executables (i
p31401
ag192
aVVCL apps, services etc
p31402
aVand so I believe the only solution in those cases is a post-build action
p31403
as(dp31404
g7
V505088
p31405
stp31406
a((dp31407
g2
(lp31408
VYour issue is that Delphi 2009 uses Unicode rather than ANSI for its text
p31409
aVThis was a major breaking change which requires significant porting effort
p31410
aVNot only do you need to deal with encoding issues in your code, you will need to upgrade any 3rd party components that you use
p31411
aVYou can revert to the previous behaviour for this particular function like this:
p31412
aVIn Delphi 2009 the  data type is a UTF-16 encoded string
p31413
aVThe ANSI encoded string that previous versions of Delphi is named
p31414
aVSimilarly  generates a 16 but  character but you want an , the 8 bit ANSI character type
p31415
aVHowever, there will surely be a number of other issues to tackle
p31416
aVI suggest you read Marco Cant's whitepaper on Delphi and Unicode
p31417
aVYou really should get on top of the issues detailed in this paper before proceeding any further with the port
p31418
as(dp31419
g7
V505088
p31420
stp31421
a((dp31422
g2
(lp31423
VCasts are dangerous because you go outside the type checking system
p31424
aVThat has caught you out here
p31425
aVThe issue is that  and  are not the same type
p31426
aVYou need to declare your array as a distinct type like this
p31427
aVThen do your constant like this:
p31428
aVWhen you need to extract the array from the combo box do it like this:
p31429
aVIf you need to support using dynamic array lengths then you would need to change your common type to reflect that
p31430
aVHowever, beware that casting to an  to put in  will bypass the reference counting of the dynamic array
p31431
aVSo you need to really understand what you are doing if you go down that route
p31432
aVOne final point
p31433
aVIf ever you wish to compile this code for 64 bit it will fail because of this line:
p31434
aVsince  is a 32 bit data type
p31435
aVInstead you should use  which is is an integer the same width as a pointer
p31436
as(dp31437
g7
V505088
p31438
stp31439
a((dp31440
g2
(lp31441
VYou can explicitly use the Unicode version of the API
p31442
aVYou are currently building your application for ANSI characters
p31443
aVIf you want to use Unicode throughout you should change your project options to use Unicode
p31444
aVIf you did that you can simply write it as
p31445
aVWindows API functions that have parameters which contain text are available in two versions, an ANSI version and a Unicode version
p31446
aVFor example the user32 DLL does not export a function called
p31447
aVInstead it exports , the ANSI version, and , the Unicode version
p31448
aVMacros in the Windows header files convert  into either  or , depending on which character set you target
p31449
aVIn Visual Studio you can set this option in the project configuration under Configuration Properties | General | Character Set
p31450
aVSelect Use Unicode Character Set
p31451
as(dp31452
g7
V505088
p31453
stp31454
a((dp31455
g2
(lp31456
VYou have to use the  prefix for all your Unicode strings
p31457
aVA non-prefixed string, e
p31458
ag217
aV, is always a  based string
p31459
aVThere is no shortcut in the language that would treat such a string as a wide character string
p31460
as(dp31461
g7
V505088
p31462
stp31463
a((dp31464
g2
(lp31465
VOne easy approach is to call the  API function
p31466
aVUnfortunately this function is mis-declared in the Delphi Windows unit, at least it is in XE2
p31467
aVBut there is a version declared in SysUtils which is correct
p31468
aVMake sure you use that version
p31469
as(dp31470
g7
V505088
p31471
stp31472
a((dp31473
g2
(lp31474
VYou don't need to delete anything and it seems wasteful to do so
p31475
aVIt would make your code messier and cost CPU time
p31476
aVJust iterate over the array of bytes:
p31477
aVIf you don't want to do this in a loop, keep track of the index of the next byte to be processed
p31478
aVEvery time you process a byte, increment the index
p31479
aVInitialise an index variable to 0 and keep calling this function, extracting one byte at a time, until it returns False
p31480
as(dp31481
g7
V505088
p31482
stp31483
a((dp31484
g2
(lp31485
VC/C++
p31486
aVWhen one or more of the variables ,  etc
p31487
aVare of type  then the multiplication by  is pointless
p31488
aVYou should simply remove it since it serves no purpose
p31489
aVWhen all of the variables are of type  then the multiplication by the  literal  forces the expression to be evaluated with double precision arithmetic
p31490
aVOn the other hand, when all of the variables are integers, the multiplication by  forces the calculation to be performed with floating point arithmetic
p31491
aVWithout the multiplication the calculation would be performed with integer arithmetic which would yield a different result
p31492
aVMy guess is that the code originally used integers and the  was needed
p31493
aVAt some point in time the code was changed to use floating point variables but the now spurious multiplication was not removed
p31494
aVDelphi
p31495
aVIf you saw such an expression in Delphi code then you should simply remove the multiplication
p31496
aVThe presence of a division operator forces the expression to be evaluated as a floating point expression
p31497
aVThe rules for Delphi expression evaluation are a little different from C and C++
p31498
aVIn C and C++ a single symbol,  is used for both integer and floating point division, with the context of the expression determined which form of division is used
p31499
aVIn Delphi  is floating point division and  is integer division
p31500
as(dp31501
g7
V505088
p31502
stp31503
a((dp31504
g2
(lp31505
VThis should work fine if I understand you correctly:
p31506
aVThe  call will ensure that all managed types are set to  which I believe is your intent
p31507
aVThis question is very closely related to your previous question and I think that you could make use of  parameters to simplify the code
p31508
aVA function result is implicitly a  parameter, but if you used an explicit  parameter it will initialise the managed types as you desire
p31509
aVPersonally, since you are introducing an interface into the mix, I think I would be inclined to go all the way and use interfaces exclusively
p31510
aVOr use standard classes and accept the need for try/finally lifetime management
p31511
as(dp31512
g7
V505088
p31513
stp31514
a((dp31515
g2
(lp31516
VWell, to create a  you need to do the following:
p31517
aVCreate a variable to work with
p31518
aVEither a local variable or a class member
p31519
aVThen you construct it
p31520
aVThe parameter to the constructor is the owner
p31521
aVThis ensures that the control is destroyed when its owner is destroyed
p31522
aVMy assumption is that  is a form
p31523
aVNow you need to give the control a parent
p31524
aVOr perhaps it's on a panel
p31525
aVFinally, you set the text
p31526
aVWith a label it's all very similar except that you use the  property rather than the  property
p31527
aVAnd you will surely want to set other properties but I guess you already know how to do that
p31528
as(dp31529
g7
V505088
p31530
stp31531
a((dp31532
g2
(lp31533
VYou clearly have a mismatch between the p/invoke code and the Delphi code
p31534
aVYou have not shown the Delphi code but the C# code is enough to know what the Delphi code should look like
p31535
aVYour  attribute uses default values for calling convention and character set
p31536
aVThis means that the calling convention is  and the character set is ANSI
p31537
aVYou have not specified any marshalling attributes so default marshalling must be used
p31538
aVTherefore your Delphi code must look like this:
p31539
aVAnd now here's the problem
p31540
aVThe p/invoke marshaller treats a  return value in a very special way
p31541
aVIt assumes that it is the responsibility of the p/invoke marshaller to deallocate the return value's memory
p31542
aVAnd it has to use the same allocator as the native code
p31543
aVThe assumption made by the marshaller is that the shared COM allocator will be used
p31544
aVSo the rule is that the native code must allocate the memory with the COM allocator by calling
p31545
aVMy bet is that your code does not do that and that will certainly result in errors
p31546
aVHere is an example of how you could make a native Delphi function that works with the C# signature in your code
p31547
aVWhilst you could adopt this approach I recommend an alternative
p31548
aVMarshal all your strings as  on the C# side and  on the Delphi side
p31549
aVThese are matching types which are also allocated by the COM allocator
p31550
aVBoth parties know exactly what to do with these types and will make your life easier
p31551
aVUnfortunately, you cannot return a  from a Delphi function across an interop boundary because Delphi uses a different ABI for function return values
p31552
aVMore details of this issue can be found in my question Why can a WideString not be used as a function return value for interop
p31553
aVSo to work around that, we can declare the return type from the Delphi code to be
p31554
aVYour code would then look like this:
p31555
aVC#
p31556
aVDelphi
p31557
as(dp31558
g7
V505088
p31559
stp31560
a((dp31561
g2
(lp31562
VThe way to stop an exception propagating is to catch it with an
p31563
aVNote that you don't write the  where you raise the exception, but at the point where you want it to stop propagating
p31564
aVHowever, you should probably not stop an exception raised inside a constructor from propagating outside that constructor
p31565
aVIf you do so your object may be partially constructed
p31566
aVI believe the correct solution to your problem is, as many others have said, to raise exceptions when you encounter errors and let them float up to a high level exception handler
p31567
as(dp31568
g7
V505088
p31569
stp31570
a((dp31571
g2
(lp31572
VThe main reason is to prevent the C++ name mangler from mangling the name of the function
p31573
aVTry exporting it without the  and inspect the resulting DLL in Dependency Walker and you will see a quite different name for the exported function
p31574
as(dp31575
g7
V505088
p31576
stp31577
a((dp31578
g2
(lp31579
VTwo problems here
p31580
aVFirst of all C#  does not match C
p31581
aVOn Windows,  long is 32 bits
p31582
aVUse  in your C# code to match up with your C
p31583
aVThe other problem is that the calling conventions probably don't match
p31584
aVYou most likely have  in your C DLL but the C# default is
p31585
aVFix this by changing your p/invoke
p31586
as(dp31587
g7
V505088
p31588
stp31589
a((dp31590
g2
(lp31591
VYou want to do something like this:
p31592
aVIf you want floating point arithmetic do it like this
p31593
as(dp31594
g7
V505088
p31595
stp31596
a((dp31597
g2
(lp31598
VThe code required for VB
p31599
aVnet is almost identical:
p31600
aVThe points of note here are:
p31601
aVin Delphi is the prefix for hexadecimal
p31602
aVThe  corresponds to
p31603
as(dp31604
g7
V505088
p31605
stp31606
a((dp31607
g2
(lp31608
VOli has correctly identified the cause of your problem
p31609
aVI think it is also worth pointing out that your code is needlessly complex
p31610
aVYou can write it more easily with a loop and bitwise shifting:
p31611
as(dp31612
g7
V505088
p31613
stp31614
a((dp31615
g2
(lp31616
VYour variables are local to the procedure where they are created so you can't refer to them using those variables when outside that procedure
p31617
aVThe solution is to make them fields of the form class
p31618
aVThen your  event handler can refer to them
p31619
aVDon't forget to remove the local variables from  and use the fields instead
p31620
as(dp31621
g7
V505088
p31622
stp31623
a((dp31624
g2
(lp31625
VThe problem is in here:
p31626
aVIf you don't find , the loop continues beyond the end of the array
p31627
aVYou need to add an extra test to your  loop to make it terminate if it reaches the end of the array without having found a match
p31628
aVAs it happens, I don't understand why your for loop starts at
p31629
aVIt would be more natural to do it like this:
p31630
aVAlso, your  variable feels poorly named
p31631
aVIt should perhaps be called  since it is  when the name has not been found, but  when it has
p31632
as(dp31633
g7
V505088
p31634
stp31635
a((dp31636
g2
(lp31637
V in the code above is not necessary since that value is immediately overwritten
p31638
aVYour compiler would probably eliminate the redundant code at the optimization stage
p31639
aVSimply remove that line of code
p31640
as(dp31641
g7
V505088
p31642
stp31643
a((dp31644
g2
(lp31645
VThis is a very broad question with many different angles
p31646
aVThe meaning of the  function
p31647
aVMuch of the code in your question betrays an incorrect understanding of the  function
p31648
aVThe documentation states this:
p31649
aVTests for a nil (unassigned) pointer or procedural variable
p31650
aVUse
p31651
aVAssigned to determine whether the pointer or procedure referenced by P
p31652
aVis nil
p31653
aVP must be a variable reference of a pointer or procedural
p31654
aVtype
p31655
aVAssigned(P) corresponds to the test P<> nil for a pointer
p31656
aVvariable, and @P <> nil for a procedural variable
p31657
aVAssigned returns
p31658
aVFalse if P is nil, True otherwise
p31659
aVNote: Assigned cannot detect a
p31660
aVdangling pointer--that is, one that is not nil but no longer points to
p31661
aVvalid data
p31662
aVFor example, in the code example for Assigned, Assigned
p31663
aVdoes not detect that P is not valid
p31664
aVThe key points to take from this are:
p31665
aVis equivalent to testing
p31666
aVcannot detect whether the pointer or object reference is valid or not
p31667
aVWhat this means in the context of this question is that
p31668
aVand
p31669
aVare completely interchangeable
p31670
aVTesting  before calling
p31671
aVThe implementation of  is very special
p31672
aVThis allows you to call  on an object reference that is  and doing so has no effect
p31673
aVFor what it is worth, I am aware of no other place in the RTL/VCL where such a trick is used
p31674
aVThe reason why you would want to allow  to be called on a  object reference stems from the way constructors and destructors operate in Delphi
p31675
aVWhen an exception is raised in a constructor, the destructor is called
p31676
aVThis is done in order to deallocate any resources that were allocated in that part of the constructor that succeeded
p31677
aVIf  was not implemented as it is then destructors would have to look like this:
p31678
aVThe next piece of the jigsaw is that Delphi constructors initialise the instance memory to zero
p31679
aVThis means that any unassigned object reference fields are
p31680
aVPut this all together and the destructor code now becomes
p31681
aVYou should choose the latter option because it is much more readable
p31682
aVThere is one scenario where you need to test if the reference is assigned in a destructor
p31683
aVIf you need to call any method on the object before destroying it then clearly you must guard against the possibility of it being
p31684
aVSo this code would run the risk of an AV if it appeared in a destructor:
p31685
aVInstead you write
p31686
aVTesting  outside a destructor
p31687
aVYou also talk about writing defensive code outside a destructor
p31688
aVFor example:
p31689
aVIn this situation there is again no need to test  in
p31690
aVThe reason being that you simply cannot call  unless the constructor of  succeeded
p31691
aVAnd if the constructor of  succeeded then you know for sure that  was assigned
p31692
aVSo again you make your code much less readable and harder to maintain by putting in spurious calls to
p31693
aVThere is a scenario where you need to write  and that is where the existence of the object in question is optional
p31694
aVFor example
p31695
aVIn this scenario the class supports two modes of operation, with and without logging
p31696
aVThe decision is taken at construction time and any methods which refer to the logging object must test for its existence
p31697
aVThis not uncommon form of code makes it even more important that you don't use spurious calls to  for non-optional objects
p31698
aVWhen you see  in code that should be a clear indication to you that the class can operate normally with  not in existence
p31699
aVIf you spray gratuitous calls to  around your code then you lose the ability to tell at a glance whether or not an object should always exist
p31700
as(dp31701
g7
V505088
p31702
stp31703
a((dp31704
g2
(lp31705
VIf you are talking about, for example, a  control or something similar, then there is no persistent canvas to paint on
p31706
aVThe system simply is not designed that way and the VCL controls reflect the underlying Windows framework
p31707
aVThe normal approach is as follows:
p31708
aVPaint first to an offscreen bitmap
p31709
aVWhen the system asks for a repaint, draw the offscreen bitmap onto the screen canvas
p31710
aVThere are a variety of reasons that may lead you to this approach
p31711
aVOften performance is a factor
p31712
aVIt may be expensive to paint and caching the image can help
p31713
aVSometimes the information required in order to paint may be transient and again caching the output may be a solution
p31714
as(dp31715
g7
V505088
p31716
stp31717
a((dp31718
g2
(lp31719
VLooks like a simple stack overflow caused by the recursion depth
p31720
aVYour options:
p31721
aVDon't worry about it, you'd never write this sort of code for real
p31722
aVIncrease the stack size
p31723
aVDo your homework assignment without using recursion if that is permitted
p31724
as(dp31725
g7
V505088
p31726
stp31727
a((dp31728
g2
(lp31729
VYour main options are MSVC and mingw
p31730
aVIf you want to write C code then avoid MSVC which doesn't have a real C compiler, just a fake wrapper around its C++ compiler
p31731
aVOh, and the supported dialect is close to C89
p31732
aVIf you want to write C++ then MSVC is fine and modern versions have become quite good and reasonably compliant with the standards
p31733
aVIf you want to write both C and C++ as per your question then mingw is probably best
p31734
aVNote that mingw is a native Windows port of the GNU compilers and does not require cygwin
p31735
aVThe 32 bit version of mingw is simple to install
p31736
aVIf you need to produce 64 bit executables then it's a bit more work to get the 64 bit version of mingw installed
p31737
aVSimilarly, if you want the free MS compiler in 64 bit mode you have to do some dirty work to get it installed
p31738
aVWith all of these options you can statically link the runtime to avoid having to deploy a runtime to target machines
p31739
as(dp31740
g7
V505088
p31741
stp31742
a((dp31743
g2
(lp31744
VYou just need to pass a reference to the  to the  class
p31745
aVI don't know what your  class looks like but basically you need to add a method like this:
p31746
aVAnother option may be to pass the notify icon to the  constructor, in exactly the same way, and make a copy of the reference
p31747
aVThat could make sense if you needed access to the notify icon repeatedly
p31748
aVHowever, this couples the two classes closely together and may be limiting if ever you need to use your balloon tip without a notify icon
p31749
aVSo yet another option would be to extract the information from the notify icon in your main form class and pass that to your balloon tip class
p31750
aVThis keeps the two classes decoupled and independent
p31751
aVOf course, if the balloon tip needs to invoke methods of the notify icon then that approach won't work
p31752
as(dp31753
g7
V505088
p31754
stp31755
a((dp31756
g2
(lp31757
VI think the best approach is to call  and work out what you need from  and
p31758
aVYou can simply subtract the former from the latter to obtain the total available addressable memory space
p31759
aVYour three bullet points of the various possibilities are correct
p31760
as(dp31761
g7
V505088
p31762
stp31763
a((dp31764
g2
(lp31765
VYou need to destroy the components within the panel before destroying the panel itself
p31766
aVI'm not sure why this is so but the debugger was telling me that your controls were attempting to handle messages after the panel started destroying itself
p31767
aVThat's not good
p31768
aVThis version of your  method gets the job done
p31769
aVBefore we kill the panel, we iterate around its children killing each of them until there are none left
p31770
aVUpdate
p31771
aVThis code is probably still broken because the button is destroyed from its own event handler
p31772
aVThat's bound to lead to runtime errors since code will execute on an object that has been destroyed
p31773
aVSolve that problem by not deleting in the event handler
p31774
aVInstead post a message to the form and delete upon receipt of that message
p31775
aVThen write a message handler and call DeleteID from there
p31776
as(dp31777
g7
V505088
p31778
stp31779
a((dp31780
g2
(lp31781
VYou've got this the wrong way round
p31782
aVYou should run all the UI in the same thread, and run the long calculation in a background worker
p31783
aVTrying to run UI in different threads within the same app just leads to pain
p31784
as(dp31785
g7
V505088
p31786
stp31787
a((dp31788
g2
(lp31789
VThis is how I would do it
p31790
aVCreate a new package which will be installed into the IDE at designtime
p31791
aVIf you have an existing package handy then you could carry on using it
p31792
aVMake sure the package  the  package
p31793
aVYou can do this in the project manager, or just by viewing the project source and adding  to the  clause
p31794
aVNow add the following unit to your package
p31795
aVWhen you compile and install this package you will now have a new menu item on the File menu which both clears the read-only flag in the input buffer and makes the file writeable
p31796
as(dp31797
g7
V505088
p31798
stp31799
a((dp31800
g2
(lp31801
VUse a CBT hook to receive notification of windows being closed
p31802
aVNote that this would likely be easier from native code
p31803
aVFrom mananged code you will expend a lot of energy working out p/invoke signatures, marshalling etc
p31804
as(dp31805
g7
V505088
p31806
stp31807
a((dp31808
g2
(lp31809
VThe  things are environment variables
p31810
aVI tried setting the host application to  and received this error message:
p31811
aVNote how the  was turned into environment variable syntax
p31812
aVI also tried with  and received this error message:
p31813
aVSo clearly environment variables will be substituted with their values, if they do exist
p31814
aVI think it is reasonable to conclude that the environment used to start a host application clearly does not define the special Delphi specific environment variables
p31815
aVSo I think the answer to your question is that you cannot use indirection like this for the host application setting
p31816
aVOn the other hand, environment variables are substituted so perhaps you could use that to make things easier
p31817
aVIn other words you could define some environment variables of your own
p31818
aVI've no idea whether that may be of help to you since I don't know the precise details of your problem
p31819
as(dp31820
g7
V505088
p31821
stp31822
a((dp31823
g2
(lp31824
VI think in your situation I would simply compile the faulty Delphi routine into a DLL and use p/invoke to call it from the C#
p31825
aVI'd include a call to set the 8087 control word before the calc, and one to restore it to the callers value afterwards
p31826
aVThis would be the lowest risk approach that I can think of
p31827
as(dp31828
g7
V505088
p31829
stp31830
a((dp31831
g2
(lp31832
VThis sounds very much like a custom shell
p31833
aVAll the MSDN documentation that I could find seems to concentrate on embedded versions of Windows where replacing the shell is clearly very common
p31834
aVHowever, I believe that the principles are much the same for desktop Windows
p31835
as(dp31836
g7
V505088
p31837
stp31838
a((dp31839
g2
(lp31840
VYou need to be using  rather than  for this:
p31841
aVMake sure you have called the  file from the RAD Studio  folder before you attempt to call
p31842
aVThis sets up the necessary environment variables
p31843
aVThe great thing about the modern  based build system, as implemented in Delphi, is that you can quite easily ensure that your command line builds are identical to your IDE builds
p31844
as(dp31845
g7
V505088
p31846
stp31847
a((dp31848
g2
(lp31849
VIt's taken me ages to work out what you are really asking but I think it boils down to this comment
p31850
aVI want the WindowState behaviour of the MDI children to be different in a parent
p31851
aVSo first MDI Child is wsMax'd and the second is wsNormal
p31852
aVThat's not possible in MDI
p31853
aVWhen an MDI child is maximized, that is the only child window that is visible
p31854
as(dp31855
g7
V505088
p31856
stp31857
a((dp31858
g2
(lp31859
VWhat you are searching for is the ability to create a parent/child relationship
p31860
aVThe parent acts as a container and the child is contained within the bounds of the container
p31861
aVA  is a classic example of a container
p31862
aVAny visual component can be a child
p31863
aVIn terms of ancestry the parent must be derived from  and the child must be derived from
p31864
aVIn practice you seldom derive from these classes directly, rather from one of their descendents
p31865
aVThe other factor, if I recall correctly, is that the parent control must include  in its
p31866
aVNow,  does indeed derive from  and so it can act as a container
p31867
aVHowever, I am not sure whether or not  is included in the  for
p31868
aVI'm really not familiar with  and don't know whether or not it can act as a parent
p31869
aVI have a suspicion that it is not designed to act as a container
p31870
aVIf that is the case then you can add  to the  in the constructor of your derived class and have the control act as a parent
p31871
aVI suspect that if  does not include  then this is by design and the image control is not expected to act as a parent
p31872
aVApparently , unlike the VCL , is indeed capable of acting as a parent to other controls
p31873
aVAs for the other control in your question,  is not derived from  and cannot be a child control
p31874
as(dp31875
g7
V505088
p31876
stp31877
a((dp31878
g2
(lp31879
VModal dialogs disable their owners so one simple test would be to check if the window was enabled
p31880
aVUse IsWindowEnabled to determine this
p31881
aVYou also need to check that the window is visible with IsWindowVisible
p31882
as(dp31883
g7
V505088
p31884
stp31885
a((dp31886
g2
(lp31887
VCertainly one solution would be to place all DLLs in the same directory, the same directory as the
p31888
aVexe
p31889
aVIf you can bring yourself to do that it would be the simplest approach for sure
p31890
aVIf not then you will have a bit more work on your hands
p31891
aVI guess you are expecting that the loader will search in the directory where the DLL lives
p31892
aVSadly it doesn't
p31893
aVInstead the loader will look first in the executable file's directory, and then the rest of the DLL search order
p31894
aVThis is why  fails to load, because it is not in the same directory as the executable
p31895
aVThe fact that modules are already in memory is beside the point
p31896
aVThe loader goes looking for the file
p31897
aVWhen it finds the file that it wants it then checks to see if it is already loaded
p31898
aVIf so then it simply bumps the reference count to that module
p31899
aVOtherwise it loads it into the process
p31900
aVYou could switch to using  for all DLL loads and always being explicit about the path
p31901
aVThat's probably inconvenient
p31902
aVYou could use side-by-side assemblies but that doesn't sound very compatible with a plugin architecture
p31903
aVSo I think the main remaining option is
p31904
aVCall this just before you load the plugin
p31905
aVYou only need to add  to the search path since the rest of the modules are in the executable directory and so will be found without trouble
p31906
aVRestore this setting to its default by calling  again, passing , once the plugin has loaded and resolved all of its imports
p31907
aVIf you have multiple sub-directories then use
p31908
as(dp31909
g7
V505088
p31910
stp31911
a((dp31912
g2
(lp31913
VI read your question to mean that you do not want to output scientific format
p31914
aVIf so then you can control the stream formatting like this:
p31915
as(dp31916
g7
V505088
p31917
stp31918
a((dp31919
g2
(lp31920
VThe error is in this bit of code:
p31921
aVA few problems here:
p31922
aVdoes not include the null-terminator so you are not allocating enough memory
p31923
aVYou need one more character
p31924
aVYou have failed to call  a second time to fill out the buffer
p31925
aVYour first access of  is out of bounds because  is beyond the end of the array
p31926
aVSince  is not initialized the loop probably counts down to  of 0 and then produces an access violation
p31927
aVEven when you fix all these errors you need to test for  in your loop in case the string contains no path separators
p31928
aVI've not looked at any other code in your question but I'm willing to bet that I've not found all the errors
p31929
aVThis should be enough for now
p31930
aVJoachim's advice to use  is very sound but on the flip side, you really need to master this type of coding
p31931
as(dp31932
g7
V505088
p31933
stp31934
a((dp31935
g2
(lp31936
VFireMonkey styles are the way to do this
p31937
aVNote that the VCL way of doing things with  is not offered in FMX
p31938
aVThis article covers the topic in some detail
p31939
as(dp31940
g7
V505088
p31941
stp31942
a((dp31943
g2
(lp31944
VDLLs export functions by name and ordinal value
p31945
aVEach of these must be unique
p31946
aVYou cannot export two different functions with the same name or the same ordinal
p31947
aVYour example with  is merely two functions with different but equivalent signatures referring to the same function
p31948
aVThis is done for convenience of the caller
p31949
aVLet us leave the ordinal to one side and concentrate on names
p31950
aVIt is very clear from the first paragraph above that you have to use distinct names for each function
p31951
aVOf course you can still use overloading internally but specify distinct names as part of the exports clause
p31952
aVLikewise when importing you can declare the imported functions to be overloads but use the name syntax to specify the DLL name
p31953
aVSo, in summary, you can easily use overloading internally on both sides of the interface but you have to use unique names when exporting and importing the functions
p31954
aVHere is a simple example:
p31955
aVLibrary that exports functions
p31956
aVLibrary that imports functions
p31957
aVThe  keyword can appear anywhere in the declaration
p31958
aVIt doesn't matter where it appears
p31959
aVOn the other hand, the calling convention has to appear before
p31960
aVNote that languages that do not support overloading (i
p31961
ag192
aVVB6, C) will obviously not be able to import the functions and use the same names for them
p31962
aVLikewise for languages that do not support renaming the function at import (i
p31963
ag192
aVC++)
p31964
aVTo the best of my knowledge it's only really Delphi that allows such neat tricks at import time
p31965
aVFor languages like C++ and C# which do support overloading you would need to introduce another layer of indirection
p31966
aVFor example in C# you would do this:
p31967
aVExactly the same approach could be used in C++
p31968
aVThe only real difference between this approach and the Delphi code I showed above is that the Delphi language supports direct syntax to effect this mapping
p31969
aVRegarding the various examples in your question, these all use string which of course is a private Delphi type
p31970
aVYou must not use  in an exported function if the function is to be callable from any language other than Delphi
p31971
aVOr indeed any compiler version other than the one you built the DLL with
p31972
as(dp31973
g7
V505088
p31974
stp31975
a((dp31976
g2
(lp31977
VI know precisely nothing about InnoSetup but surely you need to use ShowModal rather than Show here
p31978
aVInstallation UI is invariably modal and what you want here is to wait until the user has finished iteracting with the form before you return to Inno
p31979
aVOtherwise, how would Inno know when to proceed
p31980
aVShowModal runs a message loop to service the form so there will be no problems receiving input
p31981
aVYou would also change your DLL to remove DestroyWizardForm since the function that calls ShowModal can both create and destroy the form
p31982
as(dp31983
g7
V505088
p31984
stp31985
a((dp31986
g2
(lp31987
VYou just need to add a  object and handle the  event
p31988
aVThe event handler is passed the  instance and so can readily obtain the name of the action
p31989
aVThe  event will fire before the action's  event fires
p31990
aVYou can even stop the action's  event from firing by setting the  parameter to  in your  event handler
p31991
as(dp31992
g7
V505088
p31993
stp31994
a((dp31995
g2
(lp31996
VYou can't use a lib file to link to a DLL from Delphi
p31997
aVThe
p31998
aVlib file would be used by C or C++ clients of the DLL
p31999
aVIn Delphi you need to manually translate the
p32000
aVh header file into a Pascal import unit using the  keyword
p32001
aVAn example of this of the Windows
p32002
aVpas unit in the Delphi source
p32003
aVThe fact that you can't use the
p32004
aVlib file is actually not a big issue because you have to translate the
p32005
aVh file no matter what
p32006
as(dp32007
g7
V505088
p32008
stp32009
a((dp32010
g2
(lp32011
VWhat I do is add all the icons at runtime by loading from then from resources
p32012
aVWhen I add them I save the index of the added icon to a global variable
p32013
aVI also assign the ImageIndex property of each action at runtime by referring to these global variables
p32014
aVThis allows flexibility to add and remove icons to the project without having numbering problems
p32015
aVThe approach caters for runtime icon size decisions based on font scaling
p32016
aVThe drawback is that you don't get to see the images at design time which is a drawback
p32017
aVIf you want to have all the flexibility outlined above I don't see a better solution
p32018
aVIn an ideal world the images would be identified by a name or an ID rather than a contiguous index into an array
p32019
aVBut to achieve that you would need to implement a lot of code on top of the VCL
p32020
as(dp32021
g7
V505088
p32022
stp32023
a((dp32024
g2
(lp32025
VIf you are meant to call GetLastError when an API fails, this will be documented
p32026
aVSince the documentation makes no mention of GetLastError it appears that there is no further information provided in event of a failure beyond the information encoded in the return value
p32027
aVIf the function succeeds, the return value is the number of
p32028
aVscan lines set
p32029
aVIf zero scan lines are set (such as when dwHeight is 0) or the function fails, the function returns zero
p32030
aVIf the driver cannot support the JPEG or PNG file image passed to SetDIBitsToDevice, the function will fail and return GDI_ ERROR
p32031
aVIf failure does occur, the application must fall back on its own JPEG or PNG support to decompress the image into a bitmap, and then pass the bitmap to SetDIBitsToDevice
p32032
aVI am afraid it looks like you are pretty much on your own here
p32033
as(dp32034
g7
V505088
p32035
stp32036
a((dp32037
g2
(lp32038
VYou've got more than one application manifest linked to the application
p32039
aVThere can be only one and so some have to be discarded
p32040
aVModern Delphi versions link a manifest by default based on the "Runtime themes" project option
p32041
aVYou possibly have another manifest linked, perhaps dating from when you developed the project in an earlier version of Delphi
p32042
aVAre you using the TXPManifest component by any chance
p32043
aVYou can remove the manifest that you are explicitly linking
p32044
aVOr you can disable the runtime themes setting and retain the explicit manifest
p32045
aVThat latter way you are in control of the manifest
p32046
aVPersonally that is the way I do it because I do need to have control over precisely what goes in the manifest
p32047
as(dp32048
g7
V505088
p32049
stp32050
a((dp32051
g2
(lp32052
VThe bottom line is that you should not be attempting to detect dangling pointers in code
p32053
aVIf you are going to refer to pointers after they have been freed, set the pointer to  when you free it
p32054
aVBut the best approach is not to refer to pointers after they have been freed
p32055
aVSo, how do you avoid referring to pointers after they have been freed
p32056
aVThere are a couple of common idioms that get you a long way
p32057
aVCreate objects in a constructor and destroy them in the destructor
p32058
aVThen you simply cannot refer to the pointer before creation or after destruction
p32059
aVUse a local variable pointer that is created at the beginning of the function and destroyed as the last act of the function
p32060
aVOne thing I would strongly recommend is to avoid writing  tests into your code unless it is expected behaviour that the pointer may not be created
p32061
aVYour code will become hard to read and you will also lose track of whether the pointer being nil is to be expected or is a bug
p32062
aVOf course we all do make mistakes and leave dangling pointers
p32063
aVUsing  is one cheap way to ensure that dangling pointer access is detected
p32064
aVA more effective method is to use FastMM in full debug mode
p32065
aVI cannot recommend this highly enough
p32066
aVIf you are not using this wonderful tool, you should start doing so ASAP
p32067
aVIf you find yourself struggling with dangling pointers and you find it hard to work out why then you probably need to refactor the code to fit into one of the two idioms above
p32068
aVYou can draw a parallel with array indexing errors
p32069
aVMy advice is not to check in code for validity of index
p32070
aVInstead use range checking and let the tools do the work and keep the code clean
p32071
aVThe exception to this is where the input comes from outside your program, e
p32072
ag217
aVuser input
p32073
aVMy parting shot: only ever write  if it is normal behaviour for the pointer to be
p32074
as(dp32075
g7
V505088
p32076
stp32077
a((dp32078
g2
(lp32079
VThese settings are only shown in the project options for a package project
p32080
aVThe settings still take effect for DLL projects if written directly into the source with $LIBPREFIX, $LIBSUFFIX or $LIBVERSION
p32081
aVIt's quite possible that the settings can be made directly in the
p32082
aVdproj file even though the IDE doesn't have UI for the settings
p32083
as(dp32084
g7
V505088
p32085
stp32086
a((dp32087
g2
(lp32088
VArray of const, as used by Format and similar, is actually implemented as an open array of TVarRec
p32089
aVWhilst superficially similar to variant, TVarRec is a different beast
p32090
aVI recommend Rudy Velthuis's excellent article explaining some of the detail needed in order to copy and manipulate arrays of TVarRec
p32091
as(dp32092
g7
V505088
p32093
stp32094
a((dp32095
g2
(lp32096
VThis behaviour happens precisely because you show the dialog
p32097
aVIn order to close the dialog you have to click the OK button
p32098
aVThis places an input message on the queue
p32099
aVAfter that has been processed the OnIdle event fires
p32100
aVAnd you show the message box again
p32101
aVAnd so on and so on
p32102
aVYou need to make sure that you don't do anything that requires user input in your OnIdle handler
p32103
aVIn your case try outputting to a log rather than showing a dialog, e
p32104
ag217
aVOutputDebugString
p32105
as(dp32106
g7
V505088
p32107
stp32108
a((dp32109
g2
(lp32110
VThat setting is a legacy setting that won't solve your problem
p32111
aVStarting from Vista your service does not have access to the interactive desktop and you will need to perform the screen capture from a standard app running on the interactive desktop
p32112
aVYou can use an IPC mechanism to communicate between your service and the desktop app
p32113
aVYou can start this desktop app from a service but it's rather tricky to do, as explained here
p32114
aVChecking the "Allow service to interact with desktop" just means you can call interactive API functions without error
p32115
aVYou don't get access to the inreractive desktop
p32116
aVThis issue all stems from changes introduced in Vista that mean services run in an isolated session, session 0
p32117
as(dp32118
g7
V505088
p32119
stp32120
a((dp32121
g2
(lp32122
VThe most likely explanation is that you have a 32 bit process and so registry redirection is in play
p32123
aVThis will redirect you to the Wow6432Node section and then your subsequent redirection results in the key not being found
p32124
aVYou should never hard code Wow6432Node into your app
p32125
aVUse the redirector, it's your friend
p32126
aVIf you have to specify a particular view of the registry use the
p32127
aVnet 4 RegistryView enumeration
p32128
aVUsing the RegistryView enumeration will ensure that the correct location is used no matter whether your process is 32 or 64 bits
p32129
as(dp32130
g7
V505088
p32131
stp32132
a((dp32133
g2
(lp32134
VSimply put you need to exclude  the bytes used to store the checksum from the checksum calculation
p32135
aVWrite the checksum as the last thing in the file
p32136
aVCalculate it based on the contents of the file apart from the checksum
p32137
aVWhen you come to read the file calculate the checksum based on the contents before the checksum
p32138
aVOr you could write the checksum as the first bytes of the file with random access
p32139
aVJust so long as you know where it is
p32140
as(dp32141
g7
V505088
p32142
stp32143
a((dp32144
g2
(lp32145
VYour  is incorrect
p32146
aVYour function has only 4 parameters, but the real function has 5
p32147
aVPresumably what is happening is that  is being passed to  and is ignored
p32148
aVThe  parameter is just whatever happens to be sitting on the stack
p32149
aVFixing your p/invoke will probably solve the problem
p32150
aVAlso,  should be unsigned
p32151
aVWith this correct you need to decide what to pass to
p32152
aVSince you appear not to be using it at the moment, it doesn't really matter and  seems the obvious choice
p32153
as(dp32154
g7
V505088
p32155
stp32156
a((dp32157
g2
(lp32158
VThe finally clause will always be executed, unless the executing thread enters a non-terminating loop, blocks indefinitely or is terminated abnormally, whilst executing the try clause
p32159
aVThe pertinent documentation states (emphasis mine):
p32160
aVThe syntax of a try
p32161
aVfinally statement is
p32162
aVwhere each statementList is a sequence of statements
p32163
aVdelimited by semicolons
p32164
aVThe try
p32165
aVfinally statement executes
p32166
aVthe statements in statementList1 (the try clause)
p32167
aVIf statementList1 finishes without raising exceptions,
p32168
aVstatementList2 (the finally clause) is executed
p32169
aVIf an exception is raised during execution of statementList1,
p32170
aVcontrol is transferred to statementList2; once statementList2
p32171
aVfinishes executing, the exception is re-raised
p32172
aVIf a call to the
p32173
aVExit, Break, or Continue procedure causes control to leave
p32174
aVstatementList1, statementList2 is automatically executed
p32175
aVThus the finally clause is always executed, regardless of how the try clause terminates
p32176
as(dp32177
g7
V505088
p32178
stp32179
a((dp32180
g2
(lp32181
VIt's typically done when there would be a clash of names
p32182
aVFor example in the TComponent constructor imagine if it was written:
p32183
aVNow the Owner parameter hides the Owner property of the instance
p32184
aVTo refer to the property you would have to write Self
p32185
aVOwner
p32186
aVYou will probably find, in the VCL sources, that the A prefix is used when there is such a clash, and not used when there is not
p32187
aVBut there will be inconsistency in the application of this convention
p32188
aVI rather hoped that the Embarcadero Pascal style guide would say something on the matter, but sadly it remains silent
p32189
aVPersonally I never use an A prefix in code that I write
p32190
aVIn my experience hiding is invariably fine because what you typically want to refer to is the parameter rather than the instance member
p32191
aVIf you ever need to refer to the instance member then Self
p32192
aVName can disambiguate
p32193
aVSo, there's no rule, just convention determined by personal preference
p32194
aVMake your own choice and stick to it
p32195
aVConsistency is far more important than whether or not you opt to use such a naming convention
p32196
as(dp32197
g7
V505088
p32198
stp32199
a((dp32200
g2
(lp32201
VYou can only get the source code from a setup program if the author chose to distribute it
p32202
aVIf not then you can download the source from the revision control repository, e
p32203
ag217
aVsourceforge, github etc
p32204
aVassuming this is an open source project
p32205
aVIf not then you should contact the author and request the source
p32206
as(dp32207
g7
V505088
p32208
stp32209
a((dp32210
g2
(lp32211
VThat text is long out dated
p32212
aVIt might have been true in the 70's that compilers would produce more efficient output for ++n, but not any more
p32213
aVAll modern compilers will produce identical code
p32214
as(dp32215
g7
V505088
p32216
stp32217
a((dp32218
g2
(lp32219
VThere is no clipboard viewer in Windows 7 to the best of my knowledge
p32220
aVIn fact I think clipbrd
p32221
aVexe was removed from Windows at Vista
p32222
aVHowever, the XP clipbrd
p32223
aVexe still works fine, or there are countless 3rd party clipboard viewers to choose from
p32224
as(dp32225
g7
V505088
p32226
stp32227
a((dp32228
g2
(lp32229
VIt would appear that you are trying to use global variables, or member variables, throughout your code where local variables should be used
p32230
aVDon't do that
p32231
aVIt's an bad practice that will give you enormous amounts of pain in the future
p32232
aVLose that bad habit before you write too much code the wrong way
p32233
aVAlways use local variables where it is possible to do so
p32234
aVI had to guess at the type of  but you can substitute this with the actual type
p32235
aVIf you do need to use members then either pass them to the method as a parameter, or make the procedure a method of the form class that owns the members
p32236
aVIt seems likely that these variables are members of  and if you really need them to be members of  then you probably should make  a  method
p32237
aVThat said,  is a bad choice of name since it is already a method of
p32238
aVI also guessed at the type for  but perhaps it needs to be  judging from the type-casting that goes on in the  call
p32239
aVOr, perhaps  should be
p32240
aVIn other words, I suspect that you have a bug in the  line which will reveal itself once you get the code to compile
p32241
as(dp32242
g7
V505088
p32243
stp32244
a((dp32245
g2
(lp32246
VThe Delphi documentation contains this example that does exactly what you want
p32247
aVFor all that the Delphi documentation is much maligned, it often has very useful examples like this
p32248
aVThe gateway page to the examples is here and the examples are even available on sourceforge so you can check them out using your favourite svn client
p32249
as(dp32250
g7
V505088
p32251
stp32252
a((dp32253
g2
(lp32254
VWhen you add the text at design time it is saved in the
p32255
aVdfm file and compiled into the program
p32256
aVThis does not happen at runtime
p32257
aVImagine if it did
p32258
aVIt couldn't really operate in the same way because you can't have the executable changing once you have deployed the app
p32259
aVYou would not want user settings to be stored in the executable
p32260
aVSo these settings really need to be external to the application
p32261
aVTo make this happen you need to implement your own persistence mechanism
p32262
aVYou would need to save the runtime added contents to a file somewhere (e
p32263
ag217
aVunder the user profile) and then re-load this whenever the application starts
p32264
as(dp32265
g7
V505088
p32266
stp32267
a((dp32268
g2
(lp32269
VIt can be quite dangerous to do anything beyond the default behaviour of the  control
p32270
aVYour users know how the standard Windows controls behave and any deviation from this is likely to cause confusion
p32271
aVBy default the  property is set to
p32272
aVDetermines whether all the text in the edit control is automatically selected when the control gets focus
p32273
aVSet AutoSelect to select all the text when the edit control gets focus
p32274
aVAutoSelect only applies to single-line edit controls
p32275
aVUse AutoSelect when the user is more likely to replace the text in the edit control than to append to it
p32276
aVWhen this property is , the entire contents of the edit control are selected when it gets the focus by means of keyboard action
p32277
aVIf the control gets the focus by a mouse click then the contents will not all be selected
p32278
aVIn that case you simply press CTRL+A to select all
p32279
aVA double click will select the word underneath the mouse
p32280
aVThis is all standard behaviour implemented by the underlying Windows control
p32281
aVIf you change the select in response to the  event, as per the currently selected answer, then you will find that it is impossible to move the caret with a mouse click
p32282
aVThis is exceedingly counter-intuitive behaviour
p32283
aVThis is a classic example of why you need to be very careful about changing the behaviour of a control from its default
p32284
aVIt's simply very easy not to miss a particular use case when testing but when your users get hold of the program, they are sure to find all such wrinkles
p32285
aVWhat you could safely do is to call  from
p32286
aVThis would, I believe have no annoying side-effects
p32287
aVAnother option would be to call  when the focus switched to the edit control, but not every time you click in the control
p32288
aVThis might feel a little odd to the user, but I personally think it would be reasonable to take this course of action
p32289
aVIf you want to do this you need to handle the  event of your edit control:
p32290
as(dp32291
g7
V505088
p32292
stp32293
a((dp32294
g2
(lp32295
VYou won't lose any data calling realloc but the allocation may fail, just like a malloc
p32296
aVThat's usually regarded as terminal
p32297
aVIf the memory block cannot be resized in-place a new block is created and the contents of the old block copied to the new block
p32298
as(dp32299
g7
V505088
p32300
stp32301
a((dp32302
g2
(lp32303
VI would use  here:
p32304
aVOtherwise it all looks fine to me
p32305
aVIn particular it is perfectly fine to do this with a  rather than a
p32306
as(dp32307
g7
V505088
p32308
stp32309
a((dp32310
g2
(lp32311
VYou seem to be writing a mix of C and C++ but your assignment requires C strings
p32312
aVI would write it like this
p32313
aVYou can write this algorithm with fewer variables but I personally find this version easier to read, understand and validate
p32314
aVIf you prefer to use pointers rather than indices then it looks like this:
p32315
aVThe two versions are practically indistinguishable
p32316
as(dp32317
g7
V505088
p32318
stp32319
a((dp32320
g2
(lp32321
VArrow keys are used to navigate between buttons on a form
p32322
aVThis is standard Windows behaviour
p32323
aVAlthough you can disable this standard behaviour you should think twice before going against the platform standard
p32324
aVArrow keys are meant for navigation
p32325
aVIf you want to get the full low down on how a key press finds its way through the message loop I recommend reading A Key's Odyssey
p32326
aVIf you want to intercept the key press before it becomes a navigation key, you need to do so in  or earlier
p32327
aVFor example, Sertac's answer gives one such possibility
p32328
as(dp32329
g7
V505088
p32330
stp32331
a((dp32332
g2
(lp32333
VIt's not realistic to account for other apps
p32334
aVJust ignore them
p32335
aVThe system will page things in and out as needed
p32336
aVIf you really wanted to do this you'd have to dynamically adapt to other processes as they start and finish
p32337
aVThat's really not realistic
p32338
aVWhat's more it's not practical to inquire of other processes how much memory they need
p32339
aVLeave it all to the system
p32340
aVSet a budget for your app and make sure you don't exceed it
p32341
aVKeep the most recently used images in memory and when you approach your memory budget throw away the least recently used images to make space
p32342
aVIf you are stressing the available resources then make sure you use FastMM and enable  for your app so that you get 4GB address space when running on a 64 bit OS
p32343
as(dp32344
g7
V505088
p32345
stp32346
a((dp32347
g2
(lp32348
VUpdate
p32349
aVAccording to the latest comments on the QC report submitted by Altaveron, this problem will be resolved in the next Delphi update, update 4
p32350
aVAnd indeed, Altaveron now confirms that update 4 does resolve the issue
p32351
aVThis is a known problem with the MS HTML help control, hhctrl
p32352
aVocx
p32353
aVThe best description of it that I am aware of is at the HelpWare FAR HTML FAQ
p32354
aVThere are many QC reports describing the issue: 48983, 67463, 78998, 89616
p32355
aVAccording to the latest QC report, this is fixed in XE2 but you report otherwise and I'd be inclined to believe you
p32356
aVEspecially as a comparison of the source for the  unit from XE and XE2 reveals no changes that appear related to this issue
p32357
aVIt's quite hard to work around the issue since the code that needs to be modified is buried deep inside the  unit
p32358
aVI've had to resort to patching the  API call
p32359
aVLike this:
p32360
aVInclude this unit early in your
p32361
aVdpr  list, before any unit that does anything with HTML help
p32362
aVThe version of the code that I use does a little more and takes steps to ensure that any open help windows are closed when the DLL unloads
p32363
aVThis no longer happens because we have stopped sending
p32364
aVYou will want to make sure that any help windows are shut down then keep track of the window handles returned by  calls, which you can now intercept
p32365
aVThen at shutdown send a  message to those windows which replaces the missing  call to
p32366
aVHowever, I believe that the code above should get you over your immediate hurdle with regsvr32 which won't be showing help windows
p32367
aVFeel free to do some experimentation
p32368
aVAt the very least, the code above gives you entry points with which you can modify the behaviour of the  unit
p32369
as(dp32370
g7
V505088
p32371
stp32372
a((dp32373
g2
(lp32374
VThere is nothing built in that will do anti-aliasing
p32375
aVYou could use GDI+ but I would recommend graphics32 which will happily draw anti-aliased polygons
p32376
as(dp32377
g7
V505088
p32378
stp32379
a((dp32380
g2
(lp32381
VIt sounds like you want a hyperlink label
p32382
aVThe  control may meet your needs
p32383
as(dp32384
g7
V505088
p32385
stp32386
a((dp32387
g2
(lp32388
VYou can't format text in a memo control
p32389
aVYou need a rich edit control,
p32390
aVIn order to make the current selection bold you do this:
p32391
aVThe preferred way to invoke code in response to a shortcut like CTRL+A is to use actions
p32392
aVAdd a  to the form and add an action to that action list
p32393
aVSet the action's  event handler to point at code that performs the bolding of the selected text
p32394
aVSet the  property to
p32395
aVUse actions so that you can centralise the control of user events
p32396
aVTypically there may also be a tool button, a menu item and a context menu item that performed the same action and this is where actions come into their own
p32397
as(dp32398
g7
V505088
p32399
stp32400
a((dp32401
g2
(lp32402
VWork around the problem by setting the Top property for the controls after changing the panel height
p32403
as(dp32404
g7
V505088
p32405
stp32406
a((dp32407
g2
(lp32408
VYou have two circular reference issues
p32409
aVFirstly you are declaring two units which each refer to the other in the interface section
p32410
aVThat can be solved a variety of ways
p32411
aVFor now For now I am going to ignore that issue and focus on the other circular reference problem
p32412
aVIn order to do so I'm going to assume all code appears in the same unit
p32413
aVThe more pressing circular reference problem is that  refers to  and vice versa
p32414
aVIn order to break this particular circularity you would need to introduce a forward reference, just as is commonly done with classes
p32415
aVBut it turns out that forward references cannot be made for  types
p32416
aVWhilst forward references are possible for class types, there is a fundamental difference between class types and record types
p32417
aVRecord types are value types and class types are reference types
p32418
aVThe current implementation of the Delphi compiler does not support forward references for value types
p32419
aVThe solution to your problem is to move the operators that refer to both types to whichever record is declared last
p32420
aVFor example:
p32421
aVIf you wish to retain two separate units then do it like this:
p32422
aVPut  in the unit
p32423
aVDo not use  from
p32424
aVPut  in the unit
p32425
aVUse  from the interface section of
p32426
aVLike this:
p32427
aV
p32428
as(dp32429
g7
V505088
p32430
stp32431
a((dp32432
g2
(lp32433
VIt is the right shift operator
p32434
aVHere it is being used to divide by 2
p32435
aVIt would be far more clear to write this as
p32436
aVSadly a lot of people try to be clever and use shift operators in place of multiplication and division
p32437
aVTypically this just leads to lots of confusion for the poor individuals who have to read the code at a later date
p32438
as(dp32439
g7
V505088
p32440
stp32441
a((dp32442
g2
(lp32443
VYou can't call that DLL from C#
p32444
aVThe main problem are the two  callbacks
p32445
aVThere's no way in C# to match that
p32446
aVYou will need to modify the existing DLL or add an intermediate adapter DLL
p32447
aVAs it stands your DLL is only accessible from Delphi or C++ Builder
p32448
aVIf you can modify the DLL then the modification you need to make is to remove the
p32449
aVIf you need the callback to act on an instance then you will need to pass the instance as a parameter
p32450
aVHowever, C# delegates can wrap all that up transparently so you would only need to pass the instance as a parameter if you needed the DLL to be accessible from other languages, e
p32451
ag217
aVDelphi
p32452
aVThe other issue is the open array parameter
p32453
aVThat is also not easily accessed from other languages
p32454
aVAlthough there are tricks, I would recommend passing a reference to the first element rather than an open array
p32455
aVOpen arrays are unique to Delphi
p32456
aVI also do not understand why you are using the  type to hold array length
p32457
aVYou should use  for this
p32458
aVThere's nothing to gain from using byte and you simply invite overflow
p32459
aVAlso,  should not be  in Delphi
p32460
aVIt should be
p32461
aVMy recommendation to you would be to modify the DLL to have a C compatible interface and thus be accessible from all languages that support that
p32462
aVIn practice this would make it accessible from all mainstream programming languages
p32463
as(dp32464
g7
V505088
p32465
stp32466
a((dp32467
g2
(lp32468
VThere's not enough code here to say anything with any certainty
p32469
aVHowever, calling  on a thread results in a call to  followed by a
p32470
aVIt's quite plausible that the wait is not returning which would be consistent with the frozen UI
p32471
as(dp32472
g7
V505088
p32473
stp32474
a((dp32475
g2
(lp32476
VThese keys have the following special names which can be assigned directly through the  property in the Object Inspector
p32477
aVNUM ADD
p32478
aVNUM SUB
p32479
aVNUMMULT
p32480
aV/
p32481
aVI'm not sure about the numpad Enter key
p32482
aVI don't know if it has a special name or indeed if it can be distinguished from the normal Enter key using a shortcut
p32483
aVUpdate
p32484
aVIt turns out that the names for these keys vary from machine to machine
p32485
aVFranois points out that the names come from the  Windows API function, for which the documentation points out:
p32486
aVThe format of the key-name string depends on the current keyboard layout
p32487
aVThe keyboard driver maintains a list of names in the form of character strings for keys with names longer than a single character
p32488
aVThe key name is translated according to the layout of the currently installed keyboard, thus the function may give different results for different input locales
p32489
aVFor example, Sertac found that on his system, the names are ,  etc
p32490
aVI generated the values by calling  and you could do the same to generate names appropriate for your system
p32491
as(dp32492
g7
V505088
p32493
stp32494
a((dp32495
g2
(lp32496
VCreate an array of 12 string lists, one per month
p32497
aVIterate through your files adding each file name to the appropriate month
p32498
aVOnce all files have been processed, sort each individual string list with an appropriate sort order
p32499
aVFinally, populate the tree view
p32500
aVFor each string list, add a top level node and then add all the children by iterating through the string list
p32501
aVI'm assuming that you already know how to parse individual strings, how to implement a custom sort order, and how to populate a string list, and that your problem is how to tackle the problem from a high level
p32502
as(dp32503
g7
V505088
p32504
stp32505
a((dp32506
g2
(lp32507
VThe error is that  is, effectively, a pointer to the first element of the array
p32508
aVYou are thus passing the address of the pointer to the first element of the array
p32509
aVIn other words you have an extra, spurious, level of indirection
p32510
aVYou need
p32511
aVor
p32512
aVAs for  vs , the former is a Win32 API function and the latter is a C standard library function
p32513
aVThe two functions perform identical tasks and are interchangeable
p32514
as(dp32515
g7
V505088
p32516
stp32517
a((dp32518
g2
(lp32519
VYour problem is that you are performing two separate sorts
p32520
aVYou need to perform a single sort and use what is known as a lexical ordering
p32521
aVYou need to use a comparer that compares the primary field and then, only if the primary key compares equal, goes on to compare the secondary key
p32522
aVLike this:
p32523
aVThis approach can be extended to cater for an arbitrary number of keys
p32524
aVIn your update to the question you add the requirement that the key precedence will be determined at runtime
p32525
aVYou can do this with a comparison function like this:
p32526
aVHere  is an array containing identifiers for the fields, in descending order of precendence
p32527
aVSo  identifies the primary key,  identifies the secondary key and so on
p32528
aVThe  function compares the field identified by its third parameter
p32529
aVSo the  function might be like this:
p32530
as(dp32531
g7
V505088
p32532
stp32533
a((dp32534
g2
(lp32535
VYou allocated an array of pointers but did not allocate any memory for them to point to
p32536
aVYou need to call  to allocate memory from the heap
p32537
aVNaturally you would need to  the memory at some later date when you were finished with it
p32538
aVYour code invokes what is known as undefined behavior
p32539
aVBasically anything can happen, including the code working as you intended
p32540
aVIf the version with  works as you intended that's simply down to luck
p32541
aVAs an aside, your  definition is wrong
p32542
aVIt should be
p32543
as(dp32544
g7
V505088
p32545
stp32546
a((dp32547
g2
(lp32548
VImmutable objects are automatically threadsafe
p32549
aVThe
p32550
aVnet string is immutable
p32551
aVOK, you meant C rather than C#
p32552
aVWell, you will find that using Python strings is trivially easy in comparison to the extreme pain associated with strings in C
p32553
as(dp32554
g7
V505088
p32555
stp32556
a((dp32557
g2
(lp32558
VThe code to which you link does not work
p32559
aVThe  function is broken
p32560
aVLine 416 reads:
p32561
aVThis is a mis-translation from C
p32562
aVInstead it should read:
p32563
aVAfter making this change, I successfully tested the following program:
p32564
aVHowever, I know exactly nothing about Punycode and in particular I've no idea what the point of the  prefix that is added at the question to which you linked
p32565
aVSo the  and  routines that I show above are probably not exactly what you need
p32566
aVI am extremely dubious of the Delphi code in the  unit and I suspect that there are other problems lurking
p32567
aVIn your position I would get hold of , compile it with  and then link to it with
p32568
aVI would regard that as much more trustworthy than this  unit
p32569
as(dp32570
g7
V505088
p32571
stp32572
a((dp32573
g2
(lp32574
VHere is some simple example code that gets the job done
p32575
aVI hope it is self-explanatory
p32576
ag32428
as(dp32577
g7
V505088
p32578
stp32579
a((dp32580
g2
(lp32581
VIf you want to store temporary files then use a sub-folder in the temporary directory
p32582
aVUse  to find out where this is
p32583
aVNote that on all modern versions of Windows, this folder is a per-user folder and is not shared between different users
p32584
aVIf you want a location that is shared between all users then you need the  folder
p32585
aVHowever, as you have discovered, standard users do not have rights to write in the folder
p32586
aVThe standard approach is for the installation program to create a sub-folder with a permissive ACL that allows sufficient write access for standard users
p32587
as(dp32588
g7
V505088
p32589
stp32590
a((dp32591
g2
(lp32592
VIf you want to enforce the correct declaration of a unit in a project's  clause I would add a pre-build event to run a regex based Perl/Python/Ruby script
p32593
aVThe script would do a simple regex based check of the
p32594
aVdpr file and return an error if it was not as intended
p32595
aVNot fool-proof, but probably the best balance of utility for a small amount of effort
p32596
aVI realise that your question asks for runtime detection but this is a compile time property and so best attacked at compile time
p32597
as(dp32598
g7
V505088
p32599
stp32600
a((dp32601
g2
(lp32602
VIt seems to me that  is not designed to do what you desire
p32603
aVWhat's more I don't think that  is necessary either
p32604
aVI'd probably do this with a label and move it on the timer event
p32605
aVLike this:
p32606
aVI found that I needed to make the form double buffered () to avoid flicker when scrolling
p32607
as(dp32608
g7
V505088
p32609
stp32610
a((dp32611
g2
(lp32612
VThe problem is that  is a method of  (inherited from ) and so when you write  inside a  method the compiler wants to use  rather than the local function
p32613
aVThe class scope is nearer than the local function scope
p32614
aVPossible solutions include:
p32615
aVRenaming the local function to avoid the clash
p32616
aVUsing a fully qualified name,
p32617
aVThe former is a better solution in my opinion
p32618
as(dp32619
g7
V505088
p32620
stp32621
a((dp32622
g2
(lp32623
VUpdate: You will be far better off with  as suggested by Arnaud
p32624
aVHowever, I am leaving this answer here since it illustrates some of the tricks that can be used to resolve missing dependencies when static linking
p32625
aVWhat is happening here is that the
p32626
aVobj file depends on various C runtime functions which need to be provided by you
p32627
aVThe first thing to do is to add  to the  clause of the unit which contains the  directive
p32628
aVThe  unit contains implementations of a number of the C runtime library functions and is designed for just this purpose
p32629
aVHowever, when you do this, whilst some missing dependencies are resolved, lots more appear
p32630
aVMany of these are simply Windows API functions and can easily be resolved by adding  to your uses clause
p32631
aVAt this point you are left with the following:
p32632
aVTo resolve these you need to either:
p32633
aVLink another
p32634
aVobj file containing the missing dependency
p32635
aVImplement the missing dependency in Delphi code in the same unit that contains the
p32636
aVI'm not actually sure what these functions do so you've got a bit more work ahead of you
p32637
aVMy guess is that these functions are 64 bit integer arithmetic routines
p32638
aVYou can probably reverse engineer this by writing short bits of C to perform various 64 bit arithmetic operations
p32639
aVThen compile with bcc32 and look at the output as
p32640
aVPresumably  has the capability to emit
p32641
aVOr your could just link to a Delphi unit and see which of the above functions corresponds to the operations you used in your C code
p32642
aVYou could pull  out of , always a useful fall-back option for missing C runtime functions
p32643
aVIn fact, that's what the current implementation of the  unit does, so if you are going to use  you may as well get  the same way
p32644
aVBorrowing some code from Arnaud, the following unit compiles successfully:
p32645
aVNote that you don't need to provide parameter list, calling convention etc
p32646
aVfor any of these functions since we are not implementing them here
p32647
aVIn each case the code simply delegates the implementation
p32648
aVHowever, this is still missing the code to declare the sqlite3 functions
p32649
aVWhat's more, I've not even attempted to test whether or not it works
p32650
aVSuccessful compilation is only the first step
p32651
aVI strongly recommend that you use the code that Arnaud directs you towards if you wish to use static linking
p32652
aVThis code clearly has had much use and testing and you may as well benefit from that
p32653
aVStatic linking makes for convenient deployment, but dynamic linking against a DLL is much simpler to achieve
p32654
as(dp32655
g7
V505088
p32656
stp32657
a((dp32658
g2
(lp32659
VI'd write it like this:
p32660
aVNote that I moved the clipboard  command, which locks the clipboard to be outside the test for the  format
p32661
aVThat is to avoid a race condition which exists in your code
p32662
aVIn your code the clipboard could be modified between the  call and the  call
p32663
aVI also used the  class exclusively
p32664
aVThis class has all you need and you don't need to use the raw Win32 clipboard API
p32665
aVI even put error checking in
p32666
as(dp32667
g7
V505088
p32668
stp32669
a((dp32670
g2
(lp32671
VThe heap is shared between DLLs in the same process but different processes have distinct heaps
p32672
aVIt sounds like you have global variables in a DLL that is loaded into distinct processes
p32673
aVThat cannot be shared without some form of inter-process communication
p32674
as(dp32675
g7
V505088
p32676
stp32677
a((dp32678
g2
(lp32679
VYour question rather confused me
p32680
aVWhen you said:
p32681
aVlog messages to the memo
p32682
aVWhat you mean is that you want to log messages to the form by writing text to the memo
p32683
aVThat approach is fraught with danger since when you write to the memo, the form gets sent messages which results in you writing to the memo and a stack overflow is the inevitable consequence
p32684
aVI managed to make your idea sort of work by putting in re-entrancy protection
p32685
aVI also introduced a transient non-visual string list to capture any messages that are delivered before the control is ready to display them
p32686
aVOnce you introduce this then you no longer need to worry about finding the precise earliest moment at which it is safe to add to the memo
p32687
aVThe moral of the story is that you should use a more appropriate logging framework that does not interact with what you are trying to log
p32688
as(dp32689
g7
V505088
p32690
stp32691
a((dp32692
g2
(lp32693
VThe feature you are looking for was added to the Win32 debugger in Delphi 2005:
p32694
aVDelphi 2005 Reviewer's Guide
p32695
aVA popular debugging feature in Delphi 8 and C# Builder is the capability to select a particular frame from the call stack using the Local Variables dialog box
p32696
aVThis feature is now available for the Borland Win32 Debugger
p32697
aVWith the Borland Win32 Debugger loaded, view the Local Variables dialog box
p32698
aV(If this dialog box is not already visible, select View | Debug Windows | Local Variables, or press Ctrl-Alt-L, to display it
p32699
aVInitially, the values of variables local to the current function that the debugger is in are shown
p32700
aVTo view local variables in one of the methods earlier in the call chain, select the method name from the drop-down menu
p32701
aVIn Delphi 7 the local variables view always shows the local variables for the function in which execution has broken on
p32702
as(dp32703
g7
V505088
p32704
stp32705
a((dp32706
g2
(lp32707
V is in fact a function defined in the  unit
p32708
aVIn the implementations of Delphi that I have at hand, Delphi 6 and XE2,  is implemented as an intrinsic routine that results in a call to one of the following functions, as appropriate:
p32709
aVI have no idea why your assembler code is turned into
p32710
aVYou point out in a comment that the  unit itself makes use of  in  code, for example in
p32711
aVThe same code in XE2 is now pure Pascal and searches for a value of  instead of
p32712
aVThis would very much appear to be an implementation detail
p32713
aVIf you want to understand why this is so then I think you will need to reverse engineer the code in the  unit, or see if the engineers at Embarcadero will explain the implementation to you
p32714
as(dp32715
g7
V505088
p32716
stp32717
a((dp32718
g2
(lp32719
VYou can open the file in a resource editor, for example: XN Resource Editor, ResEdit, Resource Hacker, Visual Studio etc
p32720
as(dp32721
g7
V505088
p32722
stp32723
a((dp32724
g2
(lp32725
VYou can use the  extension point to help migrate your
p32726
aVdfm files
p32727
aVThis will allow your new component to read in old
p32728
aVdfm files with the old property name
p32729
aVWhen the
p32730
aVdfm file is written again, the new property name will be used
p32731
aVNote that such a technique results in the component being able to read
p32732
aVdfm files containing either the old property name or the new property name so you can migrate in a gradual fashion if you wish
p32733
aVOnce you have migrated all your
p32734
aVdfm files then it would be worth removing such code for the sake of tidiness
p32735
aVThe Delphi documentation covers this subject area, albeit from a slightly different perspective, in the Storing and Loading Unpublished Properties section of the Component Writer's Guide
p32736
as(dp32737
g7
V505088
p32738
stp32739
a((dp32740
g2
(lp32741
VYour uses clause has Windows after Classes and so the wrong RegisterClass is in scope
p32742
aVThere is a windows API function of that name but you want the function in the Classes unit
p32743
aVEither fully qualify the name (Classes
p32744
aVRegisterClass) or re-order the units in your uses clause
p32745
as(dp32746
g7
V505088
p32747
stp32748
a((dp32749
g2
(lp32750
VIt's pretty hard to piece this all together
p32751
aVI do think you need to go back to basics a bit, but all the same I think I can explain what is going on
p32752
aVYou initialise  to  and then never modify the value of
p32753
aVYou therefore call  passing  as the parameter every time
p32754
aVreturns a value of  when the input is
p32755
aVPerhaps you meant to pass  to  when you call it, but I cannot be sure
p32756
aVAre you really declaring global variables in your header file
p32757
aVThat's not good
p32758
aVTry to use local variables and/or parameters as much as possible
p32759
aVGlobal variables are pretty evil, especially declared in the header file like that
p32760
as(dp32761
g7
V505088
p32762
stp32763
a((dp32764
g2
(lp32765
VYou are passing a process handle to
p32766
aVThat's not right
p32767
aVProcesses don't have device contexts, windows do
p32768
aVRemember a process can have many windows, or even none at all
p32769
aVYou need to get hold of the window handle, the , for the window in question, and pass that to
p32770
aVI'd look to using  or  to find your target top-level window
p32771
aVOf course, there may be other problems with your code, but that's the one that jumps out at me
p32772
as(dp32773
g7
V505088
p32774
stp32775
a((dp32776
g2
(lp32777
V works just fine from forms applications
p32778
aVThis is a non-problem
p32779
as(dp32780
g7
V505088
p32781
stp32782
a((dp32783
g2
(lp32784
VThe error tells you that one of the variables you are passing as parameter does not have the required type
p32785
aVThe error is in a  parameter
p32786
aVThe final parameter for both these functions is the only var parameter so clearly  is not the required type
p32787
aVThe solution is to make  match the type specified in the declaration of  and
p32788
aVIn XE2 that type is
p32789
aVSo you just need to change your definition of  to be of type
p32790
aVHere are the XE2 declarations:
p32791
as(dp32792
g7
V505088
p32793
stp32794
a((dp32795
g2
(lp32796
VIn my view there's nothing wrong with calling  passing
p32797
aVIf you need to support XP then you can't use known folder IDs
p32798
aVYou could write code that used known folder IDs on Vista and up, and fell back to CSIDL on earlier systems
p32799
aVBut why bother
p32800
aVMS have done that for you with
p32801
as(dp32802
g7
V505088
p32803
stp32804
a((dp32805
g2
(lp32806
Vcasts  to be of type
p32807
aVdoes a bitwise shift left of 8 bits
p32808
aVThe  operator performs bitwise
p32809
as(dp32810
g7
V505088
p32811
stp32812
a((dp32813
g2
(lp32814
VRight at the end of this rather gruesome event handler is this code:
p32815
aVWhat happens then is that as soon as you click OK on the message box, the event handler is re-entered because you called  and so the whole routine starts again
p32816
aVAnd the message box is shown, and you press OK and then  is called again and so on
p32817
aVIf you have enough patience you should be able to get a stack overflow error
p32818
as(dp32819
g7
V505088
p32820
stp32821
a((dp32822
g2
(lp32823
VThe encoding cannot be what you think it is
p32824
aVThe release and numbers are packed into a single 32 bit
p32825
aVThat means that there are only 16 bits available for all the seconds in a day
p32826
aVThere are 86400 seconds in a day which is greater than 216
p32827
aVRather oddly the Delphi implementation appears to wrap around when it reaches 216 seconds, ~18
p32828
aV2 hours
p32829
aVSo at the moment, it is 22:50 in my time zone (UTC), but the auto generated release number is 16753, or around 4
p32830
aV6 hours
p32831
aVAdd back the missing 18
p32832
aV2 hours from the wrap around and bingo, it's 22:50
p32833
aVIt looks like the Visual Studio people got it right, because they took the number of seconds after 00:00 and divided by 2
p32834
aVIt would also appear therefore that the Delphi auto generated release numbers will not be monotone increasing with time, will not be unique and so on
p32835
aVThis seems to me to be a bug which I have submitted as QC#102343
p32836
aVNote that the bug was introduced in XE2 update 3
p32837
aVIt was not present in previous versions
p32838
aVNote also that the handling of the release number has changed from update 2 to update 3
p32839
as(dp32840
g7
V505088
p32841
stp32842
a((dp32843
g2
(lp32844
VYour parameters to  are reversed\u2013the start index comes first just as in Delphi
p32845
aVDelphi string indexing is 1-based
p32846
aVThe
p32847
aVnet string indexing is 0-based
p32848
aVYou have the classic off-by-one error
p32849
aVFinally, you cannot play so loose with the length parameter to
p32850
aVIn Delphi's  you can specify an arbitrarily large length value and you will get all the right-most characters
p32851
aVIn  you must not ask for more characters than there are
p32852
aVIf you do then  is thrown
p32853
aVYou need this:
p32854
aVI'm assuming you have already ensured that  is in the range  to
p32855
aVAs for your additional question,
p32856
aVtranslates to
p32857
as(dp32858
g7
V505088
p32859
stp32860
a((dp32861
g2
(lp32862
VYou would need to use  instead:
p32863
as(dp32864
g7
V505088
p32865
stp32866
a((dp32867
g2
(lp32868
VYou didn't provide very much information about you app but I suspect that you just need to assign to  from
p32869
aVYou may need to add a reference to  in order to gain access to this, depending on exactly what type of project you have
p32870
aVIf you want to keep it lightweight and avoid taking a reference to WinForms then you could just pinvoke to
p32871
as(dp32872
g7
V505088
p32873
stp32874
a((dp32875
g2
(lp32876
VYou made the same mistake as in your previous question
p32877
aVYou need
p32878
aVAll you need to do to convert this type of code is account for the 1-based vs 0-based indexing difference between Delphi strings and
p32879
aVnet strings
p32880
as(dp32881
g7
V505088
p32882
stp32883
a((dp32884
g2
(lp32885
VYou are over-complicating
p32886
aVThe Delphi language/libraries will handle conversion between strings and pointers to null-terminated char arrays
p32887
aVAnd similarly for the calling routines
p32888
aVI have omitted all the diagnostics code that you included
p32889
aVIf you want to make modifications to the text before displaying it, or before passing it to the DLL then that's easy
p32890
aVMake the modifications using standard string operations in the local string variables (always named  above)
p32891
aVFor example:
p32892
aVor
p32893
aVThe bottom line is that there is absolutely no need for you to write code that converts between strings and pointers to null-terminated char arrays since Delphi will do it for you
p32894
as(dp32895
g7
V505088
p32896
stp32897
a((dp32898
g2
(lp32899
VYou need to listen for particular windows messages being delivered to the form
p32900
aVThe easiest way to do this is to assign the  property of the form
p32901
aVRemember to keep a hold of the previous value of  and call it from your replacement
p32902
aVIn your wrapper object declare a field like this:
p32903
aVThen in the wrapper's constructor do this:
p32904
aVFinally, implement the replacement window procedure:
p32905
as(dp32906
g7
V505088
p32907
stp32908
a((dp32909
g2
(lp32910
VI would make the following observations:
p32911
aVThe decision as to whether or not to use a setter should be based on factors like code maintenance, correctness, readability rather than performance
p32912
aVYour benchmark is wholly unreasonable since the  statements evaluate to  every time
p32913
aVReal world code that sets properties would be likely to modify the properties a reasonable proportion of the time that the setter runs
p32914
aVI would expect that for many real world examples, the setter would run faster without the equality test
p32915
aVIf that test were to evaluate to  every time then clearly the code would be quicker without it
p32916
aVThe integer setter is practically free and in fact the setter is slower than the direct field access
p32917
aVThe time is spent in the string property
p32918
aVHere there is some real performance benefit due to the optimisation of the  test which avoids string assignment code if possible
p32919
aVThe setters would be faster if you inlined them, but not by a significant amount
p32920
aVMy belief is that any real world code would never be able to detect any of these performance differences
p32921
aVIn reality the bottleneck will be obtaining the values passed to the setters rather than time spent in the setters
p32922
aVThe main situation where such  protection is valuable is where the property modification is expensive
p32923
aVFor example, perhaps it involves sending a Windows message, or hitting a database
p32924
aVFor a property backed by a field you can probably take it or leave it
p32925
aVIn the chatter in the comments Premature Optimization wonders why the comparison  is quicker than the assignment
p32926
aVI investigated a little further and it wasn't quite as I had originally thought
p32927
aVIt turns out that  is dominated by a call to
p32928
aVThe two strings passed are not in fact the same reference and so each character has to be compared
p32929
aVHowever, this code is highly optimised and crucially there are only 5 characters to compare
p32930
aVThe call to  goes to  and since  is a literal with negative reference count, a brand new string has to be made
p32931
aVThe Pascal version of the code looks like this:
p32932
aVThe key part of this is the call to  which of course calls
p32933
aVI am not at all surprised that heap allocation is significantly slower than comparison of 5 characters
p32934
as(dp32935
g7
V505088
p32936
stp32937
a((dp32938
g2
(lp32939
VYou say that you want a text box which makes me think you want the user to be able to edit the text
p32940
aVIn which case you have the wrong window class
p32941
aVThe  window class is for labels
p32942
aVWhat you want is an  control
p32943
as(dp32944
g7
V505088
p32945
stp32946
a((dp32947
g2
(lp32948
VYou could compare  and  from
p32949
as(dp32950
g7
V505088
p32951
stp32952
a((dp32953
g2
(lp32954
VOxygene/Prism is a separate product from Delphi XE2 with a different, albeit similar, language
p32955
aVYou can't use a single codebase shared between XE2 and Oxygene/Prism
p32956
aVEmbarcaderos plan's for iOS and Android will be based on their cross-platform Delphi compiler and the new FireMonkey libraries
p32957
aVThe existing iOS support uses the FPC compiler but Embarcadero have stated that they are working on an ARM version of their Delphi compiler to replace that in future releases
p32958
aVSo, at the moment, of your 4 platforms, you can target Windows, MacOS and iOS with Delphi XE2/FireMonkey
p32959
aVBut not Android, as of today
p32960
aVWith Prism/Oxygene you can target Windows, MacOS and Android (and Linux as it happens)
p32961
aVNote however that there is nothing in the Prism/Oxygene akin to FireMonkey that allows you to write single source cross-platform GUI
p32962
as(dp32963
g7
V505088
p32964
stp32965
a((dp32966
g2
(lp32967
VHere's what I can see just by looking at the code:
p32968
aVIf think you have the parameters to  in the wrong order
p32969
aVThe separator is the second parameter in the function to which you linked
p32970
aVSo you should write:
p32971
aVYou are leaking memory by not freeing the arrays returned by the  function
p32972
aVDelphi is different from PHP in that you often have to manage the memory of objects that you create
p32973
aVThese should be  rather than
p32974
aVYou should convert the strings to integers up front
p32975
aVSo declare them like this:
p32976
aVand write the assignments like this:
p32977
aVtranslates to:
p32978
aVInside the while loop you want code like this:
p32979
aVConverting the 4 values back to an IP address is easiest with the  function:
p32980
aVYou have a mis-understanding of what  does it is a function that receives as input a string and returns an integer
p32981
aVWhen you write:
p32982
aVyou are not modifying the variable  which is just an input variable
p32983
aVThat issue disappears when you make the other changes I describe, but I wanted to point it out for your future benefit
p32984
aVYou may also want to force a periodic repaint of the list box so that you can see what is happening
p32985
aVPut it all together and you have this:
p32986
as(dp32987
g7
V505088
p32988
stp32989
a((dp32990
g2
(lp32991
VYou can't get this information from the timer
p32992
aVThe best you can do is make a note of when the timer last fired and work it out for yourself
p32993
aVFor example you can use  to do this
p32994
as(dp32995
g7
V505088
p32996
stp32997
a((dp32998
g2
(lp32999
VThe problem you have at the moment is that you are calling the  overload that takes the main form as a parameter
p33000
aVThis will show the main form which you do not want
p33001
aVInstead you should call one of the other  overloads
p33002
aVFor example you can call the no parameter overload of
p33003
aVMake sure that you have created and installed your notify icon before you do so
p33004
aVAnd also create, but do not show your main form
p33005
aVWhen you are ready to show your main form, in response to an action on the notify icon, call
p33006
aVYou will also wish to arrange that clicking the close button on the form merely hides the form rather than closing it
p33007
aVI'm assuming that you want your main form instance to persist hidden in the background
p33008
aVSo the top-level of your program would look like this:
p33009
aVYou'll need to add an item to the notify icon menu that closes the application
p33010
aVImplement this with:
p33011
aVIf you need more fine grained control over the application lifetime then you may be better off using the  overload that receives an
p33012
aVSince I don't have Prism at hand I have checked this out with C#/WinForms and I hope it transfers alright to Prism
p33013
as(dp33014
g7
V505088
p33015
stp33016
a((dp33017
g2
(lp33018
VThese two warnings are now documented
p33019
aVGARBAGE: Turns on or off warnings produced when the presence of non-whitespace text is detected past the end of the final 'end
p33020
aVin the program, unit, library or package
p33021
aVUNIT_EXPERIMENTAL: Turns on or off all warnings about the experimental directive applied to a unit declaration
p33022
aVPresumably the report was marked as fixed once the documentation was added
p33023
as(dp33024
g7
V505088
p33025
stp33026
a((dp33027
g2
(lp33028
VWhat is happening here is, in my view, due to a design flaw in the VCL framework
p33029
aVThe underlying windows framework maintains not one, but two icons for each top-level window
p33030
aVThese icons are associated with a window either via the window class (see ) or through  messages
p33031
aVThe VCL framework always calls  passing  and so only the large icon is assigned
p33032
aVFor Windows 7 the large icon is used on the taskbar and the small icon is used on the window's caption bar
p33033
aVOn earlier versions of Windows, which had smaller taskbars, the small icon was used on the taskbar
p33034
aVFor 100% font scaling the large icon is 32px and the small icon is 16px
p33035
aVFor large fonts, the required icon sizes change
p33036
aVNow, if an application only supplies one of the required icons, the system will scale the icon provided when it needs to draw the icon size which has not been supplied
p33037
aVIf you supply a large icon only then, generally, the resulting scaled small icon looks fine
p33038
aVIf you supply a small icon only then it's much harder to scale and what typically happens is that the small icon (shown on the caption bar) looks fine, but the large icon is pixellated
p33039
aVIn fact what is happening to you is neither of these problems
p33040
aVThe VCL code means that you are always specifying, to Windows, the large icon
p33041
aVHowever, you are clearly supplying a small icon, almost certainly 16px
p33042
aVThis has the same result as calling  with  and the 32px icon is pixellated
p33043
aVThe simplest solution for you is to use the 32px icon in for  or , wherever it is that you set the icon
p33044
aVThis will work fine for much of the time
p33045
aVHowever, if your application ever runs with font scaling active then you will encounter pixellation again
p33046
aVWith font scaling, both icon sizes can be increased
p33047
aVIn order to handle this properly you must provide to the underlying Windows framework an icon of the correct size
p33048
aVIf you don't then there will be pixellation
p33049
aVYou can find out the icon sizes by calling
p33050
aVNow it is often sufficient just to supply a large icon and rely on the built in scaling to produce the small icon
p33051
aVIf you really care about visuals you should of course use an icon specifically prepared for such small sizes
p33052
aVA 32px icon down-scaled to 16px will not be as effective visually as a 16px icon produced by a skilled visual designer
p33053
aVTo make the VCL use the small icon you provide requires extra work
p33054
aVSpecifically you need to send the  for
p33055
aVIn my code base I do this and in fact avoid using  at all and call  for both icon sizes
p33056
aVIn order to get the fine-grained control needed to do this right the VCL mechanisms just interfere
p33057
as(dp33058
g7
V505088
p33059
stp33060
a((dp33061
g2
(lp33062
VThis function will take a base64 encoded string, decode it, and write the resulting byte array to a file
p33063
aVTo explain what is happening here, the first line
p33064
aVperforms the decode and returns the decoded binary contents of the file in a  variable
p33065
aVis simply an array of bytes
p33066
aVThe next step is to create the file
p33067
aVThe idiomatic way to write files in Delphi is to use streams
p33068
aVIn this case we want a
p33069
aVThe  option means that if the file already exists, it will be replaced and overwritten by what we write
p33070
aVThe final step is to write the contents of the byte array to the file
p33071
aVThe  check is to handle the case where the base64 string decodes to an empty array
p33072
aVIf we were to remove that check then the following line would result in a runtime error if you were running with range checking enabled (which you should be doing)
p33073
aVThe call to  should be self-explanatory
p33074
as(dp33075
g7
V505088
p33076
stp33077
a((dp33078
g2
(lp33079
VHandles belong to the owning process and can only be operated on by the owning process
p33080
aVIf you want to modify a handle in another process you'll need to inject code into that process, or use
p33081
as(dp33082
g7
V505088
p33083
stp33084
a((dp33085
g2
(lp33086
VYour program won't ever crash due to a race on the increment of an integer that is only used as a count
p33087
aVAll that can go wrong is that you don't get the correct answer
p33088
aVObviously if you were using the integer as an index into an array, or perhaps it was a pointer then you could have problems
p33089
aVUnless you are incrementing this value incredibly frequently, it's hard to imagine that an interlocked increment would be expensive enough for you to notice the performance difference
p33090
aVWhat's more the most efficient approach is to get each thread to maintain its own private count
p33091
aVThen sum all the individual thread counts when you join the threads at the end of the calculation
p33092
aVThat way you get the best of both worlds
p33093
aVNo contention on the incrementing, and the correct answer
p33094
aVOf course, you need to take measures to ensure that you don't get caught out by false sharing
p33095
as(dp33096
g7
V505088
p33097
stp33098
a((dp33099
g2
(lp33100
VYou have specified the wrong value for
p33101
aVYou need to specify
p33102
aVCreates a new file, always
p33103
aVIf the specified file exists and is writable, the function overwrites the file, the function succeeds, and last-error code is set to ERROR_ALREADY_EXISTS (183)
p33104
aVIf the specified file does not exist and is a valid path, a new file is created, the function succeeds, and the last-error code is set to zero
p33105
as(dp33106
g7
V505088
p33107
stp33108
a((dp33109
g2
(lp33110
VFont style is a set
p33111
aVCorrect syntax is
p33112
aVIt is a set so that you can apply multiple styles, for example
p33113
as(dp33114
g7
V505088
p33115
stp33116
a((dp33117
g2
(lp33118
VIf you are getting negative values then you are overflowing the variable
p33119
aVYou need to use a data type that has a larger range, one that is sufficient to hold the numbers you wish to calculate
p33120
aVIf your system does not come with such a data type (and I rather suspect that  is as big as you will get) then you will need to use a bignum class
p33121
aVLooking more closely at the numbers in your question, I think that many standard bignum classes will not be able to calculate nn for n=109
p33122
aVAre you sure you wrote the problem down correctly
p33123
as(dp33124
g7
V505088
p33125
stp33126
a((dp33127
g2
(lp33128
VYou are trying to calculate the size of an array from a pointer to a dynamic array
p33129
aVIn C you simply cannot find out the length of an array if you only have a pointer to the array
p33130
aVThe code you are using is appropriate if you have an array, but you don't have an array, you have a pointer
p33131
aVSo, if you had declared  like this
p33132
aVor this
p33133
aVthen  would be an array rather than a pointer and the  code above would be applicable
p33134
aVFortunately you know how big the dynamic array is because you just created it
p33135
aVIt has  elements
p33136
aVSo you must write your call to  like this:
p33137
as(dp33138
g7
V505088
p33139
stp33140
a((dp33141
g2
(lp33142
VThere's nothing that ships with the product that has those properties
p33143
aVThe obvious and simple solution is to reverse the indexing of the list so that when you delete the first element the code actually deletes the last element of the underlying list
p33144
aVTo give you an idea of what I'm getting at, here's the sketch of the beginnings of a very basic implementation
p33145
aVIt would need a lot of work to bring to completion
p33146
aVI'm assuming that you want an array as your underlying storage because I'd guess that you want O(1) random access
p33147
aVAll the other functions that you need, that use an index parameter would also need to call
p33148
aVThe most tricky thing to write would be the sort routines
p33149
aVThe classes in  use
p33150
aVYou would do the same but then delegate the sorting to  passing a locally constructed comparer  that reversed the results of the comparer provided by the caller
p33151
as(dp33152
g7
V505088
p33153
stp33154
a((dp33155
g2
(lp33156
VYou cannot assign array types in C
p33157
aVSo you either have to copy element-wise, or use
p33158
as(dp33159
g7
V505088
p33160
stp33161
a((dp33162
g2
(lp33163
VYou need to implement a progress handler and attach it to the compression class through the  event handler
p33164
aVThen, in your progress handler, set  to
p33165
aVThe first parameter passed to the progress handler is the  instance
p33166
aVYour handler might look like this:
p33167
aVI have assumed that you are using one of the descendents of
p33168
aVThe JEDI code is supplied as source and so you can inspect the source code yourself to work out details such as this
p33169
as(dp33170
g7
V505088
p33171
stp33172
a((dp33173
g2
(lp33174
VThe exception class  raises the error List index out of bounds (0) when you try to access a member of a  instance that is empty
p33175
aVThe most likely candidate for that is the  property of the list items
p33176
aVYou would appear to have fallen into quite a common trap
p33177
aVAlthough you have created columns for the list view, you also need to fill out the  list for each list item
p33178
aVA simple solution is to modify  like this:
p33179
aVAlthough it may in fact be better to add the sub-items at the same time that you create the list items
p33180
aVBut I'm not showing code for that since you didn't include the part of your program that populates the lists
p33181
as(dp33182
g7
V505088
p33183
stp33184
a((dp33185
g2
(lp33186
VUnloading a module from Python is not supported
p33187
as(dp33188
g7
V505088
p33189
stp33190
a((dp33191
g2
(lp33192
VIt doesn't handle the case where  correctly
p33193
aVIn that eventuality you will divide by zero
p33194
aVOtherwise I believe your code to be correct
p33195
as(dp33196
g7
V505088
p33197
stp33198
a((dp33199
g2
(lp33200
VYour problem is in fact that you are passing  in the  message, when in fact you should be passing  or even just
p33201
aVI would do it like this:
p33202
aVI'd also point out that  will not return more than 64k characters to the  isn't what you need
p33203
aVOf course, in the longer run it may be better to use the Unicode throughout so that you can support international text
p33204
aVI personally would always opt for using the Unicode APIs and use the following p/invoke declarations:
p33205
as(dp33206
g7
V505088
p33207
stp33208
a((dp33209
g2
(lp33210
VYou can't get hold of that information by fair means
p33211
aVThe solution is to use two separate top-level event handlers which in turn can call another method passing a parameter identifying which event is being handled
p33212
as(dp33213
g7
V505088
p33214
stp33215
a((dp33216
g2
(lp33217
VIn your  handler you can call
p33218
as(dp33219
g7
V505088
p33220
stp33221
a((dp33222
g2
(lp33223
VYou are looking for implementation inheritance rather than interface inheritance
p33224
aVThis is only achievable in Delphi if you can derive classes from a single common ancestor
p33225
aVThis limitation is inherent because the language only supports single-inheritance
p33226
aVThe best you can do is something like this:
p33227
aVAnd likewise for  etc
p33228
aVNow, you could use interfaces and delegation to reduce some of the boilerplate, but there's no way for that to help with a message handler like
p33229
as(dp33230
g7
V505088
p33231
stp33232
a((dp33233
g2
(lp33234
VThe problem appears to be in the VBA code attached to your document rather than the Delphi code
p33235
aVSpecifically a hidden module named API is implicated
p33236
aVPerhaps this is in a template or an add-in or an auto start
p33237
aVHidden modules are protected which suggests that you may not be able to modify the module
p33238
aVYou could try contacting the author of the protected module or perhaps removing whatever it is that introduced this module
p33239
aVReverting to 32 bit Office is an easier solution
p33240
aVThis will require you to uninstall 64 bit Office first since the two editions do not co-exist
p33241
as(dp33242
g7
V505088
p33243
stp33244
a((dp33245
g2
(lp33246
VYou can't set  to  and call  on the thread instance
p33247
aVYou have to do one or the other, but not both
p33248
aVAs it stands your code destroys the thread twice
p33249
aVYou must never destroy an object twice and of course when the destructor runs for the second time, errors occur
p33250
aVWhat happens here is that since you created the thread suspended, nothing happens until you explicitly free the thread
p33251
aVWhen you do that the destructor resumes the thread, waits for it to complete
p33252
aVThis then results in  being called again because you set  to
p33253
aVThis second call to  closes the handle
p33254
aVThen you return to the thread proc and that calls
p33255
aVThis fails because the thread's handle has been closed
p33256
aVAs Martin points out in the comment you must not create  directly since the   method is abstract
p33257
aVAlso, you should not use  which is deprecated
p33258
aVUse  to begin execution of a suspended thread
p33259
aVPersonally I don't like to use
p33260
aVUsing this feature results in the thread being destroyed on a different thread from which it was created
p33261
aVYou typically use it when you want to forget about the instance reference
p33262
aVThat then leaves you uncertain as to whether or not the thread has been destroyed when your process terminates, or even whether it is terminating and freeing itself during process termination
p33263
aVIf you must use  then you need to make sure that you don't call  after having set  to
p33264
aVSo the obvious solution is to set  to  immediately before after calling  and then forget about the thread instance
p33265
aVIf you have any exceptions before you are ready to start then you can safely free the thread then since you  would still be  at that point
p33266
aVA more elegant approach would be to move all the initialisation into the  constructor
p33267
aVThen the code would look like this:
p33268
as(dp33269
g7
V505088
p33270
stp33271
a((dp33272
g2
(lp33273
VIf you really want to do this then you can avoid disk caching and buffering by specifying  and/or  when opening the file
p33274
aVBeware that using these options will complicate things
p33275
aVThe file or device is being opened with no system caching for data reads and writes
p33276
aVThis flag does not affect hard disk caching or memory mapped files
p33277
aVThere are strict requirements for successfully working with files opened with CreateFile using the FILE_FLAG_NO_BUFFERING flag, for details see File Buffering
p33278
aVA simpler alternative is to call  just before you close the file handle
p33279
as(dp33280
g7
V505088
p33281
stp33282
a((dp33283
g2
(lp33284
VIt doesn't work that way
p33285
aVYou can merge names from one module into the namespace of another module, e
p33286
ag217
aVBut you want to export names from your module into a different module
p33287
aVWhilst you could do that in a hacky way, it's not really how you are intended to program
p33288
aVInstead, simply pass the value as a parameter to the  constructor
p33289
as(dp33290
g7
V505088
p33291
stp33292
a((dp33293
g2
(lp33294
VThe problem is that your code is not retaining the  interface that is returned by the  function
p33295
aVBecause of this, the interface that is returned has its reference count decremented to zero as soon as the initialization section completes
p33296
aVThis therefore frees the object that implements the interface which does this:
p33297
aVThe key line is the call to  which forces the asynchronous call to be executed to completion
p33298
aVAll this happens in the main thread which explains the behaviour that you report
p33299
aVThe solution is that you simply need to keep the  interface alive by storing it in a variable
p33300
aVIn the real code you need to ensure that  had completed before running any code that is reliant on
p33301
aVWhen your program reached a point where it required  to have been called it has to call  on the  interface
p33302
aVSo you might write it something like this
p33303
aVThe call  from other units that required  to have run
p33304
aVOr, alternatively, call  from any methods exported by  that depended on  having run
p33305
aVThe latter option has much better encapsulation
p33306
as(dp33307
g7
V505088
p33308
stp33309
a((dp33310
g2
(lp33311
VThis problem can be solved like so:
p33312
aVObtain or implement a threadsafe version of  and
p33313
aVReplace the VCL's unsafe versions of these functions
p33314
aVFor item 1 I use Primo\u017e Gabrijelcic's code, as described on his blog article on the subject
p33315
aVFor item 2 I simply use the very well-known trick of patching the code at runtime and replacing the beginning of the unsafe routines with unconditional  instructions that redirect execution to the threadsafe functions
p33316
aVPutting it all together results in the following unit
p33317
aVThis unit must be included very early in the
p33318
aVdpr file's list of units
p33319
aVClearly it cannot appear before any custom memory manager, but it should appear immediately after that
p33320
aVThe reason being that the replacement routines must be installed before any calls to  are made
p33321
aVUpdate I have merged in the very latest version of Primo\u017e's code which he kindly sent to me
p33322
as(dp33323
g7
V505088
p33324
stp33325
a((dp33326
g2
(lp33327
VIn order to call Direct Input you will need a Delphi translation of the header file
p33328
aVThe best such translation, to my knowledge, is available from the Clootie graphics pages
p33329
aVYou need to use the  header translation
p33330
aVAs for writing a program that does not show a Window, here's the simplest template:
p33331
aVYou state in a comment that the only function you wish to call is
p33332
aVTo call that function you need the following import declaration:
p33333
as(dp33334
g7
V505088
p33335
stp33336
a((dp33337
g2
(lp33338
VThe documentation states:
p33339
aVWhen you declare a type that is identical to an existing type, the
p33340
aVcompiler treats the new type identifier as an alias for the old one
p33341
aVThus, given the declarations:
p33342
aVX and Y are of the same type; at runtime, there is no way to
p33343
aVdistinguish  from
p33344
aVThis is usually of little
p33345
aVconsequence, but if your purpose in defining a new type is to utilize
p33346
aVruntime type information, for example, to associate a property editor
p33347
aVwith properties of a particular type - the distinction between
p33348
aV'different name' and 'different type' becomes important
p33349
aVIn this case,
p33350
aVuse the syntax:
p33351
aVFor example:
p33352
aVforces the compiler to create a new, distinct type called
p33353
aVIt is not terribly common to need to create a distinct type rather than an alias
p33354
aVHowever, there are occasional uses
p33355
aVThe best example I can think of is to consider the Windows types  and
p33356
aVThese are both pointer sized opaque values
p33357
aVSo it would seem reasonably to define them like this:
p33358
aVHowever this means that variables of these types are assignable to each other
p33359
aVIt makes no sense to pass an  to  and, vice versa, it makes no sense to pass and  to
p33360
aVSo you could delcare the types like this:
p33361
aVNow the languages type system can prevent you from making such banal mistakes and let you get on with real programming
p33362
aVAnother excellent example is given by Andreas and Remy in the comments to the question:
p33363
aVhas a different property editor implemented that allows real-time updates, as you type in the Object Inspector
p33364
aVThat is possible because of
p33365
aVThat would not be possible with
p33366
as(dp33367
g7
V505088
p33368
stp33369
a((dp33370
g2
(lp33371
VI think this function is what you are looking for:
p33372
as(dp33373
g7
V505088
p33374
stp33375
a((dp33376
g2
(lp33377
VA property setter for a property takes only one parameter, of the same type as the property
p33378
aVThere is no syntax that would allow you to write the type of code you are attempting to write
p33379
aVNote that I am ignoring array properties which are not pertinent here
p33380
aVWhat you need to do is to write a dedicated setter which supplies the extra parameter to your  function
p33381
aVAnd then in the implementation you write
p33382
aVYou could hijack index specifiers to effect something similar, but I would not recommend that
p33383
as(dp33384
g7
V505088
p33385
stp33386
a((dp33387
g2
(lp33388
VYou need to call this API function in its asynchronous mode of operation
p33389
aVYou achieve this, as with many other file APIs, by passing an  struct to the API call
p33390
aVWhen you operate asynchronously the function will return immediately and it's up to you when you choose to collect the results
p33391
aVYou can test whether or not the function is ready to supply results, you can opt to be notified that the API has results available, you can cancel the pending I/O, and you can choose to block until results are available
p33392
aVThere is an awful lot of flexibility and naturally the API is more complex to use in asynchronous mode
p33393
aVThere is lots of information on MSDN about overlapped I/O
p33394
aVStart here: Synchronization and Overlapped Input and Output
p33395
as(dp33396
g7
V505088
p33397
stp33398
a((dp33399
g2
(lp33400
VCan I access data in a Python object while the thread does not own the GIL
p33401
aVNo you cannot
p33402
as(dp33403
g7
V505088
p33404
stp33405
a((dp33406
g2
(lp33407
VProbably the simplest is to return the new memory from the function rather than trying to return it via the pointer
p33408
aVThen you would call it like this:
p33409
as(dp33410
g7
V505088
p33411
stp33412
a((dp33413
g2
(lp33414
VYou cannot hope to keep the changes to a minimum unless you start writing the
p33415
aVpas file yourself
p33416
aVThat sounds like a worse option
p33417
aVProbably what is happening is that you have changed version of either one of your compilers since the last time you imported
p33418
aVOtherwise one would expect minimal differences
p33419
aVJust check it in with a comment stating which versions of compiler and
p33420
aVocx/
p33421
aVdll were used
p33422
as(dp33423
g7
V505088
p33424
stp33425
a((dp33426
g2
(lp33427
VThe problem is that you have made  a local procedure
p33428
aVYou need to move it outside the method
p33429
aVOn first inspection I expected that the compiler would emit an error with your code:
p33430
aVE2094 Local procedure/function 'Callback' assigned to procedure variable
p33431
aVBut it does not do so
p33432
aVI dug a little deeper and discovered that the callback parameter for  is declared as type
p33433
aVIf the header translation had declared this as a typed callback parameter then the above error message would indeed have been emitted
p33434
aVTo my mind the header translation is poor in this regard
p33435
aVThere seems very little to be gained from abandoning the safety of the type system
p33436
aVThe fact that your code works in 32 bit code is just a happy coincidence that relies on implementation details
p33437
aVYour luck runs out on 64 bit
p33438
aVAgain, if the type checking system had been enabled, the compiler could have told you what was wrong immediately
p33439
aVSome other comments:
p33440
aVThe  has a couple of incorrect types in its declaration:  should be of type  and the function result should be
p33441
aVis a rather heavyweight approach to getting a module handle
p33442
aVI would prefer to see  with the  and  options
p33443
as(dp33444
g7
V505088
p33445
stp33446
a((dp33447
g2
(lp33448
VThat codes results in a compile error (E2034 Too many actual parameters) in Delphi 6, 2010 and XE2
p33449
aVI guess it's a compiler bug in your version since it is not legal syntax
p33450
as(dp33451
g7
V505088
p33452
stp33453
a((dp33454
g2
(lp33455
VUsing interfaces like this will ensure that the object implementing the interface will be created and freed on the same heap
p33456
aVHowever, this will not solve the problem of dynamic string types being allocated and deallocated on different heaps
p33457
aVThere are many possible solutions to this, but in my view the best approach is to use WideString across the module boundary
p33458
aVThe WideString type is a wrapper around the COM BSTR and is allocated on the shared COM heap
p33459
aVYou only need to use WideString for the interface
p33460
aVThe internals of the implementing classes can use native Delphi strings
p33461
aVJust as strings present problems so do dynamic arrays
p33462
aVAttempting to pas dynamic arrays across module boundaries is not safe
p33463
aVThere is no solution analagous to WideString that is as convenient
p33464
aVYou can use variant arrays but that's pretty clunky in comparison to WideString
p33465
as(dp33466
g7
V505088
p33467
stp33468
a((dp33469
g2
(lp33470
VYou cannot do this with built-in features
p33471
aVIn order to get a function name from an address you need to know the map of the executable
p33472
aVThis is not part of an executable unless you take steps to add it
p33473
aVDebugging tools like JclDebug and madExcept offer the functionality you are looking for
p33474
as(dp33475
g7
V505088
p33476
stp33477
a((dp33478
g2
(lp33479
VThis function is what you need:
p33480
aVThe equivalent function for the second occurrence is:
p33481
aVI'm sure you can fill out the details for third, fourth and fifth
p33482
aVYou may prefer to write a single general function like this:
p33483
as(dp33484
g7
V505088
p33485
stp33486
a((dp33487
g2
(lp33488
V is declared incorrectly
p33489
aVIt is missing the calling convention
p33490
aVIt should be:
p33491
as(dp33492
g7
V505088
p33493
stp33494
a((dp33495
g2
(lp33496
VIf the code in the  block runs it is because an exception was raised
p33497
aVYou swallow the exception which makes it hard to know what's going wrong
p33498
aVYour error message suggests that you are attempting to trap errors raised in the file open
p33499
aVBut since your  block surrounds the entire processing of the file, exceptions raised in the processing, as opposed to the file open, will be mis-reported as "Could not open file"
p33500
aVIf you really must handle the exception then you need to move the  loop to be after the  block
p33501
aVPersonally I'd be inclined to simply ignore the exception and let the default handling of the exception halt execution:
p33502
aVIf you must handle the exception then be discerning about the class exception that you handle
p33503
aVFor example, handle just  since that is what  raises in case of failure
p33504
as(dp33505
g7
V505088
p33506
stp33507
a((dp33508
g2
(lp33509
VBe aware that you can modify ZIP files, e
p33510
ag217
aVby truncating them somewhat, the ZIP file will still be valid
p33511
aVWith my test file, I removed the final 5000 bytes and it was reported as valid
p33512
aVI extracted it successfully using my ZIP program
p33513
aVOf course the extracted contents were incorrect and not the original contents
p33514
aVPerhaps this is what was happening for you
p33515
aVMaybe your attempts to corrupt your ZIP file were not in fact making it into an invalid ZIP file
p33516
aVDelphi XE2 comes with a built in ZIP component that worked well in my simple test and successfully detected an invalid file, once I had truncated the file enough to make it truly corrupt
p33517
aVI used the  method to check validity
p33518
aVHere is my very simple test program
p33519
as(dp33520
g7
V505088
p33521
stp33522
a((dp33523
g2
(lp33524
VYou have the wrong data structure since what you really need is a dictionary
p33525
aVThe fundamental problem with using a list is that you want to search on a subset of the stored record
p33526
aVBut lists are not set up for that
p33527
aVSolve the problem by re-writing using
p33528
aVI can recommend that you have a thorough read of the dictionary code example at the Embarcadero docwiki
p33529
aVThe key to the dictionary is what you call  and the value is
p33530
aVTo add an item you do this:
p33531
aVI'm assuming your dictionary is declared like this:
p33532
aVand created like this:
p33533
aVYou can enumerate the dictionary with a simple  loop
p33534
aVAlthough be warned that the dictionary will enumerate in an odd order
p33535
aVYou may wish to sort before printing
p33536
aVIf you wish to store more information associated with each entry in the dictionary then put the additional fields in a record
p33537
aVThen your dictionary becomes
p33538
as(dp33539
g7
V505088
p33540
stp33541
a((dp33542
g2
(lp33543
VWindows in fact does support virtual desktops
p33544
aVYour proposed solution should work beautifully
p33545
aVCreate a new desktop with  but do not switch to it (obviously)
p33546
aVThen when you create the process, specify this desktop in the  struct that you pass to
p33547
as(dp33548
g7
V505088
p33549
stp33550
a((dp33551
g2
(lp33552
VThe most likely reason is that you have opened the key requesting write access but on Windows 7 under UAC, users do not, by default, have write access to
p33553
aVSolve this by passing  to the  constructor, or by using  rather than
p33554
aVThe next most likely explanation is that you have the 64 bit Firebird server installed
p33555
aVBut your 32 bit program reads from the 32 bit registry and so does not find the keys from the 64 bit Firebird
p33556
aVSee Registry Redirector to learn more about the two different registry views
p33557
aVSee Accessing an Alternate Registry View for details on how to read the 64 bit registry from a 32 bit process
p33558
aVTranslated into Delphi, you would need to include  in the  flags
p33559
aVAgain, you can pass this flag to the  constructor which may be more convenient
p33560
aVSo, in summary, if you are looking for a 32 bit server, create the registry object like this
p33561
aVand if your Firebird server is 64 bit then use this
p33562
as(dp33563
g7
V505088
p33564
stp33565
a((dp33566
g2
(lp33567
VThere's no guarantee anywhere that Windows won't immediately re-use a handle
p33568
aVIn practice, all extant implementations take steps to try to avoid re-using handles
p33569
as(dp33570
g7
V505088
p33571
stp33572
a((dp33573
g2
(lp33574
VThe standard approach to backing up to a remote location is to combine multiple tools:
p33575
aVRun  on the machine which serves svn
p33576
aVUse a tool like  to copy that repo dump from the svn server to the machine which will be backed up
p33577
aVIf your network policy allows you to run an svn server on a machine, but not to schedule  backup jobs on that machine, then I think you need to re-consider your network policy
p33578
as(dp33579
g7
V505088
p33580
stp33581
a((dp33582
g2
(lp33583
VThe following minimal example detects changes in the 64 bit view of the registry, from a 32 bit process
p33584
aVI don't know what's different about your program, but this code proves that a 32 bit program can indeed detect changes in both views
p33585
aVI know this doesn't solve you problem, but I hope it helps steer you in the right direction
p33586
aVNow, as for your program, it looks like there are lots of problems with it
p33587
aVBut the fundamental problem, the one that means you are not notified of changes, is that your event is created incorrectly
p33588
aVYou create it like this:
p33589
aVbut you need to create it like this
p33590
aVI've not delved into what the requirements are for this event, the documentation does not offer any clues
p33591
aVAll I did was look for differences between your code and the code in the MSDN example
p33592
aVMake that change to the event creation and you have enough to start receiving notifications
p33593
aVHowever, when I did that change, your program still did not work and failed with an AV
p33594
aVOne of your objects was not created
p33595
aVHowever, I think those are pretty routine bugs that you can sort out for yourself
p33596
aVI wonder why you are using
p33597
aVWhy don't you use  when you open the key to be passed to
p33598
aVAnd when you try to build a report of what has changed in a key, why don't you use
p33599
aVSince you are not attempting to write ever,  is not appropriate
p33600
aVIf you make these changes then you won't need to run as admin
p33601
as(dp33602
g7
V505088
p33603
stp33604
a((dp33605
g2
(lp33606
VThe @(stack_size_of_params) is a name decoration for stdcall extern "C" functions
p33607
aVI'm more familiar with Microsoft tools but my belief is that you will need to use a
p33608
aVdef file to export undecorated names for functions that use stdcall
p33609
aVEdit: Websearch suggests --kill-at command line option for the GNU tools could avoid need for irksome
p33610
aVdef files
p33611
as(dp33612
g7
V505088
p33613
stp33614
a((dp33615
g2
(lp33616
VYou can use test suites to create as many levels of nesting as you desire
p33617
aVThe documentation offers the following example:
p33618
aVThe  unit exposes the  class, the class that
p33619
aVimplements test suites, so you can create test hierarchies using more
p33620
aVexplicit code:
p33621
aVThe following function, , creates a test suite and adds the
p33622
aVtwo test classes to it:
p33623
aVYet another way to implement the above function would be:
p33624
aVIn the above example, the  constructor adds the tests in the passed array to the
p33625
aVsuite
p33626
aVYou can register a test suite created in any of the above ways by
p33627
aVusing the same call you use to register individual test cases:
p33628
aVWhen run with , you will see the new hierarchy
p33629
as(dp33630
g7
V505088
p33631
stp33632
a((dp33633
g2
(lp33634
V is contiguous
p33635
aVThe first control has  of
p33636
aVThe next has  of  and so on
p33637
aVYou cannot leave any gaps
p33638
aVWhilst you can assign  programmatically, I personally find it easiest to use the GUI to do so
p33639
aVRight click on the form, or indeed on a container control, and select the Tab Order menu item
p33640
aVThen you will see a dialog like this:
p33641
aVYou can use the arrow buttons to re-order, or you can simply drag items to re-order
p33642
aVIt works reasonably well in my view but you must remember that controls which contain other controls (e
p33643
ag217
aVpanels, tabsheets etc
p33644
aVhave their own tab order
p33645
aVFor such a control you need to select that control, right-click and then modify the tab order for the children of that container
p33646
as(dp33647
g7
V505088
p33648
stp33649
a((dp33650
g2
(lp33651
VUse a non-terminating  loop in combination with
p33652
aVNaturally in a real program you would want to include some mechanism to terminate the loop
p33653
aVAlso, I would concur with Dan Bryant's comment above
p33654
aVis seldom the best solution to a problem and a timer would seem more appropriate here
p33655
as(dp33656
g7
V505088
p33657
stp33658
a((dp33659
g2
(lp33660
VIt would appear that  is being overwritten because you are accessing  out of bounds
p33661
aVYour compiler is probably placing  and  close to each other on the stack which is why  is being modified incorrectly
p33662
aVWhen  equals  you write to , which is
p33663
aVThat is out of bounds
p33664
aVBut the next time round you write to  and  and one of those will be the one that causes the modification to
p33665
aVWhen you write , that can only be valid for
p33666
aVAll other values of  result in out-of-bounds access of the array
p33667
aVI would not be surprised if there are other such errors given the confusing nature of this code
p33668
as(dp33669
g7
V505088
p33670
stp33671
a((dp33672
g2
(lp33673
VEek
p33674
aVIt looks like your code either pre-dates or does not use long strings
p33675
aVIf you want to get the same behaviour as in your old Delphi then you need to replace  with
p33676
aVI see that you've tried that already and report that it fails
p33677
aVIt's really the only explanation that makes any sense to me because all other string types are essentially pointers and so the only way the  could ever have worked is with a
p33678
aVThe migration you are attempting is immense and you probably have huge numbers of confounding problems
p33679
aV@LU RD makes a good point in the comments that the record layout may differ between Delphi versions since you are not using a  array
p33680
aVYou can investigate the record layout using the two Delphi versions that you have at hand
p33681
aVYou will need to arrange that the size of the records match between versions, and that the offsets to the fields also match
p33682
aVBased on the comments below, adding a padding byte between pos and nr will resolve your problems
p33683
aVYou could also achieve the same effect by setting the  compiler option to  which would be how I think I would go about things
p33684
aVIn the long run you really ought to get away from short strings, ANSI encoding, direct mapping between your internal records and your data files and so on
p33685
aVIn the short run you may be better off getting hold of the same version of Delphi as was used to build this code and using that
p33686
aVI'd expect this issue to be just the tip of the iceberg
p33687
as(dp33688
g7
V505088
p33689
stp33690
a((dp33691
g2
(lp33692
VThe simple solution is not to remove the system menu in the first place
p33693
aVNote that the system menu is the official name for the menu that is missing in your app
p33694
aVMake your
p33695
aVdfm file look like this:
p33696
aVGet rid of that  code\u2013it's not needed
p33697
aVOK, it looks like a stray bit of code from my experimentation was confounding me
p33698
aVHere's what works
p33699
aVDo exactly what you originally did in your
p33700
aVdfm form:
p33701
aVThen add back the system menu using :
p33702
as(dp33703
g7
V505088
p33704
stp33705
a((dp33706
g2
(lp33707
VWord doesn't use a standard edit control that responds to
p33708
aVTo poke text into Word you could use  to fake input, or COM automation, or UI Automation
p33709
aVThe last of these options, UI Automation, would be my choice and is the way MS intend you to do this nowadays
p33710
as(dp33711
g7
V505088
p33712
stp33713
a((dp33714
g2
(lp33715
VIt's a documentation bug
p33716
aVThe following beeps under Win64:
p33717
as(dp33718
g7
V505088
p33719
stp33720
a((dp33721
g2
(lp33722
VFirst of all your code is C++ rather than C
p33723
aVYour function receives a parameter of type  and the use of  means that your code is actually C++
p33724
aVNow this parameter type is the root of your problem
p33725
aVYou cannot create a  in
p33726
aVnet and instead will need to use a  to pass the string data
p33727
aVThe following code is what you need:
p33728
aVC++
p33729
aVC#
p33730
aVThe default p/invoke marshalling for a
p33731
aVnet  is to pass a  as an  parameter
p33732
aVThere is no need for the complexity of , ,  as suggested by one of the other answers
p33733
aVIf you can let the p/invoke marshaller do the work then it is preferable to do so
p33734
aVNote that you also need to make sure that your calling conventions match
p33735
aVUnder the assumption that you have not used any special compiler options when building your C++ code, that code will default to used  calling convention
p33736
aVYou can make that match with the  parameter to the  attribute
p33737
as(dp33738
g7
V505088
p33739
stp33740
a((dp33741
g2
(lp33742
VThe zip file component that is built into XE2 will do this
p33743
aVThere is an overloaded  method that receives a  as its input parameters
p33744
aVTo extract individual files you can call an overloaded  method passing the name of the file that you wish to extract
p33745
aVThe extracted file is returned as a new instance of
p33746
aVYou can that use  on that instance to transfer the extracted file to your stream
p33747
aVNote that I've not tested this code, I've just written it based on the source code for  and the documentation contained in that source code
p33748
aVThere may be a few wrinkles in this but if the code behaves as advertised it meets your needs perfectly
p33749
aVOK, now I tested it because I was curious
p33750
aVHere's the program that shows that this all works as advertised:
p33751
aVNote that I extracted by index rather than file name since that was more convenient for me
p33752
aVAnd I used file streams rather than memory streams which I imagine you would use
p33753
aVHowever, since the  methods work with  I'm sure that the code will work with streams of any form
p33754
aVThis is the latest in a series of questions about ZIP files
p33755
aVI know that you are using XE2 and I wonder why you seem reluctant to use the built in ZIP class that XE2 provides
p33756
aVI've not seen anything to indicate that it will not fulfil your requirements
p33757
aVIn fact, it is precisely this ability to work directly with streams that makes me feel it has sufficient generality for any application
p33758
as(dp33759
g7
V505088
p33760
stp33761
a((dp33762
g2
(lp33763
VWhatever ultimately calls  needs to pass the  process creation flag
p33764
aVThe process is a console application that is being run without a console window
p33765
aVTherefore, the console handle for the application is not set
p33766
aVExactly how best to achieve that from a script would depend on what script language you are using
p33767
as(dp33768
g7
V505088
p33769
stp33770
a((dp33771
g2
(lp33772
VThe key topic explaining the principles is here: Delphi compiler directives
p33773
aVThe compiler directives are listed here: Delphi Compiler Directives (List)
p33774
aVAs to whether or not the directive has effect over the whole project, an entire unit, an single function and a region with a function, that varies from directive to directive
p33775
aVYou have to read the documentation for each directive to know what its scope is
p33776
aVYou ask if they need to be placed right at the start of the unit
p33777
aVYou need to take account of the scope of the directive
p33778
aVAnother part of the documentation has this to say regarding switch directives:
p33779
aVSwitch directives are either global or local:
p33780
aVGlobal directives affect the entire compilation and must appear before the declaration part of the program or the unit being compiled
p33781
aVLocal directives affect only the part of the compilation that extends from the directive until the next occurrence of the same directive
p33782
aVThey can appear anywhere
p33783
aVHowever, consider the  directive (emphasis mine):
p33784
aVThe  directive prevents the Delphi unit in which it appears from being placed in a package
p33785
aVIf this directive has unit-wide scope then it merely needs to be present in the unit to take effect
p33786
aVSo it can matter where the directive is placed
p33787
aVThe bottom line is that, for each directive, you need to know its scope and in order to do so you must consult the documentation for that directive
p33788
aVNote that you only need to set directives in code if you wish to change the settings from those made in the project settings
p33789
aVIt's perfectly reasonable to set the options in the project options and not set them in code
p33790
aVWhat appears to have happened in the code you present is that the author typed CTRL+O O and the IDE inserted the various settings as defined in the project options at that instant in time
p33791
as(dp33792
g7
V505088
p33793
stp33794
a((dp33795
g2
(lp33796
V exposes a property named  that points to the first byte of the stream
p33797
aVSo you can do something like this:
p33798
aVWhere  would be defined like this:
p33799
aVand modified the byte it was passed in-place
p33800
aVFor your trivial encryption scheme you could write the code like this:
p33801
aVI've been a bit lazy here and written the modification directly into the loop since it requires knowledge of the current index
p33802
aVYou will want to make sure that range checking is disabled for this block of code
p33803
aVThe error in your code, in the updated question, is that you need to shift by  rather than
p33804
as(dp33805
g7
V505088
p33806
stp33807
a((dp33808
g2
(lp33809
VMost keys under  are subject to redirection and this key falls into that category
p33810
aVIt will be redirected when accessed from a 32 bit process running under the WOW64 emulator
p33811
aVUse  to access the 32-bit view of the registry or  to access the 64-bit view of the registry
p33812
aVSpecify neither to access the view of the registry with the same bitness as the calling process
p33813
aVThe full list of keys that are affected by redirection is here: Registry Keys Affected by WOW64
p33814
aVThe table presented there is a little tricky to read
p33815
aVFor example, and considering only Windows 7,  is marked a being redirected
p33816
aVHowever, a number of sub keys are marked as being shared rather than redirected
p33817
aVShared means that both 32 and 64 bit processes see the same underlying data
p33818
aVSo, not all sub-keys of  are redirected
p33819
aVIf a sub-key of  is not indicated as being shared, then it is redirected
p33820
aVAnd that's the case for your key
p33821
aVIn the question title and in the comments you indicate that the key you are looking for is in the 32 bit view of the registry
p33822
aVIn that case, since your process is also 32 bit, you have nothing to do
p33823
aVOpen the registry with  only
p33824
aVYou don't need to elevate to admin because you are only reading
p33825
aVYou then ask to read  and let the redirector take you to the 32 bit view under
p33826
aVOne of the golden rules of using the registry is that you should never hard-code  in your app
p33827
aVLet the redirector do the work
p33828
as(dp33829
g7
V505088
p33830
stp33831
a((dp33832
g2
(lp33833
VThe C, C++, C# and Java standards all use the following terms:
p33834
aVThe operator is the conditional operator
p33835
aVSuch an expression is a conditional expression
p33836
aVSo those are official names
p33837
aVProgrammers often more loosely refer to it as the ternary operator since it is the only commonly used operator with 3 operands
p33838
aVStrictly speaking it is only a ternary operator
p33839
as(dp33840
g7
V505088
p33841
stp33842
a((dp33843
g2
(lp33844
VThat's not possible, in general, in a clean manner
p33845
aVYour options:
p33846
aVAdd a method to the class that returns
p33847
aVStop using  and create a local variable for the instance
p33848
aVOption 1 is viable if you have control over the class
p33849
aVBut it leaves the class looking rather odd
p33850
aVWhy would a class need an instance method that returned the instance
p33851
aVIf you don't have control over the class then you could use a class helper as RRUZ suggests but I regard the use of class helpers as a last resort
p33852
aVI've never solved a problem with a class helper
p33853
aVThat leaves option 2
p33854
aVThis would be how I would solve the problem
p33855
as(dp33856
g7
V505088
p33857
stp33858
a((dp33859
g2
(lp33860
VIt has a value of
p33861
aVI obtained this with the following C program
p33862
aVI personally feel that it's safer to use the actual Windows header files than to attempt translation, but perhaps that's just because I don't know enough about C
p33863
as(dp33864
g7
V505088
p33865
stp33866
a((dp33867
g2
(lp33868
VWIC (available for XP and up) can handle this image
p33869
aVThis component is wrapped up nicely in Delphi 2010 and up
p33870
aVFor earlier Delphi versions it is easy enough to call WIC using the COM interfaces
p33871
aVHere's my proof of concept code:
p33872
aVNote 1: WIC is delivered with Vista but has to be re-distributed for XP
p33873
aVOne obvious option would be to use WIC if available, but fall back to the Delphi JPEG decoder otherwise
p33874
aVNote 2: I can't find a re-distributable package for WIC
p33875
aVI suspect it may require end-user download for XP
p33876
aVThat said I would not be at all surprised if the vast majority of XP machines had it installed by now
p33877
as(dp33878
g7
V505088
p33879
stp33880
a((dp33881
g2
(lp33882
VYou cannot acquire elevated privileges after the process has started
p33883
aVYour options are:
p33884
aVPut the part of your application that requires elevated privileges into a separate process and manifest that with
p33885
aVRun the part of your application that requires elevated privileges as an out-of-proc COM object
p33886
as(dp33887
g7
V505088
p33888
stp33889
a((dp33890
g2
(lp33891
VYou need to use the  operator to test whether or not a key is in the dictionary
p33892
aVWith your variable names this becomes:
p33893
aVIf you wish to check for the presence of the key and retrieve the value in one go you can use the  method:
p33894
aVYou can supply your own default value to  which is returned if the key is not found
p33895
aVThen you could write your code like this:
p33896
as(dp33897
g7
V505088
p33898
stp33899
a((dp33900
g2
(lp33901
VClearly  is your problem and you certainly must not do that
p33902
aVYou could use , but then the challenge is how to keep window A on top of window B
p33903
aVThe way to do that is to make A be owned by B
p33904
aVOwned Windows
p33905
aVAn overlapped or pop-up window can be owned by another
p33906
aVoverlapped or pop-up window
p33907
aVBeing owned places several constraints on
p33908
aVa window
p33909
aVAn owned window is always above its owner in the z-order
p33910
aVThe system automatically destroys an owned window when its owner is
p33911
aVdestroyed
p33912
aVAn owned window is hidden when its owner is minimized
p33913
aVOnly
p33914
aVan overlapped or pop-up window can be an owner window; a child window
p33915
aVcannot be an owner window
p33916
aVAn application creates an owned window by
p33917
aVspecifying the owner's window handle as the hwndParent parameter of
p33918
aVwhen it creates a window with the  or
p33919
aVstyle
p33920
aVThe hwndParent parameter must identify an overlapped
p33921
aVor pop-up window
p33922
aVIf hwndParent identifies a child window, the system
p33923
aVassigns ownership to the top-level parent window of the child window
p33924
aVAfter creating an owned window, an application cannot transfer
p33925
aVownership of the window to another window
p33926
aVIn fact, as you can see from the first bullet point above, once the ownership is correctly setup, there's no need for
p33927
as(dp33928
g7
V505088
p33929
stp33930
a((dp33931
g2
(lp33932
VUpdate
p33933
aVHaving seen the updated question, the various comments, and the code of your native function, it seems likely that the exception is raised when you call
p33934
aVIt's simple enough to debug
p33935
aVI would replace your function with one like this:
p33936
aVunsigned char versionString[50];
p33937
aVIf that still fails then my guess is that the error is raised in the  of your DLL
p33938
aVDebug that by putting the above function into a plain vanilla DLL that does nothing else
p33939
aVOriginal answer
p33940
aVCalling convention is the most obvious problem
p33941
aVYour native code most likely uses  but the p/invoke default is
p33942
aVChange your p/invoke signature to be like this:
p33943
aVYou can safely omit the  parameter since none of the parameters have text because you are treating the return value as a pointer
p33944
aVEdit: Hans correctly points out in the comments that since there are no parameters, the calling convention mis-match does not matter
p33945
aVSo this isn't the problem
p33946
aVCall  to convert to a
p33947
aVnet string
p33948
aVSince  is expecting an  parameter I would recommend that you use  as the return type of you p/invoke signature
p33949
aVThis all assumes that the memory returned from your native function is allocated and freed in the native DLL
p33950
aVIf it is heap allocated and you expect the caller to deallocate it then you have a small problem
p33951
aVHow do you deallocate the memory from C# since you don't have access to the native DLL's heap
p33952
aVThe simple solution is to use the shared COM heap to allocate the memory
p33953
aVCall  to allocate the buffer for the string
p33954
aVThen declare the return value to be of type  and the p/invoke marshaller will deallocate with the COM allocator
p33955
aVOf course, this only applies if you are returning heap allocated memory that you expect the caller to deallocate
p33956
as(dp33957
g7
V505088
p33958
stp33959
a((dp33960
g2
(lp33961
VOne commonly used option is to post yourself a message in the form's
p33962
aVLike this:
p33963
as(dp33964
g7
V505088
p33965
stp33966
a((dp33967
g2
(lp33968
VYou should not use
p33969
aVThis has far too much power and all best practice tells you not to use it
p33970
aVIn my view you should be creating a local user with appropriate rights as part of your installation
p33971
aVThis is a fairly common practice for server/database products
p33972
as(dp33973
g7
V505088
p33974
stp33975
a((dp33976
g2
(lp33977
VYou forgot to allocate memory for
p33978
aVYou need to allocate it from the heap with  or stack allocate it
p33979
aVI've omitted all error checking, protection against over-running buffers etc
p33980
aVSince  is a pointer, you are incorrect in taking its address in your
p33981
as(dp33982
g7
V505088
p33983
stp33984
a((dp33985
g2
(lp33986
VYou need to list just the extensions
p33987
aVAt least, that's how I read the documentation
p33988
aVFrom the comments it looks like you want to store in the control some friendly text that indicates what type of file the mask refers to, e
p33989
ag217
aVimage files, executable files, text files etc
p33990
aVYou could perhaps re-purpose the  property to do this
p33991
aVYou could use the  property and store a
p33992
aVYou could derive from  a new class that contained an extra property
p33993
aVOr you could just store the information in the form class that owns the list box
p33994
as(dp33995
g7
V505088
p33996
stp33997
a((dp33998
g2
(lp33999
VThe linker simply includes the functions that are needed by the host executable
p34000
aVThe functions that are not needed are not included
p34001
aVThis is pretty standard behaviour of linkers when linking static libraries
p34002
as(dp34003
g7
V505088
p34004
stp34005
a((dp34006
g2
(lp34007
V already is a pointer
p34008
aVSo you should use  rather than
p34009
as(dp34010
g7
V505088
p34011
stp34012
a((dp34013
g2
(lp34014
VThere is no real valued solution to  and so  is the correct answer
p34015
aVWhat you are attempting here is akin to asking for the square root of a negative number
p34016
aVWhen you successfully evaluated
p34017
aVthe precedence of the operators meant that this was equivalent to
p34018
aVand of course that is well-defined
p34019
as(dp34020
g7
V505088
p34021
stp34022
a((dp34023
g2
(lp34024
VYou also need to call  to apply the changes
p34025
aVIt seems that the examples on MSDN are sorely lacking in detail, as discussed here
p34026
aVI hacked the code from this article to get the following which behaves well:
p34027
as(dp34028
g7
V505088
p34029
stp34030
a((dp34031
g2
(lp34032
VCreate a GUI app with whatever GUI libraries you favour, e
p34033
ag217
aVWinForms, MFC, VCL, ATL, Win32, Qt etc
p34034
aVThen communicate with your service using some form of IPC
p34035
aVSince you are already using sockets they would seem an obvious choice
p34036
as(dp34037
g7
V505088
p34038
stp34039
a((dp34040
g2
(lp34041
VInstance of classes in C# are references and thus are analogous to pointers
p34042
aVIn C# when you write  where  and  are instances of classes, the only thing that is copied is the reference to the object
p34043
aVYou now have two references to the same object
p34044
aVAs I read your question, C# references will serve your purposes
p34045
as(dp34046
g7
V505088
p34047
stp34048
a((dp34049
g2
(lp34050
VIt sounds like the problem is that you are creating a console application
p34051
aVThese come with a console by default
p34052
aVThey either inherit the console of the process that called them, if it has one, or otherwise create a new console
p34053
aVYou should make your application target the GUI subsystem rather than the console subsystem
p34054
aVThis doesn't mean that you have to show any GUI
p34055
aVIt's perfectly reasonable and commonplace to make an application that targets the GUI subsytem but does not show any windows
p34056
as(dp34057
g7
V505088
p34058
stp34059
a((dp34060
g2
(lp34061
VThere is no data type  declared in standard C
p34062
aVI can't say for sure but most likely this  is one of the standard Windows Data Types
p34063
aVIt would have been introduced by:
p34064
aVA  is an opaque type used to represent a Win32 object, for example a file, a mutex, an event etc
p34065
as(dp34066
g7
V505088
p34067
stp34068
a((dp34069
g2
(lp34070
VCode that resides in a DLL runs at just the same speed as code that resides in the host executable
p34071
aVIt is exceedingly unlikely that moving code to a DLL will result in a discernible drop in performance
p34072
aVHowever, you state in comments to the question that you have also ported from Delphi 2007 to Delphi XE2
p34073
aVThat is almost certainly the change that resulted in the performance drop
p34074
aVWhen measuring and comparing performance it is simply crucial to change one thing at a time so that you remove any possibility for confounding factors
p34075
as(dp34076
g7
V505088
p34077
stp34078
a((dp34079
g2
(lp34080
VThey both mean the same as others have said
p34081
aVThere is a trap waiting for you though
p34082
aVConsider this code:
p34083
aVYou might think that this declared to pointers to
p34084
aVNo so but otherwise
p34085
aVIn fact  is  but  is
p34086
aVThis is one of the reasons for many C programmers preferring to put the  next to the variable rather than the type
p34087
aVWhen written like this:
p34088
aVyou are less likely to be misled as to what  and  are
p34089
aVHaving said all that, many coding standards insist that you declare no more than one variable per line, i,e
p34090
aVIf you follow the one variable per line rule then there is definitely no scope for confusion
p34091
as(dp34092
g7
V505088
p34093
stp34094
a((dp34095
g2
(lp34096
VThe  values are the  values you passed when you called
p34097
aVIn this case they are the values  and
p34098
aVThe  value contains the key combination that was actually pressed
p34099
aVThe low-order word specifies the keys that were to be pressed in combination with the key specified by the high-order word to generate the  message
p34100
aVIt's all explained in the MSDN topic for
p34101
as(dp34102
g7
V505088
p34103
stp34104
a((dp34105
g2
(lp34106
VYour question seems to be
p34107
aVWhy does the compiler emit this error
p34108
aVIf you refer to unit A then that reference to unit A needs to be resolved
p34109
aVIf it cannot be found in the current package, or another package in the requires clause, then the compiler simply cannot proceed
p34110
aVYou also ask:
p34111
aVWhy the compiler cannot include an external DCU in my package
p34112
aVYou can simply add the unit to your package in the contains clause of your
p34113
aVdpk file
p34114
as(dp34115
g7
V505088
p34116
stp34117
a((dp34118
g2
(lp34119
VWhat you report doesn't quite add up
p34120
aVThe  unit that is part of the Delphi source does not refer to
p34121
aVAnd none of the units used by  refer to it either
p34122
aVSo the explanations that seem plausible to me are:
p34123
aVYou are including a unit called  somewhere in your project
p34124
aVYou've found a compiler bug
p34125
aVThe error message  is emitted typically, in my experience, when you attempt to recompile an RTL/VCL unit but fail to set the project options to match that used by the true RTL/VCL
p34126
aVAlternatively it will be emitted when you recompile an RTL/VCL unit that has modifications in its interface section
p34127
as(dp34128
g7
V505088
p34129
stp34130
a((dp34131
g2
(lp34132
VThis code exhibits undefined behaviour because pointer arithmetic is only defined when the operands are both in the same array or struct
p34133
aVThe value of 1 comes about because the compiler has placed  and  next to each other in memory
p34134
aVAnother compiler could do something different
p34135
aVIndeed the same compiler could do something different the next time you change the code
p34136
as(dp34137
g7
V505088
p34138
stp34139
a((dp34140
g2
(lp34141
VLocation of DCU files
p34142
aVRegarding the DCUs that are the output of the compilation process, you should specify a DCU output directory in each project file
p34143
aVThe default value for this, in the latest version of Delphi would be fine:
p34144
aVThis results in sub-folders of the project directory like this:  or
p34145
aVIf you set-up your project files using option sets then you will be able to control this setting (and all others) from a small number of option files
p34146
aVLocation of 3rd party code
p34147
aVYou should always use 3rd party library as code
p34148
aVIf the vendor charges more to receive the library as code, pay up
p34149
aVOnce you have done so you simply include the source code into your version control system (VCS) and treat it largely the same way as you treat your own code
p34150
aVI say largely because you should avoid modifying it
p34151
aVOnce you have all your code in the VCS then you can put the entire source code onto a new machine with a single checkout operation
p34152
aVOrganisation of your projects
p34153
aVI personally have a strong aversion to using compiler search paths
p34154
aVI don't use them and include every unit that is required in a project in the
p34155
aVdpr file
p34156
aVIf you do use search paths then you make it impossible to work on variant projects
p34157
aVSo for example, suppose you have a client that has discovered a bug in the version of the software you released 2 years ago
p34158
aVYou would like to address that bug by releasing an upgrade to the 2 year old version of the software
p34159
aVIt is perfectly plausible that asking them to upgrade to the latest version is not viable
p34160
aVPerhaps they have not paid for the upgrades
p34161
aVPerhaps the full upgrade has breaking changes that they do not want to tackle right now
p34162
aVA perfect example would be all the Delphi developers still using Delphi 7
p34163
aVNow, having motivated the scenario, how would you create a build environment for the 2 year old project
p34164
aVIf you are using search paths then they will refer to today's libraries
p34165
aVYou would be forced to change your search path, or copy the old libraries over the top of today's libraries
p34166
aVThat entire headache is trivially side-stepped by not using search paths and by including all your source in the VCS
p34167
aVWhat you should be aiming for is to be able to checkout any historic version of your program and have it build immediately
p34168
aVYou should be able to do this with full confidence that you are building identical software to what was built at the time that version was released
p34169
aVThis also requires you to have build automation but I can't imagine you are lacking that for a project of this size
p34170
as(dp34171
g7
V505088
p34172
stp34173
a((dp34174
g2
(lp34175
VRegarding your update to the question (which really needs to be a new question), here's what you need to do
p34176
aVFirst of all, since both your key and value for the dictionary are value types you need to use
p34177
aVWhen you add items to the dictionary, a copy is made of both key and value so this means you need not do any dynamic allocation
p34178
aVYour code should look like this:
p34179
aVWhen you have finished with the dictionary all you need to do is free it
p34180
aVThe dictionary owns all the contents and will clean up
p34181
aVYou may well prefer to wrap up the functionality of the dictionary and expose it through a higher-level interface
p34182
aVSo you may have an  method that received as parameters all the fields of the value to be added
p34183
aVAnd you may want an update method that received just the mutable fields
p34184
as(dp34185
g7
V505088
p34186
stp34187
a((dp34188
g2
(lp34189
VYour process targets x86 (i
p34190
ag192
aVit is a 32-bit process) and when run on a 64-bit machine under the WOW64 emulator, registry redirection comes into play
p34191
aVFor certain parts of the registry the system maintains two distinct views, one for 32 bit processes and one for 64 bit processes
p34192
aVThe list of keys affected by redirection is here: Registry Keys Affected by WOW64
p34193
aVRedirection is transparent to an application
p34194
aVA 32 bit process access  and does not know (indeed does not need to know), that the 64 bit OS is actually accessing
p34195
aVYou have a number of options available to you:
p34196
aVSwitch to the AnyCPU target so that your process will run as either 32 bit or 64 bit depending on the underlying OS
p34197
aVThis is awkward to achieve in the Express version because the target platform cannot be specified from the IDE
p34198
aVExplicitly open a 64 bit view of the registry
p34199
aVIn
p34200
aVnet this requires the  enumeration
p34201
aVHowever, note that this functionality requires
p34202
aVnet 4 and for earlier versions of
p34203
aVnet, p/invoke is required to open views of the registry
p34204
aVContinue to target x86 and write to
p34205
aVA 64-bit system will read both views of the registry when processing the run at startup registry keys
p34206
aVIn other words your existing approach already works
p34207
aVAs a final point I would comment that the task of setting up this registry key is best left to an installation program
p34208
aVModify keys under  requires admin rights and typically you can only expect to have admin rights at install time
p34209
as(dp34210
g7
V505088
p34211
stp34212
a((dp34213
g2
(lp34214
VOK, I was brave enough to download and register this OCX and try to replicate what you did
p34215
aVAnd yes I found the same behaviour as your reported
p34216
aVSo, I looked at the imported type library unit in XE2
p34217
aVRemember that in XE2 a component appears on the palette
p34218
aVAt the bottom of the unit is this code:
p34219
aVThis code registers the component in the palette and it is missing when the OCX is imported in Delphi 6, the only old Delphi I have to hand
p34220
aVIndeed the entire  component is missing from the import unit
p34221
aVSometimes the import process fails
p34222
aVSo I simply took the imported type library file from XE2 and copied it over the top of the equivalent unit in D6
p34223
aVThat's the unit named
p34224
aVWhen I compiled in D6 there was a compiler error because  was not recognised
p34225
aVReplace that with  in D6
p34226
aVAt that point the compilation succeeds and the component appears on the palette
p34227
aVNow, when I attempt to add it to a form an OLE error is produced, but I can't really help with that since I know nothing about the component
p34228
aVNote that this error occurs in both XE2 and D6
p34229
as(dp34230
g7
V505088
p34231
stp34232
a((dp34233
g2
(lp34234
VSometimes you will get an access violation and sometimes you will get  and no doubt there are other modes of failure
p34235
aVAnd even sometimes the code will appear to work and the crash will happen later
p34236
aVIt all depends on what value happens to be in  when you call  on it
p34237
as(dp34238
g7
V505088
p34239
stp34240
a((dp34241
g2
(lp34242
VIf this code
p34243
aVresults in
p34244
aVs
p34245
aVt_con_cust[0] -> 1
p34246
ag34245
aVt_con_cust[0] -> 0
p34247
aVthen the only explanation that makes sense is that
p34248
aVIf that condition was not true then how could assignment to  affect
p34249
aVI predict that when you test the two pointers for equality you will find that they are indeed equal
p34250
aVAnd then you just need to find the part of the code that assigns the two pointers to the same value
p34251
as(dp34252
g7
V505088
p34253
stp34254
a((dp34255
g2
(lp34256
VIn Python 2
p34257
aVx,  and  are limited to working with C  and your large integers are just too big for that
p34258
aVThis limitation is simply due to the implementation choices made for  and
p34259
aVIn Python 3
p34260
aVx the limitation has been removed and you can perform  with very large integers
p34261
aVThe official list of changes for Python 3 has this to say:
p34262
aVnow behaves like  used to behave, except it works with values of arbitrary size
p34263
aVThe latter no longer exists
p34264
aVIn Python 2
p34265
aVx the  function returned a list
p34266
aVClearly there's no hope of allocating memory for all the elements for very large ranges
p34267
aVThe  function returns an  object
p34268
aVThe documentation describes it as "an opaque sequence type which yields the same values as the corresponding list, without actually storing them all simultaneously"
p34269
aVThe documentation goes on to say this:
p34270
aVis intended to be simple and fast
p34271
aVImplementations may impose restrictions to achieve this
p34272
aVThe C implementation of Python restricts all arguments to native C longs (\u201cshort\u201d Python integers), and also requires that the number of elements fit in a native C long
p34273
aVThis explains the limitations in Python 2
p34274
ag18839
aVI'm not quite sure what you can usefully do with the new Python 3 support for very large ranges
p34275
aVFor example, I would not recommend you try this:
p34276
aVThat will run for a long time
p34277
aVYou indicate in the comments that you are writing code to count up to a large number
p34278
aVYou can do this trivially in Python with code like this:
p34279
aVBut you will discover that if  is a large number then this will take a very long time
p34280
aVThere's not any getting around that for values of  of the order 218 as per your question
p34281
as(dp34282
g7
V505088
p34283
stp34284
a((dp34285
g2
(lp34286
VThe best way is to attempt to write files to the directory
p34287
aVIf writing fails due to lack of rights, then the error code will tell you that
p34288
aVLook for
p34289
aVIf you try and do it any other way then you will just be replicating system code that was about to run anyway
p34290
aVAnd there's little chance for you to replicate it perfectly for current versions of Windows and future versions
p34291
aVThere's no need to create a file and write a single byte to it
p34292
aVJust assume that you have write access to the temporary folder and attempt to write the entire file(s) that you need to
p34293
aVIf you ever encounter a failure then you may as well terminate the process
p34294
aVThere's not much point in proceeding if you can't write to the temporary folder
p34295
as(dp34296
g7
V505088
p34297
stp34298
a((dp34299
g2
(lp34300
VUpdate It turns out that you are using
p34301
aVnet 3
p34302
aV5 and  was added in
p34303
aVnet 4
p34304
aVSo you should use
p34305
aVActually I'd probably add an extension method named  to do this since it is far more readable, in my view, than
p34306
aVI would use none of those and instead call
p34307
aVis a convenience method that is equivalent to setting the Length property of the current instance to 0 (zero)
p34308
aVI can't imagine that it's slower than any of your variants and I also can't imagine that clearing a  instance could ever be a bottleneck
p34309
aVIf there is a bottleneck anywhere it will be in the appending code
p34310
aVIf performance of clearing the object really is a bottleneck then you will need to time your code to know which variant is faster
p34311
aVThere's never a real substitute for benchmarking when considering performance
p34312
as(dp34313
g7
V505088
p34314
stp34315
a((dp34316
g2
(lp34317
VI would simply use a one-shot timer
p34318
aVWhen the service starts, work out when the next message is due to be delivered
p34319
aVThen start a new one-shot timer with interval equal to the time until the next message is due to be delivered
p34320
aVWhen that timer fires, deliver all messages that are due and start a new one-shot timer
p34321
aVRepeat that process in a non-terminating loop
p34322
as(dp34323
g7
V505088
p34324
stp34325
a((dp34326
g2
(lp34327
VSet the  property to
p34328
aVDetermines whether the list view gives a visual indication of which item is selected when focus shifts to another control
p34329
aVSet HideSelection to false to provide visual feedback of the selected item in the list even when the list view does not have focus
p34330
aVSet HideSelection to true to show the selection only when the list view has focus
p34331
aVHideSelection does not affect the actual value of the selection, only the visual indication
p34332
aVAlways setting HideSelection to false can make forms with many list views look too busy
p34333
as(dp34334
g7
V505088
p34335
stp34336
a((dp34337
g2
(lp34338
VThe pertinent section of the attributes documentation is this:
p34339
aVIt is important to understand that the values passed to the attribute's constructor must be constant expressions
p34340
aVBecause those values must be embedded directly into the resulting binary, it is impossible to pass an expression that requires run-time evaluation
p34341
aVThis raises a few limitations to the information that can be passed to the attribute at compile time:
p34342
aVOnly constant expressions are allowed, including sets, strings, and ordinal expressions
p34343
aVout and var parameters cannot be used, because they require run-time evaluation of addresses of passed parameters
p34344
aVAddr() intrinsic and @ operator cannot be used
p34345
aVThe TypeInfo() operator can be used to pass type information, because the RTTI block addresses are known at compile time
p34346
aVClass references are allowed, because the metaclass addresses (as the case of TypeInfo()) are known at compile time
p34347
aVThe key point is that a constant expression is a technical Pascal term that is not the same thing as a constant
p34348
aVI suspect that this is the root of the confusion
p34349
aVSince it is not possible to have a constant expression that can be passed to a , you are out of luck with your attribute
p34350
aVIndeed it is just as impossible to have a constant expression that can be passed to an open array parameter
p34351
aVI suppose that you could use the string representation of the  to solve the conundrum but that will leave you with messy duplication and an inability to pass arrays of GUIDs
p34352
as(dp34353
g7
V505088
p34354
stp34355
a((dp34356
g2
(lp34357
VYou would have to enumerate all types known to the Python interpreter
p34358
aVI guess that would be possible but it would be essentially meaningless since there are so many types
p34359
aVPython is a dynamically typed language and as such it does not have variables in the same sense as statically typed languages like C
p34360
aVIn your snippet,  is simply a name which is bound to an object
p34361
aVThat object could be of any type known to the Python interpreter
p34362
aVThere is a fundamental difference in mindset when programming in a dynamically typed language and asking questions like, what type is this object
p34363
aVshould be avoided
p34364
aVInstead it is preferable to ask questions of the form, what operations does this object support
p34365
aVThis approach to programming is known as duck typing
p34366
as(dp34367
g7
V505088
p34368
stp34369
a((dp34370
g2
(lp34371
VIt's rather difficult to understand exactly what your problem is, but one solution is obvious
p34372
aVThe openNURBS code is freely available with a completely permissive license
p34373
aVYou should simply download it and compile it directly in mingw
p34374
aVIn any case this is going to be the only viable route
p34375
aVC++ does not have a standard binary interface and each tool has a different binary interface
p34376
aVThis can even differ between different versions of the same tool
p34377
aVWhat's more, the MSVC compiled library will have a dependency on a different C++ runtime library from your mingw compiled code
p34378
aVSo, the bottom line is that you need openNURBS compiled by your mingw compiler
p34379
aVBut thankfully that's possible because the library is distributed as source
p34380
as(dp34381
g7
V505088
p34382
stp34383
a((dp34384
g2
(lp34385
VI use the following code:
p34386
aVYou would implement your hook/patch/detour by calling :
p34387
aVThis will work for 32 bit code
p34388
aVIt will also work for 64 bit code provided that both the old and new functions reside in the same executable module
p34389
aVOtherwise the jump distance may exceed the range of a 32 bit integer
p34390
aVI'd be very interested if somebody could provide an alternative that worked for 64 bit address space irrespective of how far apart the two addresses were
p34391
as(dp34392
g7
V505088
p34393
stp34394
a((dp34395
g2
(lp34396
VYour handler for  is fine for moving operations but needs to be different for sizing operations
p34397
aVYou can't detect those from within that message handler so you need an alternative
p34398
aVInstead use  and  like this:
p34399
aVYou will need to remove the  altogether
p34400
as(dp34401
g7
V505088
p34402
stp34403
a((dp34404
g2
(lp34405
VAll the time is spent performing these two lines of code:
p34406
aVYou can delete all the code that works with the bitmap and the code that actually draws the bitmap and it makes not one iota of difference to the runtime
p34407
aVIn other words, the bottleneck is the scene code not the bitmap code
p34408
aVAnd I see no way for you to optimise that
p34409
aVMy test code looked like this:
p34410
aVThis has the same elapsed time as your code, 1600ms on my machine
p34411
aVIf you remove the ,  and  calls then your code runs in 3ms on my machine
p34412
as(dp34413
g7
V505088
p34414
stp34415
a((dp34416
g2
(lp34417
VFor Win32 you do this with the  and  functions:
p34418
aVThis code toggles the checked property
p34419
aVIt assumes that you are identifying the menu item by ID rather than position
p34420
aVLooking at the code you posted,  appears suspicious
p34421
aVI imagine that  is an identifier rather than an
p34422
aVCasting is always a sign of a potential problem
p34423
aVIf you don't have the  to hand then call  to obtain it
p34424
aVIn your code you should be testing the return value of the API calls and if they return  then you should call  to obtain further information about the failure
p34425
as(dp34426
g7
V505088
p34427
stp34428
a((dp34429
g2
(lp34430
VThere's no requirement at all that the native library that you call with ctypes has to be built with a matching runtime
p34431
aVIn fact there's not even a requirement that the native library even uses a C runtime
p34432
aVFor example you can use ctypes to call code written in other languages, e
p34433
ag217
aVDelphi
p34434
aVOr you can use ctypes to call Windows API functions which are not linked against MSVC
p34435
aVI guess you'll have to look elsewhere to resolve your problem
p34436
as(dp34437
g7
V505088
p34438
stp34439
a((dp34440
g2
(lp34441
VThere is a well known script published by Microsoft known as
p34442
aVIt comes in the form of the Elevation PowerToys
p34443
aVYou can down load it from here
p34444
aVThe two files you need are  and
p34445
aVPut those in the same directory as your
p34446
aVcmd file, or perhaps somewhere on your system path
p34447
aVThen your
p34448
aVcmd file should just read:
p34449
as(dp34450
g7
V505088
p34451
stp34452
a((dp34453
g2
(lp34454
VUnless stated explicitly anywhere, the DLLs are not redistributable other than via the redistributable package to which you link
p34455
aVStandard practise from Microsoft is to force you to use the redistributable package, presumably in an effort to avoid lots of bad user experience from botched manual installations
p34456
aVSo I think you will just have to accept the deployment of this package
p34457
as(dp34458
g7
V505088
p34459
stp34460
a((dp34461
g2
(lp34462
VYou should call  which is easier to use than the older
p34463
aVYou will need to open the file by calling  but that's a cheap operation
p34464
aVYour assumption that opening a file is expensive, even a 12GB file, is false
p34465
aVYou could use the following function to get the job done:
p34466
aVThere are other API calls that will return you the file size without forcing you to create a file handle, notably
p34467
aVHowever, it's perfectly plausible that this function will just open the file behind the scenes
p34468
aVIf you are compiling with Visual Studio and want to avoid calling Win32 APIs then you can use
p34469
aVHere is a  based version of the function:
p34470
aVIf performance ever became an issue for you then you should time the various options on all the platforms that you target in order to reach a decision
p34471
aVDon't assume that the APIs that don't require you to call  will be faster
p34472
aVThey might be but you won't know until you have timed it
p34473
as(dp34474
g7
V505088
p34475
stp34476
a((dp34477
g2
(lp34478
VUse  with  exactly as you have been doing
p34479
aVI see no reason to use  on Windows, your code may as well always use the native UTF-16 encoding
p34480
as(dp34481
g7
V505088
p34482
stp34483
a((dp34484
g2
(lp34485
VI don't know for sure if this is your problem, but there is a huge design flaw with your current code
p34486
aVYou are creating 1 thread per image
p34487
aVAssuming that you have hundreds or thousands of threads this design cannot scale
p34488
aVFor a start there is a significant overhead associated with creating, starting and terminating threads
p34489
aVYou don't want to pay that overhead time and time again
p34490
aVBut more problematic is the resource overhead for a thread
p34491
aVEach thread has its own private stack space
p34492
aVThe address space (1MB) for that stack is reserved (but not committed) when the thread is created
p34493
aVWith enough threads you will exhaust your address space, even though your actual memory commit level is still low
p34494
aVI strongly urge you to abandon that code and start again
p34495
aVYou should use one of the established threading libraries
p34496
aVThreading is hard to do well and you need a lot of knowledge and expertise to do it well
p34497
aVUse either OmniThreadLibrary or AsyncCall
p34498
aVWhat you are looking for is a simple thread pool with a small number of threads
p34499
aVYou should then simply feed tasks (i
p34500
ag192
aVimage file names) to the thread pool and let it manage the processing of those tasks
p34501
as(dp34502
g7
V505088
p34503
stp34504
a((dp34505
g2
(lp34506
VYou could certainly do this and there won't be any performance implication for a single pointer
p34507
aVRather than use , a legacy API, you should opt for a different shared heap
p34508
aVFor example the simplest to use is the COM allocator,
p34509
aVOr you can use  passing the process heap obtained by
p34510
aVFor example, and neglecting to show error checking:
p34511
aVNote that you only need to worry about heap sharing if you expect the memory to be deallocated in a different module from where it was created
p34512
aVIf your DLL both creates and destroys the memory then you can use plain old
p34513
aVBecause all modules live in the same process address space, memory allocated by any module in that process, can be used by any other module
p34514
aVUpdate
p34515
aVI failed on first reading of the question to pick up on the possibility that you may be wanting multiple process to have access to the same memory
p34516
aVIf that's what you need then it is only possible with memory mapped files, or perhaps with some form of IPC
p34517
as(dp34518
g7
V505088
p34519
stp34520
a((dp34521
g2
(lp34522
VI think you are looking for something like this:
p34523
aVwhich looks like this in the GUI test runner:
p34524
aVI'd be very interested to know if I have gone about this in a sub-optimal way
p34525
aVDUnit is so incredibly general and flexible that whenever I use it I always end up feeling that I've missed a better, simpler way to solve the problem
p34526
as(dp34527
g7
V505088
p34528
stp34529
a((dp34530
g2
(lp34531
VSince your array has static storage duration it has an implicit initializer
p34532
aVYour code is equivalent to
p34533
aVSo you are safe to pass these pointers to  no matter what happened when you allocated them
p34534
aVHaving said all that, if a call to  failed don't be surprised if subsequent calls to  also fail
p34535
aVOnce you have had a heap allocation failure it is often quite reasonable to abort the process
p34536
as(dp34537
g7
V505088
p34538
stp34539
a((dp34540
g2
(lp34541
VThe  event certainly will fire if the form is destroyed
p34542
aVIt's invoked from the form's destruction code
p34543
aVSo the only conclusion is that your form is not being destroyed and so is leaked
p34544
aVThere are a couple of obvious ways to make sure that your independent forms are not leaked:
p34545
aVWhen you create then, pass either  or  as the owner parameter of the form
p34546
aVWhen the owner is destroyed, it will also destroy everything it owns, including your forms
p34547
aVExplicitly destroy these forms from, for example, the main form destructor or the
p34548
aVdpr file after the call to  returns
p34549
aVOption 1 is the most commonly used approach
p34550
as(dp34551
g7
V505088
p34552
stp34553
a((dp34554
g2
(lp34555
VA group of check boxes are typically used when the options are independent of each other
p34556
aVThat means your logic is generally not nested
p34557
aVIt would look something like this:
p34558
aVand so on
p34559
aVIf there are strong interactions between the meaning of your check boxes then that would complicate matters
p34560
aVIt's rather hard to advise you without known more details of your specific problem
p34561
aVHowever, good solutions to problems like this typically involve finding ways to remove the inter-dependencies in the code and making it possible to use independent logic as above
p34562
aVYour updated question gives more information
p34563
aVYou say:
p34564
aVthe user can choose to renew employee\u2019s contract only, or to renew it and give annual bonus, or to change the job-title with renewal, or give extra bonus with the annual raise
p34565
aVThis sounds like a mutually exclusive list of options
p34566
aVIn which case a group of check boxes is the wrong UI element
p34567
aVYou should use a radio group,
p34568
aVThis is a group of radio buttons of which only one can be selected
p34569
aVThis can then be mapped onto, say, an enumerated type and your logic can become a simple case statement
p34570
aVIf you implement this UI using check boxes then it will be possible for the user to select a combination of options that is not possible
p34571
aVFor example they may select the option to give the employee a raise but not check the option to renew the contract
p34572
aVOf course some of your options may be mutually exclusive and some may be independent of each other
p34573
aVIn that case you would need to use a combination of a radio group and some check boxes
p34574
as(dp34575
g7
V505088
p34576
stp34577
a((dp34578
g2
(lp34579
Vis equivalent to
p34580
as(dp34581
g7
V505088
p34582
stp34583
a((dp34584
g2
(lp34585
VPresumably this is an issue of relative paths
p34586
aVMy guess is that you refer to the
p34587
aVwav file using a relative path and just name it
p34588
aVThis is relative to the current directory
p34589
aVWhen you double click the
p34590
aVexe the current directory is the exe directory and the
p34591
aVwav is not found
p34592
aVWhen you press Ctrl+F5 from the IDE, the IDE sets the current directory to be the project directory and thus the file is found
p34593
as(dp34594
g7
V505088
p34595
stp34596
a((dp34597
g2
(lp34598
VThe DLL export process is subject to name mangling and decoration
p34599
aVThe long obsolete 16 bit  calling convention is equivalent to  on 32 bit platforms
p34600
aVFirst of all you should use  to specify C linkage and disable name mangling
p34601
aVHowever, your function will still be subject to name decoration
p34602
aVIf you export it with  then it will in fact be exported with the name
p34603
aVIf you wish to export it by its true name then you need to use a
p34604
aVdef file
p34605
aVHowever, the possibility still remains that you did not export the function from the DLL at all
p34606
aVUse Dependency Walker to check whether it was exported, and if so by what name
p34607
as(dp34608
g7
V505088
p34609
stp34610
a((dp34611
g2
(lp34612
VQuestion 1
p34613
aVThe following code does what you ask, relying on the new RTTI introduced in Delphi 2010:
p34614
aVQuestion 2
p34615
aVThere is no global registry of object instances
p34616
as(dp34617
g7
V505088
p34618
stp34619
a((dp34620
g2
(lp34621
VThe C++ language designers followed the lead of C and so the main function is a plain function
p34622
aVThe C# language designers made the choice, when designing the language, that all methods must be part of classes
p34623
as(dp34624
g7
V505088
p34625
stp34626
a((dp34627
g2
(lp34628
VThe best solution is to enumerate the sub keys
p34629
aVUsing  you just do that in a simple loop until there are no more keys left to enumerate
p34630
aVHowever, enumerating sub keys in Delphi using  is even easier still:
p34631
aVOne thing that you should watch out for is having to search in the 64 bit view of the registry
p34632
aVIf you have the 64 bit version of MySQL installed then I expect it to use the 64 bit view of the registry
p34633
aVIn a 32 bit Delphi process on a 64 bit OS you will need to side step registry redirection
p34634
aVDo that by passing  to the  constructor
p34635
aVThe alternative that you propose is to hard code all the possible values of version string into your application
p34636
aVThat sounds like a failure waiting to happen as soon as a version is released which isn't in your hard coded list
p34637
as(dp34638
g7
V505088
p34639
stp34640
a((dp34641
g2
(lp34642
VYour first port of call to learn about registry programming is the MSDN section on the Registry
p34643
aVStart with the About the Registry section to gain an overview
p34644
aVThere are a small number of examples in the Using the Registry section
p34645
aVBeyond that the reference section of the documentation contains blow by blow details of all API functions relating to the registry
p34646
as(dp34647
g7
V505088
p34648
stp34649
a((dp34650
g2
(lp34651
VThe  object will supply you with a  representation via the  method:
p34652
as(dp34653
g7
V505088
p34654
stp34655
a((dp34656
g2
(lp34657
VThe approach I present here feels hacky but I can't find a better way to detect whether or not the standard output has been redirected away from a screen console
p34658
aVThe approach using  cannot detect all forms of redirection since some redirections are to devices of type
p34659
aVCall  passing the standard output handle
p34660
aVIf  fails then your console has been redirected
p34661
as(dp34662
g7
V505088
p34663
stp34664
a((dp34665
g2
(lp34666
VSince you are passing an array you should declare the  to be an array:
p34667
aVThe [out] attribute instructs the p/invoke marshaller to marshal the native memory back to your managed array of structs
p34668
aVThe marshaller will marshal elements according to the length of the managed array
p34669
aVSo you need to allocate this array before you call the function
p34670
aVThe API you are calling requires that you provide an array of at least 20,000 elements
p34671
as(dp34672
g7
V505088
p34673
stp34674
a((dp34675
g2
(lp34676
VThis is just a fact of life with Windows GUI apps
p34677
aVYou can see the same effect in a WinForms app and indeed even in mainstream Windows apps
p34678
aVFor example, open an Explorer window and do exactly the same operation, resize by grabbing the left hand edge of the window
p34679
aVYou will see exactly the same effect
p34680
aVYou can see the same effect by resizing from any edge
p34681
aVWord and Excel behave in the same way
p34682
aVMy guess is that Windows repaints in the sizing loop before it sends the resizing message that allows the app to realign its controls
p34683
as(dp34684
g7
V505088
p34685
stp34686
a((dp34687
g2
(lp34688
VThe second parameter to  is an exclusive upper bound
p34689
aVParameters
p34690
aVminValue: The inclusive lower bound of the random number returned
p34691
aVmaxValue: The exclusive upper bound of the random number returned
p34692
aVmaxValue must
p34693
aVbe greater than or equal to minValue
p34694
aVReturn value
p34695
aVA 32-bit signed integer greater than or equal to minValue and less than maxValue; that is, the range of return values includes minValue but not maxValue
p34696
aVIf minValue equals maxValue, minValue is returned
p34697
aVThis means that  will only return values  in the range
p34698
aVSo for your die rolling simulation you will need to use
p34699
aVNote: The design of this API is odd
p34700
aVIt has special case handling for  which seems to needlessly complicate the API
p34701
aVIf I had designed this API I would have made both parameters be inclusive limits
p34702
aVThis would have resulted in a pleasing symmetry and would have allowed random numbers that cover the full range of
p34703
as(dp34704
g7
V505088
p34705
stp34706
a((dp34707
g2
(lp34708
VThe golden rule is that you must deallocate from the same heap that was used to allocate the memory
p34709
aVIf you allocate it with , you must deallocate it with the  from the same C RTL
p34710
aVAnd likewise on the managed side,  should be balanced by
p34711
aVNow,  is implemented by calling the Win32 function
p34712
aVSo you could free such memory with a call to  on the native side
p34713
aVAnd vice versa
p34714
aVIf you want to use a heap that is shared between native and managed, it is more common to use the COM heap
p34715
aVOn the native side use  and
p34716
aVOn the managed side use  and
p34717
aVHowever, you should avoid designing the system like this
p34718
aVIt is much simpler to stick to a rule that all memory allocated in the managed side is deallocated there, and likewise for the native side
p34719
aVIf you don't follow that rule you will likely soon lose track of who is responsible for what
p34720
as(dp34721
g7
V505088
p34722
stp34723
a((dp34724
g2
(lp34725
VWindows uses CR+LF pairs to indicate a new line
p34726
aVThis equates to  in C#
p34727
aVHowever, you are just sending , i
p34728
ag192
aVa single LF rather than a CR+LF pair
p34729
aVUse  rather than of
p34730
aVThis is the  idomatic way to spell  in C#
p34731
aVAs a bonus, if you ever ran your code on a *nix platform,  would evaluate to "\u005cn" which is the *nix new line indicator
p34732
aVFinally, in my view  is preferable from a readability perspective
p34733
aVIt documents what this thing is logically rather than relying on you knowing the magic constants
p34734
as(dp34735
g7
V505088
p34736
stp34737
a((dp34738
g2
(lp34739
VBy far the best way to tackle this is to stop the GUI message queue interfering with your MIDI player
p34740
aVPut the MIDI player on a background thread so that it can do its work without interruption from the main thread
p34741
aVNaturally this relies on you running on a machine with more than a single processor but it's not unreasonable to take that for granted nowadays
p34742
aVJudging from your comments it looks like your audio processing is being blocked by the UI thread
p34743
aVDon't let that happen and your audio problems will disappear
p34744
aVIf you are using something like  to fire VCL events from the audio thread then that will block on the UI thread
p34745
aVUse an asynchronous communication method instead
p34746
aVYour proposed alternative of speeding up the VCL is not really viable
p34747
aVYou can't modify the VCL and even if you could, the bottleneck could easily be the underlying Windows code
p34748
as(dp34749
g7
V505088
p34750
stp34751
a((dp34752
g2
(lp34753
VYou have forgotten to call the inherited
p34754
aVThat is what frees the system resources associated with the thread
p34755
as(dp34756
g7
V505088
p34757
stp34758
a((dp34759
g2
(lp34760
VUnder Vista and up, services run in an isolated session, session 0
p34761
aVThe keyboard is associated with the desktop of the interactive user which lives inside a different session
p34762
aVSo your service is simply isolated from the keyboard
p34763
aVYou will need your process to run in desktop of the interactive user
p34764
aVIf you are running on XP the "Allow service to interact with desktop" option may allow your hook to take effect in the context of the service
p34765
aVStill, that approach is not recommended
p34766
as(dp34767
g7
V505088
p34768
stp34769
a((dp34770
g2
(lp34771
VI believe the reason is explained in Raymond Chen's article, What are these strange values returned from GWLP_WNDPROC
p34772
aVIf the current window procedure is incompatible with the caller of GetWindowLongPtr, then the real function pointer cannot be returned since you can't call it
p34773
aVInstead, a "magic cookie" is returned
p34774
aVThe sole purpose of this cookie is to be recognized by CallWindowProc so it can translate the message parameters into the format that the window procedure expects
p34775
aVFor example, suppose that you are running Windows XP and the window is a UNICODE window, but a component compiled as ANSI calls GetWindowLong(hwnd, GWL_WNDPROC)
p34776
aVThe raw window procedure can't be returned, because the caller is using ANSI window messages, but the window procedure expects UNICODE window messages
p34777
aVSo instead, a magic cookie is returned
p34778
aVWhen you pass this magic cookie to CallWindowProc, it recognizes it as a "Oh, I need to convert the message from ANSI to UNICODE and then give the UNICODE message to that window procedure over there
p34779
as(dp34780
g7
V505088
p34781
stp34782
a((dp34783
g2
(lp34784
VI personally would simply call the real functions which can be imported from msvcrt
p34785
aVdll
p34786
aVThese are tried and tested robust implementations of the C standard library functions
p34787
as(dp34788
g7
V505088
p34789
stp34790
a((dp34791
g2
(lp34792
VThere's actually no recursion there
p34793
aVThe code just opens a key under HKLM, enumerates all sub-keys, and looks for a particular named value
p34794
aVIn outline, your C code would be made up from these Win32 API calls:
p34795
aVNow that you have opened the key you can enumerate sub keys:
p34796
aVNow that you have the name of each sub-key, you can read the values with :
p34797
aVis a convenience function added in Vista
p34798
aVIf you need your code to run on XP then you'll have to call  instead
p34799
aVThat involves opening the  subkey first
p34800
aVNote that I've omitted all error checking and also ignored the issue of Unicode and called the ANSI APIs
p34801
aVI'll leave all those details to you
p34802
aVRemember to call  when you have finished
p34803
aVRefer to the MSDN documentation for all the gory details of how to access the registry
p34804
as(dp34805
g7
V505088
p34806
stp34807
a((dp34808
g2
(lp34809
VYou are nearly there
p34810
aVYou still use  but instead you will need to pass  in the flags parameter
p34811
aVThen you need to specify the shell object of interest by passing a  rather than a path
p34812
aVObtain the  by calling
p34813
aVPass a  value to this routine, e
p34814
ag217
aV, ,  etc
p34815
as(dp34816
g7
V505088
p34817
stp34818
a((dp34819
g2
(lp34820
VIf you have a singleton then it boils down to a matter of personal preference
p34821
aVHere are some thoughts of mine:
p34822
aVIf the rest of your codebase uses OOP then use procedural could make this code look and feel odd
p34823
aVIf you use OOP you can use properties, default properties, array properties
p34824
aVThat could make your interface more useable
p34825
aVPutting your functionality into a class gives you an extra namespace level
p34826
aVYou may or may not appreciate that
p34827
aVIf you need to maintain a lot of state with global scope then you'll probably wrap it up into a record
p34828
aVAnd you will have functions that operate on this global record instance
p34829
aVAt which point the code would read better written with object syntax
p34830
aVBottom line is that it doesn't really matter and you have to pick what fits best in your project
p34831
as(dp34832
g7
V505088
p34833
stp34834
a((dp34835
g2
(lp34836
VThis code is incorrect in a number of ways
p34837
aVYou must check the return value of
p34838
aVIf the call to  succeeds then you already have the first file in
p34839
aVAs your code stands, you throw away the first file
p34840
aVSo you need to re-jig your loop logic to account for that
p34841
aVNaturally, if  returns  then that means the search has exhausted all files
p34842
aVSo, what is probably happening is you ask for the first file matching the search string
p34843
aVThis is returned in  after the call to
p34844
aVYou then ignore that information and ask for the next match
p34845
aVBut there is no subsequent match since there is only one object matching  since you included no wildcards in your search pattern
p34846
aVThis code will behave exactly the same on XP as it does on Windows 7 and I suspect that you are not running the same code on both systems
p34847
aVIf you want to enumerate the contents of the folder then you need to search for
p34848
aVSomething like this:
p34849
as(dp34850
g7
V505088
p34851
stp34852
a((dp34853
g2
(lp34854
VIf you were going to do this then you would need to provide a property editor
p34855
aVThe IDE does not come with property editors for class type properties
p34856
aVYou would also need to handle
p34857
aVdfm persistence
p34858
aVYou would write the class type out to the
p34859
aVdfm file as a string and when the
p34860
aVdfm file is read, you would need to fixup the reference
p34861
aVNew style RTTI could do that
p34862
aVHowever, I don't think any of this is actually viable for the following reason
p34863
aVYour design time code runs in a package inside the IDE and does not have access to the class types in the active project in the IDE
p34864
aVThose class types only exist when that project runs
p34865
aVSo the  property in the code in your question cannot be assigned to anything meaningful in the design time package
p34866
aVWell, you could use it for classes defined in the VCL and any other packages installed in your IDE but I rather imagine you'd want to use it on classes defined in the active project
p34867
aVI think all this means that you should instead use a simple string property and fixup the class type references only at runtime
p34868
as(dp34869
g7
V505088
p34870
stp34871
a((dp34872
g2
(lp34873
VPython 2
p34874
aV5 links against msvcr71 just like 2
p34875
aV4
p34876
aVVersions 2
p34877
aV6 and 2
p34878
aV7 link against msvcr90 which is the VS2008 runtime
p34879
aVIn fact versions 3
p34880
aV0, 3
p34881
aV1 and 3
p34882
aV2 also link against msvcr90
p34883
aVThe msvcr90 redistributable is here: http://www
p34884
aVmicrosoft
p34885
aVcom/download/en/details
p34886
aVaspx
p34887
aVdisplaylang=en&id;=29
p34888
as(dp34889
g7
V505088
p34890
stp34891
a((dp34892
g2
(lp34893
VYou can always download the very latest platform SDK and have all you need
p34894
aVUse the header and lib files from the SDK
p34895
aVHaving said that, it may be that all you need to do is to define  and/or  to  or higher to gain access to more recent APIs
p34896
aVOff the top of my head, I'm not sure what Windows header file mingw ships with
p34897
as(dp34898
g7
V505088
p34899
stp34900
a((dp34901
g2
(lp34902
VCreate a hidden top-level window and listen for  messages
p34903
aVThe value of  will tell you whether the entire system is going down, or whether the user is logging off
p34904
aVIf your app is a console app then use  to register to receive shutdown notifications
p34905
as(dp34906
g7
V505088
p34907
stp34908
a((dp34909
g2
(lp34910
VThis code does not leak
p34911
aVEither your leak detection is faulty, or the code you are actually running is more complex than this and the leak is in the code that you have not shown
p34912
aVThe only memory allocated by the Delphi RTL, in the code in the question, is for the dynamic strings
p34913
aVDelphi dynamic string handling does not leak
p34914
aVThe calls to WinSock,  and  allocate memory internal to WinSock
p34915
aVIn the case of :
p34916
aVThe memory for the hostent structure returned by the gethostbyname function is allocated internally by the Winsock DLL from thread local storage
p34917
aVOnly a single hostent structure is allocated and used, no matter how many times the gethostbyaddr or gethostbyname functions are called on the thread
p34918
aVThe returned hostent structure must be copied to an application buffer if additional calls are to be made to the gethostbyname or gethostbyaddr functions on the same thread
p34919
aVOtherwise, the return value will be overwritten by subsequent gethostbyname or gethostbyaddr calls on the same thread
p34920
aVThe internal memory allocated for the returned hostent structure is released by the Winsock DLL when the thread exits
p34921
aVAnd likewise for :
p34922
aVThe string returned by inet_ntoa resides in memory that is allocated by Windows Sockets
p34923
aVThe application should not make any assumptions about the way in which the memory is allocated
p34924
aVThe string returned is guaranteed to be valid only until the next Windows Sockets function call is made within the same thread
p34925
aVWhilst it is true that the code in the question does not call  that's fine since it is rather pointless to reclaim resources at process termination time
p34926
as(dp34927
g7
V505088
p34928
stp34929
a((dp34930
g2
(lp34931
VI don't believe what you are hoping to do is viable
p34932
aVThe modern RTTI in Delphi is supported by the compiler
p34933
aVAs I understand it the compiler writes a lot of extra information into the executable that the RTTI unit relies upon
p34934
aVOlder compilers don't do that
p34935
as(dp34936
g7
V505088
p34937
stp34938
a((dp34939
g2
(lp34940
VIf you are looking for hardware supported help, that's not how it works
p34941
aVThis needs to be done in software
p34942
aVYour code needs a table of opcodes and instructions and just has to perform a lookup
p34943
aVWhat you describe is known as disassembly
p34944
aVThere are many open source disassemblers and if you could use one of those it would make your task very simple
p34945
aVLook here: http://en
p34946
aVwikibooks
p34947
aVorg/wiki/X86_Disassembly/Disassemblers_and_Decompilers
p34948
as(dp34949
g7
V505088
p34950
stp34951
a((dp34952
g2
(lp34953
VIt is most definitely good practice
p34954
aVIt makes the code far more readable and removes the need for logical operators, parentheses and so on
p34955
aVI would always use  for such a test
p34956
aVThe only drawback is Delphi's very limited support for sets (base ordinal type can have no more than 256 values)
p34957
aVBut where you are not bound by those limitations then you should have no hesitation in using
p34958
as(dp34959
g7
V505088
p34960
stp34961
a((dp34962
g2
(lp34963
VAuto-size columns for virtual list view controls is performed using all the items that are visible at the time the auto-size operation is actioned
p34964
aVThat is the behaviour of the Delphi  control
p34965
aVTry performing the same operation in explorer and you can readily see that this is the operating system standard
p34966
aVWhen you operate a list view in non-virtual mode, the contents of all rows are accounted for when performing auto-size
p34967
aVI'm not sure why you observe the auto-size only accounting for the first row of data
p34968
aVIf that is really what is happening for you then I think there must be something wrong in your code that we would need to see
p34969
aVYour problem appears to be a Windows XP bug
p34970
aVVirtual list views do not perform auto-resize correctly on XP so far as I can see
p34971
aVI think that explorer switched from non-virtual to virtual between XP and Vista and I wouldn't mind betting that the explorer team had enough internal leverage to get the problem fixed
p34972
aVSo far as I am aware you are not notified that an auto-size is taking place so I think it could be difficult for you to workaround the problem
p34973
aVIf you want to pursue this further then you could attempt to respond to the  notification for the header control and list for CTRL +
p34974
aVHowever, I'm not sure whether that approach would yield any joy
p34975
as(dp34976
g7
V505088
p34977
stp34978
a((dp34979
g2
(lp34980
VThe rule here is simple, but not what you want to hear
p34981
aVAll code in a single process has to have the same bit-ness
p34982
aVIf your hosting process is 64 bit then all code in that process must be 64 bit also
p34983
aVHence, if you need to run 32 bit code, you must put the 32 bit code in a separate process and use some form of IPC
p34984
as(dp34985
g7
V505088
p34986
stp34987
a((dp34988
g2
(lp34989
VMy reading of the RTTI
p34990
aVpas source leads me to conclude that Delphi RTTI cannot inspect the IDE's current project
p34991
aVAt design-time, RTTI is able to inspect types inside packages hosted by the IDE
p34992
aVIt cannot inspect any further than that
p34993
as(dp34994
g7
V505088
p34995
stp34996
a((dp34997
g2
(lp34998
VThe short answer is no
p34999
aVThat's why the feature was added in modern versions of Delphi
p35000
aVFor Delphi 7 you have to use panels, , custom alignment etc
p35001
as(dp35002
g7
V505088
p35003
stp35004
a((dp35005
g2
(lp35006
VYour  loop runs over every character in the array setting  each iteration
p35007
aVEach time  is set, the previous value is forgotten
p35008
aVThus your  loop is actually equivalent to writing
p35009
aVYou need to make two changes:
p35010
aVOnly iterate over the character array that the user entered
p35011
aVSo stop iterating when you encounter the null-terminating character
p35012
aVSet state to  only if all characters are digits
p35013
aVSince this looks like homework, I won't write the code out in full for you
p35014
as(dp35015
g7
V505088
p35016
stp35017
a((dp35018
g2
(lp35019
VSpin-locks perform better if there is little contention for the lock and/or it is never held for a long period of time
p35020
aVOtherwise you are better off with a lock that blocks rather than spins
p35021
aVThere are of course hybrid locks which will spin a few times, and if the lock cannot be acquired, then they will block
p35022
aVWhich is better for you depends on your application
p35023
aVOnly you can answer that question
p35024
as(dp35025
g7
V505088
p35026
stp35027
a((dp35028
g2
(lp35029
VThose two flags are not declared in the Windows
p35030
aVpas that ships with Delphi
p35031
aVYou will have to declare these values for yourself
p35032
aVThe values can be found in the MSDN documentation of  SetPriorityClass
p35033
aVAs an aside remember that  modifies its second parameter, , the parameter to which you pass
p35034
aVSo your code will fail if you call the function passing a string literal which lives in read-only memory
p35035
aVI would add the following line
p35036
aVimmediately before the call to CreateProcess
p35037
aVMore information can be found here: Access Violation in function CreateProcess in Delphi 2009
p35038
as(dp35039
g7
V505088
p35040
stp35041
a((dp35042
g2
(lp35043
VI recommend you get hold of GnuWin32, the GNU tools compiled for Windows, and then you can use the same commands as your guide
p35044
aVRunning Windows does not mean you cannot also use the command line like a *nix user
p35045
as(dp35046
g7
V505088
p35047
stp35048
a((dp35049
g2
(lp35050
VIf you want your code to handle arbitrarily long arguments then you will need to allocate the character buffer dynamically with
p35051
aVCreate a local variable to calculate the total length required and use repeated calls to  to calculate that length
p35052
aVCall  remembering to add one more character  for the null-terminator
p35053
aVUse  or  multiple times to build up the string
p35054
aVCall
p35055
aVCall  (or don't bother if your process is about to terminate)
p35056
as(dp35057
g7
V505088
p35058
stp35059
a((dp35060
g2
(lp35061
VI can make a "Windows Application" and just calling TaskDialog inside WinMain, is there any problem with this solution
p35062
aVThat is the way to implement such an app
p35063
aVThere is no problem with it all
p35064
aVOf course you don't create a window explicitly in your code and you don't run a message loop
p35065
aVJust call
p35066
aVThe main point is that you don't want a console app because, as you have discovered, a console window is shown by default
p35067
aVThere are two main subsystems, the console subsystem and the GUI subsystem
p35068
aVThe latter is somewhat confusingly named
p35069
aVYou are not compelled to show GUI in a GUI subsystem app
p35070
aVIt's up to you whether or not you choose to do so
p35071
aVReally the choice comes down to whether or not you want a console
p35072
aVSo the subsystems could be better named as console and non-console
p35073
as(dp35074
g7
V505088
p35075
stp35076
a((dp35077
g2
(lp35078
VThere's nothing to worry about this in principle
p35079
aVYou just have an array of pointers and each element of the array points to a distinct memory block
p35080
aVEach element of the array, each pointer, can be therefore be reallocated independent of the other elements
p35081
aVNow, I say in principle because your code does have an error
p35082
aVYou should pass  rather than  to the
p35083
as(dp35084
g7
V505088
p35085
stp35086
a((dp35087
g2
(lp35088
VIt's perfectly safe to use
p35089
aVIt is the way to reallocate memory in a C program
p35090
aVHowever you should always check the return value for an error condition
p35091
aVDon't fall into this common trap:
p35092
aVIf this fails,  returns  and you have lost access to
p35093
aVInstead do this:
p35094
as(dp35095
g7
V505088
p35096
stp35097
a((dp35098
g2
(lp35099
VYou are correct in your assumption that the reference count of the dynamic array is not incremented when you assign to
p35100
aVThis means that the local array goes out of scope when  returns
p35101
aVThus your code is broken
p35102
aVThe most simple solution would be to change the definition of  to use a dynamic array and then the reference mechanism would manage the lifetime for you
p35103
aVSince you do not wish to change your interface then you have (at least) the following options:
p35104
aVMake  a global variable
p35105
aVThat would only work if there is only one instance in your application
p35106
aVChange the type of  to  and use  to allocate this on the heap
p35107
aVYou would also need to add another procedure which would deallocate the array with a call to
p35108
aVVery similary to option 2, wrap the array in a class
p35109
aVClass instances can be safely stored in pointers
p35110
aVAgain you would need another function to dispose of the class instance by calling
p35111
as(dp35112
g7
V505088
p35113
stp35114
a((dp35115
g2
(lp35116
VClass constructors are called automatically by the initialization code that Delphi produces
p35117
aVClass constructors are called during the initialization section of the unit in which they are declared
p35118
aVThis is described in more detail in the documentation:
p35119
aVA class constructor is a special class method that is not accessible to developers
p35120
aVCalls to class constructors are inserted automatically by the compiler into the initialization section of the unit where the class is defined
p35121
aVNormally, class constructors are used to initialize the static fields of the class or to perform a type of initialization, which is required before the class or any class instance can function properly
p35122
aVEven though the same result can be obtained by placing class initialization code into the initialization section, class constructors have the benefit of helping the compiler decide which classes should be included into the final binary file and which should be removed from it
p35123
aVYou can see that this is so by enabling Debug DCUs and then setting a breakpoint on the code in the class constructor
p35124
as(dp35125
g7
V505088
p35126
stp35127
a((dp35128
g2
(lp35129
VIt is a bitmask as described in the documentation
p35130
aVA process affinity mask is a bit vector in which each bit represents a logical processor on which the threads of the process are allowed to run
p35131
aVProcessor 0 is $01
p35132
aVProcessor 1 is $02
p35133
aVProcessor 2 is $04
p35134
aVProcessor 3 is $08
p35135
aVProcessor 4 is $10
p35136
aVAnd so on
p35137
aVYou can use logical  to combine them
p35138
aVSo processors 0 and 1 would be  or  which equals
p35139
aVI would use the shift operator  to create values for specific processors
p35140
aVLike this:
p35141
aVYou can readily extend this to generate masks for lists of processors using logical  in a loop
p35142
aVYou can test for a processor being in a bit mask like this:
p35143
aVNote: I'm using  because for 64 bit targets the bitmask is 64 bits wide
p35144
aVThat nuance doesn't matter for you on XE but it's worth getting it right to make any future code porting easier
p35145
as(dp35146
g7
V505088
p35147
stp35148
a((dp35149
g2
(lp35150
VThis blog article, Visualizing wave interference using FireMonkey, published yesterday, may be of interest
p35151
aVA couple of screenshots:
p35152
as(dp35153
g7
V505088
p35154
stp35155
a((dp35156
g2
(lp35157
VThe documentation says this (emphasis mine):
p35158
aVOn the Win32 platform, interface references are typically managed through reference-counting, which depends on the _AddRef and _Release methods inherited from System/IInterface
p35159
aVUsing the default implementation of reference counting, when an object is referenced only through interfaces, there is no need to destroy it manually; the object is automatically destroyed when the last reference to it goes out of scope
p35160
aVThe scope of a local variable is the method and so the current specification is that  will not be called until the method is complete
p35161
aVThere's never a promise that specifications will not be changed in the future but I think the likelihood of a change being made to this part of the language is vanishingly small
p35162
as(dp35163
g7
V505088
p35164
stp35165
a((dp35166
g2
(lp35167
VYour program does not initialise  at all
p35168
aVThis can lead to buffer overrun and even if that does not happen, your program is likely to have incorrect results
p35169
aVThus your code invokes undefined behaviour
p35170
aVPresumably you actually want to initialize  to be an empty string
p35171
aVLike this:
p35172
aVOnce you have done this your calls to  will work
p35173
aVIf you don't want to initialise  then you can use  instead of the first :
p35174
aVIf ever you need to assign the empty string to  later in the code do it like this:
p35175
aVThe code you suggest,  is not valid
p35176
aVIt does not compile
p35177
as(dp35178
g7
V505088
p35179
stp35180
a((dp35181
g2
(lp35182
VYou need to cast one of the operands of the division to be a double value
p35183
aVLike this:
p35184
aVYour code performs integer division  and that results in
p35185
aVYou then multiply that by 60
p35186
aVStill
p35187
aVThen you convert to double and now it is
p35188
aVCasting one of the operands to  ensures that the division will be a floating point division rather than an integer division and will yield the result you expect
p35189
as(dp35190
g7
V505088
p35191
stp35192
a((dp35193
g2
(lp35194
VThere is no interface in the RTL/VCL that does what you want (expose the same interface as )
p35195
aVIf you wanted to use such a thing you would need to invent it yourself
p35196
aVYou would implement it with a wrapper like this:
p35197
aVNaturally you would wrap up the rest of the  interface in a real class
p35198
aVDo it with a wrapper class like this so that you can wrap any type of  just by having access to an instance of it
p35199
aVUse it like this:
p35200
aVYou may prefer to add a helper function to actually do the dirty work of calling
p35201
aVNote also that lifetime could be an issue
p35202
aVYou may want a variant of this wrapper that does not take over management of the lifetime of the underlying  instance
p35203
aVThat could be arranged with a  constructor parameter
p35204
aVMyself, I think this to be an interesting thought experiment but not really a sensible approach to take
p35205
aVThe  class is an abstract class which has pretty much all the benefits that interfaces offer
p35206
aVI see no real downsides to using it as is
p35207
as(dp35208
g7
V505088
p35209
stp35210
a((dp35211
g2
(lp35212
VYour problem is that  is not a windowed component
p35213
aVis a windows message and is delivered via a window procedure
p35214
aVHence you need a window handle
p35215
aVUse  to get hold of one of these
p35216
aVWhatever is sending the messages will need to find a way to get hold of the window handle
p35217
as(dp35218
g7
V505088
p35219
stp35220
a((dp35221
g2
(lp35222
VYou are making this task much more complicated than it needs to be
p35223
aVC++/CLI is great when you have an existing body of C or C++ code, or a native library with a very large interface
p35224
aVSo long as you only have a handful of functions, direct p/invoke to the native Delphi DLL is the way to go here
p35225
aVSerg has already pointed out the spurious extra level of indirection in your Delphi function
p35226
aVSo I would write the Delphi function as:
p35227
aVOn the C# side you can declare the function like this:
p35228
aVYou can call this function from your C# code like this:
p35229
aVAnd that's it
p35230
aVSince at the C# end you have a string variable you can rely on the p/invoke marshaller to provide a null-terminated string to the native code
p35231
aVHence there is no need to pass the length
p35232
aVThe default calling convention for p/invoke is  so prefer that in the Delphi code
p35233
as(dp35234
g7
V505088
p35235
stp35236
a((dp35237
g2
(lp35238
VYou are building targeting Unicode rather than ANSI
p35239
aVBut you are passing an ANSI buffer
p35240
aVYou can fix this by a number of means:
p35241
aVUsing a Unicode buffer:
p35242
aVSwitch to targeting ANSI in your project config
p35243
aVCall the ANSI function directly
p35244
aVIt's called
p35245
aVMy preference would be to use a Unicode buffer, option 1
p35246
as(dp35247
g7
V505088
p35248
stp35249
a((dp35250
g2
(lp35251
VIf your API is in a DLL and you wish to support clients that use a different compiler then you then you cannot use exceptions
p35252
aVThere is no binary interface standard for exceptions
p35253
aVSo you pretty much have to use error codes
p35254
aVBut don't model the system using  as your exemplar
p35255
aVIf you want a good example of how to return error codes look at COM
p35256
aVEvery function returns an
p35257
aVThis allows callers to write concise code that can convert COM error codes into native exceptions
p35258
aVLike this:
p35259
aVwhere  is a function, written by you, that receives an  as its single parameter and raises an exception if the  indicates failure
p35260
aVIt is the fact that the return value of the function indicates status that allows this more concise coding
p35261
aVImagine the alternative of returning the status via a parameter:
p35262
aVOr, even worse, the way it is done in Win32:
p35263
aVOn the other hand, if you are prepared to dictate that all clients use the same compiler as you, or you deliver the library as source, then use exceptions
p35264
as(dp35265
g7
V505088
p35266
stp35267
a((dp35268
g2
(lp35269
VRun the program in compatibility mode and select the option to disable desktop composition and/or visual themes
p35270
aVThere are a number of different options and you may need to do a bit of experimentation to find the most effective
p35271
as(dp35272
g7
V505088
p35273
stp35274
a((dp35275
g2
(lp35276
VFor a top-level window, i
p35277
ag192
aVnot a child window, the co-ordinates are indeed relative to the screen
p35278
aVYou will need to read the co-ordinates of the owning window, work out what offset you need, add on the offset and finally set the co-ordinates for your dialog, relative to the screen origin
p35279
aVOr you can call , passing , and get the system to do it for you
p35280
as(dp35281
g7
V505088
p35282
stp35283
a((dp35284
g2
(lp35285
VThe pertinent section of the C standard says this (emphasis mine):
p35286
aVWithin a structure object, the non-bit-field members and the units in which bit-fields
p35287
aVreside have addresses that increase in the order in which they are declared
p35288
aVA pointer to a
p35289
aVstructure object, suitably converted, points to its initial member (or if that member is a
p35290
aVbit-field, then to the unit in which it resides), and vice versa
p35291
aVThere may be unnamed
p35292
aVpadding within a structure object, but not at its beginning
p35293
aVThe C++ standard makes the same promise:
p35294
aVA pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
p35295
aVinitial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa
p35296
aV[ Note:
p35297
aVThere might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
p35298
aVas necessary to achieve appropriate alignment
p35299
aV\u2014end note ]
p35300
aVSo when you ask:
p35301
aVCan I be confident that
p35302
aVThe answer is yes
p35303
as(dp35304
g7
V505088
p35305
stp35306
a((dp35307
g2
(lp35308
VWhat happens is that you allocate an array of length
p35309
aVYou then double capacity on the line that reads
p35310
aVAnd then you write of the end of the array in the for loop because the array is only half as long as you think it is
p35311
aVThere are quite likely other errors in your code
p35312
aVI can't see how the  variable is handled
p35313
aVIs it a global
p35314
aVWhere is it initialised
p35315
aVAlso, the code you added in your edit is clearly wrong
p35316
aVHere you appear to set the initial capacity of the list to 1, but then assign 16 values
p35317
aVClearly the  should be passed  rather than
p35318
as(dp35319
g7
V505088
p35320
stp35321
a((dp35322
g2
(lp35323
VI would look for a BOM first and if one is not found call IsTextUnicode
p35324
aVBut beware that no method is foolproof
p35325
as(dp35326
g7
V505088
p35327
stp35328
a((dp35329
g2
(lp35330
VYou cannot send the messages related to painting the window
p35331
aVOnly the system can send them
p35332
aVIf you need to force a re-paint then you simply call InvalidateRect
p35333
aVTimer messages you could probably post successfully
p35334
aVThe WM_GETDLGCODE messages you probably don't need to send since they don't have side effects
p35335
as(dp35336
g7
V505088
p35337
stp35338
a((dp35339
g2
(lp35340
VIt's no problem to have multiple Pythons on your machine
p35341
aVI currently have 2
p35342
aV5, 2
p35343
aV6, 2
p35344
aV7, 3
p35345
aV0, 3
p35346
aV1 and 3
p35347
ag25125
aVWhere it can get a little more complicated is if you want to have multiple installations of the same version, i
p35348
ag192
aVtwo different distributions based on 2
p35349
aV7, say
p35350
aVBut that's not what you are doing here so you have nothing to fear
p35351
as(dp35352
g7
V505088
p35353
stp35354
a((dp35355
g2
(lp35356
VMy guess is that the code is indeed adding all the buttons but that they are all on top of each other
p35357
aVEach button will have a default value for  and  and those default values will be the same for each button
p35358
aVSince the buttons all have the same size, only the top button is visible
p35359
aVSolve the problem by setting the  and  properties for each button
p35360
aVObviously each different button needs to have a different value for  and
p35361
aVTo answer the question you ask in a comment, you could use code along these lines:
p35362
as(dp35363
g7
V505088
p35364
stp35365
a((dp35366
g2
(lp35367
VYour code sample is lacking some information since you do not say how  is defined
p35368
aVThis means that you cannot draw the conclusions that you attempt to draw
p35369
aVOf course, since  is a reserved word in Pascal, that code could never even compile
p35370
aVI will assume now that the variable is called
p35371
aVConsider the following definitions:
p35372
aVHere,  and  are types
p35373
aVis type describing an array of 80 integers
p35374
aVis a pointer to a
p35375
aVNext a variable named  is defined
p35376
aVIt is an array of 70 s
p35377
aVNow, before you can even consider what happens when you write , we need to assign some values to the elements of
p35378
aVSuppose we did it like this:
p35379
aVNow it would be true that  refers to the same integer as  for all valid  and
p35380
aVSo when you write  you are also assigning that value to ,  and so on
p35381
aVOn the other hand you could do it like this:
p35382
aVNow each  pointer points to a distinct array in memory
p35383
aVIn this case assigning  does not modify the value of  or any of the other values
p35384
as(dp35385
g7
V505088
p35386
stp35387
a((dp35388
g2
(lp35389
VYour code is needlessly complex, largely because you are not taking advantage of the built-in  class which shields you from all the complexities of the low-level registry API
p35390
aVFor example, consider the following code:
p35391
aVThe function  will return the string value named  from the key  relative to the root key
p35392
aVIf there is an error, for example if the key or name do not exists, or if the value is of the wrong type, then an exception will be raised
p35393
aVThe  parameter is an enumeration that makes it simple for you to access native, 32-bit or 64-bit views of the registry
p35394
aVNote that native means native to the process that is running
p35395
aVSo it will be the 32-bit view for a 32-bit process and the 64-bit view for a 64-bit process
p35396
aVThis enumeration mirrors the equivalent definition in
p35397
aVnet
p35398
as(dp35399
g7
V505088
p35400
stp35401
a((dp35402
g2
(lp35403
VRaymond explains why the messages don't get through
p35404
aVIn order to solve the problem, assuming you continue with the separate desktop, you will simply need to run the process that performs the DDE in the same desktop as the target app
p35405
aVIf you need to communicate between your process on the main desktop and the target process then you will need to use some other form of IPC
p35406
as(dp35407
g7
V505088
p35408
stp35409
a((dp35410
g2
(lp35411
VIt looks to me that your problem is simply that you are trying to call a function like this
p35412
aVand don't know how to get hold of the first command-line argument
p35413
aVDo it like this:
p35414
aVNote that  is an array containing  items where each item is of type
p35415
aVSo you simply want the item at index 1
p35416
aVThe item at index 0 is the process name
p35417
as(dp35418
g7
V505088
p35419
stp35420
a((dp35421
g2
(lp35422
VThe call to SetValue needs to read like this:
p35423
aVIn your code, the use of  is incorrect
p35424
aVThat is a function that returns a
p35425
aVBut  is described thus:
p35426
aVTRttiOrdinalType is the class used to describe all the Delphi ordinal value types, such as Integer, Byte, Word, and so on
p35427
aVBut you need to provide a  that represents a , which is what the code above achieves
p35428
aVAs an aside, I initially tried to use the generic  function like this:
p35429
aVBut that just resulted in the following internal compiler error:
p35430
aV[DCC Fatal Error] Unit58
p35431
aVpas(38): F2084 Internal Error: URW1147
p35432
aVQC#103129
p35433
aVEvery time I attempt to use generics I end up being defeated by these internal errors
p35434
aVThanks to Serg for pointing out the alternative form of calling the parameterised method using type inference does not fall foul of the internal error
p35435
as(dp35436
g7
V505088
p35437
stp35438
a((dp35439
g2
(lp35440
VYour code is incorrectly calling
p35441
aVYou should only call  if the immediately prior Win32 API call failed, and that API returns status information through
p35442
aVHere the API in question is
p35443
aVThe documentation says:
p35444
aVReturn value
p35445
aVIf the function succeeds, the return value is nonzero (TRUE)
p35446
aVIf the function fails, or is completing asynchronously, the return value is zero (FALSE)
p35447
aVTo get extended error information, call the GetLastError function
p35448
aVIn other words you must only call it if  returns
p35449
aVYour code should look something like this:
p35450
aVYour code is returning the error code for an earlier failure that is unrelated to the call to
p35451
as(dp35452
g7
V505088
p35453
stp35454
a((dp35455
g2
(lp35456
VThe first thing to try is Andreas Hausladen's DelphiSpeedUp
p35457
aVFrankly, if that doesn't do anything for you there's not much else left to try
p35458
aVOh, and for what it's worth, your Delphi IDE will only be able to see 2GB of address space since it is a 32 bit process which does not mark itself as
p35459
as(dp35460
g7
V505088
p35461
stp35462
a((dp35463
g2
(lp35464
VHere are the sources of conditional definitions that I can think of:
p35465
aVThe pre-defined conditionals
p35466
aVThe conditionals specified in the project options
p35467
aVThe conditionals specified at the command line
p35468
aVThe conditionals specified in the source code (often in
p35469
aVinc files)
p35470
aVNow, I think you are asking about item 1 on this list, the pre-defined conditionals
p35471
aVThe Delphi documentation has a comprehensive lists of these:
p35472
aVPredefined Conditionals
p35473
aVCompiler Versions
p35474
as(dp35475
g7
V505088
p35476
stp35477
a((dp35478
g2
(lp35479
VThe difference is down to the the unit scope names setting in the project options for your various projects
p35480
aVIf you have  included in that setting then you don't need to fully specify the unit scope
p35481
aVTypically, old projects that are upgraded from previous Delphi versions will have  included in the unit scope names setting
p35482
aVNew projects do not
p35483
aVThis is described in the documentation for Unit Scope Names
p35484
as(dp35485
g7
V505088
p35486
stp35487
a((dp35488
g2
(lp35489
VIn fact what determines the behaviour you describe is the window owner
p35490
aVNote that I am using the Windows terminology rather than the VCL terminology
p35491
aVIn Windows terms, the meaning of owner differs from the VCL meaning
p35492
aVMSDN has this to say about window ownership:
p35493
aVAn overlapped or pop-up window can be owned by another overlapped or pop-up window
p35494
aVBeing owned places several constraints on a window
p35495
aVAn owned window is always above its owner in the z-order
p35496
aVThe system automatically destroys an owned window when its owner is destroyed
p35497
aVAn owned window is hidden when its owner is minimized
p35498
aVSo what you want to be able to control is the forms owners rather than what is the main form
p35499
aVThe VCL does allow you to specify which form is the owner of any other form
p35500
aVIn order to control the owner of a VCL form you need to use the  and  properties
p35501
aVAt the moment, your code is probably using the default  of
p35502
aVIn this mode the active form is used as the form owner and that usually means that the main form is the ultimate owner of all secondary forms
p35503
as(dp35504
g7
V505088
p35505
stp35506
a((dp35507
g2
(lp35508
VYou don't need to implement this in C++ because the standard pattern of RAII already does what you need
p35509
aVWhen the block scope ends,  is destroyed which closes the file and frees any resources associated with the object
p35510
aVThe reason the  statement exists in C# is to provide some syntactic sugar around try/finally and
p35511
aVIt is simply not needed in C++ because the two languages differ and the problem is solved differently in each language
p35512
as(dp35513
g7
V505088
p35514
stp35515
a((dp35516
g2
(lp35517
VAs we worked out in the comments, the problem is that the file dialog is changing the working directory behind your back
p35518
aVYou can, and should, set the  option
p35519
aVHowever, I recommend that you do not rely on relative paths when starting processes
p35520
aVWhen starting processes you really ought to maintain tight control over the location of the process
p35521
aVI would do it like this:
p35522
as(dp35523
g7
V505088
p35524
stp35525
a((dp35526
g2
(lp35527
V1 and 2 are identical
p35528
aV3 and 4 are identical
p35529
aVAn object reference already is a pointer, hence the equivalence of 1 and 2
p35530
aVThe typecast in 2 is gratuitous
p35531
aVFor 3 and 4, @anything is a pointer and again, the typecast is gratuitous
p35532
aV1 and 2 save the object reference in the list
p35533
aV3 and 4 save a pointer to a variable holding the object reference
p35534
aVThe Names and Values properties are for working with items of the form 'name = value'
p35535
aVI don't think that is appropriate to the other part of your question
p35536
as(dp35537
g7
V505088
p35538
stp35539
a((dp35540
g2
(lp35541
VDelphi generics do not support covariance and contravariance so what you are attempting to do is not possible with the language's current syntax
p35542
aVI suggest you have a read of the following blog articles that cover the matter in more detail
p35543
aVCraig Stuntz: Comparing C#, C++, and Delphi (Win32) Generics
p35544
aVMason Wheeler: Generics and the Covariance Problem
p35545
aVFundamentally what you are attempting to do is this:
p35546
aVThe designers have not stopped you doing this out of spite
p35547
aVThere is a good reason
p35548
aVConsider the following standard example:
p35549
aVWhilst it is reasonable to add a  to a , the actual list that  refers to is a  and a penguin is not a cat
p35550
aVAnd, if you want to think of it in the context of your example hierarchy, here's an illustration of code that justifies the language design
p35551
as(dp35552
g7
V505088
p35553
stp35554
a((dp35555
g2
(lp35556
VThe most obvious thing that  declares a string of length equal to your machine's pointer size
p35557
aVYou need to use  instead
p35558
aVLikewise for
p35559
aVNote that the first parameter to  does not need to be writeable
p35560
aVJust pass the string literal directly to it
p35561
aVNo need for  variable
p35562
aVAs for  which does need to be writeable it's easiest to do it like this:
p35563
aVThat gives you a writeable buffer
p35564
aVNote that you do not need to repeat the executable file  name
p35565
aVAnother problem is  that you have not initialized all the parameters to
p35566
aVFor example the  struct has 19 fields and you initialize only 3
p35567
aVYou should initialize all your structs to 0 and then fill out any fields you need to be non-zero
p35568
aVLike this:
p35569
aVDo this for all the structs you pass
p35570
aVYou can, and should, pass  for the  and  parameters
p35571
as(dp35572
g7
V505088
p35573
stp35574
a((dp35575
g2
(lp35576
VA  that increases the size of the block will retain the contents of the original memory block
p35577
aVEven if the memory block cannot be resized in placed, then the old data will be copied to the new block
p35578
aVFor a  that reduces the size of the block, the old data will be truncated
p35579
aVNote that your call to  will mean you  lose your data if, for some reason the  fails
p35580
aVThis is because  fails by returning , but in that case the original block of memory is still valid but you can't access it any more since you have overwritten the pointer will the
p35581
aVThe standard pattern is:
p35582
aVNote also that the casting the return value from  is unnecessary in C and that  is, by definition, equal to
p35583
as(dp35584
g7
V505088
p35585
stp35586
a((dp35587
g2
(lp35588
VThis is what you need:
p35589
aVNaturally you would replace  with whatever it is you wish to do to the file
p35590
aVYou can use wildcards if you need to:
p35591
as(dp35592
g7
V505088
p35593
stp35594
a((dp35595
g2
(lp35596
VI think you mean  which is used to allocate memory on the stack
p35597
aVAnd yes, this is different from  and  which allocate on the heap
p35598
aVDon't attempt to free memory allocated with  because it is automatically freed when the function that calls  returns to its caller
p35599
aVUsing  and/or C99 variable length arrays can be a risky business because you can readily overflow the stack if you use these tools imprudently
p35600
as(dp35601
g7
V505088
p35602
stp35603
a((dp35604
g2
(lp35605
VAccording to MSDN:
p35606
aVIn Windows 7 or later, each user profile has an associated image
p35607
aVpresented as a user tile
p35608
aVThese tiles appear to users on the User
p35609
aVAccounts Control Panel item and its Manage Accounts subpage
p35610
aVThe
p35611
aVimage files for the default Guest and default User accounts also
p35612
aVappear here if you have Administrator access rights
p35613
aVThe user's tile image is stored as
p35614
aVC:\u005cUsers\u005c\u005cLocal\u005cTemp folder as
p35615
aVbmp
p35616
aVAny slash
p35617
aVcharacters () are converted to plus sign characters (+)
p35618
aVFor example,
p35619
aVDOMAIN\u005cuser is converted to DOMAIN+user
p35620
aVI could not find an API to obtain the image and since the official documentation is calling out this implementation detail I think that means that you are safe to rely on it
p35621
aVThat is I think this is a supported way to obtain the tile image
p35622
as(dp35623
g7
V505088
p35624
stp35625
a((dp35626
g2
(lp35627
VThe original answer below answers the question you asked
p35628
aVHowever, it transpires in the comments that you are not adding objects to your string list
p35629
aVYou are simply adding integers cast to
p35630
aVIn that case you must not call  on those integers and that would completely explain your error
p35631
aVSo the entire code in your question is gratuitous and you should simply call  on the list when you are done with it
p35632
aVWhen you cast an integer to a pointer and add it to the list, there is no memory allocated beyond that used to store the pointer
p35633
aVThat is because an integer is a value type
p35634
aVWhen you add a true pointer or an object then you are adding a  type and disposal of that object involves calling  for an object or  (or ) for a pointer
p35635
aVOriginal answer to the question as asked
p35636
aVYour original code is correct, albeit a little clunky
p35637
aVThe problem you have is in the code that populates
p35638
aVSince we cannot see that code we can't say what you have got wrong
p35639
aVNow, having said your code was clunky, here's how I would write it:
p35640
aVSome notes on the above:
p35641
aVYou do not need the  test before calling
p35642
aVI explain why not here: Why should I not use "if Assigned()" before using or freeing things
p35643
aVThere's little point in setting the items to  if you are about to call
p35644
aVYou should not call  in such a routine
p35645
aVYour list's life time should be managed separately from the code that clears the list
p35646
aVThe call to  should be made in the same scope as the call that constructs the list
p35647
aVOr, if this list is a field of a class, then the call to  should be made from the destructor of the owning class
p35648
aVNow, as I have already said in comments to this question and your previous question, all this lifetime management work with the  property of a  Delphi 7 string list is very unsatisfactory
p35649
aVIt's all too easy to leak objects
p35650
aVI would recommend the following alternatives:
p35651
aVSwitch to using  rather than
p35652
aVSet the  property to  when you create the list
p35653
aVThis will ensure that when an item is deleted from the list, it will be destroyed at the point of removal
p35654
aVYou simply hand to the list the responsibility for lifetime management of its items
p35655
aVNote that this will require you to move the  that you are storing in your current string list code to be a property of the object
p35656
aVBut that is invariably the correct approach anyway so I see that as an upside rather than a drawback
p35657
aVIf you do wish to keep using a string list, create your own derived class that handles ownership, probably by adding a property named
p35658
aVPush this problem onto the list and let your higher level code be free from that concern
p35659
aVDebug the code once in the context of the list class and then re-use it over and over again safe and secure in the knowledge that it works
p35660
as(dp35661
g7
V505088
p35662
stp35663
a((dp35664
g2
(lp35665
V and  are introduced in the abstract base class
p35666
aVSo  inherits this capability even though it's not particularly useful
p35667
aVHowever, it is of course useful for many other  descendants
p35668
aVRemember that many other  descendants have private implementation
p35669
aVFor example, the  object associated with a  is private to the implementation section of the  unit
p35670
aVThe  control exposes item list as  and so to make  and  available, they need to be declared in the abstract base class
p35671
aVIn my view you can safely ignore these methods when working with an object that you know to be
p35672
aVNow, regarding the code that populates the list view, I see no point whatsoever in using an intermediate
p35673
aVI would simply populate the list view directly and make use of / on the list view
p35674
aVIf you still have performance problems with your list view then the solution is a virtual list view
p35675
as(dp35676
g7
V505088
p35677
stp35678
a((dp35679
g2
(lp35680
VOn the 64 bit platform,  is 8 bytes wide,  is 4 bytes and so the typecast is invalid
p35681
aVYou can fix this problem by using  instead
p35682
aVThe  type is the same size as a pointer and so floats between 4 bytes and 8 bytes wide depending on the output target
p35683
aVHaving said that, I personally would typecast with  because that more correctly describes the operation you are performing
p35684
as(dp35685
g7
V505088
p35686
stp35687
a((dp35688
g2
(lp35689
VWhenever the list is sorted you need to loop through the items and update the caption
p35690
aVPersonally I would switch to using the list view in virtual mode which makes adding an index column trivial
p35691
aVAs you have it at present you need to work hard to keep the list's contents in sync with the underlying data
p35692
aVWith a virtual list view that problem dissolves
p35693
as(dp35694
g7
V505088
p35695
stp35696
a((dp35697
g2
(lp35698
VThere could very well be padding between the fields
p35699
aVOn any modern system there will be
p35700
aVTry passing  a longer string
p35701
aVis clearly a typo
p35702
aVIt should read
p35703
as(dp35704
g7
V505088
p35705
stp35706
a((dp35707
g2
(lp35708
VI personally would elect not to use Pascal IO here
p35709
aVIf you want your code to be able to read Unicode data then Pascal IO cannot help you
p35710
aVYou can do what you describe using a string list to load the file and then  from the  unit to parse the string
p35711
aVNote that  may not be precisely what you need
p35712
aVFor example it does not coalesce repeated delimiters into one
p35713
aVTo see what I mean consider the following input:
p35714
aVThere are 4 spaces between the two words and  would return the following array:
p35715
aVIf you wish to treat consecutive delimiters as being just one delimiter then you can use the  property of a string list:
p35716
as(dp35717
g7
V505088
p35718
stp35719
a((dp35720
g2
(lp35721
VConsider this line:
p35722
aVThis is in fact a compile error:
p35723
aV[DCC Error]: E2064 Left side cannot be assigned to
p35724
aVYour actual code is probably something like this:
p35725
aVWhat happens here is that you copy the value of the record type to the local variable
p35726
aVYou then modify a field of this local copy
p35727
aVThat does not modify the record held in MyObject
p35728
aVTo do that you need to invoke the property setter
p35729
aVOr switch to using a reference type, i
p35730
ag192
aVa class, rather than a record
p35731
aVTo summarise, the problem with your current code is that SetSomeRecord is not called and instead you are modifying a copy of the record
p35732
aVAnd this is because a record is a value type as opposed to being a reference type
p35733
as(dp35734
g7
V505088
p35735
stp35736
a((dp35737
g2
(lp35738
VIt is easiest to use  rather than  in my view
p35739
aVLike this:
p35740
aVBeware that when using raw disk access you have to read exactly multiples of sectors
p35741
aVThe sectors on the disk I tested with are 512 bytes in size
p35742
aVI expect that CD disk sectors could very well be a different size
p35743
as(dp35744
g7
V505088
p35745
stp35746
a((dp35747
g2
(lp35748
VThe two variants are equivalent and interchangeable
p35749
as(dp35750
g7
V505088
p35751
stp35752
a((dp35753
g2
(lp35754
VWell, you can do this by using  to obtain a handle to the window used for the list, and then move that window
p35755
aVLike this:
p35756
aVI have ignored the issue of error checking to keep the code simple
p35757
aVHowever, be warned that it looks pretty horrible because the dropdown animation is still shown
p35758
aVPerhaps you can find a way to disable that
p35759
aVHowever, you simply do not need to do anything like this because Windows already does it for you
p35760
aVDrag a form to the bottom of the screen and drop down your combo
p35761
aVThen you will see the list appear above the combo
p35762
aVLike this:
p35763
as(dp35764
g7
V505088
p35765
stp35766
a((dp35767
g2
(lp35768
VIn your code you have:
p35769
aVSince  is  this evaluates to
p35770
aVSince  is  this means
p35771
aVWhen you print  that is equivalent to printing  because  is an array
p35772
aVAnd an array decays to a pointer to its first element
p35773
aVBut you don't want to do it this way at all
p35774
aVYou should simply write  and let the compiler do the work
p35775
as(dp35776
g7
V505088
p35777
stp35778
a((dp35779
g2
(lp35780
VYou need to use  to achieve this
p35781
aVNote that this will return a function pointer that uses the  calling convention
p35782
aVYou can specify a different calling convention by using the  attribute on your delegate declaration
p35783
as(dp35784
g7
V505088
p35785
stp35786
a((dp35787
g2
(lp35788
V32 bit executables invariably have a base address of
p35789
aVThe address that cannot be written to, according to the exception is
p35790
aVWhich means that your code is almost certainly trying to write to a read-only part of the executable image
p35791
aVThat happens, for example, when you try to write to string literals
p35792
aVNow, the second parameter to  must be modifiable memory (it is declared as )
p35793
aVBut you are passing a string literal
p35794
aVPut  in a modifiable buffer to solve your problem
p35795
as(dp35796
g7
V505088
p35797
stp35798
a((dp35799
g2
(lp35800
VYou have two variables called  in your project
p35801
aVThe code in the
p35802
aVdpr file creates a  and saves the reference in one of the two  variables
p35803
aVYou then are referring to the other unassigned
p35804
aVThat explains why you are getting the access violation
p35805
aVHow to fix it
p35806
aVSimply remove the  variable from
p35807
aVUse the Find in Files feature to make sure that you have only one declaration of ,  etc
p35808
aVin your entire project
p35809
aVWhen you do that correctly you will have no trouble having each unit using the other, from the implementation section, with no circular reference problems
p35810
aVIn order to learn and understand this better I suggest you read the
p35811
aVdpr file to understand how the global variables are initialised
p35812
aVI also recommend that you read the Delphi language guide section on scope resolution to understand how the compiler resolves situations where two identical names are visible at the same location
p35813
as(dp35814
g7
V505088
p35815
stp35816
a((dp35817
g2
(lp35818
VThis is surprisingly tricky to do well (see my first revision of this answer for an example of how to get it wrong)
p35819
aVHere's a rather easy to understand approach that solves the problem by:
p35820
aVRemoving all selected items from the list and storing them in a temporary string list
p35821
aVRe-adds the items to the list starting at the target index
p35822
aVRe-selects each re-added item
p35823
ag32428
aVNow, it is possible to do this with a series of calls to  but it's hard to get it right
p35824
aVEach time you make a move all the indices of the selected items change
p35825
aVThe approach I give above is my preferred method for solving this problem
p35826
aVIncidentally I recently worked on exactly the same problem in the context of a tree view and it's quite tricky there too
p35827
as(dp35828
g7
V505088
p35829
stp35830
a((dp35831
g2
(lp35832
VI believe that the problem is that Delphi 7 can only use ANSI for source files
p35833
aVLater versions of Delphi will use UTF-8 for source files and in fact you can specify what encoding you wish to use for your source files
p35834
aVIf you interpret the UTF-8 encoded string as ANSI (for example using Notepad++) then you can embed a UTF-8 encoded literal in an ANSI source code file
p35835
aVFor example this code produces a message box with your text in using Delphi 6
p35836
aVTrying to treat your string literals like this is simply not practical
p35837
aVYou probably need to start putting them into resources
p35838
as(dp35839
g7
V505088
p35840
stp35841
a((dp35842
g2
(lp35843
VIt is called
p35844
as(dp35845
g7
V505088
p35846
stp35847
a((dp35848
g2
(lp35849
VC does not support optional parameters
p35850
aVNor does it support function overloading which can often be used to similar effect
p35851
as(dp35852
g7
V505088
p35853
stp35854
a((dp35855
g2
(lp35856
VMost likely you are running a 32 bit process on a 64 bit system and the registry redirector is taking you to the 32 bit view of the registry
p35857
aVWhere those keys do not exist
p35858
aVYour options include:
p35859
aVOpen a 64 bit view of the registry using the  enumeration
p35860
aVNote that this requires
p35861
aVnet 4
p35862
aVFor older versions of
p35863
aVnet you would need to use p/invoke to read the 64 bit view of the registry from a 32 bit process
p35864
aVSwitch to a 64 bit process
p35865
as(dp35866
g7
V505088
p35867
stp35868
a((dp35869
g2
(lp35870
VI think you need a tool button  handler that can be as simple as this:
p35871
aVWhat makes this work is the fact that the controls on a toolbar do not ever become the active control
p35872
as(dp35873
g7
V505088
p35874
stp35875
a((dp35876
g2
(lp35877
VIf you have a list box at hand, and the database hands you a string with line breaks embedded, then you can simply do this
p35878
aVWhen you assign to the  property of , the string will be parsed by splitting on line breaks
p35879
aVEach line is added to the list box as a separate item
p35880
aVIf your string is using a different delimiter, then you can use  and  instead
p35881
as(dp35882
g7
V505088
p35883
stp35884
a((dp35885
g2
(lp35886
VThe  method itself does not explicitly raise an exception, but it calls the virtual destructor  which certainly could raise an exception
p35887
aVSo if you want to be sure that all your objects are destroyed, even if one of the destructors raises an exception you end up with code like this:
p35888
aVHaving said that, it should be a design principle that you do not raise exceptions in a destructor
p35889
aVSo, in my view it's perfectly reasonable to take the viewpoint that if an exception is raised in destructor, then your program is pretty much hosed
p35890
aVLeaking objects at that point is not something to worry about
p35891
aVIf your destructor has raised an exception then you are probably already leaking because that destructor did not run to completion
p35892
aVSo in my view it can be perfectly reasonable to group together some calls to  and of course you avoid deeply nested / which is something worth striving for
p35893
aVIf you want just one / then remember to write the code like this:
p35894
aVIn my own code base I have some helper methods that make this cleaner
p35895
aVThen the code can look like this:
p35896
aVI have given my  the same name as the function in  which on first glance may seem odd, but it is safe and benign to do so
p35897
aVNaturally these helpers come into their own when you have even more than two objects
p35898
as(dp35899
g7
V505088
p35900
stp35901
a((dp35902
g2
(lp35903
VSomething like this should do what you want
p35904
aVI've assumed that you are using 32bpp bitmaps with, potentially, alpha blending
p35905
aVIf you want to use mask based transparency then you would need to re-work the code to create an appropriate mask bitmap
p35906
as(dp35907
g7
V505088
p35908
stp35909
a((dp35910
g2
(lp35911
VThe macro substitutions are expanded like this:
p35912
aVbecomes
p35913
aVand
p35914
aVbecomes
p35915
aVBecause  has a higher precedence that  the values for  are different
p35916
aVThis is an excellent example of why the discerning programmer only reaches for macros when no other solution is viable
p35917
aVAnd even then, those discerning programmers that feel compelled to use macros, will always use sufficient parenthesise as to make sure such pitfalls are avoided
p35918
as(dp35919
g7
V505088
p35920
stp35921
a((dp35922
g2
(lp35923
VThe  parameter receives the thread ID
p35924
aVIt is not the address of the thread function
p35925
aVIt appears to be an exceedingly badly named parameter
p35926
aVThe  parameter is the thread function pointer and you can pass your 64 bit function pointer in that parameter
p35927
aVYour update to the question suggests that you believe that the thread ID is a 64 bit value on 64 bit Windows
p35928
aVThat is a mis-think
p35929
aVThread IDs are 32 bit values on all flavours of Windows
p35930
as(dp35931
g7
V505088
p35932
stp35933
a((dp35934
g2
(lp35935
VYou handle the  event to detect when the key goes down, and then handle the  event to detect when it goes back up
p35936
as(dp35937
g7
V505088
p35938
stp35939
a((dp35940
g2
(lp35941
VNo they do not get deleted automatically
p35942
aVIn order to create a file that will be deleted automatically when it is closed, pass  to
p35943
aVThe file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles
p35944
aVIf there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE share mode
p35945
aVSubsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified
p35946
aVIn order to gain access to this Win32 functionality from
p35947
aVnet, use the  class
p35948
as(dp35949
g7
V505088
p35950
stp35951
a((dp35952
g2
(lp35953
V is certainly a viable approach
p35954
aVIt's crude yet effective
p35955
aVSomewhat less crude is to use a good logging framework to output diagnostics
p35956
aVWith a sufficiently capable logging framework this can be very effective
p35957
as(dp35958
g7
V505088
p35959
stp35960
a((dp35961
g2
(lp35962
VIt depends when you want the initialization to run and what instancing you want
p35963
aVIf you want a single instance of the attribute (i
p35964
ag192
aVa single value) shared between all instances of the class, use a class attribute
p35965
aVIf you want each instance of the class to have a distinct value of the attribute, use an instance attribute
p35966
aVAs an aside, your code samples contain attributes rather than properties
p35967
aVI can't understand your update to the question
p35968
aVYou probably need to step back and explain your underlying problem
p35969
as(dp35970
g7
V505088
p35971
stp35972
a((dp35973
g2
(lp35974
VThe 64 bit operating system implements an emulated environment known as WOW64 which emulates the 32 bit Windows environment
p35975
aVYou are building your program targeting x86, i
p35976
ag192
aV32 bit
p35977
aVThat means that your process runs under the emulator as a 32 bit process and of course pointers are 4 bytes wide
p35978
aVIf you change your options to target x64 or AnyCPU then the pointer size will be 8 bytes when your process runs on a 64 bit system
p35979
as(dp35980
g7
V505088
p35981
stp35982
a((dp35983
g2
(lp35984
VI'm not sure what's wrong with your current code, but I believe this code will do what you need, using standard Windows API calls
p35985
as(dp35986
g7
V505088
p35987
stp35988
a((dp35989
g2
(lp35990
VThe only explanation that I can see, given the information that you have provided, is that the help file is not in the current working directory
p35991
aVI would keep the working directory out of the equation and set  to be the fully-qualified path to the help file
p35992
as(dp35993
g7
V505088
p35994
stp35995
a((dp35996
g2
(lp35997
VSend a  message to the form passing  as
p35998
aVChanges the cursor to a question mark with a pointer
p35999
aVIf the user then clicks a control in the dialog box, the control receives a WM_HELP message
p36000
aVWrite something like this in your button  event handler:
p36001
as(dp36002
g7
V505088
p36003
stp36004
a((dp36005
g2
(lp36006
VYou can't
p36007
aVThe only way to draw to the screen in Windows is via the Win32 API
p36008
aVYou can write your own GUI framework on top of Win32, but ultimately you will have to get the native system to do the actual work
p36009
as(dp36010
g7
V505088
p36011
stp36012
a((dp36013
g2
(lp36014
VYou are trying to keep track of time to a reasonable degree of accuracy
p36015
aVHowever, the standard system timer cannot be used for that purpose
p36016
aVAll that the system timer guarantees is that it will fire no sooner than the interval which you specify
p36017
aVAnd you can get the message late if you are tardy in pumping your message queue
p36018
aVQuite simply, the system timer is  not designed to be used as a stopwatch and to attempt to do so is inappropriate
p36019
aVInstead you need to use the high resolution performance counter which you can get hold of by calling
p36020
aVIf you are using Delphi 2010 or later then you can use  which provides a very convenient wrapper to the high performance timer
p36021
aVYou can still use a system timer to give your app a regular tick or pulse, but make sure that you keep track of time with the high resolution timer
p36022
aVHaving said all of that, I'm not sure that you will ever be able to achieve what you are hoping to do
p36023
aVIf you want to keep reasonably accurate time then what I say above is true
p36024
aVTrying to maintain lock-step synchronisation with code running on another machine somewhere remote over the net sounds pretty much intractable to me
p36025
as(dp36026
g7
V505088
p36027
stp36028
a((dp36029
g2
(lp36030
VYou can use the  function to do this
p36031
aVConfines the cursor to a rectangular area on the screen
p36032
aVIf a subsequent cursor position (set by the SetCursorPos function or the mouse) lies outside the rectangle, the system automatically adjusts the position to keep the cursor inside the rectangular area
p36033
as(dp36034
g7
V505088
p36035
stp36036
a((dp36037
g2
(lp36038
VYou are returning a native string from your C++/CLI wrapper class
p36039
aVYou need to return a managed
p36040
aVnet string instead
p36041
aVThe wrapper class must translate parameters and return values of native classes to appropriate managed classes
p36042
as(dp36043
g7
V505088
p36044
stp36045
a((dp36046
g2
(lp36047
VI can't reproduce your problem
p36048
aVThe following  handler, combined with  gives the desired behaviour in an otherwise empty form
p36049
aVI guess there is something else in your form that is closing the dialog
p36050
as(dp36051
g7
V505088
p36052
stp36053
a((dp36054
g2
(lp36055
VWith your current approach you would need to convert each character  from a character code into the corresponding integer
p36056
aVUse
p36057
aVIn one of your attempts you used a  cast but all this does is to give a character with the character code
p36058
aVIt would be easier to write the test like this
p36059
aVHere I am using the syntax for a character literal,  as opposed to  which is a string literal
p36060
as(dp36061
g7
V505088
p36062
stp36063
a((dp36064
g2
(lp36065
VThe
p36066
aVnet documentation describes the IsBackground property like this:
p36067
aVA thread is either a background thread or a foreground thread
p36068
aVBackground threads are identical to foreground threads, except that background threads do not prevent a process from terminating
p36069
aVOnce all foreground threads belonging to a process have terminated, the common language runtime ends the process
p36070
aVAny remaining background threads are stopped and do not complete
p36071
aVA Delphi process terminates when the main function in the
p36072
aVdpr file completes
p36073
aVThis main function always runs in the context of the main process thread, that is the thread that is automatically created by the system when the process starts
p36074
aVSo, in Delphi there is no equivalent property
p36075
aVThere is a single foreground thread, the main thread, and all other threads are background thread, using the
p36076
aVnet terminology
p36077
aVA thread cannot, at runtime, change state from foreground to background, or vice versa
p36078
as(dp36079
g7
V505088
p36080
stp36081
a((dp36082
g2
(lp36083
VYou should use  to display the popup help
p36084
aVThis gives you more flexibility through the  structure that you pass
p36085
aVUse the  field to specify the position:
p36086
aVSpecifies (in pixels) where the top center of the pop-up window should be located
p36087
aVThe Helpware site gives some sample Delphi code:
p36088
aVIn fact I think you already found this page judging by your code, but just needed to read a bit further down the page
p36089
as(dp36090
g7
V505088
p36091
stp36092
a((dp36093
g2
(lp36094
VThe  is a bitfield
p36095
aVAs for , that is logical double negation and so returns  for false or  for true
p36096
aVAnd the  is a minus sign, i
p36097
ag192
aVarithmetic negation
p36098
aVIt's all just a trick to get the compiler to barf on invalid inputs
p36099
aVConsider
p36100
aVWhen  evaluates to a negative value, that produces a compile error
p36101
aVOtherwise  evaluates to 0,  and a 0 width bitfield has size of 0
p36102
aVAnd hence the macro evaluates to a  with value 0
p36103
aVThe name is weak in my view because the build in fact fails when the input is not zero
p36104
aVis very similar, but yields a pointer rather than an
p36105
as(dp36106
g7
V505088
p36107
stp36108
a((dp36109
g2
(lp36110
VYou are reading an uninitialized variable
p36111
aVThat is undefined behaviour
p36112
aVBasically, anything can happen
p36113
aVIf you turned on your compiler warnings, the compiler would have told you exactly that
p36114
aVI suspect you believe that your local variables will be initialized automatically
p36115
aVThat is not the case
p36116
aVYou must initialize them before reading them
p36117
as(dp36118
g7
V505088
p36119
stp36120
a((dp36121
g2
(lp36122
VHas this code undefined behavior
p36123
aVYes
p36124
aVThe order in which the operands are evaluated, with respect to the side effect, is undefined
p36125
aVSection 6
p36126
aV5(2) of the standard says:
p36127
aVIf a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar
p36128
aVobject, the behavior is undefined
p36129
aVIf there are multiple allowable orderings of the
p36130
aVsubexpressions of an expression, the behavior is undefined if such an unsequenced side
p36131
aVeffect occurs in any of the orderings
p36132
aVSince  is a scalar type, and since the side effect here is unsequenced, the behavior is undefined
p36133
aVYou should write your code like this:
p36134
as(dp36135
g7
V505088
p36136
stp36137
a((dp36138
g2
(lp36139
VIn Python 3 the print statement has become a function
p36140
aVThe new syntax looks like this:
p36141
aVThis breaking change in Python 3 means that it is not possible to use the same code in Python 2 and 3 when writing to a file using the  statement/function
p36142
aVOne possible option would be to use  instead of print
p36143
aVUpdate: J
p36144
aVF
p36145
aVSebastian correctly points out that you can use  in your Python 2 code to enable the Python 3 syntax
p36146
aVThat would be an excellent way to use the same code across different Python versions
p36147
as(dp36148
g7
V505088
p36149
stp36150
a((dp36151
g2
(lp36152
VIHTMLDocument is a non-visual component and so cannot do what you ask
p36153
aVIWebBrowser2 is the visual component that you need
p36154
as(dp36155
g7
V505088
p36156
stp36157
a((dp36158
g2
(lp36159
VFMX has no multi-monitor support yet
p36160
aVYou will have to write platform specific code and switch behaviour using the platform conditional defines
p36161
as(dp36162
g7
V505088
p36163
stp36164
a((dp36165
g2
(lp36166
V would be the wrong function to use here
p36167
aVThat would require you to decide which process to run
p36168
aVThe user may prefer to use a text editor other than Notepad, I know I do
p36169
aVThe right way to do this on Windows is to ask the shell to open the file with whatever program the user has associated with the file
p36170
aVThe  function does this
p36171
aVCall it like this:
p36172
aVYou will need to include the Shellapi
p36173
aVh header file and link to the Shell32
p36174
aVlib library
p36175
aVIf your compiler does not include these files, and I would be surprised if that was the case, then you can get them from the Platform SDK
p36176
aVThat said, if you are serious about programming on Windows you should get hold of a tool that gives you access to the Windows API
p36177
aVI do recommend that you use a fully qualified path for a task like this
p36178
aVSince your text file is located in the same directory as the executable you should simply join that directory to your text file's name
p36179
aVGet hold of the full path to the executable by calling  passing  for the  parameter
p36180
as(dp36181
g7
V505088
p36182
stp36183
a((dp36184
g2
(lp36185
VIn general the inverse of a sparse matrix is not sparse which is why you won't find sparse matrix inverters in linear algebra libraries
p36186
aVSince  is diagonal,  is trivial and the Laplacian matrix calculation is thus trivial to write down
p36187
aVhas the same sparsity pattern as  but each value A_{ij} is multiplied by (D_i*D_j)^{-1/2}
p36188
aVRegarding the issue of the inverse, the standard approach is always to avoid calculating the inverse itself
p36189
aVInstead of calculating L^-1, repeatedly solve Lx=b for the unknown x
p36190
aVAll good matrix solvers will allow you to decompose L which is expensive and then back-substitute (which is cheap) repeatedly for each value of b
p36191
as(dp36192
g7
V505088
p36193
stp36194
a((dp36195
g2
(lp36196
VYou just need to use a  loop:
p36197
as(dp36198
g7
V505088
p36199
stp36200
a((dp36201
g2
(lp36202
VNone of the editions of VS2010 come with
p36203
aVRemember that VS2010 pre-dated the C++11 standard
p36204
aVYou could try  as an alternative
p36205
aVThe design of  is an evolution from  and so it should not be too traumatic to switch to  when it becomes more widely implemented
p36206
as(dp36207
g7
V505088
p36208
stp36209
a((dp36210
g2
(lp36211
VThe third constructor is not necessary, as you say, but it is provided for convenience to any clients of this class
p36212
aVIt is more concise to write
p36213
aVthan to pass all the parameters individually
p36214
aVIt may also be that the required fields are private fields and so may be inaccessible to the code creating new  instances
p36215
aVYour class is a good example since it does not have public methods  and  to expose these properties publicly
p36216
aVFinally, passing another instance of the class makes it clear to the reader that we are making a new class, that is a duplicate or a copy of the original
p36217
aVBeing able to express that intent clearly makes maintenance easier
p36218
as(dp36219
g7
V505088
p36220
stp36221
a((dp36222
g2
(lp36223
Vreturns a tuple containing 3 items, named ,  and
p36224
aVSo the subscript  picks out
p36225
aVThe subscript  picks out  from a tuple of the form
p36226
aVNote that the  function is applied before the  subscript
p36227
aVIn this case  is operating on a iterable of tuple pairs and uses lexicographic ordering to compare items
p36228
aVcalls the method  on the object  passing   as the parameter
p36229
aVSince  is a list then this is simply finding the index of the first occurrence of the value  in that list
p36230
as(dp36231
g7
V505088
p36232
stp36233
a((dp36234
g2
(lp36235
VSimple question with a simple answer
p36236
aVYes you can do this
p36237
aVI do exactly this myself to share code between the various services that are implemented in my company's codebase
p36238
aVis the way to make your  property show up in the Object Inspector
p36239
aVHaving said that, I don't find the ability to set these service properties in the Object Inspector to be all that valuable
p36240
aVI would regard it perfectly acceptable to set them at runtime in code, but that decision is down to personal preference
p36241
aVEven if you use  to make your service class known to the IDE, the default new service application will not use your service class
p36242
aVYou can customise the default service application to your needs and then save it to the Object Repository
p36243
aVMy answer here shows how I implement an app that can be run as either a service or as a standard desktop process for debugging purposes
p36244
as(dp36245
g7
V505088
p36246
stp36247
a((dp36248
g2
(lp36249
Vindex() returns the index of the first occurrence of the item in the list
p36250
aVYour list has duplicates which is the cause of your confusion
p36251
aVSo index(1) will always return 0
p36252
aVYou can't expect it to know which of the many instances of 1 you are looking for
p36253
aVI would write it like this:
p36254
aVand avoid the intermediate list altogether
p36255
as(dp36256
g7
V505088
p36257
stp36258
a((dp36259
g2
(lp36260
VYou cannot modify the enumerator from inside the for loop
p36261
aVThe language does not permit this
p36262
aVYou need to use the continue statement in order to advance to the next iteration of a loop
p36263
aVHowever, I'm not convinced that your loop even needs a continue
p36264
aVRead on
p36265
aVIn the context of your code you would need to convert the while to an if in order to make the continue refer to the foreach block
p36266
aVBut written like this it is clear that the following equivalent variant is simpler still
p36267
aVThis is equivalent to your pseudo-code because the part marked code to execute after while condition is met is executed for each item for which condition is false
p36268
aVMy assumption in all of this is that condition is evaluated for each item in the list
p36269
as(dp36270
g7
V505088
p36271
stp36272
a((dp36273
g2
(lp36274
VIf you are really desperate to patch back to the previous behaviour you could use something like this:
p36275
aVThis will work for 32 bit code
p36276
aVIt will also work for 64 bit code provided that both the old and new functions reside in the same executable module
p36277
aVOtherwise the jump distance may exceed the range of a 32 bit integer
p36278
aVIt will also not work if your RTL resides in a runtime package
p36279
aVBoth of these limitations can be readily remedied
p36280
aVWhat this code does is re-route all calls to  to the version implemented in this unit
p36281
aVThe code in this unit is just the  version from the XE2 source
p36282
aVThe only other approach that meets the needs outlined in your comments is to modify and re-compile the SysUtils unit itself, but I personally avoid that sort of solution
p36283
as(dp36284
g7
V505088
p36285
stp36286
a((dp36287
g2
(lp36288
VAssuming that your uses names the Windows unit at all, it would appear to do so by naming the unit as Winapi
p36289
aVWindows
p36290
aVAnd so your code must also do so and be written as
p36291
aVWhen you use a unit by naming the fully scoped unit name, you must also use the fully scoped name in subsequent code in that unit
p36292
aVNow, if you want to use the name Windows then you must name the unit as Windows in the uses clause and let the unit alias setting do its job
p36293
aVIf you imported the unit by naming it Windows then your original code will work
p36294
aVTo be very clear:
p36295
aVis what you have now but you would need:
p36296
aVfor your code to compile
p36297
as(dp36298
g7
V505088
p36299
stp36300
a((dp36301
g2
(lp36302
V requires two null-terminated strings, but you are not adding a null-terminator to
p36303
aVThis is why case 1 returns  when in fact it should return
p36304
aVNote that your expected values are incorrect
p36305
aVIn case 1, once you have added in the null-terminator, the two strings should compare as equal
p36306
aVAnd so  will return  and your code should also return
p36307
aVFor case 2,  returns a negative value since  and so your code should return
p36308
aVFor case 3,  returns a positive value, and it just so happens that the positive value is  which you are mistakenly testing for by equality
p36309
aVIn all cases testing for a value of  is incorrect since  never promises to return
p36310
aVIt promises to return either:
p36311
aVa value of  to indicate that the two strings are equal, or,
p36312
aVa positive value to indicate that  compares greater than , or,
p36313
aVa negative value to indicate that  compares less than
p36314
aVThe only valid comparisons on the return value of  are therefore ,  or
p36315
aVYou need to revisit the documentation for  and correct your understanding of how to interpret the return value
p36316
as(dp36317
g7
V505088
p36318
stp36319
a((dp36320
g2
(lp36321
VThis is not possible in standard C
p36322
aVYou cannot extend  to add custom format strings
p36323
aVYour helper function approach is probably about as good as you will get within the constraints of C
p36324
as(dp36325
g7
V505088
p36326
stp36327
a((dp36328
g2
(lp36329
VYou have to pass a plain  to
p36330
aVYou can use variable capture to wrap up your parameters like this:
p36331
as(dp36332
g7
V505088
p36333
stp36334
a((dp36335
g2
(lp36336
VThis facility, known as delay loading, was added in Delphi 2010
p36337
aVUsing your code as an example you could write your import like this:
p36338
aVThe binding to this external function will be performed only when the function is first called
p36339
aVIf the binding fails then an exception is raised at runtime
p36340
aVYou can use  and  to customise the delay loading behaviour should you need even more fine-grained control
p36341
aVSome blog articles to supplement the product documentation:
p36342
aVAllen Bauer: Procrastinators Unite\u2026 Eventually
p36343
aVAllen Bauer: Exceptional Procrastination
p36344
aVDr
p36345
aVBob: Delphi 2010 Delayed Dynamic Link Libraries
p36346
aVOn older versions of Delphi you can use  and
p36347
aVOr, if you want something a little slicker I can heartily recommend Hallvard Vassbotn's delay load class which he describes in this blog article
p36348
aVThis code wraps up all the boiler plate of calling  and  and is only slightly more cumbersome to use than the new Delphi 2010 built-in feature
p36349
aVI successfully used Hallvard's library for many years
p36350
aVOne minor word of caution is that it is not threadsafe so if multiple threads attempt to bind to a function at the same time then the code can fail
p36351
aVThis is easy enough to fix by adding internal locks to Hallvard's code
p36352
as(dp36353
g7
V505088
p36354
stp36355
a((dp36356
g2
(lp36357
VThat error is emitted because  has not been declared at the point at which you call it
p36358
aVIt sounds like your header files aren't quite as you describe
p36359
aVPerhaps there is some conditional code
p36360
aVMaybe you have a header guard that is not working right
p36361
aVAnother possibility is that you have got a letter case error and declared the function  but called it with
p36362
aVVery hard to say without seeing the actual files but you need to look for a reason why  is not declared in the  translation unit
p36363
aVTo illustrate this a little more clearly, the following code:
p36364
aVresults in this warning:
p36365
aVwhich is exactly as you report
p36366
aVAccording to your description, your code includes a header file which declares
p36367
aVThe compiler begs to differ with you and it remains for you to work out why  is not declared
p36368
as(dp36369
g7
V505088
p36370
stp36371
a((dp36372
g2
(lp36373
VSo far as I can see, your code should be identical to the MSDN sample
p36374
aVHowever, as Code says, the MSDN sample does look a bit funky
p36375
aVIndeed, it seems to me that the MSDN sample is only working by chance
p36376
aVNote that comment in that code that states:
p36377
aVThen it allocates space in  to store a single pointer
p36378
aVHowever, the value contained in  actually matters
p36379
aVIt cannot be
p36380
aVIn your Delphi code you zeroise that memory twice in fact
p36381
aVOnce with  and once with
p36382
aVIf you just change your Delphi code to make the contents of  non-zero then the Delphi code will start working
p36383
aVHere is a very simple project that illustrates exactly what is going on:
p36384
aVSo I think that explains the problem, but I'd actually solve it more completely than that
p36385
aVI would move on to the next step of your work and declare  fully  using a real Delphi equivalent to the  struct
p36386
aVI'd probably write the code something like this:
p36387
aVRather than trying to be too cute in , I have passed a pointer to a real
p36388
as(dp36389
g7
V505088
p36390
stp36391
a((dp36392
g2
(lp36393
VHere is a C# version of your Delphi code:
p36394
aVI've used  throughout to reduce the amount of casting that needs to be done
p36395
aVAs for your Delphi code, I fell foul of the fact that your length parameter is a mere 16-bit integer
p36396
aVMy test file was >32kb in size and so that confused me for a while
p36397
aVI'd also comment that unsigned types are inappropriate for loop variables
p36398
aVYour variable  being typed as a  will result in AVs if ever you call the function with a length of 0
p36399
aVOf course, the accesses of  and  are also a problem when the length is too small
p36400
as(dp36401
g7
V505088
p36402
stp36403
a((dp36404
g2
(lp36405
VYou cannot import a reference to a native DLL
p36406
aVInstead you need to use p/invoke to import each function one by one
p36407
aVThis can be a rather laborious process if you have a lot of functions so sometimes a C++/CLI wrapper is more convenient
p36408
as(dp36409
g7
V505088
p36410
stp36411
a((dp36412
g2
(lp36413
VVirtual constructors allow for polymorphic instantiation of objects
p36414
aVThe classic example of this is Delphi's
p36415
aVdfm streaming mechanism
p36416
aVThe code that reads
p36417
aVdfm files and instantiates forms does not know at compile time which classes to use
p36418
aVThe decision is postponed until runtime when it can be made correctly, i
p36419
ag192
aVwhen the
p36420
aVdfm file is read
p36421
aVMoreover, you can get the
p36422
aVdfm file mechanism to create custom components that are not part of the VCL and so this
p36423
aVdfm mechanism must be capable of correctly instantiating classes that are not part of the VCL
p36424
aVThe constructor for  is declared like this:
p36425
aVFor a component to take part in this mechanism it must declare its constructor with the  directive
p36426
aVThe other key to the process is class references
p36427
aVFor example
p36428
aVThe code that creates components when reading
p36429
aVdfm files, roughly, looks like this:
p36430
aVNow, if the mechanism did not use virtual constructors then the constructor that would be called would be
p36431
aVAnd so your constructor,  would never be called
p36432
aVThis is why you must include the override directive on your constructors when deriving from
p36433
as(dp36434
g7
V505088
p36435
stp36436
a((dp36437
g2
(lp36438
VThat's a delimiter set for the tokenizer
p36439
aVIt is not a regular expression as you originally suspected
p36440
aVFrom the documentation of the  constructor:
p36441
aVThe characters in the delim argument are the delimiters for separating tokens
p36442
aVDelimiter characters themselves will not be treated as tokens
p36443
aVThe documentation for the constructor overload that does not have the  argument gives an idea of what type of string might be expected:
p36444
aVConstructs a string tokenizer for the specified string
p36445
aVThe tokenizer uses the default delimiter set, which is : the space character, the tab character, the newline character, the carriage-return character, and the form-feed character
p36446
aVDelimiter characters themselves will not be treated as tokens
p36447
aVThe code you have is specifying a different set of delimiters from the default
p36448
as(dp36449
g7
V505088
p36450
stp36451
a((dp36452
g2
(lp36453
VIt would seem that  is ever so slightly less than 15 and so  takes the value down to 14
p36454
aVThe root finding algorithm is numerical rather than symbolic and floating point arithmetic is not exact
p36455
as(dp36456
g7
V505088
p36457
stp36458
a((dp36459
g2
(lp36460
VC# is case-sensitive
p36461
aVIt should be  rather than
p36462
aVAnd you also mean to write  rather than  for the equality test
p36463
as(dp36464
g7
V505088
p36465
stp36466
a((dp36467
g2
(lp36468
VYou can nest your with blocks
p36469
aVLike this:
p36470
aVThis is better than your version because you guarantee that  will be closed even if your code encounters exceptions
p36471
aVObviously you could do that with try/finally, but  is the right way to do this
p36472
aVOr, as I have just learnt, you can have multiple context managers in a with statement as described by @steveha
p36473
aVThat seems to me to be a better option than nesting
p36474
aVAnd for your final minor question, the return serves no real purpose
p36475
aVI would remove it
p36476
as(dp36477
g7
V505088
p36478
stp36479
a((dp36480
g2
(lp36481
VYou cannot disable name mangling for C++ classes and you cannot export them without mangling
p36482
aVC++ classes support features that require mangling
p36483
aVFor example, function overloading
p36484
aVIt's also worth noting that mangling is compiler specific
p36485
aVSo if you want your class to be accessible for people using different compilers, or even different languages, then exporting C++ classes from DLLs is a bad design choice
p36486
as(dp36487
g7
V505088
p36488
stp36489
a((dp36490
g2
(lp36491
VYou are looking for the  method of
p36492
aVThe  method will return the value associated with , if such a value exists
p36493
aVIf the key is not present, then  will be returned
p36494
as(dp36495
g7
V505088
p36496
stp36497
a((dp36498
g2
(lp36499
VYou need to go down one further level in order to get to the root
p36500
aVYour executable is in  but I think you coded under the assumption that it is in
p36501
aVAssuming you are on Windows, the relative path will be relative to the current working directory rather than the directory where the executable resides
p36502
aVOften they are the same thing, but not necessarily
p36503
aVI would be inclined to use fully-qualified paths and pre-pend the directory where the executable lives
p36504
aVYou can obtain this by calling  passing  as the  argument
p36505
aVThis will return the full path to the executable so you will need to strip off the file name portion
p36506
aVYou will also need to think about deployment
p36507
aVThis structure looks like your development structure but you may want a different organisation when you deploy the program
p36508
aVFor example, I'd expect the executable to live in the  directory when deployed
p36509
aVOne final thought
p36510
aVAssuming the images that your program needs is known at compile time it would be much easier to link them into the executable as resources
p36511
aVThat way you simply don't have to worry about these issues at all and the executable can stand alone
p36512
as(dp36513
g7
V505088
p36514
stp36515
a((dp36516
g2
(lp36517
VYou can wait on the thread handle with  or one of the other wait functions
p36518
aVYou can use  to allow your wait to be interrupted by input messages, for example
p36519
aVThe thread handle becomes signaled when the thread's execution has completed
p36520
aVAs an alternative, you can check on a thread's status by calling
p36521
aVThis will return  if the thread is still busy, and  if it has completed
p36522
aVIf the thread has completed, then the exit code will also be returned
p36523
aVIf one thread needs to wait for another to be complete then you should use the wait functions rather than a busy polling loop calling
p36524
aVBusy loops and polling will just consume needless amounts of CPU (and power)
p36525
aVWait functions allow the waiting thread to become idle
p36526
as(dp36527
g7
V505088
p36528
stp36529
a((dp36530
g2
(lp36531
VThe DLL function should look like this:
p36532
aVAssuming you are calling it from another Delphi module the call could look like this:
p36533
aVIt is always preferable to define an interface which requires memory to be allocated and deallocated in the same module
p36534
aVThe above example allocates and deallocates in the caller's module
p36535
aVThis means that the  method would either have to process the  completely before returning, or take a copy of the contents of  before returning
p36536
aVNow, whilst it is possible to have the allocation and deallocation in the callee's module, this is less common
p36537
aVIt is less common because it is typically less convenient to do it this way
p36538
aVIt often entails more API functions, or perhaps more a complex interface
p36539
aVYou will be pushed into the route of callee allocation when the caller is not able to determine an appropriate size for the buffer
p36540
aVWhen data is being passed from caller to callee than caller allocate is invariably the best choice
p36541
aVWhen the data flows in the other direction it is more likely that callee allocates would be appropriate
p36542
as(dp36543
g7
V505088
p36544
stp36545
a((dp36546
g2
(lp36547
VMessage only windows do not receive broadcast messages
p36548
aVYou will have to use a hidden, normal window instead
p36549
aVFrom MSDN, emphasis mine:
p36550
aVMessage-Only Windows
p36551
aVA message-only window enables you to send and receive messages
p36552
aVIt is not visible, has no z-order, cannot be enumerated, and does not receive broadcast messages
p36553
aVThe window simply dispatches messages
p36554
as(dp36555
g7
V505088
p36556
stp36557
a((dp36558
g2
(lp36559
VIt's clearly a bug with the handling of large magnitude negative numbers
p36560
aVPositive numbers are handled fine
p36561
aVIf you can intercept the calls to  then you could make sure that you only ever call  passing positive numbers and then prefix the  yourself
p36562
aVI have submitted the bug to Quality Central: QC#103436
p36563
as(dp36564
g7
V505088
p36565
stp36566
a((dp36567
g2
(lp36568
VThe documentation explains this quite well:
p36569
aVThe expression  first evaluates ; if  is false, its value is returned; otherwise,  is evaluated and the resulting value is returned
p36570
aVAnd similarly for  which will probably be the next question on your lips
p36571
aVThe expression  first evaluates ; if  is true, its value is returned; otherwise,  is evaluated and the resulting value is returned
p36572
as(dp36573
g7
V505088
p36574
stp36575
a((dp36576
g2
(lp36577
VThe const here specifies that the function is not allowed to modify the pointee
p36578
aVIf you want to modify the pointee declare your function like this:
p36579
aVOf course, if you meant that you wanted  to point at a different object, then you can simply assign to  in the body of the function
p36580
aVBut that does not sound very likely to be what you want to do
p36581
as(dp36582
g7
V505088
p36583
stp36584
a((dp36585
g2
(lp36586
VYou need to write an  event handler for the date time picker
p36587
aVYou will also need to make sure that this event handler is run when the form first shows:
p36588
as(dp36589
g7
V505088
p36590
stp36591
a((dp36592
g2
(lp36593
VCheck the value of  again
p36594
aVIf your test fails then  is not the special  object
p36595
aVPresumably str is in fact the string
p36596
aVJudging from your comments,  is actually  which is a string of type
p36597
aVYou can test for that like this:
p36598
aVNow, whilst you could do that, I suspect that your problem lies elsewhere
p36599
aVThe calling code must be converting this object to a string, for example with
p36600
aVIt would most likely be better is the calling code only converted to string if the object is not
p36601
as(dp36602
g7
V505088
p36603
stp36604
a((dp36605
g2
(lp36606
VLet's focus on this code:
p36607
aVThe first thing to say is that the  check should be moved outside the character loop
p36608
aVThe next comment to make is that whilst you are detecting non-digits, you continue executing code as if nothing is wrong
p36609
aVYou presumably intend to set  to
p36610
aVNow, the main part of the problem
p36611
aVYou need to skip the conversion to  when invalid input is detected
p36612
aVIf you want to continue with such an approach your code would look like this:
p36613
aVHaving said all of that, I'd probably reorganise the code quite a bit to deal with the errors as soon as they are detected
p36614
aVCode is much easier to understand if you can organise your error handling that way
p36615
aVNow, that's a start in the right direction, but you can continue in this vein making the code better and better
p36616
aVSven's answer gives you an excellent illustration of where such a process would ultimately lead
p36617
as(dp36618
g7
V505088
p36619
stp36620
a((dp36621
g2
(lp36622
VRebuild your application using static linking rather than dynamic linking
p36623
aVThe problem you currently have is because your are linking to the runtime dynamically and it is not installed on the target machine
p36624
aVStatically linking the runtime sidesteps the issue
p36625
aVNote that dynamic linking is to be preferred for deployed software, but for the sake of your current predicament, static linking is the expedient solution
p36626
aVThe setting can be found under: Project | Properties | Configuration Properties | C/C++ | Code Generation | Runtime Library
p36627
aVChange this setting to Multi-threaded (/MT)
p36628
as(dp36629
g7
V505088
p36630
stp36631
a((dp36632
g2
(lp36633
VHere's what I believe to be the most likely explanation
p36634
aVThe  function has a return value that is a string
p36635
aVThe p/invoke marshaller has to marshal that from native to managed
p36636
aVIt does that by assuming that the native code returns a null-terminated character pointer that was allocated by the COM allocator
p36637
aVWhen it has finished transferring the content to a
p36638
aVnet string it calls  on the pointer
p36639
aVIf that memory was not allocated by the COM allocator then you may see failures at this point
p36640
aVTo get around the problem you have a few options
p36641
aVYou could change the p/invoke for  to return
p36642
aVCopy the contents to a
p36643
aVnet string with
p36644
aVThis then leaves you with the responsibility of disposing of the unmanaged memory
p36645
aVPresumably the unmanaged library offers you a mechanism to do that
p36646
aVIf you wrote the unmanaged library then you can use an alternative solution
p36647
aVLeave the p/invoke exactly as it currently is but change the unmanaged library to allocate the return value using
p36648
aVThat then will match with the p/invoke marshaller's assumptions
p36649
as(dp36650
g7
V505088
p36651
stp36652
a((dp36653
g2
(lp36654
VYour code in Update 2 is fine (assuming that  is actually meant to be )
p36655
aVThat code works
p36656
aVThe only possible causes for failure that I can see are:
p36657
aVis not the process that you are actually interested in
p36658
aVThat process really has no threads that are associated with windows
p36659
as(dp36660
g7
V505088
p36661
stp36662
a((dp36663
g2
(lp36664
VDelphi 2006 uses single byte ANSI characters and so  is ,  is
p36665
aVOn Delphi 2009 and later, two byte Unicode characters are used
p36666
aVThis function cannot possibly work on both compilers
p36667
aVEven the standard hack of using AnsiString and AnsiChar does not work
p36668
aVMost likely the assumptions that this function makes about the RTL implementation are no longer valid in modern Delphi
p36669
aVI would re-write this function in Pascal and let the compiler do the work
p36670
aVNot only will that be the quickest way to solve your current problem, it will also get you over the hurdle of 64-bit compilation should you ever choose to tackle that
p36671
as(dp36672
g7
V505088
p36673
stp36674
a((dp36675
g2
(lp36676
VDampsquid's analysis is correct so I will not repeat that
p36677
aVHowever, I prefer a different solution that I feel to be more elegant
p36678
aVMy preferred solution for such a problem is to use Delphi  which is a
p36679
aVOn the Delphi side you write it like this:
p36680
aVAnd on the C# side you do it like this:
p36681
aVAnd that's it
p36682
aVBecause both parties use the same COM allocator for the memory allocation, it all just works
p36683
aV@NoPyGod interestingly points out that this code fails with a runtime error
p36684
aVHaving looked into this I feel it to be a problem at the Delphi end
p36685
aVFor example, if we leave the C# code as it is and use the following, then the errors are resolved:
p36686
aVIt would seem that Delphi return values of type  are not handled as they should be
p36687
aVOut parameters and var parameters are handled as would be expected
p36688
aVI don't know why return values fail in this way
p36689
as(dp36690
g7
V505088
p36691
stp36692
a((dp36693
g2
(lp36694
V will do the necessary for you
p36695
aVNote however, that it was introduced in  Vista so won't help if you need to support XP
p36696
aVIf you want to avoid code in the DLL running whilst you extract resources, use  passing , or possibly
p36697
aVOnce you have done that, you can call  to extract the MUI value
p36698
as(dp36699
g7
V505088
p36700
stp36701
a((dp36702
g2
(lp36703
VThat is well-defined
p36704
aVWhat would not be well-defined would be to dereference the pointer in
p36705
as(dp36706
g7
V505088
p36707
stp36708
a((dp36709
g2
(lp36710
VA  is the same as a , it's just the Delphi name for it
p36711
aVThe memory allocation is handled by the shared COM allocator,
p36712
aVBecause all parties use the same allocator you can safely allocate in one module and deallocate in another
p36713
aVSo, the reason you don't need to use  is that the Delphi heap is not being used
p36714
aVInstead the COM heap is used
p36715
aVAnd that is shared between all modules in a process
p36716
aVIf you look at the Delphi implementation of WideString you will see calls to the following APIs: ,  and
p36717
aVThese are the system provided  API functions
p36718
aVMany of the Windows APIs you refer to pre-date the invention of COM
p36719
aVWhat's more, there are performance benefits to using a fixed length buffer, allocated by the caller
p36720
aVNamely that it can be allocated on the stack rather than a heap
p36721
aVI also can imagine that the Windows designers don't want to force every process to have to link to  and pay the price of maintaining the COM heap
p36722
aVRemember that when most of the Windows API was designed, the performance characteristics of the typical hardware was very different from now
p36723
aVAnother possible reason for not using  more widely is that the Windows API is targeted at C
p36724
aVAnd managing the lifetime of  from C is very much more tricky than from higher level languages like C++, C#, Delphi etc
p36725
as(dp36726
g7
V505088
p36727
stp36728
a((dp36729
g2
(lp36730
VYou could use an explicit struct layout to replicate this Delphi variant record
p36731
aVHowever, I would not bother since it seems pretty unlikely that you really want assignment to  to assign also to , and vice versa
p36732
aVThat Delphi record declaration looks like it dates from mid-1990s style of Delphi coding
p36733
aVModern Delphi code would seldom be written that way
p36734
aVI would just do it like this:
p36735
aVA more elegant option would be a class with properties for each struct field
p36736
aVAnd you would arrange that the property getters and setters for the 3 floats raised exceptions if they were accessed for an invalid value of
p36737
as(dp36738
g7
V505088
p36739
stp36740
a((dp36741
g2
(lp36742
V is not a standard C++ type
p36743
aVI can't tell from the C++ code what type to use
p36744
aVNow, in my view it's easier to work from the C# where the types are more intelligible and reliable than C/C++
p36745
aVIn C#  is a signed 64 bit integer, so  in Delphi
p36746
aVThe other two parameters in your Delphi snippet in the question are specified correctly
p36747
as(dp36748
g7
V505088
p36749
stp36750
a((dp36751
g2
(lp36752
VYes, the IDE does that and always has done
p36753
aVThere is no known way to stop it behaving like that
p36754
aVYou are just going to have to suck it up
p36755
aVI have similar conditionals and the way I deal with them is to use my revision control system to help me, at commit time, undo the changes that the IDE makes
p36756
aVSo whenever I check in a
p36757
aVdpr file I review the differences and revert the bogus ones
p36758
aVI also try to add and remove units from the project by editing the
p36759
aVdpr file rather than letting the IDE do it
p36760
aVThis tends to reduce the incidence rate of the bogus mods
p36761
as(dp36762
g7
V505088
p36763
stp36764
a((dp36765
g2
(lp36766
VHere is the code used by the graphics32 library to detect processor features:
p36767
aVYou can call  to discover what you need
p36768
as(dp36769
g7
V505088
p36770
stp36771
a((dp36772
g2
(lp36773
VThe usual approach is to run what is known as a guardian process
p36774
aVThis is a separate process, often a service, that monitors the state of the main process
p36775
aVWhen the guardian detects that the main service has died, it re-spawns it
p36776
aVTo the very best of my knowledge, there is not built in Windows functionality to do this for you
p36777
as(dp36778
g7
V505088
p36779
stp36780
a((dp36781
g2
(lp36782
VCreate a  with the appropriate menu items
p36783
aVWhen you need to show it simply call  passing the top left position in screen coordinates
p36784
as(dp36785
g7
V505088
p36786
stp36787
a((dp36788
g2
(lp36789
VYou didn't actually show how you called  which would, I think, explain what the problem is
p36790
aVHowever, there's one very common mistake that is most likely what is confusing you
p36791
aVConsider the C declaration of the API:
p36792
aVThe parameters that I suspect are causing you problems are the final two
p36793
aVLet us consider
p36794
aVThis is a pointer to a
p36795
aVBecause this is an out parameter you must supply a pointer to valid memory
p36796
aVI suspect you are just declaring a variable of type  and passing that
p36797
aVThe function  then de-references that pointer and tries to write to the memory
p36798
aVIf you have not given a valid pointer then this will fail
p36799
aVThe naive solution is to change the calling code to look like this:
p36800
aVThis will work but there is a much cleaner way
p36801
aVDeclare the API import like this:
p36802
aVAn  parameter of type  is actually passed as a pointer to the  that you supply as the argument to the function call
p36803
aVYou can then change your calling code to look like this:
p36804
aVNote that I have also added some error checking which you really ought to be doing
p36805
aVThe reason that the Windows API function is declared using pointers is that the C language only supports parameter passing by value
p36806
aVIt simply does not have pass-by-reference, i
p36807
ag192
aVor  in Delphi terms
p36808
aVLanguages that do support pass-by-reference should make use of them when they can
p36809
aVSome Windows API functions have optional parameters declared as pointers
p36810
aVWhen this is the case passing  as the pointer is the way to signal that you do not wish to pass a parameter
p36811
aVTranslating those APIs to Delphi is more complex
p36812
aVYou need to implement a version using pointers to allow callers to opt-out of supplying the parameter
p36813
aVBut it can be helpful to supply an overloaded version that uses  or  for convenience to the caller
p36814
aVThe Delphi  unit contains many such examples
p36815
aVAs for , I would declare it like this:
p36816
aVI have used the  facility because this is a Windows 7 and up API
p36817
aVYou will presumably want your program to run on older versions of Windows and so delay loading is needed
p36818
aVFor more information on delay loading in Delphi, see this answer, and particularly the onward links
p36819
aVNote that the documentation in the MSDN topic to which you link is incorrect
p36820
aVThe  parameter is declared incorrectly in the MSDN topic
p36821
aVThe correct definition, the one to be found in  is this:
p36822
as(dp36823
g7
V505088
p36824
stp36825
a((dp36826
g2
(lp36827
VThe signature should be:
p36828
aVThe problems with the code in the question are
p36829
aVThe mismatch between calling conventions:  exports its functions as
p36830
aVThe count parameter is  in the native code which equates to pointer sized unsigned integer in
p36831
aVnet, i
p36832
ag192
as(dp36833
g7
V505088
p36834
stp36835
a((dp36836
g2
(lp36837
VCast the  to  and use operator
p36838
as(dp36839
g7
V505088
p36840
stp36841
a((dp36842
g2
(lp36843
VI would do it like this:
p36844
aVCast  to , then apply the offset, then assign back to
p36845
aVSince  is assignment compatible with all pointer types no further cast is needed
p36846
as(dp36847
g7
V505088
p36848
stp36849
a((dp36850
g2
(lp36851
VYou will need to mask SSE exceptions on 64 bit because 64 bit code typically uses SSE to perform floating point arithmetic
p36852
aVCall  to change the control state of the SSE unit
p36853
aVPersonally I would continue masking 8087 exceptions since 64 bit code is perfectly at liberty to use the 8087 unit should it so wish
p36854
aVThe magic MXCSR value that you want to use when calling the web browser code is
p36855
aVThis is the default Windows value for MXCSR
p36856
aVAlternatively, you can call  and  passing  to mask all exceptions
p36857
aVThese convenience methods would make your code more readable
p36858
aVIf you are satisfied that you only need to mask exceptions on 8087 under x86 and SSE under x64 then you can just call
p36859
aVThis will change the 8087 control state under x86 and change the SSE control state under x64
p36860
aVIf I had to choose between setting the entire control state or using the convenience methods to change just the exception masking part of the state, I would set the entire control state
p36861
aVThese ActiveX controls are written under the assumption that you will be using MS tooling and expect a specific FP control state
p36862
aVI would give these controls the exact control state that they expect and then revert back to the Delphi control state when execution returns from the controls
p36863
as(dp36864
g7
V505088
p36865
stp36866
a((dp36867
g2
(lp36868
VWhat I suspect that you really want is to respond to the control receiving input focus rather than just the button down event
p36869
aVFor example, suppose the user uses the mouse button to set the input focus on the edit control, then types, and then clicks on the edit control again, whilst it currently has the focus
p36870
aVYou presumably do not want the user's text to be cleared
p36871
aVOr perhaps they set input focus using the keyboard, e
p36872
ag217
aVTAB
p36873
aVAgain I suspect you would want that action to clear the contents
p36874
aVAssuming my understanding is correct then you should listen for the  notification in your dialog procedure's  handler
p36875
aVThis will fire no matter how the user brings focus to the edit control, either using the mouse or by using the keyboard
p36876
aVIn your code you just need to expand your  statement in the :
p36877
as(dp36878
g7
V505088
p36879
stp36880
a((dp36881
g2
(lp36882
VWhether you declare your pointers in an array, or individually, one by one, the same amount of memory will be consumed
p36883
aVOf course, if you can declare fewer pointers by declaring them individually, then less space will be consumed
p36884
aVSo the following two lines both reserve space for 3 pointers:
p36885
aVGiven the small number of pointers involved in your code sample, you should opt for the approach that results in  the most readable code
p36886
aVOnly if your array was huge and had only a small proportion of pointers non-null would it be worth getting concerned about the overhead of the unused pointers in the array
p36887
as(dp36888
g7
V505088
p36889
stp36890
a((dp36891
g2
(lp36892
VThe Delphi equivalent is
p36893
aVThe Delphi documentation contains some examples of how to use this type and its associated helper function
p36894
as(dp36895
g7
V505088
p36896
stp36897
a((dp36898
g2
(lp36899
VI have before me James Gentle's Springer volume on this topic, Random Number Generation and Monte Carlo Methods, courtesy of my statistician wife
p36900
aVIt discusses the stable family on page 105:
p36901
aVThe stable family of distributions is a flexible family of generally heavy-tailed distributions
p36902
aVThis family includes the normal distribution at one extreme value of one of the parameters and the Cauchy at the other extreme value
p36903
aVChambers, Mallows, and Stuck (1976) give a method for generating deviates from stable distributions
p36904
aV(Watch for some errors in the constants in the auxiliary function D2, for evaluating (ex-1)/x
p36905
aVTheir method is used in the IMSL libraries
p36906
aVFor a symmetric stable distribution, Devroye (1986) points out that a faster method can be developed by exploiting the relationship of the symmetric stable to the Fejer-de la Vallee Poissin distribution
p36907
aVBuckle (1995) shows how to simulate the parameters of a stable distribution, conditional on the data
p36908
aVGenerating deviates from the generic stable distribution is hard
p36909
aVIf you need to do this then I would recommend a library such as IMSL
p36910
aVI do not advise you attempt this yourself
p36911
aVHowever, if you are looking for a specific distribution in the stable family, e
p36912
ag217
aVCauchy, then you can use the method described by Eric, known as the probability integral transform
p36913
aVSo long as you can write down the inverse of the distribution function in closed form then you can use this approach
p36914
as(dp36915
g7
V505088
p36916
stp36917
a((dp36918
g2
(lp36919
VA plain vanilla 32 bit VCL app in XE2, running on 64 bit Windows 7 has 3 threads
p36920
aVThe main thread and two extras
p36921
aVThe two extra threads are created in  by a call to
p36922
aVIf you want to name them then you can enumerate the threads in the process and call
p36923
aVIn my experience, it's very hard to keep track of all the threads in your app
p36924
aVAs soon as your app becomes moderately complex then there are liable to be plenty of threads coming and going
p36925
aVI personally view the ones that I have not named as being somebody else's responsibility
p36926
as(dp36927
g7
V505088
p36928
stp36929
a((dp36930
g2
(lp36931
VTo my mind that is rather pointless albeit completely harmless
p36932
aVYou could perfectly well declare  to be  and I would always do it that way
p36933
aVFor a reader of the code it makes the list of local variables easier to understand
p36934
aVIn this code  is always assigned a  instance and so there's nothing to be gained from declaring  to have the base class type of
p36935
aVHowever, if you had code that assigned a variety of different types of  descendants to the variable, then it would make sense to declare it as
p36936
aVThe situations when you might declare a variable to be of type  would typically be when the code was not explicitly creating the instance
p36937
aVFor example a utility method that received a string list as a parameter would be more useful if it accepted a  since then any descendant could be passed to it
p36938
aVHere's a simple example:
p36939
aVClearly this is of much greater utility when the parameter is declared to be  rather than
p36940
aVHowever, the code in the question is not of this nature and I believe that it would be ever so mildly improved if  was declared to be of type
p36941
as(dp36942
g7
V505088
p36943
stp36944
a((dp36945
g2
(lp36946
VI'd guess that something is changing the working directory of your process, most likely your code in the process
p36947
aVNote that the documentation has this to say:
p36948
aVIf the lpFileName parameter does not contain a full path and file name for the file, WritePrivateProfileString searches the Windows directory for the file
p36949
aVIf the file does not exist, this function creates the file in the Windows directory
p36950
aVNow my guess is that this applies if you supply just a file name
p36951
aVBecause your file name starts with  I believe that will force the function to start from the current working directory
p36952
aVHaving said all of that, and no matter what the cause of the problem is, you should use a fully-qualified path in order to make sure the file is written where you want it to be written
p36953
aVWhenever you want the file to go in a specific directory, it's always easiest to force that by using fully-qualified paths
p36954
aVYou can find the path to your executable using  and then remove the file name part
p36955
aVAnother point to make is that the same directory as the executable may be a bad choice
p36956
aVIf your program is installed under the Program Files directory then the directory which contains the executable will not be generally writeable
p36957
aVI think you should consider using a directory under in the user profile
p36958
aVLook for one of the  values
p36959
as(dp36960
g7
V505088
p36961
stp36962
a((dp36963
g2
(lp36964
VIt is enough to make  volatile
p36965
aVThat is enough to stop the access method being optimised away
p36966
as(dp36967
g7
V505088
p36968
stp36969
a((dp36970
g2
(lp36971
VThere's no API to control what gets displayed
p36972
aVYou can hack the resources of user32
p36973
aVdll
p36974
aVmui to change the text if that's the kind of thing you like doing
p36975
aVModifying the wallpaper would be a more reasonable approach in my view
p36976
as(dp36977
g7
V505088
p36978
stp36979
a((dp36980
g2
(lp36981
VWell, the simple answer is that you must free  before replacing it with the result of
p36982
aVLike this:
p36983
aVAs for the exception that is being raised, you state in a comment that at some point  is
p36984
aVWhen that happens  will fail
p36985
aVI can't really advise you on how to fix this because I just cannot get my head around what this code is trying to do
p36986
aVYou are quite possibly also leaking the memory that is created by the function that assigns
p36987
aVI can't understand why would want to use  rather than the  that the C runtime provides
p36988
aVYou are calling  from Shlwapi
p36989
aVdll
p36990
aVThat makes no sense to me
p36991
aVCall the one from the C runtime and free the memory with good old
p36992
aVI also don't understand why the loop termination is designed to apparently never terminate
p36993
aVAnd I've not looked at any of your code other than this single do while loop
p36994
as(dp36995
g7
V505088
p36996
stp36997
a((dp36998
g2
(lp36999
VYou cannot set the foreground window to the master main form because it is disabled
p37000
aVIt is disabled because you are showing a modal form whose owner is that main form
p37001
aVThe obvious solution is to set the foreground window to be the modal form rather than the main form
p37002
aVSince your slave app presumably cannot easily know which window is active, you should re-work your IPC to allow the slave app to ask the master app which window is active, and then make that the foreground window
p37003
aVA more elegant solution would be to let the master app call
p37004
aVIn fact it would probably be simpler just to call  from the master process
p37005
aVOf course, the slave process would still need to send a message to the master in order to invoke this
p37006
aVThe final piece in the puzzle is dealing with the focus-stealing restrictions but you can do that using
p37007
aVYou need your slave process to call this passing the ID of the master process
p37008
as(dp37009
g7
V505088
p37010
stp37011
a((dp37012
g2
(lp37013
VAll of the file copying APIs that I know of execute in the calling process
p37014
aVThis means that when you terminate the process, the file copying will be terminated also
p37015
aVSo, in order to ensure that the file copying continues after your application closes, you would need to run the file copy from a different process
p37016
aVYou could create a simple process that did the work and pass it command line arguments to specify which files to copy
p37017
aVIf you just want to unfreeze your main application whilst the copy is in progress, then you could create a separate thread to perform the file copy
p37018
as(dp37019
g7
V505088
p37020
stp37021
a((dp37022
g2
(lp37023
VSo, my question is: how can I debug this
p37024
aVStepping into Application
p37025
aVRun is the same as stepping over in this case
p37026
aVYou need to tick Debug DCUs in the compile options for the project to be able to step through VCL code under the debugger
p37027
as(dp37028
g7
V505088
p37029
stp37030
a((dp37031
g2
(lp37032
VThat window is for the output of the compilation process
p37033
aVIt's not what you are looking for
p37034
aVYou want to generate output whilst the program runs
p37035
aVI'd use the console or OutputDebugString or similar and I can't understand what you have against those options
p37036
as(dp37037
g7
V505088
p37038
stp37039
a((dp37040
g2
(lp37041
VYou can't get the system to start screensavers with elevated rights
p37042
aVIf that were possible then it would be a truly bone-headed security and design flaw
p37043
aVScreensavers should simply not be writing to Program Files or other restricted areas
p37044
aVYou will have to find a different location to write this file
p37045
as(dp37046
g7
V505088
p37047
stp37048
a((dp37049
g2
(lp37050
VWhen we ported from D6 to D2010, a couple of years back, we just recompiled our TeeChart version 3 code
p37051
aVThere were only a handful of very minor issues to deal with
p37052
aVNow, we are just using a very small subset of TeeChart (about 7 or 8 core units) but these are the primary units all the same
p37053
aVI think you have little to worry about
p37054
aVI eventually did upgrade TeeChart
p37055
aVIf I recall correctly it was better support for XP themes that forced us to upgrade from version 3 TeeChart
p37056
aVHowever, since your TeeChart already has themes support I fully expect a recompile to be successful
p37057
as(dp37058
g7
V505088
p37059
stp37060
a((dp37061
g2
(lp37062
V is exactly equivalent to
p37063
aVYou should always prefer the latter
p37064
aVIt is easier to read and there will be no difference in performance
p37065
as(dp37066
g7
V505088
p37067
stp37068
a((dp37069
g2
(lp37070
VYour declaration of  is incorrect
p37071
aVYou have omitted the calling convention
p37072
aVThe data types you have used are wrong too, although that's probably benign for you at the moment
p37073
aVIt should look like this:
p37074
as(dp37075
g7
V505088
p37076
stp37077
a((dp37078
g2
(lp37079
VYou cannot
p37080
aVNotification area icons are 16x16, or a little bigger if you have font scaling
p37081
aVThey have to be square
p37082
as(dp37083
g7
V505088
p37084
stp37085
a((dp37086
g2
(lp37087
VIf you have multiple instances of the  class that are producing identical series of random numbers, then you must be creating each instance using the same seed
p37088
aVFor example:
p37089
aVThe most likely explanation for that is that you are creating them all like this:
p37090
aVand creating each instance at the same point in time
p37091
aVThis constructor uses the current time to seed the RNG and if you create them all at the same point in time, they will all be seeded with the same time
p37092
aVSolve the problem by creating each instance with a different seed
p37093
aVOr create a single RNG and share it between all panels
p37094
as(dp37095
g7
V505088
p37096
stp37097
a((dp37098
g2
(lp37099
VIn your code,  simply evaluates , which results in an integer value of
p37100
aVThen the name  is bound to that  object of value
p37101
aVThe addition is evaluated once and once only
p37102
aVIf you want a new addition to be performed then you will have to explicitly invoke it one way or another
p37103
as(dp37104
g7
V505088
p37105
stp37106
a((dp37107
g2
(lp37108
VThe standard way is to use a memory manager that will align blocks on 16 byte boundaries
p37109
aVFastMM will do this but you need the full version to be able to configure this option
p37110
aVNote also that the code in your question is not 64 bit ready since it casts a pointer to a 4 byte integer
p37111
as(dp37112
g7
V505088
p37113
stp37114
a((dp37115
g2
(lp37116
VIf you can't convert the project to Unicode then you will just have to accept the limitations
p37117
aVYour dialog is an ANSI dialog
p37118
aVYou can use  if you like, but when the system wants to paint the dialog it is going to use the ANSI API to obtain the window text
p37119
aVIt is going to use the ANSI text drawing GDI functions to perform the painting
p37120
aVIf you want a Unicode dialog, you need to compile for Unicode
p37121
as(dp37122
g7
V505088
p37123
stp37124
a((dp37125
g2
(lp37126
VUse a tool like Spy++ to find out what the window class name is
p37127
aVFor example, on my Windows 7 machine, the window class name for a system file open dialog is
p37128
as(dp37129
g7
V505088
p37130
stp37131
a((dp37132
g2
(lp37133
VTo answer your question directly, you can test for mouse button state with  or
p37134
aVThe virtual key code you need is
p37135
aVThe difference between these is that  reports the state at the time that the currently active queued message was posted to your queue
p37136
aVOn the other hand,  gives you the state at the instant that you call
p37137
aVFrom the documentation of :
p37138
aVThe key status returned from this function changes as a thread reads key messages from its message queue
p37139
aVThe status does not reflect the interrupt-level state associated with the hardware
p37140
aVUse the GetAsyncKeyState function to retrieve that information
p37141
aVAn application calls GetKeyState in response to a keyboard-input message
p37142
aVThis function retrieves the state of the key when the input message was generated
p37143
aVI suspect that you should be using  but I can't be 100% sure because I don't actually know what you are trying to achieve with this information
p37144
as(dp37145
g7
V505088
p37146
stp37147
a((dp37148
g2
(lp37149
VYou have a race on the mutex
p37150
aVYou are hoping for the following sequence:
p37151
aVBut what can happen is
p37152
aVI can't quite work out what your ultimate goal is but I have a suspicion that an event is actually what you are looking for
p37153
aVIn the parent:
p37154
aVCreate a named event
p37155
aVSet the event to non-signaled
p37156
aVCreate the child process
p37157
aVWait until the event is signaled
p37158
aVIn the child:
p37159
aVDo some processing
p37160
aVOpen the named event
p37161
aVSet the event to signaled, thereby releasing the parent from its wait
p37162
aVIn very high level the code you need will look like this:
p37163
aVParent
p37164
aVChild
p37165
aVI've not included any error checking
p37166
aVI'm sure you can add some
p37167
aVYou may also find that the event wrapper class in  is more convenient
p37168
aVFinally, your code has a busy loop
p37169
aVThat is almost never the solution to any problem
p37170
aVIf ever you find yourself writing a busy loop you should take that as a signal that the design is incorrect
p37171
aVThe point being that, in your code, if it could be made to work, the parent process would burn 100% CPU utilization whilst waiting on the child process
p37172
as(dp37173
g7
V505088
p37174
stp37175
a((dp37176
g2
(lp37177
VCustom drawing event handlers are always attached to the UI components and not to actions
p37178
aVSo with the plain VCL you cannot do what you ask
p37179
aVIt would be simple enough to derive your own action class that added an OnDraw event
p37180
aVYou would also have to derive your own dropdown menu class to provide the other end of the connection
p37181
as(dp37182
g7
V505088
p37183
stp37184
a((dp37185
g2
(lp37186
VI would always avoid unsafe if at all possible since unsafe code is, well, not safe
p37187
aVAnd it is quite possible to avoid in this case:
p37188
as(dp37189
g7
V505088
p37190
stp37191
a((dp37192
g2
(lp37193
VPassing 0 for the  parameter is fine
p37194
aVThe documentation describes the parameter thus:
p37195
aVA handle to the parent window used for displaying a UI or error messages
p37196
aVThis value can be NULL if the operation is not associated with a window
p37197
aVYour error is due to something else
p37198
as(dp37199
g7
V505088
p37200
stp37201
a((dp37202
g2
(lp37203
VThat code works perfectly well
p37204
aVI trust you realise that you must have the input focus set to the control that you want to receive the mouse wheel input messages
p37205
aVAre you sure that you defined  correctly
p37206
aVThe only other possibility that I can think of is that your window is already scrolled to the top
p37207
aVNote that your delta value of 120 will scroll upwards
p37208
aVTry passing  instead which is what you would need to scroll down
p37209
as(dp37210
g7
V505088
p37211
stp37212
a((dp37213
g2
(lp37214
VThe C code that you present is simply not going to work
p37215
aVYou need to be much more precise about which party allocates and is responsible for the heap memory
p37216
aVIn your current example you pass  to the C code
p37217
aVHowever, the pointer to that ctypes memory is only valid for the duration of the call to
p37218
aVAs soon as  returns then that pointer is no longer valid
p37219
aVBut you took a copy of the pointer inside
p37220
aVThus the subsequent call to  is liable to fail
p37221
aVYou are going to need to take a copy of the contents of that string and store it in the struct
p37222
aVIf you do that then you can use  safely
p37223
aVBut if you want the memory you allocated to be deallocated you will have to provide a  function to match the  function
p37224
aVWith these changes the C code would look like this:
p37225
aVThe Python code would look like this:
p37226
as(dp37227
g7
V505088
p37228
stp37229
a((dp37230
g2
(lp37231
VThis is the action of the registry redirector
p37232
aVYou have a 64 bit system
p37233
aVThe batch file is executed by the native 64 bit command interpreter
p37234
aVBut your C program is 32 bit, and the  command runs as a 32 bit process
p37235
aVThat happens because of the file redirector which translates system32 to syswow64 when you run a 32 bit process on 64 bit Windows
p37236
aVAll this means that the C program is reading out of the 32 bit view of the registry
p37237
aVYour attempt to read  is redirected to
p37238
aVThe ideal solution would be to stop using  and use the native Windows API functions to access the registry
p37239
aVThen you could specify that you want to read from the 64 bit view of the registry and you could gain access to that even from a 32 bit process
p37240
aVAn utterly revolting hack would be to get your  command to start  which would force the use of the 64 bit version of
p37241
as(dp37242
g7
V505088
p37243
stp37244
a((dp37245
g2
(lp37246
V is indeed what you want
p37247
aVUse the  which is a  containing the coordinates of the normalised position
p37248
aVOr, if  is in the window placement  then use the work area of the monitor with which the window is associated
p37249
aVHaving said that,  can sometimes return misleading information in  on Windows 7
p37250
aVI've come across this when you use the half screen Aero snap  feature
p37251
aVAfter you do that, and if the window is still normalised when you ask the question, you will find that  returns in  a  that does not match the Aero snap position
p37252
aVDeal with that by simply using  if the window is normalised
p37253
as(dp37254
g7
V505088
p37255
stp37256
a((dp37257
g2
(lp37258
VYou cannot override the constructor of  since it is not virtual
p37259
aVThe ini file classes do not use virtual constructors
p37260
aVYou simply need to remove the  from your code
p37261
aVImplement it like this:
p37262
aVWhen you need to create one you do so like this:
p37263
as(dp37264
g7
V505088
p37265
stp37266
a((dp37267
g2
(lp37268
V maintains a protected field named  which is exactly what you need
p37269
aVThe other big problem with your code is that you are assuming that selection can only be changed by the mouse
p37270
aVDon't forget about the keyboard or programmatic modification
p37271
aVYou are looking for the virtual method named
p37272
aVSo, putting it all together, you can do what you need like this:
p37273
aVWe have to make use of  before we call the inherited  method since that is where  is changed to be equal to the current selection
p37274
as(dp37275
g7
V505088
p37276
stp37277
a((dp37278
g2
(lp37279
VSince you are superclassing an existing window class and augmenting its behaviour, then you are correct to worry about collisions with existing messages
p37280
aVBecause of that I feel that you have to use a message in the  range
p37281
aVYou could equally well use  but I agree that is overkill
p37282
as(dp37283
g7
V505088
p37284
stp37285
a((dp37286
g2
(lp37287
VIt does indeed appear to be a VCL bug
p37288
aVThe  property is not properly streamed from the
p37289
aVdfm file when the style is set in the project options to be other than the system style
p37290
aVI suggest that you submit a report to QualityCentral
p37291
aVIn the meantime you may be able to work around this by setting the style in the
p37292
aVdpr file after the forms have been created
p37293
aVHowever, I don't imagine that will get you very far because you probably want to be able to create forms on the fly and not have to create the all upon startup
p37294
as(dp37295
g7
V505088
p37296
stp37297
a((dp37298
g2
(lp37299
VThe reason is that  is actually just a
p37300
aVThat means it is a double precision value holding number of days since the Delphi epoch
p37301
aVThe IDE debug hints for a  show just the date part and omit the time part
p37302
aVYou are comparing for equality and so two values that are in the same day, but have different time components will not be equal
p37303
aVHere's a screenshot to illustrate:
p37304
aVSolve the problem by using  to remove the time part of the date time
p37305
aVYou will have to use  whenever you receive a date value, and clearly before you add to the dictionary
p37306
as(dp37307
g7
V505088
p37308
stp37309
a((dp37310
g2
(lp37311
VYou need to expand each macro to fully understand it
p37312
aVRun your code through the pre-processor to see how it expands, or use your helpful IDE tools to show you
p37313
aVWhen you do so you will see the following:
p37314
aVis the result type
p37315
aVIt's an integer of some description
p37316
aVdefines the calling convention which would be
p37317
aVAnd as for the other one:
p37318
aVprobably expands to
p37319
aVThis specifies that the function is to be exported from the library
p37320
aVis the return value
p37321
aVwill be the calling convention
p37322
aVYou can think of these extra tokens as being decorators to the function
p37323
aVThey do not change the signature of the function at a conceptual level
p37324
aVProbably the closest analogous concept in Java would be attributes
p37325
as(dp37326
g7
V505088
p37327
stp37328
a((dp37329
g2
(lp37330
VThe documentation for the  attribute of  is not very useful at all
p37331
aVLooking at your output it would seem that the buffer of eight 4 byte integers is being reinterpreted as four 8 byte floats
p37332
aVBut what you want is to specify the  in the array creation:
p37333
as(dp37334
g7
V505088
p37335
stp37336
a((dp37337
g2
(lp37338
VIt is possible to have an implementation of C on a system that does not have environment variables
p37339
aVSo by that token you you cannot conclude that all host platforms support environment variables
p37340
aVHowever, that's pretty much nitpicking
p37341
aVYou will have to deal with this on a case by case basis but you'll find  pretty much everywhere
p37342
as(dp37343
g7
V505088
p37344
stp37345
a((dp37346
g2
(lp37347
VThe access violation is because of this code:
p37348
aVHere you declare that  is a pointer, but you don't make it point at anything
p37349
aVWhen  tries to write to  it results in an access violation
p37350
aVThe correct approach is like this:
p37351
aVI also don't believe that you need to call  at all
p37352
aVThe process handle that  returns should have sufficient rights
p37353
aVYou will need to wait for the spawned process to terminate before you can expect to get an exit code
p37354
aVThis is because  is asynchronous
p37355
aVYou can wait like this:
p37356
aVAnd do remember to check all your API calls for errors
p37357
as(dp37358
g7
V505088
p37359
stp37360
a((dp37361
g2
(lp37362
VThe simplest way is to make your
p37363
aVexe file self-contained by statically linking all the runtime libraries:
p37364
aVSet the Link with Dynamic RTL option to false
p37365
aVSet the Link with runtime packages option to false
p37366
aVOtherwise you need to redistribute the runtime dependencies
p37367
aVThe documentation contains a section on deployment, although you'll need to read your local documentation since you are using a very old version of the product
p37368
aVUpdate: it's chapter 17 in this document
p37369
aVAs for how to make an installer, there are a gazillion tools that do that
p37370
aVChoose one and get it to do the hard work
p37371
as(dp37372
g7
V505088
p37373
stp37374
a((dp37375
g2
(lp37376
VShould I go for a "position" approach or for some "tag" approach
p37377
aVWithout doubt you should tag your command line arguments
p37378
aVPositional approaches don't allow sufficient flexibility to omit parameters
p37379
aVTagging makes it easier for the user to understand the arguments, especially when returning to previously written code
p37380
aVThe tags should be self-documenting
p37381
aVOne common scenario when you would have untagged arguments is when you have a file name or a list of file names
p37382
aVHow to manage parameters that contain a "space"
p37383
aVThe Windows convention is that spaces are escaped by putting double-quotes around the argument
p37384
aVThe  parsing will recognise these and parse the arguments accordingly
p37385
aVWhat you see in  is the argument with the quotes removed
p37386
aVThe RTL comes with a useful helper function to aid your command-line argument parsing:
p37387
as(dp37388
g7
V505088
p37389
stp37390
a((dp37391
g2
(lp37392
VDisabling file redirection is a precarious business
p37393
aVYou are doing it here in order for your 32 bit process to be able to see the file located in
p37394
aVNormally any reference to that folder from a 32 bit process would be redirected to
p37395
aVBut, as you discovered, disabling file redirection breaks other links in the chain
p37396
aVThe best solution that I know is to use the special  alias to be able to locate the true system32 directory
p37397
aVDon't disable file redirection and simply pass  when spawning the process
p37398
aVThe documentation for file redirection says:
p37399
aV32-bit applications can access the native system directory by substituting %windir%\u005cSysnative for %windir%\u005cSystem32
p37400
aVWOW64 recognizes Sysnative as a special alias used to indicate that the file system should not redirect the access
p37401
aVThis mechanism is flexible and easy to use, therefore, it is the recommended mechanism to bypass file system redirection
p37402
aVNote that 64-bit applications cannot use the Sysnative alias as it is a virtual directory not a real one
p37403
aVWindows Server 2003 and Windows XP:  The Sysnative alias was added starting with Windows Vista
p37404
aVThe final warning effectively means that  is not recognised on XP64, unless the machine has been serviced with the MS hotfix that back-fits  to that OS
p37405
aVIn practice this doesn't matter because the XP64 installed base is vanishingly small
p37406
aVThe only other solution that I am aware of is to create your own dedicated launcher that is a 64 bit process
p37407
aVIf you place that launcher in a folder that is not subject to file redirection then you can call that launcher from your 32 bit process and then the launcher is able to see the 64 bit system directory
p37408
aVI think you would have to use this approach if you needed to support XP64
p37409
as(dp37410
g7
V505088
p37411
stp37412
a((dp37413
g2
(lp37414
VYour problem is that  is an array and arrays are not lvalues
p37415
aVYou need a pointer
p37416
as(dp37417
g7
V505088
p37418
stp37419
a((dp37420
g2
(lp37421
VFor the generic  it is simply not possible to implement the function you want
p37422
aVThat's because copy the contents of  may involve more than a simple memory copy
p37423
aVIf  contains any managed types (i
p37424
ag192
aVstrings, interfaces etc
p37425
aVthen the reference counts on those managed objects must be incremented
p37426
aVIf your  does contain managed types then I doubt that you can do much better then the code you already have
p37427
aVIf your  does not contain any managed types then a memory copy is viable but you will need to create your own class to encapsulate this list since  is not appropriate
p37428
as(dp37429
g7
V505088
p37430
stp37431
a((dp37432
g2
(lp37433
VThe operating system provides such services, namely  for XP, and  for Vista and up
p37434
aVThe JEDI libraries expose this through the  unit
p37435
aVThese don't look like being the easiest API functions to call, but they do have the obvious benefit of being system native and so should give a good look and feel
p37436
as(dp37437
g7
V505088
p37438
stp37439
a((dp37440
g2
(lp37441
VThose are linker errors
p37442
aVYou need to make sure that you are passing the PCRE
p37443
aVlib files to the linker
p37444
aVAnother possible problem could be that your compiler/linker is using a different
p37445
aVlib file format from that used to build the PCRE
p37446
aVlib files
p37447
as(dp37448
g7
V505088
p37449
stp37450
a((dp37451
g2
(lp37452
VIt's actually pretty simple to convert, but you can't use templates in Delphi
p37453
aVIt is merely adding an offset to a pointer, but the offset is specified in bytes rather than multiples of the pointer base type
p37454
aVSo convert
p37455
aVinto
p37456
aVSome more examples:
p37457
aVand so on
p37458
as(dp37459
g7
V505088
p37460
stp37461
a((dp37462
g2
(lp37463
VIt's perfectly safe to call  from a thread other than the main thread
p37464
aVI would pass  as the  member
p37465
aVIf you pass the handle of the main window then I expect that window will be disabled because  is a modal dialog
p37466
aVSince the file confirmation and progress dialogs are the top level UI for the background thread, you don't want any windows to be disabled when these modal dialogs show
p37467
as(dp37468
g7
V505088
p37469
stp37470
a((dp37471
g2
(lp37472
VYou can take advantage of the fact that you are writing to the array  in sequential order and increment the pointer rather than use array indexing
p37473
aVThe trick here is that each time round the loop  points to the ith item in the array
p37474
aVWhen each iteration is done the  advances the pointer on to the next item, ready for the next iteration
p37475
aVI also corrected your  loop
p37476
aVIn your Delphi code you performing one iteration too many
p37477
as(dp37478
g7
V505088
p37479
stp37480
a((dp37481
g2
(lp37482
VOverride the  method rather than trying to handle  messages
p37483
aVThat way, the built in mechanism for double buffering will still be active, but you can customise your painting
p37484
as(dp37485
g7
V505088
p37486
stp37487
a((dp37488
g2
(lp37489
VOn Vista and upwards services run in a different session (session 0) and are isolated from the interactive desktop(s)
p37490
aVThis means that code that you run from the service is simply unable to make the changes you want
p37491
aVThe obvious conclusion is that you need to run code in the interactive desktop
p37492
aVNow you can do this, but it's not exactly easy to achieve
p37493
aVWhat you will need to do is arrange for your service to launch an process that runs on the interactive desktop: Launching an interactive process from Windows Service in Windows Vista and later
p37494
aVThat process, rather than the service, is what will have to make the changes
p37495
aVWhilst it is possible to achieve what you want, I think you should regard the difficulties involved as a signal to review whether or not your proposed approach is the best solution to whatever your underlying problem is
p37496
as(dp37497
g7
V505088
p37498
stp37499
a((dp37500
g2
(lp37501
VYou can use the new RTTI functionality exposed by the Rtti unit
p37502
aVThis code enumerates attributes associated with methods, properties and fields, as well as with types
p37503
aVNaturally you will want to do more than , but this should give you an idea for how to proceed
p37504
aVYou can test for your specific attribute in the normal way
p37505
as(dp37506
g7
V505088
p37507
stp37508
a((dp37509
g2
(lp37510
VMost likely you just need to call  before attempting to access
p37511
aVThis will wait until Excel has started up sufficiently to have a main window handle allocated
p37512
aVThe other thing that now occurs to me is that Excel may be running out of a single process
p37513
aVSo when you do  the second time, what actually happens is that the second process hands the request on to the first process and then shuts down immediately
p37514
aVYou could use task manager to test this hypothesis
p37515
aVIf I'm right, then use  to get the list of all running processes, find the Excel process, and give its main window the focus
p37516
as(dp37517
g7
V505088
p37518
stp37519
a((dp37520
g2
(lp37521
VYes you will need a separate thread, or some other form of asynchronous execution
p37522
aVOnce you enter that while loop, no other code runs in that thread
p37523
aVEver
p37524
as(dp37525
g7
V505088
p37526
stp37527
a((dp37528
g2
(lp37529
VYou can make a window that is transparent and click through
p37530
aVHowever, it's all or nothing
p37531
aVYou can't be click through apart from double clicks
p37532
aVSo, to do what you want I believe you will need to use a global mouse hook to handle the double clicks
p37533
aVBut that's going to require native code
p37534
aVIn fact, come to think of it, why do you need the transparent click through window at all
p37535
as(dp37536
g7
V505088
p37537
stp37538
a((dp37539
g2
(lp37540
V, the equals comparison operator  are all known to work correctly
p37541
aVThus we can only conclude that  does not hold the value
p37542
aVThe most obvious possibility is that the space is in fact some other form of whitespace
p37543
aVPerhaps a tab character
p37544
aVOr perhaps a non-breaking space
p37545
aVOr perhaps it is two spaces
p37546
aVTake a look at the binary representation of the two strings and compare them
p37547
as(dp37548
g7
V505088
p37549
stp37550
a((dp37551
g2
(lp37552
VI can confirm that this is a bug
p37553
aVIf the only instantiation of the class is in the
p37554
aVdpr file, then the class constructor does not run
p37555
aVIf you create another unit, i
p37556
ag192
aVa separate
p37557
aVpas file, and instantiate a  from there, then your class constructor will run
p37558
aVI have submitted QC#103798
p37559
as(dp37560
g7
V505088
p37561
stp37562
a((dp37563
g2
(lp37564
VOn Windows 7 and upwards you should use the API function that MS introduced for this very purpose:
p37565
aVYour current code is failing for one or more of the following reasons:
p37566
aVYou are trying to read 32 bit versions of the structures from a 64 bit process
p37567
aVIn this case  has a different layout and size under 64 bits and the process you are attacking is 64 bit explorer
p37568
aVThe implementation (details of which you are relying on) of the notification area has changed between XP and 7
p37569
aVI do not know whether or not this is true, but it could be
p37570
as(dp37571
g7
V505088
p37572
stp37573
a((dp37574
g2
(lp37575
VWhat you state in the question is not true
p37576
aVTwo objects are indeed returned
p37577
aVAccess them with  and
p37578
aVI guess you are looking at  under the debugger and the IDE cannot know that you mean for your pointer  to be an array of two objects
p37579
aVSo the tooltips will only show the first object, , or
p37580
aVBut the other object,  is definitely there
p37581
aVAdd the following line after the call to :
p37582
aVand you will see this output:
p37583
aVNote that there is no point in the line  since you immediately overwrite
p37584
aVYou should do it this way:
p37585
aVYour code is also a little dangerous in that you must keep  alive at least as long as you are making references to
p37586
as(dp37587
g7
V505088
p37588
stp37589
a((dp37590
g2
(lp37591
VNo,  is correct
p37592
aVis of type  and  is 4 on your system
p37593
aVI have a feeling it is impossible due to C losing the information as soon as you treat the array as an int pointer
p37594
aVThat is correct
p37595
aVYou have to keep track of the length
p37596
as(dp37597
g7
V505088
p37598
stp37599
a((dp37600
g2
(lp37601
VYour solution is perfectly reasonable
p37602
aVI have an Excel COM add-in that does something very similar
p37603
aVIn that code I set Application
p37604
aVHandle in the DLL to be the window handle of the Excel main window
p37605
aVThat's analagous to what you are doing
p37606
aVThe issue is that you need to get the window ownership set correctly
p37607
aVYou need the chain of ownership to reach all the way back to your app's main form
p37608
aVForms in a DLL have no knowledge of what the main form is, and so you have to provide that knowledge
p37609
aVNote that I am talking about the concept of window owner as used by Windows and not the VCL concept of owner which is totally different
p37610
aVIn VCL terminology this is known as popup parent and you could solve your problem by explicitly setting the DLL form's popup parent to be the main form
p37611
aVThe relevant properties are PopupMode and PopupParent
p37612
aVFor the forms that live in the main app, the VCL will naturally make their popup parent be the main form
p37613
aVHowever, having talked about explicitly setting popup parent, I would stress that your current solution is simpler and more convenient
p37614
aVWhat both of these solutions do is to make sure that all auxiliary forms are owned by the main form
p37615
aVThat means that these forms are always on top of the main form
p37616
aVIt means that the auxiliary forms will be minimized if the main form is minimized
p37617
aVRead about owned windows here: Window Features
p37618
aVIncidentally, if you had been using runtime packages rather than a DLL, the code in the package would be connected to the same VCL as the main form
p37619
aVSo the packaged code would be able to see the main form and set the window owner appropriately
p37620
aVThis is certainly one advantage of using packages
p37621
aVOf course, there may very well be a good reason why you need to use DLLs rather than packages
p37622
as(dp37623
g7
V505088
p37624
stp37625
a((dp37626
g2
(lp37627
VThe author of that text is distinguishing NULL as not being a memory location
p37628
aVSo you use one of the 2^32 available values for NULL which leaves 2^32-1 available for memory locations
p37629
as(dp37630
g7
V505088
p37631
stp37632
a((dp37633
g2
(lp37634
VWhen a thread is killed forcibly, e
p37635
ag217
aVfrom the task manager or from Process Explorer, that does not change the thread ID
p37636
aVThe thread handle still exists because your process has not yet closed it
p37637
aVAnd the thread ID associated with that thread still exists
p37638
aVSo  will always return a non-zero value
p37639
aVAs for the exit code, you can't get a meaningful value for the exit code because the thread did not exit
p37640
aVIt was killed
p37641
aVIt never had a chance to set an exit code
p37642
aVWhat you must do is use one of the wait functions, e
p37643
ag217
aV, to wait on your thread handle
p37644
aVIf that wait terminates because the thread was killed, then the wait function will return and report a successful wait and the thread exit code will be reported as
p37645
aVTo the best of my knowledge you cannot discern by means of the Windows API that your thread was killed abnormally
p37646
aVWhat you could do is use your own mechanism to indicate that termination was abnormal
p37647
aVCreate a flag, owned by the thread, to record that termination was normal
p37648
aVSet the flag to false when the thread starts executing
p37649
aVWhen the thread terminates normally, set the flag to true
p37650
aVThis way you can tell whether or not the thread was terminated abnormally by reading the value of that flag after the thread terminates
p37651
as(dp37652
g7
V505088
p37653
stp37654
a((dp37655
g2
(lp37656
VThe return value  would suggest that  is a pointer to C string
p37657
aVThis would imply that the native code was in charge of allocating the buffer
p37658
aVSo  is not appropriate here
p37659
aVThere is not actually enough information here to know how to call this function
p37660
aVWhat is missing is knowledge of which party is responsible for deallocating the string
p37661
aVIt could be either party and I'm going to assume that the C code will do so, probably by means of the strings being statically allocated, e
p37662
ag217
aVconstants
p37663
aVNow, I have no experience with VB p/invoke so I hope you don't mind if I give you a C# version
p37664
aVI expect you can translate easily enough
p37665
aVYou call the function like this:
p37666
aVNote that your character set was incorrect in the question
p37667
aVYou have to use Ansi because the native code uses
p37668
aVI also think that your  attributes are spurious since you are just re-stating the default marshalling for those parameter types
p37669
aVNow, if the native code expects the caller to deallocate the memory, then the native code would have to export a function to do so
p37670
aVIf that's the case then you would call it passing  by value
p37671
as(dp37672
g7
V505088
p37673
stp37674
a((dp37675
g2
(lp37676
VDIB is Device Independent Bitmap
p37677
aVMore details on MSDN and Wikipedia
p37678
aVI expect that what was being referred to
p37679
as(dp37680
g7
V505088
p37681
stp37682
a((dp37683
g2
(lp37684
VAssuming that the C++ structs are packed, your C# structs should look like this:
p37685
aVOn the other hand, if they are not packed then remove the  parameter to the  attribute
p37686
aVYou should look for a  statement in the C++ header file to understand whether or not the C++ structs are packed
p37687
aVI'm guessing that the C++ structs are packed because you said that they are mapped onto data received from the server
p37688
aVYour import should be like so:
p37689
aVA  translates to  rather than  and there is no need for unsafe code here
p37690
as(dp37691
g7
V505088
p37692
stp37693
a((dp37694
g2
(lp37695
VThe documentation describes the expected use of this folder like this (emphasis mine):
p37696
aVThe file system directory that contains application data for all users
p37697
aVA typical path is C:\u005cDocuments and Settings\u005cAll Users\u005cApplication Data
p37698
aVThis folder is used for application data that is not user specific
p37699
aVFor example, an application can store a spell-check dictionary, a database of clip art, or a log file in the CSIDL_COMMON_APPDATA folder
p37700
aVThis information will not roam and is available to anyone using the computer
p37701
aVNote that this documentation refers to the typical path as per older versions of Windows
p37702
aVIn modern versions of Windows it is located in
p37703
aVRather disappointgly, the above quote is from the now legacy  documentation
p37704
aVBut the documentation for the replacement  omits the useful descriptions of what you are intended to do with these special folders
p37705
aVSo, in order to get to the bottom of questions like this you need to refer to both topics, so far as I can tell
p37706
as(dp37707
g7
V505088
p37708
stp37709
a((dp37710
g2
(lp37711
Vchecks  for truth
p37712
aVIf that is not true it then checks  for truth
p37713
aVThat is always true and so the compiler can probably work out that this test always evaluates to true
p37714
aVWhat you really mean is
p37715
as(dp37716
g7
V505088
p37717
stp37718
a((dp37719
g2
(lp37720
VIt's pretty much as simple as this:
p37721
aVMake sure you don't forget to call  in order to initalize COM
p37722
as(dp37723
g7
V505088
p37724
stp37725
a((dp37726
g2
(lp37727
VThis declaration is incorrect:
p37728
aVIt should be:
p37729
aVYou have to be careful not to mix up  and  since they are not the same thing
p37730
aVThe former is a single byte, the latter is 4 bytes
p37731
aVThis mismatch between what  expects and what your callback function delivers is enough to cause the behaviour you observe
p37732
aVIn addition, Rob Kennedy contributed this excellent comment:
p37733
aVThe compiler can help find this error if you get out of the habit of using the  operator before the function name when you call
p37734
aVIf the function signature is compatible, the compiler will let you use it without
p37735
aVUsing  turns it into a generic pointer, and that's compatible with everything, so the error is masked by unnecessary syntax
p37736
aVIn short, using  to create function pointers should be considered a code smell
p37737
aVDiscussion
p37738
aVUnfortunately the  header translation defines  in a most unhelpful manner, like this:
p37739
aVNow, the problem is in the definition of
p37740
aVIt is defined as:
p37741
aVThis means that you have to use the  operator to make a generic pointer, because the function needs a generic pointer
p37742
aVIf  were declared like this:
p37743
aVthen the compiler would have been able to find the error
p37744
aVThe compiler rejects the call to  with the following error:
p37745
aV[DCC Error] Unit1
p37746
aVpas(38): E2010 Incompatible types: 'LongBool' and 'Boolean'
p37747
aVI think I will QC this issue and try my luck at persuading Embarcadero to stop using
p37748
as(dp37749
g7
V505088
p37750
stp37751
a((dp37752
g2
(lp37753
VLinking to shared libraries, DLLs in Windows-speak, requires the following:
p37754
aVA header file at compile time:
p37755
aVAn import library at link time:
p37756
aVA DLL at runtime:
p37757
aVYou clearly have 1 and 3 and are missing 2
p37758
aVThe Windows SDK that comes with Visual Studio includes the import library
p37759
aVBut you need to add it as an additional dependency in your project's linker options
p37760
aVLike this:
p37761
as(dp37762
g7
V505088
p37763
stp37764
a((dp37765
g2
(lp37766
VYou have identified the fundamental problem
p37767
aVYour query is running in the UI thread and blocks that thread whilst it runs
p37768
aVNo UI updates can occur, timer messages cannot fire etc
p37769
aVI think the best solution is to move the execution of the ProxyMethods to a separate thread
p37770
aVHowever, there must be an existing solution -- because the related hung app issue seems like it would be a common complaint
p37771
aVI just can't find the solution
p37772
aVYou have already found the only solution to the problem
p37773
aVYou must run your long-running query in a thread other than the UI thread
p37774
as(dp37775
g7
V505088
p37776
stp37777
a((dp37778
g2
(lp37779
VI have grave doubts about this line:
p37780
aVI guess  is the time step
p37781
aVYou are incrementing the time step by a second each time around the loop
p37782
aVNormally you would increment time:
p37783
aVbut you don't have a time variable yet
p37784
aVOnce your time step gets large, all hell will break loose
p37785
aVFor now I would simply delete the  line
p37786
aVAs for the rest of the code, I've not looked at it in any detail and I can't guess what  your notation signifies
p37787
aVThere may well be more problems in the code
p37788
as(dp37789
g7
V505088
p37790
stp37791
a((dp37792
g2
(lp37793
VThe documentation explicitly states that the behaviour you see is as designed:
p37794
aVIf the delegate property is of a class type, that class and its ancestors are searched for methods implementing the specified interface before the enclosing class and its ancestors are searched
p37795
aVI guess in the full example you have an interface with multiple methods and are wanting the majority specified by the delegate, and specific ones overridden by the implementing class
p37796
aVI can't see how to achieve that with just one class, but it can be done if you introduce a second class:
p37797
aVAs @teran points out, if you are prepared to rename your method then there is an easier solution
p37798
as(dp37799
g7
V505088
p37800
stp37801
a((dp37802
g2
(lp37803
VOn Vista and up you can show a more modern looking dialog using
p37804
aVwhich looks like this:
p37805
as(dp37806
g7
V505088
p37807
stp37808
a((dp37809
g2
(lp37810
VOne possible approach is to modify your component so that it is capable of simply ignoring these properties
p37811
aVThat way you don't have to hunt them down in each and every
p37812
aVdfm file
p37813
aVFor example:
p37814
as(dp37815
g7
V505088
p37816
stp37817
a((dp37818
g2
(lp37819
VFirst of all, you should use the higher level  module and specifically the  class
p37820
aVThe  module is not what you need
p37821
aVAs you extend this code, you most likely will also want to wait for the threads to finish
p37822
aVFollowing is a demonstration of how to use the  method to achieve that:
p37823
as(dp37824
g7
V505088
p37825
stp37826
a((dp37827
g2
(lp37828
VThe documentation contains the answer:
p37829
aVIf this function is called from a 32-bit application running on WOW64, it can only enumerate the modules of a 32-bit process
p37830
aVIf the process is a 64-bit process, this function fails and the last error code is ERROR_PARTIAL_COPY (299)
p37831
aVThe machines on which this error code is returned are 64 bit systems and the process whose modules you are enumerating is a 64 bit process
p37832
aVTo enumerate the modules of a 64 bit process from your 32 bit service you need to use
p37833
aVIn fact it looks like you may need to run a 64 bit process in order to enumerate process modules
p37834
aVUpdate: You are apparently sure that the the systems on which the code is failing are 32 bit systems
p37835
aVIn that case perhaps the failures are when you try to enumerate modules of 16 bit processes
p37836
as(dp37837
g7
V505088
p37838
stp37839
a((dp37840
g2
(lp37841
VOne possible approach would be to use  rather than
p37842
aVI've never actually tried this but I think it quite plausible that  does not use any VCL units, or at the very least what it does use can easily be excised
p37843
aVAnd indeed a quick scan of the source code suggests that this will work
p37844
as(dp37845
g7
V505088
p37846
stp37847
a((dp37848
g2
(lp37849
VIf Iron python can do everything C# and VB can do in VS2010 i'll be happy
p37850
aVBut can it
p37851
aVNo, C# and VB, and to a lesser extent F#, are the primary languages for Visual Studio
p37852
aVMicrosoft support for IronPython has been dropped and it seems to be stagnating
p37853
aVIf you are just writing console based code then you may be OK with IronPython, but if you are doing any GUI work then I would not recommend it
p37854
aVEven then, the fact that the language no longer has MS backing leaves me with a bad feeling
p37855
aVI would not invest time and effort into writing IronPython code because I suspect that it will become a dead end
p37856
as(dp37857
g7
V505088
p37858
stp37859
a((dp37860
g2
(lp37861
VIf you are adamant that you do not want to use a struct then you will have to allocate the stack memory yourself with
p37862
aVBut then you will need to manage your local variables manually within that block of stack memory
p37863
aVI would not recommend that you do this
p37864
aVUse a struct
p37865
as(dp37866
g7
V505088
p37867
stp37868
a((dp37869
g2
(lp37870
VYou need to open the file again using , but this time passing  to indicate that you want to write to the file
p37871
aVI would also recommend using  to ensure that the file will be closed when you are finished writing to it
p37872
aVNaturally you may want to include newlines or other formatting in your output, but the basics are as above
p37873
aVThe same issue with closing your file applies to the reading code
p37874
aVThat should look like this:
p37875
as(dp37876
g7
V505088
p37877
stp37878
a((dp37879
g2
(lp37880
VThe problem here is that  is a function which receives a single integer parameter
p37881
aVThis code is therefore a compilation error:
p37882
aVYou cannot print a function
p37883
aVWhat you can do is call a function and print that function's return value
p37884
aVWhich is precisely what your second chunk of code does
p37885
aVHowever, since your function  ignores its input parameter, you could re-write the code like this:
p37886
aVNote that you still need to call the function using parentheses,
p37887
aVBut because there is no longer a parameter required, you can leave the parameter list empty
p37888
as(dp37889
g7
V505088
p37890
stp37891
a((dp37892
g2
(lp37893
VIn a situation like this the best approach is to try to open the document and detect failure
p37894
aVTrying to predict whether or not a file association is in place just leads to you reimplementing the shell execute APIs
p37895
aVIt's very hard to get that exactly right and rather needless since they already exist
p37896
as(dp37897
g7
V505088
p37898
stp37899
a((dp37900
g2
(lp37901
VWell, your fundamental problem is that you are returning a pointer to the stack allocated VLA
p37902
aVYou can't do that
p37903
aVPointers to local variables are only valid inside the scope of the function that declares them
p37904
aVYour code results in  Undefined Behaviour
p37905
aVAt least I am assuming that somewhere in the  in the real code is the line
p37906
aVYou'll need to use heap allocation, or pass a suitably sized buffer to the function
p37907
aVAs well as that, you only need +1 rather than +2 in the length calculation - there is only one null-terminator
p37908
as(dp37909
g7
V505088
p37910
stp37911
a((dp37912
g2
(lp37913
VThese symptoms indicate that you are calling the ANSI version of  but interpreting the returned value as Unicode
p37914
aVThe solution is to make sure you call the Unicode version of  instead
p37915
aVDo this by specifying  in your
p37916
as(dp37917
g7
V505088
p37918
stp37919
a((dp37920
g2
(lp37921
V appears to be legacy and no longer supported
p37922
aVAt least that's the case on my OS (Win7 x64)
p37923
aVAttempting to call  with  results in error code 1,
p37924
aVI believe that you will need to use  instead
p37925
aVMy advice in this situation is to attempt to call the API functions from C++ first
p37926
aVThat way you don't have to struggle with p/invoke and you know that all the structures and function prototypes are correct
p37927
aVOnce you have worked out how to call the particular API function then translate into p/invoke
p37928
aVAs an aside, you should be a little more careful about your p/invokes
p37929
aVTake care to use  to match , and make sure you use  so that you can query the error code with
p37930
aVSomething like this:
p37931
as(dp37932
g7
V505088
p37933
stp37934
a((dp37935
g2
(lp37936
VYou appear to be overcomplicating this
p37937
aVDefine a range type like this:
p37938
aVThen declare your array like this:
p37939
aVAnd that's it
p37940
aVFor whatever reason, you assert that you need to use a record here with operator overloading
p37941
aVBe that as it may, but you have pretty much identified that operator overloading implicit casts can not be used to shoehorn your type to be compatible with  and integer array indexing
p37942
aVI can't find any documentation that describes these scenarios, but it's pretty clear that the compiler won't let you do what you want
p37943
aVSo far as I can tell, you can rely on the implicit cast for actual parameters and the right hand side of assignment statements
p37944
aVHere is my minimal sample to demonstrate the options:
p37945
aVNotes:
p37946
aVIf you are supplying an implicit cast operator then there's no need to supply an explicit cast operator also
p37947
aVAn explicit cast will result in the implicit operator being called
p37948
aVI think a property on the record type results in more readable code than an explicit cast
p37949
as(dp37950
g7
V505088
p37951
stp37952
a((dp37953
g2
(lp37954
VA Delphi set is simply a collection of (possibly) related boolean flags
p37955
aVEach boolean flag corresponds to whether or not the matching ordinal value is in the set
p37956
aVYou could certainly pack a set into an integer value by representing the set as a bitset
p37957
aVOr you could create a textual representation of the set
p37958
aVHowever, both of these options leave you with no tractable ability to query the database at the SQL level
p37959
aVFor this reason I would advise you to represent each value in the set, i
p37960
ag192
aVeach boolean flag, as a separate field (i
p37961
ag192
aVcolumn) of the database table
p37962
aVThis gives you the most powerful representation of the data
p37963
as(dp37964
g7
V505088
p37965
stp37966
a((dp37967
g2
(lp37968
VC++
p37969
aVIt shall have a return type of int, but otherwise its type is
p37970
aVimplementation-defined
p37971
aVThat means that the return type must be int, but that the parameters to main can be implementation defined
p37972
aVSo there is scope for implementation specific parameters to main, but no scope for variation from an int return type
p37973
ag11735
aVC is more permissive over the allowable return types of main
p37974
aVIt does allow return types other than int
p37975
as(dp37976
g7
V505088
p37977
stp37978
a((dp37979
g2
(lp37980
VThe Windows API function you are looking for is
p37981
aVIf you subsequently need to convert these coordinates into screen relative coordinates, call
p37982
as(dp37983
g7
V505088
p37984
stp37985
a((dp37986
g2
(lp37987
VI'm slightly confused by the error message you report
p37988
aVThat is not the error message that your code produces
p37989
aVThe error message that is actually reported, for the code in your question, is:
p37990
aVE2010 Incompatible types: 'TActionBarStyle' and 'string'
p37991
aVLeaving that aside, the correct syntax for setting an action manager style at runtime is this:
p37992
aVNote that the  property is of type
p37993
aVThere are various instances of  descendents defined in the VCL, one per registered style
p37994
aVThese instances are all global variables defined in the interface section of a unit, one unit per instance
p37995
aVTo gain access to these style objects you will need to  the following units:
p37996
aVfor the  style
p37997
aVfor the  style
p37998
aVfor  the  style
p37999
aVYou will need to omit the  prefix on older versions of Delphi
p38000
aVThe form designer uses a piece of magic to make the style look like a string in the Object Inspector
p38001
aVIt has been implemented this way to make it feasible for you to register your own styles
p38002
as(dp38003
g7
V505088
p38004
stp38005
a((dp38006
g2
(lp38007
VThe cleanest approach is to call the Click method of the button
p38008
aVThis is better than the alternatives for these reasons:
p38009
aVYou could read the OnClick property, check that it was not nil, and then call the method
p38010
aVBut that seems rather pointless since the Click method already does just that
p38011
aVThere's no point duplicating this code
p38012
aVAnd you could call the event handler directly, but that would require your code to have knowledge of it
p38013
aVThat implies an undesirable level of coupling to the implementation details
p38014
aVCalling  replicates what actually happens when the user clicks
p38015
aVIt is what happens when the user presses the button
p38016
aVIt deals with any actions that are associated with the button, for example
p38017
aVIt sets the forms ModalResult property
p38018
aVAnd so on
p38019
as(dp38020
g7
V505088
p38021
stp38022
a((dp38023
g2
(lp38024
VFirst of all, as @Cosmin explains in some detail, the question does not concern overridden methods
p38025
aVThe question is about calling inherited methods
p38026
aVis the best you can do here
p38027
aVThis calls the  constructor passing the default  of
p38028
aVIn fact it may even be preferable to write:
p38029
aVand be quite explicit
p38030
aVMy assumption is that your code looks like this:
p38031
aVI read the documentation for the inherited keyword in an attempt to understand the difference between  and
p38032
aVThe best clues are contained in the following excerpts:
p38033
aVIf inherited is followed by the name of a member, it represents a normal method call
p38034
aVand
p38035
aVWhen inherited has no identifier after it, it refers to the inherited method with the same name as the enclosing method
p38036
aVIn this case, inherited takes no explicit parameters, but passes to the inherited method the same parameters with which the enclosing method was called
p38037
aVThis seems to hint that the two competing uses of  are treated differently
p38038
aVMy understanding is that  results in a call to a constructor with matching parameters
p38039
aVIn your case,  is parameterless and so the only matching constructor is that of
p38040
aVNote that none of the constructors of  can match since they all take parameters
p38041
aVOn the other hand, when you write  this is a normal method call
p38042
aVAnd so default parameters can be added to the method call
p38043
aVThe crucial point is that this variant allows calling inherited methods with non-matching parameter lists
p38044
aVIn my view, the  syntax with no following identifier should have been reserved for virtual methods
p38045
aVThe designers of  could have saved you from this unhappy fate
p38046
aVThe constructors of  should have been implemented like this:
p38047
aVThen the implementation for the parameterless constructor would simply be:
p38048
aVHad this decision been taken, the parameterless constructor declared in  would have been hidden from any derived classes and your code would work as you intended
p38049
aVThe problem you have encountered here is the result of an unhappy confluence of events involving overloading, default parameters, the parameterless constructor of  and the quirky syntax of  for constructors
p38050
aVWhilst writing  is highly readable and concise, it simply leads to confusion when overloaded methods are in play
p38051
as(dp38052
g7
V505088
p38053
stp38054
a((dp38055
g2
(lp38056
VIn Windows 7 the start button, which has class name , is a child of the desktop window
p38057
aVYour code assumes that the start button is a child of the window named  which does indeed appear to be the way the taskbar and start menu were implemented on XP
p38058
aVFor Windows 7 you want to use something like this:
p38059
aVAlthough I think it would be better search for it by name to be sure that you get the right button
p38060
aVI'm not sure how Vista implements its taskbar and start menu, but you can use Spy++ to find out
p38061
aVHaving said all of this, it would be much better if you can find a way to achieve your goals without poking around in such implementation specific details
p38062
as(dp38063
g7
V505088
p38064
stp38065
a((dp38066
g2
(lp38067
VIt's pretty simple in modern Delphi
p38068
aVIt's all built in
p38069
aVDrop a  onto the form and load the animated GIF into the Picture property
p38070
aVThen, start the animation by means of the  property:
p38071
aVYou can control the animation with  and
p38072
aVIt should be pretty easy to guess how to switch the animation off again
p38073
aVNow, since you are using Delphi 7, you don't have the  component built-in
p38074
aVHowever, you can download the code from Finn Tolderlund's website (you want the latest version of )
p38075
aVWith this version of the component, the code above should work fine, although I personally have not used it since I ported from D6 to D2010 a few years back
p38076
aVAll these various  codes are really just versions of the same component, originally written by Anders Melander and, in 2007, donated to Embarcadero for inclusion in Delphi
p38077
as(dp38078
g7
V505088
p38079
stp38080
a((dp38081
g2
(lp38082
VIf you are in control of the DLLs and you don't want to load them in order to check capability, then you could use the version resource to indicate capability
p38083
aVThis would require the host app to have knowledge of what was the minimum supported version for each optional DLL feature
p38084
aVYou can read the version resource cheaply without loading the DLL
p38085
aVIt is perfectly possible, and rather simple, to obtain the list of functions exported by a DLL with loading it into your process with LoadLibrary
p38086
aVThe dbghelp
p38087
aVdll system library provides services to do that
p38088
aVHowever, I suspect that is overkill for your situation
p38089
aVIf it is not a problem to load and unload the DLL then GetProcAddress is probably the preferred solution
p38090
aVIf there is some reason why you need to avoid loading the DLL in order to check capability, use the version resource to infer capability
p38091
aVIf you need to do this with legacy DLLs that do not have a meaningful version resource then use dbghelp
p38092
aVdll to find the exported functions
p38093
aVFor the sake of completeness, here is some code to read all the exported symbols from a DLL, without loading it with
p38094
as(dp38095
g7
V505088
p38096
stp38097
a((dp38098
g2
(lp38099
VIt's clearly a bug in the VCL
p38100
aVThe problem appears to be that modifying the  property of a button from an event handler attached to that button does not change the visual appearance of the button
p38101
aVThe button's behaviour is changed (you cannot click it if you set  to  this way), but the visuals do not indicate it
p38102
aVI submitted QC#103962 and no doubt a future update will fix the problem
p38103
aVIn the meantime I offer the following workaround:
p38104
aVThis will force the button's window handle to be recreated and this seems to be enough to get the visuals sorted
p38105
aVThere are probably alternative ways to work around this but this was all I have found so far
p38106
as(dp38107
g7
V505088
p38108
stp38109
a((dp38110
g2
(lp38111
VCOM would probably be my choice
p38112
aVHowever, if for some reason you wanted to avoid COM you could take a look at the very nifty Unmanaged Exports by Robert Giesecke
p38113
aVUnmanaged Exports is an MSBuild task that essentially allows you to export static functions from your
p38114
aVNet assemblies to be consumed as ordinary native DLL exports
p38115
as(dp38116
g7
V505088
p38117
stp38118
a((dp38119
g2
(lp38120
VIt's hard to be sure what is happening, but I will take a guess anyway
p38121
aVMost likely the value you pass to one of the  calls is negative
p38122
aVWhen this happens,  (and hence ) will be
p38123
aVThe output then will be compiler dependent
p38124
aVFor example on my compiler the output is:
p38125
as(dp38126
g7
V505088
p38127
stp38128
a((dp38129
g2
(lp38130
VOne explanation is that  holds the entire string but that you are looking at the debugger tooltip
p38131
aVIn older Delphi versions the debugger tooltip truncates at 128 characters for strings held in a variant
p38132
aVNote that the debugger tooltip for a plain  does not truncate at this length
p38133
aVTry showing the variant in a dialog box and you will see that the entire string is present
p38134
aVI checked this out on Delphi 6 and there was no truncation with your code (other than the debugger tooltip)
p38135
aVAndreas did likewise on Delphi 4 and Rodrigo did so with Delphi 5
p38136
aVI cannot imagine that it could really be the case that strings in a Delphi 5  are truncated at 128 characters
p38137
aVIf you really are seeing what you are report then I can think of the following explanations:
p38138
aVYour code is erroneously truncating the string, but you have not yet found the code that does this
p38139
aVOnly you can debug that
p38140
aVYou have a local bug private to your Delphi installation
p38141
aVAre you by any chance compiling your own RTL
p38142
as(dp38143
g7
V505088
p38144
stp38145
a((dp38146
g2
(lp38147
VAs I read the question you are asking to remove content from a file starting from the beginning of the file
p38148
aVIn other words you wish to delete content at the start of the file and shift the remaining content down
p38149
aVThis is not possible
p38150
aVYou can only truncate a file from the end, not from the beginning
p38151
aVYou will need to copy the remaining content into a new file, or copy it down yourself within the same file
p38152
aVHowever you do it there is no shortcut efficient way to do this
p38153
aVYou have to copy the data, for example as @kobik describes
p38154
aVRaymond Chen wrote a nice article on this topic: How do I delete bytes from the beginning of a file
p38155
aVJust for fun, here's a simple implementation of a stream based method to delete content from anywhere in the file
p38156
aVYou could use this with a read/write file stream
p38157
aVI've not tested the code, I'll leave that to you
p38158
as(dp38159
g7
V505088
p38160
stp38161
a((dp38162
g2
(lp38163
VIf you must do this with exceptions (and I don't think you should), then you need to have 3 separate try/catch blocks:
p38164
aVOnce an exception is thrown in your code you cannot restart execution in the middle of the  block
p38165
aVHaving said that I would always prefer to detect the null pointer with an  test rather than relying on exception handling for this non-exceptional condition
p38166
as(dp38167
g7
V505088
p38168
stp38169
a((dp38170
g2
(lp38171
VThere are no limitations
p38172
aVYou can send data as large as you like, subject to available memory constraints, using
p38173
as(dp38174
g7
V505088
p38175
stp38176
a((dp38177
g2
(lp38178
VIn the comments you indicate that the DLL takes a copy of the  pointers (and not the contents of the strings) and then modifies the contents of the strings after  returns
p38179
aVIn the face of this very unconventional interface design your only option is to take charge of the marshaling of the string parameters
p38180
aVYou cannot use  since the  passed to the native code is valid only during the pinvoke call
p38181
aVIt cannot be relied upon to be valid after the pinvoke call returns
p38182
aVSo your only solution is to pass the string parameters as
p38183
aVAllocate the memory with
p38184
aVPass the resulting  to
p38185
aVWhen you are sure the DLL is done with the pointer, deallocate with
p38186
as(dp38187
g7
V505088
p38188
stp38189
a((dp38190
g2
(lp38191
VAccording to this your problem is that this DLL is not compatible with DEP
p38192
aVYou'll need to disable DEP to workaround this but in the long term you should try to wean yourself off this particular dependency
p38193
as(dp38194
g7
V505088
p38195
stp38196
a((dp38197
g2
(lp38198
VTRadioGroup has no such functionality
p38199
aVWhat you can do is use a TGroupBox to contain your special controls
p38200
as(dp38201
g7
V505088
p38202
stp38203
a((dp38204
g2
(lp38205
VYou report a non-terminating recursive call sequence to
p38206
aVLooking at the code of  there are two candidates for a recursive call:
p38207
aVbeing equal to , or calling a function that in turn calls
p38208
aVAn event handler that responds to changes to  by calling
p38209
aVThese are the only opportunities for the code in  to call itself
p38210
aVIt is easy to see how both of these possibilities leads to the non-terminating recursive function call and eventually the stack overflow
p38211
aVOf the two candidates my bet is number 1
p38212
aVI would study carefully what happens when  is called
p38213
aVTo debug a stack overflow of this nature simply open the call stack window and look at the long sequence of calls
p38214
aVYou will typically see a pattern with one function calling itself, possibly via one or more intermediate functions
p38215
as(dp38216
g7
V505088
p38217
stp38218
a((dp38219
g2
(lp38220
V@TLama is correct that this is related to way the Windows tab control behaves when in multi-line view
p38221
aVThe behaviour you are observing is related to the way selection is handled for multi-line tabs
p38222
aVWhen you select a tab it is always shown in the bottom row because the visual cue to indicate which tab is selected can only really work for tabs in the bottom row
p38223
aVGiven that constraint the control simply has to rearrange rows of tabs as you modify the selected tab
p38224
aVIt's astoundingly confusing for the user
p38225
aVGood UI design never has UI elements changing position like this
p38226
aVClearly what is happening here is that the rearrangement is happening at runtime when the form is first shown and for whatever reason this is resulting in a different arrangement from the design time arrangement
p38227
aVGiven that the user can arrange the rows in any order just by selecting them I'm not sure you should worry about what order the rows appear in
p38228
aVIf you are dead set on forcing a particular arrangement when the form first shows you can add code like this to a  handler for the form:
p38229
aVBest practise for UI design is to avoid multi-line tab controls and I urge you to attempt to re-design your UI that way
p38230
as(dp38231
g7
V505088
p38232
stp38233
a((dp38234
g2
(lp38235
VThere is no such thing as an empty
p38236
aVA  has to have a value
p38237
aVIt is an ordinal type, a simple value type
p38238
aVJust as an integer, say, always has a value, so does a
p38239
aVThe value  is not an empty , it is the character with value 0, commonly known as
p38240
as(dp38241
g7
V505088
p38242
stp38243
a((dp38244
g2
(lp38245
VIt's perfectly safe to do this
p38246
aVThe reading thread will always read either true or false
p38247
aVThere will be no tearing because a  is just a single byte
p38248
aVIn fact the same is true for an aligned 32 bit value in a 32 bit process, i
p38249
ag192
aVThis is what is known as a benign race
p38250
aVThere is a race condition on the boolean variable since one thread reads whilst another thread writes, without synchronisation
p38251
aVBut the logic of this program is not adversely affected by the race
p38252
aVIn more complex scenarios, such a race could be harmful and then synchronisation would be needed
p38253
as(dp38254
g7
V505088
p38255
stp38256
a((dp38257
g2
(lp38258
VNo need to pin , it has value type semantics
p38259
aVIf the DLL writes to the address pointed to by , and does so after the original function returns, then you need to pin it one way or another (as well as keeping it alive and safe from the clutches of the GC)
p38260
aVThe callback function pointer is already effectively pinned
p38261
aVYou need to keep a reference to the delegate alive, but you don't need to pin it because the native thunk is allocated from the unmanged heap
p38262
aVYou don't need to do anything special here because you are passing an  and the memory behind that is pinned
p38263
aVYou don't need to to keep a reference to the string alive because it is completely disconnected from the  returned by
p38264
aVIt just has a copy of the contents of the string at the point of call to
p38265
aVI have to say that I am still incredulous that this DLL really could be doing what you say it is doing
p38266
aVI suspect that something else is going wrong which you are mis-diagnosing as the DLL holding onto pointer parameters from one call and then modifying their contents during subsequent calls
p38267
aVI find that exceptionally hard to believe, but of course only you can really know
p38268
aVIf I was in your position I would simply ask the question of the DLL vendor
p38269
as(dp38270
g7
V505088
p38271
stp38272
a((dp38273
g2
(lp38274
VWell, it's the  test that is truncating the lines at 16 characters
p38275
aVI believe that Notepad does the same as this code:
p38276
aVIf you want to replace non-printable characters with  then you can easily do so by modifying the code above like this:
p38277
as(dp38278
g7
V505088
p38279
stp38280
a((dp38281
g2
(lp38282
VYou should use  for this
p38283
aVIt deals with the quadrants exactly as you need
p38284
aVLike so:
p38285
aVThe  statement is to deal with the fact that you want results in the range 0
p38286
aV360, but  gives angles in the range -180
p38287
aV180
p38288
aVYou can do this with  using the basic approach you have taken, but you've not quite debugged it yet
p38289
aVIn any case, everybody uses  for this
p38290
aVAlso, you may as well use  rather than rolling your own
p38291
as(dp38292
g7
V505088
p38293
stp38294
a((dp38295
g2
(lp38296
VError code 3 is
p38297
aVIt seems that you made a simple mistake in your file names: one of the directories in one of your file names does not exist
p38298
aVIn a comment, you state that the call that fails is of the form:
p38299
aVThis will certainly fail
p38300
aVWhat you are trying to do is pass  as the destination filename in order to delete the file
p38301
aVBut you are not passing , you are passing the empty string
p38302
aVIn order to pass  to the native API, call it like this:
p38303
aVI would make sure that you include  in your pinvoke so that you can diagnose errors
p38304
as(dp38305
g7
V505088
p38306
stp38307
a((dp38308
g2
(lp38309
VYour calls to GetLastError are simply incorrect
p38310
aVYou cannot indiscriminately call GetLastError like that
p38311
aVYou should only call it when the API call documentation says that it is valid to do so
p38312
aVUsually this will be if the API call reports failure
p38313
aVThe calls to DefWindowProc are a fine illustration of how this can go wrong
p38314
aVThe documentation for DefWindowProc does not make any mention of a way for the function to report failure
p38315
aVAnd it makes no mention of calling GetLastError
p38316
aVThus your calls to GetLastError should not be made and are returning undefined, meaningless values
p38317
aVSince there is no single common mechanism for a Win32 function to report failure, your attempt to wrap all Win32 API calls with a single common error handling routine is doomed to failure
p38318
aVWhat you need to do is to treat each API call on its own merits, and write error checking appropriate for that API call
p38319
aVSince you are using C++ I would recommend you make use of exceptions here
p38320
aVWrite a function, ThrowLastWin32Error say, that you call whenever an API function reports failure
p38321
aVThe implementation of ThrowLastWin32Error would call GetLastError and then call FormatMessage to obtain a textual description before throwing a suitably descriptive exception
p38322
aVYou would use it like this:
p38323
aVBut the main point is that you do need case-by-case checking of function success since different Win32 functions report failure in different ways
p38324
as(dp38325
g7
V505088
p38326
stp38327
a((dp38328
g2
(lp38329
VIn modern Delphi versions, on modern Windows versions,  results in a Windows dialog window
p38330
aVYou can use a  hook to catch the activation of that dialog window
p38331
aVNote that the actual window class name varies from system to system
p38332
aVOn XP the class name will be  because the dialog is actually a Delphi
p38333
aVHowever, on Vista and later the dialog is a standard window message box dialog with window class name
p38334
aVI've shown this wrapped around a single call to , but you could install this at startup if you want to hook all message dialogs shown in your app
p38335
as(dp38336
g7
V505088
p38337
stp38338
a((dp38339
g2
(lp38340
V and family return  to indicate that the strings are equal
p38341
aVYour logic is simply the wrong way around
p38342
aVYou should write the test like this:
p38343
aVAs an aside, the other two  statements, comparing with  and  are fine when compiling for ANSI, but are incorrect when compiling for Unicode
p38344
aVWhen compiling for Unicode,  will evaluate to a wide string and therefore not be a valid argument for
p38345
aVThat's a compile error
p38346
aVAnd  will also be a compile error because  would be a wide string
p38347
aVBut the cast would be completely bogus also
p38348
aVAnyway, I'm just mentioning these issues for completeness, but I do understand that these extra if statements were added whilst you were trying to debug the root problem
p38349
as(dp38350
g7
V505088
p38351
stp38352
a((dp38353
g2
(lp38354
VThe  component includes the  method for this purpose
p38355
aVThe full list of possible members of the  set is:
p38356
aVhtAbove
p38357
aVhtBelow
p38358
aVhtNowhere
p38359
aVhtOnItem
p38360
aVhtOnButton
p38361
aVhtOnIcon
p38362
aVhtOnIndent
p38363
aVhtOnLabel
p38364
aVhtOnRight
p38365
aVhtOnStateIcon
p38366
aVhtToLeft
p38367
aVhtToRight
p38368
as(dp38369
g7
V505088
p38370
stp38371
a((dp38372
g2
(lp38373
VProbably the closest Delphi analogue to  is
p38374
aVYou can iterate over the list with a  loop:
p38375
aVIf you have a dynamic array rather than a  then you can use  to iterate over the elements
p38376
aVIn fact, all the built in containers support  and it is easy to add support for  to your own classes
p38377
aVIn C++ there is nothing like a  loop and so the idiom is to use an STL algorithm
p38378
aVThat's what drives you to using an anonymous function
p38379
aVIn Delphi with the  syntax you can express "iterate over all members of the container" in a natural way without resorting to anonymous methods
p38380
aVGenerics were added to Delphi in Delphi 2009 and the  loop was added in Delphi 2005, so all this is available to you in XE
p38381
aVFor what it's worth, anonymous were also added in Delphi 2009
p38382
aVWhat you must realise is that Delphi generics are less powerful than C++ templates
p38383
aVAlthough you talk about a generic , your code is not generic in the sense that it has specialised to
p38384
aVYou could write a generic version of your code in C++ but this would be much harder to do with Delphi generics due to the inherent limitations of generics when compared to templates
p38385
aVAn attempt to write the above code in a generic way in Delphi would founder at the point where you tried to call
p38386
aVWhilst that would be trivial with C++ templates it is frustratingly out of reach for generics
p38387
aVUpdate: In the comments you ask if there is a slick way to add the contents of one container to another
p38388
aVThe  method does that
p38389
aVhas three overloaded variants that receive one of the following input parameters: ,  or
p38390
aVAll the standard generic containers follow a similar pattern
p38391
as(dp38392
g7
V505088
p38393
stp38394
a((dp38395
g2
(lp38396
VYou could to pass a reference to the form so that the button can in turn be referenced
p38397
aVHowever, any time you have a global scope function that takes as its first parameter a reference to an object, you have a candidate for a method of that object
p38398
aVSo, add a method to
p38399
aVAnd call it like this:
p38400
as(dp38401
g7
V505088
p38402
stp38403
a((dp38404
g2
(lp38405
VThere is nothing wrong with
p38406
aVIt does indeed modify the values in the caller's array
p38407
aVThe problem lies the printing function,
p38408
aVYou are using the wrong format string for your
p38409
aVYou need to use  rather than  since these are floating point values and not integers
p38410
as(dp38411
g7
V505088
p38412
stp38413
a((dp38414
g2
(lp38415
VYes, the linker will include just the translation units that your code references
p38416
aVIf you generate a map file for your executable then you can see exactly what it contains
p38417
as(dp38418
g7
V505088
p38419
stp38420
a((dp38421
g2
(lp38422
VYou need to make sure that your application includes a comctl32 v6 manifest to enable visual styles
p38423
aVThe simple way to do this is to add the following to your code:
p38424
as(dp38425
g7
V505088
p38426
stp38427
a((dp38428
g2
(lp38429
VYou can indeed create windows in threads other than the main UI thread
p38430
aVHowever, those windows will have affinity to the thread that created them and you will need to run a message pump in each and every thread that creates windows
p38431
aVSo whilst you can do what you ask, Win32 is really designed to work with all windows in a process having affinity to the same thread
p38432
aVThere's really nothing to be gained from creating multiple UI threads
p38433
aVAll you will succeed in doing is making your life extraordinarily and needlessly complex
p38434
as(dp38435
g7
V505088
p38436
stp38437
a((dp38438
g2
(lp38439
VAre local writable constants are exactly the same as declaring a global writable constant
p38440
aVThe only difference is the scope
p38441
aVThe global variable is, well, global, and the local variable has local scope
p38442
aVWriteable typed constants are a reasonable approximation to C static local variables
p38443
aVThe enormous disadvantage of writable typed constants is that there is no keyword support like in C and you have to use a compiler option to toggle the meaning of the language
p38444
aVIn my view this makes writable typed constants effectively useless
p38445
as(dp38446
g7
V505088
p38447
stp38448
a((dp38449
g2
(lp38450
VWell, it can only be done by leaking a pointer to the writeable typed constant
p38451
aVHere is an example that takes a rather convoluted way to print the number of the beast:
p38452
aVSince the scope of a local is confined to the function in which it is defined, the approach outlined above is the only possible solution
p38453
as(dp38454
g7
V505088
p38455
stp38456
a((dp38457
g2
(lp38458
VSo obviously this happens, but I can't understand why the language works that way -- what the logic is behind the language that makes this a valuable way of operating
p38459
aVI think it'd be helpful for me moving forward to understand why this is, rather than just "that's the way it works
p38460
aVThe language needs some way to distinguish between the function and the act of calling the function
p38461
aVThat is what the parentheses provide
p38462
aVNow  is bound to the function itself
p38463
aVThe function  could be executed by
p38464
aVThis calls the function  and binds the return value to
p38465
aVNote that whether or not you bind the return value to a name is irrelevant
p38466
aVSimply writing
p38467
aVwill also execute the function but the return value will simply be ignored
p38468
as(dp38469
g7
V505088
p38470
stp38471
a((dp38472
g2
(lp38473
VFor the variable declaration the problem is that the variable name and the type are the same
p38474
aVYou could solve the problem by qualifying the type:
p38475
aVAnd you may need to do the same in the cast if your real code has a variable named  visible at the point at which you call GetWindowText:
p38476
aVThe issue is that your variable declaration is hiding  and replacing it with the variable named
p38477
aVPerhaps easier would be to avoid the name clash in the first place:
p38478
as(dp38479
g7
V505088
p38480
stp38481
a((dp38482
g2
(lp38483
V is not exactly representable in binary floating point arithmetic
p38484
aVThe computer stores the nearest number that is exactly representable in binary floating point format
p38485
as(dp38486
g7
V505088
p38487
stp38488
a((dp38489
g2
(lp38490
VThe correct way to synthesize input on Windows is to call
p38491
aVYou can sometimes achieve limited success with
p38492
aVAs for , that's something completely unrelated to what you are attempting to do
p38493
as(dp38494
g7
V505088
p38495
stp38496
a((dp38497
g2
(lp38498
VYour program exhibits undefined behaviour
p38499
aVIn short anything can happen, including your program appearing to work
p38500
aVIt's quite common that implementations of malloc/free do not return memory blocks to the underlying OS immediately after you call
p38501
aVThis is done for performance reasons
p38502
aVThe next call to  may well be most efficiently be handled by returning a pointer to the block that you just freed and therefore re-using it
p38503
aVAt this point, in your code, there would be two pointers referring to the same block of memory and who knows what would happen next
p38504
as(dp38505
g7
V505088
p38506
stp38507
a((dp38508
g2
(lp38509
V is a perfectly plausible way to do it
p38510
aVThis is implemented as:
p38511
aVThe change you are seeing is, of course, really due to the Unicode changes in D2009 rather than changes to variants
p38512
aVYour string will be , aka
p38513
aVOf course,  also picks up  and
p38514
aVIf you want a truly faithful conversion of your Delphi 2007 code then you would write:
p38515
aVExactly what you need to do, only you can know, but the key thing is that you have to account for the newly arrived
p38516
as(dp38517
g7
V505088
p38518
stp38519
a((dp38520
g2
(lp38521
V is an unsigned 32 bit integer, so  is technically correct
p38522
aVThe version that uses  was presumably done that way through mild laze
p38523
aVThe author presumably wanted not to have to cast the return value of  to
p38524
aVIn practice it simply does not matter here because the  will never get to the point where the conversion from signed to unsigned makes any difference
p38525
aVHowever, in some cases it can matter
p38526
aVFor example, a variable that held a combination of bit flags
p38527
as(dp38528
g7
V505088
p38529
stp38530
a((dp38531
g2
(lp38532
VWhilst you can delete a directory this way, it's simpler to let the system do it for you by calling  passing
p38533
aVRemember that you must double null-terminate the string you pass to this API
p38534
as(dp38535
g7
V505088
p38536
stp38537
a((dp38538
g2
(lp38539
VCall  passing  as the  parameter
p38540
aVYou will also need a handle to the service, but  gives you one of those
p38541
as(dp38542
g7
V505088
p38543
stp38544
a((dp38545
g2
(lp38546
VYou are seeding the pseudo-random number generator with the same seed each time around the look
p38547
aVSimply move the call to  outside the loop
p38548
aVA pseudo-random number generator (PRNG) is deterministic
p38549
aVThat is, given the same initial seed, it will return the same sequence of numbers each time is is called
p38550
aVIn your code, since you seed every time you call , you get the same sequence of 1 number for every iteration of your loop
p38551
aVNow, different executions of the program will have different results, because  will have changed
p38552
aVAnd in the cases when you were not seeing 100% heads or 100% tails, that would be when the loop took sufficiently long for time to have advanced
p38553
as(dp38554
g7
V505088
p38555
stp38556
a((dp38557
g2
(lp38558
VThere are some limits on the length of the names passed to , but these are typically greater than 512 characters
p38559
aVIt seems you just need to dynamically allocate the names rather than using a static char array
p38560
aVIf you want to go to the ultimate command line length then you can use  which has a limit of 32,768 characters
p38561
aVAs another option you could consider writing the list of arguments to a temporary file
p38562
aVThen you would modify the external program so that it is capable of being passed the path to that file as its command line argument
p38563
aVYou would obviously need to also modify the external program so that it could read the file and obtain the long list of files from the temporary file
p38564
as(dp38565
g7
V505088
p38566
stp38567
a((dp38568
g2
(lp38569
VIn Unicode Delphi,  maps to the Unicode version  which has the following signature:
p38570
aVSo you need to supply an ANSI output buffer but your code provides a Unicode output buffer
p38571
aVThe natural conversion is to switch to an  return value
p38572
aVAt the same time renamed the function as  to better reflect what it does
p38573
aVAn alternative would be to convert to OEM in place, but for this you need to pass in an ANSI string and call the ANSI version of the API call explicitly
p38574
aVI do have to comment that I am surprised to see the OEM character set still being actively used in the modern day
p38575
aVI thought it had gone the way of the dinosaurs
p38576
as(dp38577
g7
V505088
p38578
stp38579
a((dp38580
g2
(lp38581
VThe  function is declared in both the  and  units
p38582
aVIt doesn't much matter which you use, but if your program does not currently reference  then it makes more sense to use  in order to gain access to this function
p38583
as(dp38584
g7
V505088
p38585
stp38586
a((dp38587
g2
(lp38588
VMost likely cause for the error is that the C++ code uses  calling convention but your pinvoke uses  calling convention
p38589
aVChange the pinvoke as follows:
p38590
aVThere's no need to specify  for a function that has no text parameters
p38591
aVI also would use  as the return type since  is unsigned
p38592
aVThere may be more problems with your code because we can't see how you are calling the function and we also don't know what the protocol is for calling it
p38593
aVYou need to know more than the function signature in order to know how to call a function
p38594
aVHowever, I suspect that the calling convention problem will get you past your current hurdle
p38595
as(dp38596
g7
V505088
p38597
stp38598
a((dp38599
g2
(lp38600
VI've had no trouble ever installing many different versions of Delphi on the same machine
p38601
aVIt's a well supported configuration because, for example, component vendors need to be able to test all versions that they support
p38602
aVYou can use one VM per Delphi, but you can equally well put all the versions of Delphi on the same machine
p38603
aVWhen I put multiple Delphi versions onto a single machine I make sure that no version of Delphi is in the system PATH
p38604
aVThen when I do automated command line builds I add to the PATH at the start of the build script
p38605
aVThat way I am sure I always get the desired version
p38606
as(dp38607
g7
V505088
p38608
stp38609
a((dp38610
g2
(lp38611
VYou would typically use a function pointer variable
p38612
aVFor example:
p38613
aVThis is the most simple example imaginable
p38614
aVYou can specify procedural types that have parameter list, method of object types and so on
p38615
aVRead more in the Procedural Types topic of the language guide
p38616
as(dp38617
g7
V505088
p38618
stp38619
a((dp38620
g2
(lp38621
VTo answer the question you need to check how  and  are implemented for this class
p38622
aVThey look like this:
p38623
aVThis means that the lifetime of the object is managed by interface reference counting
p38624
aVWhich means that your code is correct and does not leak
p38625
aVNote that if you had passed an  in the constructor then the lifetime would be managed by that owner instead
p38626
aVYour code is still somewhat liable to leaking if the setting of  raises
p38627
aVI would write it like this:
p38628
aVHaving said all of that, the  class does not support  so perhaps your actual code looks slightly different
p38629
as(dp38630
g7
V505088
p38631
stp38632
a((dp38633
g2
(lp38634
VFor an EXE file there is no need for the relocation table because the executable image is always loaded at its preferred address
p38635
aVThe relocation table can safely be stripped
p38636
as(dp38637
g7
V505088
p38638
stp38639
a((dp38640
g2
(lp38641
VThe application will be getting hold of the APPDATA path via one of the system APIs, e
p38642
ag217
aVSHGetFolderPath, rather than reading the environment variable
p38643
aVThere's nothing simple that you can do to change its behaviour
p38644
as(dp38645
g7
V505088
p38646
stp38647
a((dp38648
g2
(lp38649
VAssuming a simple rectangular range then you use the  and  properties of the  object
p38650
aVThe top-left of the selection is determined by  and
p38651
aVThe number of selected rows and columns is given by  and
p38652
aVIn complete generality an Excel range can be made up of multiple non-contiguous areas
p38653
aVIn this case you use the  property of  to iterate through the simple rectangular ranges that make up the complex range
p38654
aVTo illustrate consider the following code:
p38655
aVI have not actually tested this code so I hope I have remembered correctly that indexing is 1-based
p38656
as(dp38657
g7
V505088
p38658
stp38659
a((dp38660
g2
(lp38661
VPython tuples are immutable
p38662
aVFrom the documentation:
p38663
aVTuples, like strings, are immutable: it is not possible to assign to the individual items of a tuple (you can simulate much of the same effect with slicing and concatenation, though)
p38664
aVIt is also possible to create tuples which contain mutable objects, such as lists
p38665
aVThat's the principal thing that sets them apart from lists
p38666
aVWhich leads nicely on to one possible solution: use a list in place of the tuple:
p38667
as(dp38668
g7
V505088
p38669
stp38670
a((dp38671
g2
(lp38672
VA dynamic array variable is just a reference to the array
p38673
aVIt's stored in the record as a single pointer
p38674
aVSo you can continue with your current approach without any excessive copying
p38675
aVCopying an element to a temporary variable only copies a reference to the array and does not copy the array's contents
p38676
aVAnd even better, if you are assigning to the array's items then you don't need the copy at all
p38677
aVYou can write:
p38678
aVIf you do have a record that really is big then you would be better using a class rather than a record
p38679
aVBecause an instance of a class is a reference, the same argument as above applies
p38680
aVFor this approach you may prefer TObjectList<> to TList<>
p38681
aVThe advantage of TObjectList<> is that you can set the OwnsObjects property to True and let the list be in charge of  destroying its members
p38682
aVYou could then write
p38683
as(dp38684
g7
V505088
p38685
stp38686
a((dp38687
g2
(lp38688
VDisclaimer: I personally would never use this code and could never recommend or condone its use
p38689
aVDo it like this:
p38690
aVOf course this is still unsafe since it will only work if what you put into  is in fact compatible with the method
p38691
aVSerg asks:
p38692
aVHow will you call your Test2 without creating a dummy instance of TSomething
p38693
aVI suppose you can do it like this, for static (i
p38694
ag192
aVnon-virtual and non-dynamic) methods:
p38695
aVOf course all this illustrates what a grotesque hack this is
p38696
aVI think this is no better than the version in your question
p38697
aVThere's no real clean way to do what you ask
p38698
aVI suspect that the correct way to solve your real problem would be to use RTTI to call the method
p38699
as(dp38700
g7
V505088
p38701
stp38702
a((dp38703
g2
(lp38704
VIt is not possible to move a running process from one session to another
p38705
as(dp38706
g7
V505088
p38707
stp38708
a((dp38709
g2
(lp38710
VThe problem is that the Delphi version of the callback is an instance method
p38711
aVYour C++ callback it not
p38712
aVThis is a significant mismatch
p38713
aVThis Delphi interface is badly designed and not callable from C++ without some trickery
p38714
aVA Delphi instance method is passed as two pointers, one to the code and one to the instance
p38715
aVYou can fake this in C++ by declaring the  function like this:
p38716
aVThen, once you have loaded it with , call it like this:
p38717
aVIt doesn't matter what the  parameter is since we are going to ignore that when it is passed on to
p38718
aVThe final step is to arrange that your function behaves like a Delphi instance method
p38719
aVDo that by adding an extra parameter to represent the instance
p38720
aVYou will receive in the  parameter, whatever you passed as the  parameter when you called
p38721
aVWith these changes you should be able to fake out the Delphi DLL into believing that your code is a Delphi instance method
p38722
aVFor reference I suggest your read the Program Control topic of the Delphi Language Guide
p38723
aVFinally, good luck
p38724
aVUpdate
p38725
aVThe latest edit to the question sheds some new light on what is happening
p38726
aVSpecifically this code:
p38727
aVThe  parameter results in just the code part of the method
p38728
aVThat is it is just a single pointer
p38729
aVThe instance is passed in the following parameter with
p38730
aVThe assumption that the author of this code has made is that the callback function will be passed three parameters, the user data followed by the two by var bytes
p38731
aVThe trick is that such a function is equivalent to a method call because a method call is implemented behind the scenes by passing the instance as a hidden, implicit, parameter before the actual parameters
p38732
aVSo, I believe you can solve the problem quite easily
p38733
aVSimply roll all the way back to where your code was when you asked the question
p38734
aVThen change your callback function to accept this extra parameter:
p38735
aVI am now confident that this will work
p38736
aVYou call the register function like this:
p38737
aVand your callback function should see the value of  in the  parameter
p38738
as(dp38739
g7
V505088
p38740
stp38741
a((dp38742
g2
(lp38743
VYou are looking for
p38744
as(dp38745
g7
V505088
p38746
stp38747
a((dp38748
g2
(lp38749
VIt looks like you are looking for a flexible container that has no methods and can take attributes with arbitrary names
p38750
aVThat's a
p38751
aVIf you prefer the attribute syntax that you get with a class (), then use a class just as per the code in your question
p38752
as(dp38753
g7
V505088
p38754
stp38755
a((dp38756
g2
(lp38757
V32 and 64 bit COM servers are registered in different registry views
p38758
aVSo the 32 bit processes and 64 bit processes exist in disjoint GUID namespaces
p38759
aVIn other words you use the same GUID for both 32 and 64 bit versions
p38760
aVThe registry redirector does the rest
p38761
as(dp38762
g7
V505088
p38763
stp38764
a((dp38765
g2
(lp38766
VYou need to install the  design time package
p38767
as(dp38768
g7
V505088
p38769
stp38770
a((dp38771
g2
(lp38772
VIn my experience you may be able to gain greater performance benefits by switching to a better eigensolver
p38773
aVThe best solver that I know of is ARPACK
p38774
aVYou will gain most benefit it your matrices have some structure, for example if they are sparse
p38775
aVThis solver is also most efficient if you only need to extract a small fraction of the total number of eigenpairs
p38776
aVI would start off by trying this solver on your problems running just on the CPU
p38777
aVYou may find that this alone gives sufficient performance for your needs
p38778
aVIf not then it is relatively easy to move the calculation core for ARPACK to the GPU
p38779
aVOr, there are parallel versions of ARPACK available
p38780
as(dp38781
g7
V505088
p38782
stp38783
a((dp38784
g2
(lp38785
VI guess your problem is that your program does not compile
p38786
aVHere is a version that does:
p38787
aVIn C#, in order to define methods, you need to define a class
p38788
aVThat was missing in your code
p38789
aVThe other significant problem is that C# is sensitive to the case of text
p38790
aVThat is, upper-case and lower-case text is treated as different by the compiler
p38791
aVFor example, the class is named  rather than , and so on
p38792
aVYour textbook will contain all this information and I suggest you revise the introductory sections of that book
p38793
aVYou ask how to make the text move around the screen
p38794
aVDo you mean like this
p38795
as(dp38796
g7
V505088
p38797
stp38798
a((dp38799
g2
(lp38800
VAttributeError: 'NoneType' object has no attribute 'returngene'
p38801
aVThis error happens when you try to access an attribute on the special  object
p38802
aVIn your case you are trying to read the method  in order to call it
p38803
aVClearly   evaluates to
p38804
aVYour next step is to work out why  evaluates to
p38805
aVPresumably one of the items that you appended to  was
p38806
aVAnd following that through we conclude that one of
p38807
aVor
p38808
aVreturns
p38809
aVNow you know why this error occurs, you should be able to track down the root cause
p38810
as(dp38811
g7
V505088
p38812
stp38813
a((dp38814
g2
(lp38815
VYou are going to store your data in arrays and arrays are always stored on the heap
p38816
aVSo it doesn't matter whether or not you use structs or classes to hold those arrays
p38817
aVYou may well want to make sure that your data points are value types (i
p38818
ag192
aVstructs) so that arrays of data points can be allocated efficiently in contiguous blocks of memory
p38819
aVPerformance differences between heap and stack allocated memory are most likely to be seen with small objects that are allocated and deallocated in a short space of time
p38820
aVFor long-lived objects of the size you describe, I would expect there to be no difference in performance between stack and heap allocated memory
p38821
as(dp38822
g7
V505088
p38823
stp38824
a((dp38825
g2
(lp38826
VConceptually this is just rebinding a name
p38827
aVIt's no different from this:
p38828
aVand I'm sure you would not want that to be an error
p38829
as(dp38830
g7
V505088
p38831
stp38832
a((dp38833
g2
(lp38834
VYou should be able to avoid the flickering by using /
p38835
aVThe call to BeginUpdate suppresses UI updates until EndUpdate is called
p38836
as(dp38837
g7
V505088
p38838
stp38839
a((dp38840
g2
(lp38841
VIn your code, if  raises an exception then the  variable will not be assigned
p38842
aVAnd thus the finally will attempt to access an uninitialized variable
p38843
aVThe correct way to write the code is to make sure that the variable is assigned before you enter the  block
p38844
aVThis is the most fundamental lifetime management pattern in Delphi coding and you should commit it deeply to muscle memory
p38845
aVNote that if the constructor fails, then it will tidy up the partially constructed object before propagating the exception
p38846
aVThe new object reference,  in this code, is only assigned if the constructor completes successfully
p38847
aVI would hope that the examples you found were in fact written as per my code above and you somehow transcribed them incorrectly
p38848
aVIf they are written as per the question, then they are clearly in error
p38849
as(dp38850
g7
V505088
p38851
stp38852
a((dp38853
g2
(lp38854
VAn instance method cannot modify the instance variable on which the method was invoked
p38855
aVThat's because a method is passed a copy of the instance variable (the implicit Self parameter) rather than being passed a reference to the instance variable
p38856
as(dp38857
g7
V505088
p38858
stp38859
a((dp38860
g2
(lp38861
VThe keys in a TDictionary are unordered
p38862
aVThe class makes no guarantee over their order and the actual order that is used is not the order in which they are added
p38863
aVReversing the order of an unordered dictionary is a meaningless operation
p38864
aVDelphi does not come with an ordered dictionary class although there are third party classes available
p38865
aVIf your usage is relatively simple you may be able to manage with an extra list containing the keys in the desired order
p38866
as(dp38867
g7
V505088
p38868
stp38869
a((dp38870
g2
(lp38871
VThis is what I do:
p38872
as(dp38873
g7
V505088
p38874
stp38875
a((dp38876
g2
(lp38877
VIn order to answer this question definitively one would need to have the documentation of the interfaces
p38878
aVJust knowing their signatures is never enough information
p38879
aVWithout that documentation we have to make educated guesses, and so here goes
p38880
aVLet's focus first on
p38881
aVNote that the  parameter is marked as being both  and
p38882
aVThe other parameter is an array of GUIDs
p38883
aVMost likely you are meant to pass the length of your array as input via the  parameter
p38884
aVThis tells the function how many items it is safe for it to copy
p38885
aVIf you pass in a value for  that is insufficient for the entire array then the function will indicate that in the return value
p38886
aVWhen the function returns it will set  to be the actual length of the array
p38887
aVMost likely you can call it passing  for ,  for  and use that to determine the size of array actually needed
p38888
aVThis is a very common pattern, but you will need to read the documentation to be sure
p38889
aVNow, since you are not assigning to  before calling , you are passing a random value from the stack
p38890
aVThe fact that changes to the code further down affect the way the call to  behaves strongly supports this hypothesis
p38891
aVWith your implementation, and assuming my guess is correct, you should set  to  before calling
p38892
aVHowever, I would probably avoid using fixed size arrays and allocate dynamic arrays
p38893
aVYou would need to change the definition of  to take a pointer to the first item
p38894
aVI'd do this for all the arrays in the interface
p38895
aVOther than that I did notice that you had a couple of errors in
p38896
aVThe  function should be like this:
p38897
aVAnd you will find  more convenient written this way:
p38898
as(dp38899
g7
V505088
p38900
stp38901
a((dp38902
g2
(lp38903
VThe  documentation says this regarding the return value:
p38904
aVIf a message is available, the return value is nonzero
p38905
aVIf no messages are available, the return value is zero
p38906
aVWhen the message queue is empty, it will indeed return zero, i
p38907
ag192
aVThe conclusion therefore is that the message queue is never empty
p38908
aVAnd the most likely explanation for that is that one of the messages you handle in  leads to that same message being posted to the queue
p38909
as(dp38910
g7
V505088
p38911
stp38912
a((dp38913
g2
(lp38914
VThe  function is to be found in the  package
p38915
aVIf you do not have that package installed, then you will need to install it with  before you can use it
p38916
aVThen, when the package is installed, make it available with
p38917
aVAt which point you are good to go
p38918
as(dp38919
g7
V505088
p38920
stp38921
a((dp38922
g2
(lp38923
VYou get an invalid typecast exception because  is in fact the  and is not a
p38924
aVWhat this means is that you need to use a different event handler for each button if you are going to use
p38925
aVIn your situation it is clear that you should use the  event which does provide the button index
p38926
aVThere is a potential pitfall here, however, that you need to make sure you avoid
p38927
aVThe documentation states:
p38928
aVOccurs when a button is clicked, if the OnClick event is not present
p38929
aVIn other words the  event will only fire if you have not assigned an  event handler for either the button group or the button item
p38930
as(dp38931
g7
V505088
p38932
stp38933
a((dp38934
g2
(lp38935
VThis sounds like a classic case of you needing to deploy the runtime libraries of your tools to the machines which run the software
p38936
aVYour dev machines will have the necessary runtimes already
p38937
aVExactly how to do that depends on which compiler you are using
p38938
aVThe quick and dirty approach would be to link statically to the runtime
p38939
as(dp38940
g7
V505088
p38941
stp38942
a((dp38943
g2
(lp38944
VSomewhere else in your code you have something that looks like this:
p38945
aVThen when you write
p38946
aVthat is interpreted as meaning a function call on the object bound to , which is an
p38947
aVAnd that fails
p38948
aVThe problem is whatever code binds an  to the name
p38949
aVFind that and remove it
p38950
as(dp38951
g7
V505088
p38952
stp38953
a((dp38954
g2
(lp38955
VThat solution is perfectly possible and, in my view, is the only viable way to deal with a DLL that has global state that is not thread-safe
p38956
aVIt's not pretty, but it does work
p38957
as(dp38958
g7
V505088
p38959
stp38960
a((dp38961
g2
(lp38962
VIt's because when you switch to a class, the object is passed to the native code by reference rather than by value as it is for a
p38963
aVSo there is an extra level of indirection
p38964
aVYou'll need to remove that level of indirection in your pinvoke declaration
p38965
aVYou are probably passing using  at the moment
p38966
aVSimply remove the  when you switch from  to
p38967
as(dp38968
g7
V505088
p38969
stp38970
a((dp38971
g2
(lp38972
VYou need to build the DLL and output a detailed map file
p38973
aVThe settings in the linker options control map file output
p38974
aVThat map file will give you the start address of every function in your DLL and it should be easy enough to work it out from there
p38975
aVAnother option, if you can reproduce the error on a dev machine with Delphi installed, is to simply debug the DLL with the Delphi debugger
p38976
aVThis will break when the exception is raised and you will have even more information than just the identity of the troublesome function
p38977
as(dp38978
g7
V505088
p38979
stp38980
a((dp38981
g2
(lp38982
VYou can't write a standard Windows app like that
p38983
aVYou have to do your painting in response to  messages
p38984
aVIn Delphi terms this equates to overriding the  method of a  descendent, or perhaps using a  and providing an  event handler
p38985
aVI'm going to assume that you use a
p38986
aVIf you need to avoid flicker it is common practice to draw to an off-screen bitmap and then show this when you are asked to paint
p38987
aVYour application should probably use a timer control to provide a regular pulse
p38988
aVThen, on each pulse, update your off-screen bitmap
p38989
aVThen call  on your paint box to force a paint cycle
p38990
aVThe code might look like this:
p38991
as(dp38992
g7
V505088
p38993
stp38994
a((dp38995
g2
(lp38996
VYou have to wrap the C++ objects up in free functions:
p38997
aVand then export these from your DLL
p38998
aVAlternatively you can make use of the fact that you are compiling with C++/CLI and export a managed C++/CLI class which can be consumed directly by your C# code
p38999
as(dp39000
g7
V505088
p39001
stp39002
a((dp39003
g2
(lp39004
VCall  from the  unit
p39005
aVFor example:
p39006
as(dp39007
g7
V505088
p39008
stp39009
a((dp39010
g2
(lp39011
VNo, that's not going to work
p39012
aVFrom the documentation, with my emphasis:
p39013
aVPermits the user to dynamically intercept virtual method calls on specified instances of a particular class type
p39014
aVThe problem is that you need to get hold of each and every instance before you can proxify
p39015
aVBut you are hoping to proxify in order to get hold of instances
p39016
aVSo you are now caught in a chicken and egg scenario
p39017
as(dp39018
g7
V505088
p39019
stp39020
a((dp39021
g2
(lp39022
VYou need to specify the location of the
p39023
aVlib files
p39024
aVOtherwise  does not know where to find your
p39025
aVlib files
p39026
aVYou can do this either as command line arguments to  () or by setting the  environment variable
p39027
aVExactly where these
p39028
aVlib files are to be found depends on your installation
p39029
aVOpen a Visual Studio command prompt and type  to find out what is an appropriate setting for your installation
p39030
aVMyself I'd be trying to avoid having to use  for build automation since it has a pretty painful interface
p39031
aVI'd be looking for a higher level scripting language
p39032
aVI would also prefer to use  rather than calling  and  by hand
p39033
aVBut perhaps there is some good reason why you need to do this from C++ code that I am not aware of
p39034
as(dp39035
g7
V505088
p39036
stp39037
a((dp39038
g2
(lp39039
VDelphi XE2 pre-dates Windows 8 as you know
p39040
aVWindows 8 is not even finalised and the new WinRT is radically different from Win32
p39041
aVThere is no support for WinRT in XE2
p39042
aVAnyone who is using Delphi to create WinRT apps is doing an awful lot of low level hacking
p39043
aVThis is not a viable long term approach
p39044
aVAny code you may be able to produce this way will surely be thrown away when proper Delphi tooling arrives
p39045
aVSo, in my view, you will have to wait for official Delphi support, or use the MS tools
p39046
as(dp39047
g7
V505088
p39048
stp39049
a((dp39050
g2
(lp39051
VYou can find the exported function names with  or Dependency Walker
p39052
aVBut to know how to call the functions you really need a header file and some documentation
p39053
aVIf you don't have those then you will have to reverse engineer the DLL and that is a very challenging task
p39054
as(dp39055
g7
V505088
p39056
stp39057
a((dp39058
g2
(lp39059
VYou need to put the function body, i
p39060
ag192
aVthe definition, in the header file
p39061
aVYour header needs to read like this:
p39062
aVFoo
p39063
ag10393
aVAnd naturally you also have to remove the definition of  from
p39064
aVOr, if you prefer, you can write your header code like this:
p39065
aVFoo
p39066
ag10393
aVBut the bottom line is that if you need your function inlined, and available to other translation units, its definition must be placed in the header file
p39067
aVThe C++ FAQ explains this and even predicts your unresolved external error
p39068
as(dp39069
g7
V505088
p39070
stp39071
a((dp39072
g2
(lp39073
VIf you omit  then the default calling conventionm which is , will be used
p39074
aVSo you must include that
p39075
aVThe fact that you are using  does not change anything
p39076
aVThe default calling convention is , even for external imports
p39077
aVOf course, this only matters when compiling for 32 bit
p39078
aVOn x64 Windows there is a single calling convention specified in the ABI
p39079
aVOn x64 Windows, all calling conventions specified in code are ignored and all function calls are made with the Windows x64 calling convention
p39080
as(dp39081
g7
V505088
p39082
stp39083
a((dp39084
g2
(lp39085
VIt is the syntax used for generics
p39086
aVGenerics allow you to define classes that are parameterized by type
p39087
aVYou can read all about it in the Delphi documentation
p39088
aVYou may also find the Wikipedia page useful
p39089
aVIt gives a broader overview of the concept of generic programming
p39090
as(dp39091
g7
V505088
p39092
stp39093
a((dp39094
g2
(lp39095
VThere is no such standard dialog box
p39096
aVWhilst you could make one yourself, you should refrain from doing so since it would surely result in very confused users
p39097
as(dp39098
g7
V505088
p39099
stp39100
a((dp39101
g2
(lp39102
VThis is due to padding added because of record alignment
p39103
aVhas alignment of 4 since it contains  values
p39104
aVAnd so padding is added to the end of the record to make the size an exact multiple of 4
p39105
aVThat's why the size is 136 rather than the value of 134 that you were expecting
p39106
aVYou can declare your record to be , or, equivalently, set the alignment compiler option to
p39107
aVWith an alignment of  there will be no padding added to the record and
p39108
aVHowever, I strongly recommend you do not do this
p39109
aVUsing the natural alignment results in the most efficient memory access for records
p39110
aVFor example, it is more expensive for the processor to load a misaligned value than to load an aligned value
p39111
aVFor a  or an , the natural alignment is on a 4 byte bounday
p39112
aVFor a  the natural alignment is on an 8 byte boundary and so on
p39113
aVYou should use packed records if you need binary compatibility with another library that uses packed records
p39114
as(dp39115
g7
V505088
p39116
stp39117
a((dp39118
g2
(lp39119
VCTRL+ALT+DEL is the secure attention sequence (SAS) and you can't fake it with
p39120
aVThe  function is what you need to call
p39121
aVHowever, this is only available on Windows 7
p39122
aVFor older versions of Windows, if I recall correctly, you need to request a special library from MS in order to generate SAS
p39123
aVMy memory is failing me, but I think it is called SASLIB
p39124
aVThere is also a commercial product known as SasLibEx that does the job
p39125
aVYet another avenue if you need to support older versions of Windows is to look at the source code for VNC to see how they do it
p39126
as(dp39127
g7
V505088
p39128
stp39129
a((dp39130
g2
(lp39131
VI'm assuming you are referring to Windows
p39132
aVIf so then you need this:
p39133
aVThis returns the module handle of the module used to create the process
p39134
aVFind full details in the documentation for
p39135
aVIf you want the file name of the module, rather than the module handle, then you need  instead
p39136
as(dp39137
g7
V505088
p39138
stp39139
a((dp39140
g2
(lp39141
VNegative values indicate that you are passing special color values like  to
p39142
aVThat's a mistake
p39143
aVYou need to call  first in order to convert to a true RGB value
p39144
aVA true RGB value, stored in a 32 bit integer, will never be negative
p39145
aVOne other explanation is that you are putting ARGB values into a
p39146
aVThat's also a mistake because  does not hold an alpha channel
p39147
as(dp39148
g7
V505088
p39149
stp39150
a((dp39151
g2
(lp39152
VThat just reads a 4 byte integer from a pointer
p39153
aVIn managed
p39154
aVnet code you don't have pointers (unless you use unsafe code) so the framework provides tools to help interop between the native and managed world
p39155
aVThe documentation on MSDN for the
p39156
aVnet libraries is comprehensive and, of course, describes
p39157
aVThe extra complication here is that there is an additional offset of 4 bytes
p39158
aVIn reality the pointer is probably pointing to a struct and this code is picking out the integer value at offset 4 of the struct
p39159
aVThat's overwhelmingly the most likely explanation for the code being the way it is
p39160
aVNow, a literal translation would be:
p39161
aVbut you might alternatively write it in Delphi like this:
p39162
aVIf you know which message this  relates to then you will also know what the true  is to use here
p39163
aVAnd so you would not need to define a dedicated record since  would already do so
p39164
as(dp39165
g7
V505088
p39166
stp39167
a((dp39168
g2
(lp39169
VThese are the problems that are apparent to me:
p39170
aVYour  can modify the location to which  points
p39171
aVBut you fail to modify  accordingly and it is left pointing into the previous buffer
p39172
aVThat's clearly an error
p39173
aVI see potential for another error in that the  loop need not terminate and could run off the end of the buffer
p39174
aVThis is the most likely cause of your segmentation fault
p39175
aVThe way you use  is wrong
p39176
aVIf the call to  fails then you can no longer  the original buffer
p39177
aVYou should assign the return value of  to a temporary variable and check for errors before overwriting the  variable
p39178
aVYou should not call  on the pointer
p39179
aVSince that is meant to point into the block owned by , you call  on  alone
p39180
as(dp39181
g7
V505088
p39182
stp39183
a((dp39184
g2
(lp39185
VThe simple way to do what you ask is to write:
p39186
aVbut this will yield just the same results as your code
p39187
aVIn other words, reinterpreting the char array that you have does not result in the double value that you expect
p39188
aVYou need to look into the source of the char array
p39189
aVThe code that is creating the char array is where I would expect the problem to be
p39190
aVTo solve your problem you need to understand what the LabVIEW code is doing
p39191
as(dp39192
g7
V505088
p39193
stp39194
a((dp39195
g2
(lp39196
VIt is the type of the return value
p39197
as(dp39198
g7
V505088
p39199
stp39200
a((dp39201
g2
(lp39202
VThe documentation you link to is very sparse so to answer the question we need to guess somewhat
p39203
aVThe functions you need are these:
p39204
aVIn order to know for sure how to handle this we need more information:
p39205
aVWhat does the  macro evaluate to
p39206
aVI'm going to assume , but you will need to check your header file
p39207
aVWhat is
p39208
aVI'm going to assume  but you will need to check your header file
p39209
aVWhat is
p39210
aVI'm going to assume  or  but you will need to check your header file
p39211
aVWhat is
p39212
aVI'm going to assume  but you will need to check your header file
p39213
aVWhat character set is used
p39214
aVANSI or Unicode
p39215
aVI'm going to assume ANSI
p39216
aVYou are going to need to call  to find out how big a buffer you need
p39217
aVAnd then you will allocate that buffer and call  to populate it
p39218
aVYou will need to find out whether or not the value returned by  includes the zero-terminator or not
p39219
aVI'm assuming that it does not
p39220
aVWith these assumptions you would write the pinvoke like this:
p39221
aVYou can then call the functions like this:
p39222
aVSince we don't know all the details, there are a bunch of unknowns in this answer
p39223
aVYou have the header file, and you can contact the library vendor to resolve the unknowns
p39224
aVBut hopefully the outline above tells you what questions need to be answered
p39225
as(dp39226
g7
V505088
p39227
stp39228
a((dp39229
g2
(lp39230
VThere's no simple way to do this
p39231
aVYou have to read the entire file, make the modifications you need, and then re-write the file
p39232
aVYou cannot delete from the middle of a file any other way
p39233
aVAs a minor optimisation, you only need to re-write the part of the file following the first modification
p39234
aVBut you have to re-write the entirety after that
p39235
aVIf your deleted lines are towards the end of the file, then this could be a significant optimisation
p39236
aVFor this reason, large text files are not the best storage format if you want to make such modifications
p39237
aVA database would lead to better performance
p39238
as(dp39239
g7
V505088
p39240
stp39241
a((dp39242
g2
(lp39243
VYou have de-referenced the pointer 3 times
p39244
aVOnce when you treated it as an array and used the index , and then twice more with the  operator
p39245
aVIn order to be compatible with  you should de-reference only twice
p39246
aVTo be more explicit, let's break this down:
p39247
aVhas type
p39248
aVhas type
p39249
aVhas type
p39250
aVhas type
p39251
aVAnd clearly it follows that  is not assignment compatible with  which has type
p39252
aVAs to what your code really should be, I could not say for sure, but you will need to remove one level of indirection
p39253
as(dp39254
g7
V505088
p39255
stp39256
a((dp39257
g2
(lp39258
VThe error is because  is
p39259
aVThat's because  is failing
p39260
aVTo diagnose this further, you need to start paying attention to the return value of the API functions and checking error codes in case of failure
p39261
aVThat's your next step
p39262
aVAs an aside, you have declared the  variable incorrectly
p39263
aVIn the C header file it is declared as
p39264
aVThat's an unsigned 32 bit integer which makes it  in C#
p39265
aVI've not checked anything more than this
p39266
as(dp39267
g7
V505088
p39268
stp39269
a((dp39270
g2
(lp39271
VSome programs don't submit to input faking with  or
p39272
aVInstead you should fake input with
p39273
aVYou may find that a higher level approach using UI Automation is easier than faking input
p39274
as(dp39275
g7
V505088
p39276
stp39277
a((dp39278
g2
(lp39279
VYou can't do it with a typecast like that
p39280
aVThe  type is a struct containing two fields with fractional and integer parts of the number
p39281
aVYou need to call  to perform the conversion
p39282
aVIf ever you need to go in the opposite direction you can use the predictably named
p39283
as(dp39284
g7
V505088
p39285
stp39286
a((dp39287
g2
(lp39288
VThe Delphi RTL ignores you when pass 0 as the  parameter to  for a string
p39289
aVWhen you pass 0 or less for , the RTL uses a value of
p39290
aVSo what you are doing is benign in that there are no observable differences in behaviour between passing 1 or any value less than 1
p39291
aVHowever, it is certainly confusing to use  as a string index in Delphi and I would recommend not doing so
p39292
aVIn pseudo-code, the implementation of  starts like this:
p39293
aVIn fact the actual implementation is a little more complex, but the above pseudo-code gives the correct semantics
p39294
aVYour comment about the length being stored at index 0 is true for old style short strings
p39295
aVBut it is not true for long strings
p39296
aVIn fact it was this very fact that led to the rather odd situation whereby strings are 1-based, but dynamic arrays, lists etc
p39297
aVare 0-based
p39298
as(dp39299
g7
V505088
p39300
stp39301
a((dp39302
g2
(lp39303
VYou are passing , the handle of the executable module to the resource loading function
p39304
aVThat fails because the resource lives in the package module
p39305
aVTherefore you need to pass the module handle for the package
p39306
aVYou can obtain the module handle of the package like this:
p39307
aVIf you are loading your package dynamically then the call to  returned the module handle
p39308
aVUpdate: Remy's suggestion of using  is clearly a better way to obtain the module handle
p39309
as(dp39310
g7
V505088
p39311
stp39312
a((dp39313
g2
(lp39314
VCreate a new string, copy the contents into it, and then call the function that expects a modifiable string:
p39315
as(dp39316
g7
V505088
p39317
stp39318
a((dp39319
g2
(lp39320
VA smaller decimal type would be less capable
p39321
aVSince you don't tend to perform the same type of high volume calculations that are common with floating point data, there seems to be no need for a smaller decimal on grounds of performance
p39322
as(dp39323
g7
V505088
p39324
stp39325
a((dp39326
g2
(lp39327
VNote: This is an answer to the original question
p39328
aVAssuming you want the checksum to be stored in a variable of fixed size (i
p39329
ag192
aVan integer), you  cannot your second constraint
p39330
aVThe checksum must be unique (no collisions)
p39331
aVYou cannot avoid collisions because there will be more distinct strings than there are possible checksum values
p39332
as(dp39333
g7
V505088
p39334
stp39335
a((dp39336
g2
(lp39337
VIf you are prepared to use the Windows API then the easiest way to get this done is to call
p39338
aVUse the  operation and don't forget to double null-terminate your directory name
p39339
as(dp39340
g7
V505088
p39341
stp39342
a((dp39343
g2
(lp39344
VYou need to fully qualify the type name
p39345
aVFor example by using  in place
p39346
aVOr  in the unlikely event that you want the other one
p39347
as(dp39348
g7
V505088
p39349
stp39350
a((dp39351
g2
(lp39352
VThat method finds all the browsers that are registered as Start Menu Internet Applications
p39353
aVIn practice that will suffice since all the major browsers register themselves in this way
p39354
aVIf a browser fails to register itself as a Start Menu Internet Applications then it has no chance of Windows noticing it and offering that browser to the user
p39355
aVThe MSDN topic that explains it all is here: http://msdn
p39356
aVmicrosoft
p39357
aVcom/en-us/library/windows/desktop/dd203067
p39358
aVaspx
p39359
aVThe Start menu in Windows XP and Windows Vista contains reserved slots for the default Internet (browser) and E-mail (mail) clients, together commonly known as Start Menu Internet Applications
p39360
aVApplications which register as Start Menu Internet Applications do so across the entire system (per-machine)
p39361
aVIn Windows Vista, the user may use the Default Programs feature to set a per-user default
p39362
as(dp39363
g7
V505088
p39364
stp39365
a((dp39366
g2
(lp39367
VThere are two schools of thought
p39368
aVOne school of thought says that functions should have a single exit point
p39369
aVMany many coding standards enforce that as a rule
p39370
aVThe motivation for this comes from the hard experience of maintaining spaghetti code full of large functions with gotos, multiple exits and so on
p39371
aVThe other school of thought says that spaghetti code is bad but one should be pragmatic and judge coding styles on their merits rather than following dogmatic rules
p39372
aVFor example, many programmers feel that guard clauses are much preferable to the deeply indented functions that arise when you refrain from using
p39373
aVAs an illustration consider the following example from Martin Fowler's excellent refactoring catalog: Replace Nested Conditional with Guard Clauses
p39374
aVFundamentally it all comes down to personal preference
p39375
aVI personally encourage the use of guard clauses, but refrain from wild use of exit in long procedures
p39376
as(dp39377
g7
V505088
p39378
stp39379
a((dp39380
g2
(lp39381
VYou can't realistically expect to do this since you don't have control over the stack
p39382
aVThe JVM controls the stack and any so-called stack manipulation is just a vile hack
p39383
aVWithout JNI or something similar your best solution is probably to execute the C code in a separate process and use some form of IPC to communicate with it
p39384
as(dp39385
g7
V505088
p39386
stp39387
a((dp39388
g2
(lp39389
VThe API function you need is called RegLoadMUIStringW
p39390
aVThis is a Vista API so if you want to support XP you'll need to parse the registry entry manually
p39391
aVUpdate: Actually, SHLoadIndirectString looks like it could be your XP saviour
p39392
as(dp39393
g7
V505088
p39394
stp39395
a((dp39396
g2
(lp39397
VYour bubble sort is in fact not a bubble sort
p39398
aVIt only makes a single pass over the array
p39399
aVYou need to repeatedly pass over the array until you make a pass that does not result in a swap
p39400
aVAt that point you know that your array is ordered
p39401
aVMy preferred bubble sort implementation has an outer  loop
p39402
aVThe inner loop is just as you currently have
p39403
aVThe outer loop terminates when the latest inner loop execution failed to swap any items
p39404
aVOf course, I'd recommend using a better sorting algorithm in the long run, but this is probably a homework assignment
p39405
as(dp39406
g7
V505088
p39407
stp39408
a((dp39409
g2
(lp39410
VIn your latest update you ask why this does not compile:
p39411
aVThe reason that does not compile is that  is not a true constant
p39412
aVYou can write it like this:
p39413
aVbecause  is a true constant
p39414
aVI'm struggling to get a handle on what you are really trying to do, but my instincts tell me that a constant is not what you need
p39415
aVI think you are going to need to use variables that are initialized at startup
p39416
as(dp39417
g7
V505088
p39418
stp39419
a((dp39420
g2
(lp39421
Vevaluates to a list containing  elements, each element being
p39422
aVevaluates to a list containing  elements, each element being
p39423
aVThe relevant section of documentation is here: Sequence Types
p39424
aVThe  function returns an iterator that yields tuples
p39425
aVEach tuple contains an index and the associated item from
p39426
aVSo your code is equivalent to:
p39427
as(dp39428
g7
V505088
p39429
stp39430
a((dp39431
g2
(lp39432
Vshould be
p39433
aVAnd the if test is incorrect since chdir returns 0 on success
p39434
aVYou need
p39435
as(dp39436
g7
V505088
p39437
stp39438
a((dp39439
g2
(lp39440
VYou say that the C# code does not need to manipulate the struct
p39441
aVThat makes it a pretty simple problem to solve
p39442
aVYou can treat the struct pointer as an opaque pointer, that is an
p39443
aVFirst of all you add a new function to your native code:
p39444
aVThen in your C# code you call it like this:
p39445
aVNow declare  like this:
p39446
aVAnd call it all like this:
p39447
aVAnd of course you'll want to add another function named  to deallocate the struct's memory once you are done with it
p39448
as(dp39449
g7
V505088
p39450
stp39451
a((dp39452
g2
(lp39453
VThe problem in your second variant is that you have failed to open a sub key
p39454
aVYour  call operates at the root level of a particular hive
p39455
aVYou need it to be like this:
p39456
aVDone this way it's no different from your first variant (apart from the registry view)
p39457
aVI expect that using the appropriate registry view will lead to the solution to your other question
p39458
aVNaturally you'll want to add some error checking to the code above
p39459
as(dp39460
g7
V505088
p39461
stp39462
a((dp39463
g2
(lp39464
VYou can solve your problem most concisely with a predicate written using anonymous method syntax:
p39465
as(dp39466
g7
V505088
p39467
stp39468
a((dp39469
g2
(lp39470
VWhat you ask for is not easy to achieve
p39471
aVI created a simple project with two forms, a main form and a modal form
p39472
aVI then traced the messages (using Spy++) sent to each form when the main form was clicked whilst the modal form was active
p39473
aVRemember that the main form is disabled as part of the protocol for showing modal forms
p39474
aVThis means that Windows knows that the main form cannot receive focus and the window manager doesn't forward the click on to either form
p39475
aVThe messages that are sent are in order to perform the blinking effect of the modal form
p39476
aVModal form messages
p39477
aVMain form messages
p39478
aVI don't think there's anything here that you can realistically hook onto
p39479
aVThe best you could hope for would be to try and detect a repeated stream of  messages but I really would not attempt this
p39480
aVIn my opinion you need to look more closely at the fundamental problem
p39481
aVYou say that the modal form sometimes is beneath the main form
p39482
aVIn that case you are doing something wrong with your window ownership
p39483
aVThe main form should be the ultimate owner of your modal form and if that were so then it could never be beneath the main form
p39484
aVIn my view you simply need to fix your broken window ownership structure and the problems will disappear
p39485
as(dp39486
g7
V505088
p39487
stp39488
a((dp39489
g2
(lp39490
VYou are returning a pointer to the end of the buffer rather than a pointer to the start of the buffer
p39491
aVLook at the last two lines of the function:
p39492
aVClearly this returns a pointer to the null , i
p39493
ag192
aVthe empty string
p39494
aVSolve the problem by introducing a temporary pointer which you will use to step through the output buffer
p39495
aVThen you can return the pointer to the beginning of the output buffer
p39496
aVYou also need to allocate an extra char for the , as shown above
p39497
aVFinally, your calling code never frees the memory allocated by
p39498
as(dp39499
g7
V505088
p39500
stp39501
a((dp39502
g2
(lp39503
VUse the  method of
p39504
aVThis returns a C string, i
p39505
ag192
aVa pointer to a null-terminated character array
p39506
aVThis is fine if you are compiling for ANSI
p39507
aVIf you are compiling for Unicode then you should use  instead of
p39508
aVIf that's the case, just change to  and the call to  works exactly as written above
p39509
as(dp39510
g7
V505088
p39511
stp39512
a((dp39513
g2
(lp39514
VYou cannot cast between two unrelated interfaces, no matter whether their definition is identical or not
p39515
aVThe language simply does not allow that
p39516
aVTwo distinct interface declarations, even if they are identical, result in two distinct interfaces
p39517
aVYou need to change your design so that you only have a single interface and all clients and implementers of the interface refer to the same single interface
p39518
as(dp39519
g7
V505088
p39520
stp39521
a((dp39522
g2
(lp39523
VHere is a demo of the GPC code that you link to: getoptdemo
p39524
aVpas [koders
p39525
aVcom]
p39526
as(dp39527
g7
V505088
p39528
stp39529
a((dp39530
g2
(lp39531
VYou need to run all code interacts with your UI on the UI thread
p39532
aVThat's a hard rule of WinForms
p39533
aVIf you need to show UI, or interact with existing UI, from your thread, call either Invoke or BeginInvoke depending on whether you want synchronous or asynchronous operation
p39534
aVThese methods will execute the UI code on the UI thread
p39535
as(dp39536
g7
V505088
p39537
stp39538
a((dp39539
g2
(lp39540
VFirst of all, there needs to be space for the  field
p39541
aVIf you really want the record to have size 7810 bytes then you should remove that field
p39542
aVThe other byte will be due to internal alignment and padding of the  part of the variant record
p39543
aVI can't yet quite work out where it comes from
p39544
aVNo matter, you simply want to use a packed record to avoid any padding bytes
p39545
as(dp39546
g7
V505088
p39547
stp39548
a((dp39549
g2
(lp39550
VThe classes in  do not implement
p39551
aVYou will have to introduce it yourself in your derived classes and provide the standard implementations
p39552
aVOr find a different, third party, set of container classes to work with
p39553
aVFor example:
p39554
aVYou can then declare your specialised class:
p39555
aVRemember that you need to treat this class like any other that uses reference counted lifetime management
p39556
aVOnly refer to it through interfaces
p39557
aVYou'd really want to do some more work before  was useful
p39558
aVYou'd need to declare an  which would expose the list capabilities
p39559
aVIt would be something like this:
p39560
aVYou can then simply add  to the list of interfaces supported by  and the base class  would fulfil the interface contract
p39561
as(dp39562
g7
V505088
p39563
stp39564
a((dp39565
g2
(lp39566
VExecutive summary: Use an interposer class with runtime switching of behaviour
p39567
aVAlthough @kobik is using Delphi 5 and cannot do what I describe below, this answers fleshes out the supported way to change the VMT of an instance using
p39568
aVMason's comments inspired me to write this
p39569
aVI've only compiled this in my head so it will no doubt need debugging
p39570
aVSomething tells me that capturing  might not work, in which case you would need to write
p39571
aVUnless you use a VMT modifying based solution, you will have to create new instances (as per Mason's suggestion)
p39572
aVAnd this means that you will also have to modify all references to the image list instances at the same time that you create the new instances
p39573
aVIn my view that rules out any proposed solution based on instantiating replacement objects
p39574
aVSo, my conclusion is that to implement your proposed solution in full generality, you need runtime VMT modification
p39575
aVAnd if you don't have modern Delphi that provides such facilities in a supported way, you will need to hack the VMT
p39576
aVNow, modifying the VMT, even with virtual method interceptors, is rather distasteful, in my view
p39577
aVI think you are probably going about this the wrong way
p39578
aVI suggest that you use an interposer class (or some other sub-classing technique) and switch behaviour at runtime with a property of the sub-class
p39579
as(dp39580
g7
V505088
p39581
stp39582
a((dp39583
g2
(lp39584
VWindows ships with a C runtime in  msvcrt
p39585
aVdll
p39586
aVIf you are writing a self-contained program and want to call functions from the C standard library, then perhaps this is what you need
p39587
aVIf your program uses libraries that are linked against other C runtimes, this will be no good to you
p39588
aVBut in that case, you don't need to do anything special since your compiler/linker will make the C standard library available
p39589
aVIf you want to call functions in a C runtime used by one of the DLLs you load, that's a problem
p39590
aVThe runtime could be linked statically, or it could be one of many different dynamic runtimes
p39591
as(dp39592
g7
V505088
p39593
stp39594
a((dp39595
g2
(lp39596
VThose 3 characters are the UTF-8 BOM
p39597
aVThe BOM should not be there
p39598
aVI can't say where it comes from (perhaps it is from the file) but you need to remove it
p39599
aVThe fault is certainly at your end though
p39600
aVDon't be led astray by the fact that IE and the Webkit browsers display the page fine
p39601
aVThat just means that those browsers are being lenient
p39602
as(dp39603
g7
V505088
p39604
stp39605
a((dp39606
g2
(lp39607
VTo obtain the number of elements that an array contains, use
p39608
aVUse  and  to obtain the bounds of any Delphi array
p39609
aVUsing the latter approach, with  and , allows you to avoid assuming that an array is 0-based
p39610
as(dp39611
g7
V505088
p39612
stp39613
a((dp39614
g2
(lp39615
VCall ExpandEnvironmentStrings to expand environment variables
p39616
aVWhen you use cmd
p39617
aVexe, it performs the expansion for you
p39618
aVCreateProcess does not so you will need to do it before calling CreateProcess
p39619
aVAlternatively you could use ShellExecute which will expand environment strings
p39620
aVYour current code does not meet the contract of CreateProcess
p39621
aVThe second parameter must be a pointer to modifiable memory
p39622
aVYou can get away with this if you are using the ANSI API but when targetting Unicode you code is liable to fail
p39623
aVPass a pointer to modifiable memory rather than a pointer to a literal
p39624
aVIf you added a call to expand the environment variables then you would end up with a modifiable string
p39625
aVFinally, it looks like you are just trying to open a text file
p39626
aVWhy force the user to view it in Notepad
p39627
aVMy default editor for text files is not Notepad
p39628
aVI'd loath any program that forced Notepad on me
p39629
aVInstead let the shell open the file in the user's preferred editor
p39630
aVCall ShellExecute, use 'open' as the verb and pass the text file name as the file name parameter
p39631
aVOn the other hand, perhaps you know all this and this is just example code
p39632
aVIf so, please just ignore this advice
p39633
as(dp39634
g7
V505088
p39635
stp39636
a((dp39637
g2
(lp39638
VAt the point at which you call ,  is invalid since it was already freed when you called
p39639
aVThe code should be something like this pseudo-code:
p39640
aVOf course, since this is C++, you should be avoiding  and  altogether and  using
p39641
as(dp39642
g7
V505088
p39643
stp39644
a((dp39645
g2
(lp39646
VYour pinvoke is wrong
p39647
aVThe array parameter should not be passed by  since a  is already a reference
p39648
aVDo it like this:
p39649
aVNote that this will marshal from managed to native, and back again, all 16000 values, on each call to
p39650
aVIf that's too expensive then I think you will need to perform manual marshalling
p39651
as(dp39652
g7
V505088
p39653
stp39654
a((dp39655
g2
(lp39656
VYou could start off by writing a set of functions that allocated and initialized the various nested structures
p39657
aVAnd do likewise for your other structs
p39658
aVThen you can use these building blocks in concert with standard struct initializers:
p39659
aVIf you want to allocate your  on the heap instead of the stack, then you could write a  function in similar vein
p39660
aVThe advantage of this approach is that if you ever add fields to your struct, you can just add extra parameter to the  function and any clients of that struct will be forced by the compiler to provide the extra parameter
p39661
as(dp39662
g7
V505088
p39663
stp39664
a((dp39665
g2
(lp39666
VYour remote user's machine is expecting  for the decimal separator
p39667
aVWhen it encounters  the  exception is raised
p39668
aVOn a machine which expects  as the decimal separator (e
p39669
ag217
aVmost European and South American countries)  is indeed not a valid floating point value
p39670
aVNormally I would expect to see a comma where the decimal point is, or some other locale specific punctuation problem, but the number appears fine in this case
p39671
aVYour current problem is just the flip-side of the above issue
p39672
aVNormally, because your locale uses  as the separator, you are accustomed to seeing problems when data with  is used instead
p39673
aVPut yourselves in the position of somebody from a country which uses  as a separator
p39674
aVFor them, they will be accustomed to seeing exceptions when data with  is used
p39675
aVYou could solve the problem by normalising the input to use the same decimal separator as the the machine locale
p39676
aVOn a modern Delphi you could solve the problem by use the  overload that receives a  parameter and explicitly specify that  is to be used as the decimal separator for this conversion
p39677
aVUnfortunately that facility is not available in Delphi 6
p39678
as(dp39679
g7
V505088
p39680
stp39681
a((dp39682
g2
(lp39683
VNo, you cannot do that because a  is a static, compile time construct
p39684
aVIndeed the entire type system in C++ is static
p39685
aVYou could solve your problem with something like
p39686
as(dp39687
g7
V505088
p39688
stp39689
a((dp39690
g2
(lp39691
VTwo common causes for this:
p39692
aVMismatch of calling conventions
p39693
aVYour C# code uses the default of
p39694
aVPerhaps the native code uses
p39695
aVTry adding  to the  attribute
p39696
aVMismatch of parameter lists (see below)
p39697
aVDon't kid yourself that your code is alright because
p39698
aVnet 3
p39699
aV5 doesn't raise this error
p39700
aVThe error detection in
p39701
aVnet 4 is better which is why you only see the errors there
p39702
aVBut your code is broken in all
p39703
aVnet versions
p39704
aVThe native definition for your C++ virtual method is:
p39705
aVIt looks like you are passing the object pointer as the first parameter in your pinvoke call
p39706
aVI think that could work, although I don't know enough about how virtual functions are handled when exported to know whether that's a problem
p39707
aVPresumably you have exported a plain C function to instantiate objects
p39708
aVThe other problem that I see is that on Windows, C/C++  is 32 bits
p39709
aVA C#  is 64 bits
p39710
aVThis means that the correct declaration for  is as  in your C# code
p39711
as(dp39712
g7
V505088
p39713
stp39714
a((dp39715
g2
(lp39716
VThe analysis presented in your question is simply incorrect
p39717
aVIf it was correct, then  would be useless
p39718
aVNo, when you call a function imported with p/invoke, the DLL that is loaded stays loaded
p39719
aVThe p/invoke system does not load and unload DLLs on each and every call to the imported functions
p39720
as(dp39721
g7
V505088
p39722
stp39723
a((dp39724
g2
(lp39725
VInvariably questions such as these arise due to you running a 32 bit process and registry redirection meaning that the settings are made in the 32 bit registry view
p39726
aVSilent failure is probably actually success, but the settings are not being made where you expect
p39727
aVI expect you'll find your settings under HKLM\u005cSoftware
p39728
aVWow6432Node
p39729
aVWrite to the 64 bit view either by targetting AnyCPU or by using the RegistryView enumeration
p39730
aVThe code that copies files will fall foul of the file system redirector in much the same way
p39731
as(dp39732
g7
V505088
p39733
stp39734
a((dp39735
g2
(lp39736
VRaymond Chen's article on Windows Confidential describes how that value is calculated
p39737
aVThe most pertinent paragraph states:
p39738
aVThe Size on disk measurement is more complicated
p39739
aVIf the drive supports compression (as reported by the FILE_FILE_COMPRESSION flag returned by the GetVolumeInformation function) and the file is compressed or sparse (FILE_ATTRIBUTE_COMPRESSED, FILE_ATTRIBUTE_SPARSE_FILE), then the Size on disk for a file is the value reported by the GetCompressedFileSize function
p39740
aVThis reports the compressed size of the file (if compressed) or the size of the file minus the parts that were de-committed and logically treated as zero (if sparse)
p39741
aVIf the file is neither compressed nor sparse, then the Size on disk is the file size reported by the FindFirstFile function rounded up to the nearest cluster
p39742
as(dp39743
g7
V505088
p39744
stp39745
a((dp39746
g2
(lp39747
VYour final paragraph of your question contains the answer
p39748
aVThe service runs in the context of a specific user
p39749
aVYou need to make sure that this user can access the resource in question
p39750
aVIt's not uncommon to create dedicated users just for a particular service for this very reason
p39751
as(dp39752
g7
V505088
p39753
stp39754
a((dp39755
g2
(lp39756
VThe best source of information on VCL styles is Rodrigo Ruz's blog: http://theroadtodelphi
p39757
aVwordpress
p39758
aVcom/category/vcl-styles/
p39759
as(dp39760
g7
V505088
p39761
stp39762
a((dp39763
g2
(lp39764
VYou must pass to  a pointer to memory allocated by  or one of its friends
p39765
aVIn your code you are passing  which is a stack allocated variable
p39766
aVNote that you cannot modify the size of stack allocated data so if your code does need to modify the size of a variable then that variable must be allocated on the heap
p39767
as(dp39768
g7
V505088
p39769
stp39770
a((dp39771
g2
(lp39772
VI would get a Windows 2000 installation, perhaps in a VM
p39773
aVAnd then I'd run Dependency Viewer and load the DLL
p39774
aVThis will give you a list of the missing API functions
p39775
aVThe problems may well run deeper than this though
p39776
aVEven if the troublesome DLL is using an API function that exists in Windows 2000, it may be using specific functionality of that API function that are only available in later versions of Windows
p39777
aVYou may very well need to study this at the source code level
p39778
as(dp39779
g7
V505088
p39780
stp39781
a((dp39782
g2
(lp39783
VYou are not synchronizing access to  and that means you have a race on it
p39784
aVThat's why you have the error
p39785
aVFor illustrative purposes, you can avoid the race and keep this particular design by using
p39786
aVHowever, as others suggest, the alternative overload of  that provides a loop index is clearly a cleaner solution to this particular problem
p39787
aVBut when you get it working you will find that copying files is IO bound rather than processor bound and I predict that the parallel code will be slower than the serial code
p39788
as(dp39789
g7
V505088
p39790
stp39791
a((dp39792
g2
(lp39793
VYou cannot load a 32 bit module into a 64 bit process
p39794
aVEither run a 32 bit process, or compile your native module as a 64 bit module
p39795
as(dp39796
g7
V505088
p39797
stp39798
a((dp39799
g2
(lp39800
VI assume you want to know how to pass this single path to the  (type ) parameter of
p39801
aVThis parameter is described thus:
p39802
aVargv
p39803
aVIs a NULL terminated array of character pointers naming one or more paths that make up the file hierarchy
p39804
aVSo you need to create an array of length two whose elements are of type
p39805
aVPut your path in the first element and put NULL in the second element
p39806
aVLike this:
p39807
aVYou can now pass  to
p39808
as(dp39809
g7
V505088
p39810
stp39811
a((dp39812
g2
(lp39813
VYou need to include  rather than
p39814
aVWhen you include  it will, in turn, include
p39815
aVYou need to do it this way for the necessary macros to be in place that are needed to compile
p39816
aVIn this case,  is defined in  like this:
p39817
aVBut if you include  before including  then  is not defined
p39818
as(dp39819
g7
V505088
p39820
stp39821
a((dp39822
g2
(lp39823
VAlthough ctypes was only added to the standard Python distribution in version 2
p39824
aV5, it is available for earlier versions, including version 2
p39825
ag34876
aVYour only alternative to installing ctypes is to write a Python extension
p39826
as(dp39827
g7
V505088
p39828
stp39829
a((dp39830
g2
(lp39831
VYou are not assigning  and
p39832
aVThey need to be set like this:
p39833
aVThis line is no good:
p39834
aVThat will be accessing elements out of bounds, not least because  is not initialized
p39835
aVYou need that line of code inside three nested for loops
p39836
aVIndeed, you may as well roll the zeroising code into this too
p39837
aVAlso, all your memory freeing loops are wrong
p39838
aVInstead of
p39839
aVit should read
p39840
aVThat stray semicolon was killing you
p39841
aVYou also need to perform a check that the number of columns in  equals the number of rows in , i
p39842
ag192
aVtest that
p39843
aVOne final point
p39844
aVYou duplicate your code horribly here
p39845
aVDon't have three identical for loops to allocate a matrix and three identical for loops to deallocate
p39846
aVExtract those operations into helper functions which can be called from
p39847
aVThat's all that I can find
p39848
as(dp39849
g7
V505088
p39850
stp39851
a((dp39852
g2
(lp39853
VMy guess is that you have a mismatch between the  on your machine and the value stored in the
p39854
aVdfm file
p39855
aVWhen Delphi reads the
p39856
aVdfm file it will scale any dimensions according to the ratio of the
p39857
aVdfm file  and your machine's current
p39858
aVTypical values of  are 96dpi and 120dpi
p39859
aVNote that
p39860
aVNow, as for , the IDE will always write out the form order in consecutive values
p39861
aVSo, if you have any values missing in your
p39862
aVdfm file then the IDE will write out a different version of the  values
p39863
aVNote that you can't get Delphi to leave your
p39864
aVdfm file alone
p39865
aVOnce you make any modification to the design space, and save the form, Delphi will stream it out in its preferred format
p39866
aVThis is really an unavoidable consequence of the way
p39867
aVdfm files are handled
p39868
aVThe IDE never edits
p39869
aVdfm files directly in the same way it does with your
p39870
aVpas files
p39871
aVInstead it reads the
p39872
aVdfm file in, creates the components defined on the form, and assigns their properties
p39873
aVWhen the
p39874
aVdfm file needs to be saved again, the components are asked to stream themselves out
p39875
aVSo the underlying model that is holds the settings is a  instance (often a form for example) owned by the IDE rather than the
p39876
aVdfm file
p39877
as(dp39878
g7
V505088
p39879
stp39880
a((dp39881
g2
(lp39882
VYou have to store the contents of the word that you are writing somewhere
p39883
aVexpects a pointer to some memory in your process space
p39884
aVIf you don't want to use a variable, use a constant
p39885
aVPassing  fails because  is not a pointer to a word containing the value
p39886
aVIt is a pointer to address 99
p39887
aVI think you were trying to write  but you cannot take the address of a true constant
p39888
aVYou can make this more convenient by wrapping up the call to  in a helper methods
p39889
aVAlthough your question suggests that you want to write  values, it became apparent in out lengthy chat that you actually want to write byte sequences
p39890
aVWriting integer data types will lead to machine endianness confusion
p39891
aVSo instead I would do it using an open array of  to give the flexibility at the call site
p39892
aVYou can then call the code
p39893
as(dp39894
g7
V505088
p39895
stp39896
a((dp39897
g2
(lp39898
VThe Delphi equivalent is:
p39899
aVTake care to use  rather than  since in modern versions of Delphi the generic type  is aliased to the 2 byte
p39900
aVOf course if you are on pre-Unicode Delphi then this warning is not pertinent
p39901
aVThe biggest difference in the syntax is that all arrays in C have 0 as the lower bound
p39902
aVIn Delphi you can specify whatever lower-bound you wish
p39903
aVNaturally to match the C code we specify 0 as our lower-bound
p39904
as(dp39905
g7
V505088
p39906
stp39907
a((dp39908
g2
(lp39909
VThere are two versions of the image list controls
p39910
aVThe v5
p39911
aV8 version and the v6 version
p39912
aVThe system image list is a shared coonent owned by the system and uses the v6 version
p39913
aVIt's not special in any other way, it's just a plain v6 images list
p39914
aVIn your app, your image list is either v5
p39915
aV8 or v6 depending on whether or not you include the manifest
p39916
aVBut the system owned image list is always v6
p39917
aVI don't know why you don't want to use v6 common controls in your app
p39918
aVBut with that constraint you could use the activation context API to locally use v6 common controls just while you create your image list
p39919
aVThat would solve your problem and leave the rest of your app with v5
p39920
aV8 common controls
p39921
as(dp39922
g7
V505088
p39923
stp39924
a((dp39925
g2
(lp39926
VHere's a translation of the assembler code given on an Intel blog:
p39927
aVThis code will work in both 32 and 64 bit versions of Delphi
p39928
aVUpdate: Register saving code added thanks to @PhiS
p39929
as(dp39930
g7
V505088
p39931
stp39932
a((dp39933
g2
(lp39934
VOne problem is that you need to specify the length in bytes rather than characters
p39935
aVSo use  rather than
p39936
aVAt the moment what you are passing in  is half the byte size of the buffer
p39937
aVI also believe that you should not use the same variable for the  and  parameters
p39938
aVThe above is fine if your  is expecting UTF-16 encoded text
p39939
aVIf not, and if it is expecting ANSI text then you should switch to AnsiString
p39940
aVExactly what you need to send to the standard output device depends on what text encoding it is expecting and I don't know that
p39941
aVFinally, if this is a console that you are writing to then you should simply use
p39942
as(dp39943
g7
V505088
p39944
stp39945
a((dp39946
g2
(lp39947
VThis is not your real code
p39948
aVFor a start it does not compile
p39949
aVYou have omitted the quote marks
p39950
aVIf we fix that then we have:
p39951
aVBut that returns a value of 1 and not 2 as you stated
p39952
aVThis return value is correct because the  matches  and then the input string ends
p39953
aVI expect that you have the wrong regex
p39954
aVPerhaps you should be using
p39955
aVThe  matches the beginning of the input string, the  mathes the end
p39956
aVPresumably the input is taken from a source code tokenizer
p39957
aVSo the conclusion is that there is no bug evident in the Delphi regex code from this pattern and input
p39958
as(dp39959
g7
V505088
p39960
stp39961
a((dp39962
g2
(lp39963
VYou simply need to put the DLL into memory and pass to memLoadLibrary the pointer to the location of the DLL in memory
p39964
aVFor example, from a resource:
p39965
as(dp39966
g7
V505088
p39967
stp39968
a((dp39969
g2
(lp39970
VThe  parameter is an array of doubles
p39971
aVSuppose, for sake of argument, that the array has  elements
p39972
aVThen you would call the DLL like this:
p39973
aVOne major problem that I see is that your C++ function appears to be a member function
p39974
aVYou could call that from Delphi by added an extra parameter to , before all other parameters, which contained a pointer to the C++ object instance
p39975
aVBut you would will need a way of getting hold of that instance
p39976
aVAnd obviously you would have to modify the declaration of  in your Delphi code
p39977
aVPresumably your DLL would export a function that returned a newly created instance
p39978
aVAnother possible issue is that you have specified  in your Delphi import but not done so in the C++ code
p39979
aVIf you are compiling the C++ with the option to use  for your functions then the interfaces will match
p39980
aVOtherwise you cannot call this code from Delphi at all because MS  has no direct equivalent in Delphi
p39981
aVI would add an explicit  to your C++ code
p39982
as(dp39983
g7
V505088
p39984
stp39985
a((dp39986
g2
(lp39987
VYour loop counter and indexed properties don't match
p39988
aVand  go together
p39989
aVAnd  and  go together
p39990
aVYou want to work with the latter pair since you are interesting in the children of the controls
p39991
aVThe  and  properties refer to ownership which is a different concept
p39992
aVWhat's more your loop ends but you continue using the loop variable after the loop variable
p39993
aVThat's clearly wrong
p39994
aVIt looks like it needs to be inside the loop and inside the  test
p39995
aVAs an aside  is grammatically incorrect alongside  and
p39996
aVThis property should have been named
p39997
as(dp39998
g7
V505088
p39999
stp40000
a((dp40001
g2
(lp40002
VWhen you terminate a process using the task manager, normal finalisation routines are not run
p40003
aVThe process is abruptly ended
p40004
aVNative resources, and managed resources for that matter, are reclaimed by the OS
p40005
as(dp40006
g7
V505088
p40007
stp40008
a((dp40009
g2
(lp40010
VUse
p40011
as(dp40012
g7
V505088
p40013
stp40014
a((dp40015
g2
(lp40016
VIf you want to change directory in the command prompt you have to use either  or a  script
p40017
aVYou can't get another process (i
p40018
ag192
aVPython) to do it because changes to the current directory, made in another process are not reflected back to the parent process
p40019
aVThe reason the  script works is that it is processed by the command shell that invokes it rather than by a child process
p40020
as(dp40021
g7
V505088
p40022
stp40023
a((dp40024
g2
(lp40025
VDifferent compilers on different architectures can and do use different padding
p40026
aVSo for wire transmission it is not uncommon to pack structs to achieve a consistent binary layout
p40027
aVThis can then cater for the code at each end of the wire running on different architecture
p40028
aVHowever you also need to make sure that your data types are the same size if you use this approach
p40029
aVFor example, on 64 bit systems, long is 4 bytes on Windows and 8 bytes almost everywhere else
p40030
aVAnd you also need to deal with endianness issues
p40031
aVThe standard is to transmit over the wire in network byte order
p40032
aVIn practice you would be better using a dedicated serialization library rather than trying to reinvent solutions to all these issues
p40033
as(dp40034
g7
V505088
p40035
stp40036
a((dp40037
g2
(lp40038
VThe compiler happens to put the stack allocated variable at a different location in the different versions of the program
p40039
aVTry including both printf and cout versions in the same program so that they work with the exact same pointer
p40040
aVThen you will see that the two versions behave the same way
p40041
aVAs Mr Lister correctly points out, you should use the %p format string when printing pointers in printf
p40042
as(dp40043
g7
V505088
p40044
stp40045
a((dp40046
g2
(lp40047
VThe documentation for  is pretty clear in my view and gives a reasonable example of what you need
p40048
aVBasically you want to hold an expression to be evaluated in a string:
p40049
aVThen you can define a value for :
p40050
aVAnd finally call evaluate:
p40051
aVOr if you want to make the call to eval a little more controlled, as opposed to creating a local variable named , then you can pass in the evaluation environment in the parameters to :
p40052
aVThe reason you want to control the evaluation environment is to avoid any variables defined in your program inadvertently being used in the evaluation
p40053
as(dp40054
g7
V505088
p40055
stp40056
a((dp40057
g2
(lp40058
VYour analysis is correct
p40059
aVworks for window controls but  and  are non-winowed controls
p40060
aVIn XE, from my quick scan, it seems that most controls call  to determine whether or not to draw themed
p40061
aVSo the simple solution is to replace that routine with logic that you control
p40062
aVSince it does not provide any extension points, you need to hook it
p40063
aVLike this:
p40064
aVAs it stands, this will not work with runtime packages, but it's easy enough to extend the code to work with packages
p40065
as(dp40066
g7
V505088
p40067
stp40068
a((dp40069
g2
(lp40070
VThat code works just fine for me
p40071
aVI can think of two reasons why Delphi is not producing a console app:
p40072
aVis not defined
p40073
aVYou have  somewhere in your project's code
p40074
aVI'm reasonably confident that item 2 above is the reason for your problem
p40075
as(dp40076
g7
V505088
p40077
stp40078
a((dp40079
g2
(lp40080
VI'd do it using  to parse the file into lines and  to tokenize each delimited value
p40081
aVFirst of all to load the file into a string list:
p40082
aVAnd then to actually process the strings:
p40083
aVAlthough your title describes the data as integer it appears to be mixed integer and floating point
p40084
aVAnyway, I think you should be able to fill in the blanks and populate your dynamic arrays of values, handle error checking and so on
p40085
as(dp40086
g7
V505088
p40087
stp40088
a((dp40089
g2
(lp40090
VI suggest you use GParted
p40091
aVThis program can modify partition sizes in place without required re-installation
p40092
as(dp40093
g7
V505088
p40094
stp40095
a((dp40096
g2
(lp40097
VYou aren't allowed to modify a  whilst iterating over it with
p40098
aVUse  instead
p40099
aVWhilst you could write  this is not a good idea
p40100
aVFor a start it is wasteful to create a new list just to clear out an existing one
p40101
aVWhat's more, if you have other references to the list then they will continue to refer to the old list
p40102
aVAlthough, as @dasblinkenlight points out,  is probably a private member and it's unlikely you have other references to the list
p40103
aVNo matter,  is the canonical way to clear a
p40104
as(dp40105
g7
V505088
p40106
stp40107
a((dp40108
g2
(lp40109
VWith a dynamic array, and a suitably modern version of Delphi you can use an array constructor
p40110
aVIf you want to create an array of buttons then it is written so:
p40111
aVAnd then to iterate over the array of buttons:
p40112
as(dp40113
g7
V505088
p40114
stp40115
a((dp40116
g2
(lp40117
VPass a pointer to the extra return value as a parameter to the function
p40118
aVAnd to call it:
p40119
aVOftentimes, @Mat's suggestion of packing all the return values into a  is preferable
p40120
as(dp40121
g7
V505088
p40122
stp40123
a((dp40124
g2
(lp40125
VI think you are on the right track, but I'd do it without using unsafe code
p40126
aVLike this:
p40127
aVThis is a pretty direct translation of your C++ version
p40128
as(dp40129
g7
V505088
p40130
stp40131
a((dp40132
g2
(lp40133
VYou need to write your  statement like this
p40134
aVOr you could use a  statement
p40135
aVBreaking down your attempted code is quite interesting
p40136
aVYou wrote:
p40137
aVI guess in your head you read it as, if someInt equals 1 or 2 or 4 or 5
p40138
aVAnd if computers behaved like humans then this would work
p40139
aVBut we all know that computers don't behave like that
p40140
aVThe  equality operator, a binary operator, returns  when its two operands are equal
p40141
aVSo that means, in your version, if it compiled, you would need  to be equal to
p40142
aVAnd for that to even be meaningful, we would need  to evaluate to a single value, instead of producing a compile error
p40143
aVAnd, if it did evaluate to a single value, then it could not have the meaning which you want
p40144
aVBecause you want the test to return true when  is equal to one of four candidate values
p40145
aVThe bottom line is that  tests for exact equality between precisely two values
p40146
as(dp40147
g7
V505088
p40148
stp40149
a((dp40150
g2
(lp40151
VAccording to your comments, the  message is being targetted at your MDI client window
p40152
aVAnd since that is not a VCL control it does not respond to the  message
p40153
aVYou can deal with the problem by intercepting the message and asking the main form to handle it:
p40154
aVIf you want to be even more defensive you could write it like this:
p40155
aVI've just had a look at my own MDI application and I can see that I have similar code to deal with this exact issue
p40156
aVIf it hadn't been written over 10 years ago I might have remembered sooner
p40157
as(dp40158
g7
V505088
p40159
stp40160
a((dp40161
g2
(lp40162
VNo matter how you close a process, no memory will be leaked
p40163
aVWhen a process closes, the OS reclaims all the memory owned by the process
p40164
aVNow,  results in an orderly shutdown, starting at the  object
p40165
aVAll objects owned by  will be destroyed
p40166
aVIf those objects in turn own other objects, the owned objects will be destroyed
p40167
aVHowever, in terms of leaking memory it is not possible for a process to terminate and leak memory
p40168
aVIt is possible for a process to terminate and leave certain resources in an ill-defined state which is why it is often advisable to terminate a process in an orderly fashion
p40169
as(dp40170
g7
V505088
p40171
stp40172
a((dp40173
g2
(lp40174
V defines the calling convention
p40175
aVThis is a macro defined in one of the header files that will evaluate to something like  or
p40176
aVThis has no bearing on the return type of the function
p40177
aVThe function is still a  function
p40178
aVYou state in a comment:
p40179
aVMy concern here is that if I port the above code to Java, do I need to take care of this
p40180
aVNo you do not
p40181
aVThis is purely an issue for interfacing between different native libraries of code
p40182
aVOnce the code is in Java you can simply ignore calling convention
p40183
as(dp40184
g7
V505088
p40185
stp40186
a((dp40187
g2
(lp40188
VThe equality comparison operator in C is
p40189
aVIn Delphi the equivalent operator is
p40190
aVSo you need to use this code:
p40191
aVInterestingly, as an aside, the C equality operator leads to a very classic and hard to spot bug
p40192
aVIt goes like this:
p40193
aVWhat happens here is that  is the assignment operator and so  is assigned a value of  which is then truth tested
p40194
aVAnd that returns false and so  is never executed
p40195
aVI believe that this potential confusion is one of the reasons why Pascal chose to use  for assignment
p40196
as(dp40197
g7
V505088
p40198
stp40199
a((dp40200
g2
(lp40201
VYou didn't allocate enough space for
p40202
aVInstead of
p40203
aVyou need
p40204
aVand obviously this must move to be after  has been read
p40205
aVOnce you sort that rather mundane problem out the fundamental problem is here:
p40206
aVThis makes the pointer  point at a literal which cannot be modified
p40207
aVInstead you need to copy the contents of that literal into
p40208
aVLike this:
p40209
aVYou must understand that  assigns just the pointer  and does not modify the string to which  points
p40210
aVNow, your code will obviously be in error if  is less than  since then  would be out of bounds, but I guess  is just transient while you debug this
p40211
aVYour while loop is all wrong
p40212
aVJudging from your comments you want something like this:
p40213
aVNo need to cast the return value of  in C, so remove the casts
p40214
aVis always equal to  so you can remove that too
p40215
as(dp40216
g7
V505088
p40217
stp40218
a((dp40219
g2
(lp40220
VIf you are prepared to call some Windows API functions then you can make your console go full screen as follows:
p40221
aVCall  passing  to get a handle the console handle
p40222
aVCall  passing that console handle and
p40223
aVAt this point your console window will be displaying full screen
p40224
aVI don't know if those functions are readily available in one of the win32 Python modules but they are pretty trivial to invoke using ctypes
p40225
as(dp40226
g7
V505088
p40227
stp40228
a((dp40229
g2
(lp40230
VYou can certainly do this with  as described by @Remy
p40231
aVHowever,  is not the easiest of functions to operate
p40232
aVFor convenience you may find  to be a more amenable option:
p40233
aVUltimately this will lead to the  variable being read and then a call to  being made
p40234
aVThe advantage is that you let the shell do the heavy lifting for you
p40235
as(dp40236
g7
V505088
p40237
stp40238
a((dp40239
g2
(lp40240
VIt is undefined behaviour to de-reference a null pointer
p40241
aVThe fix is simply to ensure that the pointer refers to an appropriate function
p40242
aVIn your case you want something like this:
p40243
aVand then later you can assign to :
p40244
aVNote that I am using a different name for the function pointer variable and the actual function
p40245
aVAnd now you can call the function, via the function pointer:
p40246
as(dp40247
g7
V505088
p40248
stp40249
a((dp40250
g2
(lp40251
VThe problem with your code is that the call to  results in the tree view creating a new node
p40252
aVAnd since you didn't tell the tree view to create a node of your sub-class it creates a plain
p40253
aVAnd then when you try to cast it to a , the world ends
p40254
aVYou need to use the  method to make sure that the tree view is able to create new nodes
p40255
aVLike this:
p40256
aVI can't claim to being the world's greatest expert on Delphi tree views but in my experience you never create a tree node yourself
p40257
aVYou should always call one of the  methods on  to create new nodes
p40258
as(dp40259
g7
V505088
p40260
stp40261
a((dp40262
g2
(lp40263
VYou need to instantiate an object instance to operate on
p40264
aVFor example:
p40265
aVBy missing this out you are trying to invoke methods on an uninitialized variable
p40266
aVYou should probably consider using some form of smart pointer to ensure that the object is destroyed
p40267
as(dp40268
g7
V505088
p40269
stp40270
a((dp40271
g2
(lp40272
VYou can use  to print formatted output to a character array
p40273
as(dp40274
g7
V505088
p40275
stp40276
a((dp40277
g2
(lp40278
VHere's the nave approach whereby we simply walk through the buffer byte by byte looking for the desired string
p40279
aVI don't use FPC but I expect that this will work unchanged and if not then I'm sure you can convert it
p40280
as(dp40281
g7
V505088
p40282
stp40283
a((dp40284
g2
(lp40285
VYou are not missing anything
p40286
aVThat code is bogus
p40287
aVRefactor it the way you describe in the question
p40288
aVFor what it is worth,  will return , a  rather than , a
p40289
aVSo the first excerpt should really be
p40290
aVOf course, this assumes that the right hand operand in the comparison really should be a
p40291
aVGiven the nature of this code, I would be doubtful of the correctness of everything
p40292
as(dp40293
g7
V505088
p40294
stp40295
a((dp40296
g2
(lp40297
VIf the native DLL doesn't provide a function to reset its state then you will have to unload the DLL and then reload it
p40298
aVIf you are using implicit linking that's not possible
p40299
aVYou have to use explicit linking: LoadLibrary, GetProcAddress etc
p40300
aVI'm assuming that the native code is contained in a separate DLL
p40301
aVIf that's not the case then you are completely stuck
p40302
as(dp40303
g7
V505088
p40304
stp40305
a((dp40306
g2
(lp40307
VYou have an non-terminating recursion here:
p40308
aVThe line  in the getter calls the getter recursively and that leads to stack overflow
p40309
aVAnd similarly for the setter
p40310
aVI think you meant:
p40311
aVi don't see what's to be gained from using an explicitly named field here to back to property
p40312
aVI'd remove  and declare the property like this:
p40313
as(dp40314
g7
V505088
p40315
stp40316
a((dp40317
g2
(lp40318
VYou can't write this in Delphi in a safe way
p40319
aVThat's because  is a C++ class and you can't import C++ classes into Delphi code
p40320
aVI suppose you could reverse engineer the memory layout of  but I'd be very sceptical about the wisdom of talking that approach
p40321
aVMy recommendation would be to stick with the MFC DLL
p40322
as(dp40323
g7
V505088
p40324
stp40325
a((dp40326
g2
(lp40327
VYou are looking for
p40328
as(dp40329
g7
V505088
p40330
stp40331
a((dp40332
g2
(lp40333
VIf you want to change the color for themed controls you need to custom draw it using the theme API
p40334
aVThat's a pretty tricky task that is essentially undocumented
p40335
aVGood luck
p40336
as(dp40337
g7
V505088
p40338
stp40339
a((dp40340
g2
(lp40341
VRead the file in small chunks at a time, say 1/10th the size of your memory budget
p40342
aVCount the line ends in each chunk
p40343
aVThe only real problem you face is that you need to deal with cr+lf pairs that span from the end of one chunk to the beginning of the next
p40344
aVAs an aside, surely you mean 4MB rather than 4KB
p40345
as(dp40346
g7
V505088
p40347
stp40348
a((dp40349
g2
(lp40350
VYour expression don't mean the same thing
p40351
aVWhat you write as
p40352
aVIs not actually that
p40353
aVIn fact it is
p40354
aVaccording to your  notation
p40355
aVIf you write
p40356
aVas
p40357
aVthen I think it becomes more clear
p40358
aVYou are looking for:
p40359
as(dp40360
g7
V505088
p40361
stp40362
a((dp40363
g2
(lp40364
VThis is just the standard behaviour of the underlying Windows console
p40365
aVA native C app will do exactly the same if you output  to the console
p40366
aVOf course, you should be using
p40367
aVfor your new lines
p40368
aVresolves to  on Windows
p40369
aVand  on Unix like systems
p40370
as(dp40371
g7
V505088
p40372
stp40373
a((dp40374
g2
(lp40375
VOn Python 3, print is a function
p40376
aVYou need this:
p40377
as(dp40378
g7
V505088
p40379
stp40380
a((dp40381
g2
(lp40382
VThat's a COM error
p40383
aVTo get a textual description call GetErrorInfo and then IErrorInfo
p40384
aVGetDescription
p40385
aVBut don't be surprised if you don't get anything useful back
p40386
as(dp40387
g7
V505088
p40388
stp40389
a((dp40390
g2
(lp40391
VIt sets the last modified time because that's what you asked it to do
p40392
aVThe function receives 3 filetime parameters and you only passed a value to the final one,
p40393
aVTo set the creation time call the function like this:
p40394
aVI suggest you take a read of the documentation for
p40395
aVThe key part is its signature which is as follows:
p40396
aVSince you say that you are a novice with the Windows API I'll give you a tip
p40397
aVThe documentation on MSDN is very comprehensive
p40398
aVWhenever you get stuck with a Win32 API call, look it up on MSDN
p40399
aVAnd some comments on your code:
p40400
aVYou should always check the return values for any API calls
p40401
aVIf you call the functions incorrectly, or they fail for some other reason, you'll find it impossible to work out what went wrong without error checking
p40402
aVThe variable that you call  should in fact be named
p40403
as(dp40404
g7
V505088
p40405
stp40406
a((dp40407
g2
(lp40408
VWhen  is zero, first time around the loop you are doing  which results in a divide by zero error
p40409
aVAs for what your function is trying to do, I've no idea
p40410
aVI don't see anything much related to prime numbers here
p40411
aVYou are simply finding out all the even numbers less than
p40412
aVLet's have a look at the  test:
p40413
aVThe second part,  will always be true so long as  is not
p40414
aVSo that part is spurious
p40415
aVAnd  simply tests whether or not  is even
p40416
aVWhat is your code actually intending to do
p40417
aVAre you trying to test whether or not a number is prime
p40418
aVIf so, the simplest approach is like this:
p40419
aVYou current code cannot output any numbers because your call to  is not quite correct
p40420
aVYou mean:
p40421
aVThe other point to make is that your version of the code mixed the primality test in with the I/O code
p40422
aVMixing it all together in one big routine makes it harder for you to understand and debug the code
p40423
aVSplit the primality test into a separate function as I illustrate here and you can more easily check its correctness
p40424
aVOnce you know it is correct, you can use it from your IO code
p40425
aVAnd then you can concentrate on getting your IO code correct
p40426
aVWhich could look something like this:
p40427
as(dp40428
g7
V505088
p40429
stp40430
a((dp40431
g2
(lp40432
VI'd say that MS simply got it wrong when they implemented  and that  should have been declared to return
p40433
aVIf I were you I would simply declare your P/invoke to return
p40434
as(dp40435
g7
V505088
p40436
stp40437
a((dp40438
g2
(lp40439
VTo convert  to :
p40440
aVThe code converts from UTF-16, null-terminated PWideChar to
p40441
aVIf you are getting question marks in the output then either your input is not UTF-16, or it contains characters that cannot be encoded in your ANSI codepage
p40442
aVMy guess is that what is actually happening is that your Delphi DLL was created with a pre-Unicode Delphi and so uses ANSI text
p40443
aVBut now you are trying to link to it from a post-Unicode Delphi where  has a different meaning
p40444
aVI'm sure Rob explained this to you in your other question
p40445
aVSo you can simply fix it by declaring your DLL import to return  rather than
p40446
aVLike this:
p40447
aVAnd when you have done this you can assign to a string variable in a similar vein as I describe above
p40448
aVWhat you need to absorb is that in older versions of Delphi,  is an alias for
p40449
aVIn modern Delphi it is an alias for
p40450
aVThat mismatch would explain everything that you report
p40451
aVIt does occur to me that writing a Delphi wrapper to the DLL and communicating via stdout with your C# app is a very roundabout approach
p40452
aVI'd just p/invoke the DLL directly from the C# code
p40453
aVYou seem to think that this is not possible, but it is quite simple
p40454
aVCall the function like this:
p40455
aVIf the function returns a UTF-16 string (which seems doubtful) then you can convert the  like this:
p40456
aVOr if it is actually an ANSI string which seems quite likely to me then you do it like this:
p40457
aVAnd then of course you'll want to call into your DLL to deallocate the string pointer that was returned to you, assuming it was allocated on the heap
p40458
as(dp40459
g7
V505088
p40460
stp40461
a((dp40462
g2
(lp40463
VAssuming that what is in the memo field uses #13#10 as the line separator then I would use a , and the very useful  property to split the memo field text into separate lines:
p40464
aVEven if your memo field uses Unix linefeeds then this code will interpret the memo field correctly
p40465
as(dp40466
g7
V505088
p40467
stp40468
a((dp40469
g2
(lp40470
VYou need to get the component to declare a field to store the form's original
p40471
aVThen you can do in the component's constructor:
p40472
aVThen the component's  would read:
p40473
aVNaturally the  cast ties this component to being owned by forms but if you want more flexibility you could easily cater for that
p40474
aVThis is a direct answer to the question that you asked, but it would be remiss of me not to question your overall design
p40475
aVIf you want a component to live on every form in your app then surely you should derive a subclass of  that contains your customisations
p40476
aVThen make every form in your app be based on that common base form class
p40477
aVThat approach has many other benefits
p40478
aVFor example, @LachlanG adds the following very apt comment with which I wholeheartedly concur:
p40479
aVHaving a component meddle with it's owning form is undesirable
p40480
aVThe vast majority of components should be self contained entities, altering the component owner breaks the expected contract of a Delphi component
p40481
aVThe common base form approach solves this by placing the code that works with the form inside the form
p40482
aVIf you are do go down the route of having a common base form then you should override  rather than using the  event
p40483
aVAlways use the  event raisers rather than the events themselves when you are creating a common base class or a component
p40484
as(dp40485
g7
V505088
p40486
stp40487
a((dp40488
g2
(lp40489
VYour service will get the locale settings of the user account it runs under
p40490
aVMy guess is you are running the service as LOCALSYSTEM
p40491
aVIf you configure the service to run as your interactive user then you will get the locale settings you want
p40492
as(dp40493
g7
V505088
p40494
stp40495
a((dp40496
g2
(lp40497
VHere's a simplified example based on of your problem:
p40498
aVIn the above version you have a variable called  that is confined to scope 1, and another different variable called  that is confined to scope 2
p40499
aVYou then try to refer to a variable named  after the end of the , and not such variable  can be seen because no such variable exists in that scope
p40500
aVYou solve the problem by placing  in the outermost scope which contains all references to it:
p40501
aVI've written the example with simplified made up code to make it clearer for you to understand the issue
p40502
aVYou should now be able to apply the principle to your code
p40503
as(dp40504
g7
V505088
p40505
stp40506
a((dp40507
g2
(lp40508
VYou need to use the syntax  to invoke a constructor and save the result to the instance variable:
p40509
aVAlso use  to protect the lifetime of the object in the face of exceptions
p40510
aVThe  block will always execute, providing that execution passes try
p40511
aVAnd to destroy an object you should call  rather than
p40512
aVThis doesn't matter here, but is very important when you destroy objects inside another object's destructor
p40513
aVTo learn more on the topic of  I refer you (immodest I know) to another answer of mine
p40514
as(dp40515
g7
V505088
p40516
stp40517
a((dp40518
g2
(lp40519
VThe problem is that the font that your XP console uses does not contain glyphs for the Russian characters you are trying to output
p40520
aVThe fonts that Windows 7 ships with and uses by default in its console do have a much broader coverage of Unicode code points
p40521
aVYou'll need to configure your console to use a font that contains the glyphs you want
p40522
as(dp40523
g7
V505088
p40524
stp40525
a((dp40526
g2
(lp40527
VIt is true that  has no direct support for  values
p40528
aVHowever, with the protected hack, you can trick it into creating zero-length binary  values:
p40529
aVYou need to use the protected hack to gain access to  which is a protected member
p40530
aVA cleaner approach would be to use a class helper or true class derived from , but you get the idea
p40531
as(dp40532
g7
V505088
p40533
stp40534
a((dp40535
g2
(lp40536
VCreate a brush of the desired color and then pass it in the  member of the  struct when calling  to register your window class
p40537
aVThe system will delete this brush automatically when you call  so once you have passed this brush to  you can forget all about it and must not attempt to delete it yourself
p40538
as(dp40539
g7
V505088
p40540
stp40541
a((dp40542
g2
(lp40543
VThe most plausible explanation for this is that your anti-virus software is blocking your attempts to write to this key
p40544
aVYes it's possible that somebody has applied an ACL to that key to deny you write access but it's pretty unlikely
p40545
aVOn the other hand it's very common for anti-virus software to take exception to programs that modify that particular key
p40546
as(dp40547
g7
V505088
p40548
stp40549
a((dp40550
g2
(lp40551
VThere's no built in operator that does what you want
p40552
aVYour code would work in Python, but not in Delphi
p40553
aVIf your string is a single character then you can use :
p40554
aVFor a longer input string use  from the  unit:
p40555
as(dp40556
g7
V505088
p40557
stp40558
a((dp40559
g2
(lp40560
VYou can't explicitly force stack unwinding as you call it (destruction of  and  in the code sample) before the function ends
p40561
aVIf your recursion (you didn't show it) is amenable to tail call optimisation then good compilers will be able to handle the recursion without creating a new stack frame
p40562
as(dp40563
g7
V505088
p40564
stp40565
a((dp40566
g2
(lp40567
VAs explained in the comments, the different behaviour is by design
p40568
aVThe different languages just ascribe different meanings to the  operator
p40569
aVYou ask:
p40570
aVHow can I use modulus operator in C#
p40571
aVYou can define a modulus operator yourself that behaves the same was as the Python  operator:
p40572
as(dp40573
g7
V505088
p40574
stp40575
a((dp40576
g2
(lp40577
VIf the calling function is  that means that the  method is being called at program termination
p40578
aVThat is to be expected because the Python threading framework does call  on all running non-daemon threads as part of program termination
p40579
aVThe best explanation of  is another Stack Overflow question: What is a python thread
p40580
as(dp40581
g7
V505088
p40582
stp40583
a((dp40584
g2
(lp40585
VYou can use  and  to obtain a pointer to the exported  variable
p40586
aVYou can then use  and  to assign to the delegate
p40587
aVYou will want to add the error checking that I excised in the interests of a concise example
p40588
aVNow, if you are in control of the unmanaged library I would still recommend adding a function to encapsulate writing to this function pointer
p40589
aVThat feels like a better interface to me
p40590
as(dp40591
g7
V505088
p40592
stp40593
a((dp40594
g2
(lp40595
VIdeally you should use the system scheduler for this: cron on a Unix system or Scheduled Tasks on a Windows system
p40596
aVThere may be some requirement that means you can't spawn a new process for each invocation of the function
p40597
aVIf so then use an infinite loop with a call to Sys
p40598
aVsleep() to wait until the next invocation is due
p40599
as(dp40600
g7
V505088
p40601
stp40602
a((dp40603
g2
(lp40604
VWhat you have in the log there is the call stack that resulted in the memory allocation that leaked
p40605
aVYou can see how useful it is in the call stack in your question
p40606
aVImagine that you only had the top line, the call that resulted in the leak
p40607
aVThat information on its own is pretty much useless since all heap allocations go through
p40608
aVIt is the call stack that points you to the events that led up to the call to
p40609
aVAnd that's what pinpoints what caused the leak
p40610
as(dp40611
g7
V505088
p40612
stp40613
a((dp40614
g2
(lp40615
VIn your Delphi 7 code you probably wrote something like this:
p40616
aVThis was fine in Delphi 7 where  is an alias for
p40617
aVIn XE2 the generic  type is now an alias for  which is UTF-16 encoded
p40618
aVThat means that when the code above is compiled by XE2, the UTF-8 encoded buffer returned by  is interpreted as UTF-16 encoded text
p40619
aVAnd that mismatch is what leads to your string full of question marks
p40620
aVSo, if you just wrote
p40621
aVthen you would have the same behaviour as for your Delphi 7 code
p40622
aVHowever, this is not the way to do it in Unicode Delphi
p40623
aVInstead you should use the  type
p40624
aVThis is defined as  which means a string of 8 bit character units with code page , i
p40625
ag192
aVthe UTF-8 codepage
p40626
aVWhen you do this you don't need to call  at all since the encoding attached to the string type means that the compiler can generated code to convert the string
p40627
aVNow you would simply write:
p40628
aVThe principal reference for the Unicode aspects of Delphi 2009 and later is Marco Cant's white paper: Delphi and Unicode which I recommend that you read before proceeding
p40629
as(dp40630
g7
V505088
p40631
stp40632
a((dp40633
g2
(lp40634
VI would do this the other way around
p40635
aVI would include the standard comctl v6 manifest by enabling runtime themes in the project settings
p40636
aVThen I would call  at startup, from the
p40637
aVdpr file, to disable runtime themes if necessary
p40638
aVYou'll need to make sure that  is in the
p40639
aVdpr uses clause, or even better move that function to its own dedicated unit
p40640
aVIt's easier to include the manifest as normal and then disable runtime themes
p40641
aVThe alternative of enabling runtime themes involves activation contexts which is rather more involved than this approach
p40642
aVHaving said it was easier than using the activation context, I decided to see what was involved in that
p40643
aVAnd here's what I came up with:
p40644
aVYou should include this unit as early as possible in your
p40645
aVdpr file
p40646
aVAfter any memory managers, but before any RTL/VCL units
p40647
aVSet runtime themes to None in the project settings
p40648
aVYou'd probably want to include the manifest file as a resource, but I've done it as a file here for my convenience
p40649
as(dp40650
g7
V505088
p40651
stp40652
a((dp40653
g2
(lp40654
VYour struct should be declared like this:
p40655
aVit has to be done this way because  is a pointer to unmanaged memory and cannot be marshalled by the p/invoke marshaller
p40656
aVIn order to read the contents of  you can use
p40657
aVI suspect that  is wrong and that you should be using
p40658
as(dp40659
g7
V505088
p40660
stp40661
a((dp40662
g2
(lp40663
VI have read that sizeof operator in C is interpreted at
p40664
aVcompile time
p40665
aVis determined at compile time in all cases apart from for VLAs
p40666
aVFor a VLA,  is evaluated at runtime
p40667
as(dp40668
g7
V505088
p40669
stp40670
a((dp40671
g2
(lp40672
VYou state:
p40673
aVIf Result is undefined this means that I always have to start every function by defining Result in case of exception later
p40674
aVYou are concerned that the return value of a function is undefined if the function raises an exception
p40675
aVBut that should not matter
p40676
aVConsider the following code:
p40677
aVIf the body of the function  raises an exception then, back at the call site,  should not be assigned to
p40678
aVLogically the one-liner above can be thought of as a two-liner:
p40679
aVcall
p40680
aVassign return value to
p40681
aVIf an exception is raised in line 1 then line 2 never happens and  should never be assigned to
p40682
aVSo, if an exception is raised before you have assigned to  then that is simply not a problem because a function's return value should never be used if the function raises an exception
p40683
aVWhat you should in fact be concerned about is a related issue
p40684
aVWhat if you assign to  and then an exception is raised
p40685
aVIs it possible for the value you assigned to  to propagate outside of the function
p40686
aVSadly the answer is yes
p40687
aVFor many result types (e
p40688
ag217
aVInteger, Boolean etc
p40689
aVthe value you assign to  does not propagate outside the function if that function raises an exception
p40690
aVSo far, so good
p40691
aVBut for some result types (strings, dynamic arrays, interface references, variants etc
p40692
aVthere is an implementation detail that complicates matters
p40693
aVThe return value is passed to the function as a  parameter
p40694
aVAnd it turns out that you can initialise the return value from outside the function
p40695
aVLike this:
p40696
aVWhen the body of  begins execution,  has the value
p40697
aVIt is as if  is declared like this:
p40698
aVAnd this means that you can assign to the  variable and see modifications at the call site, even if your function subsequently raises an exception
p40699
aVThere is no clean way to work around it
p40700
aVThe best you can do is to assign to a local variable in the function and only assign Result as the final act of the function
p40701
aVThe lack of a C style  statement is felt strongly here
p40702
aVIt is surprising hard to state accurately which type of result variables will be susceptible to the problem described above
p40703
aVInitially I thought that the problem just affected managed types
p40704
aVBut Arnaud states in a comment that records and objects are affected too
p40705
aVWell, that is true if the record or object is stack allocated
p40706
aVIf it is a global variable, or heap allocated (e
p40707
ag217
aVmember of a class) then the compiler treats it differently
p40708
aVFor heap allocated records, an implicit stack allocated variable is used to return the function result
p40709
aVOnly when the function returns is this copied to the heap allocated variable
p40710
aVSo the value to which you assign the function result variable at the call site affects the semantics of the function itself
p40711
aVIn my opinion this is all a very clear illustration of why it was a dreadful mistake, in the language design, for function return values to have  semantics as opposed to having  semantics
p40712
as(dp40713
g7
V505088
p40714
stp40715
a((dp40716
g2
(lp40717
VMy simple rule of thumb would be always to prefer pass by reference where it was possible
p40718
aVIf you need the ability to pass a null value, then you have to use pass by pointer
p40719
aVOtherwise use pass by reference
p40720
as(dp40721
g7
V505088
p40722
stp40723
a((dp40724
g2
(lp40725
VYou are trying to link to an unmanaged, native DLL
p40726
aVYou cannot add such a thing to a managed application as a reference
p40727
aVThe way to call your DLL is to use p/invoke:
p40728
aVNaturally things can get a bit more complicated when you start having parameters to your DLL but you can go a very long way with p/invoke
p40729
aVOne thing you need to watch out for is that your managed project targets x86 if your DLL is 32 bit, or x64 if your DLL is 64 bit
p40730
aVAs a final, minor, note the use of  is pointless in modern Delphi
p40731
aVYou should simply remove it since the compiler ignores it anyway
p40732
as(dp40733
g7
V505088
p40734
stp40735
a((dp40736
g2
(lp40737
VThere are 3 common failure modes:
p40738
aVThe source file  does not exist
p40739
aVThe destination file  exists but is read-only
p40740
aVThe destination directory  does not exist
p40741
aVMy guess is that item 3 is the problem and if so you need to make sure that the destination directory exists before you call
p40742
aVIf this is the case you will be seeing a
p40743
aVYou can use  to make sure the destination directory exists
p40744
as(dp40745
g7
V505088
p40746
stp40747
a((dp40748
g2
(lp40749
VYou have to wait until runtime to be able to get hold of the paths to imported DLLs
p40750
aVThis is because the answer depends upon the runtime environment at the point at which the library is loaded
p40751
aVFor example, two different programs could have two different DLL search paths
p40752
aVAnd so the paths to the imported DLLs could be different for those two programs
p40753
as(dp40754
g7
V505088
p40755
stp40756
a((dp40757
g2
(lp40758
VThe size of a pointer is machine dependent
p40759
aVWhat I don't understand is how does a char pointer have a size of 8
p40760
aVA char pointer, i
p40761
ag192
aVa  variable does have a size of 8, on your system
p40762
aVIn your code  gives the size of a char pointer, and it is 8
p40763
aVThe reason  is 1 is that  is  and  is 1 by definition
p40764
as(dp40765
g7
V505088
p40766
stp40767
a((dp40768
g2
(lp40769
VNote: The question was originally tagged Delphi
p40770
aVI don't know FPC/Lazarus so some of the details may not be accurate below but the concepts are still valid
p40771
aVI'm guessing that you have a global variable representing the main form, named  for the sake of argument
p40772
aVThe quickest and simplest approach is simply to use  to let your other form refer to the main form's list view
p40773
aVI'm not terribly keen on this approach since it means that the other form takes a dependency on the implementation of the main form
p40774
aVAs an alternative, you can pass a reference to the list view to the other form
p40775
aVFor example you could add a  procedure to your other form:
p40776
aVThen in the main form, probably in the  event handler for the main form, you can call this method:
p40777
aVThis isn't really all that much better than the first suggestion
p40778
aVThe other form still takes a dependency on the implementation of the main form, albeit an arguably less significant dependency
p40779
aVIf you want to keep the two forms even less coupled then the main form could expose a method that accepts additions to the list:
p40780
aVThe in your other forms unit you add the main form unit to the uses clause in the implementation section
p40781
aVThat allows you access to the  global variable and you can call
p40782
aVThis approach is the best in my view because it allows the main form to keep its list implementation private to itself
p40783
aVYou state in a comment that you want to avoid any circular references due to  clauses
p40784
aVThat's easy to arrange since none of the above require modifications to the  clause from the interface section from the two units in question
p40785
as(dp40786
g7
V505088
p40787
stp40788
a((dp40789
g2
(lp40790
VOn x64, floating point arithmetic is performed using SSE
p40791
aVThis does not have a built-in operation for  and so a call to the standard library is inevitable
p40792
aVI imagine that the MSDN article you are referring to was written with 32 bit code that uses 8087 FP in mind
p40793
as(dp40794
g7
V505088
p40795
stp40796
a((dp40797
g2
(lp40798
VYou need to use an encoding that can encode all the characters you need, and one that will be recognised by whichever program loads your file
p40799
aVYou are currently using a fixed length 8 bit encoding and there are no fixed length 8 bit encodings that can encode all the characters you need
p40800
aVSo you need to use something like UTF-8 or UTF-16 to encode your content
p40801
aVOn the flip side, many common
p40802
aVcsv file readers don't support anything other than fixed length 8 bit encodings
p40803
aVI think your next step is to find a Unicode encoding that is understood by enough
p40804
aVcsv file readers to satisfy your needs
p40805
aVIf you can find a suitable encoding then you are done
p40806
aVIf no encoding meets your needs then I suspect that you need to use something other than
p40807
aVcsv
p40808
as(dp40809
g7
V505088
p40810
stp40811
a((dp40812
g2
(lp40813
VYou tagged the question ctypes, but you cannot instantiate a C++ object directly from ctypes
p40814
aVYou can wrap the C++ object in a C interface and then use ctypes
p40815
aVOr you could write a Python extension module which could include C++ code
p40816
as(dp40817
g7
V505088
p40818
stp40819
a((dp40820
g2
(lp40821
VThere's not enough information in the question to be 100% sure but my guess is that you need this:
p40822
aVIdeally when asking a question like this you should include the full documentation of the native function
p40823
aVI say this because a char** can mean many different things
p40824
aVMy assumption is that the char** here is a pointer to a null-terminated C string allocated by the DLL
p40825
aVYour code assumes that the caller allocates the buffer but if that were so then I would expect to see char* rather than char**
p40826
as(dp40827
g7
V505088
p40828
stp40829
a((dp40830
g2
(lp40831
VYou are passing  to the  parameter of
p40832
aVThat's why the background is not redrawn when you resize
p40833
aVI suspect you intended to make use of your optional parameters and calling it like this:
p40834
as(dp40835
g7
V505088
p40836
stp40837
a((dp40838
g2
(lp40839
VOpen the project manager from the View menu, or use the shortcut Ctrl+Alt+F11
p40840
aVFind the Build Configurations node in the project manager's tree view and open it up
p40841
aVDouble click on Release
p40842
aVThe active build configuration is indicated in the project manager by boldface text
p40843
as(dp40844
g7
V505088
p40845
stp40846
a((dp40847
g2
(lp40848
VYou can use  inside the loop to access the ith element
p40849
aVIf you ever have need to increment a pointer inside a loop, you can do it like this:
p40850
aVPersonally, I would use
p40851
as(dp40852
g7
V505088
p40853
stp40854
a((dp40855
g2
(lp40856
VThe official way to fake input does not involve sending or posting Windows messages directly
p40857
aVInstead you are meant to call
p40858
aVWhen you use  it is indistinguishable from actually pressing the real keys
p40859
aVWhen you call  to fake keyboard input, the system ultimately posts messages to the message queue of the foreground thread that created the window with the keyboard focus
p40860
as(dp40861
g7
V505088
p40862
stp40863
a((dp40864
g2
(lp40865
VWindows Explorer uses  to compare file names
p40866
aVThe RTL/VCL does not declare this function so you need to do it yourself
p40867
as(dp40868
g7
V505088
p40869
stp40870
a((dp40871
g2
(lp40872
VYour only option, if you want a Borland Delphi cross-compiler, is
p40873
aVThis isn't a real cross-compiler
p40874
aVInstead you run the Kylix compiler for Linux under an emulated Linux environment
p40875
aVNote that you'll be forced to use CLX rather than VCL and that Kylix is well and truly dead nowadays
p40876
aVPersonally I think Wine is probably an easier and better option
p40877
as(dp40878
g7
V505088
p40879
stp40880
a((dp40881
g2
(lp40882
VYou need to use  when you export your function so that you suppress C++ name mangling
p40883
aVAnd you also should not try to p/invoke to members of a class
p40884
aVUse free functions instead:
p40885
aVOn the managed side your  attribute is all wrong
p40886
aVDon't use  which is for Win32 APIs only
p40887
aVDon't bother setting  if there are not text parameters
p40888
aVNo need for
p40889
aVAnd the calling convention is presumably
p40890
as(dp40891
g7
V505088
p40892
stp40893
a((dp40894
g2
(lp40895
VYou are making this more complicated than it needs to be
p40896
aVYour C# client does not need to use the  parameter because a C# delegate already has a built in mechanism for maintaining the  pointer
p40897
aVSo you can simply pass  to the delegate
p40898
aVInside your error handler delegate you just ignore the value of  since  will be available
p40899
aVIn case you don't follow this description, here's a short program to illustrate what I mean
p40900
aVNote how  is an instance method that acts as the error handler, and can modify instance data
p40901
as(dp40902
g7
V505088
p40903
stp40904
a((dp40905
g2
(lp40906
VUse multi-select (e
p40907
ag217
aVSHIFT+CLICK, or click and drag a selection rectangle) to select all 20 shapes
p40908
aVIn the Object Inspector set the  event handler to be the common event handler
p40909
aVThis will assign the same event handler to all 20 selected shapes
p40910
aVIf you need to know which shape was clicked from inside your common event handler, use
p40911
as(dp40912
g7
V505088
p40913
stp40914
a((dp40915
g2
(lp40916
VTo the very best of my knowledge, the RTL does not include such a function
p40917
aVYou could use regular expressions to fill the gap:
p40918
aVI'm quite sure this is not the best performing solution, but it would be hard to find something much simpler
p40919
as(dp40920
g7
V505088
p40921
stp40922
a((dp40923
g2
(lp40924
VAllocating strings by doing
p40925
aVin a long running loop will simply fragment your memory
p40926
aVYou may well have sufficient memory for the string but that's not enough
p40927
aVYou need the memory to be contiguous but your allocation pattern will make that hard
p40928
aVSolve the problem by pre-allocating the string to its final desired length with a call to
p40929
as(dp40930
g7
V505088
p40931
stp40932
a((dp40933
g2
(lp40934
s(dp40935
g7
V505088
p40936
stp40937
a((dp40938
g2
(lp40939
VI know this is not a direct answer to your question, but I would recommend using  rather than polling
p40940
as(dp40941
g7
V505088
p40942
stp40943
a((dp40944
g2
(lp40945
VThe error could be caused by one of the following possibilities:
p40946
aVis
p40947
aVis
p40948
aVis
p40949
aVis raising a null pointer exception
p40950
aVUse your debugger to find out which of these possibilities it is, and take it from there
p40951
as(dp40952
g7
V505088
p40953
stp40954
a((dp40955
g2
(lp40956
VThat feature really has gone and there is nothing like it any more in the product, to the very best of my knowledge
p40957
aVI think the best you can do is as follows:
p40958
aVCreate a new project
p40959
aVChange the project settings to whatever you want them to be
p40960
aVChange anything else in the default project that you don't like, for example
p40961
aVAdd this project to the repository
p40962
aVuse File | New | Customize to move this project template onto the File | New menu for easy access
p40963
as(dp40964
g7
V505088
p40965
stp40966
a((dp40967
g2
(lp40968
VSystem
p40969
aVloadlibrary() works fine on Vista
p40970
aVYour problem is that the DLL or one of its dependencies cannot be found
p40971
aVMost likely is that you need to install the appropriate MSVC runtime
p40972
aVYou sometimes get away without doing this on some machines because some other app has already installed the runtime
p40973
aVIf you cannot work this out from the documentation of your native code compiler, I would recommend using Dependency Viewer in profile mode to debug the System
p40974
aVloadlibrary failure
p40975
as(dp40976
g7
V505088
p40977
stp40978
a((dp40979
g2
(lp40980
VWhat you are missing is that you need to make your program import the function from
p40981
aVWhat's more you don't need  for this and you really should avoid using it because it will make your program hard to maintain
p40982
aVYou can import the function just like any other Windows API function:
p40983
aVYou will need a couple of type declarations too:
p40984
as(dp40985
g7
V505088
p40986
stp40987
a((dp40988
g2
(lp40989
VIf you want to reload the design-time package without killing the IDE you can:
p40990
aVOpen the Install Packages dialog
p40991
aVUncheck the package and the re-check it
p40992
aVEdited to remove unnecessary steps
p40993
as(dp40994
g7
V505088
p40995
stp40996
a((dp40997
g2
(lp40998
VThe code that you have has had an incorrect modification made to the  constant
p40999
aVIt should be:
p41000
aVOf course, even better would be to simply throw this routine away and use the version of  that is shipped with Delphi in the  unit
p41001
aVThere seems little point in grappling with this when simply deleting the code will result in a program that is correct
p41002
aVSince you are porting this to C# you can simply use  and pass  to the  parameter
p41003
aVThanks to @Ulrich for recognising that this code originates from the FastCode project
p41004
as(dp41005
g7
V505088
p41006
stp41007
a((dp41008
g2
(lp41009
VIn typical usage you will not see significant difference in the memory usage of / and character  arrays
p41010
aVOn the other hand, if you use character arrays, your code is liable to be full of bugs and leaks and you'll spend all your time dealing with those
p41011
aVIt is accepted by the entire C++ community that  is the way to handle strings
p41012
aVAny mavericks that want to use character arrays should be compelled to prove their point with benchmarks
p41013
aVThe onus should be on the freaks to prove their point of view
p41014
as(dp41015
g7
V505088
p41016
stp41017
a((dp41018
g2
(lp41019
VThe most commonly used tool is Dependency Walker
p41020
aVThis shows the list of exported symbols
p41021
aVHowever, it does not show the function prototypes because they are not contained in the DLL meta data
p41022
aVTo get that information you need a header file for the DLL
p41023
aVThe exception to this statement are DLLs containing a COM/ActiveX component with a type library
p41024
aVAnd even if you do have the prototypes, that's not enough to know how to emulate the DLL
p41025
aVYou need full documentation for the DLL
p41026
aVAnd then you probably still have a lot of reverse engineering to do
p41027
as(dp41028
g7
V505088
p41029
stp41030
a((dp41031
g2
(lp41032
VThis is indeed a documentation error
p41033
aVYou do not need to escape backslashes here
p41034
aVThe exact string that you send to this API is what will be stored in the registry
p41035
aVNo processing of backslashes will be performed
p41036
aVNow, it's true that in C and C++ you need to escape certain characters in string literals, but that's not pertinent to a Win32 API documentation
p41037
aVThat's an issue for source code to object code translation for specific languages and quite beyond the remit of this documentation
p41038
as(dp41039
g7
V505088
p41040
stp41041
a((dp41042
g2
(lp41043
VThere is no  API call in Windows
p41044
aVSo what you need to do is:
p41045
aVEnumerate all the threads in the process
p41046
aVSee RRUZ's answer for sample code
p41047
aVCall  for each of these threads
p41048
aVIn order to implement the resume part of the program, call  for each thread
p41049
as(dp41050
g7
V505088
p41051
stp41052
a((dp41053
g2
(lp41054
VA bit of websearch leads to this page or this one which indicate that the function looks like this:
p41055
aVYou already know what  from your previous question
p41056
aVAs for , that's
p41057
aVSo that means the function declaration in Delphi is:
p41058
aVThe page I link to also includes a declaration for  and I'm sure you can translate that yourself
p41059
aVYou'll still have to reverse engineer what the parameters mean since this is an implementation private, undocumented function
p41060
aVThis is the second question that you have asked that has been almost identical
p41061
aVIn both questions you present the question as being an assembler question
p41062
aVBut it's not
p41063
aVIn both questions you needed to work out the declaration of the function, and how to import it from the external DLL
p41064
aVWhat you should take away from this is that when you need to call a function in another DLL you can do one of two things:
p41065
aVImport it implicitly with the  code that I have shown in both your questions
p41066
aVThis is the simpler approach
p41067
aVUse  and  to explicitly import it
p41068
aVThis is the more laborious approach
p41069
aVPlease don't take this the wrong way \u2013 I'm just trying to show you what you need to know to be able to solve such problems for yourself
p41070
as(dp41071
g7
V505088
p41072
stp41073
a((dp41074
g2
(lp41075
VThe value that  returns is the base pointer for the  function
p41076
aVYou then call  which creates its own stack frame
p41077
aVAnd that stack frame obliterates the data at
p41078
aVTo see that this is so you can write your code this way round:
p41079
aVIn other words you gather up all the information into the stack frame of , before you stomp on it by calling
p41080
as(dp41081
g7
V505088
p41082
stp41083
a((dp41084
g2
(lp41085
VYou can use a class helper to crack the class:
p41086
aVUnit1
p41087
aVUnit2
p41088
aVPass the return value from  to one of your patching functions and you are golden
p41089
as(dp41090
g7
V505088
p41091
stp41092
a((dp41093
g2
(lp41094
VThis trick was never officially supported by the language and you have been getting away with it to date due to the implementation specifics of the 32 bit compiler
p41095
aVThe documentation is clear:
p41096
aVNested procedures and functions (routines declared within other routines) cannot be used as procedural values
p41097
aVIf I recall correctly, an extra, hidden, parameter is passed to nested functions with the pointer to the enclosing stack frame
p41098
aVThis is omitted in 32 bit code if no reference is made to the enclosing environment
p41099
aVIn 64 bit code the extra parameter is always passed
p41100
aVOf course a big part of the problem is that the Windows unit uses untyped procedure types for its callback parameters
p41101
aVIf typed procedures were used the compiler could reject your code
p41102
aVIn fact I view this as justification for the belief that the trick you used was never legal
p41103
aVWith typed callbacks a nested procedure can never be used, even in the 32 bit compiler
p41104
aVAnyway, the bottom line is that you cannot pass a nested function as parameter to another function in the 64 bit compiler
p41105
as(dp41106
g7
V505088
p41107
stp41108
a((dp41109
g2
(lp41110
VThe message tells you all you need to know
p41111
aVThe super-class is object and its constructor takes no parameters
p41112
aVSo don't pass it the parameters for your constructor since it doesn't know what to do with them
p41113
aVCall it like this:
p41114
as(dp41115
g7
V505088
p41116
stp41117
a((dp41118
g2
(lp41119
VFrom your description, this doesn't sound like something that you should let get as far as an exception
p41120
aVEspecially if all you have to go on is
p41121
aVExceptions should be for things you don't have a good way to handle and that's not the case here
p41122
aVI suggest that you check that the new ID is not already in use before you attempt to add the new record
p41123
aVOr, as @TLama suggests, take advantage of any error handling facilities of your DB framework that let you hook this before it becomes an exception
p41124
as(dp41125
g7
V505088
p41126
stp41127
a((dp41128
g2
(lp41129
VThere are no arrays, linked lists, associative arrays in Windows batch
p41130
aVThere is, however, the most arcane, bizarre, counter-intuitive syntax I have ever come across
p41131
aVSeriously, you need to use a real scripting language for this
p41132
aVAnything but batch
p41133
as(dp41134
g7
V505088
p41135
stp41136
a((dp41137
g2
(lp41138
VYou can't expect to bypass the anti-virus software so that leaves two options:
p41139
aVPersuade the AV vendors that your DLL is clean and get them to update their signatures
p41140
aVChange your DLL sufficiently so that it does not fall foul of the scanners
p41141
aVThat's going to require trial and error I guess
p41142
aVIn a previous question you asked how to download a DLL file to memory and then load it from memory rather than a file
p41143
aVI expect most good anti-virus software would regard any software that does that as being malware
p41144
aVIf I were you I would download to a temporary file and use the officially supported LoadLibrary to load the code
p41145
aVThe AV software may be more lenient to that
p41146
aVIf you are not prepared to do that then your software probably is malware in my eyes, even if you don't mean harm
p41147
aVEven if you do that, downloading and executing DLLs from the internet without the user's explicit consent is verging on malware in anyone's eyes
p41148
aVLet's put it another way
p41149
aVI would never let this program of yours run on my machine and I would be pleased when my AV software flagged it
p41150
as(dp41151
g7
V505088
p41152
stp41153
a((dp41154
g2
(lp41155
VThe problem is that you are creating a message-only window which does not receive broadcasts:
p41156
aVA message-only window enables you to send and receive messages
p41157
aVIt is not visible, has no z-order, cannot be enumerated, and does not receive broadcast messages
p41158
aVThe window simply dispatches messages
p41159
aVSo, you cannot use a message-only window and instead need to make a top-level window that is never shown
p41160
aVThat's trivial to achieve \u2014 stop passing  to  and make sure that you never call
p41161
aVAs an aside,  in the middle of a message loop is going to be a disaster
p41162
aVYou need to pump messages in a timely fashion, not fall asleep on the job
p41163
aVYou must get rid of that
p41164
aVNote that  will block if the queue is empty, so you don't need to worry about your application running hot
p41165
aVYour message loop should look like this:
p41166
as(dp41167
g7
V505088
p41168
stp41169
a((dp41170
g2
(lp41171
VThat package is a runtime package containing the VCL
p41172
aVYou presumably also need to deploy rtl90
p41173
aVbpl for the RTL and possibly some others
p41174
aVBy enabling runtime packages you are promising to deploy those packages where the executable can find them
p41175
aVYou have 3 main options:
p41176
aVDeploy the packages to a location that is contained in the PATH variable
p41177
aVUsually this means modifying PATH
p41178
aVYou should never write to the system directory
p41179
aVIt is owned by the system and you should respect that
p41180
aVDeploy the packages to the same directory as the executable file
p41181
aVDisable runtime packages and therefore build a single self-contained executable
p41182
aVThe RTL/VCL code will be statically linked into your executable
p41183
aVOption 1 is poor in my view
p41184
aVRelying on the PATH variable and the ability to modify it is fragile
p41185
aVOption 2 works but seems rather pointless in comparison with option 3
p41186
aVYou deploy more files and larger files when you choose 2, so why choose it
p41187
aVIn summary I recommend option 3
p41188
aVStatically link all RTL/VCL code into your executable
p41189
aVThe only situation where option 2 wins, in my view, is when you have multiple related executables that are all deployed to the same directory
p41190
aVIn that situation sharing the RTL/VCL code can make sense
p41191
as(dp41192
g7
V505088
p41193
stp41194
a((dp41195
g2
(lp41196
VCall it like this:
p41197
aVNote that there is no casting going on here, as suggested in your question title
p41198
aVAll we have done is de-referenced the pointer to the object which we then pass to the function
p41199
as(dp41200
g7
V505088
p41201
stp41202
a((dp41203
g2
(lp41204
VIt evaluates a polynomial in  of the form:
p41205
aVRemember that Fortran uses 1-based array indices and I have followed that convention in this equation
p41206
aVYou could write it in C# like this:
p41207
aVHere we are using 0-based array indexing appropriate to C#
p41208
aVAnd so this function evalutates a polynomial in  of the form:
p41209
as(dp41210
g7
V505088
p41211
stp41212
a((dp41213
g2
(lp41214
VWell, the simple naive answer is that you should add  to the  clause of the implementation section of :
p41215
aVYou can't add it to the  clause in the interface section of  since that would create a circular reference at the interface section
p41216
aVIn order words, the interface of  would uses , and the interface of  would use
p41217
aVThe language does not allow that
p41218
aVThe common solution is to  one of the units at the implementation level
p41219
aVHaving said that, your code is rather confused and fails in many other ways
p41220
aVYour problems run deeper than the circular reference
p41221
aVFor example, what do you mean by
p41222
aVThe constant  is not a member of
p41223
aVYou declare two global variables named  of type
p41224
aVWhy do you do that
p41225
aVAlso, you have spelled child incorrectly
p41226
as(dp41227
g7
V505088
p41228
stp41229
a((dp41230
g2
(lp41231
VSuppose that:
p41232
aVYou have a single instance of an array (static or dynamic), and
p41233
aVThe elements of the array are pure value types (i
p41234
ag192
aVcontain no references), and
p41235
aVEach thread operates on disjoint sub-arrays, and
p41236
aVNothing else in the system writes to the array whilst the threads are operating on it
p41237
aVWith these conditions, which I believe are met by your data structure and threading pattern, then all algorithms are thread-safe
p41238
as(dp41239
g7
V505088
p41240
stp41241
a((dp41242
g2
(lp41243
VYou need to use  to extract the contents of a cell array
p41244
as(dp41245
g7
V505088
p41246
stp41247
a((dp41248
g2
(lp41249
VDoes anyone know a good place where I can download a sample besides MSDN
p41250
aVI found the following samples with a cursory websearch:
p41251
aVA guide to developing Delphi programs in Windows API (without the use of the VCL)
p41252
aVDelphi Without the VCL or the IDE
p41253
aVI'm sure there are plenty more but these two should get you started
p41254
aVHowever, to get anywhere with a raw Win32 GUI you really do need a strong understanding of the windowing framework
p41255
aVFor that I recommend Programming Windows by Charles Petzold, the book that all old-school Windows 1
p41256
aV0 programmers learnt from, back in the day
p41257
aVYes it is old, but it covers the basics that you need as well as ever
p41258
as(dp41259
g7
V505088
p41260
stp41261
a((dp41262
g2
(lp41263
VLet's suppose that we are talking about a base-10 number:
p41264
aVwhere each  is a digit in the range 0 to 9 inclusive
p41265
aVI'm going to assume that you can parse the string that is your input value and find the array
p41266
aVOnce you can do that, and assuming that you have already implemented your  class with the  and  operators, then you are home
p41267
aVYou can simply evaluate the expression above with an instance of your  class
p41268
aVYou can evaluate this expression relatively efficiently using Horner's method
p41269
aVI've just written this down off the top of my head, and I will bet that there are much more efficient base conversion schemes
p41270
as(dp41271
g7
V505088
p41272
stp41273
a((dp41274
g2
(lp41275
VYou can't add a native DLL as a reference to a managed project
p41276
aVYou have 3 main options:
p41277
aVMake the native functions available with p/invoke
p41278
aVExpose the native code through COM
p41279
aVCompile the native code as a managed C++ assembly
p41280
aVFor any serious amount of code, option 3 is the most productive and effective approach
p41281
as(dp41282
g7
V505088
p41283
stp41284
a((dp41285
g2
(lp41286
VA Delphi service, created using the  class, results in an executable that supports self-registration
p41287
aVCall it like this:
p41288
aVNaturally you need elevated rights for this to work, just as you do for any mechanism that installs a service
p41289
aVIn the other direction use  to reverse the process
p41290
aVUse  to make the registration process, well, silent
p41291
aVShould you wish to customise the installation process you can provide event handlers , , ,
p41292
aVFor example, a common use of  is to supply a description for your service since the basic  code does not
p41293
as(dp41294
g7
V505088
p41295
stp41296
a((dp41297
g2
(lp41298
V@RRUZ has already answered an almost identical question on Stack Overflow
p41299
aVHowever, the code there is incorrect in that it declares process IDs as
p41300
aVThe following corrects the mistakes that I found, and also adapts the routine to return a PID rather than a filename:
p41301
aVI know that this is a duplicate question, but the code here is precisely what the OP wants, so I'll leave it visible for a while at least
p41302
as(dp41303
g7
V505088
p41304
stp41305
a((dp41306
g2
(lp41307
VWhilst I believe that it is possible to secure a service so that regular users can start and stop it, I do not recommend doing so
p41308
aVThis will create a lot of complication and is a potential cause for confusion
p41309
aVI always prefer to keep things simple, especially when it comes to installation and security
p41310
aVSo, if we can't let the user start and stop the service we probably need to let the service run all the time
p41311
aVSince you don't want the service to be active all the time I suggest you give the service its own internal  flag
p41312
aVWhen this is set true, the service is active and does busy things, otherwise the service remains idle
p41313
aVYou can use your preferred IPC mechanism (sockets, named pipes, WCF etc
p41314
aVto allow the user to toggle this switch
p41315
as(dp41316
g7
V505088
p41317
stp41318
a((dp41319
g2
(lp41320
VIf FastMM is reporting it as a leak then it really is a leak
p41321
aVYou have created an object and failed to destroy it before the program terminates
p41322
aVUsually this is due to a straightforward error in your code
p41323
aVPerhaps you omitted a try/finally to protect the object's life
p41324
aVIf it's a global scope object that is not being destroyed then you could simply destroy it at program termination
p41325
aVOr you could call RegisterExpectedMemoryLeak to indicate that you do not intend to destroy that object
p41326
aVBut only do that when you intentionally leak an object
p41327
aVDon't use it to paper over a leak that is not intentional
p41328
aVBut the bottom line is that FastMM does not lie
p41329
aVIf it says you are leaking, trust it
p41330
as(dp41331
g7
V505088
p41332
stp41333
a((dp41334
g2
(lp41335
VYou can use  for this
p41336
as(dp41337
g7
V505088
p41338
stp41339
a((dp41340
g2
(lp41341
VYou should use
p41342
aVinstead of calling
p41343
aVDoing it your way, in Python 2 will result in a linear search and rather negates the benefits of a
p41344
aVIn Python 3 your code is efficient (see comments below) but my version is clearer
p41345
as(dp41346
g7
V505088
p41347
stp41348
a((dp41349
g2
(lp41350
VI think it very unlikely that p/invoking to  would be more efficient than a pure C# solution
p41351
aVThere is an overhead in managed/unmanaged transitions and I would think that would be significant for something as trivial as
p41352
aVMyself I would use a C# tokenizer, combined with
p41353
aVThe simplest C# tokenizer is  which yields this routine:
p41354
aVHowever, since I enjoy p/invoke, here's how you would call  from C#, bearing in mind that I recommend you don't use this approach in real code
p41355
aVYou can call it like this:
p41356
aVI'm passing the string as an  because you would be calling  repeatedly to walk across the entire buffer
p41357
aVI didn't show that here, but if you are going to make any use of  then you need to do it as I illustrate
p41358
aVOf course, to use  remotely effectively you need to gain access to the  global variable
p41359
aVThe very fact that you need to deal with a global variable should be warning enough that here be dragons
p41360
aVWhat's more, the error reporting offered through  is exceedingly limited
p41361
aVHowever, if you want it, here it is:
p41362
aVOne final point
p41363
aVYour suggested input string is
p41364
aVbut  won't tokenize that because of the spurious commas
p41365
as(dp41366
g7
V505088
p41367
stp41368
a((dp41369
g2
(lp41370
VThis specifies the preferred base address of the DLL
p41371
aVIf the DLL can be loaded at this address, then the loader will do so
p41372
aVIf it cannot, then it needs to be relocated and all the absolute jumps in the DLL need to be adjusted to the new address
p41373
aVWhen the loader attempts to map a DLL into a process address space, it first reads the preferred base address
p41374
aVThen it works out the size of the DLL
p41375
aVFinally it checks to see if a contiguous block of memory stretching from the base address to the base address + size can be found
p41376
aVIf so then the DLL is loaded at the preferred base address
p41377
aVIf another DLL, or the exe resides at the preferred base address, then the DLL will need to be relocated
p41378
aVIf the application has reserved heap memory that overlaps with the preferred DLL load address space, then the DLL will need to be relocated
p41379
aVIf a DLL needs to be relocated then its physical pages cannot be shared between processes
p41380
aVThe Windows system DLLs have carefully chosen base addresses to ensure that there are no collisions and that they can be shared
p41381
aVNowadays, Address Space Layout Randomization (ASLR) complicates matters even further
p41382
aVYou can learn more from these articles:
p41383
aVDr
p41384
aVDobbs: Rebasing Win32 DLLs
p41385
aVPeering Inside the PE: A Tour of the Win32 Portable Executable File Format
p41386
as(dp41387
g7
V505088
p41388
stp41389
a((dp41390
g2
(lp41391
VTake
p41392
aVThis is equivalent to
p41393
aVBut  is not a
p41394
aVIt is of type
p41395
aVIn other words you need to de-reference your pointer twice, but you have only de-referenced it once
p41396
as(dp41397
g7
V505088
p41398
stp41399
a((dp41400
g2
(lp41401
VIt's presumably meant to switch some condition code
p41402
aVFor example code like this:
p41403
aVwould be influenced by your
p41404
aVIf your code no longer refers to  then presumably it is vestigial
p41405
as(dp41406
g7
V505088
p41407
stp41408
a((dp41409
g2
(lp41410
VThere are no pre-defined window classes for top-level application windows
p41411
aVYou must register a window class for your application, or use a dialog
p41412
as(dp41413
g7
V505088
p41414
stp41415
a((dp41416
g2
(lp41417
VYou can't do that
p41418
aVA C enum is not much more than a bunch of constants
p41419
aVThere's no type-safety or reflection that you might get in a C# or Java
p41420
as(dp41421
g7
V505088
p41422
stp41423
a((dp41424
g2
(lp41425
VYou are probably compiling for Unicode but outputting  a char array
p41426
aVYour symptoms sound like an encoding mismatch and Unicode output function mis-matched against ANSI char array is the mismatch that results in lots of questions marks
p41427
aVIn other words I hypothesise that your code resolves  as
p41428
aVAnd you then fail to satisfy the contract by passing  rather than  when you pass
p41429
aVUse  or  instead of  for
p41430
aVOr call the A version of the output functions
p41431
aVOr compile for ANSI
p41432
as(dp41433
g7
V505088
p41434
stp41435
a((dp41436
g2
(lp41437
VThat's simple in Delphi:
p41438
aVYou'll no doubt have more functions than this, but they should all be easy enough
p41439
aVIf I were you I would go back to the original C++ header file which should be much easier to translate than your p/invokes
p41440
aVI don't think there is any good conversion tool for p/invoke to Delphi import unit
p41441
aVEven for C++ header to Delphi, I'm not convinced that there is good universal tool
p41442
aVYou can look at the JEDI project which has some useful resources, but in my view it's time to roll up your sleeves
p41443
as(dp41444
g7
V505088
p41445
stp41446
a((dp41447
g2
(lp41448
VNo it is not a bug
p41449
aVYou can't use a VLA in C90
p41450
aVWhen you declared
p41451
aVthat is not a constant expression
p41452
aVA constant expression would be something like a literal value
p41453
aVNote that C differs significantly from C++ in this regard
p41454
aVEven a constant like this
p41455
aVis not a constant expression in C
p41456
aVThis is the primary reason why constant values are typically declared with  in C
p41457
as(dp41458
g7
V505088
p41459
stp41460
a((dp41461
g2
(lp41462
VThe simplest way to do this is to store metadata as resources inside DLLs
p41463
aVYou can then use the Windows API resource functions to extract the metadata
p41464
aVYou don't even need to load the DLL as a code module, you can just load it as a data module, and then extract the metadata resources
p41465
aVUse  to, well, load a library
p41466
aVThen you can use  and  to extract your metadata
p41467
as(dp41468
g7
V505088
p41469
stp41470
a((dp41471
g2
(lp41472
VIt's probably something like this:
p41473
aVThe things that are a little hazy are
p41474
aVBecause that is an  parameter and yet it is passed as a pointer to , I imagine it is a
p41475
aVYou will need to declare a matching Delphi record and a pointer type for it
p41476
aVMaybe like this:
p41477
aVThe other parameter that requires care is :
p41478
aVpTemplateArray Pointer to the array of pointers to templates
p41479
aVThis is an array of pointers
p41480
aVArrays in C are passed as pointers to the first element
p41481
aVSo that explains the type, , pointer to first element, which is itself a pointer to an
p41482
aVYou might call the function something like this:
p41483
aVI see now that you have added the struct definitions in an edit
p41484
aVI'll leave my made up structs here because you ought to be able to convert these structs yourself
p41485
as(dp41486
g7
V505088
p41487
stp41488
a((dp41489
g2
(lp41490
VFunction pointers are in fact type checked and are type safe
p41491
as(dp41492
g7
V505088
p41493
stp41494
a((dp41495
g2
(lp41496
VUse the  unit and its two classes,  and
p41497
aVHere is a simple example:
p41498
aVAnd, in the opposite direction:
p41499
aVor the shorthands encodestringbase64 and decodestringbase64 (2
p41500
ag34876
aV4+) for non stream based usage:
p41501
as(dp41502
g7
V505088
p41503
stp41504
a((dp41505
g2
(lp41506
VI think you need  rather than  since Excel uses 1-based indexing
p41507
aVI also could not get your code, using late bound COM to work at all when accessing the series object
p41508
aVBut if you switch to using early bound COM then it is fine
p41509
aVYou will need to add Excel2000, for example, to your uses clause
p41510
aVIf I were you I would switch the whole code to early bound
p41511
aVI think your code is based on this Delphi 3 example from Charlie Calvert
p41512
aVI could not get that to work on my Delphi 6
p41513
aVPerhaps Delphi changed
p41514
aVPerhaps Excel changed
p41515
aVNo matter, the thing that made it work for me was to switch to early bound COM
p41516
as(dp41517
g7
V505088
p41518
stp41519
a((dp41520
g2
(lp41521
VHave a check in Dependency Walker, or  and you will see that  has been exported with a mangled C++ name
p41522
aVThat's why the  call fails
p41523
aVUse  to stop mangling
p41524
as(dp41525
g7
V505088
p41526
stp41527
a((dp41528
g2
(lp41529
VYou are compiling a 32 bit process and there is simply not enough physical address space for your huge data block
p41530
aVA 32 bit pointer can hold 2^32 distinct values, i
p41531
ag192
aV4GB
p41532
aVYou can't allocate more than that because you would have no way to refer to the memory
p41533
aVEach byte of memory that is mapped into your process must have a unique address
p41534
aVSo, nothing is going to fit your data into a 4GB address space
p41535
aVEven if your array was less than 4GB you may have problems allocating a single contiguous block of memory
p41536
aVYou could use a 64 bit process but you'd need to make sure you had enough physical memory to avoid disk thrashing when your array was swapped
p41537
aVOr you could find a different algorithm that did not require such a huge block of memory
p41538
as(dp41539
g7
V505088
p41540
stp41541
a((dp41542
g2
(lp41543
VThis code
p41544
aVwill not compile because  is a string
p41545
aVI guess you were experimenting just before posting this
p41546
aVAll the same you error messages and the question title suggests that     is equal to -1
p41547
aVHence the list index out of bounds error
p41548
aVYou need to add a check that  is not -1 before reading from the list box
p41549
aVis the way you detect that no item is selected
p41550
aVYour code should therefore look like this:
p41551
as(dp41552
g7
V505088
p41553
stp41554
a((dp41555
g2
(lp41556
V returns a
p41557
aVBut you cannot assign one of those to a  because  is more derived than
p41558
aVYou could perhaps solve the problem by making your copy method receive a :
p41559
aVand then at the call site:
p41560
aVOf course, this won't copy any of the  specific stuff, unless you added an override to that effect
p41561
aVBut I don't really know enough about your problem to be confident that this is an appropriate solution
p41562
as(dp41563
g7
V505088
p41564
stp41565
a((dp41566
g2
(lp41567
VThe string parameters that you declared as  were always wrong
p41568
aVI guess you got away with that by chance in earlier
p41569
aVnet versions
p41570
aVThe C++ code declares these parameters as , i
p41571
ag192
aVpointer to  null terminated character array
p41572
aVThe correct way to declare these parameters in your C# code is as
p41573
aVThe p/invoke marshaller will take care of turning your C# strings into C strings and you can remove all the spurious  code
p41574
as(dp41575
g7
V505088
p41576
stp41577
a((dp41578
g2
(lp41579
VI think you are mistaken in executing cmd
p41580
aVexe
p41581
aVI'd say you should be executing python
p41582
aVexe, or perhaps executing main
p41583
aVpy with UseShellExecute set to true
p41584
aVAt the moment, your code blocks at p
p41585
aVWaitForExit() because cmd
p41586
aVexe is waiting for your input
p41587
aVYou would need to type exit to make cmd
p41588
aVexe terminate
p41589
aVYou could add this to your code:
p41590
aVBut I would just cut out cmd
p41591
aVexe altogether and call python
p41592
aVexe directly
p41593
aVSo far as I can see, cmd
p41594
aVexe is just adding extra complexity for absolutely no benefit
p41595
aVI think you need something along these lines:
p41596
aVAlso the Python script appears to output to a file rather than to stdout
p41597
aVSo when you do p
p41598
aVStandardOutput
p41599
aVReadToEnd() there will be nothing there
p41600
as(dp41601
g7
V505088
p41602
stp41603
a((dp41604
g2
(lp41605
VIt's (yet another) bug in VCL styles
p41606
aVThe  function is returning a stale icon handle
p41607
aVI'd fix it by replacing  with
p41608
aVAdd this to one of your units and all is well again
p41609
as(dp41610
g7
V505088
p41611
stp41612
a((dp41613
g2
(lp41614
VGiven that you are using C++, you should not be using arrays
p41615
aVInstead  is the appropriate data structure
p41616
aVCreate one of these to hold your registry key strings
p41617
aVWhere you currently print , instead add to :
p41618
aVIf you are building for Unicode, then use  instead
p41619
aVYour function might look like this:
p41620
as(dp41621
g7
V505088
p41622
stp41623
a((dp41624
g2
(lp41625
V is integer division that returns 0
p41626
aVThis then gets converted to a floating point value, 0
p41627
aV0 when you assign to
p41628
aVYou need to perform floating point division, for example by writing
p41629
as(dp41630
g7
V505088
p41631
stp41632
a((dp41633
g2
(lp41634
VIn C, if you have a pointer to an array, then there is not way to determine the length of that array
p41635
aVAs @AProgrammer points out, the designers could have left it at that and forced the programmer to keep track of the length of all character arrays
p41636
aVHowever, that would have made text processing in C even harder than it already is
p41637
aVTherefore the language designers settled on a convention that would allow string length to be inferred by the presence of a null character indicating the end of the string
p41638
aVFor example, consider :
p41639
aVThere is no way in C to determine the length of the array that the pointers  and  point to
p41640
aVSo, without the presence of a sentinel value to indicate the end of the string, the only other solution would have been to pass extra parameters indicating the length of the  string
p41641
aVOf course, in light of modern security considerations, string processing functions that receive buffer length parameters have been introduced
p41642
aVBut the computing landscape looked very different at the time that the null-terminated string was invented
p41643
as(dp41644
g7
V505088
p41645
stp41646
a((dp41647
g2
(lp41648
VThis code is all wrong:
p41649
aVThe local variable  is never assigned to
p41650
aVSo when you call , anything can happen
p41651
aVYou need to move  to the bottom of the unit so that it appears after the real
p41652
aVAnd you need to remove the function pointer variable
p41653
aVYou also should not use  as a parameter (or indeed a return value) in an exported DLL function
p41654
aVIt's not a valid type for interop since it relies on both sides of the interface using the same  implementation, and the same memory manager
p41655
aVYou need to find a different way to define the  interface, if you are going to export it
p41656
aVOr possibly you should not be exporting that function at all
p41657
aVImpossible for me to know with any certainty
p41658
aVMy guess is that you are actually calling  rather than  from the calling code
p41659
aVAnyway, in its current state, you must not export
p41660
aVOne other point to make
p41661
aVWhen you ask a question that involves a module interface, you should always show both sides of the interface
p41662
aVHere you have shown the DLL, but not the code that calls into the DLL
p41663
aVThe error could be there
p41664
aVIndeed, there could be an error there in addition to the errors I have pointed out
p41665
as(dp41666
g7
V505088
p41667
stp41668
a((dp41669
g2
(lp41670
VNo, string literals are stored wherever your compiler fancies
p41671
aVThe fact that you declared two of them in consecutive lines is irrelevant
p41672
aVYou can make no assumptions about where the compiler will store them
p41673
aVThe compiler can do all sorts of things
p41674
aVFor example, if you write the following code
p41675
aVthen the compiler is perfectly at liberty to create only a single literal
p41676
aVOr not
p41677
as(dp41678
g7
V505088
p41679
stp41680
a((dp41681
g2
(lp41682
VYour problem is that you are calling VCL methods from outside the main GUI thread, i
p41683
ag192
aVin TMainWindow
p41684
aVServerSocketExecute
p41685
aVThis event executes in a worker thread
p41686
aVCalling VCL/GUI code from a worker thread is simply against the rules of the game
p41687
aVAll VCL code must execute in the main GUI thread
p41688
aVSo, solve the problem by making sure that all VCL/GUI code executes in the GUI thread
p41689
aVUse the TIdPeerThread
p41690
aVSynchronize() method, or the TIdSync or TIdNotify class to achieve this
p41691
aVThanks to @Remy for supplying the details that I did not know
p41692
as(dp41693
g7
V505088
p41694
stp41695
a((dp41696
g2
(lp41697
VThat parameter most likely meant something in an earlier version of the OS, possibly even pre-release internal versions
p41698
aVBut the feature it controlled has been removed, or was never publicly released
p41699
aVOnce binaries have been built that used that parameter, MS would not have wanted to change the signature of the function
p41700
aVDoing so would have broken those pre-existing binaries
p41701
as(dp41702
g7
V505088
p41703
stp41704
a((dp41705
g2
(lp41706
VNowadays the recommendation is not to use  and use  instead to set up your build environment
p41707
aVPass the  argument to select a 64 bit build environment
p41708
aVThis MSDN page has some more information about
p41709
as(dp41710
g7
V505088
p41711
stp41712
a((dp41713
g2
(lp41714
VThe obvious explanation is that in this code
p41715
aVinside the  you are doing  and setting  to the null pointer
p41716
aVYou need to add a test for  in your  loop to protect against getting to the end of the list without finding an item that meets your search criterion
p41717
aVIt would have helped if you had included all the code because it seems that the key bit of code is in the  block
p41718
as(dp41719
g7
V505088
p41720
stp41721
a((dp41722
g2
(lp41723
VCall  to get the value
p41724
aVThe  class has a whole family of  methods that allow you to read from unmanaged memory
p41725
as(dp41726
g7
V505088
p41727
stp41728
a((dp41729
g2
(lp41730
V means Long String Clear
p41731
aVIt is used to, well, clear a long string variable
p41732
aVIn other words, when you write:
p41733
aVthen the compiler will generate a call to the runtime support function
p41734
aVIn Unicode Delphi it will be  where the U signifies  as opposed to
p41735
aVThere's no official documentation for this because it is all private implementation detail
p41736
aVHowever, there is the source code for the Delphi RTL
p41737
aVIf you refer to that, such calls are simple to understand
p41738
as(dp41739
g7
V505088
p41740
stp41741
a((dp41742
g2
(lp41743
VI think your  is designed incorrectly
p41744
aVRather than attempting to pass an index, I would simply pass the -th element
p41745
aVand call it like this:
p41746
aVYou really ought to get out of the habit of using the  operator as a means to index an array
p41747
aVUse the indexing  syntax
p41748
aVI know that they can be interchangeable but the indexing syntax conveys intent
p41749
aVIn the comments you state that the index is in fact only known inside  and is in fact not a parameter as stated in the question
p41750
aVIn that case, pass  to
p41751
aVYour code with the reference parameter modifies  because that's the  reference that you passed in
p41752
aVBut you want to modify the -th node
p41753
aVIf you pass a reference to a  then you can only modify that one object
p41754
aVIn order to do what you need then you need to pass
p41755
as(dp41756
g7
V505088
p41757
stp41758
a((dp41759
g2
(lp41760
VBased on knowledge of your previous questions, it's like this, I think:
p41761
as(dp41762
g7
V505088
p41763
stp41764
a((dp41765
g2
(lp41766
VYour code is fine
p41767
aVWhen you pass around the method pointer TFooBar you are passing two pointers, a function pointer and an instance pointer
p41768
aVWhen you invoke that method, all versions of Delphi do the exact same thing to invoke the method because the calling convention enforces a precise binary interface
p41769
aVAnd all versions of Delphi represent a method pointer in the same way
p41770
aVThe problems that you are concerned about are:
p41771
aVDifferent memory managers
p41772
aVNo problem here because we are not doing heap allocation
p41773
aVDifferent object representation on different compilers
p41774
aVNo problem here as invoking a method pointer does not rely on object representation
p41775
aVIt relies on the code pointer and the data pointer (passed by value between modules) and the calling convention (agreed to be the same by convention)
p41776
as(dp41777
g7
V505088
p41778
stp41779
a((dp41780
g2
(lp41781
VYou need to use  to produce multi-line text:
p41782
aVYou may very well want to use different flags in the final parameter, but I'm sure you can read the documentation and work out what you need
p41783
as(dp41784
g7
V505088
p41785
stp41786
a((dp41787
g2
(lp41788
VThese properties of the file can be modified to take any value
p41789
aVSo there's absolutely nothing to stop this happening
p41790
aVThat said, the most likely explanation is that the file was copied from one place to another
p41791
aVThe creation time will be the time the copy took place
p41792
aVThe modification time will be the time the source file was last modified, i
p41793
ag192
aVbefore the copy
p41794
aVSo, when the file is copied, the modification time is also copied
p41795
aVTo see this happen, simply pick a file on your machine
p41796
aVCreate a copy of it (CTRL+C, CTRL+V) and look at the properties of the copy
p41797
aVIn other words, it is actually not a contradiction for the creation time to be later than the modification time
p41798
aVThe creation time is when this file object was created
p41799
aVThe modification time is when the file contents were modified
p41800
as(dp41801
g7
V505088
p41802
stp41803
a((dp41804
g2
(lp41805
VYou are going to need to store this in something at least 7 bytes to gain the uniqueness property that you desire
p41806
aVThat therefore suggests
p41807
aVSimply copy the 7 bytes of a  into a  and you are done
p41808
aVFor the ordering part of your requirement you may need to reverse the order of the bytes depending on which end of your row array is most significant
p41809
as(dp41810
g7
V505088
p41811
stp41812
a((dp41813
g2
(lp41814
VIf it were safe to use the same matrix as both input and output, the BLAS implementation would need to use a temporary workspace
p41815
aVSince you did not provide such a workspace because the function did not request one, we can conclude that you cannot use the same matrix as input  and output
p41816
aVIn fact, if a BLAS routine is going to accept a parameter as both input and output, then it would do so by using one parameter rather than two and documenting that the parameter is used for both input and output
p41817
aVYou say that using a temporary output variable and then copying after the BLAS call is slow
p41818
aVBut that copy operation should be insignificant in comparison the the matrix multiply
p41819
aVAre you sure that the copy is a bottleneck
p41820
aVDid you time it
p41821
as(dp41822
g7
V505088
p41823
stp41824
a((dp41825
g2
(lp41826
VYour hex conversion in the question is incorrect
p41827
aVThat number is actually $cbf29ce484222000 and does not fit into a signed 64 bit integer
p41828
aVYou would need an unsigned 64 bit integer to represent it
p41829
aVThere is no unsigned UInt64 in Delphi 5 and so you are out of luck
p41830
aVThere is no integral data type that can represent that number in your version of Delphi
p41831
aVYou could perhaps interpret the bit pattern as a signed value if that does what you need
p41832
aVIn that case you would have a negative number
p41833
as(dp41834
g7
V505088
p41835
stp41836
a((dp41837
g2
(lp41838
VSince you are using relative paths, the file will be relative to the working directory of the process at the point at which you call into the native code
p41839
aVThis is a rather brittle arrangement as you have discovered
p41840
aVI would solve the problem by adding an extra string parameter to the native code that specifies the full path of the file to use
p41841
aVYou can generate this easily enough from your managed code I am sure
p41842
aVNative code
p41843
aVManaged code
p41844
aVThe other point to make is that your function to read data is incorrect
p41845
aVIt attempts to return a stack allocated buffer
p41846
aVYou need to allocate a buffer in the managed code and then pass that to the native code
p41847
aVPerhaps something like this:
p41848
aVAnd on the managed side:
p41849
as(dp41850
g7
V505088
p41851
stp41852
a((dp41853
g2
(lp41854
VBoth these versions of code have undefined behaviour in the face of multiple threads executing the functions
p41855
aVCertainly different compilers can do different things regarding saving the global variable into registers, or not
p41856
aVWhat's more, there's no guarantee that assigning to a local variable can be done in an atomic way with respect to threads that are mutating the global variable
p41857
as(dp41858
g7
V505088
p41859
stp41860
a((dp41861
g2
(lp41862
VThe pinvoke signature is wrong
p41863
aVIt should be:
p41864
aVAnd to call it you need to do this;
p41865
aVYou can't rely on the p/invoke marshaller to marshal the string value because it does not own the string
p41866
aVThe DLL owns the string
p41867
aVWhat's more, you should be specifying the calling convention for the LAME DLL functions, otherwise you will end up with the default pinvoke calling convention,
p41868
aVThat does not matter for a function with no parameters but it's a good habit to get into
p41869
as(dp41870
g7
V505088
p41871
stp41872
a((dp41873
g2
(lp41874
VThe string returned by this function is statically allocated and you do not need to free that memory
p41875
aVThis means that your current code is already exactly what you need
p41876
aVThis is an open source project and so a websearch leads to the source code for the implementation of this function to confirm this
p41877
aVAs an aside, your p/invoke is incorrect, although it is benign
p41878
aVIt should be:
p41879
aVThere's no need to specify  since the function has no text parameters
p41880
aVAnd in any case  is the default so you still would not need to specify that
p41881
aVThe calling convention is, in general, important and will need to be set for all your LAME imports
p41882
aVIt doesn't actually matter for a function with no parameters, but specifying the calling convention is a good habit to get in to
p41883
as(dp41884
g7
V505088
p41885
stp41886
a((dp41887
g2
(lp41888
VWhilst you can do this using polling (i
p41889
ag192
aVEnumProcesses), the best way to do it is an event driven approach
p41890
aVAnd to do that you need to use WMI
p41891
aVThis MSDN page gives sample code
p41892
aVUpdate Apparently you can use Event Tracing for Windows as an alternative, but I personally know nothing about that
p41893
as(dp41894
g7
V505088
p41895
stp41896
a((dp41897
g2
(lp41898
VThis is really a rather subjective topic
p41899
aVIn my view, there's nothing fundamentally wrong with three nested while loops, but you are reaching the limit of acceptability
p41900
aVWere you to add one or two more levels of nesting then you would, in my view, cross the boundary of what is reasonable to expect a reader to comprehend
p41901
aVThe human brain can only handle so much complexity at any one point in time
p41902
aVSome people would argue, counter to my opinion, that there should be no more than one level of nesting in a function, and that functions should not contain more than around 10 lines of code
p41903
aVThe counter argument is that such a policy can result in more fragmented, disjoint code
p41904
aVMy rule of thumb is that if you cannot think of a good function name for a chunk of code, then perhaps that chunk of code is not really meant to stand alone as a function
p41905
aVLooking at ways in which you could break this function up, there are a couple of obvious options
p41906
aVExtract the body of the outermost  into a separate function
p41907
aVThat extracted function would process a single line
p41908
aVIt would be easy to name and clear to read
p41909
aVExtract the  loop that skips whitespace into a separate function
p41910
aVThat again would be easy to name and would make your code easier to read
p41911
aVYou would remove the whitespace comment because the name of the extracted function would render it needless
p41912
aVThat's probably worth doing
p41913
aVIf you applied these ideas then your code might look a little like this:
p41914
aVNote that the refactoring and naming of extracted methods makes the comments a little superfluous and I removed them
p41915
aVAnother good rule of thumb is that if you need to comment code too much, then perhaps it is not yet well-factored
p41916
aVUltimately, there really are not hard and fast rules, and it comes down to judgement and personal preference
p41917
aVIn my view, the code in the question is very clear and readable, but the refactored version is just a little clearer, in my view
p41918
aVDisclaimer: I make no comment regarding the correctness or otherwise of the code
p41919
aVI simply ignored that aspect
p41920
as(dp41921
g7
V505088
p41922
stp41923
a((dp41924
g2
(lp41925
VThe key to understanding this is to know the difference between a value type and a reference type
p41926
aVFor example, consider a typical value type,
p41927
aVAfter this code has executed,  has the value 2, and  has the value
p41928
aVBecause  is a value type,  takes a copy of the value of
p41929
aVNow consider a class:
p41930
aVBecause classes are reference types,  merely assigns the reference rather than the value
p41931
aVSo  and  both refer to the same object
p41932
aVHence, after  executes,  since  and  refer to the same object
p41933
aVConsidering the code in your question, an array is a reference type and so for this function:
p41934
aVthe variable  is actually a reference, because  is a reference type
p41935
aVSo  is a reference that is passed by value
p41936
aVThus, modifications made to  inside the function are actually applied to the  object to which  refers
p41937
aVAnd so those modifications are visible to all references that refer to that same object
p41938
aVAnd that includes the reference that the caller holds
p41939
aVNow, if we look at the implementation of this function:
p41940
aVthere is one further complication
p41941
aVThe  loop simply doubles each element of the  that is passed to the function
p41942
aVThat's the modification that the caller sees
p41943
aVThe second part is the assignment of a new  object to the local variable
p41944
aVThis is not visible to the caller because all it does is to change the target of the reference
p41945
aVAnd since the reference  is passed by value, the caller does not see that new object
p41946
aVIf the function had been declared like this:
p41947
aVthen the reference  would have been passed by reference and the caller would see the newly created object  when the function returned
p41948
as(dp41949
g7
V505088
p41950
stp41951
a((dp41952
g2
(lp41953
VFastMM allocates some memory at the end of the block that you allocate and writes known values there
p41954
aVThen, when you deallocate, FastMM checks that those values are as expected
p41955
aVIf not, then the error that you see is raised because FastMM knows that your code is writing beyond the end of the memory block
p41956
aVSo, something inside the try/finally block is writing beyond the end of the block of memory
p41957
aVAnd that's why increasing its size removes the FastMM error
p41958
aVWithout seeing that code, we cannot tell what exactly is wrong and you will need to do some debugging to solve the problem
p41959
aVYou are quite right to be concerned by your "solution"
p41960
aVTrial and error is never a reasonable way to program
p41961
aVYou must find out why your program is writing beyond the end of the block
p41962
aVOne way to do that is to set a data breakpoint for the address immediately beyond the end of this block
p41963
aVThat would force the debugger to break on the code that writes beyond the end of the block
p41964
aVAs an aside, you don't need to pass the second parameter to FreeMem
p41965
aVDoing so makes your code harder to maintain and serves absolutely no purpose
p41966
aVPass just the pointer to FreeMem
p41967
as(dp41968
g7
V505088
p41969
stp41970
a((dp41971
g2
(lp41972
VIn fact you are changing the wrong property
p41973
aVYou certainly do want  to be the OK button
p41974
aVThis property determines which is the default button in Windows terms
p41975
aVThat is the button which is pressed when you hit ENTER on your keyboard
p41976
aVBy changing  you are simply breaking the keyboard interface to your dialog
p41977
aVYou are not influencing in any way what happens when the button is pressed
p41978
aVWhat you need to do is set the  property of your button to  since that's what determines whether or not a button press closes the form
p41979
aVThen, inside the button's click handler you need to decide how to respond to the button press
p41980
aVI expect that, if the validation of the dialog is successful, you should close the dialog by setting the form's  property
p41981
aVFor example
p41982
as(dp41983
g7
V505088
p41984
stp41985
a((dp41986
g2
(lp41987
VA 64 bit process can only execute 64 bit code
p41988
aVA 32 bit process can only execute 32 bit code
p41989
aVNow, the operating system kernel, for a 32 bit process, will switch into 64 bit mode for any kernel level system calls
p41990
aVBut that's really the business of the operating system
p41991
aVWhen you call , from a 64 bit process, you are calling the 64 bit
p41992
aVWhen you call from a 32 bit process, you are calling hte 32 bit
p41993
aVIt doesn't matter whether the target window is in a 32 or 64 bit process, what matters is the bitness of the executing code
p41994
aVThe section of your question which talks about 32 bit versions of the p/invoke signatures doesn't make much sense to me
p41995
aVI can't really say more without seeing any code
p41996
aVYou wonder whether or not you need to compile your app for 32 bit
p41997
aVI doubt it
p41998
aVYou are doing automation of a different process
p41999
aVIt is perfectly normal for a 32 bit process to automate a 64 bit process, and vice versa
p42000
aVWhat you can't mix is different bitness modules in the same process
p42001
aVYou can't load a 32 bit DLL from a 64 bit executable
p42002
aVAnd vice versa
p42003
aVBut you are not doing that, which means that you can compile your app for either 32 bit or 64 bit
p42004
aVNow, having said that you can use either 32 or 64 bit process, I would recommend that you target 32 bit
p42005
aVThe reason being it makes your deployment simpler since you have just a single version of the app
p42006
aVYes, you could use AnyCPU, but why bother
p42007
aVIf you don't need 64 bit process then it is simpler to stick to the lowest common denominator
p42008
as(dp42009
g7
V505088
p42010
stp42011
a((dp42012
g2
(lp42013
VWhilst this can be made safe, you are playing with fire
p42014
aVYou run the risk of re-entrancy
p42015
aVYou have to make sure that the user cannot press the button again
p42016
aVI trust you have disabled it whilst the search is running
p42017
aVYou must make sure that it is disabled before you first call
p42018
aVMy advice would always be to avoid using
p42019
aVBetter would be to start the thread and arrange for it to notify the main thread when it is done
p42020
aVOf course, you still need to disable the button whilst the thread is running
p42021
aVHowever, if you really must use  don't do it with a busy loop like this
p42022
aVThere's not much point using an entire processor to wait for a long running search operation to complete
p42023
aVUse a more intelligent blocking loop like this:
p42024
aVThe  function will block until either:
p42025
aVA message is placed on the queue, or
p42026
aVThe thread is signaled
p42027
aVThe thread is signaled when it is complete
p42028
aVThe loop terminates when the thread is signaled, but also processes any queued messages
p42029
as(dp42030
g7
V505088
p42031
stp42032
a((dp42033
g2
(lp42034
VThe equivalent Delphi code to your Cocoa code is:
p42035
aVIf your dictionary is very large then this will not be the most efficient solution
p42036
aVOn the other hand, it's probably the quickest and easiest approach to implement
p42037
as(dp42038
g7
V505088
p42039
stp42040
a((dp42041
g2
(lp42042
VBuilding on the code in your answer you need to use the following:
p42043
aVThe native code is passed a pointer to the context  and passing the struct by  is the easy way to match that
p42044
aVThe final parameter is , which is  and that is plain  in managed code
p42045
aVAs for , define it like this:
p42046
aVYou can then obtain one of those like this:
p42047
aVAnd then you can get hold of the string values from the  with  or
p42048
as(dp42049
g7
V505088
p42050
stp42051
a((dp42052
g2
(lp42053
VDo I need to find/write my own swap byte order function
p42054
aVYes you do
p42055
aVBut, to make it easy, I refer you to this question: How do I convert between big-endian and little-endian values in C++
p42056
aVwhich gives a list of compiler specific byte order swap functions, as well as some implementations of byte order swap functions
p42057
as(dp42058
g7
V505088
p42059
stp42060
a((dp42061
g2
(lp42062
VYou don't need to return GDI resources in order for a process to close
p42063
aVNaturally you ought to return them, but that won't be stopping you from terminating
p42064
aVIt sounds very much like you have a deadlock in your DLL unload
p42065
aVAnd since your DLL fails to unload then you naturally don't get to release all your GDI resources
p42066
aVDebugging this is going to involve debugging a deadlock
p42067
aVIt's rather hard to give general advice on this, and unfortunately you are using an older and less capable version of Delphi
p42068
aVThe modern Delphi debugger supports wait chain traversal and make it rather simple to debug deadlocks
p42069
aVI think if I were you I would do some post-mortem debugging when your app is in its deadlocked state
p42070
aVI'd look at the stack traces for all the threads and use that to home in on whatever it is that blocks indefinitely
p42071
aVUse Process Explorer and map2dbg to get hold of meaningful stack traces when the program is in its deadlocked state
p42072
as(dp42073
g7
V505088
p42074
stp42075
a((dp42076
g2
(lp42077
VYou should use an overloaded function
p42078
aVYou already have the perfect solution to the problem and there is no need to look for a different way to do this
p42079
aVYou could try with a single function that receives a , but then that function will also receive anything which means that the following would also be legal:
p42080
aVUsing an overload allows you to maintain compile time type safety and there is absolutely no loss of generality in using an overload
p42081
as(dp42082
g7
V505088
p42083
stp42084
a((dp42085
g2
(lp42086
VCall  and set  to  to stop the timer
p42087
as(dp42088
g7
V505088
p42089
stp42090
a((dp42091
g2
(lp42092
VWhat I really want is Delphi to run its  blocks before
p42093
aVIs this possible
p42094
aVNo it is not possible
p42095
aVIf you need to perform shutdown actions that cannot be done during  then you will need to add an exported function to your DLL that peforms the finalization
p42096
aVYou should then require your DLL's clients to call this function before unloading the DLL
p42097
aVThis is the same pattern as /
p42098
as(dp42099
g7
V505088
p42100
stp42101
a((dp42102
g2
(lp42103
VYou still have a number of the same problems as you have in the last question
p42104
aVThis time round your biggest problem is here:
p42105
aVYou can't modify  since it is owned by the pinvoke marshaller
p42106
aVInstead of passing the directory to your native code, pass the full path to the file
p42107
aVUse  in your managed code to create that, and pass it to the native code
p42108
aVand in managed code
p42109
aVIn a comment you explain that you need to concatenate strings in the native code
p42110
aVYou will need to create a native string to do that because you are not allowed to write to
p42111
aVSomething like this:
p42112
aVBut you still need to fix  which reads the file
p42113
aVMy answer at your other question tells you how to do that
p42114
as(dp42115
g7
V505088
p42116
stp42117
a((dp42118
g2
(lp42119
VThe problem is almost certainly not in your program
p42120
aVUser mode code does not produce kernel faults
p42121
aVThe problem is either in your hardware or the drivers
p42122
aVYou should direct your search in that direction rather than investigating your code
p42123
as(dp42124
g7
V505088
p42125
stp42126
a((dp42127
g2
(lp42128
VThis is down to the file system redirector
p42129
aVYou will be running a 32 bit process on a 64 bit machine
p42130
aVThat means that  is transparently redirected to  and I expect that  cannot be found there
p42131
aVIf you use  instead then you will be able to locate the file
p42132
aVHowever, I suspect that you have added  to the system directory since this is not a standard Windows component
p42133
aVYou should not do that
p42134
aVI recommend you put the file somewhere else because you simply should not be writing in the system directory
p42135
as(dp42136
g7
V505088
p42137
stp42138
a((dp42139
g2
(lp42140
VReading an uninitialized variable can lead to undefined behavior
p42141
aVThe standard says this:
p42142
aVInitializers [dcl
p42143
aVinit]
p42144
aVIf no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value
p42145
as(dp42146
g7
V505088
p42147
stp42148
a((dp42149
g2
(lp42150
VIn C# there is no such thing as
p42151
aVAn array of  would be
p42152
aVI guess you are coming at this from a C++ viewpoint and actually want an array of bytes, of length 8
p42153
aVIn which case the type you need is
p42154
aVNote that you want  rather than  since  in C# is a 16 bit data type
p42155
aVYou can obtain what you need by calling
p42156
aVWhen you call this function passing an 8 byte integer, the returned array will be a  with length equal to 8, as stated in the documentation
p42157
as(dp42158
g7
V505088
p42159
stp42160
a((dp42161
g2
(lp42162
VClearly, for your compiler, when you include , that header also includes something that includes
p42163
aVVisual Studio does not automatically include anything and so this is the only explanation for what you describe
p42164
as(dp42165
g7
V505088
p42166
stp42167
a((dp42168
g2
(lp42169
VThe method used to terminate execution varies between shells
p42170
aVFor Wing IDE you use the Restart Shell item on the Options menu
p42171
as(dp42172
g7
V505088
p42173
stp42174
a((dp42175
g2
(lp42176
VI think the latest addition of code provides a clue as to the real problem:
p42177
aVThis cannot work because  is an member function
p42178
aVYou need to be calling a C style function rather than a C++ member function
p42179
aVThe latter requires an instance ( in the code sample)
p42180
as(dp42181
g7
V505088
p42182
stp42183
a((dp42184
g2
(lp42185
VThe MSDN page that the warning refers to is the documentation of the native function
p42186
aVIt gives the signature as:
p42187
aVSo the first warning is referring to the fact that  is a pointer sized unsigned integer
p42188
aVThat means you should use
p42189
aVThe next thing that jumps out is that the  struct is indicated as
p42190
aVThat means you need to pass it by
p42191
aVSo the p/invoke declaration should be:
p42192
aVThe final warning is simple to resolve
p42193
aVSimply place your p/invoke declaration inside a class named
p42194
as(dp42195
g7
V505088
p42196
stp42197
a((dp42198
g2
(lp42199
VMost likely you are running the 64 bit version of regsvr32 and your OCX is 32 bit
p42200
aVSince regsvr32 loads the OCX DLL into its process, you must use the 32 bit version of regsvr32
p42201
aVThat can be found in C:\u005cWindows\u005cSysWOW64
p42202
as(dp42203
g7
V505088
p42204
stp42205
a((dp42206
g2
(lp42207
VIn this code:
p42208
aVyou are writing over the end of  because  is an array of length  but you are writing  elements
p42209
aVThat then overwrites  which happens to appear immediately after  in memory
p42210
aVAnd that explains the error when you subsequently read the now corrupted
p42211
aVEither change your loop termination test, or increase the length of
p42212
aVI can't tell which one is the correct solution, but clearly you will know
p42213
as(dp42214
g7
V505088
p42215
stp42216
a((dp42217
g2
(lp42218
VAssuming that you have  as an  then the naive translation to C# is simply:
p42219
aVThe players here are:
p42220
aV: a pointer to the first scanline, i
p42221
ag192
aVthe beginning of the pixel data
p42222
aV: the row number
p42223
aV: the number of bytes in a row of pixels
p42224
aV: a pointer to the beginning of row
p42225
aVBut this would be under the assumption that you were using unmanaged memory for
p42226
aVI don't know whether or not you are
p42227
aVIf you are using managed memory, then the translation would differ
p42228
aVIf you want more help you need to tell us about the types that your managed version uses
p42229
as(dp42230
g7
V505088
p42231
stp42232
a((dp42233
g2
(lp42234
VThe return value of the two functions is declared as
p42235
aVSince it is passed by value it has no meaning
p42236
aVYou can remove that  since it serves absolutely no purpose
p42237
as(dp42238
g7
V505088
p42239
stp42240
a((dp42241
g2
(lp42242
VI have experienced exactly this
p42243
aVIn my case the problem was my anti-virus  (Sophos at that time)
p42244
aVI had to completely uninstall the AV program to resolve the problem
p42245
as(dp42246
g7
V505088
p42247
stp42248
a((dp42249
g2
(lp42250
VUse whatever you find easiest to develop in
p42251
aVC# and WinForms would be a very reasonable choice
p42252
aVIt's true that a native solution will be lighter than managed code
p42253
aVBut, for the type of application you are describing, and unless you are planning to run on a 15 year old machine, you won't suffer from performance problems no matter what language/tools you choose to use
p42254
as(dp42255
g7
V505088
p42256
stp42257
a((dp42258
g2
(lp42259
VThere is no workaround
p42260
aVYou will need to use LoadLibrary and GetProcAddress
p42261
aVThat's really no fun at all so I'd try to avoid going that way if feasible
p42262
as(dp42263
g7
V505088
p42264
stp42265
a((dp42266
g2
(lp42267
VThe  operator in Visual Basic is used to concatenate strings
p42268
aVIn C# the concatenation operator is  and so the direct translation is
p42269
aVBetter in my view would be to use :
p42270
as(dp42271
g7
V505088
p42272
stp42273
a((dp42274
g2
(lp42275
VYou simply call the  function to create these matrices
p42276
aVThe documentation of the native interface contains good examples that show how to do this
p42277
aVIn order to set the data you can use
p42278
aVIt's not as efficient as direct pointer access, but that's rather harder to achieve from managed code
p42279
as(dp42280
g7
V505088
p42281
stp42282
a((dp42283
g2
(lp42284
VIn general, the compiler/linker would need to recognise the particular form of  that you are using and then include code to adapt that from the system startup function to your C or C++  function
p42285
aVIt is true that specific compilers on specific platforms could get away without doing this, using the methods that Hans describes in his answer
p42286
aVHowever, not all platforms use the stack to pass parameters, and it is possible to write conforming C and C++ implementations which have incompatible parameter lists
p42287
aVFor such cases, then the compiler/linker would need to determine which form of  to call
p42288
as(dp42289
g7
V505088
p42290
stp42291
a((dp42292
g2
(lp42293
VThe correct declaration of  is:
p42294
aVMake sure that you check for the presence of  in  before writing to
p42295
aVThat test determines whether or not you should return a Unicode or ANSI string
p42296
aVThis nuance is described in the documentation
p42297
as(dp42298
g7
V505088
p42299
stp42300
a((dp42301
g2
(lp42302
VYou are trying to allocate a 4GB block in a 32 bit process
p42303
aVThat's not possible
p42304
aVYou are limited to somewhere between 2GB and 4GB addressable space, but in reality much less will be available in a single contiguous block
p42305
aVIf you really need such a large block in a single array then you'll want to switch to a 64 bit process
p42306
aVReconsidering your algorithm is likely to be the best solution
p42307
as(dp42308
g7
V505088
p42309
stp42310
a((dp42311
g2
(lp42312
VI'm not sure what  is
p42313
aVIt doesn't appear to be the WinForms control of that name
p42314
aVAssuming you know how to do the  part then you want something like this:
p42315
as(dp42316
g7
V505088
p42317
stp42318
a((dp42319
g2
(lp42320
VThe first line, , is not valid
p42321
aVThe second line,  declares a variable of type pointer to char
p42322
as(dp42323
g7
V505088
p42324
stp42325
a((dp42326
g2
(lp42327
VPadding is determined by the implementation, by which we mean the specific compiler that you use to compile the code
p42328
aVOn certain platforms there are agreed conventions as to what padding will be used
p42329
aVThis is what makes binary interop possible for code compiled by different compilers
p42330
aVSo, whilst in theory different compilers can make different choices, so long as all the code is running inside a single process, different padding rules are seldom an issue
p42331
aVOn the other hand, if you decide to use  layouts for data that you send over a network, then you will invariably run into problems
p42332
aVDon't use the binary layout structs for data that goes on the wire
p42333
as(dp42334
g7
V505088
p42335
stp42336
a((dp42337
g2
(lp42338
VYou cannot pause a timer
p42339
aVSaving the time remaining, stopping the timer and then starting a new timer is the way to do this
p42340
aVThat method does work so I guess you have a bug in your code
p42341
as(dp42342
g7
V505088
p42343
stp42344
a((dp42345
g2
(lp42346
VIn my experience, the most effective way to use the shell API from managed code is to use the Windows API Code Pack
p42347
aVThis wraps up all the useful parts of the shell API and makes it trivially accessible from managed code
p42348
aVThe download includes lots of examples to get you on the way
p42349
as(dp42350
g7
V505088
p42351
stp42352
a((dp42353
g2
(lp42354
VYou are trying to hook an application on a different desktop
p42355
aVThe documentation for the  paramteter of  tells you that you cannot do this:
p42356
aVThe identifier of the thread with which the hook procedure is to be associated
p42357
aVIf this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread
p42358
aVRemember that session 0 isolation in Vista up means that your services run in a different session (and hence a different desktop) from any interactive desktops
p42359
aVI imagine that there are other reasons that will stop this working from session 0
p42360
aVYou are going to need to run this code from  a process that lives in the same desktop as the processes that you wish to hook
p42361
as(dp42362
g7
V505088
p42363
stp42364
a((dp42365
g2
(lp42366
V returns a tuple
p42367
aVYou then un-pack that tuple by writing:
p42368
aVIf the tuple does not have exactly three elements then the un-packing fails
p42369
aVIn your case the error message states that you have only one element
p42370
aVSo,  is clearly returning a tuple with only one element
p42371
aVAnd that means that  has no commas
p42372
aVProbably this means that your input data is not what you expect it to be
p42373
aVYou require that  is a string containing three comma separated values but there is a line in your input data that does not meet that requirement
p42374
as(dp42375
g7
V505088
p42376
stp42377
a((dp42378
g2
(lp42379
VYou need to use  to concatenate the required extension on to the end of the user input
p42380
aVHowever, simply naming the file with a  extension is not enough to make it a comma-separated file
p42381
aVYou need to format the output
p42382
aVUse  to do that
p42383
aVThe python documentation has some simple examples on how to do this
p42384
aVI advise you not to attempt to generate the formatted comma-separated output yourself
p42385
aVThat's a surprisingly hard task and utterly pointless in the presence of the built-in functionality
p42386
as(dp42387
g7
V505088
p42388
stp42389
a((dp42390
g2
(lp42391
VIf you want to maintain and exert control over a thread's lifetimes then it must have  set to
p42392
aVOtherwise it is an error to refer to the thread after it has started executing
p42393
aVThat's because once it starts executing, you've no ready way to know whether or not it has been freed
p42394
aVThe call to  creates a thread with  set to
p42395
aVThe thread is also marked as FreeOnTerminate, so you should not touch the returned instance after calling Start
p42396
aVAnd so, but default, you are in no position to exert control over the thread's lifetime
p42397
aVHowever, you could set  to  immediately before calling
p42398
aVLike this:
p42399
aVHowever, I'm not sure I would do that
p42400
aVThe design of  is that the thread is automatically freed upon termination
p42401
aVI think I personally would either follow the intended design, or derive my own  descendent
p42402
as(dp42403
g7
V505088
p42404
stp42405
a((dp42406
g2
(lp42407
VYou can't get  to behave the way you want
p42408
aVThere are no  methods and there are not parameters that disable exceptions
p42409
aVYou can be sure that this is so because the  methods do not provide any error or status codes
p42410
aVYou will have to write your own wrappers around the Win32 registry API
p42411
aVAs an aside, I agree with your opinion, expressed in the comments, that  is lacking in functionality here
p42412
aVWe expect registry operations to fail, and so we should not have to catch exceptions to deal with that
p42413
as(dp42414
g7
V505088
p42415
stp42416
a((dp42417
g2
(lp42418
VYou need to specify the calling convention, which in this case is :
p42419
aVYour code uses the default Delphi calling convention which is  and passes parameters through registers
p42420
aVThe  calling convention passes parameters on the stack and so this mis-match explains why communications between the two modules fail
p42421
aVSome more comments:
p42422
aVThe failure mode for  is to return , that is
p42423
aVCheck that rather than the return value being
p42424
aVIt's simpler to use implicit linking to import this function
p42425
aVReplace all the  and  code with this simple declaration:
p42426
aVThe system loader will resolve this import when your executable starts so you don't have to worry about the details of linking
p42427
as(dp42428
g7
V505088
p42429
stp42430
a((dp42431
g2
(lp42432
VHere's what I can see:
p42433
aVYou did not allocate
p42434
aVYou allocated memory for , but then immediately leaked by by assigning
p42435
aVI guess you meant to use  or
p42436
aVYou use a possibly uninitialized variable named
p42437
aVI guess this is the problem
p42438
as(dp42439
g7
V505088
p42440
stp42441
a((dp42442
g2
(lp42443
VError 126 is what you get when a dependent DLL can not be found
p42444
aVThere are two obvious causes for this:
p42445
aVYour DLL is not being located
p42446
aVYour DLL depends on other DLLs that cannot be found
p42447
aVI doubt that option 1 is the problem but in any case I think I would probably be using a full path to that DLL to be sure
p42448
aVSo that leaves option 2 and the most common cause for that is that your target machine does not have the C++ runtime installed
p42449
aVEither install the C++ runtime on your target machine, or use static linking, , when building your DLL so that you do not need to redistribute the runtime
p42450
aVProbably, on the machine that you developed the DLL, you have installed a C++ compiler and that installed the runtime for you
p42451
aVOn your target machine, where the code fails, you have not installed the compiler and so the runtime is not present
p42452
as(dp42453
g7
V505088
p42454
stp42455
a((dp42456
g2
(lp42457
VI would expect WMI to be slower
p42458
aVThere are some tricks that you can use to speed up WMI, but in general, performance is often poor
p42459
aVIn your situation I would simply build your app targeting AnyCPU
p42460
aVThen you have a single app that runs as x86 under a 32 bit OS and as x64 under a 64 bit OS
p42461
aVThat way you can avoid WMI altogether
p42462
as(dp42463
g7
V505088
p42464
stp42465
a((dp42466
g2
(lp42467
VThe problem is that  and  are returned from the original C code
p42468
aVThe use of pointers for those parameters is so that the parameters can mimic  semantics
p42469
aVSince Java only supports pass by value, you cannot return that information in the same way using plain method parameters
p42470
aVThe other issue is that older versions of C do not have a boolean type and so  is used instead
p42471
aVThe flag to indicate convergence should be a  in Java
p42472
aVSo your code needs to return three pieces of information: the result (a floating point value),  (a boolean value) and  (an integer)
p42473
aVYou should wrap these up into an object and return them that way
p42474
aVThe class you need would look like this:
p42475
aVYou should change your  method signature to be like so:
p42476
aVFinally, I think that  would be a much better name than  for that parameter
p42477
as(dp42478
g7
V505088
p42479
stp42480
a((dp42481
g2
(lp42482
VYou have not created the timer
p42483
aVDeclaring a variable is not enough
p42484
aVYou do need to create the timer
p42485
aVAnd you should destroy it too
p42486
aVAdd a destructor to the class
p42487
aVand implement it like this
p42488
aVI would also recommend that you make your  field have private visibility
p42489
aVIt's not good to expose the internals of a class like that
p42490
aVNote that I have included calls to the inherited constructor and destructor
p42491
aVThese are not necessary in this class since it derives directly from  and the constructor and destructor for  is empty
p42492
aVBut if you change the inheritance at some point, and make your class derive from a different class, then you will need to do this
p42493
aVSo, in my view, it is good practise to include these calls always
p42494
as(dp42495
g7
V505088
p42496
stp42497
a((dp42498
g2
(lp42499
VThe message pump never exits and so when you free the thread it blocks indefinitely waiting for the Execute method to finish
p42500
aVCall PostQuitMessage, from the thread, to terminate the message pump
p42501
aVIf you wish to invoke this from the main thread then you will need to post a WM_QUIT to the thread
p42502
aVAlso, your hidden window is a disaster waiting to happen
p42503
aVYou can't create a VCL object outside the main thread
p42504
aVYou will have to create a window handle using raw Win32, or even better, use DsiAllocateHwnd
p42505
as(dp42506
g7
V505088
p42507
stp42508
a((dp42509
g2
(lp42510
VThis is because  is not a struct
p42511
aVUse  instead
p42512
aVor, even better in my view,
p42513
aVI prefer the latter because it avoids repetition of the type of
p42514
as(dp42515
g7
V505088
p42516
stp42517
a((dp42518
g2
(lp42519
VFor some reason, the call to  is not returning the desired value under VS6
p42520
aVThe  symbols indicate that an encoding conversion has failed
p42521
aVA quick workaround is to use  instead
p42522
as(dp42523
g7
V505088
p42524
stp42525
a((dp42526
g2
(lp42527
VThe code in the question you link to does not create a new component
p42528
aVInstead it implements custom drawing by using events of the page control
p42529
aVSpecifically these events:
p42530
aVOnDrawTab
p42531
aVOnMouseDown
p42532
aVOnMouseMove
p42533
aVOnMouseLeave
p42534
aVOnMouseUp
p42535
aVYou must use the Delphi form designer to connect these event handlers up to the matching events to make the code work
p42536
aVThis approach was probably chosen for simplicity when answering that question but it does not scale to an application with many forms that have page controls
p42537
aVIn that situation you would want to derive a new page control component
p42538
aVIf you do that then, rather than using events, you need to override the following methods:
p42539
aVDrawTab
p42540
aVMouseDown
p42541
aVMouseMove
p42542
aVMouseUp
p42543
aVIn addition to this you must replicate the  behaviour
p42544
aVThat requires a message handler
p42545
as(dp42546
g7
V505088
p42547
stp42548
a((dp42549
g2
(lp42550
VIf you look at the actual memory used to store  in signed byte, then you will see that it is
p42551
aVHowever, in the language itself, rather than the binary representation,  is simply out of range for a byte
p42552
aVThe binary representation of  will indeed use two's complement but you are shielded from that implementation detail
p42553
aVThe language designers simply took the stance that trying to store 255 in a data type that can only hold -128 to 127 should be considered an error
p42554
aVYou ask in comments why Java allows:
p42555
aVThe literal  is an  literal and is interpreted using two's complement
p42556
aVThe reason that you cannot do anything similar for a byte is that the language does not provide syntax for specifying that a literal is of type , or indeed
p42557
aVI don't know why the decision not to offer more literal types was made
p42558
aVI expect it was made for reasons of simplicity
p42559
aVOne of the goals of the language was to avoid unnecessary complexity
p42560
as(dp42561
g7
V505088
p42562
stp42563
a((dp42564
g2
(lp42565
VUse the globals function
p42566
aVThe globals function returns a dict containing the  module's global variables
p42567
as(dp42568
g7
V505088
p42569
stp42570
a((dp42571
g2
(lp42572
VTake, for example
p42573
aVThis compares , decayed to a pointer, to the address of the literal
p42574
aVThat will always return false
p42575
aVTo compare the contents of C strings you need to use
p42576
aVDo yourself an enormous favour and use  instead of C strings
p42577
as(dp42578
g7
V505088
p42579
stp42580
a((dp42581
g2
(lp42582
VRemember that  sets each byte of an array to the same value
p42583
aVSo you are copying, to the first 9000 bytes of the array, the byte with value 1
p42584
aVAssuming 4 byte integers, that means you are assigning an int with value
p42585
aVBut, what's more, you are not assigning to the entire array, only the first 1/4 of it, again assuming 4 byte integers
p42586
aVYou can't do what you want with
p42587
aVUse a for loop instead
p42588
as(dp42589
g7
V505088
p42590
stp42591
a((dp42592
g2
(lp42593
VThe documentation of  explains that you cannot use one of the wait functions:
p42594
aVThe following sample code demonstrates how you can use the thread handle returned by _beginthreadex with the synchronization API WaitForSingleObject
p42595
aVThe main thread waits for the second thread to terminate before it continues
p42596
aVWhen the second thread calls _endthreadex, it causes its thread object to go to the signaled state
p42597
aVThis allows the primary thread to continue running
p42598
aVThis cannot be done with _beginthread and _endthread, because _endthread calls CloseHandle, destroying the thread object before it can be set to the signaled state
p42599
aVAnd this text also gives you the solution, namely to use  instead
p42600
aVI think you are alluding to this in the question when you say that
p42601
aVbut my functions are not __stdcall
p42602
aVYou simply have to change your functions to use the  calling convention
p42603
as(dp42604
g7
V505088
p42605
stp42606
a((dp42607
g2
(lp42608
VThis declares a pointer and sets the address to which it points to
p42609
aVThis de-references the pointer and writes 22 to the  at that  memory address
p42610
aVSince you did not allocate any memory and just set the pointer to point at a random address, it results in a runtime error
p42611
aVWhat is confusing you is that both pieces of code contain
p42612
aVHowever, the first assignment is to the pointer, and the second assignment is to the pointee
p42613
aVThis is just one of those notational overloadings that you have to get used to when programming in C
p42614
as(dp42615
g7
V505088
p42616
stp42617
a((dp42618
g2
(lp42619
VI think Punycode would meet your needs
p42620
as(dp42621
g7
V505088
p42622
stp42623
a((dp42624
g2
(lp42625
VUsing  is not necessarily incorrect
p42626
aVRaymond's article that you linked to says:
p42627
aVBecause the system tries not to inject a WM_QUIT message at a "bad time"; instead it waits for things to "settle down" before generating the WM_QUIT message, thereby reducing the chances that the program might be in the middle of a multi-step procedure triggered by a sequence of posted messages
p42628
aVIf the concerns outlined here do not apply to your message queue, then call  with  and knock yourself out
p42629
aVOtherwise you'll need to create a special signal, i
p42630
ag192
aVa user-defined message, that allows you to call  from the thread
p42631
as(dp42632
g7
V505088
p42633
stp42634
a((dp42635
g2
(lp42636
VIn C, an  with an initialization results in a variable being allocated
p42637
aVThat is the declaration will be considered a defining declaration
p42638
aVThis is in contrast with the more common use of
p42639
aVThe C standard says:
p42640
aV6
p42641
aV9
p42642
aV2 External object definitions
p42643
aVIf the declaration of an identifier for an object has file scope and an initializer, the
p42644
aVdeclaration is an external definition for the identifier
p42645
aVAs for the second part of your question, your declaration  at file scope has external linkage
p42646
aVIf you want to give it internal linkage you need to declare it
p42647
aVThe C standard says:
p42648
ag42641
ag25125
aV2 Linkages of identifiers
p42649
aVIf the declaration of an identifier for an object has file scope and no storage-class specifier, its linkage is external
p42650
as(dp42651
g7
V505088
p42652
stp42653
a((dp42654
g2
(lp42655
VYou can't find out the dimensions of an array if all you have is a pointer to the beginning of the array
p42656
aVYou will need to pass the dimensions of the array to the functions
p42657
as(dp42658
g7
V505088
p42659
stp42660
a((dp42661
g2
(lp42662
VYou cannot force a re-load of an implicitly linked DLL
p42663
aVYou will need to use explicit linking
p42664
as(dp42665
g7
V505088
p42666
stp42667
a((dp42668
g2
(lp42669
VYou need to compile your DLL for 64 bit
p42670
aVThe fact that the registration code writes to  indicates that your DLL is 32 bit
p42671
aVOn a 64 bit OS, Explorer is a 64 bit process and so can only load 64 bit shell extensions
p42672
aVDon't forget to register both 32 and 64 bit versions of the shell extension on a 64 bit machine so that any 32 bit programs can see your shell extension
p42673
aVYou do that using
p42674
as(dp42675
g7
V505088
p42676
stp42677
a((dp42678
g2
(lp42679
VThis idea is not going to work, in general
p42680
aVYou are assuming that the developer will always drop your component onto a form
p42681
aVBut they could just as well check an existing project out from revision control and then the DLL would not be created
p42682
aVIn my opinion you should simply document the dependency and let the developer ensure that the dependency is met
p42683
aVSuggest that they add the DLL to their revision control system so that it is checked out into the application directory
p42684
aVThe developer is going to need to be aware of this dependency when it comes to deployment
p42685
aVThat has to be the developer's responsibility
p42686
aVSo it is just cleaner and easier to let the developer manage this full stop
p42687
as(dp42688
g7
V505088
p42689
stp42690
a((dp42691
g2
(lp42692
VA member function cannot be represented by a single pointer
p42693
aVIt needs two pointers, one for the instance and one for the code
p42694
aVBut that's implementation detail and you just need to use a method type:
p42695
aVYou can then assign ImportantFunc to a variable of this type
p42696
aVSince you are using stdcall I suspect you are trying to use this as a Windows callback
p42697
aVThat's not possible for a member function
p42698
aVYou need a function with global scope, or a static function
p42699
as(dp42700
g7
V505088
p42701
stp42702
a((dp42703
g2
(lp42704
VI would always use  if it is appropriate \u2013 and invariably it is
p42705
aVThere are plenty of reasons
p42706
aVA very good one is that the single line version is more concise
p42707
aVAnother is that the single line version is the standard, commonly used approach
p42708
aVYet another reason is the handling of exceptions in the constructor which your method 1 does not manage correctly
p42709
aVIn case of an exception, the new instance will be destroyed, but the instance variable has still been assigned to
p42710
aVThat's an important difference from method 2 and goes against all the lifetime management conventions of Delphi
p42711
aVYou mention
p42712
aVLet's take a look at it:
p42713
aVRemember that  is the form variable that you pass as a  parameter
p42714
aVThe point about this is this code assigns that form variable before calling the constructor
p42715
aVNormally that assignment is only made after the constructor completes
p42716
aVPresumably this is so that code which references the form variable (often a global variable) can work even if it is invoked from inside that form's constructor
p42717
aVThis is a very special case and is overwhelmingly the exception rather than the rule
p42718
aVDon't let this special case drive your mainstream coding style
p42719
as(dp42720
g7
V505088
p42721
stp42722
a((dp42723
g2
(lp42724
VDEP prevents execution of code on the stack, as well as the heap
p42725
aVIn other words, the stack is viewed as being data
p42726
as(dp42727
g7
V505088
p42728
stp42729
a((dp42730
g2
(lp42731
VYou have a precedence problem
p42732
aVYou need to use
p42733
aVinstead of
p42734
aVSimilarly you need
p42735
aVWhen you write  you are indexing
p42736
aVBut you want to index , and hence require the parentheses
p42737
aVI've not checked the rest of your code, but I hope this helps you on your way to debugging the rest of it, if indeed there are more errors
p42738
as(dp42739
g7
V505088
p42740
stp42741
a((dp42742
g2
(lp42743
VThere is something wrong with your compilation environment
p42744
aVThere is nothing wrong with that code
p42745
aVIt compiles and runs fine
p42746
aVIn a comment to the question you say:
p42747
aVI'm learning to write a driver so I can do stuff with my devices like keyboards and mouses, so I'm using the WDK
p42748
aVCorrect me if I'm wrong, but I thought you need to use extern "C" to use those header files
p42749
aVIn fact you should simply write code in C rather than C++ for driver development
p42750
as(dp42751
g7
V505088
p42752
stp42753
a((dp42754
g2
(lp42755
VRun a simple for loop over the lines of the memo like this:
p42756
as(dp42757
g7
V505088
p42758
stp42759
a((dp42760
g2
(lp42761
VThe memory manager does indeed maintain metadata about each allocated block of memory
p42762
aVThis will likely contain information in addition to the size of the block
p42763
aVOne common way to implement this is to store the metadata in memory just below the memory address which the user program uses to refer to the block
p42764
aVSo if the call to malloc returns address , and the meta data contains  bytes, then the meta data will be stored in addresses  to
p42765
as(dp42766
g7
V505088
p42767
stp42768
a((dp42769
g2
(lp42770
VIf I recall correctly, the file dialog returns the file with the focus rectangle first, and then the remaining files are in the order in which the dialog displayed them
p42771
aVThere is no way for you to change this behaviour so if you don't like it you will have to sort the files
p42772
as(dp42773
g7
V505088
p42774
stp42775
a((dp42776
g2
(lp42777
VWrite OnEnter and OnExit event handlers and assign them to each control
p42778
aVUse the Sender parameter to the event to identify which control the event applies to
p42779
as(dp42780
g7
V505088
p42781
stp42782
a((dp42783
g2
(lp42784
VHere is how I handle modifications to VCL source files:
p42785
aVMake a copy the file in your project structure
p42786
aVEither add the file to your project, or make sure the search path finds your modified file
p42787
aVMake modifications, but only in the implementation section
p42788
aVYou are not able to modify the interface section if you use any other units that themselves use the unit you are modifying
p42789
aVExplicitly set the compiler options at the top of the modified source file
p42790
aVUse default Delphi options, as found by pressing CTRL+O O in a default vanilla project
p42791
aVI'd guess that one of the final two bullet points is what is tripping you up
p42792
as(dp42793
g7
V505088
p42794
stp42795
a((dp42796
g2
(lp42797
VThat unit and the code it contains has gone
p42798
aVBut it doesn't look as if it actually did anything
p42799
aVI suspect it was vestigial code that had long ceased being used but was left in place
p42800
aVThe code in that unit was not referred to by any other source code unit supplied with Delphi
p42801
aVI expect you have a stray  in your uses clause that can simply be removed
p42802
as(dp42803
g7
V505088
p42804
stp42805
a((dp42806
g2
(lp42807
VYou passed the pointer by value
p42808
aVWhich means that the pointer that the function works with is a local copy of the caller's pointer
p42809
aVAnd so the value you assign in the function cannot seen by the caller
p42810
aVPass it by reference instead so that the function can assign to the caller's pointer rather than assigning to a local copy
p42811
aVOr, perhaps consider returning the newly allocated pointer:
p42812
aVI'd prefer the latter approach
p42813
as(dp42814
g7
V505088
p42815
stp42816
a((dp42817
g2
(lp42818
V expects to receive a
p42819
aVBut you are passing a
p42820
aVYou should be calling  instead
p42821
aVAlso, you forgot to allocate the array
p42822
as(dp42823
g7
V505088
p42824
stp42825
a((dp42826
g2
(lp42827
VI would prefer to see just a single division
p42828
aVThat said, you are going to run up against issues with floating point accuracy since you have 64 random integer bits which you then try to squeeze into 53 bits of double precision
p42829
aVYou may be better off making a dedicated generator for floating point values, but I could not say for sure since I don't know your motivation
p42830
as(dp42831
g7
V505088
p42832
stp42833
a((dp42834
g2
(lp42835
VA load time dependency could not be resolved
p42836
aVThe easiest way to debug this is to use Dependency Walker
p42837
aVUse the Profile option to get diagnostics output of the load process
p42838
aVThis will identify the point of failure and should guide you to a solution
p42839
aVThe most common cause of this error is trying to load a 64 bit DLL into a 32 bit process, or vice versa
p42840
as(dp42841
g7
V505088
p42842
stp42843
a((dp42844
g2
(lp42845
VFor a start you are not checking whether or not the call to  succeeded
p42846
aVAlways check the return values of Win32 API calls
p42847
aVBut what is happening is pretty clear
p42848
aVWhenever a function returns a string with only the first character, the most likely cause is that the function is returning UTF-16 data which you interpret as ANSI
p42849
aVYour string will contain an English character which is encoded in UTF-16 with a 0 as the second byte
p42850
aVAnd when interpreted as ANSI that 0 is treated as the string terminator
p42851
aVYou need to declare your buffer as containing a wide character payload
p42852
aVSince you are using  then you would do it like this:
p42853
aVAnd the buffer size is
p42854
aVYou will need to change your  to be able to print out a wide string
p42855
aVIf I were you I would not be using
p42856
aVI would recommend that you decide to use Unicode throughout your code
p42857
aVIt makes it much simpler for you to understand and I doubt that you need to support Windows 98 these days
p42858
as(dp42859
g7
V505088
p42860
stp42861
a((dp42862
g2
(lp42863
VThere is nothing built in to the RTL/VCL that offers asynchronous I/O for files
p42864
aVIncidentally the support in Delphi Prism is down to the
p42865
aVnet framework rather than being language based
p42866
aVYou can either code directly against the Win32 API (that's not much fun) or hunt around for a Delphi wrapper to that API
p42867
aVOff the top of my head, I don't know any Delphi wrappers of asynchronous file I/O but they must exist
p42868
as(dp42869
g7
V505088
p42870
stp42871
a((dp42872
g2
(lp42873
VYou can't easily move pixels, but you can make a copy
p42874
aVWhat remains is to fill in the space with the colour of your choice which I am sure you can do easily enough with a couple of calls to
p42875
aVHowever, I think that it would be simpler not to attempt this in-place
p42876
aVInstead I would create a new bitmap
p42877
aVPerhaps like this:
p42878
as(dp42879
g7
V505088
p42880
stp42881
a((dp42882
g2
(lp42883
VThe default calling convention of the C++ compiler is , but the default calling convention for p/invoke is
p42884
aVThat mismatch is the reason for the message that you see
p42885
aVAlso, to be 100% correct,  is an unsigned integer and should be matched with
p42886
aVSo you need to import it like this:
p42887
as(dp42888
g7
V505088
p42889
stp42890
a((dp42891
g2
(lp42892
VThe simplest way to achieve this is to pass a pointer to the root node pointer to each of your functions:
p42893
aVSo, in your main function you might declare a local variable to hold the root pointer:
p42894
aVand then when you call , for example, you pass the address of the root poiner:
p42895
aVI strongly recommend that you fix your  and  functions so that they are robust to the root pointer being
p42896
aVThis was discussed in a previous question of yours and you should heed the advice
p42897
aVIf you did that then you could get rid of the test for  being zero and the associated special case code
p42898
aVYou would then replace this:
p42899
aVwith this:
p42900
aVTo drive home the message, your new  would look like this:
p42901
aVYou would need to modify  also to include a check for the  node being
p42902
aVI will leave that as an exercise for you
p42903
aVMaintaining both head and tail pointers could be a better approach since it would avoid so many list traversals
p42904
as(dp42905
g7
V505088
p42906
stp42907
a((dp42908
g2
(lp42909
VI think this is what you are looking for:
p42910
aVI can't remember if XE supports setting  and  for a
p42911
aVIf not then change the code to
p42912
aVand so on
p42913
as(dp42914
g7
V505088
p42915
stp42916
a((dp42917
g2
(lp42918
VIf the function that RRUZ provided (now deleted) is really what you want (and I'm still a little sceptical of the encoding issues) then you can write it like this:
p42919
as(dp42920
g7
V505088
p42921
stp42922
a((dp42923
g2
(lp42924
VIt's because  is a signed data type which uses two's complement
p42925
aVAnd  is equal to
p42926
as(dp42927
g7
V505088
p42928
stp42929
a((dp42930
g2
(lp42931
V is a macro that evaluates to something like , depending on your compiler/platform
p42932
aVAnd  evaluates to the calling convention, i
p42933
ag192
aVor whatever is appropriate for your compiler/platform
p42934
aVAs for the second part of the question, there is no runtime reflection capability in C and so no annotations
p42935
as(dp42936
g7
V505088
p42937
stp42938
a((dp42939
g2
(lp42940
VIs there a better way to construct an array of bytes than this
p42941
aVThat's a perfectly reasonable way to do it, in my view
p42942
aVI see that in the stream is added the value $6F32 instead of $3E6C
p42943
aVCheck again
p42944
aVThe correct values are in fact added
p42945
aVBut beware of the traps of little endian data types
p42946
aVThe 4 bytes added to your stream, in order, are: $72, $72, $6C, $3E
p42947
aVWhy do I get the first byte in the stream instead of the third
p42948
aVBecause the  property always refers to the beginning of the stream
p42949
aVIt does not take account of the stream's current position
p42950
as(dp42951
g7
V505088
p42952
stp42953
a((dp42954
g2
(lp42955
VEvery time you read a queued keyboard message, for example by calling , the OS updates private keyboard state data associated with the calling thread
p42956
aVWhen you call   that private keyboard state data is used to determine the returned key state
p42957
aVThus, so long as you don't read another queued message,  will always return the same value
p42958
as(dp42959
g7
V505088
p42960
stp42961
a((dp42962
g2
(lp42963
VI personally would call  and check the value of the  field
p42964
aVThe  and  macros are, like all macros, evaluated at compile time
p42965
aVThey tell you about the architecture of your executable file rather than the architecture of the system on which the executable runs
p42966
aVThat latter information, the information that you want, can only be determined at runtime
p42967
as(dp42968
g7
V505088
p42969
stp42970
a((dp42971
g2
(lp42972
VA modal form is invoked by calling a function, , that only returns when the modal form closes
p42973
aVIf you want to execute code on the same thread, the UI thread, then it would need to be invoked from inside
p42974
aVIn almost all cases that's not a tenable approach
p42975
aVFrom which we can conclude that the code in question must be executed in a thread other than the UI thread
p42976
as(dp42977
g7
V505088
p42978
stp42979
a((dp42980
g2
(lp42981
VYou can use :
p42982
as(dp42983
g7
V505088
p42984
stp42985
a((dp42986
g2
(lp42987
VI'd say that is a compiler bug/limitation and that you have no way around it
p42988
aVI tried using  like this:
p42989
aVwhich results in this compiler error:
p42990
aVSo the compiler doesn't recognise that the explicit operator is expecting an open array parameter
p42991
aVA plain method call rather than an operator is fine which further leads me to believe that the compiler is simply not going to play ball
p42992
aVIf you can't use open arrays then there is no clean way out for you
p42993
as(dp42994
g7
V505088
p42995
stp42996
a((dp42997
g2
(lp42998
VRun the program through Dependency Walker in its Profile mode and let that fine tool tell you exactly what is going wrong
p42999
as(dp43000
g7
V505088
p43001
stp43002
a((dp43003
g2
(lp43004
VWith pickle or similar, you can get textual representations of objects that can be used to reconstitute those objects
p43005
aVWithout something like pickle, you cannot, without writing your own persistence code
p43006
as(dp43007
g7
V505088
p43008
stp43009
a((dp43010
g2
(lp43011
VWindows won't help you here
p43012
aVYou will have to solve the problem in your own code rather than looking for a silver bullet
p43013
aVYou say
p43014
aVThe code is too
p43015
aVmuch of a mess to properly implement a way to reset state
p43016
aVwhen a user logs out
p43017
aVYou will have to re-consider that since it's your only option
p43018
as(dp43019
g7
V505088
p43020
stp43021
a((dp43022
g2
(lp43023
VAll the code you include in the question works fine in Delphi 7
p43024
aVOutput
p43025
aVYour actual code is different from what you have stated in the question
p43026
aVIn fact,  is declared as a 32 bit type in your code, probably
p43027
aVFor example, and I'm having to guess a little here:
p43028
aVOutput
p43029
aVIf we enable overflow checking then the multiplication code results in an overflow exception, as you report
p43030
aVNow consider  when  is an integer
p43031
aVThe compiler interprets this as a 32 bit integer operation and shifts the more significant bits off the end of the 32 bit register
p43032
aVThe fact that you are assigning to a 64 bit integer is not relevant
p43033
aVWhat matters are the data types in the expression
p43034
aVYou can make the code behave the way you want by including a cast to  on the right hand side
p43035
aVOutput
p43036
aVFor a fuller discussion I refer you to Barry Kelly's answer to another question
p43037
as(dp43038
g7
V505088
p43039
stp43040
a((dp43041
g2
(lp43042
VThe following shows how to do it using p/invoke to dbghelp
p43043
aVNote that I used a number of declarations from pinvoke
p43044
aVnet
p43045
as(dp43046
g7
V505088
p43047
stp43048
a((dp43049
g2
(lp43050
VThe short answer is that if your encode algorithm really is bitwise negation of a UTF-16 string, then you cannot print the output
p43051
aVThe algorithm produces un-printable output
p43052
aVYou could add an extra encoding to base64 at display time to make the negated bytes, transformed in your code, displayable
p43053
aVIf you want more precise help I think you will need to explain the context and what your motivations are
p43054
as(dp43055
g7
V505088
p43056
stp43057
a((dp43058
g2
(lp43059
VThe code in your question is probably written by someone that doesn't know about
p43060
aVOr perhaps it was originally written before  was added to the RTL
p43061
aVIf you want to nil the reference then you may as well use
p43062
aVWriting it out longhand doesn't help
p43063
aVThe only real difference is that  will set the reference to  even if  raises
p43064
aVBut your destructors should never raise anyway so this is not that big a deal in my view
p43065
aVThere is a common trap with
p43066
aVBecause it takes an untyped parameter, you can pass it anything
p43067
aVFor example you can pass an interface, a record etc
p43068
aVIf you make this mistake then you usually end up with strange runtime errors
p43069
aVI'm not going to get started on whether or not  is an appropriate design choice
p43070
aVThat topic has been covered in some depth elsewhere
p43071
as(dp43072
g7
V505088
p43073
stp43074
a((dp43075
g2
(lp43076
VYour struct is wrong
p43077
aVIt should be:
p43078
aVDelphi  matches C#
p43079
aVDelphi  matches C#
p43080
aVDelphi  matches C#
p43081
aVYour use of explicit layout just makes life hard for you
p43082
aVUse sequential and the  attribute to simplify matters
p43083
aVIn the code where you initialise a struct you write:
p43084
aVI expect that you meant to write
p43085
aVI've not checked anything else, and there may be other errors that I have not found
p43086
aVIf I were you I would add diagnostics code to emit byte by byte your serialized struct so that you can be sure that you are serializing it correctly
p43087
as(dp43088
g7
V505088
p43089
stp43090
a((dp43091
g2
(lp43092
VYour version is fine so long as you have a literal or something that you know will not be
p43093
aVIf, on the other hand, you had
p43094
aVthen clearly you would need to defend against  being
p43095
aVBut I would stop using  here and use  which removes the need for the  check
p43096
aVAre you preferring to use  because of your Java roots
p43097
as(dp43098
g7
V505088
p43099
stp43100
a((dp43101
g2
(lp43102
VYou can declare it simply like this:
p43103
aVThe default marshalling is as an pointer to null-terminated character array
p43104
aVIf you really want the ANSI version, then that's the default
p43105
aVAnd you should use  in case you want to capture the error code in case of failure
p43106
aVI trust you know that it cannot work if the window is in a different process
p43107
as(dp43108
g7
V505088
p43109
stp43110
a((dp43111
g2
(lp43112
VIncrementing like this
p43113
aVin multiple threads, without locking, is not threadsafe
p43114
aVYou can use the  class to perform lock-free, threadsafe incrementing
p43115
aVIf only a single thread is modifying the value, with many threads reading the value, then  is threadsafe in the sense that no thread will ever suffer a partial read
p43116
aVOf course there is still a race condition, but even if you use , there would be a race
p43117
as(dp43118
g7
V505088
p43119
stp43120
a((dp43121
g2
(lp43122
VOK, I think I might have deciphered it, but I wouldn't count on it
p43123
aVYou seem to be saying that the C# code displays an unexpected value in
p43124
aVLooking at the C# code,  displays data coming from
p43125
aVAnd  is assigned like so:
p43126
aVNote that  is a C# byte array and so uses zero-based indexing
p43127
aVIn your Delphi code, the matching data structures are:
p43128
aVSo,  consumes the first 9 bytes and then the next 16 are the 4 single precision values
p43129
aVIn terms of the C# bytes array:
p43130
aVis  to ,
p43131
aVis  to ,
p43132
aVis  to ,
p43133
aVis  to ,
p43134
aVis  to
p43135
aVBut you are reading  to , and so combine half of  with half of
p43136
aVIn short, you just need to fix up your indexing
p43137
aVNow, you are making it much more complex that it needs to be
p43138
aVYou could do something like this to get hold of all 4 single values:
p43139
aVAnd rather than copying things around byte by byte into , do this:
p43140
as(dp43141
g7
V505088
p43142
stp43143
a((dp43144
g2
(lp43145
VIn fact  and  should probably not be used at all
p43146
aVThat just tells you the dimensions of the primary monitor
p43147
aVIn these days of multiple monitors, that's not terribly useful
p43148
aVIn VCL code you should be using  and related properties to obtain information about your monitors
p43149
aVAs for FMX, there is no multi-monitor support and no platform independent way to find out screen size metrics
p43150
aVIn your shoes I would simply use  and deal with the FMX port when you get to it
p43151
aVYou are going to have to re-write all your GUI code anyway when you port to FMX and this particular issue is the least of your worries
p43152
aVFinally, when you say
p43153
aVI'd like to put placeholders in my code for when I port it over to XE2
p43154
aVI trust you are aware that porting to FMX is not compulsory
p43155
aVThe VCL is still supported and available in XE2 and I can't see it being removed for a long time to come
p43156
aVYou can port to XE2 without having anything to do with FMX
p43157
as(dp43158
g7
V505088
p43159
stp43160
a((dp43161
g2
(lp43162
VThe truly simple answer is to install the XVID encoder
p43163
aVNone of the codecs that are supplied with Windows are fit for your purpose
p43164
aVXVID is both high quality and free
p43165
aVRegarding distribution and licensing implications, the XVID FAQ has this to say:
p43166
aVCan I distribute Xvid together with my proprietary program
p43167
aVIf your program calls Xvid functionality upon run-time it\u2019s a derived work and hence, the terms of the GPL apply to the work as a whole including your program
p43168
aVSo no, you cannot distribute Xvid together with your proprietary program then
p43169
aVIf you want to distribute, you\u2019ll have to publish your program under the GPL as well
p43170
aVThat also requires e
p43171
ag217
aVthe provision of the full apps source code
p43172
aVRefer to the GPL license text for more information
p43173
aVWe don\u2019t link to Xvid at all, just call through the VfW interface upon run-time \u2013 can we distribute with our proprietary software
p43174
aVNo
p43175
aVIt doesn\u2019t matter in which way you link to Xvid or what you count as linking and what not
p43176
aVThe GPL doesn\u2019t focus on the term \u2018linking\u2019 at all but rather requires combined/derived works to be published as a whole under the terms of the GPL
p43177
aVBasically any two (or more) pieces make up a combined work when they are distributed for use in combination
p43178
aVHence, if your program calls upon Xvid functionality at run-time it would make up a derived work - no matter how you technically implement the calls to Xvid
p43179
aVIf you don\u2019t want to publish your program under the GPL then refrain from distributing it in combination with Xvid
p43180
aVWhat this means for you is that you could only distribute XVID with your program if your program is also licensed under the GPL
p43181
aVBut it is perfectly fine for you to suggest to your users that they obtain XVID for themselves
p43182
as(dp43183
g7
V505088
p43184
stp43185
a((dp43186
g2
(lp43187
VThe main problem would appear to be getting hold of the last modified time of the file
p43188
aVI use the following code:
p43189
aVYou call  to get the last modified time in file time format
p43190
aVThen call  to convert into  accounting for the prevailing local time zone of the machine
p43191
aVYou can then compare that value with
p43192
aVAs regards the formatting, you already appear to know how to do that
p43193
aVYou basic approach will work and you just need to flesh out the details
p43194
aVIn the comments you say that
p43195
aVshows a  for the day when you would expect a
p43196
aVThe problem is that this function formats dates rather than time intervals
p43197
aVThe value  is not treated as an elapsed time, rather it is treated as an absolute date/time,  days after the Delphi epoch
p43198
aVI would use  and  to obtain number of days, and the part of days respectively, and work from there
p43199
aVThe following code, extracted directly from my codebase, may give you some pointers
p43200
aVNote that its input is in seconds, but it should set you on the right path
p43201
as(dp43202
g7
V505088
p43203
stp43204
a((dp43205
g2
(lp43206
VIn order to load a Unicode text file you need to know its encoding
p43207
aVIf the file has a Byte Order Mark (BOM), then you can simply call  and the RTL will use the BOM to determine the encoding
p43208
aVIf the file does not have a BOM then you need to explicitly specify the encoding, e
p43209
ag217
aVFor some reason, unknown to me, there is no built in support for UTF-32, but if you had such a file then it would be easy enough to add a  instance to handle that
p43210
as(dp43211
g7
V505088
p43212
stp43213
a((dp43214
g2
(lp43215
VThe only supported way to load a DLL is from a file
p43216
aVSo, when you need to load this DLL, extract the resource, save it to a file (e
p43217
ag217
aVin the temporary directory), and call  and  to link to the library
p43218
as(dp43219
g7
V505088
p43220
stp43221
a((dp43222
g2
(lp43223
VThat is the conditional operator
p43224
aVIt is a ternary operator because it has three operands
p43225
aVIt is often referred to as the ternary operator but that terminology is rather loose since any operator with three operands is a ternary operator
p43226
aVIt just so happens that is is the only commonly used ternary operator
p43227
aVWhat does it mean
p43228
aVThe expression
p43229
aVevaluates to  if  evaluates as true, otherwise the expression evaluates to
p43230
as(dp43231
g7
V505088
p43232
stp43233
a((dp43234
g2
(lp43235
V is returning
p43236
aVWhen you pass that to , you get a segmentation fault because  expects a valid C string
p43237
aVThat the error message refers to address  is indication that the program is de-referencing the null pointer
p43238
aVNow,  returns  because  is zero and zero evaluates as false
p43239
aVSome implementations of  return the empty string when passed
p43240
aVIt seems that this code was written assuming such an implementation
p43241
aVYour compiler's library behaves differently
p43242
aVYou can probably fix the code most easily by providing your own implementation of  that behaves the way that this code assumes
p43243
aVAs an aside, I would comment that  should really return  rather than  and likewise  should be
p43244
aVYour compiler probably warns you about this and you should heed those warnings
p43245
as(dp43246
g7
V505088
p43247
stp43248
a((dp43249
g2
(lp43250
VWithout anonymous functions, you need to name your functions
p43251
aVThere's no alternative in pre C++11
p43252
as(dp43253
g7
V505088
p43254
stp43255
a((dp43256
g2
(lp43257
VWhen your delegate has multiple functions attached to it, each one is invoked in turn
p43258
aVIf the delegate has a non-void return value, the return value of the last function is what is returned
p43259
aVThe language specification, 15
p43260
aV4 Delegate invocation, says
p43261
aVIf the delegate invocation includes output parameters or a return value, their final value will come from the invocation of the last delegate in the list
p43262
aVSo, when you call , the following happens:
p43263
aVFirst,  is called which returns 30
p43264
aVThen,  is called which returns 200 and that value is returned to the original caller
p43265
aVIn your follow-up question you ask
p43266
aVCan the second code sample be amended so that the
p43267
aVdelegate runs the add method rather than the multiply
p43268
aVmethod
p43269
aVAs explained above, the  method and the  method are both executed
p43270
aVThe return value from the last executed method is what is returned to the caller
p43271
aVSo, if you want the value resulting from calling  to be returned, it must be the last method added to the delegate instance
p43272
as(dp43273
g7
V505088
p43274
stp43275
a((dp43276
g2
(lp43277
VNotepad uses Unicode so you'll need to look for UTF-16 encoded data,  and
p43278
aVI don't understand why you feel the need to convert into hex strings before comparing
p43279
aVThere's nothing special about hex that requires the use of strings
p43280
aVHexadecimal is just a number system with base-16
p43281
aVSo, decimal 32 is the same as hexadecimal 20, i
p43282
ag192
aVDo your comparison directly with integral values:
p43283
aVThat said, taking into account the  bytes your test should really be something like this:
p43284
aVI don't want to get too deep into the rest of your code, but this line
p43285
aVis wrong on many different levels
p43286
aVreturns the size of a pointer since a dynamic array variable is essentially just a pointer
p43287
aVA useful thing to remember is that  is evaluated at compile time
p43288
aVIf you used  instead of  then you would be iterating over the end of the list
p43289
aVTo loop over a dynamic array, loop from  to
p43290
aVBut in this case you are accessing index  inside the loop, so you should loop from  to
p43291
aVBut in fact you need to compare against 4 consecutive bytes to find a match
p43292
aVPerhaps like this:
p43293
as(dp43294
g7
V505088
p43295
stp43296
a((dp43297
g2
(lp43298
VI would use  for this
p43299
aVI guess you are using bitwise operations to pull out the individual color channels, but again the  class can hide those gory details
p43300
as(dp43301
g7
V505088
p43302
stp43303
a((dp43304
g2
(lp43305
VLet's take a look at the error message and work backwards:
p43306
aVlocal variable "sector" referenced before assignment
p43307
aVThat means that you are referring to  but that  has not been assigned, or bound, to an object
p43308
aVThe only assignment to  is inside the body of the for
p43309
aVSo, clearly, the body of the  loop was not entered
p43310
aVAnd this can only happen if the call to  returns an iterable object that is empty
p43311
as(dp43312
g7
V505088
p43313
stp43314
a((dp43315
g2
(lp43316
VIn your code,  is bound to a string when the module loads and is never changed
p43317
aVYou need to be dynamic, like this:
p43318
aVGlobals are just a bad idea that will haunt you in the future
p43319
aVResist the temptation to use them
p43320
as(dp43321
g7
V505088
p43322
stp43323
a((dp43324
g2
(lp43325
VYes, this is GLScene doing the logging
p43326
aVYou can disable it by making sure that the  conditional is not defined in your  file
p43327
as(dp43328
g7
V505088
p43329
stp43330
a((dp43331
g2
(lp43332
VThe fundamental problem is here:
p43333
aVThis is a class method and so  refers to a class and not an instance
p43334
aVCasting it to be an instance does not make it so
p43335
aVExactly the same error is made in your  class function
p43336
aVLooking into the specifics, the call to
p43337
aVis benign and appears to work fine because it does not refer to
p43338
aVYou could equally write  and that code would also work without problem
p43339
aVNow, if the function  referred to , that is referred to an instance, then there would be a runtime error
p43340
aValways evaluates to true because you are comparing the locations of two distinct local variables
p43341
aVis a runtime error because  does not return an instance of
p43342
aVSo when you attempt to write to  you have a runtime error
p43343
aVThis is because you are referring to  and that's why this code fails, but the earlier call to  does not
p43344
aVI'm not really sure what you are trying to do here, but it looks all wrong
p43345
aVEven if you were working with instance methods rather than class methods, it would simply be wrong to case a base class instance to a derived class instance
p43346
aVIf something is the wrong type, no amount of casting will turn it into the right type
p43347
aVFurthermore, you should never write code that has a method of  assuming it is of type
p43348
aVThe base class should know absolutely nothing of its derived classes
p43349
aVThat is one of the very basic tenets of OOP design
p43350
as(dp43351
g7
V505088
p43352
stp43353
a((dp43354
g2
(lp43355
VFirst of all you want to get hold of the full path to the executable by calling  passing  as the module handle
p43356
aVThen call  to pull out the file name component
p43357
aVThere is in fact a difference between  and
p43358
aVThe latter is the name used to start the process
p43359
aVIt could be missing the full path, but more importantly here, it could be missing the  extension
p43360
aVIf you want to know the actual filename then you need to use
p43361
as(dp43362
g7
V505088
p43363
stp43364
a((dp43365
g2
(lp43366
VC#  uses the UTF-16 encoding
p43367
aVThe language specification, 1
p43368
aV3 Types and variables, says:
p43369
aVCharacter and string processing in C# uses Unicode encoding
p43370
aVThe char type represents a UTF-16 code unit, and the string type represents a sequence of UTF-16 code units
p43371
aVUTF-16 overlaps with ASCII in that the character codes in the ASCII range 0-127 mean the same thing in UTF-16 as in ASCII
p43372
aVThe smiley faces in your program's output are presumably how your console interprets the non-printable characters in the range 0-31
p43373
as(dp43374
g7
V505088
p43375
stp43376
a((dp43377
g2
(lp43378
VYou are passing the pointer by value
p43379
aVYou would need to pass either a reference to the pointer, or the address of the pointer
p43380
aVThat said, using the return value would be better in my view:
p43381
aVWhen written this way, the  function doesn't really seem worthwhile
p43382
aVYou don't need it
p43383
aVYou can use  directly and that would be clearer
p43384
aVOf course, if you are using C++ then this is all rather pointless
p43385
aVYou should be using , smart pointers etc
p43386
aVYou should not have any need to call  directly
p43387
aVOnce you fix the bug you are talking about in this question you will come across the problem that your string is not null-terminated and that the buffer is too short to hold the string since you forgot to allocate space for the null-terminator
p43388
aVOne of the nice things about C++ is that you can escape the horrors of string handling in C
p43389
as(dp43390
g7
V505088
p43391
stp43392
a((dp43393
g2
(lp43394
V requires Vista or later, as described in the documentation
p43395
aVYou must therefore defined  and  accordingly
p43396
aVMy guess is that your project targets an earlier version of Windows
p43397
aVAlternatively you can define them in the project options, or on the command line
p43398
aVMore details here
p43399
aVIf that is not the answer then is it possible that you are using an out-of-date version of the SDK that pre-dates Vista
p43400
as(dp43401
g7
V505088
p43402
stp43403
a((dp43404
g2
(lp43405
VFloating point arithmetic is inherently imprecise
p43406
aVIn Python calculations are typically performed to double precision
p43407
aVYour numbers are not exactly representable to double precision and so are subject to rounding errors
p43408
aVOn my machine,  is
p43409
aVWhen you print the value it gets rounded to , but the actual value stored in  in less than
p43410
aVSo, when you convert  to an integer, it is truncated to
p43411
aVThe key issue is that of representability of values
p43412
aVNeither  nor  are exactly representable in double precision as can easily be seen in the Python interpreter
p43413
aVThe moral of the story is that you should not expect exact arithmetic when using floating point values
p43414
aVThe seminal discussion of this topic is: What Every Computer Scientist Should Know About Floating-Point Arithmetic
p43415
as(dp43416
g7
V505088
p43417
stp43418
a((dp43419
g2
(lp43420
VI personally would always prefer the clear readability of
p43421
aVHowever, out of the two options in the question I think  is safer because it has no duplication
p43422
aVIf you use your alternative then it's all too easy when maintenence coding to change one of of the flags and forget to change the other
p43423
aVAnd then you end up with this
p43424
as(dp43425
g7
V505088
p43426
stp43427
a((dp43428
g2
(lp43429
VThe  comparison operator compares references rather than values
p43430
aVYou need to compare the values and so need to use the  method
p43431
as(dp43432
g7
V505088
p43433
stp43434
a((dp43435
g2
(lp43436
VYou just need to remove the  flag
p43437
aVBy specifying that you are stating that the ACE should not apply to the the target folder
p43438
aVUse  instead
p43439
aVYou may find this MSDN article helpful
p43440
as(dp43441
g7
V505088
p43442
stp43443
a((dp43444
g2
(lp43445
VYou are passing  to the  parameter
p43446
aVBut  is simply the size of a pointer
p43447
aVYou should be passing  I presume
p43448
aVIf that doesn't solve your problem then the other cause of errors in  not being valid
p43449
aVHaving gone to all the trouble of calling  and , it would have been helpful if you had told us what those functions returned
p43450
as(dp43451
g7
V505088
p43452
stp43453
a((dp43454
g2
(lp43455
V works fine
p43456
aVMy guess is that the quotes you add around the environment variable name should not be there
p43457
aVReplace
p43458
aVwith
p43459
aVAs @BluePeppers correctly points out you should also replace
p43460
aVwith
p43461
as(dp43462
g7
V505088
p43463
stp43464
a((dp43465
g2
(lp43466
VThere are two main problems with this, use of open arrays and use of Delphi
p43467
aVOpen arrays
p43468
aVDelphi open arrays are implemented by passing a pointer to the first element of the array and an extra parameter specifying the index of the last item,  in Delphi terminology
p43469
aVFor more information see this answer
p43470
aVDelphi strings
p43471
aVThe C# marshaller cannot interop with a Delphi string
p43472
aVDelphi strings are private types, only to be used internally to a Delphi module
p43473
aVInstead you should use a null-terminated string,
p43474
aVPutting it all together you can write it like this:
p43475
aVDelphi
p43476
aVC#
p43477
as(dp43478
g7
V505088
p43479
stp43480
a((dp43481
g2
(lp43482
VIn the article that you refer to, it states:
p43483
aVOnly use local variable, don't use global variable, static variable, and constant string variable
p43484
aVBut  is a global
p43485
aVAnd I think that string literal would probably be classed as as "constant string variable" although the articles terminology is somewhat imprecise
p43486
aVAs others state the behavior of this code is undefined so exactly what happens is implementation specific
p43487
aVDifferent compilers may behave differently
p43488
as(dp43489
g7
V505088
p43490
stp43491
a((dp43492
g2
(lp43493
VAs discussed in the comments, the key to this is the  property
p43494
aVThis property is defined at various points in the VCL hierarchy
p43495
aVIf you set  to be  for all components in the chain, then you can change the fonts for the entire application simply by modifying
p43496
aVBy default most components set  to  and so you have nothing to do
p43497
aVThe odd one out though is
p43498
aVA brand new default form has  set to
p43499
aVThis is somewhat disappointing but I suspect reflects the fact that the original designers of the VCL did not anticipate this and that  was grafted on relatively late in the development of the VCL
p43500
aVNo matter, in an ideal world, all forms in your application should be derived from a common base class that you control
p43501
aVIf that is so then you can simply make the change there, set  to be , make sure no explicit font settings are applied to any components on you forms, and you are golden
p43502
aVControl the entire application's fonts through a single property
p43503
aVIf you don't have a common base class for your forms, here's an ideal time to add it
p43504
aVIf you don't want to do that then you need to set  for each form
p43505
aVOther related properties are  and
p43506
aVThese provide global control over the fonts used in message boxes and menus
p43507
aVHowever, recent versions of Delphi have handed back to Windows control over the painting of message boxes and menus and so these properties have no effect
p43508
as(dp43509
g7
V505088
p43510
stp43511
a((dp43512
g2
(lp43513
VAll of these methods work fine
p43514
aVYou can free memory blocks allocated by malloc in whatever order you like
p43515
aVJust imagine for a moment that the order in which you allocated memory had to be reversed when you freed it
p43516
aVIf that was so you could never insert or delete items from the middle of a list
p43517
aVYour only available dynamically allocated data structure would be a push-down stack
p43518
as(dp43519
g7
V505088
p43520
stp43521
a((dp43522
g2
(lp43523
VIt's just a function that happens to return a
p43524
aVThere's nothing more to it than that
p43525
aVYou wouldn't be surprised to see a function return an , why be surprised when one returns a struct
p43526
aVAs an aside, the  is superfluous here because that is the default storage class for functions
p43527
as(dp43528
g7
V505088
p43529
stp43530
a((dp43531
g2
(lp43532
VRather than WinDbg, you can use the Debugging API which is implemented in dbghelp
p43533
aVdll
p43534
aVIt's documented on MSDN
p43535
aVThat reference documentation is rather dry, but it should give you an idea of the capabilities of the API
p43536
aVFor example,  is the gateway to examining dump files
p43537
as(dp43538
g7
V505088
p43539
stp43540
a((dp43541
g2
(lp43542
VFor template instantiations where this fails,  is a function pointer that receives two arguments and has  return type
p43543
aVThat is  is
p43544
aVA function with a void return type does not return anything
p43545
aVNaturally you cannot read the return value of an invocation of  because you said that there was no return value
p43546
aVEven though the branch that reads the return value won't get executed, it still needs to compile and pass the static type checking
p43547
aVThe fundamental issue here is that the calls to  are dealt with at compile time and are subject compile time static type checking
p43548
aVThis Stack Overflow question covers the exact same problem as you and the accepted answer shows how to deal with the issue
p43549
as(dp43550
g7
V505088
p43551
stp43552
a((dp43553
g2
(lp43554
VYou mean bitwise negation I presume
p43555
aVNote that I changed the parameter to pass by value rather than passing a pointer to the value
p43556
aVI also fail to see why you are using pointer arithmetic instead of indexing
p43557
aVThat just makes your code harder to read
p43558
aVThe loop should be written like this:
p43559
as(dp43560
g7
V505088
p43561
stp43562
a((dp43563
g2
(lp43564
VBecause the compiler does not perform data flow analysis
p43565
aVIn order for the compiler to reject this code it would need to analysis your code and be sure that  was out of bounds and the compiler simply does not do so
p43566
aVTo do so for even moderately more complex examples would require a very significant effort from the compiler developers
p43567
aVSince this code will fail with a runtime error if you switch range checking on, I personally feel that there is little to be gained by adding such data flow analysis to the compiler
p43568
aVIf you are not running with range checking enabled, then you really should be
p43569
aVOne of the numerous benefits about getting the compiler to perform range checking is that in many cases you can expunge your range checking code
p43570
aVThis will make your code much clearer
p43571
aVHowever, you can only do this when you are in full control of the index and can analyse the code statically
p43572
aVIf the index comes from user input, then clearly you need to provide protection against abuse
p43573
aVYou ask what are the consequences of running this code without range checking
p43574
aVWell, the behaviour is not defined and really anything could happen
p43575
aVWorst case scenario is that the program always works for you but fails in a critical way for your most important clients
p43576
as(dp43577
g7
V505088
p43578
stp43579
a((dp43580
g2
(lp43581
VPut those arguments into a struct, allocated on the heap, and pass the address of the struct in the  parameter
p43582
aVYour thread function can then cast the  to a pointer to struct and read out the parameters
p43583
aVIt is essential that you put it on the heap because if you put it on the stack of the thread that calls  then it can be invalid by the time your thread procedure tries to access it
p43584
as(dp43585
g7
V505088
p43586
stp43587
a((dp43588
g2
(lp43589
VIt looks like  is a dynamic array
p43590
aVIt would have been very helpful if you had included the declarations of your variables with the rest of the code
p43591
aVHowever, I guess with reasonable confidence that its type is
p43592
aVBut you pass  to
p43593
aVThat's the address of the pointer to the first byte of the array
p43594
aVYou need to pass simply the pointer to the first byte
p43595
aVLike this:
p43596
aVAs an aside the way you load the file is a little archaic
p43597
aVIt would probably be simpler to create a  and call  on it
p43598
as(dp43599
g7
V505088
p43600
stp43601
a((dp43602
g2
(lp43603
VYou have a 64 bit machine and are running a 32 bit process
p43604
aVThe file system redirector means that  is redirected to
p43605
aVIf you want to find files in  you can use the  alias
p43606
aVOr compile for 64 bit
p43607
aVOf course you should not be creating files in the system directory in the first place
p43608
aVIt belongs to Windows and you should leave it well alone
p43609
as(dp43610
g7
V505088
p43611
stp43612
a((dp43613
g2
(lp43614
VDon't use
p43615
aVIt is the solution to almost no problems
p43616
aVIt's true that  can hog CPU but mostly on XP in my experience
p43617
aVThere is a much less significant performance hit on Vista and up
p43618
aVHowever, if your app is idle then it won't be repainting
p43619
aVIf your CPU is 100% and the app is idle then you are doing something wrong in your  handling
p43620
aVWhat you describe sounds like an endless loop of paint cycles
p43621
aVIf you do things right, that won't happen, even if you use
p43622
aVAs regards the right way to do double buffering,  is the modern way to do this, on Vista and up
p43623
as(dp43624
g7
V505088
p43625
stp43626
a((dp43627
g2
(lp43628
VI think you need to create an intermediate process which in turn spawns
p43629
aVYou then need the intermediate process to terminate immediately, at which point the relationship between the original process and  is broken
p43630
as(dp43631
g7
V505088
p43632
stp43633
a((dp43634
g2
(lp43635
V is a class method in the class  in the module
p43636
aVSo you need
p43637
aVOr you can use a different import
p43638
aVDone this way allows you to use  as per the code in the question
p43639
as(dp43640
g7
V505088
p43641
stp43642
a((dp43643
g2
(lp43644
VYour second version is less efficient because it creates an extra string object when there is simply no need to do so
p43645
aVImmutability means that your first version behaves the way you expect and is thus the approach to be preferred
p43646
as(dp43647
g7
V505088
p43648
stp43649
a((dp43650
g2
(lp43651
VYou can't call  in those event handlers
p43652
aVWhen the event handler returns, the VCL code that executes next still uses a reference to an object that you just freed
p43653
aVAnd that's where the access violation comes from
p43654
aVIf you had been running with FastMM in full debug mode then you would have been shown a helpful diagnostic message
p43655
aVThese frames will have to kill themselves in a more roundabout manner
p43656
aVPost a CM_RELEASE message to the frame asking it to call  on the frame
p43657
aVYou post the message, rather than sending it, so that all the in flight messages are processed first
p43658
aVYou'll need to add a message handler to the frame to respond to the message
p43659
as(dp43660
g7
V505088
p43661
stp43662
a((dp43663
g2
(lp43664
VAdd a reference to the class and make sure that the compiler/linker cannot strip it from the executable
p43665
aVIn production code you would want to place  in a base unit so that it could be shared
p43666
aVThe initialization section of the unit that declares the class is the most natural place for the calls to  since the unit is then self-contained
p43667
aVRegarding your observation that  can locate the type, the very act of calling  adds a reference to the type to the program
p43668
aVIt's not that the RTTI is present and  cannot find it
p43669
aVRather, the inclusion of  adds the RTTI to the resulting program
p43670
as(dp43671
g7
V505088
p43672
stp43673
a((dp43674
g2
(lp43675
VA void pointer cannot be de-referenced
p43676
aVYou need to cast it to a suitable non-void pointer type
p43677
aVIn this case,
p43678
aVSince this is C++ you should be using C++ casts rather than C styles casts
p43679
aVAnd you should not be using  in C++, etc
p43680
aVetc
p43681
as(dp43682
g7
V505088
p43683
stp43684
a((dp43685
g2
(lp43686
VSince you can't modify the DLL code, then you have no alternative but to use thunks in the style of the code in your question
p43687
aVThere's no other way for you to get the instance information to the callback function
p43688
as(dp43689
g7
V505088
p43690
stp43691
a((dp43692
g2
(lp43693
VThe first parameter is a pointer to a null-terminated character string
p43694
aVYou can't just pass a random  value
p43695
aVSo your pinvoke should look like this:
p43696
aVI believe that the second parameter, the Clarion , is a 32 bit integer
p43697
aVSo  on the C# side
p43698
aVWhat's more, you need to double check the calling convention on the Clarion side
p43699
aVAre you sure it is  which is what your C# uses
p43700
as(dp43701
g7
V505088
p43702
stp43703
a((dp43704
g2
(lp43705
VWhen using Windows messages, you should use  to transfer string data between processes
p43706
aVIf you use custom message IDs then the string data will not be marshalled between the two distinct process address spaces
p43707
aVAnd this is why your current code fails
p43708
aVThe receiving process is passed in  a pointer to memory in the address space of the calling processes
p43709
aVAnd of course that is meaningless in the other process
p43710
aVWhilst there are other ways to marshal data like this between processes with Windows messages,  is by far the simplest
p43711
aVIf your requirement becomes much more complex then you may need to consider a more comprehensive IPC approach than Windows messages
p43712
as(dp43713
g7
V505088
p43714
stp43715
a((dp43716
g2
(lp43717
VSemantically they are identical and there will be no discernible performance difference
p43718
aVSo we are left looking at clarity for the reader of the code
p43719
aVis the readable version in my opinion
p43720
aVLook at the title of your question:
p43721
aVWhat is the better way to check for an empty string
p43722
aVIn your head you view this as the empty string as opposed to the string with length 0
p43723
aVSo write the code the way that matches your viewpoint
p43724
as(dp43725
g7
V505088
p43726
stp43727
a((dp43728
g2
(lp43729
VCan I display a warning message using , once the user tries to stop the windows service
p43730
aVYes you can
p43731
aVThe MSDN document Service Changes for Windows Vista says this (emphasis mine):
p43732
aVServices have always run in session 0
p43733
aVBefore Windows Vista, the first user to log on was also assigned to session 0
p43734
aVNow, session 0 is reserved exclusively for services and other applications not associated with an interactive user session
p43735
aV(The first user to log on is connected to session 1, the second user to log on is connected to session 2, and so on
p43736
aVSession 0 does not support processes that interact with the user
p43737
aVThis change means that a service cannot post or send a message to an application and an application cannot send or post a message to a service
p43738
aVIn addition, services cannot display a user interface item such as a dialog box directly
p43739
aVA service can use the WTSSendMessage function to display a dialog box in another session
p43740
as(dp43741
g7
V505088
p43742
stp43743
a((dp43744
g2
(lp43745
VIf your data is Unicode, then I am assuming that the encoding is UTF-16
p43746
aVIn which case you cannot process it byte by byte
p43747
aVA character unit is 2 bytes wide
p43748
aVPut the data into a Delphi string first, and then parse it:
p43749
aVDo it this way and your loop can look like this:
p43750
aVI believe that your confusion was caused by processing byte by byte
p43751
aVWith UTF-16 encoded text, ASCII characters are encoded as a pair of bytes, the most significant of which is zero
p43752
aVI suspect that explains what you were trying to achieve with your  call
p43753
aVIf you want to cater for other digit characters then you can use the  unit and test with
p43754
as(dp43755
g7
V505088
p43756
stp43757
a((dp43758
g2
(lp43759
VYour code exhibits undefined behaviour
p43760
aVIt works for you by chance, but on another machine it could fail
p43761
aVAs you understood from the FAQ, the code is not valid
p43762
aVBut that does not mean it will always fail
p43763
aVThat is simply the nature of undefined behaviour
p43764
aVLiterally anything can happen
p43765
aVAccessing  is illegal because that is beyond the end of the array
p43766
aVValid indices for this array are 0, 1 and 2
p43767
aVYou did not allocate memory for  so any de-referencing of the pointer is undefined behaviour
p43768
aVYour  declaration is wrong
p43769
aVYou should write:
p43770
as(dp43771
g7
V505088
p43772
stp43773
a((dp43774
g2
(lp43775
VUse WTSGetActiveConsoleSessionId() as described in the MSDN article I showed you in your earlier question
p43776
aVThat article includes all the code you need
p43777
aVI also urge you to include error checking for your API calls
p43778
aVDiagnosing errors without that help is harder than it needs to be
p43779
as(dp43780
g7
V505088
p43781
stp43782
a((dp43783
g2
(lp43784
VYour IDE does not have the package which contains TsStatusBar installed
p43785
aVFind that package, build it, and install it
p43786
aVDesign time components need their code to be integrated into the IDE
p43787
aVThis is done using what are called packages
p43788
aVThe package project has extension
p43789
aVdpk
p43790
aVYou should find this package project in your revision control system
p43791
aVLoad the
p43792
aVdpk file in Delphi, click Build from the package manager, and finally, when built, click Install
p43793
aVNow that the package with your component is known to the IDE, your form will load
p43794
aVWhoever maintains this code in your organisation will be able to help with all the details
p43795
as(dp43796
g7
V505088
p43797
stp43798
a((dp43799
g2
(lp43800
VIf you can control every single call to CreateWindowEx then you can wrap them with a critical section
p43801
aVHowever, if you could do that, then you would not need to hook the function
p43802
aVWhat's left is to hook the function before any other threads have started
p43803
aVDo this right at the beginning of your application, possibly by using static initialization
p43804
aVOne other thought about this particular function
p43805
aVIn many apps, all windows are created in the main thread
p43806
aVIf that is so for you then you have no need to synchronize
p43807
as(dp43808
g7
V505088
p43809
stp43810
a((dp43811
g2
(lp43812
V and  send you  in  when either control key is pressed
p43813
aVTo find out whether or not the right-hand control key is pressed, read bit 24 of , as described in the MSDN documentation
p43814
aVBit 24 is described like this:
p43815
aVIndicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or 102-key keyboard
p43816
aVThe value is 1 if it is an extended key; otherwise, it is 0
p43817
as(dp43818
g7
V505088
p43819
stp43820
a((dp43821
g2
(lp43822
VYou would identify the error by checking the contents of  and checking that  is declared correctly
p43823
aVThe typical errors are  or  being
p43824
aVYou won't get any more diagnostic information from
p43825
as(dp43826
g7
V505088
p43827
stp43828
a((dp43829
g2
(lp43830
VDon't block on  at all
p43831
aVInstead arrange that  signals the main thread that it has finished
p43832
aVFor example by using
p43833
as(dp43834
g7
V505088
p43835
stp43836
a((dp43837
g2
(lp43838
VThe null GUID
p43839
aVis probably what you want
p43840
as(dp43841
g7
V505088
p43842
stp43843
a((dp43844
g2
(lp43845
VThe only way to be sure is to time the various options
p43846
aVHowever, since you are hitting a database in this process, that is likely to be dominant
p43847
aVThe variant that reduces the database access is liable to be the fastest
p43848
aVIf both variants have the same impact on the database then I'd expect them to take similar amounts of time
p43849
aVCalling methods and creating objects are orders of magnitude faster than communicating with your database
p43850
as(dp43851
g7
V505088
p43852
stp43853
a((dp43854
g2
(lp43855
VThe two versions of your code that you present are indeed equivalent
p43856
aVHowever, your implementation of this algorithm bears little relation to the algorithm as written in your Cormen reference
p43857
aVYour code should read:
p43858
as(dp43859
g7
V505088
p43860
stp43861
a((dp43862
g2
(lp43863
VVariants are managed types
p43864
aVThis means that the compiler will take care of disposing of any resources associated with the variant when it goes out of scope
p43865
aVTreat the lifetime of variants just as you would treat strings, dynamic arrays, interfaces etc
p43866
aVThis means that all three variants are identical in meaning and correctly dispose of the array and its contents
p43867
aVYou can choose to use whichever one you prefer
p43868
as(dp43869
g7
V505088
p43870
stp43871
a((dp43872
g2
(lp43873
VDynamic arrays are managed types
p43874
aVThis means that the compiler will dispose of the memory when the last reference to the array goes out of scope
p43875
aVThat means that the code to free the array in your code is rather pointless
p43876
aVIf you need to, you can deallocate the array ahead of time by using any of these equivalent lines of code:
p43877
aVBeware that if you have mutiple references to the same array then you need to do this for all references to that array
p43878
as(dp43879
g7
V505088
p43880
stp43881
a((dp43882
g2
(lp43883
VIt works because one possible outcome of undefined behaviour is that the program does what you intend
p43884
aVYou don't need to look any further than this
p43885
aVUndefined behaviour is something that you simply avoid rather than trying to understand its manifestation in one particular compiler
p43886
as(dp43887
g7
V505088
p43888
stp43889
a((dp43890
g2
(lp43891
Vis evaluated left to right
p43892
aVSo first
p43893
aVis evaluated to a truth value
p43894
aVAnd then that truth value is compared with
p43895
aVThat's not what you want
p43896
aVYou want
p43897
as(dp43898
g7
V505088
p43899
stp43900
a((dp43901
g2
(lp43902
VYou have a calling convention mismatch
p43903
aVThe C++ function pointer type uses
p43904
aVThe managed code assumes
p43905
aVFix it like this:
p43906
aVAlternatively you could change the calling convention in the C++ code to :
p43907
aVBut make sure you do only one of these and not both
p43908
as(dp43909
g7
V505088
p43910
stp43911
a((dp43912
g2
(lp43913
VIn fact, your program is indeed reading the entire file
p43914
aVIt reads the file 1000 bytes at a time until there are, in this case, 736 bytes left
p43915
aVThen it reads those final 736 bytes and  returns
p43916
aVYou are mistakenly treating the inability to read the full 1000 bytes as an error, but it is not an error
p43917
aVIf  fails then the error condition is marked by the return value being -1
p43918
aVYour loop should perhaps be more like this:
p43919
aVA couple of other points:
p43920
aVThe correct type for  is
p43921
aVRather than hardcoding  and , you would be better with something like  so that you don't keep repeating those magic values
p43922
as(dp43923
g7
V505088
p43924
stp43925
a((dp43926
g2
(lp43927
VAccording to the comments, you are trying to write to HKCR
p43928
aVIn order to do that you need admin rights
p43929
aVOn XP your user is an administrator and so has admin rights
p43930
aVThe code succeeds
p43931
aVOn Vista and up, with UAC active, your user, even if an admin user, runs with a standard user token
p43932
aVThe code fails with access denied
p43933
aVIf you really do need to write to this key then you are going to need to run with administrator rights
p43934
aVThat's going to require a requireAdministrator manifest
p43935
as(dp43936
g7
V505088
p43937
stp43938
a((dp43939
g2
(lp43940
VThe  statement always evaluates to true
p43941
aVThis means that the final  loop will do this:
p43942
aVThe net result of this is that every button's  is set to , which is
p43943
aVWhy does the  statement always evaluate to
p43944
aVWell, first of all let's look at a couple of the  clauses in the  statement:
p43945
aVThis is equivalent to
p43946
aVThe line containing the  test has absolutely no impact on the final result of the condition
p43947
aVIn fact all the lines containing  can be similarly treated
p43948
aVThis leaves:
p43949
aVWe can condense
p43950
aVinto
p43951
aVand similarly
p43952
aVis the same as
p43953
aVCombine
p43954
aVand you can see that the  condition always evaluates to
p43955
as(dp43956
g7
V505088
p43957
stp43958
a((dp43959
g2
(lp43960
Vdeallocates memory, but it does not change the value of the address stored in
p43961
aVThere is no method in standard C++ to detect that a pointer is referring to invalid memory
p43962
aVIt is your responsibility not to de-reference an invalid pointer
p43963
aVYour first example is undefined behaviour
p43964
aVOne of the possible outcomes of undefined behaviour is that the program works the way you intended it to
p43965
aVAgain, it is your responsibility not to write programs with undefined behaviour
p43966
aVIn your code,  is probably a non-virtual member function that does not de-reference  which is why it happens to work for you, on your compiler
p43967
aVMost likely if you tried to refer to some member data fields then you would encounter a runtime error
p43968
as(dp43969
g7
V505088
p43970
stp43971
a((dp43972
g2
(lp43973
VWhen the program terminates, the OS will re-claim all memory that the process allocated
p43974
aVAny memory that you leak during your program's life will be returned to the pool of available memory once your program terminates
p43975
aVWhen you allocate memory with  then this will be backed by
p43976
aVIf you allocate more memory than is available, then the computer may use a swap file on your disk instead
p43977
as(dp43978
g7
V505088
p43979
stp43980
a((dp43981
g2
(lp43982
Vdoes not return until the main form is closed
p43983
aVAll code that runs after  does not run until the program is shutting down
p43984
aVThat's clearly not what you want
p43985
aVYou can solve the problem easily enough by reordering your :
p43986
aVAn alternative would be to move the call to  into the constructor of , or some event that fires early in the form's life, e
p43987
ag217
aVThis option better encapsulates the behaviour of the form
p43988
as(dp43989
g7
V505088
p43990
stp43991
a((dp43992
g2
(lp43993
VYou can use  to identify the thread that is currently executing and take  decisions by comparing against your target thread's ID
p43994
as(dp43995
g7
V505088
p43996
stp43997
a((dp43998
g2
(lp43999
VYou have a few problems:
p44000
aVYou need to use the  event rather than a button click handler
p44001
aVYou should set the interval to  for a 10 second wait
p44002
aVYou are using a local variable for the timer instance
p44003
aVThat makes it hard for you to refer to the timer at a later date
p44004
aVMake the timer instance be a member of the form class instead
p44005
aVRemember to stop the clock after you run the form, or, it will try to open every 10 seconds
p44006
aVIn other words, something like this:
p44007
as(dp44008
g7
V505088
p44009
stp44010
a((dp44011
g2
(lp44012
VYou need to make sure that when you build the static lib, you do not use
p44013
aVIf you want to use the same lib in a DLL and in your executable, and you don't want the executable to export the symbols, then you'll need to use a DEF file rather than
p44014
as(dp44015
g7
V505088
p44016
stp44017
a((dp44018
g2
(lp44019
VIt's explained a bit better in the equivalent native API documentation
p44020
aVDisableWakeEvent
p44021
aVIf this parameter is TRUE, the system disables
p44022
aVall wake events
p44023
aVIf the parameter is FALSE, any system wake events
p44024
aVremain enabled
p44025
aVWake events are things like scheduled tasks that can wake the machine
p44026
aVFor example, perhaps you have a scheduled task to wake the machine up to perform a full virus scan once a week
p44027
aVSetting  to  will disable all those other wake events
p44028
aVSo when the system suspends, it stays suspended even if any such wake events are defined
p44029
as(dp44030
g7
V505088
p44031
stp44032
a((dp44033
g2
(lp44034
VIn Java,  always refers to an object and never to a class
p44035
as(dp44036
g7
V505088
p44037
stp44038
a((dp44039
g2
(lp44040
VI understand from second line of code that address for ref (hence the ampersand) is a
p44041
aVThen, integer ref is assigned the value of b
p44042
aVI don't think you understand how references work
p44043
aVThe first line allocates an  object
p44044
aVThis object can be referred to using the local variable
p44045
aVThe second line has the effect of making  be an alias to that same  object
p44046
aVChanges can be made to the object using either  or , but there is one and only one  object
p44047
as(dp44048
g7
V505088
p44049
stp44050
a((dp44051
g2
(lp44052
VYou state that
p44053
aVPStream is just a pointer to TStream
p44054
aVIn which case this code
p44055
aVcannot work
p44056
aVYou are passing, to a parameter of type , a pointer to a pointer to TStream
p44057
aVTo make your code compile you need to pass a  to
p44058
aVLike this:
p44059
aVIn your position, I would probably use a  like this
p44060
aVPerhaps there is a KOL way to do that, I don't know KOL at all
p44061
as(dp44062
g7
V505088
p44063
stp44064
a((dp44065
g2
(lp44066
VThe array in your first piece of code is, presumably, being allocated on the stack and does not fit
p44067
aVThe stack typically has a fixed size and you must not allocate huge objects on the stack
p44068
aVThe solution, as you have discovered, is to allocate from the heap
p44069
as(dp44070
g7
V505088
p44071
stp44072
a((dp44073
g2
(lp44074
VYou don't need to do anything special about surrogate pairs
p44075
aVA single 16 bit character unit that is one half of a surrogate pair, cannot also be a non-surrogate character unit
p44076
aVSo,
p44077
aVis perfectly correct
p44078
aVEqually you can use  with
p44079
aVIt's more complicated for multi-byte ANSI codepages
p44080
aVYou do need to deal with lead and trail byte issues
p44081
aVMy recommendation is to normalise to a more reasonable encoding if you really have to deal with multi-byte ANSI date
p44082
as(dp44083
g7
V505088
p44084
stp44085
a((dp44086
g2
(lp44087
VThe documentation for WM_CHAR says:
p44088
aVBecause there is not necessarily a one-to-one
p44089
aVcorrespondence between keys pressed and character
p44090
aVmessages generated, the information in the high-order
p44091
aVword of the lParam parameter is generally not useful to
p44092
aVapplications
p44093
aVThe information in the high-order word applies
p44094
aVonly to the most recent WM_KEYDOWN message that precedes the posting of the WM_CHAR message
p44095
aVYou will have to process the WM_KEYDOWN and WM_KEYUP messages to get extended key information
p44096
as(dp44097
g7
V505088
p44098
stp44099
a((dp44100
g2
(lp44101
VThe problem is in the design of your interface and the use of
p44102
aVThis is implemented by making an implicit, hidden, local string variable which holds the value
p44103
aVWhen the function returns, that string variable is destroyed and so  points at deallocated memory
p44104
aVSometimes your program appears to work but that's really just down to chance
p44105
aVAny small change can disturb that, as you have observed
p44106
aVThe problem is easy enough to fix
p44107
aVSimply use string parameters rather than
p44108
aVThis will make the code easier to read as well as making it work correctly
p44109
as(dp44110
g7
V505088
p44111
stp44112
a((dp44113
g2
(lp44114
VSSE instructions won't speed up reading the file
p44115
aVThat will be limited by your disk access
p44116
aVOnce you have the file in memory, then, if your compiler emits SSE instructions, the operations performed on the matrix will benefit
p44117
as(dp44118
g7
V505088
p44119
stp44120
a((dp44121
g2
(lp44122
VThe Delphi language does not support multiple inheritance of implementation, only multiple inheritance of interface
p44123
aVThus you cannot simply merge together two classes in the way you hope
p44124
aVWhat you are proposing sounds a bit odd anyway
p44125
aVBoth  and  have their own visual surfaces
p44126
aVThe only plausible thing I can imagine is that you could make the  a child of the
p44127
aVDerive a new component from
p44128
aVThat component would create and own a
p44129
aVMake the parent of the  sub control be the panel
p44130
aVAny properties and events of the  control that you want to surface in your control would have to be done manually
p44131
aVThis is composition rather than inheritance
p44132
as(dp44133
g7
V505088
p44134
stp44135
a((dp44136
g2
(lp44137
VNavigating the Win32 API can be a tricky business
p44138
aVThe registry APIs are some of the more complicated
p44139
aVHere's a short program to demonstrate how to read a registry string
p44140
aVNotes:
p44141
aVI don't have CE so this is a plain Win32 app, compiled for Unicode
p44142
aVI took that route because CE doesn't do ANSI characters
p44143
aVI've taken advantage of a number of C++ features
p44144
aVMost significantly
p44145
aVThis makes string handling a cinch
p44146
aVI've used exceptions for error handling
p44147
aVYou could replace that with some other mechanism, but it served my purpose of keeping the error handling issues in the background
p44148
aVUsing exceptions makes closing the registry key slightly messy
p44149
aVA better solution would be to use an RAII class to wrap up the lifetime of the registry key
p44150
aVI've omitted that for simplicity, but in production code you would want to take that extra step
p44151
aVUsually,  returns  data that is null-terminated
p44152
aVThis code deals with that by truncating beyond the first null character
p44153
aVIn case the value returned is not null-terminated, that truncation won't happen, but the value will still be fine
p44154
aVI've just printed to my console, but it would be trivial for you to call
p44155
aVLike this:
p44156
as(dp44157
g7
V505088
p44158
stp44159
a((dp44160
g2
(lp44161
VI think you are looking for an indexer
p44162
aVIndexers allow instances of a class or struct to be indexed just like arrays
p44163
aVIndexers resemble properties except that their accessors take parameters
p44164
aVIn your case you want to index using a string
p44165
aVSomething like this:
p44166
aVIt may be that you would be better off removing the  layer from your syntax
p44167
aVThat would result in your code reading like this:
p44168
as(dp44169
g7
V505088
p44170
stp44171
a((dp44172
g2
(lp44173
VAt a high level, what is happening is that:
p44174
aVYour algorithm doesn't work correctly
p44175
aVAt a certain iteration,  becomes negative
p44176
aVWhen that is passed to , a NaN is returned
p44177
aVThe iteration terminates
p44178
aVThe call to  displays the  as
p44179
aVYou can discern all this with a debugger, or even with the old fashioned technique of throwing in some debug  output
p44180
aVFor example, add some code to print  on each iteration of the loop
p44181
aVSince you have knowledge that the solution lies in [2,3], I would personally use a bracketing root finder
p44182
aVFor example, bisection
p44183
as(dp44184
g7
V505088
p44185
stp44186
a((dp44187
g2
(lp44188
VYour trig formula is wrong
p44189
aVRecall that O/H = sin, where O is opposite and H is hypoteneuse
p44190
aVRearrange to give H = O/sin
p44191
aVThat's the formula that you need
p44192
aVYou may need to convert from degrees to radians depending on what form you expect the input
p44193
aVThe Python trig functions use radians for angles
p44194
aVConvert with math
p44195
aVradians()
p44196
as(dp44197
g7
V505088
p44198
stp44199
a((dp44200
g2
(lp44201
VAs Viktor points out, C/C++  is 32 bits in size so needs to be matched with C#
p44202
aVOn top of that, the passing of the struct is not handled correctly
p44203
aVIn addition the call to  leaks since you never call
p44204
aVI'd probably handle the marshalling something like this:
p44205
as(dp44206
g7
V505088
p44207
stp44208
a((dp44209
g2
(lp44210
VYou cannot reliably run VCL forms outside the main GUI thread
p44211
aVWhen you try to do this, it may appear to work, but at some point in the future such code will fail
p44212
aVMost likely on your most important clients machine, in a particularly critical manner
p44213
aVThe VCL was designed such that all VCL forms are created and operated on from the main GUI thread only
p44214
aVIf you need to invoke VCL forms then you have to use tools like  to make sure that the forms are created on the GUI thread
p44215
as(dp44216
g7
V505088
p44217
stp44218
a((dp44219
g2
(lp44220
VThis code is incorrect
p44221
aVThe function  may return before the thread function starts executing
p44222
aVAnd so by the time the thread function reads the local variable, the scope of that variable may have ended
p44223
aVWhat can confuse matters is that this code may very well appear to work, at least some of the time
p44224
aVHowever, it is incorrect and you should use heap allocated memory instead
p44225
as(dp44226
g7
V505088
p44227
stp44228
a((dp44229
g2
(lp44230
VThe easiest way to do this on Windows is to call
p44231
aVPass  to make sure that no console window is shown
p44232
aVYou could alternatively use  but it's a little trickier to call
p44233
aVUse the  flag to suppress the console window
p44234
as(dp44235
g7
V505088
p44236
stp44237
a((dp44238
g2
(lp44239
VIs it dangerous to use synchronize in a non-VCL application
p44240
aVYes it is dangerous
p44241
aVIf your main thread is not calling  then  will result in deadlock
p44242
aVLet's assume
p44243
aVit is a non-VCL application which has a main thread which executes in an endless loop (or until terminated)
p44244
aVthe main thread does not call  directly or in a  handler
p44245
aVa secondary thread runs and executes  like in the example above
p44246
aVWill the thread hang on the  line
p44247
aVThe call to  will block the background thread until the main thread calls
p44248
aVSo, if the main thread never calls , the background thread will block indefinitely
p44249
aVThe following program illustrates this:
p44250
as(dp44251
g7
V505088
p44252
stp44253
a((dp44254
g2
(lp44255
VWindows supports adding icons into the tray, whose official name is the notification area
p44256
aVIt does not support adding anything else there, so your idea of adding a WinForm is simply not viable
p44257
as(dp44258
g7
V505088
p44259
stp44260
a((dp44261
g2
(lp44262
VYou don't want to make your functions  because that gives them internal linkage
p44263
aVAs the error message tells you, that's not compatible with the functions being exported
p44264
aVYour JNI functions need to have external linkage
p44265
aVThis can be achieved by replacing  with
p44266
aVHowever, since external linkage is the default for functions you can simply remove the  linkage specifier and omit
p44267
aVYou also need to specify C linkage since you are compiling as C++ rather than C
p44268
aVDo this with
p44269
aVIf you use the default C++ linkage then you end up with C++ name mangling which I suspect is the cause of your linker error
p44270
aVSo your code should be like this:
p44271
as(dp44272
g7
V505088
p44273
stp44274
a((dp44275
g2
(lp44276
VYou can think of local variables as  always being allocated on the stack of the executing thread
p44277
aVI guess JIT compiler could optimise them into registers, but semantically they are indistinguishable from stack allocated variables
p44278
aVTheir scope and lifetime is private to each invocation of a function
p44279
aVYou also ask about static variables (class variables) and the heap
p44280
aVClass variables are shared between threads in the sense that references to class variables all refer to the same variable no matter which thread is executing
p44281
aVAnd likewise for objects that reside on the heap
p44282
as(dp44283
g7
V505088
p44284
stp44285
a((dp44286
g2
(lp44287
VWell, as you have clearly explained, you can't use
p44288
aVAnd so that leaves
p44289
aVBut that requires an absolute path
p44290
aVSo, expand your relative path into an absolute path using your preferred file path utility functions, and pass that on to
p44291
aVThis may seem inconvenient but it's much more robust than relying on the vagaries of library search paths
p44292
as(dp44293
g7
V505088
p44294
stp44295
a((dp44296
g2
(lp44297
VI cannot reproduce that at all
p44298
aVBackslash is composed on an AZERTY keyboard by holding down AltGr and then pressing the 8 key on the row of numbers above the letters
p44299
aVWhen you do that the following  events are fired:
p44300
aVKeyCode: Menu, KeyValue: 18 for the AltGr going down
p44301
aVKeyCode: D8, KeyValue: 56 for the 8 going down
p44302
aVOn the other hand, if you press the key immediately to the left of W then a  with KeyCode OemBackslash and KeyValue 226 is fired, and a  character appears in the text box
p44303
aVI wonder if your keyboard layout is not set correctly to match your particular keyboard
p44304
aVI'm assuming that your keyboard looks like the image on this Wikipedia page: http://en
p44305
aVwikipedia
p44306
aVorg/wiki/AZERTY
p44307
as(dp44308
g7
V505088
p44309
stp44310
a((dp44311
g2
(lp44312
VYes, calling fread does indeed move the file pointer
p44313
aVThe file pointer will be advanced by the number of bytes actually read
p44314
aVIn case of an error in fread, the file position after calling fread is unspecified
p44315
as(dp44316
g7
V505088
p44317
stp44318
a((dp44319
g2
(lp44320
VThat code is not thread safe
p44321
aVIf multiple threads execute the function then multiple instances of MyObj could be created
p44322
aVYou need some form of synchronization here
p44323
aVThe fundamental issue is that this block code:
p44324
aVis not atomic
p44325
aVIn fact it's a very long way from being atomic
p44326
as(dp44327
g7
V505088
p44328
stp44329
a((dp44330
g2
(lp44331
VYou need to use
p44332
aVThat MSDN link contains some sample code to get you going
p44333
aVUltimately this is wrapping the native functionality exposed by IFileDialog::AddPlace
p44334
as(dp44335
g7
V505088
p44336
stp44337
a((dp44338
g2
(lp44339
VIf you are in control of the add-in then you simply need to choose a different location for the config file
p44340
aVA location to which a standard user has write permissions
p44341
aVIf you are not in control of the add-in, then you have two viable options:
p44342
aVAlways run Word as administrator
p44343
aVAdd an ACL to the config file to grant write access to standard users
p44344
aVYou ask:
p44345
aVIs there any way I can write to these files successfully from C# code for non-admin accounts also, without asking user to change the permission of the file
p44346
aVNo there is not
p44347
aVJust imagine if there was a way to do this
p44348
aVThat would completely negate the utility of file system security
p44349
as(dp44350
g7
V505088
p44351
stp44352
a((dp44353
g2
(lp44354
VYou don't need to be inside a  block in order to raise an exception
p44355
aVOn the other hand, if you want to catch and handle an exception then you do need to use a  block
p44356
aVIt is a syntax error to write  without either  or
p44357
aVOr indeed to write  without its matching
p44358
aVThese language constructs are inextricably linked
p44359
as(dp44360
g7
V505088
p44361
stp44362
a((dp44363
g2
(lp44364
VTo compare the colours, excluding comparison of alpha, you don't need any more than this:
p44365
aVTo implement your dictionary based approach you could populate the dictionary with colours that have alpha value of 255 using
p44366
aVPerhaps use an extension method:
p44367
aVCreating a new color that combines the alpha channel from one color with the RGB from another color is simple enough:
p44368
as(dp44369
g7
V505088
p44370
stp44371
a((dp44372
g2
(lp44373
VHow to check timer time
p44374
aVYou cannot
p44375
aVThe timer classes offer no way check how long remains before a timer is due to fire
p44376
aVThe best you can do is to keep track of when the timer last fired and calculate yourself how long remains before the next tick
p44377
as(dp44378
g7
V505088
p44379
stp44380
a((dp44381
g2
(lp44382
VAttributeError: 'NoneType' object has no attribute 'connectSSL'
p44383
aVis the error message that you get when you try to invoke a method on
p44384
aVThis line of code
p44385
aVis the only place where  is assigned
p44386
aVThe error message makes it clear that  is being assigned the value
p44387
aVAll the web search hits that I can find on the topic follow this pattern:
p44388
aVand so I guess that's how you are meant to do it
p44389
aVBut I do confess to knowing precisely nothing about these frameworks
p44390
as(dp44391
g7
V505088
p44392
stp44393
a((dp44394
g2
(lp44395
VThe documentation states:
p44396
aVSince glibc 2
p44397
ag25125
aV3, atexit() (and on_exit(3)) can be used within a
p44398
aVshared library to establish functions that are called when the shared
p44399
aVlibrary is unloaded
p44400
aVOn the other hand, why don't you just make an object of global scope and perform your tidy up code in its destructor
p44401
as(dp44402
g7
V505088
p44403
stp44404
a((dp44405
g2
(lp44406
VYou declared pointers  and  of type  but never initialised those pointers
p44407
aVYou need to allocate  variables and then pass pointers to those variables
p44408
aVLike this:
p44409
as(dp44410
g7
V505088
p44411
stp44412
a((dp44413
g2
(lp44414
VYou need to declare a pointer variable, and then assign to it
p44415
aVYou can do this all in one line of code, like this:
p44416
aVI'm using  here because  returns a pointer to a string whose contents must not be modified by the program
p44417
aVUsing  lets the compiler help us honour that contract
p44418
as(dp44419
g7
V505088
p44420
stp44421
a((dp44422
g2
(lp44423
VYou just leave this to the compiler
p44424
aVGood compilers know about the hardware that they are targetting
p44425
aVIf the compiler knows that bitwise operations are faster, then it can emit code to do it that way
p44426
aVYou should always write the human readable code in the most clear fashion, the fashion that correctly expresses the operation being performed
p44427
aVLet the compiler do the rest
p44428
aVAs for whether or not it is still true that bitwise operations can be faster than arithmetic, I believe that they are
p44429
aVCertainly many modern C++ compilers will emit code that uses bitwise operations for arithmetic
p44430
as(dp44431
g7
V505088
p44432
stp44433
a((dp44434
g2
(lp44435
VAlright, here is what is happening
p44436
aVYou set  so that when a non-declared variable is encountered, the interpreter shall raise an error
p44437
aVBefore you reach the first non-declared variable, , you switch off error handling with
p44438
aVThen you encounter  and an error is raised, but not reported
p44439
aVExecution resumes and the non-declared variable error is interpreted by the  statement
p44440
aVAnd so  always returns
p44441
aVFix the problem by declaring  before attempting to use it:
p44442
as(dp44443
g7
V505088
p44444
stp44445
a((dp44446
g2
(lp44447
VThe documentation for  explains why that function always returns  for you:
p44448
aVThe handle must already be owned by another NativeWindow in the
p44449
aVcurrent process; otherwise, null is returned
p44450
aVBut the window that you are targetting is in a different process
p44451
aVSo you simply cannot use  here
p44452
aVYou will have to make do with the window handle as an
p44453
aVIn your edit you state:
p44454
aVI want to deal with the entire window object and its own controls
p44455
aVThat changes nothing
p44456
aVYou can't use
p44457
aVYou will have to deal with the raw Win32 API
p44458
as(dp44459
g7
V505088
p44460
stp44461
a((dp44462
g2
(lp44463
VThe difference is that  is a non-portable, POSIX function and  is portable, standard C function
p44464
aVSpecify  when calling  to use append mode
p44465
as(dp44466
g7
V505088
p44467
stp44468
a((dp44469
g2
(lp44470
VThat's just the bitwise xor operator
p44471
aVIt is often used to combine hash codes from different objects into a single overall hash code
p44472
aVIt's not one of the easiest things to search for on Google
p44473
aVMy tip when searching for such things is to look at the table of all operators
p44474
as(dp44475
g7
V505088
p44476
stp44477
a((dp44478
g2
(lp44479
VWhat is happening is that  is returning  which you then pass to  and so produce the seg fault
p44480
aVThe documentation states that  returns  if there is no value assigned to the specified field
p44481
aVTo solve this you will need to guard against passing  to :
p44482
as(dp44483
g7
V505088
p44484
stp44485
a((dp44486
g2
(lp44487
VYou C++ code uses the  calling convention and the C# code defaults to
p44488
aVThis mismatch explains the message that you see
p44489
aVMake the two sides of the interface match:
p44490
aVAlternatively you could use  for your C++ exports:
p44491
aVIt's up to you which of these two options you choose, but make sure that you only change one side of the interface and not both, for obvious reasons
p44492
as(dp44493
g7
V505088
p44494
stp44495
a((dp44496
g2
(lp44497
VThis is explained in the documentation for :
p44498
aVThe virtual key code is in the low-order byte, and the modifier flags are in the high-order byte
p44499
aVThe modifier flags can be a combination of the following values:
p44500
aVHOTKEYF_ALT (ALT key)
p44501
aVHOTKEYF_CONTROL (CTRL key)
p44502
aVHOTKEYF_EXT (Extended key)
p44503
aVHOTKEYF_SHIFT (SHIFT key)
p44504
aVThese flags are defined so:
p44505
aVSo, when you take the CTRL and ALT flags to the high order byte of a word, and combine them, you get  which equals
p44506
aVCombine this with the virtual key code for A which is  and you have your magic constant of
p44507
as(dp44508
g7
V505088
p44509
stp44510
a((dp44511
g2
(lp44512
VThe final parameter is
p44513
aVThat's unsigned, and 32 bits in a 32 bit process and 64 bits in a 64 bit process
p44514
aVSo the best solution is to use  for the final parameter
p44515
aVI would use the following:
p44516
aVYour code uses  which is always 64 bits wide
p44517
aVAnd your process is a 32 bit process which explains why the P/invoke marshaller has detected a stack imbalance
p44518
as(dp44519
g7
V505088
p44520
stp44521
a((dp44522
g2
(lp44523
Vcatches an exception of class ShortInputException and binds the instance of the exception object to x
p44524
aVThe more common syntax for this is
p44525
aVwhich is to be preferred as described in PEP3110
p44526
aVUnless you need to support Python 2
p44527
aV5, you should use the as version
p44528
aVcalls the constructor for the super class, the class that this user defined class derives from
p44529
as(dp44530
g7
V505088
p44531
stp44532
a((dp44533
g2
(lp44534
VYes it is perfectly safe to do this
p44535
aVNaturally each different class must have a unique name, but it's up to you to ensure that is the case
p44536
as(dp44537
g7
V505088
p44538
stp44539
a((dp44540
g2
(lp44541
VYou are using the MS C compiler which only supports the now ancient C90 standard
p44542
aVAll your variables must be declared at the top of the function body
p44543
aVPainful, isn't it
p44544
as(dp44545
g7
V505088
p44546
stp44547
a((dp44548
g2
(lp44549
VAn interface cannot inherit from a class
p44550
aVIn order to do that C# would need to support multiple inheritance of implementation which is currently not supported
p44551
aVImagine if you could derive an interface, , from a class,
p44552
aVThen when you come to declare another class that implements that interface, you would have to write something like:
p44553
aVBut that implies multiple inheritance of implementation since you are inheriting from both  and
p44554
as(dp44555
g7
V505088
p44556
stp44557
a((dp44558
g2
(lp44559
VThe only way that call can fail in that manner is if
p44560
aVis invalid
p44561
aVEither  itself is invaild, or
p44562
aVMost likely the former
p44563
as(dp44564
g7
V505088
p44565
stp44566
a((dp44567
g2
(lp44568
VThe  attached to the return value applies to the return value
p44569
aVSince the return value is copied it's a pointless declaration and it makes no difference whether or not you include it
p44570
aVThe  after the parameter list means that the function does not modify any state of the object that is not marked as mutable
p44571
aVThis is a const member function and if you have a const object the compiler will not allow you to call non-const member functions on a const object
p44572
aVThere is no interaction between these two uses of  - they are completely independent constructs
p44573
as(dp44574
g7
V505088
p44575
stp44576
a((dp44577
g2
(lp44578
VWhen the user presses a key, or performs any other form of input, the system places messages in the message queue
p44579
aVThen, your app must pull off those messages in its message loop, and deal with them
p44580
aVMany UI frameworks will process those messages for you and convert them into events
p44581
aVNote that the events that you talk about are not events in any sense that Windows defines
p44582
aVThat use of events refers to a concept defined in whatever programming language/framework you are using
p44583
aVWindows events are used for thread synchronization
p44584
aVThe top level message loop may look like this:
p44585
aVThe call to  results in a window procedure being called
p44586
aVThe GUI framework typically implements that window procedure and converts the message into an event
p44587
aVSo, the executive summary is that:
p44588
aVInput events lead to messages
p44589
aVThe GUI framework converts the messages into events
p44590
aVYou implement event handlers to respond to those events
p44591
as(dp44592
g7
V505088
p44593
stp44594
a((dp44595
g2
(lp44596
V is specified in 1/500th of a second
p44597
aVSo, the following equations hold:
p44598
aVI would calculate it all like this:
p44599
aVIf you need to calculate the fractional part of seconds then do it like this
p44600
aVNote that there's simply no need for  here
p44601
aVPlug your value of 40582974 into these formula and the results are:
p44602
aVJudging from comments what you actually want is degrees as an integer and minutes as a floating point
p44603
aVThat you can do like this:
p44604
aVPlug your value of 40582974 into these formula and the results are:
p44605
as(dp44606
g7
V505088
p44607
stp44608
a((dp44609
g2
(lp44610
VIn my view you are over-complicating the problem
p44611
aVStarting and stopping services is a complicated action and indeed it is forbidden by default for non-admin users
p44612
aVThis very fact will make your application very annoying to use
p44613
aVYou will limit its use to admin users, and also pepper them with UAC dialogs
p44614
aVNobody likes apps like that
p44615
aVThe alternative is to simply leave your service running the whole time, but make it inactive whilst the standard desktop app is running
p44616
aVWhen the desktop app starts it strikes up communication with the service using some form of IPC and asks the service to stop work
p44617
aVThe service does this and then the desktop app proceeds
p44618
aVWhen the desktop app closes, the service is asked to resume work
p44619
aVYou would want to keep a communication channel open the whole time to guard against the desktop app terminating abnormally \u2013 if that happened the service would simply start up again
p44620
aVNow, if you really wanted to do a good job you could let all the processing of work always happen in the service
p44621
aVThe desktop app would merely be a front end for the service
p44622
aVThat would seem to me to be the most efficient and logical design for this app
p44623
as(dp44624
g7
V505088
p44625
stp44626
a((dp44627
g2
(lp44628
VThe GCC documentation states:
p44629
aVThis attribute, attached to a union type definition, indicates that
p44630
aVany function parameter having that union type causes calls to that
p44631
aVfunction to be treated in a special way
p44632
aVIn other words, the transparency only applies to function parameters
p44633
as(dp44634
g7
V505088
p44635
stp44636
a((dp44637
g2
(lp44638
VThis is just common or garden sampling variation
p44639
aVImagine an experiment where you toss a coin ten times, repeatedly
p44640
aVYou would not expect to get five heads every single time
p44641
aVThat's down to sampling variation
p44642
aVIn just the same way, your experiment will be subject to sampling variation
p44643
aVEach bit follows the same statistical distribution
p44644
aVBut sampling variation means that you would not expect an exact 50/50 split between 0 and 1
p44645
aVNow, your plot is misleading you into thinking the variation is somehow significant or carries meaning
p44646
aVYou'd get a much better understanding of this if you plotted the Y axis of the graph starting at 0
p44647
aVThat graph looks like this:
p44648
aVIf the RNG behaves as it should, then each bit will follow the binomial distribution with probability 0
p44649
ag7303
aVThis distribution has variance np(1 \u2212 p)
p44650
aVFor your experiment this gives a variance of 2
p44651
aV5 million
p44652
aVTake the square root to get the standard deviation of around 1,500
p44653
aVSo you can see simply from inspecting your results, that the variation you see is not obviously out of the ordinary
p44654
aVYou have 15 samples and none are more than 1
p44655
aV6 standard deviations from the true mean
p44656
aVThat's nothing to worry about
p44657
aVYou have attempted to discern trends in the results
p44658
aVYou have said that there are "3 most probable bits"
p44659
aVThat's only your particular interpretation of this sample
p44660
aVTry running your programs again with different seeds for your RNGs and you will have graphs that look a little different
p44661
aVThey will still have the same quality to them
p44662
aVSome bits are set more than others
p44663
aVBut there won't be any discernible patterns, and when you plot them on a graph that includes 0, you will see horizontal lines
p44664
aVFor example, here's what your C program outputs for a random seed of
p44665
aVI think this should be enough to persuade you to run some more trials
p44666
aVWhen you do so you will see that there are no special bits that are given favoured treatment
p44667
as(dp44668
g7
V505088
p44669
stp44670
a((dp44671
g2
(lp44672
VMy guess is that this is what happens:
p44673
aVYou move the mouse to 0,0 with SetCursor
p44674
aVThat act of calling SetCursor generates a mouse move event from your hook
p44675
aVYou respond to the mouse move by showing the cursor again and putting it back where it was before
p44676
as(dp44677
g7
V505088
p44678
stp44679
a((dp44680
g2
(lp44681
VIt's an optimisation
p44682
aVThe variables  and  are passed by value
p44683
aVThat means that modifications to them are not seen by the caller and are private to this procedure
p44684
aVHence the compiler can work out that assigning to them is pointless
p44685
aVThe values assigned to the variables can never be read
p44686
aVSo the compiler elects to save time and skip the assignments
p44687
aVI expect that you meant to declare the procedure like this:
p44688
aVAs I said in your previous question, there's not really much point in using
p44689
aVYou would be better off with one of the standard floating point types,  or
p44690
aVOr even using the generic  which maps to
p44691
aVAlso, you have declared  to be of floating point type, but the calculation computes an integer
p44692
aVMy answer to your previous question is quite precise in this regard
p44693
aVI would recommend that you create a record to hold these values
p44694
aVPassing three separate variables around makes your function interfaces very messy and breaks encapsulation
p44695
aVThese three values only have meaning when consider as a whole
p44696
as(dp44697
g7
V505088
p44698
stp44699
a((dp44700
g2
(lp44701
VThe function is returning a struct rather than a float
p44702
aVYou have to declare that struct in your C# code
p44703
aVAnd then you define your p/invoke to pass that struct to the function, as an out parameter
p44704
aVAnd, finally, you call the function like this:
p44705
as(dp44706
g7
V505088
p44707
stp44708
a((dp44709
g2
(lp44710
V and  are native Win32 APIs that allow you to read and write from and to the memory of a different processes
p44711
aVYou only ever need to use those APIs when trying to read and write memory in a different process
p44712
aVAs you may imagine, they are not often used in routine development
p44713
aVis used to copy between managed and unmanaged memory, but within the same process
p44714
aVWould Marshal
p44715
aVCopy work in all cases where ReadProcessMemory/WriteProcessMemory works, or is it more limiting
p44716
aVNo,  it is limited to operating within a single process
p44717
aVDoes Marshal
p44718
aVCopy's implementation use ReadProcessMemory/WriteProcessMemory APIs internally
p44719
aVNo
p44720
aVTo clarify: I am talking about reading from / writing to the calling (owning) process's memory only, not the memory of other processes
p44721
aVIn which case,  and  are simply not pertinent to your needs
p44722
as(dp44723
g7
V505088
p44724
stp44725
a((dp44726
g2
(lp44727
VYou declared the struct as a class in C#
p44728
aVThat's fine, but it means that any variable of that type is already a reference
p44729
aVSo you don't need to pass by
p44730
aVWhen you pass a class by ref you end up passing a pointer to a pointer to the object
p44731
aVThat's one level of indirection too many
p44732
aVThe P/invoke in the C# code should therefore be like this:
p44733
aVThe other way to fix it is to leave the  in the function declaration, but to declare the  type as a  rather than a
p44734
aVThat's because a  is a value type
p44735
aVA variable whose type is a struct is a value rather than a reference
p44736
aVBoth solutions work, it's up to you which you choose
p44737
aVThere is another problem in your C++ code
p44738
aVYou are passing  and , which are of type  to  and expecting the  format string to print them
p44739
aVThat's an error
p44740
aVYou need to call  on the strings
p44741
aVLike this:
p44742
aVThe problem with your update is that long is 32 bits in Windows C++ and 64 bits in C#
p44743
aVYou need to declare it as  in C#
p44744
aVAnd you missed the  field altogether
p44745
as(dp44746
g7
V505088
p44747
stp44748
a((dp44749
g2
(lp44750
VYou are passing a pointer, by value, to
p44751
aVThe value you assign to  in  is therefore not returned to the caller
p44752
aVYou need to pass a pointer to the pointer:
p44753
aVAnd call it like this:
p44754
aVIn fact you can write  like this:
p44755
aVAnd in fact it would be simplest just to return the  as the functions return value:
p44756
as(dp44757
g7
V505088
p44758
stp44759
a((dp44760
g2
(lp44761
VYou need to do what Windows does
p44762
aVAnd spawn a new process which will run with elevated rights
p44763
aVThere are no shortcuts here
p44764
aVThe token that is allocated when a process starts is what determines what rights the process has
p44765
aVThat token cannot be changed after the process has started
p44766
aVIf you need to elevate, you need a new process
p44767
aVI've seen lots of answers around this topic that involve spawning a new process with elevated privileges using 'runas'
p44768
aVAlso, it seems like this can be done by impersonating another user
p44769
aVFrom what I understand, both of those methods require a user to provide user credentials
p44770
aVNo that's not the case
p44771
aVIf the current user is not an admin, then the UAC dialog will prompt for new credentials of a user that does have admin rights
p44772
aVThat's the over-the-shoulder UAC dialog
p44773
aVOn the other hand, if the current user is an admin then they just get the consent dialog
p44774
aVThat's the dialog that's shown on the secure desktop and  just asks for you to click Continue
p44775
aVThe one thing that Windows components can do that you cannot is start a process elevated without showing you the consent dialog
p44776
aVThat happens on Windows 7 only (not on Vista), and only if you have the UAC setting at the new Default setting that was added in Windows 7
p44777
aVThat's how Explorer is able to show the dialog that you included in the question and then start an elevated process to do the copying without showing the consent UAC dialog
p44778
aVOnly Windows components are granted that ability
p44779
aVBut the bottom line is that you need to start a new process that runs elevated
p44780
aVUsing the  verb is the canonical way to do it
p44781
as(dp44782
g7
V505088
p44783
stp44784
a((dp44785
g2
(lp44786
VNo, this is a C99 feature
p44787
aVHowever, some compilers will allow it as an extension in C89 mode, e
p44788
ag217
aVgcc
p44789
as(dp44790
g7
V505088
p44791
stp44792
a((dp44793
g2
(lp44794
VYour problems stem from the use of  which is the wrong event to be using
p44795
aVRemy's answer explains how to workaround Windows shutdown being blocked by the default VCL end session message handling
p44796
aVAnd this in turn is caused by setting  to  in the  event
p44797
aVThat workaround will get the job done but there's a much simpler way to deal with this
p44798
aVInstead of stopping the form from closing, let it go ahead and close
p44799
aVRemove your  event altogether
p44800
aVReplace it with an  event
p44801
aVThis rather trivial bit of code is enough to make your app minimize to the tray when the main form is closed
p44802
as(dp44803
g7
V505088
p44804
stp44805
a((dp44806
g2
(lp44807
VYou need to create an executable that targets the GUI subsystem rather than the console subsystem
p44808
aVIn the MS tools the normal way to indicate that is to use a different form of main function:
p44809
aVI believe that mingw supports the same convention
p44810
as(dp44811
g7
V505088
p44812
stp44813
a((dp44814
g2
(lp44815
VIf you are always passing two ints to this one parameter then it makes no sense to pass a double
p44816
aVInstead pass either the two ints as separate ints, or wrap them up in a struct
p44817
aVThe way you are doing it leaves you no opportunity to detect the difference between a true double and two ints
p44818
aVAnd so I conclude that you will lose no functionality by doing what I describe above
p44819
as(dp44820
g7
V505088
p44821
stp44822
a((dp44823
g2
(lp44824
VYour variable is an instance variable and there is a one to one mapping between threads and instances
p44825
aVSo each thread has a separate copy of the state
p44826
aVTherefore no synchronization is needed
p44827
aVIf the variable was shared between threads then you would need to synchronize
p44828
as(dp44829
g7
V505088
p44830
stp44831
a((dp44832
g2
(lp44833
VYou can pass  or  or  to  and have it return a NaN
p44834
aVThe documentation gives the full details
p44835
as(dp44836
g7
V505088
p44837
stp44838
a((dp44839
g2
(lp44840
VThis is described in the [expr] section of the standard:
p44841
aVOtherwise, the integral promotions (4
p44842
aV5) shall be performed on both
p44843
aVoperands
p44844
aVThen the following rules shall be applied to the promoted
p44845
aVoperands:
p44846
aV\u2014 If both operands have the same type, no further conversion
p44847
aVis needed
p44848
aV\u2014 Otherwise, if both operands have signed integer types or
p44849
aVboth have unsigned integer types, the operand with the type of lesser
p44850
aVinteger conversion rank shall be converted to the type of the operand
p44851
aVwith greater rank
p44852
aV\u2014 Otherwise, if the operand that has unsigned
p44853
aVinteger type has rank greater than or equal to the rank of the type of
p44854
aVthe other operand, the operand with signed integer type shall be
p44855
aVconverted to the type of the operand with unsigned integer type
p44856
aVThe expression is evaluated left to right and so  is calculated first
p44857
aVThis has two integral types of the same rank, one operand signed and the other unsigned
p44858
aVHence the signed value is converted to an unsigned value, as described in the final paragraph of the standards extract
p44859
as(dp44860
g7
V505088
p44861
stp44862
a((dp44863
g2
(lp44864
VThe full documentation can be found on MSDN: http://msdn
p44865
aVmicrosoft
p44866
aVcom/en-us/library/ff841702
p44867
as(dp44868
g7
V505088
p44869
stp44870
a((dp44871
g2
(lp44872
VIn your command, the  is redirecting the output of  rather than the output of
p44873
aVThat explains why you are seeing nothing \u2013  is simply not outputting anything
p44874
aVBased on the comments to the question, you can achieve your goals with  like this:
p44875
as(dp44876
g7
V505088
p44877
stp44878
a((dp44879
g2
(lp44880
VThis is what is happening
p44881
aVYour struct is what is known as a variable length struct
p44882
aVThe pixel data is containined inline in the struct, starting at the offset to
p44883
aVYour API returns  which is an  that points to unmanaged data of type
p44884
aVHowever, if you look at the native code then you will see that  is equal to
p44885
aVThis is because the  has to be defined statically at compile time
p44886
aVIn reality the pixel data will have length determined by the height, width and colour count fields
p44887
aVYou can carry on using  to get at most of the fields
p44888
aVBut you can't get at the  field that way
p44889
aVThat's going to need a little more work
p44890
aVDeclare the struct like this instead:
p44891
aVWhen you need to get the image data do this:
p44892
aVIf you are not yet on
p44893
aVnet 4 then you need casting to make the arithmetic compile:
p44894
aVFinally, I think you are calculating  incorrectly
p44895
aVSurely you need to use
p44896
aVAlso you have not accounted for the color depth
p44897
aVFor example, 32 bit color will be 4 bytes per pixel
p44898
as(dp44899
g7
V505088
p44900
stp44901
a((dp44902
g2
(lp44903
VYou can use a lock object in combination with
p44904
aVOnly one thread at at time will be allowed into the  block
p44905
aVIf a thread arrives here while another thread is inside, then  returns
p44906
as(dp44907
g7
V505088
p44908
stp44909
a((dp44910
g2
(lp44911
VYou need to declare  like this:
p44912
aVYou need to declare a parameter list that matches the definition in the C++ code
p44913
aVI don't know meaningful names for the parameters but I'm sure you can supply them
p44914
aVThe C++ code specifies the  calling convention which matches  in Delphi
p44915
aVAnd then you can call it like this:
p44916
as(dp44917
g7
V505088
p44918
stp44919
a((dp44920
g2
(lp44921
VTo gain access to the posh new Vista folder selection dialog then I believe that you need to either:
p44922
aVUse a third party component, or
p44923
aVUse the native  component
p44924
aVOption 2 is easy enough using the Windows API CodePack
p44925
aVYou need to include the  option
p44926
aVThe CodePack comes with lots of examples
p44927
aVI commend it to you
p44928
as(dp44929
g7
V505088
p44930
stp44931
a((dp44932
g2
(lp44933
VJust create a file under your user profile
p44934
aVThe default security settings disallow other users access
p44935
aVNaturally administrators have access but you can't hide from an administrator
p44936
as(dp44937
g7
V505088
p44938
stp44939
a((dp44940
g2
(lp44941
VMy reading of your question is that you are asking this:
p44942
aVHow can I, using Delphi 5 targeting x86 hardware, implement thread-safe lazy initialization of a singleton
p44943
aVTo the best of my knowledge you have three options
p44944
ag5537
aVUse a lock
p44945
aVThe downside of this is that if there is contention on  then the serialization of the lock will inhibit scaling
p44946
aVI suspect that people worry about that a lot more than is necessary
p44947
aVFor example, if you have a thread that performs a lot of work, that thread can take a local copy of the reference to the singleton to reduce the contention
p44948
ag25125
aVDouble checked locking
p44949
aVThis is a technique that allows you, once the singleton has been created, to avoid the lock contention
p44950
aVDouble checked locking is a technique with a rather chequered history
p44951
aVThe most famous discussion is The "Double-Checked Locking is Broken" Declaration
p44952
aVThis is set mostly in the context of Java and the problems described do not apply to your situation (Delphi compiler, x86 hardware)
p44953
aVIndeed, for Java, with the advent of JDK5, we can now say that Double-Checked Locking is Fixed
p44954
aVThe Delphi compiler doesn't re-order the write to the singleton variable with respect to the construction of the object
p44955
aVWhat's more, the strong x86 memory model means that processor re-orderings don't break this
p44956
aVSee Who ordered memory fences on an x86
p44957
aVSimply put, double checked locking is not broken on Delphi x86
p44958
aVWhat's more, the x64 memory model is also strong and double checked locking is not broken there either
p44959
ag23064
aVCompare and swap
p44960
aVIf you don't mind the possibility of creating multiple instances of the singleton class, and then discarding all but one, you can use compare and swap
p44961
aVRecent versions of the VCL make use of this technique
p44962
aVIt looks like this:
p44963
as(dp44964
g7
V505088
p44965
stp44966
a((dp44967
g2
(lp44968
VThis looks awfully like a linker error caused by the omission of the
p44969
aVlib file for the 3rd party library
p44970
aVI expect that if you add that to your link options then your problems will be solved
p44971
as(dp44972
g7
V505088
p44973
stp44974
a((dp44975
g2
(lp44976
VYou'll need to use stdcall calling convention, and the string parameter is declared incorrectly (I think)
p44977
aVThe export keyword is no longer used and can be omitted
p44978
aVYou name your exports with the exports keyword, somewhere else in your library code
p44979
aVYour Delphi function should be like this
p44980
aVI'm not sure about PointerByReference
p44981
aVIf that is equivalent to void**, why are you mapping it to THandle
p44982
as(dp44983
g7
V505088
p44984
stp44985
a((dp44986
g2
(lp44987
VYou can simply use System
p44988
aVIO
p44989
aVPath
p44990
aVGetDirectoryName which works just fine with registry paths
p44991
as(dp44992
g7
V505088
p44993
stp44994
a((dp44995
g2
(lp44996
VThere's no way to avoid declaring a variable when you are calling a function with an out parameter
p44997
as(dp44998
g7
V505088
p44999
stp45000
a((dp45001
g2
(lp45002
VThe function that receives a parameter pointing to the variable is more general
p45003
aVIt can be used to modify a global, a local or indeed any variable
p45004
aVThe function that modifies the global can do that task and that task only
p45005
aVWhich is to be preferred depends entirely on the context
p45006
aVSometimes one approach is better, sometimes the other
p45007
aVIt's not possible to say definitively that one approach is always better than the other
p45008
aVAs for whether your global variable really is global, it is global in the sense that there is one single instance of that variable in your process
p45009
as(dp45010
g7
V505088
p45011
stp45012
a((dp45013
g2
(lp45014
VYou need to implement IFileDialogControlEvents
p45015
aVThen call IFileDialog
p45016
aVAdvise passing your IFileDialogControlEvents interface
p45017
aVYour IFileDialogControlEvents
p45018
aVOnButtonClicked method will be called when the button is clicked
p45019
as(dp45020
g7
V505088
p45021
stp45022
a((dp45023
g2
(lp45024
VYou need to pass the network network address of the printer in the arguments parameter
p45025
as(dp45026
g7
V505088
p45027
stp45028
a((dp45029
g2
(lp45030
VToolsAPI is only available in designtime packages
p45031
aVIt exists to expose the IDE for customisation and so is available only under the IDE, i
p45032
ag192
aVin designtime packages
p45033
aVYou will have to remove the reference to ToolsAPI from your desktop app
p45034
as(dp45035
g7
V505088
p45036
stp45037
a((dp45038
g2
(lp45039
VGeneric properties are not supported in Delphi
p45040
aVOnly generic classes, or generic methods
p45041
aVI can't find anything in the documentation that explicitly states that limitation
p45042
aVOn the other hand the documentation only describes generic classes and generic methods
p45043
aVAnd the new language grammar to support generics also makes no mention of properties
p45044
as(dp45045
g7
V505088
p45046
stp45047
a((dp45048
g2
(lp45049
VGetWindowThreadProcessId receives as input a window handle
p45050
aVYou are passing a process handle which is an altogether different beat
p45051
aVNaturally this results in failure
p45052
aVThe subsequent calls to SetFocus, SetForegroundWindow, PostMessage and SetWindowPos commit the same mistake
p45053
aVUse EnumWindows or FindWindow to get hold of the Notepad window handle
p45054
aVAttachThreadInput operates with thread IDs
p45055
aVYou tried to pass a handle to the function and in a 64 bit process handles are 64 bits wide and thread IDs are still 32 bits wide
p45056
aVOf course, AttachThreadInput works perfectly well under 64 bit
p45057
aVThe lesson to learn here is that casts are indicative of programming errors
p45058
aVIf you need to cast parameters to the appropriate type then usually that means that you are passing the wrong thing to the function
p45059
aVAvoid casting
p45060
as(dp45061
g7
V505088
p45062
stp45063
a((dp45064
g2
(lp45065
g5537
aV9 is not exactly representable in floating point, whereas 225 is exactly representable
p45066
aVIt's not clear where the input numbers are coming from, but it is simply impossible with IEEE754 arithmetic to perform the product 1
p45067
aV9*225 exactly
p45068
aVThe behaviour you see has nothing to do with rounding and is in fact all about representability
p45069
aVIf you need to perform this calculation exactly then you need to use decimal arithmetic rather than floating point
p45070
aVThat would mean using the currency type in Delphi or decimal in C#
p45071
aVThe source of your differing behaviour is presumably down to the 8087 control word that controls the floating point register
p45072
aVWhen your DLL executes, called from C#, the control word will differ from the default Delphi setting
p45073
aVCall Set8087CW($1372) at the entry point to your DLL to use the default Delphi control word
p45074
aVRemember to restore it before you return from the DLL
p45075
as(dp45076
g7
V505088
p45077
stp45078
a((dp45079
g2
(lp45080
VIf identical calls to FindWindow return different windows then you must have multiple windows with the name Form1
p45081
aVTry giving these different windows different names so that they can be uniquely identified
p45082
aVThe unused question is a little unclear
p45083
aVPerhaps you mean that the compiler has noticed that the value assigned to tHWND is never used and is thus pointless
p45084
aVI would make a final comment that the question is imprecise and this is probably part of your problem
p45085
aVFor example you say that all the variables are unused but we have no clear idea what you mean
p45086
aVYou will have more success in debugging if you are more precise and methodical
p45087
as(dp45088
g7
V505088
p45089
stp45090
a((dp45091
g2
(lp45092
VBit of a wild guess, but this can happen if the stream's position is not reset to 0 when you try to read from the stream, after having written to it
p45093
aVTry setting
p45094
aVimmediately before using the stream to encrypt
p45095
as(dp45096
g7
V505088
p45097
stp45098
a((dp45099
g2
(lp45100
VThe net result of your code, under Unicode Delphi, is to pass UTF-16 text to
p45101
aVAnd of course, that expects 8 bit ANSI text
p45102
aVYou have two options to resolve the problem:
p45103
aVStick with ANSI text and simply replace  with  in your code snippet
p45104
aVSwitch to Unicode text
p45105
aVUse  and apply the change suggested by Arnaud to correctly handle the length of the 16 bit text
p45106
as(dp45107
g7
V505088
p45108
stp45109
a((dp45110
g2
(lp45111
VIf I understand you correctly, you are looking for this:
p45112
as(dp45113
g7
V505088
p45114
stp45115
a((dp45116
g2
(lp45117
VDifferent Windows schemes have different cursors
p45118
aVIf you are using one of the Aero schemes then you will see the cursors to which you refer
p45119
aVIf you are using, for example, Windows Classic, then you will see the older XP style cursors
p45120
aVis all you need to do to show the currently active scheme's busy cursor
p45121
as(dp45122
g7
V505088
p45123
stp45124
a((dp45125
g2
(lp45126
VThere's no problem here and nothing needs to be fixed
p45127
aVThe  is the string delimiter and is simply escaped for representation as
p45128
aVWhen the debugger shows you  in a string, that's just its way of representing a single quote character
p45129
aVThe documentation covers this topic here: Character Strings
p45130
aVSo,
p45131
aVis a string of length 1 whose single element is the quote symbol
p45132
aVLikewise
p45133
aVis a Delphi string literal defining the string
p45134
aVThe debugger shows you the contents of the variable using the same rules as are used for string literals
p45135
as(dp45136
g7
V505088
p45137
stp45138
a((dp45139
g2
(lp45140
VThe compiler is correct
p45141
aVThe assignment of False to Result is futile and the only value your function can return is True
p45142
aVThe two possible execution paths are:
p45143
aVThe function does not raise an exception and returns True
p45144
aVThe function does raise an exception, and therefore does not return a result value at all
p45145
aVThe solution is simple, remove the line of code that sets Result to False
p45146
aVAt which point it becomes completely clear that the return value serves no purpose and you can simply turn the function into a procedure
p45147
as(dp45148
g7
V505088
p45149
stp45150
a((dp45151
g2
(lp45152
VThe order of parameter evaluation in Delphi is not defined
p45153
aVAs an interesting demonstration of this, the following program has different output depending on whether you target 32 or 64 bit code:
p45154
as(dp45155
g7
V505088
p45156
stp45157
a((dp45158
g2
(lp45159
VHow do you define a class property whose resulting value can be overridden in derived classes
p45160
aVYou cannot, as is made clear by the compiler error message:
p45161
aVE2355 Class property accessor must be a class field or class static method
p45162
aVA class field is shared between two classes that are related by inheritance
p45163
aVSo that cannot be used for polymorphism
p45164
aVAnd a class static method also cannot supply polymorphic behaviour
p45165
aVUse a virtual class function rather than a class property
p45166
as(dp45167
g7
V505088
p45168
stp45169
a((dp45170
g2
(lp45171
VIf every other  contains a null, then almost certainly you actually have UTF-16 encoded strings
p45172
aVProcess them accordingly and your problems will disappear
p45173
aVAssuming you are on Windows, where UTF-16 is common, you would use  rather than  to hold such strings
p45174
aVAnd you would use wide char string processing functions to operate on such data
p45175
aVFor example, use  rather than  and so on
p45176
as(dp45177
g7
V505088
p45178
stp45179
a((dp45180
g2
(lp45181
VThis is a simple case of export forwarding, as described in one of Matt Pietrek's excellent MSDN magazine articles, An In-Depth Look into the Win32 Portable Executable File Format, Part 2
p45182
aVYou can verify this yourself with a tool like Dependency Walker or dumpbin
p45183
as(dp45184
g7
V505088
p45185
stp45186
a((dp45187
g2
(lp45188
VThe key to understanding this issue is the Type Compatibility and Identity topic in the language guide
p45189
aVI suggest you have a good read of that topic
p45190
aVIt is also helpful to simplify the example
p45191
aVThe inclusion of generics in the example serves mainly to complicate and confuse matters
p45192
aVFrom the documentation:
p45193
aVWhen one type identifier is declared using another type identifier, without qualification, they denote the same type
p45194
aVThis means that  and  are the same type, and are indeed the same type as
p45195
aVA little further on in the documentation is this:
p45196
aVLanguage constructions that function as type names denote a different type each time they occur
p45197
aVThe declarations of  and  fall into this category
p45198
aVAnd that means that these two identifiers denote different types
p45199
aVNow we need to look at the section discussing compatibility
p45200
aVThis gives a set of rules to follow to determine whether or not two types are compatible or assignment compatible
p45201
aVWe can in fact shortcut that discussion by referring to another help topic: Structured Types, Array Types and Assignments which states clearly:
p45202
aVArrays are assignment-compatible only if they are of the same type
p45203
aVThis makes it clear why the assignment  results in a compiler error
p45204
aVYour code looked at passing parameters, but mine focused on assignment
p45205
aVThe issues are the same because, as the Calling Procedures and Functions help topic explains:
p45206
aVWhen calling a routine, remember that:
p45207
aVexpressions used to pass typed const and value parameters must be assignment-compatible with the corresponding formal parameters
p45208
as(dp45209
g7
V505088
p45210
stp45211
a((dp45212
g2
(lp45213
VYour code depends on the evaluation order of operands in an expression
p45214
aVThat evaluation order is not defined
p45215
aVLooking at a simpler case, consider this code:
p45216
aVThere is no guarantee over which order the function calls  and  will be executed
p45217
aVYou, presumably, expect  to execute before  but the compiler does not guarantee that and in practice I believe that these operands will usually be evaluated right to left
p45218
aVIn your code, the operands in your expression involve a function call, , that has a side effect which modifies its argument
p45219
aVSince the operands in your expression are not evaluated left to right, the calls to  do not occur in the same order as they appear in the expression
p45220
aVAnd since  has a side-effect which influences the rest of the expression, the results are dependent on the evaluation order
p45221
aVYou will need to re-work this code so that the calls to  occur in separate statements
p45222
as(dp45223
g7
V505088
p45224
stp45225
a((dp45226
g2
(lp45227
VAssuming you have a Delphi version that supports implementing methods on a record, I would clear a record like this:
p45228
aVIf your compiler doesn't support  then you can do the same quite simply like this:
p45229
aVAs an aside, I cannot find any documentation reference for
p45230
aVDoes anyone know where it can be found
p45231
aVAs for the second part of your question, I see no reason not to continue using records, and allocating them using dynamic arrays
p45232
aVAttempting to manage the lifetime yourself is much more error prone
p45233
as(dp45234
g7
V505088
p45235
stp45236
a((dp45237
g2
(lp45238
VIf you don't want to instantiate an instance of a class on the heap, you could use record methods
p45239
aVI sometimes do that to avoid using the heap, but that approach could be convenient for your needs
p45240
as(dp45241
g7
V505088
p45242
stp45243
a((dp45244
g2
(lp45245
VThat signifies a cast
p45246
aVThe function  returns a
p45247
aVThe  casts that value to be of type
p45248
aVIn C, this cast is needless since any pointer type is assignment compatible with
p45249
aVBut if this was C++ then the cast would be needed
p45250
aVThere is no difference between:
p45251
as(dp45252
g7
V505088
p45253
stp45254
a((dp45255
g2
(lp45256
VFor a start, since class constructors cannot be virtual (it makes no sense for them to be virtual), you need to remove the  and  keywords to make your code compile
p45257
aVClass constructors are typically used to initialise class vars
p45258
aVClass vars typically need to be initialised once and once only
p45259
aVIf you could call  in the way you suggest in the question, then  would be called multiple times when in fact it needs to be called exactly once
p45260
aVWhilst you can write  in a class constructor, and the code will compile, the compiler just ignores it
p45261
aVNote that, of course, both class constructors do run
p45262
as(dp45263
g7
V505088
p45264
stp45265
a((dp45266
g2
(lp45267
VWhen the stream object is destroyed, simply trim off the final part of the file
p45268
aVYou can do this by modifying the  property
p45269
as(dp45270
g7
V505088
p45271
stp45272
a((dp45273
g2
(lp45274
VThis code gets the job done:
p45275
aVIn the generated executable, the location where  is stored is treated as data
p45276
aVAs an alternative you could try executing code located on the stack:
p45277
aVBoth of these raise access violation exceptions when DEP is active
p45278
aVIf you need to make sure that DEP is active, for example from a 32 bit process where it is optional, call this function:
p45279
as(dp45280
g7
V505088
p45281
stp45282
a((dp45283
g2
(lp45284
VIt would be more idiomatic to use the  macro
p45285
as(dp45286
g7
V505088
p45287
stp45288
a((dp45289
g2
(lp45290
VCertainly in Delphi, and it appears FPC too, nested functions are not valid for use as callback functions
p45291
aVWhen using the 32 bit compiler, it so happens that nested functions can be used as callbacks
p45292
aVBut such code is only accepted by the compiler because the callback functions are declared in the Windows unit as untyped pointers
p45293
aVIf the Windows unit declared them as procedural types, you find that the compiler objects to using nested functions
p45294
aVFor the 64 bit Delphi compiler, you simply cannot use nested functions as callbacks at all
p45295
aVWhilst the compiler lets you go ahead, because of the use of untyped pointers in the Windows unit (see above), the callback functions are not called correctly
p45296
aVApparently that is true for FPC too
p45297
aVYou will have to stop using nested functions for your callbacks
p45298
aVIt's interesting that both FPC and Delphi compilers have the same characteristics here
p45299
aVMy guess is that the x64 calling convention, which is a register based convention as opposed to the stack based x86  is the driving force behind this issue
p45300
aVI bet that if you tried to use a nested x86  function as a callback, then that would fail at runtime too
p45301
as(dp45302
g7
V505088
p45303
stp45304
a((dp45305
g2
(lp45306
VI'm not sure precisely what's going on here, but it looks like the order of processing of messages is a bit messed up
p45307
aVInstead of killing your other form with , use  and the focus will behave as you desire
p45308
aVAnother option is to use  instead of
p45309
aVNormally you show a processing dialog modally because you don't want the user making modifications to the main form whilst you are processing
p45310
aVIf you do that then you can carry on using
p45311
as(dp45312
g7
V505088
p45313
stp45314
a((dp45315
g2
(lp45316
VI would do this by making a note when the drag process starts, for example when  is called
p45317
aVAnd then reset the flag when the  or  is subsequently called
p45318
as(dp45319
g7
V505088
p45320
stp45321
a((dp45322
g2
(lp45323
VYour header file does not include  and so the symbol  is not known to it
p45324
aVThe way you call  is also wrong
p45325
aVThe second parameter is an  and you want to pass
p45326
aVAnd I bet that your window handle is actually a hex number
p45327
aVAs an aside, I'm not sure why you put so much code in the header file
p45328
aVNormally you would declare the class in the header file and then define the implementation in the cpp file
p45329
as(dp45330
g7
V505088
p45331
stp45332
a((dp45333
g2
(lp45334
VFirst of all, you must stop calling  in
p45335
aVI won't repeat the advice in detail but simply refer you to your previous question
p45336
aVAs for what's happening here, this is what is occurring:
p45337
aVYou create an icon handle,
p45338
aVYou then pass ownership of that icon to the  instance
p45339
aVYou free the icon instance which in turn deletes the icon handle
p45340
aVThe next time you call , the icon handle  refers to a handle that has been destroyed and so naturally your attempts to use that icon fail
p45341
aVThe easiest way to add this icon to the image list is in fact to use  and not bother creating a  instance
p45342
aVIt is possible to use a  and not have the handle destroyed when the  instance is destroyed
p45343
aVCall  to tell the  instance that it no longer owns the icon handle
p45344
as(dp45345
g7
V505088
p45346
stp45347
a((dp45348
g2
(lp45349
VYour problem is not related to your manifest
p45350
aVYou can verify that this is so by creating an empty application and adding your manifest as a custom manifest
p45351
aVError code 0xc000007b is what you get when a 64 bit process imports functions from a 32 bit DLL and this is the most plausible explanation for your woes
p45352
aVUse Dependency Walker to find out which imports are being resolved by 32 bit DLLs
p45353
as(dp45354
g7
V505088
p45355
stp45356
a((dp45357
g2
(lp45358
VThe memory for the string is owned by your Delphi code but your p/invoke code will result in the marshaller calling  on that memory
p45359
aVWhat you need to do is to tell the marshaller that it should not take responsibility for freeing the memory
p45360
aVThen use  to convert the returned value to a C# string
p45361
aVYou should also make sure that the calling conventions match by declaring the Delphi function to be :
p45362
aVAlthough it so happens that this calling convention mis-match doesn't matter for a function that has no parameters and a pointer sized return value
p45363
aVIn order for all this to work, the Delphi string variable  has to be a global variable so that its contents are valid after  returns
p45364
as(dp45365
g7
V505088
p45366
stp45367
a((dp45368
g2
(lp45369
VThere are (probably) no leaks in the code you show in the question
p45370
aVI say probably because an exception raised during the  could result in a leak
p45371
aVThe lifetime of the string list should be protected by a  block
p45372
aVThat said, I expect the exception swallow in  means that you don't leak the string list
p45373
aVYou say that perhaps thousands of threads are created
p45374
aVEach thread reserves memory for its stack, and the default stack size is 1MB
p45375
aVOnce you have thousands of 1MB stacks reserved, you can easily exhaust or fragment address space
p45376
aVI've seen problems due to cavalier creation of threads in the past
p45377
aVFor example I had a program that failed when it created and destroyed threads, with never more than 256 threads in existence
p45378
aVThis was on a 16 core machine with 4GB address space
p45379
aVYou probably have 2GB address space available
p45380
aVAlthough you state that no more than 50 threads are in existence at any one moment, I'm not sure how you can be sure of that
p45381
aVNot least, because you have set  to  and thereby surrendered control over the lifetime of your threads
p45382
aVMy guess is that your problems are related to the number of threads you create
p45383
aVOne thread per processor will suffice
p45384
aVRe-use your threads
p45385
aVIt's expensive to create and destroy a thread for a small task
p45386
aVIf this is not enough to solve your problems then you will need to show the code that manages thread lifetime
p45387
aVFinally, I wonder how much benefit you will extract from threading this app
p45388
aVIf it is IO bound then the threaded version may well be slower
p45389
as(dp45390
g7
V505088
p45391
stp45392
a((dp45393
g2
(lp45394
VI'm surprised that  doesn't do transparency
p45395
aVAre you really sure that is the case
p45396
aVAnyway, if that is so, I would combine the transparency support of  with the re-sampling ability of  to build a solution that way
p45397
aVKeep the original image in a  instance
p45398
aVWhenever you need to load it into the  component, for example when re-sizing, use  to perform an in-memory re-size and load that re-sized image
p45399
aVIn fact, if you are already painting the form's background yourself, why not paint the image yourself and simply do away with the image control
p45400
aVUpdate: Websearch reveals a simple way to make TImage32 transparent: http://graphics32
p45401
aVorg/news/newsgroups
p45402
aVphp
p45403
aVart_group=graphics32
p45404
aVgeneral&article;_id=9505
p45405
as(dp45406
g7
V505088
p45407
stp45408
a((dp45409
g2
(lp45410
VIn fact you don't need to do anything special for this to work
p45411
aVYou don't need to run multiple IDEs and you don't need to attach to processes
p45412
aVStart debugging your executable and simply step into the code in the DLLs
p45413
aVThe debugger takes care of it all for you
p45414
as(dp45415
g7
V505088
p45416
stp45417
a((dp45418
g2
(lp45419
VYou will need to use the position information that is included in the  message
p45420
aVUse that to determine whether or not there is a control present at that point
p45421
aVFor example you could use the  method
p45422
aVThis will allow dragging only if you have clicked on a point on the form at which there is no control present
p45423
aVYou may wish to use an alternative criteria, but use of  is the key idea
p45424
as(dp45425
g7
V505088
p45426
stp45427
a((dp45428
g2
(lp45429
VThe fundamental mistake here is not so much the use of , but rather that the code is using names at all
p45430
aVInstead of using names you should use the well-known SIDs
p45431
aVIn your case you need
p45432
as(dp45433
g7
V505088
p45434
stp45435
a((dp45436
g2
(lp45437
VThe key to this are the  and  interfaces
p45438
aVSupport for add-ins customising the options dialog was added to the Tools API in XE
p45439
aVYour add-in needs to supply an implementation of
p45440
aVYou register the add-in options by calling
p45441
aVIf you can't work out how to do this from the Tools API source code then I suggest you download the JCL source code to use as your template
p45442
aVUwe Schuster's blog article on the subject gives a general overview but I can't find any other articles that cover this topic
p45443
as(dp45444
g7
V505088
p45445
stp45446
a((dp45447
g2
(lp45448
VBy far the easiest way to press a button on another form is to send a  message rather than faking input
p45449
aVFaking input is a tricky business and can often fail to do what you desire
p45450
aVSend the  to the top level window
p45451
aVPass notification code  as  and the buttons ID as
p45452
aVYou can use  or  to obtain the handle of the top-level window
p45453
aVA program like Spy++ would enable you to find out the ID of the target button
p45454
as(dp45455
g7
V505088
p45456
stp45457
a((dp45458
g2
(lp45459
VThe  unit is automatically used by all other units in a Delphi program
p45460
aVSo you cannot use it again
p45461
aVSimply remove  from your  clause
p45462
aVThe documentation states:
p45463
aVThe  unit and the  unit are used automatically by every application and cannot be listed explicitly in the  clause
p45464
as(dp45465
g7
V505088
p45466
stp45467
a((dp45468
g2
(lp45469
VYou need to declare the function as receiving a
p45470
aVAnd then use  to hold the payload
p45471
aVRemember that  is an alias
p45472
aVIn pre-Unicode Delphi it is an alias to
p45473
aVIn Unicode Delphi it is an alias to
p45474
aVPre-Unicode Delphi is perfectly capable of calling any Unicode APIs, but must use  explicitly
p45475
as(dp45476
g7
V505088
p45477
stp45478
a((dp45479
g2
(lp45480
VExtract the number like this:
p45481
aVOnce you can extract the ID as an integer you can then write a compare function
p45482
aVLike this:
p45483
aVis an RTL function that returns -1, 0 or 1 depending on the relative values of the two operands
p45484
aVFeed these building blocks into  and your job is done
p45485
as(dp45486
g7
V505088
p45487
stp45488
a((dp45489
g2
(lp45490
VI guess that you have un-checked "Group results by file" on
p45491
aVthe Find In Files dialog
p45492
aVThis puts all the results into the output window with no hierarchy at all
p45493
aVIt's not that the tree is auto expanded, rather there is no tree at all
p45494
as(dp45495
g7
V505088
p45496
stp45497
a((dp45498
g2
(lp45499
VIn order to do this you need to work with each individual published property of  and you will need to use fully qualified names
p45500
aV,  etc
p45501
aVshould read the old property values into the newly named component
p45502
aVUpdate
p45503
aVYou ask how to read the Charset property
p45504
aVThis is complex because it can be written either as a textual identifier (see the  constant in Graphics
p45505
aVpas), or as a plain integer value
p45506
aVHere is some rapidly hacked together code that will read your Charset
p45507
as(dp45508
g7
V505088
p45509
stp45510
a((dp45511
g2
(lp45512
VNo, this is not a bug
p45513
aVYou are telling  that the first argument is an unsigned integer but in fact you passed a signed integer
p45514
aVThat signed integer is being interpreted as unsigned and the bit pattern for a signed value of -100 equates to an unsigned value of
p45515
aVIn fact your code is in error
p45516
aVThe format string defines a contract that the compiler cannot enforce because the arguments to  are weakly typed
p45517
aVIt is your responsibility to make sure that when you promise to pass an unsigned value that you do indeed pass an unsigned value
p45518
aVThe mistake in the code here is logically equivalent to passing a string or a floating point value which is an error which you will much more readily recognise
p45519
as(dp45520
g7
V505088
p45521
stp45522
a((dp45523
g2
(lp45524
VI can see the following:
p45525
aVYou almost certainly need to specify the  calling convention in your  attribute
p45526
aVAdd
p45527
aVI believe that  adds an extra level of indirection
p45528
aVBut you are passing a C#  which is a reference type
p45529
aVThat means you are passing a pointer to a pointer
p45530
aVThat's one level of indirection too many
p45531
aVFirst of all remove  altogether
p45532
aVThen your code should work
p45533
aVIf you switched to a struct rather than a class for  then you'd need to pass by  to get the indirection
p45534
aVI think I would have the code like this:
p45535
as(dp45536
g7
V505088
p45537
stp45538
a((dp45539
g2
(lp45540
VUnfortunately this is a limitation of the streaming system
p45541
aVThe documentation says (emphasis mine):
p45542
aVSome properties, although publishable, are not fully supported by the streaming system
p45543
aVThese include properties of record types, array properties of all publishable types, and properties of enumerated types that include anonymous values
p45544
aVIf you publish a property of this kind, the Object Inspector will not display it correctly, nor will the property's value be preserved when objects are streamed to disk
p45545
aVYou can't workaround that easily and would need to provide your own custom streaming
p45546
as(dp45547
g7
V505088
p45548
stp45549
a((dp45550
g2
(lp45551
VThreading is not the problem
p45552
aVYour function  runs instantly
p45553
aVTry inside the debugger
p45554
aVYou'll find it takes no time at all
p45555
aVProcessing a 2MB string is trivial on a modern computer
p45556
aVThat said, I would always recommend pre-allocating a return buffer when possible
p45557
aVAll the time is spent sending the resulting string back to the memo control
p45558
aVWhat is happening is that you are converting the #13 and #10 characters to #23 and #20
p45559
aVFor whatever reason, the memo control does not like that
p45560
aVIt seems to me that you are sending back a string with no line feeds at all and the memo's word wrap code performs badly
p45561
aVA quick and dirty way to see that this is so is to set  to  on your memo
p45562
aVThe important lesson here is that you must correctly identify the bottleneck before attempting to optimise
p45563
aVIt's an easy trap to fall into though, as my initial fumbled efforts to answer this question demonstrate
p45564
as(dp45565
g7
V505088
p45566
stp45567
a((dp45568
g2
(lp45569
VThe string stream documentation states:
p45570
aVThe Bytes property returns the buffer in which the data is stored
p45571
aVUse the Size property to find the actual amount of data in the buffer
p45572
aVPresumably the buffer has been allocated to hold more space than it actually needs
p45573
aVOnly the first Size bytes of the buffer contain valid content
p45574
aVAlso, the call to ss_1
p45575
aVRead is a little pointless since Length(sbytes_Read) does not change after the call to SetLength
p45576
aVAnd when reading from a stream you are to use ReadBuffer rather than Read
p45577
aVLikewise for WriteBuffer
p45578
as(dp45579
g7
V505088
p45580
stp45581
a((dp45582
g2
(lp45583
VThat happens because when the control is created, it registers itself into its owners list of owned components
p45584
aVAnd hence there are multiple references to the control
p45585
aVThe reference to the control in the form's class is indeed private
p45586
aVBut the reference to the control that the form holds in its Components list is public
p45587
aVLogically this is very similar to exposing the private variable through a property:
p45588
aVAlthough you don't directly expose the private field like this, the control does so indirectly by registering with the owning form
p45589
as(dp45590
g7
V505088
p45591
stp45592
a((dp45593
g2
(lp45594
VYou need to pack 8 pixels into a single byte for 1 bit color format
p45595
aVThe inner loop would look like this:
p45596
aVThe output looks like this:
p45597
aVUpdate
p45598
aVRob's comment prompted me to look at using  rather than the bit-twiddling above
p45599
aVAnd indeed it is perfectly possible
p45600
aVSince each call to assign  results in a call to the Windows API function , the bit-twiddling code would perform better
p45601
aVOf course, that would only ever matter if your bitmap creation code was a performance hot-spot
p45602
as(dp45603
g7
V505088
p45604
stp45605
a((dp45606
g2
(lp45607
VThe documentation for  specifies that you must initialize COM before calling the function
p45608
aVSince COM initialization is per-thread, you need to initialise COM in the thread
p45609
aVThat means calling  or  from the  method of the thread
p45610
as(dp45611
g7
V505088
p45612
stp45613
a((dp45614
g2
(lp45615
V means that dcc32
p45616
aVcfg is not loaded, neither from the compiler executable directory, nor from the project directory
p45617
aVThe rules for applying options specified in
p45618
aVdproj and
p45619
aVdof files are not affected
p45620
aVThose options are applied and any command line options take precedence
p45621
as(dp45622
g7
V505088
p45623
stp45624
a((dp45625
g2
(lp45626
VWrite a C function to return the pointer to the first element of the array, and the number of elements:
p45627
aVAnd then declare the p/invoke:
p45628
aVCall the function like this:
p45629
aVThis stuff gets tedious pretty quickly, at which point a C++/CLI wrapper begins to look like a more attractive option
p45630
as(dp45631
g7
V505088
p45632
stp45633
a((dp45634
g2
(lp45635
VThis is a known problem with the debugger
p45636
aVThe actual string is concatenated correctly, but the debugger displays it incorrectly
p45637
aVTry writing the string to a memo control to see that this is the case
p45638
aVMore recent versions of the Delphi debugger get this right
p45639
aVThey still have the same 4096 character limit, but the debugger will show  for characters beyond that limit
p45640
as(dp45641
g7
V505088
p45642
stp45643
a((dp45644
g2
(lp45645
VWhen I try adding a list view to the first tab ONLY it appears on ALL tabs
p45646
aVIn that case it sounds like the component you need is a
p45647
aVEach page of a page control has different content
p45648
aVTo add a new page to a , right-click the  object and choose New Page
p45649
aVThe documentation for  states:
p45650
aVTab set controls are commonly used to display tabbed pages within a dialog box
p45651
aVis provided for backward compatibility
p45652
aVUse  component in 32-bit Windows applications
p45653
aVSo, even if  was the right type of control for you, you should be using  anyway
p45654
aVThe choice between  and  is resolved as follows:
p45655
aVDo you want each page to show the same controls, albeit with possibly different data inside those controls
p45656
aVIf so then use
p45657
aVDo you want each page to show different controls
p45658
aVIf so then use
p45659
as(dp45660
g7
V505088
p45661
stp45662
a((dp45663
g2
(lp45664
VUse :
p45665
aVRetrieves date information (using SYSTEMTIME structures) that represents the high and low limits of a month calendar control's display
p45666
aVAfter the call,  is a system time record containing the first displayed day on the calendar, and  describes the last displayed day
p45667
aVFor a calendar like the one in your screenshot, this would return 25th June and 7th October
p45668
aVIf you passed  instead of  then you would get 1st July and 30th September
p45669
as(dp45670
g7
V505088
p45671
stp45672
a((dp45673
g2
(lp45674
VThis will do the job readily enough:
p45675
aVThe  parameter in  is so that the lifetime of the wrapper object can be managed
p45676
aVWithout something like that you would leak instances of
p45677
aVPass as , the component to which you are connecting the event
p45678
aVFor example:
p45679
aVSo, when the button is destroyed, the  will also be destroyed
p45680
aVThe wrapper object must live at least as long as the object to whose events it is associated
p45681
aVAnd so the choice of  as the owner is the natural and obvious one
p45682
as(dp45683
g7
V505088
p45684
stp45685
a((dp45686
g2
(lp45687
VWith the information provided it's pretty much impossible to say what is the cause of the problem
p45688
aVSo what you need is a means to gather more concrete information
p45689
aVI recommend using a debugging tool such as madExcept or EurekaLog
p45690
aVThese will produce stack traces at the point at which the error occurs and often that gives you enough information to work out the underlying root cause
p45691
as(dp45692
g7
V505088
p45693
stp45694
a((dp45695
g2
(lp45696
VFirst of all, that does not appear to be what is normally termed injection
p45697
aVThat's just a plain module load, albeit from memory rather than file
p45698
aVAs for how the DLL can import functions from the EXE, do it in exactly the same way as when the EXE imports from the DLL
p45699
aVUse  to list the functions that the EXE exports
p45700
aVObtain the module handle of the EXE by calling
p45701
aVPass that module handle to  to import functions
p45702
aVThe only difference from the more common EXE linking to DLL pattern is that you use  rather than
p45703
aVAnd that's because the EXE must already be loaded so you can simply ask for its module handle rather than asking for the module to be loaded
p45704
aVI would comment that it's pretty unusual to do things this way
p45705
aVNormally the EXE would call the DLL and pass whatever information was needed by the DLL
p45706
aVThat information could include callback functions, interfaces etc
p45707
aVthat would allow the DLL to query its host EXE
p45708
as(dp45709
g7
V505088
p45710
stp45711
a((dp45712
g2
(lp45713
VThe manifest indicates that the component has dependencies on MSVCRT and MFC, version 8, aka VS2008
p45714
aVYou will need to install those dependencies on any machine that needs this OCX
p45715
aVThis means installing the re-distributable packages that MS supply
p45716
aVI would expect that the OCX vendor details these dependencies and recommend consulting the OCX documentation
p45717
as(dp45718
g7
V505088
p45719
stp45720
a((dp45721
g2
(lp45722
VThe function you need is GetDriveType
p45723
as(dp45724
g7
V505088
p45725
stp45726
a((dp45727
g2
(lp45728
VBy far the easiest way to do this is to use
p45729
aVThis is the Delphi wrapper around the COM  type
p45730
aVDynamic allocation of the string payload is done using the shared COM allocator
p45731
aVSince the Delphi RTL manages that, it is transparent to you
p45732
aVIn the Delphi 7 code you declare your functions like this:
p45733
aVIn your calling code you declare the functions like this:
p45734
aVThe alternative to this approach is to use  or
p45735
aVNote that you cannot use  because that alias refers to different types depending on which version of Delphi you use
p45736
aVIn Delphi 7  is an alias for , and in XE2 it is an alias for
p45737
aVThe big downside of using , say, is that the caller needs to allocate the string which is returned from the DLL
p45738
aVBut typically the caller does not know how large that string needs to be
p45739
aVThere are a variety of solutions to the problem but the neatest approach is always to use a shared allocator
p45740
aVYou state that you do not want to rely on  and so the next most obvious common allocator is the COM allocator
p45741
aVAnd that's why  is attractive
p45742
as(dp45743
g7
V505088
p45744
stp45745
a((dp45746
g2
(lp45747
VThe documentation explains this very clearly:
p45748
aVMost parameters are either value parameters (the default) or variable
p45749
aV(var) parameters
p45750
aVValue parameters are passed by value, while variable
p45751
aVparameters are passed by reference
p45752
aVTo see what this means, consider
p45753
aVthe following functions:
p45754
aVThese functions return the same result, but only the second one -
p45755
aVDoubleByRef can change the value of a variable passed to it
p45756
aVSuppose
p45757
aVwe call the functions like this:
p45758
aVAfter this code executes, the variable I, which was passed to
p45759
aVDoubleByValue, has the same value we initially assigned to it
p45760
aVBut the
p45761
aVvariable V, which was passed to DoubleByRef, has a different value
p45762
aVA value parameter acts like a local variable that gets initialized to
p45763
aVthe value passed in the procedure or function call
p45764
aVIf you pass a
p45765
aVvariable as a value parameter, the procedure or function creates a
p45766
aVcopy of it; changes made to the copy have no effect on the original
p45767
aVvariable and are lost when program execution returns to the caller
p45768
aVA variable parameter, on the other hand, acts like a pointer rather
p45769
aVthan a copy
p45770
aVChanges made to the parameter within the body of a
p45771
aVfunction or procedure persist after program execution returns to the
p45772
aVcaller and the parameter name itself has gone out of scope
p45773
aVEven if
p45774
aVthe same variable is passed in two or more var parameters, no copies
p45775
aVare made
p45776
aVThis is illustrated in the following example:
p45777
aVAfter this code executes, the value of I is 3
p45778
aVI recommend that you add a link to the Delphi Language guide to your browser's bookmarks
p45779
as(dp45780
g7
V505088
p45781
stp45782
a((dp45783
g2
(lp45784
VThe documentation for  contains the answer:
p45785
aVThe conversion uses general number format with 15 significant digits
p45786
aVTo interpret that statement you need also to refer to the topic describing the  function, and specifically the text concerning the general number format (emphasis mine):
p45787
aVThe value is converted to the shortest possible decimal string using fixed or scientific format
p45788
aVThe number of significant digits in the resulting string is given by the precision specifier in the format string; a default precision of 15 is assumed if no precision specifier is present
p45789
aVTrailing zeros are removed from the resulting string, and a decimal point appears only if necessary
p45790
aVThe resulting string uses the fixed-point format if the number of digits to the left of the decimal point in the value is less than or equal to the specified precision, and if the value is greater than or equal to 0
p45791
aV00001
p45792
aVOtherwise the resulting string uses scientific format
p45793
aVUnfortunately the documentation is in fact in error there
p45794
aVInstead of  it should read
p45795
aVThat this is illustrated by this program:
p45796
aVFor your examples,  is less than  and so is formatted using scientific notation
p45797
aVBut  is greater than  and so gets formatted using fixed notation
p45798
aVIf you want your output always to use scientific notation then use  with the  format string
p45799
aVQC#107388
p45800
as(dp45801
g7
V505088
p45802
stp45803
a((dp45804
g2
(lp45805
VCreate your new action class by deriving from
p45806
aVFor example:
p45807
aVAnd then you can register it from your design time package's  procedure by calling
p45808
aVThen from the action list editor, select  and your action will appear in the tree view of available actions
p45809
aVIn the comments you seem to imply that you want to modify  to have a new property
p45810
aVThat would require modification to the VCL itself and that's beyond your control
p45811
aVNo doubt the VCL could be hacked to achieve what you ask for but that's not a good idea
p45812
as(dp45813
g7
V505088
p45814
stp45815
a((dp45816
g2
(lp45817
VThe DLL is passed a pointer to the buffer
p45818
aVIt is perfectly possible for the DLL to modify that buffer
p45819
aVThe DLL can modify any of the 4 wide characters that your code passes to it
p45820
aVIt could also modify the fifth character, the null-terminator
p45821
aVHowever, the DLL cannot create a new buffer and have the calling code see that new buffer
p45822
as(dp45823
g7
V505088
p45824
stp45825
a((dp45826
g2
(lp45827
VI cannot answer question 1
p45828
aVHowever, I find it hard to imagine that the use of the word must could mean that the rule was optional
p45829
aVAs for question 2, you would need support from the compiler/linker
p45830
aVYou cannot reasonably expect to back fit this with a PE editing post-link tool
p45831
aVConsider the following code:
p45832
aVThe compiler emits the following:
p45833
aVNow, the real exception handler is , implemented in
p45834
aVBut, the address pushed onto the stack is , an address local to the code containing the  block
p45835
aVThis means that in order to create a SafeSEH PE section you would need to locate each and every  in your code
p45836
aVWhilst that is obviously feasible, I don't think it is tractable
p45837
aVI rather imagined that the SEH exception handlers for the x86 compiler would be just the  functions declared in
p45838
aVIn which case it would be easy enough to add a PE section listing just those functions as a post-link step
p45839
aVHowever, since every single  has its own local exception handler, I now believe that only the compiler author can realistically hope to add the SafeSEH PE section
p45840
aVThere is, so far as I can see, no QC report that requests  support for the x86 Windows compiler
p45841
aVI suggest that you log a QC report, and an official support case
p45842
aVUpdate: Well done to @haimg for succeeding where I failed and managing to locate a QC report: QC#106781
p45843
as(dp45844
g7
V505088
p45845
stp45846
a((dp45847
g2
(lp45848
VYou cannot do this
p45849
aVThe Secure Attention Sequence (the official Windows name for CTRL+ALT+DEL) is handled in kernel mode and it would be a humungous security hole if user mode apps were able to change what happens when the user sends the SAS
p45850
as(dp45851
g7
V505088
p45852
stp45853
a((dp45854
g2
(lp45855
VWhere you write
p45856
aVyou need to write
p45857
aVwhich is precisely what the second error message states
p45858
aVLooking at your code, returning a  from the Delphi DLL the way that you do is not compatible with your P/invokes
p45859
aVThe P/invoke marshaller is assuming that your return values were allocated with  and will call  on the pointer that you return
p45860
aVThat's going to lead to some problems somewhere down the line
p45861
aVI think you'll need to tackle that issue at some point but since it's not the subject of this question, I won't attempt to solve the problem here
p45862
as(dp45863
g7
V505088
p45864
stp45865
a((dp45866
g2
(lp45867
VThere's no mistake here
p45868
aVIn Windows APIs that are subject to limits on length, the maximum length of a name is (usually)
p45869
aVIt doesn't matter whether the name is a fully specified absolute path, a relative path, or just a file name, the length limit is still
p45870
aVIt may well be that the underlying file system has different limits
p45871
aVIt's perfectly plausible that the native file system limit could be less than 260
p45872
aVBut if the API declares a limit of 260 characters, then that's the limit when using that particular API
p45873
aVIf ever you think that the MSDN library is incorrect, it's easy enough to check
p45874
aVTake a look at the definition in the Windows header file and compare it with that given in the MSDN library
p45875
aVInvariably you will find that the MSDN library is accurate
p45876
as(dp45877
g7
V505088
p45878
stp45879
a((dp45880
g2
(lp45881
VHere are the problems that I can see with your code:
p45882
aVThe return value of  is a signed 32 bit integer
p45883
aVIt's declared as
p45884
aVA negative value means an error occurred and that's what's happening to you
p45885
aVOnly you don't see the negative value because you've stuffed the value into an unsigned integer
p45886
aVUnfortunately XE fails to declare
p45887
aVSo change your code to use  instead
p45888
aVYou don't check for errors when  returns
p45889
aVIf an error occurs, a negative value is returned
p45890
aVMake sure you check for that
p45891
aVYou are passing random garbage in the 4th and 5th parameters to
p45892
aVI suspect that you can pass  for both parameters the first time that you call
p45893
aVYou can certainly pass  for the 5th parameter both times you call the function since you never set
p45894
aVWhen errors occur you set  to , but you continue executing the rest of the function
p45895
aVDon't do that
p45896
aVCall exit to break out of the function
p45897
aVAssigning to  does not terminate execution in the way that  does in C-like languages does
p45898
aVUse a  block to ensure that you call
p45899
aVThat allows you to write  once only
p45900
as(dp45901
g7
V505088
p45902
stp45903
a((dp45904
g2
(lp45905
VThe line that calculates  is simply calculating the number of bytes between the pointers  and
p45906
aVAssuming you are using the same variable names a Delphi version of that code would be like this:
p45907
aVHowever, since you are using an older version of Delphi, the above code will not compile
p45908
aVOlder Delphi versions (pre Delphi 2009) don't permit pointer arithmetic on types other than
p45909
aVSo you will need to write it like this:
p45910
aVI suspect that what is confusing you in the C code is
p45911
aVThat is the C syntax for a type cast
p45912
aVAs an aside, it is a mistake to use  records for OpenCV structs
p45913
aVIf you take a look at the C header files you will see that these structs are not packed
p45914
aVThis is benign in the case of  since it has no padding, but you will get caught out somewhere down the line if you get into the bad habit of packing structs that should not be packed
p45915
as(dp45916
g7
V505088
p45917
stp45918
a((dp45919
g2
(lp45920
VDoesn't closing the application frees all objects directly without calling
p45921
aVNo
p45922
aVDelphi class instances are not garbage collected and so they need to be manually destroyed
p45923
aVHowever, if you are talking about an executable process, then it can be perfectly acceptable not to dispose of certain objects since the operating system will re-claim all resources owned by a process when that process terminates
p45924
aVSo even though Delphi destructors don't run, the OS tidies everything up when a process terminates
p45925
aVIt is not possible for a process to leak any system resources once it has terminated
p45926
aVNote that if the unit is included in a DLL or a package then failure to destroy all objects at finalization time will lead to memory leaks, if that DLL is repeatedly loaded and unloaded into a single process
p45927
aVIf you know that your code only ever runs in an executable, then feel at liberty not to  objects at finalization time
p45928
aVBe aware that if you are using a memory leak detection tool then doing so will result in your intentionally leaked object being treated as a memory leak
p45929
aVDeal with that by calling
p45930
aVOne final point to make is that an object's destructor sometimes does more than free memory
p45931
aVSometimes it can save values to a settings file, or the registry, for example
p45932
aVNaturally you would not want to omit running the destructor for such an object
p45933
as(dp45934
g7
V505088
p45935
stp45936
a((dp45937
g2
(lp45938
VYou don't get any indication which column has been moved
p45939
aVWhat does happen is that the items in the list view's  list are re-arranged to match the new order of the columns in the list view
p45940
aVSo long as you can identify each column uniquely, and not by using the column's position in the list, then you can infer the order of the columns
p45941
aVOne possible approach is to give each column a different  value
p45942
aVThen you can do something like this:
p45943
aVNaturally you'll want to do something more useful than this, but I trust that it gets the idea across
p45944
as(dp45945
g7
V505088
p45946
stp45947
a((dp45948
g2
(lp45949
VIf you want to pass classes across module boundaries then you need to link to the RTL/VCL with runtime packages
p45950
aVThat's the only way to make sure that the  class in your DLL is the exact same one as in your EXE
p45951
aVThat is the fundamental problem with your current approach
p45952
aVOn the other hand, if you are already linking to the RTL with runtime packages, then you are fine
p45953
aVIf you don't want to use runtime packages then you need to redesign your interface completely
p45954
aVYou would need to stop passing classes across the module boundary
p45955
aVYou can use interfaces, but not classes
p45956
aVAnd you would need to take control of the memory allocation to ensure that memory is always deallocated in the module that allocated it
p45957
aVOr start using
p45958
as(dp45959
g7
V505088
p45960
stp45961
a((dp45962
g2
(lp45963
VThis is one of a great many generics bugs in Delphi 2010
p45964
aVYour code compiles in XE2
p45965
aVYour options are to look for a workaround that works in 2010, or to upgrade
p45966
aVDelphi XE and XE2 do include a great many fixes for generics compiler bugs and so if you are serious about making use of generics, Delphi 2010 is not a great choice
p45967
as(dp45968
g7
V505088
p45969
stp45970
a((dp45971
g2
(lp45972
VIf you had a modern Delphi, then that code would compile and work
p45973
aVThe  in modern Delphi versions takes advantage of operator overloading to overload the equality operator
p45974
aVYou simply cannot make that syntax work in Delphi 7 since there is no built in equality operator for Delphi records
p45975
aVWithout that help from the compiler you need a helper function
p45976
aVYou can write your own:
p45977
aVAlthough, as @Sertac points out, there's little need to write your own  when you can use the Windows API function of the same name
p45978
as(dp45979
g7
V505088
p45980
stp45981
a((dp45982
g2
(lp45983
VLike this:
p45984
aVAnd also remove the first line of code from your function that pre-allocates
p45985
aVIf you'd rather allocate the buffer once (as per the code in the question) then you can code it like this:
p45986
aVBut that's a buffer overrun waiting to happen
p45987
as(dp45988
g7
V505088
p45989
stp45990
a((dp45991
g2
(lp45992
VSending a key press to a read only memo won't work
p45993
aVThe key press will be ignored because the memo is read only
p45994
aVTo delete the final character of a memo in an efficient way, that is without replacing the entire contents, you can use  and
p45995
aVOr if you prefer a pure VCL version which wraps up these Windows messages:
p45996
aVThe latter probably sends a few more Windows messages, but is much easier to read
p45997
aVI would prefer the latter option
p45998
aVOne possible problem I can see with this is that it may not do what you want with line breaks
p45999
aVSince a Windows line break is two characters (CR+LF), you would need to delete two characters if the last character in the memo was LF
p46000
aVTo handle that you can probably do it like this:
p46001
as(dp46002
g7
V505088
p46003
stp46004
a((dp46005
g2
(lp46006
VRather than do all this hard work yourself, I'd just use :
p46007
aVFor what it is worth, the problem with your code is that it doesn't ever call
p46008
aVAnd so the directories are never getting emptied, the calls to  fail and so on
p46009
aVThe lack of error checking in your code doesn't really help, but adding code to delete files would get that code in half-decent shape
p46010
aVYou also need to take care with the recursion
p46011
aVYou must make sure that all the children are deleted first, and then the parent container
p46012
aVThat takes a certain degree of skill to get right
p46013
aVThe basic approach is like this:
p46014
aVI've omitted error checking for the sake of clarity, but you should check the return values of  and
p46015
as(dp46016
g7
V505088
p46017
stp46018
a((dp46019
g2
(lp46020
VCode compiled by Microsoft C/C++ cannot call methods directly on a Delphi object
p46021
aVYou would have to wrap the methods up and present, to the C++ code, an , for example
p46022
aVCode compiled by C++ Builder can call methods directly on a Delphi object
p46023
aVIn general, wrapping up a Delphi class and presenting it as an  is not completely trivial
p46024
aVOne reason why you can't just expose the raw methods via an interface is that the Delphi methods using the  calling convention which is proprietary to Embarcadero compilers
p46025
aVYou'd need to use a calling convention that is understood by the Microsoft compiler, e
p46026
ag217
aVAnother complication comes with exceptions
p46027
aVYou would need to make sure that your interface methods did not throw exceptions since your C++ code can't be expected to catch them
p46028
aVOne option would be to use Delphi's  calling convention
p46029
aVThe  calling convention is  but with an added twist that converts exceptions into  values
p46030
aVAll rather straight forward in concept, but probably requiring a certain amount of tedious boilerplate code
p46031
aVThankfully, in the case of , you can use  to expose the Delphi stream as a COM
p46032
aVIn fact, the source code for this small class shows how to handle the issues I describe above
p46033
as(dp46034
g7
V505088
p46035
stp46036
a((dp46037
g2
(lp46038
VYou can read this out of the registry
p46039
aVLook in this key:
p46040
aVand read the string value named:
p46041
aVThis setting lives in the 32 bit view of the registry, so if you ever build 64 bit code make sure you include the  flag
p46042
as(dp46043
g7
V505088
p46044
stp46045
a((dp46046
g2
(lp46047
VYou can simply cast it to :
p46048
aVFor example:
p46049
aVoutputs
p46050
as(dp46051
g7
V505088
p46052
stp46053
a((dp46054
g2
(lp46055
VThere is no built in method that will convert a generic record into binary form (or vice versa)
p46056
aVYou will need to either:
p46057
aVWrite your own dedicated code to do so, or
p46058
aVFind and use an object persistence library
p46059
as(dp46060
g7
V505088
p46061
stp46062
a((dp46063
g2
(lp46064
VYour control is derived from , and  calls  in response to the  message
p46065
aVSo,  will not be called unless the control's window handle has been created
p46066
aVThe  method is not called when you assign , or indeed , because the window handle has not yet been allocated
p46067
aVWhen you evaluate the  property, that results in the window handle being created, and then  is called
p46068
aVThat's because  calls  which looks like this:
p46069
aVAnd it's the evalutation of the  property that forces the window handle into existence
p46070
as(dp46071
g7
V505088
p46072
stp46073
a((dp46074
g2
(lp46075
VIf you want to remove the form from the taskbar then you need to hide it rather than minimize it
p46076
aVSimply call  when you have finished fading out the form
p46077
aVWith regards removing the taskbar button, it doesn't actually matter how you configure
p46078
aVSo, what you should do is set  as you prefer for the application in its normal mode of operation
p46079
aVThat property is not pertinent to whether or not the taskbar button shows
p46080
as(dp46081
g7
V505088
p46082
stp46083
a((dp46084
g2
(lp46085
VSince Delphi does not support multiple inheritance of classes, you are pushed towards solutions like this:
p46086
aVIn  you would like to use the  keyword, but you cannot because these two classes do not share the necessary common ancestor
p46087
aVUpdate: @LU RD shows how to do it all with class helpers
p46088
aVPersonally I'm a little allergic to class helpers
p46089
aVAnd of course, there may be other reasons why you don't wish to use helpers
p46090
aVFor example, if you are using a legacy version of Delphi then they don't exist
p46091
as(dp46092
g7
V505088
p46093
stp46094
a((dp46095
g2
(lp46096
VThe only Delphi compiler is the Delphi compiler
p46097
aVIt's not free
p46098
aVThere is the Free Pascal Compiler, FPC
p46099
aVThat is, as its name suggests, free
p46100
aVFPC can compile most Delphi code but be aware that many Delphi libraries, e
p46101
ag217
aVthe VCL, are not available for FPC
p46102
as(dp46103
g7
V505088
p46104
stp46105
a((dp46106
g2
(lp46107
VYour option 3 is the correct way to do this
p46108
aVThe p/invoke marshaller will map a C# string to a pointer to null terminated character array, i
p46109
ag192
aVPChar
p46110
aVThe default calling convention is stdcall, and the default character set is Ansi and so you don't need to specify those
p46111
aVYour option 1 works also but is unnecessarily verbose since you are just re-stating the default marshalling
p46112
aVOption 2 could work also but you'd just be creating extra work for yourself
p46113
aVYou'd have the responsibility of freeing the IntPtr values once the native function call returned
p46114
as(dp46115
g7
V505088
p46116
stp46117
a((dp46118
g2
(lp46119
VIt appears that you have a mismatch between Unicode and Ansi text
p46120
aVYou are using UI controls that use Unicode, but are compiling in an Ansi Delphi
p46121
aVSo you are passing an array of 16 bit characters to a function that expects 8 bit encoded text
p46122
aVWhich explains the error code that is reported
p46123
aVIt's possible that the code worked for the original developers because they used a modern Unicode Delphi
p46124
aVIf that is the case then your best course of action is to compile the code with the version of Delphi in which it was originally compiled
p46125
aVIf you must use an Ansi Delphi then you can fix your code by passing
p46126
aVto CreateProcess
p46127
aVThat will have the effect of converting from Unicode to Ansi
p46128
aVYou could alternatively call the Unicode version of CreateProcess like this:
p46129
as(dp46130
g7
V505088
p46131
stp46132
a((dp46133
g2
(lp46134
VAssuming that you are concerned about re-entrancy from the same thread, then blocking the re-entrant call will lead to a classic deadlock
p46135
aVIf this is your scenario then you need to do one of the following:
p46136
aVMake sure that re-entrant calls cannot happen, or
p46137
aVDetect a re-entrant call and postpone it by adding to a queue for later processing, or
p46138
aVDetect a re-entrant call and simply ignore it
p46139
aVQuite possibly none of these options appeals to you
p46140
aVIf you are concerned about simultaneous calls from different threads then you can use a lock of some sort
p46141
aVFor example on Windows you would typically use a critical section
p46142
as(dp46143
g7
V505088
p46144
stp46145
a((dp46146
g2
(lp46147
VI think you are being rather defeatist
p46148
aVFind and fix the bugs
p46149
aVIt might be tricky, but it's the right solution
p46150
aVKilling threads whose behviour you don't understand is never the solution
p46151
aVIf you start killing threads you'll likely make things worse
p46152
aVThat can lead to other runtime errors, deadlock and so on
p46153
aVOnce you start killing threads you've lost control
p46154
aVNow, it would be safe to kill the process (rather than a specific thread) and rely on a watchdog service to restart the process
p46155
aVBut that's a really dire solution
p46156
aVYou should certainly use a tool like madExcept, EurekaLog etc
p46157
aVto debug unexpected exceptions
p46158
aVI see you are already using EurekaLog - that's good
p46159
aVDeadlocks (it sounds like you have deadlock) can be more tricky to chase down
p46160
aVOne good way to debug a deadlock is to get your client to produce a crash dump (e
p46161
ag217
aVfrom Process Explorer)
p46162
aVThen debug it in WinDbg using map2dbg to produce symbolic stack traces
p46163
aVThat will tell you which threads are blocking and that reveals the deadlock
p46164
aVAnd then fix the bugs
p46165
aVFor more details on this deadlock debugging technique see here: http://capnbry
p46166
aVnet/blog/
p46167
aVp=18
p46168
aVI'm not familiar with EurekaLog since I use madExcept, but I would expect EurekaLog has a facility to allow generation of thread stack traces for a hung process
p46169
aVIf so then that would most likely be the best approach for you
p46170
as(dp46171
g7
V505088
p46172
stp46173
a((dp46174
g2
(lp46175
VThat is an Access Violation exception
p46176
aVIt is raised when your program attempts to access an invalid memory address
p46177
aVThe most obvious cause is that you are accessing memory that has been deallocated and returned to the system
p46178
aVI recommend that you execute under the debugger and let the debugger break at the code that raises the exception
p46179
aVThis will tell you what object you are referencing and then you've got to work out why you are referencing it after the object has been destroyed
p46180
aVHaving said that, the instruction pointer value of 0x011c34a6 doesn't look like it's in your exe which will be based at 0x00400000
p46181
aVSo perhaps the exception is raised in a DLL which may make the fault a little more tricky to debug
p46182
aVI recommend that you use the FastMM memory manager with full debug options rather than the default Borland MM from Delphi 7
p46183
aVFastMM has lots of debugging tools to help locate and diagnose faults such as this
p46184
aVIt may help track down this fault, but if not it will for sure help you find other faults in the future
p46185
as(dp46186
g7
V505088
p46187
stp46188
a((dp46189
g2
(lp46190
VThe MDI system works by having a single window that is the parent of all the MDI child windows, known as the client window
p46191
aVThat client window is, in turn, a child of the MDI form
p46192
aVThe VCL implementation of MDI creates the child window for you
p46193
aVYou can gain access to its window handle through the ClientHandle
p46194
aVSince the client window is a child of the main form, and parents all the MDI forms, the only solution for you is to make this panel part of the client window
p46195
aVYou could take control of the painting of the client window
p46196
aVYou can do this by replacing the window proc of the client window with one of your own
p46197
aVYou'll also need to handle button clicks etc
p46198
aVBut that's pretty messy
p46199
aVNow, perhaps you could make your panel a child of the client window
p46200
aVBut I'm pretty sure that will screw up your MDI, which indeed you confirm to be the case
p46201
as(dp46202
g7
V505088
p46203
stp46204
a((dp46205
g2
(lp46206
VUsing Indy you can simply do
p46207
aVYou really don't want to spin up a TWebBrowser for a simple HTTP GET
p46208
as(dp46209
g7
V505088
p46210
stp46211
a((dp46212
g2
(lp46213
VNo, the auto increment of the build number is an IDE feature
p46214
aVYou will likely need to script your own auto increment facility using an appropriate scripting language
p46215
aVIf you wanted to use your own command line auto increment alongside the IDE's equivalent, here's what you'd need to do:
p46216
aVGet your script to read the
p46217
aVres file that is managed by the IDE
p46218
aVIncrement the build number
p46219
aVRe-create the
p46220
aVres file
p46221
aVBuild the project
p46222
aVTo make this work I think you'd need to reverse engineer what's in the IDE generated
p46223
aVres file
p46224
aVBut that's pretty easy
p46225
aVAny decent resource editing tool will help you do that
p46226
as(dp46227
g7
V505088
p46228
stp46229
a((dp46230
g2
(lp46231
VYou will always have dependencies in your code
p46232
aVWell, as long as you have code re-use, you will have dependencies
p46233
aVSince you are testing a legacy system, wholesale re-structuring is out of the question
p46234
aVSo you simply need to accept the dependencies
p46235
aVThe most convenient and practical approach is to have a single unit tests project
p46236
aVThat project contains all your unit tests
p46237
aVUse the facilities of your runner program to run only specific tests at any one time
p46238
aVThis leads to your project have the same list of units in its
p46239
aVdpr file as the main project
p46240
aVThat's what you have currently tried and it's the right approach
p46241
aVYour problem sounds like you are sharing the DCU directory (unit output directory) between the main project and the unit tests project
p46242
aVAnd you have different compiler options for the two projects
p46243
aVThat's the most likely explanation for the error you report
p46244
aVThere are a couple of obvious solutions:
p46245
aVAlign the compiler options for both projects
p46246
aVThen they can share DCUs
p46247
aVHave separate DCU directories for the two projects
p46248
aVOption 2 is much more robust and is best practise
p46249
aVHowever, you should try to understand why the compiler options differ
p46250
aVIt's quite possible that your compiler options in the new unit tests project will need to be changed so that the units under test compile and function as desired
p46251
aVIn modern Delphi I would use option sets to ensure consistency of compiler options
p46252
aVNow, there may be other technical problems that you are facing, and my explanation of the error may not be quite right since I'm having to guess a little
p46253
aVBut the bottom line is that having the same list of units in your
p46254
aVdpr files is the way to go
p46255
as(dp46256
g7
V505088
p46257
stp46258
a((dp46259
g2
(lp46260
VThat's a known bug in Delphi 2010
p46261
aVYou can work around it by adding a panel that is a child of the outermost tabsheet, and is the parent of the inner page control
p46262
aVI've no idea why this fixes the problem
p46263
aVI only discovered the workaround myself because I noticed that in my app, the only nested tab/page controls that rendered properly were those with a panel suitably interposed
p46264
aVIf I recall correctly, the defect is not present in the latest Delphi versions
p46265
as(dp46266
g7
V505088
p46267
stp46268
a((dp46269
g2
(lp46270
VHow can I create one System
p46271
aVDrawing
p46272
aVIcon from multiple
p46273
aVBitmaps
p46274
aVYou can't
p46275
aVSystem
p46276
aVDrawing
p46277
aVIcon only contains one image
p46278
ag23719
aVico file or an icon group resource can contain multiple images
p46279
aVBut when you load into System
p46280
aVDrawing
p46281
aVIcon you select just one of those images
p46282
as(dp46283
g7
V505088
p46284
stp46285
a((dp46286
g2
(lp46287
Vcompiles because a class can access its own protected members
p46288
as(dp46289
g7
V505088
p46290
stp46291
a((dp46292
g2
(lp46293
VSwitching between debug and release targets in your executable will not lead to any referenced runtime packages being rebuilt
p46294
aVPackages have their own options that are independent from projects that use them
p46295
aVThat's the only possible design choice
p46296
aVJust imagine if you had a package that was used by two other projects, A and B, say
p46297
aVNow, A is built for debug, but B is built for release
p46298
aVThe package can't be built for both at the same time
p46299
aVRebuild as needed" means that packages will be re-built if the latest build is out of date with respect to the package's source
p46300
aVRegarding the "experiment" in your question update, it's most likely that your exe is not linking at runtime to the package
p46301
aVInstead the
p46302
aVpas file is being directly compiled and linked as part of your exe project
p46303
as(dp46304
g7
V505088
p46305
stp46306
a((dp46307
g2
(lp46308
VIt's certainly easiest to load the entire file into memory
p46309
aVProvided that your file is small enough then you can do it like this:
p46310
aVI assume that when you say
p46311
aVif any line has Hello in it
p46312
aVthat you are looking for lines that contain the search string rather than lines that equal the search string
p46313
aVIn a comment you ask:
p46314
aVOk can I then ask if it would be possible to ask on how to
p46315
aVdelete a string that is typed from an edit box out of a file
p46316
aVSo
p46317
aVyou enter a string into an edit box then it searches the file
p46318
aVfor it and deletes that line
p46319
aVThat's an easy enough variation of the above:
p46320
aVThis function deletes all lines that contain the search string
p46321
aVIf you only want to delete the first such line, then break out of the for loop after the call to Delete
p46322
aVThe loop variable is descending to allow the loop to modify the list
p46323
aVIf you want to use a different test, say equality rather than contains, then simply modify the if statement
p46324
as(dp46325
g7
V505088
p46326
stp46327
a((dp46328
g2
(lp46329
VSimply subtract the integer part from the floating point value:
p46330
as(dp46331
g7
V505088
p46332
stp46333
a((dp46334
g2
(lp46335
VBy using Move and subverting the dynamic array reference counting mechanism you are simply setting a trap for yourself
p46336
aVI would strongly recommend that you stick within the standard mechanisms, and let the compiler worry about the details
p46337
aVIt will get them right every time
p46338
as(dp46339
g7
V505088
p46340
stp46341
a((dp46342
g2
(lp46343
VNo, you can't use  to print from a Delphi stream
p46344
aVThe call to  will result in a different process performing the printing operation
p46345
aVAnd that different process cannot see your Delphi stream
p46346
aVA couple of options spring to mind:
p46347
aVSave the stream to a temporary file, and print that using
p46348
aVPrint the text directly from Delphi
p46349
aVOne quick and dirty method would be to add the text to a  and call its  method
p46350
aVAndreas Rejbrand has more details here
p46351
as(dp46352
g7
V505088
p46353
stp46354
a((dp46355
g2
(lp46356
VXP does not support per-application volume control
p46357
aVThat capability was added in Vista
p46358
aVSo what you are attempting to do cannot be done in XP by fair means
p46359
aVThere is software called IndieVolume that retro fits per-app volume control to XP
p46360
aVI can only imagine it does so by means of low-level hacking, DLL injection and so on
p46361
aVI doubt that's really an option for you
p46362
as(dp46363
g7
V505088
p46364
stp46365
a((dp46366
g2
(lp46367
VWhen the window is updated during a drag operation, then the OS has to show something in the extended window region
p46368
aVIf you can't provide anything then it will show the background until you do
p46369
aVSince you didn't specify any background you get blackness
p46370
aVSurely you ought to be specifying a background brush
p46371
aVSimply adding the following to your code makes the behaviour more palatable:
p46372
aVHowever, if you take as long as 320ms to respond to a  then you ruin the resize UI for the user
p46373
aVIt becomes jerky and unresponsive
p46374
aVThe system is designed around the assumption that you can paint the window quickly enough for dragging to feel smooth
p46375
aVThe right way to fix your problem is to make  run in a reasonable time
p46376
aVIf you really can't achieve quick enough painting for smooth dragging then I suggest a couple of alternatives:
p46377
aVDisable window updates during dragging
p46378
aVI'm sure this can be done for individual windows, but I can't remember how to do it off the top of my head
p46379
aVPaint something fake whilst a resize/drag is active, and postpone the real painting until when the resize/drag has completed
p46380
aVListening for  and  are the keys to this
p46381
aVThis MSDN article illustrates how to do that: http://support
p46382
aVmicrosoft
p46383
aVcom/kb/121541
p46384
as(dp46385
g7
V505088
p46386
stp46387
a((dp46388
g2
(lp46389
VThe fundamental error here is that you omitted  from the
p46390
aVAdd that and all will be well
p46391
aVYou don't need to set  at all
p46392
aVThe fact that  begins with  determines the class
p46393
aVRather than calling  yourself, you may as well the  to do it for you:
p46394
aVOr even:
p46395
as(dp46396
g7
V505088
p46397
stp46398
a((dp46399
g2
(lp46400
VHere is some code that produces the output you desire
p46401
aVYou'd need to work it around a bit for your needs, but the concept expressed in this recursive solution is the important thing:
p46402
aVOutput:
p46403
aVIf you change the definition of , for example to  then you will see the 24 possible permutations
p46404
as(dp46405
g7
V505088
p46406
stp46407
a((dp46408
g2
(lp46409
VYou could add an  handler that re-raised the exception:
p46410
aVI'm not sure why you would want to do this at all though
p46411
aVIt's more normal to use a tool like madExcept or EurekaLog to show an error dialog that yields much more helpful information than the system dialog
p46412
as(dp46413
g7
V505088
p46414
stp46415
a((dp46416
g2
(lp46417
VUse the  command:
p46418
aVThe  switch is used for shutdown,  for restart
p46419
aVThe full usage for shutdown on my Windows 7 box:
p46420
as(dp46421
g7
V505088
p46422
stp46423
a((dp46424
g2
(lp46425
g5537
aVDo the above Delphi declarations look correct
p46426
aVThey are correct, with one exception
p46427
aVThe two callback function types have the incorrect calling convention
p46428
aVIn the C code the callback function types are declared with CDR_EXPORT which in turn is defined as CALLBACK
p46429
aVThat in turn is defined in the Windows header files and __stdcall
p46430
aVSo your Delphi function types need to match
p46431
aVThis is the only error in the translation
p46432
ag25125
aVShould I be including WIN32 when compiling the
p46433
aVprogram
p46434
aVI guess you mean, defining rather than including
p46435
aVThere's nothing to do here
p46436
aVThe WIN32 conditional is defined by the Delphi 6 compiler
p46437
aVYou don't need to define it
p46438
aVI expect that IFDEF is there because Dr
p46439
aVBob's converter originally targeted 16 bit Delphi 1
p46440
aVAnd on 16 bit Windows, the default Windows calling convention was the long-forgotten pascal calling convention
p46441
aVThat IFDEF is now a relic and you can remove it
p46442
aVBut keep the stdcall, naturally
p46443
aVI've never been terribly happy with automatic header translators
p46444
aVPersonally I think you might be better doing it by hand
p46445
as(dp46446
g7
V505088
p46447
stp46448
a((dp46449
g2
(lp46450
VAll the records in that  unit are declared to be packed
p46451
aVThe Windows API header files do not use packed structs
p46452
aVFix it by removing all the  modifiers
p46453
aVIf you make that change your function succeeds in both 32 and 64 bit targets
p46454
aVFor what it is worth, your code is actually failing on the call to
p46455
aVWith packed records  returns 40
p46456
aVThe correct size, is 48, and that's the value you get when you remove the  modifier
p46457
aVThe easiest way to debug this kind of thing is to have a copy of Visual Studio installed so that you can compare equivalent C++ code
p46458
aVI presume that the incorrect record declarations is the primary problem with that unit
p46459
aVThere may very be others, but that's the one that sticks out like a sore thumb
p46460
as(dp46461
g7
V505088
p46462
stp46463
a((dp46464
g2
(lp46465
VThere's always a foreground window
p46466
aVWell, there are instants when the foreground window is being changed when  returns , but those instants pass pretty quickly
p46467
aVI expect that  is the window handle for one of windows used to show the desktop
p46468
aVUse Spy++ or similar to work out which window it is
p46469
aVMy guess is that the state you are trying to detect is when the shell window is the foreground window
p46470
as(dp46471
g7
V505088
p46472
stp46473
a((dp46474
g2
(lp46475
VThis is the code that I use to perform this task
p46476
aVNote that I am assuming that the original icon uses 32 bit colour, with alpha channel
p46477
aVThat's reasonable in the settings that I use this code, but I can't be sure whether or not it's reasonable for you
p46478
as(dp46479
g7
V505088
p46480
stp46481
a((dp46482
g2
(lp46483
VLoad the DLL project
p46484
aVModify run parameters (Run | Parameters) to specify host app as regsvr32
p46485
aVNote that you may need to use C:\u005cWindows\u005csysnative path to defeat the 32 bit file system redirector
p46486
aVInclude path to DLL as command line arguments
p46487
aVPerhaps enable Debug DCUs, in case the error is raised in the Delphi COM self-registration code
p46488
aVThen debug the DLL like any other DLL
p46489
aVRuntime error 216 is an access violation
p46490
as(dp46491
g7
V505088
p46492
stp46493
a((dp46494
g2
(lp46495
VI believe that NativeXML is compatible with Windows, Mac and iOS
p46496
as(dp46497
g7
V505088
p46498
stp46499
a((dp46500
g2
(lp46501
VI think you are over-complicating this
p46502
aVThere's really no need for p/invoke at all \u2013 the framework already handles this for you
p46503
aVYou can do this as a one-liner:
p46504
as(dp46505
g7
V505088
p46506
stp46507
a((dp46508
g2
(lp46509
VWell, you could do this:
p46510
aVBut I probably would shy away from that
p46511
aVIt feels a little too obscure for me
p46512
aVIn my opinion you should use arithmetic operators when you are performing arithmetic
p46513
aVI'd probably leave your code as it is and add an assertion in the runtime code that the two constants were appropriately related
p46514
aVDocument it with a comment as well
p46515
as(dp46516
g7
V505088
p46517
stp46518
a((dp46519
g2
(lp46520
VLike this:
p46521
aVThen pass  to
p46522
aVBecause Delphi strings are automatically null-terminated,  is double null-terminated
p46523
aVOne null-terminator that we put on the end, and the automatically added one
p46524
aVNote that I am assuming that you are using a Unicode Delphi since you talk about wide characters
p46525
aVIf you are on an older Delphi, and are calling , then declare  to be
p46526
aVMore likely you have a list of files in, say, a string list
p46527
aVTreat them like this:
p46528
as(dp46529
g7
V505088
p46530
stp46531
a((dp46532
g2
(lp46533
VThe question you ask here is answered on this blog post: http://private-storm
p46534
aVde/2009/08/11/case-terminateprocess/
p46535
aVThis includes Delphi source code
p46536
aVFor some reason that code enabled the  privilege, which is not necessary
p46537
aVThe difficulty with this kind of approach is locating the address of  in the target app
p46538
aVThe code in the article assumes that it's at the same address as in your own process
p46539
aVThat's very likely true, but not always
p46540
aVFor example, if your process is a 64 bit process and the target process is a 32 bit process then it won't be true
p46541
aVOr if the target process has a base address that doesn't allow kernel32 to load at its preferred address
p46542
aVAnother problem is if your process is 32 bit and the target process is 64 bit
p46543
aVIn that case then I believe the  trick simply fails
p46544
aVAll in all, I would use
p46545
as(dp46546
g7
V505088
p46547
stp46548
a((dp46549
g2
(lp46550
VUse 
p46551
as(dp46552
g7
V505088
p46553
stp46554
a((dp46555
g2
(lp46556
VIf you are going to run a timer in that way, then you may as well just call
p46557
aVAnd just get rid of your  and  event handlers
p46558
aVThere's really no point in you trying to keep track of whether the key is up or down when the system already does so
p46559
aVYour timer interval is quite short
p46560
aVThe system won't fire them that frequently anyway
p46561
aVIf I recall correctly the timer resolution is typically around 50ms
p46562
as(dp46563
g7
V505088
p46564
stp46565
a((dp46566
g2
(lp46567
V reports 126, i
p46568
ag192
aVClearly a module cannot be found
p46569
aVThere are two obvious causes for this:
p46570
aVThe module you are trying to load cannot be found
p46571
aVThe module you are trying to load can be found, but one of the modules that it depends on cannot be found
p46572
aVI would recommend debugging this with Dependency Walker in profile mode
p46573
aVThis will monitor your app at runtime and tell you precisely which module cannot be found
p46574
aVFinally, in this day and age, you really should be opting for
p46575
as(dp46576
g7
V505088
p46577
stp46578
a((dp46579
g2
(lp46580
VYou are attempting to read address 0 in the target process
p46581
aVThat will always fail
p46582
aVYou need to read from an address which is meaningful in the virtual address space of the target process
p46583
aVNote that in order to call  you only need
p46584
aVThat's not the problem here, but I thought I would point it out for sake of completeness
p46585
as(dp46586
g7
V505088
p46587
stp46588
a((dp46589
g2
(lp46590
VThe program terminates at the end of the  function
p46591
aVWhich in your program is right after you call
p46592
aVTherefore the thread doesn't get a chance to run
p46593
aVTo give the thread a chance to run you will need to make the main function wait for the thread to complete
p46594
aVBy calling
p46595
as(dp46596
g7
V505088
p46597
stp46598
a((dp46599
g2
(lp46600
VAlthough this is tagged Java and Android, I'm assuming from the command you are executing and the error message that this command is executing on your Windows development machine
p46601
aVThe command line interpretor is regarding the space between  and  as a  delimiter
p46602
aVWrapping the path in quotes is the normal way to deal with this problem:
p46603
as(dp46604
g7
V505088
p46605
stp46606
a((dp46607
g2
(lp46608
VIt makes perfect sense
p46609
aVIt returns a reference to the thread that is executing the calling code
p46610
aVSo, suppose that you have two threads,  and
p46611
aVIf code running in  calls , then  will be returned
p46612
aVLikewise, If code running in  calls , then  is returned
p46613
aVThe documentation is pretty weak in my view
p46614
aVIt states:
p46615
aVReturns a reference to the currently executing thread object
p46616
aVThe use of "currently" here is very poor
p46617
aVCurrently is often interpreted to mean "at this instant in time"
p46618
aVWhich is what confused you
p46619
aVRather ironically, the MSDN (
p46620
aVdocumentation makes a better stab at it:
p46621
aVGets the  object that is calling the current code block
p46622
aVBut they still fall into the trap of using "current"
p46623
aVOh the pitfalls of writing technical documentation
p46624
as(dp46625
g7
V505088
p46626
stp46627
a((dp46628
g2
(lp46629
Vdoes what you want, if you are prepared to admit  into your code
p46630
as(dp46631
g7
V505088
p46632
stp46633
a((dp46634
g2
(lp46635
VYou need to alter one of the security settings on the machine
p46636
aVI use the following
p46637
aVreg file to effect the modification:
p46638
aVRead all about it here: http://support
p46639
aVmicrosoft
p46640
aVcom/kb/896358
p46641
as(dp46642
g7
V505088
p46643
stp46644
a((dp46645
g2
(lp46646
VFor example, instead of writing:
p46647
aVyou can use guard clauses:
p46648
aVLots of articles extol the virtues of guard clauses:
p46649
aVhttp://blog
p46650
aVmafr
p46651
aVde/2009/06/12/a-case-for-guard-clauses/
p46652
aVhttp://www
p46653
aVcodinghorror
p46654
aVcom/blog/2006/01/flattening-arrow-code
p46655
aVhtml
p46656
aVhttp://sourcemaking
p46657
aVcom/implementation-patterns/guard-clause
p46658
aVYou can use the exact same approach inside a loop with the continue keyword
p46659
as(dp46660
g7
V505088
p46661
stp46662
a((dp46663
g2
(lp46664
VWhat happens when you click the button is that a message is posted to the message queue
p46665
aVThat doesn't get processed until you next pump your message queue
p46666
aVSo, if you see a delay between clicking the button, and the program responding, that's because the message queue is not serviced in a timely fashion
p46667
aVIf your GUI thread is busy then the message queue won't be pumped until the main thread has finished whatever it is doing
p46668
aVAnd your GUI thread would be busy if you have long running tasks on it
p46669
aVOnce the queued button click message eventually gets processed, then the call to  will result in the dialog showing immediately
p46670
aVThe only other reason why the GUI thread would not run would be if the CPU was consumed by higher priority threads
p46671
aVBut that's pretty unlikely
p46672
aVIt's very unusual for applications to use high priority threads
p46673
aVI'd be surprised if you were doing that
p46674
aVHow to solve the problem
p46675
aVIf you have long running tasks on your main thread, move those tasks onto background threads
p46676
aVOr, if you have high priority threads that stop the GUI thread running, then run your background threads at normal priority
p46677
as(dp46678
g7
V505088
p46679
stp46680
a((dp46681
g2
(lp46682
VSpecifying the  property value does not assign that value to the property at runtime
p46683
aVAll it does is control how the property is stored
p46684
aVIf the property's value is equal to the default when the property is stored, then the VCL streaming framework omits the property
p46685
aVThe documentation says it like this:
p46686
aVWhen you declare a property, you can specify a default value for it
p46687
aVThe VCL uses the default value to determine whether to store the property in a form file
p46688
aVIf you do not specify a default value for a property, the VCL always stores the property
p46689
aVDeclaring a default value does not set the property to that value
p46690
aVThe component's constructor method should initialize property values when appropriate
p46691
aVHowever, since objects always initialize their fields to 0, it is not strictly necessary for the constructor to set integer properties to 0, string properties to null, or Boolean properties to False
p46692
aVIn other words, you must initialise the property in the component's constructor, in addition to setting the default value
p46693
aVAnd the onus is on you to ensure that you initialise it to the same value as you specified as the
p46694
aVI have personally always found the duplication inherent in the design to be somewhat frustrating
p46695
aVThe designers have succeeded in building into the language a violation of the DRY principle
p46696
aVThe very fact that you have asked this question illustrates the weakness of the design
p46697
aVHaving specified the  value you are surprised that the compiler appears to ignore you and demands that you set it again
p46698
as(dp46699
g7
V505088
p46700
stp46701
a((dp46702
g2
(lp46703
VI'm not familiar with the integration of dmd into Visual Studio, but one way to achieve what you need is to add the compiled
p46704
aVres file to the list of files passed to dmd
p46705
aVexe
p46706
aVFor example:
p46707
aVI'd expect there be some way in your VS integration for you to add files to the dmd command that the IDE uses to compile your code
p46708
as(dp46709
g7
V505088
p46710
stp46711
a((dp46712
g2
(lp46713
VI'd say that you shouldn't be using  here
p46714
aVRather than debugging your  I'll offer you what I believe to be the right way to open a shell view onto a folder
p46715
aVCall
p46716
aVThis way you let the shell decide on the appropriate way to display the folders contents to the user
p46717
as(dp46718
g7
V505088
p46719
stp46720
a((dp46721
g2
(lp46722
VThere's no such function
p46723
aVThe  doesn't keep track of how it got to be in a particular state
p46724
aVIt just keeps track of the pixel buffer
p46725
aVYou'll have to write your own facility to undo drawing
p46726
aVRemember the previous version of the bitmap, and if you need to go back, just restore that previous version
p46727
as(dp46728
g7
V505088
p46729
stp46730
a((dp46731
g2
(lp46732
VYou work this out by calculating the distance between the two centres, D say
p46733
aVThere is an intersection if
p46734
aVwhere R1 and R2 are the radii of the two circles
p46735
aVThe first test,  handles the case when one circle's centre is inside the other's
p46736
aVAnd the second test, , handles the case when neither circle contains the other's centre
p46737
aVSo, adapting your code we have:
p46738
aVIf performance is important here, you can do without the call to  like this:
p46739
as(dp46740
g7
V505088
p46741
stp46742
a((dp46743
g2
(lp46744
VI find your question a little on the vague side and I'm not 100% sure I understand exactly what you are asking
p46745
aVHowever, I know how to deal with your problem when calling the constructor
p46746
aVPerhaps that's all you need help with
p46747
aVYou need to use virtual constructor polymorphism and a bit of casting:
p46748
aVThis relies on virtual constructor polymorphism
p46749
aVSo you must make sure that each constructor for every class derived from  is marked with the  directive
p46750
as(dp46751
g7
V505088
p46752
stp46753
a((dp46754
g2
(lp46755
V is only called when the component's properties are streamed from the form file
p46756
aVSince you are creating it at runtime,  does not get called
p46757
aVThis is by design
p46758
aVYour code needs some work anyway to allow for the  event to be modified at runtime and have that change filter down to the pen and brush
p46759
aVI'd do it like this:
p46760
aVNow there's no need for  or anything like that
p46761
aVBecause you wait until the  events of the pen and brush actually fire before accessing
p46762
aVBy the way, in your code it's a mistake to add property setters for  and  that modify the underlying fields
p46763
aVThat leads to leaks and all sorts of mess
p46764
aVAlso, be warned that exposing the pen and brush as public properties allows clients of  to change the  event
p46765
aVAnd that subverts
p46766
as(dp46767
g7
V505088
p46768
stp46769
a((dp46770
g2
(lp46771
VI believe that  returns  rather than
p46772
aVSo your code should read:
p46773
aVIf I were you I'd declare those  return values that map to C#  as  in Delphi
p46774
aVThat way your code will work if ever you compile a 64 bit version
p46775
aVI'd also contemplate using  rather than  and so get the compiler to convert any errors from  to Delphi exception
p46776
aVI also wonder why you have to return untyped pointers in, for example,
p46777
aVWhy can't you declare that function to return  on both sides
p46778
as(dp46779
g7
V505088
p46780
stp46781
a((dp46782
g2
(lp46783
VThe pointer  points to a  variable
p46784
aVThat is,  is a pointer to a reference to an object
p46785
aVTherefore you need to de-reference
p46786
aVLike this:
p46787
aVBecause  is un-typed you need to cast it before calling the Free method
p46788
aVSo, putting this together, you can free the object like this:
p46789
aVThis will not modify the  variable though
p46790
aVIt will merely destroy the object
p46791
aVIf you want to set  to  as well then you can do it like this:
p46792
aVis an odd beast because it takes an un-typed parameter
p46793
aVThat's why you don't need to cast to
p46794
aVTo avoid all this casting it would be preferable to declare p as a typed pointer, e
p46795
ag217
aVor
p46796
as(dp46797
g7
V505088
p46798
stp46799
a((dp46800
g2
(lp46801
VWhat you are attempting to do is simply not possible with Delphi generics
p46802
aVFor what it is worth, the equivalent code is also invalid in C# generics
p46803
aVHowever, your design would work with C++ templates
p46804
as(dp46805
g7
V505088
p46806
stp46807
a((dp46808
g2
(lp46809
VIs the best way to tackle this
p46810
aVThe memory is allocated and owned on the native side of the interface
p46811
aVThe trick is how to get at it
p46812
aVSomething like this should work
p46813
aVYour code was using  but that's going to interpret the data as  encoded
p46814
aVBut your C++ code uses  which is 8 bit ANSI
p46815
aVSo you need
p46816
aVOK, there's an assumption here that the encoding is not UTF-8, but that's a detail I cannot provide
p46817
aVIt's easy enough to adapt this to UTF-8
p46818
aVYou should also double check that the native code uses the  calling convention and isn't using
p46819
as(dp46820
g7
V505088
p46821
stp46822
a((dp46823
g2
(lp46824
VWell, you could override  to achieve this
p46825
aVBut how do you know that there isn't some other way to move the focus to the last row
p46826
aVIn fact a much better solution is to override :
p46827
aVWhen you do it this way you don't need any  code, and you don't need to override
p46828
aVAll possible mechanisms to change the selected cell to the final row will be blocked by this
p46829
aVAs @TLama correctly points out, you don't need to sub-class  to achieve this
p46830
aVYou can use the  event:
p46831
as(dp46832
g7
V505088
p46833
stp46834
a((dp46835
g2
(lp46836
VYou are calling
p46837
aVeven if you don't enter the block that creates SockStream
p46838
aVAnd that means your code can call Free on an un-initialized variable
p46839
aVThat is the only reason that I can see for the access violation
p46840
aVYou need to move the Free inside the if block
p46841
aVAs an aside, always use try/finally when creating objects:
p46842
aVHad you written it like this, the compiler would not have let you put the Free in the wrong block
p46843
aVYou should do the same with MySocket
p46844
aVAnd don't access you GUI from the thread, but I think others have made that point clearly enough
p46845
as(dp46846
g7
V505088
p46847
stp46848
a((dp46849
g2
(lp46850
VHere's the rough outline of what you need to do
p46851
aVI'll leave the coding up to you:
p46852
aVStart your process with either  or
p46853
aVThis will yield a process handle
p46854
aVCall  on the process handle
p46855
aVThis gives the process a chance to load and start its message loop
p46856
aVPass the process handle to  to obtain the process ID
p46857
aVUse  to enumerate the top level windows
p46858
aVPass each of these windows to  to check whether or not you have found the top level window of your target process
p46859
aVOnce you find a window whose process ID matches your target process, you're done
p46860
aVDon't forget to close your process handles once you are done with them
p46861
as(dp46862
g7
V505088
p46863
stp46864
a((dp46865
g2
(lp46866
VThe help file is indeed a little limited here
p46867
aVI generally just read the source code to  and
p46868
aVAnyway, you need to provide an
p46869
aVThere's lots of ways to do that
p46870
aVFor example, using an anonymous function:
p46871
aVIf you don't want to use an anonymous function you can implement  some other way
p46872
aVFor example a method of some object, or a class function, or even just a plain old fashioned non-OOP function
p46873
aVIt just has to have the same signature as above
p46874
aVAs always with comparison functions, return <0 if , >0 if  and 0 if
p46875
as(dp46876
g7
V505088
p46877
stp46878
a((dp46879
g2
(lp46880
VWhat you need to do depends on what sort of library it is
p46881
aVIf it is a static library then you'll need to build a DLL and link the
p46882
aVlib file to that DLL
p46883
aVThen your C# code can p/invoke to the DLL you built
p46884
aVIf it is an import library for a DLL, then you just p/invoke straight to the DLL
p46885
aVThe
p46886
aVlib file is no use to you here
p46887
as(dp46888
g7
V505088
p46889
stp46890
a((dp46891
g2
(lp46892
VThat's because string constants are  and so made up of UTF-16 elements
p46893
aVFrom the documentation:
p46894
aVString constants are assignment-compatible with the PChar and PWideChar types, which represent pointers to null-terminated arrays of Char and WideChar values
p46895
as(dp46896
g7
V505088
p46897
stp46898
a((dp46899
g2
(lp46900
VFloating point arithmetic is inexact
p46901
aVThe value  is not exactly representable in binary floating point
p46902
aVThe recommended reading here is: What Every Computer Scientist Should Know About Floating-Point Arithmetic
p46903
aVAt some point in the program,  becomes slightly less than  due to rounding error, and so your loop terminates
p46904
as(dp46905
g7
V505088
p46906
stp46907
a((dp46908
g2
(lp46909
VIn general, there's no way out of this
p46910
aVYou need multiple finally blocks
p46911
aVHowever, I don't want to comment on your specific code, whether or not that's an appropriate design
p46912
aVIt certainly looks pretty odd
p46913
as(dp46914
g7
V505088
p46915
stp46916
a((dp46917
g2
(lp46918
VThis code shows a message box containing the number 2 on all known versions of Delphi
p46919
aVThat is exactly as is expected and the  code most certainly does not trim your keys when comparing for equality
p46920
as(dp46921
g7
V505088
p46922
stp46923
a((dp46924
g2
(lp46925
VNo it is not
p46926
aVServices run in session 0
p46927
aVYour interactive processes, your desktop, all run in a different session, one per logged on user
p46928
aVThis isolation is important and is designed to enhance security
p46929
aVEven in Windows XP you were not meant to have direct interaction between services and the desktop
p46930
aVDevelopers all did it anyway so Microsoft banned it in Vista
p46931
aVStandard practice is to create the tray icon process by some other means, e
p46932
ag217
aVHKLM\u005cSoftware
p46933
aV\u005cRun
p46934
aVThat interactive process can then communicate with the service using IPC
p46935
aVFor example named pipes
p46936
aVNow, it is technically possible, in some extremely limited situations for a service to launch a process on the desktop
p46937
aVRead about it here: http://blogs
p46938
aVmsdn
p46939
aVcom/b/winsdk/archive/2009/07/14/launching-an-interactive-process-from-windows-service-in-windows-vista-and-later
p46940
aVaspx
p46941
aVIf you still want to try it, after reading that, then I wish you all the good luck in the world
p46942
as(dp46943
g7
V505088
p46944
stp46945
a((dp46946
g2
(lp46947
VLet's take a look at this code:
p46948
aVAfter , the object has a reference count of zero, because no interface variable has yet referenced it
p46949
aVThen you call  and take an interface reference in
p46950
aVSo the object now has a reference count of 1
p46951
aVThen the function returns and  goes out of scope
p46952
aVThis reduces the reference count to 0 and so the object is freed
p46953
aVWhen you use , you must always hold an interface variable
p46954
aVSo that the reference counting can manage the object's life
p46955
aVIn this case you have mixed object references and interface variables and that invariably leads to pain and anguish
p46956
aVI can't really advise you on what your code should look like because I don't know what your problem is
p46957
aVAll I have attempted to do is to explain the behaviour for you
p46958
aVPerhaps   should be returning  rather than
p46959
aVOr perhaps you need to stop using reference counted lifetime management
p46960
aVVery hard to be sure from here
p46961
as(dp46962
g7
V505088
p46963
stp46964
a((dp46965
g2
(lp46966
VAs a wild guess I speculated that the client may have 64 bit Excel
p46967
aVThat would not be compatible with your 32 bit COM server
p46968
aVApparently that wild guess proved to be accurate
p46969
as(dp46970
g7
V505088
p46971
stp46972
a((dp46973
g2
(lp46974
VYou cannot create a DLL that loads on both Windows and Mac
p46975
aVYou will need to re-compile your code for Mac
p46976
as(dp46977
g7
V505088
p46978
stp46979
a((dp46980
g2
(lp46981
VASCII character codes are in the range 0 to 127 inclusive
p46982
aVYour data is outside that range
p46983
aVHence the attempt to interpret the data as ASCII fails
p46984
aVThe  characters are used to indicate characters that could not be decoded
p46985
aVThe first 4 bytes, in hex, are
p46986
aVThat's the header for a JPEG file
p46987
aVSo, converting these bytes into a string is just not the appropriate course of action
p46988
as(dp46989
g7
V505088
p46990
stp46991
a((dp46992
g2
(lp46993
VThis Python script will do what you want:
p46994
aVEvery 60 seconds it will synthesise a mouse move event in the message queue of the thread with input focus
p46995
aVIt moves the mouse dx=0 and dy=0
p46996
aVThat's a null operation which means that your mouse won't even jitter
p46997
aVBut it is enough to stop your machine locking itself
p46998
aVIf you want to convince yourself that this code is actually doing something, try it with non-zero values for the second and third parameters to
p46999
aVInvoke the script with  rather than  and you won't even see a console window
p47000
as(dp47001
g7
V505088
p47002
stp47003
a((dp47004
g2
(lp47005
VThe way you have written it, the  buffers are allocated on the managed side
p47006
aVBut that's  the wrong place
p47007
aVThe allocation happens on the unmanaged side
p47008
aVDeclare the struct in C# like this:
p47009
aVThen call , passing the struct as an out parameter
p47010
aVOr possibly a ref parameter
p47011
aVI can't tell from here which it should be
p47012
aVYour  will look like this (with the correct calling convention specified):
p47013
aVThen convert the returned pointers to strings like this:
p47014
aVand so on for the other fields
p47015
aVPresumably the unmanaged code also exposes a function that deallocates the memory returned in the struct
p47016
aVCall that once you are done with the struct
p47017
as(dp47018
g7
V505088
p47019
stp47020
a((dp47021
g2
(lp47022
VAll threads initially start at
p47023
aVSo you'd have to reduce the priority of each thread
p47024
aVOr reduce the priority of the owning process
p47025
aVThere is little overhead in calling
p47026
aVOnce you have woken up a thread, the additional cost of calling  is negligible
p47027
aVOnce you set the thread's priority it will remain at that value until changed
p47028
aVSuppose that you have one processor, and two threads ready to run
p47029
aVThe scheduler will always choose to run the thread with the higher priority
p47030
aVThis means that in your scenario, the below normal threads would never run
p47031
aVIn reality, there's a lot more to scheduling than that
p47032
aVFor example priority inversion
p47033
aVHowever, you can think of it like this
p47034
aVIf all processors are busy with normal priority threads, then expect lower priority threads to be starved of CPU
p47035
as(dp47036
g7
V505088
p47037
stp47038
a((dp47039
g2
(lp47040
VYou state the following:
p47041
aVI really don't have anywhere that I'm calling Sync in the main thread
p47042
aVDoing so also proves difficult because I actually have another thread that is calling Sync
p47043
aVDo I need to wrap the innards of these functions with a try-catch and use a VCLSync to get the exception to the main thread myself
p47044
aVIs there a better way to check for exceptions in a main thread idle loop of some kind
p47045
aVCalling  in the other thread will raise the exception there
p47046
aVIf you don't want it raised there, and if it must be raised in the main thread, then there is no option
p47047
aVYou simply have to catch any unhandled exceptions yourself, in the async procedure
p47048
aVYou can then queue them off to the main thread, perhaps by calling , posting a Windows message, or some similar queue mechanism
p47049
aVAnother option would be to use  if you don't mind the synchronisation at that point
p47050
aVThe bottom line is that calling  from another thread, and needing the exception to be raised on the main thread, are not compatible goals
p47051
aVErgo you must catch the exception yourself and stop AsyncCalls dealing with it
p47052
aVEssentially this is just a broadening of your current approach
p47053
aVAt the moment your fire notifications to the main thread, rather than have the main thread sync
p47054
aVAfter all, I guess you are using an asynchronous approach because you don't want to sync from the main thread
p47055
aVSo, the broadening is that you need to be able to notify the main thread of errors and exceptions, as well as more normal outcomes
p47056
as(dp47057
g7
V505088
p47058
stp47059
a((dp47060
g2
(lp47061
VYou can obtain a method, given its name, like this:
p47062
aVThis is the mechanism that the RTL uses when reading your
p47063
aVdfm files
p47064
aVIt relies on the method being published
p47065
aVYou can call it like this:
p47066
aVNaturally you'd substitute a database read in the final code
p47067
aVAs for the second part of your question, you can get the name of an event handler with this code:
p47068
as(dp47069
g7
V505088
p47070
stp47071
a((dp47072
g2
(lp47073
VYou can't inject a 32 bit DLL into a 64 bit process
p47074
aVIn order to inject a DLL into 64 bit explorer you are going to need to get XE2 or XE3 and build a 64 bit DLL
p47075
aVOr write this part of your code in C++ if you do not have access to 64 bit Delphi
p47076
aVAs it happens, your code doesn't inject anyway
p47077
aVIt just calls SendMessage from your process
p47078
aVInjection typically involves a call to CreateRemoteThread
p47079
aVIn fact you don't need to inject
p47080
aVYou can use  to allocate memory in the explorer process
p47081
aVYou can then pass that address in your
p47082
aVSince that memory is in the other process, you'll have to use  and  to access it
p47083
aVYou will still need to do this from a 64 bit process though
p47084
aVI would have thought that the shell provides facilities for you to obtain this information without hacking the explorer processes memory
p47085
as(dp47086
g7
V505088
p47087
stp47088
a((dp47089
g2
(lp47090
VYou cannot constrain a generic parameter such that  and  can be used in the generic class
p47091
aVThe only constraints available are class or interface constraints
p47092
aVTo the very best of my knowledge, the language offers no generic way to enumerate over a generic enumerated type
p47093
aVProbably the best you can do is to use RTTI, sacrificing compile time type safety (as illustrated by Tobias)
p47094
aVHaving read the comments to Tobias's answer, it seems likely that what you really want here is
p47095
aVThat's because you want to be able to find a  instance given a  key
p47096
aVAnd you want  rather than  because the former takes over ownership of the  instances
p47097
aVYou need somebody to free them all when you are done, and you may as well let  do it for you
p47098
aVFor an example of the ownership side of this, see @RRUZ's answer here: Example for using Generics
p47099
aVCollections
p47100
aVTObjectDictionary
p47101
as(dp47102
g7
V505088
p47103
stp47104
a((dp47105
g2
(lp47106
VI believe that you should be using  for this
p47107
aVHowever, the answer to your question is that the appropriate key name for HKCU is:
p47108
aVNaturally you have to provide the SID for the current user
p47109
aVThis is one of the many services that the Win32 API provides for you in
p47110
as(dp47111
g7
V505088
p47112
stp47113
a((dp47114
g2
(lp47115
VAccording to Andreas Hausladen's latest blog post, and his answer here, this XE2 bug is taken care of by IDEFixPack
p47116
aVAnd is not needed in XE3 since XE3 fixes the problem
p47117
aVSo I suspect that may be the most effective workaround if you can manage to get IDEFixPack installed on this machine
p47118
aVEven if you can't get IDEFixPack installed, then this answer could still be useful to other readers
p47119
as(dp47120
g7
V505088
p47121
stp47122
a((dp47123
g2
(lp47124
VYou'll need add a post-built action to whatever build automation you are using
p47125
aVFind an external tool that modifies the PE flags of an executable and call that from your build script
p47126
aVObviously this must happen after the executable has been built
p47127
aVI would recommend using editbin from the MS toolchain
p47128
aVYou can get this installed as part of the Windows SDK
p47129
aVThe commend will look like this:
p47130
as(dp47131
g7
V505088
p47132
stp47133
a((dp47134
g2
(lp47135
VThat approach cannot work
p47136
aVYour two processes have isolated address spaces
p47137
aVAn address, and therefore an object, is only meaningful in the context of the process that owns that address or object
p47138
aVYou can only call methods on objects that reside in your process
p47139
as(dp47140
g7
V505088
p47141
stp47142
a((dp47143
g2
(lp47144
VYou haven't shown the code that calls this code
p47145
aVHowever, it's pretty obvious that you don't have a valid  object
p47146
aVGet one of those like this:
p47147
aVYou probably have code like this:
p47148
aVor possibly like this:
p47149
aVUpdate You've now shown the calling code but you clearly haven't shown it all, because the code in the question does not exhibit the behaviour you describe
p47150
aVThe point I make remains, you must have an invalid object reference somewhere
p47151
aVI've shown a couple of the most common ways for that to come about
p47152
aVBut there are other ways to get an invalid object reference
p47153
aVThe other thing wrong with the code in the question is your destructor
p47154
aVThey must always be marked with the  directive
p47155
aVYou have to do this in order for your destructor to be called when an object is freed
p47156
as(dp47157
g7
V505088
p47158
stp47159
a((dp47160
g2
(lp47161
VYou have not allocated memory
p47162
aVYou just declared a pointer, , but didn't make it point at anything
p47163
aVThat explains the segmentation fault
p47164
aVYou will need to allocate memory for your buffer
p47165
aVWhat's more,  does not allow you to specify how big the buffer is
p47166
aVSo you are at risk of running over the end of the buffer
p47167
aVSo use  instead
p47168
aVI also corrected your declaration of  and made sure that it returns a value
p47169
as(dp47170
g7
V505088
p47171
stp47172
a((dp47173
g2
(lp47174
VThe biggest problem that I can see is that  evaluates to the size of a pointer
p47175
aVUse  instead
p47176
aVFor sure that means that your injection will fail because the path that  receives will be truncated
p47177
aVThere may be other problems, but that's the place to start
p47178
as(dp47179
g7
V505088
p47180
stp47181
a((dp47182
g2
(lp47183
VThere are two differences:
p47184
aVThe relative order in which the except and finally blocks execute differs
p47185
aVIn version 1, the finally executes before the except
p47186
aVIn version 2 the excecution order is reversed
p47187
aVIn version 1, if the finally block raises, then it will be handled by the except block
p47188
aVIn version 2, if the finally block raises, then it will be handled by the next containing exception handler, i
p47189
ag192
aVoutside this code
p47190
aVUsually you aren't concerned about finally blocks that raise
p47191
aVYou simply don't expect that to happen and if it does, something is probably very broken
p47192
aVSo the difference that counts is whether the finally runs before the exception handler, or vice versa
p47193
aVSometimes it doesn't matter, but it often does make a difference
p47194
as(dp47195
g7
V505088
p47196
stp47197
a((dp47198
g2
(lp47199
VYou are looking at the XE3 documentation, according to which  is declared as:
p47200
aVIn XE2, unfortunately,  is declared like this:
p47201
aVSo you will need to supply a regular procedure
p47202
aVThat is,  is not allowed to be a method of a class and must be just a plain old function:
p47203
aVI suspect that this was a design error in the XE2 FMX code
p47204
aVThe sort compare function is much more flexible as , which presumably is why it was changed
p47205
as(dp47206
g7
V505088
p47207
stp47208
a((dp47209
g2
(lp47210
VThis approach simply is not going to work
p47211
aVYou have two VCL instances in the target executable
p47212
aVOne owned by the target app and one owned by the DLL
p47213
aVThat's one VCL instance too many
p47214
aVYou might be able to get away with that if the exact same version of Delphi is used to build both the target app and your DLL
p47215
aVHowever, you will still have two heap managers in play
p47216
aVAnd your code passes heap allocated memory between your different VCL instances
p47217
aVYou will be allocating in one heap and deallocating in the other
p47218
aVThat doesn't work and will result in access violations
p47219
aVYou are passing a string allocated in the DLL's heap to the string grid object that uses the target app's heap
p47220
aVThat just cannot work
p47221
aVI think the access violation will occur at the point at which the DLL code attempts to deallocate the previous value of , that was allocated by the target app's heap manager
p47222
aVBasically what you are attempting is not going to work
p47223
aVYou could find out the address of the target app's implementation of  and fake a call to that
p47224
aVBut you'd also need to find the target app's implementation of ,  etc
p47225
aVand make sure that all dynamic memory that crossed from your DLL to the target app was allocated and deallocated by the target app's heap
p47226
aVYou are going to have a devil of a job making this work
p47227
aVOf course, if both target app and the DLL used the shared memory manager, then you might just be able to make this approach fly
p47228
aVMuch simpler would be to fake keyboard input
p47229
aVI personally would scope out the feasibility of that using AutoHotKey
p47230
as(dp47231
g7
V505088
p47232
stp47233
a((dp47234
g2
(lp47235
VCreate a hidden window handle, for example with
p47236
aVAnd then create your control by calling  passing that hidden window handle
p47237
as(dp47238
g7
V505088
p47239
stp47240
a((dp47241
g2
(lp47242
VThe Delphi toolchain does not have that capability built in
p47243
aVIn order to do something similar in Delphi you need to use the memory mapped file API, or some other inter-process communication (IPC) mechanism, e
p47244
ag217
aVpipes, sockets, Windows messages etc
p47245
aVOr, you could simply load the C++ DLL from your Delphi DLL
p47246
aVThe C++ DLL can access the shared data, and your Delphi DLL can call functions in the C++ DLL that read and write to the shared data
p47247
aVHowever, shared data is really very unsuited to the task
p47248
aVUsing IPC is more appropriate
p47249
aVWhat you didn't make quite clear in the question, is that there are two processes here
p47250
aVHence the need for IPC
p47251
as(dp47252
g7
V505088
p47253
stp47254
a((dp47255
g2
(lp47256
VYou can count the non-white space characters like this:
p47257
aVThis uses  to determine whether or not a character is whitespace
p47258
aVreturns  if and only if the character is classified as being whitespace, according to the Unicode specification
p47259
aVSo, tab characters count as whitespace
p47260
as(dp47261
g7
V505088
p47262
stp47263
a((dp47264
g2
(lp47265
VIf you really want one function to accept all those distinct function types, then you'll have to sacrifice type safety
p47266
aVYou can do this with a cast:
p47267
as(dp47268
g7
V505088
p47269
stp47270
a((dp47271
g2
(lp47272
VWindows shows this message when an unhandled exception leaks out of your application
p47273
aVThis is a fatal condition
p47274
aVSomething very wrong has happened with your application because exceptions should all be caught
p47275
aVYou need to work out what is throwing the exception and why it is not being caught
p47276
aVThe very first step is to expand the details of the error dialog and find out which module the fault is occurring in, what the fault is and so on
p47277
aVThat should yield some high level clues at the very least
p47278
aVMost likely the Delphi debugger will not be able to help you for such a fault
p47279
aVYou need to configure your system to arrange for a crash dump to be produced by the Windows Error Reporting service
p47280
aVThen you can load up the error report in a tool like WinDbg and try to figure it out
p47281
as(dp47282
g7
V505088
p47283
stp47284
a((dp47285
g2
(lp47286
VYour code fails because a dynamic array is not a TObject
p47287
aVYou can do it like this:
p47288
as(dp47289
g7
V505088
p47290
stp47291
a((dp47292
g2
(lp47293
V is returning  which indicates failure
p47294
aVYou then call   which returns 5
p47295
aVThis is
p47296
aVIn other words, your process does not have sufficient rights to open that file
p47297
as(dp47298
g7
V505088
p47299
stp47300
a((dp47301
g2
(lp47302
VYou don't need a cast to call SendMessage:
p47303
aVFor what it is worth, your VB
p47304
aVnet code incorrectly declares the second parameter to SendMessage as IntPtr
p47305
aVIt should be an unsigned 32 bit integer
p47306
aVIf you do need need to implement a cast in Delphi, from one type to another you have two choices
p47307
aVAn unchecked cast,
p47308
aVwhich casts Y to be of type SomeType without runtime checks
p47309
aVOr a checked cast,
p47310
aVwhich will raise an exception is Y is not SomeClass
p47311
as(dp47312
g7
V505088
p47313
stp47314
a((dp47315
g2
(lp47316
VYou can use a PE reading tool to list the exported functions
p47317
aVFor example Dependency Walker will do that for you
p47318
aVThere's not a right lot you can do with that information though
p47319
aVThere's no metadata with a native DLL that tells you how to call those functions, what their signatures are
p47320
aVOr even what the parameters represent
p47321
aVSomething has gone wrong with this project
p47322
aVA DLL on its own is not enough
p47323
aVYou need a header file and some documentation
p47324
as(dp47325
g7
V505088
p47326
stp47327
a((dp47328
g2
(lp47329
VYou are creating , a windowed control, in the DLL
p47330
aVBut you never destroy it
p47331
aVThen you unload the DLL which unloads the code that implements the window procedures for all windows created by the DLL
p47332
aVPresumably when the process shuts down, the window procedures are called, but there is no code there anymore
p47333
aVFix the problem by destroying all objects that the DLL creates
p47334
aVIt looks to me like the best approach is to do that when  terminates
p47335
aVIn the code that loads the DLL,  is declared incorrectly
p47336
aVIt should be
p47337
aVBut that doesn't actually explain the problem here since the signature mismatch is benign for a parameterless procedure
p47338
as(dp47339
g7
V505088
p47340
stp47341
a((dp47342
g2
(lp47343
VThe alpha channel is disturbed after you call LoadIcon
p47344
aVThe Win32 APIs that load icons, e
p47345
ag217
aVLoadIcon, LoadImage, etc
p47346
aVare well proven
p47347
aVThey reliably load icons with partial alpha
p47348
aVYou need to investigate the code that executes after the icon has been loaded
p47349
aVI can't give you a solution or an explanation, but I am confident that LoadIcon is not the culprit
p47350
aVI wanted to know how to create a Win32 Bitmap from an
p47351
aVIcon in resource with the partial alpha values
p47352
aVCall GetIcon or GetImage to obtain an HICON
p47353
aVThen call GetIconInfo
p47354
aVThe bitmap you need is in the hbmColor field of the ICONINFO struct
p47355
as(dp47356
g7
V505088
p47357
stp47358
a((dp47359
g2
(lp47360
VAccording to the documentation for :
p47361
aVReturn value
p47362
aVType: HWND
p47363
aVIf the message succeeds, the return value is the handle to the new child window
p47364
aVIf the message fails, the return value is NULL
p47365
aVSo, the answer is the window handle the value that the window procedure returns
p47366
aVRead it out of  after you have called the inherited window procedure
p47367
aVIf you want the window handle before the window has been created, well, you are out of luck
p47368
as(dp47369
g7
V505088
p47370
stp47371
a((dp47372
g2
(lp47373
VYou need to install the Microsoft Visual C++ 2005 redistributable
p47374
as(dp47375
g7
V505088
p47376
stp47377
a((dp47378
g2
(lp47379
VIf cost is a factor, since you reject Delphi, how about FreePascal with the Lazarus IDE
p47380
aVIt's just hit version 1
p47381
aV0 and is of a very high standard
p47382
as(dp47383
g7
V505088
p47384
stp47385
a((dp47386
g2
(lp47387
VThe double click event handler needs to force a repaint
p47388
aVCall  right at the end of that handler
p47389
aVThis will force a paint cycle on the list view
p47390
as(dp47391
g7
V505088
p47392
stp47393
a((dp47394
g2
(lp47395
VThere are no built in conditionals that tell you whether the project's , as specified in the
p47396
aVdproj file, is VCL or FMX
p47397
aVTo the very best of my knowledge you cannot switch on that setting in code
p47398
aVRemember also that it is perfectly possible, although certainly not mainstream, to have an application that uses both VCL and FMX
p47399
aVIt's really not an either or condition
p47400
aVSo I recommend that you declare your own conditional define that controls whether you use the GUI runner or the text runner
p47401
aVIn fact, you presumably already have some sort of a mechanism to do this
p47402
aVYou code names the unit
p47403
aVSo that means it must be in a  in the same file as the code in the question
p47404
aVHow did you conditionally include  in the uses clause
p47405
aVNote: The same question has been asked on the Embarcadero forums: https://newsgroups
p47406
aVembarcadero
p47407
aVcom/message
p47408
aVjspa
p47409
aVmessageID=400077
p47410
as(dp47411
g7
V505088
p47412
stp47413
a((dp47414
g2
(lp47415
VIt sounds like you want each instance of the DLL to have separate data segments
p47416
aVThat's the only reason I can think of for the question
p47417
aVThe only way to achieve this is to make sure that each time you call , the DLL has a different filename
p47418
aVCopy the DLL to a temporary file each time you need to load it, making sure that the name you use is different from any loaded instance of the DLL
p47419
aVI echo the comments above that encourage you to re-design the system architecture
p47420
as(dp47421
g7
V505088
p47422
stp47423
a((dp47424
g2
(lp47425
VYou can't get at those constants through RTTI
p47426
aVI suspect your best solution will be to use attributes instead
p47427
aVNot only will that have the benefit of actually working, I think it sounds like a cleaner and simpler solution to your problem
p47428
as(dp47429
g7
V505088
p47430
stp47431
a((dp47432
g2
(lp47433
VIn order to opt out of PCA altogether, you will defintely need to include a manifest in all three of your executables
p47434
as(dp47435
g7
V505088
p47436
stp47437
a((dp47438
g2
(lp47439
VYou need to use the appropriate well-known security identifier
p47440
aVIn your case it is:
p47441
as(dp47442
g7
V505088
p47443
stp47444
a((dp47445
g2
(lp47446
VThe Win32 API is accessible from many different toolsets
p47447
aVAll C compilers for Windows that I have ever come across can call all Win32 APIs
p47448
aVWhat's more all these C compilers can call COM APIs and even GDI+ which is a very C++ centric library
p47449
aVBut MS provided a bridge for C clients to use
p47450
aVSo, in summary, choosing to use C will not deprive you of access to any part of Win32
p47451
as(dp47452
g7
V505088
p47453
stp47454
a((dp47455
g2
(lp47456
VThe API function you are looking for is
p47457
as(dp47458
g7
V505088
p47459
stp47460
a((dp47461
g2
(lp47462
VGINA was killed by Vista
p47463
aVSo you are right that it's not present in Windows 7
p47464
aVThe replacement functionality is credential providers
p47465
aVThey certainly don't allow you to intercept SAS
p47466
as(dp47467
g7
V505088
p47468
stp47469
a((dp47470
g2
(lp47471
VYour two versions of code do the following:
p47472
aVAllocate the struct on the heap
p47473
aVAllocate the struct as a local variable
p47474
aVThese options are interchangeable in this program
p47475
aVThe code that assigns to the struct, and then prints, doesn't care whether the struct was heap allocated or is a local variable
p47476
as(dp47477
g7
V505088
p47478
stp47479
a((dp47480
g2
(lp47481
VYou need to register the implementing object, rather than the interface, as the think that is leaked:
p47482
aVThe fact that this object leaks suggests that your reference counting is broken somehow
p47483
aVI'd probably look to fix the underlying problem rather than suppress it
p47484
as(dp47485
g7
V505088
p47486
stp47487
a((dp47488
g2
(lp47489
VThe Windows virtual memory manager will do this automatically for you
p47490
aVSo long as the module can be loaded at the same address in each process, the physical memory for the code will be shared between each process that loads that module
p47491
aVThat is true for all modules, libraries as well as executables
p47492
aVThis is achieved by the linker marking code segments as being shareable
p47493
aVSo, linkers mark code segments as being shareable, and data segments otherwise
p47494
aVThe bottom line is that you do not have to do anything explicit to make this happen
p47495
as(dp47496
g7
V505088
p47497
stp47498
a((dp47499
g2
(lp47500
VThere's no documentation for this, so the best we can do is poke at the compiler and try to guess the reasoning behind its behaviour
p47501
aVNow, a procedure with a typeless parameter can be passed any parameter, irrespective of its type
p47502
aVSo, any sane overload resolution scheme has to consider the typeless parameter last, only when it has exhausted all other possible candidates
p47503
aVOtherwise it would always be chosen
p47504
aVSo with that, the behaviour can be explained
p47505
aVWhen your parameter is of type, , that is assignment compatible with a dynamic array
p47506
aVWhich means that the dynamic array overload can be selected
p47507
aVWhen your parameter is any other pointer type, it is not assignment compatible with a dynamic array
p47508
aVAnd so the overload resolution falls back to the final possible candidate, the typeless parameter
p47509
aVUltimately this behaviour comes down to the fact that the compiler considers  to be assignment compatible with any dynamic array
p47510
aVThat this statement is fact is easy to confirm by experiment, however, I cannot find documentation for it
p47511
as(dp47512
g7
V505088
p47513
stp47514
a((dp47515
g2
(lp47516
VHow can this be done
p47517
aVIt can't be done without completely replacing the entire memory allocator
p47518
aVFor example the scalable memory manager Hoard does exactly that
p47519
aVBut replacing the memory allocator is not for the faint hearted
p47520
aVIf you want to use per-thread heap with , and your allocation/deallocation code is reasonably contained, then you could simply call  and  explicitly in your thread code
p47521
aVHowever, I'd be surprised if this was as fast as the standard CRT allocator which performs well
p47522
as(dp47523
g7
V505088
p47524
stp47525
a((dp47526
g2
(lp47527
VYes, each module needs its own manifest
p47528
aVIn your case, if you were to start  from , and  does not have a manifest, then  will run virtualized, it will not have access to comctl32 v6 and so on
p47529
aVA process does not inherit its manifest from the process that creates it, each process must supply its own manifest
p47530
as(dp47531
g7
V505088
p47532
stp47533
a((dp47534
g2
(lp47535
VThis appears to be a known issue related to actions and the way they are updated in the application idle handler
p47536
aVThe following QC report describes your scenario: http://qc
p47537
aVembarcadero
p47538
aVcom/wc/qcmain
p47539
aVaspx
p47540
aVd=12706
p47541
aVThe solution to your problem, according to the QC report, is to set the TApplication
p47542
aVActionUpdateDelay property to a value greater than 0
p47543
aVWhat I would love to know is why the presence of a maximized client form leads to the VCL's DoActionIdle being called in a busy loop
p47544
aVPresumably execution of an actions's OnUpdate handler leads to another queued message, and another idle cycles, and so on
p47545
aVI'd have thought dealing with that would be the best way to tackle this issue, but perhaps it's hard to achieve
p47546
as(dp47547
g7
V505088
p47548
stp47549
a((dp47550
g2
(lp47551
VThe Windows API does not provide any such simple function, to the very best of my knowledge
p47552
aVThat sort of functionality is typically provided by libraries
p47553
aVNormally you will be using an HTML or XML library to generate your HTML or XML
p47554
aVThat's almost always a better strategy than trying to assemble it yourself
p47555
aVAnd those libraries will do the necessary escaping for you
p47556
aVFor example, a commonly used library to work with XML on Windows is MSXML
p47557
aVYou can use that library to parse and emit XML and it will take care of escaping for you
p47558
as(dp47559
g7
V505088
p47560
stp47561
a((dp47562
g2
(lp47563
VThere are a few buffer length errors and oddities, but here's your big problem
p47564
aVYou call  incorrectly
p47565
aVThat is meant to receive UTF-16 encoded text as input
p47566
aVBut when  returns false that means that the buffer is not UTF-16 encoded
p47567
aVThe following is basically what you need:
p47568
aVNote that I've fixed the length parameter to
p47569
aVFor what it is worth, I think I'd read in to a buffer of
p47570
aVThat would remove the need for the
p47571
aVIn fact I'd stop using  altogether
p47572
aVThis program should be Unicode all the way -  is what you use when you compile for both NT and 9x variants of Windows
p47573
aVYou aren't compiling for 9x anymore I imagine
p47574
aVSo I'd probably code it like this:
p47575
aVNote also that this code makes no allowance for the possibility of receiving UTF-8 encoded text
p47576
aVIf you want to handle that you'd need to take your  buffer and send to through  using
p47577
as(dp47578
g7
V505088
p47579
stp47580
a((dp47581
g2
(lp47582
VWell, you are nearly there
p47583
aVIt's like this:
p47584
aVThe problem you had is that you must increment the loop index on each iteration
p47585
aVYou were only incrementing when you found a negative value
p47586
aVBut it's better as a  loop and your  loop is over complicated
p47587
aVI'd write it like this:
p47588
as(dp47589
g7
V505088
p47590
stp47591
a((dp47592
g2
(lp47593
VTo centre a control in its parent do this:
p47594
aVCall this function, passing the frame
p47595
aVObviously you need to wait until you've assigned the parent before doing so
p47596
aVIf the page control can be re-sized at runtime, add a call to this function from the tabsheet's OnResize event
p47597
aVOr, as NGLN points out simply set the control's  to  and the VCL framework will take care off centring the control when its parent is resized
p47598
as(dp47599
g7
V505088
p47600
stp47601
a((dp47602
g2
(lp47603
VThis line doesn't do what you want
p47604
aVThat condition always evaluates to true, because  is considered truthy
p47605
aVYou mean
p47606
aVAnd the line that says
p47607
aVwas meant, I guess, to be an assignment and not a comparison:
p47608
as(dp47609
g7
V505088
p47610
stp47611
a((dp47612
g2
(lp47613
VThere's plenty of strange looking code here, but I won't try to get in too deep
p47614
aVI would say though that FBrowseWinHnd is incorrectly typed
p47615
aVIt is
p47616
aVYou don't have any s in this unit
p47617
aVThey should all be
p47618
aVThe error is here:
p47619
aVThat set's the dialog's owner window to be the window handle that represented the dialog the last time it was shown
p47620
aVAnd that's why it fails only at the second time of asking
p47621
aVClearly that's wrong
p47622
aVSimply remove this line of code and leave  as 0
p47623
aVIf you want to give the dialog an owner, change the signature of  to receive the owner window handle, and then pass it on to the dialog
p47624
aVHow would one go about debugging an API call that succeeds once, and then fails when called again
p47625
aVThe first step is to look at the value the parameters and see if they vary from one call to the next
p47626
aVAnd indeed doing exactly that is how I identified the problem
p47627
as(dp47628
g7
V505088
p47629
stp47630
a((dp47631
g2
(lp47632
VThe  parameter of  is exactly the same as the  parameter of
p47633
aVSo you simply need to pass exactly what already did when you called
p47634
aVNamely :
p47635
aVRegarding the very final part of your question, if you ever need to convert  into an object with a specific class,  in this case then you can use a runtime cast:
p47636
aVHowever, doing that rather implies that you don't need to be using RTTI in the first place
p47637
aVUsing the method in the first part of my answer is the RTTI way to do what you ask
p47638
as(dp47639
g7
V505088
p47640
stp47641
a((dp47642
g2
(lp47643
VThat is normal behaviour
p47644
aVThat's how keyboard accelerators have always worked and are meant to work
p47645
aVThe way to stop the S key invoking a button click is to remove the accelerator
p47646
as(dp47647
g7
V505088
p47648
stp47649
a((dp47650
g2
(lp47651
VCreating a new process is expensive
p47652
aVThere are no alternatives to using
p47653
aVThere are no quick fixes here
p47654
aVThere's no magic button which makes process creation super fast
p47655
aVThe solution to your problem is going to be to stop creating a new process altogether
p47656
aVPerform this task inside your process
p47657
as(dp47658
g7
V505088
p47659
stp47660
a((dp47661
g2
(lp47662
VThe only explanation for  is that the DLL that the C# code is finding is not the DLL produced from the Delphi code that you show
p47663
aVSo, perhaps the C# code is picking up an out of date version of the DLL
p47664
aVOr perhaps it's picking up a completely different DLL
p47665
aVFor example, my system has a DLL named  in the system32 directory
p47666
aVMost likely that's the DLL that your C# code is finding
p47667
aVIn order to make sure that the right DLL is found, you need to place a copy of the Delphi DLL in the same directory as the C# executable file
p47668
as(dp47669
g7
V505088
p47670
stp47671
a((dp47672
g2
(lp47673
VYou don't need to distribute the manifest file at all
p47674
aVBy using  you have embedded the manifest into the executable
p47675
aVUse a resource editing tool to confirm that the manifest has indeed been embedded as a Windows resource
p47676
aVCan you use the same manifest for all executables
p47677
aVThat depends on what's in the manifest
p47678
aVIf you are specifying  then you'd need different manifests if you have both 32 and 64 bit executables
p47679
aVBut I think that question is moot since you don't need to distribute the manifests
p47680
as(dp47681
g7
V505088
p47682
stp47683
a((dp47684
g2
(lp47685
VYou need to run the database access and the progress dialog in different threads
p47686
aVThat's the only option because the databse access code is synchronous with no callbacks
p47687
aVWell, I'm assuming that your database layer does not offer regular callbacks that you could use to keep the UI alive
p47688
aVIs that so
p47689
aVIf you cannot put the database code in a background thread, then you are in a bind
p47690
aVThe GUI code for the progress dialog wants to be in the main thread
p47691
aVIf you move that to a background thread then you can't use the VCL since it is tied to the main GUI thread
p47692
aVSo you may need to resort to raw Win32 API calls
p47693
as(dp47694
g7
V505088
p47695
stp47696
a((dp47697
g2
(lp47698
VYou move the panel down in 512 single pixel steps with a 50ms sleep in between each step
p47699
aVSince you don't process any messages in that time, your app will be unresponsive for the 25s it takes to animate the panel
p47700
aVThe program hangs because you have failed to service the message queue
p47701
aVThe solution is to use a timer rather than a loop
p47702
aVIn  you need to start the timer ticking
p47703
aVThe timer procedure is like this:
p47704
aVThese functions would look like this:
p47705
as(dp47706
g7
V505088
p47707
stp47708
a((dp47709
g2
(lp47710
VThe most likely explanations for that error are:
p47711
aVThe file you are attempting to load is not an executable file
p47712
aVrequires you to provide an executable file
p47713
aVIf you wish to be able to open any file with its associated application then you need  rather than
p47714
aVThere is a problem loading one of the dependencies of the executable, i
p47715
ag192
aVthe DLLs that are linked to the executable
p47716
aVThe most common reason for that is a mismatch between a 32 bit executable and a 64 bit DLL, or vice versa
p47717
aVTo investigate, use Dependency Walker's profile mode to check exactly what is going wrong
p47718
aVReading down to the bottom of the code, I can see that the problem is number 1
p47719
as(dp47720
g7
V505088
p47721
stp47722
a((dp47723
g2
(lp47724
VFrom your comments to Hans's answer, you are sending the message
p47725
aVThis message is typically sent with
p47726
aVNow,  has two versions,  and
p47727
aVWhen you call , you must supply Unicode text, and when you call  you supply ANSI text
p47728
aVSo, the discrimination of the type of data is not made by having two message identifiers, rather it is based on the function that is used to send the data
p47729
aVExactly the same applies when using /, /, and so on
p47730
aVIf you call , using  then you can expect that both ANSI and Unicode windows will receive your message
p47731
aVThe messaging system ensures that the data that you sent is converted to the appropriate encoding for the window that receives the message
p47732
as(dp47733
g7
V505088
p47734
stp47735
a((dp47736
g2
(lp47737
VYour buffer is the size of 10 ints, which is 40 bytes on Windows
p47738
aVYou are trying to write 100,000 bytes from that buffer
p47739
aVThat is undefined behaviour, a buffer overrun
p47740
aVHence the access violation
p47741
aVYou must not pass a value greater than , i
p47742
ag192
aV, to the  parameter of
p47743
aVYou'll need to write this file in a loop, writing 40 bytes at a time, until you have written as much as you need
p47744
aVPerhaps something like this:
p47745
aVWriting 40 bytes at a time is pretty slow
p47746
aVYou'll find it more efficient to write a few KB with each call to
p47747
aVNote that you aren't allowed to pass  to the  parameter if you also pass  to , as you do here
p47748
aVFrom the documentation:
p47749
aVlpNumberOfBytesWritten [out, optional]
p47750
aVThis parameter can be NULL only when the lpOverlapped parameter is not NULL
p47751
as(dp47752
g7
V505088
p47753
stp47754
a((dp47755
g2
(lp47756
VIt cannot be done
p47757
aVThe default calling convention cannot be modified by compiler options
p47758
as(dp47759
g7
V505088
p47760
stp47761
a((dp47762
g2
(lp47763
VSuch characters are represented by UTF-16 surrogate pairs
p47764
aVIt takes two wide character elements to represent that code point
p47765
aVSo, you just need to call  passing the necessary surrogate pair
p47766
aVAnd naturally you need to use the wide variant of
p47767
aVPresumably you won't be hard-coding such a filename in your code
p47768
aVIn which case you'll be getting it from a file dialog, , etc
p47769
aVAnd those APIs will give you the appropriate UTF-16 encoded buffer for the file
p47770
as(dp47771
g7
V505088
p47772
stp47773
a((dp47774
g2
(lp47775
VThis looks like a flaw in the VCL to me
p47776
aVThe  style does not map to an equivalent style in Win32
p47777
aVA tool button with that style is implemented in the VCL in just the same way as a  style, but with a custom paint method
p47778
aVThis is extracted from :
p47779
aVIn the old days of pre-v6 comctl32, the  style maps to a Win32  style tool button
p47780
aVAnd in pre-v6 comctl32 that renders simply as a space with no vertical lines
p47781
aVThe VCL designers clearly wanted to do more and added  with the custom painting above
p47782
aVFast forward to v6 comctl32
p47783
aVNow the common control draws a vertical line at the left hand edge of all  separators
p47784
aVSo the code above simply adds an extra vertical line in the middle of the separator
p47785
aVWe can try to get rid of the left-hand vertical line from a  by modifying the code like this:
p47786
aVHowever, that doesn't work out because there's a lot of flickering as the left hand line is drawn and then painted over
p47787
aVI suspect that the VCL designers simply missed this arcane detail in the transition to v6 comctl32
p47788
aVI'll submit a QC report in due course
p47789
as(dp47790
g7
V505088
p47791
stp47792
a((dp47793
g2
(lp47794
VIf you include TD32 debug info in a shipping version of your application, then you also include the full source for your program
p47795
aVYou probably only want to use TD32 debug info for in-house builds, and ship a version without TD32
p47796
aVSmartBear have a utility called StripTDS
p47797
aVThis allows you have have the TD32 info external to the executable
p47798
aVIt achieves this by removing it from the executable and saving it to a separate file
p47799
aVThis may very well be what you are looking for
p47800
as(dp47801
g7
V505088
p47802
stp47803
a((dp47804
g2
(lp47805
VWhether char is signed or unsigned is implementation defined
p47806
aVClearly the char data type in your system is signed
p47807
aVSo the MSB is the sign bit
p47808
as(dp47809
g7
V505088
p47810
stp47811
a((dp47812
g2
(lp47813
VI recommend using Robert Giesecke's Unmanaged Exports
p47814
as(dp47815
g7
V505088
p47816
stp47817
a((dp47818
g2
(lp47819
VA C++ function that returns an interface does not easily map to a Delphi function
p47820
aVThe calling convention for return values that are managed types in Delphi does not match that used by C++
p47821
aVTo illustrate, I created a simple C++ test DLL that exports this function:
p47822
aVThe obvious way to map this to Delphi is like this:
p47823
aVHowever, when we call this function it always returns
p47824
aVThe workaround is exactly as suggested by Serg:
p47825
aVand we can then call it like this:
p47826
aVWhen we do this,  is not  and we can call methods on it quite happily
p47827
aVSo, what we have learnt here is that Delphi cannot easily call external functions that return interfaces, unless those external functions were also implemented in Delphi
p47828
aVBut at least we have a viable workaround
p47829
aVUnfortunately this workaround is of no immediate use to you
p47830
aVThat's because   is a C++ class
p47831
aVIt is not a COM compatible interface
p47832
aVNote that  does not implement
p47833
aVSo it doesn't provide ,  and
p47834
aVDelphi's interface support is predicated on the availability of
p47835
aVAnd this means that that you cannot use  from Delphi
p47836
aVYou will need to make a C++ bridge DLL that exposes the functionality in a way that Delphi can invoke
p47837
aVFor example by exposing plain old functions that call the C++ methods of
p47838
as(dp47839
g7
V505088
p47840
stp47841
a((dp47842
g2
(lp47843
V will elevate if the current user is an administrator
p47844
aVWhich is consistent with what you have observed
p47845
aVWhen a standard user runs the process, no UAC dialog is shown and the process runs with the standard token
p47846
aVWhen an admin user executes, the UAC consent dialog is shown and the process will then run elevated
p47847
aVIf your program requires admin rights to function then you need to use
p47848
aVWhen a standard user starts such a process, the over-the-shoulder UAC dialog is shown
p47849
aVThat gives the user an opportunity to ask an admin to supply their credentials
p47850
aVYou should only use  if your program is capable of running with a limited functionality in case the user is not able to elevate
p47851
aVThis is what is meant by mixed-mode in the MSDN topic linked by your question
p47852
as(dp47853
g7
V505088
p47854
stp47855
a((dp47856
g2
(lp47857
VYou need to use  passing
p47858
aVI don't have any code samples at hand
p47859
aVBut the basic approach will be like this:
p47860
as(dp47861
g7
V505088
p47862
stp47863
a((dp47864
g2
(lp47865
VSince you are really working with byte arrays I would declare them as such in the C# function
p47866
aVOn the Delphi side, you are currently using , but say that you would rather be using a byte array
p47867
aVI'd use  on the Delphi side then, and the function would look like this:
p47868
aVFor the error message text, I've used  and  to make the memory allocation easier
p47869
aVBecause a  is allocated of the shared COM heap, it can be allocated in the Delphi code as a  and then correctly deallocated on the other side of the boundary
p47870
as(dp47871
g7
V505088
p47872
stp47873
a((dp47874
g2
(lp47875
VIn general, it's not possible to recover from an out of memory error
p47876
aVAt that point the heap is most likely corrupted
p47877
aVThe appropriate response is to terminate the process
p47878
aVIn this specific case, the allocation is performed by  in the  unit
p47879
aVThis performs repeated allocations
p47880
aVOnly as the last act of  is the return value,  in your code above, actually assigned
p47881
aVAnd if errors occur in  then the runtime makes no effort to tidy up
p47882
aVWhich means that in case of failure, any memory allocated is leaked and cannot be recovered
p47883
aVYou have no way to refer to it in order to free it
p47884
aVYou may think that  should do more to tidy up
p47885
aVHowever, it's approach is justifiable
p47886
aVSince out of memory conditions invariably result in corrupt heap, attempts to tidy up would just prolong the agony
p47887
aVOnce the heap is dead, there's no point in trying to deallocate memory
p47888
as(dp47889
g7
V505088
p47890
stp47891
a((dp47892
g2
(lp47893
VInstead of killing the process, close it gracefully
p47894
aVIt's a bit much to expect something you just killed to carry on talking to you
p47895
aVYou'll have to come up with some way to gracefully close the process
p47896
aVExactly how is best to do that, I cannot tell from here
p47897
aVIt might be more appropriate to use a packet capture library rather than relying on external console apps
p47898
aVFor example pcap
p47899
aVnet
p47900
aVI'm sure there are other libs for this
p47901
as(dp47902
g7
V505088
p47903
stp47904
a((dp47905
g2
(lp47906
VYou have to organise the auto repeat for yourself
p47907
aVCreate an  event for the media player
p47908
aVThis fires when the song completes
p47909
aVThe code that starts the song needs to look like this:
p47910
as(dp47911
g7
V505088
p47912
stp47913
a((dp47914
g2
(lp47915
VTo get the list of running processes:
p47916
aVYou can then loop through the  array looking for your target process
p47917
aVThen you can call
p47918
aVto get hold of all the modules
p47919
aVThen you can iterate over that collection and find each  module's filename or handle
p47920
aVNote that the handle, the  in Win32 terms, is given by the  property
p47921
aVFinding out information about the exported functions is a little more difficult
p47922
aVThat information is not readily available through the
p47923
aVnet classes, and even in raw Win32 it's tricky because your code is executing out of process
p47924
aVYou can't do anything with the  from another process
p47925
aVThe way to check for existence of a function is to use the dbghelp library to parse the PE data of the actual module file
p47926
aVI couldn't find any code on the web to do this, so I produced this translation of another Stack Overflow answer of mine
p47927
aVNote that I used a number of declarations from pinvoke
p47928
aVnet
p47929
aVI hope this helps
p47930
as(dp47931
g7
V505088
p47932
stp47933
a((dp47934
g2
(lp47935
VThis is standard Unicode Delphi migration fodder
p47936
aVRequired reading is Marco Cant's paper
p47937
aVWhite Paper: Delphi and Unicode
p47938
aVIf you haven't read that, do so
p47939
aVIf you haven't read it recently, do so again
p47940
aVThe reason that  produces a warning is that the base type for sets cannot have more than 256 values
p47941
aVBut since  is now UTF-16, that's a lot more than 256
p47942
aVAll this means that your code can never work with sets and UTF-16 characters
p47943
aVYou could use  and
p47944
aVBut if you want this code to work on Unicode data then you'll need to use something other than a
p47945
aVFor example  could be used
p47946
aVI would not recommend that for production
p47947
aVIts performance characteristics will be terrible
p47948
aVA hash based dictionary would do better
p47949
aVBest of all would be a dedicated large set class
p47950
aVOne final point
p47951
aVCharacters are not the same as code points in UTF-16 which is a variable length encoding
p47952
aVThe code in question and this answer make no allowance for that
p47953
as(dp47954
g7
V505088
p47955
stp47956
a((dp47957
g2
(lp47958
VYou have to check all preceding candidates for primality
p47959
aVThere are no shortcuts
p47960
aVAs you say, you can cache the result of a prior calculation and start from there, but that's really the best you can do
p47961
as(dp47962
g7
V505088
p47963
stp47964
a((dp47965
g2
(lp47966
VThis allows you to pass a pointer by reference
p47967
aVWhich gives the function the opportunity to modify the pointer and have that modification seen by the caller
p47968
aVYou don't need to stop there
p47969
aVYou can pass by reference a pointer to pointer to int, for example
p47970
as(dp47971
g7
V505088
p47972
stp47973
a((dp47974
g2
(lp47975
VStop using floating point calculations for this
p47976
aVYou are subject to the vagaries of floating point
p47977
aVWhen I ran your program with my compiler, the output was 100
p47978
aVBut I guess your compiler treated the floating point  differently
p47979
aVA simple change to make the code behave, and use integer arithmetic only, would be like this:
p47980
aVBut I'd rather see the binary built up in a string rather than an integer
p47981
as(dp47982
g7
V505088
p47983
stp47984
a((dp47985
g2
(lp47986
VYou have tried executing the new process with the runas verb with ProcessStartInfo
p47987
aVBut that's not the same as executing the runas process from the command prompt
p47988
aVSo the simple way to replicate what you do at the command prompt is to execute the runas program passing all the parameters, just as you do from the command prompt
p47989
aVI don't understand the nuances of what you are attempting
p47990
aVHowever, if running through cmd does exactly what you need then you can do just that:
p47991
as(dp47992
g7
V505088
p47993
stp47994
a((dp47995
g2
(lp47996
VYou can achieve this by setting  to
p47997
aVThis capability is only available if you are using the full version of FastMM as opposed to the cut-down version bundled with Delphi
p47998
aVYou cannot call  because it is not declared in the interface section of the unit
p47999
aVYou could modify the source code for  to make it available
p48000
aVHowever, calling it whilst your program is running will likely yield nothing useful
p48001
aVThat will just spit out a report containing all the memory blocks that are currently allocated
p48002
aVWhich is quite different from a list of blocks that have been leaked
p48003
as(dp48004
g7
V505088
p48005
stp48006
a((dp48007
g2
(lp48008
VYou are calling , but passing it UTF-16 encoded data
p48009
aVEither switch to  or convert the module name to ANSI
p48010
aVI would do the former
p48011
aVAs well as switching to , you need to copy the entire buffer
p48012
aVAchieve that by replacing the two instances of  with
p48013
aVSome more comments:
p48014
aVUsing  is excessive
p48015
aVYou only need
p48016
aVThe  cast in  looks wrong
p48017
aVBecause  is UTF-16 encoded
p48018
aVJust use
p48019
aVOr  if you go down that route
p48020
aVUsing  for handles is wrong
p48021
aVIt doesn't actually matter, but you should use
p48022
aVWhen using  you must pass  for the size parameter
p48023
aVPut that all together and the code should look like this:
p48024
aVPersonally, I'd probably pass in a  rather than a , but perhaps you have some other motivation for doing that
p48025
as(dp48026
g7
V505088
p48027
stp48028
a((dp48029
g2
(lp48030
VThe solution is to build each project separately
p48031
as(dp48032
g7
V505088
p48033
stp48034
a((dp48035
g2
(lp48036
VWindows GUI functions have thread affinity
p48037
aVThis constraint is passed on to the VCL
p48038
aVWhich means that you can only access VCL routines from the main GUI thread
p48039
aVIn your code you have broken this rule by calling  from a thread other than the main GUI thread
p48040
aVWhen that code is mapped down to Win32 it ends up calling  with a device context that is associated with a different thread from the caller
p48041
aVThat's against the rules
p48042
aVThe solution is to abide by the rules
p48043
aVOnly call VCL functions from the main GUI thread
p48044
as(dp48045
g7
V505088
p48046
stp48047
a((dp48048
g2
(lp48049
VIt turns out that I was confused by the question
p48050
aVIn fact default properties are not relevant here because real valued properties cannot have defaults
p48051
aVAnd in fact the framework does not stream out real valued properties if they have a value of 0
p48052
aVWhich means that real value properties effectively have a hard-coded default of 0
p48053
aVWhich appears to be a monstrous design flaw in the streaming framework
p48054
aVJust imagine for a minute a real valued property which is assigned a value of  in the component's constructor
p48055
aVThis makes it impossible for the property to be assigned a value of  and have that value survive a round-trip through a
p48056
aVdfm file
p48057
aVThere is a way to work around this, but you need to override
p48058
aVThe VCL bug is found in the  unit, in
p48059
aVInside that function is this local function:
p48060
aVClearly this function should be implemented like this:
p48061
aVThe same fault appears to exist also in the handling of ,  and  properties
p48062
aVThis is such a major flaw I'd expect it to be well-known
p48063
aVI'd expect there to be a bunch of discussions of this topic already on SO, Emba forums, and some QC reports
p48064
aVAnd there it is, a QC report from the dawn of time: QC#928
p48065
aVSince that report is over 10 years old and appears moribund, I created QC#109194
p48066
as(dp48067
g7
V505088
p48068
stp48069
a((dp48070
g2
(lp48071
VTypically you want to maintain a separation between the underlying data and the visual representation of that data
p48072
aVWith that in mind, one would typically prefer to implement sorting at the GUI level rather than lower down at the data level
p48073
aVFor example, this allows you to show multiple views of the same data, differently sorted
p48074
aVThat's the sort of benefit you reap from maintaining clear separation between model and view
p48075
aVIn your case your implementations of the two options have shown a performance difference
p48076
aVWhat I would take from that is that it is possible to optimise your sorting when implemented at the GUI level
p48077
aVThat's how I would approach the problem
p48078
as(dp48079
g7
V505088
p48080
stp48081
a((dp48082
g2
(lp48083
VIt is perfectly safe to call  on a form that is owned
p48084
aVOr pass the form to
p48085
aVAnd that is the right way to dispose of your form
p48086
aVSo, this code does what you need
p48087
as(dp48088
g7
V505088
p48089
stp48090
a((dp48091
g2
(lp48092
VJPEG error 42 is reported when the stream is truncated
p48093
aVFor example, if you attempt to load a zero length file into a  then error 42 is the end result
p48094
aVIf some images display, but not all, then the most likely explanation is that the data is somehow not making the round-trip to the DB and back
p48095
aVCheck the size of the BLOB field when you write it out
p48096
aVCheck that it tallies with the size of the file when you write it to a disk file
p48097
aVCheck that the disk file is a valid JPEG
p48098
aVThen confirm that the BLOB field has the exact same length when you re-read it
p48099
aVPerhaps there's something wrong with your DB code and the stream is getting truncated
p48100
aVSo, the very first step here is to confirm that you can recover the exact same data that you originally put into the DB
p48101
aVThe only other thought I have is that the graphic in the image control is not always a JPEG
p48102
aVThe code that you use to load the image,  assumes that the data is a JPEG
p48103
aVIf you had saved something other than a JPEG then  would fail
p48104
as(dp48105
g7
V505088
p48106
stp48107
a((dp48108
g2
(lp48109
VYour C compiler clearly does not support C99 VLAs
p48110
aVWhich means that arrays have to have dimensions known at compile time
p48111
aVAnd yours does not
p48112
aVObviously you can allocate on the heap with
p48113
aVBut you have stated that you don't want to do that for performance reasons
p48114
aVIf you really must have stack allocated memory, whose size is determined at runtime, then you need to use
p48115
aVBeware that  is fraught with danger
p48116
aVStack Overflow is an ever-present danger when using , just as it is when using a C99 VLA
p48117
as(dp48118
g7
V505088
p48119
stp48120
a((dp48121
g2
(lp48122
VYou need to find the declaration of the flag values in the C++ header file
p48123
aVAnd then translate those declarations into your Delphi code
p48124
aVIt will look like this:
p48125
aVI don't have the header file so I cannot fill in the values
p48126
as(dp48127
g7
V505088
p48128
stp48129
a((dp48130
g2
(lp48131
VYou are seeing  because you are running under the debugger
p48132
aVThat's just the name of the host process used by the debugger and you cannot change that
p48133
aVWell, I suppose you could but it's not what you want to do
p48134
aVYou want to change the name used by your executable
p48135
aVWhen you run without debugging, as your users will, the application name displayed on the taskbar app popup is determined by the assembly name specified in the Application page of the project config
p48136
aVSo, just change that to whatever you want and there's nothing more to do
p48137
as(dp48138
g7
V505088
p48139
stp48140
a((dp48141
g2
(lp48142
VYou are using GetLastInputInfo to measure idle time
p48143
aVThat seems very sensible
p48144
aVSo the question boils down to
p48145
aVShould I do periodic checks in an OnIdle handler or a timer
p48146
aVOnIdle fires every time the message queue is emptied
p48147
aVIf no messages are placed in the queue, OnIdle will never fire
p48148
aVSo, OnIdle is not periodic
p48149
aVIf you want something to check inactivity regularly, then OnIdle may not work
p48150
aVA timer is certain to work
p48151
aVYou can think of it like this: the OnIdle event fires when the idle counter starts, but you need an event to fire when the idle counter expires
p48152
aVI get the feeling that the app's OnIdle is going to be firing
p48153
aVtoo often
p48154
aVIn fact your problem is the opposite of this
p48155
aVNote that you may experiment with this and find that OnIdle appears to work adequately, and fire regularly
p48156
aVFor example, if your app uses any timers then OnIdle will fire following each timer event
p48157
aVBecause the timer event comes in on the queue and once it is processed, OnIdle is fired
p48158
aVBut if your app has no timers then you can expect OnIdle not to fire at all if you stop interacting with your program
p48159
as(dp48160
g7
V505088
p48161
stp48162
a((dp48163
g2
(lp48164
VYes you can
p48165
aVYou can install all versions of Delphi side by side on a single machine
p48166
aVI'm currently sitting at a machine with D6, 2010, XE, XE2 and XE3
p48167
aVDifferent people have different ways to organise side by side installations
p48168
aVI personally remove all references to Delphi from my system PATH variable
p48169
aVThen if I need to do anything at the command line I make sure I execute the  for the target version
p48170
aVThat sets all the environment variables needed for that Delphi version
p48171
aVAt that point executing  results in the target version of the command line compiler being invoked
p48172
as(dp48173
g7
V505088
p48174
stp48175
a((dp48176
g2
(lp48177
VThe RTL code behind  calls  to test for a match to your search pattern
p48178
aVThis function only supports masking against a single mask
p48179
aVThe alternative is to use the  overload that admits a
p48180
aVYou supply a predicate that tests whether or not a name matches your pattern
p48181
aVDo note that  creates and destroys a heap allocated  every time it is called
p48182
aVI can well imagine that being a performance bottleneck over a long search
p48183
aVIn which case you could create an array of  objects from
p48184
aVAnd use those in the predicate to test
p48185
aVI've no idea whether this is a valid concern or not, just something that occurred to me whilst perusing the code
p48186
as(dp48187
g7
V505088
p48188
stp48189
a((dp48190
g2
(lp48191
VThe previous version worked by luck
p48192
aVYour code has always been broken
p48193
aVWith a string return value the p/invoke marshaller
p48194
aVcopies the context to a new string,
p48195
aVthen calls  on the pointer that the native code returned
p48196
aVFor whatever reason, you got away with that on your previous versions of Windows
p48197
aVBut it's causing a failure on your latest version of Windows
p48198
aVIt's exceedingly likely that this string will be statically allocated in the DLL
p48199
aVAnd so you should not be attempting to free it
p48200
aVLooks like you have a bit of work ahead of you
p48201
as(dp48202
g7
V505088
p48203
stp48204
a((dp48205
g2
(lp48206
VYou cannot override that method because it doesn't exist
p48207
aVThe  event is fired from  which you can override
p48208
aVIt is declared like this in :
p48209
aVThe base implementation fires both  and  events
p48210
aVIf you want to get anywhere with this endeavour you'll need to consult the source code for this control
p48211
as(dp48212
g7
V505088
p48213
stp48214
a((dp48215
g2
(lp48216
VIf it is a native DLL then you just need to place the DLL in the same folder as the executable
p48217
aVThe DLL search looks in that folder first
p48218
as(dp48219
g7
V505088
p48220
stp48221
a((dp48222
g2
(lp48223
VCall  passing the parent window as
p48224
aVYour window is the window with class name equal to
p48225
aVThe documentation states that:
p48226
aVIf a child window has created child windows of its own, EnumChildWindows enumerates those windows as well
p48227
as(dp48228
g7
V505088
p48229
stp48230
a((dp48231
g2
(lp48232
VIf all the DLLs share the same C++ runtime then they will share the same failure hook
p48233
aVHowever, it seems that some of the DLLs involved do not share runtime
p48234
aVAnd this means that you simply cannot impose your failure hook onto such a DLL
p48235
aVWhat is the right way to define a consistent global variable like this across DLLs
p48236
aVThere is no way to do that
p48237
aVIf DLLs are to share a global variable, they must all co-operate to do so
p48238
aVYou cannot impose it from the outside
p48239
aVEach DLL must opt-in
p48240
as(dp48241
g7
V505088
p48242
stp48243
a((dp48244
g2
(lp48245
VDoSomething procedures must reside outside the class hierarchy in this case
p48246
aVI can't reverse the structure, so I can't take advantage of class inheritance and polymorphism
p48247
aVFurthermore, this is just an example
p48248
aVI'd like to focus on the core question: how can I cast an object to its parent class at runtime
p48249
aVThe key to understanding this is the fact that Delphi is a statically typed language
p48250
aVRemember also that you are calling non-polymorphic procedures
p48251
aVWhich means that the type of the parameter is determined at compile time
p48252
aVAnd the overload resolution is based on that type
p48253
aVSo, overload resolution happens at compile time
p48254
aVSo, your example:
p48255
aVdoes what you want because the type of the parameter is known at compile time
p48256
aVIt's simply not possible to make anything like
p48257
aVdo what you want because the type of the parameter has to be known at compile time
p48258
aVHow can I cast an object to its parent class at runtime
p48259
aVThis is the crux of the matter
p48260
aVCasting is not a runtime construct, it is a compile time construct
p48261
aVSo the simple answer is that you cannot cast an object to its runtime type
p48262
aVIf you cannot use polymorphic dispatch then your only option is hard-coded casts
p48263
aVThe example in Cosmin's answer shows how to do that in a quite usable fashion but the fact remains that overloads are resolved at compile time
p48264
aVThere's simply no way to escape that
p48265
aVYou ask in a comment if RTTI can be helpful here
p48266
aVWell, it won't help you with any casting or overload resolution as already discussed
p48267
aVHowever, it can help you avoid lots of boilerplate hard coded casts
p48268
aVHere's a simple example:
p48269
aVOuput:
p48270
aVDoSomething_TClass1
p48271
aVDoSomething_TClass1
p48272
aVDoSomething_TClass2a
p48273
aVDoSomething_TClass1
p48274
aVDoSomething_TClass2b
p48275
aVObviously such an approach relies on you following the naming convention
p48276
aVOne of the main benefits of this approach over the hard-coded casting variants is that the order of calling the inherited methods is determined by the class hierarchy
p48277
as(dp48278
g7
V505088
p48279
stp48280
a((dp48281
g2
(lp48282
VThe PHP  function implements MD5 perfectly well
p48283
aVThe following PHP:
p48284
aVresults in this output:
p48285
aV:  b15835f133ff2e27c7cb28117bfae8f4
p48286
aV:  3590cb8af0bbb9e78c343b52b93773c9
p48287
aV\u005c": 3bd864034f446da13581129bb17f9191
p48288
aV\u005c': 024c94d6e03b6f67a86b952b914816c7
p48289
aVSo, the top two values are what you get from your Delphi code, and the same values that Ignacio obtained from Python
p48290
aVSo, there's absolutely no reason to believe that the PHP MD5 code is at fault
p48291
aVAnd the bottom two values are what your PHP code is returning
p48292
aVWhich leaves us to conclude that you are feeding your Delphi code different input from that which you feed to your PHP code
p48293
aVIf you feed them both the same input, you will get the same output
p48294
as(dp48295
g7
V505088
p48296
stp48297
a((dp48298
g2
(lp48299
VI made the following program
p48300
aVAnd found exactly what you report
p48301
aVThe evaluate/modify window reports that the function was eliminated
p48302
aVWeird
p48303
aVAnyway, I tried this, which seemed to be enough to trick it
p48304
aVPerhaps the issue is that the function is declared as being
p48305
aVAlthough in my tests, the function call was not actually being inlined
p48306
as(dp48307
g7
V505088
p48308
stp48309
a((dp48310
g2
(lp48311
VIn fact this code highlights a compiler bug in XE2
p48312
aVIn XE2, the code compiles when it should not
p48313
aVRemove the  constraint and the compilation fails with
p48314
aVE2568 Can't create new instance without CONSTRUCTOR constraint in type
p48315
aVparameter declaration
p48316
aVBut the  constraint merely states that the class has a parameterless constructor
p48317
aVThe documentation states:
p48318
aVConstructor Constraints
p48319
aVA type parameter may be constrained by zero or one instance of the
p48320
aVreserved word "constructor"
p48321
aVThis means that the actual argument type
p48322
aVmust be a class that defines a default constructor (a public
p48323
aVparameterless constructor), so that methods within the generic type
p48324
aVmay construct instances of the argument type using the argument type's
p48325
aVdefault constructor, without knowing anything about the argument type
p48326
aVitself (no minimum base type requirements)
p48327
aVThe fact that the presence or otherwise of the  constraint influences this code indicates that the XE2 compiler has a fault
p48328
aVIn XE3 the code correctly fails to compile
p48329
aVThe only way to call a constructor with the syntax  is if you are using a  constraint and are calling a parameterless constructor
p48330
aVThat is not the case here and so XE3 correctly reports a compilation error
p48331
aVYou need some casting to make it compile
p48332
aVThis is a well-known trick to get around some of the quirks of the Delphi generics implementation's handling of constructors
p48333
aVAlthough it looks messy, I believe that this code is what the language designers intended us to use
p48334
aVIn my opinion, the change in behaviour is due to a bug fix and XE3 is behaving as designed
p48335
as(dp48336
g7
V505088
p48337
stp48338
a((dp48339
g2
(lp48340
VThat's just how R is formatting the number
p48341
aVThe interop is fine and the value returned from C, and held by R has the full precision
p48342
aVIt's just the display that is rounding the value
p48343
aVoutputs
p48344
aVInstead of  use a function that outputs more precision
p48345
aVFor example:
p48346
as(dp48347
g7
V505088
p48348
stp48349
a((dp48350
g2
(lp48351
VLet's take a look at this line in your XE3 script:
p48352
aVMy guess is that you follow that up in the XE2 script with:
p48353
aVAt which point your path variable looks like this:
p48354
aVAnd so the second script fails because the paths from the first script appear earlier
p48355
aVThe elegant way to fix this is to use  and  in your scripts to isolate them from each other
p48356
aVThe hacky way to fix it is to set the path like this:
p48357
aVPlease use the elegant approach
p48358
aVWhat's more you should use pushd and popd to isolate directory changes to each script
p48359
aVIf this doesn't solve everything, do give more information
p48360
aVFor a start, error messages are very useful
p48361
as(dp48362
g7
V505088
p48363
stp48364
a((dp48365
g2
(lp48366
VThe  property returns a  which is a low-level base class
p48367
aVYou'll need to up-cast that to an appropriate derived class
p48368
aVFor example, if your action manager contains  instances then you can do this:
p48369
aVIf you are deriving custom actions from , then use that in your cast
p48370
aVObviously you might want to use  to check for the actual runtime type of the action and avoid a runtime cast error
p48371
as(dp48372
g7
V505088
p48373
stp48374
a((dp48375
g2
(lp48376
VThe  field is a variable length array inlined in a struct
p48377
aVThe actual struct will have  elements
p48378
aVYou cannot use a Delphi dynamic array here
p48379
aVIn fact you can never use a Delphi dynamic array in interop
p48380
aVSo, declare it as  just as the C code does
p48381
aVIn order to access it you'll need to disable range checking
p48382
aVAn actual instance of this record will have valid data in indices
p48383
aVFor your integral types, map  in C to  in Delphi
p48384
aVAnd  in C to  in Delphi
p48385
aVNeither of those are the same as Delphi
p48386
aVThe former is unsigned, and the latter is 64 bits wide
p48387
aVThe  type is rather awkward to work with
p48388
aVYou may prefer to declare those fields as  instead
p48389
aVThis type of struct is invariably heap allocated
p48390
aVThe heap allocation code has to work out the size needed to fit  items in the variable length array
p48391
aVIf you are allocating the buffer then you'll need the inner record in  a separately defined type so that you can conveniently name it to pass to
p48392
aVIf the API allocates then you are fine as above
p48393
as(dp48394
g7
V505088
p48395
stp48396
a((dp48397
g2
(lp48398
VSince you have not provided any code, we have to guess at what your problem is
p48399
aVSo here goes
p48400
aVForms get disabled when other forms are shown modally, and then re-enabled when the modal form is closed
p48401
aVSo most likely you show the login form modally and then hide it rather than close
p48402
aVTo close the modal form you need to set the modal form's  property
p48403
aVIf you hide rather than close, then the main form will still be disabled
p48404
aVThe key is that you must properly close the modal form before the main form can become usable
p48405
aVTypically for an app with an initial login form you organise your application's
p48406
aVdpr file like this:
p48407
aVThe first form created using  becomes your applications's main form
p48408
aVWhen the main form is closed, the entire application goes down with it
p48409
aVIn my opinion, you should use  only for creating the main form
p48410
aVAny other forms can be created using the  syntax
p48411
aVIf you follow that policy then you don't need to worry about which order your forms are created in
p48412
as(dp48413
g7
V505088
p48414
stp48415
a((dp48416
g2
(lp48417
VThat number uses scientific notation
p48418
aVThe  signifies exponentiation, in this case to base 10
p48419
aVSo this number is 2108
p48420
aVBecause calculators, computer programming languages etc
p48421
aVtypically do not use superscript notation,  is used to indicate the exponentiation
p48422
aVTo represent that number in Java, as an integer literal, write it like this:
p48423
aV200000000
p48424
aVAs @Saintali helpfully points out, in Java SE 7 and later you can use underscores in the literal to improve clarity:
p48425
aV200_000_000
p48426
aVIf the data you are reading uses scientific notation, then it represents floating point values
p48427
aVShould you really be converting this to integer data
p48428
aVIf you do need to read this in from file and then convert to int, you should read into a floating point data type and then cast to
p48429
as(dp48430
g7
V505088
p48431
stp48432
a((dp48433
g2
(lp48434
VThe
p48435
aVnet code you link to uses  which is exactly the same as
p48436
aVSo your code is already equivalent to the
p48437
aVnet code to which you link
p48438
aVAnd these both refer to the same location as
p48439
aVTake a look at the documentation for
p48440
aVIt says:
p48441
aVDefault Path        %APPDATA% (%USERPROFILE%\u005cAppData\u005cRoaming)
p48442
aVLegacy Default Path %APPDATA% (%USERPROFILE%\u005cApplication Data)
p48443
aVThe "Default Path" is what you will see on Vista or later
p48444
aVThe "Legacy Path" is what you see on XP
p48445
aVThe different behaviour that you have observed is nothing more than the expected difference between XP and Vista/7/8
p48446
aVOn my Windows machine,
p48447
aVevaluates to
p48448
aVIn other words, your code is already doing the right thing
p48449
aVYou do not need to make any changes to it at all
p48450
aVCarry on using
p48451
aVWhat is odd about this user's particular situation is that several registry keys normally found in HKEY_LOCAL_MACHINE are actually located in HKEY_CURRENT_USER
p48452
aVThat's not uncommon
p48453
aVQuite often applications configure default settings in  and then copy them to  when the application is first run
p48454
aVWithout knowing more details of the settings in question it's hard to comment on that aspect of your question
p48455
as(dp48456
g7
V505088
p48457
stp48458
a((dp48459
g2
(lp48460
VThe Delphi  type is described like this in the documentation:
p48461
aVThe TDateTime class inherits a val data member--declared as a double--that holds the date-time value
p48462
aVThe integral part of a TDateTime value is the number of days that have passed since December 30, 1899
p48463
aVThe fractional part of a TDateTime value is the time of day
p48464
aVIn  the type is declared like this:
p48465
aVYour value of  is a perfectly valid  value
p48466
aVIt represents a point in time that is  days after the Delphi date time epoch
p48467
aVCall  to convert that into human readable form
p48468
aVIf you only want to see the date part, and don't want to see the time, use  instead
p48469
aVwhich results in this output
p48470
aV06/10/2012 16:03:19
p48471
aV06/10/2012
p48472
aVIn summary, your code is functioning exactly as expected
p48473
aVThe value you see is exactly what you would expect for a
p48474
aVIf you need to represent the date time value in textual format, use the appropriate conversion function
p48475
as(dp48476
g7
V505088
p48477
stp48478
a((dp48479
g2
(lp48480
VThe icon that is displayed on the message box dialog is implemented using a  control with  style
p48481
aVYou can obtain the icon handle by sending that control the  message
p48482
aVIn the code in your question, the variable named  is actually the window handle of the  control that contains the icon
p48483
aVI'd name it
p48484
aVWith that name change, the code to obtain the icon would look like this:
p48485
as(dp48486
g7
V505088
p48487
stp48488
a((dp48489
g2
(lp48490
VWell, for a start  is declared incorrectly
p48491
aVIt's unsigned in the Windows headers and should be so in Delphi
p48492
aVIn fact I think this was corrected in a recent release of Delphi
p48493
aVI'd imagine that the preference for signed over unsigned is largely historical and not particularly significant
p48494
aVHowever, I can think of one example where it is important
p48495
aVConsider the for loop:
p48496
aVIf  is unsigned and  is 0 then this loop runs from 0 to  which is not what you want
p48497
aVUsing a signed integer loop variable avoids that problem
p48498
aVPascal is a victim of its syntax here
p48499
aVThe equivalent C or C++ loop has no such trouble
p48500
aVdue to the syntactic difference and use of a comparison operator as stopping condition
p48501
aVThis could also be the reason why  on a string or dynamic array returns a signed value
p48502
aVAnd so for consistency,  should accept signed values
p48503
aVAnd given that the return value of  is used to index strings, it should be signed also
p48504
aVHere's another Stack Overflow discussion of the topic: Should I use unsigned integers for count members
p48505
aVOf course, I'm speculating wildly here
p48506
aVPerhaps there was no design and just out of habit the precedent of using signed values was set and became enshrined
p48507
as(dp48508
g7
V505088
p48509
stp48510
a((dp48511
g2
(lp48512
VYou should follow the  message by sending the combo box a  message with  equal to
p48513
aVIt's the  that triggers the  event
p48514
aVIn Delphi the code would look like this:
p48515
aVOr you could use the  message instead which would perhaps be a little more direct:
p48516
aVYou'll want to translate that into whichever
p48517
aVnet language you are using, but I'm sure that's easy for you
p48518
as(dp48519
g7
V505088
p48520
stp48521
a((dp48522
g2
(lp48523
VYou are nearly there
p48524
aVYou need to use the concatenation operator, , on both sides of the variable:
p48525
aVI'm not quite sure I understand what you are getting at regarding the quotes
p48526
aVIf you want to include a double quote in a string then you need to escape it by writing
p48527
aVSo the way to create a string with just a single character that is a double quote is like this
p48528
as(dp48529
g7
V505088
p48530
stp48531
a((dp48532
g2
(lp48533
V uses
p48534
aVAlmost all Win32 APIs do so
p48535
aVThey never use
p48536
aVThe function is declared as:
p48537
aVso your mistake is simply that your version has too many parameters
p48538
aVThe pinvoke
p48539
aVnet declaration that you have found is correct
p48540
aVThe  convention pushes params right to left which explains how your code worked even with an extra spurious parameter
p48541
as(dp48542
g7
V505088
p48543
stp48544
a((dp48545
g2
(lp48546
VYou are not meant to send the
p48547
aVIt's a specially synthesised message
p48548
aVYou never post it or send it
p48549
aVInstead you call  or one of the related functions to get the system to generate
p48550
aVAnd you are not meant to draw on a window outside of a  message handler
p48551
aVOr from a thread other than the GUI thread
p48552
aVPerhaps you aren't doing any of those things, but they are common mistakes so it doesn't hurt to mention it
p48553
aVIf  does not work then something fundamental is wrong with your code
p48554
aVYou need to fix that rather than try to make painting work by some other mechanism
p48555
aVSo, the solution is to use  and fix whatever is broken in your  handler
p48556
aVWithout seeing your  handler I would not like to speculate as to what is wrong
p48557
as(dp48558
g7
V505088
p48559
stp48560
a((dp48561
g2
(lp48562
V is an instance method
p48563
aVWhich means that in order to call it you must have an instance on which to invoke it
p48564
aVOn the other hand,  is a function pointer
p48565
aVIt is compatible with plain functions rather than instance methods
p48566
aVThey are simply not compatible
p48567
aVIn order for  to be compatible with  you need to define it as:
p48568
aVThe  indicates that this type is compatible with instance methods
p48569
aVA variable of type  (as defined in this answer) holds both a function pointer and an instance pointer
p48570
aVIt is sometimes referred to as a two pointer function type
p48571
aVBefore you proceed I recommend that you read carefully the documentation
p48572
aVI note that you are using  calling convention for these function pointers
p48573
aVThis usually indicates that you are attempting interop with external modules
p48574
aVThat's not something that is reliable with instance methods
p48575
aVWhat I mean by this is that you cannot implement an  instance method in a language other than Delphi
p48576
aVIf this code is destined for use in an interop setting then you should refrain from using
p48577
aVFor an interop setting you would normally include the instance pointer as a separate parameter
p48578
aVIn which case the Delphi declaration would look like this:
p48579
aVYou would then implement such a function like this
p48580
aVFinally, the function in the external module that is passed the callback would need to be passed both  and the instance pointer for the  instance
p48581
aVPerhaps a little like this:
p48582
aVwhich you would call like this:
p48583
aVHaving looked at the C++ code at the related question it seems that the C++ side of the interface looks like this:
p48584
aVThis callback doesn't even admit a data pointer so you cannot use an instance method at all
p48585
aVQuite how you are meant to implement callbacks for multiple instances is beyond me
p48586
aVAnyway, you can declare this function in Delphi like this:
p48587
aVTo call it you'll need this:
p48588
as(dp48589
g7
V505088
p48590
stp48591
a((dp48592
g2
(lp48593
VIt's all changed in XE3
p48594
aVThe platform support has been completely overhauled
p48595
aVSee Pawel Glowacki's article for more
p48596
aVIn spite of the overhaul, this is still not much use if you have multiple monitors
p48597
aVPerhaps there is some multimon support in FMX2, but it's clearly not available in
p48598
as(dp48599
g7
V505088
p48600
stp48601
a((dp48602
g2
(lp48603
VYou are looking for
p48604
aVFor example:
p48605
aVI've little idea what you mean when you say I must also be able to store the value through a pointer
p48606
aVUpdate: Looking at your updated question, I can imagine what is happening
p48607
aVThe code that reads the choice, i
p48608
ag192
aVthe number 1, 2, etc
p48609
aVis not reading the newline
p48610
aVThen you call  which consumes the newline
p48611
aVAnd then you call  again which fetches the string
p48612
as(dp48613
g7
V505088
p48614
stp48615
a((dp48616
g2
(lp48617
VAccording to the documentation, you need to call
p48618
aVrepeatedly to read the stream
p48619
aVYou pass a buffer to that function and the function fills it out with the next part of the stream
p48620
aVWhen the function returns 0 it means that the entire stream has been read
p48621
aVThe code would be something like this:
p48622
aVThe documentation I'm looking at has the function named
p48623
aVBut your import unit seems to call it
p48624
aVI'm not sure where that discrepancy comes from
p48625
aVI'm also not convinced by the header translation that you use
p48626
aVI would write  instead of  and I would write  instead of
p48627
as(dp48628
g7
V505088
p48629
stp48630
a((dp48631
g2
(lp48632
VPerhaps you are creating the browser instance in a different thread from which you then issue subsequent calls
p48633
aVThe following trivial code works exactly as expected:
p48634
aVI'm not using  because I don't have the import unit handy
p48635
aVBut that won't change anything \u2013 your problems will not be related to early/late binding
p48636
aVObviously  runs in the GUI thread
p48637
aVAnd  is a button  event handler
p48638
aVAnd so it runs in the main GUI thread
p48639
aVIf you are calling your  function from a thread other than the GUI thread, that would explain your errors
p48640
aVIf you access the browser on a thread other than the one on which it was created, you will receive an  with message The application called an interface that was marshalled for a different thread
p48641
aVFinally, a word of advice when asking questions
p48642
aVIf you receive an error message, make sure you include that exact error message in your question
p48643
aVDoing so makes it much more likely we can provide good answers
p48644
as(dp48645
g7
V505088
p48646
stp48647
a((dp48648
g2
(lp48649
VIt looks to me as though your design is that:
p48650
aVThe main thread only ever switches the  flag from  to
p48651
aVThe worker thread only ever switches the flag in the opposite direction
p48652
aVNo code other than what we see here accesses the array
p48653
aVIf that is true, the original code without the critical section is already thread safe
p48654
aVAt least it is on hardware that uses a strong memory model
p48655
aVFor example the Intel x86 or x64 architectures
p48656
aVThe  boolean acts as a synchronisation barrier between the threads
p48657
aVHowever, your entire design looks flawed to me
p48658
aVThe  loop and the  causes me some alarm
p48659
aVThat thread is going run repeatedly for no good reason
p48660
aVSurely you should only be executing the code in the thread when the main thread has made modifications to the array
p48661
aVI'd prefer the use of a signal (for example a Windows event) to wake up the thread
p48662
as(dp48663
g7
V505088
p48664
stp48665
a((dp48666
g2
(lp48667
VAccording to all my research, the function is in fact named
p48668
aVYou can check what functions your DLL exports using Dependency Walker, for example
p48669
aVOf course, the definitive source for your library should be the C++ header file that it is supplied with
p48670
aVMy advice would be to start learning how to use LIBRTMP using C or C++
p48671
aVAt the moment you don't know whether errors are due to a bad translation of the interface, or due to calling it incorrectly
p48672
aVIf you continue using Delphi then you'll forever be struggling to work out the cause of errors
p48673
aVHowever, switch to C or C++ and you already have the header file that is needed to link to the library
p48674
aVYou can compile the demo programs that come with RTMPDUMP and observe how they work
p48675
aVYou can use them as your documentation since LIBRTMP itself appears to have none (not that I can find)
p48676
aVThen, once you understand how the library works, start porting it do Delphi
p48677
aVFirst of all create the simplest possible C++ program that uses the library
p48678
aVPort that to Delphi
p48679
aVHaving a running C++ version of the program to compare against will help you isolate faults
p48680
aVEventually you'll have a functioning Delphi translation of the interface
p48681
aVMore importantly you'll actually understand how to call the library
p48682
aVIf you carry on down your current path you'll make very slow progress
p48683
as(dp48684
g7
V505088
p48685
stp48686
a((dp48687
g2
(lp48688
VThe call to  results in the file being opened for writing
p48689
aVThat's because the default value of  is
p48690
aVSince your app runs virtualized, and since your user token does not have admin rights, the virtualization layer kicks in and creates a copy of the file in the virtual store
p48691
aVThe solution that is available using legacy Pascal I/O is to set  to
p48692
aVThen  will open the file for reading and the virtualization layer will not be invoked
p48693
aVRemember that  is a global variable that affects all legacy Pascal I/O
p48694
aVWoe betide you if you have threads, or forget to set  back to  when you need to write a file
p48695
aVRevolting isn't it
p48696
aVProcess wide global flags to control file access mode
p48697
aVWell, this stuff was invented long before applications had threads
p48698
aVAnd long before OOP was invented
p48699
aVSo I can understand why it is so
p48700
aVThe lesson to take away from this is that it is time to switch to one of the modern forms of file access
p48701
aVFor example,
p48702
aVIndeed, it's also time that you disabled virtualization in your application
p48703
aVVirtualization was introduced in Vista, nearly 6 years ago
p48704
aVIt was meant as a help for old programs that had not yet been re-compiled for Vista
p48705
aVYour application should not be using it still
p48706
as(dp48707
g7
V505088
p48708
stp48709
a((dp48710
g2
(lp48711
VYou used to be able to, but it cost Google too much money to allow 3rd parties to piggyback on their service
p48712
aVSo you can't do that using an API anymore: http://news
p48713
aVcnet
p48714
aVcom/8301-17939_109-10193024-2
p48715
aVhtml
p48716
as(dp48717
g7
V505088
p48718
stp48719
a((dp48720
g2
(lp48721
VThere are two bugs here
p48722
aVFirst of all in
p48723
aVWhen the dynamic array is  this erroneously returns a low/high bounds pair of
p48724
aVIt should return
p48725
aVThis bug is fixed in the latest versions of Delphi
p48726
aVThat causes  to return a variant array with a single, empty, element
p48727
aVThe second bug affects the other direction,
p48728
aVThis bug is still present in the latest versions of Delphi
p48729
aVThis bug is in
p48730
aVThere is a  loop which walks over the input variant array and populates the output dynamic array
p48731
aVWhen the input variant array is empty, it should not enter that  loop
p48732
aVHowever, the code erroneously does so and attempts to read an element of the variant array with
p48733
aVSince the array is empty, that provokes a runtime error
p48734
aVI have reported this: QC#109445
p48735
aVHere is a very simply bit of code that fixes the bugs
p48736
aVNote that I have only consider the case where the arrays are one dimensional
p48737
aVIf you need to support higher dimensional arrays then you can extend this approach to do so
p48738
as(dp48739
g7
V505088
p48740
stp48741
a((dp48742
g2
(lp48743
V is indeed just what you need
p48744
aVHere's a simple example:
p48745
aVThe code in the question is failing to call  which is probably why it fails
p48746
aVOr perhaps the the class declaration omits the  directive on
p48747
aVNo matter, it's cleaner the way I have it in this answer
p48748
as(dp48749
g7
V505088
p48750
stp48751
a((dp48752
g2
(lp48753
VThe first comment to make is that your basic design is very weak
p48754
aVYou have mixed the sorting code and the compare/exchange code all in together
p48755
aVIf ever you need to sort different data, then you'll have to start again
p48756
aVYou need to decouple the sorting code from the code that understands the data
p48757
aVThe way to achieve that decoupling is to implement a generic sort routine that knows nothing about the data
p48758
aVInstead all it needs to know is how to compare two elements, and how to exchange two elements
p48759
aVAll the common in-memory sorting routines can be implemented efficiently that way
p48760
aVThe other problem you have, I guess, is that your code will spend a lot of time copying the data around
p48761
aVInstead of doing that, use a layer of indirection
p48762
aVWhat I mean by that is that you should not attempt to modify the original array
p48763
aVInstead create an array of indices into the data array, and sort the array of indices rather than the array of data
p48764
aVTo give you an idea of that, here's how it might look:
p48765
aVThen, in order to sort the array you do something like this:
p48766
aVOr, as yet another alternative, instead of an array of indices, use an array of pointers to the elements of the data array
p48767
aVNow, I've used global variables here for the sake of clarity of exposition
p48768
aVIn reality you'd likely want to wrap this up into a class, or at least make the compare and swap functions be methods of objects
p48769
aVThat's how I did it in my Delphi 6 code base
p48770
aVThe interface looked like this:
p48771
aVOnce you get on top of the concept of separating the sort algo from the data then you'll make some progress
p48772
aVIt then becomes trivial to swap out one sorting algo for another
p48773
aVYou can compare them easily
p48774
aVYou can readily measure whether or not the indirection approach is worthwhile
p48775
aVAnd so on
p48776
aVSo, my absolute number one piece of advice for you is to throw away the code in the question and separate sorting from data handling, as nature intended
p48777
as(dp48778
g7
V505088
p48779
stp48780
a((dp48781
g2
(lp48782
VAs you know, because it was the subject of your previous question, you need all calls to the COM object to be made from the same thread
p48783
aVThe obvious choice is the main GUI thread
p48784
aVSo, create the  in your main form's  event handler
p48785
aVAnd then use  or  whenever you need to show the browser
p48786
aVThe code that you pass to  or  will be executed on the main GUI thread
p48787
aVAssuming you are using a modern version of Delphi with support for anonymous methods you'd write it like this:
p48788
as(dp48789
g7
V505088
p48790
stp48791
a((dp48792
g2
(lp48793
VIf all you have in the record is an object reference, then you can't get the compiler to help you
p48794
aVYou are in sole charge of the lifetime of that object
p48795
aVYou cannot overload the assignment operator, and you don't get any notification of scope finalisation
p48796
aVWhat you can do though is to add a guard interface that will manage the lifetime of the object
p48797
aVYou need to make sure that  manages its lifetime by reference counting
p48798
aVFor example by deriving from
p48799
aVWhen you initialise the record you do this:
p48800
aVAt this point, the  field of the record will now manage your object's lifetime
p48801
aVIn fact, if you want to push this idea further, you can build a dedicated class to guard the lifetime of objects
p48802
aVThat then no longer constrains you to implement  on your class
p48803
aVThere are plenty of examples on the web that illustrate the technique
p48804
aVFor example I offer Jarrod Hollingworth's article titled Smart Pointers, and Barry Kelly's titled Reference-counted pointers, revisited
p48805
aVThere are many more out there
p48806
aVIt's an old trick
p48807
aVNote however, that what you have here is a strange hybrid of value type and reference type
p48808
aVOn the face of it, records are value types
p48809
aVHowever, this one acts like a reference type
p48810
aVIf you have other fields in the record that are value types then that would be even more confusing
p48811
aVYou'll need to be very aware of this issue when you work with such a record
p48812
aVOn the face of it, without knowing more about your design, I'd be inclined to advise you not to put object references in records
p48813
aVThey fit better inside reference types, i
p48814
ag192
aVclasses
p48815
as(dp48816
g7
V505088
p48817
stp48818
a((dp48819
g2
(lp48820
VYour code is just fine
p48821
aVThe most likely explanation is that your calculator is in  mode and so treats the argument to  as an angle measured in degrees
p48822
aVComputer code like MATLAB code always use radians rather than degrees
p48823
aVSwitch your calculator to  mode and the two evaluations will agree
p48824
as(dp48825
g7
V505088
p48826
stp48827
a((dp48828
g2
(lp48829
VFirst of all, I am assuming that your question concerns Delphi, despite the Free Pascal tag
p48830
aVI'm basing that assumption on the fact that you quote the Delphi documentation
p48831
aVA Windows API message should be converted into an exception by calling
p48832
aVThis will raise an
p48833
aVThat is a native Delphi exception
p48834
aVThe  exception is unrelated
p48835
aVThat's what is used when the RTL converts a system trap, e
p48836
ag217
aVaccess violation, maths errors etc
p48837
aVinto a native exception
p48838
aVNote that Win32 is commonly used to refer to both the 32 and 64 bit Windows API
p48839
aVThere's really only one interface with both 32 and 64 bit variants
p48840
aVThe underlying exception handling model is completely different between 32 and 64 bit Windows
p48841
aVThe 32 bit model is stack based and the 64 bit model is table based
p48842
aVThis means that the implementations of exception handling, and try/finally, are completely different between 32 and 64 bit architectures
p48843
aVThe original implementation in XE2 of the 64 bit table based model had a large number of faults
p48844
aVI am pleased to say that, following a number of QC reports submitted by myself and others, the implementation in XE3 is much improved
p48845
aVStack Overflow is not the place to go into the low-level details of the exception handling ABI of these two architectures
p48846
aVInstead I offer the following articles:
p48847
aVA Crash Course on the Depths of Win32\u2122 Structured Exception Handling
p48848
aVx64 Structured Exception Handling
p48849
as(dp48850
g7
V505088
p48851
stp48852
a((dp48853
g2
(lp48854
VWell, I think that you could use
p48855
aVThis is not 100% reliable
p48856
aVIt's possible for the clipboard to contain data, and for this function to return
p48857
aVFor a start, the clipboard could have been filled by something other than a control, but I expect there are plenty of ways for the clipboard to be full of data, and have no owner window
p48858
aVBut so long as your app doesn't do anything too non-standard with the clipboard, I think it would do the job for you
p48859
aVIf you want to be 100% sure of which control in your app filled the clipboard with data, keep track yourself of the last control to fill the clipboard
p48860
as(dp48861
g7
V505088
p48862
stp48863
a((dp48864
g2
(lp48865
VThis looks more like C code than C++, so I'll stick to that style
p48866
aVI can't understand why you would be using
p48867
aVYou only need that for DDE which I cannot possibly imagine you are using here
p48868
aVUse  or  if this really is C++
p48869
aVIf you really are using a DDE API that requires , then keep the  part separate from the string reversing code
p48870
aVMixing the two concerns makes for unmaintainable code
p48871
aVIf this really is C++ then  is what you should be using wherever possible
p48872
aVI also think there's great confusion with all the casting and all the non-standard Windows type macros
p48873
aVIt makes the code pretty much unreadable
p48874
aVThere is also an indexing error as pointed out by Maximus
p48875
aVFor what it is worth, I'd write the function something like this:
p48876
aVThe only cast you need is the return value of
p48877
aVIf you were to use  then you would not even need to do that
p48878
aVIn which case the code would be like this:
p48879
aVOne should always strive to write code without casts
p48880
aVDon't do pointer arithmetic yourself when the index operator  can be used
p48881
aVIt's much easier to read this way
p48882
as(dp48883
g7
V505088
p48884
stp48885
a((dp48886
g2
(lp48887
VIt depends on the specific implementation of the pseudo random number generator (PRNG) in question
p48888
aVThere are a great many variants in use
p48889
aVA common example is the family of linear congruential generators (LCGs)
p48890
aVThese are defined by a recurrence relation:
p48891
aV  Xn+1 <- aXn + c  (mod m)
p48892
aVSo each new sample from the PRNG is determined solely by the previous sample, and the constants a, c and m
p48893
aVNote that the choice of a, c and m is crucial, as discussed here
p48894
aVLCGs are very simple and efficient
p48895
aVThey are often used for the random number generators provided by the standard library
p48896
aVHowever, they have poor statistical properties and for better randomness, more advanced PRNGs are preferred
p48897
as(dp48898
g7
V505088
p48899
stp48900
a((dp48901
g2
(lp48902
VThe naive answer to the question is to listen to  and respond to a  value of
p48903
aVThe other obvious possibility is to make all the tool windows be owned by the main window
p48904
aVSo long as you are happy for the tool windows always to be on top of the main window, this will solve your problem
p48905
aVThe owned windows will be hidden when the owner is minimized, and re-shown when the owner is restored
p48906
aVLearn more about ownership in the MSDN topic on Window Features
p48907
as(dp48908
g7
V505088
p48909
stp48910
a((dp48911
g2
(lp48912
VYou have the following problems that I can see:
p48913
aVThe function has been exported by ordinal rather than name
p48914
aVYou need to specify the ordinal in your Delphi code
p48915
aVThe first parameter should be PAnsiChar rather than a Delphi string
p48916
aVThe VB code uses string to instruct the marshaller to pass a null-terminated string
p48917
aVAs a rule of thumb, it's almost always a mistake to include a Delphi managed stype like string in a DLL import or export
p48918
aVThe final parameter is passed by reference
p48919
aVThat's a Delphi var parameter
p48920
aVThe return value should be BOOL, I think, but that probably won't be causing you trouble
p48921
aVPut it all together like this:
p48922
aVNote that I'm not 100% sure that the text encoding is ANSI
p48923
aVHowever, the main blockage for you was the ordinal import
p48924
aVI hope I've cleared that for you
p48925
aVI trust you can resolve the remaining details
p48926
as(dp48927
g7
V505088
p48928
stp48929
a((dp48930
g2
(lp48931
V makes the assumption that the edit box text is non-empty, i
p48932
ag192
aVhas at least 1 single character
p48933
aVWhen the edit box text is empty, the  property is the empty string and accessing the first character leads to an access violation
p48934
aVI note that you are setting the edit box text to the empty string explicitly, and of course the user can do so
p48935
aVSo you certainly have to guard for that eventuality
p48936
aVSolve the problem by checking whether or not the edit box is empty
p48937
aVThe other possible candidate for an access violation is if  results in an out of bounds access of the array
p48938
aVPerhaps your mathematics with the Tag field is all messed up
p48939
aVIt looks pretty weird to me
p48940
aVAs I state below,  would appear to make more sense here
p48941
aVMore general comments:
p48942
aVYou really need to separate the presentation, i
p48943
ag192
aVthe GUIm from the underlying data
p48944
aVYou really don't want to be solving with a 4D array of visual controls as your input data
p48945
aVDon't keep repeating
p48946
aVRead that value once into a local variable
p48947
aVOr perhaps store  into a local variable
p48948
aVWhy are you calculating , ,  and  at all
p48949
aVSurely  is all you need
p48950
aVEven if you do have to calculate these, don't keep repeating yourself by writing  more than once
p48951
aVStore that reference into a local variable and use that in any subsequent reference
p48952
aVIf you need to calculate , ,  and  from , don't do it inline in an event handler
p48953
aVPut that calculation in a dedicated helper method
p48954
aVAnd likewise a dedicated helper method that goes in the opposite direction
p48955
aVAnd test that those functions are indeed inverses of each other
p48956
aVTo give you an example, those helpers could look like this:
p48957
as(dp48958
g7
V505088
p48959
stp48960
a((dp48961
g2
(lp48962
VWhat you are creating with  is not a symbolic link
p48963
aVIt is an NTFS junction
p48964
aVYou can create junctions without admin rights, but you need  to create a symbolic link
p48965
aVAnd by default only admin tokens have
p48966
aVSo, you need to create a junction
p48967
aVThis Code Project article shows you how to do that: http://www
p48968
aVcodeproject
p48969
aVcom/Articles/194/Windows-2000-Junction-Points
p48970
as(dp48971
g7
V505088
p48972
stp48973
a((dp48974
g2
(lp48975
VThis is just a consequence of how Delphi's form streaming mechanism works
p48976
aVWhen you open a form in the Delphi designer, the
p48977
aVdfm file is used to create instances of each component on the form
p48978
aVIn your case, the form designer will instantiate each of the objects in the
p48979
aVdfm file
p48980
aVEach property in the
p48981
aVdfm file will be read in
p48982
aVThen, if you do anything in the designer that marks the form as having been modified, for example changing the active tabsheet, then the designer will re-create the
p48983
aVdfm file when you save
p48984
aVAnd it re-creates the
p48985
aVdfm file by asking the in-memory components to save themselves
p48986
aVThis saving process makes no account of what the
p48987
aVdfm file on disk looks like
p48988
aVEach component just saves its properties as they are at that point in time
p48989
aVSo, in summary, there's really nothing you can do to change Delphi's behaviour
p48990
aVThe best you can do is to work around it to minimise the impact
p48991
aVIf your forms have  then you should make sure that all developer machines use the same font scaling
p48992
aVOtherwise when developer A saves at one font scaling, that
p48993
aVdfm file will be completely different from the one that developer B saves at a different font scaling
p48994
aVAll positions will be altered
p48995
aVIt sounds as though you have some developers that use 120dpi font scaling
p48996
aVAnd that's going to give you no end of grief
p48997
aVIf benign edits to the form file result in large changes, commit those changes
p48998
aVOnce you have every developer machine configured the same way, you'll find things settle down
p48999
aVThose benign edits should no longer result in
p49000
aVdfm file changes
p49001
aVThis is just one of the occupational hazards of visual design with Delphi
p49002
aVYou need to pay lots of care and attention to your
p49003
aVdfm files whenever you commit
p49004
aVI regularly find myself reverting changes to
p49005
aVdfm files from the Tortoise commit dialog
p49006
aVI also often elect to modify the
p49007
aVdfm file in a text editor rather than using the form designer
p49008
as(dp49009
g7
V505088
p49010
stp49011
a((dp49012
g2
(lp49013
VI'm assuming that you have an ordinal value rather than a variable of this enumerated type
p49014
aVIf so then you just need to cast the ordinal to the enumerated type
p49015
aVLike this:
p49016
as(dp49017
g7
V505088
p49018
stp49019
a((dp49020
g2
(lp49021
VYou can use the system's file associations to do the printing
p49022
aVThis relies on the machine having programs capable of printing all the document types you are interested in
p49023
as(dp49024
g7
V505088
p49025
stp49026
a((dp49027
g2
(lp49028
VThe  resource is documented on MSDN
p49029
aVA typical such resource script looks like this:
p49030
aV1 VERSIONINFO
p49031
aVFILEVERSION 1,12,2,12993
p49032
aVPRODUCTVERSION 1,12,2,12993
p49033
aVFILEOS 0x40004L
p49034
aVFILETYPE 0x1L
p49035
aVBEGIN
p49036
aVBLOCK "StringFileInfo"
p49037
aVBEGIN
p49038
aVBLOCK "000004E4"
p49039
aVBEGIN
p49040
aVVALUE "CompanyName", "My Company\u005c0"
p49041
aVVALUE "FileDescription", "My Program\u005c0"
p49042
aVVALUE "FileVersion", "My Program\u005c0"
p49043
aVVALUE "LegalCopyright", "My Company 2012\u005c0"
p49044
aVEND
p49045
aVEND
p49046
aVBLOCK "VarFileInfo"
p49047
aVBEGIN
p49048
aVVALUE "Translation", 0x0000 0x04E4
p49049
aVEND
p49050
aVEND
p49051
as(dp49052
g7
V505088
p49053
stp49054
a((dp49055
g2
(lp49056
VThis is the third similar question you have asked on this topic
p49057
aVI'll attempt to give you some background information and help you work out what is going on
p49058
aVFirst of all it's important to know that msvcrt
p49059
aVdll is a system component
p49060
aVIt is not the MSVC runtime
p49061
aVIt is supplied as part of Windows
p49062
aVBack in the bad old days, in the mid-90s, a lot of devlopers assumed that the MSVC6 runtime was always available
p49063
aVAnd they neglected to install that runtime as part of their program's installation
p49064
aVThis occasionally caused trouble when the install program happened to find a machine without MSVC6
p49065
aVThe MSVC team moved to differently named runtime DLLs, msvcrt70
p49066
aVdll, msvcrt80
p49067
aVdll and so on
p49068
aVAnd they educated the developers that installing the MSVC runtime should be part of all MSVC application's installation programs
p49069
aVBut the Windows team wanted to help out legacy apps that had installers that assumed MSVC6 runtime was available
p49070
aVSo they took the MSVC6 runtime under their control and started shipping it with Windows
p49071
aVI think this started around the time of Windows 2000 or XP
p49072
aVThe point I am trying to make is that msvcrt
p49073
aVdll is a system DLL over which you have no control
p49074
aVIn your previous questions you have described your attempts to modify that DLL
p49075
aVDon't do that
p49076
aVNow, from what I can glean, the version of msvcrt
p49077
aVdll that shipped with 2003 server does not export a function named
p49078
aVHardly surprising since SSE floating point was not widely available back in the days of 2003 server
p49079
aVClearly something in your system is resulting in an attempt to import
p49080
aVYou should be able to work out what is provoking this by using Dependency Walker
p49081
aVUse the functions on the Profile menu to start your application and study closely the logs
p49082
aVYou should be able to see the chain of events that lead to an attempt to link to
p49083
aVI'd be surprised if any of the Windows code linked to msvcrt
p49084
aVdll
p49085
aVThat library is provided purely as a prop for legacy apps that link against MSVC6
p49086
aVBut you never know
p49087
aVAlso try loading your executable in Dependency Walker
p49088
aVLook at the list of imported DLLs
p49089
aVCheck to see if msvcrt
p49090
aVdll is in the list
p49091
aVIf so, see what functions your executable imports, and if  is in that list
p49092
aVIf so then you'll be able to find it somewhere in the Delphi source code
p49093
aVFrom the various similar sounding reports on the web I suspect that the problem you face is benign
p49094
aVMany of the people reporting the same issue can OK the dialogs and have their program continue without problem
p49095
aVThis suggests that you can simply suppress the error reporting and so solve your problem
p49096
aVUse the  function to do so
p49097
aVYou want to include the  flag
p49098
aVBe aware that  has a rather perverse interface
p49099
aVAlmost all code that I have ever seen uses it incorrectly
p49100
aVIncluding the code in the Delphi RTL, and so many of the commonly used Delphi third party libraries
p49101
aVRaymond Chen, as usual, explains how to use it correctly
p49102
aVCould switching compilers provoke the behaviour change
p49103
aVCertainly they could
p49104
aVEither the library code that you are using is implemented differently
p49105
aVOr perhaps the error mode is somehow  different at the crucial moment
p49106
as(dp49107
g7
V505088
p49108
stp49109
a((dp49110
g2
(lp49111
VThe following article by Aaron Margosis covers exactly this topic: FAQ: How do I start a program as the desktop user from an elevated app
p49112
aVThe basic idea is to obtain the user token of the shell process, i
p49113
ag192
aV, make a primary token from that and finally launch the new process with that token
p49114
aVThe article includes some C++ code which should be easy enough to translate to Delphi
p49115
aVIt also includes the following itemised list outlining the approach:
p49116
aVEnable the SeIncreaseQuotaPrivilege in your current token
p49117
aVGet an HWND representing the desktop shell (GetShellWindow)
p49118
aVGet the Process ID (PID) of the process associated with that window (GetWindowThreadProcessId)
p49119
aVOpen that process (OpenProcess)
p49120
aVGet the access token from that process (OpenProcessToken)
p49121
aVMake a primary token with that token (DuplicateTokenEx)
p49122
aVStart the new process with that primary token (CreateProcessWithTokenW)
p49123
as(dp49124
g7
V505088
p49125
stp49126
a((dp49127
g2
(lp49128
VThe code in the question produces the expected output in XE2 update 4
p49129
aVNote that update 3 produces the bad output and so clearly the fix arrived with update 4
p49130
aVAlso, XE3 produces the expected output
p49131
as(dp49132
g7
V505088
p49133
stp49134
a((dp49135
g2
(lp49136
VSince you are compiling your own version of a Delphi unit, you can disable debug info in that unit
p49137
aVAdd  to the source code of the unit(s) in question
p49138
as(dp49139
g7
V505088
p49140
stp49141
a((dp49142
g2
(lp49143
VAssuming that the underlying data type is , and that the array is 1-dimensional, the way I would solve this is as follows:
p49144
aVIf the underlying element type is something else, e
p49145
ag217
aV,  etc
p49146
aV, it should be obvious how to modify this to match
p49147
as(dp49148
g7
V505088
p49149
stp49150
a((dp49151
g2
(lp49152
VUse FindWindow or EnumWindows to find the top level window of the target application
p49153
aVCall EnumChildWindows to enumerate all children of the top level window
p49154
aVIn the enumeration callback use GetClassName to check for the desired window class
p49155
aVIt would be EDIT for a raw Win32 edit window, for example
p49156
aVUse a tool like Spy++ to understand the structure of the target app, and find out the precise window class names that it uses
p49157
aVYour questions in the comments about how to call  got me thinking
p49158
aVIf you are using XE3, you could write a simple type record helper for  to make it syntactically cleaner to get hold of the class name:
p49159
aVAnd then you can write  to obtain the window class name
p49160
aVOf course, if you are not using XE3 you can do it like this:
p49161
aVNote that I am using a buffer length of 256 since window class name lengths are limited to be no longer than that
p49162
aVRegarding the code in the update, you must not use an instance method for the callback
p49163
aVThe callback must be declared like this:
p49164
aVThis is made clear in the documentation
p49165
aVUnfortunately the declaration of  in  completely abandons type safety of the callback function
p49166
aVSo you have to get it right without help from the compiler
p49167
aVNote also that  and  are not the same thing
p49168
aVDon't mix them up
p49169
as(dp49170
g7
V505088
p49171
stp49172
a((dp49173
g2
(lp49174
VThis behaviour is what happens when you modify a non-calculated field
p49175
aVThe  event should not make any modifications to non-calculated fields
p49176
aVI know nothing about your database structure, but if my hunch is correct, you are modifying a non-calculated field somewhere in the  event handler
p49177
aVAnd because you modify a non-calculated field, the calculated fields need to be re-calculated
p49178
aVAnd so  is called
p49179
aVWhich modifies a non-calculated field
p49180
aVAnd, well, you can see where this is going
p49181
as(dp49182
g7
V505088
p49183
stp49184
a((dp49185
g2
(lp49186
VDon't use  as a return value in a p/invoke call
p49187
aVThat will assume that the memory was allocated using  and so will result in the marshaller calling  on the returned pointer
p49188
aVThat leads to runtime errors
p49189
aVOne option is that you could change the native code to use  for the memory that it allocates to be returned to C#
p49190
aVIf you did that then you can just carry on using  in your p/invoke return value
p49191
aVThe alternative is to use  as now,  on the C# side, and export a deallocator from your native code
p49192
aVTo convert from  to string use
p49193
aVOnce you've done that you can pass the pointer back to your native DLL so that it can call  on it
p49194
aVThat would look like this:
p49195
aVAnd you call it like this:
p49196
aVAnd you'll need to do something similar for each of your p/invoke calls that returns a string
p49197
aVWhether or not you need to deallocate these pointers is not 100% clear
p49198
aVIt depends on whether or not you allocated the memory down the C++ code
p49199
aVFor example,  maps onto a call to
p49200
aVAnd that returns a pointer to a buffer owned by the sockets library
p49201
aVSo your code must not attempt to free it
p49202
aVBut if you return memory that was allocated with  or , then you've got to free it also
p49203
aVA few other observations:
p49204
aVYou are returning sockets that are declared as  in the C++ code but typing them as   in your C wrappers
p49205
aVDon't do that
p49206
aVUse  all the way through
p49207
aVThe C# type  is 32 bytes
p49208
aVFor a 64 bit integer use
p49209
aVUnsigned versions are  and
p49210
aVFor a type that is machine word size, use  or
p49211
as(dp49212
g7
V505088
p49213
stp49214
a((dp49215
g2
(lp49216
VEach key press is a key down and then a key up
p49217
aVSo you need two calls to  per key press
p49218
aVFor example, to press F3:
p49219
aVNote that  isn't actually defined by the Windows header files, or the Delphi translation
p49220
aVDefine it to be
p49221
aVIt makes the code clearer written out explicitly though
p49222
aVNaturally you would not litter your code with paired calls to
p49223
aVBut instead you would wrap up the paired calls into a helper function
p49224
aVIt's possible that in some situations you would need to specify the second parameter, the scan code
p49225
aVBut it's often not necessary
p49226
as(dp49227
g7
V505088
p49228
stp49229
a((dp49230
g2
(lp49231
VWhen  is called, all existing top level windows are disabled
p49232
aVThat's how modality is meant to work
p49233
aVIf you have a window with which interaction is reasonable, you just need to enable it again
p49234
aVFor example, you could add this to your utility window:
p49235
aVThis will make sure that your utility window can never be disabled
p49236
as(dp49237
g7
V505088
p49238
stp49239
a((dp49240
g2
(lp49241
VFor this legacy Turbo Pascal style , there is really no meaning to the keyword
p49242
aVAlthough an  constructor does have some special treatment, there's absolutely no need for that here
p49243
aVWhat have here is nothing more than a  with some methods
p49244
aVThe XE3 compiler was changed so that it no longer allows you to call a constructor on  inside an instance method
p49245
aVThat is the case for both  and
p49246
aVI've not seen any documentation of why this change was made
p49247
aVNo doubt in time it will seep out
p49248
aVYour immediate solution is to replace  with
p49249
aVIn the longer term, it would make sense to turn this into a  rather than an
p49250
aVI would also council you to change the name of the method to
p49251
aVSome library designers seem to opt for using  and  methods on their records
p49252
aVThis had led to immense amount of code being written like this:
p49253
aVIn fact all that code is spurious and can simply be removed
p49254
aVA  variable will automatically initialize itself
p49255
aVThat sort of design also sets a giant Heffalump Trap for that faction of Delphi coders that like to use
p49256
aVPassing a record to  leads to some interesting fireworks
p49257
as(dp49258
g7
V505088
p49259
stp49260
a((dp49261
g2
(lp49262
VDelphi does not support either importing or exporting classes from DLLs
p49263
aVTo import a class from another module, you need to use packages
p49264
as(dp49265
g7
V505088
p49266
stp49267
a((dp49268
g2
(lp49269
VMy scroll box looks like this:
p49270
as(dp49271
g7
V505088
p49272
stp49273
a((dp49274
g2
(lp49275
VIt seems pretty clear that somewhere along the way the data is being mangled between an 8 bit text encoding and a 16 bit encoding
p49276
aVThe spurious first character is almost certainly the UTF-16 BOM
p49277
aVOne possible explanation is that the Delphi developer is writing UTF-16 encoding text to the file
p49278
aVAnd presumably you are expecting an 8 bit encoding
p49279
aVAnother explanation is that the Delphi code is correctly writing out 8 bit text, but that your code is mangling it
p49280
aVPerhaps your read/write code is doing that
p49281
aVUse a hex editor on the file output from the Delphi program to narrow down exactly where the mangling occurs
p49282
aVIn the absence of any code in the question, it's hard to be more specific than this
p49283
as(dp49284
g7
V505088
p49285
stp49286
a((dp49287
g2
(lp49288
VYou are suffering from a common and fundamental mis-understanding of array parameters
p49289
aVWhat you have here:
p49290
aVis not in fact a dynamic array
p49291
aVIt is an open array parameter
p49292
aVNow, you can pass a dynamic array as a parameter to a function that receives an open array
p49293
aVBut you cannot modify the length of the dynamic array
p49294
aVYou can only modify its elements
p49295
aVIf you need to modify the length of the dynamic array, the procedure must receive a dynamic array
p49296
aVIn modern Delphi the idiomatic way to write that is:
p49297
aVIf you are using an older version of Delphi that does not support generic arrays then you need to declare a type for the parameter:
p49298
aVHow should you choose whether to use open array or dynamic array parameters
p49299
aVIn my opinion you should always use open arrays if possible to do so
p49300
aVAnd if not possible, then use dynamic arrays as a final resort
p49301
aVThe reason being a function with an open array parameter is more general than one with a dynamic array parameter
p49302
aVFor example, you can pass a constant sized array as an open array parameter, but not if the function receives a dynamic array
p49303
as(dp49304
g7
V505088
p49305
stp49306
a((dp49307
g2
(lp49308
VIn real code you'd want to use your own exception class
p49309
aVAnd if you want to allow case insensitive matching, compare strings using
p49310
as(dp49311
g7
V505088
p49312
stp49313
a((dp49314
g2
(lp49315
VYour VB
p49316
aVnet declaration is:
p49317
aVThe equivalent Delphi import would be:
p49318
aVDelphi string types should not be used for interop
p49319
aVThe p/invoke marshaller maps String to C++ char*  which is PAnsiChar in Delphi
p49320
aVThis sort of task really should be carried out with the C++ header file
p49321
aVYou say you have not got that
p49322
aVIf the DLL is written in C++ then the header file surely exists
p49323
aVIt would pay to track it down and work from that as your source
p49324
as(dp49325
g7
V505088
p49326
stp49327
a((dp49328
g2
(lp49329
Vis the correct way to initialise a wchar_t variable to U+03B1
p49330
aVThe L prefix is used to specify a wchar_t literal
p49331
aVYour code defines a char literal and that's why the compiler is warning
p49332
aVThe fact that you don't see the desired character when printing is down to your local environment's console settings
p49333
as(dp49334
g7
V505088
p49335
stp49336
a((dp49337
g2
(lp49338
VIt's going to be easier to continue using 1-based indexing
p49339
aVYou can do that a few different ways
p49340
aVFor example:
p49341
aVThe trick here is that even though the dynamic array uses 0 based indexing, you simply ignore the values stored in the 0 index
p49342
aVIf ever you are porting code from Fortran which uses 1-based indexing, this approach is generally the most effective
p49343
as(dp49344
g7
V505088
p49345
stp49346
a((dp49347
g2
(lp49348
VWhen a DLL is linked by its name only, the DLL search path is used to locate it
p49349
aVThis search path is a complicated beast that varies depending on a variety of settings
p49350
aVIt is documented in some detail on MSDN
p49351
aVIn all variants of the DLL search path, the directory from which the executable was loaded is the first directory searched
p49352
aVThis is by far the safest way to load a DLL
p49353
aVRequiring modifications to the global  environment variable is invasive
p49354
aVRequiring DLLs to be installed in system directories is invasive and against all recommendations of best practice
p49355
aVRequiring the use of current directory is fragile and brittle and opens security vulnerabilities
p49356
aVIn an ideal world, applications should be isolated
p49357
aVAnd the most effective way to achieve that is to place dependencies in the same directory as the executable files
p49358
as(dp49359
g7
V505088
p49360
stp49361
a((dp49362
g2
(lp49363
VYour output is what happens when you send ANSI text to a function that is expecting UTF-16 encoded text
p49364
aVFrom which I conclude that your FASM code is sending an ANSI payload to the DLL
p49365
aVAnd the DLL is compiled in a Unicode aware Delphi for which  means ,  means  and so on
p49366
aVYou need to make the two sides match up
p49367
aVFor example, by changing the Delphi code:
p49368
aVSome other points to note:
p49369
aVYou don't need  on the end of your function declaration
p49370
aVIt is ignored by modern Delphi compilers
p49371
aVDon't use Delphi's managed string across module boundaries
p49372
aVIn any case on the FASM side you declared the parameter to be a null-terminated pointer to ANSI encoded character array
p49373
aVAnd that's
p49374
aVYour code uses the Delphi  calling convention
p49375
aVIt's hard to believe that FASM uses that
p49376
aVI'd expect  and Sertac's answer backs that up
p49377
as(dp49378
g7
V505088
p49379
stp49380
a((dp49381
g2
(lp49382
VThe standard way to do this is to use the  class
p49383
aVAs Hans points out, remember to call  when are done with it
p49384
as(dp49385
g7
V505088
p49386
stp49387
a((dp49388
g2
(lp49389
VInside this method
p49390
aVis an object of type
p49391
aVAnd that's your form
p49392
aVRemember that  refers to the instance associated with the active method
p49393
aVAnd in your code, the class is a form and so the instance, , is always a form instance
p49394
aVTo know what  is, look at the type that follows the  or  keyword
p49395
aVThe  instance is an instance of that type
p49396
aVIn your situation, if you want to pass the shape you can pass either , or to be more general,
p49397
aVThe latter allows you to share one event handler between multiple shapes
p49398
aVThis sort of mistake highlights why you should use checked casts with the  operator
p49399
aVWhen you make a mistake, you will get informed of it immediately and in a helpful way
p49400
aVYour unchecked casts just lead to hard to understand cryptic errors
p49401
aVSo I'd probably be inclined to declare  as receiving a parameter of type
p49402
aVAnd then calling it like this:
p49403
aVAnd this allows you to remove the casts from  and confine them just to the event handlers which by necessity only have a  instance, , available
p49404
as(dp49405
g7
V505088
p49406
stp49407
a((dp49408
g2
(lp49409
VThe event handler for an  must have a signature of this form:
p49410
aVThe component is going to call your event handler passing all those parameters, and your event handler must be of the expected form
p49411
aVYou have no control over this
p49412
aVThe component has a pre-determined, hard-coded form for its event handlers
p49413
aVYou simply have to fit in
p49414
aVYour current solution is the correct one
p49415
aVHaving said that,  can only work when it is passed a
p49416
aVSo declare the function that way:
p49417
aVAnd call it like this:
p49418
as(dp49419
g7
V505088
p49420
stp49421
a((dp49422
g2
(lp49423
VMaxInt is declared in the System unit
p49424
aVI'm pretty sure that's the only MaxInt that is in scope here
p49425
aVThe warning you see is accurate
p49426
aVMaxInt is signed and size_t is unsigned
p49427
aVYou should suppress the warning
p49428
aVFor example you could cast MaxInt to size_t:
p49429
aVThat's fine because MaxInt is within the range of values of size_t
p49430
aVAs an aside, I'd probably deal with the underlying issue by hooking the function that needs fixing, rather than re-compiling the entire unit
p49431
aVI personally find that to be less invasive and easier to maintain
p49432
aVWhy do I get the compiler warning for that one
p49433
aVproject build only
p49434
aVSome ideas:
p49435
aVYou only have one project that includes that unit
p49436
aVYou have different compiler options in different projects
p49437
aVPerhaps only one of your projects has warnings enabled, or only one project has that specific warning enabled
p49438
aVYou only have one project with WIN32 defined
p49439
aVThis file is only compiled once, but used multiple times
p49440
aVPerhaps because you are making rather building
p49441
aVIt's pretty hard to explain that part of your question
p49442
aVIrrespective, when the code in your question is compiled with warnings enabled, you will get that warning
p49443
aVYou really are comparing signed and unsigned
p49444
aVSo you really do need to suppress the warning with the method I provide above
p49445
aVRemember that a warning does not mean that your code is broken
p49446
aVSuppressing that warning will not change the behaviour of the code
p49447
aVWhen you see that warning you analyse the code to check whether or not there is a problem
p49448
aVIn this case, the code works fine and you just need to suppress the warning
p49449
as(dp49450
g7
V505088
p49451
stp49452
a((dp49453
g2
(lp49454
VAn interface defines a contract between implementor and consumer
p49455
aVPart of that contract is enforced by the compiler
p49456
aVFor example, that all implementations of the interface have the requisite functions of particular names, which take specific parameters
p49457
aVBut there is another part of an interface that is not enforced by the compiler
p49458
aVThat's the part of the contract that is described in the interface documentation
p49459
aVYou could decide that it suffices to tell all implementors what rules they must abide by
p49460
aVMany libraries take that stance
p49461
aVThe Windows API is one prominent example
p49462
aVIf you are dead set on enforcement through code then an interface cannot help
p49463
aVYou need something that expresses the constraint in code and in this case that's going to require implementation
p49464
aVWhich means you would need to use a class
p49465
aVAn (almost) abstract base class could get it done
p49466
aVThe only concrete part of the class would enforce the ownership constraint
p49467
aVThe rest of the class would be a series of abstract virtual methods
p49468
aVThat's not an interface in the sense implied by the Delphi keyword
p49469
aVHowever, it's an interface in semantic terms
p49470
as(dp49471
g7
V505088
p49472
stp49473
a((dp49474
g2
(lp49475
VYes this is a legacy from days of yore
p49476
aVAnd no you should not get into the habit of using this feature
p49477
aVRemember that code is read more often than it is written
p49478
aVAlways think of your readers who most likely won't know what that syntax means
p49479
as(dp49480
g7
V505088
p49481
stp49482
a((dp49483
g2
(lp49484
VWhat Remy said is quite correct, but there may be an easier way to make your code work in both XE2 and XE3
p49485
aVSimply add a unit alias from  to
p49486
aVAdd this in your project options, on the Delphi Compiler page
p49487
aVYou need to add the following:
p49488
aVNote that if you need to compile in both XE2 and XE3 using the same
p49489
aVdproj file then you are out of luck
p49490
aVThat unit alias setting will stop the program compiling under XE3
p49491
aVHowever, if you have have different
p49492
aVdproj files for XE2 and XE3, then this will allow you to use the same source in both
p49493
aVOr, if you only need to compile for XE2 at the command line, then you could add this unit alias there
p49494
aVI can't tell whether or not this will help you, but I know that the unit alias feature has helped me out of a similar spot on more than one occasion in the past
p49495
as(dp49496
g7
V505088
p49497
stp49498
a((dp49499
g2
(lp49500
VYou don't need to compile any code at all
p49501
aVJust connect your special keyboard button to
p49502
as(dp49503
g7
V505088
p49504
stp49505
a((dp49506
g2
(lp49507
VThe main problem in the code in the question is here:
p49508
aVThe problem is that inside the  constructor,  is a local variable
p49509
aVYour code clearly assumes that you are referring to the member variable of the same name
p49510
aVSo you initialize the local variable, and then it immediately vanishes out of scope
p49511
aVIn the rest of the code you refer to the member variable  which has not initialised
p49512
aVSolve the problem by initialising that member variable
p49513
aVYou could do it like this:
p49514
as(dp49515
g7
V505088
p49516
stp49517
a((dp49518
g2
(lp49519
VIf your design mandates that hierarchy then your code is reasonable
p49520
aVI'd modify it to use checked casts, with the  operator
p49521
aVThese will raise runtime errors if the classes are not of the required type:
p49522
as(dp49523
g7
V505088
p49524
stp49525
a((dp49526
g2
(lp49527
VThe most likely explanation is that the function will have been exported with a decorated name
p49528
aVI'd expect it to have been exported with the name
p49529
aVSo you could import it like this:
p49530
aVUse a tool like Dependency Walker to check the exact name used to export the function
p49531
aVIf you cannot modify the Delphi code, then you'll need to make your C++ DLL match
p49532
aVDo that by using a
p49533
aVdef file which allows you control over the exported name
p49534
aVThe other problem you will face is that Delphi's ABI for return values differs from that used by most other tools on the Windows platform
p49535
aVSpecifically a return value is semantically a  parameter
p49536
aVOn the other hand, your C++ compiler will regard the return value as an  parameter
p49537
aVMy question on Delphi  return values covers exactly this issue
p49538
aVBecause of this, I'd expect the function declaration above to lead to access violations
p49539
aVInstead you should declare the return value to be a  and cast it to an interface reference in your Delphi code
p49540
aVYou'll need to double check and make sure that the reference counting is handled appropriately
p49541
aVAgain, if you cannot modify the Delphi code, you need to make the C++ code match
p49542
aVA Delphi interface return value is implemented as an additional  parameter following the other parameters
p49543
aVSo, to make your C++ function match, declare it like this:
p49544
as(dp49545
g7
V505088
p49546
stp49547
a((dp49548
g2
(lp49549
VSince you are not specifying the various paths on the command line, they need to be in a
p49550
aVcfg file
p49551
aVMy dcc32
p49552
aVcfg file for Delphi 6 looks like this:
p49553
aV/LE"C:\u005cProgram Files (x86)\u005cBorland\u005cDelphi6\u005cProjects\u005cBpl"
p49554
aV/LN"C:\u005cProgram Files (x86)\u005cBorland\u005cDelphi6\u005cProjects\u005cBpl"
p49555
aV/U"C:\u005cProgram Files (x86)\u005cBorland\u005cDelphi6\u005cLib";"C:\u005cProgram Files (x86)\u005cBorland\u005cDelphi6\u005cImports"
p49556
aV/R"C:\u005cProgram Files (x86)\u005cBorland\u005cDelphi6\u005cLib"
p49557
aVI have this in the Delphi  directory
p49558
aVI put it there because it is specific to one particular machine since it uses absolute paths
p49559
aVObviously you might need to add some more paths to what I have above, but the above will get you what you need for the basic RTL/VCL units
p49560
as(dp49561
g7
V505088
p49562
stp49563
a((dp49564
g2
(lp49565
VIn , this line of code
p49566
aVis responsible for your access violation
p49567
aVThat's because  has not been initialised before you attempt to call a method on it
p49568
aVDelphi instances are created like this:
p49569
aVI'm not sure about your threading model, but I trust you are aware that VCL controls must only be accessed from the GUI thread
p49570
as(dp49571
g7
V505088
p49572
stp49573
a((dp49574
g2
(lp49575
VAssuming you are prepared to rely on the Windows API, when you call the  function to launch a process, you have the  parameter
p49576
aVNormally you pass  which means, use the environment of the creating process
p49577
aVHowever, you can supply an environment block which will be used by the new process
p49578
aVThe environment block that you pass is a null-terminated block of null-terminated strings
p49579
aVFor example:
p49580
aVdefines two separate variables
p49581
as(dp49582
g7
V505088
p49583
stp49584
a((dp49585
g2
(lp49586
VInstead of naming your objects , ,  etc
p49587
aVyou should put them in an array
p49588
aVThen you can refer to them using
p49589
aVYou mention this approach in your question and say that you can't use it
p49590
aVBut you can
p49591
aVYou just need to add a layer between the old code an the new
p49592
aVInitialise the array like this:
p49593
aVNow you can write code that uses array indexing, but still stands on top of the code which you are not allowed to modify
p49594
as(dp49595
g7
V505088
p49596
stp49597
a((dp49598
g2
(lp49599
VRTTI cannot enumerate constants
p49600
aVWhilst they might appear to be fields, they are not
p49601
aVThey are implemented just like any other constant, inside the record's namespace
p49602
aVYou may have to consider an alternative approach
p49603
aVFor example you could use attributes instead of constants
p49604
aVOr perhaps adding a class function that enumerates these constants
p49605
aVYet another approach would be like this:
p49606
as(dp49607
g7
V505088
p49608
stp49609
a((dp49610
g2
(lp49611
VThe  switch is used to specify that you want to target the console subsystem
p49612
aVAnd you really do want to do that to ensure that your process connects to the existing console if started from a console app
p49613
aVFor example, suppose you do go down your route of targeting the GUI subsystem, and then calling , as per your own answer
p49614
aVThen you'll find your app shows a brand new console rather than using the existing one when started from another console app, e
p49615
ag217
aVIf you need to use other libraries, then you are free to add them on command line using
p49616
aVThere's nothing special about a console app that means that it cannot link to any Win32 API function
p49617
aVIt's just that the default set of libraries associated with  is missing some of the libraries that you want
p49618
aVOn the other hand, you can use both  and  when you build your app
p49619
aVThey are not mutually exclusive
p49620
aVThis produces an application that targets the console subsystem
p49621
aVAnd you get the standard  set of Win32 libraries automatically linked
p49622
aVIt's probably the simplest way to achieve your goal
p49623
as(dp49624
g7
V505088
p49625
stp49626
a((dp49627
g2
(lp49628
VThe C# equivalent is the generic list container
p49629
aVIt's very similar to Delphi's  but is a typesafe container due to the use of generics
p49630
aVIn fact in modern Delphi code, the generic Delphi class  would be preferred over the non-generic  because of type safety
p49631
aVAssuming that you want a list of  objects you would instantiate an instance of
p49632
aVand then you can add items
p49633
aVand so on
p49634
as(dp49635
g7
V505088
p49636
stp49637
a((dp49638
g2
(lp49639
VYour structure declaration is wrong
p49640
aVIt should be:
p49641
aVYou must also pass a pointer to the  struct when you call
p49642
aVI'd do it like this:
p49643
aVAs @eryksun helpfully points out, adding
p49644
aVbefore the call to  will make  perform runtime type checking
p49645
as(dp49646
g7
V505088
p49647
stp49648
a((dp49649
g2
(lp49650
VThis sort of thing happens every now and again
p49651
aVIt's just a false positive rather than anything flawed in your program
p49652
aVBy chance your compiled program has something in common with the signature used by your AV tool to identify that virus
p49653
aVWhat you should do is send your program to the AV vendor so that they can fix their signatures
p49654
aVAV software does not attempt to detect security flaws like buffer overruns
p49655
aVIf they did, and could do so effectively, then almost all software would be detected as malware
p49656
as(dp49657
g7
V505088
p49658
stp49659
a((dp49660
g2
(lp49661
VThe simplest way to combine multiple objects in a single compound type is a record:
p49662
aVFor convenience provide a function to initialise one of these records:
p49663
aVThen your  function can receive an open array of such records:
p49664
aVNote that I have put the  parameter at the end
p49665
aVSince it has a default value, that default value is only useful when it appears at the end of the list
p49666
aVNow, to call the function you can write code like this:
p49667
as(dp49668
g7
V505088
p49669
stp49670
a((dp49671
g2
(lp49672
VYou would never write  or
p49673
aVInstead you would write
p49674
aVor even more likely
p49675
aVwhere  was some text provided by user input
p49676
aVPerhaps read from a file and so on
p49677
aVIn which case
p49678
aVwill indeed return  if  is a character string containing
p49679
aV> str = "6***"
p49680
aV> as
p49681
aVinteger(str)
p49682
aV[1] NA
p49683
aVWarning message:
p49684
aVNAs introduced by coercion
p49685
as(dp49686
g7
V505088
p49687
stp49688
a((dp49689
g2
(lp49690
VYour painting code is in the wrong place and is painting to the wrong thing
p49691
aVIn Windows programs you are meant to paint in response to a  message
p49692
aVYou are not doing so
p49693
aVWhat's more, you have to paint on a device context that is provided by a call to
p49694
aVThe VCL wraps all those details up for you, but you still need to follow the rules
p49695
aVIn your case I recommend that you add a  component to your form
p49696
aVThen implement an  event handler for the paint box
p49697
aVFinally, whenever you wish to repaint the paint box, for example on a timer, call the  method of the paint box
p49698
aVI suspect that you want your each new ellipse to be drawn in addition to the earlier drawn ellipses
p49699
aVIn which case you are probably best served by drawing them to an off-screen bitmap first and then, when you come to paint to the paint box, draw that bitmap on the paint box
p49700
aVThe point is that a window needs to be able to re-paint itself in its entirety
p49701
aVWhen you paint to a screen device, what you painted is lost the next time that window needs to be painted
p49702
aVSo it's the responsibility of the application to be able to paint its entire self at any point, if it is asked
p49703
aVMore generally I urge you to stop using global variables
p49704
aVThey will cause you no end of trouble
p49705
aVPrefer local variables wherever possible
p49706
aVIf you need state to persist between different method calls, use member variables
p49707
aVThe guiding principle is to use the narrowest scope possible
p49708
aVYour current design uses a timer to poll for new data
p49709
aVThat's a very poor approach
p49710
aVThe most efficient and effective approach is to use synchronous blocking communication
p49711
aVIndy takes that approach
p49712
aVWindows sockets components instead tend to be used in an asynchronous mode
p49713
aVIrrespective of the relative merits of these two approaches, you should not be polling on a timer
p49714
aVIf you do use asynchronous communication, then respond to new data by handling an event rather than polling
p49715
aVYour program is currently trying to mix together GDI painting, and network communication
p49716
aVI suggest that you attempt to get on top of these concepts one at a time
p49717
aVLearn how to paint without the distraction of communication
p49718
aVThen when you have cracked painting, try to bring in the communication aspect
p49719
as(dp49720
g7
V505088
p49721
stp49722
a((dp49723
g2
(lp49724
VYou need to add  to the  property
p49725
aVInclude it in the Object Inspector, or in code:
p49726
as(dp49727
g7
V505088
p49728
stp49729
a((dp49730
g2
(lp49731
VAlthough  is an array of  elements, it can also be considered as an array of bytes
p49732
aVWell, assuming  is 8 bits wide, which it usually is
p49733
aVSo, if this variable contains code, it is clearer to express it as an array of bytes, rather than a text array
p49734
aVFor example, there may be elements that are not readily expressed as printable characters
p49735
aVSince the content will be generated by a compiler or assembler, it will originally have been in the form of a binary block of code
p49736
aVAnd it's easiest and clearest to convert that to the hex representation that you presented
p49737
as(dp49738
g7
V505088
p49739
stp49740
a((dp49741
g2
(lp49742
V is an internal helper class used by the VCL
p49743
aVIt's not what you need
p49744
aVI suspect that all you need to do is to declare a published property of type
p49745
aVThe VCL will automatically provide a design time editor and can stream the image to the
p49746
aVdfm file
p49747
aVYou can use any  descendent, including
p49748
as(dp49749
g7
V505088
p49750
stp49751
a((dp49752
g2
(lp49753
VUse the  command in your post-build event:
p49754
aVThe  expands to the output file's full path
p49755
as(dp49756
g7
V505088
p49757
stp49758
a((dp49759
g2
(lp49760
VThere's no way to know this when your file is being compiled
p49761
aVA source file can be compiled to a
p49762
aVdcu and then linked into any type of project
p49763
aVA good example are the RTL and VCL units
p49764
aVProbably the best you can do is to define a conditional in your project options that indicates whether or not the project is a library
p49765
aVBut you need to make sure that the
p49766
aVdcu is always re-compiled when you build any project that uses this unit
p49767
as(dp49768
g7
V505088
p49769
stp49770
a((dp49771
g2
(lp49772
VYou can do what you want like this:
p49773
aVYou can add even more flexibility if you design it like this:
p49774
as(dp49775
g7
V505088
p49776
stp49777
a((dp49778
g2
(lp49779
VYou cannot simply cast a  to a
p49780
aVThat's not enough
p49781
aVYou need to convert the text from being 8 bit encoded to being 16 bit encoded
p49782
aVThat said, since you seem to be using ANSI strings in your program, it may just be easier to use
p49783
aVFor example:
p49784
aVHaving said that, if this is meant to be professional software, I'd recommend that you do use UNICODE text throughout your application
p49785
aVIn which case you would do it like this:
p49786
as(dp49787
g7
V505088
p49788
stp49789
a((dp49790
g2
(lp49791
VI guess your C struct looks something like this:
p49792
aVBecause of the reference to the payload, I don't believe you can get the p/invoke marshaler to  do the work for you
p49793
aVYou'll need to marshal by hand
p49794
aVIn the C# code declare the struct like this
p49795
aVWhen you need to prepare such a struct for a function call do this:
p49796
aVIf you need to read data that is returned by your function, use the same tactic in the opposite direction
p49797
aVWhen you have finished with the struct make sure you deallocate the memory by calling
p49798
as(dp49799
g7
V505088
p49800
stp49801
a((dp49802
g2
(lp49803
VThe only truly effective way I have ever found to do this is to take charge of calling  and
p49804
aVLike this:
p49805
as(dp49806
g7
V505088
p49807
stp49808
a((dp49809
g2
(lp49810
VCopy the items to a temporary list and then remove whichever you want to remove from that temporary list
p49811
aVThen save it
p49812
aVFor example, this code will remove the first two element from the list
p49813
aVI'm not sure if I fully understand which elements of the list need to be removed
p49814
aVNo matter, the basic idea of copying to a different list and saving that, is almost certainly what you need
p49815
aVYou will surely be able to work out which elements need to be deleted
p49816
as(dp49817
g7
V505088
p49818
stp49819
a((dp49820
g2
(lp49821
VThe reason for the Delphi string tradition of 1-based strings is quite simple
p49822
aVThe tradition comes from the implementation of old style Turbo Pascal strings
p49823
aVThat data type stored the length of the string in the first byte of the variable, index 0
p49824
aVThe string data began in the next byte, index 1
p49825
aVYou can still use that data type today
p49826
aVIt's now called ShortString
p49827
aVAs is immediately obvious from it's implementation, there is a 255 character limit
p49828
aVThis limit led to the introduction of huge strings, if I recall correctly, in Delphi 2
p49829
aVWhen huge strings were introduced the language designers chose to retain 1-based indexing to make it easier for developers to switch from short strings to huge strings
p49830
aVI guess Turbo Pascal didn't invent the idea of using element 0 for length
p49831
aVIt's just that I'm too young to remember what came before then
p49832
aVDynamic arrays weren't bound by the past in the same way and had a free choice
p49833
aVI don't know why zero based was chosen
p49834
aVPerhaps because it fits more easily with the prevailing fashion on platform on which Delphi existed at that time, namely Windows
p49835
aVThat's just a guess though
p49836
aVDanny Thorpe worked on the Delphi compiler at that time, and even he can't remember the rationale
p49837
aVThe Delphi language designers are currently moving towards zero based string indexing for huge strings
p49838
aVThe initial steps in this direction can be seen in XE3 in the TStringHelper class which uses 0-based indexing
p49839
aVAnd also in the ZEROBASEDSTRINGS conditional which allows you to opt in to 0-based indexing
p49840
aVExpect the next generation Delphi compiler to use 0-based indexing only
p49841
aVThe times they are changin'
p49842
as(dp49843
g7
V505088
p49844
stp49845
a((dp49846
g2
(lp49847
VThe access violation occurs because  receives an untyped var parameter that is expected to be an object reference
p49848
aVYou are passing an interface reference which does not meet the requirement
p49849
aVUnfortunately you only find out at runtime
p49850
aVThis is, in my view, the strongest point against the use of
p49851
aVYour reference counting disables lifetime management by the interface reference counting mechanism
p49852
aVIn order to destroy an object you need to call its destructor
p49853
aVAnd in order to do that you must have access to the destructor
p49854
aVYour interface doesn't expose the destructor (and it should not)
p49855
aVSo, we can deduce that, in order to destroy the object, you need to have an object reference
p49856
aVHere are some options:
p49857
aVOr you can do it like this
p49858
as(dp49859
g7
V505088
p49860
stp49861
a((dp49862
g2
(lp49863
VThe implementation of  looks like this:
p49864
aVSo, look through your code for anything that assigns to
p49865
aVAnother approach is to use your debugger to help you
p49866
aVEnable Debug DCUs
p49867
aVThen set a break point on the call to  in your
p49868
aVdpr file
p49869
aVThen step into that procedure with F7
p49870
aVThen step into the call to  and follow that along until you reach the code that blocks
p49871
aVIf you are using a revision control system you can simply check out older versions of the project and use a binary search to find the commit that introduced the behaviour
p49872
aVIf you are not using revision control, start doing so now
p49873
as(dp49874
g7
V505088
p49875
stp49876
a((dp49877
g2
(lp49878
VAccording to the comment trail, you need to create a  of bytes
p49879
aVWhich is done like this in Delphi:
p49880
aVOr, if the  needs 1-based indexing:
p49881
aVYou can then populate the array in a loop using
p49882
aVIf you have a Delphi dynamic , and the expected  uses 0-based indexing, then you can simply write:
p49883
aVIf you have a lot of data to transfer then the element by element poking of the data that the RTL offers is pretty much hopeless
p49884
aVEven the simple  approach results in element by element copying which will be horribly slow for large amounts of data
p49885
aVIn your position, I'd blit the array in one go
p49886
aVLike this:
p49887
aVOr, if you need to use 1-based indexing:
p49888
as(dp49889
g7
V505088
p49890
stp49891
a((dp49892
g2
(lp49893
VOn Vista and later, windows services run in session 0
p49894
aVInteractive users exist in session 1 and up
p49895
aVThis means that windows services cannot show user interface and indeed cannot easily start processes in the interactive session
p49896
aVNow, there are ways to launch interactive processes from a service
p49897
aVIf you are dead set on launching an interactive process from your service, then that article tells you all your need to know
p49898
aVBut such techniques are very tricky and absolutely not to be recommended
p49899
aVThe recommendation is that you find a different way to communicate between your service and the interactive desktop
p49900
aVThe normal approach is to run a standard desktop app, perhaps started using
p49901
aVAnd use some form of IPC to communicate between the desktop app and the service
p49902
as(dp49903
g7
V505088
p49904
stp49905
a((dp49906
g2
(lp49907
VI'm not an expert on the shell
p49908
aVIn fact I know practically nothing
p49909
aVBut by reading the documentation I can glean the following:
p49910
aVexpects an absolute PIDL
p49911
aVenumerates relative PIDLs
p49912
aVSo you code is bound to fail because of that
p49913
aVPerhaps there are other errors too
p49914
aVI can't tell
p49915
aVAnyway, I think the easy way to solve the problem is to use  to obtain the name you need:
p49916
as(dp49917
g7
V505088
p49918
stp49919
a((dp49920
g2
(lp49921
VWhat you are trying to do does in fact work fine
p49922
aVI tested it out myself
p49923
aVHere's the project file I used:
p49924
aVI made a copy of the  file and placed it in the same directory as the
p49925
aVdpr file
p49926
aVThen, in the copy rather than the original, I modified
p49927
aVI added the  to prove to myself that this code was indeed being executed
p49928
aVIn your position I would definitely use this solution instead of attempting code hooks
p49929
aVAnd of course the other simple solution is to upgrade to a later Delphi version
p49930
aVOne thing to be careful of is to remember to remove the modified unit when you do upgrade
p49931
aVThe leak was fixed in XE2
p49932
as(dp49933
g7
V505088
p49934
stp49935
a((dp49936
g2
(lp49937
VYou can indeed call  from Delphi
p49938
aVYou need to use the  unit
p49939
aVIf your Delphi doesn't have  declared then you can import it like this:
p49940
as(dp49941
g7
V505088
p49942
stp49943
a((dp49944
g2
(lp49945
VHere are the possibilities that I can see:
p49946
aVThe return value should not be
p49947
aVUse  and convert to a string with
p49948
aVThe C++ type  should be matched with
p49949
aVYou used  in C# which is a 64-bit type
p49950
aVIn C++ on Windows,  is an unsigned 32-bit type
p49951
aVThe C++ type  should be matched with
p49952
aVThe calling convention used by the C++ DLL is probably
p49953
aVAdd  to your P/Invoke
p49954
aVDon't use  for such a function
p49955
aVThat's used with Win32 API functions that return error conditions through
p49956
aVThis DLL file almost certainly does not
p49957
aVSo the P/Invoke should look something like this:
p49958
as(dp49959
g7
V505088
p49960
stp49961
a((dp49962
g2
(lp49963
VDouble null-terminated strings cannot contain empty lines
p49964
aVAn attempt to include empty lines means including two consecutive nulls, and that is interpreted as termination rather than an empty line
p49965
aVRaymond Chen discussed this quirk much more eloquently that I can
p49966
aVPerhaps you can save to  and use  as a delimiter
p49967
as(dp49968
g7
V505088
p49969
stp49970
a((dp49971
g2
(lp49972
VBy default, anything with a compatible integrity level can use  and
p49973
aVThat means an integrity level that is greater or equal to that of the target process
p49974
as(dp49975
g7
V505088
p49976
stp49977
a((dp49978
g2
(lp49979
VYou need to compile your code as a 64 bit process to see the 64 bit control panel items
p49980
aVThat needs XE2 or later
p49981
aVWhen I try your code in a 64 bit process the output is as follows:
p49982
aVNVIDIA nView Desktop Manager
p49983
aVPower Options
p49984
aVNotification Area Icons
p49985
aVTaskbar and Start Menu
p49986
aVCredential Manager
p49987
aVDefault Programs
p49988
aVRemoteApp and Desktop Connections
p49989
aVWindows Live Language Setting
p49990
aVWindows Update
p49991
aVDesktop Gadgets
p49992
aVWindows Firewall
p49993
aVPhone and Modem
p49994
aVSpeech Recognition
p49995
aVUser Accounts
p49996
aVRegion and Language
p49997
aVHomeGroup
p49998
aVMouse
p49999
aVFolder Options
p50000
aVKeyboard
p50001
aVDevice Manager
p50002
aVWindows CardSpace
p50003
aVPerformance Information and Tools
p50004
aVPrograms and Features
p50005
aVIndexing Options
p50006
aVNetwork and Sharing Center
p50007
aVAutoPlay
p50008
aVSync Center
p50009
aVRecovery
p50010
aVInternet Options
p50011
aVDevices and Printers
p50012
aVColor Management
p50013
aVBackup and Restore
p50014
aVSystem
p50015
aVAction Center
p50016
aVFonts
p50017
aVWindows Anytime Upgrade
p50018
aVDisplay
p50019
aVTroubleshooting
p50020
aVGetting Started
p50021
aVAdministrative Tools
p50022
aVEase of Access Center
p50023
aVWindows Defender
p50024
aVDate and Time
p50025
aVLocation and Other Sensors
p50026
aVPersonalization
p50027
aVSound
p50028
aVJava (32-bit)
p50029
aVDirectX
p50030
aVRealtek HD Audio Manager
p50031
aVBDE Administrator (32-bit)
p50032
aVAdvansys Formativ (32-bit)
p50033
aVMail (32-bit)
p50034
aVMicrosoft Mail Postoffice (32-bit)
p50035
aVFlash Player (32-bit)
p50036
aVNVIDIA Control Panel
p50037
aVIn a 32 bit process the output is:
p50038
aVJava
p50039
aVBDE Administrator
p50040
aVAdvansys Formativ
p50041
aVMail
p50042
aVMicrosoft Mail Postoffice
p50043
aVFlash Player
p50044
aVNote that the 64 bit process enumerates the 32 bit items as well as the 64 bit items
p50045
as(dp50046
g7
V505088
p50047
stp50048
a((dp50049
g2
(lp50050
VThe access violation is down to the lpCommandLine parameter
p50051
aVThat is meant to a editable memory, LPWSTR and the API function does modify the buffer
p50052
aVBut you pass a pointer to non-modifiable memory
p50053
aVBut there's a more fundamental problem
p50054
aVYou say you want to prompt for credentials from a service
p50055
aVServices should not show UI and in modern versions of Windows, a service simply cannot show UI
p50056
aVYour design is flawed and you need to re-consider it
p50057
as(dp50058
g7
V505088
p50059
stp50060
a((dp50061
g2
(lp50062
VThis article by Steve Trefethen, a former Borland developer, shows how to use
p50063
as(dp50064
g7
V505088
p50065
stp50066
a((dp50067
g2
(lp50068
VYou can use \u005cu to escape a Unicode character code:
p50069
aVwhich defines a string containing the space character
p50070
as(dp50071
g7
V505088
p50072
stp50073
a((dp50074
g2
(lp50075
VIf you are able to call Windows API functions, then you can use WMI
p50076
aVAfter all, the WMI interface is part of the Windows API
p50077
as(dp50078
g7
V505088
p50079
stp50080
a((dp50081
g2
(lp50082
VLike this:
p50083
aVSource: http://blog
p50084
aVkutulu
p50085
aVorg/2012/01/com-interop-part-9-custom-activations
p50086
aVhtml
p50087
aVm=1
p50088
as(dp50089
g7
V505088
p50090
stp50091
a((dp50092
g2
(lp50093
V doesn't show dialogs when it fails
p50094
aVAnd it will not offer to delete files on your behalf
p50095
aVThat dialog is shown by the  app
p50096
aVIn order to handle errors you need to check the return value of the call to
p50097
aVIf that return value is greater than 32 then the call succeeded
p50098
aVOtherwise there was an error
p50099
aVThe possible reported errors are listed in the documentation
p50100
aVFor better error handling, use
p50101
aVIf a call to  fails then you can obtain an error code by calling
p50102
as(dp50103
g7
V505088
p50104
stp50105
a((dp50106
g2
(lp50107
VI suspect that your code is slow because it is performing unnecessary reallocations of the string
p50108
aVHowever, without seeing your code it's hard to be sure
p50109
aVProbably the simplest way to code your algorithm is to use
p50110
aVWhether or not that gives sufficient performance, only you can say
p50111
as(dp50112
g7
V505088
p50113
stp50114
a((dp50115
g2
(lp50116
VThis question is rather similar to your previous question, but with the added complexity of reading the array from a file
p50117
aVI'd probably write it like this:
p50118
as(dp50119
g7
V505088
p50120
stp50121
a((dp50122
g2
(lp50123
VThe native API does not offer an equivalent to
p50124
aVYour options are:
p50125
aVUse the Win32 API
p50126
aVStick with native API and hard code the path
p50127
aVMix the Win32 and native APIs
p50128
aVUse the Win32 API to open  with
p50129
aVThen call  to find out the native name of the key
p50130
aVAnd then use the native API from there on
p50131
aVThis gets around your objection to hard coding
p50132
aVOption 3 sounds plausible, but I've never called  and can't even be sure that the idea works
p50133
as(dp50134
g7
V505088
p50135
stp50136
a((dp50137
g2
(lp50138
VThe  overload you should be using is this one:
p50139
aVNow, you can create an  by calling
p50140
aVLike this:
p50141
aVI've written the  function as an anonymous method, but you could also use a plain old style non-OOP function, or a method of an object
p50142
aVOne potential problem with your comparison function is that you may suffer from integer overflow
p50143
aVSo you could instead use the default integer comparer
p50144
aVIt might be expensive to call  repeatedly so you could store it away in a global variable:
p50145
aVAnother option to consider is to pass in the comparer when you create the list
p50146
aVIf you only ever sort the list using this ordering then that's more convenient
p50147
aVAnd then you can sort the list with
p50148
as(dp50149
g7
V505088
p50150
stp50151
a((dp50152
g2
(lp50153
VMost likely the problem is that  has dependencies on other DLLs that reside in the same folder as
p50154
aVWhen your application lives in a different folder from , those dependencies will not be resolved from the folder that contains
p50155
aVInstead they are resolved by the system DLL search order
p50156
aVYour use  influences the system DLL search order
p50157
aVAnd it means that the dependencies of  are resolved from the directory that contains
p50158
aVYou can test this hypothesis by using, for example, Dependency Walker in profile mode
p50159
aVThat will tell you how the dependencies of  are resolved at runtime
p50160
aVYou are right to dislike the use of
p50161
aVThe best solution would be to put all the DLLs in the same directory as the application
p50162
aVOf course, the other possibility is that the call to  has a dependency on the working directory
p50163
aVYou can rule that out by changing the working directory back to its original value after the call to
p50164
as(dp50165
g7
V505088
p50166
stp50167
a((dp50168
g2
(lp50169
VThat error should be self-explanatory
p50170
aVLet's try to de-construct it
p50171
aVProperty accessor must be an instance field or method
p50172
aVThe property accessor is the expression following the
p50173
aVIf your property was writeable, then the expression following the  would also be a property accessor
p50174
aVTherefore, in your code the property accessor is
p50175
aVAn instance field is a normal field of the class
p50176
aVSo, class fields do not qualify
p50177
aVSimilarly, an instance method is a plain method of the class
p50178
aVA class method is not an instance method
p50179
aVIn fact, any method that is not a class method are instance methods
p50180
aVThe error therefore indicates that  is not an instance field
p50181
aVAnd that is correct
p50182
aVIt is a class field
p50183
aVI guess you don't mean for  to be a class field
p50184
aVYou need to write the class like this:
p50185
aVOr perhaps:
p50186
aVI favour the former as it gives a much clearer distinction between class and instance fields
p50187
as(dp50188
g7
V505088
p50189
stp50190
a((dp50191
g2
(lp50192
VIf you are returning a truth value, a boolean, then your proposed changes do not change the semantics of the code
p50193
aVThat's because bitwise XOR, when used in a truth context, is the same as
p50194
aVIn my view your proposed changes make the code much easier to understand
p50195
aVQuite why the author thought bitwise XOR would be appropriate eludes me
p50196
aVI guess some people think that sort of coding is clever
p50197
aVI don't
p50198
aVIf you want to know the relative performance of the two versions, write a program and time the difference
p50199
aVI'd be surprised if you could measure any difference between them
p50200
aVAnd I'd be equally surprised if these lines of code were your performance bottleneck
p50201
as(dp50202
g7
V505088
p50203
stp50204
a((dp50205
g2
(lp50206
VExample code using Indy's  might be:
p50207
as(dp50208
g7
V505088
p50209
stp50210
a((dp50211
g2
(lp50212
VWhat you have saved is not a JPEG image
p50213
aVYou have saved a Windows bitmap
p50214
aVThat has no compression at all
p50215
aVIt happens to have the  extension, but that doesn't make the file itself be a JPEG
p50216
aVYou need to use  to save the file
p50217
aVControl the compression by using the  property
p50218
aVOnce you have your image in a bitmap, transfer it to a JPEG
p50219
as(dp50220
g7
V505088
p50221
stp50222
a((dp50223
g2
(lp50224
VYour problem is not one of precision
p50225
aVThe issue is that your function does not define a triangle wave
p50226
aVEach time  is reset to 0, the next returned value from the function is 0
p50227
aVNext time round length is set to 0, the first if branch is executed and counter is set to 0
p50228
aVWhen faced with a problem like this you should plot the output
p50229
aVHad you done so you would have seen immediately that your function does not produce a triangle wave form
p50230
aVHere's some code that does:
p50231
aVAgain, I cannot stress enough that you must plot and visualize the output from your code to gain insight into its behaviour
p50232
as(dp50233
g7
V505088
p50234
stp50235
a((dp50236
g2
(lp50237
VYou can call  on the menu item to force it to be updated
p50238
aVThis is a protected member to you need to gain access to that member by the well-known protected member hack
p50239
as(dp50240
g7
V505088
p50241
stp50242
a((dp50243
g2
(lp50244
VYou need to configure your service to run as a user which has sufficient rights
p50245
aVIn this case you are looking for rights to network shares
p50246
aVTypically that's going to need a domain user with appropriate rights
p50247
aVNormally you'd ask your network manager to create a dedicated user account for the purpose
p50248
aVYou appear to be labouring under some false information as to how services work
p50249
aVYou talk about running the service under the account of the logged on user
p50250
aVRemember that services run when there are no users logged on
p50251
aVAnd remember that there may be multiple logged users at any point in time
p50252
as(dp50253
g7
V505088
p50254
stp50255
a((dp50256
g2
(lp50257
VYou can use  to manipulate the DLL search order
p50258
as(dp50259
g7
V505088
p50260
stp50261
a((dp50262
g2
(lp50263
VFor what it's worth, I'd avoid the duplication of Serg's answer and write it like this:
p50264
aVObviously you can stick whatever you like in between the start and end labels
p50265
as(dp50266
g7
V505088
p50267
stp50268
a((dp50269
g2
(lp50270
VAs of Vista, a Windows service cannot interact with any interactive desktop
p50271
aVWhich means that you can't do what you are proposing from a Windows service
p50272
aVYou would need a standard desktop application
p50273
as(dp50274
g7
V505088
p50275
stp50276
a((dp50277
g2
(lp50278
VYour intended code is:
p50279
aVThis results in a compilation error
p50280
aVThat's because  expects a parameter of type
p50281
aVBut you are passing a , an integral parameter
p50282
aVConvert it from an integral data type to a string by calling :
p50283
as(dp50284
g7
V505088
p50285
stp50286
a((dp50287
g2
(lp50288
VYou cannot replicate that  in your Python code
p50289
aVIt can only be used in-proc, for example for plugins
p50290
aVThe example Delphi code is written under the assumption that the call to  is made from the same process as the window which receives the message
p50291
aVThat's because the  is used to copy a pointer, and pointers are only valid inside the process which allocated the memory
p50292
aVYou cannot send a pointer across a process boundary
p50293
aVIn my opinion, the designers of the interface are abusing
p50294
aVIt is meant to be used to solve the exact problem of transferring data between processes
p50295
aVIt is the simplest most lightweight inter-process communication available
p50296
aVTo then use it to transfer a pointer rather defeats the process
p50297
as(dp50298
g7
V505088
p50299
stp50300
a((dp50301
g2
(lp50302
VUse
p50303
as(dp50304
g7
V505088
p50305
stp50306
a((dp50307
g2
(lp50308
VAre manual filler values really necessary when converting a C enum which is started from nonzero value
p50309
aVNo they are not necessary
p50310
aVIf you are compiling with Delphi 6 or later you can write it like this:
p50311
aVIn fact I believe that the reason this capability was introduced in Delphi 6 was to make it easier to write C header translations
p50312
aVThis was pertinent to the Delphi 6 development phase because it went hand-in-hand with the first release of Kylix which of course had a lot of interaction with Linux C libraries
p50313
as(dp50314
g7
V505088
p50315
stp50316
a((dp50317
g2
(lp50318
VYou can use the  tool from the FreePascal project
p50319
aVInvoke it like this:
p50320
aVThe output are files named  and  containing the IDs and targets of your aliases
p50321
as(dp50322
g7
V505088
p50323
stp50324
a((dp50325
g2
(lp50326
Vdcc32 options from the following places:
p50327
aVA dcc32
p50328
aVcfg file
p50329
aVThis can be either in the current directory, or the same directory as dcc32
p50330
aVexe
p50331
aVThe command line
p50332
aVThe source code
p50333
aVI have order these in order of increasing precedence
p50334
aVSo, an option specified in source code always overrides settings made a dcc32
p50335
aVcfg file, or on the command line
p50336
aVdcc32
p50337
aVexe will choose whichever dcc32
p50338
aVcfg file it finds first
p50339
aVIt looks in the current directory first
p50340
aVWhat all this means is that you are responsible for getting the settings from the
p50341
aVdof file, and from the IDE into your command line compilation environment
p50342
aVThis is one of the many reasons why you should upgrade
p50343
aVModern Delphi versions use msbuild for command line compilation and make it trivially easy to be sure that your command line builds are the same as IDE builds
p50344
aVWhen you watch an msbuild in progress you will see that it results in a call to dcc32
p50345
aVexe with all options specified on the command line
p50346
aVTransforming the project settings into a call to dcc32
p50347
aVexe is what you are now faced with
p50348
aVIn Delphi 6 you have to do that yourself
p50349
aVIn modern Delphi, the tools are part of the product
p50350
as(dp50351
g7
V505088
p50352
stp50353
a((dp50354
g2
(lp50355
VYou don't need to use unsafe code
p50356
aVYou can do it like this:
p50357
aVAlthough this interface design is just asking for a buffer overrun
p50358
aVHow are you supposed to know how big the unmanaged buffer is
p50359
aVIt would make more sense for the  parameter to be passed by
p50360
aVOn input it would tell you how big the buffer is
p50361
aVOn output you would have recorded how many bytes you copied into the buffer
p50362
as(dp50363
g7
V505088
p50364
stp50365
a((dp50366
g2
(lp50367
VIt's probably easier to do this using Python's built in regex module, , rather than shelling out to
p50368
aVI know this doesn't answer the question directly but it's probably the right solution to the underlying problem
p50369
aVI think this falls into the "is there a better way to do this
p50370
aVpart of your question
p50371
as(dp50372
g7
V505088
p50373
stp50374
a((dp50375
g2
(lp50376
V is an  and so you are subject to the endianness of your machine
p50377
aVI would store this as a char array:
p50378
as(dp50379
g7
V505088
p50380
stp50381
a((dp50382
g2
(lp50383
V doesn't return a value
p50384
aVIt just removes the top value
p50385
aVIt's declared like this:
p50386
aVTo get the top value you need to call
p50387
aVAfter that you can call
p50388
aVThere are a couple reasons why  does not return the value popped
p50389
as(dp50390
g7
V505088
p50391
stp50392
a((dp50393
g2
(lp50394
VYou can simply declare your function in C# like this:
p50395
aVAs it is written, your C++ code would appear to use the  calling convention
p50396
aVSo you may need to make the C# declaration match
p50397
aVI suspect that is the main problem you are facing
p50398
aVNote also that , which you use for the  parameter is 32 bits wide in a 32 bit process, and 64 bits wide in a 64 bit process
p50399
aVSo the correct C# type is
p50400
aVPersonally I'd declare it to be  in both the C++ and C# code
p50401
aVOne final word of advice
p50402
aVWhen you encounter failures, include the error messages in your questions
p50403
aVI suspect your first code failed with this error:
p50404
aVA call to PInvoke function 'MyApp
p50405
aVMyApp
p50406
aVProgram::print_string_array' has unbalanced the stack
p50407
aVAnd if you had included that in the question it would have been a great help
p50408
as(dp50409
g7
V505088
p50410
stp50411
a((dp50412
g2
(lp50413
VThe Pascal equivalent of a C  is known as a variant record
p50414
aVA record type can have a variant part, which looks like a case
p50415
aVstatement
p50416
aVThe variant part must follow the other fields in the record
p50417
aVdeclaration
p50418
aVTo declare a record type with a variant part, use the following
p50419
aVsyntax:
p50420
aVThe first part of the declaration - up to the reserved word case - is
p50421
aVthe same as that of a standard record type
p50422
aVThe remainder of the
p50423
aVdeclaration - from case to the optional final semicolon - is called
p50424
aVthe variant part
p50425
aVIn the variant part,
p50426
aVtag is optional and can be any valid identifier
p50427
aVIf you omit tag, omit the colon (:) after it as well
p50428
aVordinalType denotes an ordinal type
p50429
aVEach constantList is a constant denoting a value of type ordinalType, or a comma-delimited list of such constants
p50430
aVNo value can
p50431
aVbe represented more than once in the combined constantLists
p50432
aVEach variant is a semicolon-delimited list of declarations resembling the fieldList: type constructions in the main part of the
p50433
aVrecord type
p50434
aVThat is, a variant has the form:
p50435
aVfieldList1: type1;
p50436
aVfieldListn: typen;
p50437
aVwhere each fieldList is a valid identifier or comma-delimited list of
p50438
aVidentifiers, each type denotes a type, and the final semicolon is
p50439
aVoptional
p50440
aVThe types must not be long strings, dynamic arrays, variants
p50441
aV(that is, Variant types), or interfaces, nor can they be structured
p50442
aVtypes that contain long strings, dynamic arrays, variants, or
p50443
aVinterfaces; but they can be pointers to these types
p50444
aVRecords with variant parts are complicated syntactically but
p50445
aVdeceptively simple semantically
p50446
aVThe variant part of a record contains
p50447
aVseveral variants which share the same space in memory
p50448
aVYou can read or
p50449
aVwrite to any field of any variant at any time; but if you write to a
p50450
aVfield in one variant and then to a field in another variant, you may
p50451
aVbe overwriting your own data
p50452
aVThe tag, if there is one, functions as
p50453
aVan extra field (of type ordinalType) in the non-variant part of the
p50454
aVrecord
p50455
aVAs for the rest, it's pretty routine:  is a 64 bit integer, and  is , or  in Delphi
p50456
aVIt's possible that  may be more appropriate than
p50457
aVIt's a bit hard to tell of course because C, unlike Pascal, doesn't have separate types for  and
p50458
aVBut these arrays look to me as though they would be read as text so my guess is that  would be more appropriate
p50459
as(dp50460
g7
V505088
p50461
stp50462
a((dp50463
g2
(lp50464
VDisclaimer: Forceful termination of threads is not advisable \u2013 please don't try this at home
p50465
aVI believe you can do what you want like this:
p50466
as(dp50467
g7
V505088
p50468
stp50469
a((dp50470
g2
(lp50471
VThe code I use to perform this task is:
p50472
aVThis code will bring all angles into the range  to
p50473
aVFor example:
p50474
aVoutputs:
p50475
aV355
p50476
ag7303
ag7303
ag7303
as(dp50477
g7
V505088
p50478
stp50479
a((dp50480
g2
(lp50481
VThe behaviour you describe is what happens when your application fails to load
p50482
aVWhen run from the debugger you get a silent failure
p50483
aVWhen run without a debugger you will see an error message, "Application failed to initialize
p50484
aVThis will give details
p50485
aVIn your case it seems that the likely cause is that the dependency of the DLL cannot be resolved by the library loader
p50486
aVThat's why the app runs when the call to the external function is removed
p50487
aVWhen you remove that call, you also remove the dependency on the external DLL
p50488
aVSolve the problem by making sure the DLL can be loaded
p50489
aVFor example place it in the same directory as the executable
p50490
aVThe silent failure from the debugger is rather frustrating
p50491
aVOnce you have experienced it a few times you'll know what to do - run without the debugger to find out what's really going wrong
p50492
aVI also recommend that you don't pass managed Delphi strings across module boundaries
p50493
aVThat will force you to use the same compiler for both executable and DLL
p50494
aVIf you are going to accept that constraint then you may as well use packages
p50495
aVAs your code stands, it would need to use ShareMem to work
p50496
aVBut I don't recommend that
p50497
as(dp50498
g7
V505088
p50499
stp50500
a((dp50501
g2
(lp50502
Vis the correct way to do this
p50503
aVYou'll need
p50504
aVYour compiler error is because you are instantiating a type,
p50505
aVWhen you instantiate that type you ask the compiler to deal with
p50506
aVwhere  is
p50507
aVIf you wrote that code out without generics you'd understand the compiler error
p50508
aVSo, the compiler is behaving correctly here, but the issue of instantiation is catching you out
p50509
aVIt's only at the point of instantiation that the compiler error becomes apparent
p50510
aVWithout instantiation, of if you had instantiated  there would be no compiler error
p50511
aVThe AV is because you were casting  to be an instance rather than a class
p50512
as(dp50513
g7
V505088
p50514
stp50515
a((dp50516
g2
(lp50517
VAnonymous procedures captures variables rather than values
p50518
aVSo you are capturing the variable LObject
p50519
aVSince this is a loop variable, the value of LObject changes
p50520
aVThe anonymous procedures evaluate LObject when they execute rather than when the anonymous procedures are created
p50521
aVRather than using an anonymous procedure, I'd probably just use a method of TMyObject
p50522
aVTry writing the code that way and I predict you will find it easier to understand
p50523
aVThe reason for getting 4 lines of output rather than 3 is probably just that WriteLn is not threadsafe
p50524
aVWrap the call to WriteLn in a lock to clear that up
p50525
as(dp50526
g7
V505088
p50527
stp50528
a((dp50529
g2
(lp50530
VYou need to add an event handler to your class
p50531
aVAnd then connect it up:
p50532
as(dp50533
g7
V505088
p50534
stp50535
a((dp50536
g2
(lp50537
VThe data you have shown in the question looks like UTF-16 encoded data rather than UTF-8
p50538
aVHowever, since you are using a Unicode aware Delphi, and a  data type, clearly there has been an encoding mismatch
p50539
aVYour string variable appears to be double UTF-16 encoded if you can see what I mean
p50540
aVIt would appear therefore that  is assuming that the data is transmitted using ANSI or UTF-8
p50541
aVIn other words, an 8-bit encoding
p50542
aVBut in fact the data is transmitted as UTF-16
p50543
aVTo solve the problem you need to align the reading of the buffer with the transmission of the buffer
p50544
aVYou need to make sure that both sides use the same encoding
p50545
aVUTF-8 would be a good choice
p50546
aVIf the data in the buffer is UTF-16, then you can extract it with
p50547
aVIf you switch to UTF-8 then extract it with
p50548
as(dp50549
g7
V505088
p50550
stp50551
a((dp50552
g2
(lp50553
VYou are trying to serialize a variable of type
p50554
aVTake a look at its declaration:
p50555
aVYour code will serialize the first two fields, but will fail to serialize the hidden field that is part of the implementation detail
p50556
aVThis is a rather special type
p50557
aVYou cannot simply assign one  variable to another
p50558
aVYou are meant to pass around  variables
p50559
aVIn fact, consider the code that sends the type information:
p50560
aVThis code is already broken because it is assigning to a , which as I stated above cannot be done with simple assignment
p50561
aVNow, you obviously cannot trivially serialize a  because that only has meaning in the address space of the process that owns it
p50562
aVAnd you cannot readily call  and serialize the  that is returned
p50563
aVThat's a complex structure which also contains hard to serialize pointers
p50564
aVI suspect the simplest approach will be to roll your own type information serialization mechanism
p50565
aVPerhaps it's enough to send the name of the type and then get the receiver to look it up using that name
p50566
as(dp50567
g7
V505088
p50568
stp50569
a((dp50570
g2
(lp50571
VPython  is not ordered
p50572
aVFor performance reasons, it is more efficient for the implementation to forget the order in which you added items
p50573
aVAs the documentation states:
p50574
aVKeys and values are listed in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionary\u2019s history of insertions and deletions
p50575
aVIf you need an ordered dictionary, you can use
p50576
as(dp50577
g7
V505088
p50578
stp50579
a((dp50580
g2
(lp50581
VYou call  which turns  into
p50582
aVNaturally, when you start at the right answer, no iteration is needed
p50583
aVIn other words, although you intended to use  as your starting value, you actually used
p50584
aVSimply remove the call to
p50585
as(dp50586
g7
V505088
p50587
stp50588
a((dp50589
g2
(lp50590
VDifferent messages have different requirements
p50591
aVSome need to be posted to the queue
p50592
aVAnd some need to be delivered synchronously
p50593
aVSo the system is designed to need both delivery mechanisms
p50594
aVIn the case of , it always needs to be delivered synchronously
p50595
aVThat's because the window manager needs to be able to manage the lifetime of the text data
p50596
aVRaymond Chen talked about this issue: Why can't I PostMessage the WM_COPYDATA message, but I can SendMessageTimeout it with a tiny timeout
p50597
aVThere is a peril with calling  when the window is in another process
p50598
aVIf the other process is hung, that your process will not also become hung
p50599
aVBecause  is synchronous
p50600
aVThe solution is to call
p50601
aVThis will marshal your string data into the other process
p50602
aVAnd you can set a timeout to ensure that, in the eventuality of the other process being hung, your process can avoid that fate
p50603
as(dp50604
g7
V505088
p50605
stp50606
a((dp50607
g2
(lp50608
VUse  to enumerate all top level windows
p50609
aVCall  for each top level window to check whether or not that window belongs to the target process
p50610
aVWhen you find the desired top level window, call  to enumerate all of its children
p50611
aVIf you know the hierarchy, or the window class name, then you should be able to identify which of the children is you target window
p50612
as(dp50613
g7
V505088
p50614
stp50615
a((dp50616
g2
(lp50617
VThe explanation that makes sense is that you have a memory leak
p50618
aVI think you have a mis-understanding of how FastMM leak reporting works
p50619
aVYou seem to infer from the leak report that ,  etc
p50620
aVare responsible for the leak
p50621
aVThat's not the case
p50622
aVA leak is reported when memory is allocated but not subsequently deallocated
p50623
aVIn the case of functions like  and , their job is to create new strings which naturally involves allocation of memory
p50624
aVThe leak is reported because the memory that was created to hold the string buffer was not deallocated
p50625
aVIt is not the fault of  or , the allocating function, when the rest of the code fails to deallocate that memory
p50626
aVDelphi 2007 is a mature product and the memory management for strings is known to be correct
p50627
aVPerhaps you do some manual memory copying that bypasses the reference counting for strings
p50628
aVAre you setting some variables/fields to  with a call to
p50629
aVAre you disposing of a record with  instead of
p50630
aVThe former will not decrement the strings reference count
p50631
aVSomething like this is the likely cause of the leak
p50632
aVLooking at extracts of the code you posted, this is a problem:
p50633
aVYou have failed to call the inherited destructor
p50634
aVWhich means that the members of the list won't be destroyed
p50635
aVWhich explains why your string is not destroyed
p50636
aVIn fact you don't need to provide a destructor for the list class
p50637
aVSimply remove it and let the inherited  destructor do the work
p50638
aVSince defaults to , any members of the list are destroyed as soon as they are removed from the list, and when the list itself is destroyed
p50639
aVIf your  method actually cleared the list, then that would happen
p50640
aVBut your  isn't a real
p50641
aVA real  in a container is expected to remove all members
p50642
aVYou should remove your  and rely on the inherited version
p50643
aVIn , you also fail to call the inherited destructor
p50644
aVAnd also fail to destroy the string list instance that is owned by that class
p50645
aVTo summarise, I'd write these constructors and destructors like this:
p50646
aVAnd then remove the , and remove the  method
p50647
aVThe versions inherited from  suffice
p50648
aVIn the comments you state:
p50649
aVThe objects' destructors are called as soon as the objects are used to display the node tree
p50650
aVAfter that they are obsolete, and are deallocated (I hope)
p50651
aVI'd say there's a good chance that this is not helping
p50652
aVSince you created the object list in  mode, you should not be destroying the members of the list at all
p50653
aVYou've asked the list itself to do that
p50654
aVYou can't both do it
p50655
aVAnd the "I hope" comment doesn't fill me with much confidence that this code is correct
p50656
aVSince we can't see all of your code, I'm far from sure that this is the entirety of the problems with it
p50657
aVThe bottom line is that your code has leaks
p50658
aVTrust in FastMM
p50659
as(dp50660
g7
V505088
p50661
stp50662
a((dp50663
g2
(lp50664
VThe error in the pinvoke
p50665
aVnet code is that the attribute is missing the initial
p50666
aVInstead of
p50667
aVit should read
p50668
aVHowever,  is not really very sensible here
p50669
aVSure you can specify all the field offset, but why make it hard for yourself
p50670
aVUse
p50671
aVSince that is the default, you can simply omit the attribute
p50672
as(dp50673
g7
V505088
p50674
stp50675
a((dp50676
g2
(lp50677
VYou can use a number of methods to get a larger block of memory
p50678
aVin fact takes an  which is a 64 bit sized value on 64 bit
p50679
aVCall the native function
p50680
aVAgain, it takes a pointer sized parameter
p50681
aVCall the native function  which also takes a pointer sized parameter
p50682
aVSince you state that  only takes a 32 bit parameter, then it would appear that your process is 32 bit
p50683
aVAnd that's the real problem
p50684
aVIn a 32 bit process you cannot allocate more than 4GB (total)
p50685
aVAnd that limit is imposed by the size of your pointers
p50686
aVAs a further limit, in a 32 bit OS, a process cannot allocate more than 2GB (total)
p50687
aVSo, I suggest that you need to switch to a 64 bit process to solve your problem
p50688
as(dp50689
g7
V505088
p50690
stp50691
a((dp50692
g2
(lp50693
VI'm not entirely sure I understand your question, but I think you are looking for something like this:
p50694
aVThat said, I can't see the point of that class
p50695
aVYou could just use  from
p50696
aVAnd if your need an array, then you can use a dynamic array:  or , as you prefer
p50697
as(dp50698
g7
V505088
p50699
stp50700
a((dp50701
g2
(lp50702
VYour solution using a named mutex will work and is for sure the simplest approach
p50703
as(dp50704
g7
V505088
p50705
stp50706
a((dp50707
g2
(lp50708
VThere's no definitive documentation giving the list of all the things you can do and connot do in a form's OnCreate
p50709
aVAs for whether or not the
p50710
aVdfm file has been processed and all the form's owned components created, yes they have
p50711
aVI wouldn't place much store in the code you have found
p50712
aVCalling Sleep during start up, to make the main thread wait, is absolutely not good practice
p50713
aVIf the code wanted to wait for another thread it could block for that thread, or wait to get a message from that thread
p50714
aVThis just looks like code that got put in by someone who didn't understand what he/she was doing
p50715
aVAnd the code never got removed
p50716
aVThe other line of code is reasonable:
p50717
aVBecause this message is posted, it won't get processed until the application starts pumping messages
p50718
aVThat happens when you call Application
p50719
aVRun in your
p50720
aVdpr file
p50721
aVWhich means that everything related to the creation of you main form happens before that message is pulled off the queue
p50722
as(dp50723
g7
V505088
p50724
stp50725
a((dp50726
g2
(lp50727
VI suggest that you do the following:
p50728
aVSave to an in memory stream
p50729
aVUse TMemoryStream, and call SaveToStream on the bitmap
p50730
aVCompress the stream, perhaps using the zlib unit
p50731
aVThis step is optional
p50732
aVEncode the stream using base64
p50733
aVFor example you can use the functionality provided by Soap
p50734
aVEncdDecd
p50735
aVAnd in the opposite direction, well you just reverse the steps
p50736
as(dp50737
g7
V505088
p50738
stp50739
a((dp50740
g2
(lp50741
VYour Delphi 2006 program is calling the ANSI version of ShellExecute, namely ShellExecuteA
p50742
aVThat receives ANSI parameters
p50743
aVWhen those arguments arrive in your Delphi XE2 program, they will be retrieved via GetCommandLine
p50744
aVAnd XE2 programs will call the Unicode version, GetCommandLineW
p50745
aVBut behind the scenes, Windows will have converted from ANSI to Unicode for you
p50746
aVThis sort of context sensitive conversion happens all the time in Windows
p50747
aVFor example, you call SendMessageA, for WM_SETTEXT, passing a PAnsiChar
p50748
aVBut the window is a Unicode window and so receives a PWideChar
p50749
aVThe system has to be this way
p50750
aVAnything else would be anarchy
p50751
aVThe source of your problem is not that one program uses ANSI, and the other Unicode
p50752
aVYour problem is elsewhere
p50753
aVWhere exactly, it's impossible to tell with this information
p50754
aVOne obvious possibility is that your argument contains spaces
p50755
aVThose spaces are interpreted as argument separators by the recipient, the XE2 program
p50756
aVWrap your arguments in quote marks
p50757
aVLike this:
p50758
aVAnother possibility is that you are perhaps casting the argument to PAnsiChar when you receive it
p50759
aVIf so, don't
p50760
aVJust read ParamStr(1) which is a Unicode string
p50761
aVConverted from ANSI for you by Windows
p50762
aVI'm clearly guessing a little at the end here, but there's frankly not enough information to diagnose the fault definitively
p50763
aVBut I can be sure that ANSI text is transparently converted to Unicode in your scenario
p50764
as(dp50765
g7
V505088
p50766
stp50767
a((dp50768
g2
(lp50769
VWell, the obvious difference is that  opens the file, using the  API to obtain a file handle
p50770
aVIn contrast,  does not because it reads the size from the file meta data
p50771
aVSo I would expect  to perform better
p50772
aVAlthough, for many applications that performance difference would not matter
p50773
aVMuch more significantly,  can fail due to a sharing violation in situations that  will succeed
p50774
aVSo you really should not use
p50775
aVNote also that the two functions you present behave differently in case of an error:  returns -1, and  raises an exception
p50776
aVPersonally I prefer this version:
p50777
aVOr, if you prefer to return -1 in case of error you would write it like this:
p50778
aVSome how this feels more natural than calling , but that's perhaps just personal preference
p50779
aVThere's really nothing wrong with the  approach
p50780
aVAlthough it doesn't need that  variable
p50781
aVYou can write it more clearly like this:
p50782
aVUpdate: @CodeInChaos makes a good point about the approaches that don't open a file handle
p50783
aVThese approaches can give inaccurate results for hard linked files
p50784
as(dp50785
g7
V505088
p50786
stp50787
a((dp50788
g2
(lp50789
VThe function you are looking at already has a point at which it skips directories:
p50790
aVSo you can simply extend this condition
p50791
aVHowever, I would not extend it by adding another  clause
p50792
aVI personally find  statements like this to be exceedingly opaque
p50793
aVI would introduce an explanatory variable:
p50794
aVand then assign it like this:
p50795
aVAnd then you need to re-work your  to receive a  parameter:
p50796
aVAlthough I'd probably re-write @Sertac's if statement to break it up a bit more
p50797
aVBut perhaps that's just my personal preference
p50798
as(dp50799
g7
V505088
p50800
stp50801
a((dp50802
g2
(lp50803
VTrying to use overloading here just leads to pain and suffering
p50804
aVJust imagine what happens when you want to use an integer literal
p50805
aVOr imagine you want to pass NextWord an index that is an expression, e
p50806
ag217
aVa+b
p50807
aVOr you pass the return value of a function
p50808
aVAre you going to have functions that return the various dedicated types that you propose to define
p50809
aVAnd think about any human that has to read the code
p50810
aVHow would they be expected to determine which overload is being called
p50811
aVYou can avoid all the pain by giving your functions different names
p50812
aVOverloading is appropriate when you have multiple functions that take parameters with different types
p50813
aVThat is not the case here
p50814
aVYour functions take parameters with the same type
p50815
aVAnd so your functions need different names
p50816
aVAnother way to organise it would be to have a single function, but to pass more to the function
p50817
aVPass the index, and an enumerated type which describes how to interpret that index
p50818
aVYou could combine those two values into a record
p50819
as(dp50820
g7
V505088
p50821
stp50822
a((dp50823
g2
(lp50824
VIn order to have write access to HKLM, your process needs to run as a user with admin rights
p50825
aVIn addition, on systems which include UAC (Vista and up), your process will need to run elevated
p50826
aVTo achieve that specify  in your application manifest
p50827
aVIt is important that you don't run your application with elevated rights unless it is strictly necessary
p50828
aVYou can move the portion of the application that needs to write to  into a one time only operation, e
p50829
ag217
aVyour install program
p50830
aVOr you can separate your application into two parts: the large part that runs with normal rights, and the small part that requires elevation
p50831
aVThe reason that you may need to split your application into smaller parts is that the user token is assigned at process startup and cannot be modified during the life of the process
p50832
aVSo, if you want some parts of your application to be elevated, and others not, you need to have two distinct processes
p50833
as(dp50834
g7
V505088
p50835
stp50836
a((dp50837
g2
(lp50838
VYou can view a bitmap handle, an HBITMAP, as an ID
p50839
aVSo, pass them around by value
p50840
aVThey are pointer sized so there's no performance issues with pass by value for an HBITMAP
p50841
as(dp50842
g7
V505088
p50843
stp50844
a((dp50845
g2
(lp50846
VThat method is an instance method of the form and so  refers to the text, or caption, of the form
p50847
aVYou need to use
p50848
aVinstead
p50849
aVAlthough, to avoid duplication you should use a local variable to hold the edit control reference:
p50850
as(dp50851
g7
V505088
p50852
stp50853
a((dp50854
g2
(lp50855
VIt looks to me as though you are using the wrong syntax for your regex
p50856
aVlooks like Perl regex syntax
p50857
aVFor Delphi's  you need to remove the slash delimiters and specify case insensitivity through an options parameter
p50858
aVLike this:
p50859
as(dp50860
g7
V505088
p50861
stp50862
a((dp50863
g2
(lp50864
VWindow handles and process handles are not the same thing
p50865
aVFor  you need a window handle
p50866
aVAfter creating the process call  to allow the process to start up and create its main window
p50867
aVCall  to enumerate the top level windows
p50868
aVFor each top level window, call  to find out the process ID of the process that created that window
p50869
aVThe process ID of the process you created is
p50870
aVWhen you have find a window with process ID that matches that of the process you just created, that window is your guy
p50871
as(dp50872
g7
V505088
p50873
stp50874
a((dp50875
g2
(lp50876
VMy guess is that you are missing the  unit from your
p50877
aVdpr file's uses clause
p50878
aVAdd that and you will be able to write:
p50879
aVin your
p50880
aVdpr file
p50881
aVAlthough clearly you need to write it after the uses clause
p50882
aVThe  feature was added a few versions before Delphi 2007
p50883
aVAnd so the error that you are presumably seeing is simply that  is not declared
p50884
aVAnd that is solved by making sure that the symbol is visible in the
p50885
aVdpr file
p50886
aVClearly you can do that by declaring a constant in the
p50887
aVdpr file, but to avoid duplication I always prefer to add the Windows unit
p50888
as(dp50889
g7
V505088
p50890
stp50891
a((dp50892
g2
(lp50893
VYou are making it far harder than it needs to be
p50894
aVRealVNC already comes equipped with features that allow you to connect without requiring interaction
p50895
aVAll you need to do is create a text file containing the necessary options and pass that to the RealVNC viewer program on startup
p50896
aVThe text file might look like this:
p50897
aV[Connection]
p50898
aVHost=myhost
p50899
aVcom::666
p50900
aVEncryption=AlwaysOn
p50901
aVUsername=domain\u005cuser
p50902
aVPassword=********
p50903
aV[Options]
p50904
aVYou can get RealVNC to create the file for you by opening the connection, bringing up the RealVNC menu (i
p50905
ag192
aVwith F8), and then selecting Save Connection
p50906
aVThis will save a
p50907
aVvnc file containing all the settings of that connection
p50908
aVJust pass that
p50909
aVvnc file to the viewer program on startup and it's all good
p50910
aVAll you need to do therefore is:
p50911
aVCreate the
p50912
aVvnc connection files
p50913
aVChange the command line to
p50914
aVRemove all the code after the call to
p50915
aVCall  on the two handles returned by
p50916
aVFor your needs I suggest that calling  is probably easier than
p50917
as(dp50918
g7
V505088
p50919
stp50920
a((dp50921
g2
(lp50922
VYou cannot easily use  with data passed by reference
p50923
aVThe reason being that  executes asynchronously and you need to keep the memory you are passing alive until the message has been processed by its recipient
p50924
aVI guess that's what is behind your  code
p50925
aVObviously this only works within the same process
p50926
aVAnd you will also find that Windows won't let you use  for any of its messages that receive pointers
p50927
aVFor example,  with  always fails
p50928
aVYou can only hope to do this using a user-defined message
p50929
aVAnd of course you'll need to deallocate the memory in the code that receives the message
p50930
aVI'm going to assume that you are using a user defined message that does allow sending a string with
p50931
aVIn which case you already have the solution
p50932
aVDo the concatenation using string variables and then use the first block of code in your answer
p50933
aVAlthough you can make it much cleaner like this:
p50934
aVAnd you can just call that procedure like this:
p50935
aVYour current code fails because:
p50936
aVWhen you call  you don't allocate any memory for the longer string
p50937
aVWhen you write  you fall into the trap of that you were trying to avoid with
p50938
aVThat's a local string which has been deallocated by the time the message is processed
p50939
aVIf you can find a way of solving your problem without using  to pass a string, that might be preferable to all this complexity
p50940
as(dp50941
g7
V505088
p50942
stp50943
a((dp50944
g2
(lp50945
VYou can simply read  from
p50946
aVOr you can use  to return the full path to the executable file associated with a process handle
p50947
as(dp50948
g7
V505088
p50949
stp50950
a((dp50951
g2
(lp50952
VYou can always safely use these two types interchangeably in API translations
p50953
aVAlthough, clearly, once you have selected one type for a particular function, you have to stick to that type whenever you call that function
p50954
aVUsing  makes it easier to assign values because there's no need to refer to a record field
p50955
aVUsing  makes it easier to separate into low and high 32 bit parts
p50956
aVNow that the compiler has good support for 64 bit integers, it probably makes more sense to use
p50957
aVBecause, usually, there is no need to separate the 64 bit integer into its low and high parts
p50958
aVBut way back when the compiler couldn't handle 64 bit integer types, there was no other option to work with 64 bit integers
p50959
as(dp50960
g7
V505088
p50961
stp50962
a((dp50963
g2
(lp50964
VThe question (now) asks for:
p50965
aVThe next multiple of b that is not less than a
p50966
aVUsing your notation of  and , you can write it directly like this:
p50967
aVThe question originally asked for
p50968
aVThe next multiple of a that is not greater than b
p50969
aVAnd for that the answer is
p50970
aVThis was the answer for which the original comments applied to
p50971
as(dp50972
g7
V505088
p50973
stp50974
a((dp50975
g2
(lp50976
VAndreas gave you a good answer to the direct question that you asked
p50977
aVTaking a different approach, I think you could solve your problem more easily by passing the locale when you initlialise the object
p50978
aVFor example:
p50979
aVfor Italian
p50980
aVThen the system will fill out the locale specific settings, day names, month names etc
p50981
aVOr perhaps you would use the overload that takes a locale ID is more appropriate
p50982
aVNo matter, you surely get the idea
p50983
as(dp50984
g7
V505088
p50985
stp50986
a((dp50987
g2
(lp50988
VThe  variable in that function has not been initialized and could hold any value
p50989
aVNow, the implementation detail means that, in some combinations of compiler options, your code happens to run with  referring to a valid object
p50990
aVBut that's really just a coincidence of those implementation details
p50991
aVIf this were C++ then that function would exhibit undefined behaviour
p50992
aVAlthough that term does not have a formal meaning in Delphi, it can be helpful to use that term in a Delphi setting to mean the same thing as in the context of C++
p50993
aVI would also make the point that even if  did not refer to a valid string list object, your code would not be guaranteed to raise an access violation
p50994
aVIt could be that  points to a block of memory that just happens to look enough like a string list for that code to execute successfully
p50995
aVIf you do things properly, you can predict the behaviour of your program
p50996
aVIf your code is flawed and induces undefined behaviour, then your program's behaviour becomes unpredictable
p50997
aVIt may work
p50998
aVIt may fail
p50999
aVOr that code may execute fine, but then lead to a failure later in the program's execution
p51000
aVAnd so on
p51001
as(dp51002
g7
V505088
p51003
stp51004
a((dp51005
g2
(lp51006
VThis code
p51007
aVfails just as the error message describes:  is a module and is not callable
p51008
aVPresumably you should be calling some function or class defined in the  module
p51009
aVBut since I can't find any documentation for that module, and since you didn't give any information, I can't tell you what the code should look like
p51010
as(dp51011
g7
V505088
p51012
stp51013
a((dp51014
g2
(lp51015
VIn a plain vanilla application, the code in the question results in  executing when an object is dropped on the form
p51016
aVSo, clearly there's something else happening to stop it working
p51017
aVThe most obvious potential causes are:
p51018
aVThe main form's window handle is re-created after the initial call to
p51019
aVYour process is running at a higher integrity level than the process that is dropping files on it
p51020
aVFor example, are you running your process as administrator
p51021
aVNote that running the Delphi IDE as administrator would lead to your process running as administrator when started from the IDE
p51022
aVSomething else in your process is interfering with drag/drop
p51023
aVWithout knowing what's in your app, it's hard to guess what this could be
p51024
aVStart removing portions of your app until there's nothing left but the code in the question
p51025
aVOption 2 seems quite plausible
p51026
aVTo learn more see: Q: Why Doesn\u2019t Drag-and-Drop work when my Application is Running Elevated
p51027
aV\u2013 A: Mandatory Integrity Control and UIPI
p51028
as(dp51029
g7
V505088
p51030
stp51031
a((dp51032
g2
(lp51033
VIf you cannot use a modern Delphi which includes this interface, you need to translate the interface from the Windows header files, in this case
p51034
aVIn Delphi it begins like this:
p51035
aVThe GUID can be found in the header file
p51036
aVYou then need to add in the functions
p51037
aVIt's essential that you add them in the same order as they are declared in the header file
p51038
aVThe functions should all be declared as
p51039
aVI don't want to post the entire interface declaration from the XE3 source because I'd consider that to be a copyright violation
p51040
aVPerhaps if you search hard enough you might find this code on the web somewhere
p51041
aVAnd in fact, I just found it: http://mustangpeakcommonlib
p51042
aVgooglecode
p51043
aVcom/svn-history/r12/trunk/Source/MPShellTypes
p51044
aVpas
p51045
as(dp51046
g7
V505088
p51047
stp51048
a((dp51049
g2
(lp51050
VIt's a largely non-issue on the architectures that Delphi supports
p51051
aVThe x86 and x64 architectures forgive you if you access mis-aligned data
p51052
aVOn the other hand, accessing mis-aligned data on Itanium will result in runtime errors
p51053
aVBut Delphi never targeted Itanium
p51054
aVThe issue that is significant is record layout
p51055
aVAn Int64 has alignment of 8
p51056
aVBut FILETIME and LUID have alignment of 4
p51057
aVWhich is why LUID_AND_ATTRIBUTES is marked with an explicit $ALIGN 4
p51058
aVIf you are going to declare FILETIME and LUID to be Int64 then you need to take special care with record layout every time you include one in a record
p51059
as(dp51060
g7
V505088
p51061
stp51062
a((dp51063
g2
(lp51064
VWill increase in stack reserve size and stack commit size improve application performance
p51065
aVAlmost certainly it will make no discernible difference to performance
p51066
aVWill it avoid Out of Memory issues which we come across
p51067
aVNo
p51068
aVIf you run out of stack space then you get a stack overflow error rather than out of memory
p51069
as(dp51070
g7
V505088
p51071
stp51072
a((dp51073
g2
(lp51074
VThe compiler is being a little lax because there is no ambiguity in doing so
p51075
aVConsider the following:
p51076
aVwhich produces this output:
p51077
aVTest1Integer
p51078
aVTest1OpenArray
p51079
aVTest2
p51080
aVI've overloaded  so that there is a version that receives an integer, and a version that receives an open array of integers
p51081
aVIn that situation, the call  goes to the overload that receives just an integer
p51082
aVOn the other hand, I can call  which receives an open array, just by passing an integer
p51083
aVI believe that this behaviour is not documented in the language guide
p51084
aVHowever, @hvd found the following in the documentation for compiler error E2192 (emphasis mine):
p51085
aVOpen array arguments must be supplied with an actual array variable, a constructed array or a single variable of the argument's element type
p51086
as(dp51087
g7
V505088
p51088
stp51089
a((dp51090
g2
(lp51091
VWhen you use
p51092
aVthe system will look for the DLL in the DLL search path
p51093
aVThe first place searched is the directory which contains your executable file
p51094
aVThat's the best place to put your DLL
p51095
aVIf you see "entry point not found" then that means simply that the entry point was not found
p51096
aVThe article you link to does not use p/invoke to link to the C++ DLL
p51097
aVThat article describes how to link to a native DLL from managed C++
p51098
aVSo you appear to be doing something different from that since you are using C# and p/invoke
p51099
aVUnless you supply precise details of what you are doing, for example the code, it's hard to prescribe a remedy
p51100
aVOK, now you have added some code
p51101
aVThat helps a lot
p51102
aVYou should not use static methods for p/invoke exports
p51103
aVRemove the  and have plain old C-style functions:
p51104
aVNo need for a header file that declares those functions
p51105
aVJust a single
p51106
aVcpp file should get it done
p51107
aVThe use of  stops your names from being mangled by the C++ compiler
p51108
aVIf you need to inspect your DLL to see what it exports, use Dependency Walker
p51109
aVOn the C# side use:
p51110
as(dp51111
g7
V505088
p51112
stp51113
a((dp51114
g2
(lp51115
VWell, to answer directly the question that you asked, you would do it like this:
p51116
aVBut your approach is quite possibly not the best solution to your actual problem
p51117
as(dp51118
g7
V505088
p51119
stp51120
a((dp51121
g2
(lp51122
VSince the  field is a pointer to memory allocated in the native code, you are going to need to declare it as  in the C# code
p51123
aVIf you want to access individual pixels in the C# code you'll need to write a  method, just as you did in the C++ code
p51124
aVNote that since the  field is a pointer to memory allocated in the native code, I'd expect the actual code to have a destructor for the struct that calls
p51125
aVOtherwise your code will leak
p51126
aVThis also means that you are going to need to create and destroy instances in the native code, and never do so in the managed code
p51127
aVIs this the policy you currently follow
p51128
aVI suspect not based on the code that I can see here
p51129
aVYou also need to reconsider passing the  by value
p51130
aVDo you really want to take a copy of it when you call that function
p51131
aVDoing so means you've got two instances of the struct whose  fields both point to the same memory
p51132
aVBut, which one owns that memory
p51133
aVThis structure really needs to be passed by reference
p51134
aVI think you've got some problems in your design, but I can't see enough of the code, or know enough about your problem to be able to give you concrete advice
p51135
aVIn comments you state that your main goal is to transfer these bits from your C# code to the C++ code
p51136
aVI suggest you do it like this:
p51137
aVOn the C# side you can declare it like this:
p51138
as(dp51139
g7
V505088
p51140
stp51141
a((dp51142
g2
(lp51143
VWhat you are actually doing is converting from host byte order to network byte order
p51144
aVAll standard sockets libraries provide helper functions to do that
p51145
aVFor example, Winsock offers htons, htonl etc
p51146
aVAnd in the opposite direction you have ntohs, ntohl etc
p51147
aVIf you are using Indy, then the equivalent functions are  and
p51148
aVYou should serialize each field into a byte stream, with each field being transformed by the appropriate hton* function
p51149
aVThen you can put the byte stream on the wire
p51150
as(dp51151
g7
V505088
p51152
stp51153
a((dp51154
g2
(lp51155
VIn your design time package for the component, implement a component editor:
p51156
aVYou need to register this component editor also
p51157
aVCall  in your  procedure to do so:
p51158
as(dp51159
g7
V505088
p51160
stp51161
a((dp51162
g2
(lp51163
VIn this case, since the record will have no padding, you can simply copy the contents of the buffer onto your record
p51164
aVAnd then you need to convert from network byte order to host byte order
p51165
aVAnd you know how to do that from your previous question
p51166
aVTo make sure that you don't ever get caught out by record padding/alignment issues you would be advised to pack any records that you blit onto the wire:
p51167
aVYou also ought to check that  contains the right amount of information before calling
p51168
aVPersonally I would probably build your record into something a little more powerful, making use of Indy's functions to convert between host and network byte order
p51169
aVPut it all together and your de-serializing code looks like this:
p51170
as(dp51171
g7
V505088
p51172
stp51173
a((dp51174
g2
(lp51175
VIs there a way to prevent IDE from deleting functions/
p51176
aVprocedures with empty bodies on save
p51177
aVThere is no option in the IDE to disable this behaviour
p51178
as(dp51179
g7
V505088
p51180
stp51181
a((dp51182
g2
(lp51183
VYour code already retrieves all the data
p51184
aVThat is the RTF representation of the contents of the control
p51185
aVThere's no text because your control doesn't have any text in it
p51186
aVIt appears to contain only a metafile vector image
p51187
aVIf you sent that control a  message to obtain plain text, then you'd get back nothing
p51188
aVBecause the control doesn't contain text, only an image
p51189
as(dp51190
g7
V505088
p51191
stp51192
a((dp51193
g2
(lp51194
VThe other program has opened the file with a sharing mode that does not allow other processes to read it
p51195
aVTypically this happens when the other application is writing to the file
p51196
aVThere's not a whole lot you can do about this
p51197
aVThis is perfectly normal behaviour, and is to be expected
p51198
aVYou can try detecting the error, waiting for a short period of time, and re-trying
p51199
aVSince you are already running this on a timer, the re-try will just happen
p51200
aVSo perhaps you just need to suppress those exceptions:
p51201
aVNote that detecting  is perhaps a little crude
p51202
aVPerhaps there are other failure modes that lead to that error
p51203
aVHowever, as a first pass, the code above is a decent start
p51204
as(dp51205
g7
V505088
p51206
stp51207
a((dp51208
g2
(lp51209
VIt's easy enough to test whether or not there is a systematic problem with string values containing underscores
p51210
aVYou can simply create such a value in the registry editor and then read it into your C# program with
p51211
aVWhen you do so you'll discover that the C# registry code doesn't lose underscores
p51212
aVSo, there must be some other explanation for your problem
p51213
aVMy best guess is that your label component does not display the underscore
p51214
aVI'm not very familiar with the C# UI frameworks but that seems plausible
p51215
aVTry looking at the value of  under the debugger rather than in a label caption on your UI
p51216
aVThe other thing that comes to mind is that you have registry redirection because you have an x86 process running on x64, and your key is under a redirected key, HKLM\u005cSoftware, for example
p51217
aVPerhaps if you look under the Wow6432Node you will see the underscore discrepancy
p51218
aVAs for managing the life of the key, the key is backed by an unmanged resource
p51219
aVNamely a Windows
p51220
aVThe  class implements  and so you should wrap your keys in a  statement
p51221
as(dp51222
g7
V505088
p51223
stp51224
a((dp51225
g2
(lp51226
VI bet that you have a 64 bit machine and a 32 bit process
p51227
aVThe File System Redirector comes in to play and  redirects to
p51228
aVThe best way to avoid the redirector is to execute a 64 bit process
p51229
aVOr you could list  to get the 64 bit system folder from a 32 bit process
p51230
aVYou can even disable the File System Redirector but that is quite a dangerous thing to do and I would not recommend it
p51231
aVAlso, you tidy up the find handle by calling  rather than
p51232
aVYou should be adding the backslash before calling
p51233
aVAnd test for special  and  by comparing the full name against those special values
p51234
as(dp51235
g7
V505088
p51236
stp51237
a((dp51238
g2
(lp51239
VRead the executable file name from Application
p51240
aVExeName
p51241
aVAnd then call CopyFile to perform the copy
p51242
aVRegarding your update:
p51243
aVThe destination needs to be a file
p51244
aVYou are attempting to copy a file to a path that specifies a folder
p51245
aVYou didn't check for errors
p51246
aVWhen you call an API function like , you need to check the return value
p51247
aVYou want something like this:
p51248
as(dp51249
g7
V505088
p51250
stp51251
a((dp51252
g2
(lp51253
VAn expression like
p51254
aVis evaluated at compile time
p51255
aVWhich means that an assignment
p51256
aVresults in identical compiled code to
p51257
aVOn the other hand, for
p51258
aVthe concatenation is performed at runtime
p51259
as(dp51260
g7
V505088
p51261
stp51262
a((dp51263
g2
(lp51264
VUse HexToBin:
p51265
aVNow, the docs say:
p51266
aVThe hexadecimal number must use lower-case characters; HexToBin does not recognize upper-case characters
p51267
aVBut it turns out that this statement is incorrect and  works no matter what case text you give it
p51268
as(dp51269
g7
V505088
p51270
stp51271
a((dp51272
g2
(lp51273
VThe answer to this question is yes
p51274
aVMemory is owned by the process in which it resides
p51275
aVIt is not owned by the process which allocated it
p51276
aVIn many ways, this is similar to calling  from one thread and then  from another
p51277
aVThat's perfectly fine
p51278
aVAnd it's perfectly fine to do the equivalent with  and
p51279
as(dp51280
g7
V505088
p51281
stp51282
a((dp51283
g2
(lp51284
VYou should use quotes around parameters that contain spaces:
p51285
aVd:/program1
p51286
aVexe text1 text2 "text3 text4 text5"
p51287
aVWhen you invoke you program like this ParamStr(1) is 'text1', ParamStr(2) is 'text2' and ParamStr(3) is 'text3 text4 text5'
p51288
as(dp51289
g7
V505088
p51290
stp51291
a((dp51292
g2
(lp51293
VIt seems that you are not calling  and so the memory is not being freed
p51294
aVIf you want to free it then you clearly will need to call
p51295
aVHowever, you'd need to wait until the remote thread was signaled before doing so
p51296
aVIn a comment you say:
p51297
aVMy process closes before the thread does
p51298
aVHow am I supposed to free it then
p51299
aVWell, that will present a challenge
p51300
aVOne suggestion is that you don't attempt to free this memory at all
p51301
aVInstead that would make sure that you allocate it once only
p51302
aVYou are allocating the memory every time you create a thread
p51303
aVChange that policy to allocate the memory once and then re-use it for each subsequent thread that you create
p51304
aVThe alternative to this is to make sure that your process waits for the remote thread, and then deallocates
p51305
aVDo that by calling  on the remote thread handle
p51306
aVNote that the remote thread handle is the return value from
p51307
aVYou currently ignore it
p51308
as(dp51309
g7
V505088
p51310
stp51311
a((dp51312
g2
(lp51313
VI presume that  is a property
p51314
aVAnd you cannot pass a property to a  or  parameter
p51315
aVYou can only pass variables to parameters of those kinds
p51316
aVYou'll need to find a different way to write your code
p51317
aVYou've come up with one such idea, but  it seems needlessly complex to me
p51318
aVI cannot see anything simpler than:
p51319
aVHow could there be any code simpler than this
p51320
aVYou need to specify at a bare minimum the following:
p51321
aVThe target control
p51322
aVThat we are dealing with the  property
p51323
aVThe fact that we are assigning
p51324
aVThe new value
p51325
aVThe code above does that and nothing more
p51326
as(dp51327
g7
V505088
p51328
stp51329
a((dp51330
g2
(lp51331
VThe documentation to  contains the answer
p51332
aVThe C++ signature of that method is:
p51333
aVThat translates to Delphi as:
p51334
aVThat said, the Delphi translation in  declares the parameter to be  which is semantically incorrect
p51335
aVAs it happens it doesn't really matter
p51336
aVPut it all together and you code should read like this:
p51337
aVNote that I have added some error checking
p51338
aVYou should too
p51339
aVThe code in your question calls three different COM methods and in each case fails to check for errors
p51340
as(dp51341
g7
V505088
p51342
stp51343
a((dp51344
g2
(lp51345
VYou cannot realistically expect to use the same approach in your list class as you use in the simple class that serializes access to a single object
p51346
aVFor example, your list class has, like so many before it, a  property, and an indexed  property
p51347
aVI'm going to presume that your threading model allows the list to mutate
p51348
aVNow, suppose you want to write code like this:
p51349
aVSuppose that another thread were to mutate the list whilst this loop was running
p51350
aVWell, that would clearly lead to runtime failures
p51351
aVSo, we can conclude that the loop above would need to be wrapped with a lock
p51352
aVWhich means that thread-safety aspects of the list must be exposed externally
p51353
aVYou cannot keep it all internal with the current design
p51354
aVIf you wish to keep the lock internal to the class you'll have to remove the  and  properties
p51355
aVYou could have your list looking like this (with some parts removed):
p51356
aVAnd now you can replace the loop above with this:
p51357
aVIt's not difficult to extend this concept to allow for your  method to support deletion of certain items, as determined by the  procedure
p51358
aVBut as you say, quite what you can do with such a list is moot
p51359
aVShared data is the bane of multi-threading
p51360
aVI suggest you find a way to solve your problem that gives each thread its own private copy of all data that it needs
p51361
aVAt which point you need no synchronisation and it's all good
p51362
aVOne final point
p51363
aVThere is no single concept of thread safety
p51364
aVWhat is meant by thread safety varies from context to context
p51365
aVEric Lippert said it best: What is this thing you call "thread safe"
p51366
aVSo anytime you ask a question like this, you should give plenty of detail on your particular use case and threading model
p51367
as(dp51368
g7
V505088
p51369
stp51370
a((dp51371
g2
(lp51372
VThe pertinent documentation is this:
p51373
aVMaximum Path Length Limitation
p51374
aVIn the Windows API (with some exceptions discussed in the following
p51375
aVparagraphs), the maximum length for a path is , which is
p51376
aVdefined as 260 characters
p51377
aVA local path is structured in the following
p51378
aVorder: drive letter, colon, backslash, name components separated by
p51379
aVbackslashes, and a terminating null character
p51380
aVFor example, the
p51381
aVmaximum path on drive D is "D:\u005csome 256-character path string"
p51382
aVwhere "" represents the invisible terminating null character for
p51383
aVthe current system codepage
p51384
aV(The characters < > are used here for
p51385
aVvisual clarity and cannot be part of a valid path string
p51386
aVNote  File I/O functions in the Windows API convert "/" to "\u005c" as part
p51387
aVof converting the name to an NT-style name, except when using the
p51388
aV"\u005c\u005c
p51389
aV\u005c" prefix as detailed in the following sections
p51390
aVThe Windows API has many functions that also have Unicode versions to
p51391
aVpermit an extended-length path for a maximum total path length of
p51392
aV32,767 characters
p51393
aVThis type of path is composed of components
p51394
aVseparated by backslashes, each up to the value returned in the
p51395
aVlpMaximumComponentLength parameter of the GetVolumeInformation
p51396
aVfunction (this value is commonly 255 characters)
p51397
aVTo specify an
p51398
aVextended-length path, use the "\u005c\u005c
p51399
aV\u005c" prefix
p51400
aVFor example, "\u005c\u005c
p51401
aV\u005cD:\u005cvery
p51402
aVlong path"
p51403
aVNote  The maximum path of 32,767 characters is approximate, because
p51404
aVthe "\u005c\u005c
p51405
aV\u005c" prefix may be expanded to a longer string by the system at
p51406
aVrun time, and this expansion applies to the total length
p51407
aVThe "\u005c\u005c
p51408
aV\u005c" prefix can also be used with paths constructed according to
p51409
aVthe universal naming convention (UNC)
p51410
aVTo specify such a path using
p51411
aVUNC, use the "\u005c\u005c
p51412
aV\u005cUNC\u005c" prefix
p51413
aVFor example, "\u005c\u005c
p51414
aV\u005cUNC\u005cserver\u005cshare",
p51415
aVwhere "server" is the name of the computer and "share" is the name of
p51416
aVthe shared folder
p51417
aVThese prefixes are not used as part of the path
p51418
aVitself
p51419
aVThey indicate that the path should be passed to the system
p51420
aVwith minimal modification, which means that you cannot use forward
p51421
aVslashes to represent path separators, or a period to represent the
p51422
aVcurrent directory, or double dots to represent the parent directory
p51423
aVBecause you cannot use the "\u005c\u005c
p51424
aV\u005c" prefix with a relative path,
p51425
aVrelative paths are always limited to a total of  characters
p51426
aVAs long as you are calling Unicode versions of Windows API functions, then there's no need to strip the  prefix
p51427
aVBecause the path that you have been handed is a valid path
p51428
aVAs we discovered in the comments, you were calling an ANSI version of an API function
p51429
aVAnd when you do that, the  prefix is not valid
p51430
aVSo, stick to Unicode API functions and it's all good
p51431
as(dp51432
g7
V505088
p51433
stp51434
a((dp51435
g2
(lp51436
VI expect you simply forgot to create the
p51437
aVYou need
p51438
aVsomewhere
p51439
aVFor example, in the  section of that unit
p51440
as(dp51441
g7
V505088
p51442
stp51443
a((dp51444
g2
(lp51445
VThe final field of the structure is declared incorrectly
p51446
aVYour code declared  to be a pointer to null-terminated array
p51447
aVBut in fact it should be:
p51448
aVTake a look at the C++ declaration for that field:
p51449
aVThat's an inline array of  wide characters
p51450
aVYou can get hold of  like this:
p51451
as(dp51452
g7
V505088
p51453
stp51454
a((dp51455
g2
(lp51456
VThere are a few options
p51457
ag5537
aVUse a file stream
p51458
ag25125
aVUse a reader
p51459
aVYou would combine the above approach with a  to make the reading of the values simpler:
p51460
aVThe reader class has lots of functions to read other data types
p51461
aVAnd you can go in the opposite direction with a binary writer
p51462
ag23064
aVOld style Pascal I/O
p51463
aVYou can declare a variable of type  and use , , etc
p51464
aVto read from the file
p51465
aVI really don't recommend this approach
p51466
aVModern code and libraries almost invariably prefer the stream idiom and by doing the same yourself you'll make your code easier to fit with other libraries
p51467
as(dp51468
g7
V505088
p51469
stp51470
a((dp51471
g2
(lp51472
VStore them in a thread list
p51473
aVCreate one of these objects before you create any clients
p51474
aVWhenever you create a client, add it:
p51475
aVWhenever you need to iterate over the clients, you can do so like this:
p51476
aVIn the thread's destructor you will also need to remove the client from the list
p51477
as(dp51478
g7
V505088
p51479
stp51480
a((dp51481
g2
(lp51482
VThe unit initialization section is the code that runs before  executes
p51483
aVThat's the code that is in the  sections at the bottom of a unit
p51484
aVSo you would appear to have an error in that code
p51485
aVMost likely it will be in one of your own units
p51486
aVThe thing to do is to run under the debugger and see which unit the debugger breaks at
p51487
aVMake sure your IDE is configured to break when access violations occur
p51488
aVI'd also recommend enabling Debug DCUs in case the exception surfaces in one of the RTL/VCL units
p51489
as(dp51490
g7
V505088
p51491
stp51492
a((dp51493
g2
(lp51494
VThe flag applies only to the PE module which sets it
p51495
aVSo, setting the flag in an EXE does not mean that modules loaded by that EXE are affected by the flag
p51496
aVEach module (DLL, package etc
p51497
aVthat is loaded by your EXE will be treated by the loader according to the PE options specified in that module
p51498
aVSo, you'll need to set the PE flag on each module that resides on a network share
p51499
aVFor what it's worth, I'd recommend adding  as well
p51500
as(dp51501
g7
V505088
p51502
stp51503
a((dp51504
g2
(lp51505
VIs there a hidden flag that I can use to ensure the dialog only allows the selection of a folder, where the button changes to "Select Folder"
p51506
aVNo there is not
p51507
aVYou need to use  which wraps  which is the system component that provides this functionality
p51508
as(dp51509
g7
V505088
p51510
stp51511
a((dp51512
g2
(lp51513
VNo predefined functions are included
p51514
aVThere are the standard arithmetic operators: +, -, *, div and mod
p51515
aVAnd there's all the standard logical and bitwise operators
p51516
aVBut nothing like abs, sin, exp, log etc
p51517
aVYou have to put those in yourself
p51518
aVIt is trivially easy to add functions and I think it's a good design to let you choose exactly what your evaluator supports
p51519
as(dp51520
g7
V505088
p51521
stp51522
a((dp51523
g2
(lp51524
VThis is quite an interesting problem
p51525
aVLU RD has given you an answer that fixes your code
p51526
aVI offer as an alternative, the way I would address the problem:
p51527
aVThe key point to stress is that your code is hard to understand because all the different aspects are mixed in with each other
p51528
aVI have attempted here to break the algorithm down into smaller parts which can be understood in isolation
p51529
as(dp51530
g7
V505088
p51531
stp51532
a((dp51533
g2
(lp51534
VIn this code:
p51535
aVYou are attempting to pass a variable of type  to the second parameter of
p51536
aVThat parameter is typed as being
p51537
aVNow,  is typed as being
p51538
aVA variable of procedural type cannot be passed to a parameter of type
p51539
aVIt's rather difficult to know exactly what the correct code would look like because the question doesn't contain enough background information
p51540
aVPerhaps  should receive a  rather than a
p51541
aVBut that's just a guess
p51542
aVIf you want more complete advice, then you will need to add sufficient detail to the question
p51543
aVYou state in a comment that:
p51544
aVI can not change the parameter type  to
p51545
aVIn that case you are stuck
p51546
aVIt's simply not possible to cast a  to a
p51547
aVNow, you could implement a class that had a single field of type , and pass that
p51548
aVBut I doubt very much that's really the right solution
p51549
as(dp51550
g7
V505088
p51551
stp51552
a((dp51553
g2
(lp51554
VYou state that you are not assigning the icon
p51555
aVIn which case the component uses
p51556
aVBut that will typically be an icon that is the wrong size for the notification area
p51557
aVFor the notification area you need to use a square icon with size determined by the  system metric
p51558
aVThe best way to get that is to call  which allows you to specify the icon size
p51559
aVOnce you have loaded the icon into an  you can just write this:
p51560
as(dp51561
g7
V505088
p51562
stp51563
a((dp51564
g2
(lp51565
VI think there's a compiler bug in there because the behaviour with  differs from the behaviour with overloaded functions that you provide
p51566
aVWhat's more there's an interaction with the Typed @ operator compiler option
p51567
aVI don't know how you set that
p51568
aVI always enable it but I suspect I'm in the minority there
p51569
aVSo I cannot explain the odd behaviour, and answer the precise question you ask
p51570
aVI suspect the only way to answer it is to look at the internals of the compiler, and very few of us can do that
p51571
aVAnyway, in case it helps, I think the cleanest way to pass the parameter is like so:
p51572
aVThis compiles no matter what you set Typed @ operator to
p51573
as(dp51574
g7
V505088
p51575
stp51576
a((dp51577
g2
(lp51578
VYou can do this very easily
p51579
aVSimply pass  to
p51580
aVWhether or not the end result is sensible or practical is something I could not say
p51581
aVBoth processes would read and write to the same console which could get pretty weird
p51582
as(dp51583
g7
V505088
p51584
stp51585
a((dp51586
g2
(lp51587
VSuppose that you want, elsewhere in the code, to be able to assign a different implementation of  to the  variable
p51588
aVThen that variable needs to be declared with type
p51589
aVAlternatively, if you want to make it clear to any code readers that all you intend to do with  is use the interface defined by , then the type declaration makes that clear
p51590
as(dp51591
g7
V505088
p51592
stp51593
a((dp51594
g2
(lp51595
VConsider the Python string
p51596
aVAs described in the documentation, the back slash character is interpreted as an escape character
p51597
aVSo  is in fact the ASCII Bell character, character number 7
p51598
aVYour filename is  and the  in there is interpreted as ASCII Bell
p51599
aVYou can see this clearly in the interpretor:
p51600
aVWhen you print that string note that the  does not appear
p51601
aVThat's because it has been turned into a Bell control character which is invisible
p51602
aVTo include a backslash you can use the correct escape sequence
p51603
aVPut it all together and your filename should be:
p51604
aVAs an alternative, you can prefix the string with  to make it a raw string
p51605
aVThis is also detailed in the documentation
p51606
as(dp51607
g7
V505088
p51608
stp51609
a((dp51610
g2
(lp51611
VThe file version information is of variable length
p51612
aVIt contains a number of different pieces of information
p51613
aVThe total length of all these different pieces is given by the return value of
p51614
aVWhen you call  you are asking for a specific individual piece of information within the overall version information
p51615
aVAnd the length of that specific part can never be larger that the overall size
p51616
aVThe documentation for  contains sample code that extracts the file description
p51617
as(dp51618
g7
V505088
p51619
stp51620
a((dp51621
g2
(lp51622
VYou can use  for this:
p51623
aV>>> sum(map(sum, T))
p51624
ag9193
aV89816000000000007
p51625
aVFrom the documentation for :
p51626
aVmap(function, iterable,
p51627
aVApply function to every item of iterable and return a list of the results
p51628
aVSo you are using  to total up the inner lists, and then a call to  to total those values for the final answer
p51629
aVThis approach will work if your inner lists contain multiple items
p51630
as(dp51631
g7
V505088
p51632
stp51633
a((dp51634
g2
(lp51635
VMaking the change you suggest will certainly result in faster code
p51636
aVAccessing a local variable is always going to be faster than accessing a property getter on
p51637
aVFor a start, those getters perform validity checking on the index
p51638
aVBut even for a class with the most simple getter possible, it would be hard to beat the cached local for performance
p51639
aVNow, whether this matters in your case is impossible to say from here
p51640
aVIf you do anything remotely non-trivial inside the loop then their runtime of the item getter will be irrelevant
p51641
aVThe fact that the loop might run for a large number of iterations is not the key factor
p51642
aVWhat counts most of all is how much time you spend in each iteration
p51643
aVIf it costs you 1 time unit to call the item getter, and 1000 time units to do whatever you do with each item, then it the getter performance is a non-issue
p51644
aVUltimately the definitive way to answer the question is to time the alternatives
p51645
aVOnly optimise based on measurement
p51646
aVThere's a much better reason to copy the item into a local variable: clarity of expression
p51647
aVYour current code is an egregious violation of the DRY principle
p51648
aVFinally, this code would read best of all if it used a for in loop:
p51649
aVNow, for in loops can be slower than traditional loops, but you should weight that against clarity and maintainability
p51650
aVOptimisation usually makes code harder to maintain and more prone to faults
p51651
aVConclusion: only optimise bottlenecks
p51652
as(dp51653
g7
V505088
p51654
stp51655
a((dp51656
g2
(lp51657
VYou can do this in a one-liner using Move
p51658
aVIf you need to perform a network/host byte order transformation, then you can run across the integer array after the
p51659
aVIn the opposite direction you do it all in reverse
p51660
aVIf you haven't got byte order issues then you might not actually need to convert to a byte array at all
p51661
aVIt's possible that you can use the integer array as is
p51662
aVRemember that, without byte order issues, the memory layout of the byte and integer arrays are the same (which is why you are able to blit with )
p51663
as(dp51664
g7
V505088
p51665
stp51666
a((dp51667
g2
(lp51668
VYou don't need to make any changes at all when you compile for 64 bit
p51669
aVThe C and C# versions match each other on both 32 and 64 bit
p51670
aVYou seem to think that C int is 8 bytes wide in 64 bit code on Windows
p51671
aVIt is not
p51672
aVIt is 4 bytes wide
p51673
aVYou can remove all the MarshalAs attributes since they merely re-state the default marshalling
p51674
aVIt seems highly unlikely that the switch from 32 bit OS to 64 bit OS is really the cause of the discrepancy
p51675
as(dp51676
g7
V505088
p51677
stp51678
a((dp51679
g2
(lp51680
VOn the C# side do it like this:
p51681
aVAnd on the Delphi side like this:
p51682
aVTo call the function from Delphi you would do like so:
p51683
as(dp51684
g7
V505088
p51685
stp51686
a((dp51687
g2
(lp51688
VThat  is used as the owner window for any UI that is shown as a result of the call to
p51689
aVFor example, any error message dialogs will be owned by that window
p51690
aVThe implications of a window being owned are described in the MSDN documentation
p51691
aVKey excerpts:
p51692
aVBeing owned places several constraints on a window
p51693
aVAn owned window is always above its owner in the z-order
p51694
aVThe system automatically destroys an owned window when its owner is destroyed
p51695
aVAn owned window is hidden when its owner is minimized
p51696
aVThe important one is the first one
p51697
aVIf you are calling  from a GUI app then you want any windows to be owned by the window that is currently active in your app
p51698
aVSo pass
p51699
aVIf you have no GUI in your app then pass 0
p51700
aVIn the code samples, the call to  is not showing any UI at all
p51701
aVSo it makes no difference what you pass
p51702
aVBut if your calls resulted in an error dialog being shown, then the window handle that you pass would become relevant
p51703
as(dp51704
g7
V505088
p51705
stp51706
a((dp51707
g2
(lp51708
VModules don't own windows
p51709
aVA window is owned by a process
p51710
aVStrictly speaking, windows have affinity to the thread which created them
p51711
aVBut since visible windows are invariably created by the main GUI thread of a process, it doesn't hurt to think of windows as being owned by a process
p51712
aVAs it happens, any module within a process could potentially have created the window returned by
p51713
aVSo what are asking for doesn't really make any sense
p51714
as(dp51715
g7
V505088
p51716
stp51717
a((dp51718
g2
(lp51719
V is an integer expression that evaluates to the  with value
p51720
aVIf you want a decimal calculation then you should do it like this:
p51721
aVThe  suffix indicates a literal of type
p51722
aVBut that itself would be somewhat odd since  receives a floating point parameter as input
p51723
aVSo, if you are using  then I think that you really want to use floating point division
p51724
aVLike this:
p51725
as(dp51726
g7
V505088
p51727
stp51728
a((dp51729
g2
(lp51730
VThis is a situation where you want to create the controls dynamically at runtime rather than at designtime
p51731
aVTrying to grapple with 6 different variables is just going to be a world of pain
p51732
aVAnd when you need the grid to be 3x4 rather than 2x3, you'll regret that decision even more
p51733
aVSo, start with a completely blank form
p51734
aVAnd add, in the code, a two dimensional array of panels:
p51735
aVThen, in the form's constructor, or an  event handler, you can initialise the array by calling a function like this:
p51736
aVAnd now you can refer to your panels using cartesian coordinates rather than a flat one dimensional array
p51737
aVOf course, you can easily enough declare a flat one dimensional array as well if you want
p51738
aVThe key idea is that when you are creating large numbers of control in a structured layout, you are best abandoning the designer and using code (loops and arrays)
p51739
as(dp51740
g7
V505088
p51741
stp51742
a((dp51743
g2
(lp51744
VIf the program reads the input from the standard input then you can create a text file containing your input:
p51745
ag25125
aVThen redirect the standard input to that file:
p51746
aVmyapp
p51747
aVexe < inputfile
p51748
aVtxt
p51749
aVPerhaps the program  has command line options that would also allow you to avoid being prompted
p51750
aVNote that your question is ambigous
p51751
aVIf you are choosing the option to read, shouldn't you input 1
p51752
as(dp51753
g7
V505088
p51754
stp51755
a((dp51756
g2
(lp51757
VYour process is a 32 bit process and so, on a 64 bit OS, the registry redirector comes into play
p51758
aVThe  key is redirected and there are two views of it, a 32 bit view that your process is finding, and a 64 bit view
p51759
aVIt is true that if you run a 64 bit process, you will see the 64 bit view of the registry
p51760
aVHowever, that is not the full story
p51761
aVWindows processes  entries from both 32 and 64 bit views of the registry
p51762
aVSo, if you just switched to an x64 or AnyCPU process you would then be missing the autoruns stored in the 32 bit registry view
p51763
aVSo, since your goal is to list all the autoruns, you will need to read both 32 and 64 bit views of the registry
p51764
aVYou can do that using the  enumeration that was introduced in
p51765
aVnet 4
p51766
aVThis allows a 32 bit process to access the 64 bit view of the registry
p51767
aVAnd indeed it allows a 64 bit process to access the 32 bit view of the registry
p51768
aVIf you want a process that runs on both 32 bit and 64 bit systems you will need to target either x86 or AnyCPU
p51769
aVAnd then use  to read both views of the registry if you detect that you are running on a 64 bit system
p51770
as(dp51771
g7
V505088
p51772
stp51773
a((dp51774
g2
(lp51775
VWindows error code 32 is
p51776
aVWhich means that the file has already been opened by by some other entity using a sharing mode that denies your process access
p51777
aVThat other entity appears to be your own program
p51778
aVYou open the file and then fail to close it
p51779
aVYour window proc is completely broken too
p51780
aVIt's time to step back a little and master the basics
p51781
as(dp51782
g7
V505088
p51783
stp51784
a((dp51785
g2
(lp51786
VProcess explorer works like this:
p51787
aVYou download a single 32 bit executable
p51788
aVWhen you run that executable on a 32 bit OS, that's it
p51789
aVWhen you run that executable on a 64 bit OS, the 32 bit process detects that on startup and  to disk extracts a 64 bit executable that is stored as a resource in the 32 bit process
p51790
aVAnd then it runs that 64 bit executable
p51791
aVThere aren't any settings in Visual Studio that would automate that process for you
p51792
aVYou'd have to write that part for yourself
p51793
aVYou could have a build process that built the 64 bit version first
p51794
aVAnd then you could compile that executable into a resource which you link into your 32 bit process
p51795
aVWhich is what you ship
p51796
aVI myself am not convinced it's worth all the effort
p51797
aVPersonally I'd be inclined to ship two different executables, but I guess only you know your own requirements
p51798
as(dp51799
g7
V505088
p51800
stp51801
a((dp51802
g2
(lp51803
VThis article tells you how to do it: http://www
p51804
aVnanoant
p51805
aVcom/programming/themed-menus-icons-a-complete-vista-xp-solution
p51806
aVIn summary, on XP you should pass HBMMENU_CALLBACK in the hbmpItem field of the MENUITEMINFO struct
p51807
aVThis makes your menu owner draw, but you only need to deal with the icon in WM_MEASUREITEM and WM_DRAWITEM
p51808
aVOn Vista and up you put a PARGB32 bitmap (pre-multiplied alpha, 32 bit color depth) in hbmpItem and let the system draw the menu
p51809
aVSo, no owner draw on Vista and up
p51810
aVAlthough the theme API does offer functionality for painting menus, it is fiendishly difficult to get right and there's really no need since you can let the system do it
p51811
as(dp51812
g7
V505088
p51813
stp51814
a((dp51815
g2
(lp51816
VUnder the assumption that you are using the built in , then you can call the  method
p51817
aVIf a comment you ask:
p51818
aVHow can I access the offline child nodes in code
p51819
aVLike so:
p51820
as(dp51821
g7
V505088
p51822
stp51823
a((dp51824
g2
(lp51825
VNotification area icons are square icons, of size equal to
p51826
aVIn other words, they are small icons
p51827
aVThe sample code towards the end of the  documentation gives tacit confirmation of this
p51828
as(dp51829
g7
V505088
p51830
stp51831
a((dp51832
g2
(lp51833
VSendMessage suspends currently executing thread (as well as any other thread)
p51834
aVNo, that is incorrect
p51835
aVdoes not suspend anything
p51836
aVSendMessage merely delivers a message synchronously
p51837
aVThe function does not return until the message has been delivered
p51838
aVThat is, the window proc of the target window has been executed
p51839
aVAnd because the window proc is always called on the thread that owns the window, this means that the calling thread may need to be blocked to wait until the window's owning thread is ready to execute the window proc
p51840
aVIt most definitely doesn't suspend all threads in the process
p51841
aVHow does the critical section know that I am protecting
p51842
aVIt doesn't
p51843
aVIt's entirely up to you to make sure that all uses of  that need protection, are given protection
p51844
aVA critical section is a form of mutex
p51845
aVA mutex ensures that only one thread of execution can hold the mutex any any instant in time
p51846
aVAs I call  within all of the threads that might write to this block or use this function
p51847
aVThat's not really it either
p51848
aVThe "within all of the threads" is a mis-think
p51849
aVYou need to be thinking about "at all sections of code that use the variable"
p51850
aVDoes a critical section therefore always need to be a global kind of variable
p51851
aVNo, a critical section can be a global variable
p51852
aVBut it need not be
p51853
as(dp51854
g7
V505088
p51855
stp51856
a((dp51857
g2
(lp51858
VUndefined behaviour means that anything can happen
p51859
aVOne of the possible outcomes is that your program runs perfectly
p51860
aVAnother possible outcome is that your program crashes
p51861
aVOr indeed anything else that you can think of
p51862
aVYou won't gain any insight trying to analyse particular instance of undefined behaviour
p51863
aVThe remedy is not to call  twice
p51864
as(dp51865
g7
V505088
p51866
stp51867
a((dp51868
g2
(lp51869
VPossibly the function is being exported with a mangled name
p51870
aVYou can suppress the mangling like this:
p51871
aVYou aren't obviously exporting the function either
p51872
aVThe simple way to do that is like this:
p51873
aVIf that still doesn't resolve the missing export, use a tool like Dependency Walker to check whether the function is in fact being exported, and if so under what name
p51874
aVFinally, you should declare the calling convention on the C# side to be cdecl to match the calling convention of your native function
p51875
as(dp51876
g7
V505088
p51877
stp51878
a((dp51879
g2
(lp51880
VYou are out of luck with the old fashioned  which is an obsolete and deprecated function
p51881
aVOn Vista and up you should use  in its folder selection mode
p51882
aVFor pre-Vista operating systems probably the best you can do is
p51883
aVThere is an overload of  that calls
p51884
aVIt's the overload with 5 parameters
p51885
aVI don't know when it was introduced
p51886
aVPerhaps it's present even in Delphi 7
p51887
aVI also can't be sure whether or not  will offer the directories that you are looking for
p51888
aVSince you are also using an obsolete and deprecated version of Delphi then it's a bit more work to call
p51889
aVYou'll need to declare the interface yourself and create and instance of it with
p51890
as(dp51891
g7
V505088
p51892
stp51893
a((dp51894
g2
(lp51895
VThe question is very hard to decipher
p51896
aVI think that you have tried two different versions of the function that you named , as shown below
p51897
aVConsider this version of the function:
p51898
aVIt returns 115 no matter what value you pass as the parameter
p51899
aVYou are overwriting the parameter with the assignment
p51900
aVThe parameter is therefore utterly pointless
p51901
aVAnd now the other version:
p51902
aVThis version of the function receives a parameter in the variable
p51903
aVIt then adds on 115 to that value, and returns the result
p51904
aVSo when you call it like this:
p51905
aVthe value that is returned is 215
p51906
aVIt might be easier to understand if you wrote the functions like this:
p51907
aVThese versions are exactly equivalent to your versions but I hope you'll find them easier to understand
p51908
as(dp51909
g7
V505088
p51910
stp51911
a((dp51912
g2
(lp51913
VThe  operator deletes the entire block of memory
p51914
aVYou cannot deallocate part of block of memory \u2013 you can only deallocate the entire block
p51915
aVThis is also the case for , and
p51916
aVThe deallocating function can only deallocate the entire block of memory
p51917
as(dp51918
g7
V505088
p51919
stp51920
a((dp51921
g2
(lp51922
VThis code is the inverse of the code in the question:
p51923
aVAnd the code in the question can be written much more simply like this:
p51924
as(dp51925
g7
V505088
p51926
stp51927
a((dp51928
g2
(lp51929
VIn your program,  is in fact returning  which is an error condition
p51930
aVYour message loop terminates when  returns a value <=0, and so it terminates when  returns -1
p51931
aVNow, because the final call to  fails with an error, the value of  is not well-defined
p51932
aVYou should not return it as an exit code
p51933
aVYou should only return  as an exit code when the final call to  returned 0
p51934
aVThis is all made clear in the documentation
p51935
aVYou can see all this if you change your message loop to look like this:
p51936
aVOn my machine, the  route is selected and the error code is 1400
p51937
aVWhich is
p51938
aVI'm not quite sure why your app is behaving in this way, but I'm content that I've answered the question you asked about exit codes
p51939
as(dp51940
g7
V505088
p51941
stp51942
a((dp51943
g2
(lp51944
VYou have this definition for the structure:
p51945
aVThe p/invoke marshaller will marshal classes by reference
p51946
aVIn other words, a pointer to the object is passed to the native code
p51947
aVThis mismatch explains why the program fails
p51948
aVThe solution is to make sure that both sides of the interface match
p51949
aVOne way is to pass by value on both sides
p51950
aVA simple way to achieve that is to declare the structure to be a value type in C#
p51951
aVDo that by making it a struct:
p51952
aVThe other way would be to pass by reference at both sides
p51953
aVYou would achieve that by using  on the C# side and changing the C code
p51954
as(dp51955
g7
V505088
p51956
stp51957
a((dp51958
g2
(lp51959
VThere's no such thing as ASCII/UTF-8
p51960
aVThose are two distinct encodings, that in fact encode different character sets
p51961
aVI suspect that you are actually using ASCII, or perhaps Windows ANSI, at present
p51962
aVUTF-8 is a complete encoding for Unicode
p51963
aVIf the file only contains ASCII characters then the UTF-8 encoding is identical to the ASCII encoding
p51964
aVAnd if your files are predominantly English, then UTF-8 is the Unicode encoding that produces the smallest files
p51965
aVConclusion: use UTF-8
p51966
as(dp51967
g7
V505088
p51968
stp51969
a((dp51970
g2
(lp51971
VMost likely that service runs as  and so can kill anything it likes
p51972
aVSo it's extremely unlikely that you can defend against it
p51973
aVIndeed, a quick websearch throws up some some hits that indicate that the service does indeed run as
p51974
aVYour only tenable solution is going to involve the other software
p51975
aVEither compel your users to remove it, or work with its developers to find a way to white-list your program
p51976
as(dp51977
g7
V505088
p51978
stp51979
a((dp51980
g2
(lp51981
VThis function is passed a pointer
p51982
aVThe function modifies that pointer
p51983
aVBut since parameters are passed by value, that modification is not seen by the caller
p51984
aVYou need to write the function like this:
p51985
aVThe caller of this function is expected to pass the address of an  variable
p51986
aVThe function then writes an  value, 9999 in this case, to that address
p51987
aVThis is the key
p51988
aVYou are passed an address, and you then write a value to that address
p51989
aVYour broken version simply modified the address
p51990
aVYou were missing the indirection
p51991
aVWhen the function returns, the caller can observe the modification to the  variable whose address was passed to the function
p51992
aVThe calling code can look like this:
p51993
aVNow, this is broken in a very serious way
p51994
aVThis function does indeed return a pointer to the caller
p51995
aVBut it returns a pointer to an object that goes out of scope as soon as the function returns
p51996
aVThat is known as undefined behaviour
p51997
aVDon't do this
p51998
aVNever pass out of a function, a pointer to a local variable defined in that function
p51999
as(dp52000
g7
V505088
p52001
stp52002
a((dp52003
g2
(lp52004
VThe C++ function is passing parameters in  and
p52005
aVSo you just need to copy them to the registers that Delphi is expecting:  and  respectively
p52006
aVSince the second parameter is already in the right register all you need is this:
p52007
aVI've done this in two functions so that I can write a pure  only function that does the register swapping
p52008
aVWe want pure  to avoid all preamble
p52009
aVSo,  is your hook function
p52010
aVNote also that since you are using a Unicode Delphi, you will want  to match up with
p52011
aVThe best reference I know for calling conventions is by Agner Fog
p52012
aVYou'll find all the gory details there
p52013
aVOne important point is that, on Windows x86, the EAX, ECX and EDX registers are volatile, or scratch registers
p52014
aVWhich means that callees can modify those registers without having to restore them
p52015
aVWhich is why I modify EAX above and do not bother to put it back
p52016
as(dp52017
g7
V505088
p52018
stp52019
a((dp52020
g2
(lp52021
VIt's because of User Account Control (UAC)
p52022
aVIntroduced in Vista, this changes the way administrator user accounts operate
p52023
aVWhen an user from the administrator group logs on, the user is allocated two tokens: a token with all privileges, and a token with reduced privileges
p52024
aVWhen that user creates a new process, the process is by default handed the reduced privilege token
p52025
aVSo, although the user has administrator rights, she does not exercise them by default
p52026
aVThis is a "Good Thing"\u2122
p52027
aVTo exercise those rights the user must start the process with elevated rights
p52028
aVFor example, by using the "Run as administrator" verb
p52029
aVWhen she does this, the full token is handed to the new process and the full range of rights can be exercised
p52030
aVYou almost certainly don't want to be detecting whether or not your process is running elevated
p52031
aVBest practise is to mark those parts of your program that require elevation and force the system to show UAC elevation dialogs when those parts of the program execute
p52032
aVThe bind is that elevation can only happen at process start
p52033
aVSo if you need to split your app into parts that require elevation, and parts that don't, there need to be multiple processes
p52034
aVWhilst you could mark your entire app as requiring elevation, you should not do so if the only thing that needs elevation is the very rare scenario where the computer name is to be changed
p52035
aVYour next step is to bone up on the details over at MSDN
p52036
aVFor example:
p52037
aVhttp://msdn
p52038
aVmicrosoft
p52039
aVcom/en-us/library/windows/desktop/bb756996
p52040
aVaspx
p52041
aVhttp://msdn
p52042
aVmicrosoft
p52043
aVcom/en-us/library/windows/desktop/aa511445
p52044
aVaspx
p52045
as(dp52046
g7
V505088
p52047
stp52048
a((dp52049
g2
(lp52050
VCAS operations will work perfectly well with that memory
p52051
aVThe file mapping API and the virtual memory system do all the hard work of mapping the memory into multiple processes
p52052
aVBy the time you get your hands on the memory, you can't tell it apart from any other piece of memory
p52053
as(dp52054
g7
V505088
p52055
stp52056
a((dp52057
g2
(lp52058
VIf you are using
p52059
aVnet 4 or later, and therefore can make use of , you can do this quite simply
p52060
aVHere's an example that uses the Excel automation interface
p52061
aVIf you can't use dynamic then it's much more messy
p52062
aVTrying to do very much of that will sap the lifeblood from you
p52063
aVCOM is so much easier if you can use early bound dispatch rather than late bound as shown above
p52064
aVAre you sure you can't find the right reference for the COM object
p52065
as(dp52066
g7
V505088
p52067
stp52068
a((dp52069
g2
(lp52070
VGet the list of file names in the folder:
p52071
aVAnd then pick an index at random
p52072
aVSo, your random filename is given by
p52073
aVCall  on startup to ensure that the user doesn't get the same sequence of random numbers each time they run the program
p52074
aVThis isn't the most efficient approach since it allocates strings for each file in the directory, and then you use only one
p52075
aVHowever, it's probably the most convenient and simple approach
p52076
as(dp52077
g7
V505088
p52078
stp52079
a((dp52080
g2
(lp52081
VYou could just cast the  to , but that's not portable
p52082
aVFor example, it's conceivable, albeit somewhat unlikely, that
p52083
aVSo, if you want to be portable you should pass a pointer to an
p52084
aVFor example you could allocate storage for  with
p52085
aVWithout knowing more about what  is and does, I can't say who should be responsible for calling  on that block of memory
p52086
aVMy assumption here is that  is asynchronous and that the pointer could be read some time after the call to  returns
p52087
aVHowever, if the pointer will be read during the execution of  then you can make it even simpler
p52088
aVSo, the bottom line is that I think it best to pass an  to
p52089
aVExactly how you achieve that depends on the operation of
p52090
as(dp52091
g7
V505088
p52092
stp52093
a((dp52094
g2
(lp52095
VThe problem is that you have not successfully loaded the OpenSLL libraries that are needed to implement the hash
p52096
aVCall
p52097
aVYou'll also need to make sure that your program can find suitable OpenSLL DLLs
p52098
as(dp52099
g7
V505088
p52100
stp52101
a((dp52102
g2
(lp52103
VThe  class will do this for you
p52104
aVWhen converting from  to  you need to pass the pointer and the buffer length to the managed code
p52105
aVThen you can do this:
p52106
aVAnd in the other direction there's nothing much to do
p52107
aVIf you have a  then you can simply pass that to your DLL function that expects to receive a char*
p52108
aVC++
p52109
aVC#
p52110
as(dp52111
g7
V505088
p52112
stp52113
a((dp52114
g2
(lp52115
VThe following will work:
p52116
aVYou will need to add a GUID to the interface:
p52117
aVObviously you need to use the same GUID in the C# code as was used in the C++ code
p52118
aVUpdate
p52119
aVLooking at your C++ COM object implementation, the obvious fault is in
p52120
aVYou must not return  for all GUIDs
p52121
aVOnly return  for the interfaces you implement
p52122
aVReturn  for the others
p52123
as(dp52124
g7
V505088
p52125
stp52126
a((dp52127
g2
(lp52128
VThe difference is probably because your managed program has greater needs than the unmanaged program
p52129
aVAnd so there are fewer resources left for your DLL
p52130
aVPrograms can run out of memory even when there appears to be memory left
p52131
aVThis happens when the address space is fragmented and the virtual memory allocator cannot find a large enough contiguous block of memory to meet an allocation request
p52132
aVThere's not much you can do about that I suspect
p52133
aVI doubt you'll have much luck trying to make your managed process consume fewer resources
p52134
aVIf you run on a 64 bit system and your process is large address aware then your process can access have 4GB of memory
p52135
aVMarking your
p52136
aVnet executable as  might well help
p52137
aVFor details please refer to another SO question: How to make a
p52138
aVNET application "large address aware"
p52139
aVIn summary you need to run the  tool to mark your executable:
p52140
aVBe aware though that on a 32 bit OS you are pretty much stuck with the 2GB limit
p52141
aVYes you can boot your system with the /3GB switch but this is generally not to be advised
p52142
aVThe other obvious option would be to house the DLL in an out of process COM server
p52143
aVBy putting it in a different process you could keep the
p52144
aVnet runtime out of the process and leave as much space as possible for the hungry DLL
p52145
as(dp52146
g7
V505088
p52147
stp52148
a((dp52149
g2
(lp52150
VA C# struct is a value type
p52151
aVWhich means that
p52152
aVwill make a copy of the struct
p52153
aVSo, nothing to get concerned about
p52154
aVIn fact, in  you are not operating on the object that was allocated in your Delphi code
p52155
aVThat's because the p/invoke marshaller had to take the raw pointer that it received and convert that into a  object
p52156
aVAnd a  contains C# strings which are most definitely not blittable with those Delphi character arrays
p52157
aVSo the marshaller has already added a layer in between your C# code and the Delphi code
p52158
aVSince the function receives the structure by ref what happens is as follows:
p52159
aVBefore calling  the marshaller de-serializes the raw unmanaged pointer to a  object
p52160
aVis then passed that  object by reference
p52161
aVWhen  returns, the p/invoke marshaller serializes the  object back to the original raw unmanaged pointer
p52162
aVOne of the consequences of this is that changes you make to the  object are not visible to the Delphi code until the callback procedure returns
p52163
aVContrast that to what happens when you call a Delphi procedure passing a variable as a  parameter
p52164
aVIn that case any changes in the procedure are visible immediately outside that procedure
p52165
as(dp52166
g7
V505088
p52167
stp52168
a((dp52169
g2
(lp52170
VThis is a bug which afflicts the IDE, but won't afflict a build server
p52171
aVThat's because the build server does not invoke the IDE
p52172
aVA build server uses the command line compiler to perform the compilation
p52173
aVEven if the command line compiler had a bug like this it likely would not affect the build server
p52174
aVThat's because each time the build server starts a build action, it creates a new process to perform the build
p52175
aVAnd when that single build is complete, that process terminates
p52176
aVSo even if the command line compiler had a memory leak bug, it would not matter because once the compilation was complete, the process would terminate and the memory would be re-claimed by the system
p52177
as(dp52178
g7
V505088
p52179
stp52180
a((dp52181
g2
(lp52182
VA trivial solution is to strip off the decimal separator:
p52183
as(dp52184
g7
V505088
p52185
stp52186
a((dp52187
g2
(lp52188
VUse
p52189
aVAs the documentation says:
p52190
aVThe break statement terminates the closest enclosing loop or switch statement in which it appears
p52191
aVControl is passed to the statement that follows the terminated statement, if any
p52192
aVSo your code should look like this:
p52193
as(dp52194
g7
V505088
p52195
stp52196
a((dp52197
g2
(lp52198
Vif you were using runtime packages then you'd need to ensure that your program found the new package file, the
p52199
aVbpl
p52200
aVBut you probably are not using runtime packages
p52201
aVSo the runtime program statically links the Indy code using
p52202
aVdcu files located in the Delphi installation folders
p52203
aVSpecifically in this case to
p52204
aVYou need to make sure you link the new code
p52205
aVThe easiest way is to add the modified file to your project
p52206
aVThat will mean that the modified version gets compiled and linked into your program
p52207
aVSince your modifications are in the implementation section of the unit this is all you need to do
p52208
aVIf the modifications were in the interface section you'll encounter "Unit X was compiled with a different version of Unit Y" errors
p52209
aVYou'd solve that by adding the rest of the Indy source to your project
p52210
aVOne point to stress is that you should never modify the files under the Delphi installation folder
p52211
aVIf you want to build modifications to those components, take copies of the files and make modifications in those copies
p52212
as(dp52213
g7
V505088
p52214
stp52215
a((dp52216
g2
(lp52217
VIt's not so much that users choose to use other than 32 bit color
p52218
aVThe real need for 256 color icons is for when they are running over a remote desktop app that uses lower pixel depth for bandwidth efficiency
p52219
aVHaving said that, my experience is that apps which only load 32bpp icons still look reasonable under limited bandwith, low pixel depth remote desktop
p52220
aVAnd I suspect most people run their remote desktop with a decent pixel depth in the modern day of higher bandwidth connections
p52221
aVIf you are going to generate 256 color icons, you usually need to create bespoke low pixel depth icons
p52222
aVIt seldom looks good when you merge a modern alpha blended icon down to low pixel depth
p52223
aVIf I were you I'd try out you app over remote desktop at low bandwidth settings and see how it looks
p52224
aVEven if it looks a bit dirty, that may not matter to you
p52225
aVYou may well be prepared to make that sacrifice
p52226
as(dp52227
g7
V505088
p52228
stp52229
a((dp52230
g2
(lp52231
VYou can call  from a WinRT app
p52232
aVThat tells you the architecture of the underlying device
p52233
as(dp52234
g7
V505088
p52235
stp52236
a((dp52237
g2
(lp52238
VYou can use  from the  unit
p52239
aVAnd so on and so on
p52240
aVIf you want a dictionary that contains a dictionary, you can do use
p52241
aVHowever, when you do that you'll need to take special care over the lifetime of the dictionary items that are contained in the outer dictionary
p52242
aVYou can use  to help manage that for you
p52243
aVYou'd create one of these objects like this:
p52244
aVThis  operates the same was as a traditional  with  set to
p52245
as(dp52246
g7
V505088
p52247
stp52248
a((dp52249
g2
(lp52250
VAssuming your analysis is correct, and the problem is that the executable is located on a network drive with a flaky connection, then there is a solution
p52251
aVYou need to add PE flags to your executable that forces Windows to copy the file from the network to the local machine before running it
p52252
aVMake sure that your
p52253
aVdpr file's uses clause includes the  unit
p52254
aVAnd then add this line:
p52255
aVjust before the  in your
p52256
aVdpr file
p52257
aVWe added the  unit so that the two constants would be recognised
p52258
as(dp52259
g7
V505088
p52260
stp52261
a((dp52262
g2
(lp52263
VCall  to enumerate the top level windows
p52264
aVCall  for each of those windows to test whether or not the window is visible
p52265
aVCall  to find out a window's position
p52266
aVIn Python you can do all this with the  module
p52267
aVI must confess that I cannot understand the relationship between VMware Fusion and the two questions you asked
p52268
as(dp52269
g7
V505088
p52270
stp52271
a((dp52272
g2
(lp52273
VPass a pointer to the  that you wish to modify:
p52274
aVWhen you need to modify the value, you need to de-reference the pointer:
p52275
aVWhen you call the function, pass the address of the variable that you wish to modify:
p52276
as(dp52277
g7
V505088
p52278
stp52279
a((dp52280
g2
(lp52281
VMerge this into your registry:
p52282
aVWindows Registry Editor Version 5
p52283
aV00
p52284
aV[HKEY_CLASSES_ROOT\u005c
p52285
aVDPR]
p52286
aV@="BDS
p52287
aVDprFile"
p52288
aV[HKEY_CLASSES_ROOT\u005cBDS
p52289
aVDprFile]
p52290
aV@="Delphi Project File"
p52291
aVFriendlyTypeName"=hex(2):40,00,25,00,43,00,6f,00,6d,00,6d,00,6f,00,6e,00,50,\u005c
p52292
aV00,72,00,6f,00,67,00,72,00,61,00,6d,00,46,00,69,00,6c,00,65,00,73,00,25,00,\u005c
p52293
aV5c,00,45,00,6d,00,62,00,61,00,72,00,63,00,61,00,64,00,65,00,72,00,6f,00,5c,\u005c
p52294
aV00,53,00,68,00,65,00,6c,00,6c,00,5c,00,42,00,44,00,53,00,53,00,52,00,2e,00,\u005c
p52295
aV64,00,6c,00,6c,00,2c,00,2d,00,31,00,37,00,30,00,39,00,00,00
p52296
aV[HKEY_CLASSES_ROOT\u005cBDS
p52297
aVDprFile\u005cDefaultIcon]
p52298
aV@="\u005c"C:\u005c\u005cProgram Files (x86)\u005c\u005cEmbarcadero\u005c\u005cRAD Studio\u005c\u005c10
p52299
aV0\u005c\u005cBin\u005c\u005cdelphicoreide170
p52300
aVbpl\u005c",3"
p52301
aV[HKEY_CLASSES_ROOT\u005cBDS
p52302
aVDprFile\u005cShell]
p52303
aV[HKEY_CLASSES_ROOT\u005cBDS
p52304
aVDprFile\u005cShell\u005cOpen]
p52305
aV[HKEY_CLASSES_ROOT\u005cBDS
p52306
aVDprFile\u005cShell\u005cOpen\u005cCommand]
p52307
aV@="\u005c"C:\u005c\u005cProgram Files (x86)\u005c\u005cEmbarcadero\u005c\u005cRAD Studio\u005c\u005c10
p52308
aV0\u005c\u005cBin\u005c\u005cbdsLauncher
p52309
aVexe\u005c" \u005c"C:\u005c\u005cProgram Files (x86)\u005c\u005cEmbarcadero\u005c\u005cRAD Studio\u005c\u005c10
p52310
aV0\u005c\u005cBin\u005c\u005cbds
p52311
aVexe\u005c" /np"
p52312
aV[HKEY_CLASSES_ROOT\u005cBDS
p52313
aVDprFile\u005cShell\u005cOpen\u005cddeexec]
p52314
aV@="[open(\u005c"%1\u005c")]"
p52315
aV[HKEY_CLASSES_ROOT\u005cBDS
p52316
aVDprFile\u005cShell\u005cOpen\u005cddeexec\u005capplication]
p52317
aV@="bdslauncher"
p52318
aV[HKEY_CLASSES_ROOT\u005cBDS
p52319
aVDprFile\u005cShell\u005cOpen\u005cddeexec\u005ctopic]
p52320
aV@="system"
p52321
aVObviously this assumes your XE3 lives in the same place as mine
p52322
aVIf it's elsewhere on your machine, then update the paths accordingly
p52323
aVThis is probably easier than an wholesale re-install
p52324
as(dp52325
g7
V505088
p52326
stp52327
a((dp52328
g2
(lp52329
VProbably the easiest thing to do is to use the unit alias feature to help
p52330
aVIn order for this to work you need different project settings for different compiler versions
p52331
aVFor example, different
p52332
aVdpr and
p52333
aVdproj files for each supported compiler version
p52334
aVIn your XE2 project you define a unit alias like so:
p52335
aVIn the XE3 project you omit that alias
p52336
aVThen in your
p52337
aVpas file you can happily use System
p52338
aVActions with no problems in either version of Delphi
p52339
aVAn even simpler solution is to create an empty unit named  that you only include in your project for XE2 builds
p52340
as(dp52341
g7
V505088
p52342
stp52343
a((dp52344
g2
(lp52345
VI suspect the following explains what you have observed:
p52346
aVWhen you don't define  the child process uses the standard input device attached to the console
p52347
aVThe child process detects that standard input is an interactive console device and writes a prompt
p52348
aVWhen you do define  the child process detects that the standard input is a pipe and so neglects to write a prompt
p52349
aVAfter all, what's the point of prompting a non-interactive input device
p52350
aVThe child process will use  to detect what type of device is attached to the standard input
p52351
aVA value of  indicates a console
p52352
aVWhen you attach a pipe to the standard input then the standard input file type will be
p52353
aVMy conclusion is that everything is working as designed and intended
p52354
as(dp52355
g7
V505088
p52356
stp52357
a((dp52358
g2
(lp52359
VWhen you wish to force a chunk of the file to be paged in to memory, call  using the  file handle that you used to create the file mapping
p52360
as(dp52361
g7
V505088
p52362
stp52363
a((dp52364
g2
(lp52365
VA tool bar has a reference to a single image list
p52366
aVThis is a property of the underlying Windows control that is simply reflected on to you by the VCL
p52367
aVThe conclusion is that you must put all the images into the same image list
p52368
aVYou cannot have two different image lists referenced by a single tool bar
p52369
aVOne solution would to pass your image list to the plugin and allow it to add glyphs to your image list
p52370
aVNote that I'm talking about the primary image list
p52371
aVNaturally you use different image lists for disabled images and the hot images
p52372
aVBut those don't really contain different glyphs\u2013they contain the same glyphs but rendered in different states
p52373
as(dp52374
g7
V505088
p52375
stp52376
a((dp52377
g2
(lp52378
VIn your update you added this code:
p52379
aVThe loop condition is incorrect
p52380
aVInstead of  you need
p52381
aVYour multiplication loop looks like this:
p52382
aVThe assignment  is in the wrong block\u2013the  array access is out-of-bounds
p52383
aVIt should be like this:
p52384
aVNote that I have initialised  to 0 every time a new  loop is started
p52385
aVThat corrects another error in your code
p52386
aVIt would be a lot better if you declared the variables with the tightest scope possible
p52387
aVLike this:
p52388
aVHad you done that the compiler would have rejected your original placement of the assignment to
p52389
aVYour  function should be declared like this:
p52390
aVand you should return a value from your
p52391
as(dp52392
g7
V505088
p52393
stp52394
a((dp52395
g2
(lp52396
VFirst of all the declaration is wrong
p52397
aVIt needs to be , and it returns
p52398
aVSecondly, your implementation doesn't set the return value
p52399
aVReturn  to continue enumeration,  to stop enumeration
p52400
aVIn your case you need to return
p52401
aVFinally, you'll need to cast the list box to be  when you call
p52402
aVConsult the documentation for the full details
p52403
aVPutting it all together you have this:
p52404
aVNote also that  does not enumerate all running processes
p52405
aVWhat it does is enumerate all top level windows
p52406
aVNote quite the same thing
p52407
aVTo enumerate all running processes there is
p52408
aVHowever, since you are reading out window titles and window class names, you probably do want to use
p52409
aVAs I've said many times before, I loath the fact that the Delphi header translation for  uses  for the  parameter
p52410
aVWhich means that you can't rely on the compiler to check type safety
p52411
aVI personally always use my own version of
p52412
aVAnd then when you call the function you don't use the  operator and so let the compiler check that your callback function is declared correctly:
p52413
as(dp52414
g7
V505088
p52415
stp52416
a((dp52417
g2
(lp52418
VThe VS2012 runtime that you are installing uses functions that are not present available in XP
p52419
aVSee this MS article: Targeting Windows XP with C++ in Visual Studio 2012 which explains more and provides some workarounds
p52420
aVUpdate 1 for VS2012 resolve the problem
p52421
aVBut Update 1 isn\u2019t just about new Windows platforms
p52422
aVIt also enables you to target Windows XP with native C++ applications in Visual Studio 2012
p52423
aVIf you are building with update 1 and still encountering problems then I suspect that you are installing an out of date runtime
p52424
aVYou need to deploy the runtime delivered with update 1
p52425
as(dp52426
g7
V505088
p52427
stp52428
a((dp52429
g2
(lp52430
VIt's pretty hard to do any real damage
p52431
aVYou won't accidentally format a drive
p52432
aVThe API calls needed to do that are pretty tricky to use
p52433
aVYou can't call them successfully by accident
p52434
aVYou could pretty easily delete a bunch of files from the machine
p52435
aVBut you'd need to be writing code that calling functions like  to do that
p52436
aVIn any case, so long as you have UAC enabled, the system security won't let you delete system files, or program files
p52437
aVI don't think you need to worry unduly
p52438
as(dp52439
g7
V505088
p52440
stp52441
a((dp52442
g2
(lp52443
VFor a start I'd recommend that you abandon  and use C++ memory allocation techniques
p52444
aVLike , , , ,  etc
p52445
aVThat said, I can see the following errors in your code:
p52446
aVI don't really know what your code is trying to do so I'm not going to try to re-write it and correct everything
p52447
aVThe fundamental problem you have is that you systematically write sizeof(
p52448
aVand calculate the size of a pointer when you actually want the size of a character element
p52449
aVPerhaps what you really need to do is throw away all this horrid code and use  to do your concatenation
p52450
as(dp52451
g7
V505088
p52452
stp52453
a((dp52454
g2
(lp52455
VYou cannot call those functions on ARM
p52456
aVThey are simply not available
p52457
aVIn fact many of the functions aren't available even on the Intel Windows RT
p52458
aVFor example, consider
p52459
aVThe documentation states clearly that this function is available on desktop apps only
p52460
aVYou'll have to find a way to live without these functions
p52461
as(dp52462
g7
V505088
p52463
stp52464
a((dp52465
g2
(lp52466
VYou can use a fixed size buffer inside a struct
p52467
aVYou'll need it to be in an unsafe block though
p52468
aVOn the C++ side you'll need to use  to represent this type
p52469
aVAs Marc correctly says, fixed size buffers are no fun to work with
p52470
aVYou'll probably find it more convenient to do runtime length checking
p52471
as(dp52472
g7
V505088
p52473
stp52474
a((dp52475
g2
(lp52476
VYour literal  is a character literal rather than a string string literal
p52477
aVThe ASCII code for  is 89
p52478
aVSo, you are passing a  rather than a
p52479
aVWhen Word needs to get a string representation of that integer it simply converts the integer  to its textual representation, the string
p52480
aVTo get around the problem you can do this:
p52481
aVThe idea is that we ensure that we pass a string to  rather than a character
p52482
aVRemember that  receives a variant parameter and so you do need to be careful about the type of the payload stored in the variant
p52483
as(dp52484
g7
V505088
p52485
stp52486
a((dp52487
g2
(lp52488
VYou need to set the  property of the page control
p52489
aVLike this:
p52490
as(dp52491
g7
V505088
p52492
stp52493
a((dp52494
g2
(lp52495
V is not deep and doesn't do recursion
p52496
aVSo it won't allocate memory for any of the pointers inside the structure you pass
p52497
aVIf you think about this a bit more, you can see that must be so
p52498
aVYou don't pass in any information about the structure you are allocating
p52499
aVYou just pass a size for the memory block
p52500
aVNow,  doesn't even know what type of data you are allocating
p52501
aVIt doesn't know that the block itself contains a pointer
p52502
aVAs for why this design choice was made, how can the library tell who owns the memory that your pointer refers to
p52503
aVPerhaps it's owned by that structure
p52504
aVOr perhaps you want to use that pointer to refer to some memory allocated elsewhere
p52505
aVOnly you can know that which is why the responsibility falls to you
p52506
aVIn fact your structure is a fine example of this
p52507
aVProbably the  member is owned by the structure, and the  member is not
p52508
as(dp52509
g7
V505088
p52510
stp52511
a((dp52512
g2
(lp52513
VCall  passing
p52514
as(dp52515
g7
V505088
p52516
stp52517
a((dp52518
g2
(lp52519
VYou need to include either /C or /K in the options to
p52520
aV/C      Carries out the command specified by string and then terminates
p52521
aV/K      Carries out the command specified by string but remains
p52522
aVWithout one these options, the  command that you pass is simply ignored
p52523
aVHaving said that, , at least on my Windows 7 box, is not implemented inside
p52524
aVIt is a separate executable
p52525
aVSo you can invoke it directly and bypass  completely
p52526
aVRegarding your call to  I have the following comments:
p52527
aVDon't include the path
p52528
aVJust invoke  and let the system locate the executable using the standard search path
p52529
aVPass  for
p52530
aVYou aren't passing any handles to the new process and so you don't need the new process to inherit your handles
p52531
aVPass  as the working directory
p52532
aVThere's just no need to specify it here
p52533
as(dp52534
g7
V505088
p52535
stp52536
a((dp52537
g2
(lp52538
VAdd an icon resource to your project with the icon name being
p52539
aVSo, in your
p52540
aVrc file you have this:
p52541
aVAnd in the
p52542
aVdpr file compile and link the resource like this:
p52543
aVIf you have an older version of Delphi that won't accept this syntax for  then you'll need to compile the resource manually and link it like so:
p52544
aVFor example, this
p52545
aVdpr file:
p52546
aVis all you need to create an app with a main form having an icon, and that icon being shown on the task bar
p52547
aVAnd here's what it looks like:
p52548
aVNote that some of the KOL demo projects have code like this:
p52549
aVwhich naturally interferes with any attempts to impose an icon
p52550
aVClearly you'll need to remove any such code
p52551
aVI struggled with this a little whilst answering this question (my first ever KOL project FWIW) and wonder if you might have the same problem
p52552
as(dp52553
g7
V505088
p52554
stp52555
a((dp52556
g2
(lp52557
VThe use of  in the function refers to a local variable of that name
p52558
aVAnd since you have not assigned such a local variable, the program fails when you attempt to read from it
p52559
aVYou need to tell the interpretor that you want to refer to the global variable
p52560
as(dp52561
g7
V505088
p52562
stp52563
a((dp52564
g2
(lp52565
VProblem 1
p52566
aVA published property in a helper does not show up in the Object Inspector
p52567
aVThat's right
p52568
aVProperties declared in helpers will never appear in the Object Inspector
p52569
aVProblem 2
p52570
aVVirtual methods have no effect in class helpers
p52571
aVAgain, that's by design
p52572
aVAlthough the compiler allows you to define virtual methods in helpers, it doesn't have any effect
p52573
aVIn order for  to fire,  needs to be the active helper for the target object
p52574
aVProblem 3
p52575
aVThe  method for my intercepted  class does not fire
p52576
aVThat's because you are not instantiating the intercepted
p52577
aVIf you instantiate the right class, the interceptor class that you define, that method will fire
p52578
as(dp52579
g7
V505088
p52580
stp52581
a((dp52582
g2
(lp52583
VYour  function should look like this:
p52584
aVBut perhaps you'd be better with
p52585
aVAs for your , that looks more difficult
p52586
aVIt clearly only accepts ANSI input
p52587
aVIf you want to stick with ANSI then just change the declaration to
p52588
aVRTF is encoded with 7 bit ASCII
p52589
aVTo make that function work with Unicode input you'd need to escape any characters with ordinal >= 128
p52590
aVThe escaping is described, for example, on the Wikipedia Rich Text Format page
p52591
aVI'll leave that as an exercise for you
p52592
aVBefore you go much further you need to read Marco Cant's white paper: Delphi and Unicode
p52593
as(dp52594
g7
V505088
p52595
stp52596
a((dp52597
g2
(lp52598
VQuestion 1
p52599
aVCall the SetPosition and SetSize methods on the form
p52600
aVQuestion 2
p52601
aVUse
p52602
as(dp52603
g7
V505088
p52604
stp52605
a((dp52606
g2
(lp52607
VOn the menu item, set  to
p52608
aVOn the button, set the  to
p52609
aVYou must do this at runtime
p52610
aVThis will break the association with the action for just those individual properties
p52611
aVThe action will still be used for , ,  etc
p52612
as(dp52613
g7
V505088
p52614
stp52615
a((dp52616
g2
(lp52617
VYour p/invokes are a little off
p52618
aVYou need to use , which is the default
p52619
aVAnd for the  parameters you should simply declare them to be  at the C# end
p52620
aVThe correct C# p/invoke for  is:
p52621
aVAnd for  you need this:
p52622
aVIf, after fixing your code, you still receive errors when calling these functions, then you are clearly using the library incorrectly
p52623
aVAnd that's beyond the scope of this question
p52624
aVConsult the documentation, and/or seek support from the library vendor
p52625
as(dp52626
g7
V505088
p52627
stp52628
a((dp52629
g2
(lp52630
VAfter a little experimentation, it seems that the determination of whether or not debug info is enabled is controlled by the first unit that references a specific instantiation of the type
p52631
aVSo, if the first time the compiler encounters an instantiation of the type, debug info is enabled, then the specific type will be compiled with debug info
p52632
aVOn the other hand, if the first instantiation is in a unit with no debug info, then there will be no debug info
p52633
aVIn your example, the first (and only) instantiation of  is in the
p52634
aVdpr file which does have debug info enabled
p52635
aVSo, if you move the  into the
p52636
aVdpr file, and set  in , you will find that there is no debug info for
p52637
aVThe reason I talk about the first instantiation is that there may be many different units that  instantiate
p52638
aVThe first one that the compiler meets is the one that determines whether or not the instantiated type is compiled with debug info
p52639
aVIt is possible to arrange for  to have debug info, but for  not to have debug info
p52640
aVI guess it must be possible since I cannot step info any Generics
p52641
aVCollections
p52642
aVTList method without enabling the "use debug
p52643
aVdcus" option
p52644
aVI cannot explain that
p52645
aVAccording to my hypothesis, debug info should be available for TList instantiations, if debug info is on when you instantiate the class for the first time
p52646
aVI suspect that there may be a bug in the debugger
p52647
aVFor example, I wrote the following program:
p52648
aVWhen I run this with Enable Debug DCUs off, I can indeed step into
p52649
aVBut I step into completely the wrong place
p52650
aVIt lands at
p52651
aVSo, I'm sorry I can't offer more insight, but this aspect of your question has me baffled
p52652
as(dp52653
g7
V505088
p52654
stp52655
a((dp52656
g2
(lp52657
VYou can simply  the tab sheet
p52658
aVYou don't need to separately free the children of the tab sheet
p52659
aVJust call  on the tab sheet and you are done
p52660
aVHowever, if the button lives on the tab sheet that is being freed, that will not work
p52661
aVIt is not possible to free the parent of the button from the button's  event handler
p52662
aVThe solution is to post your self a message
p52663
aVThe message needs to contain the information needed to free the tab sheet
p52664
aVBy posting the message you allow the  event handler to run to completion before the queued message is processed
p52665
aVThen add a handler for the message to the form:
p52666
aVand implement it like this:
p52667
aVNow, having written this lengthy response, do be clear that the advice from paragraph 2 onwards only applies in the case where the button is a child of the control that is being freed
p52668
as(dp52669
g7
V505088
p52670
stp52671
a((dp52672
g2
(lp52673
VI expect that the designers confined these classes to implementation sections to ensure that other developers were not able to use them
p52674
aVDoes it change in newer versions of delphi
p52675
aVIn XE3, and presumably in all other versions since Delphi 7, these types are still confined to the implementation section of
p52676
aVIs it a good practice if I just copy it to my unit
p52677
aVNo it would not\u2013that would be a clear violation of the Delphi license
p52678
as(dp52679
g7
V505088
p52680
stp52681
a((dp52682
g2
(lp52683
VThe key issue here is that the first instance of  is created as window that is owned by the application window,
p52684
aVAnd here I am referring to the Windows meaning of owner
p52685
aVIn VCL language this is known as the popup parent
p52686
aVNow, when you create that first  instance, the  property is still
p52687
aVAnd because you did not explicitly assign , the code in  sets the owner to be the application window
p52688
aVYou simply do not want your windows to be owned by the hidden application window
p52689
aVThis is the reason why that first  instance sometimes appears behind all the other windows, in particular behind your main form
p52690
aVIt has simply been created with the wrong owner
p52691
aVThe form that is owned by  gets shown in
p52692
aVThat happens due to the line that reads
p52693
aVThis is followed by a call to  which results in the incorrectly owned form coming to the front
p52694
aVPresumably that form comes to the front because it is also owned by
p52695
aVRight now I don't have a clear explanation for the precise mechanism, but I don't find that terribly interesting because the form is clearly setup wrongly
p52696
aVIn any case, the fundamental problem is that you have created a window that is incorrectly owned
p52697
aVThe solution therefore is to make sure that the window is owned correctly
p52698
aVDo that by assigning the
p52699
aVFor example:
p52700
as(dp52701
g7
V505088
p52702
stp52703
a((dp52704
g2
(lp52705
VYour code is failing because you are passing  for both  and
p52706
aVYou must pass a value for at least one of them
p52707
aVThe documentation makes that clear
p52708
aVIt looks like you have also attempted to pass a value to
p52709
aVBut you have passed a non-modifiable string literal
p52710
aVAgain the documentation makes it clear that is not allowed
p52711
aVPass a pointer to memory that can be modified
p52712
aVThe Unicode version of this function, CreateProcessW, can modify the contents of this string
p52713
aVTherefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string)
p52714
aVIf this parameter is a constant string, the function may cause an access violation
p52715
aVYou can meet that requirement like this:
p52716
aVPersonally, I see no need for  in this day and age
p52717
aVSurely you aren't still writing programs for Windows 98
p52718
aVI would do it like so:
p52719
aVThe other possible failure vector in your code is the  parameter
p52720
aVMake sure that you have initialised that correctly
p52721
aVThe most simply way to do that is like so:
p52722
aVBut you might like to add a call to
p52723
as(dp52724
g7
V505088
p52725
stp52726
a((dp52727
g2
(lp52728
VI wrote the following program:
p52729
aVIt converts 1280x760 pixel bitmaps to JPEG images, and then saves to disk
p52730
aVIt does so 100 times
p52731
aVOn my machine this takes 9 seconds
p52732
aVThat's a throughput of 11 images per second
p52733
aVIf I skip the convert to JPEG step and save the bitmap directly I can get a through put of 150 images per second
p52734
aVClearly the conversion to JPEG is a bottleneck
p52735
aVYou are looking for 30 images per second
p52736
aVWhilst multi-threading helps, I suspect you have a quad core machine
p52737
aVOne processor for the webcam, and three for the saving
p52738
aVSo if you only have three threads available, then you are probably going to struggle to reach the required throughput of 30 frames per second
p52739
aVTheoretical peak on my machine would be 33
p52740
aVIf you don't achieve 30 frames per second then your queue will obviously overflow
p52741
aVThe obvious conclusion is that you need to find a faster JPEG conversion library
p52742
aVI'm quite sure that such libraries exist
p52743
aVFor example, I think that  should be a lot faster
p52744
aVAs for your existing code there are some obvious flaws:
p52745
aVshould usually be avoided
p52746
aVIn your case it is suicidal to sleep if the last attempt to pull an image succeeded
p52747
aVDon't do that
p52748
aVYou should use a real threaded queue
p52749
aVOne that allow proper blocking waits on synchronization objects
p52750
aVIt's actually pretty trivial to make one yourself using event objects and your favourite non-threaded queue
p52751
aVYou are holding the lock whilst calling
p52752
aVThat is going to hinder scaling
p52753
aVAssign  to a local variable, outside the lock
p52754
aVAnd then assign to the shared data inside the lock
p52755
aVSo, you could check these ideas out by first of all removing the call to
p52756
aVAnd then changing  to look like this:
p52757
aVThese suggestions will help a little, but I think you'll need to tackle the fundamental problem, namely the JPEG conversion
p52758
as(dp52759
g7
V505088
p52760
stp52761
a((dp52762
g2
(lp52763
VIs there a variant of realloc that "zeroes" the memory area like calloc
p52764
aVNo
p52765
aVIs there a variant of realloc that does not copy if ever there is not enough space to grow on place, but instead just allocates like alloc
p52766
aVNo
p52767
aVIf I were you I'd probably use  and
p52768
aVBut ideally you want to design your system so that reallocations are infrequent and so the different performance characteristics of the various options are not significant
p52769
aVIn other words, make sure that it doesn't matter which option you select
p52770
as(dp52771
g7
V505088
p52772
stp52773
a((dp52774
g2
(lp52775
VThe pointer  points to a string literal
p52776
aVAccording to the standard, attempting to modify a string literal results in undefined behaviour
p52777
aVIn the case of your implementation, the segmentation fault indicates that the compiler is choosing to place the string literal in non-modifiable memory
p52778
aVDeclare  to be a string that is modifiable
p52779
aVFor example, like this:
p52780
as(dp52781
g7
V505088
p52782
stp52783
a((dp52784
g2
(lp52785
VIt's no problem at all
p52786
aVPerhaps you are relying on auto-create for your forms
p52787
aVThat only happens in an EXE project
p52788
aVIf my guess is correct you'll have a global variable of type TMyForm that is never initialized
p52789
aVYou need something like this:
p52790
as(dp52791
g7
V505088
p52792
stp52793
a((dp52794
g2
(lp52795
VYour declaration of the parameter for  is wrong
p52796
aVYou've declared an array of pointers to
p52797
aVYou need a simple char buffer
p52798
aVLike this:
p52799
aVor
p52800
aVUse whichever you prefer
p52801
aVWhen you call the function, you can do it like this:
p52802
aVAlso I would point out that your declaration for  is incorrect
p52803
aVYou should use
p52804
as(dp52805
g7
V505088
p52806
stp52807
a((dp52808
g2
(lp52809
VThis appears to be a mismatch of alignment rather than size
p52810
aVThe  pointer has 8 byte alignment
p52811
aVBut according to your analysis of the layout, it is placed on a 4 byte boundary
p52812
aVThe C# code in your question will give  an offset of 16
p52813
aVBut your analysis says that it has an offset of 12
p52814
aVThis leads me to suspect that the native  is in fact packed
p52815
aVshould resolve your problems
p52816
aVUpdate
p52817
aVI can confirm that my hunch was correct
p52818
aVThe following can be found in dismapi
p52819
aVh wrapping the struct declarations:
p52820
as(dp52821
g7
V505088
p52822
stp52823
a((dp52824
g2
(lp52825
VThe problem most likely is an attempt to load a 64 bit module
p52826
aVDebug this with Dependency Walker in profile mode
p52827
as(dp52828
g7
V505088
p52829
stp52830
a((dp52831
g2
(lp52832
V expects that you will pass a procedure that receives one parameter
p52833
aVIf you don't want to pass a parameter, just add one and ignore it
p52834
aVYou can write an adapter to make the code cleaner for the caller:
p52835
aVWith that adapter in place, the code in your question compiles and works
p52836
aVSince AsyncCalls is discontinued, and will not be modified again, you could easily enough modify that code to support the usage you desire
p52837
aVPersonally I would modify  and add another sub class of  to do the work
p52838
aVAs a really dirty hack, this would work:
p52839
aVThis relies on the fact that the integer parameter  is passed in a volatile register
p52840
aVSo, whilst the framework passes , your procedure doesn't read it from the register
p52841
as(dp52842
g7
V505088
p52843
stp52844
a((dp52845
g2
(lp52846
VYou are calling  to compare the first 256 bytes of  against the first 256 bytes of
p52847
aVYou are then taking the return value of  and passing it through
p52848
aVThat maps  to  and  to
p52849
aVThe conclusion therefore is that the first 256 bytes of the two arrays are equal
p52850
aVBecause  returned
p52851
aVNote that your statement in the question that  returned  is obviously incorrect
p52852
aVThat is a big part of our confusion
p52853
aVPrecision and accuracy are crucial when programming
p52854
as(dp52855
g7
V505088
p52856
stp52857
a((dp52858
g2
(lp52859
VMy understanding is that you want to convert a text file from UTF-8 to ASCII
p52860
aVThat's quite simple:
p52861
aVThe runtime library comes with all sorts of functionality to convert between different text encodings
p52862
aVSurely you don't want to attempt to replicate this functionality yourself
p52863
aVI trust you realise that this conversion is liable to lose data
p52864
aVCharacters with ordinal greater than 127 cannot be represented in ASCII
p52865
aVIn fact every code point that requires more than 1 octet in UTF-8 cannot be represented in ASCII
p52866
as(dp52867
g7
V505088
p52868
stp52869
a((dp52870
g2
(lp52871
VThe key section of code is here
p52872
aVThis loop pulls of pairs of numbers
p52873
aVThese are the pairs that get pulled off the stream:
p52874
aV11   50
p52875
aV12   25
p52876
aV4543 2323
p52877
aV2321 12
p52878
aVAt that point the text  is encountered and so the while loop terminates
p52879
aVThat is because the text cannot be converted into a
p52880
aVTo solve your problem you will need to switch to line oriented processing
p52881
aVUse  to pull off a line at a time
p52882
aVAnd then break the line into distinct items
p52883
aVOne possible solution would be like so:
p52884
as(dp52885
g7
V505088
p52886
stp52887
a((dp52888
g2
(lp52889
VHere's my version, for both x86 and x64:
p52890
aVOne of the nice things about x64 is that there are a lot more registers available, many of which are volatile
p52891
aVSo we can make use of that scratch space and avoid touching main memory at all
p52892
aVWell obviously we have to touch main memory to return the result
p52893
aVSince RBX is nonvolatile we preserve its value
p52894
aVAll the other registers that we modify are volatile and so we need not preserve them
p52895
aVI can't think of any way to simplify this further
p52896
as(dp52897
g7
V505088
p52898
stp52899
a((dp52900
g2
(lp52901
VClients initiate communication
p52902
aVThat is the definition of a client\u2013the actor that initiates the communication
p52903
aVOnce the connection is established though, both sides can send data
p52904
aVSo, the clients connect to the server
p52905
aVThe server maintains a list of all connected clients
p52906
aVWhen the server wants to send out communications it just sends the data to all connected clients
p52907
aVSince clients initiate communication, it follows that, in the event of broken communication, it is the client's job to re-establish connection
p52908
as(dp52909
g7
V505088
p52910
stp52911
a((dp52912
g2
(lp52913
VYou have this line of code:
p52914
aVfollowed by this:
p52915
aVAnd in between you do not assign anything to
p52916
aVWhat this means is that  does not refer to a valid object
p52917
aVAnd so you can expect runtime errors
p52918
as(dp52919
g7
V505088
p52920
stp52921
a((dp52922
g2
(lp52923
VLike this:
p52924
as(dp52925
g7
V505088
p52926
stp52927
a((dp52928
g2
(lp52929
VThe  function returns
p52930
aVYou cannot assign one of those to a
p52931
aVFor exactly the same reason why you cannot assign a  reference to a  reference
p52932
aVYou can change the code to be like so:
p52933
as(dp52934
g7
V505088
p52935
stp52936
a((dp52937
g2
(lp52938
VThe line that fails is:
p52939
aVBefore this line runs you assigned  like this:
p52940
aVIt would seem that  returned
p52941
aVAs I'm sure you know, you have to have a valid object instance in order to call methods, access fields and properties etc
p52942
aVYour code should check for this condition and respond accordingly
p52943
aVYou can see all this quite readily in the debugger
p52944
aVThe debugger will break on that line and when you inspect the variables it will tell you that  is
p52945
aVThen you have to look at the code and work out why
p52946
aVI recommend that you spend some time improving your debugging skills and learning how to use the tools available
p52947
as(dp52948
g7
V505088
p52949
stp52950
a((dp52951
g2
(lp52952
VI've had a read of the TeeChart source code (v2010)
p52953
aVThere is no scope for customisation\u2013nothing like
p52954
aVFor non-logarithmic axes, the minor ticks are drawn equally spaced between the labels
p52955
aVFor logarithmic axes the minor ticks are not drawn equally spaced between the labels, at least for non-equally spaced labels
p52956
aVIn fact I can see that in my code I always disable minor ticks when using logarithmic axes
p52957
aVI suspect that's because they simply don't work at all
p52958
aVSo I think your only option is to modify the source code yourself
p52959
as(dp52960
g7
V505088
p52961
stp52962
a((dp52963
g2
(lp52964
VThe answer is already in your question
p52965
aVDelete does not delete a file that is open for normal I/O
p52966
aVSo, close the file, and then you can delete it
p52967
aVYou should also wrap your file streams in  blocks to ensure that the unmanaged resources will be tidied up in a timely and predictable fashion
p52968
aVLike this:
p52969
aVThis is the best way to make sure that your file is closed when you have finished with it
p52970
aVYou can put your call to  after the  block
p52971
aVFinally, I'm pretty sure that you don't want to use
p52972
aVFor example, on your input file that will allow other processes to delete the file while you are operating on it
p52973
aVYou want  on the file that you are reading, and  on the file that you are writing
p52974
as(dp52975
g7
V505088
p52976
stp52977
a((dp52978
g2
(lp52979
Vis wrong
p52980
aVThat's one byte off the end
p52981
aVYou mean:
p52982
aVYou will also have a buffer overrun if the input string does not have a space
p52983
aVCheck for the null terminator in your loop and terminate when you encounter one
p52984
aVI'd write it like this:
p52985
aVFor what it is worth, I think  is probably a better option here
p52986
aVOnce you've worked out exactly how much text needs to be copied, you may as well just blit it over
p52987
aVNo need for a string function which looks for null terminators
p52988
aVYou, once you fix the code, have already checked for them
p52989
aVAnd you should check the return value of
p52990
as(dp52991
g7
V505088
p52992
stp52993
a((dp52994
g2
(lp52995
VNothing has changed since Delphi 7
p52996
aVIn Delphi 7, and in fact previous versions, TDateTime is IEEE754, measuring the number of days since the Delphi epoch
p52997
aVYou are going to need to get in touch with the software vendor and try to work out what this data's format really is
p52998
aVIt would be surprising if the format was a non-IEEE754 floating point data type
p52999
aVAre you quite sure that it is floating point
p53000
as(dp53001
g7
V505088
p53002
stp53003
a((dp53004
g2
(lp53005
VThere is a mechanism for you to modify the contents of a meta file
p53006
aVCall  passing a callback function,
p53007
aVThe callback function is called for each record in the metafile
p53008
aVYou can take a copy of this record, modify it, and then pass it to
p53009
aVSo, you could look for records that specified colours, and make whatever modifications you need
p53010
as(dp53011
g7
V505088
p53012
stp53013
a((dp53014
g2
(lp53015
VThe fundamental problem with your code is that you are forcing 256 distinct updates irrespective of the performance characteristics of the machine
p53016
aVYou don't have to use every single alpha blend value between 255 and 0
p53017
aVYou can skip some values and still have a smooth fade
p53018
aVYou need to account for the actual graphics performance of the machine
p53019
aVSince you cannot predict that, you should account for real time in your fade code
p53020
aVDoing so will give you a consistent rate of fade irrespective of the performance characteristics of your machine
p53021
aVSo, here's a simple example to demonstrate tying the fade rate to real time:
p53022
aVThe fade has a 1 second duration
p53023
aVYou can readily adjust the mathematics to modify the duration to your requirements
p53024
aVThis code will produce a smooth fade even on your low performing machine
p53025
aVI would also comment that you should not use the global variable  in a  method
p53026
aVThe  method already has access to the instance
p53027
aVIt is
p53028
aVAnd of course you can omit the
p53029
aVWhat's more the call to  is bad
p53030
aVThat allows re-entrant handling of queued input messages
p53031
aVYou don't want that to happen
p53032
aVSo remove the call to
p53033
aVYou actually ask about detecting the Adjust for best performance setting
p53034
aVBut I think that's the wrong question
p53035
aVFor a start you should fix your fade code so that the fade duration is independent of graphics performance
p53036
aVHaving done that you may still wish to disable the fade if the user has asked for lower quality appearance settings
p53037
aVI don't think you should look for one of the 3 canned options that you mention
p53038
aVThey are quite possibly Windows version specific
p53039
aVPersonally I would base the behaviour on the Animate windows when minimizing and maximizing setting
p53040
aVMy rationale is that if the user does not want minimize and maximize to be animated, then presumably they don't want window close to be faded
p53041
aVHere's how to read that setting:
p53042
aVI think that most of the other settings that you may be concerned with can also be read using
p53043
aVYou should be able to work out how to do so by following the documentation
p53044
as(dp53045
g7
V505088
p53046
stp53047
a((dp53048
g2
(lp53049
VHere's one option
p53050
aVFirst of all add a method to process input supplied in a  variable
p53051
aVThe signature looks like this:
p53052
aVWe will come to the implementation later
p53053
aVNext add a couple of methods that rely on :
p53054
aVFinally we can implement the method that does all the real work
p53055
aVI've taken the code from your question and replaced  with
p53056
aVThe result looks like this:
p53057
aVHaving written all this, I would comment that Uwe's approach is better
p53058
aVIt uses exactly the same basic idea
p53059
aVPut the code that does the work in one method and add extra adapter methods to support input from varying sources
p53060
aVThe reason that I think Uwe's approach is better is that it reduces the number of temporary string lists that are created
p53061
aVThe way Uwe slices it up is better in that regard
p53062
aVAnd if you want to add a  to Uwe's answer that is simple:
p53063
as(dp53064
g7
V505088
p53065
stp53066
a((dp53067
g2
(lp53068
VYou can simply cast  to be a
p53069
aVLike this:
p53070
aVAnd now you can use  for the first 16 bit value,  for the second, and so on
p53071
aVAnalagous code can be used for
p53072
aVIt doesn't matter whether your function receives  or
p53073
as(dp53074
g7
V505088
p53075
stp53076
a((dp53077
g2
(lp53078
VAssuming that this line of code from the question is accurate:
p53079
aVthen the problem lies here:
p53080
aVThis is a dynamic array constructor
p53081
aVIt creates a dynamic array of length equal to the number of parameters to the constructor
p53082
aVAnd then assigns each element of the array, in turn, to the parameters passed
p53083
aVConsider an example using
p53084
aVThis initialises  to be an array of length 3 and having values 1, 2 and 3
p53085
aVNow, let's look at your code again
p53086
aVThis initialises  to be an array of length 0
p53087
aVSo when you access  that results in a runtime error because the array index is out of bounds
p53088
aVTo solve the problem you will need to make sure that the array is initialised to have sufficient elements
p53089
aVOne option is certainly to use a dynamic array constructor
p53090
aVAnother is to use
p53091
aVI suspect that your understanding of Delphi's dynamic arrays is poor
p53092
aVI suggest that you consult the documentation
p53093
as(dp53094
g7
V505088
p53095
stp53096
a((dp53097
g2
(lp53098
VThe short string types in your question don't really protect the strings from exceeding the proper length
p53099
aVWhen you assign a longer value to these short strings, the value is silently truncated
p53100
aVI'm not sure what database access method you are using but I rather imagine that it will do the same thing
p53101
aVNamely truncate any over-length strings to the maximum length
p53102
aVIn which case there is nothing to do
p53103
aVIf your database access method throws an error when you give it an over long string then you would need to truncate before passing the value to the database
p53104
aVIf you have to truncate explicitly, then there are lots of places where you might choose to do so
p53105
aVMy philosophy would be to truncate at the last possible moment
p53106
aVThat's the point at which you are subject to the limit
p53107
aVTruncating anywhere else seems wrong
p53108
aVIt means that a database limitation is spreading to parts of the code that are not obviously related to the database
p53109
aVOf course, all this is based on the assumption that you want to carry on silently truncating
p53110
aVIf you want to do provide user feedback in the event of truncation, then you will need to decide just where are the right points to action that feedback
p53111
as(dp53112
g7
V505088
p53113
stp53114
a((dp53115
g2
(lp53116
VI see no reason to use floating point arithmetic here
p53117
aVI always avoid floating point arithmetic if integer arithmetic suffices
p53118
aVI would write it like this:
p53119
aVOr perhaps this version:
p53120
aVThis is particularly easy to understand
p53121
aVYou subtract the records shown on all the full pages, and what is left are the records on the last page
p53122
aVAs far as  goes, you can calculate it like so:
p53123
aVThanks to @Rob for his insight
p53124
as(dp53125
g7
V505088
p53126
stp53127
a((dp53128
g2
(lp53129
VNeither  nor  are exactly representable in binary floating point
p53130
aVYour desired answer of  is not exactly representable either
p53131
aVIf you want exact decimal arithmetic, you should use the  type
p53132
aVFor example:
p53133
aVwhich will result in  being of type , and having the exact value that you desire
p53134
aVThe  suffix on the literals is used to indicate values of type
p53135
aVUseful resources
p53136
aVWhat Every Computer Scientist Should Know About Floating-Point Arithmetic
p53137
aVWhat is the exact value of a floating-point variable
p53138
as(dp53139
g7
V505088
p53140
stp53141
a((dp53142
g2
(lp53143
VIf you are using Delphi 7, then  will map to the ANSI version,
p53144
aVIn which case passing  is wrong
p53145
aVWrite it like this:
p53146
aVOr, if you prefer to use the Unicode version, then you need to use
p53147
as(dp53148
g7
V505088
p53149
stp53150
a((dp53151
g2
(lp53152
VThis is how I pull messages off a thread's queue:
p53153
aVUsing  will pull messages of the queue of the calling thread
p53154
aVBut it's not appropriate to use in a message loop because it won't block
p53155
aVThat's why you use
p53156
aVIt blocks if the queue is empty
p53157
aVAnd  also calls other  methods that are not designed to be thread safe
p53158
aVSo there are plenty of reasons not to call it from a thread other than the main thread
p53159
aVWhen you need to terminate the thread, then I do this:
p53160
aVNone of this is OTL specific
p53161
aVThis code all is intended to live in a  descendent
p53162
aVHowever, the ideas are transferable
p53163
aVIn the comments you indicate that you want to run a busy, non-blocking message loop
p53164
aVYou would use  for that
p53165
as(dp53166
g7
V505088
p53167
stp53168
a((dp53169
g2
(lp53170
VThis question appears to be entirely about injection
p53171
aVAnd you defend against that by passing all user data to the DB using parameters
p53172
aVWhen you do this there's no need to escape anything
p53173
aVDon't be tempted to tackle this problem in any other way
p53174
as(dp53175
g7
V505088
p53176
stp53177
a((dp53178
g2
(lp53179
VThe explanation for the failure of your code is that the path is invalid
p53180
aVThe documentation says:
p53181
aVDirectoryNotFoundException
p53182
aVThe specified path is invalid (for example, it is on an
p53183
aVunmapped drive)
p53184
aVTrying to predict in advance whether or not a directory can be created is a devil of a job
p53185
aVYou'd need to account for security, OS name rules and limits, file system name rules and limits, and whether or not drives are mapped
p53186
aVAnd probably lots more concerns
p53187
aVI would not contemplate re-implementing what the system provides for free
p53188
aVIn any case, whilst you can call , you do still need to allow for an exception being thrown
p53189
aVIf the file system changes between the call to  and the subsequent call to , then an exception will be raised
p53190
aVFor example, if another process creates the directory that you are trying to create
p53191
aVGranted, this is a rather unlikely event, but it's perfectly possible
p53192
aVIn summary, the best option, by a distance, is to catch the exception
p53193
aVAs the well known saying goes, it's better to ask for forgiveness than to ask for permission
p53194
as(dp53195
g7
V505088
p53196
stp53197
a((dp53198
g2
(lp53199
VThe bare minimum virtual  methods that you need to override are:
p53200
aVIf you want to support the assigning to the  property you need to override:
p53201
aVThe implementation of the 32 bit  must call the 64 bit
p53202
aVAnd the 64 bit  does the work
p53203
aVIf you don't override these methods then assigning to the stream's  property will silently do nothing
p53204
as(dp53205
g7
V505088
p53206
stp53207
a((dp53208
g2
(lp53209
VYou don't need to register the built-in property editors for ,  and
p53210
aVThey are already registered
p53211
aVThat's why your attempts to register them have no impact
p53212
aVThe built-in property editors for these types simply convert between the underlying floating point value and a string representation
p53213
aVThey don't implement date time pickers or anything like that
p53214
aVYou say:
p53215
aVHowever I need the same thing for TTime and TDateTime but they don't come with a property editor, and in fact it won't even accept any value I type in there either
p53216
aVThat is in fact incorrect
p53217
aVThey do come with property editors
p53218
aVThey are the same built-in property editors that you named in your question
p53219
aVAnd they do accept values
p53220
aVThey don't accept the values you provided because you provided invalid values
p53221
aVIf you want to register a property editor that does provide a visual date time picker, then you will have to write the property editor yourself
p53222
as(dp53223
g7
V505088
p53224
stp53225
a((dp53226
g2
(lp53227
VThe common idiom for an empty statement macro is this:
p53228
aVAs Ben points out in a comment, it is prudent to use this technique in both versions of the macro
p53229
aVThis idiom is discussed in many places
p53230
aVFor example:
p53231
aVhttp://bruceblinn
p53232
aVcom/linuxinfo/DoWhile
p53233
aVhtml
p53234
aVhttp://yarchive
p53235
aVnet/comp/linux/empty_statement_macro
p53236
aVhtml
p53237
as(dp53238
g7
V505088
p53239
stp53240
a((dp53241
g2
(lp53242
VThe class is compiled with the Emit runtime type information setting enabled
p53243
aVWhen the class is compiled with runtime type information, the default visibility is
p53244
aVWhich means that the short string field is
p53245
aVAnd short string fields are not allowed to be published
p53246
aVThe documentation says:
p53247
aVFields can be published only if they are of a class or interface type
p53248
aVThat's a pretty stringent requirement
p53249
aVIt means that you can't publish integer or boolean fields, for example
p53250
aVI suspect this limitation is because the primary use for published fields is for object references
p53251
aVThink of the components on a form
p53252
aVSolve the problem using one of these options:
p53253
aVDon't emit runtime type information for this class
p53254
aVMake the short string fields public rather than published
p53255
aVUse properties rather than fields
p53256
as(dp53257
g7
V505088
p53258
stp53259
a((dp53260
g2
(lp53261
VThe implicit function Result variable is only available when the extended syntax compiler option is enabled
p53262
aVThe Result variable
p53263
aVIn the {$X+} mode, the predefined
p53264
aVvariable Result can be used within a function body to hold
p53265
aVthe function's return value
p53266
as(dp53267
g7
V505088
p53268
stp53269
a((dp53270
g2
(lp53271
VI would write it like this:
p53272
aVWhen you call the function you can pass
p53273
aVBut if you pass a pointer to a variable, you can name that variable such that the code at the call site makes it obvious what is going on
p53274
aVThe problem with using a function that returns a value is that you typically name those functions with the name of the value that is returned
p53275
aVBut if the function has a strong side effect, that won't be captured in the name
p53276
aVWhen there are side effects, it is often a good idea to use a  function and a name that describes the side-effects
p53277
as(dp53278
g7
V505088
p53279
stp53280
a((dp53281
g2
(lp53282
VThe compiler warning is accurate
p53283
aVIf the if statement never evaluates to , because no match was found, then the loop does not assign to Result
p53284
aVAnd then the function exits without assigning a value
p53285
aVYour options:
p53286
aVAssign a value to , after the loop completes, that indicates that no match was found
p53287
aVRaise an exception, after the loop completes
p53288
aVI would also suggest that you  immediately after assigning
p53289
aVNo point continuing round the loop when you have found the answer
p53290
aVI would likely write this function like this:
p53291
aVNote the use of the  variable as the loop variable
p53292
aVThis is idiomatic and has the benefit of reducing the number of local variables that you declare
p53293
aVI agree that you could probably solve your problem more effectively using , but I wanted to show you how to deal with the compiler warning in an idiomatic fashion
p53294
as(dp53295
g7
V505088
p53296
stp53297
a((dp53298
g2
(lp53299
VYour indentation is all awry
p53300
aVI think this is what is confusing you
p53301
aVIf you indent the code properly, it looks like this:
p53302
aVI think it's clear to see now that the code that follows the  loop can execute without  having been assigned
p53303
aVIt's clear from the indentation in the question that you intended the long swathe of code that follows the assignment to be inside the  statement
p53304
aVBut the compiler obeys the code rather than the indentation
p53305
aVYou are going to need to add some  pairs to your code
p53306
aVPersonally I never use the single statement syntax \u2013 all my blocks are compound blocks wrapped with  pairs
p53307
aVIn my view the single statement syntax is one of the great errors of Pascal
p53308
aVAnd indeed C
p53309
aVI used the built-in code formatter to straighten out your indentation
p53310
aVThat would probably be a useful tool that could help you to repair the code
p53311
aVAnd it could let you get a handle on how the indentation might be laid out correctly
p53312
aVFinally, as I have said to you at least once before, do not use  as a variable name
p53313
aVThis hides the type named
p53314
aVThe  prefix is reserved for types
p53315
aVYou should call your form variable , or perhaps  with the  indicating that it is a local variable
p53316
as(dp53317
g7
V505088
p53318
stp53319
a((dp53320
g2
(lp53321
VThe modern versions of Delphi implement  in broadly the same way as your code does
p53322
aVThe implementation has extra handling for symlinks but is otherwise essentially identical to your version
p53323
aVThere's one interesting nuance in the modern Delphi implementation
p53324
aVIf the call to  returns , then the code doesn't immediately bail out
p53325
aVInstead it does this:
p53326
aVAnd the implementation of  uses  and a check of the   on
p53327
aVThis indicates that  can fail when the file exists, but is locked
p53328
aVBut that  can succeed in such a scenario
p53329
aVThat's reasonable because  uses the file metadata rather than the data stored in the file itself
p53330
aVIt's hard to say why the code is is the way it is in the older versions
p53331
aVI think it's weak
p53332
aVPersonally I would replace  with a better version, using a code hook
p53333
aVFor example: Patch routine call in delphi
p53334
aVAs always, there's a Raymond Chen article on the subject: Superstition: Why is GetFileAttributes the way old-timers test file existence
p53335
as(dp53336
g7
V505088
p53337
stp53338
a((dp53339
g2
(lp53340
VYou can't call the paint box  event handler yourself
p53341
aVWhen you do so the paint box canvas is not properly prepared
p53342
aVIn order to force the paint box to repaint you need to call the  or  methods
p53343
aVLike this:
p53344
aVor
p53345
aVCalling  results in asynchronous repainting
p53346
aVThe control is marked as being dirty and when the message queue is next empty a  message is synthesised and the control will be repainted
p53347
aVCalling  forces a synchronous paint cycle
p53348
aVThat is, the paint will be performed, and then the  function will return
p53349
aVUnless you have a special reason for forcing synchronous re-paint, I suggest that you call
p53350
aV@Sertac suggests in a comment that your painting code is not in an  handler
p53351
aVIf that is so then that is an even bigger problem
p53352
aVYou must put all your painting code in the event handler attached to the paint box  event
p53353
as(dp53354
g7
V505088
p53355
stp53356
a((dp53357
g2
(lp53358
VYour function pointer is declared with no calling convention specified
p53359
aVThe default calling convention is
p53360
aVBut Windows API functions are
p53361
aVYou need to add the calling convention to your function pointer type
p53362
as(dp53363
g7
V505088
p53364
stp53365
a((dp53366
g2
(lp53367
VFrom the comments it is clear that you are not assigning a  to the  event
p53368
aVThe declaration of  is:
p53369
aVSo you need a procedure, with a single parameter of type , and the procedure must be the method of an object
p53370
aVSo, something like this:
p53371
aVAnd then you can assign it like so:
p53372
as(dp53373
g7
V505088
p53374
stp53375
a((dp53376
g2
(lp53377
VDynamic arrays always have a lower bound of
p53378
aVSo,  equals  for all dynamic arrays
p53379
aVThis is even true for empty dynamic arrays, i
p53380
ag192
aVFrom the documentation:
p53381
aVDynamic arrays are always integer-indexed, always starting from 0
p53382
as(dp53383
g7
V505088
p53384
stp53385
a((dp53386
g2
(lp53387
VThe type that you declared receives its parameter by value
p53388
aVThe function you pass is marked with
p53389
aVSo the compiler rejects the parameter you attempt to pass as not matching
p53390
aVYou need to make both sides match
p53391
aVFor example:
p53392
as(dp53393
g7
V505088
p53394
stp53395
a((dp53396
g2
(lp53397
VYou cannot create a new session from a service
p53398
aVSessions are managed by the OS
p53399
aVNew ones get created when users logon interactively
p53400
as(dp53401
g7
V505088
p53402
stp53403
a((dp53404
g2
(lp53405
VFrom your comment it seems you want to know how to pull out some key value pairs, comma separated, into a dictionary
p53406
aVHere's a basic example:
p53407
aVYou may likely want to add more error-checking and so on, but I'm assuming you already know how to do that
p53408
aVThis example illustrates splitting a line on the first comma, and also how to populate a dictionary
p53409
aVIn order to use it you need to transfer your file to a  object
p53410
aVThat's routine:
p53411
as(dp53412
g7
V505088
p53413
stp53414
a((dp53415
g2
(lp53416
VI'm sure that you can't keep the functionality and have the  directories stored elsewhere
p53417
aVIf you want the functionality then you need the folders alongside your source code
p53418
aVThe folders are hidden and so long as you configure your revision control system properly, you never need to be aware of them
p53419
aVI would also recommend using Andreas Hausladen's DDevExtensions which has a feature to delete the  folders when they are empty
p53420
as(dp53421
g7
V505088
p53422
stp53423
a((dp53424
g2
(lp53425
VYour p/invoke doesn't look quite right
p53426
aVIt should (presumably) use the  calling convention
p53427
aVYou should not use
p53428
aVAnd there's no need for unsafe code
p53429
aVI would write it like this:
p53430
aVThen call it like this:
p53431
aVI didn't specify the  since  is the default
p53432
as(dp53433
g7
V505088
p53434
stp53435
a((dp53436
g2
(lp53437
VYour code here is basically fine
p53438
aVI would always choose to increment a pointer than cast to a fake array
p53439
aVBut you should not cast to an integer
p53440
aVThat is semantically wrong and you'll pay the penalty anytime you compile on a platform that has pointer size different from your integer size
p53441
aVAlways use a pointer to an element of the right size
p53442
aVIn this case a pointer to byte
p53443
aVUnless the compiler is having a really bad day, you won't find it easy to get better performing code than this
p53444
aVWhat's more, I think this style is actually rather clear and easy to understand
p53445
aVMost of the clarity gain comes in avoiding the need to cast
p53446
aVAlways strive to remove casts from your code
p53447
aVIf you want to allow any pointer type to be passed then you can write it like this:
p53448
aVOr if you want to avoid pointers in the interface, then use an untyped const parameter
p53449
aVUse a var parameter if you need to modify the buffer
p53450
as(dp53451
g7
V505088
p53452
stp53453
a((dp53454
g2
(lp53455
VDeclare the function in C# like this:
p53456
aVAnd then call it like this:
p53457
aVNote that C#  does not match C
p53458
aVYou need C#  to match that because  is the same size as a pointer, either 32 or 64 bits
p53459
aVBut  is always 4 bytes
p53460
aVI am assuming that your DLL uses the cdecl calling convention
p53461
aVIf you are using stdcall, you can make the obvious alteration
p53462
aVI also assumed that your data is in fact text data
p53463
aVIf it is just a plain old byte array then the code is simpler
p53464
aVAnd then to call:
p53465
as(dp53466
g7
V505088
p53467
stp53468
a((dp53469
g2
(lp53470
VThe documentation for  reads:
p53471
aVUse with DwmSetWindowAttribute
p53472
aVEnables or forcibly disables DWM transitions
p53473
aVThe pvAttribute parameter points to a value of TRUE to disable transitions or FALSE to enable transitions
p53474
aVThe macros  and  are declared as:
p53475
aVSo you need to pass  for the  parameter
p53476
aVThe boolean type that Windows uses natively is
p53477
aVThis is declared like this:
p53478
aVAnd since  is , the  you need to pass is
p53479
as(dp53480
g7
V505088
p53481
stp53482
a((dp53483
g2
(lp53484
VSo long as you have overloaded constructors named , you cannot hide the parameterless  constructor when deriving from
p53485
aVThis is discussed here: http://www
p53486
aVyanniel
p53487
aVinfo/2011/08/hide-tobject-create-constructor-delphi
p53488
aVhtml
p53489
aVIf you are prepared to put another class between your class and  you can use Andy Hausladen's trick:
p53490
as(dp53491
g7
V505088
p53492
stp53493
a((dp53494
g2
(lp53495
VProcesses and native OS threads are only bound to specific processors if somebody specifically requests for that to happen
p53496
aVBy default, processes and threads can (and will) be scheduled on any available processor
p53497
aVModern operating systems use pre-emptive multi-threading and can interrupt a thread's execution at any moment
p53498
aVWhen that thread is next scheduled to run, it can be executed on a different processor
p53499
aVThis is known as a context switch
p53500
aVThe thread's entire execution context is stored away by the operating system and then when the thread is re-scheduled, the execution context is restored
p53501
aVBecause of all this, it makes no real sense to ask what processor your thread is executing on since the answer can change at any moment
p53502
aVEven during the execution of the function that queried which the current thread's processor
p53503
aVAgain, by default, there's no relationship between the processors that two separate processes execute on
p53504
aVThe two processes could execute on the same processor, or different processors
p53505
aVIt all depends on how the OS decides to schedule the different threads
p53506
aVIn the comments you state:
p53507
aVThe Python process will execute on only one core due to the GIL lock
p53508
aVThat statement is simply incorrect
p53509
aVFor example, a section of Python code would claim the GIL, get context switched around all the available processors, and then release the GIL
p53510
aVRight at the start of the answer I said alluded to the possibility of binding a process or thread to a particular processor
p53511
aVFor example, on Windows you can use  and  to do this
p53512
aVHowever, it is unusual to do this
p53513
aVI can only recall ever doing this once, and that was to ensure that an execution of  run on a specific processor
p53514
aVIn the normal run of things, processes and threads have affinity with all processors
p53515
aVIn another comment you say:
p53516
aVI am creating the child processes to use multi cores of the CPU
p53517
aVIn which case you have nothing to worry about
p53518
aVTypically you would create as many processes as there are logical processors
p53519
aVThe OS scheduler is sensible and will schedule each different process to run on a different processor
p53520
aVAnd thus make the optimal use of the available hardware resources
p53521
as(dp53522
g7
V505088
p53523
stp53524
a((dp53525
g2
(lp53526
VThe default namespace appears to be Portal cake\u2013it's a lie
p53527
aVThe documentation you link to does not match the program
p53528
aVI made this program:
p53529
aVMyCompany
p53530
aVPrograms
p53531
aVMyProgram
p53532
aVdpr
p53533
aVMyUnit
p53534
aVpas
p53535
aVAnd the resulting
p53536
aVdcu file is named
p53537
aVAccording to the documentation that you linked to it should be named
p53538
aVI believe that you will have to specify the namespace explicitly in the unit name
p53539
as(dp53540
g7
V505088
p53541
stp53542
a((dp53543
g2
(lp53544
VOne common algorithm to perform a shuffle is the Fisher-Yates shuffle
p53545
aVThis generates uniformly distributed permutations
p53546
aVTo implement on a Delphi  object you can use this:
p53547
aVNow, whilst in theory this will generate uniformly distributed permutations, the actual performance depends heavily on the quality of the random number generator
p53548
aVThis is discussed in Knuth's Art of Computer Programming, volume 2, section 3
p53549
ag34876
aV2, Algorithm P
p53550
aVFurther reading:
p53551
aVFisher-Yates shuffle (Wikipedia)
p53552
aVJeff Attwood's two blog articles on shuffling: Shuffling and The Danger of Navet
p53553
aVThe intuition behind Fisher-Yates shuffling (Eli Bendersky)
p53554
aVArt of Computer Programming, Donald Knuth, volume 2, section 3
p53555
ag34876
ag25125
aVShuffling (Wikipedia)
p53556
as(dp53557
g7
V505088
p53558
stp53559
a((dp53560
g2
(lp53561
VYou need to declare  to be
p53562
aVThen allocate it with a call to
p53563
aVAllocate an extra element in case the registry data is mal-formed and is missing a null-terminator
p53564
aVThat is something that can happen
p53565
aVThen set the last element to :
p53566
aVThen get the value:
p53567
aVDeallocate using :
p53568
as(dp53569
g7
V505088
p53570
stp53571
a((dp53572
g2
(lp53573
VAs I understand it, you are using the wrong method
p53574
aVThe  method is used to create a new document
p53575
aVYou can pass a template file name to make the new document be based on that template
p53576
aVBut you want to open an existing document and edit it
p53577
aVIt doesn't matter that the document is a template
p53578
aVYou still need to open it
p53579
aVAnd for that you need the  method
p53580
aVHere's a rather trivial example
p53581
aVI've used late binding because I found that easier for this example
p53582
aVBut you should stick to your early binding approach
p53583
aVYou'll have to navigate the fact that the open method takes loads of parameters
p53584
aVI think you can simply pass  to all but the first parameter
p53585
as(dp53586
g7
V505088
p53587
stp53588
a((dp53589
g2
(lp53590
VIf your app is meant to be processing all the time, then of course it will consume all of the CPU
p53591
aVIf it is meant to be waiting for new data to arrive, then it should not consume much CPU
p53592
aVAn incredibly common mistake that people make is to write a busy loop
p53593
aVThat would look like this:
p53594
aVI'm going to make a wild guess that your code looks like this
p53595
aVThis will run at full CPU utilization and spend almost all of its time repeatedly calling  which would return  almost always
p53596
aVWhat you need to do instead is to let the CPU idle when there is no data
p53597
aVAnd then wake-up to process it
p53598
aVThere are countless ways to achieve that
p53599
aVIn an ideal world you'd get a notification when there was new data
p53600
aVBut if you can't manage that then polling with a sleep will throttle the CPU use
p53601
aVSince we know nothing about the architecture of your application, I won't even attempt to suggest an implementation
p53602
aVBut the key is that you use a blocking wait, rather than a busy loop
p53603
as(dp53604
g7
V505088
p53605
stp53606
a((dp53607
g2
(lp53608
VYou should only call  on objects that were allocated by a call to , ,  etc
p53609
aVSince these three fields were not created that way you should not attempt to  them
p53610
aVThe memory for these three fields is part of the struct it is allocated when you allocate the struct
p53611
aVIt was not separately allocated
p53612
aVAnd consequently does not need separate deallocation
p53613
as(dp53614
g7
V505088
p53615
stp53616
a((dp53617
g2
(lp53618
VAn internal error means that the compiler has a bug
p53619
aVYou could do what the error message says and submit a bug report
p53620
aVHowever, because you are using such an ancient version of GCC, I expect that would be fruitless
p53621
as(dp53622
g7
V505088
p53623
stp53624
a((dp53625
g2
(lp53626
VThe principle difference relates to when and how you decide the array length
p53627
aVUsing fixed length arrays forces you to decide your array length at compile time
p53628
aVIn contrast using  allows you to decide the array length at runtime
p53629
aVIn particular, deciding at runtime allows you to base the decision on user input, on information not known at the time you compile
p53630
aVFor example, you may allocate the array to be a size big enough to fit the actual data input by the user
p53631
aVIf you use fixed length arrays, you have to decide at compile time an upper bound, and then force that limitation onto the user
p53632
aVAnother more subtle issue is that allocating very large fixed length arrays as local variables can lead to stack overflow runtime errors
p53633
aVAnd for that reason, you sometimes prefer to allocate such arrays dynamically using
p53634
as(dp53635
g7
V505088
p53636
stp53637
a((dp53638
g2
(lp53639
VOnly the first assignment can lead to slicing, since that assignment involves a copy
p53640
aVThe second assignment merely takes a reference to the object
p53641
aVWithout a copy, there can be no slicing
p53642
as(dp53643
g7
V505088
p53644
stp53645
a((dp53646
g2
(lp53647
VThe message means that the p/invoke marshaller isn't capable of marshalling that return value into a
p53648
aVAs I see it you have the following options:
p53649
aVDeclare the C# function as returning
p53650
aVThen on the managed side you need to copy the memory into a  allocated in your C# code
p53651
aVYou can use  to do that
p53652
aVSomehow you'll need to find out the length of the array
p53653
aVYou also need to handle deallocation
p53654
aVYour C# code cannot do that
p53655
aVSo it will have to call another function in the native code and ask the native code to deallocate
p53656
aVAllocate the  in the C# code before the call to your native code
p53657
aVInstead of using a function return value, you pass the  as a parameter
p53658
aVThis requires the calling code, the C# code, to know how big the array needs to be
p53659
aVIf you can choose option 2, it will result in simpler code on both sides of the interface
p53660
aVMy guess is that the return array is the same length as the input arrays
p53661
aVIn which case choose option 2
p53662
as(dp53663
g7
V505088
p53664
stp53665
a((dp53666
g2
(lp53667
VI would first of all say that this is not a linked list
p53668
aVThat's a very different structure
p53669
aVWhat's more, rather than reimplementing , you should simply use the built-in class that is supplied with Delphi
p53670
aVThe fundamental problem with your code is that you are using dynamic arrays incorrectly
p53671
aVYou must not use raw allocation functions like
p53672
aVFunctions like ,  etc
p53673
aVare for use with raw pointers
p53674
aVThe lifetime of dynamic arrays is managed by the compiler/runtime library
p53675
aVTo allocate dynamic arrays you must use
p53676
aVThe other significant error is that the call to  moves the wrong number of elements
p53677
aVThe code below is a simplified and corrected variant of your code
p53678
aVBut I urge you to use the built-in RTL classes that are known to work
p53679
aVFor example, if you are using a modern version of Delphi you can use one of the generic containers from
p53680
aVIn your case  appears to be what you need
p53681
aVIn older Delphi versions you would use  from the  unit
p53682
as(dp53683
g7
V505088
p53684
stp53685
a((dp53686
g2
(lp53687
VThe error message indicates that you are attempting to link the resource script, the
p53688
aVrc file, rather than the compiled resource, the
p53689
aVres file
p53690
aVSo you presumably have a line that reads:
p53691
aVThis instead should read
p53692
aVWhat's more, judging from the error message, I suspect that you resource script, the
p53693
aVrc file, is not a resource script
p53694
aVI bet that it is in fact a Word document
p53695
aVYour
p53696
aVrc file needs to be a text file that looks like this:
p53697
aVWordDocument RCDATA MyDoc
p53698
aVdoc
p53699
aVYou also need to compile your script
p53700
aVLike this:
p53701
aVThis compilation step produces the binary compiled resource file, the
p53702
aVres file
p53703
aVTo make it crystal clear, you need to carry out these steps:
p53704
aVMake the
p53705
aVrc file as described above
p53706
aVCompile the
p53707
aVrc file with brcc32
p53708
aVLink the compiled resource by adding {$R stuff
p53709
aVres} to one of your Delphi source files
p53710
aVYou need to go back to basics and try to understand Windows resources better
p53711
aVAbout Resource Files (Windows)
p53712
aVResource Files Made Easy (delphi
p53713
aVabout
p53714
aVcom)
p53715
aVhow to add resources and to use them
p53716
as(dp53717
g7
V505088
p53718
stp53719
a((dp53720
g2
(lp53721
VThere is one explanation that makes sense:
p53722
aVYou are executing the program on a 64 bit machine
p53723
aVYour C# program is built as x86
p53724
aVThe  file exists in
p53725
aVAlthough  is on your system path, in an x86 process you are subject to the File System Redirector
p53726
aVWhich means that  actually resolves to
p53727
aVThere is no 32 bit version of  in
p53728
aVThe solution is to change your C# program to target  or
p53729
as(dp53730
g7
V505088
p53731
stp53732
a((dp53733
g2
(lp53734
VAn integer data type can support as many flags as there are bits
p53735
aVAccording to the MSDN documentation,  is a 32 bit data type
p53736
aVDWORD A 32-bit unsigned integer
p53737
aVThe range is 0 through 4294967295 decimal
p53738
as(dp53739
g7
V505088
p53740
stp53741
a((dp53742
g2
(lp53743
VFor the Win32 rich edit control, to search for text, you need to use either  or
p53744
aVOr, if you are using Unicode, the variants with the  suffix
p53745
aVTo select text, use the  message
p53746
aVThe reference documentation for the rich edit control enumerates the entire capabilities of this control
p53747
as(dp53748
g7
V505088
p53749
stp53750
a((dp53751
g2
(lp53752
VCall
p53753
aVYou supply a callback function that is called once for each top-level window
p53754
aVYou can then check the properties of each window with your specific criterion
p53755
aVYou can call  and then check that against the value that you are looking for
p53756
as(dp53757
g7
V505088
p53758
stp53759
a((dp53760
g2
(lp53761
VThe window handle that you are looking for is, I believe, returned by
p53762
aVTo get the class name, pass that window handle to the Windows API function
p53763
aVHere's a Delphi wrapper to that API function:
p53764
aVI used a buffer of length 256 because window class names are not allowed to be longer than that
p53765
as(dp53766
g7
V505088
p53767
stp53768
a((dp53769
g2
(lp53770
VLet's look at the line of code that causes the problems:
p53771
aVIt's very hard to find anything to say about that line of code
p53772
aVPure and simple it is an outright travesty
p53773
aVThe very first thing to do is to use some local variables
p53774
aVFor example:
p53775
aVThen we can write this:
p53776
aVContinuing in this vein we have:
p53777
aVThen the code can look like this:
p53778
aVYour first task is to re-write the code in a sane manner along the lines I suggest
p53779
aVThen there is the actual error
p53780
aVYou have an access violation with a read of address
p53781
aVThat is the hallmark of an attempt to de-reference the null pointer
p53782
aVClearly something in here is
p53783
aVI can't tell that
p53784
aVBut your debugger will tell you that
p53785
aVMake sure you configure it to break when exceptions are raised
p53786
aVThat's a setting in the IDE debugger options
p53787
aVQuite possibly one of the  calls returns
p53788
aVOr perhaps  is
p53789
aVYou may need to break that single  statement into multiple  statements to make it easier to debug
p53790
aVMy final point is to re-iterate my initial advice
p53791
aVThis code is unworkable
p53792
aVRe-factor it into a sane form immediately
p53793
as(dp53794
g7
V505088
p53795
stp53796
a((dp53797
g2
(lp53798
VYou are passing  to
p53799
aVWhen you do this, the object behaves like
p53800
aVIt's lifetime is managed by interface reference counting
p53801
aVBut you are not holding a reference to an interface
p53802
aVThe documentation covers this in some detail
p53803
aVWhen TXMLDocument is created without an Owner, it behaves like an interfaced object
p53804
aVThat is, when all
p53805
aVreferences to its interface are released, the TXMLDocument instance is automatically freed
p53806
aVWhen TXMLDocument is created with an Owner, however, it behaves like any other component, and is freed by its Owner
p53807
aVIf you enable Debug DCUs and set a breakpoint in  you can observe the object being destroyed just before your access violation
p53808
aVSolve the problem by either:
p53809
aVPassing an owner when you create the document
p53810
aVSwitch to using interfaces to refer to the object
p53811
aVThat is declare  as
p53812
aVDo make sure you do one or other of these, but not both
p53813
as(dp53814
g7
V505088
p53815
stp53816
a((dp53817
g2
(lp53818
VThe file will be loaded faithfully
p53819
aVAll whitespace is preserved exactly as it is in the file
p53820
aVThe most plausible explanation for what you observe is that your text editor displays the file differently from how the TMemo control displays it
p53821
aVPossibly your file contains tab characters
p53822
aVThese are often displayed differently in different viewers
p53823
aVOr perhaps the text editor uses a monospace font, and your memo control does not
p53824
aVBut I stress again, the file will be loaded faithfully
p53825
aVThe contents of the file are loaded into the memo control without alteration
p53826
as(dp53827
g7
V505088
p53828
stp53829
a((dp53830
g2
(lp53831
VA Delphi string grid is not a windows control
p53832
aVIt's a custom Delphi control
p53833
aVAs such it doesn't respond to windows messages asking for its content
p53834
aVWithout the source of the app you would need to reverse engineer the app to work out where the content is stored
p53835
aVRealistically the most effective way to do this will be to inject a thread into the target application
p53836
aVThat thread can then do the work of reading the information and can then use some IPC to get the data back to your VB process
p53837
aVIn order to do this you will, ideally, need:
p53838
aVKnowledge of the exact version of Delphi used to build the app
p53839
aVA deep understanding of the Delphi compiler and RTL
p53840
aVThe Delphi VCL source code for
p53841
aVI've no idea how you'll be able to synchronize your reading thread with the Delphi app
p53842
aVAnyway, whilst what you ask for is, in theory possible, in reality it is completely impractical
p53843
aVThe sensible solution is to ask the authors of the Delphi program to provide an automation interface
p53844
as(dp53845
g7
V505088
p53846
stp53847
a((dp53848
g2
(lp53849
VIf the username should be fixed during the entire lifetime of the object then it should be passed in to the constructor
p53850
aVThe benefit is that it's not possible to misuse the class and forget to assign the username
p53851
aVDeclare a constructor that receives the extra information in parameters:
p53852
aVCreate the form like this:
p53853
as(dp53854
g7
V505088
p53855
stp53856
a((dp53857
g2
(lp53858
VYour thread's  method must regularly check the state of the thread's  property
p53859
aVAnd if it is , then the thread  method must exit
p53860
aVSo, a typical  method might look like this:
p53861
aVIt looks like your thread has its own  flag that is performing the same task
p53862
aVThe problem with that is that  doesn't know about it
p53863
aVSo you should get rid of  and instead use the built in mechanism
p53864
aVWhen you call  on the thread it will call
p53865
aVThat sets  to be
p53866
aVThen it waits for the thread method to exit
p53867
aVThat will happen because your thread notices that  is  and quits
p53868
aVAnd then the thread's destructor can continue and finish the job of tidying up the thread
p53869
aVLooking at the code in your answer, it would be better written to make use of the existing  mechanism
p53870
aVNow there's no need for a separate  method
p53871
aVYou can just call  on the thread
p53872
aVThen  is called
p53873
aVAnd then  is called
p53874
aVThen the event is signaled
p53875
aVThen  terminates
p53876
aVAnd then the thread can go away
p53877
aVHaving said that, I'm struggling to think of a scenario where a 5000ms timeout would be the best approach
p53878
aVI don't know why you are doing this, but I'd guess that you are trying to throttle the thread so that it doesn't run hot
p53879
aVYou want to avoid a busy loop
p53880
aVThat's admirable, but using a fixed timeout is not the way to do it
p53881
aVThe way to do it is to wait on a synchronisation event, typically an event
p53882
aVThen when there is more work to be done, the event becomes signaled and your thread wakes up
p53883
as(dp53884
g7
V505088
p53885
stp53886
a((dp53887
g2
(lp53888
VThere is a detailed MS knowledge base article titled Considerations for server-side Automation of Office
p53889
aVSome key excerpts:
p53890
aVUser Identity: Office applications assume a user identity when the applications are run, even when Automation starts the
p53891
aVapplications
p53892
aVThe applications try to initialize toolbars, menus,
p53893
aVoptions, printers, and some add-ins based on settings in the user
p53894
aVregistry hive for the user who launches the application
p53895
aVMany services
p53896
aVrun under accounts that have no user profiles (such as the SYSTEM
p53897
aVaccount or the IWAM_[servername] accounts)
p53898
aVTherefore, Office may not
p53899
aVinitialize correctly on startup
p53900
aVIn this situation, Office returns an
p53901
aVerror on the CreateObject function or the CoCreateInstance function
p53902
aVEven if the Office application can be started, other functions may not
p53903
aVwork correctly if no user profile exists
p53904
aVInteractivity with the desktop: Office applications assume that they are being run under an interactive desktop
p53905
aVIn some
p53906
aVcircumstances, applications may need to be made visible for certain
p53907
aVAutomation functions to work correctly
p53908
aVIf an unexpected error occurs,
p53909
aVor if an unspecified parameter is needed to complete a function,
p53910
aVOffice is designed to prompt the user with a modal dialog box that
p53911
aVasks the user what the user wants to do
p53912
aVA modal dialog box on a
p53913
aVnon-interactive desktop cannot be dismissed
p53914
aVTherefore, that thread
p53915
aVstops responding (hangs) indefinitely
p53916
aVAlthough certain coding
p53917
aVpractices can help reduce the likelihood of this issue, these
p53918
aVpractices cannot prevent the issue entirely
p53919
aVThis fact alone makes
p53920
aVrunning Office Applications from a server-side environment risky and
p53921
aVunsupported
p53922
aVObviously, as has been pointed out in the comments, using the  account is a mistake
p53923
aVYou would need to run the service under an account that has a user profile
p53924
aVBut even when you fix that, the other bullet point will kill you
p53925
aVOffice applications do indeed assume they are running under an interactive desktop
p53926
aVMy advice is to abandon attempting to automate Office from a service
p53927
aVUse a library like Aspose instead
p53928
aVOr run the process on an interactive desktop
p53929
as(dp53930
g7
V505088
p53931
stp53932
a((dp53933
g2
(lp53934
VThe documentation lists  as being the relevant header
p53935
aVWhen we look there at the macro declaration we see:
p53936
aVWhich leaves us with a little work to do
p53937
aVThe lazy way to do this is to write a program to emit the value:
p53938
aVAnd this outputs our desired value:
p53939
aV0x00090064
p53940
as(dp53941
g7
V505088
p53942
stp53943
a((dp53944
g2
(lp53945
VAccording to my web searches, you need to increase the BLOB SIZE parameter in the BDE administrator:
p53946
aVhttp://www
p53947
aVborlandtalk
p53948
aVcom/blobstream-limited-to-32768-bytes-vt34635
p53949
aVhtml
p53950
aVhttp://www
p53951
aVdelphigroups
p53952
aVinfo/2/63/235340
p53953
aVhtml
p53954
aVThe first of these threads suggests an alternative approach of setting RequestLive of the TQuery to be True
p53955
aVThe second thread dates from 1902 which would appear to be a rare sighting in the wild of the Y2K bug
p53956
as(dp53957
g7
V505088
p53958
stp53959
a((dp53960
g2
(lp53961
VThe operating system puts it wherever it can find some free space in the virtual address space
p53962
aVIt is not part of the PE file
p53963
aVThere is a single virtual address space for each process
p53964
aVThe modules are loaded into that address space
p53965
aVThe heap is created in that address space
p53966
aVAnd so is the stack
p53967
aVFor an unmanaged process, the OS reserves the entire stack allocation for a new thread, and  then commits the memory on demand
p53968
aVManaged
p53969
aVnet processes have a different policy
p53970
aVThey commit and reserve the entire stack allocation when each thread is created
p53971
as(dp53972
g7
V505088
p53973
stp53974
a((dp53975
g2
(lp53976
VThis page purports to contain the checksum algorithm: http://automateeverything
p53977
aVtumblr
p53978
aVcom/post/19951549637/google-page-rank-bash-script
p53979
aVThe code there is in C but it's simple enough to port it to Delphi
p53980
aVOr even to just compile it to
p53981
aVobj and link in directly
p53982
aVHere's my quick attempt at a port
p53983
aVPerhaps you'll find it useful
p53984
aVI'd certainly want to do some proper testing of this before using it for real
p53985
as(dp53986
g7
V505088
p53987
stp53988
a((dp53989
g2
(lp53990
VYou are trying to perform integer division
p53991
aVIn Delphi you do that with
p53992
aVThe  operator is for floating point division
p53993
aVLooking at the code, you are trying to reverse this calculation:
p53994
aVYou reverse that like this:
p53995
aVHowever, your algorithm will not work
p53996
aVConsider what happens when you encrypt 64 and 128
p53997
aVYou multiply by 4 to get 256 and 512 respectively
p53998
aVThen add one to get 257 and 513
p53999
aVThen you store back to an 8 bit data type and lose the higher order bytes
p54000
aVAnd so both characters are encoded  to the value 1
p54001
aVI'm assuming that you are using 8 bit text
p54002
aVBut if you are using 16 bit text, your algorithm still fails in an exactly analogous fashion
p54003
aVYour proposed algorithm is not reversible
p54004
aVI urge you to find an off-the-shelf encryption algorithm rather than trying to write your own
p54005
aVEncryption is hard to get right
p54006
as(dp54007
g7
V505088
p54008
stp54009
a((dp54010
g2
(lp54011
VFirst of all you consume :
p54012
aVThen you attempt to read from the file
p54013
aVHowever, the file  is already at its end, and so the first call to  returns
p54014
aVSince there is nothing to read
p54015
aVYou would need to move the file pointer back to the beginning of the file
p54016
aVBut your  based loop will still not do what you want
p54017
aVThat's because you want line oriented input
p54018
aVSo you should use  rather than
p54019
aVJust in the same way that you handled  in a line oriented way, you need to handle your printing to
p54020
aVAnd as Mats points out, you never allocated buf
p54021
aVSo if there had been anything to read, you would be de-referencing an un-initialized pointer
p54022
aVHaving said all of that, it would seem to me to make more sense to run just a single loop
p54023
aVCall  inside the loop that calls
p54024
as(dp54025
g7
V505088
p54026
stp54027
a((dp54028
g2
(lp54029
VIn fact you can use a  loop
p54030
aVThis is syntactic sugar for:
p54031
aVIn terms of readability I would recommend the  loop
p54032
aVIn older Delphi versions that don't support the node iterator you may prefer to do it with a  loop
p54033
aVI expect there are other ways to do it
p54034
aVThese are the only ones that I know
p54035
aVLU RD makes the interesting observation that the documentation states:
p54036
aVAccessing tree view items by index can be time-intensive, particularly when the tree view contains many items
p54037
aVFor optimal performance, try to design your application so that it has as few dependencies on the tree view's item index as possible
p54038
aVThis is quite true
p54039
aVFor random access the code has to walk the tree, starting at the root, until the ith node is located
p54040
aVHowever, there is an optimisation for sequential access
p54041
aVThe Delphi tree view wrapper remembers the index of the last node located by index
p54042
aVThe next time you ask for a node with index no more than one different from the cached node, the required node can be returned quickly
p54043
aVThis is implemented in
p54044
as(dp54045
g7
V505088
p54046
stp54047
a((dp54048
g2
(lp54049
VAssuming you are using WinForms, you should be able to rely on the underlying Win32 mechanism
p54050
aVAnd that is the  message
p54051
aVThe documentation says:
p54052
aVAn application sends the WM_UPDATEUISTATE message to change the UI state for the specified window and all its child windows
p54053
aVSo you can send the message to the handle of the top-level window
p54054
aVYou need to pass  for the low-order word of  and  for the high-order word of
p54055
aVHere is some rather crude sample code
p54056
aVBear in mind that my C# expertise is very limited
p54057
as(dp54058
g7
V505088
p54059
stp54060
a((dp54061
g2
(lp54062
VYou need to override the protected virtual method  in your main form
p54063
aVWhen that fires you know the app is going down
p54064
aVBut the inherited implementation calls  on the MDI children before firing the  event on the main form
p54065
aVHere is the  implementation of :
p54066
aVNotice that the MDI children get their  notifications before that for , i
p54067
ag192
aVthe main form
p54068
aVSo in your main form you need:
p54069
aVand then an implementation that looks like this:
p54070
aVThen the MDI children can check the state of the main form's  property in their  events
p54071
as(dp54072
g7
V505088
p54073
stp54074
a((dp54075
g2
(lp54076
VA Delphi or FreePascal  is a managed type that cannot be used as a JNA type
p54077
aVThe JNA documentation explains that Java  is mapped to a pointer to a null-terminated array of 8 bit characters
p54078
aVIn Delphi terms that is
p54079
aVSo you can change the input parameter in your Pascal code from  to
p54080
aVThe return value is more problematic
p54081
aVYou will need to decide who allocates the memory
p54082
aVAnd whoever allocates it must also free it
p54083
aVIf the native code is responsible for allocating it then you'd need to heap allocate the null-terminated string
p54084
aVAnd return a pointer to it
p54085
aVYou'd also need to export a deallocator so that the Java code can ask the native code to deallocate the heap allocated block of memory
p54086
aVIt is usually more convenient to allocate a buffer in the Java code
p54087
aVThen pass that to the native code and let it fill out the content of the buffer
p54088
aVThis Stack Overflow question illustrates the technique, using the Windows API function  as its example: How can I read the window title with JNI or JNA
p54089
aVAn example of this using Pascal would be like so:
p54090
aVOn the Java side, I guess the code would look like this, bearing in mind that I know absolutely nothing about Java
p54091
as(dp54092
g7
V505088
p54093
stp54094
a((dp54095
g2
(lp54096
VPersonally I think you are over-complicating things
p54097
aVI'd avoid the unsafe code and skip the C++/CLI layer
p54098
aVI'd use a simple p/invoke declared like this:
p54099
aVBecause  and  are blittable types, no copying is necessary
p54100
aVThe marshaller just pins the arrays for the duration of the call
p54101
as(dp54102
g7
V505088
p54103
stp54104
a((dp54105
g2
(lp54106
VYour analysis is correct:
p54107
aVAll integers between -253 and 253 are exactly representable in double precision
p54108
aVThe IEEE754 standard requires calculations to be performed exactly, and then rounded to the nearest representable number
p54109
aVHence a product of two values that equals an integer in that range will therefore be represented exactly
p54110
aVReference:  What every computer scientist should know about floating-point arithmetic
p54111
aVThe key section is the discussion of the IEEE standard as pertaining to operations
p54112
aVThat contains the statement of the second bullet point above
p54113
aVYou already knew the first bullet point and it's the second point that completes the argument
p54114
as(dp54115
g7
V505088
p54116
stp54117
a((dp54118
g2
(lp54119
Vis ambiguous
p54120
aVIt can be either the function, or the value returned after executing the function
p54121
aVIn most contexts, only one of those meanings is valid, and that meaning is chosen
p54122
aVIn your code, either meaning is valid
p54123
aVIn such a scenario the language rules mean that the procedural type interpretation is chosen
p54124
aVTo force function invocation write:
p54125
aVThis is a significant difference from most other languages, e
p54126
ag217
aVC, C++, C#, Java, Python etc
p54127
aVIn those languages you must use parentheses in order to invoke a function
p54128
as(dp54129
g7
V505088
p54130
stp54131
a((dp54132
g2
(lp54133
VAssuming that you are compiling with the Microsoft compiler then you can use RTL functions instead of inline assembly
p54134
aVTo test for particular floating point status flags call
p54135
aVTo clear floating point status flags call
p54136
aVIn order to use  you'll need to translate from the raw 8087 flags, to the abstract flags used by
p54137
aVUpdate
p54138
aVThe code in the question is an implementation of a small part of  which is part of C99
p54139
aVIt's needed for the MS compiler since it only implements C89
p54140
aVIn my view you would be much better off using a real C99 compiler
p54141
aVThat would come with an implementation of
p54142
as(dp54143
g7
V505088
p54144
stp54145
a((dp54146
g2
(lp54147
VIn the code you show, the only thing that we can criticise is your destructor:
p54148
aVAssigning  to  is rather pointless (albeit harmless) since that will happen automatically
p54149
aVBut what is missing here is a call to the inherited destructor
p54150
aVSo, your destructor should look like this:
p54151
aVNow, if you decided to remove the finalization of  then you could simply remove the destructor from your class and rely on that of the base class
p54152
aVHowever, you do appear to be measuring your memory leak with an invalid tool
p54153
aVYou can't measure memory leaks with task manager
p54154
aVUse the FastMM leak detector
p54155
as(dp54156
g7
V505088
p54157
stp54158
a((dp54159
g2
(lp54160
VYour problems all stem from the use of binary floating point, i
p54161
ag192
aVor
p54162
aVMany of the numbers in your question are not exactly representable using binary
p54163
aVExactly representable numbers in binary floating point are of the form k/2^n where k is an integer and n is a non-negative integer
p54164
aVSo, these values are not exactly representable:
p54165
aVand so on
p54166
aVScary isn't it
p54167
aVBecause the numbers you are working with cannot be represented exactly, you are subject to round-off error
p54168
aVAnd that's why your program does not behave the way you desire
p54169
aVThe standard reference on floating point arithmetic is: What Every Computer Scientist Should Know About Floating-Point Arithmetic
p54170
aVThis excellent work covers floating point arithmetic at a fundamental level
p54171
aVIt is not restricted to binary floating point
p54172
aVIt also considers representations using the decimal system
p54173
aVAnd this is the real key to solve your problem
p54174
aVTo make your arithmetic accurate you need to use decimal rather than binary representations
p54175
aVIf you do that then you can represent the currency values exactly
p54176
aVSadly, common C implementations do not come with decimal floating point or fixed point data types
p54177
aVSo you will need to either roll your own, or find a third party library
p54178
aVAs a very simple solution, assuming that you only ever need to represent up to 2 decimal places, you can use a fixed point decimal representation
p54179
aVStore your values in  variables and assume an implicit multiplicative shift of
p54180
as(dp54181
g7
V505088
p54182
stp54183
a((dp54184
g2
(lp54185
VYou should use
p54186
aVThat evaluates to CR+LF on Windows, and LF on Unix systems
p54187
aVThere are no escape sequences for CR or LF characters in VB
p54188
aVAnd that's why  is treated literally
p54189
aVSo,  is your guy
p54190
as(dp54191
g7
V505088
p54192
stp54193
a((dp54194
g2
(lp54195
VIf you compile the Controls unit yourself, with the unsafe typecast warning enabled, then you will see the warning
p54196
aVBut if you link the pre-built
p54197
aVdcu file then you see no warning
p54198
aVThe compiler only emits warnings on units that it compiles
p54199
aVAs a general rule, the RTL and VCL units generate large numbers of hints and warnings
p54200
aVIf ever I have to re-compile them, I always have to switch hints and warnings off on those units
p54201
aVThe modern day documentation for the warning says:
p54202
aVYou have used a data type or operation for which static code analysis cannot prove that it does not overwrite memory
p54203
aVFor example, you might have cased (sic) one record to another or one instance to another
p54204
aVAnd that warning does apply to your code
p54205
aVYour code is unsafe
p54206
aVThe compiler cannot verify that it is correct to overlay two 16 bit integers onto a 32 bit integer
p54207
aVSo the compiler warns you
p54208
aVIt's up to you to decide whether or not the code is correct
p54209
aVNow, it appears that the warning was intended primarily for the
p54210
aVnet compiler
p54211
aVAll the same, it still has meaning for the Win32 compiler
p54212
aVOverlaying one record on another is suspicious behaviour
p54213
as(dp54214
g7
V505088
p54215
stp54216
a((dp54217
g2
(lp54218
VMenu items that have sub-items do indeed fire  events
p54219
aVBut they fire when the sub-menu opens rather than when you click on the parent menu item
p54220
aVI'm pretty sure you don't want to invoke all sub-items when that happens
p54221
aVThe  event for a parent menu fires whenever the sub-menu is opened
p54222
aVEither when you click on the parent menu item, hover over it, or press the right arrow key when the menu item is selected via the keyboard
p54223
aVSo, the  event for a parent menu corresponds to opening the sub-menu
p54224
aVInvoking all the child menu item actions when the sub-menu is opened goes against all standard expected UI behaviour
p54225
aVWhat you should do is add another sub-item that can be used to invoke all actions
p54226
aVDon't go against the platform standard UI unless there are no sane alternatives
p54227
as(dp54228
g7
V505088
p54229
stp54230
a((dp54231
g2
(lp54232
VYour code is technically invalid
p54233
aVIt only runs at all due to an implementation detail that should not be relied upon
p54234
aVLet's take a look at the pertinent section of code:
p54235
aVFirst we make P point to the first character of MyArray[0]
p54236
aVThen we assign to MyArray[0]
p54237
aVAt this point there's no reason for the string buffer that P points at to be kept alive
p54238
aVNo string variable refers to it
p54239
aVIts reference count has gone to zero, and so it should be deallocated
p54240
aVWhich makes the subsequent use of P invalid
p54241
aVIn which case, why does your code run
p54242
aVBecause the strings you use happen to be literals
p54243
aVAnd so they are stored with reference count equal to -1 and bypass the normal heap allocation routines used by strings
p54244
aVBut if you were to use string values that were not literals, then what I describe in the paragraph above would come to pass
p54245
aVAnd I expect that your real code doesn't use literals
p54246
aVSo your actual question is somewhat moot
p54247
aVThe P pointer just points at a block of memory
p54248
aVIt remains pointing at the same block of memory until you modify the pointer
p54249
aVIf you modify the contents of the block of memory, then P will see those modifications if you de-reference it
p54250
aVIt's just a pointer like any other pointer
p54251
aVYou need to take care using a PChar variable
p54252
aVIn your use, it is an unmanaged pointer into a compiler managed object
p54253
aVThat provides lots of scope for errors and you've fallen into the trap
p54254
aVIf you want a copy of a string, take a copy into another string variable
p54255
as(dp54256
g7
V505088
p54257
stp54258
a((dp54259
g2
(lp54260
VThe issue is that the machines where the program fails to run are missing the appropriate C/C++ runtime runtime
p54261
aVYou have two main options
p54262
aVDeploy the appropriate redistributable package for your version of Visual Studio
p54263
aVThis is needed when you link to the runtime dynamically
p54264
aVLink to the runtime statically
p54265
aVThat way the runtime is built into your executable
p54266
as(dp54267
g7
V505088
p54268
stp54269
a((dp54270
g2
(lp54271
VThe main problem is that when passing  you are meant to pass a  variable, but you are passing a pointer to a
p54272
aVThe documentation says:
p54273
aVThe pvParam parameter is a BOOL variable
p54274
aVSet pvParam to TRUE to disable overlapped content, or FALSE to enable overlapped content
p54275
aVWhich means that your code to set the property needs to be like this:
p54276
aVYour  is a disaster
p54277
aVSorry to sound harsh
p54278
aVIt returns  for Windows 8 and later
p54279
aVAnd your code has problems with operator precedence
p54280
aVYou write:
p54281
aVand operator precedence means that is interpreted as
p54282
aVSince  returns a signed value,  evaluates to  irrespective of windows version
p54283
aVThat's because  is always <=
p54284
aVYou want logical negation rather than bitwise negation
p54285
aVSo you should write
p54286
aVor equivalently
p54287
aVIn reality there is a built in function to do this
p54288
aVIt's called
p54289
aVCall it like this:
p54290
aVThe rest of your function is a bit of a mess though
p54291
aVYou pass  by value and then assign to it
p54292
aVPresumably you are intending the caller to receive that value
p54293
aVWhich won't happen unless you passed by
p54294
aVPersonally I'd write your procedure like this:
p54295
aVI think it's better to convert an error in  to an exception since it's an exceptional circumstance
p54296
aVI defy you to actually generate a failure of that call to
p54297
aVIn which case there's no point building an error code returning mechanism for something that simply will not happen
p54298
aVCheck for errors and convert to a runtime exception
p54299
aVThis makes the calling code so much simpler
p54300
aVYour button click handler can be much simpler:
p54301
aVAnd the getter function is also much more complex than necessary
p54302
aVI'd have it like this:
p54303
as(dp54304
g7
V505088
p54305
stp54306
a((dp54307
g2
(lp54308
VOn Linux you can call  which blocks until a signal is received
p54309
aVYou'd therefore need to call  is a loop
p54310
aVThe advantage of this over sleeping is that you process can be terminated by a termination signal
p54311
as(dp54312
g7
V505088
p54313
stp54314
a((dp54315
g2
(lp54316
VThe functionality that you are looking for, assuming your answer is accurate, is most easily implemented using FileTimeToLocalFileTime
p54317
aVOr if you prefer to use SystemTimeToTzSpecificLocalTime then do so like this:
p54318
as(dp54319
g7
V505088
p54320
stp54321
a((dp54322
g2
(lp54323
VThe  just contains the name of the file
p54324
aVThe volume information is described in the  field
p54325
as(dp54326
g7
V505088
p54327
stp54328
a((dp54329
g2
(lp54330
VOverride the  virtual method in your control:
p54331
aVThis makes width be the master dimension
p54332
aVIf you want height to be in charge then you can re-arrange the formula
p54333
aVYou could try to be intelligent in choosing which dimension is the master
p54334
aVYou will also need to add code to your property setter for the  property
p54335
aVBecause a modification of that property will need to provoke a re-sizing of the control
p54336
as(dp54337
g7
V505088
p54338
stp54339
a((dp54340
g2
(lp54341
VMost likely you have updated the
p54342
aVh and
p54343
aVlib file, but are linking to an out of date DLL
p54344
aVMake sure that the DLL that your program links to is the one that matches the
p54345
aVh and
p54346
aVlib file
p54347
aVYou can debug what happens at program load time by running Dependency Walker in profile mode
p54348
aVThat will show the full path to the DLL that is actually loaded and you will then be able to work out what has gone wrong
p54349
as(dp54350
g7
V505088
p54351
stp54352
a((dp54353
g2
(lp54354
VThe only way to be sure is to time the various options on your compiler
p54355
aVThere will be no hard and fast rule that applies to all compilers
p54356
aVIf you are talking about allocating an array of  or , say, then for any decent implementation you should not be able to detect a performance difference
p54357
as(dp54358
g7
V505088
p54359
stp54360
a((dp54361
g2
(lp54362
VThe number  can be represented exactly in binary floating point
p54363
aVBut the number  cannot
p54364
aVSo you are finding the rational value of the nearest representable number to
p54365
aVWhich is most definitely not
p54366
aVIn fact the closest double precision value to  is:
p54367
aVTo make any reasonable headway with this task you will probably need to represent your values with a decimal data type rather than a binary type like
p54368
aVIf the above doesn't make any real sense to you then I suggest you have a good read of: What Every Computer Scientist Should Know About Floating-Point Arithmetic
p54369
as(dp54370
g7
V505088
p54371
stp54372
a((dp54373
g2
(lp54374
VData modules changed with the XE2 release
p54375
aVRemember that XE2 introduced a new component framework, FireMonkey, in addition to the long-standing VCL
p54376
aVA new pseudo-property, named  was added to data modules
p54377
aVThis controls what components can be added to the data module in the IDE designer
p54378
aVThe default  for a data module is
p54379
aVThis specifies that the data module is framework neutral and so accepts neither VCL components nor FMX components
p54380
aVIn your case you probably want to accept VCL components so you need to specify a  of
p54381
aVRead all about  in the documentation
p54382
aVSystem
p54383
aVClasses
p54384
aVTDataModule and its descendant classes, such as
p54385
aVWeb
p54386
aVHTTPApp
p54387
aVTWebModule, have a pseudo-property named ClassGroup that
p54388
aVdoes the following:
p54389
aVDetermines the framework affinity for the data module
p54390
aVThat is, ClassGroup specifies that the data module is either framework-neutral
p54391
aVor is to work with a specific framework (namely, VCL or FMX)
p54392
aVEnables framework-specific nonvisual components in the Tool Palette
p54393
aVYou need to set a framework-specific value for ClassGroup in
p54394
aVthe Object Inspector in order to enable framework-specific nonvisual
p54395
aVcomponents such as the following:
p54396
aVTActionList is VCL-only, and so to enable TActionList in the Tool Palette, you must set ClassGroup to the VCL setting
p54397
aVTTimer exists in both FMX and VCL
p54398
aVTo enable TTimer for the correct framework, you must set ClassGroup to either FMX or VCL, to
p54399
aVmatch the framework of the parent application
p54400
aV(TTimer and TActionList
p54401
aVare further discussed later in this topic
p54402
as(dp54403
g7
V505088
p54404
stp54405
a((dp54406
g2
(lp54407
VYou are passing  to
p54408
aVBut  has not been initialised at that point
p54409
aVI guess you meant to pass
p54410
aVI guess the call to  returns a thread ID of 0 since the window you passed it does not exist
p54411
aVAnd that leads to the failure in
p54412
aVThe other obvious failure vector is that you fail to set  correctly
p54413
aVYou say that you are doing that, but since you didn't show the code, we can only take your word for that
p54414
aVAs an aside, I note that you are not checking for errors in any of your calls to Windows API functions
p54415
aVI count 8 API calls in that code, not one of which has error checking
p54416
aVYou really must get into the habit of checking for errors
p54417
as(dp54418
g7
V505088
p54419
stp54420
a((dp54421
g2
(lp54422
VThat's a linked list
p54423
aVSo one option is to write C++/CLI code to adapt the native linked list to a
p54424
aVnet
p54425
aVGoing down this route will mean that you need to make copies of the list whenever it is modified in the native code and needs to be returned to the managed code
p54426
aVAnd vice versa
p54427
aVIf making copies is not an option then you should wrap the native linked list in a managed class
p54428
aVSo you don't try to convert the struct definition at all
p54429
aVInstead you write a C++/CLI managed class that encapsulates the functionality that you need to expose
p54430
aVI can't say much more than that because you haven't given any information on the operations that you need to perform on this list
p54431
aVNow have you explained what the data flow is
p54432
as(dp54433
g7
V505088
p54434
stp54435
a((dp54436
g2
(lp54437
VThe  in your code will set all the bits to 0 which may or may not be what you want to do
p54438
aVIn particular, it's not guaranteed that a pointer with all zero bits is the null pointer
p54439
aVNor that a floating value with all zero bits is zero
p54440
aVIf you want your code to be completely portable then you should initialise each element
p54441
aVOr you could do the initialization with a C99 compound literal:
p54442
aVIn practise, you'll have to work hard to find a C implementation for which the code above will have a different result from your variant that uses
p54443
as(dp54444
g7
V505088
p54445
stp54446
a((dp54447
g2
(lp54448
VThe first issue I see is that Delphi's binary interface for function return values is different from that used by C# (and indeed every other major Windows compiler)
p54449
aVSo instead of using a function, use an  parameter
p54450
aVThen on the C# you can declare the function like this:
p54451
aVNote that I removed a load of spurious parameters to your  attribute
p54452
aVI guess you were adding them at random
p54453
aVThe other issue is the interface
p54454
aVIt needs to be declared as being a COM interface that supports
p54455
aVLike this:
p54456
aVUpdate 1
p54457
aVThe first problem with the updated question is something I failed to pick up in my original answer
p54458
aVThe way the C# interface is declared means that that the marshaller assumes that the native functions all return  COM error codes
p54459
aVIf the C# method has a return value then it is implicitly converted into an  parameter
p54460
aVThere is a simple way to achieve this in Delphi
p54461
aVYou replace  with  on each method in the interface, and obviously in the implementation of that interface
p54462
aVNote that you should not change the calling convention of the  function
p54463
aVSo your Delphi code should be like this:
p54464
aVAnother problem with the method in updated question is that C# marshals  as a 4 byte value, but Delphi  is just a single byte
p54465
aVThis error is actually benign, but you can fix the problem by making the two sides of the interface match
p54466
aVFor example:
p54467
aVAnd I repeat what I said above
p54468
aVI removed spurious parameters from your  attribute
p54469
aVIn particular don't use  because your code is not setting the Win32 last error
p54470
aVYour  should be exactly as per my answer
p54471
aVDon't confuse things by adding needless extra parameters to the attribute
p54472
aVUpdate 2
p54473
aVYou say in comments that you can't use  on the Delphi side
p54474
aVWhich means that you need to suppress the  signature transformation on the C# side of the interface
p54475
aVThat's done with
p54476
aVYou need to apply it to each method on your C# interface
p54477
aVThis interface matches up with a Delphi interface declared like this:
p54478
as(dp54479
g7
V505088
p54480
stp54481
a((dp54482
g2
(lp54483
VThe handler will run so long as it is bound to the event
p54484
aVYou say that you haven't found the place to bind the events
p54485
aVThat clearly is the problem
p54486
aVIt's still done in the Object Inspector
p54487
aVOpen that up from the View menu, or press F11
p54488
aVClick on the surface of the form
p54489
aVSelect the second page of the Object Inspector, called Events
p54490
aVAnd there you can relate events to handlers just as you are used to in Delphi 7
p54491
aVIf you cannot get the Object Inspector to show form events when the form design surface is selected, then you have a configuration problem with your Delphi installation
p54492
as(dp54493
g7
V505088
p54494
stp54495
a((dp54496
g2
(lp54497
VAll programs can be decompiled to a degree
p54498
aVHowever, the vast bulk of the useful information in your source code is removed during compilation
p54499
aVThe source code that a decompiler produces is a pale imitation of the original
p54500
aVThe variable names, function names, class names etc
p54501
aVwill not be available after decompilation
p54502
aVSo the best that a decompiler can do is to turn your functions that look like this:
p54503
aVinto rather meaningless code like this:
p54504
aVAnd even succeeding in doing that much accurately can be very hard for a decompiler
p54505
as(dp54506
g7
V505088
p54507
stp54508
a((dp54509
g2
(lp54510
VYou can do this with a symbolic link
p54511
aVAt the command line you would do it like this:
p54512
aVC:\u005c>mklink 1
p54513
aVtxt other\u005cA
p54514
aVtxt
p54515
aVsymbolic link created for 1
p54516
aVtxt > other\u005cA
p54517
aVtxt
p54518
aVProgrammatically you use the  function
p54519
aVBut you cannot do that and keep a true file named C:\u005c1
p54520
aVtxt
p54521
aVYou cannot have two distinct objects with the same name
p54522
aVRegarding the Program Files and Program Files (x86) folders, they are just ordinary folders
p54523
aVIt's only convention that says that 64 bit apps go in the former, and 32 bit apps go in the latter
p54524
aVPerhaps you are thinking of the file system redirector which affects the system32 folder
p54525
aVAnyway, that's really outwith the question
p54526
as(dp54527
g7
V505088
p54528
stp54529
a((dp54530
g2
(lp54531
VPass a file object to the  parameter of :
p54532
as(dp54533
g7
V505088
p54534
stp54535
a((dp54536
g2
(lp54537
VYou cannot determine that definitively at runtime
p54538
aVYou cannot take an arbitrary address and determine whether or not a real  lies behind it
p54539
as(dp54540
g7
V505088
p54541
stp54542
a((dp54543
g2
(lp54544
VThat's a function pointer
p54545
aVIt receives a pointer to the struct, and returns a
p54546
aVPresumably, since there is no calling convention specified, the default calling convention of  applies
p54547
aVWith that information, you would translate to Delphi like this:
p54548
aVNote that unlike C, a Delphi procedural type is implicitly a pointer
p54549
as(dp54550
g7
V505088
p54551
stp54552
a((dp54553
g2
(lp54554
VThe best way to invoke the  event handler attached to a control is to call the  method on the control
p54555
aVLike this:
p54556
aVCalling the event handler directly forces you to supply the  parameter
p54557
aVCalling the  method gets the control to do all the work
p54558
aVThe implementation of the windows message handler for a button click calls the  method
p54559
aVBut I second the opinion expressed in whosrdaddy's answer
p54560
aVYou should pull out the logic behind the button into a separate method
p54561
as(dp54562
g7
V505088
p54563
stp54564
a((dp54565
g2
(lp54566
VYou have a circular reference
p54567
aVYour implementation of  holds a reference to
p54568
aVAnd your implementation of  holds a reference to
p54569
aVAnd this circular reference means that the interface reference count can never go to zero
p54570
aVThe normal solution to this issue to to use a weak reference
p54571
aVSome useful links:
p54572
aVWeak reference": down to earth explanation needed
p54573
aVhttp://www
p54574
aVfinalbuilder
p54575
aVcom/Resources/Blogs/PostId/410/WeakRefence-in-Delphi-solving-circular-interfac
p54576
aVaspx
p54577
aVhttp://delphisorcery
p54578
aVblogspot
p54579
aVco
p54580
aVuk/2012/06/weak-interface-references
p54581
aVhtml
p54582
as(dp54583
g7
V505088
p54584
stp54585
a((dp54586
g2
(lp54587
VHere's a fun example with a  implementation on a generic container:
p54588
aVBecause we cannot come up with a generic equivalent to  I raise an exception when the method is called on an empty list
p54589
aVThe output is:
p54590
aV12
p54591
ag5537
aV20000000000000E+0001
p54592
aVWarren P
p54593
as(dp54594
g7
V505088
p54595
stp54596
a((dp54597
g2
(lp54598
VThis behaviour is as designed
p54599
aVThe control is a wrapper around the Win32 control
p54600
aVTake a look at the documentation for
p54601
aVIn the remarks you find this statement
p54602
aVIf visual styles are active, this message has no effect except when wParam is MCSC_BACKGROUND
p54603
aVI think that in Vista and later, even attempts to set , which corresponds to , have no effect
p54604
aVIf you disable visual styles in your application you can indeed see that the settings specified in  are applied
p54605
as(dp54606
g7
V505088
p54607
stp54608
a((dp54609
g2
(lp54610
VI also agree that using the critical section API from
p54611
aVnet seems like a bad design choice
p54612
aVIf you must then I'd contemplate writing a C++/CLI mixed-mode wrapper
p54613
aVThat way you can include the windows header files directly
p54614
aVHowever, there is a rather obvious flaw in your p/invoke code
p54615
aVThat's the declaration of the  struct
p54616
aVYou've declared it as holding a single integer value
p54617
aVBut the native  is bigger than that
p54618
aVOn x86 it is 24 bytes long, and on x64 it is 40 bytes long
p54619
aVYou don't need to declare any of the fields since from your perspective it's just an opaque block of memory
p54620
aVIf I were you I would get rid of
p54621
aVI would change all the  parameters to
p54622
aVAnd I would use  to create a large enough block of memory to hold the critical section data
p54623
aVFor example:
p54624
aVand so on
p54625
as(dp54626
g7
V505088
p54627
stp54628
a((dp54629
g2
(lp54630
VThat code compiles on my Delphi 2010, once the error in the declaration of  is fixed
p54631
aVThere's probably something else in the real code that leads to the internal error
p54632
aVIn any case it makes more sense to use a  loop here:
p54633
aVAnd perhaps if you did that you'd escape the internal error
p54634
aVIf switching to  doesn't sidestep the internal error then you need to supply a complete program that exhibits the fault
p54635
aVTry and cut it down to the smallest size possible
p54636
aVThis is always good practice when asking question, submitting bug reports etc
p54637
aVIn my experience, if you want to do any serious generics programming, without drowning in a flood of internal errors, you need to move beyond Delphi 2010
p54638
as(dp54639
g7
V505088
p54640
stp54641
a((dp54642
g2
(lp54643
VYour function is declared like this
p54644
aVand is designed to return a non-const pointer into the middle of the const  string
p54645
aVYou must not cast const data to non-const
p54646
aVSo you should declare your function like this:
p54647
aVAt which point you can remove the cast in your  statement
p54648
aVThe function would arguably be simpler if it used pointers to iterate:
p54649
aVThe other problem is that the literal  is a null-terminated C string literal rather than
p54650
aVYou need to use  to specify a  literal
p54651
as(dp54652
g7
V505088
p54653
stp54654
a((dp54655
g2
(lp54656
VThat error is
p54657
aVThe application has failed to start because its side-by-side configuration is incorrect
p54658
aVPlease see the application event log or use the command-line sxstrace
p54659
aVexe tool for more detail
p54660
aVUsing sxstrace
p54661
aVexe might be a little tricky in your scenario
p54662
aVIt's certainly worth checking the event logs to see if they contain clues
p54663
aVMy guess would be that the problem box is missing the appropriate MSVC runtime
p54664
aVMake sure that you deploy the MSVC runtime that is used by the DLL you are trying to load
p54665
aVThat's the obvious first thing to try before attempting to debug the problem
p54666
as(dp54667
g7
V505088
p54668
stp54669
a((dp54670
g2
(lp54671
VThe  function is defined like this:
p54672
aVNote that it receives two pointers of type
p54673
aVYou then call it like this:
p54674
aVBut  and  are of type
p54675
aVSo the actual parameters passed are not compatible, just as the compiler says
p54676
aVYou need to pass pointers to these records instead:
p54677
aVIn the longer term you are going to need to be careful about the lifetime of these records
p54678
aVYou'll need to allocate on the heap and without garbage collection I suspect that you'll enter a world of pain trying to keep track of who owns the records
p54679
aVPerhaps you could consider using interface reference counting to manage lifetime
p54680
as(dp54681
g7
V505088
p54682
stp54683
a((dp54684
g2
(lp54685
VYou should add a property to the form that returns the desired value:
p54686
aVAnd implement it like this:
p54687
aVThis will always return the current state which I believe is what you want
p54688
as(dp54689
g7
V505088
p54690
stp54691
a((dp54692
g2
(lp54693
VOverloaded methods can be very effective
p54694
aVHowever, as soon as there is a hint of ambiguity they become a liability
p54695
aVA good example of this are the new TStream overloads introduced in XE3
p54696
aVIt's not hard to fall into a trap where the compiler chooses an overload that you weren't expecting
p54697
aVAt least in your code the compiler stopped
p54698
aVIn that sense you were lucky
p54699
aVSo my advice, in your situation, is to abandon overloads
p54700
aVExpress the different input types in the method name
p54701
aVYes it's a little more verbose, but you won't make any mistakes, and you code will compile
p54702
as(dp54703
g7
V505088
p54704
stp54705
a((dp54706
g2
(lp54707
VIndeed each of your calls to GetMem must be matched with a call to FreeMem
p54708
aVI'm not sure why you have this array
p54709
aVIt's not a type that I'd expect to see in pure Pascal code
p54710
aVSo my guess is that you are passing the PChar array to some external library
p54711
aVIn which case I'd declare an array of string as well as the array of PChar
p54712
aVAnd then make each PChar element by using PChar(
p54713
aVon the corresponding element of the string array
p54714
aVThen you can avoid the StrCopy, GetMem and FreeMem
p54715
as(dp54716
g7
V505088
p54717
stp54718
a((dp54719
g2
(lp54720
VYou need to set all the appropriate environment variables in your build environment
p54721
aVThe way to do this is to execute the rsvars
p54722
aVbat script in the Delphi bin directory
p54723
aVMy other tip is to remove all Delphi entries from your system path
p54724
aVThis forces you to be explicit about setting the appropriate environment variables for the correct version
p54725
as(dp54726
g7
V505088
p54727
stp54728
a((dp54729
g2
(lp54730
VAs has been noted, command
p54731
aVcom is the DOS/Windows 9x command interpretor
p54732
aVBut I see no reason to invoke a command interpretor at all
p54733
aVI'd do it like this:
p54734
aVThere's no need to specify a verb here either
p54735
as(dp54736
g7
V505088
p54737
stp54738
a((dp54739
g2
(lp54740
VSince your threads are all modifying the same bitmap, you need to serialize all access to that bitmap
p54741
aVThat means reading its contents as well as writing to it
p54742
aVOf course, this assumes that multiple threads drawing to a shared bitmap is the right solution to your problem
p54743
aVWithout knowing what your actual problem is, I could not comment on that
p54744
as(dp54745
g7
V505088
p54746
stp54747
a((dp54748
g2
(lp54749
VNever use  for local variables
p54750
aVInitialize should be used only in Delphi code where a variable is dynamically allocated by other means than the New standard procedure
p54751
aVWhat's more it would be optimized to a nop with your record since it doesn't contain any managed types
p54752
aVSo, we can throw this option away and reduce the field to three contenders
p54753
aVThe remaining three contenders all have the same effect for an uninitialized local variable
p54754
aVHowever, it's risky to  use  on a local variable with managed members, e
p54755
ag217
aVstrings, interface references, variants etc
p54756
aVIf the managed members have been initialized then you will break the reference counting mechanism
p54757
aVHowever, if you are sure that the record has not been initialized, then  is safe and efficient, albeit rather ugly looking in my view
p54758
aVPersonally, I would reject  for this role
p54759
aVThat leaves  and the constant assignment
p54760
aVIn older versions of Delphi you can only use the constant assignment
p54761
aVIt's fair to say that the constant assignment is as ugly as , by the time you've declared the constant
p54762
aVSo, in modern Delphi versions I would opt for  since it is more concise and reads better, in my view
p54763
aVAs was discussed in a question covering similar ground, the compiler produces very efficient code when you assign  to a variable
p54764
as(dp54765
g7
V505088
p54766
stp54767
a((dp54768
g2
(lp54769
VYour file is UTF-16 encoded because you are using the Unicode version of the Win32 API
p54770
aVYour text editor is interpreting the file as being 8 bit encoded
p54771
aVSo you simply need to get your text editor to interpret the file as UTF-16
p54772
aVProbably the easiest way to do that is to put the UTF-16LE BOM at the beginning of the file
p54773
aVAs an aside I would advise you to stop coding to support MBCS character sets, stop using  and so on
p54774
aVJust write your program assuming that you will be targeting the Unicode version of the Win32 API
p54775
aVIt will make your code much easier to read if you write  rather than  and so on
p54776
aVOf course, if you need to support Windows 9x then forget I said this and carry on writing code that will compile in both MBCS and Unicode modes
p54777
as(dp54778
g7
V505088
p54779
stp54780
a((dp54781
g2
(lp54782
VOne scenario that requires the use of the VirtualAllocEx is when you need to allocate memory in the address space of a different process
p54783
aVI cannot imagine any other use case for VirtualAllocEx or VirtualAlloc in a managed app
p54784
as(dp54785
g7
V505088
p54786
stp54787
a((dp54788
g2
(lp54789
VNo it is not safe
p54790
aVYour code is liable to lead to the window handle being created with affinity to the wrong thread
p54791
aVDon't use the GUI to store your applications state
p54792
aVUse the GUI to show a view onto that state
p54793
aVOnce you separate the state from the view you are home and dry
p54794
aVYour worker threads can use the underlying state state without touching GUI
p54795
as(dp54796
g7
V505088
p54797
stp54798
a((dp54799
g2
(lp54800
VI'm sure you've read the documentation for the short-circuiting operators, and for the element-wise operators
p54801
aVOne important difference is that element-wise operators can operate on arrays whereas the short-circuiting operators apply only to scalar logical operands
p54802
aVBut probably the key difference is the issue of short-circuiting
p54803
aVFor the short-circuiting operators, the expression is evaluated from left to right and as soon as the final result can be determined for sure, then remaining terms are not evaluated
p54804
aVFor example, consider
p54805
aVIf  evaluates to , then we know that  evaluates to  irrespective of what  evaluates to
p54806
aVSo there is no need to evaluate
p54807
aVNow consider this expression:
p54808
aVwhere we imagine that  takes a long time to evaluate
p54809
aVIf we can perform some other, cheap, test that allows us to skip the call to , then we can avoid calling ExpensiveFunctionCall
p54810
aVSo, suppose that  evaluates to
p54811
aVIn that case, because we have used short-circuiting operators,  will not be called
p54812
aVIn contrast, if we used the element-wise operator and wrote the function like this:
p54813
aVthen the call to  would never be skipped
p54814
aVIn fact the MATLAB documentation, which I do hope you have read, includes an excellent example that illustrates the point very well:
p54815
aVIn this case we cannot perform  if  is zero
p54816
aVHence the test for
p54817
aVThe use of the short-circuiting operator means that we avoid calculating  when  is zero and so avoid the run-time error that would arise
p54818
aVClearly the element-wise logical operator would not be able to avoid the run-time error
p54819
aVFor a longer discussion of short-circuit evaluation, refer to the Wikipedia article on the subject
p54820
as(dp54821
g7
V505088
p54822
stp54823
a((dp54824
g2
(lp54825
VI really wanted to know why it doesn't do the matching as expected
p54826
aVProcessing of  escape sequences in the  text is performed in
p54827
aVIf you take a look at the code you will find that there are no sequences that yield the carriage return and line feed characters
p54828
aVIn fact  is all about back references
p54829
aVThe processing of the matching phase of the regex is performed by the PCRE code
p54830
aVHowever, the replacement phase is pure Pascal code
p54831
aVAnd it's easy enough to inspect the code to see what it does
p54832
aVAnd it doesn't do what you think and expect it to do
p54833
aVThe conclusion is that you cannot specify the characters you want using escape sequences
p54834
aVI think you will need to devise your own rules for escaping non-printable characters and apply those rules in an  event handler
p54835
as(dp54836
g7
V505088
p54837
stp54838
a((dp54839
g2
(lp54840
VThe name of the unit in XE3 is
p54841
aVThe  class is defined in that unit
p54842
aVThere is no  unit in XE3
p54843
aVSimply remove all references to that unit
p54844
aVI guess at some point the unit was renamed
p54845
aVProbably when it was taken on by Embarcadero and incorporated into Delphi
p54846
aVIf I go do a download of the GIFImage stuff from Finn's site here http://www
p54847
aVtolderlund
p54848
aVeu/delphi/, and then put the GIFImage
p54849
aVpas file in my project, the situation resolves itself
p54850
aVDon't do this
p54851
aVDelete those files
p54852
aVIf you go down that route you will have two versions of the same GIF code
p54853
as(dp54854
g7
V505088
p54855
stp54856
a((dp54857
g2
(lp54858
VThe single quote marks denote a  literal
p54859
aVUsually that means a single character
p54860
aVMulti-character literals are permitted, but the standard says that their meaning is implementation defined
p54861
aVIt would seem that your implementation regards  as being invalid due to having too many characters
p54862
aVIn any case, I'm fairly sure you were not intending to write a multi-character literal
p54863
aVLooking at the snippet of code I think you mean to read the input into a string and use  to test for equality with the string
p54864
as(dp54865
g7
V505088
p54866
stp54867
a((dp54868
g2
(lp54869
VThe x64 exception model is table based, in contrast to the stack based x86 model
p54870
aVWhich means that exception stacks do not exist
p54871
aVIn any case, I've never seen a stalk walk routine that attempts to include exception and finally blocks
p54872
aVThis one is no different
p54873
aVIt walks the function call stack
p54874
aVThe exception flow within a single function is controlled by the scope tables
p54875
aVIn your function, if your code raised an exception at the point at which is calls , then multiple scope table entries match the exception location
p54876
aVThe exception is handled by the innermost matching scope
p54877
aVThe distance between the scope's begin and end addresses can be used to infer which scope is the innermost
p54878
aVIf that innermost scope does not handle the exception, or re-raises it, then the next most innermost scope is asked to handle it
p54879
aVAnd so on until all the matching scopes for the function are exhausted
p54880
as(dp54881
g7
V505088
p54882
stp54883
a((dp54884
g2
(lp54885
VYour C++ functions use the  calling convention, but the default calling convention for  is
p54886
aVThis calling convention mismatch is the most common cause of the stack imbalanced MDA error
p54887
aVYou fix the problem by making the calling conventions match
p54888
aVThe easiest way to do that is to change the C# code to specify  like this:
p54889
as(dp54890
g7
V505088
p54891
stp54892
a((dp54893
g2
(lp54894
VC99 is the first version of the standard that allows local variables to be declared after the first non-declaring statement of a block
p54895
aVSo if you pass  to gcc, it will accept your code
p54896
aVObviously, later versions of the standard also allow locals to be declared after non-declaring statements
p54897
as(dp54898
g7
V505088
p54899
stp54900
a((dp54901
g2
(lp54902
VThe error message indicates that your package is trying to register a component that is already registered, namely
p54903
aVIt's not obvious from the details that you have provided why this would happen
p54904
aVOne possible reason would be if you included the TNT components in your package instead of referencing that in your package's requires clause
p54905
aVAnother possible reason would be if your  function attempted to register
p54906
aVThis could happen if your actual declaration of  was like so:
p54907
as(dp54908
g7
V505088
p54909
stp54910
a((dp54911
g2
(lp54912
VThere is no problem with your C# union
p54913
aVHowever,  is wrong
p54914
aVIt's  in the C code and  in the C# code
p54915
aVYou need to declare it as  in the C# code
p54916
aVFor what it's worth, you are safe to omit  since that is the default for a struct
p54917
as(dp54918
g7
V505088
p54919
stp54920
a((dp54921
g2
(lp54922
VThe  and  characters are not allowed to be used in a Windows file name
p54923
aVAnd so that file cannot be opened under Win32
p54924
aVThe naming conventions documentation lists the following reserved characters:
p54925
aV< (less than)
p54926
aV> (greater than)
p54927
aV: (colon)
p54928
aV(double quote)
p54929
aV/ (forward slash)
p54930
aV\u005c (backslash)
p54931
aV| (vertical bar or pipe)
p54932
aV(question mark)
p54933
aV* (asterisk)
p54934
aVWindows differs significantly in this area from *nix systems
p54935
aVOn *nix there are typically no such OS enforced limitations on the characters that can be used in a file
p54936
aVAs a friend of mine once discovered when he tried to delete a file named  and suffered the most unfortunate consequences
p54937
aVNow, it is conceivable that these limitations do not apply when using the native API
p54938
aVYou could try and open the file with
p54939
aVThat may just work
p54940
as(dp54941
g7
V505088
p54942
stp54943
a((dp54944
g2
(lp54945
VNothing has changed in this area, at least for desktop apps, since Vista
p54946
aVIn other words, you are already 5 years out-of-date
p54947
aV;-)
p54948
aVThe guidelines that were introduced for Vista remain valid
p54949
aVFor application icons the guidelines say:
p54950
aVApplication icons and Control Panel items: The full set includes 16x16, 32x32, 48x48, and 256x256 (code scales between 32 and 256)
p54951
aVThe 256px icon should be a compressed PNG icon
p54952
aVThe Delphi 4 resource compiler does not support such icons
p54953
aVYou can use, for example, the MS resource compiler,
p54954
as(dp54955
g7
V505088
p54956
stp54957
a((dp54958
g2
(lp54959
VIf you really want to replicate the  functionality in Delphi I suggest you look at the  function in the Grids unit in the VCL
p54960
aVThis is a procedure declared in the implementation section of the unit, so you'd have to copy the VCL source to make use of it
p54961
as(dp54962
g7
V505088
p54963
stp54964
a((dp54965
g2
(lp54966
VIf you want to make your GUI program appear responsive, you must service the message queue in a timely fashion
p54967
aVThere is no alternative
p54968
aVWhen it comes to running database queries, the way to do that without freezing your UI, is to move the query to a different thread
p54969
as(dp54970
g7
V505088
p54971
stp54972
a((dp54973
g2
(lp54974
VYour code displays the value of
p54975
aVThat's the number of nodes that are direct children of
p54976
aVRemember that  is just a single node
p54977
aVYou probably meant to use
p54978
aVAnd you then display
p54979
aVThese are the captions of the direct children of
p54980
aVIf you want to iterate through all selected nodes then you can do it like this:
p54981
aVI recommend reading the online help when you are faced with situations like this
p54982
aVParticularly for Delphi 7 the documentation is very clear
p54983
aVFor  the documentation states:
p54984
aVSpecifies the selected node in the tree view
p54985
aVproperty Selected: TTreeNode;
p54986
aVDescription
p54987
aVRead Selected to access the selected node of the tree view
p54988
aVIf there
p54989
aVis no selected node, the value of Selected is nil
p54990
aVIf the MultiSelect property is True and the MultiSelectStyle property
p54991
aVincludes msControlSelect, then Selected returns the last node clicked
p54992
aVon, even if that click deselected the node
p54993
aVFor a current selection
p54994
aVstatus when MultiSelect is True, refer to the Selections property
p54995
aVAnd then when you follow on to the documentation for  it says:
p54996
aVIndicates the number of direct descendants of a tree node
p54997
aVproperty Count: Integer;
p54998
aVDescription
p54999
aVUse Count to determine how many child nodes belong to a tree node
p55000
aVCount includes only immediate children, and not their descendants
p55001
aVCount can be useful when iterating through the children of a tree
p55002
aVnode
p55003
aVIn other words, the documentation tells you just the same as I have told you
p55004
as(dp55005
g7
V505088
p55006
stp55007
a((dp55008
g2
(lp55009
VThere's no such function
p55010
aVYou'll need to keep track of previous hits in a list, say, and do the back tracking using that list
p55011
as(dp55012
g7
V505088
p55013
stp55014
a((dp55015
g2
(lp55016
VYou don't get to choose whether or not your notification icon is hidden
p55017
aVThat's up to the user
p55018
aVThis is by design
p55019
aVOn the other hand MS do get to force some of their notification icons to be visible initially
p55020
aVRaymond Chen discusses this here: There is no interface for preventing your notification icon from being hidden
p55021
aVFirst of all, I'd like to congratulate you on writing the most awesome program in the history of the universe
p55022
aVUnfortunately, Windows 7 was not prepared for your awesomeness, because there is no way to prevent your notification icon from being hidden
p55023
aVThat's because if there were, then every other program (the ones that aren't as awesome as you) would use it, thereby causing your awesome icon to be lost among all the non-awesome ones
p55024
as(dp55025
g7
V505088
p55026
stp55027
a((dp55028
g2
(lp55029
VIn your code you try to modify the text attributes in this code:
p55030
aVWhen this code executes, ActiveControl will be cmbFont
p55031
aVNow look at CurrText
p55032
aVSo, the first if block will not be entered
p55033
aVIn fact your function appears not to assign anything to Result in this case
p55034
aVYou must always assign to Result
p55035
aVThe compiler will tell you this when you enable warnings and hints
p55036
aVInstead of using ActiveControl you should specify the rich edit instance directly
p55037
aVI don't know how your form is arranged, but you'll need to use some other means to work out which rich edit control the change is to be applied to
p55038
aVPerhaps based on the active page of the page control
p55039
as(dp55040
g7
V505088
p55041
stp55042
a((dp55043
g2
(lp55044
VCode in one process cannot be executed in another process
p55045
aVYou need some form of inter-process communication, or remote procedure call
p55046
as(dp55047
g7
V505088
p55048
stp55049
a((dp55050
g2
(lp55051
VIf you can use a local variable, do so
p55052
aVThat's a rule with practically no exceptions
p55053
aVThis results in the cleanest and most efficient code
p55054
aVIf you need to allocate on the heap, use dynamic arrays, GetMem or New
p55055
aVUse New when allocating a record
p55056
aVExamples of being unable to use the stack include structures whose size are not known at compile time, or very large structures
p55057
aVBut for records, which are the primary use case for New, these concerns seldom apply
p55058
aVSo, if you are faced with a choice of stack vs heap for a record, invariably the stack is the correct choice
p55059
as(dp55060
g7
V505088
p55061
stp55062
a((dp55063
g2
(lp55064
VThere's no magic trick to finding these casts beyond the sort of text search that you are using
p55065
aVIt would be really nice if the compiler warned of such a cast
p55066
aVI find it very disappointing that it doesn't
p55067
aVWhen you do find such a problem, don't change to
p55068
aVChange the pointers to be typed pointers, and use pointer arithmetic
p55069
aVThen your code will be safe forever
p55070
aVThere are still some situations where you need to cast to integers
p55071
aVFor example when passing addresses to
p55072
aVBut cast these to either  or  as appropriate
p55073
aVYour idea of forcing runtime errors is sound and, thankfully for you, not original
p55074
aVYou should use the full version of FastMM and define
p55075
aVThis forces the calls that FastMM makes to  to pass the  flag
p55076
aVThis will flush out most of your erroneous casts as runtime pointer truncation errors
p55077
aVHowever, that will only force top down allocation for memory allocated by your memory manager
p55078
aVOther modules in your process will use the default policy of bottom up
p55079
aVYou can set a machine wide setting to change that default policy
p55080
aVSet  to  with value  and reboot
p55081
aVNote that this might cause your machine to have stability problems
p55082
aVMany applications cannot cope with this
p55083
aVIn particular there are very few anti-virus products that can cope with this setting
p55084
aVMSE is the one that I found works with machine wide top down allocation
p55085
aVWhat's more the 64 bit debugger does not run under top down allocation
p55086
aVSo you have to do this kind of testing without the debugger
p55087
aVMy QC report is still open and this problem has not been addressed, even in XE3
p55088
as(dp55089
g7
V505088
p55090
stp55091
a((dp55092
g2
(lp55093
VYou can use AutoHotKey for this purpose
p55094
as(dp55095
g7
V505088
p55096
stp55097
a((dp55098
g2
(lp55099
VThis code is wrong:
p55100
aVWhen you write  you are doing nothing \u2013 that is a no-op
p55101
aVYou meant to write:
p55102
aVAnd that's why  is  in  which explains the access violation
p55103
aVDon't be helpless when you face a runtime error
p55104
aVRun the code under the debugger and let the debugger tell you which variable is not initialised
p55105
as(dp55106
g7
V505088
p55107
stp55108
a((dp55109
g2
(lp55110
VI downloaded the latest code from the SVN repo: https://tporpheus
p55111
aVsvn
p55112
aVsourceforge
p55113
aVnet/svnroot/tporpheus/trunk
p55114
aVI then built all projects in the package group
p55115
aVThe output
p55116
aVbpl files landed here:
p55117
aVWhere the files will land on your machine depends on your IDE settings
p55118
aVThe setting that counts is the Package output directory found under Tools | Options | Environment Options | Delphi Options | Library
p55119
aVThe default value is  which, at least on my machine, expands to the directories shown above
p55120
as(dp55121
g7
V505088
p55122
stp55123
a((dp55124
g2
(lp55125
VMost likely you are running your application elevated
p55126
aVProbably because you are running Delphi elevated
p55127
aVIn Vista and later, low privilege processes cannot send messages to higher privilege processes
p55128
aVThis MSDN blog explains more
p55129
aVIf you are running your Delphi IDE elevated, I urge you to stop doing so
p55130
aVThere's very seldom a need to do so for standard desktop application development
p55131
aVAs Remy points out, your  is incorrect
p55132
aVYou are destroying the window handle before calling
p55133
aVSimply reverse the order
p55134
aVPersonally I'd use  in both  and
p55135
aVThe  property creates the window handle if it is not assigned and so masks such errors
p55136
as(dp55137
g7
V505088
p55138
stp55139
a((dp55140
g2
(lp55141
VIn this situation, the pinvoke marshaller allocates the string return value with the shared COM allocator
p55142
aVSo your native code should call  on the pointer that the native DLL returns
p55143
aVAnd so you may need to take a copy of the contents before you free the memory
p55144
aVAs an aside, there's no need to decorate the parameters with  since that just re-states the default
p55145
aVYour code would be easier to read with that removed
p55146
as(dp55147
g7
V505088
p55148
stp55149
a((dp55150
g2
(lp55151
VLegacy Pascal I/O uses  to convert floating point values to text
p55152
aVAnd  hard codes a decimal separator of
p55153
aVI suggest you use a more modern form of I/O
p55154
aVFor example the  class which uses  to convert floating point to text
p55155
as(dp55156
g7
V505088
p55157
stp55158
a((dp55159
g2
(lp55160
VIf you want to set state and position in a single call, there is the  API
p55161
aVFirst of all you would call  to fill out a  struct with the current values
p55162
aVThen you would modify the  and  members
p55163
aVAnd then you would fire the modified struct back at
p55164
as(dp55165
g7
V505088
p55166
stp55167
a((dp55168
g2
(lp55169
VAccording to the comments to the question you want to run a standard desktop app, built with WinForms, not a service, that starts before the user has logged on
p55170
aVThis is not possible
p55171
aVWhat you need is a service
p55172
as(dp55173
g7
V505088
p55174
stp55175
a((dp55176
g2
(lp55177
VSince you are compiling with GCC then you can include  which declares these functions:
p55178
aVYou don't need to, and should not, re-implement this functionality
p55179
as(dp55180
g7
V505088
p55181
stp55182
a((dp55183
g2
(lp55184
VAs well as all the mis-declarations of variables, leading to the un-intended use of variants, I can see a couple more problems:
p55185
aVYou use  in a number of the API calls
p55186
aVBut in VBA  is a signed 16 bit type
p55187
aVAll the uses of  in your  statements should instead be , a signed 32 bit integer
p55188
aVYou are drawing to the screen DC
p55189
aVYou aren't supposed to do this
p55190
aVIt will have un-predicatable results
p55191
aVThe screen is owned by the system and you should not draw on that DC
p55192
aVYou'll need to find another way to do whatever it is you are trying to do
p55193
as(dp55194
g7
V505088
p55195
stp55196
a((dp55197
g2
(lp55198
VThis is my hypothesis
p55199
aVOn the machine on which the code compiles, the non-ASCII characters in the code are all valid ANSI characters for that machine's locale
p55200
aVBut the other machine uses a different locale under which some of those characters are not included in the >= 128 portion of the codepage
p55201
aVAnd hence those characters are promoted to  and so of course are not compatible with
p55202
as(dp55203
g7
V505088
p55204
stp55205
a((dp55206
g2
(lp55207
VIt's very common to want to find the closest parent of a specific class
p55208
aVSo, it pays dividends to make a function to do just that
p55209
aVOnce you have this in place you can use it to solve your current problem
p55210
aVHaving separated the concerns like this you can make use of  in other settings
p55211
as(dp55212
g7
V505088
p55213
stp55214
a((dp55215
g2
(lp55216
VI'm going to consider the case where you have two lists
p55217
aVI'll leave it up to you to generalise the ideas to handle more than two lists
p55218
aVThe key understanding is best gained using the most simple case where there are two lists
p55219
aVI would solve the problem like this:
p55220
aVGenerating a permutation of the integers 0, 1,
p55221
aVN-1
p55222
aVUse the Fisher\u2013Yates shuffle to achieve this
p55223
aVUsing that permutation to shuffle both lists
p55224
aVThe key is to use the same permutation to shuffle both lists
p55225
aVAnd then you can apply to your situation like this:
p55226
aVThis is an exceedingly general solution that can be extended to more than two lists, and can be applied to other data types
p55227
aVIf you want a very short and simple dedicated routine then you can do it like this:
p55228
aVI'm struggling to think of a good name for this procedure
p55229
aVCan anyone help me out by offering something better
p55230
as(dp55231
g7
V505088
p55232
stp55233
a((dp55234
g2
(lp55235
VWriting a GUI in VBScript is not really viable
p55236
aVNo doubt it's possible, but there aren't any toolkits that make it easy
p55237
aVIt's not what VBScript was designed for
p55238
aVThere are a number of options that occur to me:
p55239
aVWrite your GUI in another language, whatever you fancy
p55240
aVThen send commands to your VBscript code as command line arguments
p55241
aVThat's the easiest option for you
p55242
aVAll you need to do is write the GUI, and replace your hard-coded values in the VBscript code with some code that pulls values off the command line
p55243
aVDo the COM automation of Xshell in a different language that supports COM automation
p55244
aVThe majority of languages do
p55245
aVAnd write the GUI there too
p55246
aVFor example, Python would be my choice
p55247
aVSwitch wholesale to a different language for both GUI and your ssh code
p55248
aVAgain many languages exist with good modules for ssh
p55249
as(dp55250
g7
V505088
p55251
stp55252
a((dp55253
g2
(lp55254
VYou are looking for  and , or their unsigned friends  and
p55255
aVInclude either  or
p55256
as(dp55257
g7
V505088
p55258
stp55259
a((dp55260
g2
(lp55261
VThe error message states:
p55262
aVHost 'My-PC' is not allowed to connect to this MySQL server
p55263
aVAnd this would indicate that the SQL server is blocking your client based on its host name, 'My-PC'
p55264
aVSo, you need to configure your MySQL server to allow connections from that host
p55265
as(dp55266
g7
V505088
p55267
stp55268
a((dp55269
g2
(lp55270
Vvcl150
p55271
aVbpl is the VCL runtime package for Delphi XE
p55272
aVYou should contact whoever supplied the application and ask for the necessary packages
p55273
as(dp55274
g7
V505088
p55275
stp55276
a((dp55277
g2
(lp55278
VCreate a record containing the information to be returned from the login form:
p55279
aVThen return such a record from the  method of the login class:
p55280
aVIf the login is successful, then the implementation of the  method needs to fill out these details
p55281
aVThen pass the information to the main form
p55282
aVYou cannot do that in the call to
p55283
aVSo instead you'd need a different method on  that can be called after the main form has been created
p55284
aVAnd that method would receive the  record returned from the successful login
p55285
aVSo to  you would add a public method named , say
p55286
aVThen your
p55287
aVdpr file would look like this:
p55288
as(dp55289
g7
V505088
p55290
stp55291
a((dp55292
g2
(lp55293
VThe only way that  could return an  is either:
p55294
aVYour program uses a declaration of  other than the version declared in
p55295
aVYour program failed to include  and so does not declare  at all
p55296
aVIn which case parameters and return values default to
p55297
aVWhich is of course an error because the actual implementation of  does not match and so the value returned is nonsense
p55298
as(dp55299
g7
V505088
p55300
stp55301
a((dp55302
g2
(lp55303
VSeeing a question mark for any non-ASCII character is the hallmark of an attempt to convert from Unicode to ANSI
p55304
aVThe problem is in this function:
p55305
aVThis converts from Unicode to ANSI in the calls to
p55306
aVYou simply need to remove that part of the code
p55307
aVYou'll need to modify this record
p55308
aVso that  is an array of
p55309
aVAnd then adapt  accordingly
p55310
aVI've not studied it in detail, but I expect you need something like this:
p55311
aVI've not run this code so you may need to work on it further
p55312
aVHowever, it's obvious that the problem is down to the conversion to ANSI
p55313
aVI've now run this code and it works well
p55314
as(dp55315
g7
V505088
p55316
stp55317
a((dp55318
g2
(lp55319
VBecause the program enters into this function, thousands of times every minute, and every time these variables are redefined, and again destroyed, maybe it is better to define these variables outside the  function, in the class, thus saving time and resources
p55320
aVAs far as time and resources go, it makes little difference
p55321
aVThese are local variables, stored on the stack
p55322
aVThe entire stack is already reserved when your thread is created, and the memory for these variables is committed no later than the first time this procedure is executed
p55323
aVSo this means that, for  conditions that don't refer to these variables, you likely won't be able to measure the difference in runtime or resource needs caused by the presence of the variables
p55324
aVRaymond points out that  can be called recusively
p55325
aVIf you have a lot of local variables in your , the resulting stack usage can be sub-optimal
p55326
aVI still can't imagine any real world application where the bottleneck was stack usage of
p55327
aVHaving said that, a  method which is one big switch statement containing all the variables is bad practice
p55328
aVYou don't want to pollute the local namespace of this function with lots of different variables
p55329
aVI suggest you make a separate handler function for each message that you want to handle in the window procedure
p55330
aVFinally, you suggest declaring these variables in the class
p55331
aVDon't do this
p55332
aVLocal variables are always preferred where possible
p55333
aVIt's certainly going to be possible to declare these variables as locals
p55334
aVAlthough they should be locals of the separate handler functions that  calls
p55335
as(dp55336
g7
V505088
p55337
stp55338
a((dp55339
g2
(lp55340
VPost yourself a message from your  event handler
p55341
aVThis will be processed as soon as your application starts servicing its message queue
p55342
aVThat only happens when the application is ready to receive input
p55343
aVWhich matches your my understanding of your requirements
p55344
aVAdd a message handler to deal with the message:
p55345
aVYou'd implement that like this:
p55346
as(dp55347
g7
V505088
p55348
stp55349
a((dp55350
g2
(lp55351
VI'm piecing things together from this question, your last question, the comments to those questions, and your answers to those questions
p55352
aVWhat you are trying to do is modify  for a single rich edit control
p55353
aVThe problem is working out which rich edit control to operate on
p55354
aVLet us suppose you had the following function available:
p55355
aVThen you could simply write:
p55356
aVOr, if there was a possibility that there was no rich edit control active:
p55357
aVSo, how do we implement
p55358
aVWell, it seems that you have a control with multiple pages, each containing a distinct rich edit
p55359
aVThat sounds very much like a page control to me
p55360
aVI'm going to assume that your page control is called , and the tab sheets called ,  etc
p55361
aV, and rich edit controls are named ,  etc
p55362
aVBut if your names are different then you'll need to adapt this code
p55363
aVNow, there are other ways to do this
p55364
aVYou could make an array of rich edit references that could be indexed by
p55365
aVAnd there are indeed yet more possible solutions
p55366
aVBut the key is to use the  or  properties of the page control to work out which rich edit control to operate on
p55367
as(dp55368
g7
V505088
p55369
stp55370
a((dp55371
g2
(lp55372
VYou need to add the  unit to your uses clause
p55373
aVIn older versions of Indy, this unit did not exist
p55374
aVIn Indy 10 this is a new unit that now contains  which used to live in
p55375
aVIf you are also using , then you'll have the same problem
p55376
aVThe unit needed in that case is
p55377
aVAnd so on and so on
p55378
as(dp55379
g7
V505088
p55380
stp55381
a((dp55382
g2
(lp55383
VThe segmentation fault is because you allocated a pointer, but did not create memory for the pointer to point at
p55384
aVOnce you do that, then  is indeed how to access that field in the inner struct
p55385
aVYou need to allocate memory for the struct, and all references within
p55386
aVAnd naturally you need to reverse the process with calls to  when you are done
p55387
aVOr, perhaps  and  are meant to point to values that are allocated elsewhere then it would look like this:
p55388
aVAnd to deallocate you just free
p55389
aVRemember to pair each successful call to  with a call to
p55390
as(dp55391
g7
V505088
p55392
stp55393
a((dp55394
g2
(lp55395
VThe rules for the favicon are all explained on the Wikipedia page
p55396
aVThe standards use a link element with a rel attribute in the  section of the document to specify the file format, file name and a location can be specified for any Web site directory
p55397
aVYou need to look, inside the  element, for  elements of this form:
p55398
aVor
p55399
aVIf you don't find such links, then use the fall back of looking for  at the root directory
p55400
aVI'm not certain why you think that Facebook don't follow the standard
p55401
aVI just looked at an FB page which contained this:
p55402
aVIt's not possible for websites to use some other mechanism to get favicons to browsers
p55403
aVThe browsers follow the well-defined rules for getting favicons
p55404
aVIf a website did something different, the browser would not find the favicon
p55405
as(dp55406
g7
V505088
p55407
stp55408
a((dp55409
g2
(lp55410
VYou are going to need to change the p/invoke:
p55411
aVYou call it once passing  for the length:
p55412
aVThen you need to check that  equals
p55413
aVIf it does not then you have an error
p55414
aVOtherwise you can continue
p55415
aVNow you can check  against
p55416
aVAnd finally we can convert the buffer to a
p55417
aVPut it all together and it looks like this:
p55418
aVFrom the comments it appears that we also need to make changes to the way the  struct is marshalled
p55419
aVI suggest the following:
p55420
aVfollowed by calls to  to convert the  string fields into C# strings
p55421
aVNaturally this conversion needs to happen before the call to
p55422
aVMy guess is that the API actually allocates the string buffers in the space beyond the end of
p55423
aVWhich is why you have to ask how much memory to allocate
p55424
aVI don't have Windows 8 at hand to test this hypothesis
p55425
as(dp55426
g7
V505088
p55427
stp55428
a((dp55429
g2
(lp55430
VFiltering input messages in CLX is not simple
p55431
aVThere appears to be nothing like the VCL's
p55432
aVYou can stop mouse wheel events being handled by CLX page controls with a simple interposer
p55433
aVAdd this code to your main form, before the declaration of your main form class
p55434
aVAnd then in the implementation section of the unit, add this:
p55435
aVIf you have a number of page controls on different forms then you should declare the interposer in a unit that can be shared by all the forms in your app
p55436
aVOr maybe even derive a proper grown-up sub-class
p55437
as(dp55438
g7
V505088
p55439
stp55440
a((dp55441
g2
(lp55442
VPassing a  parameter would match a C++ parameter of type
p55443
aVIn that case the memory would be allocated by the C# code by setting the capacity of the string builder object
p55444
aVFor your function it would appear that the memory is allocated by the C++ code
p55445
aVHence the double pointer
p55446
aVSo you would need this:
p55447
aVYou call it like this:
p55448
as(dp55449
g7
V505088
p55450
stp55451
a((dp55452
g2
(lp55453
VIf the warnings are disabled in the IDE options dialog, then the command send to  will not enable them
p55454
aVWhich leads me to believe that the warnings are enabled in the IDE options
p55455
aVSo, my guess is that you have multiple build configurations and are looking in the wrong build configuration in the IDE
p55456
aVI always get confused by the way the IDE presents build configurations
p55457
aVYou may find it easier to search the
p55458
aVdproj file in a text editor
p55459
aVLook for ,  and
p55460
aVYou can then delete all of those entries and your settings will revert to the default value, which is not to warn
p55461
as(dp55462
g7
V505088
p55463
stp55464
a((dp55465
g2
(lp55466
VDe-referencing an invalid pointer is Undefined Behaviour
p55467
aVThat doesn't mean that a sigsev is guaranteed
p55468
aVAnything could happen
p55469
as(dp55470
g7
V505088
p55471
stp55472
a((dp55473
g2
(lp55474
VYou don't need to automate the shell to do this
p55475
aVAs you have discovered that's not easy to do cleanly
p55476
aVYou can use the ZIP component that ships with Delphi, TZipFile
p55477
aVIf you have an older version of Delphi, one that does not include this component, then you should use a third party component like Abbrevia
p55478
as(dp55479
g7
V505088
p55480
stp55481
a((dp55482
g2
(lp55483
VIn XE2, the internal storage for  is opaque and hidden
p55484
aVYou cannot gain access to it by normal means
p55485
aVAll access to elements of the list are copied \u2013 references to the underlying storage are not available
p55486
aVSo you cannot blit to it using
p55487
aVIf you want a structure that you can blit to, you should consider a dynamic array,
p55488
aVYou can always use the trick of implementing a class helper for  that would expose the private variable
p55489
aVThat's pretty hacky but will do what you ask
p55490
aVI guess you might want to put some parameter checking in , but I'll leave that to you
p55491
aVIf you were using XE3, you could access the private storage of  by using the  property
p55492
aVIf you don't need to blit and can use a for loop then do it like this:
p55493
aVBut I interpret your question that you wish to avoid this option
p55494
as(dp55495
g7
V505088
p55496
stp55497
a((dp55498
g2
(lp55499
VThe p/invoke declaration should look like this:
p55500
aVAnd then you call it like this:
p55501
aVThe way that the native code works is that it expects the calling code to allocate the buffer,
p55502
aVThe calling code says how long the buffer is in
p55503
aVThen when the native code returns,  contains the actual length of the buffer
p55504
aVOr perhaps the number of bytes that were copied
p55505
aVThe former is more useful
p55506
aVAssuming the former then you could perhaps write it like this:
p55507
aVYou should be checking return values etc
p55508
aVI can't be 100% sure exactly how to call the function because there's no enough information in your question
p55509
aVAt least the p/invoke signature now matches your C++ code
p55510
as(dp55511
g7
V505088
p55512
stp55513
a((dp55514
g2
(lp55515
VIn Visual Studio,  is IEEE754 double precison
p55516
aVThat has 53 bits of binary precision,  or around 15-16 decimal significant figures
p55517
aVProbably your diagnostic code that is printing the values only prints to 7 digits of precision
p55518
aVOr your debugger view only shows 7 digits of precision
p55519
aVIn other words the problem is not in the underlying data type, but in the way you are viewing that data
p55520
aVUpdate 1
p55521
aVYour comments indicate that you believe that calculations on double precision values are being carried out to single precision
p55522
aVBy default that will not be the case
p55523
aVIt could happen if you have change the floating point precision control with a call to
p55524
aVHowever, if your floating point control is set at the default value, then operations on double precision values will not be rounded to single precision
p55525
aVUpdate 2
p55526
aVYour Excel calculations are performing a different calculation
p55527
aVThe output from your C++ program matches the code
p55528
aVThe first non-zero value output  which matches the code
p55529
aVBecause the code says that the value should be
p55530
aVThe corresponding value from your Excel code is  which therefore does not match the C++ code
p55531
aVIn other words the question is a red-herring
p55532
aVThere's no rounding problems here
p55533
aVThe issue is entirely down to discrepancies between the two different versions of your code
p55534
aVUpdate 3
p55535
aVYour C++ code does not match the expression in the latest update
p55536
aVThe code uses a multiplicative factor of 1000, but your expression uses a factor of 10000
p55537
as(dp55538
g7
V505088
p55539
stp55540
a((dp55541
g2
(lp55542
VThis would appear to be a regression in Delphi
p55543
aVThe output is 'strange' in Delphi 2010
p55544
aVBut in XE2 there is no output, and so the bug is not present
p55545
aVI don't have XE at hand to test on, but thanks to @Sertac for confirming that XE also outputs 'strange'
p55546
aVNote that older versions of Delphi are also fine, so this was a regression around D2009 time
p55547
aVOn 2010 the code generated is:
p55548
aVThe literal 1
p55549
aV32 is stored as a 10 byte floating point value that should have the value 13200
p55550
aVThis is an exactly representable binary floating point value
p55551
aVThe bit pattern for 13200 stored as 10 byte float is:
p55552
aV00 00 00 00 00 00 40 CE 0C 40
p55553
aVHowever, the bit pattern stored in the literal at $00405118 is different, and is slightly greater than
p55554
aVThe value is:
p55555
aV01 00 00 00 00 00 40 CE 0C 40
p55556
aVAnd that explains why  evaluates to
p55557
aVOn XE2 the code generated is:
p55558
aVNotice here that the literal is held in a 4 byte float
p55559
aVThis can be seen by the fact that we compare against
p55560
aVAnd if we look at the contents of the single precision float stored at  we find:
p55561
aV00 40 4E 46
p55562
aVAnd that is exactly 13200 as represented as a 4 byte float
p55563
aVMy guess is that the compiler in 2010 does the following when faced with :
p55564
aVConvert 1
p55565
aV32 to the nearest exactly representably 10 byte float
p55566
aVMultiply that value by 10000
p55567
aVStore the resulting 10 byte float away at
p55568
aVBecause 1
p55569
aV32 is not exactly representable, it turns out that the final 10 byte float is not exactly 13200
p55570
aVAnd presumably the regression came about when the compiler switch from storing these literals in 4 byte floats to storing them in 10 byte floats
p55571
aVThe fundamental problem is that Delphi's support for the  data type is founded on an utterly flawed design
p55572
aVUsing binary floating point arithmetic to implement a decimal fixed point data type is simply asking for trouble
p55573
aVThe only sane way to fix the design would be to completely re-engineer the compiler to use fixed point integer arithmetic
p55574
aVIt's rather disappointing to note that the new 64 bit compiler uses the same design as the 32 bit compiler
p55575
aVTo be quite honest with you, I would stop the Delphi compiler doing any floating point work with  literals
p55576
aVIt's just a complete minefield
p55577
aVI would do the 10,000 shift in my head like this:
p55578
aVAnd then the calling code would be:
p55579
aVThere's no way for the compiler to screw that up
p55580
aVHumph
p55581
as(dp55582
g7
V505088
p55583
stp55584
a((dp55585
g2
(lp55586
VWhilst you can use flags enum, I personally find that using bitwise operators for set operations is somewhat unclean
p55587
aVYou could use
p55588
aVAdd members to the set with , and test for membership with
p55589
aVBut it still makes for a mess at the call site
p55590
aVThis is one area where C# is weak in comparison with many other languages
p55591
aVIdeally there should be a  type built into the language that supported an  operator to test for membership
p55592
as(dp55593
g7
V505088
p55594
stp55595
a((dp55596
g2
(lp55597
VI'm guessing that since you can't use , you also can't use
p55598
aVYou can concatenate strings with a function like this:
p55599
aVThis can be done more efficiently, but that probably doesn't matter for homework
p55600
aVAnd you need to check for errors, etc
p55601
aVetc
p55602
aVYou also need to decide who is going to call  on  and
p55603
aVFor what it is worth, the efficient version looks like this:
p55604
aVIt's more efficient because it only walks the input strings once
p55605
as(dp55606
g7
V505088
p55607
stp55608
a((dp55609
g2
(lp55610
VThere are three projects that have been mentioned here:
p55611
aVchromiumembedded, latest revision 996
p55612
aVdelphichromiumembedded, latest revision 147
p55613
aVdcef3, latest revision 24
p55614
aVThese are three distinct projects
p55615
aVYou cannot compare revision numbers across projects
p55616
aVThat's an apples and oranges comparison
p55617
aVYou compare revision 24 of dcef3 with revision 823 of some other project
p55618
aVThat comparison is simply meaningless
p55619
aVI suspect that some of the confusion is because the dcef3 and delphichromiumembedded projects depend upon chromiumembedded
p55620
aVSo you may see, in the dcef3 and delphichromiumembedded projects, mentions of chromiumembedded revision numbers
p55621
aVThis is indeed confusing and you need to keep a clear head when navigating these projects
p55622
aVThe project that you are interested in is dcef3
p55623
aVAnd so you should use the latest revision which is, as of today, revision 24
p55624
aVI have to say that this is a marvellous project
p55625
aVIt's incredible that we can pull down this code from an svn repo, build the source immediately, and in less than a minute have a functioning Chromium web browser inside a VCL form, from which I can edit this very post
p55626
aVBravo
p55627
as(dp55628
g7
V505088
p55629
stp55630
a((dp55631
g2
(lp55632
VThe main advantage is less onerous type identity rules
p55633
aVConsider:
p55634
aVThese two variables are not assignment compatible
p55635
aVIt is a compiler error to write:
p55636
aVOn the other hand if you use the generic syntax:
p55637
aVthen these two variables are assignment compatible
p55638
aVSure, you can write
p55639
aVBut all parties need to agree on the same type
p55640
aVIt's fine if all code is in your control, but when using code from a variety of sources, the advent of generic dynamic arrays makes a huge difference
p55641
aVThe other advantage that springs to mind, in similar vein, is that you can readily use the generic array type as the return type of a generic method
p55642
aVWithout the generic array you are compelled to declare a type of this form:
p55643
aVin your generic class, which is rather messy
p55644
aVAnd if you are writing a generic method in a non-generic class, then you've no way to make that declaration
p55645
aVAgain the generic array solves the problem
p55646
aVThis all follows on from type compatibility rules described in the documentation like this:
p55647
aVType Compatibility
p55648
aVTwo non-instantiated generics are considered assignment
p55649
aVcompatible only if they are identical or are aliases to a
p55650
aVcommon type
p55651
aVTwo instantiated generics are considered assignment
p55652
aVcompatible if the base types are identical (or are aliases to a
p55653
aVcommon type) and the type arguments are identical
p55654
as(dp55655
g7
V505088
p55656
stp55657
a((dp55658
g2
(lp55659
VThe symptoms you describe are consistent with a badly coded screensaver
p55660
aVIt would appear that the screensaver is attempting to access an inactive desktop
p55661
aVI expect it was written without consideration for the possibility of there being multiple desktops in the interactive session
p55662
aVThere's nothing you can do about it
p55663
aVYou can't fix the screensaver since you didn't code it
p55664
aVThe obvious workarounds are:
p55665
aVEnable the On resume, display logon screen option
p55666
aVStop using multiple desktops
p55667
aVChoose a different screensaver, one that handles multiple desktops correctly
p55668
aVOf these the lask option would be my choice
p55669
aVOne final point
p55670
aVI don't see any Flash here
p55671
aVThat screensaver uses DirectX to render text
p55672
as(dp55673
g7
V505088
p55674
stp55675
a((dp55676
g2
(lp55677
VThe likely explanation is that a service running under the LOCALSYSTEM account is saving the file
p55678
aVKnowing very little about the architecture of your application, I can't say in any detail how this comes about
p55679
as(dp55680
g7
V505088
p55681
stp55682
a((dp55683
g2
(lp55684
VThe appropriate p/invoke declaration is
p55685
aVIt is your responsibility to allocate the buffer before you call the function:
p55686
aVThe only thing that's not 100% clear is the calling convention
p55687
aVI'd guess that this library uses  which would mean your  should be
p55688
as(dp55689
g7
V505088
p55690
stp55691
a((dp55692
g2
(lp55693
VIf all you have is a pointer, there's no way for you to tell whether or not it has been freed
p55694
aVYou have to get your program to keep track of this information
p55695
aVEven if you could detect a stale pointer, which you can't, it would not help you
p55696
aVYou would still have a race
p55697
aVIn your excerpt you have a thread list
p55698
aVSo long as all access to the pointer is made whilst the list is locked then you will have no problems
p55699
aVPresumably you are freeing the object whilst not holding a lock to the list
p55700
aVFix that problem and all should be well
p55701
as(dp55702
g7
V505088
p55703
stp55704
a((dp55705
g2
(lp55706
VIn code you can do it like this:
p55707
aVBut a lookup table would be much more efficient, and only consume 256 bytes of memory
p55708
aVThis is more than 10 times faster than the version of the code that operates on individual bits
p55709
aVFinally, I don't normally like to comment too negatively on accepted answers when I have a competing answer
p55710
aVIn this case there are very serious problems with the answer that you accepted that I would like to state clearly for you and also for any future readers
p55711
aVYou accepted @Arioch's answer at the time when it contained the same Pascal code as can be seen in this answer, together with two assembler versions
p55712
aVIt turns out that those assembler versions are much slower than the Pascal version
p55713
aVThey are twice as slow as the Pascal code
p55714
aVIt is a common fallacy that converting high level code to assembler results in faster code
p55715
aVIf you do it badly then you can easily produce code that runs more slowly than the code emitted by the compiler
p55716
aVThere are times when it is worth writing code in assembler but you must not ever do so without proper benchmarking
p55717
aVWhat is particularly egregious about the use of assembler here is that it is so obvious that the table based solution will be exceedingly fast
p55718
aVIt's hard to imagine how that could be significantly improved upon
p55719
as(dp55720
g7
V505088
p55721
stp55722
a((dp55723
g2
(lp55724
VYou don't need a button
p55725
aVDelete it and handle the image's OnClick event instead
p55726
aVIf you need to know the point on the image that was clicked, call GetMessagePos from your event handler
p55727
as(dp55728
g7
V505088
p55729
stp55730
a((dp55731
g2
(lp55732
VI'm not 100% sure I understand, but I think you have a situation like this
p55733
aVYou have a  descendent, say
p55734
aVAnd that class in turn uses another class named  which does not descend from
p55735
aVYou want to call  from a method of
p55736
aVHere are some options:
p55737
aVPass the  instance to
p55738
aVThis is a rather brutal solution to the problem
p55739
aVNow  can do anything to the thread when all it wants to do is call
p55740
aVPass a procedural variable referring to the  method to
p55741
aVThis gives  the ability to do what it needs and no more
p55742
aVCall the  class method passing  for the first parameter
p55743
aVOf these, the final option is the simplest
p55744
aVYou can do it like this:
p55745
aVNote that it is not a good idea to pass in a  and cast to  as per the code in the question
p55746
aVForce the caller to pass in a procedural variable of the right type
p55747
aVIn this case the cast is benign, but you should always aim to avoid casts
p55748
as(dp55749
g7
V505088
p55750
stp55751
a((dp55752
g2
(lp55753
VFastMM4 with FullDebugMode does work with XE3
p55754
aVI for one am using it with XE3 and I'm sure loads of other people are too
p55755
aVPossibly you are using out of date code
p55756
aVIn so then download the latest version
p55757
aVIf that's not it then there's something wrong with your project
p55758
aVDownload the latest FastMM version and compile one of the demos in XE3 to convince yourself that FastMM works fine with XE3
p55759
aVOr simply create a blank project and add FastMM4 to the project
p55760
aVMake sure that it appears first in the
p55761
aVdpr file uses list
p55762
aVThen enable the  conditional in
p55763
aVAnd then compile and observe that the compilation succeeds
p55764
as(dp55765
g7
V505088
p55766
stp55767
a((dp55768
g2
(lp55769
VThe equivalent to C#  is
p55770
aVThe C++ code that corresponds to your C# code is this:
p55771
aVYou should not take the advice to write such a class for yourself
p55772
aVWhere they are appropriate, always use the standard containers
p55773
as(dp55774
g7
V505088
p55775
stp55776
a((dp55777
g2
(lp55778
VTo perform abnormal termination call Halt() passing the exit code
p55779
aVOn Windows this results in a call to TerminateProcess and will stop execution there and then
p55780
aVYou note that no cleanup is performed and usually that's what you want
p55781
aVSince you are performing this check at application startup there should be nothing to cleanup
p55782
as(dp55783
g7
V505088
p55784
stp55785
a((dp55786
g2
(lp55787
VIn the implementation section you need to declare the function as being a method of the class:
p55788
aVYour declaration looked like this:
p55789
aVAnd that defines a stand-alone function rather than a method of the class
p55790
as(dp55791
g7
V505088
p55792
stp55793
a((dp55794
g2
(lp55795
VAccording to the subversion repo, the latest revision for Indy 10 is r4910
p55796
aVThe ZIP file that you link to is named Indy10_4910
p55797
aVzip
p55798
aVSo that is as up-to-date as you can be
p55799
aVThe way to check something like this is to look at the source control repo yourself
p55800
aVThe Indy website has a source control repo gateway page here: http://www
p55801
aVindyproject
p55802
aVorg/sockets/Download/svn
p55803
aVEN
p55804
aVaspx
p55805
aVUpdate: If what @mjn says is true then the ZIP file may be out of date
p55806
aVI would always use svn to pull off the latest version
p55807
as(dp55808
g7
V505088
p55809
stp55810
a((dp55811
g2
(lp55812
VYou can do a plain text search for the text "madexcept"
p55813
aVThe easiest way to do that that I know of is with command line utilities
p55814
aVI would combine the strings and grep utilities like this:
p55815
aVC:\u005cmydir>strings MyApp
p55816
aVexe | grep -i madexcept
p55817
aVMadException
p55818
aVMadExceptionT
p55819
aVmadExcept
p55820
aVmadExcept
p55821
aVU9v;1   madExcept5
p55822
aVA       madExcept
p55823
aVmadExcept
p55824
aVmadExcept1
p55825
aVc       madExceptL
p55826
aVc       madExcept
p55827
aVc       madExcept
p55828
aVc       madExceptL
p55829
aVc       madExcept
p55830
aVc       madExcept
p55831
aVmadExcept
p55832
aVc       madExceptH
p55833
aVThis way madExcept can't install the thread hooks
p55834
aVI personally use GnuWin32 as my source for these indispensable utilities
p55835
aVIf you are not a command line sort of a person, use Process Explorer
p55836
aVRun the executable and then run Process Explorer
p55837
aVFind the process and double click it
p55838
aVThe brings up the Process Explorer properties dialog which contains a page named Strings
p55839
aVSelect that page and click on the save button
p55840
aVNow you have a text file with all the strings in the executable in which you can search
p55841
aVAll this will tell you is that you compiled the madExcept code into your program
p55842
aVYou won't know whether or not it is actually active
p55843
as(dp55844
g7
V505088
p55845
stp55846
a((dp55847
g2
(lp55848
VThat is not safe without synchronisation
p55849
aVThe reading threads can be in the middle of a read at the same time as the writing thread modifies the list
p55850
aVAnd modifying the list can mean reallocating the underlying memory
p55851
aVThe RTL provides the  class for such a scenario
p55852
aVEach thread, both writing and reading threads, need to wrap all access to the list in  and  pairs
p55853
aVIf you are using a Delphi that supports generics there is a generic version,
p55854
as(dp55855
g7
V505088
p55856
stp55857
a((dp55858
g2
(lp55859
VYou missed the multiplication operator,
p55860
aVWithout the multiplication operator, the compiler treats the parentheses  as the function call operator
p55861
as(dp55862
g7
V505088
p55863
stp55864
a((dp55865
g2
(lp55866
VYou didn't check the return value of
p55867
aVMost likely the call failed and the buffer  was never assigned anything
p55868
aVAlways check return values
p55869
aVFrom the code we can see, I note that you are lying about the buffer size
p55870
aVYou say that it is 8192 bytes
p55871
aVBut you only allocated 255 bytes
p55872
aVYou are also calling the Unicode version of the API, but passing in a  buffer
p55873
aVIf you are expecting string data then you need to supply a buffer of wide characters
p55874
aVThe Unicode version of this API will return string data as UTF-16 encoded text
p55875
aVOnce you get all that sorted you next need to check what type is stored in that value
p55876
aVYou are passing NULL for the type parameter
p55877
aVPass a pointer to a variable and find out whether or not a string really is stored
p55878
aVthere
p55879
aVYou will also need to read how many bytes are read and set the null-terminator in your buffer accordingly
p55880
as(dp55881
g7
V505088
p55882
stp55883
a((dp55884
g2
(lp55885
VThe following works well for me
p55886
aVI'm not 100% certain I have fully understood the question though, so do let me know if I've got it wrong
p55887
aVNote that the correct type for  is  and not
p55888
as(dp55889
g7
V505088
p55890
stp55891
a((dp55892
g2
(lp55893
VThe conversion in your code using  on a  converts to ANSI correctly
p55894
aVThe appearance of  in an encoding conversion indicates that the conversion of a character failed
p55895
aVThe most likely reason for this is that  contains characters that are not present in your ANSI codepage
p55896
aVI would expect that you should be converting to UTF-8 rather than ANSI, but of course I don't have all the information that you have
p55897
aVThe bottom line is that the  indicates that the source string contains a character that cannot be encoded in the destination character set
p55898
aVUpdate
p55899
aVYour answer gives further evidence that you should be converting to UTF-8
p55900
aVOnly you can know for sure, but the evidence you present is consistent with that conclusion
p55901
as(dp55902
g7
V505088
p55903
stp55904
a((dp55905
g2
(lp55906
VYou can use the  operator and assign a  value
p55907
aVAnd yes,  is a more idiomatic and modern C++ way to do this, but you should know about the  operator too
p55908
as(dp55909
g7
V505088
p55910
stp55911
a((dp55912
g2
(lp55913
VIf you need the main form to be created first, then create it first:
p55914
aVThat's a direct and naive answer to the question that you asked
p55915
aVThinking more broadly, I would encourage you to move the login testing out of the main form
p55916
aVPut it somewhere  that can be used by whatever higher-level code needs to
p55917
aVThe design you are currently working towards has unhealthy coupling
p55918
as(dp55919
g7
V505088
p55920
stp55921
a((dp55922
g2
(lp55923
VIf it is a C# DLL then you can add a reference and use it
p55924
aVIf it is a native DLL then you'd need to do some reverse engineering
p55925
aVHowever, what you are describing is not the normal way to do about developing software
p55926
aVTo write decent software you need to have good documentation for the libraries that you use
p55927
aVTrying to guess how a library is meant to be called is a recipe for disaster
p55928
aVDevelopment should be based on a solid and deep understanding of the tools you are using
p55929
as(dp55930
g7
V505088
p55931
stp55932
a((dp55933
g2
(lp55934
VThe question lacks important details, but I would expect that you need to allocate memory for each IntPtr in the array
p55935
aVAnd obviously you should free the memory once you are done with it
p55936
as(dp55937
g7
V505088
p55938
stp55939
a((dp55940
g2
(lp55941
VYou can use  from  to split the string into pieces
p55942
aVAnd then use  to convert to integer
p55943
aVAnd obviously substitute  if you have floating point values
p55944
as(dp55945
g7
V505088
p55946
stp55947
a((dp55948
g2
(lp55949
VYou pass the wrong thing to
p55950
aVYou are passing the address of a local variable rather than the address of the algorithm
p55951
aVYou need to write:
p55952
aVAnd also  is wrong
p55953
aVYou are passed a pointer by value and modify that pointer
p55954
aVSo the caller cannot see that modification
p55955
aVYou need it to be:
p55956
aVI think your code would be easier if you defined a type to represent an algorithm
p55957
aVThat type would be just a , but it would make the code much easier to read
p55958
aVWhat's more, I would make  return the algorithm
p55959
as(dp55960
g7
V505088
p55961
stp55962
a((dp55963
g2
(lp55964
VIn the absence of code that demonstrates your problem, I will give you a correspondingly general answer
p55965
aVYou are trying to display English characters, but see Chinese characters
p55966
aVThat is what happens when you pass 8 bit ANSI text to an API that receives UTF-16 text
p55967
aVLook for somewhere in your program where you cast from  to
p55968
as(dp55969
g7
V505088
p55970
stp55971
a((dp55972
g2
(lp55973
VI always use this approach:
p55974
aVDon't let the use of  put you off, it's perfectly safe
p55975
aVAnd don't worry about 64 bit pointer truncation
p55976
aVIf you have a record whose size is >4GB then you have bigger problems
p55977
as(dp55978
g7
V505088
p55979
stp55980
a((dp55981
g2
(lp55982
VThat code works because of a new feature introduced in D2010, namely the ability to recover a reference to the object that implements an interface
p55983
aVNote though that if the  is implemented by something other than your Delphi code, then the cast will fail
p55984
aVIf you need to refer to the implementing object in older versions of Delphi then you will need to use one of the various hacks to recover it
p55985
aVFor example:
p55986
aVHallvard Vassbotn's classic approach
p55987
aVBarry Kelly's more recent variant
p55988
aVHowever, you should not need to get back to the implementing object
p55989
aVThe fact that you do want to is a very strong indication that your design is wrong
p55990
as(dp55991
g7
V505088
p55992
stp55993
a((dp55994
g2
(lp55995
VYou can get the title of a window with the  function
p55996
aVYou'll need to p/invoke to it
p55997
aVYou can find sample code for this at pinvoke
p55998
aVnet
p55999
as(dp56000
g7
V505088
p56001
stp56002
a((dp56003
g2
(lp56004
VThe two radio buttons are in fact  controls
p56005
aVThey are children of the containing group window
p56006
aVSo you need to enumerate those children, by calling  to find the appropriate button
p56007
aVThen you can send that button the  message to simulation pressing it
p56008
aVBy the way,  won't find your window
p56009
aVYou are asking it to match a window with class name  and title
p56010
aVI'm confident that call to  will return zero
p56011
aVPersonally I'd call  on the top level window and stop when you find a window with title
p56012
aVAnd so avoid having to use  at all
p56013
as(dp56014
g7
V505088
p56015
stp56016
a((dp56017
g2
(lp56018
VYou should not overwrite the
p56019
aVdcu files that are part of the Delphi installation
p56020
aVWhat's more, I would not recommend that you do anything with the
p56021
aVdcu files that you used to build these
p56022
aVbpl files
p56023
aVWhat you should do is to include the Indy source files, the
p56024
aVpas files, in your project
p56025
aVPersonally I prefer to avoid using a search path to achieve that and instead simply add all the necessary
p56026
aVpas files to the project
p56027
aVBut you may prefer to use the search path option
p56028
aVBut the main point is that since this project is supplied in source form it is best to compile the source yourself, as part of your project
p56029
aVThat makes it much easier for you, whilst debugging, to step through the Indy code
p56030
aVThere's no need to have separate DCU files for release and debug
p56031
aVIt makes the build process simpler, only one thing to build
p56032
aVIt makes it easier if your source code targets multiple Delphi compiler versions
p56033
as(dp56034
g7
V505088
p56035
stp56036
a((dp56037
g2
(lp56038
VThe documentation for  says:
p56039
aVFile attributes for the existing file are copied to the new file
p56040
aVWhich means that you cannot use base your program on the last modified attribute of the file, or indeed any attribute of the file
p56041
aVIndeed there are all sorts of ways for the last modified attribute of the file to change
p56042
aVIt can in fact go backwards in time
p56043
aVInstead I suggest that you use  to keep track of modifications
p56044
aVThat will allow you to receive notifications whenever a file is modified
p56045
aVYou can write your program in an event based manner based on the  API
p56046
aVIf you can't use  and the file attributes, then you'll have to base your decisions on the contents of the file
p56047
as(dp56048
g7
V505088
p56049
stp56050
a((dp56051
g2
(lp56052
VSince you want to share a mutex across sessions you must use either the  namespace, or create your own private namespace
p56053
aVAs it stands, you are not specifying a namespace
p56054
aVAnd whilst the service defaults to use the global namespace, your interactive application will be using the local namespace
p56055
as(dp56056
g7
V505088
p56057
stp56058
a((dp56059
g2
(lp56060
VTo answer the question directly, you can use the  command or  in MATLAB to execute an external process
p56061
aVOnce it returns you can read and parse the output from your MATLAB function
p56062
aVWrap that all up in a MATLAB
p56063
aVm file and you have what you describe in the question
p56064
aVOf course, you could just access the web service directly from MATLAB with
p56065
aVAnd as others point out,  allows you to import and use your
p56066
aVnet assembly directly from MATLAB, which may be cleaner than parsing text file output
p56067
as(dp56068
g7
V505088
p56069
stp56070
a((dp56071
g2
(lp56072
VYou need to call the dictionary constructor overload that receives a  parameter of type
p56073
aVFor example, suppose that we have
p56074
aVThen we could pass to the constructor an instance of
p56075
aVAn example of such a thing is
p56076
aVThis is very unwieldy and you would never prefer this option over a simple  followed by a series of calls to
p56077
aVYou would only use the option of passing in an existing collection if you happened to a ready-made one at hand
p56078
aVAnother example of a class that derives from  is  itself:
p56079
aVSo if you already had one instance of the dictionary, you could create another one and initialise it with the contents of the first:
p56080
as(dp56081
g7
V505088
p56082
stp56083
a((dp56084
g2
(lp56085
VYou cannot add the unmanaged DLL as a reference to your managed C++ project
p56086
aVYou can only do that with managed DLLs
p56087
aVWhat you do instead is link to the unmanaged DLL in the same way as you link to an unmanaged DLL in an unmanaged C++ project:
p56088
aVUse the header file for compilation
p56089
aVSupply the unmanaged DLL's
p56090
aVlib file to the linker, for example by adding it to the list of Additional Dependencies list in the linker configuration pages
p56091
aVPut the DLL in the same directory as the executable, so that it can be located by the loader
p56092
as(dp56093
g7
V505088
p56094
stp56095
a((dp56096
g2
(lp56097
VIt's entirely up to you how you treat an error condition
p56098
aVIn your case this error condition is entirely to be expected, and it's perfectly safe for you to treat it as an expected condition
p56099
aVAnother example of this nature is when you call an API function but don't know how large a buffer to provide
p56100
aVSo you provide a buffer that you hope will be big enough
p56101
aVBut if the API call fails, you then check that the last error is
p56102
aVThat's an expected error condition
p56103
aVYou can then try again with a larger buffer
p56104
as(dp56105
g7
V505088
p56106
stp56107
a((dp56108
g2
(lp56109
VIt depends on the security attributes used to create the pipe
p56110
aVThe pipe creator has to use security attributes that are permissive enough to let the limited user gain access to the pipe
p56111
as(dp56112
g7
V505088
p56113
stp56114
a((dp56115
g2
(lp56116
VLike this:
p56117
aVI omitted error checking for the sake of brevity
p56118
aVYou would not do that
p56119
aVThen when you call  you can set up the security attributes record like this:
p56120
aVThe documentation for  states:
p56121
aVWhen the pDacl parameter does not point to a DACL and the bDaclPresent flag is TRUE, a NULL DACL is specified
p56122
aVAll access is allowed
p56123
aVYou should not use a NULL DACL with an object because any user can change the DACL and owner of the security descriptor
p56124
aVThis will interfere with use of the object
p56125
aVSo, the above is how to do it, but the documentation does stress that you should not do so
p56126
as(dp56127
g7
V505088
p56128
stp56129
a((dp56130
g2
(lp56131
VStep 1 is that you must not make the desktop window the owner of your form
p56132
aVRaymond Chen explains why not
p56133
aVTo really understand what's happening you need to read Window Features on MSDN to get a clearer understanding of window ownership
p56134
aVAnd be very careful that window ownership is a concept completely unrelated to Delphi component ownership
p56135
aVIn Delphi terms, window ownership is controlled by the  property
p56136
aVAs has been clarified in comments, you want both forms to be unowned, top-level windows
p56137
aVThe main form automatically is that
p56138
aVFor the details form you need to set  to  and that's it:
p56139
aVThe final step is to make sure that the save dialog is owned properly
p56140
aVTo do that specify the owner when you call :
p56141
aVSo, in summary you need to make three changes:
p56142
aVSet the detail form's  to
p56143
aVRemove the  extended style, it is not needed for an unowned top-level window
p56144
aVPass the detail form's handle when calling  on the save dialog
p56145
aVUpdate
p56146
aVIt turns out that you are using XP, and the Delphi code that shows the file dialog is rubbish
p56147
aVAlthough you pass a handle to the  method, that is ignored and the main window handle is used as the dialog's owner
p56148
aVAnd that's why the main window comes to the front
p56149
aVYou can get around this by setting  to
p56150
aVYou should probably set this in your
p56151
aVdpr file
p56152
aVRead more about this here: http://blogs
p56153
aVembarcadero
p56154
aVcom/abauer/2005/09/30/21517
p56155
as(dp56156
g7
V505088
p56157
stp56158
a((dp56159
g2
(lp56160
VThat is a reference parameter in C++
p56161
aVIn Delphi that corresponds to a  parameter
p56162
aVThe documentation says:
p56163
aVMost parameters are either value parameters (the default) or variable (var) parameters
p56164
aVValue parameters are passed by value, while variable parameters are passed by reference
p56165
as(dp56166
g7
V505088
p56167
stp56168
a((dp56169
g2
(lp56170
VYou are populating the rich edit window in a tight loop, and not servicing your message queue
p56171
aVUnless your process is regularly attending to its message queue, the system thinks that your app has stopped responding
p56172
aVWell, it has stopped responding
p56173
aVIn order to keep your application responsive, you must pump your message queue
p56174
aVI don't really know what your real program is trying to do
p56175
aVIf you wanted to put that text into a rich edit, you'd do so with a single  message
p56176
aVIf you really do have a long running task then it belongs on a different thread
p56177
aVThen you have to deal with synchronizing back to the GUI thread
p56178
aVIf all you do is call SendMessage then the system takes care of synchronizing that
p56179
aVThe bottom line is that must pump your message queue in a timely fashion
p56180
as(dp56181
g7
V505088
p56182
stp56183
a((dp56184
g2
(lp56185
VYou've declared  to be an instance method and so need to implement it as such:
p56186
aVYou declared a function
p56187
aVthat is not a method of the class
p56188
aVThis question suggests that you are missing some understanding of the Delphi object model
p56189
aVI refer you to the relevant section of the language guide to fill in the missing knowledge
p56190
aVI would also recommend that you use different names for your dimensions parameters
p56191
aVYou should use  and  so that it is clear to future readers of the code that these parameters are going to be used to set the corresponding shape properties
p56192
as(dp56193
g7
V505088
p56194
stp56195
a((dp56196
g2
(lp56197
VI expect that what happens is this:
p56198
aVYou have multiple monitors
p56199
aVThe message arrives at IE that its monitor is being turned off
p56200
aVIE responds to this by moving itself to one of the remaining monitors
p56201
as(dp56202
g7
V505088
p56203
stp56204
a((dp56205
g2
(lp56206
VThe simplest is to use a list
p56207
aVUse a generic list from
p56208
aVFor you needs, you would declare the list to be a field in one of your classes
p56209
aVThe class that you want to control and manage all the machines
p56210
aVCreate it like this:
p56211
aVAdd new members to the list like this:
p56212
aVIterate over the list like this:
p56213
aVIf you would like the list to control the lifetime of the machines, then use  instead
p56214
aVThen when you remove items from the list, clear the list, destroy the list etc
p56215
aV, the machines will also be destroyed
p56216
aVThe Delphi documentation contains an example illustrating the use of
p56217
aVSo, to make it clear, your  loop would look like this:
p56218
aVThen at some other point in your code when you need to iterate over all machines, use the code in the  loop above
p56219
aVOf course, this may all be a complete red herring
p56220
aVPerhaps you don't ever need to refer to your machine objects outside the routine in the question
p56221
aVIn which case you don't need a list at all, and the code in the question is already perfectly adequate
p56222
aVI note that you state:
p56223
aVCurrently that will place one machine on the form
p56224
aVThat is not so
p56225
aVThe while loop will create one machine object for each iteration of your  loop
p56226
aVThe fact that you re-use the local variable  doesn't change that
p56227
aVEach time round the loop you call  and so create a new instance each iteration
p56228
as(dp56229
g7
V505088
p56230
stp56231
a((dp56232
g2
(lp56233
VIf you want to implement the copy/paste yourself, the mechanism is almost identical to drag and drop
p56234
aVThe drag and drop code that you have will create an
p56235
aVTo copy, instead of calling  to initiate a drag, simply call  passing the
p56236
aVAnd for pasting you call  to get the  from the clipboard
p56237
aVAnd then you simply use the exact same code as for a drop operation to decode the
p56238
aVThat's all there is to it
p56239
aVThere is another way to do it, probably a better approach in my view
p56240
aVAnd that is to use  to do the work
p56241
aVAnd example of this can be found in the TurboPower tpShellShock project
p56242
aVHave a look for  in the  unit
p56243
aVSo long as the DevExpress component is using the shell interfaces, i
p56244
ag192
aV, then you will be able to use that same approach
p56245
aVThe advantage of this shell based approach is that you are getting the shell to do the work
p56246
aVIf a copy dialog needs to be shown, then the shell will do so
p56247
aVThis will give you the most integrated user experience
p56248
aVThis code looks like this:
p56249
aVI think you should be able to use this code pretty much as is
p56250
aVI would point out that the handle parameter is declared incorrectly
p56251
aVIt should be
p56252
aVIt's used as the owning window for any dialog that is shown during the call to
p56253
as(dp56254
g7
V505088
p56255
stp56256
a((dp56257
g2
(lp56258
VI would put all the controls in a panel, and then move the panel rather than the controls
p56259
aVThat way you perform the shift in a one single operation
p56260
aVIf you would rather move the controls within their container then you can use
p56261
aVFor what it is worth, it is more efficient to use  than to modify  and  in separate lines of code
p56262
as(dp56263
g7
V505088
p56264
stp56265
a((dp56266
g2
(lp56267
VRob has identified problems with your existing code
p56268
aVHowever your existing approach is needlessly complex
p56269
aVIf you chose a simpler approach you would find it easier to get the code right
p56270
aVIf you want a date time that is 20 milliseconds greater than now, do it like this:
p56271
aVIf you want a date time representing 0845 today, then you write:
p56272
as(dp56273
g7
V505088
p56274
stp56275
a((dp56276
g2
(lp56277
VDynamic arrays don't need to be freed
p56278
aVThey are managed types and the compiler makes sure that when there are no more references to the object, the object is destroyed
p56279
aVAs for detecting duplicates, you can do it like this:
p56280
aVI assume that when you say "null", in the context of a string you mean that the string is empty
p56281
aVThis is an algorithm with complexity O(n^2)
p56282
aVThat's bad news if the array is large
p56283
aVIf your array was ordered you can do the test with an O(n) algorithm
p56284
aVNaturally these functions can easily be modified to identify which index is the duplicate:
p56285
as(dp56286
g7
V505088
p56287
stp56288
a((dp56289
g2
(lp56290
VSince you want to use WSDL, you are working from the wrong documentation
p56291
aVYou linked to a guide about SOAP
p56292
aVTo learn about WSDL, read this: Access Web Services That Use WSDL Documents
p56293
aVWhen you use MATLAB's , you don't need to worry about the SOAP implementation
p56294
aVThe generated MATLAB class takes care of that
p56295
as(dp56296
g7
V505088
p56297
stp56298
a((dp56299
g2
(lp56300
VDestroying a control is no different from destroying any other object
p56301
aVSimply call Free on the object and you are done
p56302
aVThe only time that you run into problems is when you call Free on an object for whom an event handler is running
p56303
aVFor example freeing a button in that button's OnClick handler
p56304
aVIn such a scenario you need to post a message to your form, and then free the button when that queued message is processed
p56305
aVYour problem is that you are calling Free on the wrong object
p56306
aVYou created 5 labels but only held on to a reference to one of them
p56307
aVYou need to free all 5 labels
p56308
aVYou'll want an array or a list to hold the label references
p56309
aVThen you'll be able to free them all
p56310
aVIn your form declare an array:
p56311
aVWhen you create them:
p56312
aVDestroy like this:
p56313
aVSome general advice for you
p56314
aVWhen you are faced with a problem, simplify it
p56315
aVWhy try to debug object destruction with multiple controls
p56316
aVCreate a blank app, and add a single control
p56317
aVThen try to delete that single control
p56318
aVThen move to multiple controls
p56319
aVDon't troubleshoot the complex version, always try to simplify
p56320
as(dp56321
g7
V505088
p56322
stp56323
a((dp56324
g2
(lp56325
VYour control still has afinity to the GUI thread
p56326
aVSo you cannot access it from the worker thread
p56327
aVYou just need a slight adjustment to the threading design to make this work
p56328
aVProcess the page's source to pull off all the links in the GUI thread
p56329
aVThis has to be done there, you have no choice
p56330
aVBut then let the worker thread do the onward processing of the links
p56331
aVI'm assuming the real app does more with the links than put them in a memo
p56332
aVYou should have a simple producer/consumer design
p56333
aVThe GUI thread produces a list of links
p56334
aVThe worker thread(s) consume them
p56335
aVA threadsafe queue will allow you to synchronize tasks between the threads
p56336
aVAnd you may benefit from using a higher level library like OTL in preference to coding raw threads
p56337
as(dp56338
g7
V505088
p56339
stp56340
a((dp56341
g2
(lp56342
VIf you want to find out why an API call is failing you need to check the return values
p56343
aVThat's what is missing in this code
p56344
aVYou need to treat each function on its own merits
p56345
aVRead the documentation on MSDN
p56346
aVIn the case of , the return value is an
p56347
aVFor  you get back a
p56348
aVIf that is  then the call failed
p56349
aVThe likely culprit here is , the code that receives the CSIDL, but you must check for errors whenever you call Windows API functions
p56350
aVTaking a look at the documentation for  we see this:
p56351
aVCSIDL_COMMON_APPDATA
p56352
aVVersion 5
p56353
ag9193
aVThe file system directory that contains application data for all users
p56354
aVA typical path is C:\u005cDocuments and Settings\u005cAll
p56355
aVUsers\u005cApplication Data
p56356
aVThis folder is used for application data that
p56357
aVis not user specific
p56358
aVFor example, an application can store a
p56359
aVspell-check dictionary, a database of clip art, or a log file in the
p56360
aVCSIDL_COMMON_APPDATA folder
p56361
aVThis information will not roam and is
p56362
aVavailable to anyone using the computer
p56363
aVIf the machine has a shell version lower than 5
p56364
aV0, then this  value is not supported
p56365
aVThat's the only documented failure mode for this  value
p56366
aVI don't think that applies to your situation, so you'll just have to see what the  status code has to say
p56367
as(dp56368
g7
V505088
p56369
stp56370
a((dp56371
g2
(lp56372
VWhen you set the  property of a  object, the new value is parsed as a null-terminated string
p56373
aVTherefore when the code reaches your null character, the parsing stops
p56374
aVI'm not sure why the Delphi RTL code was designed that way, and its not documented, but that's just how setting the  property works
p56375
aVYou can avoid this by using the  method rather than the  property
p56376
as(dp56377
g7
V505088
p56378
stp56379
a((dp56380
g2
(lp56381
VIf I had to solve this problem I'd tackle it by instrumenting calls to ,  and
p56382
aVI would hook the calls to those functions and use a thread local variable to count the calls
p56383
aVYou can do this by adding the following unit to your project
p56384
aVUnlike Serg's approach, this technique will not change the semantics of your program
p56385
as(dp56386
g7
V505088
p56387
stp56388
a((dp56389
g2
(lp56390
VThe root of all your problems is that you are using a class, which is a reference type
p56391
aVInstead you need to make your vector be a value type
p56392
aVThat means use a
p56393
aVIn your code, even when you fix the problem identified by @NGLN, you have still destroyed all instances of your class by the time you start calling
p56394
aVUnless you grasp this issue soon, I fear that you will continue having problems
p56395
aVSwitching to using a value type will make your coding trivially easy in comparison to your current approach
p56396
aVHere's something to get you started:
p56397
aVThis is extracted from my own codebase
p56398
aVI'm using , but if you really prefer to use , then you can readily change it
p56399
aVThe use of operator overloading makes the code you write so much more readable
p56400
aVNow you can write  and so on
p56401
aVHere's what your test code looks like with this record:
p56402
aVOr if you want to compress it somewhat:
p56403
as(dp56404
g7
V505088
p56405
stp56406
a((dp56407
g2
(lp56408
VYou have used  for all the callback functions
p56409
aVThat is incorrect
p56410
aVThe C header does not do that and so there is a binary mismatch
p56411
aVThat explains your errors
p56412
aVFix the problem by removing all mention of  from your Delphi unit
p56413
aVSome other comments:
p56414
aVC  maps to Delphi , or Delphi
p56415
aVOn a Unicode Delphi, your use of  will be incorrect
p56416
aVLikewise you should use  rather than
p56417
aVThe functions ,  etc
p56418
aVare declared as  in the C code
p56419
aVYou've made them  in your Delphi code
p56420
aVThe fourth parameter of  takes a pointer to the struct
p56421
aVYour Delphi code is declared to receive the struct
p56422
aVYou need to add that indirection and make the Delphi code also receive a pointer
p56423
aVThe  parameter of  is a pointer to a byte array
p56424
aVYou've declared it in Delphi as
p56425
aVI suspect there are a handful more errors in your conversion
p56426
aVI recommend you go over it again very carefully
p56427
as(dp56428
g7
V505088
p56429
stp56430
a((dp56431
g2
(lp56432
VThe reason is that  gives you the last day of the month, but also a time corresponding to the end of the day
p56433
aVBut your  is probably the very beginning of the  day
p56434
aVIf you print out the raw values of  and  in the loop you see this:
p56435
aVSo, looking at the final line you can see we have a time of 23:59 on day 41364
p56436
aVI'd fix this by working with pure dates and not letting time get in the way of things
p56437
aVChange the incrementing code to remove the time part of the date
p56438
aVAnd I'd also be explicit about doing the same in the loop test
p56439
as(dp56440
g7
V505088
p56441
stp56442
a((dp56443
g2
(lp56444
VYou could write your own event sink to listen to the Word application's  event
p56445
aVHowever, it's going to be easier to switch to early bound COM
p56446
aVThe import type library, found in , contains all that you need
p56447
aVUse  for your application object
p56448
aVAssign your handler(s) to the events of the application object
p56449
aVDepending on precisely what you want to do, the events that seem most applicable are  and
p56450
aVTo illustrate, here's the most trivial example that I can devise:
p56451
as(dp56452
g7
V505088
p56453
stp56454
a((dp56455
g2
(lp56456
VThe  function works perfectly well in all versions of Delphi
p56457
aVThe problem is your cast, which is what is known as an unsafe typecast
p56458
aVAn unsafe typecast from an interface reference to an object has ill-defined behaviour in older versions of Delphi
p56459
aVHowever, the behaviour is well-defined in modern Delphi
p56460
aVThe documentation says more
p56461
aVSo, the basic problem is that your expectations for the behaviour are not compatible with the Delphi 7 version of the language
p56462
aVIf you get the interface to return the ID you will find that the interface you are creating is as expected
p56463
aVIt's rather unusual to ask for the implementing object from an interface
p56464
aVTo do so suggests that there is a problem with your design
p56465
aVShould you really need to do so there are a few options:
p56466
aVIn modern Delphi you can use the type-safe case with the  operator
p56467
aVIn older Delphi versions there are hacks that retrieve the implementing object: Casting a delphi interface to its implementation class without modifying the interface
p56468
aVYou could add a function to the interface that returns the implementing object
p56469
aVThe latter option works in all versions of Delphi and does so without resorting to subterfuge
p56470
as(dp56471
g7
V505088
p56472
stp56473
a((dp56474
g2
(lp56475
VLike this:
p56476
aVNotes:
p56477
aVis a pointer sized integer
p56478
aVIn Delphi that is
p56479
aVis an unsigned 32 bit integer,  in Delphi
p56480
aVgets marshalled to a C string, pointer to null-terminated string
p56481
aVSince there is no  specified, the default of  is used
p56482
aVThat's  in Delphi
p56483
aVNo  is specified so the default of  applies
p56484
aVSo, that's  in Delphi
p56485
aVThe  is an array of bytes
p56486
aVThat's marshalled as a pointer to the first byte of the array
p56487
aVSo,  in Delphi
p56488
aVYou will also need to translate  to Delphi
p56489
aVIt looks like it might be a struct
p56490
aVYou might be better off working from the C++ header file rather than the p/invoke declarations
p56491
aVIt's always best to work from the original source of an interface definition
p56492
as(dp56493
g7
V505088
p56494
stp56495
a((dp56496
g2
(lp56497
VYou can use the dbghelp library to obtain the image headers
p56498
aVThen you can read the information you need out of the
p56499
aVHere's some sample code
p56500
aVPlease forgive the rather lame error handling
p56501
aVI just knocked it up quickly to illustrate, and I'm not even remotely fluent in C++
p56502
aVTo link this you need to add  to the additional dependencies of your project
p56503
aVTo learn more about the details behind this, refer to the MSDN documentation for the various API calls that are used
p56504
as(dp56505
g7
V505088
p56506
stp56507
a((dp56508
g2
(lp56509
VFirst of all, I am assuming that the DLL was not in fact written in VB6
p56510
aVThe fact that you show code that uses  to call the function contradicts that
p56511
aVSo I am assuming that the DLL was written in some other language (e
p56512
ag217
aVC++) and that you are currently calling the DLL from VB6
p56513
aVThe VB6 code that calls the DLL is declared like this:
p56514
aVYour C# version looks like this:
p56515
aVThere are two obvious differences:
p56516
aVThe third parameter does not match
p56517
aVInstead of  you need
p56518
aVThe return value does not match
p56519
aVA VB6 variant cannot be matched up with
p56520
aVYou need to declare the return value to be of type  in your C# code
p56521
aVSo the pinvoke should be:
p56522
aVUpdate
p56523
aVWith this declaration you receive a pinvoke error:
p56524
aVPInvoke restriction: cannot return variants
p56525
aVI'm not sure how you can get around this in pinvoke
p56526
aVIn your situation I think I would create a VB6 project that wrapped up the DLL and exposed it as a COM interface
p56527
aVI'd then add a COM reference to your C# project and move on
p56528
as(dp56529
g7
V505088
p56530
stp56531
a((dp56532
g2
(lp56533
VYou need to set  in the runtime code
p56534
aVThe code in your question won't result in the control showing for a plain vanilla , or indeed any control
p56535
aVFrom the documentation, with my emphasis:
p56536
aVSpecifies the parent of the control
p56537
aVUse the Parent property to get or set the parent of the control
p56538
aVThe
p56539
aVparent of a control is the control that contains it
p56540
aVFor example, if
p56541
aVan application includes three radio buttons in a group box, the group
p56542
aVbox is the parent of the three radio buttons, and the radio buttons
p56543
aVare the child controls of the group box
p56544
aVTo serve as a parent, a control must be an instance of a TWinControl
p56545
aVdescendant
p56546
aVWhen creating a new control at run time, assign a Parent property
p56547
aVvalue for the new control
p56548
aVUsually, this is a form, panel, group box,
p56549
aVor a control that is designed to contain another
p56550
aVChanging the parent
p56551
aVof a control moves the control onscreen so that it is displayed within
p56552
aVthe new parent
p56553
aVWhen the parent control moves, the child moves with
p56554
aVthe parent
p56555
as(dp56556
g7
V505088
p56557
stp56558
a((dp56559
g2
(lp56560
VIt's undefined behaviour to modify a literal because the standard says so
p56561
aVAnd the standard says so to allow compilers to put literals in read only memory
p56562
aVAnd it does this for a number of reasons
p56563
aVOne of which is to allow compilers to make the optimisation of storing only one instance of a literal that is repeated many times in the source
p56564
as(dp56565
g7
V505088
p56566
stp56567
a((dp56568
g2
(lp56569
VFile locking is known not to work reliably and robustly for file access to network shares
p56570
aVSimply put, you need to find another mechanism to implement mutual exclusion
p56571
aVFor example, use a client/server database design
p56572
as(dp56573
g7
V505088
p56574
stp56575
a((dp56576
g2
(lp56577
VThe design of actions is based on idle time updating of actions
p56578
aVAs you move your mouse, the application receives lots of queued messages
p56579
aVEach time the queue is emptied, the application is deemed to be idle, and all the actions are updated
p56580
aVAnd this can lead to high CPU utilization
p56581
aVThis issue is well known and acknowledged in the VCL
p56582
aVFor example, take a look at TApplication
p56583
aVActionUpdateDelay
p56584
as(dp56585
g7
V505088
p56586
stp56587
a((dp56588
g2
(lp56589
VYou can handle Word's  event like this:
p56590
aVIn real code,  would be a field of one of your objects rather than a local variable as I show here
p56591
aVYour code uses late bound COM
p56592
aVWhilst you can write event sinks with late bound COM, it's trivially easy using early bound COM since the event sink is provided for you
p56593
aVSo, stop calling  to create the COM object and instead use
p56594
as(dp56595
g7
V505088
p56596
stp56597
a((dp56598
g2
(lp56599
VException code  is an access violation, also known as general protection fault
p56600
aVThe program is reading from, or writing to, an address which is not part of the virtual address space
p56601
aVA very common cause is that you are de-referencing a stale pointer
p56602
aVIn other words, the pointer was once valid, but you have subsequently freed it
p56603
aVThen later when you attempt to access it, an exception is raised
p56604
aVThe exception is faulting in  which is a system DLL
p56605
aVThat means that something in your program is passing invalid data to a system API
p56606
aVIn order to solve this problem you will likely need to run under the debugger and let the debugger break at the point in the code where the exception occurs
p56607
aVThen you can attempt to work out why the memory that is being accessed is invalid
p56608
aVThat's something that you can do, but we cannot
p56609
aVYou have the code, we do not
p56610
aVSo, we can't give you any more help than this
p56611
aVIn any case, there's no need to despair\u2013these problems are usually easy enough to solve with the help of a debugger
p56612
as(dp56613
g7
V505088
p56614
stp56615
a((dp56616
g2
(lp56617
VThe problem is that the date time picker control is being initialised with the current date
p56618
aVAnd that includes a day of the month that is invalid for some months
p56619
aVSo, just to be clear, you are asking this question on the 29th January 2013
p56620
aVWhen you click on the up/down control to move to February, the control fails to perform the change because there is no 29th February in 2013
p56621
aVFor any future visitors that find it hard to reproduce, this is the code you need to demonstrate the issue:
p56622
aVThe simple fix for the problem is to make sure that the  property for the control is for the start of the month
p56623
aVYou can achieve that by executing this code when you initialise the control:
p56624
aVOr perhaps if you want to be more explicit:
p56625
aVThe  helper function is found in the  unit
p56626
as(dp56627
g7
V505088
p56628
stp56629
a((dp56630
g2
(lp56631
VI've no experience of this, but here's my best suggestions based on reading the documentation that you have linked to
p56632
aVFirst of all, I think you need to specify more of the members of :
p56633
aVneeds to be set to
p56634
aVneeds to be set to
p56635
aVYou also need to make sure that the variant really is
p56636
aVThat's a 4 byte real, in Delphi terms a variant of type
p56637
aVI think that should get it done
p56638
aVPutting it all together, it looks like this:
p56639
aVAs regards whether or not JPEG quality 1
p56640
aV0 is lossless, it is not
p56641
aVThat's a question already well covered here: Is Jpeg lossless when quality is set to 100
p56642
as(dp56643
g7
V505088
p56644
stp56645
a((dp56646
g2
(lp56647
VYou should set
p56648
aVin your
p56649
aVdpr file and then never modify that setting
p56650
aVThen, when you want to remove the main form from the taskbar you simply write
p56651
aVWhen you need to bring the main form out of hiding again write
p56652
aVAnd that's it
p56653
aVNaturally you'll want to show and hide your notification area icon in concert with hiding and showing the main form
p56654
aVThe code in  is not necessary and you should remove it
p56655
aVWhen you application is in  equals  mode, the main form is an un-owned top-level window
p56656
aVAnd so it appears on the taskbar whenever it is visible
p56657
aVSo you can remove the main form from the taskbar simply my hiding it
p56658
aVThe other forms in your application will be owned top-level windows
p56659
aVTypically they will be owned by your main form
p56660
aVBy virtue of being owner, they will not appear on the taskbar
p56661
aVBy and large you should try hard to avoid fiddling with window styles
p56662
aVYou can usually make your application behave the way you need without doing so
p56663
aVWhat's more, if ever you have to adjust window styles, you must do it in
p56664
aVThat way the window style will persist when the window gets re-created
p56665
aVBut I re-iterate, avoid modifying window styles where you can
p56666
aVThe key MSDN references are:
p56667
aVWindow Features
p56668
aVThe Taskbar
p56669
aVHere's the smallest program I can produce that proves the point:
p56670
aVIn the comments you make it clear that you want to be able to hide the taskbar window without hiding the main form
p56671
aVIn that case I suggest that you set  to
p56672
aVThat will mean that  will be the window associated with the taskbar button
p56673
aVYou can then hide that window to remove it from the taskbar
p56674
aVYou will now need to explicitly set  for any auxiliary forms
p56675
aVIf you want those windows to be owned by the main form, then you can set it up
p56676
aVHere's my example adjusted for this scenario:
p56677
aVRun this program and click on the toggle button
p56678
aVNow you will see main form and other form showing
p56679
aVAnd nothing in the taskbar
p56680
aVI included the toggle button to show that you can switch between your two modes of operation whilst the program is running
p56681
aVNo need to restart it
p56682
aVThe key here is to make a window other than your visible forms be the window associated with the taskbar
p56683
aVOnce you do that you can once again control taskbar presence by showing and hiding that window
p56684
aVIn this case that window is the application window,
p56685
aVBecause that's the window on the taskbar, you need to set its  property to control its text
p56686
aVI stress finally, once again, that interaction with the taskbar is best controlled with window owner and visibility
p56687
aVAlways search for solutions using those methods rather than , extended window styles etc
p56688
aVUpdate
p56689
aVHopefully the last word on the subject
p56690
aVAs you have noticed, the code directly above has poor behaviour when the main form is minimised
p56691
aVWhen that happens, the application window is made visible again and so appears once more in the taskbar
p56692
aVI'm not so sure of myself when it comes to suppressing this behaviour
p56693
aVThe behaviour comes about because of the code in  which shows the application handle when the main form is minimized
p56694
aVThe best solution that I have is to convert a main form minimize into a hide
p56695
aVOr another way would be to suppress the application window show by means of an  event handler for
p56696
as(dp56697
g7
V505088
p56698
stp56699
a((dp56700
g2
(lp56701
VFirst of all I question whether or not you have chosen the correct type to represent your data structure
p56702
aVYou say your type is
p56703
aVBut it looks like the inner array always has exactly two elements, the first an integer, and the second a string
p56704
aVIn that case the inner array should be replaced with a record
p56705
aVAnd now you just have a one dimensional array
p56706
aVI assume you have no difficulty sorting one of those
p56707
aVBut suppose that you really did need a multi-dimensional array
p56708
aVSuppose that the array was ragged, i
p56709
ag192
aVthat different inner arrays had different lengths
p56710
aVYou can still view that array as a one-dimensional array
p56711
aVDeclare it like this:
p56712
aVNow you can sort  just as if it were a one-dimensional array
p56713
aVNote that I needed to declare a type for the inner array
p56714
aVThe reason being that the sort function needs to be able to compare and exchange elements of the outer array
p56715
aVSo you'll need functions to do that
p56716
aVAnd you need to define a type to achieve that
p56717
aVFor example, your exchange function might look like this:
p56718
aVWithout defining , this would not be possible
p56719
aVThat's because of the rather stringent assignment compatibility rules for dynamic arrays
p56720
aVYou can extend to as many dimensions as you like:
p56721
aVAgain, you can use your standard array sort to sort this three dimensional version of
p56722
as(dp56723
g7
V505088
p56724
stp56725
a((dp56726
g2
(lp56727
V does not support folder selection at all
p56728
aVYour options are:
p56729
aVwhich is available on Windows 2000 and later, but looks a bit ugly
p56730
aVwhich is the platform native folder chooser, but only available on Vista or later
p56731
aVTo make the dialog behave as a folder picker, pass  to
p56732
aVIn my opinion the best result for the user is to use  where available, but fall back to  for older operating systems
p56733
as(dp56734
g7
V505088
p56735
stp56736
a((dp56737
g2
(lp56738
VThe documentation that you have linked to is for the generic container  from the  unit
p56739
aVBut the class that you have used in your code is the legacy non-generic container  from the  unit
p56740
aVThe  method that you are trying to use only exists on the generic class
p56741
aVIf you switch to the generic container then you'll find that you can remove most of the boiler-plate code from your class
p56742
aVIt becomes:
p56743
aVYou don't need ,  and  because the type-safe generic class already has that functionality sorted
p56744
aVThe only work you have to do is to adapt your sorting code to fit with the somewhat different interface used by the Delphi generic containers
p56745
as(dp56746
g7
V505088
p56747
stp56748
a((dp56749
g2
(lp56750
VI have defined critical sections for each of the threads including the main thread
p56751
aVThat's not how it works
p56752
aVYou need to have a single shared critical section object
p56753
aVEach thread must use the same critical section in order for the serialization to work
p56754
aVYou need to have a one-to-one relationship between critical section objects and resources that need protection
p56755
aVFrom the documentation:
p56756
aVA critical section object can be owned by only one thread at a time, which makes it useful for protecting a shared resource from simultaneous access
p56757
as(dp56758
g7
V505088
p56759
stp56760
a((dp56761
g2
(lp56762
VLook at this line:
p56763
aVWhen you cast it to  you are truncating a 16 bit value into 8 bits and so lose
p56764
aVYou should cast to a 2 byte value,
p56765
aVThat said, it might be easier just to return your two bytes in an array
p56766
aVLike this:
p56767
aVIf I were you I would separate the bitwise manipulations and the conversions to and from string
p56768
aVThe way you have it in your question mixes the two concerns
p56769
as(dp56770
g7
V505088
p56771
stp56772
a((dp56773
g2
(lp56774
VIt may be faster to write directly to a stream
p56775
aVOr it may not
p56776
aVI suggest you try it out and time both options
p56777
aVWriting to a stream looks like this:
p56778
aVTo have any hope of this version being fast, you need to use a buffered stream
p56779
aVTry this one: Buffered files (for faster disk access)
p56780
aVThe code above will output UTF-16 text on modern Delphi
p56781
aVIf you want to output ANSI text simply declare  as
p56782
aVI'll let you do the timing, but my guess is that this variant performs similarly to the string list
p56783
aVI suspect that the time is spent calling  and
p56784
aVI expect that the file saving with the string list is already very fast
p56785
aVPutting speed to one side, there is another benefit of this approach
p56786
aVIn the string list approach, as per the code in the question, the entire content of the text file is stored in memory
p56787
aVAnd when you save the file, another copy is made as part of the save procedure
p56788
aVSo you will have two copies of the entire file in memory
p56789
aVIn contrast, when saving directly to a stream, the only memory requirement is whatever buffer your stream class uses
p56790
aVFor a 50MB file as per the question there's likely no real problem with either approach
p56791
aVFor a much larger file then you will run into out of memory errors if you try to hold the entire file in memory
p56792
aVPersonally though, I'd consider making use of the  class
p56793
aVThis useful class separates the concerns of writing data (text, values etc
p56794
aVfrom the concern of pushing to a stream
p56795
aVYour code would become:
p56796
aVThe  implements buffering with a 1KB buffer so you can use  and expect to get reasonable performance
p56797
aVI would recommend that you choose the technique that leads to the most readable code
p56798
aVIf performance becomes an issue you can optimise that later
p56799
aVMy personal preference would be for
p56800
aVThis gives very clean and readable code, yet also excellent separation of content generation from streaming
p56801
aVThe performance is perfectly reasonable also
p56802
as(dp56803
g7
V505088
p56804
stp56805
a((dp56806
g2
(lp56807
VI would consider using a binary writer for this task
p56808
aVThis is a higher level class that takes care of the details of getting data into the stream
p56809
aVI expect that your real problem is more involved than this
p56810
aVThe benefit of using the writer class is that you insulate yourself from the gory details of spewing data to the stream
p56811
as(dp56812
g7
V505088
p56813
stp56814
a((dp56815
g2
(lp56816
g23719
aVtheme file contains customisation settings for an entire desktop
p56817
aVIt is of no use for your goals
p56818
aVWindows does not perform per application theming
p56819
aVThat requires custom drawing from the application, or third party add-ons like Window Blinds
p56820
aVThe easiest way to theme your app is to upgrade to the lates Delphi and use VCL styles, the feature introduced in XE2
p56821
as(dp56822
g7
V505088
p56823
stp56824
a((dp56825
g2
(lp56826
VAggPas is not capable of reading PDF files
p56827
as(dp56828
g7
V505088
p56829
stp56830
a((dp56831
g2
(lp56832
VYou have not set the window ownership properly because you are using the no parameter version of
p56833
aVYou need to set the owner by calling the  overload that receives an owner parameter
p56834
aVAlternatively you can set the  property directly, but it's much better to do so when you call
p56835
aVThe window owner is an important Win32 concept
p56836
aVI recommend reading the MSDN documentation on the subject
p56837
aVAn owned window is always above its owner in the z-order
p56838
aVThe system automatically destroys an owned window when its owner is destroyed
p56839
aVAn owned window is hidden when its owner is minimized
p56840
aVIn your case I think you want form A to be owned by your main form, and form B to be owned by form A, and form C to be owned by form B
p56841
as(dp56842
g7
V505088
p56843
stp56844
a((dp56845
g2
(lp56846
VAt designtime you can effect the change by editing the
p56847
aVdfm file manually
p56848
aVMake sure that the form is saved with the  property set to
p56849
aVThen, close your project in Delphi, or close Delphi altogether
p56850
aVNext open the
p56851
aVdfm file in a text editor and adjust the forms  property
p56852
aVFor example, if you want to scale from 7pt to 8pt, and  is set to , then you should change it to
p56853
aVThen re-load the project and open the form in the designer and your form will be scaled
p56854
aVThis won't be a perfect scaling because you aren't allowed floating point values for
p56855
aVBut it may be good enough
p56856
aVAt runtime, you can to call :
p56857
aVNote that  is a protected member
p56858
aVSo, depending on where you are calling this, you may need to use the protected member hack
p56859
aVOne option then would be to call the form persistence framework at runtime to generate a scaled version of the
p56860
aVdfm file
p56861
aVThat would allow you more precise control than playing tricks with
p56862
aVFor example, you can attach the following to the  event of your form:
p56863
aVThis will generate a new
p56864
aVdfm file based on the runtime state
p56865
aVYou can then compare this with the version of the
p56866
aVdfm file that is in your revision control system
p56867
aVThere will be a few changes that you won't want to accept, but mostly the changes will be the position and size changes that you do want
p56868
as(dp56869
g7
V505088
p56870
stp56871
a((dp56872
g2
(lp56873
VThe main implication of not having  is that your application won't be accepted for the Windows 8 store, or for Windows 8 desktop certification
p56874
aVIf that's not an issue for you then feel free to use
p56875
aVThe documentation says:
p56876
aVThe most common reason for the linker not to be able to produce an image is because one or more of the input files (modules) to the linker was not compatible with the safe exception handlers feature
p56877
aVA common reason for a module to not be compatible with safe exception handlers is because it was created with a compiler from a previous version of Visual C++
p56878
aVIs it possible that the project upgrade to VS2012 changed the setting to
p56879
aVPerhaps you've never been building with
p56880
as(dp56881
g7
V505088
p56882
stp56883
a((dp56884
g2
(lp56885
VOne option is to put a  command as the first line of your
p56886
aVbat file
p56887
aVYou could change the working directory of the calling process, but that's using a hammer to crack a nut
p56888
aVIf you move away from the  function you can call
p56889
aVThat allows you to specify all the gory details you need when creating a new process
p56890
aVYou need to run the command interpreter (find that by reading the  environment variable)
p56891
aVYou can specify the working directory for the new process as one of the parameters to
p56892
aVis rather hard to call though
p56893
aVAnd it won't help you with requesting elevation to admin rights
p56894
aVInstead you can use
p56895
aVCall that passing  for the verb, which will result in elevation
p56896
as(dp56897
g7
V505088
p56898
stp56899
a((dp56900
g2
(lp56901
VThat error is the Win32 error
p56902
aVIt's generated by the loader and is what happens when you try to run a 64 bit process on a 32 bit operating system
p56903
aVThere are other ways to see that error, but this is by far the most common reason for it to occur on a
p56904
aVexe file
p56905
aVTo compile a 32 bit process you need to target x86 in your project configuration
p56906
aVAnother alternative would be to target AnyCPU
p56907
aVThat will result in a 32 bit process when executed on a 32 bit OS, and a 64 bit process when executed on a 64 bit OS
p56908
aVIt would appear that your build targets x64
p56909
as(dp56910
g7
V505088
p56911
stp56912
a((dp56913
g2
(lp56914
VAs this program proves, the  event does fire when the control is sent a  message
p56915
aVNote that this original version of the answer was overly complex and used a  like this:
p56916
aVand consequently had to perform manual marshalling:
p56917
aVComments at this question (Automatic casting for string DllImport arguments vs Marshal
p56918
aVStringToCoTaskMemUni) persuaded me to update
p56919
as(dp56920
g7
V505088
p56921
stp56922
a((dp56923
g2
(lp56924
VDo what the documentation says, and call  to find out the reason behind the error
p56925
aVSome possible causes spring to mind:
p56926
aVdoes not like forward slashes as separators
p56927
aVThe system doesn't like
p56928
aVpng files for wallpaper
p56929
aVThe file doesn't exist
p56930
aVYou have an ANSI/Unicode encoding mismatch
p56931
aVYou don't have rights to modify the wallpaper
p56932
aVReally, the list is endless
p56933
aVSo let the system tell you
p56934
aVNote that the documentation says:
p56935
aVWhen the  flag is used,  always returns
p56936
aVBut this is a great big fat lie
p56937
aVIt's trivially easy to call the function, pass , and receive  in return
p56938
as(dp56939
g7
V505088
p56940
stp56941
a((dp56942
g2
(lp56943
VYou can get hold of the arguments by calling :
p56944
aVAnd then you can iterate through this array just like you would any other array
p56945
aVRemember that the first item in the array is the file name of the executing program
p56946
as(dp56947
g7
V505088
p56948
stp56949
a((dp56950
g2
(lp56951
VI suggest you consult the sources of the WINE project which will contain exactly what you need
p56952
as(dp56953
g7
V505088
p56954
stp56955
a((dp56956
g2
(lp56957
VOn the 64 bit compiler the actual value of  is:
p56958
aVThat's because the cast to  makes  into a negative number
p56959
aVAnd then the conversion to unsigned leads to
p56960
aVNote that this value is correct
p56961
aVThe declaration in the windows header file is:
p56962
aVand when you include the header file and inspect the value of  in a C++ program, it is the exact same value as for the Delphi declaration
p56963
aVAnd then we can solve the puzzle from the Delphi documentation which states that the selectors in a case statement can only be:
p56964
aVany expression of an ordinal type smaller than 32 bits
p56965
aVYou have no choice but to replace your  statement with an  statement
p56966
as(dp56967
g7
V505088
p56968
stp56969
a((dp56970
g2
(lp56971
VI don't believe that you can reasonably expect to make the change that you want without modifying the original component
p56972
aVLet's take your vehicle kind example and delve a bit deeper
p56973
aVI expect that the original component will have code like this:
p56974
aVNow, suppose you introduce an enumerated type with an extra enumeration
p56975
aVIf the case statement above runs, with  equal to , no method will be called
p56976
aVNow, perhaps the behaviour that you want from the original control can be achieved by setting  to  or  when  is
p56977
aVBut that seems unlikely to me
p56978
aVOnly you can know for sure, because only you have the code, and know what your actual problem is
p56979
as(dp56980
g7
V505088
p56981
stp56982
a((dp56983
g2
(lp56984
VFirst of all I would like to comment that your question misses some very important details
p56985
aVNamely that you do not actually give any information as to how your code is failing
p56986
aVAll you say is:
p56987
aVI've been trying to P/Invoke RegSaveKey to no avail
p56988
aVQuestions like this one are all about the details
p56989
aVWe need to see precise and detailed error diagnostics
p56990
aVRemember that we cannot see your screen
p56991
aVYou need to pay more attention to the return values from API calls
p56992
aVYou are checking the return value of  against zero, but that's all
p56993
aVYou need to capture and inspect the value returned by
p56994
aVThat's an error code
p56995
aVYou can throw a  if the error code is not equal to zero
p56996
aVChange the code to throw  and you will at least get some informative text when the error occurs
p56997
aVSo, if  is failing, you will at least find out why
p56998
aVAnd you aren't checking the other API calls at all
p56999
aVGive them the same treatment
p57000
aVThere are really very few failure modes for your call to
p57001
aVThe only plausible explanation that I can concoct is that the registry key does not exist
p57002
aVI expect that you already checked that
p57003
aVBut watch out for the registry redirector
p57004
aVIf your process is a 32 bit process running on 64 bit OS, then the redirector will take you to the  section of the registry, the 32 bit view
p57005
aVPerhaps what you mean by "to no avail" is that information is saved to the file, but it's the wrong information
p57006
aVThat would be consistent with the registry redirector confusing you
p57007
aVIf that's what is biting you then include the  flag when calling
p57008
aVOr target x64
p57009
aVIt would be a lot easier to use  to open the key
p57010
aVI understand that you can't readily call  so you still need to p/invoke that
p57011
aVBut  exposes a  property that you can pass to
p57012
aVThere's one proviso to this
p57013
aVIf you do need to use the  flag then that requires the
p57014
aVnet 4 and
p57015
aVAs for , I defer to the information given by Stephen in his answer
p57016
as(dp57017
g7
V505088
p57018
stp57019
a((dp57020
g2
(lp57021
VYou are sending the message to the main window handle
p57022
aVThat's the handle of the instance of
p57023
aVBut your window procedure is attached to a different window handle, the window handled created by your call to
p57024
aVA simple fix would be to override  in  rather than using
p57025
aVOr as Mason says, you can use the special message handling syntax of Delphi:
p57026
aVIt's also possible that  is not even the handle to your main window
p57027
aVIf you are using an older version of Delphi then  may locate the application's handle,
p57028
aVIn which case you will need  or  in your C# code to locate the desired window
p57029
aVAlso, your code would be clearer if you declared the message constant using hex in Delphi:
p57030
as(dp57031
g7
V505088
p57032
stp57033
a((dp57034
g2
(lp57035
VSince your comment gave me carte blanche to suggest an alternative solution, here's what I would do:
p57036
aVStop using
p57037
aVIt leads to lots of visual oddities in lots of controls
p57038
aVI personally avoid it like the plague
p57039
aVSolve your flickering problem by adding the  extended window style to your control
p57040
aVThis window style can be a bit of a performance drag and I'd recommend that you only add this during the sizing loop, which is when you need it
p57041
aVI describe how to do that in my answer here: TLabel and TGroupbox Captions Flicker on Resize
p57042
as(dp57043
g7
V505088
p57044
stp57045
a((dp57046
g2
(lp57047
VThe message box is a modal dialog which pumps the message queue
p57048
aVAnd so that allows for the timer tick messages to fire, since they are posted to the GUI thread's message queue
p57049
aVThis is always the case for a modal dialog that is shown in the GUI thread
p57050
aVSince each thread has only one message queue, the modal dialog's message pump will pull of the timer tick messages
p57051
as(dp57052
g7
V505088
p57053
stp57054
a((dp57055
g2
(lp57056
VThere is no assembler code associated with
p57057
aVdfm form files
p57058
aVThe properties in the
p57059
aVdfm file will be turned into a binary
p57060
aVdfm resource and then linked to the executable
p57061
aVAt runtime the form persistence code loads the resource and processes its contents dynamically using RTTI
p57062
aVUse a resource editor to see more
p57063
aVThe form resources will appear under RCData | TMyForm for a form class named
p57064
aVYou can then extract the resource from the executable and save it to disk
p57065
aVUse the  utility supplied with Delphi to convert it to text, passing  to do that
p57066
aVThen edit the text
p57067
aVdfm
p57068
aVThen convert it back to binary using the  option to convert
p57069
aVThen update the executable and you are done
p57070
aVAnd @Remy points out a much simpler solution
p57071
aVUse a resource editor that supports Delphi
p57072
aVdfm files, for example XN Resource Editor
p57073
aVThat wraps up and shields you from all the details above
p57074
as(dp57075
g7
V505088
p57076
stp57077
a((dp57078
g2
(lp57079
VThe error code 0xc000007b is STATUS_INVALID_IMAGE_FORMAT
p57080
aVThe most common cause for that is when the loader attempts to load a 32 bit DLL into your 64 bit process
p57081
aVUse Dependency Walker in profile mode to find out which DLL is at fault
p57082
as(dp57083
g7
V505088
p57084
stp57085
a((dp57086
g2
(lp57087
VThe obvious way in which your call to  could be wrong is that your C# code will pass UTF-16 Unicode text, but perhaps the native library expects 8 bit ANSI
p57088
aVWe can't tell because we don't know what  expands to
p57089
aVIf that's it then you'll need to pass an  to  and convert to ANSI manually
p57090
aVUse
p57091
aVto convert to a null terminated ANSI string, stored in a byte array
p57092
aVAnd then copy that to a null-terminated string allocated on the unmanaged heap
p57093
aVYou can then pass that on to
p57094
aVWhen you are done with the memory, deallocate it with
p57095
aVThe other problem is
p57096
aVAlmost certainly that returns a pointer to a string that is allocated in the library
p57097
aVSo you'd need to declare the return value as , and use the  class to convert into a C# string
p57098
aVYour code is going to result in an attempt by the p/invoke marshaller to deallocate the block of memory returned by  and I'm sure that's not what you want
p57099
as(dp57100
g7
V505088
p57101
stp57102
a((dp57103
g2
(lp57104
VYour approach is sound, but I don't see that you need to cast, or indeed declare an enumerator class
p57105
aVI'd do it like this:
p57106
as(dp57107
g7
V505088
p57108
stp57109
a((dp57110
g2
(lp57111
VYou cannot hope to achieve differently coloured taskbar buttons
p57112
aVYou could install your own shell and take complete control of the taskbar, but you can't expect your clients to do that
p57113
aVYou cannot expect to paint over the top of the Windows taskbar
p57114
aVThe taskbar is animated
p57115
aVHow are you going to keep up with that
p57116
aVHow are you going to even know where the buttons are
p57117
aVI don't believe that there is a public API that will tell you that
p57118
aVI think you have to rule that idea out
p57119
aVThere is an API that allows you to change the colour of a taskbar button
p57120
aVIt's the taskbar progress API added in Windows 7
p57121
aVYou could use that to make your taskbar buttons yellow, green or red
p57122
aVI personally would not recommend that since the user will think you are showing progress
p57123
aVThe main options that are available to you are to change the window caption, and so the text that appears in the taskbar button
p57124
aVOr to change the icon
p57125
as(dp57126
g7
V505088
p57127
stp57128
a((dp57129
g2
(lp57130
VWhen maximized windows were originally implemented, the designers wanted to remove the resizing borders
p57131
aVRather than removing them, they instead decided to draw those borders beyond the edges of the screen, where they would not be seen
p57132
aVHence the rather surprising window rectangle of a maximized window
p57133
aVThis implementation decision became a problem with the advent of multi-monitor systems
p57134
aVBy that time there were applications that relied on this behaviour and so the Windows team decided to retain the behaviour for the sake of compatibility
p57135
aVThis meant that maximized windows leaked onto neighbouring screens
p57136
aVIn time the window manager acquired capabilities that meant it could suppress that leakage
p57137
aVRaymond Chen, as usual, has an article that covers the details: Why does a maximized window have the wrong window rectangle
p57138
as(dp57139
g7
V505088
p57140
stp57141
a((dp57142
g2
(lp57143
VThere is no single official list of Windows API functions that details which ones raise SEH exceptions
p57144
aVYou need to check each and every function that you call
p57145
as(dp57146
g7
V505088
p57147
stp57148
a((dp57149
g2
(lp57150
VYou are calling  which shows the dialog modally
p57151
aVWhen a modal dialog is shown, the other owning windows are disabled and only the modal dialog can accept input
p57152
aVThat is the very essence and intent of a modal dialog
p57153
aVThe idea is that you can interact only with the dialog, and cannot interact with the other windows
p57154
aVAnother answer suggests passing  as the  parameter to
p57155
aVThat's not the solution
p57156
aVThat will result in you having an unowned window
p57157
aVYes, you will be able to interact with the main window, but when you do so your main window will appear on top of the dialog
p57158
aVThat's because the ownership is set incorrectly
p57159
aVI recommend that you read about window ownership to better understand the issue
p57160
aVThe correct solution to your problem is to show a modeless dialog
p57161
aVA modeless dialog allows you to interact with the other windows in your application
p57162
aVAnd that's exactly what you ask for in the question
p57163
aVYou show modeless dialogs by calling  followed by
p57164
aVThis MSDN article shows an example: Using Dialog Boxes
p57165
as(dp57166
g7
V505088
p57167
stp57168
a((dp57169
g2
(lp57170
VThis is just down to the inherent inaccuracy of floating point arithmetic
p57171
aVTwo of your values are not exactly representable in binary floating point,  and
p57172
aVSo, those numbers are approximated by the closest representable values
p57173
aVAnd that means that it's quite plausible that your equation won't evaluate to exactly
p57174
aVNow consider your two expressions:
p57175
aVThe difference between these two is that  is evaluated at compile time and  is evaluated at runtime
p57176
aVNow, it's down to the compiler how the constant expression  is evaluated
p57177
aVTo the best of my knowledge, it's not documented how that will be evaluated
p57178
aVHowever, it is clear that the compiler uses a different evaluation method to evaluate the constant expression from that used at runtime
p57179
aVThis program illustrates that:
p57180
aVOutput:
p57181
ag25124
aV8
p57182
aVTrue
p57183
aVFalse
p57184
aVTrue
p57185
aVSo, this shows that  and  have different values, and that  is strictly greater than
p57186
aVThe fundamental problem you have is that of representably of floating point values
p57187
aVBecause you are using , which uses a binary representation, your decimal input values are not exactly representable
p57188
aVIf you want exact arithmetic here, you will need to use a decimal representation
p57189
aVAs always when answering variants of this question, I refer you to the essential reading on the subject: What Every Computer Scientist Should Know About Floating-Point Arithmetic
p57190
as(dp57191
g7
V505088
p57192
stp57193
a((dp57194
g2
(lp57195
VAs soon as you return the address to the system, any future reference of that address is invalid
p57196
aVOnce you have made the successful call to , you must not refer to  again
p57197
aVOnce you have returned the address to the system, the system owns it
p57198
aVThe only way for that address to become valid in the future, is through another call to
p57199
as(dp57200
g7
V505088
p57201
stp57202
a((dp57203
g2
(lp57204
VYou don't need to export any functions at all from your DLL
p57205
aVYou can just use the DLL's module handle directly from your host executable
p57206
aVYou are already passing a module handle to the resource stream constructor
p57207
aVYou are passing the module handle of the executable
p57208
aVInstead, pass the module handle of the library
p57209
aVIf you don't want to call any functions in the DLL, if it is a resource only DLL, then use  and  instead:
p57210
aVPerhaps you know that the the DLL is already loaded
p57211
aVFor example, it is linked to your executable implicitly
p57212
aVIn that case you can more simply use  rather than  or
p57213
aVNote that I omitted all error checking for the sake of a simple exposition
p57214
as(dp57215
g7
V505088
p57216
stp57217
a((dp57218
g2
(lp57219
VAlignment and padding for structs and classes is not specified by the standard
p57220
aVIt's entirely down to the compiler
p57221
aVHowever, all sane compilers follow the underlying platform ABI
p57222
aVIn your case the platform is Windows, and the Windows platform ABI is adhered to
p57223
aVThe padding in this case, for both structs, is after the last member
p57224
aVThe first struct has one extra padding byte, and the second struct has three extra padding bytes
p57225
aVThe largest type in the struct has size 4
p57226
aVAnd that means that the overall size will be a multiple of 4
p57227
aVFor both structs, the smallest multiple of 4 that accommodates the struct is 8
p57228
aVEach data type has an alignment property
p57229
aVA 4 byte data type has alignment of 4
p57230
aVA 2 byte data type has an alignment of 2
p57231
aVA type with alignment of 4 is aligned when placed on a 4 byte offset from the start of the struct
p57232
aVA type with alignment of 2 is aligned when placed on a 2 byte offset from the start of the struct
p57233
aVAnd so on
p57234
aVMembers are placed at the smallest offset that respects both the order of declaration of members, and the alignment property of the members
p57235
aVFor an example with padding internal to the struct consider this struct
p57236
aVThe alignment of  is 1, and the alignment of  is 4
p57237
aVSo,  is placed on a 1 byte boundary, and  must be placed on a 4 byte boundary
p57238
aVThat means that  will have offset 0, then there will be 3 padding bytes, and then  will be laid out at an offset of 4
p57239
as(dp57240
g7
V505088
p57241
stp57242
a((dp57243
g2
(lp57244
VI believe that you are over-thinking this
p57245
aVThere's no need for your loop and the framework already provides convenience methods that do exactly what you want
p57246
aVI'd write the code like this:
p57247
aVI guess your question about preserving the spacing was motivated by the fact that your loop doesn't preserve line breaks
p57248
aVThat's yet another reason for using the built-in framework
p57249
aVLet it take the strain and get the details right
p57250
as(dp57251
g7
V505088
p57252
stp57253
a((dp57254
g2
(lp57255
VElevation can only be performed at the time of process creation
p57256
aVSo you need a new process to execute this code
p57257
aVYour main options:
p57258
aVCall ShellExecute passing the verb runas and an exe file
p57259
aVThis will elevate the new process
p57260
aVAdd the requireAdministrator manifest to an executable and run that
p57261
aVUse an out-of-proc COM server and initiate it elevated
p57262
aVOf these options, number 1 is likely to be simpler for you
p57263
aVYou don't need a separate executable for option 1
p57264
aVYou can pass command line arguments that will result in the call to the registration function
p57265
as(dp57266
g7
V505088
p57267
stp57268
a((dp57269
g2
(lp57270
VYou should add exception logging to your application
p57271
aVFor example EurekaLog or madExcept
p57272
aVI personally use the latter and cannot recommend it highly enough
p57273
aVOnce you have the exception logging tool added to your project, any unhandled exceptions will result in a comprehensive bug report including stack traces for your threads
p57274
as(dp57275
g7
V505088
p57276
stp57277
a((dp57278
g2
(lp57279
VI'm not going to answer your question directly because I think you've asked the wrong question
p57280
aVYou are trying to download files over the internet without any GUI being shown to the user
p57281
aVAs such, an embedded browser is simply the wrong solution
p57282
aVRather than trying to suppress popup dialogs, use a tool that never shows popup dialogs
p57283
aVWhat I believe you should be doing is downloading the files using direct HTTP download
p57284
aVThere are many different ways to achieve that
p57285
aVFor example, an extremely convenient method, available out of the box with Delphi, is to use Indy
p57286
aVI believe that the component you need is
p57287
as(dp57288
g7
V505088
p57289
stp57290
a((dp57291
g2
(lp57292
VIf something in your program refers to the object then the linker cannot remove it
p57293
aVSo you can take advantage of this like this:
p57294
aVThen in your initialization section you can write this:
p57295
aVAll you need to do is refer to the object
p57296
aVYou don't need to call the function, or read/write the variable, just take its address
p57297
as(dp57298
g7
V505088
p57299
stp57300
a((dp57301
g2
(lp57302
VThere is simply no way to specify that you want just specific elements initialized
p57303
aVThe initializer for a global array variable is simply a list of elements
p57304
aVThe elements are specified in order
p57305
aVAny unspecified elements are set to default values,  in your case
p57306
aVBecause the list is processed in order, it follows that unspecified elements must be those at the end of the array
p57307
aVIn order to do that you must write those initializations in code
p57308
aVNaturally you can pick any element you like in the code
p57309
aVIf you wish the initialization to be carried out as program startup time then you must invoke the initialization code from an initialization section
p57310
as(dp57311
g7
V505088
p57312
stp57313
a((dp57314
g2
(lp57315
VI used to use this component way back when
p57316
aVAs I recall, registering the OCX only gives you runtime support
p57317
aVTo get it all working at designtime you need to run, on your dev machine, the installation program that the vendor supplied
p57318
aVI also distinctly remember that there was a
p57319
aVlic file installed onto each developer machine
p57320
aVSo you should find them on the old machines, but I'm not sure whether they can be easily transferred
p57321
as(dp57322
g7
V505088
p57323
stp57324
a((dp57325
g2
(lp57326
VYou could create a dictionary, , and store it in a global variable
p57327
aVLoad it up with the name to width mapping at initialization time
p57328
aVAnd then your function becomes a one-liner
p57329
as(dp57330
g7
V505088
p57331
stp57332
a((dp57333
g2
(lp57334
VYou can use :
p57335
aVFrom the documentation:
p57336
aVTrims leading and trailing spaces and control characters from a string
p57337
aVPerhaps you only want to trim from the end of the string
p57338
aVIn which case use
p57339
aVAnd for completeness there is also  for those times when you only want to trim from the start of the string
p57340
as(dp57341
g7
V505088
p57342
stp57343
a((dp57344
g2
(lp57345
VI'm going to first of all assume that the XML parser operates correctly
p57346
aVIf it is incapable of reading files, well the solution is obvious
p57347
aVWhich leads us to look at how the file is created
p57348
aVWhen you call SaveToFile, the file is opened, written, closed and buffers are flushed
p57349
aVIn a plain vanilla system, your XML parser will see the entire content of the file
p57350
aVThe only conclusion is that something is interfering
p57351
aVThe most like suspect is your virus scanner
p57352
aVMany scanners, even the most respected ones, cannot properly handle a file being closed and then immediately re-opened
p57353
aVThe bottom line is that your code is fine and the problem almost certainly lies with your local environment
p57354
as(dp57355
g7
V505088
p57356
stp57357
a((dp57358
g2
(lp57359
VYou are mixing CLX and VCL
p57360
aVYour button is the CLX , but your form is a VCL form
p57361
aVI don't know whether you want your app to be a VCL app or a CLX app, but whichever it is, you need all the parts of your app to come from the same framework
p57362
aVMy guess is that you want a VCL app
p57363
aVAnd somehow you have used , the CLX unit, rather than , the VCL unit
p57364
aVAnd that's why you are getting the CLX version of
p57365
aVSo, assuming I'm guessing right, simply change  to  and your code will compile
p57366
as(dp57367
g7
V505088
p57368
stp57369
a((dp57370
g2
(lp57371
VYou can do it like this:
p57372
aVMake an  property
p57373
aVTest that property in  and switch behaviour accordingly
p57374
aVCall  whenever the property changes
p57375
aVInstead of item 3 you may be able to simply change the window style with a call to
p57376
aVDo make sure that you test  before attempting to do this
p57377
aVNo point forcing the window to be created needlessly
p57378
aVHowever, you presumably also need to force a paint cycle whenever this happens
p57379
aVPersonally, I think I'd be inclined to force window recreation
p57380
as(dp57381
g7
V505088
p57382
stp57383
a((dp57384
g2
(lp57385
VCreate a page control,
p57386
aVAdd 7 pages
p57387
aVCreate your 7 forms
p57388
aVAdd each form into its tabsheet
p57389
aVThe final step is as follows:
p57390
aVSince you are doing this for 7 forms and 7 tabsheets, you'll want to do it in an array, and extract the code above into a method
p57391
as(dp57392
g7
V505088
p57393
stp57394
a((dp57395
g2
(lp57396
VDeclare the string parameter as StringBuilder:
p57397
aVNo need to repeat the default value of CharSet, and these API functions don't use the Win32 last error mechanism
p57398
as(dp57399
g7
V505088
p57400
stp57401
a((dp57402
g2
(lp57403
VYou are calling the  method of  which receives a single parameter of type
p57404
aVYou need to concatenate a string and an integer
p57405
aVIn order to do so you must convert the integer into a string
p57406
aVYou attempted to do that using  which is a perfectly reasonable approach
p57407
aVBut that failed because the compiler could not locate
p57408
aVNow,  is declared in the  unit and so you must add that unit to your  clause
p57409
aVHowever, I'd probably use  here
p57410
aVLike , this function is declared in  which you must use
p57411
aVFor more details on format read the documentation for format strings
p57412
as(dp57413
g7
V505088
p57414
stp57415
a((dp57416
g2
(lp57417
VYou are not checking the return value of
p57418
aVYou must do so, and only go on to read values if  returns
p57419
aVI suspect that some of these keys do not exist
p57420
aVYou then ignore the  that comes back from  and try to read a value anyway
p57421
aVThat will lead to exceptions being raised
p57422
aVSo your function should be like so:
p57423
aVPersonally I'd use  because I feel it is more explicit
p57424
aVI realise that you are using  as your  value which is the same as
p57425
aVI just feel that  makes it easier for the human reader to verify intent
p57426
as(dp57427
g7
V505088
p57428
stp57429
a((dp57430
g2
(lp57431
VIt's easy enough to work this out from the code
p57432
aVYou just do a text search for
p57433
aVFor example using the IDE's Find in Files feature
p57434
aVBut you can always be lazy and get the debugger to do it
p57435
aVEnable Debug DCUs
p57436
aVSet a breakpoint in
p57437
aVRun
p57438
aVWhen the program breaks, look at the call stack
p57439
aVYou will see that the  object is instantiated from  in the  unit
p57440
aVAnd  is called from the  section of the  unit
p57441
aVThe full call stack for a plain vanilla VCL app looks like this:
p57442
aVVcl
p57443
aVForms
p57444
aVTApplication
p57445
aVCreate(nil)
p57446
aVVcl
p57447
aVControls
p57448
aVInitControls
p57449
aVVcl
p57450
aVControls
p57451
aVVcl
p57452
aVControls
p57453
aVSystem
p57454
aVInitUnits
p57455
aVSystem
p57456
aV_StartExe(
p57457
ag7012
aVSysInit
p57458
aV_InitExe($5A81BC)
p57459
aVProject1
p57460
aVProject1
p57461
aV:749933aa kernel32
p57462
aVBaseThreadInitThunk + 0x12
p57463
aV:76f09ef2 ntdll
p57464
aVRtlInitializeExceptionChain + 0x63
p57465
aV:76f09ec5 ntdll
p57466
aVRtlInitializeExceptionChain + 0x36
p57467
aVDoing the same thing with , you will see that the  object is also instantiated in
p57468
aVI won't try and explain all of this
p57469
aVI think there's enough information and advice here for you to work it all out from here
p57470
aVAlthough this is the call stack from an XE3 application, it will look just the same for your Delphi 5 application
p57471
as(dp57472
g7
V505088
p57473
stp57474
a((dp57475
g2
(lp57476
VThe current directory is set as part of process startup
p57477
aVOnce the process starts it is at liberty to change its current directory as it pleases
p57478
aVThe current directory is specified as a parameter to , and indeed any of the other similar API functions that are used to create processes
p57479
aVIt is quite common to pass  for the current directory of the new process
p57480
aVIn that case the current directory of the parent process is used
p57481
aVSo, looking at your specific questions:
p57482
aVWhy is that so
p57483
aVIf the current directory for your process is , that's because whatever started the process chose to make it so, or your process elected to make it so
p57484
aVIs it always the case
p57485
aVNo, both the process creator and the process itself are free to set the current directory
p57486
aVAnd is this intended
p57487
aVI don't know, because I don't know how your process was created
p57488
as(dp57489
g7
V505088
p57490
stp57491
a((dp57492
g2
(lp57493
VYou are iterating over the components owned by the form
p57494
aVI think that's the wrong approach
p57495
aVYou should be looking at the parent/child relationship rather than ownership
p57496
aVNot least because it's perfectly possible for a form to contain controls that it does not own
p57497
aVSo, your approach can fail to find controls, particularly dynamically created controls
p57498
aVSo, if you have a tabsheet (or indeed any windowed control), you can iterate over its children like this:
p57499
aVIf your target grid control is a direct descendent of the tabsheet then this will be enough
p57500
aVIf it is more than one level deep in the hierarchy then you will need a recursive solution
p57501
aVI will leave that recursive solution as an exercise for you
p57502
aVSuppose that you have a control and want to find the tabsheet that it sits inside, then you need to walk up the parent chain
p57503
aVLike this:
p57504
as(dp57505
g7
V505088
p57506
stp57507
a((dp57508
g2
(lp57509
VThere is no direct equivalent in Delphi
p57510
aVIt's not possible for there to be such a thing because Delphi does not have macros and a pre-processor
p57511
aVObviously it's possible in Delphi to work out the offset for a specific field in a specific record
p57512
aVAnd then it's trivial to perform the subtraction required to get the containing record base address
p57513
aVBut what you cannot do is express that calculation once and re-use it for any general field/record pair, as can be done with the C macro
p57514
aVYou will need to write one function for each field/record pair that you work with in this way
p57515
as(dp57516
g7
V505088
p57517
stp57518
a((dp57519
g2
(lp57520
VThat symbol is used to display a code point that does not have a glyph in the selected font
p57521
aVFor example, the code point could be non-printable, or it could be a character from a language that is not included in the font your debugger is using
p57522
aVIt's impossible to say what the code point actually is from here
p57523
aVYou will need to write some diagnostics code, or inspect in the debugger to find out what it really is
p57524
aVIn order to resolve the problem you'll need to track down where these strings are coming from
p57525
aVAnd then look to find out what you are doing wrong
p57526
aVIt does look rather like an off-by-one error in your code
p57527
aVIn other word, perhaps the string actually starts one character later than your code thinks it does
p57528
as(dp57529
g7
V505088
p57530
stp57531
a((dp57532
g2
(lp57533
VThere's no need at all to use  here
p57534
aVI would do it like this:
p57535
aVAnd then the function is:
p57536
aVYou may need to specify the  calling convention, depending on the native code
p57537
aVCall the function like this:
p57538
aVSince there is no mention of string length in the native code you posted, I'm assuming that the strings are allocated by the native code and that you don't need to to anything to deallocate them
p57539
as(dp57540
g7
V505088
p57541
stp57542
a((dp57543
g2
(lp57544
VYou are using quite a low resolution timer and a single evaluation of the factorial function is too fast to even register
p57545
aVYou could use a higher resolution timer, but by far the easiest approach is to time something that takes longer
p57546
aVInstead of timing a single call to factorial, time a thousand, or a million
p57547
aVIf you are actually interested in implementing a fast factorial function, for integer inputs, then you should use a lookup table
p57548
aVFor what it is worth, I think that TStopWatch in the Diagnostics unit is more convenient for timing than the date/time functions
p57549
as(dp57550
g7
V505088
p57551
stp57552
a((dp57553
g2
(lp57554
VThe error message
p57555
aVMeans that the current directory does not contain files names  or
p57556
aVWhat you can do is either:
p57557
aVSpecify the full path to the file
p57558
aVEnsure that the current directory, when your code executes, is the directory that contains your file
p57559
aVHowever, even when you do this, your program may very well fail
p57560
aVYou may not have sufficient rights to modify the contents of that folder
p57561
aVAnd the file you are trying to rename may well be locked if the OS has loaded the driver
p57562
aVAnd as @Hans points out, the file system redirector could very well be confounding matters for you
p57563
aVThe best way to avoid that is to us a 64 bit process
p57564
aVI see no reason for using a C++ program here
p57565
aVRenaming files is a task best suited to a scripting language
p57566
as(dp57567
g7
V505088
p57568
stp57569
a((dp57570
g2
(lp57571
VMost likely  is not declared with enough memory for the indices you use
p57572
aVIf  then you need to declare it like this:
p57573
aVBecause C++ uses zero-based indices this allows for indices in the range 0 to 8 inclusive
p57574
aVMost likely your declaration is like this:
p57575
as(dp57576
g7
V505088
p57577
stp57578
a((dp57579
g2
(lp57580
VYou appear to be trying to load a GIF file from a resource
p57581
aVDo it like this:
p57582
aVwhere  is an instantiated object of type
p57583
aVI really cannot work out what your code is trying to do
p57584
aVPerhaps you have multiple images
p57585
aVIn which case create one resource for each image, each resource having a different name
p57586
aVNote that I don't mean one
p57587
aVres file per image
p57588
aVYou can put all your images into a single
p57589
aVrc file, each resource with a different name
p57590
aVThen compile that
p57591
aVrc file to a
p57592
aVres file and link to your application
p57593
as(dp57594
g7
V505088
p57595
stp57596
a((dp57597
g2
(lp57598
VThe documentation for  says this about the  parameter
p57599
aVA pointer to a buffer that receives the converted string
p57600
aVTo calculate the number of characters that must be allocated to hold the returned string, set this parameter to NULL
p57601
aVThe function will place the required number of characters, including the terminating NULL character, in the value pointed to by pcchString
p57602
aVYou are obliged to allocate the buffer so that the API function can populate it
p57603
aVYou are failing to do so
p57604
aVIn order to proceed you must read the documentation carefully and abide by the requirements of the API
p57605
aVSo you need to call the function like this:
p57606
aVYou should also check the return value of  to detect failures
p57607
aVI omitted that for brevity
p57608
aVI'm also assuming that yours is an ANSI Delphi
p57609
aVI assumed that because you used
p57610
as(dp57611
g7
V505088
p57612
stp57613
a((dp57614
g2
(lp57615
VAccording to your question, the line
p57616
aVleads to an access violation at address
p57617
aVNow, for a start, why won't you tell us the precise error message with the full details
p57618
aVHiding the address makes it harder
p57619
aVAnyway, it looks like the address is going to be a value very close to zero
p57620
aVIn any case the only explanation for an access violation there is that  is invalid
p57621
aVMost likely it is
p57622
aVI note that the code in question is inside a  method
p57623
aVSo why do you use  to refer to the object
p57624
aVYou are already inside an instance of the object
p57625
aVDo you have multiple global variables named
p57626
aVPerhaps one in the main form unit and one in the frame unit
p57627
aVYou should stop using global variables for your GUI objects
p57628
aVI know that the IDE leads you that way
p57629
aVResist the temptation to program that way
p57630
aVAbuse of global variables leads to pain and suffering
p57631
aVSince the code is inside a  method you can use
p57632
aVIn all your  methods remove all references to
p57633
aVYour loop should be like this:
p57634
aVand the rest of the methods in that class need similar treatment
p57635
aVNote that you don't need to explicitly write  and it is idiomatic not to
p57636
aVFinally, I urge you to learn how to use the debugger
p57637
aVIt's a wonderful tool and if you would use it, it would have told you what the problem was
p57638
aVDon't be helpless, let the tools help you
p57639
as(dp57640
g7
V505088
p57641
stp57642
a((dp57643
g2
(lp57644
VHere's some simple code to mark a header column as sorted ascending:
p57645
aVI have omitted error checking for the sake of simplicity
p57646
aVIf you want the arrow in the opposite direction, I'm sure you can work out how to swap the logic around
p57647
aVThe key MSDN topic is that for the  struct
p57648
as(dp57649
g7
V505088
p57650
stp57651
a((dp57652
g2
(lp57653
VThis routine seems to be far more complicated than it needs to be
p57654
aVRather than trying to debug it, I offer you my routine that compares streams
p57655
aVIf you wish to add your 100MB size check to this function, it's obvious where and how to do it
p57656
aVThe routine above uses a stack allocated buffer
p57657
aVIn contrast your version allocates on the heap
p57658
aVPerhaps your version leads to heap fragmentation
p57659
aVI realise that this does not answer the direct question that you asked
p57660
aVHowever, it does solve your problem
p57661
aVI hope this proves useful
p57662
as(dp57663
g7
V505088
p57664
stp57665
a((dp57666
g2
(lp57667
VServices run in a different session from the interactive user
p57668
aVServices run in session 0
p57669
aVSession 0 processes do not have access to the interactive desktop
p57670
aVWhich means that any attempt to show an interactive process in session 0 is doomed to fail
p57671
aVYou are attempting to create a Notepad process which is interactive
p57672
aVThere are ways to launch a process on an interactive desktop from a session: Launching an interactive process from Windows Service in Windows Vista and later
p57673
aVAs you will understand after reading that article, what you are attempting to do is non-trivial
p57674
as(dp57675
g7
V505088
p57676
stp57677
a((dp57678
g2
(lp57679
VComponent editors can only operate on a single component
p57680
aVThis is one very good reason to prefer making properties available through the Object Inspector rather than component editors, wherever possible
p57681
aVBecause the Object Inspector can operate on multiple components at once
p57682
as(dp57683
g7
V505088
p57684
stp57685
a((dp57686
g2
(lp57687
VSimply call the  API function
p57688
aVSince this function was added in Vista, it won't be declared in the library units that shipped with Delphi 7
p57689
aVSo you'd need to declare it yourself
p57690
aVNow, since this function was added in Vista, attempts to call it on XP will lead to failures
p57691
aVSo, I would recommend dealing with this by using CSIDL functions rather than the Vista known folder APIs
p57692
as(dp57693
g7
V505088
p57694
stp57695
a((dp57696
g2
(lp57697
VThe documentation for CloseHandle makes it clear why this happens:
p57698
aVIf the application is running under a debugger, the function will throw an exception if it receives either a handle value that is not valid or a pseudo-handle value
p57699
aVSo, when your call to CreateFile fails, the subsequent call to CloseHandle will raise an SEH exception
p57700
aVThe solution is that your code must only call CloseHandle if the call to CreateFile succeeded
p57701
aVAs others point out, your use of WriteFile is wrong
p57702
aVI won't repeat the details here
p57703
as(dp57704
g7
V505088
p57705
stp57706
a((dp57707
g2
(lp57708
VLooking the the property in question, , its type is  which is defined as:
p57709
aVAs you can see, C++ Builder uses the template  to emulate Delphi set types
p57710
aVAll of the functionality available using the built in Delphi set operators is exposed through the methods of
p57711
aVSpecifically to this question, set membership is testing using
p57712
as(dp57713
g7
V505088
p57714
stp57715
a((dp57716
g2
(lp57717
VYou are looking for the  and  operators:
p57718
aVIn C++ these operators are baked into the language
p57719
aVIn Delphi,  and  are implemented as intrinsic routines
p57720
as(dp57721
g7
V505088
p57722
stp57723
a((dp57724
g2
(lp57725
VIn fact your code works fine
p57726
aVThe problem is that the programs you are testing against really do not implement
p57727
aVWhen the system returns  it is accurate
p57728
aVThe interface is not implemented
p57729
aVI tested this with the File Is In Use Sample from the SDK
p57730
aVFiles that are added to the ROT by that application, which does implement , were picked up by your code
p57731
aVOn the other hand, files opened by Acrobat 8 and Word 2010 were not
p57732
aVThe conclusion that I draw from this is that  is a fine idea in principle, but not much use if applications don't support it
p57733
aVAnd it appears that there are major applications that do not
p57734
aVIt is clear that you will need to use one or more of the other mechanisms to detect which application has a file locked when you find that  is not implemented
p57735
as(dp57736
g7
V505088
p57737
stp57738
a((dp57739
g2
(lp57740
VRunning this code whilst the modal dialog is showing is interfering with window activation
p57741
aVI'm not sure exactly what the mechanism is for this interference, but the fix is simple enough
p57742
aVMove the code outside the dialog
p57743
aVExecute this code immediately after the call to ShowDialog returns
p57744
as(dp57745
g7
V505088
p57746
stp57747
a((dp57748
g2
(lp57749
VAssuming your mask is so simple that it only has # and / it's easy to write a test function:
p57750
as(dp57751
g7
V505088
p57752
stp57753
a((dp57754
g2
(lp57755
VThe VCL provides Application
p57756
aVActionUpdateDelay to help in such situations
p57757
aVSet it to a non-zero value to force a delay between successive action updating
p57758
aVHowever, it might be more prudent to find out why your action is forcing endless repeated OnIdle conditions
p57759
aVIf you can stop it doing so then there's no need for update delay
p57760
as(dp57761
g7
V505088
p57762
stp57763
a((dp57764
g2
(lp57765
VA GUID in binary form is best thought of as a record
p57766
aVIndeed in Delphi the record already exists \u2013 it is
p57767
aVAll you need to do is to copy the relevant bytes directly into a variable of type  and your job is done
p57768
aVIf you want a string representation, use
p57769
aVThis will take care of all the endian issues automatically
p57770
aVLet's take a look at the declaration of :
p57771
aVYour code treats this as a straight array of bytes
p57772
aVHowever, in the record, ,  and  are integral types on a little endian machine
p57773
aVSo your code reverses the first 4 bytes, those belonging to
p57774
aVIt then reverses the two bytes of , and also the two bytes of
p57775
aVThe array of 8 bytes at the end of the GUID are not reversed, of course
p57776
aVSo, whilst you could readily do all the byte swapping yourself, it's far better to use a record to do so, and take advantage of the helper function that converts a binary GUID record to a properly formatted GUID string
p57777
as(dp57778
g7
V505088
p57779
stp57780
a((dp57781
g2
(lp57782
V supports Windows consoles
p57783
aVI expect that your application targets the console subsystem
p57784
aVIf you cannot get your application to fail under the debugger then you need to add some diagnostics to it
p57785
aVI recommend using an tool like madExcept or EurekaLog to do this
p57786
aVPersonally I use madExcept and cannot recommend it highly enough
p57787
aVFrom what I have heard, EurekaLog is also a fine product
p57788
aVIntegrate one of these tools with your application and the next time it faults it will produce a detailed diagnostics report
p57789
aVMost significantly you will get stack traces for each thread in your process
p57790
aVThe stack trace for the faulting thread should hopefully lead you to the root cause of your program's bug
p57791
aVThe doubt I have is that if the fault is occurring in  then including diagnostics in your process may not to yield fruit
p57792
aVIt's plausible that your application already faulted, which in turn led to the error message in
p57793
aVIn which case diagnostics in your app will help
p57794
aVIf not then you may need to find a way to make the fault occur in your process
p57795
as(dp57796
g7
V505088
p57797
stp57798
a((dp57799
g2
(lp57800
VRelative paths are relative to the working directory of the process
p57801
aVThe working directory of the process is determined at process startup, and may not be the directory that contains the executable
p57802
aVWhat's more, the working directory can change during the processes life
p57803
aVIt seems to me that you should be giving a full path to these files
p57804
aVYou need to get hold of the directory in which the executable lives
p57805
aVThat is
p57806
aVSo you should be using this code to name your file:
p57807
as(dp57808
g7
V505088
p57809
stp57810
a((dp57811
g2
(lp57812
VThe C++ function type is a plain function, i
p57813
ag192
aVnot a member function
p57814
aVBut you have declared your version to be a method of object
p57815
aVThat is a mismatch
p57816
aVYou must remove
p57817
aVYou must also specify the calling convention
p57818
aVMost likely it will be
p57819
aVIn Delphi, if the calling convention is not specified, then the register based Delphi fastcall convention,  is used
p57820
aVThat's certainly wrong
p57821
aVFinally, if the pointer to the struct can never be  then it is more idiomatic to use a  parameter:
p57822
aVAnd obviously you'd have to change the calling code to match:
p57823
as(dp57824
g7
V505088
p57825
stp57826
a((dp57827
g2
(lp57828
VI can see two options:
p57829
aVSet Form1
p57830
aVParentWindow := WHandle immediately following Application
p57831
aVCreateForm
p57832
aVIf that's too late, then you will need to override TForm1
p57833
aVCreateParams and set it in there
p57834
as(dp57835
g7
V505088
p57836
stp57837
a((dp57838
g2
(lp57839
VThe simplest way to determine whether or not a window has any children is to call  passing
p57840
as(dp57841
g7
V505088
p57842
stp57843
a((dp57844
g2
(lp57845
VOne of the constraints of the VCL is that all interaction with GUI controls must be performed on the main thread
p57846
aVThere's no way to circumvent that
p57847
aVIf you want to show debugger GUI in a separate thread, using VCL, your only option is to use an out-of-process solution
p57848
aVIn other words, run your debugger in a different process, and use IPC to communicate between the two processes
p57849
as(dp57850
g7
V505088
p57851
stp57852
a((dp57853
g2
(lp57854
VYour code is not threadsafe
p57855
aVIf one of the threads attempts to open the file whilst the other thread has it open, the second attempt to open may fail with a sharing violation
p57856
aVEven if the OS allows you to open the file twice, simultaneously, you now have two separate unsynchronized buffers, and two distinct file pointers
p57857
aVThere's absolutely no guarantee that your writes will be consistent
p57858
aVYou should serialize access to the shared resource with a mutex
p57859
aVAlternatively, use a producer/consumer approach and put all writing to the log on a single thread, the consumer
p57860
aVThen let multiple producer threads push logging tasks onto the consumer thread
p57861
as(dp57862
g7
V505088
p57863
stp57864
a((dp57865
g2
(lp57866
VIt is clear that your version of the loop is semantically identical
p57867
aVHowever, that's not the only thing to consider
p57868
aVNotice that further down the  loop there is a second condition that breaks out of the loop
p57869
aVI suspect that this is what has motivated the author to use
p57870
aVBy writing it as  you alert the reader to the fact that there must be one or more breaks inside the
p57871
aVThe reader is going to have to look inside the loop for breaks, and will hopefully find them both
p57872
aVWritten your way, the casual reader might scan the top of the code and assume that the  condition was the only way for the loop to terminate
p57873
aVAnother point to consider is that of symmetry, or balance
p57874
aVAs written by the original author, the loop terminations are all of the same form
p57875
aVNamely breaks from within the loop
p57876
aVYour version feels asymmetrical
p57877
aVOne termination point in the  test, and a further termination point, of a different nature, inside the loop
p57878
as(dp57879
g7
V505088
p57880
stp57881
a((dp57882
g2
(lp57883
VDoes __forceinline perform faster than __inline
p57884
aVSometimes it does, sometimes it does not
p57885
aVIt all depends on what's inside the function, the patterns of calling, and lots of other factors
p57886
aVIn general, predicting performance accurately from a static analysis is close to impossible
p57887
aVIf you want to answer the question accurately, time both alternatives
p57888
as(dp57889
g7
V505088
p57890
stp57891
a((dp57892
g2
(lp57893
VIn fact  is a subset of
p57894
aVThat's because duplicate values are not allowed in a set
p57895
aVThe documentation makes this clear:
p57896
aVA set object is an unordered collection of distinct hashable objects
p57897
aVThe key word in that sentence is distinct
p57898
aVSo, it follows that, and can easily be verified, that your three sets are all equal to each other
p57899
as(dp57900
g7
V505088
p57901
stp57902
a((dp57903
g2
(lp57904
VSince you are declaring variables, they must have different names
p57905
aVUnlike functions, procedures and methods which can overload the same name
p57906
aVSo, solve your problem by choosing different names for your two variables
p57907
aVAnd also remove everything after the  in your two variable declarations
p57908
aVThose keywords only apply to procedures and methods, and not to procedural variables
p57909
aVYou have to use variables if you are going to link explicitly using
p57910
aVYou need a variable to hold the function pointer returned by
p57911
aVIf you linked implicitly using the  keyword, then you would not have a variable
p57912
aVAnd then you could declare functions overloaded with the same name
p57913
aVI must admit that I am surprised that you chose the same name for these variables
p57914
aVThey must have different names in the C code, and they must be exported from the DLL with different names
p57915
aVI hope you aren't trying to call the same function with different parameter lists
p57916
aVThat certainly will not work
p57917
aVThe other problem that I can see you will have is that your  parameters cannot possibly match the parameters used in the C library
p57918
aVYou'll need to use  I suspect
p57919
aVBut that's really the topic for a different question
p57920
as(dp57921
g7
V505088
p57922
stp57923
a((dp57924
g2
(lp57925
VConsider adding a bit of runtime support to associate an enumeration with your controls
p57926
aVFirst create an enumerated type:
p57927
aVThen add a dictionary to your form:
p57928
aVThen in the form's constructor create and populate the dictionary:
p57929
aVThis section of code should be placed in a separate local helper function rather than inline in your form's constructor
p57930
aVNow you can write your case statement:
p57931
as(dp57932
g7
V505088
p57933
stp57934
a((dp57935
g2
(lp57936
VMost likely it's because a form style change will lead to window handle re-creation
p57937
aVAnd this will force re-creation of the handles of all child windows too
p57938
aVWindow re-creation is by and large something that can happen without you noticing
p57939
aVBut there are controls which have problems with re-creation
p57940
aVI've suffered from this with the toolbar control in the past, for example
p57941
aVMore recent versions of Delphi are more resilient to re-creation
p57942
as(dp57943
g7
V505088
p57944
stp57945
a((dp57946
g2
(lp57947
VThe reason your window was not receiving the  messages is that your window is created from a secondary thread
p57948
aVEach thread in a process has its own message queue
p57949
aVSynchronous messages are delivered when you service the message queue, so ever for a non-queued message like  you do need to service the secondary threads message queue in order for messages to be delivered
p57950
aVFor example, look at the documentation for , the most common way to pull messages of the queue:
p57951
aVThe function dispatches incoming sent messages until a posted message is available for retrieval
p57952
aVThe same is true for
p57953
aVIt dispatches incoming sent messages before peeking the queue
p57954
aVThere are a handful of other ways for sent messages to be dispatched, but these are the primary ones
p57955
aVNow, I suspect that it may be inconvenient for you to periodically dispatch messages from your secondary thread
p57956
aVIf your secondary thread does nothing else then it can simply sit in the traditional , ,  loop
p57957
aVAnd most of the time it will happily block in  dispatching any incoming sent messages
p57958
aVBut if your secondary thread does more work then that's probably not a viable option
p57959
aVYou are already running and servicing a message queue on the main service thread
p57960
aVIt may make more sense to make your listener window have affinity with the main service thread
p57961
aVDo that by creating it from code that runs in the main service thread
p57962
aVNote also that  is documented not to be thread-safe
p57963
aVYou must not call it from any thread other than the main thread of the process
p57964
aVSo, if you do wish to remain on a secondary thread, you'll need to use  rather than
p57965
aVBut this is perhaps yet another good reason to move this window onto the main thread
p57966
as(dp57967
g7
V505088
p57968
stp57969
a((dp57970
g2
(lp57971
VYou clarify in a comment that you wish to refer to local variables by name
p57972
aVThis is impossible in all versions of Delphi
p57973
aVIf you want to be able to refer to values by names then you will have to stop using local variables to store your values
p57974
aVInstead use a dictionary
p57975
aVIn Delphi that is:
p57976
aVwhich is a generic class defined in the Generics
p57977
aVCollections unit
p57978
aVSo if your values are integers, for example, you would use
p57979
as(dp57980
g7
V505088
p57981
stp57982
a((dp57983
g2
(lp57984
VThe  and  units are units from devExpress
p57985
aVYou need to install the appropriate devExpress code/components to resolve this
p57986
aVThis may involve a purchase if you don't already have the devExpress components
p57987
aVIn which case you will need to talk to the developer to find out which specific components are used by this project
p57988
aVThe  units are TMS components
p57989
aVSame advice as for devExpress
p57990
aVAs for , , , I suspect that they are part of the project that you have inherited
p57991
aVUpdate: I guessed wrong, the first two are 3rd party, linked to from Jan's answer
p57992
aVOne final point
p57993
aVI don't understand why you are asking here as your first port of call
p57994
aVIf a developer has produced some code for you, it is that developer that you should be talking to
p57995
aVWe can guess and reverse engineer to a degree, but the author of the code should know what its dependencies are
p57996
as(dp57997
g7
V505088
p57998
stp57999
a((dp58000
g2
(lp58001
VBecause of the "as-if" rule, the compiler is allowed to do the conversion of the literal to a floating point value at compile time
p58002
aVA good compiler will do so if that results in better code
p58003
aVIn order to answer your question definitively for your compiler and your target platform(s), you'd need to check what the compiler emits, and how it performs
p58004
aVHowever, I'd be surprised if any mainstream compiler did not turn either of the two if statements into the most efficient code possible
p58005
as(dp58006
g7
V505088
p58007
stp58008
a((dp58009
g2
(lp58010
VConsider a string variable named
p58011
aVOn an ANSI Delphi  is ANSI encoded
p58012
aVOn a Unicode Delphi it is UTF-16 encoded
p58013
aVTherefore, either way, you need to convert  to UTF-8 encoding
p58014
aVAnd then you can use  to get a pointer to a null terminated C string
p58015
aVSo, the code you need looks like this:
p58016
as(dp58017
g7
V505088
p58018
stp58019
a((dp58020
g2
(lp58021
VIterating over  is the wrong approach
p58022
aVThat just yields the components that are owned by the form
p58023
aVYou will miss any components that are added dynamically, and not owned by the form, or components that are owned by frames
p58024
aVInstead you should use
p58025
aVHowever, that only yields first generation children
p58026
aVIf there is deeper parent/child nesting then you need to recurse
p58027
aVThat's more work
p58028
aVI use some helpers to make it easy
p58029
aVI've wrapped them up in this unit:
p58030
aVNow you can solve your problem like this:
p58031
aVOr you could make use of a predicate to put the caption test inside the iterator:
p58032
as(dp58033
g7
V505088
p58034
stp58035
a((dp58036
g2
(lp58037
VThat happens when your list of design-time packages is empty
p58038
aVSo, somehow I guess you have lost your design-time packages
p58039
aVRestore them like this:
p58040
aVFrom the menu select Component | Install Packages
p58041
aVIf you see anything in the list, check, at the very least, Embarcadero Standard Components
p58042
aVIf Embarcadero Standard Components is not in the list, click Add and browse to the Delphi bin directory (C:\u005cProgram Files (x86)\u005cEmbarcadero\u005cRAD Studio\u005c9
p58043
aV0\u005cbin)
p58044
aVOnce there, select dclstd160
p58045
aVbpl
p58046
aVAlso add any other packages that you need
p58047
aVYou may wish to include more than just the standard components
p58048
aVAt this point the New Component dialog will start offering you some ancestor components
p58049
as(dp58050
g7
V505088
p58051
stp58052
a((dp58053
g2
(lp58054
VWell, you don't need to pin, the marshaller will take care of that for you
p58055
aVBut, it's a poor p/invoke
p58056
aVMy advice is not to trust what you find on pinvoke
p58057
aVnet, the quality is very varied
p58058
aVI'd use  here
p58059
as(dp58060
g7
V505088
p58061
stp58062
a((dp58063
g2
(lp58064
VCreate a thread when your process starts
p58065
aVMake that thread sleep for the required duration
p58066
aVWhen that sleep is over, kill the process
p58067
as(dp58068
g7
V505088
p58069
stp58070
a((dp58071
g2
(lp58072
VYou don't need a 64 bit processor to perform arithmetic on a 64 bit data type
p58073
aVAll 32 bit compilers that I know of support arithmetic on 64 bit integers
p58074
aVIf the hardware doesn't allow native arithmetic, then the compiler has to generate code to do the arithmetic
p58075
aVTypically this will make use of support functions in the compiler's RTL
p58076
aVThe struct is intended for use by compilers that don't provide native support for 64 bit data types
p58077
aVThe very documentation to which you linked makes that clear:
p58078
aVNote  Your C compiler may support 64-bit integers natively
p58079
aVFor
p58080
aVexample, Microsoft Visual C++ supports the __int64 sized integer type
p58081
aVFor more information, see the documentation included with your C
p58082
aVcompiler
p58083
aVCompilers that don't support native 64 bit integers will not be able to treat the  union member as an integer
p58084
aVAnd the definition of :
p58085
aVOf course, all compilers written in the past 10 years (or more) will have native support for 64 bit integers
p58086
aVBut this union was originally introduced a very long time ago and the compiler landscape would have been different then
p58087
aVWhen looking at Windows header files, always bear in mind the history and legacy
p58088
as(dp58089
g7
V505088
p58090
stp58091
a((dp58092
g2
(lp58093
VAs @Mike Sutton pointed out in the comments, you should be using the  event of  to trigger updates to your image
p58094
aVThe documentation says:
p58095
aVThe event handler of the OnTrack event is called cyclically from the
p58096
aVMouseMove method while the TSelection object is in the process of
p58097
aVmoving or resizing
p58098
aVWrite a custom OnTrack event handler to perform a specific action when
p58099
aVTSelection is in the process of moving or resizing
p58100
aVYou state in a comment, the components are created dynamically at runtime, rather than on the designtime surface
p58101
aVSo you will also need to assign your handler in code
p58102
aVDo it like this:
p58103
aVYour event handler will look like this:
p58104
aVYou also say in the comments that you need to track selection changes for a number of linked images and selections
p58105
aVYou can modify the event handler like this:
p58106
as(dp58107
g7
V505088
p58108
stp58109
a((dp58110
g2
(lp58111
VYou can indeed call the native API from Delphi
p58112
aVDelphi does not ship with header translations for the native API
p58113
aVSo you need to provide your own, or use a pre-existing translation
p58114
aVFor example
p58115
aVthe JEDI translation of the NT API
p58116
as(dp58117
g7
V505088
p58118
stp58119
a((dp58120
g2
(lp58121
VIf you want users to be able to drop one of these components onto a form, or allow ownership to be handled using the  mechanism, then derive from
p58122
aVOtherwise, derive from
p58123
aVSpecifying an  when you create a  framework is optional
p58124
aVIf you want to opt out then simply pass  to the constructor of a
p58125
aVWhen you do that you take on ownership of the component, and it's your job to call  when you are done with it
p58126
aVSo, I suspect that what you wish to do is declare your class like this:
p58127
as(dp58128
g7
V505088
p58129
stp58130
a((dp58131
g2
(lp58132
VYou could solve this using the  property of
p58133
aVThat's often a quick and easy approach
p58134
aVThe only slight wrinkle is if you need the list items to manage the lifetime of their associated data
p58135
aVIn that case you have to implement an  event handler to finalize the associated data when a node is destroyed
p58136
aVAn alternative approach is to use a subclass of
p58137
aVFirst define your subclass:
p58138
aVThen implement a handler for the list view's  event
p58139
aVThis determines the actual class of list item that the list view instantiates
p58140
aVNow the list view will create items of class
p58141
aVSo, you can simply access a list item's  property as you would any other property
p58142
aVOf course this approach can be extended to store more information
p58143
aVThe only other point to make is that the list view control will still offer you items that are compile time typed as being
p58144
aVSo you will need to up-cast
p58145
aVFor example, suppose you wanted to do something when an item was edited
p58146
aVThe event handler looks like this:
p58147
aVNote that the item is passed as type
p58148
aVSo you would need to write it like this:
p58149
as(dp58150
g7
V505088
p58151
stp58152
a((dp58153
g2
(lp58154
VThe animation is controlled by the  property of the  control
p58155
aVSet it to  to animate, and set it to  to stop the animation
p58156
aVThere is also the  property
p58157
aVIf that is  then the animation loops endlessly
p58158
aVOtherwise it runs once and then stops
p58159
aVIf you want to run the animation once then set  to  and then set  to
p58160
aVFinally you have the  event
p58161
aVThat fires each time a looped animation loops back to the start
p58162
aVSo, if you want to show an animation twice or more then you need to set  to  and then count the loops in an  handler
p58163
as(dp58164
g7
V505088
p58165
stp58166
a((dp58167
g2
(lp58168
VFirst of all, you should be checking your API calls for errors
p58169
aVYou need to check the return values of all your calls to API functions
p58170
aVThat said, given the code in the question,
p58171
aVIf that results in an item being added to the list box, then it means that  did indeed return a valid window handle, and  did indeed point to valid memory
p58172
aVIn which case the only explanation for what you report is that the text encoded did not match
p58173
aVSo, we can assume that the  macro evaluates to
p58174
aVAnd since you are passing ANSI encoded text, that mismatch explains the symptoms
p58175
aVThe function treats the text as UTF-16 encoded
p58176
aVOne obvious solution is to use  instead
p58177
aVHowever, a better solution, in my view, would be to pass UTF-16 encoded data
p58178
aVObviously your code would add in the error checking that I mentioned at the start
p58179
as(dp58180
g7
V505088
p58181
stp58182
a((dp58183
g2
(lp58184
VExpress is the cut-down edition of VS and as such it is less capable than the Pro edition
p58185
aVSo, you should stick to VS 2012 Pro which is more than capable of developing Windows 8 apps
p58186
as(dp58187
g7
V505088
p58188
stp58189
a((dp58190
g2
(lp58191
VIf you return as , then the marshaller will call  on the pointer that is returned
p58192
aVI expect that's what's happening to you and is why your code fails
p58193
aVLooking at that API it seems most likely that the pointer that is returned points to a string literal in the DLL, certainly not something allocated with
p58194
aVSo, you are going to need to return that as an  and then convert to string using
p58195
aVSo you need it like this:
p58196
aVBefore you go much further you need to work out what  is
p58197
aVIs it  or is it
p58198
aVIt makes no difference for this no-parameter function, but before long you'll be passing parameters, and you'll need to know
p58199
as(dp58200
g7
V505088
p58201
stp58202
a((dp58203
g2
(lp58204
VThe reason you cannot use  in your code is that your class does not explicitly list  in its list of supported interfaces
p58205
aVEven though your interface derives from , unless you actually list that interface, your class does not support it
p58206
aVSo, the trivial fix is to declare your class like this:
p58207
aVThe reason that your class needs to implement  is that is what the compiler is relying on in order to implement the  cast
p58208
aVThe other point I would like to make is that you should, in general, avoid using interface inheritance
p58209
aVBy and large it serves little purpose
p58210
aVOne of the benefits of using interfaces is that you are free from the single inheritance constraint that comes with implementation inheritance
p58211
aVBut in any case, all Delphi interfaces automatically inherit from  so in your case there's no point specifying that
p58212
aVI would declare your interface like this:
p58213
aVMore broadly you should endeavour not to use inheritance with your interfaces
p58214
aVBy taking that approach you will encourage less coupling and that leads to greater flexibility
p58215
as(dp58216
g7
V505088
p58217
stp58218
a((dp58219
g2
(lp58220
VI'm not sure there's a simply way to do what you wish
p58221
aVYou can convert a  into a  with a simple cast:
p58222
aVbut you cannot concatenate
p58223
aVSo this is a compiler error:
p58224
aVYou could use a helper function to get the job done:
p58225
aVThen you can call it like this:
p58226
as(dp58227
g7
V505088
p58228
stp58229
a((dp58230
g2
(lp58231
VThe variant value that can be used to clear the contents of a cell is
p58232
aVAlternatively you can use the  method on a cell
p58233
aVPersonally I find the latter to be more readable
p58234
as(dp58235
g7
V505088
p58236
stp58237
a((dp58238
g2
(lp58239
VThere is no such pre-defined conditional, and there could not be such a conditional
p58240
aVThat's because at compilation time it is impossible to know whether the unit will, ultimately, be linked into an executable, a library or a package
p58241
aVIn fact, the same compiled unit could be linked into any or all of the above project types
p58242
aVAnd indeed you can see this yourself when you link the RTL into your projects
p58243
aVYou link the same  unit, the same compiled
p58244
aVdcu file, into all your projects, irrespective of the project type
p58245
as(dp58246
g7
V505088
p58247
stp58248
a((dp58249
g2
(lp58250
VYou can use  for this job:
p58251
as(dp58252
g7
V505088
p58253
stp58254
a((dp58255
g2
(lp58256
VYou can use the  unit that is supplied with Delphi
p58257
aVThe function you need is
p58258
aVYou simply need to create two streams, one for input and one for output
p58259
aVIf you are working with files then you should create  instances
p58260
aVOnce you have your two file streams created, all you need is:
p58261
as(dp58262
g7
V505088
p58263
stp58264
a((dp58265
g2
(lp58266
VIs this code able to modify its code to do any harm
p58267
aVYes
p58268
aVAnd indeed it may do harm without even needing to modify itself
p58269
aVIs the code part of a dynamically loaded dll read only by default or is it writable
p58270
aVBy default, DLLs are capable of modifying themselves
p58271
aVThey need to call  in order to do so, but that's perfectly possible
p58272
aVIf a code does not use any other dll it is still able to do something that requires some code from a system dll
p58273
aVThe DLL can just load any system DLL and call whatever functions it chooses
p58274
aVHow could it load another dll and find a function if the function for loading dlls is not loaded by default
p58275
aVBy calling  and
p58276
aVIf the DLL really imports nothing at all then it's tricky to get hold of
p58277
aVBut not impossible
p58278
aVIf Windows manages to do it, then surely the DLL can as well
p58279
aVOne thing it could do is read the in-memory contents of the kernel32 DLL which is loaded into every process
p58280
aVIt could parse the PE export table and use that to find the address of
p58281
as(dp58282
g7
V505088
p58283
stp58284
a((dp58285
g2
(lp58286
VYou cannot make C variables after the program has been compiled
p58287
aVIn order to create named things at runtime you need a dynamic data structure like a dictionary
p58288
aVThat said, perhaps you don't actually need the variables named, in which case a dynamically allocated array is what you need
p58289
aVSince you cannot actually create variables at runtime, the naming issues becomes moot
p58290
as(dp58291
g7
V505088
p58292
stp58293
a((dp58294
g2
(lp58295
VYou say that you did not mean to call the methods
p58296
aVBut you did
p58297
aVYou write
p58298
aVand that calls  since it uses the call operator
p58299
aVYou are calling each one of your arithmetic operator methods as you populate your dictionary
p58300
aVIf you want to capture the method instead of calling it you need to put  into the
p58301
aVThen when you do want to call the method you do it like this:
p58302
aVAt this point we are using the call operator  and supplying the parameters
p58303
aVPutting it all together, your function looks like this:
p58304
aVSince the  never varies, it may be more sensible to make it be a class attribute and initialise it once only
p58305
aVIt doesn't look to me as though your instance is doing very much useful here
p58306
aVYou are not referring to  anywhere
p58307
aVWhich suggests that these methods may be better as static methods
p58308
as(dp58309
g7
V505088
p58310
stp58311
a((dp58312
g2
(lp58313
VThere are three ways to deallocate the memory associates with a dynamic array, :
p58314
aVIt's up to you which one to use
p58315
aVThe documentation says the same, albeit in a slightly round about fashion:
p58316
aVTo deallocate a dynamic array, assign nil to a variable that references the array or pass the variable to Finalize; either of these methods disposes of the array, provided there are no other references to it
p58317
aVDynamic arrays are automatically released when their reference-count drops to zero
p58318
aVDynamic arrays of length 0 have the value nil
p58319
aVThis will release all memory associated with the array, including any nested managed types, such as strings, dynamic arrys etc
p58320
aVthat are owned by your record type
p58321
aVIf you need to resize the array for future use, and have the new data available, simply resize using , and initialise the remaining elements appropriately
p58322
as(dp58323
g7
V505088
p58324
stp58325
a((dp58326
g2
(lp58327
VA comparison sort algorithm accesses elements in an array under the assumption that the sort function has certain properties
p58328
aVSpecifically,
p58329
aVIf f(x,y)<0 then f(y,x)>0
p58330
aVIf f(x,y)=0 then f(y,x)=0
p58331
aVIf f(x,y)<0 and f(y,z)<0 then f(x,z)<0
p58332
aVf(x,x)=0
p58333
aVThe sort algorithm guarantees that it will sort the array if your function obeys the rules
p58334
aVOtherwise, if you don't obey the rules, all bets are off
p58335
aVAnything could happen
p58336
aVDon't be surprised if you encounter runtime errors
p58337
aVThe most commonly seen, in my experience, is stack overflow, but access violation is plausible too
p58338
as(dp58339
g7
V505088
p58340
stp58341
a((dp58342
g2
(lp58343
VIn my opinion, there's no point attempting to continue from
p58344
aVIn my experience, chances are exceedingly high that the heap will be corrupted and future errors can be expected
p58345
aVUsually, the safest course of action is to terminate the process
p58346
as(dp58347
g7
V505088
p58348
stp58349
a((dp58350
g2
(lp58351
VLet us consider the following three type declarations:
p58352
aVThese are all very similar to each other
p58353
aVIn terms of calling instances of each of these three types, the calling code is identical
p58354
aVThe differences arise in what can be assigned to variables of these types
p58355
aVProcedural types
p58356
aVis a procedural type
p58357
aVYou can assign to a variable of type  something of this form:
p58358
aVThis is a non object-oriented procedure
p58359
aVYou cannot assign an instance or class method to a  variable
p58360
aVHowever, you can assign a static class method to a  variable
p58361
aVMethod pointers
p58362
aVis a method pointer
p58363
aVThis is indicated by the presence of
p58364
aVWhen you have a variable of type  you must assign either:
p58365
aVA instance method of an instantiated object, or
p58366
aVA class method
p58367
aVSo you can assign either of these:
p58368
aVThe big difference between a procedural type and a method pointer is that the latter contains a reference to both code and data
p58369
aVA method pointer is often known as a two-pointer procedural type
p58370
aVA variable that contains a method pointer contains references to the code and the instance/class to call it on
p58371
aVConsider the following code:
p58372
aVNow, although  and  refer to the same piece of code, they are associated with different object instances
p58373
aVSo, if we call
p58374
aVWe are invoking  on the two distinct instances
p58375
aVThat code is equivalent to:
p58376
aVAnonymous methods
p58377
aVFinally we come to anonymous methods
p58378
aVThese are even more general purpose than procedural types and method pointers
p58379
aVYou can assign any of the following to a variable defined using the  syntax:
p58380
aVA plain non object-oriented procedure
p58381
aVAn instance method of an instantiated class
p58382
aVA class method
p58383
aVAn anonymous method
p58384
aVFor example:
p58385
aVAnonymous methods, item 4 above, are those declared in-line in your code
p58386
aVFor example:
p58387
aVThe biggest benefit of anonymous methods when compared to the procedural types and method pointers is that they allow for variable capture
p58388
aVFor example consider the following short program to illustrate:
p58389
aVThis has the following output:
p58390
aV12
p58391
aV-84
p58392
as(dp58393
g7
V505088
p58394
stp58395
a((dp58396
g2
(lp58397
VThe process is as follows:
p58398
aVIf a string  has length greater than zero, then  returns a pointer to the first element of the string content
p58399
aVBecause the  is managed to have a hidden null-terminator nothing more needs to be done
p58400
aVIf a string  has length zero, then  returns a pointer to a block of memory containing a null-terminator
p58401
aVAs an implementation detail, the null-terminator that is returned from  is a global constant allocated in the read-only section of the compiled module
p58402
aVAre Delphi strings automatically allocated and kept to be one char longer with an implicit #0 char in order to make casting to a PChar (PAnsiChar / PWideChar) easier
p58403
aVYes
p58404
aVThe magic, if you can call it that, is that:
p58405
aVUsing  on empty strings returns a pointer to a null-terminator
p58406
aVDelphi maintains the hidden null-terminator at the end of the string
p58407
as(dp58408
g7
V505088
p58409
stp58410
a((dp58411
g2
(lp58412
VYou are going to need to perform some synchronisation on reading
p58413
aVYou can't let one thread mutate a data structure whilst another tries to read it
p58414
aVA common approach is a single writer, multiple reader lock
p58415
aVDelphi comes with one of these, namely
p58416
aVHowever, I believe that its performance is poor, and since the  debacle I personally have little faith in the ability of Emba's engineers to write correct synchronization primitives
p58417
aVMy recommendation would be to use the Slim Reader/Writer (SRW) Lock introduced in Vista
p58418
aVIf you still need to support XP then I'd suggest falling back to a critical section
p58419
as(dp58420
g7
V505088
p58421
stp58422
a((dp58423
g2
(lp58424
VThere are two distinct families of functions that you will need to use to get this task done:
p58425
aVand related functions
p58426
aVThese can be used to start a new process
p58427
aVYou must supply a filename of an executable image
p58428
aVand friends
p58429
aVThese will apply verbs to files using the shell's rules for associating file classes to executables
p58430
aVIn order to open a URI you need to use one of the  family
p58431
aVAnd in order to execute as a standard user from your elevated process, you need to use one of the  family
p58432
aVYou cannot meet both your requirements with a single function
p58433
aVYour solution therefore is to use one of the  functions to create a process that runs as standard user
p58434
aVThat process in turn will call
p58435
aVYou will pass the URI as command line arguments to
p58436
aVYou will therefore need to either create a distinct executable as your standard user launcher
p58437
aVOr re-use your existing executable but make it switch into launcher mode depending on the arguments that you pass it
p58438
as(dp58439
g7
V505088
p58440
stp58441
a((dp58442
g2
(lp58443
VHaving now tried this myself, and looked at the the code, my conclusion is that there is a bug
p58444
aVThe RTTI unit does indeed attempt to perform  method re-writing
p58445
aVIt just appears to get it wrong
p58446
aVI recommend that you submit your project as a QC report, and workaround the problem by using  with  return values
p58447
as(dp58448
g7
V505088
p58449
stp58450
a((dp58451
g2
(lp58452
VIt's simple enough to solve the problem using  and
p58453
aVHere's an example program that I don't think needs any further explanation:
p58454
as(dp58455
g7
V505088
p58456
stp58457
a((dp58458
g2
(lp58459
VLooking at the output you provide we can see that the debugger has broken at this line:
p58460
aVand your error message is
p58461
aVAccess violation
p58462
aVRead of address 00000034
p58463
aVAttempting to read an address so close to zero is what happens when you try to read a field from an object reference that points to
p58464
aVFrom this we can conclude that  has not been instantiated
p58465
aVThe solution is to make sure that  is instantiated
p58466
as(dp58467
g7
V505088
p58468
stp58469
a((dp58470
g2
(lp58471
VQuestion 1: Module in which a type is defined
p58472
aVAccording to my Python, it's defined in the built in module named :
p58473
aVProgrammatically you can find out the module in which a type is defined by reading its  attribute:
p58474
aVQuestion 2: Find the superclasses of a type
p58475
aVThe  attribute of a type list its superclasses
p58476
aVQuestion 3: What is the type of a given object
p58477
aVYou didn't actually ask this question, but your comments indicate that you should have done so
p58478
aVTo find the type of an object use the  function
p58479
aVSo, when you catch an exception, you have an object rather than a type, that is you have an instance of the class
p58480
aVSo to learn about the type you must first use  to obtain the type
p58481
as(dp58482
g7
V505088
p58483
stp58484
a((dp58485
g2
(lp58486
VRecords don't need to be created
p58487
aVThey are value types and you should think of them the same way that you think about other value types, e
p58488
ag217
aVDeclare a local variable or a class field that is a value type and that's all you need to do
p58489
aVSimilarly, a constant sized array is a value type
p58490
aVSo, the answer to your question, is that  does not need any special allocation
p58491
aVWhat does need allocation and initialization are the contents of your record
p58492
aVSo if any of the fields in your record are class instances, then they need instantiating
p58493
aVSo, consider this record:
p58494
aVYou can declare one like this:
p58495
aVand the record itself is allocated
p58496
aVBut you need to initialise its members:
p58497
aVAnd when you are done with the record, you'd need to destroy the object
p58498
aVThis is easy to get wrong and so in general your records should contain only value types, or managed types (e
p58499
ag217
aVstrings, interfaces, dynamic arrays etc
p58500
aVNow, I can't tell what your code is all about from what's in the question, but I suspect that your record has some class instances
p58501
aVWhich immediately makes record a dubious choice of data structure
p58502
aVI'd hold these in a class which has constructor and destructor that manage the lifetime of the objects within
p58503
aVAnd I'd also avoid using a constant length array
p58504
aVThey are very inflexible
p58505
aVInstead I suggest you hold your sprite objects in a generic list,
p58506
aVOr, perhaps even better,  and that way you can let the list look after the life time of its members
p58507
as(dp58508
g7
V505088
p58509
stp58510
a((dp58511
g2
(lp58512
VUnless you are doing runtime type lookup based on class names, it's pretty easy to solve this problem
p58513
aVIf you think a class is unused, delete it
p58514
aVIf all your code compiles and links, then it wasn't used
p58515
aVIf you get unresolved references, then it was used
p58516
as(dp58517
g7
V505088
p58518
stp58519
a((dp58520
g2
(lp58521
VThis is a serious design flaw in
p58522
aVAnd it's easy to reproduce the behaviour you describe
p58523
aVWell done for specifying the problem so clearly
p58524
aVThe issue afflicts both 32 and 64 bit programs equally
p58525
aVPersonally I don't use  because it just doesn't work
p58526
aVI implement a handler for
p58527
aVIt looks like this:
p58528
aVPut that in in a class and assign it to  on startup:
p58529
aVI've just tested that out on the trivial two form application and it works well
p58530
aVIn real code you may wish to embellish this
p58531
aVFor example, my actual code is more complex
p58532
aVIt stores in user settings the position and window state of the help window when it is closed
p58533
aVAnd then when shown again, that position and window state are restored
p58534
aVSo that the help window appears to remember where it last was on the screen
p58535
aVThanks to @Sertac for dredging out the details in the comments below
p58536
aVIn summary here's where the  code goes wrong:
p58537
aVIt makes sends the  command at help system startup
p58538
aVAs described in the documentation this configures HTML Help to run on the same thread as the calling application instead of a secondary thread
p58539
aVWhen you call  that calls  which disables windows in the calling thread
p58540
aVBecause the help viewer window was created by your app's main thread (because of the  command), it gets disabled
p58541
aVAnd that's why you cannot interact with the a pre-existing help window whilst a Delphi modal form is active
p58542
as(dp58543
g7
V505088
p58544
stp58545
a((dp58546
g2
(lp58547
VHere you have directly encoded the character
p58548
aVWhether or not your code can parse this depends on the charset used by your XML document
p58549
aVSo, if your XML document uses UTF-8 and is correctly encoded then your XML code will be able to parse it
p58550
aVThis uses a named entity, deg
p58551
aVIn XML there are only five pre-defined named entities: quot, amp, apos, lt, gt
p58552
aVIt is possible for an XML document to define other named entities, however that is unusual
p58553
aVSo, it would seem that deg is not a valid named entity for your document
p58554
aVThis version uses a numeric character reference, NCR
p58555
aVYou can use an NCR to specify any Unicode code point
p58556
aVAs to what you should do going forwards, we can immediately rule out the named entity
p58557
aVI would also recommend avoiding wholesale use of NCRs for all non-ASCII characters
p58558
aVThat just leads to unreadable documents
p58559
aVOf course, if you must use a non-Unicode aware tool to process the document then using NCRs is the only approach
p58560
aVSo that leaves us with directly encoding non-ASCII characters
p58561
aVYou should make sure that your XML is properly encoded using the UTF-8 charset and that approach will work well, and lead to readable and clean documents
p58562
as(dp58563
g7
V505088
p58564
stp58565
a((dp58566
g2
(lp58567
VPolygon in side other polygon
p58568
aVSince your polygon is either all inside, or all outside, this can simply be reduced to testing whether one point the polygon is inside or outside the other polygon
p58569
aVThat's a well known problem with a variety of solutions: Point in polygon
p58570
aVMerging polygons
p58571
aVThere's no unique solution to your problem
p58572
aVThe most obvious approach to me would be to find two corners, one corner from each polygon that are closer together than any other pair of corners
p58573
as(dp58574
g7
V505088
p58575
stp58576
a((dp58577
g2
(lp58578
VYou have a couple of choices as to how to do this
p58579
aVYou can allocate unmanaged memory
p58580
aVAnd then copy the contents of your managed memory across
p58581
aVAnd then presumably copy it back when your call into native code returns
p58582
aVSince your example sets  to  then I guess you want to do it the other way
p58583
aVAnd that is to pass the managed memory down to the native code
p58584
aVIn order to do that you need to pin it to protect it from GC movement
p58585
aVIn order to make either of these approaches work I think you need a wrapper class to managed either the native memory, or the pinning
p58586
aVHere's how I'd tackle the pinning approach:
p58587
as(dp58588
g7
V505088
p58589
stp58590
a((dp58591
g2
(lp58592
VYou are overcomplicating matters
p58593
aVYou can simply use :
p58594
aVwhich outputs
p58595
aV999999989000
p58596
aV999999989000
p58597
aV999999989001
p58598
aV999999989001
p58599
aV999999989002
p58600
aV999999989002
p58601
aVIf you don't want banker's rounding, and you really do want your  logic then you do need to write your own function
p58602
aVBut the problem with your function is that it was truncating to 32 bit integer
p58603
aVMake the function return a 64 bit integer:
p58604
aV999999989000
p58605
aV999999989001
p58606
aV999999989001
p58607
aV999999989001
p58608
aV999999989002
p58609
aV999999989002
p58610
as(dp58611
g7
V505088
p58612
stp58613
a((dp58614
g2
(lp58615
VIf I call Free directly to the thread, it shouldn't immediately be destroyed, it should wait until the thread is done and there's no more work left to do
p58616
aVI think you have a slight mis-understanding of what happens when you destroy a thread
p58617
aVWhen you call  on a , the following happens in the destructor:
p58618
aVis called
p58619
aVis called
p58620
aVThe remainder of the thread's destructor then runs
p58621
aVIn other words, calling  already does what you ask for, namely notifying the thread method that it needs to terminate, and then waiting for it to do so
p58622
aVSince you are in control of the thread's  method, you can do as much or as little work there once you detect that the  flag has been set
p58623
aVAs Remy suggests, you could override  and do your last pieces of work there
p58624
aVFor what it is worth, this is a poor way to implement a queue
p58625
aVThat call to  jumps right out at me
p58626
aVWhat you need is a blocking queue
p58627
aVYou empty the queue and then wait on an event
p58628
aVWhen the producer adds to the queue the event is signaled so that your thread can wake up
p58629
as(dp58630
g7
V505088
p58631
stp58632
a((dp58633
g2
(lp58634
VYour code fails because you are returning a pointer to a variable that immediately goes out of scope
p58635
aVYou are returning a pointer to a local variable
p58636
aVLocal variables have scope that ends when the function returns
p58637
aVSo it is an error to attempt to refer to them after the scope has ended
p58638
aVYou'll need to use  to allocate the string
p58639
aVThat way you can allocate an object whose lifetime survives the end of the function
p58640
aVRemember that you need to match every call to  with a call to
p58641
aVI've also omitted error checking here to simplify things
p58642
as(dp58643
g7
V505088
p58644
stp58645
a((dp58646
g2
(lp58647
VYou said it yourself when you said that the exact same command works at the command prompt
p58648
aVThe difference there is the presence of a command interpreter,
p58649
aVWhat that does for you is create the pipe that pipes the input file into the MySQL process
p58650
aVYou have two obvious solutions to the problem:
p58651
aVUse  to start the process and set up the pipes yourself
p58652
aVThis is a little low level and involves a fair amount of Win32 boilerplate
p58653
aVIt does make it a little simpler to block until the process has finished, should you need to do that
p58654
aVGet  to invoke  and ask  to run MySQL and sort out the pipes
p58655
aVOption 2 is the simpler
p58656
aVIt looks like this:
p58657
aVThe  switch to  tells to carry out the command and then terminate \u2013 which is just what you want here
p58658
aVIf you need to block your process until the MySQL process is done, then you can switch to
p58659
aVThat returns a process handle on which you can wait
p58660
aVAgain it's a little harder to operate, but probably still easier than  since that forces you to manages the pipe
p58661
as(dp58662
g7
V505088
p58663
stp58664
a((dp58665
g2
(lp58666
VThis is an issue that is resolved in the latest versions of Delphi
p58667
aVSo you could either upgrade, or simply use the new code in Delphi 2010
p58668
aVFor example this program produces the output you expect:
p58669
aVThe Delphi 2010 code for  looks like this:
p58670
aVSo,  effectively boils down to a floating point subtraction of the two date/time values
p58671
aVBecause of the inherent in-exactness of floating point arithmetic, this subtraction can yield a value that is slightly above or below the true value
p58672
aVWhen it is below the true value, the use of  will take you all the way down to the previous minute
p58673
aVSimply replacing  with  would resolve the problem
p58674
aVAs it happens the latest Delphi versions, completely overhaul the date/time calculations
p58675
aVThere are major changes in
p58676
aVIt's a little harder to analyse, but the new version relies on
p58677
aVThat converts the time portion of the value to the number of milliseconds since midnight
p58678
aVAnd it does so like this:
p58679
aVNote the use of
p58680
aVThe use of  rather than  is the reason why the latest Delphi code handles  in a robust fashion
p58681
aVAssuming that you cannot upgrade right now, I would deal with the problem like this:
p58682
aVLeave your code unchanged
p58683
aVContinue to call  etc
p58684
aVWhen you do upgrade, your code that calls  etc
p58685
aVwill now work
p58686
aVIn the meantime fix  etc
p58687
aVwith code hooks
p58688
aVWhen you do come to upgrade, you can simply remove the hooks
p58689
as(dp58690
g7
V505088
p58691
stp58692
a((dp58693
g2
(lp58694
V is described as:
p58695
aVThe file system directory that contains application data for all users
p58696
aVBecause it is shared between all users on the computer, you need to have admin rights to write to that location
p58697
aVIf you want your configuration to be shared by all users then  is the right place for it
p58698
aVHowever, you'll need to make sure that you have sufficient rights when you come to write there
p58699
aVIf you do need your application to write to  then the normal approach is to create a directory for your application during installation
p58700
aVBecause your installer will run elevated it can do this
p58701
aVIt must also add a permissive ACL to the new directory so that your application can later, when running as standard user, write to that folder
p58702
aVIf you want a configuration that is stored in the user profile then you should choose a location under , described as:
p58703
aVThe file system directory that serves as a common repository for application-specific data
p58704
aVBecause this is in the user profile, each user on the machine will have a separate copy of the configuration file
p58705
as(dp58706
g7
V505088
p58707
stp58708
a((dp58709
g2
(lp58710
VThe error handling for  is something of a disaster
p58711
aVRaymond Chen discusses it here: Why does ShellExecute return SE_ERR_ACCESSDENIED for nearly everything
p58712
aVSo, even if you can convert the handful of possible  errors into text, you'll find that you invariably get
p58713
aVAnd that's not very helpful
p58714
aVThe bottom line is that if you want real error reporting then you need to use
p58715
aVIf that fails you call  to get the Win32 error
p58716
aVTo turn it into an exception with the descriptive text, call
p58717
aVIf you just want the descriptive text associated with an error, you call
p58718
as(dp58719
g7
V505088
p58720
stp58721
a((dp58722
g2
(lp58723
VI'm assuming that the MATLAB array struct use col-major ordering
p58724
aVIn which case the struct constructor needs to look like this:
p58725
aVIf the native code expects row-major then it's simpler
p58726
aVA C# multi-dimensional array is stored as a contiguous row-major array
p58727
aVSo you can use code very similar to the one dimensional code I provided in your recent question
p58728
aVNote well that these two variants differ in the way they pass the data to the native code
p58729
aVThe first version passes a copy of the original data
p58730
aVThe second passes a reference to the original data
p58731
aVI'm not sure how you want your code to behave
p58732
aVIt's easy enough to adapt the second version to pass a copy
p58733
aVAs for the first version, if you wanted the native code to modify the data and have those modifications reflected back to the managed code, then you'd need to marshal the modifications back after the native call returned
p58734
as(dp58735
g7
V505088
p58736
stp58737
a((dp58738
g2
(lp58739
VConsider writing to a file
p58740
aVThis is an expensive operation
p58741
aVIf in your code you write one byte at a time, then each write of a byte is going to be very costly
p58742
aVSo a common way to improve performance is to store the data that you are writing in a temporary buffer
p58743
aVOnly when there is a lot of data is the buffer written to the file
p58744
aVBy postponing the writes, and writing a large block in one go, performance is improved
p58745
aVWith this in mind, flushing the buffer is the act of transferring the data from the buffer to the file
p58746
aVDoes this clear the buffer my deleting everything in it or does it clear the buffer by outputing everything in it
p58747
aVThe latter
p58748
as(dp58749
g7
V505088
p58750
stp58751
a((dp58752
g2
(lp58753
VYou are essentially asking how to read the contents of a  into a C# object
p58754
aVLet's first consider a 1D array
p58755
aVRead it like this:
p58756
aVAnd that's it
p58757
aVYou'd want to assert that
p58758
aVAnd you may not need to do the  step
p58759
aVYou probably still have access to the array you passed for  and so you can just use that
p58760
aVThe two dimensional case is just more of the same
p58761
aVAgain you'll want to check that
p58762
aVThat puts the data in a one-dimensional array and presumably you'll want to put this into a two-dimensional managed array
p58763
aVAssuming the MATLAB is col-major, you'll need to deal with the col-major to row-major translation
p58764
as(dp58765
g7
V505088
p58766
stp58767
a((dp58768
g2
(lp58769
VThe simplest solution is as follows:
p58770
aVFrom the original process, process A say, use  to create a new process, process B, say
p58771
aVProcess B runs as a different user
p58772
aVPass to process B command line arguments that specify the file that you want to open
p58773
aVFrom process B call  or  to open the other file
p58774
as(dp58775
g7
V505088
p58776
stp58777
a((dp58778
g2
(lp58779
VI want to make my MDI MFC application topmost of all other applications' windows
p58780
aVThis is simply not possible
p58781
aVIf your application could do that, then so could the other applications
p58782
aVOnly one could win, and there's no reason why your application could be more special than the others
p58783
as(dp58784
g7
V505088
p58785
stp58786
a((dp58787
g2
(lp58788
VYour algorithm is not a root finder
p58789
aVTo recap, your recursive step is
p58790
aVCn = f(Cn-1)
p58791
aVand you terminate when Cn equals Cn-1 up to tolerance
p58792
aVThat algorithm may find fixed points, but it won't find roots
p58793
aVTo find roots you need something like Newton's method, bisection, secant method, etc
p58794
aVEven as a fixed point finder, your code is broken
p58795
aVThe first time the code performs the termination test, it reads the value of  before initializing it
p58796
aVIn the comments you tell us that you asked the wrong question, and that you are trying to find fixed points
p58797
aVIn which case you just need to modify the code to avoid reading variables before they are initialised:
p58798
aVAlso the function in your code doesn't match the one in the question
p58799
aVI don't know which one is right
p58800
as(dp58801
g7
V505088
p58802
stp58803
a((dp58804
g2
(lp58805
VA C parameter of type  is a pointer to a null-terminated array of 8 bit characters
p58806
aVIn Delphi the equivalent type is
p58807
aVYou cannot use  since that is a managed Delphi type that has no equivalent in C
p58808
aVIn addition, the error function prototype has void return value
p58809
aVYou are returning a pointer and that's an error
p58810
aVThe bigger problem that you have is that you cannot readily implement a C style function that receives a variable number of arguments in Delphi
p58811
aVYou can declare and call such a function, but you cannot implement one
p58812
aVThis means that such a function, with variable arguments, has to be an external function
p58813
aVNow, you could write your own assembler routine to full off the variable arguments
p58814
aVHowever, that's not the route I would take
p58815
aVI would write the function in C and then compile it to a
p58816
aVobj file that can be linked into your Delphi program with
p58817
aVIf you don't actually need to read off the variable arguments, you can ignore them like this:
p58818
aVNote that I have made the following changes:
p58819
aVChange the type name to be prefixed with  which is standard
p58820
aVCorrected the type of the  parameter
p58821
aVChanged from function to procedure to match the C declaration
p58822
aVRemoved the  which we cannot implement in Delphi and thus ignore the additional parameters
p58823
aVThen your imported function would look like this:
p58824
aVAnd then you can implement the error callback function like this:
p58825
as(dp58826
g7
V505088
p58827
stp58828
a((dp58829
g2
(lp58830
VThere is no supported way to hide a process from the system task manager
p58831
as(dp58832
g7
V505088
p58833
stp58834
a((dp58835
g2
(lp58836
VSo my question is, am I still able to create a plugin in C# that will export a function like above
p58837
aVIf not, what languages are able to do that apart from C++
p58838
aVAll of the mainstream programming environments on Windows can produce and consume COM interfaces
p58839
aVC, C++, C#, VB6, VB
p58840
aVnet, Delphi and so on
p58841
aVSo, yes, you can use COM interfaces for your task
p58842
aVAs a point of detail, what you can't do is pass an interface out of a Delphi DLL as the return value of a function
p58843
aVThat's because Delphi uses non-standard semantics for function return values
p58844
aVInstead you need to return it via an out parameter
p58845
aVSo you'd need to write your  like this:
p58846
as(dp58847
g7
V505088
p58848
stp58849
a((dp58850
g2
(lp58851
VWhat you are attempting to do is not supported:
p58852
aVMicrosoft does not currently recommend, and does not support, Automation of Microsoft Office applications from any unattended, non-interactive client application or component (including ASP, ASP
p58853
aVNET, DCOM, and NT Services), because Office may exhibit unstable behavior and/or deadlock when Office is run in this environment
p58854
aVYou can automate Excel if the process is run in an interactive desktop
p58855
aVAttempts to automate Excel from a non-interactive desktop (e
p58856
ag217
aVfrom a session) are not supported and fail
p58857
as(dp58858
g7
V505088
p58859
stp58860
a((dp58861
g2
(lp58862
Vcompares two pointers
p58863
aVYou presumably want to compare the strings, rather than the addresses
p58864
aVUse  for that
p58865
aVYour use of a  loop is rather odd
p58866
aVWhat makes you think that  is going to return a different value when you call it the second time
p58867
aVOr the third time
p58868
aVYour function is not needed at all
p58869
aVYou simply need to call  passing the two strings that you wish to compare
p58870
aVSo, rather than calling , just do this:
p58871
as(dp58872
g7
V505088
p58873
stp58874
a((dp58875
g2
(lp58876
VThere's not a whole lot of documentation on the details of setting Delphi options using msbuild
p58877
aVThe procedure I follow is as follows:
p58878
aVFind the setting you wish to control in the IDE
p58879
aVMake a change to that setting and observe how that change is effected in the
p58880
aVdproj file
p58881
aVHopefully you will now have the name of a property that can be set by passing the  argument to msbuild, i
p58882
ag192
aVIn the case of the output file name, to the very best of my knowledge, there is no option in the IDE or
p58883
aVdproj file, or even to , that allows you to control the output file name
p58884
aVWhich means that your only option is to do the renaming as part of your build script
p58885
as(dp58886
g7
V505088
p58887
stp58888
a((dp58889
g2
(lp58890
VIt is indeed a scan code and for many keyboards it is the scan code for the NumLock key
p58891
aVThe example code attached to the documentation of  is an example of how to toggle the NumLock state
p58892
aVAnd so naturally 0x45 is used as the scan code
p58893
aVMy guess is that lots of the other examples that you found simply copied blindly that value from the  MSDN example
p58894
aVSince applications typically ignore the scan code and respond to the virtual key code, it usually doesn't matter what value is passed as the scan code
p58895
aVFinally, you'll want to use  rather than
p58896
aVThe reason being that that former allows you to place a sequence of events in the queue
p58897
aVWith  you place the events in the queue one at a time and it's possible that your faked events can get interspersed with real events
p58898
aVAnd that problem is one of the main reasons why  was introduced
p58899
as(dp58900
g7
V505088
p58901
stp58902
a((dp58903
g2
(lp58904
VYou cannot possibly hope to call a C++ library like this using P/invoke
p58905
aVYou've simply got the wrong tool for the job
p58906
aVWhat you need to do is use a C++/CLI mixed mode layer to do the work
p58907
aVNot only will this have the obvious benefit of actually working, it will be far easier too
p58908
aVWrite C++ code that calls the native Qt DLLs
p58909
aVThen expose that code to your C# using managed classes
p58910
aVFinally you can simply add a reference to the C++/CLI library from your C# code and it's all good
p58911
as(dp58912
g7
V505088
p58913
stp58914
a((dp58915
g2
(lp58916
VFirst of all, I assume that you meant to write:
p58917
aVThe documentation answers your question:
p58918
aVIf a relative path is specified, the entire relative path is appended to every token in the DLL search path list
p58919
aVTo load a module from a relative path without searching any other path, use GetFullPathName to get a nonrelative path and call LoadLibrary with the nonrelative path
p58920
aVSo yes, you can specify a relative path
p58921
aVBut the way it is interpreted is perhaps not what you were expecting
p58922
aVThe DLL search will take each path in the DLL search path in turn, combine that with your relative path, and try to load that DLL
p58923
aVSo, if you want your relative path to be relative to the current working directory, call  to expand it to an absolute path, and then load that
p58924
aVIf you want your relative path to be interpreted relative to some other directory, then combine with that directory and load the DLL with an absolute path
p58925
as(dp58926
g7
V505088
p58927
stp58928
a((dp58929
g2
(lp58930
VYou are essentially asking the difference between
p58931
aVand
p58932
aVThe former is an expression that evaluates to
p58933
aVThe latter is an assignment that assigns  to
p58934
aVSo, the former does not modify , the latter does
p58935
as(dp58936
g7
V505088
p58937
stp58938
a((dp58939
g2
(lp58940
VYou need to execute this command:
p58941
aVand then parse the output
p58942
aVThe output looks a little like this:
p58943
aVUse  to execute the  command and read in the output
p58944
aVThen parse it however you feel like
p58945
aVFor example you could use a simple regex with  to find the information
p58946
as(dp58947
g7
V505088
p58948
stp58949
a((dp58950
g2
(lp58951
VYou use  to instantiate an object
p58952
aVThe call to  returns an object and it is up to that function to either instantiate a new object, or return an existing one
p58953
aVThe warning from Resharper is accurate
p58954
aVYour second block of code instantiates a new object and stores a reference to that new object in :
p58955
aVYour code then immediately loses that reference by replacing it with whatever is returned from the function call:
p58956
aVIn other words the first line, the one that used  is pointless and should not be present
p58957
as(dp58958
g7
V505088
p58959
stp58960
a((dp58961
g2
(lp58962
VThere is nothing in the built-in control to allow you to change this behaviour
p58963
aVIn fact the behaviour that you are observing is the as-designed behaviour of the underlying Windows control
p58964
aVYou can verify this readily by creating a raw Win32  control with the  style
p58965
aVSo the control already is showing correctly
p58966
aVIf you really wish to change the appearance, you will need to paint the tabs yourself
p58967
as(dp58968
g7
V505088
p58969
stp58970
a((dp58971
g2
(lp58972
VDDE is built on top of windows messages
p58973
aVYou need to make sure that messages are dispatched on the thread that has the DDE connection
p58974
as(dp58975
g7
V505088
p58976
stp58977
a((dp58978
g2
(lp58979
VThe font smoothing of text is determined by the font that you select into the device
p58980
aVTo learn about the options offered by the raw Win32 interface, read the  documentation
p58981
aVIn Delphi the underlying Win32 API font API is wrapped up by the  class
p58982
aVThe property that is pertinent to this question is
p58983
aVThe default value is  which uses the system-wide font smoothing setting
p58984
aVYou want to set  to either  or
p58985
aVOlder versions of Delphi do not have this property
p58986
aVIn which case you will need to call  to create an  with the required quality settings
p58987
aVYou can call this function immediately before you start drawing text:
p58988
aVPass either  or  depending on your needs
p58989
as(dp58990
g7
V505088
p58991
stp58992
a((dp58993
g2
(lp58994
VHere's something very crude
p58995
aVIt uses a rather limited tab-delimited text format
p58996
aVThe contents are not allowed to contain inline tab characters
p58997
aVI've also implemented no error checking whatsoever on the load function
p58998
aVI'm sure you can add that
p58999
as(dp59000
g7
V505088
p59001
stp59002
a((dp59003
g2
(lp59004
VThe type library only describes how to call the library
p59005
aVThe
p59006
aVpas file generated from the type library also only describes how to call the library
p59007
aVThat's all compile time
p59008
aVAt run time when you actually call the library, you need the library to be registered and present
p59009
aVSo yes, you'll need to distribute and register the library
p59010
as(dp59011
g7
V505088
p59012
stp59013
a((dp59014
g2
(lp59015
VI wouldn't use that code at all
p59016
aVIt's really weak in my view
p59017
aVHere's something better:
p59018
aVThis uses operator overloading to implement the , ,  and  operators
p59019
aVYou will find the code that you can write based on this  record to be much more expressive than the component you refer to in the question
p59020
aVThere is more functionality implemented in the code that you have linked to
p59021
aVHowever, it's easy to extend the record in this answer to add more functionality
p59022
aVOf course, since you have Delphi 7, the code in this answer is of no help to you
p59023
aVThat's because operator overloading wasn't introduced until later
p59024
aVIf you are going to do any serious mathematics you need operator overloading to make your code readable
p59025
as(dp59026
g7
V505088
p59027
stp59028
a((dp59029
g2
(lp59030
VYou can do this with  and , the integer division and modulus operators
p59031
as(dp59032
g7
V505088
p59033
stp59034
a((dp59035
g2
(lp59036
VThe documentation link is here:
p59037
aVBoolean short-circuit evaluation
p59038
aVType    Switch
p59039
aVSyntax  {$B+} or {$B-} {$BOOLEVAL ON} or {$BOOLEVAL OFF}
p59040
aVDefault {$B-} {$BOOLEVAL OFF}
p59041
aVScope   Local
p59042
aVThe $B directive switches between the two different models of Delphi
p59043
aVcode generation for the and and or Boolean operators
p59044
aVIn the {$B+} state, the compiler generates code for complete Boolean
p59045
aVexpression evaluation
p59046
aVThis means that every operand of a Boolean
p59047
aVexpression built from the and and or operators is guaranteed to be
p59048
aVevaluated, even when the result of the entire expression is already
p59049
aVknown
p59050
aVIn the {$B-} state, the compiler generates code for short-circuit
p59051
aVBoolean expression evaluation, which means that evaluation stops as
p59052
aVsoon as the result of the entire expression becomes evident in left to
p59053
aVright order of evaluation
p59054
aVAs you can see, the default option is for short-circuit evaluation
p59055
aVUnfortunately you got a little mixed up in your test
p59056
aVYour Delphi code is in fact quite different from the C code
p59057
aVIn Delphi the  operator has a higher precedence than the equality operator
p59058
aVWhich means that your Delphi code is equivalent to:
p59059
aVBut in C and C++, the precedence is the other way around
p59060
aVSo  has lower precedence than
p59061
aVAnd so the Delphi and C++ if statements in your question are logically different, irrespective of short-circuit evaluation
p59062
aVI'm quite sure that you really meant to write your Delphi code like this:
p59063
aVThat would give the same logic as your C++ code, and you would have seen the same behaviour due to short circuit evaluation
p59064
aVFinally, you should never test against  and  in Delphi
p59065
aVAlways write the code like this:
p59066
as(dp59067
g7
V505088
p59068
stp59069
a((dp59070
g2
(lp59071
VIf you really do want to sleep, you simply call
p59072
aVIn the most basic terms, your thread's main execution loop would look like this:
p59073
aVYou should not call  on the main service thread
p59074
aVCall it on a background thread
p59075
aVSo the idea is that the main service thread stays alive and ready to process any service messages
p59076
aVAnd the background thread does the actual work
p59077
aVAnd yes, sleeping is something to be avoided in general
p59078
aVIdeally you want a blocking queue that you can wait on in case it is empty
p59079
aVAnd then, when items are added to the queue, your thread will wake
p59080
as(dp59081
g7
V505088
p59082
stp59083
a((dp59084
g2
(lp59085
VThe most obvious flaw is that you are writing off the end of all of your arrays
p59086
aVFor example, you write
p59087
aVand that means that the valid indices for  are  to  inclusive
p59088
aVBut then you write
p59089
aVand that is an out of bounds access because the last index is
p59090
aVYou do the same for all your array access
p59091
aVIf you compile with range checking enabled, the compiler will generate a runtime error that explains what you have done wrong
p59092
aVPersonally I think you would be better using a record to hold your four components:
p59093
aVAnd use a  as your container
p59094
as(dp59095
g7
V505088
p59096
stp59097
a((dp59098
g2
(lp59099
VSystem
p59100
aVXML
p59101
aVdll is a
p59102
aVnet library
p59103
aVAs such you cannot readily use it from a native development tool like Delphi
p59104
aVYou could wrap it in a COM object
p59105
aVOr you could use the
p59106
aVnet API to spin up the
p59107
aVnet runtime
p59108
aVOr you could use Robert Giesecke's Unmanaged Exports to make the
p59109
aVnet library consumable from your native code
p59110
aVHowever, all of those options are rather involved
p59111
aVYou will likely be better off finding a native library that meets your needs
p59112
as(dp59113
g7
V505088
p59114
stp59115
a((dp59116
g2
(lp59117
VYou can indeed do that
p59118
aVThen the following code, located in a different unit of course, does not compile:
p59119
aVIt's not a good idea to do this though
p59120
aVNow consider this class, again declared in a different unit
p59121
aVIf  ever executes, then the  statement does nothing
p59122
aVThat's because  is private
p59123
aVSo, my advice is that whilst what you propose is possible, that you do not do it
p59124
aVAs a rule of thumb you should avoid reducing the visibility of members
p59125
as(dp59126
g7
V505088
p59127
stp59128
a((dp59129
g2
(lp59130
VYou don't always initialize
p59131
aVIf none of your  conditions evaluate to true, then it will be uninitialized
p59132
aVYou'll need to make sure that you always initialize it
p59133
aVWhat's more you must not pass  to  since that will print the address of  which I am sure is not what you desire
p59134
aVPass  instead
p59135
aVWhen you wrote:
p59136
aVI presume that you in fact meant:
p59137
as(dp59138
g7
V505088
p59139
stp59140
a((dp59141
g2
(lp59142
VI would write it like this, in all versions of Delphi:
p59143
aVIt's always worth avoiding casts if possible
p59144
aVIn this case you are wanting to increment an ordinal value, and  is what does that
p59145
aVThe reason your typecast failed is that casts on the target of an assignment are special
p59146
aVThese typecasts are known as variable typecasts and the documentation says:
p59147
aVYou can cast any variable to any type, provided their sizes are the same and you do not mix integers with reals
p59148
aVIn your case the failure is because the sizes do not match
p59149
aVThat's because  is two bytes wide in Unicode Delphi
p59150
aVSo, the most literal conversion of your original code is:
p59151
aVHowever, it's just better and clearer to use
p59152
aVIt's also conceivable that your uuencode function should be working with  since uuencode maps binary data to a subset of ASCII
p59153
aVIf you did switch to  then your original code would work unchanged
p59154
aVThat said, I still think  is clearer
p59155
as(dp59156
g7
V505088
p59157
stp59158
a((dp59159
g2
(lp59160
VIf the external tool needs admin rights then you have no choice
p59161
aVYou will need to run it elevated
p59162
aVYou can do that programmatically though
p59163
aVYou don't need to set the compatibility options of the executable file to check the Run as administrator option
p59164
aVWhat you need to do is start the process by calling  or  and pass  as the verb
p59165
as(dp59166
g7
V505088
p59167
stp59168
a((dp59169
g2
(lp59170
VThere's absolutely no problem with your compiler
p59171
aVThe compiler is free to choose how to compile your code, and it chose not to modify the stack pointer
p59172
aVThere's no need for it to do so since your function doesn't call any other functions
p59173
aVIf it did call another function then it would need to create another stack frame so that the callee did not stomp on the caller's stack frame
p59174
aVAs a general rule, you should avoid trying to make any assumptions on how the compiler will compile your code
p59175
aVFor example, your compiler would be perfectly at liberty to opimize away the body of your function
p59176
as(dp59177
g7
V505088
p59178
stp59179
a((dp59180
g2
(lp59181
VI expect that -1 was chosen because that value can never be used for an ID
p59182
aVIn which case it can be used to signal that the ID is invalid
p59183
aVIt would seem that the designer of this function intended callers to check whether or not the return value is the special sentinel value -1
p59184
aVIf -1 is returned, then the caller is expected to take appropriate steps
p59185
aVFor example, the caller may show or log an error message
p59186
as(dp59187
g7
V505088
p59188
stp59189
a((dp59190
g2
(lp59191
VYour code fails to compile because the compiler cannot guarantee at compile time of the generic class that there is a possible conversion to all conceivable
p59192
aVWhen faced with
p59193
aVin the generic method the compiler needs to know how to convert  to
p59194
aVAnd it cannot do so
p59195
aVThis is one of the limitations of generics in comparison with templates
p59196
aVThe easiest solution for you is to do the conversion at runtime with help from  from the  unit
p59197
aVAnd here's a sample test program to demonstrate that  does the job:
p59198
aVOutput
p59199
ag25125
ag34876
aVhello
p59200
aV-666
p59201
as(dp59202
g7
V505088
p59203
stp59204
a((dp59205
g2
(lp59206
VThere are two sentences
p59207
aVFirst of all:
p59208
aVAccessing the input buffer while a read operation is using the buffer may lead to corruption of the data read into that buffer
p59209
aVFollowed by:
p59210
aVApplications must not read from, write to, reallocate, or free the input buffer that a read operation is using until the read operation completes
p59211
aVThe documentation does not explicitly say that each of the actions mentioned in the second sentence may lead to the corruption described in the first sentence
p59212
aVIt says the following:
p59213
aVAccessing input buffer during read may corrupt that buffer, and
p59214
aVDo not read, write, reallocate or free the buffer during read
p59215
aVSo, as I interpret the documentation, it does not state that reading from the buffer during a read operation can corrupt it
p59216
as(dp59217
g7
V505088
p59218
stp59219
a((dp59220
g2
(lp59221
VYou are using  to allocate an memory for an object
p59222
aVThat will allocate the memory, but it will not initialize the object
p59223
aVThat's a problem for the non-POD members, for example
p59224
aVInstead of using malloc you need to use
p59225
aVWhen you are done with the struct, use  to dispose of it
p59226
aVSince you are using C++ you should forget all about  and
p59227
aVHeap allocations are performed with  and  in C++
p59228
as(dp59229
g7
V505088
p59230
stp59231
a((dp59232
g2
(lp59233
VWhat is happening is that F1 gets special treatment by the system
p59234
aVYes it is true that your menu item's handler that has a shortcut of F1 fires
p59235
aVBut after that handler has fired, the app receives a  message
p59236
aVThis  message is processed initially by
p59237
aVThis looks up the help context ID associated with the active control
p59238
aVAnd then  is called using that help context
p59239
aVAnd presumably the active control's help context ID differs from that of the form
p59240
aVSo, although your menu item opens the help file at your preferred topic, the subsequent  overrides the menu item
p59241
aVIt appears that you want all F1 always to route to the form's help context ID
p59242
aVIn which case, my advice would be as follows:
p59243
aVSet the  for the form
p59244
aVRemove all  properties for all other controls on your form
p59245
aVIn other words, revert them to the default value of
p59246
aVThen when the  message is handled, it starts at the active control and find a help context of
p59247
aVThen it will rise up through the parents to the form, which is non-zero
p59248
aVI think that I would also remove the F1 shortcut from the menu item / action
p59249
aVAnd let the  message be the mechanism for invoking help
p59250
as(dp59251
g7
V505088
p59252
stp59253
a((dp59254
g2
(lp59255
VYou are correct to set  to be the handle of the main form of the host app
p59256
aVThis will make the host app's main window be the owner of your windows
p59257
aVHowever, as you have observed, that also keeps your top-level windows off the taskbar
p59258
aVThat's because owned top-level window's do not appear in the taskbar
p59259
aVTo put an owned top-level window on the taskbar you should include the  extended window style
p59260
aVAdd this in your form's  procedure
p59261
aVThen you can use  and , passing your form's handle, to display taskbar progress for your form's taskbar button
p59262
aVI must admit I find your code odd:
p59263
aVSince the code is running in your DLL, which also created the form, you shouldn't be using  to obtain the handle
p59264
aVYou can just use  where  is the reference to your form instance
p59265
aVThat said, I'd still prefer the approach outlined above, using , since it is resilient to window handle re-creation and feels rather simpler to me
p59266
as(dp59267
g7
V505088
p59268
stp59269
a((dp59270
g2
(lp59271
VYour QA testers can equally use FastMM to detect memory leaks
p59272
aVYou just need to give them a build which enables memory leak detection
p59273
as(dp59274
g7
V505088
p59275
stp59276
a((dp59277
g2
(lp59278
VYou can paint your image in an  handler for the form
p59279
aVHere's a simple example of tiling:
p59280
aVIn real code you would want to cache the bitmap rather than load it every time
p59281
aVI'm sure you can work out how to adapt this to centre a bitmap
p59282
aVThe output looks like this:
p59283
aVHowever, since this is the background to the form, it's much better to do the painting in a handler for
p59284
aVThat will also make sure that you won't have any flickering when you resize
p59285
aVHere's a more advanced version of the program that demonstrates this, together with a stretch draw option
p59286
as(dp59287
g7
V505088
p59288
stp59289
a((dp59290
g2
(lp59291
VTrying to control rigidly what's shown in a file dialog through a filter or a file name pattern is not going to work
p59292
aVThe user can always type their own pattern into the file name edit box
p59293
aVWhat you need to do is use the file dialog's facilities for controlling what objects are displayed
p59294
aVUnfortunately the C# wrapper doesn't expose this functionality that is offered by the underlying Win32 controls
p59295
aVIf you need to support XP, then you need to listen for the  notification
p59296
aVThis is sent for each item in the folder
p59297
aVYou therefore get the opportunity to either allow or deny the inclusion of each item
p59298
aVFor the dialogs used in Vista and later it's different
p59299
aVThese dialogs use
p59300
aVYou need to call the  method to add a filter
p59301
aVThat filter is your implementation of  which again controls inclusion using the  method
p59302
aVIt's going to be a bit messy to make all this happen from C#, but this is the correct way to do what you ask
p59303
aVOnce you do this, there's no need to even think about trying to make the file name edit box read-only
p59304
aVBecause the dialog will only offer up the items that you have allowed to be included
p59305
as(dp59306
g7
V505088
p59307
stp59308
a((dp59309
g2
(lp59310
VThe Delphi libraries choose to implement all floating point assignments to variants by means of a call to
p59311
aVAnd that function looks like this:
p59312
aVNote that this uses a type of
p59313
aVAnd includes an implicit conversion to  which is an alias for
p59314
aVI'm not sure why the designers chose that particular route, but the consequence of that choice is the behaviour that you observe
p59315
aVA simple way to make a  variant you can use:
p59316
aVAlthough this will convert  to , and then back again to
p59317
aVTo avoid that needless conversion, write your own helper:
p59318
aVwhich you can call like this:
p59319
aVThis latter approach is the correct solution in my opinion
p59320
as(dp59321
g7
V505088
p59322
stp59323
a((dp59324
g2
(lp59325
VThe application must perform the resize
p59326
aVAnd it does so when it receives a  message for the parent control
p59327
aVYou are not going to be able change this by modifying the resources in a pre-existing binary
p59328
aVYou are going to need to write some code to respond to that message
p59329
as(dp59330
g7
V505088
p59331
stp59332
a((dp59333
g2
(lp59334
VThat painting is done by the special explorer theme
p59335
aVThat is added to the control by a call to  in
p59336
aVIf you use the default theme then you will not get the hot tracking
p59337
aVYou can make that happen by reverting the explorer window theme
p59338
aVFor example in an interposer class:
p59339
aVOf course, you'll also lose everything else that the explorer theme adds
p59340
aVSo far as I can tell, there are no notification messages that allow you to suppress the explorer theme hot tracking painting
p59341
as(dp59342
g7
V505088
p59343
stp59344
a((dp59345
g2
(lp59346
V is VB6 legacy
p59347
aVYou should use p/invoke and the DllImport attribute
p59348
aVThere are lots of ways that this could fail
p59349
aVPerhaps the DLL is not loading because there's a 32/64 bit mismatch
p59350
aVAlso, your calling conventions do not match
p59351
aVYour DLL will be using cdecl but your VB code uses stdcall
p59352
aVThe pinvoke above fixes that
p59353
aVMost seriously your function does not appear to have been exported from the DLL
p59354
aVThat's going to make it fail for sure
p59355
aVUse Dependency Walker to determined whether or not your function has been exported
p59356
aVI'm not so familiar with g++ so you'll have to work out how to export your function using the GNU toolchain
p59357
aVBut watch out for name decoration and name mangling
p59358
aVYou may need to take care with how you export your function so that it is exported with the desired name
p59359
as(dp59360
g7
V505088
p59361
stp59362
a((dp59363
g2
(lp59364
VThere is no formal concept of a background process in Windows
p59365
aVI guess what you mean is that you don't want the process to show a GUI
p59366
aVYou can achieve that by:
p59367
aVMaking the process target the GUI subsystem rather than the console subsystem
p59368
aVA process that targets the console subsystem is automatically given a console window when it is started
p59369
aVNot creating a visible window
p59370
aVIf you wish the process to run with a lower priority then you can do that by calling  but I'd be surprised if you needed to do that
p59371
as(dp59372
g7
V505088
p59373
stp59374
a((dp59375
g2
(lp59376
VError: found 'unsigned int' expected a double Warning: missing prototype
p59377
aVThis indicates that you are calling a function that does not have a prototype
p59378
aVWhen that happens your compiler assumes a default return value type of
p59379
aVThe solution is to add the missing prototype
p59380
aVThe code that you have posted is incomplete
p59381
aVIt would seem that the call to  is triggering the error
p59382
aVBut the  is clearly defined
p59383
aVMost likely in the real code  is either in a different file, or is first declared below
p59384
aVYou should be configuring your compiler so that it does not accept function calls if the function has not been declared
p59385
aVThe fact that the C language accepts such things dates back to the very early days of the language
p59386
aVYou should configure your compiler to disallow these ancient and bad practises
p59387
aVYour program is going to fail at runtime when you do get it to compile
p59388
aVYou will overflow  in the loop in
p59389
aVFinally, your  function is declared incorrectly
p59390
aVIt should be
p59391
as(dp59392
g7
V505088
p59393
stp59394
a((dp59395
g2
(lp59396
VThat creates a new property rather than overriding the existing property
p59397
aVAnd in fact it is not possible to override properties
p59398
aVIf  was virtual then you could override the setter
p59399
aVYou can access the inherited property though
p59400
aVLike this:
p59401
aVThe problem with this is that your property won't displace the  property in the
p59402
aVdfm files
p59403
aVWhen the
p59404
aVdfm files are read,  refers to the  property
p59405
aVYou can set your property at runtime if you have a reference to a
p59406
aVSo, whilst the code above will compile, I don't expect that it will solve your problem
p59407
aVI've answered the direct question of how to access an inherited property from a derived class, but I don't think I've solved your actual problem
p59408
aVMy instincts are that your proposed design, and the code above, is a bad idea
p59409
aVSince modifying form style will result in window re-creation, perhaps what you really need is to override  or
p59410
as(dp59411
g7
V505088
p59412
stp59413
a((dp59414
g2
(lp59415
VUsing that dialog to add resources results in modifications to the
p59416
aVdproj file
p59417
aVThat's the master source
p59418
aVYour
p59419
aVdproj file should have items like this:
p59420
aVThe compiler will use the information from the
p59421
aVdproj file to create and compile a
p59422
aVrc file and name the output
p59423
aVdres
p59424
aVThat
p59425
aVdres file is then linked to your application
p59426
aVIf those items are present in the
p59427
aVdproj file, then items will appear in that dialog
p59428
aVIf your
p59429
aVdproj file has been lost and re-created then the items will not appear in that dialog
p59430
aVThat's the most likely explanation for what you observe
p59431
aVYou'll need to add the files again, and make sure that you look after your
p59432
aVdproj file
p59433
aVI trust it is in your revision control system
p59434
aVThe reason why you can still get hold of the images at runtime is that the
p59435
aVdres file is still present and is still linked in when you re-build the application
p59436
aVBut the
p59437
aVdres file is not being re-created because the settings have been lost from the
p59438
aVdproj file
p59439
as(dp59440
g7
V505088
p59441
stp59442
a((dp59443
g2
(lp59444
VThere is no iterator on  that returns a reference to a value
p59445
aVAll the iterators provide values and that means that what you are asking for is not possible with the current design
p59446
aVIn other languages, for example C++ and D that I know, references are first class citizens in the language
p59447
aVYou can easily write iterators that enumerate references rather than values
p59448
aVThat's what you need to solve your problem concisely
p59449
aVUnfortunately the language is lacking
p59450
aVOne obvious option would be to switch to using reference types (class) rather than value types (record)
p59451
aVThat would solve the iteration problem in a stroke because would be iterating over references
p59452
aVHowever, one usually chooses to use value types for a good reason and you may have constraints that stop you making this switch
p59453
aVAnother possibility would be to write a container that offered iterators that provided pointers to the values
p59454
aVThat's as close as you can get to a reference to a record
p59455
aVBut you would have to roll your own container
p59456
as(dp59457
g7
V505088
p59458
stp59459
a((dp59460
g2
(lp59461
VClearly  evaluates to
p59462
aVWhich means that the clipboard in fact does not contain text in the format you specify
p59463
aVI changed your program to prove the point:
p59464
aVOutput:
p59465
aVboo yah
p59466
aVchetan
p59467
as(dp59468
g7
V505088
p59469
stp59470
a((dp59471
g2
(lp59472
VAll of the mainstream compilers that are freely available can meet your needs:
p59473
aVVS 2012 Desktop Express ships with an x64 compiler
p59474
aVMingw is open source and easy enough to build
p59475
aVSo you can be as up-to-date as you like if you cannot find a binary distribution that meets your needs
p59476
aVClang is also open source and what I said above for Mingw applies equally
p59477
as(dp59478
g7
V505088
p59479
stp59480
a((dp59481
g2
(lp59482
VThe main problem is that your Fortran library expects the scalar parameters to be passed by reference
p59483
aVSo you need to declare your p/invoke to match
p59484
aVThe array parameters can be passed quite simply as arrays and the p/invoke marshaller will pin them for you
p59485
aVSo, your p/invoke declaration should be like this:
p59486
aVYou can adjust the  attributes to meet your needs
p59487
as(dp59488
g7
V505088
p59489
stp59490
a((dp59491
g2
(lp59492
VThis is by design
p59493
aVThe purpose of  is to halt execution immediately
p59494
aVBy design it will not run any code in catch or finally blocks
p59495
aVThe documentation says:
p59496
aVThis method terminates a process without running any active
p59497
aVtry/finally blocks or finalizers
p59498
aVThe FailFast method writes the message string to the Windows
p59499
aVApplication event log, creates a dump of your application, and then
p59500
aVterminates the current process
p59501
aVThe messa string is also included in
p59502
aVerror reporting to Microsoft
p59503
aVUse the FailFast method instead of the Exit method to terminate your
p59504
aVapplication if the state of your application is damaged beyond repair,
p59505
aVand executing your application's try/finally blocks and finalizers
p59506
aVwill corrupt program resources
p59507
aVThis makes it clear that code in your finally blocks will not run
p59508
aVIf there was a way to make code run after  then that would render  pretty much useless
p59509
aVIts very existence is predicated on the fact that your code does not execute after you call it
p59510
aVYou point to documentation that states (emphasis mine):
p59511
aVUsually, when an unhandled exception ends an application, whether or not the finally block is run is not important
p59512
aVHowever, if you have statements in a finally block that must be run even in that situation, one solution is to add a catch block to the try-finally statement
p59513
aVBut those words simply do not apply here
p59514
aVYou are assuming that when you call , an unhandled exception terminates the application
p59515
aVThat is not the case
p59516
aVThe application is just terminated on the spot \u2013 there is no unhandled exception
p59517
as(dp59518
g7
V505088
p59519
stp59520
a((dp59521
g2
(lp59522
VMost likely you will have two instances of the VCL in your process, one for the host exe and one for the DLL
p59523
aVAnd that is one instance too many
p59524
aVThe TForm class from your host exe is a different class from the TForm class in your DLL
p59525
aVThe basic rule is that you cannot share VCL/RTL objects across module boundaries unless all modules use the same instance of the VCL/RTL runtime
p59526
aVThe way to make that happen is to link to the VCL/RTL using packages
p59527
as(dp59528
g7
V505088
p59529
stp59530
a((dp59531
g2
(lp59532
VYou can use  to locate the component by name
p59533
aVThis presupposes that the component is owned by the form object
p59534
aVChances are high that that is a valid assumption
p59535
aVPersonally I don't like this sort of code
p59536
aVI would create an array of edit controls:
p59537
aVThen in the constructor I would initialise the array:
p59538
aVThis makes the code that subsequently gets an edit control given an index much cleaner
p59539
aVIf you go down this route then it's likely to be easier to create the edit controls at runtime too rather than have to create them all in the designer, and then write that array assignment code in the constructor
p59540
aVIn outline, it looks like this
p59541
as(dp59542
g7
V505088
p59543
stp59544
a((dp59545
g2
(lp59546
VRead a file line by line like this:
p59547
aVThis prints each value to standard output
p59548
aVIf you want to output to a file it would be like this:
p59549
as(dp59550
g7
V505088
p59551
stp59552
a((dp59553
g2
(lp59554
VWhat file extension do memory mapped files have
p59555
aVMemory mapped files can have any file extension
p59556
aVYou can create a file mapping for any file
p59557
aVCan I use such a file, if I don't know its contents
p59558
aVYes, you can create a file mapping for any file without knowing its contents
p59559
aVThese answers are so trivial that I suspect that you don't fully understand what a memory mapped file is and why they are useful
p59560
aVI suspect that the question you should have asked is: What is a memory mapped file
p59561
as(dp59562
g7
V505088
p59563
stp59564
a((dp59565
g2
(lp59566
VWhen  is called, the  parameter  is
p59567
aVTo return something to the caller you need to assign to
p59568
aVThat's an empty super object
p59569
aVYou can now populate it with whatever values you like in the normal way
p59570
aVHere is a simple demonstration:
p59571
as(dp59572
g7
V505088
p59573
stp59574
a((dp59575
g2
(lp59576
VFor direct access you are expect to use the  method
p59577
aVThe documentation includes a number of examples, such as FMX
p59578
aVAlphaColorToScanline:
p59579
as(dp59580
g7
V505088
p59581
stp59582
a((dp59583
g2
(lp59584
VThe super method has signature as follows:
p59585
aVThis means that you cannot use an instance method since an instance method has an incompatible signature
p59586
aVYour method must look like this:
p59587
aVThe reason you get a runtime error rather than a compile time error is that you abandoned the type system by using the @ operator
p59588
aVRemove the @ and your program will fail at compile time with an error message that is a terser version of what I said above
p59589
aVIt's one of the great fallacies of Delphi programming that one must use the @ operator to obtain a function pointer
p59590
aVIt's a bad habit that you would do well to unlearn
p59591
as(dp59592
g7
V505088
p59593
stp59594
a((dp59595
g2
(lp59596
VThe problem is that these keys are used as dialog navigation keys
p59597
aVAnd as such, they never make their way to the  event
p59598
aVTo be honest I had a hard time understanding why they are firing for your main form's  event
p59599
aVI could not make that happen in my test environment
p59600
aVThat's because I had added a button to the form
p59601
aVThat's enough to mean that the arrow keys are treated as navigation keys
p59602
aVTry creating a an app with a single form and adding a few buttons
p59603
aVThen run the app and use the arrow keys to move the focus between the buttons
p59604
aVThat's what I mean when I say that the arrow keys are treated as navigation keys
p59605
aVI expect that the difference between your two forms is that the main form has nothing that can be navigated around by arrow keys, but the modal form does
p59606
aVNow, you could stop the arrow keys being treated as navigation keys
p59607
aVLike this:
p59608
aVHowever, a better solution, in my view, is to stop trying to implement shortcuts using  events
p59609
aVThat seems like the wrong solution
p59610
aVThe right solution is to use actions
p59611
aVCreate an action list
p59612
aVAdd actions for first, last, previous and next actions
p59613
aVGive them the appropriate  properties
p59614
aVAssign those actions to your buttons
p59615
aVAnd the job is done
p59616
aVOne of the benefits of this is that you can stop trying to fake button click events
p59617
aVFor what it is worth, calling  is the wrong way to do that
p59618
aVCall the button's  method if ever your really need to do that
p59619
aVHowever, use an action and it's all taken care of
p59620
aVAnother benefit is that you'll no longer need to pfaff around with
p59621
aVSimply put, if you want to implement short cuts, use
p59622
as(dp59623
g7
V505088
p59624
stp59625
a((dp59626
g2
(lp59627
VYou code for  is incorrect
p59628
aVYou want something like this, inspired by the VCL code for file dialogs:
p59629
aVYou can use  as your template for this code, if you can't actually use  itself
p59630
aVCome to think of it, why can't you just use
p59631
as(dp59632
g7
V505088
p59633
stp59634
a((dp59635
g2
(lp59636
VI think it's fair to say that there is a widely used convention
p59637
aVTypically a class declaration would be arranged like this:
p59638
aVIn other words the sections would be organised with the form designer's declarations first, and then in order of increasing visibility
p59639
aVInterestingly other conventions are used in other languages
p59640
aVFor example, take a look at the Google C++ style guidelines where the order of sections is the reverse of the above
p59641
aVPersonally I would prefer to see the public declarations first
p59642
aVWhen reading code that already exists I am typically reading with a top-down perspective
p59643
aVAnd often when writing code, I find that a top-down approach is beneficial
p59644
aVLooking at my  record, there is a reason why the declarations are ordered as they are
p59645
aVI have a number of such similar records and some of them are variant records
p59646
aVFor example:
p59647
aVNow, the variant part of the record must appear last
p59648
aVIt is a compilation error to do otherwise
p59649
aVAnd so there's simply no choice for this record
p59650
aVHaving established the convention for  and related records,  simply followed suit
p59651
as(dp59652
g7
V505088
p59653
stp59654
a((dp59655
g2
(lp59656
VI would recommend using Dependency Walker to debug dependency issues
p59657
aVYou can use it in a static mode, or a dynamic mode (from the Profile menu) to diagnose exactly what the loader is doing at runtime
p59658
aVThe latter mode sounds like what you are looking for
p59659
as(dp59660
g7
V505088
p59661
stp59662
a((dp59663
g2
(lp59664
VYou cannot use
p59665
aVdcu files from one version of Delphi in a different version
p59666
aVYou need to re-compile from source
p59667
aVHowever, that's much easier said than done
p59668
aVBecause of the Unicode changes introduced in Delphi 2009 your components will almost surely not work when re-compiled in the latest version of Delphi
p59669
aVYou'll need to get updated source for all the components
p59670
aVWhat's more you'll need to update your code too
p59671
aVThe starting point is Marco Cant's white paper on Unicode
p59672
as(dp59673
g7
V505088
p59674
stp59675
a((dp59676
g2
(lp59677
VEssentially what you are asking is whether or not you can write code that will be executed when an assembly is first loaded
p59678
aVThat question is addressed here:
p59679
aVNet: Running code when assembly is loaded
p59680
aVIn your position I would put the onus on the user of your library
p59681
aVProvide a function that initializes your library, and ask the user of the library to call it before any other function
p59682
aVYou could, if you wished, take that initialization inside your library using lazy initialization
p59683
aVSo, all of your methods could look like this:
p59684
aVI would also recommend against using
p59685
aVThere's an easier way to do it
p59686
aVSince you can get hold of the full path to the DLL that needs to be loaded, simply load it in  with a call to
p59687
aVOnce the DLL is loaded, your p/invokes will automatically be bound to the DLL that you already loaded
p59688
as(dp59689
g7
V505088
p59690
stp59691
a((dp59692
g2
(lp59693
VIt's simple enough to put together a  and  in the same manner as
p59694
aVIf you already know how these classes work, then you'll be able to follow the code below
p59695
aVThis is the most basic implementation possible
p59696
aVIf you wish you could add some more bells and whistles in the manner of
p59697
as(dp59698
g7
V505088
p59699
stp59700
a((dp59701
g2
(lp59702
VThat's going to be a little messy
p59703
aVYou'd need to do something like this
p59704
aVBasically you create an instance of  that is owned by the  that you pass to
p59705
aVWhen that  dies, it destroys the  which in turn destroys your string list
p59706
aVThe code is resilient to an explicit  being called on the string list
p59707
as(dp59708
g7
V505088
p59709
stp59710
a((dp59711
g2
(lp59712
VThe problem is that the calling conventions for the callback do not match
p59713
aVYour native code expects the callback to be , but the managed code declares it to be
p59714
aVYou can fix this either in the managed code or in the native code
p59715
aVFor simplicity, I'll show how to fix it in the managed code
p59716
aVSome other points:
p59717
aVDon't set the  parameter to  since your functions are not setting the Win32 last error
p59718
aVDon't use  anywhere in this code
p59719
aVAs a general rule you should avoid  and you just don't need it for any of this
p59720
as(dp59721
g7
V505088
p59722
stp59723
a((dp59724
g2
(lp59725
VAs the very first act of your program, check the parameters
p59726
aVIf they are fine, continue as normal
p59727
aVOtherwise call  passing
p59728
aVIf that succeeds, then you can print your error to stdout and quit
p59729
aVIf it doesn't, then you'll have to show the error in a message box
p59730
as(dp59731
g7
V505088
p59732
stp59733
a((dp59734
g2
(lp59735
VAll you need is this function:
p59736
aVFor some reason  interprets the strings in the  record as ANSI strings
p59737
aVI cannot find any documentation on this
p59738
aVI suspect it is simply a bug in the HtmlHelp file library
p59739
aVI think that the strings that you pass in  must be ANSI strings
p59740
as(dp59741
g7
V505088
p59742
stp59743
a((dp59744
g2
(lp59745
VThe simple answer to your question is that it is only possible to modify the extra class memory using
p59746
aVFor which you need a valid window handle
p59747
as(dp59748
g7
V505088
p59749
stp59750
a((dp59751
g2
(lp59752
VYou have byte buffers declared like this:
p59753
aVTo read a single value from that buffer, at offset  you simply write:
p59754
as(dp59755
g7
V505088
p59756
stp59757
a((dp59758
g2
(lp59759
VI think this is going to be difficult to do cleanly
p59760
aVSo far as I know, Word automation doesn't give you the opportunity to cancel long running events
p59761
aVIt also doesn't notify you of progress
p59762
aVProbably the best that you can do is first of all move the automation into a separate thread
p59763
aVThen throw up a marquee progress bar whilst the long running automation is in progress
p59764
aVAt least that will let the user know that something is happening
p59765
aVAs far as cancelling goes, you can let the user cancel from your progress dialog and then have your program continue
p59766
aVYou could kill the automation thread, but that would leave Word in a bad state
p59767
aVI'd just let it continue to completion, but then ignore the results
p59768
aVFrom the user's perspective this will meet your goals reasonably well, even if it's a little dirty behind the scenes
p59769
as(dp59770
g7
V505088
p59771
stp59772
a((dp59773
g2
(lp59774
VYou cannot perform arithmetic directly on a bookmark
p59775
aVTo do what you ask you need to go to the bookmark, and then move relative to that:
p59776
aVIf you wish, you could then save another bookmark representing that record
p59777
as(dp59778
g7
V505088
p59779
stp59780
a((dp59781
g2
(lp59782
VYou say that you create the class by calling:
p59783
aVThat code will allocate an instance, but will not run the constructor
p59784
aVAnd that is your problem
p59785
aVYou cannot expect an instance to work if you have not constructed it properly
p59786
aVYou need to use
p59787
aVNow, it sounds as though you want to be able to write code that can work on a variety of  descendent
p59788
aVYou can make that work
p59789
aVFirst of all declare your variable to be of type
p59790
aVAnd then get hold of a class reference
p59791
aVAnd then instantiate the object, if the class reference is compatible
p59792
aVBecause  uses a virtual constructor that will run the  constructor
p59793
aVYou could use this same code to construct JPEG, BMP, GIF etc
p59794
as(dp59795
g7
V505088
p59796
stp59797
a((dp59798
g2
(lp59799
VThe return value of  is used to indicate success or failure
p59800
aVThis is described in the documentation
p59801
aVReturn value
p59802
aVIf the function succeeds, the return value is the
p59803
aVprevious thread execution state
p59804
aVIf the function fails, the return
p59805
aVvalue is
p59806
aVThe value of  is simply  so you can check for success by comparing the return value against
p59807
aVSo there will not be an exception when it fails
p59808
aVThe return value will simply be
p59809
aVDon't expect Windows API functions to raise exceptions to signal failure
p59810
aVThey simply do not do that
p59811
aVThe p/invoke signature that you need, obtained from pinvoke
p59812
aVnet is:
p59813
aVThen you can call it like this
p59814
aVAnd if the call fails then raise an exception like this:
p59815
aVMost likely your problem is that you are using
p59816
aVI think you should be using
p59817
as(dp59818
g7
V505088
p59819
stp59820
a((dp59821
g2
(lp59822
VWhat is happening here is that the ownership of the object list is getting in the way
p59823
aVBecause you are using , anytime the list is asked to forget about a member, it will destroy it
p59824
aVThis happens in your code when you write:
p59825
aVThe member that is stored at index  before the assignment is destroyed to make room for the new item
p59826
aVEventually you will end up destroying an object that has already been destroyed and that's when your invalid pointer exception occurs
p59827
aVTo solve the problem could make use of the  method which allows you to remove an item without destroying it
p59828
aVOr as @Arioch smartly points out in the comments, the  method which is perfect for comparison sorts
p59829
aVEven easier would be to temporarily switch  to  during your sort, not forgetting to restore it when you were done
p59830
aVOr perhaps you didn't even mean to use
p59831
aVAnd in that case you want  instead
p59832
aVFrankly though you'd be far better off using the in-built  method that is originally exposed by
p59833
aVThere's simply no need for you to implement a sort method on a class that already comes with a perfectly decent one
p59834
as(dp59835
g7
V505088
p59836
stp59837
a((dp59838
g2
(lp59839
VWhat you are trying to do is not possible in Delphi
p59840
aVIt does not have an interpreter
p59841
aVWhat you need is to embed a scripting language
p59842
as(dp59843
g7
V505088
p59844
stp59845
a((dp59846
g2
(lp59847
VI infer from your question that you want to read the text contents of the cell as are presented to the user in Excel
p59848
aVI don't think you can perform the operation on an entire range
p59849
aVThe way I have done that in the past is like this
p59850
aVNote that I'm using early bound COM
p59851
aVIn fact this code came out of the very first question I ever asked here on Stack Overflow: How do I read the formatted textual representation of a cell in Excel
p59852
as(dp59853
g7
V505088
p59854
stp59855
a((dp59856
g2
(lp59857
VThe simplest way to run a message queue in a thread is as follows:
p59858
aVAnd in your thread procedure would look like this:
p59859
aVAll that said, what you are attempting is not going to work
p59860
aVYou appear to be trying to use VCL components away from the main thread
p59861
aVThat is specifically not allowed
p59862
aVThe VCL's threading model dictates that all VCL code is run on the main thread
p59863
aVYour attempts to create a VCL form away from the main thread are doomed to failure
p59864
aVI would question your desire to create a new thread
p59865
aVA Delphi DLL can show VCL forms provided that it runs those forms out of the thread that loaded and called the DLL
p59866
aVYou can call  from that thread and show a modeless form
p59867
aVThis means that you are relying on the host application's message queue to deliver messages to your windows
p59868
aVBy and large this can be made to work
p59869
aVIf your form is modal then you can simply call  and the form will be serviced by the standard Delphi modal message loop
p59870
aVSo my advice to you is to keep all your GUI in the host app's GUI thread
p59871
aVIf your DLL is expected to show GUI, and is also expected to do that away from the host app's GUI thread then you are in trouble
p59872
aVBut I think that's highly unlikely to be the case
p59873
as(dp59874
g7
V505088
p59875
stp59876
a((dp59877
g2
(lp59878
VI would suggest that modifying PATH is a very invasive solution
p59879
aVI would recommend attempting to avoid that
p59880
aVYou may be able to do that using SetDllDirectory
p59881
aVThis will add a directory to the search path, but will make that change locally to your process
p59882
aVYour host app should call SetDllDirectory immediately before loading your DLL
p59883
aVThen any dependencies of the DLL will be resolved using the modified search path
p59884
aVWhen the DLL has successfully loaded, call SetDllDirectory again to restore the search path to its default value
p59885
aVIf you aren't in control of the host then it might be tricky to implement this
p59886
aVYou'd need to call SetDllDirectory in your DLL and then it would be too late
p59887
aVYou could put another layer between the host and plugin
p59888
aVThat layer could modify the DLL search path and then use LoadLibrary to load the DLL that used implicit linking
p59889
aVThe other obvious option is to stop using implicit linking
p59890
aVUse LoadLibrary to resolve all your dependencies
p59891
aVThat's actually not as hard as it sounds
p59892
aVIn a modern Delphi you could use delay loading also
p59893
aVSo long as the DLL search path is modified, before you call into the delay loaded imports, they will resolve
p59894
as(dp59895
g7
V505088
p59896
stp59897
a((dp59898
g2
(lp59899
VYou need to override the  method of your form
p59900
aVIn that method you can implement any special handling you need for any Windows messages delivered to your form's window
p59901
aVTake care to follow the documentation to the letter:
p59902
aVNotes to Inheritors
p59903
aVInheriting controls should call the base class's
p59904
aVWndProc method to process any messages that they do not handle
p59905
as(dp59906
g7
V505088
p59907
stp59908
a((dp59909
g2
(lp59910
VThe error message is a little misleading
p59911
aVWhat it is saying, essentially, is that the  keyword cannot appear after the  keyword
p59912
aVThis is a bit of an aside, but if you are overriding a method then you do not need to, and should not, re-state the calling convention
p59913
aVYou cannot modify the calling convention when you override a method so it's best not to repeat it
p59914
aVHowever, when you fix that problem, your code will still not compile
p59915
aVAnd that is because he  function is not virtual
p59916
aVTherefore you cannot override it
p59917
aVI don't see how you can change the behaviour of the  implementation without re-declaring and re-implementing the entire implementation of
p59918
aVAnd I don't think that's at all easy to do
p59919
as(dp59920
g7
V505088
p59921
stp59922
a((dp59923
g2
(lp59924
VIt's going to be hard to beat that if you are targeting generic x86 hardware
p59925
aVThe runtime doesn't know for sure that the target machine has an SSE unit
p59926
aVIf it did, it could do what the x64 compiler does and inline a  opcode
p59927
aVBut since the runtime has to check whether an SSE unit is available, you are left with the current implementation
p59928
aVThat's what the implementation of  does
p59929
aVAnd what's more it passes the value in an x87 register and then transfers it to an SSE register if an SSE unit is available
p59930
aVYou could tell the x86 compiler to target machines that have SSE units
p59931
aVThen the compiler would indeed emit a simple  opcode inline
p59932
aVThat's going to be as fast as you can get
p59933
aVBut if you run the code on an older machine then it will fail
p59934
aVPerhaps you could supply two versions, one for machines with SSE, and one for those without
p59935
aVThat's not going to gain you all that much
p59936
aVIt's just going to avoid all the overhead of  that happens before you actually reach the  opcode that does the work
p59937
aVTo change the compiler settings from the IDE, use Project > Properties > Configuration Properties > C/C++ > Code Generation > Enable Enhanced Instruction Set
p59938
aVOn the command line it is /arch:SSE or /arch:SSE2
p59939
as(dp59940
g7
V505088
p59941
stp59942
a((dp59943
g2
(lp59944
VVirtual method dispatch in Delphi is known to work
p59945
aVSo, if  is not being executed then these are the possible reasons:
p59946
aVThe  method is not being called at all
p59947
aVThe actual instance on which  is being called is not an instance of
p59948
aVIf you showed the rest of the code then we could be more sure, but the above options should be enough for you to work it out
p59949
aVThe only place that calls  is
p59950
aVIf your overridden  doesn't call  then nothing else will
p59951
aVConsidering your updated code, I ran it under the debugger
p59952
aVWhen the button is clicked,  is called twice
p59953
aVThe first time it is called as a result of the call to  in
p59954
aVThe second time it is called you can inspect  to find out what class  is
p59955
aVWhen you do that you will find that  evaluates to
p59956
aVIn which case, item 2 from my list is the explanation
p59957
aVI don't really understand what you are trying to do here
p59958
aVHowever, I suspect that your problem stems from the way  is implemented
p59959
aVI suspect it should be like this:
p59960
aVThere should have been alarm bells going off when you assigned the return value of a  constructor to an object reference
p59961
aVThat's always an error
p59962
aVYou must assign that to an interface reference
p59963
aVI expect that what happens is that the dispatch code will use an  if it encounters one, but if it finds an instance of a class instead it creates a new  to do the work
p59964
aVAnd that's the third instance of
p59965
as(dp59966
g7
V505088
p59967
stp59968
a((dp59969
g2
(lp59970
VAt present I have resorted to having 'caller' methods on the host object which can then call the FMyObj instance when needed, but this is creating quite a bloated object with lots of single-line methods
p59971
aVThat is the right solution
p59972
aVSince the instance is not available at the point of initialisation you have no alternative
p59973
aVWhen you use  you are defining something called a method pointer
p59974
aVWhen you assign to a variable of method pointer type, the instance is captured at the point of assignment
p59975
aVThere is no mechanism for the instance associated with a method pointer to be dynamically resolved
p59976
aVThe only way to achieve that is to use runtime delegation, which is what you are currently doing
p59977
aVAs is so often the case, another layer of indirection is used to solve a problem
p59978
aVYour record that contains a number of methods looks awfully like an
p59979
aVI suspect that the most elegant solution will involve an
p59980
aVPerhaps at the point of calling you can call a function that returns an
p59981
aVAnd that function will using the value of  at the time of calling to locate the appropriate interface
p59982
as(dp59983
g7
V505088
p59984
stp59985
a((dp59986
g2
(lp59987
VYou can use the same compare function that Explorer uses, namely
p59988
aVIf you have your strings in a  instance then you can use its  method
p59989
aVThis expects a compare function of this form:
p59990
aVSo, feed  this function:
p59991
as(dp59992
g7
V505088
p59993
stp59994
a((dp59995
g2
(lp59996
VMulti-monitor systems are common nowadays
p59997
aVPlacing at the centre of the screen may spread the form across multiple monitors
p59998
aVThat's undesirable
p59999
aVSo I'd centre the form on its monitor:
p60000
aVAs @bummi points out, you can write:
p60001
aVThis almost works as you would wish
p60002
aVI will center the form on a screen
p60003
aVHowever, it always picks the default monitor
p60004
aVSo using that code could result in your form being moved onto a different monitor which I think would never be desirable
p60005
aVRather forcing the form to the centre, you may decide instead to grow or shrink it on all sides:
p60006
aVAnd if you wanted to get really cute you'd adjust the bounds rect so that the newly sized and positioned form did not go off the edge of the monitor
p60007
aVThen the previous code sample would be altered like this:
p60008
as(dp60009
g7
V505088
p60010
stp60011
a((dp60012
g2
(lp60013
VUI in WPF needs to execute on the UI thread
p60014
aVAnd you recognise that because I can see you using  to interact with your progress window
p60015
aVYour problem though is that you are executing your long-running task also on the UI thread
p60016
aVWhen you do that you don't give the progress window an opportunity to operate
p60017
aVThe thread is consumed by the long-running task and is thus unable to service the UI
p60018
aVThe solution is to execute the long-running task away from the UI thread
p60019
as(dp60020
g7
V505088
p60021
stp60022
a((dp60023
g2
(lp60024
VA macro has to expand to something that is not a macro
p60025
aVIt's not turtles all the way down
p60026
as(dp60027
g7
V505088
p60028
stp60029
a((dp60030
g2
(lp60031
VYou marshalling of the output string incorrectly
p60032
aVUsing  in the p/invoke declaration is appropriate when passing data from managed to native
p60033
aVBut you cannot use that when the data flows in the other direction
p60034
aVInstead you need to use
p60035
aVLike this:
p60036
aVThen allocate the memory for output:
p60037
aVAnd then you can call the function
p60038
aVOn the other hand, if these parameters have null characters in them then you cannot marshal as string
p60039
aVThat's because the marshaller won't marshal anything past the null
p60040
aVInstead you need to marshal it as a byte array
p60041
aVThat matches your C declaration
p60042
aVThen assuming the ANSI encoding you convert the input string to a byte array like this:
p60043
aVIf you want to use a different encoding, it's obvious how to do so
p60044
aVAnd for the output you do need to allocate the array
p60045
aVAssuming it's the same length as the input you would do this:
p60046
aVAnd somehow your C function has got to know the length of the arrays
p60047
aVI'll leave that bit to you
p60048
aVThen you can call the function
p60049
aVAnd then to convert the output array back to a C# string you use the  class again
p60050
as(dp60051
g7
V505088
p60052
stp60053
a((dp60054
g2
(lp60055
VThe problem is here:
p60056
aVThe first line replaces  with
p60057
aVThe second line replaces those new  with
p60058
aVAs Jon says, you need the replacement that escapes the escape character to run before introducing any escape characters
p60059
aVBut, I think you should use a real encoder
p60060
aV;-)
p60061
as(dp60062
g7
V505088
p60063
stp60064
a((dp60065
g2
(lp60066
VI suspect that to use A-links you need to do the following:
p60067
aVAssign an  handler as described below
p60068
aVAssign  during program startup
p60069
aVCall  if you wish to invoke the help system with an A-link
p60070
aVSet the  property for any GUI controls that you wish to respond to context sensitive F1 key presses
p60071
aVThe  handler looks like this:
p60072
aVThe  unit contains methods named  which do the same
p60073
aVBut I don't see how they could ever be called
p60074
aVThe above approach is a little bit hacky because it interprets keywords as A-Links
p60075
aVIf you want context sensitive help, I can't see what else you can do
p60076
as(dp60077
g7
V505088
p60078
stp60079
a((dp60080
g2
(lp60081
VCall  passing your
p60082
aVHey presto, an  is returned
p60083
aVFor what it's worth, a good way to look for the answer yourself is to go to the MSDN topic describing
p60084
aVScroll down to the bottom of the page and look at the See Also section
p60085
aVThe most important functions that use the type will be listed there, and indeed  is there
p60086
aVThat's always a useful way of finding out what can be done with any particular Win32 type
p60087
as(dp60088
g7
V505088
p60089
stp60090
a((dp60091
g2
(lp60092
VYour service runs in session 0
p60093
aVYour interactive desktop is in a different session
p60094
aVSo you will not see anything when your service starts a process
p60095
aVBecause it starts in the same session as the service, in session 0
p60096
aVIf you want the service to start a process on the interactive desktop, that possible, albeit difficult: Launching an interactive process from Windows Service in
p60097
aVWindows Vista and later
p60098
as(dp60099
g7
V505088
p60100
stp60101
a((dp60102
g2
(lp60103
VIt's likely a dependency problem
p60104
aVSolve it with Dependency Walker
p60105
aVUse the Profile menu to start a process
p60106
aVRun regsvr32
p60107
aVSpecify the command line arguments and the working directory
p60108
aVMy guess is that the problem is a missing MSVC runtime, but the tool will reveal what is causing the failure
p60109
aVYou'll need to run Dependency Walker elevated so that the registration can work
p60110
as(dp60111
g7
V505088
p60112
stp60113
a((dp60114
g2
(lp60115
VThe race is unavoidable
p60116
aVThere's no API that can atomically do what you want
p60117
aVBut it's a rather benign race
p60118
aVWhat can go wrong
p60119
aVThe window is closed just before you ask about it
p60120
aVSo you get an error and then try again
p60121
aVAll you need to do is be aware of the race condition and check for and handle errors gracefully
p60122
as(dp60123
g7
V505088
p60124
stp60125
a((dp60126
g2
(lp60127
VWhen you do
p60128
aVthe variable  has not been initialised
p60129
aVWhich means that when you later check
p60130
aVits behaviour is ill-defined, because  was never initialised
p60131
aVWhat happens then is that the ill-defined behaviour that you see is that the expression never evaluates to  and so you never assign to the  or  fields
p60132
aVWhich is consistent with your observations
p60133
aVI suspect that you should make  be a  variable and copy into it the value of the parameter  that was passed to
p60134
aVBut since I don't know all the details of what you are doing, I can't be 100% sure of that
p60135
aVSome other comments:
p60136
aVDo you really mean to name your class
p60137
aVNormally we prefix classes with
p60138
aVThe code would read a lot easier if you used  loops instead of  loops
p60139
aVThe loop that contains a call to  on the list is inefficient
p60140
aVYou've already found the item, and calling  just searches the list once again
p60141
aVThe way to do that loop is with a class  loop using an index
p60142
aVAnd when you find the item to be deleted, call  passing the item's index
p60143
aVWhen you remove an item you fail to call  which means that you leak memory
p60144
as(dp60145
g7
V505088
p60146
stp60147
a((dp60148
g2
(lp60149
VYes, I can reproduce this behaviour
p60150
aVIt's clearly a Windows limitation and the API in question does not offer you any way to increase buffers
p60151
aVI think your chances of working around it using  are close to zero
p60152
aVBecause  is now a a legacy API
p60153
aVIf you are browsing for folders then you should use  in folder selection mode
p60154
aVThat's a  a much nicer dialog that uses the new Vista dialogs
p60155
aVIn Delphi that is wrapped by
p60156
aVOnly use that if  though
p60157
aVFor XP you need to call back on
p60158
as(dp60159
g7
V505088
p60160
stp60161
a((dp60162
g2
(lp60163
VThe  method of a frame is only called if the frame has children
p60164
aVYou'll need to add a paint box control (or similar) to your frame, or some children (perhaps invisible)
p60165
as(dp60166
g7
V505088
p60167
stp60168
a((dp60169
g2
(lp60170
VTo draw the rectangle, you can draw 4 lines
p60171
aVOr use a clear brush \u2013 that is use brush style
p60172
aVThe other issue to solve is that as the user moves the mouse and the zoom rectangle will move and you will need to repaint what lies underneath
p60173
aVDo this as follows:
p60174
aVCall  passing a rect for the previous location of the zoom rectangle
p60175
aVCall  for force a paint cycle and paint what was under the previous zoom rectangle
p60176
aVDraw the new zoom rectangle
p60177
as(dp60178
g7
V505088
p60179
stp60180
a((dp60181
g2
(lp60182
VYour problem is that the classes in your DLL are different from the classes in your executable
p60183
aVYou have two instances of these classes, even thought they are compiled from the same code
p60184
aVThe compiler is accurate when it says that the object is not the class that you cast it to
p60185
aVYou simply cannot share Delphi classes using DLLs
p60186
aVThe solution is either:
p60187
aVCompile all your code into a single executable
p60188
aVUse runtime packages to share classes
p60189
aVIn your scenario it's not enough that you put your code in a package
p60190
aVThe problem are the devexpresses classes
p60191
aVYou need to link to those using runtime packages
p60192
aVBecause you are not doing so you have multiple different versions of those classes
p60193
aVYou note that the results of the is operator appear to be at odds with the ClassName function
p60194
aVWell, that's because all the different versions of the class have the same name
p60195
aVI also note that the issue you are encountering is the same as in your earlier question: How can I pass TForm to a DLL as parameter
p60196
aVThe explanation and advice from the answer you accepted there apply equally here
p60197
as(dp60198
g7
V505088
p60199
stp60200
a((dp60201
g2
(lp60202
VAfter you have shown the message, simply call
p60203
as(dp60204
g7
V505088
p60205
stp60206
a((dp60207
g2
(lp60208
VThis is known as a conditional expression
p60209
aVThe expression x if C else y first evaluates the condition, C (not x); if C is true, x is evaluated and its value is returned; otherwise, y is evaluated and its value is returned
p60210
aVSo, your specific example is equivalent to:
p60211
as(dp60212
g7
V505088
p60213
stp60214
a((dp60215
g2
(lp60216
VYou can't assign anything other than an integer to a progress bar's position
p60217
aVSo, if you want to make the position move smoothly from one value to another you need to set the position to each individual value
p60218
aVThere are no handy shortcuts
p60219
aVThere's nothing available out of the box like jQuery's animate() method
p60220
aVYou mention timers and loops
p60221
aVThose are the methods you need to use
p60222
as(dp60223
g7
V505088
p60224
stp60225
a((dp60226
g2
(lp60227
VYour current code fails with a null reference exception because you never instantiate the list
p60228
aVYou should do so in your constructor
p60229
aVHowever, I'd prefer this as a static method
p60230
aVIt feels wrong to me to be using a property for your list of permutations
p60231
aVIn order to make that work you would need to add the list of permutations as a parameter to your recursive function
p60232
aVAnd the list would need to be instantiated by the caller
p60233
aVSo I think your function should be declared like this:
p60234
aVThe code inside the function can remain largely unchanged and just needs to pass around the list whenever it makes a recursive call
p60235
aVI won't repeat your code here because I think should be obvious what I mean
p60236
as(dp60237
g7
V505088
p60238
stp60239
a((dp60240
g2
(lp60241
VYou are compiling the PNGImage unit yourself, and you have an out of date PNGImage designed for a pre-Unicode Delphi
p60242
aVThat is the fundamental problem you have
p60243
aVThe PNG functionality is now built in to Delphi
p60244
aVThe PNGImage unit is part of the standard libraries that ship with the product
p60245
aVSimply remove your version of the PNGImage code
p60246
aVMake sure you delete the
p60247
aVpas and
p60248
aVdcu files so that your errant version cannot be used
p60249
aVThen include PNGImage in a uses clause in one of your units, which I guess you already do
p60250
aVThis will result in the built in version of the unit being used
p60251
as(dp60252
g7
V505088
p60253
stp60254
a((dp60255
g2
(lp60256
VYou have to bind at runtime and that means you need to use LoadLibrary and GetProcAddress:
p60257
aVAnd then you can call it:
p60258
aVSome comments:
p60259
aVI don't know why you write this function when it exists in standard system libraries
p60260
aVUsing string across DLL boundaries is liable to fail
p60261
aVYou need to be using ShareMem and make sure that all code is built with the same Delphi version
p60262
aVBetter to allocate the buffer in the calling code
p60263
as(dp60264
g7
V505088
p60265
stp60266
a((dp60267
g2
(lp60268
VCurrent directory and working directory are just two different names for the same thing
p60269
aVEach process maintains a single current directory
p60270
aVThe current directory is specified on startup as a parameter to whichever function is used to create the process, for example
p60271
aVHow do you change the current directory for one of your applications
p60272
aVWell, it depends how you start it
p60273
aVIf you start it from a shortcut, change the properties of the shortcut to specify the current directory
p60274
aVIf you start from a command prompt, the current directory will be the current directory of the command prompt at the moment that you start it
p60275
aVIf you start by calling , the working current will be whatever you pass to   in the  parameter
p60276
aVIf you pass  then the current directory of the parent process will be used
p60277
as(dp60278
g7
V505088
p60279
stp60280
a((dp60281
g2
(lp60282
VWindows bitmap objects have fixed width and height
p60283
aVWhen you create an  you have to decide once and for all on the height, width and indeed other properties such as pixel format
p60284
aVSo, of course when you modify the  and  property of a Delphi , then the implementing  will need to be re-created
p60285
aVIt seems that you are asking to be able to create an  that has width and height properties that can be modified
p60286
aVNo such thing exists
p60287
as(dp60288
g7
V505088
p60289
stp60290
a((dp60291
g2
(lp60292
VLogically there's no need to use the  keyword when the code is already part of an existing type declaration section
p60293
aVSo,
p60294
aVproduces types that are indistinguishable from
p60295
aVHowever, as you have discovered, the compiler has a limitation that requires all forward declarations to be fully resolved before the end of the section where the forward declaration was introduced
p60296
aVThere's no particular reason that it has to be that way
p60297
aVIt would be perfectly possible for the compiler to relax that limitation
p60298
aVOne can only assume that a compiler implementation detail, probably originating a very long time ago, has leaked into the language specification
p60299
as(dp60300
g7
V505088
p60301
stp60302
a((dp60303
g2
(lp60304
VYou are only meant to call  if the API function call reported failure
p60305
aVCheck the return value of both  and
p60306
aVIf either returns  then the API call failed and then, and only then, is it valid to call
p60307
aVThe documentation states it like this:
p60308
aVReturn value
p60309
aVIf the function succeeds, the return value is nonzero
p60310
aVIf the function fails, the return value is zero
p60311
aVTo get extended error
p60312
aVinformation, call
p60313
aVWhat is happening is that  succeeds and does not modify the last error value
p60314
aVThen when you call  it returns an error code for some other call to an API function, that happened before you called
p60315
aVYou should write the code like this:
p60316
as(dp60317
g7
V505088
p60318
stp60319
a((dp60320
g2
(lp60321
VThe function is this:
p60322
aVIf execution reaches my added comment, after the for loop completes, the function exits and nothing is returned
p60323
aVAnd when you exit a function without having executed a  statement,  is returned
p60324
aVYou must make sure that you return something from the recursive function
p60325
aVI can't advise you on how to re-write the function since I don't know what it is trying to do
p60326
aVIt's very far from obvious to me how it needs to be changed
p60327
aVHowever, what I can say with complete confidence is that you must return something
p60328
as(dp60329
g7
V505088
p60330
stp60331
a((dp60332
g2
(lp60333
VAll you need is to modify the handling of
p60334
aVWell, it's pretty obvious what this does and how it works
p60335
aVYou ask how to do this in a frame
p60336
aVIt's not possible to handle dialog navigation in a frame
p60337
aVThat's done by the form for fairly obvious reasons
p60338
aVSo you'll need somehow to splice this code into the form that hosts your frame
p60339
aVFor a memo control this will have no effect
p60340
aVThey will treat pressing ENTER as input of a line break
p60341
aVBut I presume that's what you would wish to happen
p60342
aVOtherwise the memo control would be completely unusable
p60343
as(dp60344
g7
V505088
p60345
stp60346
a((dp60347
g2
(lp60348
VThe  format string treats the substituted value as , which is signed
p60349
as(dp60350
g7
V505088
p60351
stp60352
a((dp60353
g2
(lp60354
VDelphi's register calling convention, also known as Borland fastcall, on x86 uses EAX, EDX and ECX registers, in that order
p60355
aVHowever, Microsoft's fastcall calling convention uses different registers
p60356
aVIt does not use EAX at all
p60357
aVInstead it uses ECX and EDX registers for first two parameters, as described by the documentation
p60358
aVSo, with that information you could probably write some assembler to make a Delphi  function call from C++, by moving the parameter into the  register
p60359
aVHowever, it's going to be so much easier to let the Delphi compiler do that
p60360
aVEspecially as I imagine that your real problem involves multiple functions and more than a single parameter
p60361
aVI suggest that you write some Pascal code to adapt between  and
p60362
aVThen you can call  from your C++ code and let the Delphi compiler handle the parameter passing
p60363
as(dp60364
g7
V505088
p60365
stp60366
a((dp60367
g2
(lp60368
VIn your code you have:
p60369
aVThat is a declaration of a function
p60370
aVI presume that you actually meant to call the function:
p60371
aVNow, that won't compile either
p60372
aVSince  is a type
p60373
aVI think you need:
p60374
aVWhat's more, there's no need to actually specify a verb
p60375
aVThe default verb for a path will suffice
p60376
aVAnd it sounds as though you are passing strings like this:
p60377
aVThat's not good because the backslash is used as the escape character in C++
p60378
aVSo you need to escape it:
p60379
aVIf you are not going to test the return value then you can simply write:
p60380
aVIf you do want to check for errors on return from , then  is a bad function to call
p60381
aVIts error handling is particularly weak
p60382
aVUse  instead
p60383
aVRaymond Chen discusses the error handling of  in Why does ShellExecute return SE_ERR_ACCESSDENIED for nearly everything
p60384
as(dp60385
g7
V505088
p60386
stp60387
a((dp60388
g2
(lp60389
VThis line:
p60390
aVis equivalent to:
p60391
aVThat's because the  operator has higher precedence than the  operator
p60392
aVSince  is non-zero, it always evaluates as true, and so  always evaluates as true
p60393
aVYou need to write this:
p60394
aVOf course, even if the precedence was the other way around,
p60395
aVwould not have been what you intended either
p60396
as(dp60397
g7
V505088
p60398
stp60399
a((dp60400
g2
(lp60401
VThe answer to your question is provided in full technicolor by the documentation:
p60402
aVThe Decimal value type represents decimal numbers ranging from
p60403
aVpositive 79,228,162,514,264,337,593,543,950,335 to negative
p60404
aV79,228,162,514,264,337,593,543,950,335
p60405
aVThe Decimal value type is
p60406
aVappropriate for financial calculations requiring large numbers of
p60407
aVsignificant integral and fractional digits and no round-off errors
p60408
aVThe Decimal type does not eliminate the need for rounding
p60409
aVRather, it
p60410
aVminimizes errors due to rounding
p60411
aVA decimal number is a floating-point value that consists of a sign, a
p60412
aVnumeric value where each digit in the value ranges from 0 to 9, and a
p60413
aVscaling factor that indicates the position of a floating decimal point
p60414
aVthat separates the integral and fractional parts of the numeric value
p60415
aVThe binary representation of a Decimal value consists of a 1-bit sign,
p60416
aVa 96-bit integer number, and a scaling factor used to divide the
p60417
aV96-bit integer and specify what portion of it is a decimal fraction
p60418
aVThe scaling factor is implicitly the number 10, raised to an exponent
p60419
aVranging from 0 to 28
p60420
aVTherefore, the binary representation of a
p60421
aVDecimal value is of the form, ((-296 to 296) / 10(0 to 28)), where
p60422
aV-296-1 is equal to MinValue, and 296-1 is equal to MaxValue
p60423
aVFor more information about the binary representation of Decimal values and an example, see the Decimal(Int32[]) constructor and the GetBits method
p60424
aVThe scaling factor also preserves any trailing zeroes in a Decimal
p60425
aVnumber
p60426
aVTrailing zeroes do not affect the value of a Decimal number in
p60427
aVarithmetic or comparison operations
p60428
aVHowever, trailing zeroes can be
p60429
aVrevealed by the ToString method if an appropriate format string is
p60430
aVapplied
p60431
aVAnd the binary representation, as described in the documentation for :
p60432
aVThe binary representation of a Decimal number consists of a 1-bit
p60433
aVsign, a 96-bit integer number, and a scaling factor used to divide the
p60434
aVinteger number and specify what portion of it is a decimal fraction
p60435
aVThe scaling factor is implicitly the number 10, raised to an exponent
p60436
aVranging from 0 to 28
p60437
aVThe return value is a four-element array of 32-bit signed integers
p60438
aVThe first, second, and third elements of the returned array contain
p60439
aVthe low, middle, and high 32 bits of the 96-bit integer number
p60440
aVThe fourth element of the returned array contains the scale factor and
p60441
aVsign
p60442
aVIt consists of the following parts:
p60443
aVBits 0 to 15, the lower word, are unused and must be zero
p60444
aVBits 16 to 23 must contain an exponent between 0 and 28, which
p60445
aVindicates the power of 10 to divide the integer number
p60446
aVBits 24 to 30 are unused and must be zero
p60447
aVBit 31 contains the sign: 0 mean positive, and 1 means negative
p60448
aVNote that the bit representation differentiates between negative and
p60449
aVpositive zero
p60450
aVThese values are treated as being equal in all
p60451
aVoperations
p60452
as(dp60453
g7
V505088
p60454
stp60455
a((dp60456
g2
(lp60457
V is simply a pointer
p60458
aVAnd your code just changes the value of the pointer, the address, not the string to which it points
p60459
aVWhat's more, what you are attempting to do leads to undefined behaviour, and will most likely result in runtime errors
p60460
aVAll modern compilers will store your string  in read-only memory
p60461
aVAttempts to modify that memory will lead to memory protection errors
p60462
as(dp60463
g7
V505088
p60464
stp60465
a((dp60466
g2
(lp60467
VThe FMX framework won't route messages to your form
p60468
aVSo, your  will never be called because the FMX framework never calls
p60469
aVYou can see that this is the case by inspecting the  method declared in the implementation section of the  unit
p60470
aVThe easiest way to solve this problem will be to create your own window by calling
p60471
aVAnd then implementing a window procedure for that window that will handle the  message
p60472
aVI've wrapped those low-level API calls like this:
p60473
aVThis is a thread-safe version of the VCL  which is notorious for being unusable outside the main thread
p60474
aVWhat you need to do is create a class with a window procedure, i
p60475
ag192
aVsomething that implements a
p60476
aVIt can be an instance method or a class method
p60477
aVThen simply call  to create the window, and pass that window to
p60478
aVWhen it's time to unwind it all, unregister your hot key, and destroy the window with a call to
p60479
as(dp60480
g7
V505088
p60481
stp60482
a((dp60483
g2
(lp60484
VSimilar method the system uses for owner and owned windows, but such windows must belong same thread
p60485
aVThis statement is incorrect
p60486
aVYou can indeed make the owner of a window be a window from a different process
p60487
aVAnd that is the correct way to do what you desire
p60488
as(dp60489
g7
V505088
p60490
stp60491
a((dp60492
g2
(lp60493
VTypically an event handler will be declared with a property declared like this:
p60494
aVSo, in order to fire it the code will execute  and so you need to search the component's source code for references to  or possibly
p60495
aVUsually you will find something like this:
p60496
aVFinally, you need to look for the places where  is called
p60497
aVAs a worked example, we can use the  event of
p60498
aVThis is declared like this:
p60499
aVThat's the only reference to
p60500
aVSo we look for  which leads to this:
p60501
aVNow,  is a private method, so we don't need to look outside the unit in which it is declared
p60502
aVAnd the only place it is used is as the property setter for :
p60503
aVThen you could continue and look for the places where that property is assigned to, but there will be a lot of places where that happens
p60504
aVSo, if you want to debug all this you simply need to enable Debug DCUs and set a breakpoint inside
p60505
aVYou may wish to make the break point condition on the content of  if your find that the break point fires too often
p60506
as(dp60507
g7
V505088
p60508
stp60509
a((dp60510
g2
(lp60511
VThere are exactly two ways to do what you want:
p60512
aVReturn an error/status code and have every function on the call stack check that code
p60513
aVRaise an exception and handle it at the high level
p60514
aVYou do not wish to use option 1, so that leaves option 2
p60515
as(dp60516
g7
V505088
p60517
stp60518
a((dp60519
g2
(lp60520
VThe feature is named XML Documentation Comments and is documented here
p60521
aVIt appears to have been modelled closely on the equivalent
p60522
aVnet feature so you should be right at home with it
p60523
aVThe documentation contains this example:
p60524
aVwhich results in this help insight hint:
p60525
aVAnd there are various other ways to process and consume the documentation
p60526
as(dp60527
g7
V505088
p60528
stp60529
a((dp60530
g2
(lp60531
VCan I test if a file can be opened without attempting to
p60532
aVopen it
p60533
aVThe
p60534
aVnet framework, just like the Windows API beneath, provides no such functionality
p60535
aVIf you wish to know whether or not a file can be opened you are expected to attempt to open it and check for failure
p60536
as(dp60537
g7
V505088
p60538
stp60539
a((dp60540
g2
(lp60541
VI'd put this at the start of my
p60542
aVdpr file's code:
p60543
aVThis checks to see if there is more than a single command line argument
p60544
aVIf so, then each one is handed off to a new process, and this process terminates
p60545
aVI suppose you could hand off arguments 2 to N and let this process handle argument 1
p60546
aVBut, being of a mathematical nature, the symmetry of this version appeals to me
p60547
as(dp60548
g7
V505088
p60549
stp60550
a((dp60551
g2
(lp60552
VYou don't specify compatibility mode in a manifest
p60553
aVThat's done through the registry
p60554
aVSome useful resources that describe this further:
p60555
aVhttp://msdn
p60556
aVmicrosoft
p60557
aVcom/en-us/library/windows/desktop/bb756937
p60558
aVaspx
p60559
aVhttp://blogs
p60560
aVtechnet
p60561
aVcom/b/askperf/archive/2007/10/05/the-program-compatibility-assistant-part-two
p60562
aVaspx
p60563
aVhttp://superuser
p60564
aVcom/questions/379375/how-can-i-set-the-compatibility-mode-for-an-executable-from-the-command-line
p60565
aVhttp://www
p60566
aVverboon
p60567
aVinfo/index
p60568
aVphp/2011/03/running-an-application-as-administrator-or-in-compatibility-mode/
p60569
as(dp60570
g7
V505088
p60571
stp60572
a((dp60573
g2
(lp60574
VFrom what I've read Delphi does not support export of variables
p60575
aVThat statement is incorrect
p60576
aVHere's the simplest example that shows how to export a global variable from a Delphi DLL:
p60577
aVI think your problem is that you wrote it like this:
p60578
aVAnd that fails to compile with this error:
p60579
aVE2276 Identifier 'NvOptimusEnablement' cannot be exported
p60580
aVI don't understand why the compiler doesn't like the second version
p60581
aVIt's probably a bug
p60582
aVBut the workaround in the first version is just fine
p60583
as(dp60584
g7
V505088
p60585
stp60586
a((dp60587
g2
(lp60588
VAll that function does is convert binary to hex string
p60589
aVSince your input hash is 32 bits wide all you need is this:
p60590
aVwhere hash is the int that contains the hashed value
p60591
aVSince I guess that you are on a little endian machine, this will have the hex bytes reversed
p60592
aVFix that like this:
p60593
aVPut it all together and you have this:
p60594
as(dp60595
g7
V505088
p60596
stp60597
a((dp60598
g2
(lp60599
VIf the VCL code that you want to replicate is:
p60600
aVthen the equivalent for FMX would be:
p60601
aVThe reason is that  is an FMX handle
p60602
aVThat's not the same as a window handle
p60603
aVYou convert to a window handle with
p60604
aVYou may need to declare a couple of constants:
p60605
as(dp60606
g7
V505088
p60607
stp60608
a((dp60609
g2
(lp60610
VLike this:
p60611
aVFor example, with this program:
p60612
aVAnd here's the output:
p60613
aV>dcc32 MyProject
p60614
aVdpr
p60615
aVEmbarcadero Delphi for Win32 compiler version 24
p60616
ag9193
aVCopyright (c) 1983,2012 Embarcadero Technologies, Inc
p60617
aVMyproject
p60618
aVdpr(9) Warning: W1020 Constructing instance of 'TMyClass' containing abstract method 'TMyClass
p60619
aVX'
p60620
aVMyproject
p60621
aVdpr(12)
p60622
aV13 lines, 0
p60623
aV03 seconds, 21568 bytes code, 13256 bytes data
p60624
aV>dcc32 -W^^CONSTRUCTING_ABSTRACT MyProject
p60625
aVdpr
p60626
aVEmbarcadero Delphi for Win32 compiler version 24
p60627
ag9193
aVCopyright (c) 1983,2012 Embarcadero Technologies, Inc
p60628
aVMyproject
p60629
aVdpr(9) Error: E1020 Constructing instance of 'TMyClass' containing abstract method 'TMyClass
p60630
aVX'
p60631
aVMyproject
p60632
aVdpr(12)
p60633
aVIf you want all warnings to be treated as errors then you do it like this:
p60634
aVFor further reading I refer you to Delphi XE2's hidden hints and warnings options
p60635
as(dp60636
g7
V505088
p60637
stp60638
a((dp60639
g2
(lp60640
VYou need to link to the dynamic runtime,
p60641
aVThe problem you have is that the other machine doesn't have that runtime installed
p60642
aVSolve that by simply installing, on each machine where you need to run the program, the redistributable package for your version of Visual Studio
p60643
as(dp60644
g7
V505088
p60645
stp60646
a((dp60647
g2
(lp60648
VIt seems that  works fine with method pointers, but doesn't like properties
p60649
aVHere's a quick sample to demonstrate:
p60650
aVThis programs works as expected
p60651
aVHowever, uncommenting the property is enough to make it fail
p60652
aVIt's clearly an RTTI bug
p60653
aVI see no ready way for anyone other than Embarcadero to fix it
p60654
aVIt seems that the combination of a property whose type is a method pointer is the problem
p60655
aVThe workaround is to avoid such properties
p60656
aVI suggest that you submit a QC report
p60657
aVThe code from this answer is just what you need
p60658
as(dp60659
g7
V505088
p60660
stp60661
a((dp60662
g2
(lp60663
VLots of ways to do this
p60664
aVFor example my personal choice would be:
p60665
as(dp60666
g7
V505088
p60667
stp60668
a((dp60669
g2
(lp60670
VYou cannot mix 32 bit and 64 bit code in a single process
p60671
aVSo the only way to use mix bitness code is to have more than one process
p60672
aVYou'll need some form of IPC to make it work
p60673
aVYou cannot do it with  since that is in-process
p60674
as(dp60675
g7
V505088
p60676
stp60677
a((dp60678
g2
(lp60679
VThis is wrong:
p60680
aVI presume you meant to write:
p60681
aVBut since  equals 1 by definition you would simply omit that
p60682
aVBut even that is wrong since you need to allow space for the null terminator which your code does not currently write
p60683
aVThe allocation needs to be:
p60684
aVAnd add the null-terminator like this:
p60685
aVAll in all, the finished product is as so:
p60686
aVI removed the cast of the return value of  which is not needed in C
p60687
aVAnd you should also ensure that you check the return value of  for a failed allocation
p60688
aVIt will return the null pointer if it fails
p60689
aVI've not shown how to do that because I don't know your error handling policy
p60690
as(dp60691
g7
V505088
p60692
stp60693
a((dp60694
g2
(lp60695
VI always thought it was part of the design philosophy in
p60696
aVPascal, that it looked at both the right and left hand sides of
p60697
aVan expression when deciding what format/precision to use
p60698
aVfor an operation
p60699
aVThat is not correct
p60700
aVExpressions assignment targets do not influence the evaluation of the expression
p60701
aVThe reason that
p60702
aVevaluates to 0 in C/C++ is that the / operator is overloaded
p60703
aVIt can mean either integer division or floating point division
p60704
aVIf one of the arguments is floating point then the operator is floating point division, otherwise, as here, it is integer division
p60705
aVIn Delphi the / operator is not overloaded
p60706
aVIt is always floating point division
p60707
aVThat's why this code gives a compile error:
p60708
as(dp60709
g7
V505088
p60710
stp60711
a((dp60712
g2
(lp60713
VFollowing the documentation, it would seem that the struct that is returned when you pass  and  is
p60714
aVBut that struct looks nothing like your declaration of
p60715
aVAnd that's why the values that you read out of your  records are not what you expect
p60716
aVRead the documentation for
p60717
aVIn the  table it lists  as the struct associated with
p60718
aVAnd  has an array of
p60719
aVThe bottom line is that the record that you are using on your side of the interface does not match the struct used on the other side
p60720
aVSome other comments:
p60721
aVIt is incorrect to pack these records
p60722
aVThe C++ header file does not do so and uses aligned structs
p60723
aVAligned structs is the norm
p60724
aVIt's usually a safe bet when interacting with the Windows API that structs will be aligned
p60725
aVYou are also neglecting to check the return value of  in the second call that you make
p60726
as(dp60727
g7
V505088
p60728
stp60729
a((dp60730
g2
(lp60731
VWin32 threads do not have names
p60732
aVThere is a Microsoft convention whereby applications raise special SEH exceptions containing a thread name
p60733
aVThese exceptions can be intercepted by debuggers and used to indicate the thread name
p60734
aVA couple of the answers cover that
p60735
aVHowever, that is all handled by the debugger
p60736
aVThreads themselves are nameless objects
p60737
aVSo, if you want to associate names with your threads, you'll have to develop your own mechanism
p60738
aVWhilst you could use thread local storage that will only allow you to obtain the name from code executing in that thread
p60739
aVSo a global map between thread ID and the name would seem like the most natural and useful approach
p60740
as(dp60741
g7
V505088
p60742
stp60743
a((dp60744
g2
(lp60745
VThe difference is in the subsystem that each executable targets
p60746
aVtargets the  subsystem
p60747
aVtargets the  subsystem
p60748
as(dp60749
g7
V505088
p60750
stp60751
a((dp60752
g2
(lp60753
VThe latest updates to the documentation have removed all of the text on which this question was based
p60754
aVMy conclusion is that the original text was simply a documentation error
p60755
as(dp60756
g7
V505088
p60757
stp60758
a((dp60759
g2
(lp60760
VThe quote in the question contains all the information that you are permitted to rely on:
p60761
aVIf fdwReason is DLL_PROCESS_ATTACH, lpvReserved is NULL for dynamic loads and non-NULL for static loads
p60762
aVAll you are entitled to do is treat  as a boolean that signals information about whether the load is dynamic or static (aka implicit)
p60763
aVIt's perfectly plausible that there are versions of Windows for which  carries more information that a plain boolean
p60764
aVHowever, that is a private implementation detail and you should not rely on that
p60765
as(dp60766
g7
V505088
p60767
stp60768
a((dp60769
g2
(lp60770
VThe enumerator provided by an action manager provides actions typed as
p60771
aVAnd it is provided by the action manager class so that you can enumerate an action manager directly
p60772
aVYour code attempts to iterate over  and that could not be possible because  is an indexed property
p60773
aVYou can't iterate over one of those
p60774
aVSo your code needs to look like this:
p60775
aVYou may need to up-cast using  if you want to access properties that are declared in descendents of
p60776
as(dp60777
g7
V505088
p60778
stp60779
a((dp60780
g2
(lp60781
VThe problem is that Delphi 7, by default, assumes that help files use the old WinHelp format that was not shipped with Vista
p60782
aVEven though your help file has the
p60783
aVchm extension, Delphi tries to show it using WinHelp commands
p60784
aVAnd since WinHelp isn't there, you get the error message that you reported
p60785
aVThere are various ways to get the help system to show HTML help
p60786
aVFor example, a common technique is to implement an  handler for the  object and route the help to calls to the  API
p60787
aVI gave a very simple example of that in a recent answer
p60788
as(dp60789
g7
V505088
p60790
stp60791
a((dp60792
g2
(lp60793
VThe difference is the call to
p60794
aVYour version omits that
p60795
aVWhen you put it back you will find that your version is then comparable to the version in
p60796
aVEven when you remove the call to   the performance gain is negligible
p60797
aVMy version of your test program looks like this:
p60798
aVThe runtime varies a fair bit from run to run
p60799
aVBut here's a typical output:
p60800
aVMarshal class: result=Console
p60801
aVWriteLine("Marshal class: result={0} time={1}ms",
p60802
aVs, sw
p60803
aVElapsedMilliseconds); time=1914ms
p60804
aVMy implementation: result=Console
p60805
aVWriteLine("Marshal class: result={0} time={1}ms",
p60806
aVs, sw
p60807
aVElapsedMilliseconds); time=2065ms
p60808
aVBut sometimes it comes out the other way around
p60809
aVIn short, nothing to choose between the two
p60810
aVWhen you remove the call to , then your version wins more often than not
p60811
aVBut not by much
p60812
aVThere's typically around a 5% difference in speed
p60813
aVI don't know why you think that  is "very slow"
p60814
aVI very much expect that the two parameter version of  is essentially the  clause of your code
p60815
aVNote: My test environment was Win7 x64, VS2012, AnyCPU, Release
p60816
as(dp60817
g7
V505088
p60818
stp60819
a((dp60820
g2
(lp60821
VYou need to do the following for each of the three menu items:
p60822
aVSet  to
p60823
aVSet  to
p60824
aVSet the  for all three items to the same value
p60825
aVThis will result in a bullet rather than a tick being placed next to your menu item
p60826
aVThat's by design
p60827
aVThese menu items operate like radio buttons (hence the bullet) rather than check boxes (which would have ticks)
p60828
as(dp60829
g7
V505088
p60830
stp60831
a((dp60832
g2
(lp60833
VVirtual methods are implemented with a virtual method table (VMT)
p60834
aVThere is one VMT for each class
p60835
aVThe VMT contains one entry for each virtual method in the class
p60836
aVAnd that entry is the address of the method
p60837
aVThis allows for very efficient calling
p60838
aVYou simply get the address of the VMT which is located at a fixed offset from
p60839
aVThen you look up the method pointer by index and call the method
p60840
aVWhat this does mean is that if you have a class with a lot of virtual methods, and you derive a sub-class, you will make a brand new VMT with all the virtual methods
p60841
aVAnd if you have not overridden many of them, then you'll find that the VMTs have a lot of overlap
p60842
aVThis used to matter in the days of 16 bit
p60843
aVThe VMTs could take up a lot of space in the executable image (that's what is meant by code size) and you could run out of space for the VMTs
p60844
aVSo dynamic methods were introduced
p60845
aVThe analogue to the VMT is the dynamic method table, DMT
p60846
aVThis is implemented differently to avoid the repetition when methods are not overridden
p60847
aVThe downside is that calling dynamic methods is more expensive
p60848
aVIn modern times, since 32 bit, and especially with the very fat executables that Delphi produces, these size issues don't matter
p60849
aVAnd so all sound advice is to use virtual methods exclusively
p60850
aVVirtual method table implementations are well understood and there are many references can be found to understand them
p60851
aVThat's less so for dynamic methods which are rather quaint
p60852
aVThe best sources of information I have found are from Hallvard Vassbotn's blog:
p60853
aVhttp://hallvards
p60854
aVblogspot
p60855
aVco
p60856
aVuk/2007/03/hack15-overriding-message-and-dynamic
p60857
aVhtml
p60858
aVhttp://hallvards
p60859
aVblogspot
p60860
aVco
p60861
aVuk/2006/04/dynamic-methods-and-inherited
p60862
aVhtml
p60863
aVm=1
p60864
as(dp60865
g7
V505088
p60866
stp60867
a((dp60868
g2
(lp60869
VThe  and  members are
p60870
aVWhich means that they are not visible in sub-classes, like
p60871
aVIn order to make them visible to sub-classes you need to make these members  rather than
p60872
aVAnother option is to leave the member fields as private, and add protected or public access methods to allow the values to be read
p60873
aVFor example:
p60874
aVI would also comment that I don't understand why you are using  to access members of your class
p60875
aVThere's no need for that and it's usually best to simply omit it
p60876
aVWithout seeing your homework assignment, I'm not 100% sure what to make of the requirement that
p60877
aVmember variables and properties are private
p60878
aVMy guess is that your task is to override
p60879
aVYou are being asked to extend the  returned to include all the information included by the base class implementation, and add some more
p60880
aVYour current attempt simply duplicates the code in
p60881
aVAnd that's the problem
p60882
aVIn order for that to work, the derived classes need access to the private members
p60883
aVAnd you are not allowed to do that
p60884
aVSo, your solution will have to involve calling  on the base class, and then appending to the string that the base class implementation returns
p60885
aVSince this is homework, I will refrain from implementing this for you
p60886
as(dp60887
g7
V505088
p60888
stp60889
a((dp60890
g2
(lp60891
VThe simplest way to achieve your goal, in my view, is to assign to the  property for the form
p60892
aVYou can do this before showing the form
p60893
aVWhen you form is later shown, the VCL framework will ensure that the  is given input focus
p60894
aVFrom the documentation:
p60895
aVIf the form does not have focus,  is the control on the form that will receive focus when the form receives focus
p60896
as(dp60897
g7
V505088
p60898
stp60899
a((dp60900
g2
(lp60901
VMy question is, is there a maximum for the number of apps that can send using SendMessage to a single application
p60902
aVNo there is not
p60903
aVYour problem is not related to the number of processes sending messages
p60904
aVOne likely explanation for an access violation when processing messages is that your message contains a pointer to memory that is only valid in the address space of the sending process
p60905
aVBut that's a wild guess since we have no code
p60906
as(dp60907
g7
V505088
p60908
stp60909
a((dp60910
g2
(lp60911
VYour call to  returns  because there are other APIs called after  returns, and your exception code executes
p60912
aVThe error code returned by  a thread local variable and is shared between all code that runs in your thread
p60913
aVSo in order to capture the error code you need to call  immediately after the failed function returns
p60914
aVThe documentation explains it like this:
p60915
aVFunctions executed by the calling thread set this value by calling the
p60916
aVSetLastError function
p60917
aVYou should call the GetLastError function
p60918
aVimmediately when a function's return value indicates that such a call
p60919
aVwill return useful data
p60920
aVThat is because some functions call
p60921
aVSetLastError with a zero when they succeed, wiping out the error code
p60922
aVset by the most recently failed function
p60923
aVIf you are using  then the framework doesn't give you an opportunity to call  at the suitable moment
p60924
aVIf you really want to get that information you will have to call  yourself and use a  instead of
p60925
aVThe idea there is that with  you are responsible for the synthesis of the file handle which you pass to the constructor of
p60926
aVThat gives you the opportunity to  capture the error code in case of failure
p60927
as(dp60928
g7
V505088
p60929
stp60930
a((dp60931
g2
(lp60932
VYour only option, for conditional defines, is to put them in a
p60933
aVinc file which you then include in all three units
p60934
aVHowever, conditional defines, and  are not the only way to achieve conditional compilation
p60935
aVYou might consider using a boolean constant instead of a conditional
p60936
aVSo long as it is visible in all three units, you can use  rather than
p60937
aVOr, starting in XE3, you can terminate the  with
p60938
aVPersonally I tend to favour this latter approach when trying to compile conditionally and don't want the condition to have global scope
p60939
as(dp60940
g7
V505088
p60941
stp60942
a((dp60943
g2
(lp60944
VThe global variable
p60945
aVin snake
p60946
aVpas is never created
p60947
aVYou must create it before you can call methods on it
p60948
as(dp60949
g7
V505088
p60950
stp60951
a((dp60952
g2
(lp60953
VLinking of libraries on Windows is handled completely differently from how it is handled on Linux
p60954
aVLinking from plugin to host executable is simple on Linux, but not so much on Windows
p60955
aVOn Windows the traditional way to link to an external module is to use an import library, provided by a
p60956
aVlib file
p60957
aVIn order to do it that way, you would need to create an import library for your executable file which includes all the exported functions that your plugins need to call
p60958
aVI've never created an import library for an executable
p60959
aVNormally you do it for a DLL
p60960
aVI'm not even sure it will work for an executable
p60961
aVSome other options:
p60962
aVExport the functions from the executable, and use  in your plugin to bind to them at runtime
p60963
aVWhen you initialize the plugins, pass an interface containing all the functionality that they need
p60964
as(dp60965
g7
V505088
p60966
stp60967
a((dp60968
g2
(lp60969
VLet us take a look at this function:
p60970
aVHere the function returns a new
p60971
aVIt returns it so that the caller can do something with it
p60972
aVThe function doesn't return  because the caller wants to obtain and use that new
p60973
as(dp60974
g7
V505088
p60975
stp60976
a((dp60977
g2
(lp60978
VI think you have placed the cart ahead of the horse here
p60979
aVHaving all your threads synchronize into the main thread, each with their own timer and message queue, will place a heavy burden on the system
p60980
aVWhat's more, often times you don't want to burden your threads with running a message loop
p60981
aVA better approach in my view is to place a single timer in the main thread
p60982
aVWhen it ticks, have it retrieve progress from each thread or task that it needs to report on
p60983
aVYou'll need to serialize access to that progress, but that's not expensive
p60984
as(dp60985
g7
V505088
p60986
stp60987
a((dp60988
g2
(lp60989
VAssuming that the combo box contains the URL then you simply do this:
p60990
aVThere's no need to pass a verb
p60991
aVPass nil and the default verb is used
p60992
aVIn fact sometimes you'll encounter a browser that fails to register an action to the open verb
p60993
aVIf you've stripped off the protocol for the link text that you display in the combo, you should add it back:
p60994
aVJudging from the comments what you actually want is a one to one map between a URL and a friendly name
p60995
aVPut them both in a record:
p60996
aVThen create either a list of them, , or a dynamic array,  or
p60997
aVThen populate the list or array
p60998
aVThen use that structure to populate your combo box with friendly names
p60999
aVWhen the button is clicked, read the selected index,
p61000
aVAnd finally, look up the URL using that index
p61001
aVYet another option would be to use a dictionary to associate URL and friendly name
p61002
aVPersonally, I like the list of  better
p61003
as(dp61004
g7
V505088
p61005
stp61006
a((dp61007
g2
(lp61008
VWhat's wrong is that you are looping over the  property
p61009
aVThat lists the components that are owned by the tab sheet
p61010
aVFor components created in the form designer, the form is the owner
p61011
aVSo it is expected that  is zero since the only thing on your form that owns anything is the form itself
p61012
aVWhat you need to to is use  and  to iterate over the children of the tab sheet
p61013
aVSimply replace all use of  with , and likewise replace  with
p61014
aVNote that the  and  properties only give the immediate children
p61015
aVSince you have panels you most likely have the panels as children of the tab sheet, and the check boxes as children of the panels
p61016
aVSo you need to iterate over the children of the panels
p61017
aVMy answer here shows one way to do that
p61018
aVIf you use the code I presented there then your iteration over checkboxes can be written very simply indeed:
p61019
as(dp61020
g7
V505088
p61021
stp61022
a((dp61023
g2
(lp61024
VYou have the following declarations:
p61025
aVYou want to know how to populate the array of images
p61026
aVIt is quite wasteful to create 55 images when 3 will suffice
p61027
aVSo instead of that, use indirection
p61028
aVStore references to the images
p61029
aVAnd  is a visual component, and so not appropriate for a sprite
p61030
aVI would hold the images in an array like this:
p61031
aVAnd populate it
p61032
aVThen populate your  array like this, for example:
p61033
aVOf course your sprites may be better with a real name rather than in an array
p61034
aVSome other comments:
p61035
aVJPEG is a bad format for a game sprite
p61036
aVIt is a lossy format
p61037
aVA plain Windows bitmap would be fine, as would a GIF or PNG
p61038
aVI'd much rather see the images as embedded resources
p61039
aVThen your executable can stand alone
p61040
aVI'd also far rather see your  array holding the state of each invader
p61041
aVAnd then you would create a function that would render that state onto a canvas
p61042
as(dp61043
g7
V505088
p61044
stp61045
a((dp61046
g2
(lp61047
VWhen you copy to the clipboard from Excel, many different formats are placed on the clipboard
p61048
aVYou need to find one of those formats that you can replicate, and that will give the desired result
p61049
aVThe way I have achieved this in the past is to put HTML on the clipboard
p61050
aVFor which you can use this function:
p61051
aVThe only thing that remains is to generate the HTML which you pass to that function
p61052
aVThat's down to you
p61053
aVI suggest that you use Excel to put HTML on the clipboard and then inspect the HTML that it generates
p61054
aVUse that as a guide for what you need to do
p61055
as(dp61056
g7
V505088
p61057
stp61058
a((dp61059
g2
(lp61060
VThe code that you have will work for late bound COM
p61061
aVBut you state that you are using early bound COM
p61062
aVFor early bound COM you need to use something like this:
p61063
aVI cannot explain how the code worked in the past
p61064
aVPerhaps the import unit created from the Excel type library differed in some subtle way
p61065
as(dp61066
g7
V505088
p61067
stp61068
a((dp61069
g2
(lp61070
VShould I be concerned about RTL and VCL internals and possible memory leaks within them
p61071
aVProbably not
p61072
aVRecent versions of the RTL/VCL are clean
p61073
aVI've not encountered leaks with them, although that's not to say that you won't
p61074
aVIn any case, the reports you present looks just like a routine memory leak in your code
p61075
aVWhen your code leaks, typically what happens is that you create an object and then fail to destroy it
p61076
aVThe leaked object can own lots of other objects
p61077
aVAnd they are all tracked by FastMM and reported as distinct leaks
p61078
aVSo, if you create an object that contains a string, then leaking the owning object leaks the string too
p61079
as(dp61080
g7
V505088
p61081
stp61082
a((dp61083
g2
(lp61084
VYou can check the time stamp by:
p61085
aVFind the file in explorer
p61086
aVRight click on it and select the Properties menu item
p61087
aVSelect the Digital Signatures tab and view the timestamp
p61088
aVIt looks like this:
p61089
as(dp61090
g7
V505088
p61091
stp61092
a((dp61093
g2
(lp61094
VI've no experience with  but I can make a guess as to what is happening
p61095
aVThis component stores settings to a database, as specified by the  property of the  instance
p61096
aVIn your case that is
p61097
aVSo, for this all to work you need for  to be available whenever  reads and writes settings
p61098
aVI'll bet that  has already been destroyed when  attempts to store to it
p61099
aVI expect that happens when  is freed
p61100
aVSo the explanation for the problem is that  is freed before
p61101
aVThe solution will be to make sure that  is still alive when  is freed
p61102
as(dp61103
g7
V505088
p61104
stp61105
a((dp61106
g2
(lp61107
VThe return value from  is a string and not a boolean
p61108
aVHence your  and  tests, although they have well-defined meaning, that meaning is not the meaning that you intend
p61109
aVYou need to compare  against string values
p61110
aVSo you would need, for example, code like this:
p61111
aVI used  to effect case-insensitive comparison
p61112
aVYou may also want to strip off white space:
p61113
aVI'm sure you can fill in the test against  yourself
p61114
aVEven if you did have a boolean, you should not use code like  or
p61115
aVYou should test for truth with:
p61116
aVor
p61117
aVbecause it is much more readable
p61118
as(dp61119
g7
V505088
p61120
stp61121
a((dp61122
g2
(lp61123
VThe code in the question contains a number of errors:
p61124
aVreturns  and not
p61125
aVThe function pointer has the wrong return value and an incorrect calling convention
p61126
aVFunction names are case sensitive and you must account for name decoration
p61127
aVYou did no error checking at all
p61128
aVYour code probably fails on the call to , returns  and then bombs when you try to call the function at
p61129
aVSo you need something like this:
p61130
aVThe function name is decorated because you used
p61131
aVIf you had used , or a
p61132
aVdef file, then there would have been no decoration
p61133
aVI'm assuming MSVC decoration
p61134
aVIt seems that decoration differs with your compiler, mingw, and the function is named
p61135
aVFrankly it's much easier to do it with a
p61136
aVlib file instead of calling  and
p61137
aVIf you can, I'd switch to that way now
p61138
as(dp61139
g7
V505088
p61140
stp61141
a((dp61142
g2
(lp61143
VFor pounds you get the fractional part with  and then multiply by 100
p61144
aVThen use  to get it in integer form:
p61145
aVAnd for stones it's just :
p61146
aVIn the other direction you do:
p61147
aVWith these functions you can readily do the rest
p61148
aVThe validity checks for values of pounds greater than 14 are easy to deal with
p61149
aVFor example:
p61150
aVI'd be very surprised if you found this code anywhere in a general purpose library
p61151
aVThat's because it's a very poor way to store weight
p61152
aVIf you are going to use a floating point format you should do it like this:
p61153
aVIn the other direction you would do it like this:
p61154
aVUnfortunately you still need to do the div/mod shuffle
p61155
aVImagine what happens when , for example
p61156
aVDoing it this way makes arithmetic on the floating point values more sensible
p61157
aVFor example, suppose you have measured weights of 10 people and want to know the total
p61158
aVIt makes sense to do that with true floating point representation, but not with your representation
p61159
aVTo see that, suppose these 10 people, and they all weigh zero stones, 10 pounds
p61160
aVVery small people I know
p61161
aVBut you would call that 0
p61162
ag5537
aVAdd up 10 lots of that and you have a weight of 1
p61163
ag9193
aVBut it's clear that the actual value is 100 pounds, or 7 stone two pounds
p61164
aVBut if you take 10 pounds and feed it into:
p61165
aVthen you find a weight value of 10/14
p61166
aVAdd 10 lots of that to get 100/14, and well, I'm sure you get my drift
p61167
aVThe other obvious way to store such data is as pounds
p61168
aVEither integers or floating point could make sense
p61169
as(dp61170
g7
V505088
p61171
stp61172
a((dp61173
g2
(lp61174
VCall  to enumerate the top level windows
p61175
aVPass each top level window handle to  to find out which process ID it is associated with
p61176
aVWhen you find a top level window that matches your process ID, check that the window is the main window of the app, presumably by checking its class name
p61177
aVFinally, call  on that main window to enumerate all children of that main window
p61178
as(dp61179
g7
V505088
p61180
stp61181
a((dp61182
g2
(lp61183
VThe default handler for the  verb on images in modern Windows versions may not invoke a new process
p61184
aVIt may well just show the image in an already running shell process
p61185
aVAnd when that happens, the process handle that is returned is
p61186
aVThat is what is happening here, and that is why the call to  fails in the way you describe
p61187
aVThe documentation for  covers this:
p61188
aVEven if fMask is set to SEE_MASK_NOCLOSEPROCESS, hProcess will be NULL if no process was launched
p61189
aVFor example, if a document to be launched is a URL and an instance of Internet Explorer is already running, it will display the document
p61190
aVNo new process is launched, and hProcess will be NULL
p61191
aVWhat this all means is that the design of that part of your program is based on a flawed assumption
p61192
aVNamely the assumption that calling  will always yield a process handle on which you can wait for termination
p61193
aVYou will need to find some other way to solve your problem
p61194
as(dp61195
g7
V505088
p61196
stp61197
a((dp61198
g2
(lp61199
VLet's take a look at :
p61200
aVLet's assume that  and is implemented correctly and always returns the number of items indexed by
p61201
aVIn which case the conclusion is that the body of the loop is deleting a form
p61202
aVThat is  is changing during the execution of the loop
p61203
aVThe only way that can happen is if one of the form's action update handlers results in a form being deleted
p61204
aVSo, I can't tell you any more than that, but this analysis should lead you to the root cause of the problem
p61205
aVAnd the second part of your question is quite simple
p61206
aVYou cannot use VCL components outside the main GUI thread
p61207
aVIn fact it is plausible that destroying the VCL form in your thread is what is leading to  changing during the execution in the GUI thread of
p61208
as(dp61209
g7
V505088
p61210
stp61211
a((dp61212
g2
(lp61213
VYou cannot pass Delphi objects across a module boundary unless you are using runtime packages
p61214
aVSo, between a DLL and an EXE, it is not possible
p61215
aVThe reason for this restriction is that in order to pass objects across module boundaries you need to share the types between the modules
p61216
aVAnd that's not possible with a DLL and an EXE
p61217
aVThe sharing of types between different modules is the primary functionality of runtime packages
p61218
aVThe documentation explains the limitation like this:
p61219
aVLibraries are significantly more limited than packages in what they
p61220
aVcan export
p61221
aVLibraries cannot export constants, types, and normal
p61222
aVvariables
p61223
aVThat is, class types defined in a library will not be seen
p61224
aVin a program using that library
p61225
aVTo export items other than simple
p61226
aVprocedures and functions, packages are the recommended alternative
p61227
aVLibraries should only be considered when interoperability with other
p61228
aVprogramming is a requirement
p61229
aVIf you must use DLLs then you need to find some other way to interop
p61230
aVOne good option is to use interfaces
p61231
as(dp61232
g7
V505088
p61233
stp61234
a((dp61235
g2
(lp61236
VTo solve this you use the  indexed property which is described in the documentation like this:
p61237
aVIndicates the name part of strings that are name-value pairs
p61238
aVWhen the list of strings for the TStrings object includes strings that
p61239
aVare name-value pairs, read Names to access the name part of a string
p61240
aVNames is the name part of the string at Index, where 0 is the first
p61241
aVstring, 1 is the second string, and so on
p61242
aVIf the string is not a
p61243
aVname-value pair, Names contains an empty string
p61244
aVSo, instead of  you simply need to use
p61245
aVYour compare function thus becomes:
p61246
as(dp61247
g7
V505088
p61248
stp61249
a((dp61250
g2
(lp61251
VYou can't use your current representation to plot a reasonable chart
p61252
aVSuppose you have a bar chart with the following values:
p61253
aV10st 12lb
p61254
aV10st 13lb
p61255
aV11st 0lb
p61256
aV11st 1lb
p61257
aVThe chart will look like this:
p61258
aVForget about the axis labelling for a moment
p61259
aVLook at the difference between the bars
p61260
aVThe difference between each adjacent value is 1lb
p61261
aVBut the graph tells a completely different story
p61262
aVI've used a bar chart here, but the principle applies for all chart types
p61263
aVThe bottom line is that you need to represent your weight values with a true decimal representation of the weight
p61264
aVYour representation does not obey basic laws of arithmetic
p61265
aVSo, half a stone must be 0
p61266
ag7303
aVTrying to represent a half with the number 0
p61267
aV07 is simply asking for a world of pain
p61268
aVUse this formula to convert from stones and pounds to a true floating point representation of the weight:
p61269
aVOr if you store only the pounds then it is simply
p61270
aVI would suggest that you make sure that the  of the axis is at least 1
p61271
aVIf you need to go smaller than that then you'll have to get into custom axis label titles
p61272
aVAnd when you add your values, give them a label
p61273
aVThis will allow the chart to use sensible labels to identify values
p61274
aVFor example:
p61275
aVAnd the result looks like this:
p61276
aVYou'd obviously write a bunch of helper functions to handle this
p61277
aVI'd suggest storing the raw data as pounds
p61278
aVSo, 11st 1lb would be stored as 11*14 + 1 = 155
p61279
aVThen you'd have these helpers:
p61280
aVAnd then the data population would look like this:
p61281
aVYou have complete freedom with how you create text labels for your weights
p61282
aVIf you want something less verbose than 10st 13lb then you can adjust the helper functions to your needs
p61283
aVNow, this has been quite a long answer, so I will summarise my advice:
p61284
aVWhen you acquire the data, from what ever source, convert from whichever format they arrive in to a well-defined storage format, the raw data format
p61285
aVStore this raw data as integer values, in units of pounds
p61286
aVWhen you plot the weights, convert to floating point values in units of stones by
p61287
aVAssociate text labels to each value that you plot so that you can present the weights in human readable form
p61288
aVBe prepared to supply custom label axes if you need to label weights in between whole values of stones
p61289
as(dp61290
g7
V505088
p61291
stp61292
a((dp61293
g2
(lp61294
VIt has no effect at all
p61295
aVAll 64 bit processes are automatically decreed to be large address aware
p61296
as(dp61297
g7
V505088
p61298
stp61299
a((dp61300
g2
(lp61301
VBecause you made the thread free itself upon termination then you have asked it to destroy all traces of itself as soon as it is done
p61302
aVSince you cannot exert influence on when it finishes, it is wrong to refer to anything inside the thread after you start it
p61303
aVThe solutions proposed by other, namely asking the thread to signal you when it terminates, are good
p61304
aVI personally would probably elect to do it that way
p61305
aVIf you use an event as a signal then you can wait on that event
p61306
aVHowever, there is another way to do it
p61307
aVCreate the thread suspended
p61308
aVDuplicate the thread handle
p61309
aVStart the thread
p61310
aVWait on the duplicated handle
p61311
aVBecause you own the duplicated handle, rather than the thread, you are safe to wait on it
p61312
aVIt seems a little more complicated, but I suppose it avoids creating an extra synchronization object where one is not needed
p61313
aVNote that I'm not advocating this approach over the approach of using an event to signal completion
p61314
aVAnyway, here's a simple demonstration of the idea
p61315
as(dp61316
g7
V505088
p61317
stp61318
a((dp61319
g2
(lp61320
VYour callbacks use the  calling convention
p61321
aVBut that's a Delphi specific calling convention
p61322
aVYour library uses
p61323
aVThis can be seen from the Pascal source code for the library:
p61324
aVYou'll need to change your callbacks to match the library's calling convention
p61325
aVThe compiler would have told you all of this if only you had not used the  operator to obtain function pointers
p61326
aVDoing so means that the compiler will not check that your function pointers' signatures match the declared signatures
p61327
aVThis is one of the most common errors that people make
p61328
aVFor whatever reason, the myth has been perpetuated that the way to obtain a function pointer is to use the  operator
p61329
aVIn summary you need to add  to your callback functions:
p61330
aVAnd then stop using  to obtain function pointers:
p61331
as(dp61332
g7
V505088
p61333
stp61334
a((dp61335
g2
(lp61336
VDoes not the first declaration too initialize with a default 0 value
p61337
aVNo
p61338
aVAssuming this is a locally scoped variable, your first declaration does not result in any initialization at all
p61339
aVHow come not all of the values in the array are garbage and why only after 94th row the garbage values are appearing
p61340
aVUninitialized memory can have any value, including the values of  that you are observing
p61341
as(dp61342
g7
V505088
p61343
stp61344
a((dp61345
g2
(lp61346
VThe class type of the host form is obtained like this:
p61347
aVHere when I write  I take that to be your frame
p61348
aVAlthough you said "owner", I suspect that what you really mean is the form on which the frame resides
p61349
aVThat's usually the same thing as the frame's owner, but not always
p61350
aVThere's no need to register anything or call
p61351
aVThe only slight wrinkle with this is that  could return something derived from  rather than
p61352
aVSo the cast in the above code has potential to be incorrect
p61353
aVYou would deal with that by including a runtime test
p61354
as(dp61355
g7
V505088
p61356
stp61357
a((dp61358
g2
(lp61359
VI don't think there's much to be gained by trying to do something more advanced than iterating over the 26 drive letters
p61360
aVBefore attempting to check whether or not the marker path exists you could add a call to  and compare the return value against
p61361
aVThis will make sure that your code doesn't spin up the CD/DVD drive, or hit the network in the case of a mapped share
p61362
as(dp61363
g7
V505088
p61364
stp61365
a((dp61366
g2
(lp61367
VWell, you can use use a CAcert certificate to sign your code, but it won't help you
p61368
aVThat's because the OS doesn't install the CAcert root certificate
p61369
aVIf you want to stop your users seeing these messages you'll need to obtain a commercial certificate
p61370
as(dp61371
g7
V505088
p61372
stp61373
a((dp61374
g2
(lp61375
VThe sparse libraries concentrate on general purpose sparse storage
p61376
aVFor banded matrices you can use any of the standard linear algebra libraries, for example LAPACK
p61377
as(dp61378
g7
V505088
p61379
stp61380
a((dp61381
g2
(lp61382
VMuch of this code began life as C code, and dated from the 1980s
p61383
aVIf it were being written from scratch today then you could expect the code to look a little different
p61384
aVFor example, you pick out the  type
p61385
aVBack in the day, when the Windows API was first conceived, there was no boolean type in C
p61386
aVYou mention the  and  macros and propose templates
p61387
aVWell, there are no templates in C as you know and those macros probably even pre-date C++ templates
p61388
aVAlthough MFC is a C++ library, it stands atop Win32 which is a C API
p61389
aVAnd so the implementation of MFC will clearly have to use that C API in its implementation
p61390
as(dp61391
g7
V505088
p61392
stp61393
a((dp61394
g2
(lp61395
VThe problem is that there are two types named  in the VCL
p61396
aVOne defined in the  unit and one defined in  unit
p61397
aVClearly you are passing  to a function expecting , or vice versa
p61398
aVYou almost certainly don't want to have anything to do with
p61399
aVSo the solution is to make sure that all of your units list the  unit after the  unit in the uses clause
p61400
aVThis will have the effect of hiding
p61401
aVMy psychic debugging suggests that the unit in which  is declared either does not list  at all in its  clause, or it lists  before
p61402
aVFinally, how would you go about working out something like this yourself
p61403
aVWell, try pressing CTRL+click on the  referenced in
p61404
aVI'm confident that they will take you to the  declared in
p61405
aVThat should be enough for you to work out that it's not the type that you meant when you wrote
p61406
as(dp61407
g7
V505088
p61408
stp61409
a((dp61410
g2
(lp61411
VYour code is that it compares each value with all values that appear later in the list
p61412
aVBut the question asks you to consider adjacent pairs only
p61413
aVSo, you only need to walk the list once
p61414
aVLike this:
p61415
aVWhat's more, your code printed indices rather than values, a fault that I fixed in the above
p61416
as(dp61417
g7
V505088
p61418
stp61419
a((dp61420
g2
(lp61421
VThe code in  is fine, the problem is in the calling code
p61422
aVYou almost certainly are passing a string literal or some other read-only memory to the function
p61423
aVMost likely your calling code is:
p61424
aVBut you need to pass writeable memory
p61425
aVLike this:
p61426
as(dp61427
g7
V505088
p61428
stp61429
a((dp61430
g2
(lp61431
VI need to be able to get the value of the timer, whether its elapsed time is greater than an interval of 500ms
p61432
aVA timer does not provide an interface that allows you to ascertain how much time has elapsed
p61433
aVThe only thing that they do is fire an event when they expire
p61434
aVYou need to record the passage of time using some other mechanism, for example the  class
p61435
as(dp61436
g7
V505088
p61437
stp61438
a((dp61439
g2
(lp61440
VNo, there is no Windows API function that will yield the control's name
p61441
aVThat is a private Delphi implementation detail
p61442
aVIf you control the code of the target process then clearly you can implement some form of IPC to solve the problem
p61443
aVOtherwise, any solution that yields the control name is going to involve rather vile hacking
p61444
aVOne approach would be to inject into the process a DLL built with the same version of the runtime
p61445
aVGet that DLL to find the VCL control reference from the HWND and read out the name
p61446
aVThere are lots of variants on this and the nicely done  trickery offered by @Samaliani's answer is typical of the hoops you have to jump through
p61447
aVHowever, I can think of a much simpler solution to your problem
p61448
aVFind the handles to all the edit controls and use those handles to receive the coordinates of the controls
p61449
aVThe relative positions of the edit controls will be enough to identify which one is the desired target
p61450
aVAnd please read @dthorpe's comments below for some more useful thoughts
p61451
as(dp61452
g7
V505088
p61453
stp61454
a((dp61455
g2
(lp61456
VThe Delphi code is old and pre-dates generics, the Delphi analogue to C++ templates
p61457
aVIn modern Delphi code those list classes would simply not exist
p61458
aVInstead one would use  and
p61459
aVIn C++ code you would simply use  and
p61460
aVThere is simply no point in your C++ translation to implement  and
p61461
aVI would also correct your terminology
p61462
aVDelphi properties cannot be overriden
p61463
aVThe new property in  is just that, a new property
p61464
as(dp61465
g7
V505088
p61466
stp61467
a((dp61468
g2
(lp61469
VYou've misinterpreted how  works
p61470
aVIt does not respond to the value of  in the struct that you pass
p61471
aVInstead it fills out as much of the struct as it can
p61472
aVThe documentation says:
p61473
aVThe dwMask member specifies which attributes are consistent throughout the entire selection
p61474
aVWhat this means is that the rich edit control will assign to  as value that specifies which attributes are consistent
p61475
aVSo, you need to completely re-initialize the struct before you make the subsequent call to
p61476
as(dp61477
g7
V505088
p61478
stp61479
a((dp61480
g2
(lp61481
VYour approach is sound
p61482
aVHowever, if stdout is attached to a console then your code fails
p61483
aVA call to  following the stream write reveals the error code :
p61484
aVNot enough storage is available to process this command
p61485
aVIf you redirect stdout to a file then your code will work fine
p61486
aVAnd surely you don't really want to spew binary data to the console
p61487
aVThat's just going to put unreadable content on the console and make the computer beep annoyingly
p61488
aVIf you must output to the console then you'll need to find out how big the console device buffer is and write to it in appropriately sized chunks
p61489
aVI must confess that I'm not sure how you go about doing that
p61490
aVYou could use trial and error, but that doesn't appeal to me
p61491
aVPresumably there is a way to query the console to find out the information
p61492
aVLooking at the documentation for , it seems that 64K is the upper limit
p61493
aVAnd indeed if I write spaces to your handle stream then I can write nearly 64K in one go
p61494
aVHowever, if I write raw JPEG binary data, then it gives out earlier
p61495
aVSo I think that's part of the problem too \u2013 don't dump a JPEG onto the console
p61496
aVOne other comment
p61497
aVSince you read the contents of the file into a memory stream, there's no need to allocate an intermediate buffer
p61498
aVYou can write  directly
p61499
as(dp61500
g7
V505088
p61501
stp61502
a((dp61503
g2
(lp61504
VWindows creates a copy of the startup info struct for the new process
p61505
aVThat has to happen because the new process has a brand new address space and cannot see your struct
p61506
aVNow, what happens to your struct
p61507
aVWell, the documentation has the answer
p61508
aVThe parameter is annotated like this:
p61509
aVThe  means that the contents of the struct are not modified by the call to
p61510
aVSo, you can be confident that when  returns, the startup info struct has not been modified
p61511
as(dp61512
g7
V505088
p61513
stp61514
a((dp61515
g2
(lp61516
VIs there a better way to stop my workerThreadFunc() from executing instead of doing checks like that at various checkpoints
p61517
aVProbably not
p61518
aVThere's no fully reliable way to pre-emptively halt a thread in unmanaged code
p61519
aVAnything that purports to do that leads to
p61520
aVAnd the documentation lists all sorts of dire consequences for using that function
p61521
aVFor example:
p61522
aVIf the target thread owns a critical section, the critical section will not be released
p61523
aVIf the target thread is allocating memory from the heap, the heap lock will not be released
p61524
aVIf the target thread is executing certain kernel32 calls when it is terminated, the kernel32 state for the thread's process could be
p61525
aVinconsistent
p61526
aVIf the target thread is manipulating the global state of a shared DLL, the state of the DLL could be destroyed, affecting other users of
p61527
aVthe DLL
p61528
aVYou ask:
p61529
aVIs there a way to interrupt doLaboriousTask2() and have it exit immediately
p61530
aVWell, you could call  but, for all the reasons described in the documentation, you almost certainly should not do that
p61531
as(dp61532
g7
V505088
p61533
stp61534
a((dp61535
g2
(lp61536
VThe msscript component was not ported to 64 bit
p61537
aVIt's a legacy component and MS chose not to put the effort into migrating it to 64 bit
p61538
aVYou'll simply need to find another way to do whatever it is you do with that component
p61539
as(dp61540
g7
V505088
p61541
stp61542
a((dp61543
g2
(lp61544
VSection 4
p61545
aV10 of the standard, Pointer conversions [conv
p61546
aVptr] says:
p61547
aVA null pointer constant is an integral constant expression (5
p61548
aV19) prvalue of integer type that evaluates to zero
p61549
aVor a prvalue of type std::nullptr_t
p61550
aVA null pointer constant can be converted to a pointer type; the result
p61551
aVis the null pointer value of that type and is distinguishable from every other value of pointer to object or
p61552
aVpointer to function type
p61553
aVSuch a conversion is called a null pointer conversion
p61554
aVTwo null pointer values of the
p61555
aVsame type shall compare equal
p61556
aVThe conversion of a null pointer constant to a pointer to cv-qualified type is
p61557
aVa single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (4
p61558
aV4)
p61559
aVA null pointer constant of integral type can be converted to a prvalue of type std::nullptr_t
p61560
aVSo, yes,  is a special value in the context of pointers
p61561
as(dp61562
g7
V505088
p61563
stp61564
a((dp61565
g2
(lp61566
VThe problem is that  contains the length of the string, including the trailing zero terminator
p61567
aVSo when you do:
p61568
aVthis results in  being set to
p61569
aVAt some point you then pass this to a Windows API dialog function that treats the string as a null-terminated string, and truncates the string at the stray null-terminator
p61570
aVSo you fix it like this:
p61571
aVNote that you should also check the return value of  in case that call fails:
p61572
aVor a rather crisper variant:
p61573
aVOne final point
p61574
aVThis is the wrong way to get hold of the roaming app data folder
p61575
aVFor a start you are assuming all sorts of implementation details
p61576
aVYour approach will fail on older versions of Windows which use different naming patterns
p61577
aVOr some future version of Windows
p61578
aVOr the current versions that have been configured in a different way
p61579
aVThe right way to do this is to ask the system where the roaming app data folder is
p61580
aVDo that using  (for older Windows versions), or  (for modern Windows versions)
p61581
as(dp61582
g7
V505088
p61583
stp61584
a((dp61585
g2
(lp61586
VYou are calling
p61587
aVThat returns what are known as shared icons
p61588
aVThis is explained in the documentation for
p61589
aVOne of the consequences of being a shared icon is that you do not need to call
p61590
aVIt is only necessary to call DestroyIcon for icons and cursors created
p61591
aVwith the following functions: CreateIconFromResourceEx (if called
p61592
aVwithout the LR_SHARED flag), CreateIconIndirect, and CopyIcon
p61593
aVDo not
p61594
aVuse this function to destroy a shared icon
p61595
aVA shared icon is valid as
p61596
aVlong as the module from which it was loaded remains in memory
p61597
aVThe
p61598
aVfollowing functions obtain a shared icon
p61599
aVLoadIcon
p61600
aVLoadImage (if you use the LR_SHARED flag)
p61601
aVCopyImage (if you use the LR_COPYRETURNORG flag and the hImage parameter is a shared icon)
p61602
aVCreateIconFromResource
p61603
aVCreateIconFromResourceEx (if you use the LR_SHARED flag)
p61604
aVSo, how does this relate to your code
p61605
aVWell, when you write
p61606
aVyou are assigning to the  property of a  object
p61607
aVIf that  object already contains an icon, then that icon will be destroyed before being replaced by the new icon
p61608
aVThat's because  has ownership of its icon handles
p61609
aVAll this means that the line of code above results in a call to  for a shared icon
p61610
aVThis is what MSDN tells you not to do, but in fact it turns out to be benign
p61611
aVIt's nothing to worry about
p61612
aVNow, even if you were using a function that returns non-shared icons, e
p61613
ag217
aVthen your code would not leak icon handles
p61614
aVThat's because the  class takes on ownership of the icon handle
p61615
aVBut since you are using shared icons, it's not even possible to leak those handles
p61616
aVObjects that cannot be destroyed, cannot be leaked
p61617
aVSome more points:
p61618
aVI personally would not call  over and over like that
p61619
aVI would call it twice at program startup and remember the shared icon handles
p61620
aVThen I would use those handles to assign to
p61621
aVWhen you call  you do not have a lot of control over the size of the icon returned
p61622
aVI think that it's possible that you will get a large icon rather than a small icon
p61623
aVAnd that will need to be scaled to the small icon size before display
p61624
aVWhen creating notification area icons you should make sure that they are  by  sized
p61625
as(dp61626
g7
V505088
p61627
stp61628
a((dp61629
g2
(lp61630
VThe VCL hard codes the name  for your application's icon
p61631
aVThis can be seen in the code in :
p61632
aVOn the other hand, the shell assumes that the first icon in your executable is the main application icon
p61633
aVThe order that the shell uses is alphabetical by icon name
p61634
aVThe consequence of this is that all your icons should have names that appear after MAINICON in the alphabet
p61635
as(dp61636
g7
V505088
p61637
stp61638
a((dp61639
g2
(lp61640
VThe character set for ByValTStr is determined by the CharSet argument of the StructLayout attribute
p61641
aVSince you've not specified that, the default of 8 bit ANSI is used
p61642
aVIf you specify the CharSet as CharSet
p61643
aVUnicode then that should deal with the problem
p61644
aVAdd this attribute to your struct:
p61645
aVFor the purposes of debugging write a C++ program that outputs the size of the struct
p61646
aVMake sure that your C# program matches that value
p61647
as(dp61648
g7
V505088
p61649
stp61650
a((dp61651
g2
(lp61652
VThis is the function that I use to convert from UTC to local
p61653
aVAs you can see the function transforms the UTC date time as follows:
p61654
aVDate time -> system time
p61655
aVSystem time -> file time
p61656
aVFile time -> local file time  (this is the conversion from UTC to local)
p61657
aVLocal file time -> system time
p61658
aVSystem time -> date time
p61659
aVIt should be obvious how to reverse this
p61660
aVNote that this conversion treats daylight saving as it is now rather than as it is/was at the time being converted
p61661
aVThe  type, introduced in XE, attempts to do just that
p61662
aVThe code becomes:
p61663
aVIn the other direction use
p61664
aVThis class appears to be (loosely) modelled on the
p61665
aVnet  class
p61666
aVA word of warning
p61667
aVDo not expect the attempt to account for daylight savings at the time being converted to be 100% accurate
p61668
aVIt is simply impossible to achieve that
p61669
aVAt least without a time machine
p61670
aVAnd that's just considering times in the future
p61671
aVEven times in the past are complex
p61672
aVRaymond Chen discusses the issue here: Why Daylight Savings Time is nonintuitive
p61673
as(dp61674
g7
V505088
p61675
stp61676
a((dp61677
g2
(lp61678
VThe most obvious implementation would be:
p61679
aVBut if I were doing this I would use const parameters:
p61680
aVWell, if I were really doing this I'd use
p61681
as(dp61682
g7
V505088
p61683
stp61684
a((dp61685
g2
(lp61686
VIf you have two strings that contain integers and you wish to compare as integers then convert them from text to integer, and compare numerically
p61687
aVAnd similarly for dates
p61688
aVConvert them from text to numeric values, for example  values
p61689
aVAnd then compare numerically
p61690
aVExactly how you implement this latter function depends on how you want to convert from text to numeric representation of date/time
p61691
as(dp61692
g7
V505088
p61693
stp61694
a((dp61695
g2
(lp61696
VThe simplest way is to write the commands to a temporary file with
p61697
aVbat extension and pass that file name to ShellExecuteEx
p61698
aVThe alternative involves trying to do it with arguments to cmd
p61699
aVexe
p61700
aVThat's going to involve /C, the & or && operators and argument quoting hell
p61701
aVMy recommendation is to seek an easy life and create a temporary file with your script in
p61702
as(dp61703
g7
V505088
p61704
stp61705
a((dp61706
g2
(lp61707
VIf this is a C++ class that is exported by the DLL then you'll need to write a C++ wrapper DLL to convert it to something that can be consumed by Delphi
p61708
aVThat's because C++ classes can only be consumed by C++ code in just the same way that Delphi classes can only be consumed by Delphi code
p61709
aVIf this is an interface then you may be able to use the DLL directly
p61710
aVIf the interface is COM compatible then you may be in better shape
p61711
aVYou need to know how to instantiate the objects though
p61712
aVIs it COM
p61713
aVOr do you call functions exported by the DLL
p61714
aVYou will get nowhere trying to guess at this with PE viewer
p61715
aVYou need to study the DLL's documentation and header file
p61716
aVThat is the true specification for the binary interface
p61717
aVRegarding your update, that looks like the method from an interface
p61718
aVThat's what interface methods look like
p61719
aVBut, there's still not enough information to say for sure
p61720
as(dp61721
g7
V505088
p61722
stp61723
a((dp61724
g2
(lp61725
VLike this:
p61726
as(dp61727
g7
V505088
p61728
stp61729
a((dp61730
g2
(lp61731
VIt's possible to do what you want but I cannot imagine why you would want to
p61732
aVWhen we ported our app from D6 to D2010 we had shared source that would build in both versions
p61733
aVThis was purely a transitional arrangement
p61734
aVAs soon as we were confident in the D2010 port, we severed the umbilical cord
p61735
aVAnd at this point we embraced the new features of D2010 with relish
p61736
aVIn order to make this work we used the following crutches:
p61737
aVHelper functions to mitigate the ANSI/Unicode differences
p61738
aVUnit aliases to deal with unit renaming
p61739
aVFor example the themes units changed names from D6 to D2010 and the unit alias feature hid that
p61740
aVOodles of conditional code
p61741
aVAll this was needed because we had a porting task and so had to compile in both versions
p61742
aVThe old version for our existing product maintenance, and the new version so that we could test and develop the port
p61743
aVBut I see no reason for you to do any of this
p61744
aV, not least because it leads to very complex code
p61745
aVIf you want your app to build in D7 then always build it in D7
p61746
aVSince you cannot use features of modern Delphi and retain compatibility with D7, why use anything other than D7
p61747
aVWhen you buy modern Delphi you also gain access to old Delphi versions
p61748
as(dp61749
g7
V505088
p61750
stp61751
a((dp61752
g2
(lp61753
VThe fundamental issue, as I see it, is that  results in the class under test (CUT) being instantiated
p61754
aVI suspect that the framework was designed under the assumption that you would mock an abstract base class
p61755
aVIn which case, instantiating it would be benign
p61756
aVI suspect that you are dealing with legacy code which does not have a handy abstract base class for the CUT
p61757
aVBut in your case, the only way to instantiate the CUT involves passing parameters to the constructor and so defeats the entire purpose of mocking
p61758
aVAnd I rather imagine that it's going to be a lot of work to re-design the legacy code base until you have an abstract base class for all classes that need to be mocked
p61759
aVYou are writing  where  is a class
p61760
aVThis results in a proxy object being created
p61761
aVThat happens in
p61762
aVThe code of which looks like this:
p61763
aVAs you can see the code makes an assumption that your class has a no parameter constructor
p61764
aVWhen you call this on your class, whose constructor does have parameters, this results in a runtime RTTI exception
p61765
aVAs I understand the code, the class is instantiated solely for the purpose of intercepting its virtual methods
p61766
aVWe don't want to do anything else with the class since that would rather defeat the purpose of mocking it
p61767
aVAll you really need is an instance of an object with a suitable vtable that can be manipulated by
p61768
aVYou don't need or want your constructor to run
p61769
aVYou just want to be able to mock a class that happens to have a constructor that has parameters
p61770
aVSo instead of this code calling the constructor I suggest you modify it to make it call
p61771
aVThat's the bare minimum that you need to do in order to have a vtable that can be manipulated
p61772
aVAnd you'll also need to modify the code so that it does not attempt to destroy the mock instance and instead calls
p61773
aVAll this will work fine so long as all you do is call virtual methods on the mock
p61774
aVThe modifications look like this:
p61775
aVFrankly this looks a bit more sensible to me
p61776
aVThere's surely no point in calling constructors and destructors
p61777
aVPlease do let me know if I'm wide of the mark here and have missed the point
p61778
aVThat's entirely possible
p61779
as(dp61780
g7
V505088
p61781
stp61782
a((dp61783
g2
(lp61784
VYou only registered the leak of the string list object
p61785
aVYou also need to register that you are leaking all the objects owned by the string list
p61786
aVIn this case it owns  instances of  objects
p61787
aVThe memory manager does not know that those strings are owned by the string list object and so will also be leaked
p61788
aVAnd that's much easier said than done
p61789
aVBecause you need to find the start of the memory block that represents a string
p61790
aVThat's at a fixed offset from the string's first character, and the offset depends on which Delphi version you use
p61791
aVIn Unicode Delphi, in 32 bit code, the offset is 12 bytes
p61792
aVSo the following will register the leaked strings:
p61793
aVEven when you do that you'll still get two reported memory leaks
p61794
aVAt least one of those is explained by the dynamic array that is owned by the string list,
p61795
aVIf you wanted to register that leak, then you'll need to do some more hacking because again you'll have to rely on implementation details as to where that array is stored
p61796
as(dp61797
g7
V505088
p61798
stp61799
a((dp61800
g2
(lp61801
VSome obvious points:
p61802
aVThe code in the question doesn't compile
p61803
aVYour main declaration is not standard
p61804
aVThe  statement has an erroneous semi-colon at the end of the line
p61805
aVThe logic in your if statement is incorrect
p61806
aVThe logical or test will always evaluate to true since a character can't be both space and punctuation
p61807
aVYour palindrome checking function is far more complex than it needs to be
p61808
aVThe key change to make is that your  statement should be like so:
p61809
aVA complete working program looks like this:
p61810
aVHere is the output:
p61811
aVEnter a message: He lived as a devil, eh
p61812
aVstring = helivedasadevileh
p61813
aVPalindrome
p61814
as(dp61815
g7
V505088
p61816
stp61817
a((dp61818
g2
(lp61819
VHere's how to solve the compilation problems
p61820
aVThe call to  actually fails on the third parameter
p61821
aVLooking at the declaration, it is  which is
p61822
aVNow,  is of type  so you need to pass its address:
p61823
aVAnd similarly in the call to
p61824
aVThe C# code is:
p61825
aVTranslated to Pascal that would be:
p61826
aVI've no idea whether or not the code will solve your problem
p61827
aVI think that's beyond the remit of this question \u2013 at least that's my excuse and I'm sticking to it
p61828
as(dp61829
g7
V505088
p61830
stp61831
a((dp61832
g2
(lp61833
VThat looks like ISBN
p61834
aVTo calculate the check digit I suggest the following
p61835
aVThis converts a single character in the range '0' to '9' to the corresponding integer value
p61836
aVThis calculates the check digit for an 11 digit code
p61837
aVTo compare the actual check digit with the calculated check digit you would write:
p61838
as(dp61839
g7
V505088
p61840
stp61841
a((dp61842
g2
(lp61843
VYou appear to be trying to call the function named
p61844
aVThat receives an array of
p61845
aVThe p/invoke for that is:
p61846
aVThere's absolutely no need for unsafe code
p61847
aVJust make an array of type  in your calling code and then call
p61848
aVYou need to make sure the calling conventions match
p61849
aVSince you did not specify a calling convention in the C++ code I assume the default of  is used
p61850
aVThe struct can be declared simply as
p61851
aVThe  function is going to be more tricky because you are returning a pointer as the function return value
p61852
aVIt would be easier for you to return that information using a parameter instead of the function return value
p61853
aVMy best advice for you is to break this problem down into small pieces
p61854
aVGet the simplest function working
p61855
aVThen move on to the next function
p61856
aVAnd so on
p61857
aVDon't try to solve the entire problem in one go
p61858
aVThen you'll not know where to look for the error when it inevitably fails
p61859
as(dp61860
g7
V505088
p61861
stp61862
a((dp61863
g2
(lp61864
VYou are using a 32 bit integer
p61865
aVYou could use instead a 64 bit integer,
p61866
aVOr if you need more range than that then use a big integer class with arbitrary precision
p61867
aVBut I urge you not to use floating point arithmetic for integer calculations
p61868
aVThat will just be inaccurate
p61869
as(dp61870
g7
V505088
p61871
stp61872
a((dp61873
g2
(lp61874
VYour code runs in a 32 bit process
p61875
aVAnd as such it is subject to the registry redirector
p61876
aVThat is the technology that maintains separate 32 and 64 bit views of certain portions the registry
p61877
aVThe way this is implemented is that the 32 bit view of  is stored under
p61878
aVAnd that's where your registry writes are being re-directed to
p61879
aVNow you could choose to write to the 64 bit view of the registry by using the  flag
p61880
aVHowever, there's no need to do that
p61881
aVYou can simply write to the 32 bit view of the registry
p61882
aVWhen a user logs on Windows processes the  startup apps from both 32 and 64 bit views of the registry
p61883
aVMany programs do this
p61884
aVLooking at my machine I can see the following entries under :
p61885
aVApple Push
p61886
aViTunesHelper
p61887
aVQuickTime Task
p61888
aVDivXUpdate
p61889
aVSunJavaUpdate
p61890
aVIn other words, the code in the question already works
p61891
as(dp61892
g7
V505088
p61893
stp61894
a((dp61895
g2
(lp61896
VFirst of all let me congratulate you on a very well asked question
p61897
aVIt was a delight, for once, to receive all the code that was needed to reproduce the problem
p61898
aVThe problem is due to the slightly different ABIs used by gcc and Microsoft tools for function return values
p61899
aVFor return values that can fit into registers, for example  return values there are no differences
p61900
aVBut since your struct is too large to fit in a single register and there are differences between the APIs in that situation
p61901
aVFor larger return values, the caller passes a hidden pointer to the function
p61902
aVThis hidden pointer is pushed onto the stack by the caller
p61903
aVThe function writes the return value to the memory address specified by that hidden pointer
p61904
aVThe difference in the ABIs is in who pops that hidden pointer off the stack
p61905
aVThe Microsoft tools use an ABI that requires the caller to pop the hidden pointer, but the default gcc ABI asks the callee to do that
p61906
aVNow, gcc being almost infinitely configurable, there is a switch that will allow you to control the ABI
p61907
aVAnd you can make gcc use the same rules as the Microsoft tools
p61908
aVDoing so requires the  function attribute
p61909
aVChange your C code to be like this:
p61910
as(dp61911
g7
V505088
p61912
stp61913
a((dp61914
g2
(lp61915
VI presume what you are looking for is the angle between two vectors
p61916
aVThat is \u03b8 in this diagram:
p61917
aVThe algebraic dot product can be expressed geometrically as  = |v1||v2|cos \u03b8
p61918
aVThis can be rearranged to find \u03b8 = cos-1 /(|v1||v2|)
p61919
aVThat returns an angle in radians
p61920
aVYou can convert that into degrees using  from the  unit
p61921
aVNow, the other way to interpret your problem is that you want to take two points and form the line between then
p61922
aVAnd then find the angle between that line and the horizontal, say
p61923
aVAs described by this diagram:
p61924
aVThe can still be expressed as the angle between two vectors
p61925
aVThe first vector is p2-p1 and the other is a vector in the horizontal direction, (0, 1)
p61926
aVFeed those two into  and you have your answer
p61927
aVIf you want to measure angle to vertical, then you can use the same idea
p61928
aVHopefully there's enough here for you to solve the problem, whatever it actually is
p61929
as(dp61930
g7
V505088
p61931
stp61932
a((dp61933
g2
(lp61934
VNo function exists in the Windows API that will check if a function is open in another application
p61935
aVIf it did exist it would be subject to a race condition
p61936
aVSuppose that you checked first whether or not a file was already opened and the answer came back that it was not currently open
p61937
aVThen you move on to open it, but in the meantime somebody else has
p61938
aVThen your attempt to open fails
p61939
aVSo, the only way to know whether or not you can open a file is to attempt to do so
p61940
aVIf the file has been opened in such a way as to prevent your attempt to open it, then that attempt will fail
p61941
as(dp61942
g7
V505088
p61943
stp61944
a((dp61945
g2
(lp61946
VThe bottom line is that there is no way to protect a third party from working out what your program does
p61947
aVYour program can be debugged
p61948
aVIf the computer can execute it, then a third party can reverse engineer it
p61949
aVI believe that utorrent uses an image packer which is why you cannot inspect its imports easily
p61950
aVBut all you need to do is inspect the unpacked image and all will be revealed
p61951
as(dp61952
g7
V505088
p61953
stp61954
a((dp61955
g2
(lp61956
VIf I use C# to P/Invoke a certain DLL, will the actual C++ DLL be run for the duration of the call and then be shut down, destroying all used memory
p61957
aVNo
p61958
aVOnce the DLL is loaded it will stay loaded
p61959
aVThe DLL's lifetime is not tied to a function call
p61960
aVThis means that variables in the DLL that have static storage persist beyond the initial p/invoke call
p61961
as(dp61962
g7
V505088
p61963
stp61964
a((dp61965
g2
(lp61966
VThe type you have used
p61967
aVrepresents a mapping from a string to an instance of a class
p61968
aVBut you want a mapping from a string to the class
p61969
aVSo you need:
p61970
aVwhere
p61971
aVNote that you do not need to declare  since it is already declared in the  unit
p61972
as(dp61973
g7
V505088
p61974
stp61975
a((dp61976
g2
(lp61977
VYou don't have to do anything at all to make that menu show in a Windows  control
p61978
aVThat's a standard system menu implemented by the control
p61979
aVIt appears on a  added to a vanilla VCL forms app, since  is simple a wrapper of the multi-line variant of the  control
p61980
aVHere's all I needed in my
p61981
aVdfm file:
p61982
aVThis is functionality provided by the system
p61983
aVIf your control is not behaving that way then I can think of the following reasons why that happens:
p61984
aVYour control is not a Windows  control
p61985
aVYour control is an  control but it is not using the default message handler that results in this menu
p61986
aVIf item 1 is the reason, then there's nothing you can do to get the system display the menu
p61987
aVIf your control is not an  control you can hardly expect it to magically behave like one
p61988
aVIn the case of item 2, you need to work out how the control is stopping the message that leads to the menu being handled by the control's default message handler
p61989
as(dp61990
g7
V505088
p61991
stp61992
a((dp61993
g2
(lp61994
VThe issue that you have is that instantiation of a generic requires that the type arguments are known at compile time
p61995
aVIn your code  is not known at compile time, it is only determined at runtime
p61996
aVAnd that means that  is an invalid instantiation of the generic
p61997
aVThe bottom line here is that generics give you parameterisation of your code, but the parameters must be supplied at compile time
p61998
aVSince you don't know the parameters until runtime, you cannot solve your problem using generics
p61999
aVWell, I say, cannot, but you could use RTTI to call your generic method
p62000
aVFor that to work you'd need to ensure that each possible instantiated type was included in the executable's list of types
p62001
aVBut doing all that would really defeat the purposes of generics
p62002
aVIt's going to be much easier to use standard runtime arguments rather than compile time generic arguments
p62003
as(dp62004
g7
V505088
p62005
stp62006
a((dp62007
g2
(lp62008
VThe C# equivalent to the intrinsic  and  functions  are, respectively,  and
p62009
aVThat's because C# arrays are zero based
p62010
aVI don't see any reason why the  property of an array should have performance characteristics that differ from Delphi's
p62011
aVIn terms of performance, the big difference between a Pascal  loop and that used by C derived languages concerns evaluation of the termination test
p62012
aVConsider a classic Pascal  loop:
p62013
aVWith a Pascal  loop,  is evaluated once only, at the beginning of the loop
p62014
aVNow consider the equivalent in a C derived language:
p62015
aVIn this loop,  is evaluated every time round the loop
p62016
aVSo in a language like C#, you would need a local variable to avoid calling that function over and over
p62017
aVIn the case of an array, if the optimiser could be certain that  did not mutate during the loop, then the code could be optimised by the compiler
p62018
aVI personally do not know whether or not the C# optimiser does that, but please refer to the comments for some more information
p62019
aVBefore you start re-writing your loops to use local variables containing the length of the array, check whether or not it makes any difference
p62020
aVAlmost certainly it won't
p62021
aVThe difference between Pascal and C-like for loops that I outline above is probably more significant in semantic terms than performance
p62022
aVThe language that I am particularly envious of is D
p62023
aVHere you can use a  loop that presents each item in an array as a reference, and thus allows you to modify the contents of the array:
p62024
as(dp62025
g7
V505088
p62026
stp62027
a((dp62028
g2
(lp62029
VThe function that you need to use is
p62030
aVThis is not the easiest function in the world to use and it is worth pointing out that it is not 100% reliable
p62031
aVIt will sometimes fail to notify you of modifications
p62032
aVIn my experience that is more likely to happen for shares
p62033
aVThis API can be used in synchronous or asynchronous modes
p62034
aVAs is always the case, the synchronous version is much easier to code against
p62035
aVBut of course it blocks the calling thread
p62036
aVSo the way out of that is to put the calls to  in different threads
p62037
aVIf you have a very large number of directories to watch, then one watching thread per directory is going to be an unworkable burden
p62038
aVIf that is so then you would need to grapple with asynchronous usage
p62039
aVYou  parameter allows you to monitor an entire tree of directories which I think is what you want to do
p62040
aVFor more details I refer you to this article: Understanding ReadDirectoryChangesW
p62041
as(dp62042
g7
V505088
p62043
stp62044
a((dp62045
g2
(lp62046
VYou have a 32 bit process running on a 64 bit system
p62047
aVYour process runs inside the WOW64 emulator and is subject to the File System Redirector
p62048
aVThis redirects references to the 64 bit system folder, %windir%\u005cSystem32, to the 32 bit system folder, %windir%\u005cSysWOW64
p62049
aVThe recommended way to gain access to the 64 bit system folder, from within a 32 bit process running under the emulator is to use the %windir%\u005cSysnative alias:
p62050
aV32-bit applications can access the native system directory by substituting %windir%\u005cSysnative for %windir%\u005cSystem32
p62051
aVWOW64 recognizes Sysnative as a special alias used to indicate that the file system should not redirect the access
p62052
aVThis mechanism is flexible and easy to use, therefore, it is the recommended mechanism to bypass file system redirection
p62053
aVNote that 64-bit applications cannot use the Sysnative alias as it is a virtual directory not a real one
p62054
aVNaturally, this alias only exists on 64 bit systems
p62055
aVThe simplest way to check that is to test the value of
p62056
aVWhilst it is possible to disable the redirector, it is not advisable to do so
p62057
aVThe documentation says:
p62058
aVApplications can control the WOW64 file system redirector using the Wow64DisableWow64FsRedirection, Wow64EnableWow64FsRedirection, and Wow64RevertWow64FsRedirection functions
p62059
aVDisabling file system redirection affects all file operations performed by the calling thread, so it should be disabled only when necessary for a single CreateFile call and re-enabled again immediately after the function returns
p62060
aVDisabling file system redirection for longer periods can prevent 32-bit applications from loading system DLLs, causing the applications to fail
p62061
aVI would strongly advise you against disabling the file system redirector
p62062
as(dp62063
g7
V505088
p62064
stp62065
a((dp62066
g2
(lp62067
VWhat you are attempting to do is now rather complex
p62068
aVTo be able to keep on top of this I would recommend that you build a well-factored set of low-level helper routines
p62069
aVThen you can compose the high-level UI code in short, clear methods
p62070
aVTo start with, lets have some routines that get and set list header sort state
p62071
aVThat's the up/down sort icon in the list view's header control
p62072
aVI took this code from this answer: How to show the sort arrow on a TListView column
p62073
aVNext up I would make a record to hold the sort specification
p62074
aVIdeally this would arrive at the sort compare function in its  parameter
p62075
aVBut sadly the VCL framework missed the opportunity to use that parameter for its intended purpose
p62076
aVSo instead we will need to store the specification for the active sort in the form that owns the list view
p62077
aVAnd then in the form itself you'll declare a field to hold one of these:
p62078
aVThe compare function uses the specification
p62079
aVIt's very simple:
p62080
aVNext up we'll implement a sort function
p62081
aVThis  function is decoupled from the  handler
p62082
aVThat will allow you to sort columns independently from the user's UI actions
p62083
aVFor example, perhaps you want to sort the control on a particular column when you first show the form
p62084
aVFinally, the  handler can then call the sort function:
p62085
aVFor the sake of completeness, here is a complete unit that implements these ideas:
p62086
as(dp62087
g7
V505088
p62088
stp62089
a((dp62090
g2
(lp62091
VIn my opinion the solution is to set  to
p62092
aVUsing a value of  causes all sorts of other problems
p62093
aVThis property worked reasonably well before XP themes, but since their arrival, using  has not been viable, in my view
p62094
aVIn addition to the problems you have encountered, I've come across lots of painting flaws when using the Windows Basic theme
p62095
aVI know that's not mainstream, but I happen to see that a lot with remote access
p62096
aVAnd there's more
p62097
aVWhen you double buffer a form you stop the theme animation from working
p62098
aVFor example, a default button pulses to indicate that it is the default button
p62099
aVIf you get resize flickering without double buffering the form, use the ideas from my answer to another question
p62100
aVFrom the comments it seems that the flickering you wish to combat is in a paint box
p62101
aVI obviously don't know the details, but my experience and instincts say that you should be able to deal quite easily with that flickering at a local level
p62102
aVThere surely should be no need for the global form wide double buffering
p62103
as(dp62104
g7
V505088
p62105
stp62106
a((dp62107
g2
(lp62108
VThat's a linker error caused by the fact that you have not supplied the library file which is needed for the  function
p62109
aVYou need to pass the  library to the linker
p62110
aVThis information is included in the MSDN documentation for the function
p62111
aVScroll down to the bottom of the topic to see the information
p62112
aVAs a general rule, in order to use an API function you need to look at the Requirements section in the function's documentation
p62113
aVThat lists the following information:
p62114
aVMinimum supported Windows version
p62115
aVThe header file that you need to include
p62116
aVThe library file that you need to pass to the linker
p62117
as(dp62118
g7
V505088
p62119
stp62120
a((dp62121
g2
(lp62122
VYour code uses
p62123
aVto produce the filename
p62124
aVFor an input value of  this results in the string
p62125
aVThat's because your format string explicitly includes a leading zero
p62126
aVSo the problem boils down to your conversion from integer to string
p62127
aVYou want a conversion that does not have leading zeros
p62128
aVFor example:
p62129
aVOr if you want the convenience of converting the number, and adding on the extension in one go, then
p62130
aVThe format item has the following syntax:
p62131
aVSo, since  contains just the index, and omits the , the default formatting is performed by calling  on the object
p62132
aVSo, the above call to  is just a convenient way to write:
p62133
aVAs a piece of general advice, I suggest you take some time to learn how to get the most out of your debugger
p62134
aVHad you inspected the value of your file name variable you would immediately have seen the erroneous leading zero
p62135
aVYou will benefit greatly from learning how to use the debugger to investigate problems with your code
p62136
as(dp62137
g7
V505088
p62138
stp62139
a((dp62140
g2
(lp62141
VIt means that you attempted to read from an invalid memory location
p62142
aVIn this case the location was
p62143
aVSince that is just a small offset above zero, it seems that you are probably de-referencing an offset from a null pointer
p62144
aVSo, a common way to see something like this would be if you had a struct with a member at offset
p62145
aVAnd then if you tried to read that member from a pointer to a struct where the pointer was null
p62146
aVAnd you would get the same error indexing into an array using a null pointer
p62147
aVI think you get the idea now
p62148
aVThe other relevant information is the code address which led to the fault
p62149
aVIn your example that is
p62150
aVIf you configure your linker to produce a full image map you'll be able to identify which line of code led to the fault
p62151
aVEven better, if you produce debug information then you can attach a debugger
p62152
aVIn general terms this sort of error is known as a segmentation fault, or an access violation, or a protection fault
p62153
aVThose terms all mean the same thing
p62154
as(dp62155
g7
V505088
p62156
stp62157
a((dp62158
g2
(lp62159
VYou have a Python module that defines
p62160
aVIn your console you have another, distinct object that you name
p62161
aVWhen you output  from your console you get that object
p62162
aVWhen your module that contains your functions prints , it prints the object defined in that module
p62163
aVSo the fundamental problem is that you have two things that you call
p62164
aVI expect that you imported the module like this:
p62165
aVHaving done that you've no way to distinguish between the two  objects
p62166
aVSo instead use:
p62167
aVThen you can use  to refer to the global  defined in the module
p62168
as(dp62169
g7
V505088
p62170
stp62171
a((dp62172
g2
(lp62173
VYour problem is that you did not copy the code from @Ken's answer
p62174
aVThere's no point in us trying to debug the transcription errors that you made
p62175
aVThe correct solution is to use the code from the answer correctly
p62176
aVSince @Ken gave you a complete unit, just use that
p62177
aVMake sure you use the clipboard
p62178
aVSelect the entire unit and paste it into an empty editor window
p62179
aVThen save it to a file named
p62180
aVIf you need to edit that code then I would probably remove all the declarations that can now be found in the Windows unit
p62181
aVIt avoids confusion having only the one copy of these things
p62182
aVFor example the types and constants can, I think, all be removed
p62183
as(dp62184
g7
V505088
p62185
stp62186
a((dp62187
g2
(lp62188
VThe rule is simple:
p62189
aVWhen the variable can hold exactly one value, you test with the equality operator,
p62190
aVWhen the variable can hold zero, one or more flags, you test for the presence of the flag with the bitwise and operator,
p62191
aVIn the case of , the documentation says:
p62192
aVThe file attributes of a file
p62193
aVFor possible values and their descriptions, see
p62194
aVThe use of the plural indicates that the second of my bullet points applies
p62195
as(dp62196
g7
V505088
p62197
stp62198
a((dp62199
g2
(lp62200
VYou need to set the  property to be the bottom of the previous panel
p62201
aVFor example, like this:
p62202
aVTo fit it into your code you'd have to keep track of the location of the most recently added panel
p62203
aVPerhaps you could add a  parameter to your  function:
p62204
aVI trust you get the idea
p62205
as(dp62206
g7
V505088
p62207
stp62208
a((dp62209
g2
(lp62210
VYou allocate the length of the string using , but then populate it with
p62211
aVIf  is longer than  then you have a good chance of a segfault
p62212
aVDid you mean to use
p62213
aVYou really ought to add some error checking to your code:
p62214
as(dp62215
g7
V505088
p62216
stp62217
a((dp62218
g2
(lp62219
VYou cannot pass a Delphi  object since that is only meaningful to Delphi code
p62220
aVWhat you need to pass is an , a handle to a Windows bitmap
p62221
aVThe Delphi  class is just a wrapper around the Windows bitmap and can provide  handles
p62222
aVThe thing you need to watch out for is the ownership of those handles
p62223
aVIf you have a Delphi  you can get an  by calling the  method of a
p62224
aVThe handle returned by  is no longer owned and managed by the  object which is exactly what you want
p62225
aVYou pass that handle to the C++ code and let it become the owner
p62226
aVIt is responsible for disposing of that handle
p62227
aVThe documentation for  says:
p62228
aVReturns the handle to the bitmap so that the TBitmap object no longer
p62229
aVknows about the handle
p62230
aVUse ReleaseHandle to disassociate the bitmap from the bitmap handle
p62231
aVUse it when you need to give a bitmap handle to a routine or object
p62232
aVthat will assume ownership (or destroy) the bitmap handle
p62233
aVIn the other direction your Delphi code would receive an  from the C++ code and take on ownership
p62234
aVDo that by assigning to the  property of a  instance
p62235
aVThe details will vary from language to language, but no matter what, all will be able to deal with an
p62236
as(dp62237
g7
V505088
p62238
stp62239
a((dp62240
g2
(lp62241
VI think this is what you are looking for:
p62242
as(dp62243
g7
V505088
p62244
stp62245
a((dp62246
g2
(lp62247
VIf the type of  is  then you cannot avoid memory management issues
p62248
aVThe compiler is not going to manage the lifetime of a  instance for you
p62249
aVYou will have to use one of the standard lifetime management mechanisms:
p62250
aVYou take care of it with try/finally blocks, and explicit calls to
p62251
aVYou derive your object from  and let it be owned by something that is guaranteed to outlive all references to your wrapped string
p62252
aVOption 2 has a number of variants
p62253
aVOther ways to hand off ownership include using interfaces
p62254
aVSo long as the owner outlives all references to the object then you are safe
p62255
aVPersonally I don't very much like option 2
p62256
aVIf the compiler isn't going to manage the lifetime of my objects, I prefer to manage it myself
p62257
aVI find that if I use explicit management then it is easier to reason about when my objects' lives end
p62258
as(dp62259
g7
V505088
p62260
stp62261
a((dp62262
g2
(lp62263
VI'm afraid you are out of luck with the built in ZIP code
p62264
aVIt does record the modified timestamp when creating ZIP files
p62265
aVBut does not restore it when extracting
p62266
aVAnd there's no option to make it do so
p62267
aVI think your best option is to use a third party ZIP component
p62268
aVFor example I recommend tpAbbrevia which does support this functionality
p62269
as(dp62270
g7
V505088
p62271
stp62272
a((dp62273
g2
(lp62274
VThe error, a floating point invalid operation, makes the problem sound as though it is related to the floating point control word
p62275
aVBy default Delphi unmasks floating point exceptions
p62276
aVSo when code asks the floating point unit to perform operations that result in errors, the FPU signals which is then converted to an exception
p62277
aVBut most other Windows development environments mask these exceptions on the FPU
p62278
aVSuch code is written under the assumption that the execution environment has FPU exceptions masked
p62279
aVBut if you call a DLL from Delphi, the execution environment will have unmasked FPU exceptions, breaking that assumption
p62280
aVI suspect that if you mask FPU exceptions then your problems will disappear
p62281
aVTo test if this is the problem, you can simply add this to your code, executed early in its life:
p62282
aVThis will mask all exceptions and set the FPU control word to the default Windows setting
p62283
aVIn the longer term you may wish to mask exceptions before each call to this DLL, and then restore the FPU control word when the call to the DLL returns
p62284
aVThat is a slightly dangerous game using the libraries that are supplied with Delphi since  is not threadsafe due to its use of the global variable
p62285
aVIf you wish to read more about that issue, I refer you to QC#107411
p62286
as(dp62287
g7
V505088
p62288
stp62289
a((dp62290
g2
(lp62291
VTo answer the direct question, the closest equivalent is :
p62292
aVAlthough if you were translating the code in the question to Delphi you would not fill the string with spaces
p62293
aVThe VB code is not actually interested in what the string contains when it allocates it, it just uses  as a simple way to allocate a string of certain length
p62294
aVThe spaces are overwritten by the string returned from the API call
p62295
aVIn Delphi you would allocate a string of length 8192 by writing:
p62296
aVAnd indeed in Delphi you would use  to read from an INI file
p62297
aVSo if you are actually trying to translate the code in the question, I suggest that you don't do so and instead use Delphi's built-in libraries
p62298
as(dp62299
g7
V505088
p62300
stp62301
a((dp62302
g2
(lp62303
VThere are two issues here
p62304
aVJava is big endian and Delphi is little endian
p62305
aVThe Java code writes the date as a 64 bit integer
p62306
aVThe Delphi code reads a floating point
p62307
aVAssuming you are going to change the Delphi code rather than the Java code, here's what you would do to bring the two sides together:
p62308
aVFind or write some helper utilities to deal with the endian issue
p62309
aVConvert from big endian to little endian as soon as you read the data
p62310
aVRead the date as a 64 bit integer
p62311
aVThen you need to work out what the Java epoch is and convert from milliseconds since the Java epoch into a Delphi  which measures days elapsed since the Delphi epoch
p62312
aVDealing with endianness is simple enough, albeit rather tiresome
p62313
aVThe time conversion is perhaps a little more involved
p62314
aVThe key information is that the Java epoch is the same as the Unix epoch
p62315
aVSo a function that converts Unix time to Delphi  is all you need
p62316
aVFortunately the Delphi RTL supplies the very function
p62317
aVIt's in the  unit and is named
p62318
aVNote that  receives a Unix time measured in seconds so you'll need to divide your value in milliseconds by
p62319
aVOne other point that I would make is that the Java code writes the data out with no gaps between fields
p62320
aVBut the Delphi code uses an aligned record
p62321
aVNow, since all the members are the same size, there is no padding in this case
p62322
aVBut it's something to watch out for
p62323
aVIf I were you I would not be using legacy Pascal I/O to read this
p62324
aVI'd use a binary reader class that operates in a similar way to your Java writer
p62325
aVAnd I'd use that reader to read in the fields one at a time
p62326
aVThere may be something to be gained from finding (or writing) a reader class that handles the endian conversion for you
p62327
as(dp62328
g7
V505088
p62329
stp62330
a((dp62331
g2
(lp62332
VThe C code uses the  calling convention, but your C# code uses
p62333
aVThat is the reason why you receive the p/invoke stack imbalance message
p62334
aVChange the  to specify the calling convention:
p62335
aVNote that the default marshalling for the parameters is sufficient
p62336
aVThis change will resolve the stack imbalance, but your code will still fail to work
p62337
aVThat's because the struct is translated incorrectly
p62338
aVThe inline strings needs to be marshalled as :
p62339
as(dp62340
g7
V505088
p62341
stp62342
a((dp62343
g2
(lp62344
VYou need to convert from the node to its associated shell folder
p62345
aVWhich you can do like this:
p62346
aVThe shell folder object is just stored in the node's  property so you can do it like this:
p62347
aVOnce you have the shell folder you can get the full path with
p62348
as(dp62349
g7
V505088
p62350
stp62351
a((dp62352
g2
(lp62353
VUsing the  message is the answer
p62354
aVHere is the simplest example that I can construct to demonstrate
p62355
aVThis will save the contents of a rich edit control to a file
p62356
as(dp62357
g7
V505088
p62358
stp62359
a((dp62360
g2
(lp62361
VYour syntax is wrong
p62362
aVThe second parameter to the  is an open array containing the arguments
p62363
aVSo you need to wrap your list of arguments in what is known as an open array constructor
p62364
aVAn open array constructor is a sequence of expressions separated by commas and enclosed in brackets
p62365
aVSo, write the code like this:
p62366
as(dp62367
g7
V505088
p62368
stp62369
a((dp62370
g2
(lp62371
VTo answer your direct question, there's nothing much you can do to speed up msbuild
p62372
aVI'd expect it to run faster if your machine used an SSD, but that's probably not the sort of solution you are looking for
p62373
aVThe only other thing I can think of is to stop using msbuild altogether
p62374
aVAll it does is drive the C# compiler
p62375
aVSo why bother with msbuild at all
p62376
aVJust use the C# compiler directly
p62377
aVFor example via
p62378
as(dp62379
g7
V505088
p62380
stp62381
a((dp62382
g2
(lp62383
VYou need read the index of the item representing the name/value pair
p62384
aVDo that by calling
p62385
aVAnd then you modify that item
p62386
aVSo the code would look a little like this:
p62387
aVSince you are on a Delphi that has support for generics, you may be better off with
p62388
aVEven then it's not trivial to change the name of an item
p62389
aVTranslated to a dictionary the code looks like this:
p62390
as(dp62391
g7
V505088
p62392
stp62393
a((dp62394
g2
(lp62395
VYour approach is not valid
p62396
aVDynamic arrays are managed types
p62397
aVTheir lifetimes are managed by the compiler
p62398
aVFor that to work you must not cast away the fact that they are managed types, which is exactly what you did
p62399
aVYou cast the dynamic array to
p62400
aVAt that point you have taken a new reference to the dynamic array, but the compiler is not aware of it because a  is not a managed type
p62401
aVYou've got a few options to solve your problem
p62402
aVIf you are on a modern Delphi then stop using
p62403
aVInstead use the generic type safe containers in
p62404
aVIn your case  is what you need
p62405
aVBecause this is compile time type safe, all the lifetime of the managed types is taken care of
p62406
aVIf you are on an older Delphi, then you can wrap your dynamic array inside a class
p62407
aVThen add instances of those classes to your
p62408
aVMake sure that your list is configured to own its objects
p62409
aVIt's perfectly possible for you to do that wrapping purely in the implementation of  which will encapsulate things well
p62410
as(dp62411
g7
V505088
p62412
stp62413
a((dp62414
g2
(lp62415
VYour code to read the entire file into a string is very wasteful
p62416
aVPascal I/O uses buffering so I don't think it's the byte by byte aspect particularly
p62417
aVAlthough one big read would be better
p62418
aVThe main problem will be the string concatenation and the extreme heap allocation demand required to concatenate the string, one character at a time
p62419
aVI'd do it like this:
p62420
aVThat alone should make a big difference
p62421
aVWhen it comes to writing the file, a similar use of strings will be much faster
p62422
aVI've not attempted to decipher the writing part of your code
p62423
aVWriting the new data, and the block of zeros again should be batched up to as few separate writes as possible
p62424
aVIf ever you find that you need to read or write very small blocks to a file, then I offer you my buffered file streams: Buffered files (for faster disk access)
p62425
aVThe code could be optimised further to read only a portion of the file, and search until you find the target
p62426
aVYou may be able to avoid reading the entire file that way
p62427
aVHowever, I suspect that these changes will make enough of a difference
p62428
as(dp62429
g7
V505088
p62430
stp62431
a((dp62432
g2
(lp62433
VTo the best of my knowledge, typing into a combo box will result in the  event firing
p62434
aVBut it is true that modifying the text property does not
p62435
aVThe way I would go about getting  to fire for your combo box is to handle the  message
p62436
aVThe handler for this needs to call the  method which will then call , if it has been assigned
p62437
aVAs a simple example, here's an interposer class implementation:
p62438
as(dp62439
g7
V505088
p62440
stp62441
a((dp62442
g2
(lp62443
VYour C code changes the value of the pointer, rather than changing the buffer
p62444
aVRemember that C parameters are passed by value so modifying a parameter can never result in changes that can be seen by the caller
p62445
aVAnyway, you just need to use  to copy your string into the buffer provided
p62446
aVObviously in real code you'll want to pass the buffer length too so that you can avoid buffer overruns
p62447
as(dp62448
g7
V505088
p62449
stp62450
a((dp62451
g2
(lp62452
VIt seems to me that all your recent questions have been related to the following problem:
p62453
aVYou want to get the full product name of the operating system
p62454
aVVarious example codes that you have tried have flaws
p62455
aVFor example, many of the samples you have tried do not recognise Windows 8
p62456
aVYou want to know the product type
p62457
aVYou wish to detect the Ultimate editions
p62458
aVI suggest that you use WMI to do this
p62459
aVThat will future proof your code so that it works on as yet unreleased versions of Windows
p62460
aVFor my WMI code, I shamelessly re-used the WMI expert RRUZ's code from this answer: How do I use WMI with Delphi without drastically increasing the application's file size
p62461
aVSo now you can solve your problem with this simple program:
p62462
aVOn my machine the output is:
p62463
aVOS Name: Microsoft Windows 7 Professional
p62464
aVVersion: 6
p62465
ag5537
aV7601
p62466
aVUltimate edition: False
p62467
aVThe  class has loads more information
p62468
aVSo if you want to get at the service pack information, ask for the  property
p62469
aVLike this:
p62470
aVI hope this provides enough information for you to fill out what you actually need for your problem
p62471
aVAlthough you say that you want to support Windows 95, 98 and ME, do be aware that programs produced with Unicode versions of Delphi (XE2 for example) do not run on those ancient systems
p62472
as(dp62473
g7
V505088
p62474
stp62475
a((dp62476
g2
(lp62477
VYour cast is incorrect in modern Delphi versions
p62478
aVThe second parameter of  is typed as  which in XE2 is unsigned
p62479
aVSo if you were going to cast then you should cast to
p62480
aVIn 32 bit code your cast re-interprets large values of  as negative values
p62481
aVThen when you pass to an unsigned parameter and the range check error ensues
p62482
aVIn 64 bit code your cast would result in pointer truncation
p62483
aVBut you don't need to cast anyway
p62484
aVThat's because  is  and so is
p62485
aVSimply remove the cast:
p62486
aVThe definition of Windows types has traditionally been a mess in Delphi with many of the key types defined incorrectly
p62487
aVWhen the 64 bit Delphi compiler was introduced Embarcadero chose that moment to correct these errors
p62488
aVOn older Delphi versions the cast was needed because the second parameter of  was signed, but  was unsigned
p62489
as(dp62490
g7
V505088
p62491
stp62492
a((dp62493
g2
(lp62494
VThe only way to get Delphi to mark a function for export is to use the  directive
p62495
aVAnd Delphi will always add a named entry to the PE export table for each function that you export
p62496
aVBut it's easy enough to give the function no name
p62497
as(dp62498
g7
V505088
p62499
stp62500
a((dp62501
g2
(lp62502
VYour code is correct
p62503
aVYou allocate the correct amount of memory
p62504
aVInstead of  I would use , which is more expressive
p62505
aVI do wonder why you are using
p62506
aVI think  would be more appropriate in C++ code
p62507
aVAnd I also wonder why you are using raw pointers
p62508
aVWouldn't  makes more sense in C++ code
p62509
as(dp62510
g7
V505088
p62511
stp62512
a((dp62513
g2
(lp62514
VTaking the question at face value, in full generality, the only way to be able to do this for all possible windows is to screen scrape and use OCR to convert to text
p62515
aVThat's because there is no single common interface that all programs use to generate text
p62516
aVNow, there are things that you can do that will work for many programs
p62517
aVYou can use the accessibility or automation APIs
p62518
aVThese are the same techniques as used by screen readers
p62519
aVDocument can be found here:
p62520
aVUI Automation (UIA)
p62521
aVMicrosoft Active Accessibility (MSAA)
p62522
aVAs I understand it, UIA is the successor to MSAA and is preferred in new apps
p62523
as(dp62524
g7
V505088
p62525
stp62526
a((dp62527
g2
(lp62528
VI would store the class references in an array
p62529
aVAnd then for syntactical ease, use an indexed property:
p62530
aVThen you can simply loop over  to instantiate the objects
p62531
aVHaving said all that, is all of this scaffolding really necessary
p62532
aVWould it not just be easier to use an array property
p62533
aVThen, instead of writing  you write
p62534
aVUsing array properties gives you so much more flexibility because you can index them with variables and so decide at runtime rather than compile time which object you are referring to
p62535
as(dp62536
g7
V505088
p62537
stp62538
a((dp62539
g2
(lp62540
VRob has explained why you cannot use Delphi sets for what you need
p62541
aVI would also stress that a  is a very heavyweight type to store what amounts to an interval
p62542
aVOnce this is recognised, it makes sense to use a function like  which operates on intervals
p62543
aVAs a fun exercise, you can write a simple record that represents an interval
p62544
aVAnd then you can use operator overloading to implement an  operator that will test for interval inclusion
p62545
aVThis allows you to use the readable notation, and have the natural storage for an interval
p62546
aVAnd of course there are no constrains on element size
p62547
aVHere is the simple demonstration:
p62548
as(dp62549
g7
V505088
p62550
stp62551
a((dp62552
g2
(lp62553
VYour struct declarations are not correct
p62554
aVThe C code has inline byte arrays and simply put, they do not match the default marshalling for
p62555
aVThe easiest way to fix it is to use
p62556
aVLike this:
p62557
aVYour functions also have incorrect return value
p62558
aVA C  maps to C#
p62559
aVSo they declarations should be:
p62560
aVThe other thing to double check is the calling convention
p62561
aVThe C# function above use the default of
p62562
aVAre you sure that the C code also does
p62563
aVSince there is nothing specified between the return value and the function name, I suspect that the functions are actually
p62564
aVIn which case you need:
p62565
as(dp62566
g7
V505088
p62567
stp62568
a((dp62569
g2
(lp62570
VWhat you actually describe is a random integer with possible values in the range 0 to 10
p62571
aVSo you would write:
p62572
aVor indeed some other way to generate an integer  such that 0 <= i <= 10
p62573
aVNow,  is your value scaled by 10
p62574
aVIf you then want to divide by 10, do just that:
p62575
aVDo be aware that a binary floating point variable cannot exactly represent 0
p62576
aV1, 0
p62577
aV2, 0
p62578
aV3, 0
p62579
aV4, 0
p62580
aV6, 0
p62581
aV7, 0
p62582
aV8 and 0
p62583
ag42642
aVThe only values in your list that can be exactly expressed are 0
p62584
aV0, 0
p62585
aV5 and 1
p62586
ag9193
aVThis is why it is better to store the information in an integer variable
p62587
aVNote: As has been pointed by others (thank you), the obvious  has poor randomness properties
p62588
aVI updated the answer to avoid using that
p62589
as(dp62590
g7
V505088
p62591
stp62592
a((dp62593
g2
(lp62594
VSurely you meant to write:
p62595
aVIn other words, you pass the
p62596
aVlib file to the linker rather than the
p62597
aVdll
p62598
aVWhen you compiled the DLL, a
p62599
aVlib file will have been generated
p62600
aVBut that's not your immediate problem
p62601
aVThe compiler has no declaration for
p62602
aVThat's because you have not included the library's header file in your C++ code
p62603
aVDoing that should resolve the issue
p62604
aVIf all you need is that one function then it should be trivial to declare it in your C++ code
p62605
aVYou probably will need to wrap that in an  block too
p62606
aVActually, having looked at the library, the header file that is supplied with the source does not declare that function, even though it's present in the library
p62607
as(dp62608
g7
V505088
p62609
stp62610
a((dp62611
g2
(lp62612
VYou are trying to declare a variable like this:
p62613
aVsuch that  can be assigned objects of type  or  or
p62614
aVThat is not possible
p62615
aVWhen you define a variable using a generic type, the type must be fully instantiated
p62616
aVThe only way that you can have a variable that holds any object of type  is if the variable is declared to have a common base class to
p62617
aVAnd the common base class cannot be a non-instantiated generic
p62618
aVFor  the only possible common base class is
p62619
aVSo you could write
p62620
aVand then assign any of your objects to
p62621
aVBut I'm not sure that would be terribly useful
p62622
as(dp62623
g7
V505088
p62624
stp62625
a((dp62626
g2
(lp62627
VBy default, the height of a single line edit control is determined automatically by the font metrics
p62628
aVSo, if you want your edit to be larger, either:
p62629
aVMake its font larger, or
p62630
aVSet  to be
p62631
aVI think an edit control with  set to  will just look odd due to the extra unused vertical space
p62632
aVI don't think I've ever used, or even seen, an edit control so configured
p62633
as(dp62634
g7
V505088
p62635
stp62636
a((dp62637
g2
(lp62638
VAt some point, in order to get a queued message, you must call a function like  or
p62639
aVThose functions yield  objects and it is those  objects that you must pass to  and
p62640
aVIn the code in the original version of the question, you are trying to call  and  too late
p62641
aVYou call them inside your window proc
p62642
aVYou should call them at the point where you first receive the  object
p62643
aVIn other words, call  and  straight after the call to  or
p62644
as(dp62645
g7
V505088
p62646
stp62647
a((dp62648
g2
(lp62649
VNormally the message loop will use  instead of
p62650
aVThe difference is that  returns immediately
p62651
aVReturning either  if a message was removed, or  if no message was fetched
p62652
aVOn the other hand if the queue is empty,  blocks until a message arrives
p62653
aVThe point is the comment stating work happens here
p62654
aVPresumably the author had some reason why the normal blocking message loop would not suffice
p62655
aVThe down side of the non-blocking message loop code in the question is that it is a busy loop
p62656
aVIt will not idle and so it will fully consume the CPU, unless there is a call to  or similar that you have excised
p62657
aVIn a comment you say that you actually want to pull off keyboard messages only, and just messages for a specific window
p62658
aVYou need to call  like this:
p62659
as(dp62660
g7
V505088
p62661
stp62662
a((dp62663
g2
(lp62664
VSince you are using C++ it's going to be so much easier to start using C++ libraries to work with strings
p62665
aVYou can use  to concatenate the caption and score
p62666
as(dp62667
g7
V505088
p62668
stp62669
a((dp62670
g2
(lp62671
VThe most common choices are CSC or CSR storage
p62672
aVThese are both efficient for matrix-vector multiplication
p62673
aVIt's also very easy to code those multiplication routines, if you have to do it yourself
p62674
aVThat said, Yale storage also yields very efficient matrix-vector multiply
p62675
aVIf you are performing matrix element lookup, then you have misunderstood how to use the format
p62676
aVI suggest you study some of the standard sparse libraries to learn how matrix-vector multiplication is implemented
p62677
aVEven with your current storage you can perform matrix multiplication in O(n) complexity
p62678
aVAll sparse matrix-vector multiplication algorithms that I have ever seen boil down to the same steps
p62679
aVFor example consider y = Ax
p62680
aVZeroise the result vector, y
p62681
aVInitialise an iterator for the non-zero elements of the matrix, A
p62682
aVGet the next non-zero element of the matrix, A[i,j] say
p62683
aVNote that the pattern of i,j doesn't follow a regular pattern
p62684
aVIt simply reflects the order in which the non-zero elements of A are stored
p62685
aVy[i] += A[i,j]*x[j]
p62686
aVIf there are more elements of A, goto 3
p62687
aVI suspect you are writing the classic double for loop dense multiplication code:
p62688
aVand that's what is leading you to perform lookups
p62689
aVBut I'm not suggesting that you stick with your  storage
p62690
aVThat's not going to be super efficient
p62691
aVI'd recommend CSC mainly because it is the most widely used
p62692
as(dp62693
g7
V505088
p62694
stp62695
a((dp62696
g2
(lp62697
VYour variable  is a double precision floating point variable
p62698
aVThe value you store in it is the closest representable value to 0
p62699
aV258
p62700
aVThis value, like all binary floating point values, has a binary expansion that terminates
p62701
aVAfter all, you are storing it in a 64 bit wide variable
p62702
aVYour expectations are incorrect
p62703
aVWhilst the number stored in  may have a repeating decimal representation, the binary representation must terminate
p62704
as(dp62705
g7
V505088
p62706
stp62707
a((dp62708
g2
(lp62709
VI suspect that the question boils down to what you mean when you say:
p62710
aVA message box does not block the main application
p62711
aVWhat I take this to mean is that when you show the message box, your VCL form can still be interacted with
p62712
aVThe issue here is unrelated to threads and I suggest we remove them from the equation
p62713
aVYour understanding of what  does is sound
p62714
aVThe issue is entirely related to the concept of a window's owner, and how modal dialog windows behave with respect to their owners
p62715
aVNote that by owner, I don't mean the Delphi property , but I mean the Windows API meaning of owner
p62716
aVCreate a VCL app and drop two buttons on the form
p62717
aVAdd the following  handlers
p62718
aVNow observe what happens when you click on
p62719
aVThe message box shows, but you can still click on the VCL form
p62720
aVAnd compare with
p62721
aVWhen it shows the message box, the VCL form cannot be interacted with
p62722
aVWhen a modal dialog window is shown, the dialog window disables its owner
p62723
aVIn the case of , the owner is the VCL form
p62724
aVAnd once the form is disabled, you cannot interact with it
p62725
aVIn the case of , there is no owner and so the modal dialog window does not disable any other window
p62726
aVThat's why the VCL form can be interacted with
p62727
aVRaymond Chen has a long series on modality at his Old New Thing blog:
p62728
aVModality, part 1: UI-modality vs code-modality
p62729
aVModality, part 2: Code-modality vs UI-modality
p62730
aVModality, part 3: The WM_QUIT message
p62731
aVModality, part 4: The importance of setting the correct owner for modal UI
p62732
aVModality, part 5: Setting the correct owner for modal UI
p62733
aVModality, part 6: Interacting with a program that has gone modal
p62734
aVModality, part 7: A timed MessageBox, the cheap version
p62735
aVModality, part 8: A timed MessageBox, the better version
p62736
aVModality, part 9: Setting the correct owner for modal UI, practical exam
p62737
as(dp62738
g7
V505088
p62739
stp62740
a((dp62741
g2
(lp62742
V is a function that is known to work correctly
p62743
aVIt allows one process to read memory from another process
p62744
aVBut the addresses it uses are still virtual memory addresses
p62745
aVThey are relative to the virtual address space of the target process
p62746
aVI suspect that what you are actually trying to do is read physical memory
p62747
aVIn which case there is no alternative to kernel mode
p62748
aVOnly in kernel mode can physical memory be addressed
p62749
as(dp62750
g7
V505088
p62751
stp62752
a((dp62753
g2
(lp62754
VObject Pascal was an object oriented extension of Pascal developed by Apple
p62755
aVThe first version of Delphi was evolved from Turbo Pascal
p62756
aVThe object oriented features in Turbo Pascal were, rightly, considered not fit for purpose
p62757
aVSo Borland developed Delphi 1 and incorporated much of the Apple Object Pascal language
p62758
aVSo the language for the Delphi product was originally named Object Pascal
p62759
aVApple stopped developing Object Pascal and it was never standardised as had been originally intended
p62760
aVFor the release of Delphi 6, Borland chose to rename their language as Delphi
p62761
aVYou ask the question:
p62762
aVWhat's the difference between Object Pascal and Delphi
p62763
aVBut that's not really too meaningful since the original Object Pascal doesn't really exist in a distinct form any more
p62764
aVApple abandoned it
p62765
aVThe only extant implementations of Object Pascal like languages that are in widespread use are Delphi and the languages that it inspired: FreePascal, Oxygene, DWS, etc
p62766
aVSo a better question would be "What is the difference between Delphi and FreePascal
p62767
aVNowadays, Object Pascal is used loosely to refer to this family of related languages
p62768
as(dp62769
g7
V505088
p62770
stp62771
a((dp62772
g2
(lp62773
VThe top of your formdrop unit looks like this:
p62774
aVBut it should look like this:
p62775
aVIn  strings are short strings by default
p62776
aVTo use long strings you need to add
p62777
aVThe LCL is compiled for long strings and so you need to match that
p62778
aVIf you don't then there is a mismatch between the strings that you receive in your  event and the strings that the LCL sent you
p62779
as(dp62780
g7
V505088
p62781
stp62782
a((dp62783
g2
(lp62784
VSince you are performing column slicing, it may be better to store the matrix using CSC rather than CSR
p62785
aVBut that would depend on what else you are doing with the matrix
p62786
aVTo calculate the mean of a column in a CSC matrix you can use the  function of the matrix
p62787
aVTo calculate the standard deviation efficiently is going to involve just a bit more effort
p62788
aVFirst of all, suppose you get your sparse column like this:
p62789
aVThen calculate the variance like so:
p62790
as(dp62791
g7
V505088
p62792
stp62793
a((dp62794
g2
(lp62795
VHere's the simplest example I can think off to get and set the values from a string grid using RTTI:
p62796
aVI excised the error checking for the sake of simplicity
p62797
aVI'm going to assume that you already know how to check for errors
p62798
as(dp62799
g7
V505088
p62800
stp62801
a((dp62802
g2
(lp62803
VI implement all short cut key handling using actions
p62804
aVIf you do this then you can use the centralisation that actions, action lists, action managers etc
p62805
aVprovide to enable and disable all actions based on whether or not a form is active
p62806
aVDo that, for example, by setting the action list's  property on the  and  event handlers of the form:
p62807
as(dp62808
g7
V505088
p62809
stp62810
a((dp62811
g2
(lp62812
VIt's true that if that struct was layed out with no padding, then it could be placed at an odd address and its members would each, individually, be properly aligned
p62813
aVThe problem is how the compiler would go about placing it at an odd address
p62814
aVFor sure that could be arranged for a variable of automatic storage
p62815
aVBut what about a heap allocate variable allocated by
p62816
aVThe contract that  adheres to is that it must return a block of memory that is properly aligned for objects of any type
p62817
aVAnd  could never do that if there were some objects that needed to be placed at odd addresses
p62818
as(dp62819
g7
V505088
p62820
stp62821
a((dp62822
g2
(lp62823
VExecutive summary
p62824
aVis sufficient
p62825
aVDetailed answer
p62826
aVThe  generic container owns its contents
p62827
aVWhen you free the container, the contents are also disposed of
p62828
aVNow, if  is an unmanaged reference, either a pointer or a class, then the list owns the reference
p62829
aVIt does not own that which the reference refers to
p62830
aVSo if you have , add some objects, and then free the list, the references are disposed of, but the objects remain
p62831
aVSo, to deal with this there is
p62832
aVThat container can be configured to own the objects as well as the references, and so dispose of the objects at the appropriate moment
p62833
aVNow, in your scenario, each of your lists contains either a value type, or a managed type
p62834
aVThe list owns those objects and disposes of them when it is destroyed
p62835
aVSo for all of your lists,  is all that is needed
p62836
as(dp62837
g7
V505088
p62838
stp62839
a((dp62840
g2
(lp62841
VSystem
p62842
aVEntryPointNotFoundException: fz_pixmap_samples
p62843
aVmeans that the library does not export a function named
p62844
aVMost likely there is some name decoration that means that the function is exported with a different name
p62845
aVThe first thing to do is to remove the  argument which will allow the managed code to look for decorated names
p62846
aVIf that doesn't get it done then you need to study the
p62847
aVso library file to find out exactly what name is used to export the function
p62848
aVAnd use that in your p/invoke declaration
p62849
as(dp62850
g7
V505088
p62851
stp62852
a((dp62853
g2
(lp62854
VYou cannot send strings between processes using
p62855
aVBecause you are trying to send text across a process boundary, that text needs to be marshalled from the sender's process to the receiver's process
p62856
aVThat would involve allocating a string on the heap of the receiving  process
p62857
aVBecause messages are delivered asynchronously, there would need to be a mechanism for the receiver of the message to free that marshalled string
p62858
aVBut no such mechanism exists
p62859
aVEven for synchronous messages delivered with , only certain messages perform string marshalling
p62860
aVOnly the messages that are defined by the system and designed to carry string payload perform cross-process marshalling
p62861
aVAnd even then, it's only the messages that are intended to be used cross-process
p62862
aVSo you cannot use user-defined messages to send strings cross-process with
p62863
aVYou will need to find a more capable IPC mechanism
p62864
aVOr send text character by character
p62865
as(dp62866
g7
V505088
p62867
stp62868
a((dp62869
g2
(lp62870
VIt's an enum of bit flags:
p62871
aVAnd then
p62872
aVis just the result of bitwise OR-ing the other two flags
p62873
aVSo, bit 0 and bit 1 set
p62874
aVThe  operator is the left shift operator
p62875
aVAnd the  operator is bitwise OR
p62876
aVIn summary the resulting values are:
p62877
aVBut it makes a lot more sense to think about it in terms of flags of bits
p62878
aVOr as a set where the universal set is:  { PKRevealControllerTypeLeft, PKRevealControllerTypeRight }
p62879
aVTo learn more you need to read up about enums, shift operators and bitwise operators
p62880
as(dp62881
g7
V505088
p62882
stp62883
a((dp62884
g2
(lp62885
VYou can have overloaded functions and procedures with the same name
p62886
aVHowever, you cannot rely on function return type for overload discrimination
p62887
aVSo if you have a function and a procedure with the same argument list, they cannot be overloaded
p62888
aVI would caution you not to go mad with overloading
p62889
aVThere are all sorts of traps that you can fall into
p62890
aVFor example, if you distinguish based on floating point or integer arguments it can be hard to be sure which overload you are calling
p62891
aVThere is also much scope for confusion when you distinguish between pointers and dynamic arrays, as Embarcadero discovered with the XE3 TStream overloads
p62892
aVIn fact the documentation of the overloading rules is incomplete and the only way to fully understand the compiler's behaviour is by reverse engineering
p62893
as(dp62894
g7
V505088
p62895
stp62896
a((dp62897
g2
(lp62898
VA couple of obvious problems:
p62899
aVThis is just a pointer assignment
p62900
aVAnd tmp has the same value each time you make the assignment
p62901
aVYou need to allocate a new string each time round the loop
p62902
aVAnd use strcpy to copy it
p62903
aVSecondly your print loop assumes that the strings array is initialised with null pointers
p62904
aVIt is not
p62905
aVYou did not initialise it at all
p62906
as(dp62907
g7
V505088
p62908
stp62909
a((dp62910
g2
(lp62911
VWith this signature
p62912
aVyou have but two options to signal an error:
p62913
aVRaise an exception
p62914
aVReturn a sentinel value that indicates an error
p62915
aVThe third option is to change the signature
p62916
aVwhere the function return value is now an error code
p62917
aVIf you return an error code you force the caller to explictly check every single return value of each call
p62918
aVThat's a heavy burden
p62919
aVThink of the fun involved in calling even the most mundane Win32 API to picture the burden
p62920
aVIf you return a sentinel value, then the same burden is placed on each and every caller
p62921
aVIf you raise an exception then the caller's job is easier
p62922
aVThe caller can usually ignore exceptions and let them bubble upwards and be handled be a central exception handler
p62923
aVThe flip side is when the error condition occurs commonly and needs immediate handling
p62924
aVIn such scenarios raising an exception is usually the wrong choice
p62925
aVIf the error must always be handled at the call site then using exceptions makes it likely that the caller will forget to handle it
p62926
as(dp62927
g7
V505088
p62928
stp62929
a((dp62930
g2
(lp62931
VJudging from the commments and the question edit, you are trying to work out how to perform a replacement using a regex
p62932
aVThe function you need is
p62933
aVThere are lots of overloads
p62934
aVThe simplest to use are the class functions
p62935
aVFor example:
p62936
aVwill replace all occurrences of 3 with 4
p62937
aVOr if you want to use the instance method approach, do it like this:
p62938
aVRemember that  is a record, a value type
p62939
aVThere's no  to call and no need for
p62940
aVI personally regard  as very badly named
p62941
aVI would have preferred  if I had been designing the  type
p62942
aVUsing the instance method approach allows the expression to be compiled and that speeds up performance for repeated matching of the same expression to different input data
p62943
aVI don't know whether that would matter for you
p62944
aVIf not then use the class function interface which is simpler to use
p62945
aVYou'll obviously extend this to use a useful regex for your replacement
p62946
aVThe documentation for the PCRE regex flavour that Delphi uses is here: http://www
p62947
aVregular-expressions
p62948
aVinfo/pcre
p62949
aVhtml
p62950
as(dp62951
g7
V505088
p62952
stp62953
a((dp62954
g2
(lp62955
VThere's no way to pass a command line argument to a process so that the process can see it, but nothing else in the system cannot
p62956
aVThis is an obvious flaw and when programs allow passwords to be passed as arguments, it's usually done for convenience for the user that is not concerned about eavesdroppers
p62957
aVWell designed programs will usually provide, in addition, other secure means of authentication
p62958
as(dp62959
g7
V505088
p62960
stp62961
a((dp62962
g2
(lp62963
VThe error in the code in the question is here:
p62964
aVHere you destroy  and then immediately try to use it again
p62965
aVYou need an extra variable
p62966
aVThere may be other errors in your complete program, but that's the obvious one that can be detected in the code excerpt that you posted
p62967
as(dp62968
g7
V505088
p62969
stp62970
a((dp62971
g2
(lp62972
VThe problem is that you aren't allocating any strings
p62973
aVThe only strings that you have in  are  and
p62974
aVYou then make assignments like this:
p62975
aVThat assigns a pointer but does not copy the contents of the string
p62976
aVYou'll end up with every entry in  pointing to the same string,
p62977
aVAnd likewise for
p62978
aVYou'll need to use  and  to make new string instances
p62979
aVIn the code you have commented out calls to
p62980
aVI suspect you tried these and encountered runtime errors
p62981
aVThose runtime errors were because you did not allocate any memory
p62982
aVThe corrected code would look like:
p62983
aVAnd similarly for
p62984
aVIn production quality code you'd include error checking
p62985
aVAnd you'd want to make sure that you call  on any pointer returned by the calls , once you had finished with it
p62986
aVI'd also question the use of C variable length arrays, VLAs
p62987
aVIn your code, , ,  and  are all VLAs
p62988
aVUsing VLAs can readily lead to stack overflow if you have large array dimensions
p62989
aVMy instincts say that heap allocation is what you need here
p62990
as(dp62991
g7
V505088
p62992
stp62993
a((dp62994
g2
(lp62995
VIn the first version you pass the null pointer to
p62996
aVThen  attempts to write to that address and that leads to the segfault
p62997
aVYou need to pass a pointer to an  struct when you call
p62998
aVWhich is what you do in the second version
p62999
as(dp63000
g7
V505088
p63001
stp63002
a((dp63003
g2
(lp63004
VYou have to change everything:
p63005
aVAll references to the CLSID in the DLL that implements the COM server
p63006
aVThe registration code
p63007
aVThe code that instantiates and consumes the COM server
p63008
aVI suspect that you didn't manage to get every last reference
p63009
as(dp63010
g7
V505088
p63011
stp63012
a((dp63013
g2
(lp63014
VInstead of , compare your strings using collation order, by calling
p63015
as(dp63016
g7
V505088
p63017
stp63018
a((dp63019
g2
(lp63020
VYour results are exactly what is to be expected from a uniform distribution where you sample with replacement
p63021
aVConsider the simplest possible example
p63022
aVYou have a coin and toss it twice
p63023
aVSo we assume that we are sampling from a uniform discrete distribution
p63024
aVThe possible outcomes, which occur with equal probability of 0
p63025
aV25 are:
p63026
aVAs you can see, only two of the four outcomes have both heads and tails
p63027
aVThis is known as sampling with replacement
p63028
aVSo, once we have sampled a tails, then we "put it back in the bag", and it could come out again on the next sample
p63029
aVNow suppose we sample without replacement
p63030
aVIn that case there are two possible outcomes:
p63031
aVAnd as you see, each possible value appears exactly once
p63032
aVEssentially your expectation for the results is not correct
p63033
aVAs another example, suppose you toss a coin and it comes down tails
p63034
aVWhat do you expect will happen on the next toss
p63035
aVYou are arguing that the coin must now come down heads
p63036
aVBut that is clearly nonsense
p63037
aVIf you did want to sample without replacement, and it's not clear that's really what you want, then you do so with the Fisher-Yates shuffle
p63038
as(dp63039
g7
V505088
p63040
stp63041
a((dp63042
g2
(lp63043
VYou have to initialise the  parameter before you call the
p63044
aVYou must specify in the  which information you are requesting
p63045
aVIn your case you want to do it like this:
p63046
aVYou have also completely neglected to include error checking in your code
p63047
aVYou should add it
p63048
aVYou need to check the return value of every API call
p63049
aVConsult the documentation on MSDN to know how to interpret it
p63050
aVUsing the code above as an example, you would write:
p63051
as(dp63052
g7
V505088
p63053
stp63054
a((dp63055
g2
(lp63056
VIt appears to be a known issue with older Delphi versions, related to DEP, as I guessed in comments to the question
p63057
aVIt's clear that the code in the RTL cannot work when DEP is enabled
p63058
aVHere's a link to confirm the theory: http://codecentral
p63059
aVembarcadero
p63060
aVcom/Item/23411
p63061
aVAlthough that CodeCentral article includes code to fix the problem in Delphi 5, it looks like it will work in Delphi 7 too
p63062
aVThe fix works by hooking the  function
p63063
aVSo make sure you always use that rather than calling  yourself, for obvious reasons
p63064
as(dp63065
g7
V505088
p63066
stp63067
a((dp63068
g2
(lp63069
VYou have a few options:
p63070
aVCall  to test asynchronously whether the operation has completed
p63071
aVPass a
p63072
aVThat will be executed when the read completes
p63073
aVUse the event in the  structure
p63074
aVThat is signaled when the read completes
p63075
as(dp63076
g7
V505088
p63077
stp63078
a((dp63079
g2
(lp63080
VYou need to change the permissions so that the user has  access rights
p63081
aVThe simplest way to do so will be for your uninstall program to remove the ACL that the installer added
p63082
aVYou just need your uninstaller to reverse the steps that the installer did
p63083
aVYour installer went:
p63084
aVCreate a key
p63085
aVAdd ACL to the key
p63086
aVSo your uninstaller needs to:
p63087
aVRemove the ACL from the key
p63088
aVDelete the key
p63089
as(dp63090
g7
V505088
p63091
stp63092
a((dp63093
g2
(lp63094
VThe implementation of  would look like this:
p63095
aVIf you want to restart, then you can just create a new instance and start that
p63096
aVThe documentation for  makes it clear that the  method can only be called once for each instance of the class
p63097
aVIf you want to pause and resume a thread, then you'll need to use a condition variable
p63098
as(dp63099
g7
V505088
p63100
stp63101
a((dp63102
g2
(lp63103
VThe design of your application is probably wrong
p63104
aVStandard desktop apps are not supposed to write to
p63105
aVBecause of UAC, you need to have administrator rights, and be running in an elevated process in order to be able to write to
p63106
aVIf your application does need to make changes to  then consider doing so at installation time because the installer will be run elevated
p63107
aVIf a desktop application does need to write to  then it should consider separating those parts of the application that need to run elevated into a separate process
p63108
aVOtherwise the users are going to be very fed up with having to go through a UAC dialog in order to run your application
p63109
aVEven if they aren't using the part of the application that writes to
p63110
aVAnd if you force the entire app to require elevation then standard users can never run it at all
p63111
as(dp63112
g7
V505088
p63113
stp63114
a((dp63115
g2
(lp63116
VSince you used a relative path, the image must reside in the working directory
p63117
aVWhen you start an executable, unless you specify otherwise, the working directory is set to be the directory in which the executable resides
p63118
aVClearly the image is not there
p63119
aVSince it can be hard to extert control over the working directory, especially in a GUI app, it is usually better to specify a full absolute path rather than a relative path
p63120
aVFor example:
p63121
aVHowever, far better for your scenario would be to include the image as a resource and so make your executable self-contained
p63122
aVThen you don't need to worry about details like making sure the images land in the same directory as the executable
p63123
as(dp63124
g7
V505088
p63125
stp63126
a((dp63127
g2
(lp63128
VYou destructor is declared incorrectly
p63129
aVYou wrote:
p63130
aVBut you must override the virtual destructor declared in
p63131
aVIf you don't then your destructor will not be called by  which calls the virtual destructor declared in
p63132
aVFix it like this:
p63133
aVAlthough it doesn't matter in this case, you should get in to the habit of calling the inherited constructors and destructors in your constructors and destructors
p63134
aVThat way, when you derive from a class that does more than  does in its constructors and destructors, you will make sure the superclass code runs
p63135
aVThe FastMM report is a bit odd though
p63136
aVIt reports that the  object is leaked
p63137
aVBut since you created that as owned by the form, the form should take it down
p63138
aVThe object that is clearly leaked in the code in the question is the instance of
p63139
aVSo I suspect that there are other problems in the classes that we cannot see
p63140
aVQuite possibly you made the same error and omitted the  on the destructors of the classes that we cannot see
p63141
as(dp63142
g7
V505088
p63143
stp63144
a((dp63145
g2
(lp63146
VYour variable  is a pointer to
p63147
aVAnd since  does not have a member named , that is why the compiler objects
p63148
aVWhat's more, you have one level of indirection too many
p63149
aVA variable of type , or indeed any Delphi class is already a reference
p63150
aVIt is already a pointer
p63151
aVWhich is why your assignment to  does not use the  operator
p63152
aVIt doesn't need to take the address since the reference already is an address
p63153
aVYou need to change  to match
p63154
aVYou need a variable that is not a pointer to a reference, but a variable of whatever the actual type of the object is
p63155
aVFor example, suppose the type that defined the  property was  then your code should be:
p63156
aVOr even simpler would be to change the type of the variable from  to
p63157
aVAnd then pass around  instead of
p63158
aVThen your code could read:
p63159
aVAnd then:
p63160
aVIf you had a common base class for all of these objects then you could declare your variable to be of that type
p63161
aVAnd you could then use virtual functions and polymorphism which I think would lead to much simpler and clearer code
p63162
as(dp63163
g7
V505088
p63164
stp63165
a((dp63166
g2
(lp63167
VEnums don't contain strings
p63168
aVThe documentation describes them like this:
p63169
aVThe enum keyword is used to declare an enumeration, a distinct type consisting of a set of named constants called the enumerator list
p63170
aVEvery enumeration type has an underlying type, which can be any integral type except char
p63171
aVThe default underlying type of the enumeration elements is int
p63172
aVBy default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1
p63173
aVPerhaps what you are looking for is a string array
p63174
aVIf all you want to do is add a bunch of strings to a combo box, then a string array is fine
p63175
aVBut if you really do need an enumeration then you'll want to declare an  and find a way to map between the enum values and the string names
p63176
aVThe  attribute will do the trick
p63177
as(dp63178
g7
V505088
p63179
stp63180
a((dp63181
g2
(lp63182
VYour quoting on the arguments is wrong
p63183
aVYou have too many quotes
p63184
aVYou need to write
p63185
aVTo see that your version will fail I did the following experiment at the console:
p63186
aVC:\u005cUsers\u005cheff>setx path """C:\u005cProgram Files\u005cJava\u005cjdk1
p63187
ag25124
aV0_02\u005cbin\u005c"""
p63188
aVERROR: Invalid syntax
p63189
aVDefault option is not allowed more than '2' time(s)
p63190
aVType "SETX /
p63191
aVfor usage
p63192
aVI also note that you are using
p63193
aVNormally you do that so that you can then wait on the process handle that is returned
p63194
aVYou don't appear to be doing that
p63195
aVWhat's more, you don't appear to be closing the process handle which is your responsibility when you use
p63196
as(dp63197
g7
V505088
p63198
stp63199
a((dp63200
g2
(lp63201
VSend the underlying rich edit window the  message
p63202
aVYou pass a  struct which specifies the code page
p63203
aVSo, something like this would pull the text out into a UTF-16 encoded :
p63204
aVYou can then convert that UTF-16 string to whatever code page you like
p63205
aVIf you'd rather pull it out in a specific code page directly, then do it like this:
p63206
as(dp63207
g7
V505088
p63208
stp63209
a((dp63210
g2
(lp63211
VYou are mixing AND and OR for some reason
p63212
aVYou have
p63213
aVbut you want to write
p63214
aVThe code should read:
p63215
aVI would also echo @cdhowie's comment
p63216
aVUsing an HTML parser will make your code easier to read and write, and make it more robust to varied input
p63217
as(dp63218
g7
V505088
p63219
stp63220
a((dp63221
g2
(lp63222
VThey are quite different things:
p63223
aVThe return value, the  indicates whether or not you processed the message
p63224
aVNon-zero if you processed it, zero otherwise
p63225
aVThis determines whether or not  is called
p63226
aVAnd  is used to send information back to the caller related to this specific notification
p63227
aVExactly what that information is depends on which notification is being handled, as specified by the  struct passed via
p63228
as(dp63229
g7
V505088
p63230
stp63231
a((dp63232
g2
(lp63233
VThat is precisely how pseudo random number generators (PRNGs) work
p63234
aVWhen seeded the same way, they yield the same sequence of pseudo random numbers
p63235
aVTake a look at the documentation for the constructor of the  class:
p63236
aVProviding an identical seed value to different Random objects causes each instance to produce identical sequences of random numbers
p63237
aVOnly do note that PRNGs use numeric seeds rather than strings, as per your example in the question
p63238
aVAnd if you need a cryptographically secure PRNG, then you'll need to use a class other than , although the same principles regarding seeds apply
p63239
as(dp63240
g7
V505088
p63241
stp63242
a((dp63243
g2
(lp63244
VI think that you must be calling  incorrectly
p63245
aVThis code:
p63246
aVproduces this output on my machine:
p63247
aV\u005c\u005c
p63248
aV\u005cDISPLAY1
p63249
aV\u005c\u005c
p63250
aV\u005cDISPLAY2
p63251
aVI suspect that your call to  is failing in some way and perhaps you are not checking the return value for errors
p63252
aVHaving searched QualityCentral I suspect you have fallen victim to a known bug in older versions of Delphi: QC#3239
p63253
aVThis is reported fixed in version 10
p63254
ag9193
aV2124
p63255
aV6661 which is Delphi 2006
p63256
aVYour comments confirm this diagnosis
p63257
aVTo fix the problem you'll need a new  definition
p63258
aVHere's one that will work on your pre-Unicode Delphi:
p63259
aVIf you add that to the code above (before you declare the variables of course) then I believe it will resolve your problem
p63260
aVAs an interesting aside, even in XE3, these structs have not been translated correctly: QC#114460
p63261
aVAdmittedly the error is rather benign as it only affects  and , but the error caught me out whilst trying to solve the problem in this question
p63262
as(dp63263
g7
V505088
p63264
stp63265
a((dp63266
g2
(lp63267
VModal forms work as follows:
p63268
aVWhen the modal form is shown, it disables its owner window
p63269
aVThis has the effect of making interaction with the owner impossible
p63270
aVWhen the modal window closes, it re-enables the owner
p63271
aVBut in your scenario modal windows in the secondary application won't be disabling the windows in the primary app
p63272
aVSo to solve your problem you need to make sure that your secondary app reaches out to the primary app and disables the appropriate windows whilst the modal form is shown
p63273
aVModality is a somewhat tricky area
p63274
aVIt's easy to get it wrong with all sorts of bad consequences
p63275
aVIt took at least 10 releases of the VCL to get the handling of modality and window owner anywhere close to correct
p63276
aVRaymond Chen wrote a great serious of articles on modality and I'm sure you'll find them useful:
p63277
aVModality, part 1: UI-modality vs code-modality
p63278
aVModality, part 2: Code-modality vs UI-modality
p63279
aVModality, part 3: The WM_QUIT message
p63280
aVModality, part 4: The importance of setting the correct owner for modal UI
p63281
aVModality, part 5: Setting the correct owner for modal UI
p63282
aVModality, part 6: Interacting with a program that has gone modal
p63283
aVModality, part 7: A timed MessageBox, the cheap version
p63284
aVModality, part 8: A timed MessageBox, the better version
p63285
aVModality, part 9: Setting the correct owner for modal UI, practical exam
p63286
as(dp63287
g7
V505088
p63288
stp63289
a((dp63290
g2
(lp63291
VIs there any way to make list view it mimic the Explorer selection style
p63292
aVNo,  in  theme does not behave that way
p63293
aVThe control used by the modern Explorer is actually
p63294
aVAnd you are not able to use one of them
p63295
aVThe only way to get the behaviour of  is to code it yourself
p63296
aVI expect that's possible to do but I'd also expect it to be very difficult to achieve
p63297
as(dp63298
g7
V505088
p63299
stp63300
a((dp63301
g2
(lp63302
VYour code cannot work because you are using binary floating point
p63303
aVAnd binary floating point types cannot represent the decimal numbers that you are trying to represent
p63304
aVRepresentable binary floating point numbers are of the form s2e where s is the significand and e is the exponent
p63305
aVSo, for example, you cannot represent 0
p63306
aV1 as a binary floating point value
p63307
aVThe most obvious solution is to perform the calculation using integer arithmetic
p63308
aVDon't call StrToFloat at all
p63309
aVDon't touch floating point arithmetic
p63310
aVParse the input string yourself
p63311
aVLocate the decimal point
p63312
aVUse the number of digits that follow to work out the decimal scale
p63313
aVStrip off any leading or trailing zeros
p63314
aVAnd do the rest using integer arithmetic
p63315
aVAs an example, suppose the input is
p63316
aVConvert that, by processing the text, into numerator and denominator variables
p63317
aVObviously you'd have to code string parsing routines rather than use integer literals, but that is routine
p63318
aVFinally, complete the problem by finding the gcd of these two integers
p63319
aVThe bottom line is that to represent and operate on decimal data you need a decimal algorithm
p63320
aVAnd that excludes binary floating point
p63321
as(dp63322
g7
V505088
p63323
stp63324
a((dp63325
g2
(lp63326
VScintilla is an obvious and common choice
p63327
aVIt has a permissive license and is designed as a source code editor
p63328
aVIt's written in C++ and the Windows version is a standard Win32 control based on Windows messages
p63329
as(dp63330
g7
V505088
p63331
stp63332
a((dp63333
g2
(lp63334
VFloating point data types cannot represent all numbers
p63335
aVSince your computer uses binary floating point, the only representable numbers are of the form s2e where s is the significand, and e is the exponent
p63336
aVAnd it is easy enough to see that 5
p63337
aV1 does not fit that mould
p63338
aVIt is not exactly representable
p63339
aVThis page shows you the closest exactly representable double precision binary floating point value to 5
p63340
ag5537
aVThe value is:
p63341
aVSo the closest value to 5
p63342
aV1 is slightly less than 5
p63343
ag5537
aVMultiply it by 100 and truncate, and you have 509
p63344
aVThe standard reference from which to learn more about the topic is David Goldberg's What Every Computer Scientist Should Know About Floating-Point Arithmetic
p63345
as(dp63346
g7
V505088
p63347
stp63348
a((dp63349
g2
(lp63350
VYou did not allocate any memory for the pointer to point at
p63351
aVYou can do so like this:
p63352
aVor like this:
p63353
aVIf you allocate with  then you'll want to call  on the pointer when you are finished using it
p63354
aVAccessing an uninitialized pointer leads to undefined behaviour
p63355
aVIn your program it led to segmentation fault, one very common outcome of uninitialized pointer access
p63356
as(dp63357
g7
V505088
p63358
stp63359
a((dp63360
g2
(lp63361
VIt seems to me that you simply want to disable the top level window
p63362
aVThis will solve all your problems and remove the need for your  code
p63363
aVYou end up with a minuscule amount of code
p63364
aVYou need to p/invoke the  API call from user32:
p63365
aVYou can then control the availability of your form like this:
p63366
as(dp63367
g7
V505088
p63368
stp63369
a((dp63370
g2
(lp63371
VIt dates back to the Linux compiler, Kylix
p63372
aVHere's what I can see in my Delphi 6 language guide, page 9-4:
p63373
aVThe directive local, which marks routines as unavailable for export, is platform-specific and has no effect in Windows programming
p63374
aVOn Linux, the local directive provides a slight performance optimization for routines that are compiled into a library, but are not exported
p63375
aVThe directive can be specified for standalone procedures and functions, but not for methods
p63376
aVA routine declared with local\u2014for example
p63377
aV\u2014does not refresh the EBX register and hence
p63378
aVcannot be exported from a library
p63379
aVcannot be declared in the interface section of a unit
p63380
aVcannot have its address take or be assigned to a procedural-type variable
p63381
aVif it is a pure assembler routine, cannot be called from a another unit unless the caller sets up EBX
p63382
as(dp63383
g7
V505088
p63384
stp63385
a((dp63386
g2
(lp63387
VI'm assuming from your comment to the question, that you have decomposed the problem into sorting and comparing, and that you have got the sorting part covered
p63388
aVWhich leaves order comparison
p63389
aVYou need a function that will perform a lexicographic order comparison based first on the number of laps completed, and secondly on the time since the start of this lap
p63390
aVBasically it will look like this:
p63391
aVYou'll find  in  and  in
p63392
aVWhat I'm not sure about is what the sense of the  values is
p63393
aVYou may need to negate the result of the call to  to get the result you desire
p63394
aVAlso, what happens if there is overtaking during the lap
p63395
aVPresumably you won't be able to detect that until the racers complete the current lap
p63396
as(dp63397
g7
V505088
p63398
stp63399
a((dp63400
g2
(lp63401
VYou've got very little chance of calling that function
p63402
aVFor a start your current code can't hope to succeed since I presume  is
p63403
aVThat's a C++ data type which Delphi code cannot either provide or consume
p63404
aVTo match up against Delphi's  you need to use the COM  data type
p63405
aVAnother problem with your code as it stands is that it uses  in the C++ side, and  on the Delphi side
p63406
aVYou'll need to align the calling conventions
p63407
aVHowever, that will also fail because of a difference between Delphi's ABI for return values, and the platform standard
p63408
aVThat topic was covered in detail here: Why can a WideString not be used as a function return value for interop
p63409
aVYour best bet is to stop using  as a return value and convert it into a C++ reference parameter
p63410
aVYou'll want to convert the Delphi to match
p63411
aVYou are looking at something like this:
p63412
aVDelphi
p63413
aVC++
p63414
as(dp63415
g7
V505088
p63416
stp63417
a((dp63418
g2
(lp63419
VHere's an article from Embarcadero that confirms that you do need to call OleInitialize: http://edn
p63420
aVembarcadero
p63421
aVcom/article/20468
p63422
aVThere's no problem calling it the way you do
p63423
aVThat is how it is meant to be done
p63424
as(dp63425
g7
V505088
p63426
stp63427
a((dp63428
g2
(lp63429
VMost likely you have a 64 bit system
p63430
aVYou copy the file to the 64 bit system directory, system32
p63431
aVBut, because of the file system redirector, your 32 bit application loads it from the 32 bit system directory, SysWOW64
p63432
aVSolve the problem by copying to SysWOW64
p63433
aVYou probably know this, but I feel compelled to say it anyway
p63434
aVThe system directory belongs to the system and you should not be writing to it
p63435
as(dp63436
g7
V505088
p63437
stp63438
a((dp63439
g2
(lp63440
VSend the edit window the  message
p63441
aVYou'll need to allocate a string buffer to store the text in
p63442
aVYou can find out the required length by sending
p63443
aVThe alternative approach, perhaps slightly simpler, is to use the  and  functions
p63444
aVFor a window in the same process as the caller, there's no real difference between the two approaches
p63445
as(dp63446
g7
V505088
p63447
stp63448
a((dp63449
g2
(lp63450
VYou are using a relative filename
p63451
aVBut your current directory does not contain the file
p63452
aVAnd you don't want to search there anyway
p63453
aVUse os
p63454
aVpath
p63455
aVjoin(folder, filename) to make an absolute path
p63456
as(dp63457
g7
V505088
p63458
stp63459
a((dp63460
g2
(lp63461
VThere is no way to enforce parameter count to match
p63462
aVYou simply have to get it right
p63463
aVThe same is true for calling convention, parameter types and so on
p63464
aVUnlike managed code, native DLLs do not have metadata describing how they must be called
p63465
aVIf you enable the p/invoke stack imbalance MDA then you will at least be able to detect the error you made at runtime
p63466
as(dp63467
g7
V505088
p63468
stp63469
a((dp63470
g2
(lp63471
VYou need your data to be 16 byte aligned
p63472
aVThat requires some care and attention
p63473
aVYou can make sure that the heap allocator aligns to 16 bytes
p63474
aVBut you cannot make sure that the compiler will 16 byte align your stack allocated variables because your array has an alignment property of 4, the size of its elements
p63475
aVAnd any variables declared inside other structures will also have 4 byte alignment
p63476
aVWhich is a tough hurdle to clear
p63477
aVI don't think you can solve your problem in the currently available versions of the compiler
p63478
aVAt least not unless you forgo stack allocated variables which I'd guess to be too bitter a pill to swallow
p63479
aVYou might have some luck with an external assembler
p63480
aVU
p63481
as(dp63482
g7
V505088
p63483
stp63484
a((dp63485
g2
(lp63486
VManaged C# code cannot consume unmanaged C++ objects like
p63487
aVSo you cannot use the unmanaged DLL directly from C#
p63488
aVThe simplest solution will be to make a C++/CLI layer that adapts from unmamaged to managed
p63489
aVAnother option would be to adapt the unmamaged code so that it was callable with p/invoke but I think that would involve more effort than C++/CLI
p63490
as(dp63491
g7
V505088
p63492
stp63493
a((dp63494
g2
(lp63495
VTrying to do this with Excel is going to lead to lots of pain
p63496
aVUse one of the many excellent
p63497
aVnet charting libraries for your charts
p63498
aVIf for some other reason you must use Excel then you will need separate workbooks
p63499
aVOnly one thread at a time can operate on a workbook
p63500
aVI believe that multiple threads can operate in parallel on multiple workbooks and while I've never done it myself, I see no reason why it should not work
p63501
aVIt's quite possible that your existing code could be speeded up significantly
p63502
aVAre you disabling screen updates whilst adding data to Excel
p63503
aVIs automatic re-calculation disabled
p63504
aVAre you pushing data onto Excel cell by cell, or an entire range in one go
p63505
aVCell by cell is crushingly slow
p63506
aVYou want to minimise the number of calls you make to Excel since the IPC cost of callin an out-of-proc COM server is significant
p63507
as(dp63508
g7
V505088
p63509
stp63510
a((dp63511
g2
(lp63512
VYou cannot delete things from a raster image
p63513
aVEach pixel must have a value
p63514
aVAll you can do is draw something else over what is already there
p63515
aVSo if you want to restore what was there before, you must remember what it was, and draw it again
p63516
aVDrawing programs maintain layers, and merge those layers into a single image for rendering
p63517
aVYou could do that too, but you have to do it yourself with multiple bitmaps, one per layer
p63518
aVIf you want to draw a selection rectangle you don't need to draw on the underlying bitmap
p63519
aVWhen you need to paint you paint the bitmap to the screen and then paint the rectangle on top
p63520
aVThat way you don't let the selection rectangle spoil the actual image
p63521
as(dp63522
g7
V505088
p63523
stp63524
a((dp63525
g2
(lp63526
VYou need to make a note of the mouse position before you move it
p63527
aVSo call GetCursorPos before MouseMove
p63528
aVRemember this position in a variable that you pass to the function that restores the cursor position
p63529
as(dp63530
g7
V505088
p63531
stp63532
a((dp63533
g2
(lp63534
VThat is a symptom of the icon being cached and the cache not being refreshed
p63535
aVNormally a restart fixes the problem
p63536
as(dp63537
g7
V505088
p63538
stp63539
a((dp63540
g2
(lp63541
VI've not studied the details of your call to dgemm, and I cannot tell how you are interpreting the result matrix
p63542
aVBut it seems pretty likely that you are mixing up col major and row major interpretations somewhere
p63543
aVMost likely the calculation uses col major, but you are assuming row major
p63544
as(dp63545
g7
V505088
p63546
stp63547
a((dp63548
g2
(lp63549
VThe DC that you assign to your canvas handle is only valid during the PaintWindow call
p63550
aVYou use it outside that function when it is not valid and hence the behaviour that you observe
p63551
aVI think that you should be able to solve your problem by calling the PaintTo method
p63552
aVCreate a bitmap of the right size and pass its canvas to PaintTo
p63553
as(dp63554
g7
V505088
p63555
stp63556
a((dp63557
g2
(lp63558
VThere is only one calling convention on x64 and so it does not matter which calling convention you specify
p63559
aVIt is always ignored on x64
p63560
aVOn x86 it is important to make sure calling conventions match on both sides of the interface
p63561
aVSo if you ever anticipate running your code on x86 it would be prudent to get that right now
p63562
as(dp63563
g7
V505088
p63564
stp63565
a((dp63566
g2
(lp63567
VMixing Delphi and C# GUI in the same application is possible, but hard to achieve
p63568
aVYou'll need to set up a whole infrastructure to organise interop between the two languages
p63569
aVYou'll end up creating a huge amount of interop code that you will subsequently abandon
p63570
aVEven worse, the interop code will need to be two way
p63571
aVYou'll sometimes have C# visual code talking to Delphi non-visual
p63572
aVAnd vice-versa
p63573
aVThe idea of converting the code module by module sounds good, but I predict it will entail vast amounts of interop scaffolding
p63574
aVIt would be easier to slice it along the visual/non-visual divide, but that's not what you are proposing
p63575
aVSo frankly I think your current plan is far from optimal
p63576
aVI would not entertain it
p63577
aVI think a clean port is the best option
p63578
as(dp63579
g7
V505088
p63580
stp63581
a((dp63582
g2
(lp63583
VFor the VCL forms you need to override CreateParams and set Params
p63584
aVWndParent to the owning window
p63585
aVThat will be your OpenGL window as I understand
p63586
aVThe common dialog classes have an Execute overload that receives a window handle
p63587
aVPass the handle of your OpenGL window and that OpenGL window will be the owner window of the dialog
p63588
aVOn the subject of your forms rendering strangely it's hard to give definitive advice
p63589
aVMy guess is that the strangeness is due to the host app not enabling themes
p63590
aVIf you control the host fix it there
p63591
aVOtherwise you need to use activation contexts
p63592
aVMy answer to this question gives sample code: Possible to do runtime optional toggling of  **runtime themes** by adding an application manifest at runtime
p63593
as(dp63594
g7
V505088
p63595
stp63596
a((dp63597
g2
(lp63598
VMost likely this is down the the file system redirector
p63599
aVAssuming you really are running elevated then you will have sufficient rights
p63600
aVBut a 32 bit process sees the 32 bit system folder SysWOW64
p63601
aVThat's probably where your file is landing
p63602
aVIf you really do need to write to the 64 bit system directory either run a 64 bit process, or write to the sysnative alias
p63603
aVI'm not quite sure why you are using the legacy OpenFile
p63604
aVIt would be normal to use CreateFile
p63605
aVOr even TFileStream
p63606
as(dp63607
g7
V505088
p63608
stp63609
a((dp63610
g2
(lp63611
VIn order to use x64 features you need to be running in 64 bit mode
p63612
aVYou cannot use the 64 bit registers from a 32 bit process
p63613
aVA 32 bit process is restricted to 32 bit x86 opcodes
p63614
aVYou cannot use any of the x64 features from a 32 bit process
p63615
as(dp63616
g7
V505088
p63617
stp63618
a((dp63619
g2
(lp63620
VUsing panels like you describe is a very common and very respectable way to proceed
p63621
aVNothing wrong with doing it that way
p63622
aVAnother often used idiom is a page control with hidden tabs
p63623
aVSo, make a page control
p63624
aVAdd two tab sheets
p63625
aVSet TabVisible to False for both tab sheets
p63626
aVThen at run time set the ActivePage property of the page control to specify which page is shown to the user
p63627
aVThe page control approach is really rather similar to using panels
p63628
aVIt's perhaps marginally easier to work with at design time, but much comes down to personal preference
p63629
as(dp63630
g7
V505088
p63631
stp63632
a((dp63633
g2
(lp63634
VHere's a very simple example that prints to the console the window text for each dialog that is opened:
p63635
as(dp63636
g7
V505088
p63637
stp63638
a((dp63639
g2
(lp63640
VYou want to test whether something is a combination
p63641
aVTo do this you need to verify that the putative combination satisfies the following conditions:
p63642
aVEach element is in the range 1
p63643
aVN and
p63644
aVNo element appears more than once
p63645
aVSo, implement it like this
p63646
aVDeclare an array of counts, say array [1
p63647
aVN] of Integer
p63648
aVIf N varies at runtime you will need a dynamic array
p63649
aVInitialise all members of the array to zero
p63650
aVLoop through each element of the putative combination
p63651
aVCheck that the element is in the range 1
p63652
aVN
p63653
aVAnd increment the count for that element
p63654
aVIf any element has a count greater than 1 then this is not a valid combination
p63655
aVNow you can simplify by replacing the array of integers with an array of booleans but that should be self evident
p63656
as(dp63657
g7
V505088
p63658
stp63659
a((dp63660
g2
(lp63661
VYou could use the built in class registry
p63662
aVRegister all your form classes by calling
p63663
aVDo this from an initialization section, typically that of the unit which defines the class
p63664
aVWhen you want to recover the class from the registry, call  passing the class name
p63665
aVFor safety, check that  returns a class that inherits from
p63666
aVFinally create the form instance using either  or just calling the  virtual constructor of the class
p63667
aVThe instantiation looks like this:
p63668
as(dp63669
g7
V505088
p63670
stp63671
a((dp63672
g2
(lp63673
VBecause FPC supports so many different platforms, the structure of the RTL code is somewhat complex
p63674
aVBut the platform independent part of the RTL code, which is what you are interested in can be found under the  directory
p63675
aVThe code for  is in include files in
p63676
aVThe relevant files are  and
p63677
aVThe former contains the code for the interface section, the latter code for the implementation section
p63678
aVThe  unit is highly platform specific
p63679
aVLook for your platform under
p63680
aVFor  look under
p63681
as(dp63682
g7
V505088
p63683
stp63684
a((dp63685
g2
(lp63686
VTo execute code in the main thread, without access to a  instance, call the class methods  or
p63687
aVIf you happen to be using an old Delphi compiler that does not have those methods, then  or  with a user defined message are the simplest solution
p63688
as(dp63689
g7
V505088
p63690
stp63691
a((dp63692
g2
(lp63693
VI'd probably use a conditional
p63694
aVIt's very clear and not especially verbose
p63695
aVIt's easy enough to use Enum
p63696
aVGetValues() to make this generic
p63697
aVThe concrete example above gets the idea across most clearly I think
p63698
as(dp63699
g7
V505088
p63700
stp63701
a((dp63702
g2
(lp63703
VDoes Delphi 7 have some way to identify the kind of string used and automatically define the correct type
p63704
aVEven if it improved performance, the compiler never makes such transformations
p63705
aVIn order to do so it would need to perform what is known as data flow analysis
p63706
aVIn other words it would need to analyse how the data flows through the program and reason about the possible content that could be held in variables
p63707
aVBut the compiler does not perform that sort of analysis and so cannot make optimisations of the
p63708
aVtype you describe
p63709
as(dp63710
g7
V505088
p63711
stp63712
a((dp63713
g2
(lp63714
VYou are returning an array allocated by a call to C++ new and hoping that the marshaler will turn it into a C# byte[]
p63715
aVThat won't happen
p63716
aVYou'll need to pass a pointer by reference and then marshal it by hand
p63717
aVYour p/invoke should look like this:
p63718
aVWhen the function returns data will point to the array and you can read the contents using the Marshal class
p63719
aVI guess you would copy it to a new byte array
p63720
aVSome other points:
p63721
aVThe calling conventions do not match
p63722
aVThe native side is cdecl and the managed is stdcall
p63723
aVYou'll need to export a deallocator to delete the memory returned by the native function
p63724
aVConsider a re-design where the caller allocates the buffer
p63725
as(dp63726
g7
V505088
p63727
stp63728
a((dp63729
g2
(lp63730
VUnit scope names were introduced in XE2
p63731
aVAnd XE2 is compiler version 23
p63732
aVSo the conditional is:
p63733
as(dp63734
g7
V505088
p63735
stp63736
a((dp63737
g2
(lp63738
VUse the mod operator:
p63739
aVThe Value-1 adapts the 1-based indexing of Value to the 0-based indexing of enumerated types
p63740
as(dp63741
g7
V505088
p63742
stp63743
a((dp63744
g2
(lp63745
VServices run in session 0, but that's a non-interactive session
p63746
aVSo if the other process is interactive you need to make sure that it runs in an interactive session
p63747
aVThat's quite trick to arrange, but not impossible
p63748
aVDetails can be found here: http://blogs
p63749
aVmsdn
p63750
aVcom/b/winsdk/archive/2009/07/14/launching-an-interactive-process-from-windows-service-in-windows-vista-and-later
p63751
aVaspx
p63752
as(dp63753
g7
V505088
p63754
stp63755
a((dp63756
g2
(lp63757
VYou need to declare your struct in C# and then pass it to the function
p63758
aVLike this:
p63759
aVOr, if you only have an opaque pointer to the struct, you omit the struct declaration and pass the opaque pointer:
p63760
as(dp63761
g7
V505088
p63762
stp63763
a((dp63764
g2
(lp63765
VThe C# language does not support meta classes
p63766
aVSo you'll have to implement your factory in another way
p63767
aVOne way is to use a switch statement on an enum:
p63768
aVAnother commonly used option is to do it with reflection which would allow you to write code closer to what you are used to doing
p63769
aVAnd yet another option is to replace your dictionary of classes with a dictionary of delegates that return a new instance of your object
p63770
aVWith lambda syntax that option yields very clean code
p63771
aVThe disadvantage of reflection is that you give up compile time type safety
p63772
aVSo whilst the reflection based approach is probably closest to the Delphi code in the question, it's not the route that I personally would choose
p63773
aVRather than trying to shoe horn your Delphi solution into a language that does not want that approach, I suggest you look for the most idiomatic C# solution
p63774
aVStart with a web search for class factory
p63775
as(dp63776
g7
V505088
p63777
stp63778
a((dp63779
g2
(lp63780
VShowMessage shows a modal dialog
p63781
aVIn other words, it disables its owning window while the dialog shows
p63782
aVAnd so you cannot interact with the other windows in your app
p63783
aVShowMessage already does what you want
p63784
aVIf you find that you can interact with other windows in your application whilst the dialog is showing, then you must have got the window ownership wrong
p63785
as(dp63786
g7
V505088
p63787
stp63788
a((dp63789
g2
(lp63790
VCreate two versions of the
p63791
aVmsi
p63792
aVOne version you deliver on multiple DVDs
p63793
aVYou cannot possibly install that silently because you cannot silently change physical media
p63794
aVAnd the second version you deliver as a single, unsplit, package
p63795
aVThat version has no problem being installed silently because there is no need for human intervention to change media
p63796
as(dp63797
g7
V505088
p63798
stp63799
a((dp63800
g2
(lp63801
VIt's not messages that have privileges, rather it is processes
p63802
aVThe functionality is known as User Interface Privilege Isolation (UIPI)
p63803
aVThis functionality stops lower integrity level processes sending messages to higher integrity level processes
p63804
aVBut that's not your problem
p63805
aVYour problem is that each process has a separate address space
p63806
aVAnd so a pointer from one process means nothing in a different process
p63807
aVWhich is why you encounter an access violation
p63808
aVThe pointer that you receive points to memory in a different process and so is meaningless
p63809
aVYou need to use an inter-process communication (IPC) mechanism
p63810
aVFor example, sending a  message, or named pipes, or sockets and so on
p63811
as(dp63812
g7
V505088
p63813
stp63814
a((dp63815
g2
(lp63816
VThere are two distinct errors
p63817
aVFirstly, the updating of  must use  rather than
p63818
aVAnd secondly, the Delphi code performs arithmetic on  in the context of  which is a 2 byte unsigned integer
p63819
aVBut the Java code performs the same calculations in the context of  which is a 4 byte signed integer
p63820
aVTo fix this I believe you simply need to perform the arithmetic using 4 byte signed and then truncate  to a 2 byte value
p63821
aVLike this:
p63822
aVI also think that you can simplify the Java code considerably
p63823
aVI know next to nothing about Java and so I'm sure a skilled Java expert could do very much better than this:
p63824
aVOutput:
p63825
aV4144db69bf
p63826
aVOn a more general note, since you have both codes, you should arrange that both codes are as close to each other in organisation as possible
p63827
aVAnd then print off as much diagnostics as possible to pinpoint the calculation step where differences first appear
p63828
as(dp63829
g7
V505088
p63830
stp63831
a((dp63832
g2
(lp63833
VYour original question title was a little mis-leading because all you actually want to do is concatenate a string and an integer
p63834
aVIn C++ you would probably do that with :
p63835
aVAnd then to get a  variable:
p63836
aVAnd finally to pass a C string to the SDL function use :
p63837
aVThe declaration of  is wrong
p63838
aVYou need an array of length 10, but you declared it to have length 9
p63839
aVIf you made  into a constant you could write  and so be sure that the array was the correct length
p63840
aVThe code might then look like this:
p63841
aVIf your file names really start with  then you'll need to adjust the indexing:
p63842
aVFinally, if you need to extend this to handle a variable number of files, determined at runtime, then you should use  instead of a raw array
p63843
aVUsing  allows you to let the C++ standard library take care of low-level memory management for you
p63844
aVIn fact any time you find yourself allocating memory when programming in C++ you should ask yourself if there is already some part of the standard library that will do it for you
p63845
as(dp63846
g7
V505088
p63847
stp63848
a((dp63849
g2
(lp63850
VThe only explanation is that the file is not a valid Windows bitmap (maybe the file is truncated)
p63851
aVOr perhaps the file uses some esoteric format not supported by Delphi
p63852
aVIs it using run-length encoding, for example
p63853
aVIf the file did not exist you'd get a different error, one that indicated that no such file exists
p63854
aVSo, the file exists but cannot be loaded
p63855
aVErgo, it's not a Windows bitmap
p63856
aVStep 1 to diagnose this is to look at the format of the file
p63857
aVLoad up the bitmap file header and check that the values make sense
p63858
aVProbably the easiest way to do this is to step through the VCL code when running your program under the debugger
p63859
aVEnable the Debug DCUs option so that you can do that
p63860
aVSet a breakpoint in  in the  unit and take it from there
p63861
aVHaving said all that, it may just be easier for you to avoid trying to debug the problem at all
p63862
aVIf you can load the image into an image editor, simply save a new copy of the image in a format that will be read by Delphi
p63863
aVFor example a plain vanilla Windows bitmap, or, even better, a PNG file which will admit compression
p63864
as(dp63865
g7
V505088
p63866
stp63867
a((dp63868
g2
(lp63869
VFor C the value is given by  in
p63870
aVFor C++ you can alternatively use  from
p63871
as(dp63872
g7
V505088
p63873
stp63874
a((dp63875
g2
(lp63876
VRegarding the floating point exceptions,  expects to operate with floating point exceptions masked
p63877
aVIt looks like you are using Delphi default floating point settings and have exceptions unmasked
p63878
aVI suspect that if you mask exceptions then your problems will disappear
p63879
aVDo that like so:
p63880
aVAnd as others have said, you silence the Javascript popups by setting  to
p63881
as(dp63882
g7
V505088
p63883
stp63884
a((dp63885
g2
(lp63886
VI'd like to retrieve the stack as it was just before the
p63887
aVexception was thrown, or in other words the contents before
p63888
aV(after would do too) the OnException call
p63889
aVActually, you don't want the stack before the OnException call
p63890
aVThat's what you've already got
p63891
aVYou want the stack at the point at which the exception was raised
p63892
aVAnd that requires the stack tracing to happen ASAP after the raise
p63893
aVIt's too late in the OnException call because the exception has propagated all the way to the top-level handler
p63894
aVmadExcept works by hooking all the RTL functions that handle exceptions
p63895
aVAnd it hooks the lowest level functions
p63896
aVThis takes some serious effort to bring about
p63897
aVWith these routines hooked the code can capture stack traces and so on
p63898
aVNote that the hooking is version specific and requires reverse engineering of the RTL
p63899
aVWhat's more the stack walking is very much more advanced than your basic code
p63900
aVI don't mean that in a derogatory way, it's just that stack walking on x86 is a tricky business and the madExcept code is very well honed
p63901
aVThat's the basic idea
p63902
aVIf you want to learn more then you can obtain the source code of JclDebug for free
p63903
aVOr buy madExcept and get its source
p63904
as(dp63905
g7
V505088
p63906
stp63907
a((dp63908
g2
(lp63909
VThe text you quote:
p63910
aVAn object remains in memory as long as at least one object handle exists
p63911
aVdoes not apply to thread execution
p63912
aVThreads execute until they are finished
p63913
aVAnd then they stop executing
p63914
aVThe thread handle merely provides a mechanisn for you to query for exit codes, to wait until signaled, to force termination etc
p63915
aVSo, closing the final handle to a thread will not terminate the thread
p63916
as(dp63917
g7
V505088
p63918
stp63919
a((dp63920
g2
(lp63921
VThe main problem with that code, is that it does not perform correct error handling
p63922
aVYou need to check the return value of  to detect an error
p63923
as(dp63924
g7
V505088
p63925
stp63926
a((dp63927
g2
(lp63928
V on a dynamic array yields the size of a pointer
p63929
aVA dynamic array is a reference type that is represented as a pointer to the first element of the array
p63930
aVAnd hence  returns the size of a pointer
p63931
aVAnd that's no use to you here
p63932
aVYou need to use  instead:
p63933
aVThe  function returns the number of elements in an array
p63934
aVWhat's more, I would probably simplify the way you cast to
p63935
aVYou can do it more concisely like this:
p63936
aVThat's meaningful because , being a reference to a dynamic array, points to the first element of the array
p63937
as(dp63938
g7
V505088
p63939
stp63940
a((dp63941
g2
(lp63942
VThe most common cause for such problems is session zero isolation
p63943
aVBut since that was introduced in Vista, and you experience the problem with XP, we can probably rule that out
p63944
aVWhich then leaves the user as the most likely explanation
p63945
aVIt's quite common for programs to fail when run from the LOCALSYSTEM account
p63946
aVThere are a multitude of reasons why the program could fail
p63947
aVDiagnostics from the failing program would lead you to the explanation
p63948
aVIn any case, you are not supposed to use the LOCALSYSTEM account
p63949
aVThe official policy from Microsoft has been, for at least 10 years now, possibly more, that you should not use the LOCALSYSTEM account for your services
p63950
aVI suggest that you run your service under a user account created specially for it
p63951
aVBut in the short term, to test the theory, just use one of the existing accounts on your test machine
p63952
aVIf that solves the immediate problem, it's still possible that you may encounter session zero isolation problems on operating systems which implement that feature
p63953
as(dp63954
g7
V505088
p63955
stp63956
a((dp63957
g2
(lp63958
VIt's not a coincidence
p63959
aVIt turns out that  is implemented by a call to  which passes a timeout value of
p63960
aVThis is trivial to discern using a debugger
p63961
aVAnd it also turns out that  dialogs respond to  messages by closing the dialog
p63962
aVThat's how  implements the timeout
p63963
aVSo, if you post a  message to a  dialog you are really posting it to a  dialog and so you will indeed close it
p63964
aVIt's certainly not a bug because  makes no promises at all as to how it will respond to receiving  messages
p63965
aVAnd it's not a feature because it's not documented
p63966
aVIt's just a curious side-effect of the current implementation of
p63967
aVOf course, all this is implementation detail, subject to change, etc
p63968
aVetc
p63969
as(dp63970
g7
V505088
p63971
stp63972
a((dp63973
g2
(lp63974
VYou can simply execute  in all cases
p63975
aVIf it's not running, then  will having nothing to kill and will just return
p63976
aVIn that situation,  will report an error and set the error level
p63977
aVYou can suppress the reporting of the error by redirecting standard error:
p63978
aVAs for the error level, you can just ignore that and it will be cleared by the next command that you execute
p63979
aVOr if needed, you can clear it yourself
p63980
aVThis approach is, in my view, better than trying to anticipate whether or not  will succeed
p63981
aVYou won't be able to anticipate all possible failure modes and since  itself performs the very check that you are asking about, I think you may as well leave that check to
p63982
as(dp63983
g7
V505088
p63984
stp63985
a((dp63986
g2
(lp63987
VThere's a difference because there is no standard that mandates the text size for web page rendering
p63988
aVAnd so browser vendors are free to render text at whatever size they wish
p63989
as(dp63990
g7
V505088
p63991
stp63992
a((dp63993
g2
(lp63994
VIf you use a relative path, the path you supply is combined with the working directory of the process
p63995
aVIt's very hard to maintain control over the working directory of a GUI process
p63996
aVThat's because GUI processes tend to be started in lots of different ways
p63997
aVWhat's more, file dialogs have a tendency to change working directory
p63998
aVFinally, the working directory is shared between all threads in the process, and can be changed by any thread
p63999
aVThere are lots of pitfalls
p64000
aVSo in a GUI process I suggest that you never use relative paths
p64001
aVOr, if you do use relative paths, you convert them to absolute paths before using them
p64002
aVAnd perform that conversion against a well-defined root path
p64003
aVUnless you are writing a portable app, you should not expect to be able to save to the directory which contains the executable file
p64004
aVOn modern systems executable files are often located in read-only directories
p64005
aVIf you want to save user settings, save them at an appropriate location in the user's profile
p64006
aVOn the other hand, if you are wanting to read files, that you never modify, then it's reasonable to store them alongside the executable
p64007
aVBut even in that case, open the file using a full absolute path
p64008
aVCreate that path by combining the directory which contains the executable, with the relative path to the file
p64009
aVSo, to summarise, you said:
p64010
aVIt's rarely realistic to always specify the absolute path
p64011
aVBut I disagree
p64012
aVI would counter that using an absolute path is very often the best option
p64013
aVBut you don't have to hard code the absolute path
p64014
aVYou can, and should, create it at runtime
p64015
as(dp64016
g7
V505088
p64017
stp64018
a((dp64019
g2
(lp64020
VYou can use pinvoke
p64021
aVnet as a source of Win32 API translations
p64022
aVFor example, here are the two you are interested in:
p64023
aVCreateProcess
p64024
aVCreateThread
p64025
aVDo be warned that the translations there are of variable quality
p64026
aVFor example, there are two versions of  at the link above
p64027
aVOnly one of them is accurate
p64028
aVIt's obvious which one it is
p64029
aVMore generally you should have a good read of the MSDN p/invoke tutorial, and Marshaling Data with Platform Invoke
p64030
as(dp64031
g7
V505088
p64032
stp64033
a((dp64034
g2
(lp64035
VThe error is raised specifically by your program
p64036
aVThat can be discerned from this message:
p64037
aVException class Exception with message 'Error creating shared memory Global\u005c{B40FBC0C-FEBD-11DD-B3EA-FC6656D89593} (5)
p64038
aVThat has all the hallmarks of an exception raised by a Delphi program
p64039
aVThe hexadecimal is indicated by  rather than , and the first words of the message are standard Delphi
p64040
aVI'm going to assume that it is your program that raises this exception
p64041
aVFirst of all, the exception class is
p64042
aVTo the very best of my knowledge, nothing in the RTL, or any reputable third party libraries raises an exception of class
p64043
aVThat is considered bad practice
p64044
aVAlways raise a sub-class of
p64045
aVErgo, your application's code is raising this exception
p64046
aVSecondly, the message describes an error in creating shared memory, and gives a named object in the  namespace
p64047
aVThis is probably a named file mapping object
p64048
aVAnd finally the message includes a Win32 error code retrieved by a call to
p64049
aVThat code is number 5, our old friend
p64050
aVSo it would seem that this program operates in tandem with a separate process and communication is effected using shared memory, a file mapping
p64051
aVAnd the security for that file mapping has not been set correctly for whatever reason
p64052
aVThe object has been placed in the  namespace, which is what you do if you need it to be shared between sessions
p64053
aVSo it seems plausible that the other process resides in a service in session 0
p64054
aVPerhaps the security attributes that are needed to secure an object for cross-session access have not been correctly specified
p64055
aVThe code that raises the exception will look a little like this:
p64056
aVThat's about all I can say from the evidence presented
p64057
aVBut now you know what to search for in your program in order to locate the code which is failing
p64058
aVOver to you
p64059
as(dp64060
g7
V505088
p64061
stp64062
a((dp64063
g2
(lp64064
VTo check whether or not the value exists, call
p64065
aVNote that what you called  is actually a key rather than a value
p64066
aVTo avoid confusion you should name it such
p64067
aVI used the name
p64068
aVThen to check whether or not the value exists, compare  against  as described in the documentation
p64069
aVThe other problem with your code is that there is absolutely no error checking
p64070
aVI'll leave that to you to address
p64071
as(dp64072
g7
V505088
p64073
stp64074
a((dp64075
g2
(lp64076
VThe only problem I can see is that you did not specify an owner for the dialog
p64077
aVThis could lead to the dialog showing behind your main window
p64078
aVSpecify the handle of your main window to be the dialog's owner
p64079
aVRead more about window ownership on the Window Features page on MSDN
p64080
as(dp64081
g7
V505088
p64082
stp64083
a((dp64084
g2
(lp64085
VThe behaviour you describe is what happens when the
p64086
aVbpl files cannot be found
p64087
aVif you run the
p64088
aVexe outside the IDE you will get an error message to that effect
p64089
aVFor some reason that error message does not show when running from within the IDE
p64090
aVNote that it's not enough even to use the Run Without Debugging option
p64091
aVYou have to start the executable outside the IDE, for example by double clicking on the
p64092
aVexe file in an explorer window
p64093
aVProbably the most effective way to debug this to work out which dependencies are failing is with Dependency Walker
p64094
aVLoad up your executable and debug its startup from the Profile menu
p64095
aVSolve the problem by making sure that the
p64096
aVbpl files can be found
p64097
aVMake sure they are on the DLL search path
p64098
aVThe best way to do that is to place them alongside the
p64099
aVexe file
p64100
as(dp64101
g7
V505088
p64102
stp64103
a((dp64104
g2
(lp64105
VActions represent, well, actions
p64106
aVThey are associated with UI elements that result in actions: buttons and menu items
p64107
aVOn the other hand a radio group is not used to invoke an action
p64108
aVA radio group is used to make a selection from a mutually exclusive set of options
p64109
aVThe individual items in a radio group cannot be assigned an action
p64110
aVRadio groups do often interact with actions however
p64111
aVBut they do so through the OnUpdate handlers of actions that are associated with other UI elements
p64112
aVFor example, consider a form with a button and menu item that are only visible when the radio group has ItemIndex equal to 0
p64113
aVThis would be coded with an OnUpdate handler for the action that looked like this:
p64114
aVAnd the action itself is associated with the button and the menu item, but not the radio group
p64115
aVIt's just that the action's events refer to the radio group's state
p64116
as(dp64117
g7
V505088
p64118
stp64119
a((dp64120
g2
(lp64121
VThe Chrome browser doesn't expose its DOM to external processes
p64122
aVYou need to be in process
p64123
aVSo in order to access the Chrome browser's DOM you need to be inside a Chrome extension
p64124
as(dp64125
g7
V505088
p64126
stp64127
a((dp64128
g2
(lp64129
VFiles don't work that way
p64130
aVYou can trim off the end, but not the beginning
p64131
aVIn order to mutate a file to remove content at the beginning you need to re-write the entire file
p64132
aVI expect you'll want to find some other way to solve your problem
p64133
aVBut a linear file is totally inappropriate for representing a FIFO queue
p64134
as(dp64135
g7
V505088
p64136
stp64137
a((dp64138
g2
(lp64139
VThe problem is that the DLL is not being found when the p/invoke runtime code calls
p64140
aVYou could resolve this by making sure that your DLL is on the DLL search path at the point where the first p/invoke call to it is made
p64141
aVFor example by calling
p64142
aVThe solution that I personally prefer is for your managed code to p/invoke a call to  passing the full absolute path to the native DLL
p64143
aVThat way when the subsequent p/invoke induced call to  is make, your native DLL is already in the process and so will be used
p64144
aVAnd then somewhere in your code:
p64145
aVJust make sure that you call  passing the full path to the native library, before you call any of the p/invokes to that native library
p64146
as(dp64147
g7
V505088
p64148
stp64149
a((dp64150
g2
(lp64151
VThis construct
p64152
aVis known as an open array constructor
p64153
aVFrom the documentation:
p64154
aVOpen array constructors allow you to construct arrays directly within function and procedure calls
p64155
aVThey can be passed only as open array parameters or variant open array parameters
p64156
aVSo, you cannot use an open array constructor to create a function return value
p64157
aVIf you have a fixed number of elements in the array that you need to return, you can use a dynamic array constructor:
p64158
aVHowever, this will not work for a variable number of elements
p64159
aVNow, I know that the example in your question only has a constant number of elements in the array
p64160
aVBut I'm sure you'll encounter situations where you need more flexibility than a dynamic array constructor can provide
p64161
aVIf you wish to create a copy of an existing dynamic array and return that, use
p64162
aVThis breaks down when you have an open array at hand
p64163
aVYou cannot pass an open array to
p64164
aVPersonally I think this is rather a shame since open array parameters are so exceptionally flexible and useful that I'd like to see as much RTL support for them as possible
p64165
aVSo, you end up having to write helper functions for those situations
p64166
aVYou can write a dedicated helper for each array type, but that becomes somewhat tiresome
p64167
aVThat's where generics come in handy
p64168
aVI have a helper class for the purpose
p64169
aVHere's the relevant extract:
p64170
aVNow, this works with your string arrays, but also with any other type
p64171
aVCall it like this:
p64172
aVA critical point to make is that we are using the generic version of the dynamic array,  rather than
p64173
aVIt's essential that you do that if you want to use generics seriously
p64174
aVThat's because  is not assignment compatible with  or indeed any other type declared as
p64175
aVIt pays dividends to change your code base to use  throughout
p64176
aVJust in case anyone is interested in the rest of this helper class, here it is:
p64177
as(dp64178
g7
V505088
p64179
stp64180
a((dp64181
g2
(lp64182
VFirst of all we need to define what abstract class means
p64183
aVThere appear to me to be two competing definitions:
p64184
aVAn abstract class is one that cannot be instantiated
p64185
aVThis is the most commonly used definition
p64186
aVAn abstract class is one that contains more than one abstract method
p64187
aVSince Delphi no language mechanism for enforcing definition 1, it would appear that definition 2 is the definition that applies to this question
p64188
aVAnd the answer to the question is that classes that contain abstract methods can be used with Visual Form Inheritance
p64189
aVModern versions of Delphi do allow you to decorate classes with the  keyword
p64190
aVHowever, this has no effect
p64191
aVYou can still instantiate such a class
p64192
aVIt is my understanding that the  keyword was added for the benefit of the Delphi
p64193
aVnet compiler
p64194
aVAgain, in modern versions of Delphi, you can configure the compiler to treat instantiation of classes with abstract methods as a compilation error
p64195
aVThat's probably the closest you can get in Delphi to definition 1
p64196
aVHowever, even that does not fully adhere to definition 1 since those classes can be instantiated through RTTI or virtual constructors
p64197
aVAnd the mechanism by which a designed component is instantiated is a perfect example
p64198
aVTake this class for example:
p64199
aVEven if you set the option for W2000 Constructing instance containing abstract method to Error, you can still let the framework instantiate the class
p64200
aVIt's only if you write  that the compiler objects
p64201
as(dp64202
g7
V505088
p64203
stp64204
a((dp64205
g2
(lp64206
VAt this point:
p64207
aVyou truncate a 64 bit pointer to 32 bit
p64208
aVHence the access violation
p64209
aVInstead you need
p64210
aVYour code is just as broken on Win7, but somehow you were unlucky and only ever ran this code with pointers with address < 4GB
p64211
aVYou should run some top-down memory allocation testing to flush out any other such errors
p64212
as(dp64213
g7
V505088
p64214
stp64215
a((dp64216
g2
(lp64217
VHere's a translation of your Delphi code:
p64218
aVThis is probably the lamest piece of Java ever written
p64219
aVTogether with the answer to your previous question, I have now written two Java programs
p64220
as(dp64221
g7
V505088
p64222
stp64223
a((dp64224
g2
(lp64225
VYou've got the parameters reversed
p64226
aVTo restore the original parent you need:
p64227
aVRemember that in both cases you are changing the parent of your window
p64228
aVSo the first parameter to  must the same both times
p64229
aVPart of the problem is that your variables are poorly named
p64230
aVI would name them like this:
p64231
as(dp64232
g7
V505088
p64233
stp64234
a((dp64235
g2
(lp64236
VThere is no size limitation on the code in the Soap
p64237
aVEncdDecd unit, beyond that imposed by the use of the  data type
p64238
aVThis program which successfully encodes and then decodes a 100MB string demonstrates the point:
p64239
aVYour problem almost certainly lies in your code rather than the  unit
p64240
aVYou code could be quite a bit simpler
p64241
aVFor example:
p64242
as(dp64243
g7
V505088
p64244
stp64245
a((dp64246
g2
(lp64247
VThe DLL is returning a null pointer
p64248
aVThese are represented as None in ctypes
p64249
aVI don't know why the function behaves that way but the output you see makes it quite clear that your function returns null
p64250
as(dp64251
g7
V505088
p64252
stp64253
a((dp64254
g2
(lp64255
VFirst of all you do need to make sure that your backslashes are suitably escaped, or use raw strings as per the first code sample
p64256
aVI'm going to assume that you've done that
p64257
aVThe most likely explanation is that you use 32 bit Python on a 64 bit system
p64258
aVAnd so are subject to the registry redirector serving up the 32 bit view of the registry
p64259
aVEither use 64 bit Python, or specifically open they key with a 64 bit view
p64260
aVDo the latter by specifying the KEY_WOW64_64KEY flag
p64261
as(dp64262
g7
V505088
p64263
stp64264
a((dp64265
g2
(lp64266
VThis behaviour is due to the registry redirector
p64267
aVYou are running the 32 bit version of , presumably because the process that invokes it is a 32 bit process
p64268
aVAnd so the 32 bit version of  reads the 32 bit view of the registry by default
p64269
aVYou should use /reg:64 switch to force reg to use the 64 bit view of the registry, as described here: MS-KB-948698
p64270
aVIf you are doing this from a program then it's better to use the registry API to read entries than using the  tool
p64271
as(dp64272
g7
V505088
p64273
stp64274
a((dp64275
g2
(lp64276
VThe lowest common denominator is that you can create menus in all versions
p64277
aVThey show up fine in the pre-ribbon versions of Office, but they appear on an special tab named Add-ins
p64278
aVThis tab only exists so that legacy code that uses old style command bars can still present UI in modern versions of Office that use the ribbon
p64279
aVSo, if you use command bar code to add menu items, those menus will indeed appear in all versions of Office
p64280
aVBut this truly is the lowest common denominator
p64281
aVThe user experience is poor on ribbon versions of Office
p64282
aVThe normal solution that add-in authors take is to arrange that the add-in switches behaviour according to the version of its host
p64283
aVSo, if the add-in detects that it is on Office 2003 or earlier, use command bars
p64284
aVOtherwise, add a ribbon interface
p64285
as(dp64286
g7
V505088
p64287
stp64288
a((dp64289
g2
(lp64290
VYou cannot use the same class for both in-process locks, and cross-process locks
p64291
aVThe implementations are quite different
p64292
aVYour current strategy is the correct one
p64293
as(dp64294
g7
V505088
p64295
stp64296
a((dp64297
g2
(lp64298
VThe problem is this line:
p64299
aVThat works on the 32 bit version because the alignment of the struct has no padding
p64300
aVBut on the 64 bit version, there are 4 bytes of padding before the pointer
p64301
aVSo  is 4 bytes short
p64302
aVThat's the problem
p64303
aVThe solution is to stop calculating the size yourself and use  which is designed for this very purpose
p64304
as(dp64305
g7
V505088
p64306
stp64307
a((dp64308
g2
(lp64309
VThe normal procedure is like this:
p64310
aVThe main program detects that an update is ready
p64311
aVThe main program silently downloads the update to a temporary location
p64312
aVThe download is performed in a background thread
p64313
aVWhen the download is complete and verified, the main program restarts
p64314
aVWhenever the program starts and notices that there is a new update waiting to be installed it terminates and runs a separate executable that performs the update
p64315
aVWhen the update is complete, the program is restarted again
p64316
aVThe main benefit of this is that the user is not compelled to wait for the download to occur
p64317
aVA process which may take time and may fail
p64318
aVThus giving the user as little downtime as possible
p64319
aVThere is a tricky scenario to handle
p64320
aVThat's when the program starts the updater and then shuts itself down
p64321
aVIf the main process doesn't close before the update opens the executable, then the updater can fail
p64322
aVThe most elegant way to handle this is for the main program to pass its PID to the updater
p64323
aVThe updater can then open a handle to that process and wait until it is signaled
p64324
aVAn alternative approach, quite similar, goes like this:
p64325
aVThe main program detects that an update is ready and fires off a separate executable to perform the update
p64326
aVOr, the main program periodically fires off the updater to check whether or not there is an update available
p64327
aVThe update process silently downloads the update to a temporary location
p64328
aVWhen the download is complete and verified, the updater signals the main process to terminate
p64329
aVOnce the main process has terminated (the updater waits for it to do so), the updater performs the update
p64330
aVWhen the update is complete, the main program is restarted
p64331
aVTo be honest, the second approach seems more attractive to me
p64332
aVIt has a much better separation of concerns
p64333
aVThe main program is concerned with its business
p64334
aVThe updater is concerned with its job
p64335
aVObviously there has to be interaction and cooperation between them, but this is kept to a bare minimum
p64336
as(dp64337
g7
V505088
p64338
stp64339
a((dp64340
g2
(lp64341
VThe only option that abides by the license is to install the redistributable package
p64342
aVEarlier versions of D3DX did support static linking, but for reasons of security MS changed the rules to ban static linking
p64343
aVThey wanted to be able to service these DLLs through WIndows Update and that's only possible if they are installed using the official redistributable package
p64344
aVOne possible option for you is to see if you can avoid linking to D3DX
p64345
aVIt may be that you use a small enough footprint of that library that you can bypass it
p64346
as(dp64347
g7
V505088
p64348
stp64349
a((dp64350
g2
(lp64351
VCompilers do not make any account for what makes sense
p64352
aVThey simply follow rules
p64353
aVIt's the designers of the languages that make the rules and they generally try to make those rules so that they make sense
p64354
aVOf course, what seems sensible to one person, appears bizarre to another
p64355
aVThere's really no way around that
p64356
as(dp64357
g7
V505088
p64358
stp64359
a((dp64360
g2
(lp64361
VPython 3
p64362
aV3 on Windows is built with VS2010, which doesn't match your VS2008
p64363
aVPrevious versions of Python did indeed use VS2008
p64364
aVYou'll need to get hold of VS2010
p64365
as(dp64366
g7
V505088
p64367
stp64368
a((dp64369
g2
(lp64370
VIt is impossible to avoid some form of reference, for example pointers
p64371
aVAs you are trying it to do it, there is an infinite recursion in the definition
p64372
aVAn  includes a  which includes and , and so on for ever more
p64373
aVSo, both classes would require infinite storage which is obviously nonsensical
p64374
aVIf you really have a model where  contains  and  contains  then these classes appear to be incapable of living without each other
p64375
aVIn which case perhaps you only really have one class and not two
p64376
as(dp64377
g7
V505088
p64378
stp64379
a((dp64380
g2
(lp64381
VI don't know whether or not this is the problem, but that's just not how you get hold of the path to the logged on user's desktop
p64382
aVThe path might well have that form, but in lots of situations it will not
p64383
aVFor example:
p64384
aVOlder versions of Windows, e
p64385
ag217
aVXP
p64386
aVSome future as yet unreleased version of Windows changes things
p64387
aVThe user moves their profile
p64388
aVThe machine uses a language other than English and Desktop is localized
p64389
aVThe correct way to do it is to use one of the functions that receives a  or a known folder ID
p64390
aVFor example by passing  to
p64391
aVThe same goes for the program files folder which is
p64392
aVOnce you get this sorted, you may still get
p64393
aVObviously since you are copying to the desktop of the logged on user, you should have rights to that folder
p64394
aVHas anything interfered with security settings on that folder
p64395
aVOpen the security settings dialog and look at the effective rights that you have in that folder
p64396
aVDoes the file already exist and has it got an ACL that prohibits you writing over the file
p64397
aVDoes it exist already and is read-only
p64398
as(dp64399
g7
V505088
p64400
stp64401
a((dp64402
g2
(lp64403
VYou cannot unlock the lock screen programmatically from user space
p64404
aVThat is by design
p64405
aVOK, let's clarify that
p64406
aVUsing documented APIs, you cannot do this
p64407
aVYou need to reverse engineer undocumented APIs as @Remko has done for his SasLibEx product
p64408
as(dp64409
g7
V505088
p64410
stp64411
a((dp64412
g2
(lp64413
VIn this line
p64414
aVyou are setting the position of the stream
p64415
aVThat's akin to setting the file pointer in file
p64416
aVThe value of  bears no relation to the resource number
p64417
aVThe documentation describes it like this:
p64418
aVIndicates the current offset into the stream for reading and writing
p64419
aVUse Position to obtain the current position of the stream
p64420
aVThis is the
p64421
aVnumber of bytes from the beginning of the streamed data
p64422
aVIn fact you should not set  at all
p64423
aVIt serves no purpose
p64424
aVYou code can be:
p64425
aVSo you need to call this function four times, each time passing the ID of the resource and the destination filename
p64426
as(dp64427
g7
V505088
p64428
stp64429
a((dp64430
g2
(lp64431
VCall  passing  or
p64432
as(dp64433
g7
V505088
p64434
stp64435
a((dp64436
g2
(lp64437
VYou cannot do this within a single process
p64438
aVThat's because a 32 bit process can only load 32 bit modules, and a 64 bit process can only load 64 bit modules
p64439
aVThe only way for your 64 bit code to call 32 bit code, and vice versa, is to use an out-of-proc solution
p64440
aVFor example an out-of-proc COM server
p64441
as(dp64442
g7
V505088
p64443
stp64444
a((dp64445
g2
(lp64446
VThe information can be found in the program documentation: TMemoryManagerState
p64447
aVAnd there's more information available in a number of topics index from Memory Management Index
p64448
aVIf you want to really understand how FastMM works, then you should download and read the source
p64449
aVFor example, that defines  like so:
p64450
aVAs you can see, the comments document the record's fields
p64451
as(dp64452
g7
V505088
p64453
stp64454
a((dp64455
g2
(lp64456
VI think you are trying to represent 5 minutes as 0
p64457
aV05
p64458
aVThe way to do that is to first of all obtain the minutes as an integer
p64459
aVAnd then simply convert to double
p64460
aVAnd you convert in the other direction like this:
p64461
aVHowever, I urge you not to go any further with this
p64462
aVYou cannot expect to perform arithmetic on a quantity like that
p64463
aVWhat is the result of 2
p64464
aV20-1
p64465
aV50
p64466
aVYou and I know it's 30 minutes, but the computer says 0
p64467
aV70 which is no use at all
p64468
aVStore the hours using a true fractional representation
p64469
aVSo 5 minutes is
p64470
aVOr store the total minutes in an integer
p64471
aVOr total seconds in an integer
p64472
aVOr a
p64473
aVThe key is that you can write your own helper routines to convert from a sane storage format to a value that is human readable
p64474
aVBut you must store the raw data in a representation that will admit arithmetic operations
p64475
as(dp64476
g7
V505088
p64477
stp64478
a((dp64479
g2
(lp64480
VThe problem is that you are asking the container to call  on your keys when items are removed
p64481
aVBut your keys are not classes and so that is an invalid request
p64482
aVThis is trapped at runtime rather than compile time because the ownership is not determined until runtime
p64483
aVYou only want  and should remove
p64484
aVFor what it is worth, if you are trying to maked an  equivalent to , then your approach is flawed
p64485
aVA string list is an ordered container, but a dictionary is not
p64486
aVYou won't be able to index by integer, iterate in order and so on
p64487
aVI also do not understand why you would want to force all consumers of this class to declare the objects to be of type
p64488
aVYou should leave that parameter free for the consumer to specify
p64489
aVThat's the beauty of generics
p64490
aVPerhaps you don't want an ordered container, in which case a dictionary is what you need
p64491
aVBut in that case you simply don't need to create a new class
p64492
aVYou can simply use  as is
p64493
aVIf you are dead set on creating a sub class then I'd do it like this:
p64494
aVThat will allow the consumer of the class to decide which type of objects they put in the dictionary, and maintain compile time type safety
p64495
aVSo, when you want a dictionary of list boxes your declare a variable like this:
p64496
as(dp64497
g7
V505088
p64498
stp64499
a((dp64500
g2
(lp64501
VYou have a multi threaded application
p64502
aVIn order for the memory manager to work, multi-threaded applications must set  to
p64503
aVThis will happen if you base your threads on
p64504
aVFrom the documentation:
p64505
aVIsMultiThread is set to True to indicate that the memory manager should support multiple threads
p64506
aVIsMultiThread is set to True by BeginThread and class factories
p64507
aVBecause you are calling the raw Windows API , and not using the RTL supported thread routines, nothing in the system sets  to
p64508
aVAnd so the memory manager assumes that there is only a single thread, and does not lock access to the memory manager's shared data structures
p64509
aVHence the problems you observed
p64510
aVIf you simply set  at startup, your code will work perfectly
p64511
aVOr switch to using a  based thread
p64512
aVNote that your issue has nothing at all to do with Indy
p64513
aVYou can see this failure simply by allocating heap memory in the thread
p64514
aVThis program dies every time on my system:
p64515
as(dp64516
g7
V505088
p64517
stp64518
a((dp64519
g2
(lp64520
VThis appears to be a very poorly documented function
p64521
aVThe documentation for  says:
p64522
aVWhen this function returns, contains a pointer to the array of icon handles
p64523
aVBut since the parameter has type , the caller must provide the array
p64524
aVThe documentation for  is also wrong
p64525
aVIt turns out that it also is an array
p64526
aVAll the marshalling can be done using default settings
p64527
aVSince there is no ANSI version of this API, give it the full name,  and set the  to Unicode
p64528
aVSo far as the documentation goes, there's no mention of  being called
p64529
aVTo call this you'll need to allocate the arrays like this:
p64530
aVFinally, I echo @Cody's comment
p64531
aVSince this API is clearly documented incorrectly, I'd try to use an alternative API that is documented properly and that you can rely on for the future
p64532
aVSince you seem to be struggling to get this all to work, here's a fun program that extracts and displays icons from
p64533
aVI've not attempted to do any error checking, not called  on the icons and so on
p64534
as(dp64535
g7
V505088
p64536
stp64537
a((dp64538
g2
(lp64539
VYou can surely use the  unit in your FMX app which is clearly targeting Windows, and the message constant is defined there
p64540
aVIf you don't want to use , just define the constant in your own code:
p64541
as(dp64542
g7
V505088
p64543
stp64544
a((dp64545
g2
(lp64546
VYou can use the import units that ship with Delphi
p64547
aVThey work perfectly well with Office 2013
p64548
aVObviously if you are using interfaces introduced in Office 2013 then they will be missing
p64549
aVBut there's no indication that is the case
p64550
aVThese import units are installed in
p64551
aVBecause the Office COM servers run out-of-proc, there are no issues with mixing 32 and 64 bit code
p64552
as(dp64553
g7
V505088
p64554
stp64555
a((dp64556
g2
(lp64557
VMy analysis of the madExcept trace is as follows:
p64558
aVThe code is failing on line 1589 of
p64559
aVThat line does this:
p64560
aVThe disassembled code indicates that  is
p64561
aVThe only place where  is assigned to a non-nil value is earlier in the routine on line 1573 in the call to
p64562
aVThe code that calls  does not check the return value of that call
p64563
aVSince  is  then it would seem that the call to  failed
p64564
aVAs to why it fails I could not say with the current information
p64565
aVHowever, it would seem to be a bug in the FMX code in the sense that the FMX code must check for errors and fails to do so
p64566
aVI suggest that you submit a QC report
p64567
as(dp64568
g7
V505088
p64569
stp64570
a((dp64571
g2
(lp64572
VThe reason this happens is that each row of your list refers to the same object, the list named
p64573
aVYou can see this by looking at the  of each row
p64574
aVYou will find that:
p64575
aVand so on
p64576
aVEach row is in fact the same object
p64577
aVYou need to create a separate list for each row:
p64578
aVAnd now you will see that:
p64579
aVand so on
p64580
aVAnd your attempts to modify individual elements will behave as you intend
p64581
aVBut really, if you want to work with matrices, then you should use numpy
p64582
as(dp64583
g7
V505088
p64584
stp64585
a((dp64586
g2
(lp64587
VYou are looking to synchronize access to a shared resource
p64588
aVThe way to do that is to use a synchronization object
p64589
aVWhich means to use a mutex
p64590
aVUsing a mutex means that you can do idle waiting rather than a busy loop
p64591
aVAnd you also don't need to concern yourself with the compiler optimising away the read of  in the  loop
p64592
aVAnd if you have multiple processes writing then you've got a data race that you cannot resolve without a mutex or equivalent
p64593
aVYour first option can never work in that scenario
p64594
aVIncidentally you would need to use  in the  loop test
p64595
aVThat's because  always evaluates true
p64596
as(dp64597
g7
V505088
p64598
stp64599
a((dp64600
g2
(lp64601
VIn what follows, I am assuming that the entire function call is encapsulated by
p64602
aVIn which case this is a function pointer that can be declared like this:
p64603
aVThe  block does not push parameters onto the stack
p64604
aVTherefore the parameter list is empty
p64605
aVAnd the  block does not extract a return value
p64606
aVSo the function has  return type
p64607
aVYou assign to the function pointer in just the same way:
p64608
aVAnd you call it like this:
p64609
as(dp64610
g7
V505088
p64611
stp64612
a((dp64613
g2
(lp64614
VWhat is the safest way solve my problem
p64615
aVPass an absolute path
p64616
aVYou are in charge of where the executable files are located
p64617
aVBuild that logic into your Python code, form the full absolute path, and use that
p64618
as(dp64619
g7
V505088
p64620
stp64621
a((dp64622
g2
(lp64623
VIterate across the controls of the tabsheet using its  and  properties
p64624
aVThis will iterate over all immediate children of the tabsheet
p64625
aVIf you need to iterate deeper into the children of the children and so on then you want a recursive solution
p64626
aVIf you want to search in each tabsheet then you need to iterate over them too
p64627
as(dp64628
g7
V505088
p64629
stp64630
a((dp64631
g2
(lp64632
VYou are setting the background color of a label
p64633
aVA control which is invariably transparent
p64634
aVSo nothing happens
p64635
aVSet  instead
p64636
aVAs for your function, a case statement is much cleaner:
p64637
aVIf you really did want to set the background color, then you must set the label's  property to
p64638
as(dp64639
g7
V505088
p64640
stp64641
a((dp64642
g2
(lp64643
VTo answer the question as asked, you can make the test function inline:
p64644
aVThe compiler will then write the code for Test into each calling function
p64645
aVWhilst you can do this, my advice is that you do not
p64646
aVIt's just a trick but I don't think it really helps you
p64647
aVIf you want to raise the exception at the return address, you can do this:
p64648
aVIf you want to go further up the stack, then you'll have to use something like
p64649
aVCombine the back trace with raise at and you can raise the exception at any point in the call stack, if really you think that's a good idea
p64650
aVI do not think it's a good idea, as I explain below
p64651
aVIf you use a good debugging tool, like madExcept, then the call stacks in the madExcept bug reports will tell you all you need to know when an error occurs
p64652
aVWith the extra clarification in the comments, it seems that what you really want to happen is for the exception to contain information from higher up the call stack
p64653
aVTo my mind it is a violation of encapsulation to ask the callee to report information about its caller
p64654
aVSo if you want to include information from the caller, let the caller catch the exception, add the information, and re-raise
p64655
as(dp64656
g7
V505088
p64657
stp64658
a((dp64659
g2
(lp64660
VStructure layout is implementation defined
p64661
aVAnd it turns out that the default layout used by GCC differs from the layout used by MSVC, for example
p64662
aVI'm guessing that you are used to the way MSVC lays out structs that contain bitfields
p64663
aVThere is, of course, a GCC attribute, , to allow you to change behaviour
p64664
aVThis is described in more detail in the documentation
p64665
aVSo, this struct has size 16:
p64666
aVIf you use the  option, the default, then the size is 12
p64667
aVFor a particular implementation, where will I get the documentation that describes how a specific compiler(e
p64668
aVg GCC) introduces padding in a structure
p64669
aVYou need to consult the documentation of each compiler
p64670
aVIn the case of GCC, the documentation says:
p64671
ag34876
aV9 Structures, unions, enumerations, and bit-fields
p64672
aVA member of a union object is accessed using a member of a different type (C90 6
p64673
ag23064
ag25125
aV3)
p64674
aVThe relevant bytes of the
p64675
aVrepresentation of the object are treated as an object of the type used
p64676
aVfor the access
p64677
aVSee Type-punning
p64678
aVThis may be a trap representation
p64679
aVWhether a \u201cplain\u201d int bit-field is treated as a signed int bit-field or as an unsigned int bit-field (C90 6
p64680
ag7303
aV2, C90 6
p64681
ag7303
ag25125
aV1, C99
p64682
ag42641
ag25124
aV2, C99 6
p64683
ag25124
ag25125
aV1)
p64684
aVBy default it is treated as signed int but this may be changed by the -funsigned-bitfields option
p64685
aVAllowable bit-field types other than _Bool, signed int, and unsigned int (C99 6
p64686
ag25124
ag25125
aV1)
p64687
aVNo other types are permitted in
p64688
aVstrictly conforming mode
p64689
aVWhether a bit-field can straddle a storage-unit boundary (C90 6
p64690
ag7303
ag25125
aV1, C99 6
p64691
ag25124
ag25125
aV1)
p64692
aVDetermined by ABI
p64693
aVThe order of allocation of bit-fields within a unit (C90 6
p64694
ag7303
ag25125
aV1, C99 6
p64695
ag25124
ag25125
aV1)
p64696
aVDetermined by ABI
p64697
aVThe alignment of non-bit-field members of structures (C90 6
p64698
ag7303
ag25125
aV1, C99 6
p64699
ag25124
ag25125
aV1)
p64700
aVDetermined by ABI
p64701
aVThe integer type compatible with each enumerated type (C90 6
p64702
ag7303
ag25125
aV2, C99 6
p64703
ag25124
ag25125
aV2)
p64704
aVNormally, the type is unsigned int if there are
p64705
aVno negative values in the enumeration, otherwise int
p64706
aVIf -fshort-enums
p64707
aVis specified, then if there are negative values it is the first of
p64708
aVsigned char, short and int that can represent all the values,
p64709
aVotherwise it is the first of unsigned char, unsigned short and
p64710
aVunsigned int that can represent all the values
p64711
aVOn some
p64712
aVtargets, -fshort-enums is the default; this is determined by the ABI
p64713
aVSo, by and large, you need to work out what the ABI for your platform is
p64714
aVThat's really the sane thing for any compiler to do
p64715
aVIf it doesn't layout structs according to the ABI, then it makes interop exceedingly tricky
p64716
aVWhat's a bit odd is that GCC's view as to what the ABI is on Windows differs from the MSVC implementation
p64717
aVI've got no insight as to why that is so
p64718
as(dp64719
g7
V505088
p64720
stp64721
a((dp64722
g2
(lp64723
VYou cannot make Win32 controls send notifications to the control rather than its parent
p64724
aVThat is simply how Win32 notification messages work
p64725
aVWhat frameworks like WinForms, VCL etc
p64726
aVdo is to arrange that parent controls reflect notification messages back to the child control
p64727
aVI guess that OWL does not do this notification message reflection
p64728
aVIf you are going to use a framework, it seldom makes sense to swim against the tide
p64729
aVI suggest that you would be better off following the framework standard approach
p64730
as(dp64731
g7
V505088
p64732
stp64733
a((dp64734
g2
(lp64735
VYou are saving  to  a file named:
p64736
aVSo the system treats this as a relative path and it seems that there is no directory named  contained in the working directory
p64737
aVClearly you meant to write:
p64738
as(dp64739
g7
V505088
p64740
stp64741
a((dp64742
g2
(lp64743
VYou did not initialize the  array
p64744
aVYou need to add a call to
p64745
aVAnd you can simplify the code by replacing the  loop with a call to
p64746
as(dp64747
g7
V505088
p64748
stp64749
a((dp64750
g2
(lp64751
VThe function  is passes a , a pointer to a null-terminated array of characters
p64752
aVYou cannot use it to work out the length of an array of strings
p64753
aVInstead I suggest you do it like this:
p64754
aVSo, the sentinel is the null pointer
p64755
aVThe loop like this:
p64756
aVAnd likewise for the other array, of course
p64757
aVNow, all that said, you are going about this the wrong way for a C++ program
p64758
aVInstead of using C string, pointers to character arrays, use
p64759
aVInstead of using raw arrays to hold your strings, use the standard container classes
p64760
aVIn your case you want
p64761
aVThe best advice I can give you is to forget the C way of doing things, and try to learn the idiomatic C++ way to write code
p64762
as(dp64763
g7
V505088
p64764
stp64765
a((dp64766
g2
(lp64767
VYou have a global variable
p64768
aVThere's just one instance of it per module instance
p64769
aVAnd there's one instance of your native DLL module per process
p64770
aVUsing a global variable is not the solution here
p64771
aVIf you want to have a different variable associated with each button click, you'll need to create a separate variable for each
p64772
aVIt would make much more sense for the variables to be owned by the C# code
p64773
aVYour C++ code would look like this:
p64774
aVThen in the C# you call it like this:
p64775
as(dp64776
g7
V505088
p64777
stp64778
a((dp64779
g2
(lp64780
VHans is quite correct that you cannot solve your problem by deriving a new class from
p64781
aVWhat you can do though is to use the raw  component in folder picker mode
p64782
aVYou'll also need to use  to add your check box
p64783
aVSince this is just COM it's actually very simple to use from
p64784
aVnet
p64785
as(dp64786
g7
V505088
p64787
stp64788
a((dp64789
g2
(lp64790
VFor  you need to set the protected property  to
p64791
aVFor  you can indeed remove the border in
p64792
aVLike so:
p64793
aVIt looks like this:
p64794
as(dp64795
g7
V505088
p64796
stp64797
a((dp64798
g2
(lp64799
VIf you need to allocate and zero fill an array, then calloc is the simplest way to do it
p64800
aVDon't let the zero initialize drive the choice between stack or heap allocation
p64801
aVMake that choice independently
p64802
aVDon't get hung up on performance of the allocation and initialization
p64803
aVYou are sorting
p64804
aVThe sorting will dominate
p64805
aVYou won't be able to reliably measure the allocation and zero initialization
p64806
aVAs always with performance, if you really want to know, measure
p64807
as(dp64808
g7
V505088
p64809
stp64810
a((dp64811
g2
(lp64812
VLike this:
p64813
as(dp64814
g7
V505088
p64815
stp64816
a((dp64817
g2
(lp64818
VYou appear to be lying about the length of your buffer
p64819
aVYou allocate len characters, but then say that the buffer is size len+1
p64820
aVYou'll need to allocate len+1 characters
p64821
aVSkype on Windows is a Delphi application, built with VCL controls
p64822
aVThe VCL uses a design that sometimes leads to window re-creation during the lifetime of a form
p64823
aVIn other words the window handle can change and you could be left with a stale handle
p64824
aVThat's another plausible failure mode
p64825
aVYet another possible failure mode is the fact that you are messing with the GUI from a non-GUI thread in a way that the application does not know about
p64826
aVIt's more than likely that adding a menu behind the VCL's back is enough to cause failure
p64827
aVYou should not use HWND_DESKTOP as a window owner, and you appear to leak that text buffer
p64828
aVI think your odds of succeeding on this path are low
p64829
aVVery low
p64830
aVI suggest that you use a supported automation interface
p64831
as(dp64832
g7
V505088
p64833
stp64834
a((dp64835
g2
(lp64836
VThis line
p64837
aVdoes not copy the string, it merely copies of an address
p64838
aVIt's a pointer assignment
p64839
aVSo every element in  points to the same block of memory, the character array
p64840
aVSo naturally the last value that was copied into  is what you see when you look in , for all indices
p64841
aVIf you want to copy the string you'll need to use
p64842
aVAnd you almost certainly are not allocating any memory for the  pointers in  so you'd need to do that as well
p64843
aVUse  and
p64844
aVHowever, since you tagged this as C++, I'd abandon using raw arrays, C strings etc
p64845
aV, and switch to C++ standard containers
p64846
aVIn this case you seem to want
p64847
aVDeclare the container like this:
p64848
aVAnd then add items like this:
p64849
aVAnd iterate over the container like this:
p64850
as(dp64851
g7
V505088
p64852
stp64853
a((dp64854
g2
(lp64855
VMixed mode C++/CLI DLLs must be linked against the dynamic runtime
p64856
aVThat means you must deploy the dynamic runtime to any machine on which you hope to run such a DLL
p64857
aVSince you are using VS2010, you don't need to deploy the runtime using the redistributable package, although that is the recommended way to do so
p64858
aVYou can instead deploy specific Visual C++ DLLs to the application local folder
p64859
as(dp64860
g7
V505088
p64861
stp64862
a((dp64863
g2
(lp64864
VComplex arithmetic is a C99 feature
p64865
aVAnd MSVC only supports something approximating C89
p64866
aVMS has publicly stated that it won't go beyond C89 for its C compiler
p64867
aVErgo, you need a different compiler
p64868
aVThe GNU compiler, for example, will do the job
p64869
aVOn Windows that usually means the mingw port
p64870
as(dp64871
g7
V505088
p64872
stp64873
a((dp64874
g2
(lp64875
VAm I correct in my assumption that, I can modify the managed structure in terms of the access specifier of each variable, and even the variable name, but I cannot alter the order of the variables
p64876
aVYes, that is correct
p64877
aVNeither the access specifier, nor the variable name has any impact on the way the struct is laid out
p64878
as(dp64879
g7
V505088
p64880
stp64881
a((dp64882
g2
(lp64883
VProbably the cleanest way to listen to window creation and destruction is using a CBT hook
p64884
aVListen for  and
p64885
aVThis MSDN article, Windows Hooks in the
p64886
aVNET Framework, covers the subject from a
p64887
aVnet perspective
p64888
as(dp64889
g7
V505088
p64890
stp64891
a((dp64892
g2
(lp64893
VPHP's  is an implementation of RFC 3986
p64894
aVMy websearch for that yields this Delphi unit which claims to implement RFC 3986
p64895
aVI tested it on your input:
p64896
aVThe output was:
p64897
aV_%25_%26_%2B_%3D_%20_%22_%27_a_b_c_d_e_f_g_h_
p64898
aVThe key to my successful websearch was found in the PHP documentation for  where is states:
p64899
aVURL-encode according to RFC 3986
p64900
as(dp64901
g7
V505088
p64902
stp64903
a((dp64904
g2
(lp64905
VOn my desktop version of Windows you can show that dialog by executing
p64906
aVI've no idea whether or not that will work on your embedded Windows
p64907
as(dp64908
g7
V505088
p64909
stp64910
a((dp64911
g2
(lp64912
VThe mistake is here:
p64913
aVYou meant:
p64914
aVFix that and your file mapping can be created
p64915
aVI agree with Hans that you should not be sharing the file handle
p64916
as(dp64917
g7
V505088
p64918
stp64919
a((dp64920
g2
(lp64921
V is an intrinsic function
p64922
aVThe official documentation of it is completely hopeless
p64923
aVIt says:
p64924
aVI can only guess as to why the documentation generator cannot cope with this function
p64925
aVBut the three identical overloads are clearly bogus
p64926
aVAnd it's not a function, rather it is a procedure
p64927
aVNo matter
p64928
aVBecause it is an intrinsic, you cannot assign it to a function pointer
p64929
aVThe solution is to wrap it up in a function of your own
p64930
aVYou can then assign that function to a variable or constant of procedural type
p64931
aVThe other variant of  takes a third parameter that specifies the code page, passed as a
p64932
aVYou can only call that function if the first argument to  is a
p64933
aVSo, intrinsics are really a law unto themselves
p64934
aVNote that the documentation does state that  should no longer be used
p64935
aVInstead you should use
p64936
aVThe documentation is no better there mind you
p64937
as(dp64938
g7
V505088
p64939
stp64940
a((dp64941
g2
(lp64942
VWhy do x64 projects use a default packing alignment of 16
p64943
aVOn x64 the floating point is performed in the SSE unit
p64944
aVYou state that the largest type has alignment 8
p64945
aVBut that is not correct
p64946
aVSome of the SSE intrinsic types, for example , have alignment of 16
p64947
as(dp64948
g7
V505088
p64949
stp64950
a((dp64951
g2
(lp64952
VThe problem can be found right at the top of your window procedure
p64953
aVYou are creating a bunch of GDI objects every time your  is called:
p64954
aVYou don't ever return these to the system and so eventually you exhaust available GDI resources
p64955
aVCreate those objects once only at application initialization time
p64956
aVThat call to  looks very suspicious to me
p64957
aVYou certainly do not need it
p64958
aVRemove it
p64959
aVAnother problem that you have is the code to retrieve the mouse position
p64960
aVYou never use  for that since the mouse may have moved since the message was posted
p64961
aVYou can get it from
p64962
aVLike this:
p64963
aVYou'll need to include the Windowsx header properly
p64964
aVIt's done like this:
p64965
aVNote the difference from your code in the question
p64966
as(dp64967
g7
V505088
p64968
stp64969
a((dp64970
g2
(lp64971
VNormally it is preferable to get the caller to allocate the buffer
p64972
aVThat way the caller is in a position to deallocate it also
p64973
aVHowever, in this case, only the callee knows how long the buffer needs to be
p64974
aVAnd so the onus passes to the callee to allocate the buffer
p64975
aVBut that places an extra constraint on the system
p64976
aVSince the callee is allocating the buffer, the caller cannot deallocate it unless they share the same allocator
p64977
aVThat can actually be arranged without too much trouble
p64978
aVYou can use a shared allocator
p64979
aVThere are a few
p64980
aVYour platform appears to be Windows, so for example you can use  and
p64981
aVBoth sides of the interface can call those functions
p64982
aVThe alternative is to keep allocation and deallocation together
p64983
aVThe caller must hold on to the pointer that the callee returns
p64984
aVWhen it has finished with the buffer, usually after copying it into a Python structure, it asks the library to deallocate the memory
p64985
as(dp64986
g7
V505088
p64987
stp64988
a((dp64989
g2
(lp64990
VThe only way that I can see for that error to occur is for  to be equal to
p64991
aVThis sort of problem is usually much easier to solve if you have the code running under the debugger
p64992
aVYou can simply inspect the value of the expression's arguments and then it becomes clear as to why the fault occurs
p64993
as(dp64994
g7
V505088
p64995
stp64996
a((dp64997
g2
(lp64998
VWhen you call
p64999
aVthis is implemented by
p65000
aVwhich in turn leads to a call to
p65001
aVwhich finally calls  passing  as
p65002
aVAnd the documentation for  says that  of  means:
p65003
aVPrevents other processes from opening a file or device if they request delete, read, or write access
p65004
aVIn other words,  is trying to open the file with exclusive share mode
p65005
aVAnd that will clearly fail since the file is already open
p65006
aVI think that  is using the wrong share mode
p65007
aVIt should allow read access
p65008
aVHowever, even if that was the case it would not help you since your other handle has write access
p65009
aVSolve the problem by avoiding
p65010
aVInstead open it like this:
p65011
aVYou have to pass
p65012
aVYou are in no position to deny any form of sharing since you already opened it for both reading and writing
p65013
aVThere is a further problem which I had failed to grasp when I originally wrote this answer
p65014
aVIt's true that  always tries to gain exclusive access
p65015
aVBut it's also true that your use of , the very first call you make, can also result in exclusive access
p65016
aVEven though you specified
p65017
aVThe code in  that creates files stream reads like this:
p65018
aVRight off the bat this is a disaster
p65019
aVIt's plain and simply wrong for file creation behaviour to be switched on file exists check
p65020
aVFile creation needs to be an atomic operation
p65021
aVWhat if the file is created after  returns, but before the call to  that is made inside
p65022
aVBut I guess the reason the code has been written like this is that there is no way to use  and have  passed to
p65023
aVAnd hence this horrid botch
p65024
aVAnd it turns out that if the  option is chosen, because  returns , then your sharing options are ignored
p65025
aVThat's because they are passed to the  parameter of  instead of being combined with
p65026
aVAs the documentation says, on Windows the  parameter is ignored
p65027
aVSo the correct code should be:
p65028
aVAnd what about the other branch of the if
p65029
aVSurely that's wrong too
p65030
aVSince the valued passed to  is ignored, then surely the value of  is ignored
p65031
aVWell, it turns out that the documentation lied
p65032
aVThe code in  reads:
p65033
aVLook at the  branch where  is passed to
p65034
aVThat doesn't look very much like  is being ignored
p65035
aVSo all that explains why the sharing mode is set correctly in your call to  if and only if the file already exists
p65036
aVSo, not only can you not use , but  is also out
p65037
aVQuit while you are ahead and give up on  altogether
p65038
aVI have no idea what happened with the QA at Embarcadero when  was introduced, but there was evidently a major failure
p65039
aVCombine that failure with the bizarre design flaws of  and you have a veritable bug factory
p65040
aVI submitted a QC report: QC#115020
p65041
aVQuite interestingly the erroneous behaviour in , where  is used when it should not, is new to XE3
p65042
aVI believe it was an attempt to deal with the bogus code in  which has already been reported as QC#107005, which is incorrectly marked as Fixed
p65043
aVSadly the attempt to fix  leaves  still broken, and in turn breaks  which used to work
p65044
as(dp65045
g7
V505088
p65046
stp65047
a((dp65048
g2
(lp65049
VYour C++ code uses the  calling convention but your p/invoke uses
p65050
aVChange or the other to match
p65051
aVFor example, you could change the p/invoke to use
p65052
aVThe other comments I would make are:
p65053
aVIt may be preferable to use  to suppress C++ name mangling
p65054
aVAlthough in the comments, Hans argues for mangling
p65055
aVYou've mapped  to
p65056
aVThat will work fine on 32 bit, but not on 64 bit, where  is 64 bits wide
p65057
aVI suggest that you use  here
p65058
aVAre you quite sure that the function calls SetLastError
p65059
aVIt's not a Windows function so I'd guess it does not
p65060
as(dp65061
g7
V505088
p65062
stp65063
a((dp65064
g2
(lp65065
VThat constructor does not necessarily leak
p65066
aVIt's plausible that the code actually works
p65067
aVHowever, it is inpenetrable and leads to calling code whose semantics are hard to discern from the outside
p65068
aVYou should refactor
p65069
aVThere's an easy way to refactor
p65070
aVThe key is that you break up the two modes of operation into separate functions:
p65071
aVA constructor named Create that acts like a normal Delphi constructor
p65072
aVYou appear already to have this
p65073
aVA procedure that copies the contents of one instance to another
p65074
aVThat could well be named Assign
p65075
aVSo, here's the plan of campaign:
p65076
aVChange Assign into a procedure rather than a constructor
p65077
aVDeal with the call to Create that can be found in the current Assign
p65078
aVYou need to remove that from Assign, but make sure that everything that it did still happens when Assign runs
p65079
aVNow all constructor mode calls to Assign fail to compile
p65080
aVSo we fix them
p65081
aVThe ones that passed nil, convert into constructor calls of Create
p65082
aVThe other ones need to call the Create constructor and then Assign
p65083
aVYou might want an overloaded Create that receives an existing instance and calls Assign
p65084
aVThat could be convenient
p65085
aVThat would leave you able to do all that you do today, but would avoid calling a constructor on an instance which is always a bad idea
p65086
as(dp65087
g7
V505088
p65088
stp65089
a((dp65090
g2
(lp65091
VYour p/invokes appear to have been lifted from here: http://blogs
p65092
aVmsdn
p65093
aVcom/b/fiddler/archive/2011/12/10/fiddler-windows-8-apps-enable-loopback-network-isolation-exemption
p65094
aVaspx
p65095
aVThat article says:
p65096
aVTheir
p65097
aVNET declarations (as of the BUILD conference) are as follows:
p65098
aVHowever, the API changed before release
p65099
aVThe released version of the API has an extra parameter and is located in a different DLL
p65100
aVThe documentation can be found on MSDN
p65101
aVYou'll need to modify your p/invoke to use this API
p65102
as(dp65103
g7
V505088
p65104
stp65105
a((dp65106
g2
(lp65107
VYour suspicion is correct and the issue lies with the call to
p65108
aVYou wrote:
p65109
aVThere is a  raised
p65110
aVBut it is in
p65111
aVThe traceback tells you that
p65112
aVAnd so  is never actually called because the exception is raised before it gets called
p65113
aVThe way to think about it is that  can only catch exceptions if it actually manages to be called
p65114
aVIf the act of preparing its arguments raises an exception, then  does not even run, and so cannot catch anything
p65115
aVIf you expect an exception in the call to  just change your assertion:
p65116
aVOr you could postpone the call to  with a lambda:
p65117
as(dp65118
g7
V505088
p65119
stp65120
a((dp65121
g2
(lp65122
VDCOM garbage collection does this automatically
p65123
aVAfter the three missed pings at 120 second intervals, the connection will be cleaned up
p65124
aVSo you have nothing to do
p65125
aVYou can sit back and let the system do the work
p65126
as(dp65127
g7
V505088
p65128
stp65129
a((dp65130
g2
(lp65131
VThe fundamental problem is that your variable capture is capturing a single variable which is then shared between all threads
p65132
aVSo each time a thread reads the shared variable, it gets whatever value happens to have been put in there most recently
p65133
aVAs well as that semantic error, there is a clear data races on the shared variable
p65134
aVThe simplest solution is to create one variable per thread
p65135
aVJust move the variable's declaration inside the loop
p65136
aVLike this:
p65137
aVNow each thread has its own private instance of the string variable
p65138
as(dp65139
g7
V505088
p65140
stp65141
a((dp65142
g2
(lp65143
VDoes the meaning of Self change in a class method as to refer the class rather than the object
p65144
aVIn a class method  refers to the class
p65145
aVThe documentation says:
p65146
aVIn the defining declaration of a class method, the identifier Self represents the class where the method is called (which can be a descendant of the class in which it is defined
p65147
aVIf the method is called in the class C, then Self is of the type class of C
p65148
aVThus you cannot use Self to access instance fields, instance properties, and normal (object) methods
p65149
aVYou can use Self to call constructors and other class methods, or to access class properties and class fields
p65150
aVA class method can be called through a class reference or an object reference
p65151
aVWhen it is called through an object reference, the class of the object becomes the value of Self
p65152
aVThe compiler won't object to you using  since it is a legal and supported thing to do
p65153
aVIt just complains when you try to use instance members, instance methods etc
p65154
aVhas this meaning in class methods for exactly the same reason it exists in instance methods
p65155
aVIt allows you to fully specify a symbol and thus avoid scoping ambiguity
p65156
aVWhat's more it allows you to access the actual class on which the method is called
p65157
aVThis may be a descendant of the class in which the method is defined
p65158
aVI wonder, however, whether it is possible to have a case where  is potentially dangerous in class methods
p65159
aVI don't see any particular danger inherent in this part of the language
p65160
aVIn fact the use of  reduces scope and so reduces the danger of inadvertently referring to a local variable rather than a class member
p65161
as(dp65162
g7
V505088
p65163
stp65164
a((dp65165
g2
(lp65166
VOK, I've fired up XE2 and can reproduce what you report
p65167
aVIt would seem that Embarcadero have blundered when building Indy for XE2
p65168
aVThere is a mismatch between the zlib version of the linked objects, and the zlib version that is passed to the zlib initialization functions
p65169
aVNothing you can do with what they shipped can work around that flaw
p65170
aVYour options, as I see it:
p65171
aVFix the version of Indy that was supplied with XE2
p65172
aVThis will involve modifying the Indy source files and fixing the version mismatch
p65173
aVAnd then linking the modified Indy units to your application
p65174
aVNot impossible, but possibly a little awkward
p65175
aVUse the latest version of Indy, obtained from the Indy project repo
p65176
aVYou'll then have the latest and greatest Indy
p65177
aVUse a different zlib library
p65178
aVFor example the zlib library that ships with Delphi is known to work
p65179
aVI know you had trouble with this when I suggested it in a comment, but I for one have used it without trouble
p65180
aVUse a different version of Delphi
p65181
aVNot a great option, but I'm including it for completeness
p65182
as(dp65183
g7
V505088
p65184
stp65185
a((dp65186
g2
(lp65187
VBecause of virtual memory protection on Windows, you cannot read from physical memory from user space
p65188
aVIn order to read from physical memory you need to be executing code in kernel space
p65189
as(dp65190
g7
V505088
p65191
stp65192
a((dp65193
g2
(lp65194
VThe code in your question as you would expect when built into a simple test project
p65195
aVSo, here are the two explanations that I can concoct:
p65196
aVYou are taking a copy of  in your executable
p65197
aVAnd so the changes to the value of  made in the DLL do not get reflected in the copy
p65198
aVYour DLL is, for some reason, not modifying the struct
p65199
as(dp65200
g7
V505088
p65201
stp65202
a((dp65203
g2
(lp65204
VFor a 125% font scaling, the DPI aware setting is not relevant
p65205
aVWhat happens is that the text will be 25% bigger, and the onus is then on you to scale up your UI to match
p65206
aVYour dialogs will typically need to be 25% larger to accommodate the larger text
p65207
aVNot only do you have to scale the sizes, you also need to scale the positions
p65208
aVIt's up to you to code all of that
p65209
aVOr use a UI framework that does it for you
p65210
aVFor font scaling larger than 125%, the DPI aware setting comes into play
p65211
aVWhat happens is:
p65212
aVIf your app is not marked DPI aware, Windows will scale your app using raster image resizing
p65213
aVThis will lead to your visual elements being pixellated
p65214
aVIf your app is marked DPI aware, Windows will render your app faithfully
p65215
aVAgain, the onus is on you to scale your UI to fit the text
p65216
aVThis MSDN article has all the gory details
p65217
aVBack to your specific question
p65218
aVYou said:
p65219
aVI would like to prevent this from happening, so that text isn't scaled up, and the app displays correctly
p65220
aVIn other words you are saying that you would like to ignore the user's font scaling setting and render at 100% DPI irrespective of their wishes
p65221
aVYou can do this by reducing the size of all your text by 25%
p65222
aVI really do not recommend that you do so
p65223
as(dp65224
g7
V505088
p65225
stp65226
a((dp65227
g2
(lp65228
VBefore we come to the delegates, I suspect that you are wrong to pack the struct
p65229
aVIt's very unusual to do so
p65230
aVOnly do that if you find the pack  in the C code
p65231
aVThe  field is not a function pointer
p65232
aVIt's just a void pointer
p65233
aVIn C# that is
p65234
aVThe  member is an array of 4 pointers
p65235
aVI'm not quite sure what they contain, but for sure you can marshal that like this:
p65236
aVThat leaves you with manual intervention to populate the array, or read its contents
p65237
aVIt's possible that could be done by the marshaller, but without knowing the semantics of the interop, I can't say how to do that
p65238
aVAs for , you should declare the delegate outside the struct
p65239
aVLike this:
p65240
aVHere I am assuming that the calling convention is  since there's nothing in the C code to say otherwise
p65241
aVPutting it all together you have:
p65242
as(dp65243
g7
V505088
p65244
stp65245
a((dp65246
g2
(lp65247
VYou can specify additional linker options in the configuration dialog
p65248
aVLook under the Linker | Command Line page
p65249
aVPerhaps the errant lib is specified there
p65250
aVIn any case you can see there the command line that is passed to the linker and determine whether or not your lib file is there
p65251
aVThe easiest way to work out where they are coming from is to open up the project file in a text editor and search for the errant lib file
p65252
aVIf the problem is in the project configuration, this tactic is guaranteed to succeed
p65253
aVIf you have removed everything from your project settings, and you are not passing the errant lib to the linker command line, then the other place where a lib file may be specified is in code
p65254
aVIn a  statement
p65255
aVIt would look like this:
p65256
as(dp65257
g7
V505088
p65258
stp65259
a((dp65260
g2
(lp65261
VDon't ever use  in the main thread
p65262
aVIt blocks your apps GUI thread which is a serious faux pas
p65263
aVInstead drop a timer on the form
p65264
aVAnd write a timer handler like this:
p65265
aVThe timer event handler is executed at regular intervals
p65266
aVEach time the timer ticks you update the position of the shape
p65267
aVYou will probably want to set the timer interval to be quite low so that the animation appears smooth
p65268
aVFor example, try 100ms
p65269
aVAnd you may also want to disable the timer when the shape reaches its target
p65270
as(dp65271
g7
V505088
p65272
stp65273
a((dp65274
g2
(lp65275
VYou can gain access with a cast:
p65276
aVAs a side note, I suggest you reconsider your design
p65277
aVThe path you are taking leads to confusion and bugs
p65278
as(dp65279
g7
V505088
p65280
stp65281
a((dp65282
g2
(lp65283
VIf you don't want to use network transport then probably the simplest way to do cross-session IPC is to use a named pipe
p65284
aVThe main thing to take care over is that you will need to supply security attributes when creating the named pipe
p65285
aVWithout doing so you won't succeed in cross-session communications
p65286
aVMy code to do so looks like this:
p65287
as(dp65288
g7
V505088
p65289
stp65290
a((dp65291
g2
(lp65292
VWhen you write:
p65293
aVyou should write
p65294
aVYou are asking the control to own itself
p65295
aVThat just cannot work
p65296
aVThat quite possibly leads to a non-terminated recursion if the constructor fails
p65297
aVThe other big problem is that you are creating a web browser control inside
p65298
aVThat's a very big no-no
p65299
aVYou'll want to stop doing that
p65300
aVMove that code into a separate exported function
p65301
aVDo nothing in
p65302
aVPresumably the caller has already initialized COM
p65303
aVIf not, you will need to ensure that the caller does so
p65304
aVIf the caller is a VCL forms app then COM will be initialized automatically
p65305
as(dp65306
g7
V505088
p65307
stp65308
a((dp65309
g2
(lp65310
VYes you do need to free the enumerator
p65311
aVWhoever calls  owns what it returns
p65312
aVWhen it is a  loop the compiler writes the code and ensures that the enumerator object is disposed of
p65313
aVWhen you call it, it is your job to dispose of the enumerator
p65314
aVThis is in fact a very easy question to answer for yourself
p65315
aVSimply create a program that calls  and fails to  it
p65316
aVUse the memory manager's facilities to check whether or not the object is leaked
p65317
aVAnd this results in the following leak report:
p65318
aVAn unexpected memory leak has occurred
p65319
aVThe unexpected small block leaks are:
p65320
aV13 - 20 bytes: TList
p65321
aVTEnumerator x 1
p65322
as(dp65323
g7
V505088
p65324
stp65325
a((dp65326
g2
(lp65327
VYou need to use  when you are allocating using the Delphi heap in one module, and deallocating them using the same heap in a different module
p65328
aVThe  unit ensures that memory allocations in both modules share the same allocator
p65329
aVNow, you can do that with a Delphi executable and a Delphi DLL, provided that both executable and DLL are compiled with the same version of Delphi
p65330
aVBut you cannot do that at all with a Delphi executable and a C DLL
p65331
aVYou cannot allocate memory in Delphi and expect your C DLL to be able to deallocate it
p65332
aVC runtimes will not map malloc/free to a call to shared memory manager
p65333
aVYour question makes it clear that you would like to allocate a Delphi string in Delphi and pass it to a C DLL
p65334
aVAnd then free it in that C DLL
p65335
aVWell you cannot reasonably expect to do that
p65336
aVA Delphi string has to be managed by the Delphi runtime
p65337
aVYou don't have that available in your C DLL
p65338
aVNow, it's certainly possible that you could devise a way to emulate the Delphi runtime in C sufficient so that you could interop with strings
p65339
aVBut I think that's a bad idea
p65340
aVInstead, what you should do is follow standard interop practice:
p65341
aVArrange that memory is deallocated in the same module that allocates it
p65342
aVOnly pass standard interop types between the two modules
p65343
aVThat is: integral types, floating point types, null-terminated string pointers
p65344
aVAnd compound types, records and arrays, that only contain standard interop types
p65345
aVUpdate
p65346
aVYou state in comments:
p65347
aVThe problem is I don't have soucecode of Delphi app
p65348
aVThat leaves you in something of a bind
p65349
aVYou cannot change the interface to the DLL
p65350
aVThe solution is to make a thin wrapper DLL written in Delphi 7
p65351
aVThat wrapper DLL should use  and can create strings that are destroyed by the host executable
p65352
aVThe wrapper DLL forwards to your new C DLL any requests from the host executable
p65353
aVThe interop between the Delphi 7 wrapper and the new C DLL follows the standard interop guidelines
p65354
aVThe wrapper DLL is what is known as an adapter
p65355
as(dp65356
g7
V505088
p65357
stp65358
a((dp65359
g2
(lp65360
VTo add a message to the queue of the thread associated with another window, you need to use the  Windows API function
p65361
aVNow, if you are doing this on a different thread from the GUI thread, then you cannot use  to obtain the window handle
p65362
aVThat's because doing so introduces a race with the GUI thread
p65363
aVAnd if the handle needs to be re-created, it will be created with affinity to your thread rather than the GUI thread
p65364
aVRemember the rules: only interact with VCL objects from the GUI thread
p65365
aVSo you typically do not use  with the handle of a VCL form because you cannot easily guarantee that the message will be delivered to the correct window
p65366
aVEven if you synchronize access to the window handle, the window can be re-created and your message will not arrive
p65367
aVThe simplest way to deliver messages asynchronously is to call
p65368
aVThis does not need a window handle to operate and so avoids all the issues with VCL object affinity to the GUI thread
p65369
aVThe procedure that you send when you call  executes on the GUI thread and so is safe to perform all VCL operations
p65370
aVIf you are on an older Delphi that pre-dates  then it is more complicated
p65371
aVYou should in that case use
p65372
aVBut you'll have to direct the message to a window not associated with a form
p65373
aVDirect it to a window created with
p65374
aVRemember that you must call  on the GUI thread
p65375
aVWindows created this way are immune from re-creation and are safe targets for
p65376
aVThe window procedure for that window can then forward the message on to your form
p65377
aVAnd that is safe because the window procedure executes in the thread associated with its window
p65378
aVIn this case that is the GUI thread
p65379
aVAs an aside, if you are calling  away from the GUI thread, then that is also wrong
p65380
aVExpect intermittent and hard to diagnose failures
p65381
as(dp65382
g7
V505088
p65383
stp65384
a((dp65385
g2
(lp65386
VYou are over thinking this
p65387
aVThe C# marshalling will create a thunk around your delegate
p65388
aVYou must not attempt to do so
p65389
aVOn the Delphi side write it like this:
p65390
aVSimply remove the
p65391
aVOn the C# side your delegate is:
p65392
aVThe method that you use for your delegate looks like this:
p65393
aVAnd then you call into the native code like this:
p65394
aVSo, let's put it all together
p65395
aVOn the Delphi side you can write:
p65396
aVAnd on the C# side:
p65397
as(dp65398
g7
V505088
p65399
stp65400
a((dp65401
g2
(lp65402
VThe process is as follows:
p65403
aVUse the FMX printing API
p65404
aVMake a screen shot of your form by calling the  method
p65405
aVPrint the screen shot with
p65406
aVSince  does not derive from , and  is a  method, you cannot call  on your form
p65407
aVYou'll need an overall container for your forms controls on which you can call
p65408
as(dp65409
g7
V505088
p65410
stp65411
a((dp65412
g2
(lp65413
VYour problem is not the
p65414
aVYour problem is that your code's arithmetic is incorrect due to the use on uninitialized values
p65415
aVYou are failing to initialised
p65416
aVMy guess is that you mean to initialize  after reading in
p65417
aVSo, move the assignment to  to a point in the code where  is properly defined
p65418
aVThe strange output you are getting is the result of printing a floating point NaN with  format
p65419
aVI would also suggest that you move the  test inside the
p65420
aVAs you have it presently, that part of the tax deduction code has leaked into the calling code
p65421
as(dp65422
g7
V505088
p65423
stp65424
a((dp65425
g2
(lp65426
VYou have two problems:
p65427
aVThe string that Delphi is sending to you is UTF-16 encoded
p65428
aVYou'd need to encode as ANSI and return , if you want to match up against
p65429
aVThe memory that the returned pointer refers to is liable to be deallocated when the function returns
p65430
aVYou get away with it in your function since you return a string literal which is held as a global constant that endures for the lifetime of the DLL
p65431
aVFor a string variable, you will encounter runtime errors when your caller tries to read memory that has been deallocated
p65432
aVTo confuse matters, those runtime errors will be intermittent
p65433
aVYour code may appear to work
p65434
aVExpect failures when you deploy to your most important customer
p65435
aVYour options to solve item 2:
p65436
aVArrange that the caller allocates the buffer, which can then be populated by the callee
p65437
aVAllocate and deallocate the string on a shared heap
p65438
aVFor example the COM heap with  and
p65439
aVUsing a shared heap allows you to allocate in one module, and deallocate in the other
p65440
aVAs a rule of thumb, always prefer option 1 if it can meet your needs
p65441
as(dp65442
g7
V505088
p65443
stp65444
a((dp65445
g2
(lp65446
VThe most common behaviour is to call
p65447
aVSo if I explicitly do not want the inherited behaviour, I do not call
p65448
aVOtherwise, I do
p65449
aVIf the inherited behaviour is a no-op like , I still call
p65450
aVNote also that the situtation for constructors and destructors is perhaps a little different than for other methods
p65451
aVIt's exceptionally rare that you would need to skip a call to the inherited method
p65452
aVI cannot think of an example
p65453
aVInvariably constructors are creating and destroying other objects, so how could you contemplate skipping that
p65454
aVI know that some authors write code that omits  when deriving directly from , because they know that the implementation in  does nothing
p65455
aVI do not like that and to me it is a mistake to do that
p65456
aVThe implementation details of  should not be leaking into derived classes
p65457
aVI'm pretty sure that  will always be no-ops
p65458
aVIf Embarcadero changed that then so much code would break
p65459
aVBut what about one of your classes
p65460
aVSuppose you have a class derived from
p65461
aVAnd then you have another class derived from that:
p65462
aVYou have no constructor for  and a constructor for  that looks like this:
p65463
aVThen one day you modify the  constructor to do something
p65464
aVNow  is broken
p65465
aVSo, I would never ever omit a call to  because that call does nothing
p65466
aVThe situation for normal instance methods is a little different
p65467
aVIt is more plausible that you want to ignore the base class implementation and provide a brand new implementation
p65468
aVBut take the decision based on what the derived class wants to do rather than whether or not the super class has an empty implementation for the method
p65469
as(dp65470
g7
V505088
p65471
stp65472
a((dp65473
g2
(lp65474
VThe calculation of  may well be your bottleneck, but a single evaluation of  is still going to consume a very small number of clock cycles
p65475
aVThe overhead of performing thread synchronisation will outweigh any possible gain from parallel execution
p65476
as(dp65477
g7
V505088
p65478
stp65479
a((dp65480
g2
(lp65481
VYour code fails because of this code:
p65482
aVYou cannot cast an RGB color to an  in any meaningful way
p65483
aVThe only way to obtain an  is a ask the system to give you one
p65484
aVSo, you need to create a real brush using one of the API functions for that purpose
p65485
aVFor example,
p65486
aVWhen you have finished with the brush, call  to return resources to the system
p65487
aVAs a general rule, every time you write a cast, regard the code as very suspicious
p65488
aVAlways endeavour to write code without casts
p65489
as(dp65490
g7
V505088
p65491
stp65492
a((dp65493
g2
(lp65494
VIf I understand your question correctly, you are asking how to convert a variant to an
p65495
aVDo that like this:
p65496
aVIn your case I think you have another type,  that derives from
p65497
aVYou can get hold of that like this:
p65498
as(dp65499
g7
V505088
p65500
stp65501
a((dp65502
g2
(lp65503
VThe most obvious flaw that I can see is that you set  to  when you call
p65504
aVYou must pass  and when you do so your code works as expected
p65505
aVThe output from  is faithfully read into
p65506
as(dp65507
g7
V505088
p65508
stp65509
a((dp65510
g2
(lp65511
VDelphi does not follow the platform standard ABI for return values
p65512
aVThe standard ABI passes return values to the caller by value
p65513
aVDelphi treats the return value as an implicit extra var parameter, passed after all other parameters
p65514
aVThe documentation describes the rules
p65515
aVYou can change your calling code to match that
p65516
aVPass an extra reference to struct parameter in your C++ function
p65517
aVIf you are going to do this on the C++ side, you would be best doing the same change on the Delphi side for clarity
p65518
aVSince Delphi does not follow the platform standards for return values I suggest you restrict yourself to types that are compatible with other tools
p65519
aVThat means integral values up to 32 bits, pointers and floating point values
p65520
aVAs a general rule of thumb, do not pack records
p65521
aVIf you do so you will have mis-alignment which affects performance
p65522
aVFor the record in the question, there will be no padding anyway since both fields are the same size
p65523
as(dp65524
g7
V505088
p65525
stp65526
a((dp65527
g2
(lp65528
VThe rights that executing code has are controlled by the process token which is a process wide object
p65529
aVSo, if your process has elevated rights, all code that executes in that process has elevated rights
p65530
aVThe conclusion is that, in order for different parts of your application to have different rights, you need to have multiple processes
p65531
aVIt is perfectly common and standard for applications to do this
p65532
aVAn application can start with separate rights
p65533
aVWhen the user wishes to perform an action that requires elevated rights, the program invokes a separate executable to perform that task
p65534
aVThis is indeed better for the user since they only need to face the UAC dialog for actions that actually need elevation
p65535
as(dp65536
g7
V505088
p65537
stp65538
a((dp65539
g2
(lp65540
VThe basic problem is that you have created a single pipe, and made the external process use both ends of the same pipe
p65541
aVThe pipe is used to connect two distinct processes
p65542
aVSo each process should only know about one end of it
p65543
aVSo imagine you want to app1 to send information to app2
p65544
aVCreate a pipe with a write end and a read end
p65545
aVA typical configuration looks like this
p65546
aVThis is what you would get if you wrote
p65547
aVat the command interpretor
p65548
aVBut you have attached the read end of your pipe to app1, stdin
p65549
aVSo in your case the diagram is like this
p65550
aVThat's a clear mistake in your program
p65551
aVWhen app1 writes to its stdout, whatever it writes appears in its own stdin
p65552
aVAbsolutely not what you intended
p65553
aVThe extra twist in the tale is that your app is also trying to read the read end of the pipe
p65554
aVSo both your app and the external process are reading that
p65555
aVNow, that's a race
p65556
aVWho's to say which one gets the content
p65557
aVPerhaps all you need is to remove the line that assigns  and leave it as 0 instead
p65558
aVOne final point
p65559
aVWriting  is very inefficient
p65560
aVThe entire contents of the memo will be both read, and written
p65561
as(dp65562
g7
V505088
p65563
stp65564
a((dp65565
g2
(lp65566
VYour analysis is accurate
p65567
aVYou are not using  or  or equivalents
p65568
aVSo you are not responsible for deallocating anything
p65569
as(dp65570
g7
V505088
p65571
stp65572
a((dp65573
g2
(lp65574
VThe usual form of function pointer definitions is
p65575
aVbut I saw a
p65576
aVform today which I didn't understand
p65577
aVThere is nothing special here, no magic syntax
p65578
aVThis is not a different form of function pointer declaration
p65579
aVThis is just the standard form of function pointer declaration, and  is a macro defined by one of the header files that you are using
p65580
aVSo, find that macro definition to learn what its purpose is
p65581
as(dp65582
g7
V505088
p65583
stp65584
a((dp65585
g2
(lp65586
VAutorun specified using that registry key works the same on Windows 8 as it did in earlier versions of Windows
p65587
aVFeel free to continue using that method
p65588
as(dp65589
g7
V505088
p65590
stp65591
a((dp65592
g2
(lp65593
VThe border is drawn because the MDI client window has the extended window style
p65594
aVThis style is described thus:
p65595
aVThe window has a border with a sunken edge
p65596
aVHowever, my first simple attempts to remove that style failed
p65597
aVFor example you can try this code:
p65598
aVThis code does indeed remove
p65599
aVBut you cannot see any visual change and if you inspect the window using a tool like Spy++ then you will see that the MDI client window retains
p65600
aVSo, what gives
p65601
aVIt turns out that the MDI client window's window procedure (implemented in the VCL code) is forcing the client edge to be shown
p65602
aVAnd this overrides any attempts that you make to remove the style
p65603
aVThe code in question looks like this:
p65604
aVSo, you simply need to override the handling of this  message
p65605
aVDo that like this:
p65606
aVThe end result looks like this:
p65607
aVNote that the code above does not call the default window procedure
p65608
aVI'm not sure whether or not that will cause other problems but it's very plausible that other MDI behaviour will be affected
p65609
aVSo, you may need to implement a more capable behaviour patch
p65610
aVHopefully this answer gives you the knowledge you need to make your application behave the way you desire
p65611
aVI was thinking a bit more about how to implement a comprehensive solution that ensured the default window procedure was called for the  message, whatever that message happens to be
p65612
aVIt's not trivial to achieve since the default window procedure is stored in a private field
p65613
aVWhich makes it rather hard to reach
p65614
aVI suppose you could use a class helper to crack the private members
p65615
aVBut I prefer a different approach
p65616
aVMy approach would be to leave the window procedure exactly as it is, and hook the calls that the VCL code makes to
p65617
aVWhenever the VCL tries to add the  for an MDI client window, the hooked code can block that style
p65618
aVThe implementation looks like this:
p65619
aVOr if you prefer the version that uses a private member class helper crack, that looks like this:
p65620
aVFinally, I thank you for the very interesting question
p65621
aVIt was certainly a lot of fun exploring this problem
p65622
as(dp65623
g7
V505088
p65624
stp65625
a((dp65626
g2
(lp65627
VI just needed a way to convert a file object to a ctypes FILE* so that I can pass it to GD
p65628
aVYou are out of luck
p65629
aVThat was possible in Python 2
p65630
aVx, but is not possible in Python 3
p65631
ag18839
aVThe documentation explains why not:
p65632
aVThese APIs are a minimal emulation of the Python 2 C API for built-in file objects, which used to rely on the buffered I/O (FILE*) support from the C standard library
p65633
aVIn Python 3, files and streams use the new io module, which defines several layers over the low-level unbuffered I/O of the operating system
p65634
aVIf you want a  you are going to have to make one yourself, using the C standard library directly
p65635
as(dp65636
g7
V505088
p65637
stp65638
a((dp65639
g2
(lp65640
VThe file dialog will not do this for you
p65641
aVThere is no setting that will make it recurse into sub-folders and return all files contained within
p65642
aVIf you want that functionality you must implement it yourself
p65643
as(dp65644
g7
V505088
p65645
stp65646
a((dp65647
g2
(lp65648
VIt's a lambda expression
p65649
aVThe VB equivalent to that C# lambda expression would be:
p65650
as(dp65651
g7
V505088
p65652
stp65653
a((dp65654
g2
(lp65655
VBut what does  actually mean to the compiler
p65656
aVDoes it mean pptr is of type
p65657
aVYes,  is of type
p65658
aVAnd  is pointer to pointer to int
p65659
aVSo  has type , and  has type
p65660
aVWhy can't I write:
p65661
aVWell,  has type
p65662
aVAnd so  has type  which is not assignment compatible with a variable of type
p65663
aVA pointer to int is a different type of thing to a pointer to pointer to int
p65664
as(dp65665
g7
V505088
p65666
stp65667
a((dp65668
g2
(lp65669
VDoes this depend on the compiler or is it a language feature
p65670
aVThe behaviour is specified by the language standard
p65671
aVThe current standard (C11 6
p65672
ag25124
aV9 Initialization / 21, which is at page 141) describes what happens when you supply fewer initializers than elements of an aggregate:
p65673
aVIf there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be
p65674
aVinitialized implicitly the same as objects that have static storage duration
p65675
aVSo, the elements that are not specified are initialized to
p65676
as(dp65677
g7
V505088
p65678
stp65679
a((dp65680
g2
(lp65681
VI'd say that an exception is very plausible
p65682
aVWhen you call  this will lead to the following sequence of events:
p65683
aVA call to
p65684
aVbeing set to
p65685
aVreturning
p65686
aVis called
p65687
aVExit procedures are run, specifically  which will tear down  and all components that it owns
p65688
aVHmm, better hope your thread does not access anything owned by
p65689
aVis called
p65690
aVUh-oh
p65691
aVMemory manager is shut down, and lots more beside
p65692
aVis called
p65693
aVNow your thread is killed
p65694
aVYour thread will carry on running until the call to
p65695
aVIf it executes any code at all that would be affected by the calls to  and , then you should expect problems
p65696
as(dp65697
g7
V505088
p65698
stp65699
a((dp65700
g2
(lp65701
VI could not reproduced the behaviour you report
p65702
aVWhen I compiled that code in a fully updated 64 bit XE3, the code produced the expected output
p65703
aVI conclude that either:
p65704
aVYou have not fully updated your XE3 installation
p65705
aVYour code is using a different  function that is contained in your code
p65706
aVThanks to @bummi for pointing out the QC report that proves that item 1 is the explanation
p65707
aVYour solution is (obviously) to apply the updates
p65708
as(dp65709
g7
V505088
p65710
stp65711
a((dp65712
g2
(lp65713
V expands to the complete list of arguments passed to the script
p65714
aVYou typically use it when you want to call some other program or script and pass the same arguments that were passed to your script
p65715
as(dp65716
g7
V505088
p65717
stp65718
a((dp65719
g2
(lp65720
VIf you really have two separate processes, then you need inter-process communication (IPC)
p65721
aVFor example, you could make process A into an out-of-proc COM server which is consumed by process B in the manner of Office automation
p65722
aVThat's one option of many, but they all require IPC
p65723
aVHowever, it sounds a little like you have an executable and a DLL in the same process
p65724
aVIn which case you have two separate instances of the VCL
p65725
aVWhich means that you cannot pass a  object, or indeed any other VCL object between the two modules
p65726
aVIn fact, you cannot pass any class between these two modules since you cannot share classes between modules
p65727
aVThe  in module A is a different  from that in module B
p65728
aVYour main options are:
p65729
aVUse a package instead of a DLL
p65730
aVUse interfaces for your interop since these can be safely passed between two modules
p65731
as(dp65732
g7
V505088
p65733
stp65734
a((dp65735
g2
(lp65736
VThe simple answer to the question is that the language does not support generic type aliases
p65737
aVThe only places where you can use generic parameters are:
p65738
aVGeneric class, interface, record and array types, or
p65739
aVGeneric procedural types, or
p65740
aVGeneric methods
p65741
as(dp65742
g7
V505088
p65743
stp65744
a((dp65745
g2
(lp65746
VThe second link that you include in the question is not applicable
p65747
aVThat is a question concerning sorting rather than efficient lookup
p65748
aVAlthough you discuss sorting a number of times in your question, you do not have a requirement to sort
p65749
aVYour requirement is simply a dictionary, also known as an associative array
p65750
aVOf course, you can implement that by sorting an array and using binary search for your lookup, but sorting is not a requirement
p65751
aVYou simply need an efficient dictionary
p65752
aVOut of the box, the most efficient and convenient data structure for your problem is
p65753
aVThis has lookup complexity of O(1) and so scales well for large collections
p65754
aVFor smaller collections a binary search based lookup with lookup complexity of O(log n) can be competitive and can indeed out-perform a dictionary
p65755
aVCosmin Prund wrote an excellent answer here on SO where he compared the performance of dictionary lookup against binary search based lookup
p65756
aVI recommend you have a read
p65757
aVI would say that for small containers, performance is probably not that big a problem for you
p65758
aVSo even though binary search may be quicker, it probably does not matter because your performance is good either way
p65759
aVBut performance probably becomes an issue for larger containers and that's where the dictionary is always stronger
p65760
aVFor large enough containers, the performance of binary search may become unacceptable
p65761
aVI'm sure that it is possible to produce more efficient implementations of dictionaries than the Embarcadero one, but I'd also say that the Embarcadero implementation is perfectly solid
p65762
aVIt uses a decent hash function and does not have any glaring weaknesses
p65763
aVIn terms of memory complexity, there's little to choose between a dictionary and a sorted array
p65764
aVIt's not possible to improve on a sorted array for memory use
p65765
aVI suggest that you start with  and only look beyond that if your performance requirements are not met
p65766
as(dp65767
g7
V505088
p65768
stp65769
a((dp65770
g2
(lp65771
VLike this:
p65772
aVOr more generally to concatenate multiple files:
p65773
aVCall it like this:
p65774
as(dp65775
g7
V505088
p65776
stp65777
a((dp65778
g2
(lp65779
VThe only way in which your code can produce a run time error is if you failed to instantiate an instance of
p65780
aVI suspect that the code that calls  looks like this:
p65781
aVThis will fail because  is not initialized
p65782
aVFix it like this:
p65783
aVAs a more general piece of advice I strongly recommend that you read about how to create a Short, Self Contained, Correct (Compilable), Example
p65784
as(dp65785
g7
V505088
p65786
stp65787
a((dp65788
g2
(lp65789
VThat's just an interaction with the Delphi debugger's handling of
p65790
aVBut your diagnostic does not reflect how  messages actually arrive in a real program
p65791
aVFor example, consider this variant of your program:
p65792
aVYou will notice that the form's caption only changes when you move the mouse
p65793
aVOr take your program, and use a different debug string monitor
p65794
aVFor example,  from SysInternals
p65795
aVWith that external debug string monitor you find that debug messages only arrive when the mouse really moves
p65796
aVI'm not sure what the Delphi debugger is doing that leads to the behaviour that you observe
p65797
aVHowever, be assured that  messages in your actual program will only arrive if the mouse really is moving
p65798
as(dp65799
g7
V505088
p65800
stp65801
a((dp65802
g2
(lp65803
VLooking at the declaration of  in the
p65804
aVnet implementation of , it is clear what to do
p65805
aVStop casting to  and write your code like this:
p65806
aVI had not appreciated this until now, but it seems that the Windows API calls you make from Delphi
p65807
aVnet use the same  attribute as other
p65808
aVnet languages
p65809
aVI guess that makes sense and these are just normal p/invoke calls as would be found in C# interop code
p65810
aVInterestingly, you report that attempts to pass  to one of these string parameters leads to a compiler error
p65811
aVThat means that there's no easy way to pass the null pointer to an API function that expects a C string
p65812
aVWhat you would have to do is to use an overloaded external declaration that received a  for the parameter which you want to pass  to
p65813
aVAs an aside, the Embarcadero developers made a mistake in their  declaration
p65814
aVThey set  which is incorrect for  which does not set the thread last error value
p65815
as(dp65816
g7
V505088
p65817
stp65818
a((dp65819
g2
(lp65820
VDevice context handles are not valid when passed cross-process
p65821
aVSo what you are attempting to do is not possible
p65822
aVAs for your other questions:
p65823
aVIs it possible to have an  that is not associated with an
p65824
aVYes that is perfectly possible
p65825
aVPlenty of device contexts are not associated with windows
p65826
aVHow I can get the  of the window which call DrawTextEx
p65827
aVWindows do not call functions, code calls functions
p65828
aVSo, the question does not really mean anything
p65829
as(dp65830
g7
V505088
p65831
stp65832
a((dp65833
g2
(lp65834
VYou need to force the linker to include the code
p65835
aVIt's not enough just to include the header file
p65836
aVTry adding this to your code:
p65837
aVI'm assuming that you don't need to add the  unit scope name since you did not do so in the code in the question
p65838
aVBut if you did need to do that the code would look like this:
p65839
aVJudging by your comments, and this Embarcadero forum thread, I suspect that you are using a version that requires unit scope names
p65840
aVYou probably have specified unit scope aliases that mean you can omit the unit scope name in the header file
p65841
aVBut it seems that you cannot omit the unit scope name in the  directive
p65842
as(dp65843
g7
V505088
p65844
stp65845
a((dp65846
g2
(lp65847
VYou cannot pass a string from native managed that way
p65848
aVYour code is wrong in 32 bit also, you just happen to get away with it
p65849
aVThe second version of the code is also wrong
p65850
aVIt only appears to work
p65851
aVYou need to either:
p65852
aVAllocate from a shared heap so that that the managed code can deallocate off that heap
p65853
aVThe shared heap for p/invoke is the COM heap
p65854
aVAllocate the memory on the managed side, and copy the contents into that buffer on the native side
p65855
aVOption 2 is always preferable
p65856
aVIt looks like this:
p65857
aVOn the native side you would have
p65858
aVThen call this like so:
p65859
aVIf you want to try option 1, it looks like this on the managed side:
p65860
aVand like this native:
p65861
aVWhen the managed code copies the contents of  to the string value, it then calls  on the pointer that you returned
p65862
aVAnd this is trivially easy to call:
p65863
as(dp65864
g7
V505088
p65865
stp65866
a((dp65867
g2
(lp65868
VIf you want to add quotes to your command, simply do so
p65869
aVPossibly the easiest way is to use single quotes for your string:
p65870
aVIf you want to write a double quote inside a string delimited by double quotes you need to escape it
p65871
aVThat would be done like this:
p65872
aVHowever, it's just a lot easier to use  instead and let it handle quoting for you
p65873
aVFor example:
p65874
aVEven the documentation for  recommends using :
p65875
aVThe subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function
p65876
aVSee the Replacing Older Functions with the subprocess Module section in the subprocess documentation for some helpful recipes
p65877
as(dp65878
g7
V505088
p65879
stp65880
a((dp65881
g2
(lp65882
VOverflow occurs when an expression yields a value that does not fit in the range of the data type in which the expression is evaluated
p65883
aVOverflow can occur for positive and negative numbers
p65884
aVYour particular expression will only result in overflow if the input values are already close to overflowing a floating point value
p65885
aVSo, if you are using double precision values for example, then your code can only overflow if the input data has magnitude of around 1e308
p65886
aVIt seems unlikely that your input data is really of that form
p65887
aVSo my guess is that your problem is related to how you read your input data
p65888
aVI suspect you are reading it incorrectly and so end up performing arithmetic on meaningless values
p65889
as(dp65890
g7
V505088
p65891
stp65892
a((dp65893
g2
(lp65894
V messages are delivered for each discreet scroll event
p65895
aVWhen the user stops scrolling, the messages stop arriving
p65896
aVThat's all there is to it
p65897
aVMouse wheel messages do not have any analogue to the mouse button down/up message pairs
p65898
aVThat's because wheel scrolling is a fundamentally different action from button pressing
p65899
as(dp65900
g7
V505088
p65901
stp65902
a((dp65903
g2
(lp65904
VIt seems that file dialogs do not inherit their layout from the parent window
p65905
aVI was a little surprised by this
p65906
aVI think you may need to force the issue by adding the  to the dialog window
p65907
aVThat's not totally easy to do since the file dialog interface does not provide you a window handle
p65908
aVYou can work around that by using a CBT hook
p65909
aVHere's an example which forces RTL for all dialogs (which have class name )
p65910
aVI've written the example in Delphi since that's what I am personally most familiar with
p65911
aVI'm sure you can translate it into your MFC environment
p65912
aVFirst of all install the hook:
p65913
aVAnd when you need to uninstall it:
p65914
aVAnd the hook procedure:
p65915
aVAnd this is what it looks like on my very left-to-right English OS:
p65916
as(dp65917
g7
V505088
p65918
stp65919
a((dp65920
g2
(lp65921
VYour group box wants to look something like this:
p65922
aVFor  descendents you should generally override the virtual constructor named
p65923
aVThat will allow your component to be instantiated by the streaming framework
p65924
aVThe implementation looks like this:
p65925
aVProbably the most important lesson is that you must set the  property of dynamically created controls
p65926
aVThis is needed to impose the parent/child relationship of the underlying windows
p65927
aVIn order to create one of these at runtime you code it like this:
p65928
aVThis code would run in the form's constructor, or an  event
p65929
aVI trust you get the basic idea now
p65930
as(dp65931
g7
V505088
p65932
stp65933
a((dp65934
g2
(lp65935
V will return the null pointer when it fails
p65936
aVSome obvious reasons why this could happen:
p65937
aVYou have exhausted heap memory
p65938
aVThat is plausible if  is very large
p65939
aVYou have corrupted the heap
p65940
aVThat could happen if there are errors in the code that you are running, but have removed for the purpose of asking this question
p65941
aVInspect the value of  to find out more information about the failure
p65942
as(dp65943
g7
V505088
p65944
stp65945
a((dp65946
g2
(lp65947
VYou can listen for  notification messages
p65948
aVThe MSDN documentation is a little sparse, but the sample code from the documentation of  makes it clear that a  message should be broadcast by any party that modifies the default printer
p65949
aVUnfortunately the  does not include any information that allows you to determine whether or not the default printer has been changed
p65950
aVYou've no way of knowing whether or not a particular  message indicates change of default printer or indicates change of some other setting
p65951
aVHowever, I would question your belief that you should be responding to this message
p65952
aVConsider the following scenario:
p65953
aVYou have a machine with two printers, A and B
p65954
aVPrinter A is the default printer
p65955
aVApplication starts
p65956
aVUser prints, but selects printer B
p65957
aVUser prints again
p65958
aVProgram remembers that last time round the user wanted printer B
p65959
aVBut this time user wants printer A and so changes to that printer
p65960
aVUser then changes default printer to printer B in control panel
p65961
aVUser goes to print again
p65962
aVWhich printer should be offered to the user
p65963
aVThe thing is the application has a history
p65964
aVThe last time the user printed they explicitly selected printer A
p65965
aVWhy should a change to the default printer mean that next time round the application should offer the new default printer rather than the last printer that the user chose to use
p65966
as(dp65967
g7
V505088
p65968
stp65969
a((dp65970
g2
(lp65971
VIf this code runs in the main thread, then you will need to service the message queue (i
p65972
ag192
aVcall ) if you want the user to interact with your program and abort
p65973
aVIn which case I think you already know the solution
p65974
aVCall
p65975
aVIf the user chooses to abort, set a boolean flag and check that flag regularly in the inner-most loop
p65976
aVOf course, this is all rather messy
p65977
aVThe fundamental problem is that you are performing long-running actions on the GUI thread
p65978
aVThat's something you should not do
p65979
aVMove the database processing code onto a different thread
p65980
aVIf the user chooses to abort, signal to the thread that it is to abort
p65981
aVFor example a call to the  method of the thread would be one way to do this
p65982
as(dp65983
g7
V505088
p65984
stp65985
a((dp65986
g2
(lp65987
VIt's a compiler bug, and it's present in all earlier versions of the compiler
p65988
aVThe fault is not limited to XE4
p65989
aVSubmitting a QC report is the correct response
p65990
aVI would not be surprised if Embarcadero never attempt to fix it
p65991
aVThat's because you are using deprecated
p65992
aVSwitch to using  and the code compiles
p65993
aVThe issue you have uncovered in this question is unrelated to the SO question you refer to at the top of your question
p65994
aVIncidentally, this really is a case of old meets new
p65995
aVLegacy Turbo Pascal objects, and modern day generic containers
p65996
aVYou are mixing oil and water
p65997
as(dp65998
g7
V505088
p65999
stp66000
a((dp66001
g2
(lp66002
VThat function was defined in  in XE3 but has been removed in XE4
p66003
aVThe replacement functionality appears to be
p66004
as(dp66005
g7
V505088
p66006
stp66007
a((dp66008
g2
(lp66009
VI think your p/invoke code is wrong
p66010
aVYou say that  and  are output parameters, and the other parameters are input
p66011
aVIn which case the p/invoke should be:
p66012
aVAssuming this is correct, the Delphi should look like this:
p66013
aVwhere ,  etc
p66014
aVare string variables that specify the input parameters
p66015
aVWe need to use one byte  and
p66016
aVYour code in the question uses the two byte UTF-16  and
p66017
aVYou would call it like this:
p66018
aVI don't know how large the  string needs to be made
p66019
aVIf you don't have any documentation, you can't find out
p66020
aVBetter make it large and hope for the best
p66021
aVIf you don't make it large enough, and the function attempts to write to that buffer, then you have buffer overrun
p66022
aVI've assumed that the  parameter has pure out semantics since that's what you said
p66023
aVIf you need to pass data in using some or all of the fields, change it to  and initialise the record accordingly
p66024
as(dp66025
g7
V505088
p66026
stp66027
a((dp66028
g2
(lp66029
VThe only explanation that makes any sense is that  is not running
p66030
aVIf it was executed then  would definitely run
p66031
aVAnd  would definitely be called
p66032
aVThere are no execution branches that avoid  being shown
p66033
aVThe only possible way for  not to be called in the event of  executing is for an exception to be raised
p66034
aVIn which case you would have noticed that
p66035
aVEither the event handler is not hooked up at all
p66036
aVOr it is hooked up to the form's  event but you are clicking on the panel rather than the form
p66037
as(dp66038
g7
V505088
p66039
stp66040
a((dp66041
g2
(lp66042
VThe folder where the executable resides is:
p66043
aVAnd so you want to save your file to:
p66044
as(dp66045
g7
V505088
p66046
stp66047
a((dp66048
g2
(lp66049
VAn extension is defined to be the characters that appear after the final dot in the filename
p66050
aVThe file extension is determined by simple text processing
p66051
aVYou start at the end of the filename and walk backwards until you find a dot
p66052
aVUsing your example, the file extension of  is
p66053
aVYou might think that the extension of your file is  but the system does not
p66054
aVAnd it's the system's rules that count
p66055
aVThus, a file extension cannot contain a dot
p66056
aVAnd so, whilst you could register a file extension with a dot, the system would never recognise any file as matching your extension
p66057
as(dp66058
g7
V505088
p66059
stp66060
a((dp66061
g2
(lp66062
VThe final parameter, the thing that you pass  to, needs to be a
p66063
aVThat is a function of this form:
p66064
aVThe compiler is telling you that  is not a function of that form
p66065
aVIn fact the compiler tells you that  is an  which is definitely not the right thing
p66066
aVTo get it up and running with a default do-nothing dialog procedure implement it like this:
p66067
aVThe documentation says this:
p66068
aVTypically, the dialog box procedure should return TRUE if it processed the message, and FALSE if it did not
p66069
aVIf the dialog box procedure returns FALSE, the dialog manager performs the default dialog operation in response to the message
p66070
aVSo by returning  we are asking for default processing
p66071
aVOnce you have the dialog up and running, you can then fill out the dialog procedure with any functionality that you need
p66072
as(dp66073
g7
V505088
p66074
stp66075
a((dp66076
g2
(lp66077
VThis is documented on the Mathworks site: http://www
p66078
aVmathworks
p66079
aVco
p66080
aVuk/support/solutions/en/data/1-IHYHFZ/index
p66081
aVhtml
p66082
as(dp66083
g7
V505088
p66084
stp66085
a((dp66086
g2
(lp66087
VYou will need to customise the top level exception handler
p66088
aVWrite an event handler and attach it to
p66089
aVYou can then handle particular exceptions any way you like
p66090
aVThe event handler will look like this:
p66091
aVObviously you have to write the code for
p66092
aVThis can show a message box using whatever icon you prefer
p66093
aVThe OnException event is called when an unhandled exception reaches the message loop
p66094
aVIf you don't have an event handler, the framework calls
p66095
aVWhich is what you should do for those exceptions that do not get your special treatment
p66096
as(dp66097
g7
V505088
p66098
stp66099
a((dp66100
g2
(lp66101
VFirstly your struct has the parameters in the wrong order
p66102
aVAnd the byte array needs to be declared as  with manual marshalling:
p66103
aVThe p/invoke should be:
p66104
aVThe byte array needs to be  so that the struct is blittable
p66105
aVAnd that's needed so that the array parameters can be declared as
p66106
aVIt's going to be a bit of a pain doing the marshalling of the byte arrays
p66107
aVYou'll want to use  to pin the managed byte arrays, and call  to get the address of the pinned array for each struct in your arrays of structs
p66108
aVIt will be worth your while writing some helper functions to make that task less painful
p66109
as(dp66110
g7
V505088
p66111
stp66112
a((dp66113
g2
(lp66114
VThe Win32 control only draws vertical separator lines if the toolbar uses the flat style
p66115
aVSo you can achieve the effect you want by including the  style when you create the toolbar window
p66116
as(dp66117
g7
V505088
p66118
stp66119
a((dp66120
g2
(lp66121
VWhat is happening here is that you call  and create an instance to an object
p66122
aVBut you then assign that instance to an interface reference, the global variable
p66123
aVBecause that variable is of type , the interface delegation means that the implementing object is the instance of  and not the instance of
p66124
aVHence nothing ever takes a reference to the instance of , its reference count is never increased, and so it is never destroyed
p66125
aVI don't think there's a very easy way around this
p66126
aVYou may be able to use  but it may not solve your problem
p66127
aVIt would force you to declare  to be of type  which I imagine you do not want to do
p66128
aVAnyhow, here's what it looks like re-cast that way:
p66129
aVThe documentation does talk about this:
p66130
aVThe class you use to implement the delegated interface should derive from TAggregationObject
p66131
aVInitially I could not find any documentation for this
p66132
aVAnd finally I realised that it's actually named  and is documented
p66133
aVTAggregatedObject provides the functionality for an inner object of an
p66134
aVaggregate by implementing the IInterface methods to delegate to the
p66135
aVcontrolling IInterface
p66136
aVAn aggregated object is an object composed of several interfaced
p66137
aVobjects
p66138
aVEach object implements its own behavior and interfaces, but
p66139
aVall the objects share the same reference count, which is that of the
p66140
aVcontroller object
p66141
aVIn the container pattern, the controller is the
p66142
aVcontainer object
p66143
aVTAggregatedObject does not itself support any interfaces
p66144
aVHowever, as
p66145
aVis typical of an aggregate, it does implement the methods of
p66146
aVIInterface, which are used by the objects that descend from it
p66147
aVTAggregatedObject, therefore, serves as a base for classes that
p66148
aVimplement interfaces for creating objects that are part of an
p66149
aVaggregate
p66150
aVTAggregatedObject is used as a base for classes that create contained
p66151
aVobjects and connecting objects
p66152
aVUsing TAggregatedObject ensures that
p66153
aVcalls to the IInterface methods delegate to the controlling IInterface
p66154
aVof the aggregate
p66155
aVThe controlling IInterface is specified in the constructor for
p66156
aVTAggregatedObject and is indicated by the Controller property
p66157
aVIn addition there is this from the source code comments:
p66158
aVTAggregatedObject and TContainedObject are suitable base   classes
p66159
aVfor interfaced objects intended to be aggregated   or contained in an
p66160
aVouter controlling object
p66161
aVWhen using   the "implements" syntax on an
p66162
aVinterface property in   an outer object class declaration, use these
p66163
aVtypes   to implement the inner object
p66164
aVInterfaces implemented by aggregated objects on behalf of   the
p66165
aVcontroller should not be distinguishable from other   interfaces
p66166
aVprovided by the controller
p66167
aVAggregated objects   must not maintain
p66168
aVtheir own reference count - they must   have the same lifetime as
p66169
aVtheir controller
p66170
aVTo achieve this,   aggregated objects reflect the
p66171
aVreference count methods   to the controller
p66172
aVTAggregatedObject simply reflects QueryInterface calls to   its
p66173
aVcontroller
p66174
aVFrom such an aggregated object, one can   obtain any
p66175
aVinterface that the controller supports, and   only interfaces that the
p66176
aVcontroller supports
p66177
aVThis is   useful for implementing a controller
p66178
aVclass that uses one   or more internal objects to implement the
p66179
aVinterfaces declared   on the controller class
p66180
aVAggregation promotes
p66181
aVimplementation   sharing across the object hierarchy
p66182
aVTAggregatedObject is what most aggregate objects should   inherit
p66183
aVfrom, especially when used in conjunction with   the "implements"
p66184
aVsyntax
p66185
as(dp66186
g7
V505088
p66187
stp66188
a((dp66189
g2
(lp66190
VAccording to Marco Cant's whitepaper, the  data type in the XE4 iOS target is not in fact immutable, although he seems to contradict himself
p66191
aVHe says:
p66192
aVIn the new Delphi LLVM-based compiler, there is one string type, representing Unicode strings (UTF16), and mapped to the current string type in Delphi XE3 (an alias for the UnicodeString type on the Windows compiler)
p66193
aVHowever, this new string type uses a different memory management model
p66194
aVThe string type is still reference counted, but it is immutable, which means you cannot modify the string contents once it is constructed
p66195
aVBut he then goes on to say:
p66196
aVIn other words strings are now Unicode-based, soon-to-become immutable, and reference-counted
p66197
aVAnd also:
p66198
aVWhere things start to change, however, is when you modify an existing
p66199
aVstring, not by replacing it with a new value (in which case you get a
p66200
aVbrand new string) but when you modify one of its elements, as shown in
p66201
aVthis line of code (and also in the previous section, where I
p66202
aVintroduced the topic):
p66203
aVAll Delphi compilers use a copy-on-write semantics: If the string you
p66204
aVmodify has more than one reference, it is first copied (adjusting the
p66205
aVreference counts of the various strings involved as required) and
p66206
aVlater modified
p66207
aVThe new compiler does something very similar to the classic one
p66208
aVIt
p66209
aVimplements a copy-on-write mechanism, unless there is a single
p66210
aVreference to the string, in which case the string gets modified in
p66211
aVplace
p66212
aVAs an example, consider the following code, which outputs the
p66213
aVin-memory location of the actual string
p66214
aVAnd he then shows a picture of an iOS device with mutating strings
p66215
aVAnd in the official documentation we have:
p66216
aVStrings are immutable (constant), so you cannot index into a string as
p66217
aVan array and manipulate the characters in a string
p66218
aVIf you attempt to
p66219
aVmodify a string, the Delphi mobile compilers might emit the message
p66220
aVW1068 Modifying strings in place may not be supported in the future
p66221
aV(Delphi)
p66222
aVYou can specify whether the message x1068 is emitted as a
p66223
aVwarning or an error
p66224
aVIn the Hints and Warnings page, set the warning
p66225
aV"Modifying strings in-place
p66226
aVto "true" or "error"
p66227
aVSo I interpret all that as meaning that the XE4 release of the iOS compiler still has mutable strings
p66228
aVThe developers really don't want you to mutate your strings any more and are telling you that strings are immutable on the mobile compilers
p66229
aVBut they do appear still to be mutable
p66230
aVGo figure
p66231
aVHowever, you have been served notice that in a future release, the string may become immutable
p66232
aVYou can prepare for that future release now by setting
p66233
aVwhich will give you an idea of the impact of the change
p66234
aVIf you want to buckle up and stop mutating strings, you can do this:
p66235
aVOnce you do that you'll need to convert code that accesses individual string elements
p66236
aVI suspect you'll be surprised by how little such code there is
p66237
aVI just compiled 600,000 lines of code and saw only 120 instances of the warning
p66238
aVAnd most of those were in third party units
p66239
aVI've seen quite a stir about this change, but I honestly don't believe that very much code mutates strings
p66240
aVIn the overwhelming majority of cases strings are built up by concatenation, or by calls to functions like
p66241
aVThat code is not affected by this
p66242
aVI don't think there are any great pitfalls
p66243
aVYou can use  to let the compiler guide you through the process
p66244
aVAny code that mutates strings should be converted to use
p66245
aVAs for the benefits of immutability, I refer you to Why
p66246
aVNET String is immutable
p66247
aVIf you are using the traditional Windows or OSX compilers then I see no compelling reason to change
p66248
aVThe iOS compiler is brand new
p66249
aVThe change to immutable strings has been floated, but it may never happen
p66250
aVIt may happen only on the mobile compilers and never on the traditional compilers
p66251
aVRight now, I would sit tight, and wait to see how it all plays out
p66252
as(dp66253
g7
V505088
p66254
stp66255
a((dp66256
g2
(lp66257
VThat's a basic fact of life for panels
p66258
aVIt's not special to the , you will see the same effect for any control derived from
p66259
aVThe transparency is only supported when the application is themed
p66260
aVThe grid panel is just a convenient way to layout your controls
p66261
aVIf you want to support running unthemed then the simplest solution is to remove the  and layout your controls manually
p66262
aVThat's pretty much trivial to do
p66263
aVHandle the  event of the control that currently contains the panel, and position your controls as desired
p66264
as(dp66265
g7
V505088
p66266
stp66267
a((dp66268
g2
(lp66269
VYou'd have to go through all the different users under , which requires elevated rights
p66270
aVAnd doesn't capture any users that have not yet been created
p66271
aVThat's just the wrong approach
p66272
aVThe way to do it is to add the default values to a corresponding key under  at install time
p66273
aVWhen your program attempts to read from the registry, it looks in  first, and if your key is not present, it copies the information from the corresponding key in  to the key in
p66274
aVA general rule of installer programs is that they should not rely on being run by the user that will subsequently use the program that has been installed
p66275
aVCertainly in corporate settings programs are usually installed under a user account that will never subsequently run the program being installed
p66276
as(dp66277
g7
V505088
p66278
stp66279
a((dp66280
g2
(lp66281
VHere's my guess:
p66282
aVYour ancient compiler pre-dates the introduction of the  format string
p66283
aVSo the runtime realises that it has encountered a format string that it does not recognise and gives up attempting to format
p66284
aVIn any case, you cannot pass a string to  and expect anything meaningful
p66285
aVSo, even if your compiler understood '%a', the behaviour would be undefined
p66286
aVThere's little to be gained from attempting to understand UB
p66287
aVFix your code
p66288
aVshould output
p66289
aVeven on your ancient compiler
p66290
aVIf it does not, that's a bug in the runtime for the compiler
p66291
aVI personally am prepared to bet that your compiler will produce that output for that program
p66292
aVI rather imagine that your question has been transcribed incorrectly
p66293
aVEither the output in the question does not match the code, or vice versa
p66294
aVAnd that's confirmed by your pastebin:
p66295
aVSo, not only is it a little pointless discussing UB, it's even more pointless discussing a program when the version you are running differs from the code in the question
p66296
aVIn future I urge you to use copy/paste to transfer code into a Stack Overflow question, and double and triple check that the output is what you claim it to be
p66297
aVBottom line: It's 2013 now
p66298
aVThere's no reason to be using BCC v5
p66299
aV02
p66300
aVIt's time to step forward in time
p66301
as(dp66302
g7
V505088
p66303
stp66304
a((dp66305
g2
(lp66306
VThe documentation says:
p66307
aVMB_SERVICE_NOTIFICATION
p66308
aVThe caller is a service notifying the user of an event
p66309
aVThe
p66310
aVfunction displays a message box on the current active
p66311
aVdesktop, even if there is no user logged on to the
p66312
aVcomputer
p66313
aVThis was possible in XP, but in Vista and later, services are isolated in session 0 and cannot interact with user sessions
p66314
aVThere is the option of using WTSSendMessage() to show simple popup messages on the active interactive desktop
p66315
aVThis is rather limited however
p66316
aVA more comprehensive option is to run a desktop application whenever a user logs on
p66317
aVThis can remain hidden most of the time
p66318
aVThis desktop app can use IPC to communicate with the service, for example with named pipes
p66319
aVFinally, the service can use that IPC channel to send messages to the desktop application which can then display UI to the user
p66320
as(dp66321
g7
V505088
p66322
stp66323
a((dp66324
g2
(lp66325
VOnce a property has been published, it cannot be un-published
p66326
aVAnd the Delphi form designer needs to publish the components it operates on
p66327
aVSo your designed forms will be full of published components
p66328
aVSince you cannot hide the components what is left is to hide the form
p66329
aVSince you talk about the form sometimes not being assigned, I suspect you are using global variables to refer to your forms
p66330
aVThat's probably your main problem
p66331
aVIf you have visible global variables of form type, then any part of your program can poke at any other part, with no restraint
p66332
aVSo the first thing to do is to remove those global variables
p66333
aVIt's perfectly possible to write an application without a single global variable of form type
p66334
aVThen you can control how the parts of your application interact with each other
p66335
aVOther parts of the question hint that your forms own data
p66336
aVThat's a design choice that is rather fragile
p66337
aVHold the data in non-visual model objects that are designed just for that purpose
p66338
aVAnd let the forms merely present views of that data
p66339
aVThen when one part of the system needs to ask for data, it can ask the non-visual model objects rather than the visual forms
p66340
as(dp66341
g7
V505088
p66342
stp66343
a((dp66344
g2
(lp66345
VWhat causes this
p66346
aVWhy does a program, coded exactly the same way, crash on a memory free in its 64-bit version on a 64-bit machine, and not the 32-bit version on a 32-bit machine
p66347
aVBecause your code is incorrect
p66348
aVBy chance it works on 32 bit, but compiling for 64 bit, with different pointer size, exposes the faults in your code
p66349
aVIs there any difference in win 32 bit server and win 64 bit server
p66350
aVPlease help me to get difference of memory structure in both type of windows OS
p66351
aVThe principal difference is  that pointers are 32 bits wide on 32 bit, and 64 bits wide on 64 bit
p66352
aVThere are obviously many other differences, but from your perspective it's pointer size that matters
p66353
aVFar and away the most common bug uncovered by a port from 32 to 64 bit is pointer truncation
p66354
aVSay you have code that casts pointers to ints
p66355
aVThat happens to work at runtime when compiled for 32 bit, but on 64 bit you lose half of the pointer
p66356
aVWhen you later cast back to a pointer
p66357
aVyou don't get the same pointer that you started with
p66358
aVFundamentally the problem is that the code made the assumption that an , which is 4 bytes wide on Windows, is the same size as a pointer
p66359
aVThat assumption holds for 32 bit, but not for 64 bit
p66360
aVYou'll likely be suffering from this problem and very likely other more subtle problems
p66361
aVIn order to solve the problem you will need to debug the process in detail
p66362
aVI think you are looking for some simple switch that will make your program work
p66363
aVThere is no magic solution because the problem lies in your code
p66364
aVAnd so it will need to be carefully debugged
p66365
as(dp66366
g7
V505088
p66367
stp66368
a((dp66369
g2
(lp66370
VI'm going to assume that your C# process is 64 bit
p66371
aVIf it's a 32 bit process, then you cannot load a 64 bit DLL, and that's the reason for the failure
p66372
aVIf you copied the file into  then a 64 bit process will look there
p66373
aVIf the file you copied is named , then your program will find it
p66374
aVSo, if you see
p66375
aVUnable to load DLL 'sampleDll
p66376
aVdll': The specified module could not be found
p66377
aVthe problem is not that  cannot be located, rather that its dependencies cannot be resolved
p66378
aVThe most common explanation for this is that you need to install the C runtime that  depends upon
p66379
aVConsult the documentation for this DLL to find out what its dependencies are
p66380
aVIf it's a DLL that you have made yourself, then you know what you used when you built it and can discern the dependencies for yourself
p66381
aVFinally, I would stress that you should not be copying files into the  directory
p66382
aVThat belongs to the system and you should not touch it
p66383
aVThe best place for a DLL to reside is in the same directory as the executable that loads it
p66384
as(dp66385
g7
V505088
p66386
stp66387
a((dp66388
g2
(lp66389
VThere is nothing in Windows batch that will allow you to build a GUI
p66390
as(dp66391
g7
V505088
p66392
stp66393
a((dp66394
g2
(lp66395
VNo, Windows 3
p66396
aV11 dates from the early 1990s and as such pre-dates
p66397
aVnet by a loooong time
p66398
aVYou cannot run any version of
p66399
aVnet on Windows 3
p66400
aV11, never mind bleeding edge
p66401
aVnet 4
p66402
ag7303
as(dp66403
g7
V505088
p66404
stp66405
a((dp66406
g2
(lp66407
VYou have a number of options for creating a process that runs under a different user from the parent process:
p66408
aVor
p66409
aVThese require you to obtain a primary token that represents a user, calling either  or
p66410
aVwhich allows you to specify the user name and password as parameters
p66411
aVHowever, if you want the process that you create to appear on the interactive desktop, you need to do quite a bit of work
p66412
aVThis article covers the details: Launching an interactive process from Windows Service in Windows Vista and later
p66413
as(dp66414
g7
V505088
p66415
stp66416
a((dp66417
g2
(lp66418
VAdd a call to  to the MATLAB code that you execute
p66419
aVYour quoting looks a little wonky mind you, but you just need to add  to the end of the command that you pass in the  argument
p66420
aVBy the way, this would be a lot easier with  so that you could let  do the quoting for you
p66421
as(dp66422
g7
V505088
p66423
stp66424
a((dp66425
g2
(lp66426
VWell, the download links at that site do appear to be down
p66427
aVYou could try downloading from here instead: http://www
p66428
aVvdebris
p66429
aVcomli
p66430
aVcom/wp-content/uploads/2009/09/libtiffdelphi_3_9_1
p66431
aVrar
p66432
aVI think you could use Mike Lischke's GraphicEx to solve your problem
p66433
aVThe  record that is made available by the  class appears to have what you need
p66434
as(dp66435
g7
V505088
p66436
stp66437
a((dp66438
g2
(lp66439
VYou are passing  for the  parameter of
p66440
aVFrom the documentation:
p66441
aVA handle to the owner window of the message box to be created
p66442
aVIf this parameter is NULL, the message box has no owner window
p66443
aVSo, the message box has no owner window
p66444
aVWhich means that it may well appear behind other windows
p66445
aVIdeally you should pass the window handle of an appropriate owner window in your application
p66446
aVOwned windows always appear above their owners
p66447
aVThat's far and away the most normal way to control which windows appear on top of other windows
p66448
aVHowever, I suspect that you may find it hard to come up with such a window handle
p66449
aVIn which case you may find that including the  flag in the  parameter, parameter number 4, meets your needs
p66450
aVIt's hard to be quite sure what you exact needs are though, because what you ask for is demonstrably impossible to achieve
p66451
aVYou asked that the window
p66452
aVbe above all programs
p66453
aVWell, that's clearly impossible, as can be proved by demonstrating a contradiction
p66454
aVSuppose that your window showed itself above all other windows
p66455
aVIf your window could do that, so could another window
p66456
aVAnd clearly you cannot have two different windows that show above all other windows
p66457
as(dp66458
g7
V505088
p66459
stp66460
a((dp66461
g2
(lp66462
VI used the following function in Delphi 6 to detect Unicode BOMs
p66463
aVThis will detect all the standard BOMs
p66464
aVYou could use it to block such files if that's the behaviour you want
p66465
aVYou state that Delphi 6  can load 16 bit encoded files if they do not have a BOM
p66466
aVWhilst that may be the case, you will find that, for characters in the ASCII range, every other character is
p66467
aVWhich I guess is not what you want
p66468
aVIf you want to detect that text is Unicode for files without BOMs then you could use
p66469
aVHowever, it may give false positives
p66470
aVThis is a situation where I suspect it is better to ask for forgiveness than permission
p66471
aVNow, if I were you I would not actually try to block Unicode files
p66472
aVI would read them
p66473
aVUse the TNT Unicode library
p66474
aVThe class you want is called
p66475
as(dp66476
g7
V505088
p66477
stp66478
a((dp66479
g2
(lp66480
VYou state in a comment that when you execute
p66481
aVfrom a command prompt, the program starts, but does not open your file
p66482
aVThis means that the executable does not support passing a file name as an argument
p66483
aVThis explains why your call to  fails
p66484
aVIt is doing exactly the same as the command interpretor cmd
p66485
aVexe
p66486
aVIf it fails for one, it will fail for the other
p66487
aVIt looks like what you are attempting may not be possible
p66488
aVYou also said that you sent a  to the process
p66489
aVThat's not something that you can do just like that
p66490
aVIf the application does support drag and drop, then you'll be able to automate file opening, but it's more involved than sending a  from a different process
p66491
aVThe first step is to confirm whether or not the application can even accept drag/drop performed interactively
p66492
as(dp66493
g7
V505088
p66494
stp66495
a((dp66496
g2
(lp66497
VThe XE4 feature matrix states:
p66498
aVNew in XE4
p66499
aVIndy for iOS
p66500
aVSo I believe you can use the version of Indy that ships with the product
p66501
aVIt's possible that you are building from out of date source
p66502
as(dp66503
g7
V505088
p66504
stp66505
a((dp66506
g2
(lp66507
VThe function you need is
p66508
aVThis topic on MSDN has sample code that will meet your needs: Modifying the ACLs of an Object in C++
p66509
as(dp66510
g7
V505088
p66511
stp66512
a((dp66513
g2
(lp66514
VWhat you are declaring is called a Typed Constant
p66515
aVAnd in this specific case it is an Array Constant
p66516
aVThe documentation states (emphasis mine):
p66517
aVTo declare an array constant, enclose the values of the array's elements, separated by commas, in parentheses at the end of the declaration
p66518
aVThese values must be represented by constant expressions
p66519
aVThe code that the compiler objects to is where you attempt to use a typed constant where only a constant expression is allowed
p66520
aVThis is one of the most frustrating areas of the Delphi language because the language forces you to repeat yourself
p66521
as(dp66522
g7
V505088
p66523
stp66524
a((dp66525
g2
(lp66526
VHere's a rather dirty way to do it, that results in very clean code for the consumer
p66527
aVI was expecting the linker to put  in a read-only segment of the executable but it appears not to do so
p66528
aVIn any case, even if it did you could use  to get around that for the duration of the assignment
p66529
as(dp66530
g7
V505088
p66531
stp66532
a((dp66533
g2
(lp66534
VYour question is, which is faster:
p66535
aVor
p66536
aVThe answer is probably that the second is faster
p66537
aVConditional statements involve branches which risks branch mis-prediction
p66538
aVHowever, that line of code is trivial compared to what is around it
p66539
aVRunning across a database one row at a time is going to be outrageously expensive
p66540
aVI bet that you will not be able to measure the difference between the two options because the handling of that little  is simply swamped by the rest of the code
p66541
aVIn which case choose the more readable and simpler version
p66542
aVBut if you care about the performance of this code you should be asking the database to do the work, as you yourself state
p66543
aVWrite a query to perform the work
p66544
as(dp66545
g7
V505088
p66546
stp66547
a((dp66548
g2
(lp66549
VYou simply need to check that
p66550
as(dp66551
g7
V505088
p66552
stp66553
a((dp66554
g2
(lp66555
VIn the first version, when you write
p66556
aVthe expression
p66557
aVis evaluated first
p66558
aVAfter it has been evaluated, it is subsequently assigned to  with tuple unpacking
p66559
aVThe key point is that the entire right hand side of an assignment statement is evaluated in its entirety before performing the binding of the left-hand side names
p66560
aVIn the second version,
p66561
aVis performed first, and then
p66562
aVhappens after
p66563
aVBy which point,  has been re-bound
p66564
aVSo, to illustrate with some values
p66565
aVThe first time round the loop, after  we have
p66566
aVNow,  is
p66567
aVAnd so we have
p66568
aVBut the alternative goes like this:
p66569
aVYou ask in a comment:
p66570
aVHow would Example 1 be rewritten into 2 statements
p66571
aVThe safest way is to introduce temporary variables
p66572
aVLike this:
p66573
aVIn this case you don't actually need two temporary variables, one will suffice, but this is the most general form
p66574
aVThis tuple unpacking is how you swap two values idiomatically in Python
p66575
aVIn other languages you write:
p66576
aVIn Python you write:
p66577
as(dp66578
g7
V505088
p66579
stp66580
a((dp66581
g2
(lp66582
VMost likely the DLL is exporting the function with a decorated name
p66583
aVFind out what that name is and use it on the C# side
p66584
aVTo find the exported name use a tool like dumpbin or Dependency Walker
p66585
aVAre you quite sure that your DLL uses the cdecl calling convention
p66586
as(dp66587
g7
V505088
p66588
stp66589
a((dp66590
g2
(lp66591
VOnce you fix your indentation
p66592
aVyour code will still not work
p66593
aVNote how the elif is at a different indentation from the if
p66594
aVYou cannot splice a try into the middle of an if statement
p66595
aVAll the elif statements must be at the same nesting/indentation level
p66596
aVTherefore if you open a try block inside an if or elif, you must complete it before completing that if or elif
p66597
aVYou'll need it like this:
p66598
aVAnother point to make is not to compare against None using the equality operator
p66599
aVYou should use is when comparing against the singleton None:
p66600
as(dp66601
g7
V505088
p66602
stp66603
a((dp66604
g2
(lp66605
VThe documentation for OnExecute says:
p66606
aVOccurs when the thread associated with the service starts up
p66607
aVIf you are not spawning a new thread to handle individual
p66608
aVservice requests in an OnStart event handler, this is where you implement the service
p66609
aVWhen the OnExecute event handler finishes, the service thread terminates
p66610
aVMost OnExecute event handlers contain a loop that calls the service thread's ProcessRequests method so that other service requests are not locked out
p66611
aVYour OnExecute does not loop
p66612
aVOnce that function exits, the service stops
p66613
aVYou will need to do what the documentation describes
p66614
aVEither loop, or spawn a thread to handle service requests
p66615
aVDo be aware that you cannot show UI in a service
p66616
aVSo your attempts to call ShowMessage cannot work
p66617
aVYou'll need to use a logging mechanism appropriate for services
p66618
aVFor example one that writes to a file
p66619
aVWhat you are trying to do would be much easier in a normal desktop process which was scheduled as a scheduled task
p66620
aVI think a service is the wrong solution to your problem
p66621
as(dp66622
g7
V505088
p66623
stp66624
a((dp66625
g2
(lp66626
VIt's very difficult to exert control over the working directory in a GUI app
p66627
aVThe working directory may not be the directory which contains the executable
p66628
aVOr the working directory may have been changed by some code in your process
p66629
aVAnd since relative paths are relative to the working directory, this makes any attempt to use relative paths something of a lottery
p66630
aVSo, my advice is that you use an absolute path
p66631
aVUse Path
p66632
aVCombine to join together the path that contains your executable (for example by using Assembly
p66633
aVGetExecutingAssembly()
p66634
aVLocation) and the filename, and use that resulting absolute path
p66635
as(dp66636
g7
V505088
p66637
stp66638
a((dp66639
g2
(lp66640
Vis a tuple
p66641
aVAnd it always evaluates to  in a boolean context, irrespective of the values of ,  and
p66642
aVThis is what the documentation for Truth Value Testing has to say:
p66643
aVAny object can be tested for truth value, for use in an if or while
p66644
aVcondition or as operand of the Boolean operations below
p66645
aVThe following
p66646
aVvalues are considered false:
p66647
aVNone
p66648
aVFalse
p66649
aVzero of any numeric type, for example, 0, 0
p66650
aV0, 0j
p66651
aVany empty sequence, for example, '', (), []
p66652
aVany empty mapping, for example, {}
p66653
aVinstances of user-defined classes, if the class defines a bool() or len() method, when that method returns the integer zero or bool value False
p66654
aVAll other values are considered true \u2014 so objects of many types are
p66655
aValways true
p66656
aVYour non-empty sequence falls into the "All other values" category and so is regarded as being true
p66657
aVTo express your condition using plain Python logic, you need to write:
p66658
aVAs @Volatility points out, the  utility function can be used to simplify your code and make it read more clearly
p66659
as(dp66660
g7
V505088
p66661
stp66662
a((dp66663
g2
(lp66664
VYou can pass as many 128 bit SSE intrinsic parameters as you like under x64
p66665
aVThe x64 ABI was designed with these types in mind
p66666
aVFrom the MSDN documentation:
p66667
aV__m128 types, arrays and strings are never passed by immediate value but rather a pointer is passed to memory allocated by the caller
p66668
aVStructs/unions of size 8, 16, 32, or 64 bits and __m64 are passed as if they were integers of the same size
p66669
aVStructs/unions other than these sizes are passed as a pointer to memory allocated by the caller
p66670
aVFor these aggregate types passed as a pointer (including __m128), the caller-allocated temporary memory will be 16-byte aligned
p66671
as(dp66672
g7
V505088
p66673
stp66674
a((dp66675
g2
(lp66676
VWell, I'd probably read into a buffer that was declared using a more appropriate type
p66677
aVFor example, suppose your data are 16 bit integers,  in Delphi
p66678
aVThen declare a dynamic array of
p66679
aVThen allocate enough space for the data:
p66680
aVAnd then read the buffer:
p66681
aVNow you can access the elements as  values
p66682
aVIf you have different element types, then you can adjust your array declaration
p66683
aVIf you don't know until runtime what the element type is you may be better off with  and then using pointer arithmetic and casting to access the actual content
p66684
aVI'd say that the design of the interface to  is a little weak
p66685
aVThe buffer isn't really a string
p66686
aVIt's probably best considered as a byte array
p66687
aVBut perhaps because C does not have separate byte and character types, the function is declared as taking a pointer to char array
p66688
aVReally the Delphi translation would be better exposing a pointer to byte or even better in my view, a plain untyped  type
p66689
aVI assumed that you were struggling with interpreting the output of  since that was the code that you included in the question
p66690
aVBut, according to now deleted comments, your question is a GUI question
p66691
aVYou want to add content to a memo
p66692
aVDo it like this:
p66693
aVIf you want to convert to floating point then, still assuming 16 bit signed data, do this:
p66694
as(dp66695
g7
V505088
p66696
stp66697
a((dp66698
g2
(lp66699
VServices run in session 0 which is isolated from the interactive desktop
p66700
aVYou cannot show UI from a service
p66701
aVYou need to run a separate desktop process to show the UI and then use IPC to communicate between the service and the desktop process
p66702
aVIf your dialog is simple enough you could possibly use WTSSendMessage
p66703
aVIf you want to run code at regular intervals then you may be better off with a scheduled task rather than a service
p66704
as(dp66705
g7
V505088
p66706
stp66707
a((dp66708
g2
(lp66709
VFirst of all, I'm not going to attempt to describe how to remove every other character from a string
p66710
aVWhilst that might appear to solve your problem it merely papers thinly over the gaping cracks
p66711
aVWhat you have here is a classic text encoding mismatch
p66712
aVThe real solution to your problem will involve fixing the mismatch
p66713
aVI suspect the problem arises in code that you have not shown
p66714
aVAs I understand your question now, you have a  variable  that contains incorrectly encoded text
p66715
aVBut the code in the question takes  as input, and so the damage has already been done by the time we reach the code in the question
p66716
aVThe key to solving this is the code that puts duff data into
p66717
aVYou need to find the code which assigns to  and sort out the encoding problem there
p66718
aVIt looks like you have taken UTF-16 encoded text and interpreted it as if it had an 8 bit encoding
p66719
aVI could speculate as to how that would happen, but it would be better for you to look at the actual code, the code that assigns to
p66720
aVIf you cannot work it out, please do post an update to the question
p66721
aVI'm pretty confident that there are no bugs in the database libraries and that this is just an encoding mismatch
p66722
as(dp66723
g7
V505088
p66724
stp66725
a((dp66726
g2
(lp66727
VIt looks like your application has dependencies on third party assemblies that have not been deployed to the target machine
p66728
aVYou must make sure that you deploy those third party dependencies on any machine that runs your program
p66729
aVYour program works on your development machine because you have, presumably, installed the necessary assemblies when you installed the dev tools for the third party product
p66730
aVThe error message indicates that you application has a dependency on Crystal Reports
p66731
aVSo you probably need to deploy the Crystal Reports redistributable package
p66732
aVOnce you've cleared that up, there may be other dependencies to resolve
p66733
as(dp66734
g7
V505088
p66735
stp66736
a((dp66737
g2
(lp66738
VI initially suspected that the issue is that the function expects  and Delphi converts your float to something else
p66739
aVWhen I tracked it down in the debugger I find that the variant being passed to  is has  of  and a currency value of
p66740
aVQuite how that happens I'm not sure
p66741
aVAs I discovered, answering this question, it's surprisingly tricky to get a single precision float into a variant
p66742
aVI initially suspected that you can use the solution I presented there to solve your problem
p66743
aVBut this fails also, in the same way, for reasons I don't yet understand
p66744
aVLike you, I tried calling the function using
p66745
aVThis is what I came up with:
p66746
aVI cannot call  this way, but can call the  function
p66747
aVTo add to your collection of success/failure indicators, when I call  function using  I have success
p66748
aVWhen I call using Python's , I get
p66749
aVThere is clearly some special magic ingredient that we are missing
p66750
aVIt seems that all the MS tools know about this magic
p66751
aVI conclude that it is not possible to call  using variant dispatch as implemented in Delphi
p66752
aVIt does not know about the magic, whatever that magic is
p66753
aVIt is clearly possible to call  on the  and succeed
p66754
aVWe can tell that because other environments manage to do so
p66755
aVSo, what I do not know yet is what the missing magic is
p66756
aVIf you could use early bound COM, then you could sidestep this issue:
p66757
aVOK, with the help of Hans Passant, I have some Delphi code that manages to call this function:
p66758
aVFor reasons unknown, you need to include  as well as
p66759
aVThe question that I asked probably makes this question a duplicate
p66760
aVSo, I'm voting to close
p66761
as(dp66762
g7
V505088
p66763
stp66764
a((dp66765
g2
(lp66766
VPython extension DLLs are not expected to have the MSVCR manifest
p66767
aVYou can take a look at the extension DLLs that ship with Python (e
p66768
ag217
aV_bz2
p66769
aVpyd, _ctypes
p66770
aVpyd, _lzma
p66771
aVpyd, _tkinter
p66772
aVpyd etc
p66773
aVand you will see that they do not contain a manifest resource
p66774
as(dp66775
g7
V505088
p66776
stp66777
a((dp66778
g2
(lp66779
VYou are trying to initialize a variable as part of its declaration
p66780
aVThe documentation states that the syntax must be:
p66781
aVwhere constantExpression is any constant expression representing a
p66782
aVvalue of type type
p66783
aVThe documentation for constant expressions says (emphasis mine):
p66784
aVA constant expression is an expression that the compiler can evaluate without executing the program in which it occurs
p66785
aVConstant expressions include numerals; character strings; true constants; values of enumerated types; the special constants True, False, and nil; and expressions built exclusively from these elements with operators, typecasts, and set constructors
p66786
aVConstant expressions cannot include variables, pointers, or function calls
p66787
aVYou are contravening the final sentence, specifically the part that I have highlighted
p66788
aVIt's quite possible that all you want to do is declare an array of strings
p66789
aVIn which case you would simply write:
p66790
aVIf you need to initialize this array, do so in the  section of the unit that declares them:
p66791
aVI note that you are trying to initialize the elements of the array with other string variables
p66792
aVWith a simpler example, I wonder if you are trying to do this:
p66793
aVand then I wonder if you are hoping that you can do this:
p66794
aVIf that's what you are hoping for, you will be disappointed
p66795
aVThe string data type in Delphi is quite complex, but fundamentally it behaves like a value type
p66796
aVIf you are trying to do what I outline above you'll need to use references to string variables:
p66797
aVand then you can indeed write:
p66798
as(dp66799
g7
V505088
p66800
stp66801
a((dp66802
g2
(lp66803
VThe code in your question will replace all content in the file with the text 'left::'
p66804
aVThat part of your code is fine
p66805
aVI/O error 32 is a sharing violation
p66806
aVThe file is locked in a way that prevents your code writing to the file
p66807
aVEither another process, or even your own process has a lock on the file
p66808
aVThe system doesn't lie
p66809
aVThe file is already open somewhere which is why your code fails with error 32
p66810
aVI think it most likely that your own program is the guilty party
p66811
aVLook at all the places in the code where you open that file
p66812
aVDo you have two or more file variables that are attached to that file
p66813
aVAre you 100% sure that you never open the file with one file variable whilst it is already open with another variable
p66814
as(dp66815
g7
V505088
p66816
stp66817
a((dp66818
g2
(lp66819
VWhen your notification icon receives the message corresponding to an action, you can query at that point to find out an associated point on the screen
p66820
aVFor example if you are handling ,  etc
p66821
aVin your icon's message procedure you can call  to find out the position on the icon associated with the message
p66822
aVI wrap this up with the following function so that I can decode the message into a :
p66823
aVSo what you can do is, in your icon's message procedure, make a note of this point
p66824
aVWhen you need to show the form, use this point to determine where your icon lives
p66825
aVSince the point can be in the taskbar, you'll need to clip it into the work area
p66826
aVAfter your question update it seems you want to know how to find out the location of the taskbar
p66827
aVDo that by calling  passing
p66828
as(dp66829
g7
V505088
p66830
stp66831
a((dp66832
g2
(lp66833
VThe  is really just a convenient way to use  for an automation interface
p66834
aVThat's why they have the same GUID \u2013 they are exactly the same thing behind the scenes
p66835
aVWhen you use  to invoke a method you typically have to call  to obtain the dispatch ID for your method
p66836
aVBut since these are static, you can save time by skipping that step, if you know the dispatch ID
p66837
aVAnd that's what a  allows you to do
p66838
aVWhen you call a method on a  you still end up calling  on the , but you skip the call to
p66839
aVWhen you use  with an interface, you'll get the
p66840
aVYou can then cast it to its corresponding
p66841
aVIt's still the same interface, but when you invoke methods on the  you'll save that call to
p66842
aVSo, if you have an  for the Word application object, say, you can write code like this:
p66843
aVThe  cast is nothing more than a call to
p66844
aVWhich in turn is nothing more than a call to
p66845
aVAnd you can then write:
p66846
aVBoth produce the same output
p66847
aVThe former first calls  before calling
p66848
aVThe latter goes straight to
p66849
as(dp66850
g7
V505088
p66851
stp66852
a((dp66853
g2
(lp66854
VI think you mean a function like this:
p66855
aVIf you use  from the  unit you can write it more concisely:
p66856
as(dp66857
g7
V505088
p66858
stp66859
a((dp66860
g2
(lp66861
VI've never done this before, but I think this should work
p66862
as(dp66863
g7
V505088
p66864
stp66865
a((dp66866
g2
(lp66867
VI expect that this is due to the file system redirector
p66868
aVFor a 32 bit process on a 64 bit system, that will redirect references to  to
p66869
aVYou have a 64 bit system, and are running 32 bit Python
p66870
aVWhen you invoke  from  it finds  because  is a 64 bit process, and so not subject to redirection
p66871
aVLikewise for PowerShell
p66872
aVBut your 32 bit Python cannot see into the 64 bit system directory
p66873
aVSo it cannot find
p66874
aVYou also tried to execute  and that failed in the same way
p66875
aVFor exactly the same reason
p66876
aVThe redirector means that to a 32 bit process that path actually refers to
p66877
aVTest out this hypothesis by invoking
p66878
aVThat should work from your 32 bit Python because it uses the  alias that allows 32 bit processes to see into the 64 bit system directory
p66879
aVAny long term solution should involve putting  somewhere else
p66880
aVRemember that the system directory belongs to the system and you should not be modifying its contents
p66881
aVI suggest that you create a dedicated folder for such utilities, and add that directory to your
p66882
as(dp66883
g7
V505088
p66884
stp66885
a((dp66886
g2
(lp66887
V simply starts the other process and waits for it to complete
p66888
aVThat's taking a minute to happen, but the time is not spent executing
p66889
aVThe time is spent executing the other process
p66890
aVThe only way to speed things up is to speed up that other process
p66891
as(dp66892
g7
V505088
p66893
stp66894
a((dp66895
g2
(lp66896
VThe working directory of a process on Windows is not an environment variable
p66897
aVIt is read by calling the Win32 API function
p66898
aVIn Python that is wrapped up by
p66899
aVThere is no standard environment variable on Windows named
p66900
aVThe command interpretor  does create the illusion of an environment variable named , but it's private to
p66901
aVSince your code runs in the Python executable, that's just not relevant
p66902
aVNote that when you execute the  command in , there is no  variable listed
p66903
aVIt's easy to verify that what I say is true
p66904
aVWrite a simple C program that calls  passing
p66905
aVYou'll see that there is no such variable
p66906
aVEven if you did happen to be able to hack into the  process that started your  executable, what good would it do you
p66907
aVYour Python process has a working directory that is distinct from that of
p66908
aVAnd who says that your Python process was even started from
p66909
aVI'm not quite certain where your confusion lies, but the way to obtain the working directory in Python is to call
p66910
aVAnd then if you want to resolve symlinks, you will have to do so yourself
p66911
as(dp66912
g7
V505088
p66913
stp66914
a((dp66915
g2
(lp66916
VUsing both a dynamic array and a TList is not good
p66917
aVUse one or other, but not both
p66918
aVInserting is easy in TList, but you need to manage lifetime of your pointers
p66919
aVYou are looking at heap allocation
p66920
aVFor a dynamic array, lifetime is easy, but insertion and deletion requires a bit of care
p66921
aVOf course, if you had modern Delphi it would be trivial with TList
p66922
aVUse insertion sort to maintain the ordering of your array
p66923
aVWhenever you insert a new item, insert it at a position where it is greater than the previous element, and less than the subsequent element
p66924
aVIf your list is already ordered, then inserting following this rule maintains the ordered property
p66925
aVFor efficiency you can use binary search to find the insertion point
p66926
aVFor an example of this look at TStringList when Sorted is True
p66927
aVBefore you tackle binary search (surprisingly tricky to get right), implement a version with linear search
p66928
aVProve to yourself this works, and then move on to binary search if you need the extra efficiency
p66929
aVWhen deleting, simply delete the item
p66930
aVDeleting any item from an ordered array preserves the ordered property
p66931
aVYour compare function is a little "odd"
p66932
aVAll you need is:
p66933
as(dp66934
g7
V505088
p66935
stp66936
a((dp66937
g2
(lp66938
VWhat you are trying to achieve cannot be done very easily and is not supported
p66939
aVHowever, it is possible using a modicum of hacking
p66940
aVAaron Margosis wrote an article describing one technique
p66941
aVTo quote the pertinent section, you will need to carry out these steps:
p66942
aVEnable the SeIncreaseQuotaPrivilege in your current token
p66943
aVGet an HWND representing the desktop shell (GetShellWindow)
p66944
aVGet the Process ID (PID) of the process associated with that window (GetWindowThreadProcessId)
p66945
aVOpen that process (OpenProcess)
p66946
aVGet the access token from that process (OpenProcessToken)
p66947
aVMake a primary token with that token (DuplicateTokenEx)
p66948
aVStart the new process with that primary token (CreateProcessWithTokenW)
p66949
aVThe article contains a download link for some demo C++ source from which it should be simple enough to translate to C#
p66950
as(dp66951
g7
V505088
p66952
stp66953
a((dp66954
g2
(lp66955
VWell, for starters,  has no compatibility issues on Windows 7 or Windows 8
p66956
aVYes, you are now recommended to use  instead
p66957
aVBut if you want to support older operating systems like XP, then you can and should just call
p66958
aVIt works and will continue to work
p66959
aVIt's pefectly fine to use it on Windows 7 and Windows 8 and I'll eat my hat if it's ever removed from Windows
p66960
aVMicrosoft go to extraordinary lengths to maintain backwards compatibility
p66961
aVSo,  is your best option in my view
p66962
aVYour  based approach fails because you need to put it in a separate function in order to allow recursion
p66963
aVAnd the code I posted in that other answer is incomplete
p66964
aVHere is a complete version:
p66965
aVThis deletes a directory and its contents
p66966
aVYou'd want to walk the top level directory and then call this function for each subdirectory that you found
p66967
as(dp66968
g7
V505088
p66969
stp66970
a((dp66971
g2
(lp66972
VBefore you go any further you need to recognise that the VCL design forces all VCL forms to be associated with the main GUI thread
p66973
aVYou cannot create them on a different thread
p66974
aVSo your design is fundamentally flawed in that way
p66975
aVYou are never going to be able to create VCL forms in any thread other than the main GUI thread
p66976
aVEven if that was not the case, your code could not do anything useful
p66977
aVThat's because your thread does not contain a message loop
p66978
aVNo sooner has the form been created, the thread which it is associated with terminates
p66979
aVYou could make this work with raw Win32 calls to  etc
p66980
aVBut you'd need at the very least to run a message loop in your thread for the lifetime of any windows created there
p66981
aVAs to why your code never switches back to the original desktop, I cannot be sure
p66982
aVPerhaps there is an exception in the code that attempts to create the form and so the code that restores the original desktop never runs
p66983
aVThat code should be protected by a try/finally
p66984
aVAs a general point, in order to debug code which calls raw Win32 APIs, you must include error checking
p66985
aVYou don't do any, and so you don't know which API call is failing
p66986
aVThat would be the first step to debugging a problem like this, if we didn't already know that the approach is doomed to failure no matter what
p66987
aVPerhaps I'm missing something, but it's not obvious to me why you are trying to run this form out of a different thread
p66988
aVIs there any reason why it cannot run out of the main GUI thread
p66989
aVAnd to answer my own question, I am missing something
p66990
aVFrom the documentation of :
p66991
aVThe SetThreadDesktop function will fail if the calling thread has any windows or hooks on its current desktop (unless the hDesktop parameter is a handle to the current desktop)
p66992
as(dp66993
g7
V505088
p66994
stp66995
a((dp66996
g2
(lp66997
VThese are the usual steps to link to a DLL:
p66998
aVInclude the DLL's header file in any of your source files that need to use functions from the DLL
p66999
aVYou'll typically need to make sure that your build environment's include path contains the location of the header file
p67000
aVIn the IDE you can do this using the Additional Include Directories configuration setting
p67001
aVPass the DLL's
p67002
aVlib file to the linker
p67003
aVIn the IDE you do this by adding the
p67004
aVlib file to the Additional Dependencies setting
p67005
aVAnd you'll typically need to add the path to the
p67006
aVlib file to the Additional Library Directories setting
p67007
aVHaving done that, your program should compile and link
p67008
aVTo make it run, you'll need to ensure that the DLL itself can be found at runtime
p67009
aVThe simplest way to make that happen is to put it in the same directory as the executable file
p67010
aVMy guess, looking at your error message, is that in step 2 you passed the
p67011
aVdll to the linker rather than passing the
p67012
aVlib file
p67013
as(dp67014
g7
V505088
p67015
stp67016
a((dp67017
g2
(lp67018
VIt's unrealistic to expect to be able to convert a string into a character
p67019
aVA string can contain 0, 1 or more characters
p67020
aVWhich character do you want
p67021
aVIf you want the first character, use , after having checked that the string is not empty
p67022
aVIn your case you probably want to add a check that the string's length is exactly 1 because otherwise that means the user's input is invalid
p67023
aVCheck
p67024
as(dp67025
g7
V505088
p67026
stp67027
a((dp67028
g2
(lp67029
VUsing an in-memory database is one option, but it seems quite a heavy duty solution for what is really quite a simple problem
p67030
aVAnother option to consider is to use  where  is a  with the various file details in
p67031
aVAs for sorting, the most efficient approach is to would maintain an index for each column that you wanted to sort by
p67032
aVSo, an index is a simple array of integers that represented the order of the records when sorted by a particular column
p67033
aVSo, an index array of  would mean that the first item was index 1, the second was index  and the third was index
p67034
aVDoing this means that you only need to sort on each column if and when you need to, and only do so once
p67035
aVThat said, you only even need to maintain separate index arrays if you have a lot of files
p67036
aVYou may find that performance is acceptable by simply sorting on demand when ever you need to
p67037
aVI'm sure that's what Explorer does
p67038
aVI can't give you advice on which option is right for your problem because I don't know you performance constraints
p67039
aVBut to summarise, here are the main options in order increasing complexity:
p67040
aVUse  and re-sort the list on demand
p67041
aVUse  and build and retain index arrays on demand
p67042
aVUse an in-memory database
p67043
as(dp67044
g7
V505088
p67045
stp67046
a((dp67047
g2
(lp67048
VThe only plausible explanation for what you report is that the DLL has a different definition of the struct
p67049
aVAnd so when the calling code writes to members of the struct, it writes to different offsets from the offsets used in the DLL
p67050
aVIn the statement above, I mean also to cover the possibility that the layout of the struct is different in the DLL from that in the calling code
p67051
aVAs it happens, for 32 bit targets, the packed and aligned layouts of your struct are the same
p67052
aVFor 64 bit targets, packed and aligned differ
p67053
aVIt's hard to say what the mismatch is from the code that you have posted
p67054
aVUnfortunately you seem to be a little shy
p67055
aVIf you could only publish the entire code, for both the DLL and the code that consumes the DLL, it would be easy to tell you what the mismatch is
p67056
aVSo, as it stands I'm afraid you'll have to work out the rest of the details, unless you can manage to publish complete code
p67057
as(dp67058
g7
V505088
p67059
stp67060
a((dp67061
g2
(lp67062
VThe  class is a wrapper of the Windows API for INI files
p67063
aVThis does support Unicode INI files, but only if those files are encoded as UTF-16
p67064
aVMichael Kaplan has more details here: Unicode INI function; Unicode INI file
p67065
aVSo, you are out of luck with
p67066
aVInstead you could use  which allows you to specify an encoding in its constructor
p67067
aVThe  class is a native Delphi implementation of INI file support
p67068
aVThere are various pros and cons between the two classes
p67069
aVIn your situation, only  can serve your needs, so it's looking like its pros are going to outweigh its cons
p67070
as(dp67071
g7
V505088
p67072
stp67073
a((dp67074
g2
(lp67075
VHere's code that does what you ask, using a combination of regular expressions, split and list comprehension:
p67076
as(dp67077
g7
V505088
p67078
stp67079
a((dp67080
g2
(lp67081
VThe names of resources within a given module must be unique, just in the same way as variables in a function must have unique names, files in a directory must have unique names and so on
p67082
aVSo, if you put two resources with the same name into the same module, one resource will get discarded and you will only be able to retrieve the remaining resource
p67083
aVIn case you are unclear on what a module is, I'll try to explain
p67084
aVA module is a DLL or an executable, or a Delphi package
p67085
aVYour executable file is a single module, with a single instance handle
p67086
aVIt is linked to DLLs, each of which are separate distinct modules
p67087
aVAny packages that your executable load are also distinct modules
p67088
aVYou can have resources in those other modules that have the same name as resource in your executable
p67089
aVI think I need to control  but I just cannot grasp how
p67090
aVThat cannot help as I hope you now understand
p67091
aVThe value  identifies the module and in your code it refers to the module associated with the executable
p67092
aVYour options:
p67093
aVGive the resources different names
p67094
aVPut the resources into different modules
p67095
as(dp67096
g7
V505088
p67097
stp67098
a((dp67099
g2
(lp67100
VI want to send one or more local variable(a,b,c) that already has value to another procedure to use them there
p67101
aVThis shows a misunderstanding about the lifetime of local variables
p67102
aVLocal variables only have scope for the duration of the function that owns them
p67103
aVSince your two event handlers have disjoint lifetimes, their local variables are never in existence simultaneously
p67104
aVSo when you say "that already has value", you are mistaken
p67105
aVThe local variables that exist when  is executing simply do not exist when  is executing
p67106
aVYou'd need the variables to be members of the class rather than be local variables
p67107
aVThat way the variables' lifetimes span the separate execution of your event handlers
p67108
as(dp67109
g7
V505088
p67110
stp67111
a((dp67112
g2
(lp67113
VThis is a linker error when compiling the executable
p67114
aVThe DLL is fine, but you have not told the linker how to link to it
p67115
aVYou need to pass to the linker the import library (the
p67116
aVlib file) that was created when you built your DLL
p67117
aVI take it you are using Visual Studio
p67118
aVIn which case add your import library to the Additional Library Dependencies setting in the project configuration for your executable
p67119
as(dp67120
g7
V505088
p67121
stp67122
a((dp67123
g2
(lp67124
VYour attempt to write down the inverse of a 4x4 matrix is utterly wrong
p67125
aVThere's absolutely no point trying to fix it since it can never work
p67126
aVYou ask what the result of  is
p67127
aVWell, that is division by zero and the result is not defined
p67128
aVThere is no real number  that satisfies
p67129
aVIf there was then , a contradiction
p67130
aVOn a computer, attempting to perform division by zero sometimes leads to an error, or sometimes results in a special floating point value  being returned
p67131
aVThe latter appears to be what happens in your environment
p67132
aVI don't know why you rejected the determinant based code
p67133
aVPerhaps you found it tricky to implement
p67134
aVBut that's just how it is
p67135
aVYou aren't going to shortcut that complexity
p67136
as(dp67137
g7
V505088
p67138
stp67139
a((dp67140
g2
(lp67141
VIn this line
p67142
aVyou are performing integer division
p67143
aVSo, for example, let's say that  is 3 and  is 5, then you perform  which equals
p67144
aVBut I think you are looking to perform  and hoping for the answer
p67145
aVSo you need to perform floating point division
p67146
aVYou can force that by casting one of the operands to a float
p67147
aVIn the question you wrote  rather than
p67148
aVI assumed that was a transcription error when asking the question
p67149
aVBut perhaps your real code looks like that
p67150
aVIn which case, you'll need to change it to  to get it to compile
p67151
aVThe other possible problem you have is that the program expects arguments to be passed on the command line
p67152
aVAre you passing two arguments to your program
p67153
aVIn other words you need to execute your program like this:
p67154
aVIf you are not passing arguments then you will encounter runtime errors when attempting to access non-existent arguments in
p67155
aVAt the very least you should add a check to the program to ensure that
p67156
aVIf you want to read the input from , rather than passing command line arguments, use
p67157
as(dp67158
g7
V505088
p67159
stp67160
a((dp67161
g2
(lp67162
VIn many cases there will be no point in putting an intermediate memory stream in between the download and the file
p67163
aVAll that will do is consume memory because you have to put the entire file in memory before you can put it to disk
p67164
aVUsing a file stream directly avoids that issue
p67165
aVThe main situation where the file stream option has problems is if you want to be sure that you've downloaded the entire file successfully before saving to disk
p67166
aVFor example, if you are overwriting a previous version of a file, you may want to download it, check a hash signature, and only then overwrite the original file
p67167
aVIn that scenario you need to put the file to some temporary location before over-writing
p67168
aVYou could use a memory stream, or you could use a file stream using a temporary file name
p67169
as(dp67170
g7
V505088
p67171
stp67172
a((dp67173
g2
(lp67174
VIn Delphi 6 there is no built in support for dynamic array initialization
p67175
aVI'd use a pair of helper functions for this:
p67176
aVAnd then call it like this:
p67177
as(dp67178
g7
V505088
p67179
stp67180
a((dp67181
g2
(lp67182
VThese are window styles
p67183
aVThe list of which can be found over on MSDN
p67184
aVWindow styles are bit flags that are combined using bitwise OR
p67185
aVSo, first decompose  into its constituent parts:  and
p67186
aVNow,  is  and   is
p67187
aVWhoever wrote the code using magic constants should be given a suitably humiliating punishment
p67188
aVThat code should read:
p67189
aVObviously you'll need to define the  constants, but do take the time to do so for the benefit of future readers of the code
p67190
as(dp67191
g7
V505088
p67192
stp67193
a((dp67194
g2
(lp67195
VYou are allocating random text to  and then setting  to a random number
p67196
aVWhen you print those things you get, well, random output
p67197
aVBecause you have not restricted the randomisation to printable characters weird things happen
p67198
aVYou are printing control characters
p67199
aVYour second screenshot would indicate that you have printed a carriage return character
p67200
aVI'm sure you don't want to do that
p67201
aVThe program is doing exactly what you asked it to do
p67202
aVSince you did not say what set of characters you wanted to assign to  from, I really could not say what your program should be
p67203
aVYou could make it choose values in the range A to Z with this change:
p67204
aVI'll bet that there are other problems with your code, but since the main focus of the question concerned printing, I'll not look any deeper
p67205
as(dp67206
g7
V505088
p67207
stp67208
a((dp67209
g2
(lp67210
VYou also need to include  when you call
p67211
aVThat's needed to notify the system that the background has been changed and will result in the system responding to your change
p67212
aVYou'll need to add a declaration for  which has the value
p67213
aVThe documentation says this about :
p67214
aVBroadcasts the WM_SETTINGCHANGE message after updating the user profile
p67215
aVThat said, even without , the desktop background will be changed on some systems
p67216
aVSo my guess is that your main problem is actually with your bitmap file
p67217
aVHere are some possible problems with your bitmap file:
p67218
aVYou've specified the path to the bitmap incorrectly
p67219
aVThe bitmap is still locked by the code that saved it
p67220
aVThe bitmap is not in fact a bitmap
p67221
aVPerhaps you saved a
p67222
aVjpg to a file with a
p67223
aVbmp extension
p67224
aVProve to yourself that the code above works by creating a simple bitmap in Paint and changing the code above to use the hard coded path to that file
p67225
aVThat will convince you that the desktop background can be changed
p67226
as(dp67227
g7
V505088
p67228
stp67229
a((dp67230
g2
(lp67231
VWhen you create a component with an , the  adds your component to its list of components that it owns
p67232
aVThat happens in this code:
p67233
aVAs you can see the component is added to the end of the list
p67234
aVWhen the owner is destroyed, it calls :
p67235
aVAs you can see, the loop processes the last member first
p67236
aVSo, components are destroyed in reverse order
p67237
aVPersonally I would not rely on destruction order
p67238
aVIf the form needs to be sure that the thread is terminated before the form is destroyed, I would write code in the form's destructor to enforce that
p67239
aVUsing  is a perfectly respectable solution to many problems
p67240
aVWhether or not it's the best solution to your problem is impossible me to say because you have not fully described your problem
p67241
aVHow expensive is dynamic form creation/destruction in typical application
p67242
aVNot very
p67243
aVTypically forms are shown in response to user interaction
p67244
aVPrograms can create forms a lot faster than users can process them
p67245
aVSo dynamically creating forms is seldom a problem
p67246
aVIf you wanted to create and destroy thousands of forms a second that might be a problem
p67247
aVBut that would be bizarre
p67248
as(dp67249
g7
V505088
p67250
stp67251
a((dp67252
g2
(lp67253
VYou detect the pressing of the SHIFT key when your hook proc is called with  equal to
p67254
aVWhen your hook proc is called corresponding to the A key being pressed, the  and  values are identical whether or not the SHIFT key is down
p67255
aVSince you are not calling  and  as would happen in a normal message loop, you are going to have to translate the raw key down/up events into actual key presses
p67256
aVIt's probably going to be easiest for you to use  to detect whether or not the SHIFT key is down
p67257
aVThat depends on exactly what you are trying to do
p67258
aVIt looks a little like you are making a fully functioned keylogger
p67259
aVIn which case ad-hoc calls to  may not meet your needs, and proper processing of the individual key down/up messages would be better
p67260
aVSome other comments:
p67261
aVWhy are you heap allocating your  record
p67262
aVYou can perfectly well use a stack allocated record
p67263
aVI hope that  is a window in the same process as your hook
p67264
aVIf not it won't receive any useful information because the pointer you send it is only meaningful in the process that defines it
p67265
aVIf you want to send information cross-process them  is your guy
p67266
as(dp67267
g7
V505088
p67268
stp67269
a((dp67270
g2
(lp67271
VWhy does system32 get mapped to SysWOW64
p67272
aVThis is a rather obscure corner of the registry
p67273
aVBecause your process is a 32 bit process the registry redirector interjects
p67274
aVThe documentation states:
p67275
aVIn addition, REG_SZ or REG_EXPAND_SZ keys containing system32 are replaced with syswow64
p67276
aVThe string must begin with the path pointing to or under %windir%\u005csystem32
p67277
aVThe string comparison is not case-sensitive
p67278
aVEnvironment variables are expanded before matching the path, so all of the following paths are replaced: %windir%\u005csystem32, %SystemRoot%\u005csystem32, and C:\u005cwindows\u005csystem32
p67279
aVThe simplest (and possibly the only) way to get around this is to perform the writing from a 64 bit process and thus escape the clutches of the registry redirector
p67280
aVDo I have to call  for each different key that I write to
p67281
aVYes
p67282
aVDo I have to empty all the subkeys before I can delete a key
p67283
aVFrom the documentation of :
p67284
aVCall DeleteKey to remove a specified key and its associated data, if any, from the registry
p67285
aVUnder Windows 95, if the key has subkeys, the subkeys and any associated data are also removed
p67286
aVUnder Windows NT, subkeys must be explicitly deleted by separate calls to DeleteKey
p67287
aVThe reason for this is that  calls  whose documentation states:
p67288
aVThe subkey to be deleted must not have subkeys
p67289
aVTo delete a key and all its subkeys, you need to enumerate the subkeys and delete them individually
p67290
aVTo delete keys recursively, use the RegDeleteTree or SHDeleteKey function
p67291
aVSo, if you are prepared to call Windows API functions directly, you can delete a key and its subkeys in one API call, using either of those aforementioned functions
p67292
aVIf you need to support XP then use  which you call like this:
p67293
as(dp67294
g7
V505088
p67295
stp67296
a((dp67297
g2
(lp67298
VThe list class is not itself an array
p67299
aVIn other words, it does not derive from an array
p67300
aVInstead it encapsulates an array that is used by the implementation to hold the list's member elements
p67301
aVSince  offers random access to its elements, and those elements are indexed , using an array to store the elements is the obvious implementation
p67302
as(dp67303
g7
V505088
p67304
stp67305
a((dp67306
g2
(lp67307
VWindows displays on top the window which is higher up the z-order
p67308
as(dp67309
g7
V505088
p67310
stp67311
a((dp67312
g2
(lp67313
VYour function import is failing because the function is named  where the  specifies that you want to use Unicode characters
p67314
aVSo your function declaration should be
p67315
aVOnce that is fixed, the two most common failure modes are:
p67316
aVYour process does not have admin rights
p67317
aVYour process runs in a 32 bit process on a 64 bit system and so cannot see the 64 bit view of the registry
p67318
aVBased on your earlier question, option 2 seems most likely
p67319
aVYou said "nothing is happening", but I'm sure something is happening
p67320
aVThe function is failing and returning an error status to you
p67321
aVBut you did not check the return value of the call to
p67322
aVWhenever you call a Windows API, check the return value
p67323
aVIf it fails, the return value allows you to diagnose that failure
p67324
aVAssuming the issue is the registry redirector for your 32 bit process, your options include:
p67325
aVRun the code from a 64 bit process
p67326
aVUse
p67327
aVEmpty the key's subkeys first, and then use
p67328
aVNote that the code where you specify  only has effect when using the  methods
p67329
aVSince  is a Windows API function, it is independent from that class
p67330
as(dp67331
g7
V505088
p67332
stp67333
a((dp67334
g2
(lp67335
VYou are passing a literal to your function and attempting to modify literals is undefined behaviour
p67336
aVMake a modifiable string like this:
p67337
aVOn top of that,  only works when you have an odd number of characters in your string
p67338
aVYour  condition is wrong
p67339
aVIt should be:
p67340
aVYour code said:
p67341
aVand if your string has an even number of characters, that condition is always true
p67342
aVHence the loops until you get a segmentation fault because  and  point outside the input string
p67343
as(dp67344
g7
V505088
p67345
stp67346
a((dp67347
g2
(lp67348
VThe streaming framework needs to be able to convert a component class name into a class
p67349
aVOnce it has done so it is able to instantiate an object of the right class
p67350
aVThe key line of code is:
p67351
aVAlthough  has type , the actual runtime type can be a subclass of
p67352
aVIn your case,
p67353
aVSo, in order to be able to convert the string  into the meta class , there needs to be a registry (i
p67354
ag192
aVa map) of classes and their names
p67355
aVAnd that registry is populated by calls to
p67356
aVWithout that call, the streaming framework cannot find the metaclass  that is named
p67357
aVAnd so it cannot stream in the component
p67358
aVAlthough you are working with FPC, the Delphi documentation for  will be helpful to you
p67359
as(dp67360
g7
V505088
p67361
stp67362
a((dp67363
g2
(lp67364
VTo perform the reverse of your function  you simply do this:
p67365
aVAlthough, I think you have the names of your variables back-to-front
p67366
aVI'd call  the low byte, and  the high byte
p67367
aVYou are also mistaken in supposing that you can fit  into 2 bytes
p67368
aVRemember that 2^16 is
p67369
aVI have a function that allows me to separate a int value into 2 bytes (e
p67370
aVg: int "123123" results in E0F3; highByte= 0xF3 and lowByte=0xE0)
p67371
aVWell, E0F3 represented in decimal is equal to 57587
p67372
aVWhich is the value you report in the comment you made to my answer
p67373
aVNow,  represented in hexadecimal is  and you need at least three bytes to store that value
p67374
as(dp67375
g7
V505088
p67376
stp67377
a((dp67378
g2
(lp67379
V is a window handle
p67380
aVIt does not have a  property
p67381
aVSimply remove the
p67382
aVI don't expect this will solve all the problems in that code, but it's the solution to the compiler error that is the subject of this question
p67383
as(dp67384
g7
V505088
p67385
stp67386
a((dp67387
g2
(lp67388
VIt looks like your main problem is this line of code:
p67389
aVThis should simply not be there
p67390
aVWhen you call the window proc with , a second list view is created
p67391
aVSimply remove this line of code from your program
p67392
aVSome other comments:
p67393
aVYour handling of  is odd
p67394
aVYou don't need to handle that message since the default handler will call
p67395
aVAnd you should not call  from there
p67396
aVInstead call it from
p67397
aVSo, replace the  clause with this:
p67398
aVIt's probably cleaner to zero-initialize a struct before populating the handful of members that need values
p67399
aVFor example:
p67400
aVYou use this approach in the  handler too, but the syntax above is perhaps a little more idiomatic than
p67401
aVFinally, I'd prefer to see your  and  handlers use  rather than letting  be called
p67402
as(dp67403
g7
V505088
p67404
stp67405
a((dp67406
g2
(lp67407
VFrom code I came to know that they are storing the user settings using
p67408
aVThe constructor of  receives the name of the file that stores the INI file
p67409
aVSo, you simply need to find the call to  and your answer will be revealed
p67410
as(dp67411
g7
V505088
p67412
stp67413
a((dp67414
g2
(lp67415
VThe things that I can see wrong with your code at present are:
p67416
aVThe property setter must receive a single parameter of the same type as the property, namely
p67417
aVThe property setter must be a member of the class, but you've implemented it as a standalone procedure
p67418
aVA published property needs to have a getter
p67419
aVSo the code would become:
p67420
aVThis code does not instantiate
p67421
aVI'm guessing that the code that does instantiate  is part of the larger component code that has been excised for the sake of this question
p67422
aVBut obviously you do need to instantiate
p67423
aVAn alternative to instantiating  is to turn  into a record
p67424
aVWhether or not that would suit your needs I cannot tell
p67425
aVIt looks like you are having some problems instantiating this object
p67426
aVDo it like this:
p67427
aVOne final comment
p67428
aVUsing  for an object is a bad name
p67429
aVUse class for the type, and object for the instance
p67430
aVSo, your property should be  and the member field should be  etc
p67431
as(dp67432
g7
V505088
p67433
stp67434
a((dp67435
g2
(lp67436
V returns  when it fails
p67437
aVThat's clearly what's happening here
p67438
aVIt's failing because you are looking under the wrong root key
p67439
aVYou are looking under HKCU but the key is under HKLM
p67440
aVSo you need
p67441
aVYou must always check the return value when you call
p67442
aVIf it is  then handle that error case
p67443
aVThe other thing to watch out for is the registry redirector
p67444
aVIf your process is a 32 bit process running on a 64 bit system, then you will see the 32 bit view of the registry
p67445
aVThat means that your attempt to view  is transparently redirected to
p67446
as(dp67447
g7
V505088
p67448
stp67449
a((dp67450
g2
(lp67451
VDefault parameters can be used with DLLs
p67452
aVBut the default parameters must be declared when the function is imported rather than when it is exported
p67453
aVThat's because default parameters are implemented at the call site
p67454
aVThe caller detects that parameters are missing and generates code to supply the missing parameters
p67455
aVSo you can use default parameters when you import the DLL, provided that the language that consumes the DLL supports that
p67456
aVIn the DLL code, export the function
p67457
aVYou can specify default parameters there if you wish, but it won't have any effect for the consumer of the DLL
p67458
aVIn the code that imports the DLL function, declare your default parameters
p67459
aVIt is the default values declared at this point that matter
p67460
aVSince DLLs are typically used to provide language neutral interfaces, and since some languages do not support default parameters, it is rare to use them in DLL interfaces
p67461
as(dp67462
g7
V505088
p67463
stp67464
a((dp67465
g2
(lp67466
VLooking at statement 1, I'm assuming you mean:
p67467
aVIn which case, I'd probably write it like this:
p67468
aVYou can use an analogous form for statement 2
p67469
aVHaving said that, I cannot make your comments in the question's code match up with my interpretation of your conditionals, so it's plausible I don't understand your requirement
p67470
as(dp67471
g7
V505088
p67472
stp67473
a((dp67474
g2
(lp67475
VAssuming that you really do need to write to both 32 and 64 bit views of the registry, the solution is as I described in an earlier question
p67476
aVYou need to write the registry entries for the 32 bit DLL from 32 bit code, and write the registry entries for the 64 bit DLL from 64 bit code
p67477
aVYour problems all stem from attempting to modify the 64 bit view of the registry from a 32 bit process
p67478
aVThe registry redirector is getting in the way of you doing that
p67479
aVThe information I provided in your other question is enough to show that you cannot write the information you desire to the 64 bit view from a 32 bit process
p67480
as(dp67481
g7
V505088
p67482
stp67483
a((dp67484
g2
(lp67485
VThere is no support for mobile in XE3
p67486
aVIt was added in XE2 using FPC compiler, removed from XE3 and then restored for XE4 using new Embarcadero mobile compiler
p67487
as(dp67488
g7
V505088
p67489
stp67490
a((dp67491
g2
(lp67492
VSince you are using Windows, you can use the code in the question even in a FireMonkey app
p67493
aVI think you need to put the code into a unit which does not use any FMX units, but otherwise it works fine
p67494
aVYou'll need to use Vcl
p67495
aVDialogs in that unit
p67496
as(dp67497
g7
V505088
p67498
stp67499
a((dp67500
g2
(lp67501
VAs you know, all UI code must be executed on the main GUI thread
p67502
aVThat's why you are calling  to update your GUI
p67503
aVSynchronize works broadly like this:
p67504
aVThe task to be performed on on the main thread is placed in a queue
p67505
aVThe main thread is signaled to indicate that synchronize tasks are pending
p67506
aVThe background thread blocks
p67507
aVWhen the main thread next checks to see if there are pending synchronize tasks, it executes them
p67508
aVThe background thread is signaled to indicate that the task has been executed
p67509
aVThe background thread stops blocking and continues executing
p67510
aVIt's quite a complex little dance
p67511
aVYour problem is that your main thread is busy executing some long running task
p67512
aVPresumably in the calls to  and
p67513
aVAnd that means that the GUI thread does not perform item 4 in a timely fashion
p67514
aVWhat's more, the main thread blocks the background thread, somewhat negating the utility of threads
p67515
aVYour problem, fundamentally, is that your main GUI thread is busy doing something other than servicing the GUI
p67516
aVYou should dedicate your GUI thread to servicing the GUI
p67517
aVIt should take on nothing else, and certainly not any long running tasks
p67518
aVOnce you manage to ship all the non-GUI tasks out of the GUI thread and onto background threads, you'll find that you application is responsive
p67519
aVFinally, I recommend that you remove that call to  from
p67520
aVYou probably added it to try to deal with your non-responsive GUI
p67521
aVBut it won't help at all because your problem is that  is not executing in a timely fashion
p67522
as(dp67523
g7
V505088
p67524
stp67525
a((dp67526
g2
(lp67527
VMSDN makes this perfectly clear:
p67528
aVA child window has a client area but no other features, unless they are explicitly requested
p67529
aVAn application can request a title bar, a window menu, minimize and maximize buttons, a border, and scroll bars for a child window, but a child window cannot have a menu
p67530
aVThis refers to the menu as drawn by Windows itself
p67531
aVIf your component custom draws a menu bar, then of course it can have a menu, even if it is a child window
p67532
aVYour call to  does not make your window into a child window
p67533
aVThis is explained in the documentation:
p67534
aVFor compatibility reasons, SetParent does not modify the WS_CHILD or WS_POPUP window styles of the window whose parent is being changed
p67535
aVTherefore, if hWndNewParent is NULL, you should also clear the WS_CHILD bit and set the WS_ POPUP style after calling SetParent
p67536
aVConversely, if hWndNewParent is not NULL and the window was previously a child of the desktop, you should clear the WS_POPUP style and set the WS_CHILD style before calling SetParent
p67537
as(dp67538
g7
V505088
p67539
stp67540
a((dp67541
g2
(lp67542
VThis happens when the
p67543
aVocx is not registered with the systems COM registry
p67544
aVNormally you would run  to register the COM server, although different components sometimes have different ways of performing that registration
p67545
as(dp67546
g7
V505088
p67547
stp67548
a((dp67549
g2
(lp67550
VThis is definitely not a recursive call
p67551
aVThe call
p67552
aVis not calling
p67553
aVThat much is clear since the parameter count does not match
p67554
aVThe explanation is that  is overloaded
p67555
aVThere is another version with three parameters
p67556
aVThat three parameter version is declared in one of the header files that you included
p67557
as(dp67558
g7
V505088
p67559
stp67560
a((dp67561
g2
(lp67562
VThe issue is that none of the numbers that you are using can be exactly representing in binary floating point format
p67563
aVThat's the nature of binary floating point
p67564
aVFor more details read What Every Computer Scientist Should Know About Floating-Point Arithmetic
p67565
aVThe closest single precision floats to your two numbers are:
p67566
ag9193
aV1 = + 0
p67567
aV10000 00014 90116 11938 47656 25
p67568
aV14
p67569
aV7 = + 14
p67570
aV69999 98092 65136 71875
p67571
aVSo,  is evaluated first, and because the values are not exactly representable, that just happens to evaluate to a value that is less than
p67572
aVSo when you  it, you turn it into 146
p67573
aVAnd hence the result that you observe
p67574
aVI understand that the same number can be encoded differently as a double
p67575
aVIn general that is not the case
p67576
aVYour problem is that neither 14
p67577
aV7 nor 0
p67578
aV1 can be exactly represented at all
p67579
aVThe issue is nothing to do with uniqueness of representation
p67580
aVSo, to perform your sum exactly, you need to use decimal arithmetic
p67581
aVThat's not something that is built in to C++ and you would need to use a third party library for that
p67582
as(dp67583
g7
V505088
p67584
stp67585
a((dp67586
g2
(lp67587
VYour fundamental problem is that you have mis-interpreted the answers in the question to which you linked
p67588
aVWhen you derive the class  you do not make a new static variable
p67589
aVSo,  and  are the same variable
p67590
aVOnce you correct this mis-understanding everything else will be obvious and clear
p67591
aVLooking at your code:
p67592
aVHow is it that instead of A::a I can also access objA
p67593
ag4706
aVBecause the language specification says that you can
p67594
aVThe language specification says that  and  are the same variable
p67595
aVThis is covered in any good guide to the language
p67596
aVFor example, online you can read cppreference
p67597
aVcom which says it like this:
p67598
aVTo refer to a static member n of class T, two forms may be used: qualified name T::m or member access expression e
p67599
aVm or e->m, where e is an expression that evaluates to T or T* respectively
p67600
aVWhen in the same class scope, the qualification is unnecessary
p67601
as(dp67602
g7
V505088
p67603
stp67604
a((dp67605
g2
(lp67606
VYou are making very heavy weather of loading RTF
p67607
aVYour code to read a file into a string will never work, as @evanmcdonnal explained
p67608
aVDid your file dialog based code that succeeded really do it like that
p67609
aVRemember that a file dialog is just UI that generates a file name in a string
p67610
aVIf your code with a file dialog works, then it will work when the file dialog is replaced with a hard coded string
p67611
aVI suspect that some part of your problem is that you are using a relative path
p67612
aVPerhaps the working directory is not what you expect it to be
p67613
aVYou should specify the full path to the file
p67614
aVIn any case, to load RTF simply call the LoadFile method of the control
p67615
aVBut I strongly recommend passing the full path to the file
p67616
as(dp67617
g7
V505088
p67618
stp67619
a((dp67620
g2
(lp67621
VThere are a few issues here that are worth considering
p67622
aVFirst of all, you have assumed a packed layout
p67623
aVPerhaps the native struct really is packed but that would be unusual
p67624
aVIt's normal for structs to be aligned
p67625
aVUnless the native declaration contains a  directive your struct will be aligned
p67626
aVSecondly, pointers are different sizes for 32 and 64 bit targets and so your use of explicit will only be able to work for one target
p67627
aVThe way to deal with that is to use explicit layout for the union only
p67628
aVThat's the best way to handle unions
p67629
aVAnd then use this union in your struct
p67630
aVIf your struct really is packed then use the  parameter of the  attribute to specify that
p67631
as(dp67632
g7
V505088
p67633
stp67634
a((dp67635
g2
(lp67636
VYour Delphi function isn't designed correctly for interop
p67637
aVIf the Delphi function returns a string then you need to agree to use a shared heap so that the callee can allocate the string, and the caller can deallocate it
p67638
aVThe normal way to deal with this is to use COM BSTR, which is wrapped by WideString in Delphi
p67639
aVThis uses the shared COM heap so you can allocate in one module and deallocate in another
p67640
aVIt's not possible to use WideString as a return value for interop since Delphi uses a different ABI from the MS tools for return values
p67641
aVThis is discussed in more detail here: Why can a WideString not be used as a function return value for interop
p67642
aVSo instead you should return the string via an out parameter:
p67643
aVYour C# type library will be able to import that correctly
p67644
as(dp67645
g7
V505088
p67646
stp67647
a((dp67648
g2
(lp67649
VThe easiest way to map from the instruction pointer to unit name and line number is to use one of the various debugging libraries: madExcept, EurekaLog, JclDebug etc
p67650
aVThese tools all rely on the detailed map file that is produced by the linker
p67651
aVAlthough these libraries are best known for producing bug reports from unexpected exceptions, they have all the functionality that you need
p67652
as(dp67653
g7
V505088
p67654
stp67655
a((dp67656
g2
(lp67657
VThe way I handle this is that I have a single project with multiple targets: 32/64 bit, debug/release, etc
p67658
aVEach of those targets is output to a separate directory
p67659
aVFor example,
p67660
aVWhen I prepare the files needed for deployment and installation, I rename the executables at that point
p67661
aVAnd this renaming is needed because I deploy 32 and 64 bit versions to the same directory
p67662
aVNaturally this is all automated
p67663
aVRemy's approach of renaming the output file as a post-build action has the downside that the debugger won't be able to locate an executable
p67664
aVThe philosophy is to fit in with the development environment when working with files that will be used by the IDE
p67665
aVBut then when it comes to deployment, you are free to rename files, re-organise them into a different folder structure etc
p67666
aVthat better suits your deployment needs
p67667
as(dp67668
g7
V505088
p67669
stp67670
a((dp67671
g2
(lp67672
VDeclare the p/invoke like this:
p67673
aVAnd call it like this:
p67674
as(dp67675
g7
V505088
p67676
stp67677
a((dp67678
g2
(lp67679
VSimply put your moving code needs to do this:
p67680
aVWhen the mouse goes down, check if the mouse position is over a control that can be dragged
p67681
aVIf so, then set a variable named  to refer to that control
p67682
aVThis code lives in an  event handler
p67683
aVWhen the mouse moves, if  is not nil, move the control
p67684
aVThis code lives in an  event handler
p67685
aVWhen the mouse goes up, set  to nil
p67686
aVThat's pretty much all there is to it
p67687
aVThe main nuance is that you must also remember the X, Y values of the mouse when the drag commenced
p67688
aVSo in your  handler you write:
p67689
aVAnd then in the  your position code reads:
p67690
aVYou will also need to capture the mouse when you start dragging
p67691
aVThe resizing code is similar
p67692
aVAgain, you need to decide in the  that you are resizing rather than dragging, but the code still involves handling mouse down, move and up events
p67693
aVAs for painting, you need to force a repaint whenever one of your event handlers changes a property that will influence the visual appearance of your form
p67694
aVYou can use the value of  to decide whether or not to use special drawing of your control and indicate that it is being dragged
p67695
aVAnd likewise for resizing
p67696
aVI've not coded up a full working implementation since your question is high level and conceptual
p67697
aVThe implementation is down to you
p67698
as(dp67699
g7
V505088
p67700
stp67701
a((dp67702
g2
(lp67703
VWhen you write:
p67704
aVyou are checking whether the float is zero or not
p67705
aVYour code is equivalent to
p67706
aVThis is perfectly safe to do, and only you can determine whether or not it has the meaning that you require
p67707
as(dp67708
g7
V505088
p67709
stp67710
a((dp67711
g2
(lp67712
VAs I understand your question, you want to extract a single file from a ZIP archive
p67713
aVWhich you do like this:
p67714
aVIf you want to extract the file to a different directory, specify that in the  parameter of
p67715
as(dp67716
g7
V505088
p67717
stp67718
a((dp67719
g2
(lp67720
VThe simplest approach is to read your UTF-8 string into a variable of type UTF8String and then assign to another string variable
p67721
aVYou can assign to an AnsiString if you want, but I don't understand why you would do that
p67722
aVIf you do convert to ANSI, any characters that cannot be represented will be converted to question marks
p67723
aVIf you are desperate to strip non-ASCII characters, read into UTF8String, convert to string, and strip characters > 127
p67724
aVAs I understand it, the standard mandates ASCII but it's common now for EXIF text to be encoded with UTF-8
p67725
aVI suggest you simply read the text into a UTF8String and leave it at that
p67726
aVYour library gives you an AnsiString that actually contains UTF-8 text
p67727
aVSo you can simply convert to UTF8String like this:
p67728
aVNow you will have the text that the file creator intended you to see
p67729
as(dp67730
g7
V505088
p67731
stp67732
a((dp67733
g2
(lp67734
VThe Controls property of a windowed control allows you to obtain every child control
p67735
aVBecause these children can be any TControl descendent, you'll need to cast to TWebBrowser
p67736
aVUse the as operator to benefit from runtime validity checking of the cast:
p67737
as(dp67738
g7
V505088
p67739
stp67740
a((dp67741
g2
(lp67742
VYour code will be safe if you protect all access to shared variables with a critical section (lock)
p67743
aVHowever, if the variables are correctly aligned, do not store references, and no more than pointer sized, then you may be able to avoid using a lock
p67744
aVFor example, if you have an integer which contains a count, then you will not need to use a lock
p67745
aVYour writing thread can safely modify and the reading thread will never suffer from tearing
p67746
aVIf you had multiple writing threads then you would likely need to use a lock, or an interlocked function
p67747
aVIf your variable is a reference, then you likely need to use a lock
p67748
aVIf you have multiple variables that form a compound variable, then again you'll need a lock
p67749
aVThe importance of alignment is that if a variable is misaligned, then the writing of the variable may not be atomic
p67750
aVThe variable may be written in two parts
p67751
aVAnd so the reading thread can read the variable in partially updated state
p67752
aVAlways align variables
p67753
aVIf you refrain from packing records and classes, your variables will be aligned
p67754
aVUltimately I cannot say for sure whether or not your code is safe because you did not show it
p67755
aVA description of code only goes so far
p67756
aVYou really should post your code for a question like this
p67757
as(dp67758
g7
V505088
p67759
stp67760
a((dp67761
g2
(lp67762
VDelphi 7 only supports bmp and jpg out of the box
p67763
aVTo get wider image support you need to use a third party library
p67764
aVI recommend Mike Lischke's GraphicEx: http://www
p67765
aVdelphi-gems
p67766
aVcom/index
p67767
aVphp/libs/graphicex-library
p67768
as(dp67769
g7
V505088
p67770
stp67771
a((dp67772
g2
(lp67773
VYou cannot call SetFocus on a control if its form does not have focus
p67774
aVAnd after the help form has shown, the memo's form no longer has focus
p67775
aVInstead, the help form has the focus
p67776
aVSo set the focus back to the form:
p67777
as(dp67778
g7
V505088
p67779
stp67780
a((dp67781
g2
(lp67782
VYou cannot send messages across session boundaries
p67783
aVSo you need an IPC solution like TCP/IP, sockets, named pipes etc
p67784
as(dp67785
g7
V505088
p67786
stp67787
a((dp67788
g2
(lp67789
VWhat you describe in the question is not consistent with reality
p67790
aVIs this "renaming" not a legal thing to do
p67791
aVExporting the same function under multiple names is perfectly legal
p67792
aVThe problems you describe do not happen
p67793
aVCan I debug DLL with FastMM4 without changing
p67794
aVit into a console app
p67795
aVYes you can
p67796
aVSpecify a host application in the Run parameters dialog and you can debug your DLL
p67797
as(dp67798
g7
V505088
p67799
stp67800
a((dp67801
g2
(lp67802
VSort the data in ascending order
p67803
aVThen pick out the values using the following indices: 0, n-1, 1, n-2,
p67804
aVIn pseudo code the algorithm looks like this:
p67805
as(dp67806
g7
V505088
p67807
stp67808
a((dp67809
g2
(lp67810
VYour type declarations are absolutely fine
p67811
aVYour problem is presumably that when you read an item from the stream, you don't know what type it is
p67812
aVYou cannot use is since you don't have an instance yet
p67813
aVSolve that problem by writing a type code to the stream for each instance
p67814
aVWhen you read from the stream, read the type code and use that to determine which type to instantiate
p67815
aVThis sort of persistence streaming is so much easier using a persistence framework that emits XML, JSON, YAML etc
p67816
as(dp67817
g7
V505088
p67818
stp67819
a((dp67820
g2
(lp67821
VThe  parameter needs to be passed by value rather than by reference:
p67822
aVSome general advice
p67823
aVWhen an API call fails, check the return value
p67824
aVIn this case if the function returns false then call  to find out the error status code
p67825
as(dp67826
g7
V505088
p67827
stp67828
a((dp67829
g2
(lp67830
VI'm sure it could be done more elegantly, but here's what you ask for implemented using a class helper to crack the private members:
p67831
aVInclude this unit in your project and the  class will be patched so that its  method redirects to  and allows you to implement your own  subclass
p67832
aVI don't think the code will work if you are using runtime packages but to sort that out you just need to use more capable hooking code
p67833
as(dp67834
g7
V505088
p67835
stp67836
a((dp67837
g2
(lp67838
VThe only way to answer this question is to time both options, a task which is trivially easy
p67839
aVMaking performance predictions without timing is pointless
p67840
aVSince we don't have your code, only you can answer your question
p67841
as(dp67842
g7
V505088
p67843
stp67844
a((dp67845
g2
(lp67846
VYou can disable themes for an individual control by calling
p67847
aVFor your progress bar, disable the theming like this:
p67848
aVOnce you have disabled the theming, you'll be able to control the colors
p67849
as(dp67850
g7
V505088
p67851
stp67852
a((dp67853
g2
(lp67854
VThe native DLL is allocating the memory for the buffer, and returning the unmanaged pointer in the  field of the struct
p67855
aVAnd so your struct declaration is wrong
p67856
aVYou need the byte array to be declared as a pointer
p67857
aVThe you must call  to copy the buffer's content to a byte array
p67858
aVFor example:
p67859
aVMake sure you call  when you have copied all the buffers
p67860
aVOtherwise you will leak the memory that the native DLL allocated
p67861
aVNote that in the C++ code,  is the struct and  is a pointer to the struct
p67862
aVSo your C# struct should be named
p67863
aVAlso, you do not need to use  to make new instances of a struct
p67864
aVJust declare them like this:
p67865
as(dp67866
g7
V505088
p67867
stp67868
a((dp67869
g2
(lp67870
VWhat you are attempting is impossible
p67871
aVYou cannot implement a Delphi form in C#
p67872
aVThe code that you posted treats the pointer returned by the DLL function as a Delphi form
p67873
aVThe only thing that can implement a Delphi form is code compiled by Delphi
p67874
aVWhat's more, your code is not even valid if the DLL is implemented in Delphi
p67875
aVThat's because the  class in the host executable is not the same as the  class in the DLL
p67876
aVIn order to do what you are attempting to do, with a Delphi DLL, you'd need to pass interfaces across the module boundary
p67877
aVThe bottom line is that your current design for this add-on architecture can never work
p67878
aVYou need to go right back to the drawing board and start again
p67879
as(dp67880
g7
V505088
p67881
stp67882
a((dp67883
g2
(lp67884
VYou can call the Windows API function
p67885
aVAnything that is sent to that function appears in the Event Log window in the IDE (View | Debug Windows | Event Log)
p67886
as(dp67887
g7
V505088
p67888
stp67889
a((dp67890
g2
(lp67891
VDelphi's  is encoded with UTF-16
p67892
aVUTF-16 is a variable length encoding, just like UTF-8
p67893
aVIn other words, a single Unicode code point may require multiple character elements to encode it
p67894
aVAs a point of interest, the only fixed length Unicode encoding is UTF-32
p67895
aVThe UTF-16 encoding uses 16 bit character elements, hence the name
p67896
aVIn a Unicode Delphi,  is an alias for  which is a UTF-16 character element
p67897
aVAnd  is an alias for , which is an array of  elements
p67898
aVThe  function returns the number of elements in the array
p67899
aVSo,  is always 2 for
p67900
aVSome Unicode code points are encoded with multiple character elements, or s
p67901
aVBut  returns the number of characters elements and not the number of code points
p67902
aVThe character elements all have the same size
p67903
aVSo
p67904
aVis correct
p67905
as(dp67906
g7
V505088
p67907
stp67908
a((dp67909
g2
(lp67910
VInterfaces do not support generic parameterized methods, as the compiler says
p67911
aVThere is no workaround because it's a fundamental limitation
p67912
aVParameterized methods in classes are implemented by adding one method per instantiation to the class
p67913
aVThat works for classes since they are concrete, but is not viable for interfaces
p67914
aVThat's because interfaces are a table of functions and the size of that table cannot vary depending on which generic method instantiations happen to be present elsewhere in the code
p67915
aVFor similar reasons, generic methods cannot be virtual or dynamic
p67916
aVThe code in your question is a little mis-leading also
p67917
aVYou wrote:
p67918
aVbut I'm sure you meant:
p67919
aVIn any case, it's not possible
p67920
aVOne option is to use a class instead
p67921
aVI agree that this is a bind
p67922
aVIf you want to do it in an interface, the best you can do is:
p67923
aVBut you'd have to call it like this:
p67924
aVwhich feels somewhat foul
p67925
aVChoose your poison
p67926
as(dp67927
g7
V505088
p67928
stp67929
a((dp67930
g2
(lp67931
VIf the objects overlap, the behaviour of memcpy is undefined
p67932
aVThere's little point in trying to reason about undefined behaviour
p67933
aVSince it is undefined it defies reason
p67934
aVYou know the rules, and they are clearly documented
p67935
aVIf the objects overlap, use memmove
p67936
aVAs for the use of "as if", that is to specify behaviour but not place any limitations on implementation
p67937
aVThis allows the library implementor to use whatever method they see fit, so long as the end result is the same as using an intermediate buffer
p67938
aVFor example, the implementation could detect that the objects do not overlap and so avoid using an intermediate buffer for performance reasons
p67939
as(dp67940
g7
V505088
p67941
stp67942
a((dp67943
g2
(lp67944
VThe key is in this function:
p67945
aVIn some cases, depending on whether or not the host application has a comctl32 v6 manifest, different branches of the  statement are chosen
p67946
aVIf the  branch is chosen, then the ensuing call to  fails with  code
p67947
aVThis is a Win32 error code,
p67948
aVIf the  branch is chosen, then the dialog shows
p67949
aVI'm not sure why  is failing when called from a library initialization block, but I'm not entirely surprised
p67950
aVYou are severely restricted in what can be done from  and you should not be attempting to show dialogs from there
p67951
as(dp67952
g7
V505088
p67953
stp67954
a((dp67955
g2
(lp67956
VWell, for a start, there's no point in
p67957
aVWhat you are looking for is
p67958
aVThat class allows you to supply a file handle whose lifetime you control
p67959
aVAnd if you use  you'll be able to avoid the rather nasty hacks of your variant
p67960
aVThat said, why are you even bothering with a stream
p67961
aVReplace the code that creates and uses the stream with a call to  to seek to the end of the file, and a call to   to write content
p67962
aVHowever, even using that, your proposed solution requires further synchronization
p67963
aVA single windows file handle cannot be used concurrently from multiple threads without synchronisation
p67964
aVYou hint in a comment (should be in the question) that you are serializing file writes
p67965
aVIf so then you are just fine
p67966
as(dp67967
g7
V505088
p67968
stp67969
a((dp67970
g2
(lp67971
VThe documentation states that the returned value for those inputs is
p67972
aVx < 0 but not NegativeInfinity; y is not an integer, NegativeInfinity, or PositiveInfinity: returns NaN
p67973
aVThe reason that  is returned is that the function is not well-defined for your input values
p67974
aVThe Wikipedia article on Exponentiation covers this topic
p67975
as(dp67976
g7
V505088
p67977
stp67978
a((dp67979
g2
(lp67980
VOn a 64 bit system:
p67981
aVThe 64 bit system directory is named
p67982
aVThe 32 bit system directory is named
p67983
aVIf you must copy a DLL into the system directory, make sure that you copy 32 bit DLLs to the 32 bit system directory, and 64 bit DLLs to the 64 bit system directory
p67984
aVThat's essential if you want your application to be able to locate the DLL
p67985
aVSince your code is 32 bit, you need to use the 32 bit DLL
p67986
aVHowever, you should probably place the DLL in the same folder as your executable since the Windows system directory is private and reserved for use by the system
p67987
aVApplications should not modify the system directory
p67988
as(dp67989
g7
V505088
p67990
stp67991
a((dp67992
g2
(lp67993
VYou should be using the combo box with the  style
p67994
aVThat means that only the values that you add to the combo can be selected
p67995
aVIn which case you can read the value you need out of
p67996
aVIf you are using any other style of combo box then the user will be able to input invalid months by typing in the combo
p67997
aVIt doesn't sound as though that's desirable to you
p67998
aVHowever, if for some good reason you do not want to use  then you will need to convert from month text to index, and include a validity check
p67999
aVIf you really do need to do that, then you can simplify matters in comparison to the code in your question by using the code that @bummi provided here: Convert month name to number in Delphi
p68000
aVNote also that your code runs the risk of failing to set
p68001
aVAs a piece of general advice I'd suggest that you always include an  clause in an  statement like that, and that your  clause raises an exception
p68002
aVThat way you will at least discover if, somehow, the month is not being recognised
p68003
as(dp68004
g7
V505088
p68005
stp68006
a((dp68007
g2
(lp68008
VAs suggested by Ken, it's simplest to forget all about JSON and write directly to the blob field
p68009
aVSaving
p68010
aVLoading
p68011
aVYou appear insistent in the comments that JSON is what you need
p68012
aVI'm find that a little hard to believe
p68013
aVBut anyway, to convert from your JSON array, held in a string, to an image, do this:
p68014
aVAlso, to the best of my knowledge, your code that calls  does not work
p68015
aVIt yields an empty JSON array object
p68016
aVFinally, your code was leaking like a sieve
p68017
aVYou are under the mis-apprehension that you don't need to free objects that you create
p68018
aVYou also are mistakenly instantiating objects and then overwriting the new object with a different object, thus leaking the first
p68019
aVTake a look at how I created objects, and compare with your code
p68020
aVFor example:
p68021
aVHere you instantiate a  object and store a reference to that object in
p68022
aVIt is your job to free that reference
p68023
aVBut you immediately abandon that reference in the next line when you overwrite it with the reference to the new object returned by
p68024
aVSince you never free  at all you leak not one, but two objects
p68025
aVYou do need to brush up your basic understanding of Delphi lifetime management
p68026
as(dp68027
g7
V505088
p68028
stp68029
a((dp68030
g2
(lp68031
VThe meaning of  is clearly documented:
p68032
aVPrivate, Protected, and Public Members
p68033
aVA private member is invisible outside of the unit or program where its
p68034
aVclass is declared
p68035
aVIn other words, a private method cannot be called
p68036
aVfrom another module, and a private field or property cannot be read or
p68037
aVwritten to from another module
p68038
aVBy placing related class declarations
p68039
aVin the same module, you can give the classes access to one another's
p68040
aVprivate members without making those members more widely accessible
p68041
aVFor a member to be visible only inside its class, it needs to be
p68042
aVdeclared strict private
p68043
aVA protected member is visible anywhere in the module where its class
p68044
aVis declared and from any descendent class, regardless of the module
p68045
aVwhere the descendent class appears
p68046
aVA protected method can be called,
p68047
aVand a protected field or property read or written to, from the
p68048
aVdefinition of any method belonging to a class that descends from the
p68049
aVone where the protected member is declared
p68050
aVMembers that are intended
p68051
aVfor use only in the implementation of derived classes are usually
p68052
aVprotected
p68053
aVA public member is visible wherever its class can be referenced
p68054
aVStrict Visibility Specifiers
p68055
aVIn addition to private and protected visibility specifiers, the Delphi
p68056
aVcompiler supports additional visibility settings with greater access
p68057
aVconstraints
p68058
aVThese settings are strict private and strict protected
p68059
aVvisibility
p68060
aVThese settings can be used in Win32 applications
p68061
aVClass members with strict private visibility are accessible only
p68062
aVwithin the class in which they are declared
p68063
aVThey are not visible to
p68064
aVprocedures or functions declared within the same unit
p68065
aVClass members
p68066
aVwith strict protected visibility are visible within the class in which
p68067
aVthey are declared, and within any descendent class, regardless of
p68068
aVwhere it is declared
p68069
aVFurthermore, when instance members (those
p68070
aVdeclared without the class or class var keywords) are declared strict
p68071
aVprivate or strict protected, they are inaccessible outside of the
p68072
aVinstance of a class in which they appear
p68073
aVAn instance of a class
p68074
aVcannot access strict protected or strict protected instance members in
p68075
aVother instances of the same class
p68076
aVDelphi's traditional private visibility specifier maps to the CLR's
p68077
aVassembly visibility
p68078
aVDelphi's protected visibility specifier maps to
p68079
aVthe CLR's assembly or family visibility
p68080
aVNote: The word strict is treated as a directive within the context of a class declaration
p68081
aVWithin a class declaration you cannot declare
p68082
aVa member named 'strict', but it is acceptable for use outside of a
p68083
aVclass declaration
p68084
aVYour version of Delphi, Delphi 7, does not support the  specifiers
p68085
as(dp68086
g7
V505088
p68087
stp68088
a((dp68089
g2
(lp68090
VI'm not sure I understand the question
p68091
aVIf you want to know how to write U+FE9F in Delphi source code, in a modern Unicode version of Delphi
p68092
aVDo that simply like so:
p68093
aVIf you want to read individual characters from \u062c\u0628\u0644 then do it like this:
p68094
aVNote that the code above is fine for your particular word because each code point can be encoded with a single UTF-16  character element
p68095
aVIf the code point required multiple elements, then it would be best to transform to UTF-32 for code point level processing
p68096
aVNow, let's look at the string that you included in the question
p68097
aVI downloaded this question using wget and the file that came down the wires was UTF-8 encoded
p68098
aVI used Notepad++ to convert to UTF16-LE and then picked out the three UTF-16 characters of your string
p68099
aVThey are:
p68100
aVU+062C
p68101
aVU+0628
p68102
aVU+0644
p68103
aVYou stated:
p68104
aVThe first letter is \u062c\u0640, name is (\u01e7\u012bm), its Unicode value is U+FE9F
p68105
aVBut that is simply incorrect
p68106
aVAs can be seen from the above, the actual character you posted was U+062C
p68107
aVSo the reason why your attempts to read the first character yield U+062C is that U+062C really is the first character of your string
p68108
aVThe bottom line is that nothing in your Delphi code is transforming your character
p68109
aVWhen you do:
p68110
aVthe compiler performs a simple two byte copy
p68111
aVThere is no context aware transformation that occurs
p68112
aVAnd likewise when reading
p68113
aVLet's look at how these characters are displayed, using this simple code on a VCL forms application that contains a memo control:
p68114
aVThe output looks like this:
p68115
aVAs you can see, the rendering layer knows what to do with a U+062C character that appears at the beginning of the string
p68116
as(dp68117
g7
V505088
p68118
stp68119
a((dp68120
g2
(lp68121
VThis code
p68122
aVworks perfectly
p68123
aVI tested by looking at the drop-down effect of a combo box
p68124
aVWhen  is  then the combo's list appears instantly
p68125
aVWhen  is  then the combo's list slides down
p68126
aVMost likely you are looking at a control which is not painted by the system and that control is ignoring this option
p68127
as(dp68128
g7
V505088
p68129
stp68130
a((dp68131
g2
(lp68132
VYour call to  returns a void pointer
p68133
aVYou cannot de-reference that without a cast
p68134
aVBut I don't think that's the correct solution
p68135
aVYou should change  so that it returns
p68136
as(dp68137
g7
V505088
p68138
stp68139
a((dp68140
g2
(lp68141
VIf we are talking about unmanaged DLLs, declare the p/invokes like this:
p68142
aVNote that we are not specifying a path to the DLL, just its name, which I presume is the same for both 32 and 64 bit versions
p68143
aVThen, before you call any of your p/invokes, load the library into your process
p68144
aVDo that by p/invoking to the  API function
p68145
aVAt this point you will determine whether your process is 32 or 64 bit and build the full path to the DLL accordingly
p68146
aVThat full path is what you pass to
p68147
aVNow, when you call your p/invokes for the library, they will be resolved by the module that you have just loaded
p68148
aVFor managed assemblies then you can use  to specify the path of the assembly
p68149
aVThis can be a little tricky to orchestrate, but this excellent article shows you how: Automatically Choose 32 or 64 Bit Mixed Mode DLLs
p68150
aVThere are a lot of details relating to mixed mode and the native DLL dependencies that are probably not relevant to you
p68151
aVThe key is the  event handler
p68152
as(dp68153
g7
V505088
p68154
stp68155
a((dp68156
g2
(lp68157
VI do not want it to show the break cancel or continue options
p68158
aVThat's not something that you change in code
p68159
aVYou need to change your debugger options to effect that change
p68160
aVYou can stop all exceptions from provoking the break/continue dialog by unchecking the Notify on language exceptions option on the Language Exceptions page of the debugger options dialog
p68161
aVOr if you want to be a bit cuter, you can choose to ignore certain classes of exception
p68162
aVAgain, from the Language Exceptions page of the debugger options dialog, add your exception classes to the list
p68163
aVOr, on the break/continue dialog, check the Ignore this exception type and press continue
p68164
aVWhen you have asked for an exception type to be ignore, you'll no longer see the break/continue dialog for that exception class, or its subclasses
p68165
aVI'm trying to raise an exception for my button
p68166
aVWell, not in the code that you showed
p68167
aVIf you want to raise an exception, well, you can simply do that:
p68168
aVOr, if you want to show a message box, do so
p68169
aVI suspect that you are trying to show this code
p68170
aVfrom running when it is going to raise an exception
p68171
aVThere are a few ways that you can do that:
p68172
aVDisable the button that has the call to  behind it, if you know it is going to raise an exception
p68173
aVDon't call  if you know it is going to raise an exception
p68174
aVLet  be called, but detect the error condition, show an error dialog, and then call
p68175
aVYou'd have to do this in code that runs before the form actually shows, so perhaps you could add a method to the form that would call  only if the form was in a state to show
p68176
aVThis would allow you to move the decision closer to the code that knows about the reason behind the decision
p68177
aVFinally, your variables, types and methods can all be given names
p68178
aVYou must start doing so because it's hopeless trying to program with entities that are numbered rather than named
p68179
aVWhat's more, you should stop using the global variables containing references to forms that the IDE provides for you
p68180
aVI wish the IDE would stop doing that because it's a terrible practice
p68181
aVCreate instances when you need them, and don't use global variables where they are not appropriate
p68182
as(dp68183
g7
V505088
p68184
stp68185
a((dp68186
g2
(lp68187
VList of index out of bound(0)
p68188
aVThis means that you attempted to reference index 0 of the list, but there is no element at index 0
p68189
aVIn other words, your list is empty
p68190
aVThe only place in the code that I can see which could lead to that error is where you read items from
p68191
aVSo, I conclude that  is empty
p68192
aVEither the file you loaded it from is not present, or that file is empty
p68193
aVAt this point in the code
p68194
aVyou need to do more than silently ignore the missing file
p68195
aVPersonally I would remove the check for  and attempt to load the file no matter what
p68196
aVIf it fails to load, your application will raise an exception to that effect
p68197
aVYou should also add a check that the dictionary is not empty
p68198
aVYour program assumes that the working directory of your process is the same directory as contains the executable
p68199
aVThat may not always be the case
p68200
aVInstead of using relative paths, always a brittle affair for GUI programs, specify the full path to the dictionary file:
p68201
aVYou have a number of booleans:
p68202
aVThese should all be replaced by an enumerated type:
p68203
aVor something along those lines
p68204
aVDeclare a field  and initialise to
p68205
aVEvery time the user guesses wrong, write
p68206
aVWhen you reach , well you get the idea
p68207
aVThe point is that there is a total order on the state and all those booleans provide you more flexibility than is possible to have
p68208
aVIt also leads to verbose and awkward code
p68209
as(dp68210
g7
V505088
p68211
stp68212
a((dp68213
g2
(lp68214
VYou give an example of your two numbers
p68215
aV353
p68216
aV58
p68217
aV353
p68218
aV59
p68219
aVThese numbers cannot be exactly represented in binary floating point format
p68220
aVAlso, the value  cannot be exactly represented in binary floating point format
p68221
aVPlease read What Every Computer Scientist Should Know About Floating-Point Arithmetic
p68222
aVSo, for example, when you try to represent  as a , there is no  with that value and you get the closest float value which happens to be 353
p68223
aV579986572265625
p68224
aVIn my view you are using the wrong data type to represent these values
p68225
aVYou need to be using a decimal format
p68226
aVThat will allow you to represent these values exactly
p68227
aVIn C# you use the  type
p68228
aVThen you can write:
p68229
aVUse  or  to convert from your textual representation of the number into a  value
p68230
as(dp68231
g7
V505088
p68232
stp68233
a((dp68234
g2
(lp68235
V works correctly when passed
p68236
aVThe fact that it returns  indicates that there are no text files in the directory above your working directory
p68237
as(dp68238
g7
V505088
p68239
stp68240
a((dp68241
g2
(lp68242
VThe simplest solution is to change the declaration on the managed side of the interface
p68243
aVChange the name of either the struct or the field
p68244
aVIf you don't want to do that, you'll need to make the change in your C++ code
p68245
aVFor example:
p68246
aVYou'll need to stop automatically generating the header file every time you build and switch to manual generation
p68247
aVIt seems to me that, since you control both sides of the interface, changing the C# code is by far the simplest solution
p68248
as(dp68249
g7
V505088
p68250
stp68251
a((dp68252
g2
(lp68253
VIt looks like you've configured your virus scanner to remove the compiled executable that the linker emits
p68254
aVAnd it looks like the virus scanner is doing so every time you regenerate the executable
p68255
aVThe solution is to find the option in your virus scanner to stop it deleting that file
p68256
as(dp68257
g7
V505088
p68258
stp68259
a((dp68260
g2
(lp68261
VI retrieve the first character of the message, not all the content
p68262
aVThis indicates that the string is encoded as UTF-16 and it can be seen from the C# code that generates the message that the data you send is UTF-16 encoded
p68263
aVOn the other hand, your C code treats it as being 8 bit ANSI encoded
p68264
aVAnd that's why the C code fails to read it correctly
p68265
aVIf your C code treats it as UTF-16 then you'll get all the content
p68266
aVYou must not assume that the string is null-terminated and should use  to avoid buffer overruns
p68267
aVSo you can change your C code to be like so:
p68268
aVNote that  will treat the input as a UTF-16 encoded string, and will print no more than  characters
p68269
aVI'm also assuming that you are using Microsoft's tools, because the  format type is a non-standard Microsoft special
p68270
aVIf you want to be portable then there are ways to do that, but I'm not sure you are quite ready to tackle that issue
p68271
as(dp68272
g7
V505088
p68273
stp68274
a((dp68275
g2
(lp68276
VYou are expected to use variable capture for this
p68277
aVIn case you are not familiar with variable capture for anonymous methods, it's discussed in some detail in the documentation
p68278
as(dp68279
g7
V505088
p68280
stp68281
a((dp68282
g2
(lp68283
VIs there a way in delphi to determine in which folder the batch file is which called the
p68284
aVexe
p68285
aVThat depends
p68286
aVIf you know that the batch file lives in the parent directory of the directory which contains the executable, then you can do this:
p68287
aVOn the other hand, if you have no special knowledge of where the batch file lives in relation to the executable, then there's no easy way to work out where it is
p68288
aVYou can't expect to work it out from the working directory since that could, in general, be a directory other than the one containing the batch file
p68289
aVSo, if you do not control the batch file, then you can't expect to locate it easily and reliably
p68290
aVWhat's more, I'm not sure how you can be sure that there even is a batch file
p68291
aVThe program could presumably be started by some other mechanism
p68292
as(dp68293
g7
V505088
p68294
stp68295
a((dp68296
g2
(lp68297
VProbably the easiest way is to call the API functions  and  directly
p68298
aVThese will, unless you use some of the more esoteric functionality, show the modern dialogs on Vista and up
p68299
aVObviously you'll need to call the W variants, and pass the W versions of the structs
p68300
aVHere's the simplest example I can construct:
p68301
aVNaturally you can expand this to have more functionality
p68302
as(dp68303
g7
V505088
p68304
stp68305
a((dp68306
g2
(lp68307
VFor a basic example, allocate the  array of a  object like this:
p68308
aVAnd to deallocate:
p68309
aVBut you'll probably need to allocate the  objects dynamically too
p68310
aVAnd then you'll populate in a loop:
p68311
aVAnd to deallocate:
p68312
aVYou'll also want to populate the rest of the fields, but I'll concentrate on the allocation and leave that to you
p68313
aVIn real code you'll want to check the return values of your calls to  for errors, and respond accordingly
p68314
aVReallocation is a little more tricky
p68315
aVSuppose that you want to change the length of the  array in a  object
p68316
aVAt this point I think you need to start wrapping things up in functions
p68317
aVThis gets more tricky when you are reallocating an array that contains elements that also have dynamic memory allocated
p68318
aVYou need to make sure that you  any such nested dynamically allocated memory before you reallocate the parent array
p68319
as(dp68320
g7
V505088
p68321
stp68322
a((dp68323
g2
(lp68324
VWhen writing interop code it is critical that both sides of the interface match in every way
p68325
aVHere are the main issues that you must make agree on both sides:
p68326
aVCalling conventions
p68327
aVParameters lists
p68328
aVParameter types and semantics
p68329
aVThe first observation is that your calling conventions do not match
p68330
aVYou have  on the Delphi side and  on the C# side
p68331
aVThe Delphi  convention is private to Delphi and so you should use
p68332
aVSecondly, your string parameter types do not match
p68333
aVThe Delphi  is a data type that became legacy when Delphi 2 was released and should be considered a relic from the previous century
p68334
aVIt was never a valid interop type, and there's nothing in the p/invoke framework that can be used to match it
p68335
aVWhilst you could attempt to do the marshalling by hand, this is a lot of work that is simply not needed when there are simple solutions available
p68336
aVYou should try to forget all about
p68337
aVYou need to use a string type that both sides of the interface can work with
p68338
aVYou could use null-terminated C strings, but a better and simpler choice is the COM  which is  in Delphi
p68339
aVSo, the final result is as follows
p68340
aVDelphi
p68341
aVC#
p68342
aVI did not bother specifying the calling convention on the  since the default is
p68343
aVIf you prefer you can be explicit about this
p68344
aVBe careful when using  that you don't attempt to use it as a return value
p68345
aVBecause Delphi uses non-standard semantics for return values, you can only use simple types that fit into a register as return values
p68346
as(dp68347
g7
V505088
p68348
stp68349
a((dp68350
g2
(lp68351
VHow to trace such 0x0eedfade exception
p68352
aVThis is the code for a Delphi exception
p68353
aVClearly you are raising a Delphi exception that is not being handled and that is bringing your process down
p68354
aVYou should add madExcept, EurekaLog, JCLDebug or similar to your process
p68355
aVThese tools will produce diagnostics reports when your process fails
p68356
aVThe most useful part of those reports will be the stack trace at the point of failure
p68357
aVYou should be able then to work out where the failure occurs, at the very least, and this usually is enough to work out what is wrong with your code
p68358
as(dp68359
g7
V505088
p68360
stp68361
a((dp68362
g2
(lp68363
VYou are relying on the shell's associations to print the file, but that's a terribly brittle approach
p68364
aVIf you right click on the file and select Print you'll observe the same behaviour as your call to
p68365
aVSo, if you want to use  with the Print verb you will need to change your machine's configuration
p68366
aVYou need to make sure that the machine's associations are configured to handle the Print verb on a
p68367
aVhtml file in a way that suits you
p68368
aVYou could do that for your machine but you cannot expect to do it for other people's machines
p68369
aVInstead you could run this command to be sure that the HTML file will be printed:
p68370
aVYou can translate that readily into a  call
p68371
as(dp68372
g7
V505088
p68373
stp68374
a((dp68375
g2
(lp68376
VYour design does not work and this can be seen even without any understanding of what  does
p68377
aVIn fact, irrespective of the meaning of , your code is broken
p68378
aVTo see this, consider two threads arriving at the  statement in  at the same time
p68379
aVLet's consider the three options for which branches they take:
p68380
aVThey both choose the second branch
p68381
aVThen you create two instances and your code no longer implements a singleton
p68382
aVThey both choose the first branch
p68383
aVThen you never create an instance
p68384
aVOne choose the first and the other chooses the second
p68385
aVBut since there is no lock in the first branch, the thread that takes that route can read  before the other thread has written it
p68386
aVPersonally I'd use double-checked locking if I had to implement your  function
p68387
as(dp68388
g7
V505088
p68389
stp68390
a((dp68391
g2
(lp68392
VFrom the documentation:
p68393
aVThe LoadCursor function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource
p68394
as(dp68395
g7
V505088
p68396
stp68397
a((dp68398
g2
(lp68399
VThis boils down to the fact that  statements are processed sequentially
p68400
aVAs soon as a condition that evaluates to  is encountered, the other  clauses are skipped
p68401
aVSuppose that  and  are both
p68402
aVWhen you write
p68403
aVyou do not execute both  and
p68404
aVSince  is ,  executes and  is not even evaluated
p68405
aVNow consider your problem
p68406
aVConsider the number 15
p68407
aVAll three candidate divisors, 3, 5 and 15, divide into that number
p68408
aVSince the multiples of  are also multiples of  (and ), you will never even reach the  test for multiples of
p68409
as(dp68410
g7
V505088
p68411
stp68412
a((dp68413
g2
(lp68414
VThere is only one single unique process ID for a process
p68415
aVBut Spy++ is reporting the value as hexadecimal, and task manager reports it as decimal
p68416
aVNow, A48 (hexadecimal) is equal to 2632 (decimal)
p68417
aVThe other value, 1744, is a thread ID
p68418
aVThat is the ID of a different object
p68419
aVThreads and processes are not the same things
p68420
aVA process contains one or more threads
p68421
aVWhen you call  it returns the window's thread ID as the return value of the function
p68422
aVThe second parameter can be used to return the process ID of the process that owns the thread
p68423
aVCall it like this:
p68424
aVAfter the function returns,  contains the process ID
p68425
aVYou are trying to install a hook and need a thread ID for that
p68426
aVIn your code use the variable
p68427
as(dp68428
g7
V505088
p68429
stp68430
a((dp68431
g2
(lp68432
VNeither really does the trick
p68433
aVThe first won't detect EOF, and the second moves the file pointer which I guess is not what you want
p68434
aVYou should read the file pointer by calling  with a "move method" of  and a distance of zero
p68435
aVAnd compare that against the file size, obtained by calling
p68436
as(dp68437
g7
V505088
p68438
stp68439
a((dp68440
g2
(lp68441
V is a big endian unsigned two byte value
p68442
aVIn Delphi you would do this:
p68443
aVLet's look at this in more detail:
p68444
aVis an array of bytes and so  is the value you are trying to unpack
p68445
aVconverts from network byte order (big endian) to host byte order
p68446
aVSince the parameter of  is a , we need to treat  as a word and hence the cast
p68447
aVIn order to call  you'll need to use the  unit
p68448
as(dp68449
g7
V505088
p68450
stp68451
a((dp68452
g2
(lp68453
VIt's perfectly fine in a VCL application to follow the MSDN advice and set SEM_ FAILCRITICALERRORS at startup
p68454
as(dp68455
g7
V505088
p68456
stp68457
a((dp68458
g2
(lp68459
VDynamic arrays are not objects, classes or records
p68460
aVThey do not have methods defined on them
p68461
aVInstead of
p68462
aVyou must write
p68463
aVAnd likewise for
p68464
aVNext up,  is a type
p68465
aVIf you want to make a new one, you use the helper function
p68466
aVThen you assign to , but surely you mean to assign to
p68467
aVFinally, there's no need to introduce a local variable, and then assign  that local variable
p68468
aVYou can do all the work directly on
p68469
aVSo, I'd write the code like this:
p68470
as(dp68471
g7
V505088
p68472
stp68473
a((dp68474
g2
(lp68475
VIf you don't tell ctypes what type the parameters are, it attempts to infer it from the values that you pass to the function
p68476
aVAnd this inference will not always work as you need
p68477
aVThe recommended way to deal with this is to set the  attribute of the function and so explicitly tell  what the parameter types are
p68478
aVThen you can call the function like this:
p68479
as(dp68480
g7
V505088
p68481
stp68482
a((dp68483
g2
(lp68484
VYou cannot call that function from C#
p68485
aVThat's because you cannot use Delphi  for interop
p68486
aVYou can use  for strings passed from managed to unmanaged, but in the other direction it's more complex
p68487
aVYou'd need to allocate the memory at the caller, or use a shared heap
p68488
aVI prefer the latter approach which is easiest done with the COM
p68489
aVThis is  in Delphi
p68490
aVAs has been discussed before, you cannot use  as a return value for interop, since Delphi uses a different ABI from MS tools for return values
p68491
aVThe Delphi code needs to look like this:
p68492
aVOn the C# side you write it like this:
p68493
aVIf you want Unicode for the URL then use  and
p68494
as(dp68495
g7
V505088
p68496
stp68497
a((dp68498
g2
(lp68499
VIgnoring the fact that you are copying an uninitialized value, I think you've got the wrong end of the stick regarding assignment
p68500
aVAssignment is meant to be performed using the assignment operator
p68501
aVAssignment is a central part of the language and so the designers provided a first class operator to perform it
p68502
aVUse that operator, =, to perform assignment
p68503
aVIn many cases you can perform assignment using memcpy but why would you want to
p68504
aVIt's much more verbose and it's completely opaque to the reader
p68505
aVYou would never replace
p68506
aVwith a call to memcpy
p68507
aVBottom line, perform assignment using the = assignment operator
p68508
as(dp68509
g7
V505088
p68510
stp68511
a((dp68512
g2
(lp68513
VThe documentation says:
p68514
aVIf the user selects a folder that
p68515
aVdoes not have a physical path (for example, My Computer),
p68516
aVthe OK button on the dialog box will be disabled
p68517
aVYou ask:
p68518
aVIs there any way to enable the OK button for My Computer
p68519
aVThere is not
p68520
as(dp68521
g7
V505088
p68522
stp68523
a((dp68524
g2
(lp68525
VThere's no problem with having up to 20 timers active at one time in an application
p68526
aVModern hardware is more than capable of handling that
p68527
aVRemember also that timer messages are low priority messages and so are only synthesised when the message queue is empty
p68528
aVSo, you need to keep the message queues of your threads serviced promptly in order for the messages to be delivered in a timely manner
p68529
aVA bigger problem for you is that you cannot create  instances outside the GUI/VCL thread
p68530
aVThat's because the timer component calls  which is not thread safe and can only be called from the GUI/VCL thread
p68531
aVSo, you'll need to interact with the raw Win32 timer API directly and not use the VCL  wrapper
p68532
as(dp68533
g7
V505088
p68534
stp68535
a((dp68536
g2
(lp68537
VThe error that the system is returning to you is
p68538
aVAlthough you have not stated what extension  has, it seems likely that it is not
p68539
aVWere you to rename the downloaded file to have extension , then the call to  would succeed
p68540
aVThat's the hacky way to do it
p68541
aVThe cleaner way is to use the  member of the  struct to specify that you want the file to be treated as an executable
p68542
aVYou can do that by adding the following to your code:
p68543
aVI'd write your code like this:
p68544
aVNote the zero initialization so that we can omit explicit assignment for members that should be
p68545
as(dp68546
g7
V505088
p68547
stp68548
a((dp68549
g2
(lp68550
VYou need to modify the error mode of the other process
p68551
aVIf you control the code of the other process, call  and adding the  option to the error mode
p68552
aVYou should make this call as soon as the process begins execution
p68553
aVThe documentation on MSDN even discusses the very issue that you have encountered:
p68554
aVBest practice is that all applications call the process-wide SetErrorMode function with a parameter of SEM_FAILCRITICALERRORS at startup
p68555
aVThis is to prevent error mode dialogs from hanging the application
p68556
aVIf you cannot control the code in the other process, then you can set the error mode in your process
p68557
aVThat will have the desired effect because a child process inherits the error mode of its parent process
p68558
as(dp68559
g7
V505088
p68560
stp68561
a((dp68562
g2
(lp68563
VYou can use Live Bindings to evaluate expressions
p68564
aVHere's a trivial example:
p68565
aVNote, I've intentionally omitted the code to free objects and so this code leaks
p68566
aVI chose to do that so we could concentrate on the expression evaluation aspect
p68567
as(dp68568
g7
V505088
p68569
stp68570
a((dp68571
g2
(lp68572
VI think the simplest solution is to use
p68573
aVHere's a very simple example:
p68574
as(dp68575
g7
V505088
p68576
stp68577
a((dp68578
g2
(lp68579
VMinimizing an MDI child window changes the order in which the forms appear in
p68580
aVThis indexed property always returns the active MDI child in
p68581
aVSo, the cleanest way to do what you want is to take a copy of all the forms first, and then start minimizing
p68582
as(dp68583
g7
V505088
p68584
stp68585
a((dp68586
g2
(lp68587
VIn your timer you load every single image, overwriting each image with the next until the loop terminates
p68588
aVAt which point image  remains
p68589
aVYou need to keep track of some state that persists between each execution of the timer event
p68590
aVDeclare a field in  named  of type
p68591
aVThen make your timer like so:
p68592
aVIf you have code that stops and starts the slideshow then you'll likely want to re-initialise  each time you start
p68593
as(dp68594
g7
V505088
p68595
stp68596
a((dp68597
g2
(lp68598
VLike this:
p68599
aVIn order for this to work, the file  must be located in the working directory when you call
p68600
aVIf you cannot ensure that then pass the full path to the
p68601
aVjar file
p68602
as(dp68603
g7
V505088
p68604
stp68605
a((dp68606
g2
(lp68607
VIn previous versions of Windows, a 3GB Address Space meant the application was given 0x00000000 to 0xBFFFFFFF, and the OS used 0xC0000000 to 0xFFFFFFFF (see Richter's Programming Applications for Windows or Solomon and Russinovich's Windows Internals)
p68608
aVIn principal, I believe that means I have the theoretical space
p68609
aVNothing has changed in Windows 8
p68610
aVWhat you stated is still true
p68611
aVIn order, on a 32 bit system, to be able to reserve a 2GB block of memory you need at least the following to be true:
p68612
aVYour process is large address aware
p68613
aVYour system is booted with the /3GB switch
p68614
aVThe virtual address space of your process has an unreserved range of addresses that is 2GB in size
p68615
aVIt's easy enough to arrange for the first two conditions to hold, but the third condition is harder to control
p68616
aVYou should not assume that your process will be able to find a 2GB contiguous range of address space in a 32 bit process
p68617
aVThat's an unrealistic expectation
p68618
aVIf your test system is a 64 bit system then you should consider testing on  32 bit system also
p68619
aVFor example, on a 64 bit system there is no /3GB boot option and all large address aware 32 bit processes have a 4GB address space
p68620
aVOf course, you are still subject to item 3 on my list
p68621
as(dp68622
g7
V505088
p68623
stp68624
a((dp68625
g2
(lp68626
VThere is no way to insert items at the front of an
p68627
aVYou have to make a new instance
p68628
as(dp68629
g7
V505088
p68630
stp68631
a((dp68632
g2
(lp68633
VAccording to your comments, the problem is the second parameter, and specifically the open array that  receives
p68634
aVAccording to the documentation, the  macro could be helpful
p68635
aVYou'd call  like this:
p68636
aVSo the call to  will become:
p68637
as(dp68638
g7
V505088
p68639
stp68640
a((dp68641
g2
(lp68642
VThe intended way for you to do this is to handle the  message and tell the Window manager that the edit control does not want to handle the TAB key
p68643
aVRaymond Chen covers this very issue in this article: Those who do not understand the dialog manager are doomed to reimplement it, badly
p68644
aVAs often the case with Raymond, quite a provocative title to the article
p68645
aVThe code sample from the article looks like this:
p68646
as(dp68647
g7
V505088
p68648
stp68649
a((dp68650
g2
(lp68651
VFile->New->Project to show this dialog:
p68652
aVThen select Dynamic Link Library and away you go
p68653
as(dp68654
g7
V505088
p68655
stp68656
a((dp68657
g2
(lp68658
VThe Delphi  control provides no such event, and the underlying Windows control does not provide a notification
p68659
aVThe reason for that is that you the programmer are in charge of adding columns
p68660
aVColumns can only be added by calling  in Delphi, or by sending a  message to the underlying window
p68661
aVSo, you are in charge of adding columns, which presumably you do by calling
p68662
aVRoute all code that adds columns through a method that calls , and add any special handling at that point
p68663
as(dp68664
g7
V505088
p68665
stp68666
a((dp68667
g2
(lp68668
VFor all of the compilers that you mention, 64 bit integer types exist for both 32 and 64 bit targets
p68669
aVHowever, there are no 128 bit integer types
p68670
aVSo,  evaluates to 64 for all of the listed compilers, and for both 32 and 64 bit targets
p68671
aVThe best you can do is probably to use the SSE2 intrinsic  but that depends on the presence of an SSE2 unit on the processor
p68672
aVBut you don't need to upgrade to be able to use that
p68673
aVIt's available in VS2008 also
p68674
as(dp68675
g7
V505088
p68676
stp68677
a((dp68678
g2
(lp68679
VAccording to your comments, you want to run this code:
p68680
aVwhenever anything changes that you wish to affect the layout of your groups
p68681
aVSo I think you need to call this function from the following events:
p68682
aVThe  event of the form
p68683
aVThe  event of the
p68684
aVThe  and  events of the two category panels
p68685
aVThat looks a bit weird though when one panel is collapsed, and the other is expanded
p68686
aVPersonally I'd rejig the code to fill all available space
p68687
as(dp68688
g7
V505088
p68689
stp68690
a((dp68691
g2
(lp68692
VWere this to even be possible, you'd need to ensure that  was in scope
p68693
aVAnd that would mean putting it inside the  statement
p68694
aVSo you'd write this:
p68695
aVBut that does not work because you are not allowed to assign to the pointer
p68696
aVIt is, after all, fixed
p68697
aVIf you attempt to assign to a fixed pointer the compiler objects:
p68698
aVerror CS1656: Cannot assign to 'chRef' because it is a 'fixed variable'
p68699
aVEven if you could do this, which you cannot, there would be no point
p68700
aVSince  is about to leave scope, it would make no sense to modify it when you know that nothing could ever observe that modification
p68701
as(dp68702
g7
V505088
p68703
stp68704
a((dp68705
g2
(lp68706
VWhy do the files have different size
p68707
aVBecause they use different encodings
p68708
aVThe 1251 encoding maps each character to a single byte
p68709
aVBut UTF-8 uses variable numbers of bytes for each character
p68710
aVHow do I get the true file contents
p68711
aVYou need to use a string type that matches the encoding used in the file
p68712
aVSo, for example, if the content is UTF-8 encoded, which is the best choice, then you load the content into a UTF-8 string
p68713
aVYou are using FPC in a mode where  is UTF-8 encoded
p68714
aVIn which case the code in the question is what you need
p68715
aVLoading an MBCS encoded file with a code page of 1251, say, is more tricky
p68716
aVYou can load that into an  variable and so long as your system's locale is 1251 then any conversions will be performed correctly
p68717
aVBut the code will behave differently when run on a machine with a different locale
p68718
aVAnd if you wanted to load text using different MBCS encodings, for example 1252, then you cannot use this approach
p68719
aVYou would need to load into a byte array and then convert from 1252, say, to UTF-8 so that you could then store that UTF-8 in a  variable
p68720
aVIn order to do that you can use the  unit from LCL
p68721
aVFor example, you can use ,  etc
p68722
aVto convert from MBCS to UTF-8
p68723
aVHow can I determine from the file what encoding is used
p68724
aVYou cannot
p68725
aVYou can make a guess that will be accurate in many cases
p68726
aVBut in general, it is simply impossible to identify the encoding of an array of bytes that is meant to represent text
p68727
aVIt is sometimes possible to take a file and rule out certain encodings
p68728
aVFor example, not all byte streams are valid UTF-8 or UTF-16 text
p68729
aVAnd so you can rule out such files
p68730
aVBut for encodings like 1251, 1252 etc
p68731
aVthen any byte stream is valid
p68732
aVThere's simply no way for you to tell 1251 encoded streams apart from 1252 encoded streams with 100% accuracy
p68733
aVThe  unit has  which sounds like it may be of some use
p68734
as(dp68735
g7
V505088
p68736
stp68737
a((dp68738
g2
(lp68739
VCall  or  or  passing one of the  protection flags
p68740
aVThe  function is used for file mappings and so  is the closest Windows analogue
p68741
as(dp68742
g7
V505088
p68743
stp68744
a((dp68745
g2
(lp68746
VI'd p/invoke it like this:
p68747
aVYou need to specify that the character set is  since the C code receives
p68748
aVYou don't need to specify the calling convention since the default is  which matches the native code
p68749
as(dp68750
g7
V505088
p68751
stp68752
a((dp68753
g2
(lp68754
VThe presence of  suggests that your task is close to impossible
p68755
aVThat DLL is used to allow different modules (e
p68756
ag217
aVan executable and a DLL) to share a common Delphi memory manager
p68757
aVThis allows for one module, the executable say, to allocate a Delphi string, and pass it to the other module, the DLL say, which in turn can deallocate the string
p68758
aVUnless both modules share the same heap, such an architecture cannot work
p68759
aVThe  library makes heap sharing across modules possible
p68760
aVAny DLL that wishes to use the Delphi memory manager of its host includes the  unit which in turn uses the  library to effect memory manager sharing
p68761
aVNow, your Fortran host cannot possibly meet the required contract
p68762
aVThe only thing that can provide a Delphi memory manager is a Delphi host
p68763
aVWhat will be happening is that the DLL you call believes that it is responsible for freeing the memory that it is passed
p68764
aVThe DLL probably receives Delphi  variables which are heap allocated
p68765
aVWhen the DLL attempts to free memory, that memory was allocated in your Fortran host process
p68766
aVAnd that mismatch is likely what is leading to access violations
p68767
aVThese will not necessarily occur every time you call the function
p68768
aVThe design of this DLL, to use  is reasonable provided that it was expected only to be called from a Delphi host
p68769
aVIf the developer of the DLL knew what they were doing then they would have been aware of that restriction
p68770
aVThe fact that you have got no documentation for the DLL suggests to me that you've extracted the DLL from another program and are trying to use it in a way in which it was not designed
p68771
aVYour chances of success are exceptionally low
p68772
as(dp68773
g7
V505088
p68774
stp68775
a((dp68776
g2
(lp68777
VIs there any PRNG library which support store and restore of sequencing state
p68778
aVAll good PRNG libraries allow you to store and restore their state
p68779
as(dp68780
g7
V505088
p68781
stp68782
a((dp68783
g2
(lp68784
VYour code which copies between the managed array, and the unmanaged pointer, is in the wrong place
p68785
aVIt would need to be after the call to the unmanaged function
p68786
aVBut you may as well let the p/invoke marshaller do the work for you:
p68787
aVBecause a byte array is blittable then the marshaller will just pin your array during the call and hand it off to the native code
p68788
aVI'm assuming that the other two parameters are passed correctly
p68789
aVSince you did not specify any more details of the interface, they could well be wrong
p68790
aVI'd guess that  is used to tell the function how big the buffer is, and to return how much was copied to it by the function
p68791
aVI cannot see where you specify  in the question
p68792
aVI'm trusting that you got that bit right
p68793
aVSome other comments:
p68794
aVYou may need to specify a calling convention in the  attribute
p68795
aVIs the native code  perhaps
p68796
aVThe return value is  in the native code but you've mapped it to
p68797
aVThat probably is fine if the protocol is that non-zero return means success
p68798
aVBut if the return value indicates more than that then you'd clearly need to use
p68799
aVPersonally I'd be inclined to use  and stay true to the native
p68800
as(dp68801
g7
V505088
p68802
stp68803
a((dp68804
g2
(lp68805
VDo I really need to create memory objects to insert string values and pass them through methods for retrieval, or is this just unique to the Delphi handler
p68806
aVThe author of the Delphi code is best placed to explain why it was done in that particular way
p68807
aVHowever, it looks to me as though  is an external function since it was declared using
p68808
aVAnd so the author will have needed to come up with a solid means to marshal text data across a module boundary
p68809
aVThe author chose to use the COM  interface which is a perfectly reasonable choice
p68810
aVIn order to interact with that from Delphi, the author needed to use an object that implements
p68811
aVThe simplest way is to use the  class which wraps a  and presents an  interface
p68812
aVIn order to use that, a concrete stream must be provided
p68813
aVHence the use of
p68814
aVClearly  must return the URL somewhere and why not a memory stream
p68815
aVAnyway, that's my best guess as to why the Delphi code is that way
p68816
aVThere's no evidence that memory streams are needed to implement IIS handlers (whatever they are)
p68817
aVI think you are getting all hung up on replicating the Delphi implementation
p68818
aVIn your shoes I would simply try to understand what the underlying requirements are
p68819
aVWhat is your IIS handler required to do
p68820
aVThen implement that using the idiomatic C# techniques and classes
p68821
aVUse the extant Delphi code as a guide of what the requirement is, but not as a guide for how to implement that requirement
p68822
as(dp68823
g7
V505088
p68824
stp68825
a((dp68826
g2
(lp68827
VYou are talking about pre-ANSI C, and the style of prototype known as K&R; prototypes
p68828
aVFor such  function declarations, parameters and return values whose types are not specified are deemed to be of type
p68829
as(dp68830
g7
V505088
p68831
stp68832
a((dp68833
g2
(lp68834
VYou can indeed use
p68835
aVAll you need is:
p68836
aVThis program illustrates:
p68837
aVOutput
p68838
aVFalse
p68839
aVTrue
p68840
as(dp68841
g7
V505088
p68842
stp68843
a((dp68844
g2
(lp68845
VIt seems that the issue is that COM is not being initialized
p68846
aVThis normally happens in  because of the initialization procedure that is added by using
p68847
aVBut you report in a comment that  is  inside  which indicates that  is not included in your project
p68848
aVSo, you can solve the issue readily by including  in your project
p68849
aVOr if you want to be explicit about it, just call  at the very start of your
p68850
aVdpr file
p68851
as(dp68852
g7
V505088
p68853
stp68854
a((dp68855
g2
(lp68856
VYou are performing the arithmetic using integer operations
p68857
aVThis expression:
p68858
aVis evaluated using integer arithmetic because the operands are all integers
p68859
aVAnd so it evaluates to  and then when you convert to float with
p68860
aVyou merely convert  into
p68861
aVYou need to perform the arithmetic using floating point operations
p68862
aVYou can force that by making at least one of the operands be a float
p68863
aVFor example:
p68864
aVAlternatively you could make  and  be floats
p68865
aVFinally, you are not going to get  mind you
p68866
aVRather the answer is  which is the correct answer
p68867
as(dp68868
g7
V505088
p68869
stp68870
a((dp68871
g2
(lp68872
VThere is no synchronization between different invocations of methods
p68873
aVIf the methods, no matter what type of methods they are, access shared data, then synchronization may be needed
p68874
aVIt does not make any difference if they method is a class method or an instance method, static or dynamic, etc
p68875
aVAll that matters is whether or not there are shared objects being accessed from multiple threads
p68876
aVIf two different thread accessed this method, how about
p68877
aVFCounter
p68878
aVFCounter will count sequential from last value
p68879
aVor different thread with different value start from zero
p68880
aVIn your code,  is a class variable
p68881
aVThere is a single instance of the variable, shared between all threads
p68882
aVA class variable is just a global variable, nothing more, nothing less
p68883
aVYour code modifies that shared variable
p68884
aVAs written the code has a data race
p68885
aVYou can solve it with synchronization
p68886
aVFor example by using  rather than
p68887
aVFor more complex objects you'd serialize with a critical section
p68888
as(dp68889
g7
V505088
p68890
stp68891
a((dp68892
g2
(lp68893
VYou could create a local variable that referred to the  object that you wish to operate on
p68894
aVLike this:
p68895
as(dp68896
g7
V505088
p68897
stp68898
a((dp68899
g2
(lp68900
VYou are compiling for Unicode which means that  is an alias for , the wide character version
p68901
aVHowever, the text in your program is encoded using ANSI
p68902
aVThis means that your program cannot handle internationalization properly
p68903
aVThe compiler is telling you that there is a mismatch between the text encoding that  expects, and the text encoding that you are supplying
p68904
aVIt's true that you could call  to resolve that mis-match, but that is only going to perpetuate the root problem, the fact that you are using ANSI text in your program
p68905
aVSo, the best solution is to start encoding all your text as Unicode
p68906
aVStop using  and start using
p68907
aVOnce you change  to  then
p68908
aVis correct
p68909
as(dp68910
g7
V505088
p68911
stp68912
a((dp68913
g2
(lp68914
VBy a process of reverse engineering, I infer that  is an unsigned 32 bit integer,
p68915
aVSo the compiler performs the  loop arithmetic in an unsigned context
p68916
aVThis means that  is interpreted as unsigned, and so your loop runs from  to
p68917
aVTo flesh this out, this is what happens step by step:
p68918
aVis
p68919
aVis evaluated and has value
p68920
aVInterpreted as an unsigned integer  is 232-1
p68921
aVYour loop body executes for all values 0 <= i < 232
p68922
aVThe solution is to make your loop variable be a signed integer, for example
p68923
aVWhen you switch  to be of type , the following happens:
p68924
aVis
p68925
aVis evaluated and has value
p68926
aVInterpreted as a signed integer  is -1
p68927
aVThe loop body does not execute
p68928
as(dp68929
g7
V505088
p68930
stp68931
a((dp68932
g2
(lp68933
VHere's how I do it:
p68934
aVPrepare an icon file with an icon editing program
p68935
aVThis file is a
p68936
aVico file and contains multiple versions of the same icon with different sizes and pixel formats
p68937
aVReference that icon file in a
p68938
aVrc file that is used as source to the resource compiler
p68939
aVAs part of the compilation, the
p68940
aVrc file is processed, resulting in a
p68941
aVres file
p68942
aVLink the
p68943
aVres file to the executable with a  directive
p68944
aVAt runtime load the appropriate version of the icon with one of the Windows API functions that loads images from resources
p68945
aVI use these steps for all the icons that I use on toolbars and menus
p68946
aVThat allows me to have a GUI that scales with the user's font scaling settings
p68947
aVThe way that the Delphi IDE leads you to do it is to make a  and fill it up with icons that are stored in the
p68948
aVdfm file
p68949
aVThat's pretty hopeless because it doesn't readily allow you to have different sized icons
p68950
aVAnd it also means that your visual assets are stored in a
p68951
aVdfm file in a great big glob representing all icons
p68952
aVIf you want to swap out a single icon, then you can do so but it's rather opaque
p68953
aVThe history trail left in your VCS is meaningless beyond any comments you leave
p68954
aVIf you are just talking about the main program icon, then you can add your
p68955
aVico file to the project in the Project | Options | Application dialog and the IDE will take care of the rest of the details
p68956
as(dp68957
g7
V505088
p68958
stp68959
a((dp68960
g2
(lp68961
VSub items in a list view are only visible in columns when the list view is in report view style
p68962
aVThe sub items are displayed in a row, the same row that contains the main item caption
p68963
aVThink of Explorer in Details view mode
p68964
aVSo, you've got the wrong control
p68965
aVYou need a tree view rather than a list view
p68966
aVEither the built in tree view control or the excellent virtual tree view control
p68967
as(dp68968
g7
V505088
p68969
stp68970
a((dp68971
g2
(lp68972
VYou can readily design your own classes to support a fluent style, should you so desire
p68973
aVFor many types, the fluent style is not appropriate, so don't feel you have to use it everywhere
p68974
aVHowever, for some types it can make good sense
p68975
as(dp68976
g7
V505088
p68977
stp68978
a((dp68979
g2
(lp68980
VThe remarks section of the documentation appears to explain when  is needed:
p68981
aVIf the hEvent member of the OVERLAPPED structure is NULL, the system uses the state of the hFile handle to signal when the operation has been completed
p68982
aVUse of file, named pipe, or communications-device handles for this purpose is discouraged
p68983
aVIt is safer to use an event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device
p68984
aVIn this situation, there is no way to know which operation caused the object's state to be signaled
p68985
as(dp68986
g7
V505088
p68987
stp68988
a((dp68989
g2
(lp68990
V is the wrong message to use when replacing a small portion of the text
p68991
aVYou use  to set the entire text content of the control
p68992
aVWhat you want is to select the word that needs to be corrected
p68993
aVUse  for that
p68994
aVAnd then use  to replace the text with the corrected version
p68995
aVI expect that will also have the happy effect of fixing the problem of unwanted scrolling
p68996
as(dp68997
g7
V505088
p68998
stp68999
a((dp69000
g2
(lp69001
VLike this:
p69002
as(dp69003
g7
V505088
p69004
stp69005
a((dp69006
g2
(lp69007
VYou can do this using the  directive:
p69008
aVSo you could re-write your code like this:
p69009
aVThis will suppress the compiler hint, but it also makes your eyes bleed
p69010
aVI would probably suppress it like this:
p69011
aVThe untyped parameter that the suppress function receives is sufficient to suppress H2077
p69012
aVAnd the use of  means that the compiler emits no code since there is no function call
p69013
as(dp69014
g7
V505088
p69015
stp69016
a((dp69017
g2
(lp69018
VYou can use the  function for this
p69019
aVFor example:
p69020
as(dp69021
g7
V505088
p69022
stp69023
a((dp69024
g2
(lp69025
VFrom the Tools | Options | Editor Options | Code Insight menu, deselect the Auto complete check box under Code template completion
p69026
aVOnce you disable template auto complete then you need to manually invoke the template if you want it
p69027
aVDo that with CTRL+J
p69028
as(dp69029
g7
V505088
p69030
stp69031
a((dp69032
g2
(lp69033
VThe problem is simply that you are deleting multiple lines from the memo
p69034
aVThat's because, for some reason, you coded a loop which deleted in each and every iteration of the loop
p69035
aVYou don't want to do that
p69036
aVYou only want to delete a single line
p69037
aVYou need to use code along these lines:
p69038
aVI have replaced your code which looped over the list box items and deleted multiple items from the list box, and multiple rows from the memo
p69039
aVInstead I obtain the index of the selected item in the list box, and make a single deletion from the list box and remove a single line from the memo
p69040
as(dp69041
g7
V505088
p69042
stp69043
a((dp69044
g2
(lp69045
VYour declaration of the implementation is missing the class
p69046
aVIt should be:
p69047
aVYou might also consider omitting the default values in the implementation
p69048
aVHere's a complete program that compiles, to illustrate the point:
p69049
as(dp69050
g7
V505088
p69051
stp69052
a((dp69053
g2
(lp69054
VNo, WriteAllBytes is a blocking, synchronous method
p69055
aVAs you stated, if it were not, the documentation would say so
p69056
aVPossibly the virus scanner is still busy scanning the file that you just wrote, and is responsible for locking the file
p69057
aVTry temporarily disabling the scanner to test my hypothesis
p69058
as(dp69059
g7
V505088
p69060
stp69061
a((dp69062
g2
(lp69063
VThe documentation contains a section titled Requirements
p69064
aVThis lists the header file and import library required to call the function
p69065
aVIf you fail to include the header file, the compiler objects because no function has been declared
p69066
aVIf you fail to pass the import library to the linker it fails with a missing reference
p69067
aVYou did not pass the import library to the linker
p69068
aVAdd it to the Additional Library Dependencies in the  linker section of your project configuration
p69069
aVThe name of the import library is listed in the MSDN documentation that I linked to above
p69070
aVThis procedure can be followed for all API functions
p69071
as(dp69072
g7
V505088
p69073
stp69074
a((dp69075
g2
(lp69076
VThe function would be p/invoked like this:
p69077
aVI removed the size paramter since it is not needed since you can use a null-terminated string
p69078
aVCall the function like this:
p69079
aVThe tricky bit is to deallocate the memory allocated on the native side
p69080
aVEither use a shared allocator, e
p69081
ag217
aVthe COM allocator
p69082
aVOr export a deallocator from the native code
p69083
aVPersonally I'd re-design the interface to use COM BSTR
p69084
aVI'd have the C++ return a BSTR and on the managed side use [MarshalAs(UnmanagedType
p69085
aVBStr)]
p69086
aVThen the framework handles all the deallocation and marshalling for you
p69087
as(dp69088
g7
V505088
p69089
stp69090
a((dp69091
g2
(lp69092
VYour immediate problem is likely that you are passing ANSI text to the sCode parameter
p69093
aVUnfortunately you omitted your p/invoke declaration which would have made that clear
p69094
aVThat's easy to fix, but you have much bigger problems
p69095
aVThis function is hard to call because it has been designed incorrectly
p69096
aVIt's only viable if it returns constant strings that are allocated by the compiler rather than heap allocated strings
p69097
aVYou could force it to work with that signature if you:
p69098
aVExported a deallocator function from the native code
p69099
aVAllocated the string using a shared heap, e
p69100
ag217
aVthe COM heap
p69101
aVIt looks like you are returning COM error codes in string form
p69102
aVThat's perverse
p69103
aVInstead you could make your life very easy by returning HRESULT
p69104
aVAnyway, to answer the direct question you declare the p/invoke like this:
p69105
aVThen call like this
p69106
aVThen marshal the pointer to a string
p69107
aVBut remember that this can only work if the returned string data is statically allocated
p69108
aVOtherwise you will have leaks, or access violations
p69109
aVMy primary advice is to redesign the interface
p69110
aVDon't return an error code in a string
p69111
aVOn a general note, if you must pass strings from Delphi to C# do it like this:
p69112
aVDeclare an out parameter of type WideString in the Delphi code
p69113
aVThis wraps a COM BSTR
p69114
aVOn the managed side declare an out parameter of type string
p69115
aVDecorate that parameter with [MarshalAs(UnmanagedType
p69116
aVBStr)]
p69117
aVNote that you cannot marshal a WideString return value to MS tools because Delphi uses a different ABI for return values
p69118
aVThat's why you use an out parameter
p69119
as(dp69120
g7
V505088
p69121
stp69122
a((dp69123
g2
(lp69124
VThe documentation is clear on the matter
p69125
aVYou are passing None for the ord parameter to linalg
p69126
aVnorm() so you get the Frobenius norm
p69127
aVThe code appears to be normalising the input, by dividing by the norm
p69128
aVThen it seems makes a poor attempt to scale to have 8 bit color values
p69129
aVBut the code scales to the range 0 to 256 instead of 0 to 255
p69130
aVHowever, the first step seems pointless to me
p69131
aVThe code could simply read:
p69132
aVBut perhaps it should be 255 instead of 256
p69133
aVSince we've got not context here, I'm reluctant to state that the code is wrong
p69134
aVOnly you are in a position to decide that because only you know the context
p69135
as(dp69136
g7
V505088
p69137
stp69138
a((dp69139
g2
(lp69140
VThe only thing that I know that works is for you to let the IDE manage the
p69141
aVdpr file
p69142
aVDon't add comments
p69143
aVDon't use conditionals like $IFDEF
p69144
aVDon't modify the code in the
p69145
aVdpr file
p69146
aVif you do any of these things, expect the IDE to bite back
p69147
aVPersonally I do all of these and fight back at commit time
p69148
aVI use my VCS to defend against bogus IDE changes
p69149
aVIt's not ideal, but it's the best option
p69150
as(dp69151
g7
V505088
p69152
stp69153
a((dp69154
g2
(lp69155
VNow here is a snip from the official delphi
p69156
aVdocumentation
p69157
aVIn fact, the documentation that you posted that was delivered with the Delphi 7 help is the MSDN help
p69158
aVThe official MSDN documentation for Win32 is written in C and you simply need to learn enough C to be able to read it and map it across to Delphi
p69159
aVThere are small pockets of Delphi specific Win32 code examples and guides to be found on the internet
p69160
aVBut these do not cover all of Win32
p69161
aVIt is my opinion that if you wish to be an effective consumer of Win32 you must learn enough C to access both the official docs, and the myriad of third party articles and samples
p69162
as(dp69163
g7
V505088
p69164
stp69165
a((dp69166
g2
(lp69167
VYou can use GetProcAddress to obtain the address of the exported globals
p69168
aVYou cannot get the marshaller to do it with DllImport
p69169
aVSo your two options are:
p69170
aVUse GetProcAddress and do all the marshalling yourself
p69171
aVAdd getters and setters to the C code and let the marshaller do the heavy lifting from there
p69172
aVPersonally I would opt for option 2
p69173
as(dp69174
g7
V505088
p69175
stp69176
a((dp69177
g2
(lp69178
VA Delphi open array is actually passed using two parameters: the address of the first element, and the element count minus one
p69179
aVTo call your C++ function you cannot use an open array
p69180
aVSimply declare the function as receiving a pointer to the first element:
p69181
aVCall it like this:
p69182
aVAt some point you may want to let the array length vary dynamically
p69183
aVAs it stands the code assumes that the array has three elements
p69184
aVFor more generality you would pass an extra parameter specifying the array length
p69185
aVI'm assuming that the C++ function really is stdcall although nothing in the question makes that explicit
p69186
as(dp69187
g7
V505088
p69188
stp69189
a((dp69190
g2
(lp69191
VYour original question asked why the child process does not inherit the working directory of the parent
p69192
aVWell, if you pass NULL to CreateProcess then the new process will inherit the working directory of the parent process at the time that the call to CreateProcess is made
p69193
aVThe documentation makes this quite clear and there are no surprises here
p69194
aVCreateProcess behaves precisely as advertised
p69195
aVThe edited question concentrates on DLL search
p69196
aVIt's not easy to answer this new take on the question from this information
p69197
aVThe best thing to do is to run the program under the profile mode of Dependency Walker
p69198
aVThis should reveal what is wrong
p69199
aVYou may well find that the problem is not at all what you expect it to be
p69200
aVAnd for future reference, I recommend that you include full details of any errors when you ask a question
p69201
aVYou stated that an exception was raised but really you need to supply the full details of any exceptions
p69202
as(dp69203
g7
V505088
p69204
stp69205
a((dp69206
g2
(lp69207
VThe 32 bit emulator (known as WOW64) has a parallel system directory named SysWOW64
p69208
aVThe 32 bit DLL is found in there
p69209
aVThe system transparently maps requests to access system32 from 32 bit processes into requests to access SysWOW64
p69210
aVThat is performed by the File System Redirector
p69211
as(dp69212
g7
V505088
p69213
stp69214
a((dp69215
g2
(lp69216
VOxygene doesn't attempt to be source compatible with Delphi
p69217
aVWhat's more the runtime libraries used by the various Oxygene flavours differ entirely from those used by Delphi
p69218
aVSo you won't find any serious libraries that have single source that can compile on Oxygene and Delphi
p69219
aVThe way that RemObjects have developed Oxygene on different platforms is quite interesting and radically different from the approach taken by Embarcadero with Delphi
p69220
aVWith Delphi the goal is that you can single source development for all the platforms
p69221
aVThat is made possible by the FireMonkey framework which presents a common interface to all platforms
p69222
aVObviously you need to vary some elements of an app to account for device differences
p69223
aVWith Oxygene, each platform is targetted separately
p69224
aVSo for Windows, the runtime is
p69225
aVnet
p69226
aVFor Java it is the JVM and for Apple platforms you target Cocoa
p69227
aVAll this means that you cannot expect to write a GUI app in Oxygene and have it work on multiple platforms
p69228
aVSo not only can you single source your app between Delphi and Oxygene, you cannot readily single source multiple Oxygene targets
p69229
aVNow, you can probably port to Oxygene or FPC without too much trouble
p69230
aVBut maintaining single source is liable to mean a lot more effort
p69231
aVWhether that's worth the effort is debateable
p69232
aVIn the long run you'll want a codebase in one of Delphi, FPC, Oxygene, or even something radically different
p69233
aVBut you won't want your code spread out over multiple languages
p69234
as(dp69235
g7
V505088
p69236
stp69237
a((dp69238
g2
(lp69239
VYou cannot expect to block the GUI thread of any process
p69240
aVIn your scenario things are a little more complex because there are two GUI threads
p69241
aVOne for each process
p69242
aVHowever, by establishing a parent/child relationship between windows of these processes you are also introducing a requirement that both GUI threads are serviced in good time
p69243
aVWindows that are in a parent/child relationship will send each other messages
p69244
aVAnd if those messages are synchronous, that is sent rather than posted, then blocking one GUI thread will lead to the other being blocked
p69245
aVThe golden rule of GUI programming remains in force: do not block a GUI thread
p69246
aVIf you have a long running task, then move it onto a background thread
p69247
aVUpdate
p69248
aVOK, as explained here when you relate windows from different threads you attach  their message queues to each other
p69249
aVAnd so if you block one thread, you block all of the attached threads
p69250
aVSo, don't block a GUI thread
p69251
as(dp69252
g7
V505088
p69253
stp69254
a((dp69255
g2
(lp69256
VEven if your class has no data members, you cannot expect it to be usable from code compiled with a different compiler
p69257
aVThere is no common ABI for C++ classes
p69258
aVYou can expect differences in name mangling just for starters
p69259
aVIf you are prepared to constrain clients to use the same compiler as you, or provide source to allow clients to compile your code with their compiler, then you can do pretty much anything across your interface
p69260
aVOtherwise you should stick to C style interfaces
p69261
as(dp69262
g7
V505088
p69263
stp69264
a((dp69265
g2
(lp69266
VClearly you have a 32 bit DLL which cannot be loaded in a 64 bit process
p69267
aVEither make a 64 bit version of the DLL, or configure IIS to host your DLL in a 32 bit process
p69268
aVHowever, I suspect that your DLL is not needed at all
p69269
aVYou appear to be using it to perform some trivial text processing
p69270
aVIt's probably going to be simpler just to port that to
p69271
aVnet and avoid all this complexity
p69272
aVOnce you've done this, you'll be free of this dependency for good
p69273
as(dp69274
g7
V505088
p69275
stp69276
a((dp69277
g2
(lp69278
VYour event handler, and therefore the VCL accessing code that it contains, executes on a thread other than the GUI thread
p69279
aVAll code that accesses VCL objects must execute on the GUI thread
p69280
aVHence, you will need to change your code to make sure that the VCL portions are marshalled on to the GUI thread
p69281
aVUse TIdSync or TThread
p69282
aVSynchronize to marshal the VCL portions of your code onto the GUI thread
p69283
aVRemy gives an example of the former approach here: Indy synchronize ServerTCPExecute
p69284
as(dp69285
g7
V505088
p69286
stp69287
a((dp69288
g2
(lp69289
VYour question is akin to asking the difference between Linux and Ubuntu
p69290
aVLazarus is an IDE/component library, based on FreePascal (FPC)
p69291
aVAnd CodeTyphon is a distribution of Lazarus and FPC
p69292
aVSo CodeTyphon is just one way to install a functioning installation of Lazarus
p69293
aVLazarus uses the same floating window design as older versions of Delphi
p69294
aVInstalling from CodeTyphon won't change that
p69295
as(dp69296
g7
V505088
p69297
stp69298
a((dp69299
g2
(lp69300
VYou are missing an import library (
p69301
aVlib file) for the DLL
p69302
aVThat's why the linker is giving that error message
p69303
aVUnfortunately Delphi won't generate a
p69304
aVlib file which is a bit of a weakness in my view
p69305
aVYou can solve the problem by either:
p69306
aVLinking with LoadLibrary/GetProcAddress
p69307
aVGenerate a suitable
p69308
aVlib file
p69309
aVOption 2 is easy enough
p69310
aVCreate a fake DLL project in Visual Studio
p69311
aVArrange for it to export the same functions as your Delphi DLL
p69312
aVImplement these functions with empty stubs
p69313
aVUse a
p69314
aVdef file rather than __declspec(dllexport) to avoid name decoration of your exports
p69315
aVIt's really obvious really
p69316
aVMake a fake DLL that has an identical interface to the real DLL
p69317
aVThe same name, the same functions
p69318
aVThe fake DLL needs no implementation because all you are doing is getting the MS tools to make the
p69319
aVlib file that Delphi cannot
p69320
aVMore details here: http://support
p69321
aVmicrosoft
p69322
aVcom/kb/131313
p69323
aVFWIW I believe that the Delphi export modifier is ignored
p69324
aVUse an exports clause instead
p69325
as(dp69326
g7
V505088
p69327
stp69328
a((dp69329
g2
(lp69330
VThe assignable typed constants option has been disabled by default for as long as I can remember
p69331
aVIt was disabled by default in many versions preceeding Delphi 7
p69332
aVThe language feature is poorly designed and because of that, in my view, should not be used
p69333
aVIt is confusing to readers of the code
p69334
aVThe idea of modifying a constant is quite simply bizarre
p69335
aVThe use-case for assignable typed constants is locally scoped variables with static (i
p69336
ag192
aVglobal) storage duration
p69337
aVIf the language had been properly designed then there would be a place for locally scoped variables with static storage duration
p69338
aVBut the design was fatally flawed because you cannot, in the Delphi language, readily distinguish between assignable typed constants and real constants, due to the overloading of the const keyword
p69339
aVA sane design would have introduced syntax to declare variables with static storage and distinguish them from constants
p69340
aVBut instead the designers chose a compiler option
p69341
aVOr perhaps, way back when, in Turbo Pascal all typed constants were assignable
p69342
aVAll the same, without language syntax support, the overloading of the const keyword is simply untenable
p69343
aVThe compiler option is retained for backwards compatibility
p69344
aVYou are not expected to use assignable typed constants
p69345
aVAgain, for as long as I can remember, any decent coding standard bans the use of assignable typed constants
p69346
aVMy recommendations:
p69347
aVDisable assignable typed constants at the global level
p69348
aVNever use $J+ in your code
p69349
aVThe closest construct in modern Delphi for locally scoped variables with static storage duration is strict private class variables
p69350
aVThey are not available in Delphi 7 and so your only option is a global variable, which is a rather sorry state of affairs
p69351
as(dp69352
g7
V505088
p69353
stp69354
a((dp69355
g2
(lp69356
VYou need to ensure that the TMyQuery object outlives the TFields object which it owns
p69357
aVBut you must also make sure that you destroy that TMyQuery object to avoid the leak
p69358
aVThe simplest way is to return the TMyQuery object from the function and let the caller read the Fields property
p69359
aVWhen you are done, destroy the TMyQuery object
p69360
aVAnd naturally you'll use try/finally to ensure that exceptions don't lead to leaks
p69361
as(dp69362
g7
V505088
p69363
stp69364
a((dp69365
g2
(lp69366
VSomewhere in your program is a class which declares an abstract virtual:
p69367
aVAnd your program instantiates a class that does not override this abstract method, and then calls the method
p69368
aVWhen this method is called, an EAbstractError exception is raised
p69369
aVThe abstract method is not necessarily declared in code that you wrote
p69370
aVFor example, perhaps you instantiated a TStrings class:
p69371
aVwhen you meant to write
p69372
aVSubsequent method calls on the TStrings instance will lead to abstract errors
p69373
aVRemember that TStrings is an abstract class full of abstract methods
p69374
aVWith many patterns of class instantiation your code would lead to a compiler warning
p69375
aVThe compiler will warn that you are instantiating a class that contains abstract methods
p69376
aVIf your mistake is as suggested above, then the compiler warnings will locate the error for you
p69377
aVI cannot stress enough the importance of listening to the compiler's warnings
p69378
aVHowever, if the abstract class in question is a form, then the compiler will not be able to warn if you are using Application
p69379
aVCreateForm to instantiate it
p69380
aVIf your code declares the abstract method, then you can find the problem readily by performing a search (Find in Files) for the uses of abstract
p69381
aVIf that does not help, and there are no compiler warnings, then configure the debugger to break on exceptions and then take a look at the call stack when the program breaks on the exception
p69382
as(dp69383
g7
V505088
p69384
stp69385
a((dp69386
g2
(lp69387
VI'm guessing this is a decimal separator issue
p69388
aVWord returns the string '14
p69389
aV0' and then when you convert to integer the period is treated as a positional separator on one machine, and a decimal separator on another
p69390
aVThe solution is to stop converting to integer which I infer that you are doing in code that you have not shown
p69391
aVI am inferring that from this comment:
p69392
aVI can convert it to string and use the first 2 chars
p69393
aVSince the code in the question operates on strings, I conclude that other code, not shown in the question, is converting to integer
p69394
as(dp69395
g7
V505088
p69396
stp69397
a((dp69398
g2
(lp69399
VWhether or not you allocate an object on the heap typically is driven by one of the following concerns:
p69400
aVIf the new object needs to outlive the function that creates it, the object must be allocated on the heap
p69401
aVIf the object is very large, and does not fit on the stack, then you must allocate it on the heap
p69402
aVBeyond that, the choice of pass by value or pass by reference is determined by the semantics
p69403
aVIf you want to operate on a copy, pass by value
p69404
aVIf you want to operate on the actual object, pass by reference
p69405
as(dp69406
g7
V505088
p69407
stp69408
a((dp69409
g2
(lp69410
VYou need to install Delphi using the installation program
p69411
aVIt's not enough just to copy the installation folder
p69412
aVThere are registry settings too
p69413
aVYou may be able to hack together a working solution by transferring registry settings from one machine to another, but the correct solution is to install properly
p69414
as(dp69415
g7
V505088
p69416
stp69417
a((dp69418
g2
(lp69419
VPrefix the file name with  to enable extended-length path parsing
p69420
aVFor example you would write
p69421
aVNote that this will only work if you are calling the Unicode versions of the Win32 API functions
p69422
aVSo if you use a Unicode Delphi then this will do the job
p69423
aVOtherwise you'll have to roll your own version of  that calls Unicode versions of the API functions
p69424
aVThese issues are discussed in great length over on MSDN: Naming Files, Paths, and Namespaces
p69425
as(dp69426
g7
V505088
p69427
stp69428
a((dp69429
g2
(lp69430
VThe code appears to be in the wrong place
p69431
aVWe cannot see your implementation of , but that's where the code should live
p69432
aVBut I want to concentrate on the code in the question which contains multiple errors
p69433
aVHere's how I would write it:
p69434
aVThe problems that I have addressed:
p69435
aVDon't use global variables here
p69436
aVThe variables here can all be, and should be, local variables
p69437
aVFavour local variables over all other variables, and use them wherever possible
p69438
aVDon't cast a  to integer and compare against 0
p69439
aVA  is a logical and so can be used directly in a logical context
p69440
aVUse  rather than that  mess
p69441
aVDon't perform the same text comparison twice
p69442
aVOnce is enough
p69443
aVBreak out of the loop when you find a match
p69444
aVUse try/finally to defend against exceptions leading to resource leak
p69445
as(dp69446
g7
V505088
p69447
stp69448
a((dp69449
g2
(lp69450
VFiles are linear streams of data
p69451
aVIf you want to remove content from a file, you must re-write all the content of the file that follows the part that you have remove
p69452
aVSo, unless the content to be removed is at the end of the file, you will need to perform some writing
p69453
aVIn the worst case scenario, in order to remove the first byte of a file, you need to re-write the entire file apart from the byte that you removed
p69454
aVFWIW, Raymond Chen wrote a nice article on this subject: How do I delete bytes from the beginning of a file
p69455
as(dp69456
g7
V505088
p69457
stp69458
a((dp69459
g2
(lp69460
VThere is no defined order of evaluation of parameters
p69461
aVThe compiler is free to decide which order to evaluate them, as it pleases
p69462
aVThe latest version of the standard, C11, says so like this, 6
p69463
ag7303
ag25125
aV2/10:
p69464
aVThere is a sequence point after the evaluations of the function designator and the actual
p69465
aVarguments but before the actual call
p69466
aVEvery evaluation in the calling function (including
p69467
aVother function calls) that is not otherwise speci\ufb01cally sequenced before or after the
p69468
aVexecution of the body of the called function is indeterminately sequenced with respect to
p69469
aVthe execution of the called function
p69470
aVIf you wish to force a specific order of evaluation you'll need to pull the expressions out of the function call, and save them away to local variables
p69471
aVIs there a better way to do this
p69472
aVVery probably
p69473
aVHaving functions return values and also apply side effects to fixed length statically allocated buffers is not generally considered best practise
p69474
aVHowever, I would not wish to tell you how to solve your problem because I don't know enough about the problem
p69475
as(dp69476
g7
V505088
p69477
stp69478
a((dp69479
g2
(lp69480
VThe reason that the article chose to use an executable rather than a DLL is that an out of process COM server is required
p69481
aVThat's because UAC elevation affects the entire process and so you cannot elevate for an in process COM server
p69482
aVSo, if you put the COM server in a DLL, then you'll need to also arrange for an out of process host for that DLL which is a needless complication
p69483
aVIt's much simpler to do it as described in the article
p69484
as(dp69485
g7
V505088
p69486
stp69487
a((dp69488
g2
(lp69489
VIt appears that you are trying to read the memory of another process
p69490
aVYou are sending an  message to a list view control
p69491
aVThis requires you to allocate memory in the virtual address space of that other process
p69492
aVWhich you did with the call to
p69493
aVSo far so good, but here's the kicker
p69494
aVYou need the struct that you allocate to be the right layout for the target process
p69495
aVNow, let's assume that the target process is a 64 bit process
p69496
aVIn which case the struct contains 64 bit pointers
p69497
aVWhen your process is also 64 bit then the struct that you defined will have 64 bit pointers
p69498
aVBut when your process is 32 bit, any pointers in the struct will be 32 bit
p69499
aVSo, now we have a situation where the struct in your process has a different layout from the struct in the target process
p69500
aVThat mismatch is enough to make all of this effort fail
p69501
aVIn order to have any chance of making this work, you would need to declare your struct so that its layout matched the 64 bit layout
p69502
aVGiven that you are only accessing a handful of fields, it may just be simpler to allocate a block of memory the right size (perhaps a byte array) and read/write the fields manually
p69503
aVAnd avoid struct marshalling
p69504
aVEven then I am doubtful that a 32 bit process is even able to poke at a 64 bit process that way
p69505
aVYou can do it in the other direction, from a 64 bit process to a 32 bit process
p69506
aVBut I have tried and never succeeded in the direction that you are attempting
p69507
aVAll the indications are that you should stick to a 64 bit processes for this task
p69508
aVOr alternatively find an officially supported way to do whatever it is you are doing
p69509
aVFor example, if you just want to read the contents of an explorer view, there's a shell API for that
p69510
aVAs an aside, please stop using magic constants instead of message identifier names
p69511
aVNobody likes to try and understand what  means
p69512
aVDeclare a constant named
p69513
aVYou also appear to perform no error checking at all
p69514
aVThat's also going to make life hard for you
p69515
aVIf one of the API calls fails, how will you ever find out about that
p69516
as(dp69517
g7
V505088
p69518
stp69519
a((dp69520
g2
(lp69521
VYou are mapping screen coord  to bitmap coord
p69522
aVAnd likewise,  to
p69523
aVSo, if the cursor's screen position is  then you map that to  and
p69524
aVAnd then you also need to account for the hot spot, but you already seem to know how to do that
p69525
aVThe mapping above applies equally to all monitors
p69526
aVNote that I used my own notation because I found your single letter variables mis-leading
p69527
aVNot to mention that fact that the meaning of these variables changes during the function
p69528
aVI'm look at you,
p69529
aVThat's always a recipe for pain
p69530
aVAlso, don't you need to delete the bitmap handles that are handed to you when you call
p69531
aVAnd some error checking wouldn't go amiss
p69532
as(dp69533
g7
V505088
p69534
stp69535
a((dp69536
g2
(lp69537
VThat's not easy to do
p69538
aVThe console window is actually handled by a separate process,
p69539
aVYou'd need to persuade that process to change its behaviour which would involve gross hacks
p69540
aVYou can obtain the window handle readily enough and change basic properties of the window, and hope that  doesn't change them back
p69541
aVBut custom painting of the caption bar would involve injecting code into
p69542
as(dp69543
g7
V505088
p69544
stp69545
a((dp69546
g2
(lp69547
VYou would use that when you needed to obtain the GUID of an interface
p69548
aVIn your case you are looking for the GUID of
p69549
aVIn Delphi the compiler performs magic for you
p69550
aVWhere you would need to use  in C++ you can simply pass the interface type itself,  in this case
p69551
aVYou can use an interface type in any context that expects a  and so long as that interface has a GUID defined, the compiler will do the rest for you
p69552
aVSo, in C++ you might write:
p69553
aVIn Delphi you would write:
p69554
aVJust to show you how pervasive this magic is, I offer the following fun program:
p69555
aVwhich produces this output:
p69556
aV{00000000-0000-0000-C000-000000000046}
p69557
aVLooking at your update, you do not need to use
p69558
aVYou can write that line of code like this:
p69559
aVHowever, the variable naming is odd
p69560
aVThe variable named  really should be declared like this:
p69561
aVBut I doubt that you even need the variable at all
p69562
aVIt looks like it only ever holds that GUID
p69563
aVThat GUID is known at compile time
p69564
aVIf you hold it anywhere, hold it in a constant
p69565
aVBut do you need to hold it anywhere
p69566
aVSurely you can remove it and replace all uses with
p69567
as(dp69568
g7
V505088
p69569
stp69570
a((dp69571
g2
(lp69572
VTo the best of my knowledge there is no such tool
p69573
aVUsing Agner Fog's object file converter, the tool that Arnaud refers to, I've never succeeded in converting a Delphi unit into a COFF
p69574
aVobj that can be linked to an MSVC program
p69575
aVI do believe that it's not realistic to take Delphi source code, compile it, and then use the generated object in MSVC
p69576
aVThe other direction is quite possible
p69577
aVYou can compile C code to an object, and link that object to your Delphi executable
p69578
aVWhen you do this you need to resolve any dependencies that the compiled object has
p69579
aVBut to link a Delphi object into a C/C++ program is going to require whatever part of the Delphi RTL that you use
p69580
aVAnd that's going to be tricky unless you happen not to use any part of the Delphi RTL, which seems unlikely
p69581
aVIn your situation I think your options are:
p69582
aVPort the code to C or C++
p69583
aVCompile the Delphi code into a dynamic library and link to that from your C++ program
p69584
as(dp69585
g7
V505088
p69586
stp69587
a((dp69588
g2
(lp69589
VThe most obvious reason why this advice is given is for programmers that want to write code like this:
p69590
aVThat condition will only evaluate true if the object's class is
p69591
aVHowever, very commonly you would want the conditional code to run for  and any descendents
p69592
aVIn which case you write:
p69593
aVIf you need to know what class an instance is, then  is what you should use
p69594
aVIf you are maintaining a list of classes in a  instance, then feel free to use  to obtain the meta class of an instance
p69595
as(dp69596
g7
V505088
p69597
stp69598
a((dp69599
g2
(lp69600
VError code  is the COM error code that represents the Win32 error
p69601
aVNormally when a 32 bit process tries to load a 64 bit DLL, or vice versa, the error code is  which would appear as  when wrapped in a COM error code
p69602
aVTherefore, I think that the problem is not a 32/64 bit mismatch
p69603
aVThe most likely explanation is that the DLL, or one of its dependencies, is corrupt
p69604
aVIn order to debug this I would remove the complexity of IIS
p69605
aVYou've got added layers of p/invoke and IIS to deal with
p69606
aVFirst of all make sure that you can load this DLL from another native program
p69607
aVCreate a 64 bit C++ console app in VS that does this:
p69608
aVSee what happens when you run that
p69609
aVIf you get an error code, what value is it
p69610
aVIs it
p69611
aVAt this point I'd use Dependency Walker in Profile mode to try to work out which DLL is the trouble maker
p69612
as(dp69613
g7
V505088
p69614
stp69615
a((dp69616
g2
(lp69617
VI think you are over-complicating this
p69618
aVThere's no need to use the  property at all
p69619
aVLeave it at its default setting of
p69620
aVThen, to read/write RTF use  and
p69621
aVAnd to read/write plain text use the  property
p69622
aVThis is about as simple as I can make it:
p69623
as(dp69624
g7
V505088
p69625
stp69626
a((dp69627
g2
(lp69628
VIf you prefix file names with  then you enable extended-length path parsing and so escape from the 260 character path length limit
p69629
aVIn order for this prefix to work you need to be calling the Unicode versions of the Win32 API functions
p69630
aVSo if you were using a Unicode Delphi then this is all you need to do
p69631
aVBut since you are using a pre-Unicode Delphi you'll  have to roll your own version of  that calls Unicode versions of the API functions
p69632
aVYou'll be calling , ,  and using the Unicode version of the struct,
p69633
aVThese issues are discussed in great length over on MSDN: Naming Files, Paths, and Namespaces
p69634
aVIn your particular scenario, the documentation for  calls the issue out like this:
p69635
aVIn the ANSI version of this function, the name is limited to MAX_PATH characters
p69636
aVTo extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\u005c
p69637
aV\u005c" to the path
p69638
aVNote that the two file name fields in  are limited in length to 260 characters
p69639
aVThat is fine because they only contain the relative part of the name, that is the object name relative to the containing directory
p69640
aVYou only need to use the  prefix when you call
p69641
aVIn order to use the Unicode version of this API you'll use a  for the  parameter of  and pass it using
p69642
aVAs for the file attributes, they can be read out of the  struct on each iteration
p69643
aVThat part of your code need not change
p69644
aVThe only thing you need to fix is to get the >260 char parsing on the initial call to
p69645
aVEverything else flows on quite normally
p69646
as(dp69647
g7
V505088
p69648
stp69649
a((dp69650
g2
(lp69651
VFrom an  instance you do the following:
p69652
aVRead the  property which is a
p69653
aVCheck that the  is
p69654
aVThen drill down to  which is
p69655
aVThen read out the  which is type
p69656
aVFinally check that the type that the pointer refers to is an AnsiChar with
p69657
aVPut it all together like this:
p69658
aVAnd here's a program to demonstrate:
p69659
aVOutput:
p69660
aVTrue
p69661
aVTrue
p69662
aVTrue
p69663
as(dp69664
g7
V505088
p69665
stp69666
a((dp69667
g2
(lp69668
VYour implementation of  does not return anything
p69669
aVIt needs to return
p69670
aVOr you could delete the getter and change the property to be like so:
p69671
as(dp69672
g7
V505088
p69673
stp69674
a((dp69675
g2
(lp69676
VThe  and  properties of  are completely different things
p69677
aVtells you what sort of type you have
p69678
aVThis can be one of the 23 different options define in the  enumerated type
p69679
aVtells you which type you have
p69680
aVThis is a string and there are an unlimited number of possible values
p69681
aVDifferent types will (usually) have different names, but may have the same
p69682
aVFor example consider this simple demonstration
p69683
aVThe output is:
p69684
aVTObject
p69685
aVTInterfacedObject
p69686
aVSo, you cannot infer the type kind from the type name since kind and name are quite different things
p69687
as(dp69688
g7
V505088
p69689
stp69690
a((dp69691
g2
(lp69692
VDeclare  to be a  rather than a
p69693
aVBy doing so you make it a reference type
p69694
aVThat matches the declaration of  because  has type  which is a pointer to the struct
p69695
aVYou do need to specify  when you do this since that's not the default for a class
p69696
aVOnce you've made this change, you can set the variable to
p69697
aVYou can adopt the same policy for  to allow that to be passed as
p69698
aVNote that the declaration on pinvoke
p69699
aVnet erroneously uses  on
p69700
aVThat's wrong because the error code comes back in the return value
p69701
aVI also removed the setting of  to  since that is the default
p69702
aVTheir declaration of  also appears wrong since the  parameter has type  which is the struct rather than a pointer to it
p69703
aVI would advise you to treat what you find on pinvoke
p69704
aVnet with extreme scepticism
p69705
aVA large proportion of the declarations on that site are simply incorrect
p69706
aVYou ask about the possibility of using nullable types
p69707
aVAccording to @JaredPar's answer here, that's not an option
p69708
as(dp69709
g7
V505088
p69710
stp69711
a((dp69712
g2
(lp69713
VYou cannot pass a Delphi object between a DLL and a host executable
p69714
aVThat's because objects can only be operated on in the module in which they are created
p69715
aVNow, if you were using runtime packages, you'd be able to escape that limitation
p69716
aVYou could export a function from your DLL that created and showed the form
p69717
aVThe function might look like this:
p69718
aVNote that you cannot pass the parent as a Delphi object for exactly the same reasons as I describe above
p69719
aVYou also cannot specify that the parent of the form be a control in your executable
p69720
aVSo you have to pass the parent's window handle
p69721
aVThe implementation would be like so:
p69722
aVYou would call it like this:
p69723
aVYou'd also need to supply a function to destroy the form when you are done:
p69724
aVAnd you need to watch out for window re-creation
p69725
aVIf the host window is re-created then you need to manually re-create the child form
p69726
aVIn short, what you are attempting is rather brittle
p69727
aVIf I were you I would look for a different approach
p69728
as(dp69729
g7
V505088
p69730
stp69731
a((dp69732
g2
(lp69733
VPresumably this is because the default value for  is
p69734
aVI expect that you can set it to  before you do your conversions
p69735
as(dp69736
g7
V505088
p69737
stp69738
a((dp69739
g2
(lp69740
VYou don't need to initialise the array
p69741
aVYou can let  set the values
p69742
aVYou do not need to assign them to anything before calling
p69743
aVThe documentation states that the  parameter has out semantics and so its value on input is not used
p69744
aVYou must perform error checking though, to make sure that you detect that the function has failed and so do not use uninitialized values
p69745
aVIt won't hurt to do
p69746
aVbefore you call
p69747
aVBut so long as you perform proper error checking on the call to  there's no way that function can complete successfully and not assign to the  parameter
p69748
as(dp69749
g7
V505088
p69750
stp69751
a((dp69752
g2
(lp69753
VThe closest equivalent in Java is a static variable of a class
p69754
aVThat has static lifetime, but also has a wider scope than a Delphi assignable typed constant
p69755
aVIn Java there is nothing exactly like Delphi's rather quaintly named assignable typed constants that has local scope, but static lifetime
p69756
aVA static class variable is as close as you can get
p69757
aVIn C/C++ you could use a local variable with static storage duration, which has the same semantics as Delphi's assignable typed constants
p69758
as(dp69759
g7
V505088
p69760
stp69761
a((dp69762
g2
(lp69763
VThis would happen if your DLL threw exceptions out of its exported functions
p69764
aVA DLL must not do that so you need to catch all exceptions at the boundary of your DLL, and convert them into error code return values
p69765
aVIf you don't have control over the DLL then you'll need to write a wrapper layer to it
p69766
aVCreate another native DLL which calls the original DLL and catch any exceptions that it throws
p69767
aVYou could do this with another Delphi DLL I suspect, or alternatively with a C or C++ DLL that used SEH to catch the exceptions
p69768
aVIt would be possible to script the generation of the code for such a wrapper DLL
p69769
aVYou'd want to do that if there were a lot of functions that you needed to wrap
p69770
as(dp69771
g7
V505088
p69772
stp69773
a((dp69774
g2
(lp69775
VAssuming that you did not specify a comparer in the constructor to  you will get  as your comparer
p69776
aVAnd that is a comparer that performs simple binary comparison using
p69777
aVThat's fine for a record full of value types, with no padding
p69778
aVBut otherwise you will need to supply your own compare function when you instantiate the list
p69779
aVIf you want to look at the details, the default comparer for records is implemented in
p69780
aVFor larger records the equality comparer is this function:
p69781
aVFor smaller records there is an optimization and your comparer will be the 4 byte comparer
p69782
aVThat looks like this:
p69783
aVThat's a bit weird, but it interprets the 4 bytes of your record as a 4 byte integer and performs integer equality comparison
p69784
aVIn other words, the same as , but more efficient
p69785
aVThe comparer that you want to use might look like this:
p69786
aVUse  if you want case insensitive, and so on
p69787
aVI've used an ordered comparison function because that's what  wants
p69788
aVThe fact that the default record comparison is an equality comparison tells you that attempts to sort lists of records without specifying your own comparer will have unexpected results
p69789
aVGiven that the default comparer uses an equality comparison tells you that it would not be totally unreasonable to use a comparer like this:
p69790
aVThat will be fine for unordered operations like  or  but obviously no use at all for sorting, binary search and so on
p69791
as(dp69792
g7
V505088
p69793
stp69794
a((dp69795
g2
(lp69796
VYou need to declare your p/invoke code so that it receives a delegate rather than a
p69797
aVIn VB6 there is no way to specify delegates or even pointers and hence the use of integers and
p69798
aVThe other issue is that VB6  is 32 bit so to match you need to use C#
p69799
aVThat's because C#  is 64 bit
p69800
aVSo, in C# you do it like this:
p69801
aVAnd naturally you need to adapt your callback functions to match the new definition of the delegate
p69802
aVAnd that's it
p69803
as(dp69804
g7
V505088
p69805
stp69806
a((dp69807
g2
(lp69808
VThe  parameter is declared incorrectly
p69809
aVPass the  by value
p69810
aVYou also need to allocate the  instance to have the desired capacity
p69811
aVSo, allocate the  like this:
p69812
aVAnd then set  like this:
p69813
aVI removed the parameters to
p69814
aVMost are not necessary, and the  is incorrect
p69815
aVThere may be other issues with your code, but with these changes at least the call to  will match your C++ code
p69816
as(dp69817
g7
V505088
p69818
stp69819
a((dp69820
g2
(lp69821
VYou need to call  rather than
p69822
aVA key is what appears as a folder in Regedit but you are looking for a value named  in the key
p69823
aVSome other comments:
p69824
aVSince you are only reading from the registry, use  rather than
p69825
aVCheck the return value of  in case the key cannot be opened
p69826
aVIf you actually need to do this with HKLM (as you state in a comment), watch out for registry redirection confusion when running 32 bit process on 64 bit system
p69827
as(dp69828
g7
V505088
p69829
stp69830
a((dp69831
g2
(lp69832
VYou now have two distinct types in your program, both with the name
p69833
aVThe one declared in the VCL is registered with the name
p69834
aVSince you are trying to register your  with the global registry, using the same name as the VCL version, the registration naturally fails
p69835
aVSome possible ways forward:
p69836
aVRename your form to avoid the clash
p69837
aVDon't register your class at all
p69838
aVYou don't need to register forms since they are not instantiated by the streaming framework
p69839
aVYou instantiate them by providing a meta class
p69840
aVEither to , or by a standard constructor
p69841
aVYou'd need to make sure that you always listed the unit that declared your  after  in any uses clauses
p69842
aVOr use a fully scoped type like
p69843
aVIf you used a later version of Delphi you could add your extensions using a class helper
p69844
aVPersonally I'd be inclined to do both 1 and 2 above
p69845
aVNote that I am assuming that your intent is that your  is used for all your forms rather than
p69846
as(dp69847
g7
V505088
p69848
stp69849
a((dp69850
g2
(lp69851
VYou need to use  and use the  member of  to specify that you want to treat the file as a text file
p69852
aVLike this:
p69853
aVPass the full path to the file as
p69854
as(dp69855
g7
V505088
p69856
stp69857
a((dp69858
g2
(lp69859
VThe problem is that you are passing  as the  parameter
p69860
aVThat means that you look for the resource in the executable host and not the DLL
p69861
aVYou'll have to pass the module handle of the DLL
p69862
aVYou are provided with that instance handle as the first parameter passed to your  function
p69863
aVIf you are compiling with MSVC then you could use  to obtain the module handle
p69864
aVPersonally I would suggest that making a note of the value passed to  is a cleaner approach
p69865
aVIt avoids taking a dependency on one specific compiler
p69866
aVNote also that you can call  in case  fails to obtain more information about the reason for the error
p69867
aVIt's quite possible that would have helped you identify the fault
p69868
as(dp69869
g7
V505088
p69870
stp69871
a((dp69872
g2
(lp69873
VYour thread procedure is
p69874
aVThe return value of your thread procedure is the thread's exit code
p69875
aVSo the return value of the call to  can be read by calling
p69876
aVWhich you already do
p69877
as(dp69878
g7
V505088
p69879
stp69880
a((dp69881
g2
(lp69882
VYou can write  to make an  with a specific ordinal
p69883
aVSo your code should be:
p69884
aVThe problem with the code in the question is that you converted to UTF-16 and back
p69885
aVIt would seem to me that strings are the wrong type for your crypto code
p69886
aVUse a byte array,
p69887
as(dp69888
g7
V505088
p69889
stp69890
a((dp69891
g2
(lp69892
VYou need to place the  before the return value, and the  after the return value
p69893
aVFor example:
p69894
aVYour macro places them together, after the function return value
p69895
aVHence the syntax error
p69896
aVSo if you want both in a single macro, you need a parameterized macro that takes the return type as a parameter
p69897
aVIt's simpler and clear to be explicit and skip the macros and write it out longhand, in my view
p69898
aVI suggest that you shun macros unless they give significant benefit in comparison to non-macro alternatives
p69899
aVIn this case I see no such benefit
p69900
aVNote that some of your flattening functions are missing return statements
p69901
aVAnd you also need to be clear on the lifetime of the  pointers that you return
p69902
aVI trust you are already on top of that
p69903
as(dp69904
g7
V505088
p69905
stp69906
a((dp69907
g2
(lp69908
VFrom what I can tell, the ActiveX control that ships with the reader is much cut down from that supplied with the full product
p69909
aVIt does not include any means to save a file, unlike the ActiveX for the full product
p69910
aVBut that's not a limitation since the reader cannot modify files
p69911
aVYou don't need Acrobat Reader to save the file for you
p69912
aVYou can do what you need by way of a simple file copy
p69913
aVUse  for that
p69914
as(dp69915
g7
V505088
p69916
stp69917
a((dp69918
g2
(lp69919
VYou are missing a level of indirection
p69920
aVYour native code returns a double pointer
p69921
aVBut the managed code only performs a single pointer de-reference
p69922
aVAdd in that second layer of indirection and you'll be fine
p69923
aVInstead of
p69924
aVyou need
p69925
aVAnd instead of
p69926
aVyou need
p69927
aVTo be honest though, this is a pretty complex interface
p69928
aVIf I was faced with creating an interop layer, I would use C++/CLI
p69929
as(dp69930
g7
V505088
p69931
stp69932
a((dp69933
g2
(lp69934
VThe reason why  did not return a meaningful value is that your p/invoke declaration does not tell the framework to remember the last error code
p69935
aVYou need your declaration like this:
p69936
aVThe call to  fails because the handle you pass in the first parameter is indeed invalid
p69937
aVLook again at the documentation
p69938
aVYou are meant to pass a  but you pass a
p69939
aVand  receive different types of handle
p69940
aVAnd you are passing the wrong one
p69941
aVThe documentation for  says that you need to pass:
p69942
aVA handle to the status information structure for the current service
p69943
aVThis handle is returned by the RegisterServiceCtrlHandlerEx function
p69944
as(dp69945
g7
V505088
p69946
stp69947
a((dp69948
g2
(lp69949
VA C# struct with no fields still has a size of 1
p69950
aVThe reason this is so is that the compiler must be able to take the address of a struct using the  operator in unsafe code
p69951
aVI would expect your struct type to be treated exactly the same way as the  type
p69952
as(dp69953
g7
V505088
p69954
stp69955
a((dp69956
g2
(lp69957
VBoth  and  perform the calculation using floating point arithmetic
p69958
aVThe input is converted to float before the square root is calculated
p69959
aVDo these calculations recognize when the input value is a perfect square
p69960
aVNo they do not
p69961
aVFloating arithmetic has no concept of perfect squares
p69962
aVlarge integers may not be representable, for values where the number has more significant digits than available in the floating point mantissa
p69963
aVIt's easy to see therefore that for non-representable input values,  may be innaccurate
p69964
aVAnd you proposed fix by adding a small value will not in general fix the problem
p69965
aVIf your input is an integer then you should consider performing your calculation using integer arithmetic
p69966
aVThat ultimately is the right way to deal with this
p69967
as(dp69968
g7
V505088
p69969
stp69970
a((dp69971
g2
(lp69972
VFirst of all, I can't even begin to imagine the point of your program
p69973
aVIt seems highly likely to me that there would be a better way to meet your actual goal
p69974
aVBut, taking the question at face value, if you have hooked  then presumably you could also hook
p69975
aVIf that's not an option, for whatever reason, then you can easily find the file name from your hooked WriteFile
p69976
aVCall  passing
p69977
as(dp69978
g7
V505088
p69979
stp69980
a((dp69981
g2
(lp69982
VThere are (at least) two common conventions when a  is returned by a function
p69983
aVYou cannot tell which is in force without reading the documentation of the function
p69984
aVThe function returns a pointer to statically allocated memory
p69985
aVIn which case the caller does not need to deallocate it
p69986
aVThe function returns a pointer to heap allocated memory
p69987
aVIn which case the caller does need to deallocate it
p69988
aVThe documentation for the function must specify how the caller must deallocate the function (free, delete etc
p69989
aVNow, since you are in charge of writing your own functions, you can choose whatever protocol you like
p69990
aVAnd in your case you should not return a  from your functions
p69991
aVChoose a third way
p69992
aVReturn a  and let the standard library take care of allocation and deallocation
p69993
aVDo it this way to make life easier for the consumer of the library
p69994
aVIn fact, since you are writing C++, you should be shunning
p69995
aVSure you have to use C string when interacting with the Windows API
p69996
aVBut leave it at that
p69997
aVDon't pass the pain on to the consumer of your library
p69998
aVHide that complexity away
p69999
aVIn your situation I would make sure that you have a function that can combine two  instances
p70000
aVThis could perhaps be implemented using , but it's easy enough to roll your own
p70001
aVThen the only interaction you need with the Windows API is a function that returns the temporary directory in a string
p70002
aVThat looks like this:
p70003
aVThe code in this function is the only code that needs to deal with C strings
p70004
aVYou can now forget all about them in the rest of your code which can treat this as a black box
p70005
aVDon't let the implementation details of the lowest common denominator C interface of Win32 leak into your nicely factored C++ code
p70006
as(dp70007
g7
V505088
p70008
stp70009
a((dp70010
g2
(lp70011
VHere are the things that can go wrong:
p70012
aVThe calling conventions do not match
p70013
aVThe function names do not match
p70014
aVThe struct declaration is incorrect
p70015
aVThe parameters do not match
p70016
aVYou are calling the function incorrectly
p70017
aVThe function is returning an error code
p70018
aVAssuming what you have told us is correct, none of these potential problems apply
p70019
aVI am confident that your interop code is correct
p70020
aVTherefore, the only remaining conclusions are that:
p70021
aVThe C code is incorrect
p70022
aVYour expectations of the C code are not correct
p70023
aVThe next step I would take would be to write some native code, using C or C++, and compare the behaviour of that code with your C#
p70024
aVI'd expect the behaviour to be the same
p70025
aVAt which point you need to look into what could be up with the library code
p70026
as(dp70027
g7
V505088
p70028
stp70029
a((dp70030
g2
(lp70031
VThat is a UTF-8 encoded string
p70032
aVTo display it in a Unicode control you must first convert it to UTF-16 which is the native encoding used on Windows
p70033
aVYou perform that conversion using, for example,
p70034
as(dp70035
g7
V505088
p70036
stp70037
a((dp70038
g2
(lp70039
VWARNING: Although the answer below addresses the question that was asked, I would recommend that nobody ever uses it
p70040
aVIf you want to perform rounding differently from  then write and call a dedicated function
p70041
aVYou can use a runtime code hook to change the implementation of
p70042
aVThe wrinkle is that it's a little tricky to get hold of the address of the  function though because it is an intrinsic
p70043
aVYou also have to be careful to follow the calling convention used
p70044
aVThe input value is passed in the x87 stack register  and the return value is a 64 bit integer in
p70045
aVHere's how to do it
p70046
aVIf you'd rather implement your version in Pascal than asm then you need to adapt the non-standard calling convention of  to the standard Delphi calling convention
p70047
aVLike this:
p70048
aVNote that I have assumed here that your program is targeting 32 bit
p70049
aVIf you need to target 64 bit then the principles are much the same, but the details obviously differ
p70050
as(dp70051
g7
V505088
p70052
stp70053
a((dp70054
g2
(lp70055
VNote: This answer applied to the original question
p70056
aVYou have to switch to 64 bit Python
p70057
aVAccording to your comments your object has size 5
p70058
aV7GB even with 32 bit floats
p70059
aVThat cannot fit in 32 bit address space which is 4GB, at best
p70060
aVOnce you've switched to 64 bit Python I think you can stop worrying about intermediate values using 64 bit floats
p70061
aVIn fact you can quite probably perform your entire calculation using 64 bit floats
p70062
aVIf you are already using 64 bit Python (and your comments confused me on the matter), then you simply do not need to worry about  or  returning a 64 bit float
p70063
aVThat's one single value out of ~1
p70064
aV5 billion values in your array
p70065
aVIt's nothing to worry about
p70066
aVNote: This answer applies to the new question
p70067
aVThe code in your question produces the following output:
p70068
aVfloat32
p70069
aVfloat32
p70070
aVfloat32
p70071
aVIn other words, the symptoms that you report are not in fact representative of reality
p70072
aVThe reason for the confusion is that you earlier code, that to which my original answer applied, was quite different and operated on a single dimensional array
p70073
aVIt looks awfully like  returns scalars as
p70074
aVBut when the return value is not a scalar, then the data type is not transformed in the way you thought
p70075
as(dp70076
g7
V505088
p70077
stp70078
a((dp70079
g2
(lp70080
VYou can define the Java class  that maps to your struct like this:
p70081
aVThen call it like this:
p70082
as(dp70083
g7
V505088
p70084
stp70085
a((dp70086
g2
(lp70087
VYou can use  from the  unit to measure elapsed time using the system's high-resolution performance counter
p70088
aVTo read a time value in seconds, say, from a time span, do this:
p70089
as(dp70090
g7
V505088
p70091
stp70092
a((dp70093
g2
(lp70094
VYou cannot do what you want with a  statement
p70095
aVThere is no way to name the object that is the subject of a with statement
p70096
aVUse a local variable instead
p70097
aVFor example:
p70098
aVAs an added benefit you get to remove these  statements that are a scoping blight on any code
p70099
as(dp70100
g7
V505088
p70101
stp70102
a((dp70103
g2
(lp70104
VThe documentation covers this topic here: Procedures and Functions, External Declarations
p70105
aVAs an example, the documentation shows how to link to the Windows API function :
p70106
aVNote: I corrected the multitude of errors in the documentation's declaration of this function
p70107
as(dp70108
g7
V505088
p70109
stp70110
a((dp70111
g2
(lp70112
VYour first function call fails because you did not initialise
p70113
aVYou need to do this:
p70114
aVOnce you fix that, the rest of the code will work as intended
p70115
as(dp70116
g7
V505088
p70117
stp70118
a((dp70119
g2
(lp70120
VThere are a few things wrong with your p/invoke:
p70121
aVThe calling convention looks to be
p70122
aVIt's not specified in the native code and the most likely default is
p70123
aVYou are passing  which is used for  parameters
p70124
aVNote that I am assuming that the two parameters are both input parameters
p70125
aVThe character set is wrong
p70126
aVThe native code receives 8 bit encoded text
p70127
aVYou do not need to be using
p70128
aVA corrected declaration is:
p70129
aVYou can omit the specification of character set since ANSI is the default
p70130
aVOf course, it doesn't hurt to specify  if you prefer to be explicit
p70131
aVThere's no need to specify  if it is the same name as the function that you declare
p70132
as(dp70133
g7
V505088
p70134
stp70135
a((dp70136
g2
(lp70137
V never fails
p70138
aVIt merely places they event that you specify into the currently active input queue
p70139
aVBecause the function is asynchronous the keyboard event is not processed until the other application gets round to processing it
p70140
aVSo, most likely the other application has not processed the keyboard event by the time you call
p70141
aVYou can't expect to know when a particular keyboard event is processed, unless you have control of the other application
p70142
aVBut in that case you would not be communicating with it by faking input
p70143
as(dp70144
g7
V505088
p70145
stp70146
a((dp70147
g2
(lp70148
VYour fundamental problem is a mis-understanding of the meaning of the indexed property
p70149
aVYour believe that this accesses just the top level nodes
p70150
aVThat is not so
p70151
aVThis property gives access to each and every node in the tree
p70152
aVThe way to understand that is to look at your tree, expand all folders, and read downwards from the top ignoring nesting
p70153
aVFor your tree, the indexing looks like this:
p70154
aVSo when you refer to  you are actually getting the node with caption Detail that is a child of the very first node, that named Pay History
p70155
aVThe node that you want has index 13 so you can change your code to be
p70156
aVThe other property that you are using is
p70157
aVThis is different again
p70158
aVThis access the list of direct children of a particular node
p70159
aVSo,  can be used to access the two nodes that are children of the first node, that named Pay History
p70160
aVIn your situation I would not want to write:
p70161
aVI would reject code that relied on a magic number like that
p70162
aVI would populate the tree view at runtime and save away in instance variables references to any nodes that I needed to use later
p70163
aVFor example:
p70164
aVIf you need to modify properties of the node later then you can do so with code that can be understood at a glance by the reader
p70165
aVAnd when you insert new nodes, or re-order the nodes, you don't break all your existing code as you would with a magic constant
p70166
as(dp70167
g7
V505088
p70168
stp70169
a((dp70170
g2
(lp70171
VSQLite is not restricted to ANSI
p70172
aVIt is a misconception that  implies ANSI encoded text
p70173
aVNot all functions that operate on  data assume that the data is ANSI encoded
p70174
aVIn the case of SQLite it fully supports Unicode and does so using  data encoded using UTF-8
p70175
aVIf you intend to continue using UTF-16 encoded text internal to your application you'll need to add an adapter layer at the boundary between your code and the SQLite code
p70176
aVConvert from UTF-16 to UTF-8 when passing data to SQLite, and the opposite direction when receiving
p70177
aVWhich to my mind renders the question that you asked somewhat moot, but I'll address that anyway:
p70178
aVAre there any limitations or negative impacts from using ANSI Functions in a Unicode Application
p70179
aVThe most obvious drawbacks of using ANSI functions are:
p70180
aVSeverely restricted character set
p70181
aVPerformance cost when converting between different character sets
p70182
aVRisk of programmer confusion and errors due to using multiple character sets in a single codebase
p70183
as(dp70184
g7
V505088
p70185
stp70186
a((dp70187
g2
(lp70188
VThere is not documented way to disable this behaviour for the rich edit control
p70189
aVThere are not styles, messages or functions that offer any way to disable this behaviour
p70190
aVThe  style that you have mentioned allows a small margin to be added when the text is left aligned
p70191
aVThe Delphi wrapper to the rich edit control does not include the  style so it's not as if you can remove it since it's never there in the first place
p70192
aVFor centred and right aligned text, the selection area is always present, irrespective of the presence or otherwise of the  style
p70193
aVIn fact the  style appears to make no difference at all to the control's behaviour for centred and right aligned text
p70194
aVI expect that if you reverse engineered the implementation of this selection zone, you'd be able to remove the behaviour by modifying the rich edit control's window procedure
p70195
as(dp70196
g7
V505088
p70197
stp70198
a((dp70199
g2
(lp70200
VThe windows style you are looking for is
p70201
aVNote that  includes  so your window is already sizeable
p70202
aVYour window procedure handling of  is what is stopping the resizing from working
p70203
aVRemove that case from the switch statement and resizing should start working again
p70204
as(dp70205
g7
V505088
p70206
stp70207
a((dp70208
g2
(lp70209
VC#  is analogous to, and has the same performance characteristics, as  C++
p70210
aVC#  is analagous to, and has the same performance characteristics, as C++
p70211
aVThe performance characteristics are discussed in some detail in the remarks sections of the relevant sections of the
p70212
aVnet documentation: ,
p70213
as(dp70214
g7
V505088
p70215
stp70216
a((dp70217
g2
(lp70218
VThe code in the article is correct, and all three of your proposed variants are not correct
p70219
aVLet's look at the correct code first, with some annotations:
p70220
aVThe key points to note here:
p70221
aVmodifies the list
p70222
aVdoes not modify the list
p70223
aVYour first two proposed versions are wrong because they do
p70224
aVat every iteration
p70225
aVAssigning to  modifies the list
p70226
aVImagine a scenario where  always returned false
p70227
aVIn that case you must never modify the list, but you modify it every time round the loop
p70228
aVAnd the final variant is wrong in because you are only passing in a  then there's no way for the caller's head pointer to be modified
p70229
aVIn fact, the final variant does not modify the list at all
p70230
as(dp70231
g7
V505088
p70232
stp70233
a((dp70234
g2
(lp70235
VProbably what happens is that you are managing to delete the
p70236
aVbat file before the  process can read and process it
p70237
aVYou'll need to wait for the process that you start with  to finish before deleting the file
p70238
aVLike this:
p70239
aVAs an aside, I do wonder why you feel the need to create the
p70240
aVbat file in a directory where you are not supposed to write
p70241
aVYou could readily create the
p70242
aVbat file under the temporary directory
p70243
aVIf you need the working directory to be a different directory then you can readily specify that when starting the process
p70244
as(dp70245
g7
V505088
p70246
stp70247
a((dp70248
g2
(lp70249
VYour problem is that you are trying to perform this action in a different process
p70250
aVWhen you call  you pass the address of a  struct
p70251
aVBut that address is only valid in your process
p70252
aVBecause each process has its own private virtual memory space, that pointer that you send has no meaning in the other process
p70253
aVIt's possible that you could use ,  and   to allocate, write and read an instance of the  struct in the address space of the other process
p70254
aVThat's your only hope of making this mechanism work
p70255
aVThere are lots of examples to be found using websearch that illustrate the technique
p70256
aVHowever, I would not recommend that you do that
p70257
aVYou should use one of the standard automation interfaces to solve your actual problem
p70258
aVFor example UIAutomation
p70259
as(dp70260
g7
V505088
p70261
stp70262
a((dp70263
g2
(lp70264
VThe cleanest way to modify the hint at runtime is to intercept the  message
p70265
aVDoing it this way means that you don't need to hunt down all the different events that might lead to your hint changing
p70266
aVInstead you simply wait until the hint is about to be shown and use the current state of the control to determine what to show
p70267
aVHere's an example using an interposer class:
p70268
aVIf you wanted to make this more useful you would derive a sub-class of  and add on  event that allowed such customisation to be specified in a less coupled manner
p70269
as(dp70270
g7
V505088
p70271
stp70272
a((dp70273
g2
(lp70274
VProbably the simplest way to do this is to install the 32 bit version of MATLAB and use the  from that installation
p70275
aVDon't worry about the warnings that you get about installing 32 bit MATLAB on 64 bit Windows
p70276
aVIt works just fine
p70277
aVI have lots of different versions of MATLAB installed on my machine for development purposes, both 32 and 64 bit, all happily co-existing side by side
p70278
aVThe documentation also mentions a  option that can be passed to :
p70279
aV-win32 Run in 32-Bit Mode
p70280
aVUse this option to build a 32-bit application on a 64-bit system only
p70281
aVwhen the following are both true:
p70282
aVYou use the same MATLAB installation root (matlabroot) for both 32-bit and 64-bit versions of MATLAB
p70283
aVYou are running from a Windows command line (not a MATLAB command line)
p70284
aVSince you have to install 32 bit MATLAB, no matter what, it seems to me that it's just easier to run the 32 bit  directly
p70285
as(dp70286
g7
V505088
p70287
stp70288
a((dp70289
g2
(lp70290
VYou have a tool button that is used to indicate a boolean state
p70291
aVSuch buttons should use the  tool button style
p70292
aVWhen the button uses that style, clicking the button toggles its  property
p70293
aVYou are using the  button style
p70294
aVThis is for a standard push button that is not meant to indicate state
p70295
aVWhen you have a , the  property is always  during and after the  event
p70296
aVIn addition to setting the style to  you can set the  property to   (keeping  as )
p70297
aVThat will prevent your button from automatic  state switching
p70298
aVYou'll be able then to switch the state of your button in the way you've used
p70299
as(dp70300
g7
V505088
p70301
stp70302
a((dp70303
g2
(lp70304
VThe property that you need is named  rather than
p70305
aVAlso note that the right hand side of the assignment as written in the question is also incorrect
p70306
aVYou presumably mean to read
p70307
as(dp70308
g7
V505088
p70309
stp70310
a((dp70311
g2
(lp70312
VThe function you are looking at is
p70313
aVfrom the  unit
p70314
aVPersonally I would not bother converting this to x64 assembler
p70315
aVThere are quite a few tricky details that you need to get right in order to do so
p70316
aVIt makes more sense to me to port to Pascal and let the compiler deal with the details
p70317
aVThe simplest most naive translation looks like this:
p70318
aVIf this is performance critical then you'd want to unroll the loop a little to operate on large operands
p70319
aVSay 32 bit operands on x86 and 64 bit operands on x64
p70320
aVA version that operated on 32 bit operands might look like this:
p70321
aVActually, you can easily enough write a version that automatically uses 32 or 64 bit operands as determined by the compilation target
p70322
aVThe trick is to use the  type which is machine word size
p70323
aVThis final version is pretty efficient when compiled with optimisations enabled
p70324
aVI would not look beyond that final Pascal version
p70325
as(dp70326
g7
V505088
p70327
stp70328
a((dp70329
g2
(lp70330
VYour paint box  event handler is probably dedicated to painting to the size of the paint box
p70331
aVYou need to generalize the painting code to be able to draw to a general canvas whose size is only known at runtime
p70332
aVThat way you can draw to the low resolution paint box and the high resolution file with the same painting code
p70333
aVExtract the code inside your  event handler into a separate method that looks like this:
p70334
aVThen call this method from your  handler
p70335
aVPass  as the parameter to the method
p70336
aVIn outline that looks like this:
p70337
aVFinally you can call the method from the method that saves the image to file
p70338
aVIn that case I assume you have a temporary bitmap on which to draw the image before saving
p70339
aVPass the canvas of that bitmap
p70340
aVA sketch of that code would be:
p70341
as(dp70342
g7
V505088
p70343
stp70344
a((dp70345
g2
(lp70346
VIt seems that you don't want to use any of the more powerful features of C++ so I suspect that you are really looking for a C style routine
p70347
aVThat would look like this:
p70348
aVYou'd need to allocate the destination buffer before calling
p70349
aVAnd for your example you would pass 3 for the skip parameter
p70350
aVPersonally I'd much rather do it using C++ standard containers, but this is what I think you asked for
p70351
as(dp70352
g7
V505088
p70353
stp70354
a((dp70355
g2
(lp70356
VYou are writing out UTF-16 character codes as integers
p70357
aVHence the file full of numbers
p70358
aVIt's probably easier just to blit the text buffer straight to the file:
p70359
aVYou may wish to put the UTF-16LE BOM at the front of the file to help your text editor work out the encoding that is in use
p70360
as(dp70361
g7
V505088
p70362
stp70363
a((dp70364
g2
(lp70365
VLet's take a look at this function:
p70366
aVThe compiler actually implements it like this:
p70367
aVThe compiler introduces a temporary local to store the result of
p70368
aVThere's a very good reason for that
p70369
aVIf it did not, where would it write the result of your addition operator
p70370
aVSince the ultimate destination is , if your addition operator writes directly to  it is modifying its input variable
p70371
aVThere is no way to stop the compiler generating this temporary local
p70372
as(dp70373
g7
V505088
p70374
stp70375
a((dp70376
g2
(lp70377
VThe  magic all happens in
p70378
aVWhen the hint stops showing that code sets the status bar text to be empty
p70379
aVYou could modify the behaviour like this:
p70380
aVI've used a rather crude interposer class and a brittle instance variable to store the text to be restored
p70381
aVYou could tart this up to be a little more robust if you wish
p70382
aVThe code above at least shows you the place you need to add your hooks
p70383
as(dp70384
g7
V505088
p70385
stp70386
a((dp70387
g2
(lp70388
VYou can simply pass the  struct by
p70389
aVYou will also need to ensure that the calling conventions match
p70390
aVIt looks to me as though the native code is
p70391
aVFinally,  means ANSI on Win9x and Unicode elsewhere
p70392
aVSo, that is appropriate if the native code expects a UTF-16 string
p70393
aVIf it expects ANSI then use  instead
p70394
aVThis code works correctly, and the string specified in the C# code is received by the native code
p70395
as(dp70396
g7
V505088
p70397
stp70398
a((dp70399
g2
(lp70400
VThere's another way to influence which windows appear on the taskbar, namely
p70401
aVThis allows an app to add or remove whichever windows it likes
p70402
aVAnd this means that code based on window styles can never work with 100% reliability
p70403
aVSo far as I am aware, there is no supported way to query for taskbar buttons added or removed using
p70404
aVI ignored the Linux aspect of your question because the question is tagged Delphi and Delphi does not target Linux
p70405
aVCode that will work with whichever Linux shell you happen to use will necessarily not be cross-platform
p70406
as(dp70407
g7
V505088
p70408
stp70409
a((dp70410
g2
(lp70411
VI want to have a event that tells me that a new object was just created at run time (or destroyed)
p70412
aVThere are no built in events that fire whenever an object is created or destroyed
p70413
aVBecause I like writing code hooks, I offer the following unit
p70414
aVThis hooks the  method in the  unit
p70415
aVIdeally it should use a trampoline but I've never learnt how to implement those
p70416
aVIf you used a real hooking library you'd be able to do it better
p70417
aVAnyway, here it is:
p70418
aVAssign a handler to  and that handler will be called whenever an object is created
p70419
aVI leave it as an exercise to the reader to add an  event handler
p70420
aVNote that I am not saying that such an approach is a good thing to do
p70421
aVI'm just answering the direct question that you asked
p70422
aVYou can decide for yourself whether or not you want to use this
p70423
aVI know I would not do so
p70424
as(dp70425
g7
V505088
p70426
stp70427
a((dp70428
g2
(lp70429
VI'm going to assume that the code does not explicitly use
p70430
aVSince that data type differs between 32 and 64 bit (it's 10 bytes in 32 bit and 8 bytes in 64 bit), any explicit use of  introduces an immediate difference
p70431
aVI'm going to assume that you are using  for all your variables
p70432
aVAlthough the arguments below transfer across equally to
p70433
aVBeyond that, the most common reason for this is a difference in behaviour between the two floating point units
p70434
aVThe x87 unit, used by 32 bit code, stores intermediate values to 80 bit extended precision
p70435
aVThe SSE unit, used by 64 bit code, stores intermediate values to 64 bit double precision
p70436
aVNow, the x87 unit can be configured using the control word to store intermediate values to 64 bit precision
p70437
aVIt makes no difference in terms of performance, but will align your 32 and 64 bit results to be closer
p70438
aVEven then you won't get exactly the same results on the different units
p70439
aVIn fact you won't get the exact same results on all x87 units
p70440
aVEven though these units are all IEEE754 conformant, that standard allows a degree of leeway for calculations
p70441
aVWhat's more, higher order calculations like trigonometry, logarithms, exponentiation etc
p70442
aVare performed quite differently between 32 and 64 bit
p70443
aVThe 32 bit unit has more built in functionality than the 64 bit unit
p70444
aVYou'll note in the Delphi source code that the trig functions, for example, are all implemented in the RTL for 64 bit
p70445
aVOn 32 bit code they are implemented by calling x87 ops
p70446
aVThe bottom line is that you will never get your 32 and 64 bit programs to agree exactly when there are floating point calculations involved
p70447
aVYou will have to accept differences to a small tolerance
p70448
as(dp70449
g7
V505088
p70450
stp70451
a((dp70452
g2
(lp70453
VThe first failure occurs at
p70454
aVYou pass it an uninitialized pointer
p70455
aVYou then pass on that same uninitialized pointer to
p70456
aVChange your code to allocate a buffer:
p70457
aVIf you had checked the return value of  for errors you would have learnt that something was wrong there
p70458
aVAlways check return values for errors with the Windows API
p70459
as(dp70460
g7
V505088
p70461
stp70462
a((dp70463
g2
(lp70464
VThere is no problem with two threads accessing distinct regions of memory in terms of correctness
p70465
aVThe issue that may affect you are the performance problems due to false sharing
p70466
aVYou can avoid those by making sure that there is at least a whole cache line of unused space between the two regions of memory
p70467
aVIf you want to learn more about false sharing I refer you to one of Herb Sutter's articles on the subject: Eliminate False Sharing
p70468
as(dp70469
g7
V505088
p70470
stp70471
a((dp70472
g2
(lp70473
VThis is an endianness mis-match
p70474
aVYou are displaying the value using one endianness convention, but your expected value uses the other convention
p70475
aVEndianness is a well-known issue for integer data types, but it is perhaps less well known endianness also affects floating point representation
p70476
as(dp70477
g7
V505088
p70478
stp70479
a((dp70480
g2
(lp70481
VAs Rob explained, WS_EX_NOACTIVATE is not relevant here
p70482
aVMost likely you used WS_EX_TRANSPARENT and that made your window transparent to mouse clicks
p70483
aVTo get finer grained control of mouse click transparency, handle the WM_NCHITTEST message in your top level window
p70484
aVReturn HTTRANSPARENT for regions that you want to be "click through"
p70485
aVOtherwise return, for example, HTCLIENT
p70486
as(dp70487
g7
V505088
p70488
stp70489
a((dp70490
g2
(lp70491
VAssuming that your byte array is UTF-16 encoded, you can simply cast the buffer to  and pass that to the string's constructor:
p70492
aVIf the buffer contains a null-terminator you'd need to subtract that from the length passed to the constructor
p70493
as(dp70494
g7
V505088
p70495
stp70496
a((dp70497
g2
(lp70498
VWhat type of 'string' is 'Result' if the notation Result
p70499
aVLength is allowed
p70500
aVIt's just the same old , aliased to , that you've been using since
p70501
aVThe difference is that this code uses the new record helper (specifically )
p70502
aVThat's what lets you use  notation on a string variable
p70503
aVIs there a way in which I can tell the compiler to use 'XE3' compatibility for a unit
p70504
aVNo
p70505
aVThe code in question is a library unit and it is designed to be compiled in a particular mode
p70506
aVWhat's more, you can't readily re-compile it unless you take on compiling the RTL/VCL yourself
p70507
aVEven if there was such a mode, it would not help since the code is simply wrong (see below)
p70508
aVNo amount of mode switching can fix this particular piece of code
p70509
aVI get to thinking maybe this is something to do with the Immutable strings that I've heard about
p70510
aVIt's not
p70511
aVNone of the Delphi compilers have immutable strings yet
p70512
aVThe concept of immutable strings is just something that has been floated as a future change
p70513
aVAnd if the change is made, expect it to be made in the mobile compilers first
p70514
aVThe problem is in fact just a rather simple bug in the code that you posted which has clearly had no testing at all
p70515
aVThe use of  is wrong
p70516
aVThat method does not modify the string in-place
p70517
aVInstead it returns a new string that has the character removed
p70518
aVThe code should read:
p70519
aVThe reason that the developer who coded  has made this mistake is that whoever designed the string helper code named the  method incorrectly
p70520
aVSince  is a verb you would expect it to operate in-place
p70521
aVA method that does not modify the subject, and returns a new instance, as this method does, should be given a name that is a noun
p70522
aVSo this method should be named something like
p70523
aVIt looks to me as though the RTL designers copied the
p70524
aVnet naming where the same flaw also exists
p70525
aVYou should submit a QC report, if one does not already exist
p70526
aVI know that XE4 update 1 has just been released
p70527
aVIt's plausible that it contains a fix
p70528
aVYour other options, as I see them, are:
p70529
aVStick with XE3 until XE4 is sufficiently debugged
p70530
aVInclude a copy of the  unit in your project and fix the bugs yourself
p70531
as(dp70532
g7
V505088
p70533
stp70534
a((dp70535
g2
(lp70536
VThere won't be any corruption unless you perform string conversion operations
p70537
aVPut a byte into an  like this:
p70538
aVOr you can use a cast:
p70539
aVThat puts a single byte into an element of a pre-allocated
p70540
aVIn the opposite direction you write:
p70541
aVIf you want to blit a byte array onto a string then use:
p70542
aVThis code is the same as your third method
p70543
aVIt works just fine and there will be no corruption, unless you perform some subsequent operation on the string
p70544
aVYour first method will also work but is over-complicated
p70545
aVYour second method does something completely different involving hexadecimal representation
p70546
aVI'm not quite sure what you were trying to achieve there
p70547
aVBut you really want to be using byte arrays rather than strings
p70548
aVA dynamic array of byte,  is your guy
p70549
as(dp70550
g7
V505088
p70551
stp70552
a((dp70553
g2
(lp70554
VThe easiest way by far to do this is to compile a mixed mode C++/CLI DLL
p70555
aVIt is called mixed mode because it mixes managed and unmanaged code
p70556
aVYou can compile your existing C++ class into a mixed mode DLL
p70557
aVThen to export the functionality as a managed class, wrap it up in a C++/CLI ref class
p70558
aVOnce you've done that you can add it as a reference in your C# program and it's all good
p70559
as(dp70560
g7
V505088
p70561
stp70562
a((dp70563
g2
(lp70564
VWhen using , for the  format string you must specify how many characters you wish to read:
p70565
aVThe documentation describes the requirement:
p70566
aVUnlike scanf and wscanf, scanf_s and wscanf_s require the buffer size to be specified for all input parameters of type c, C, s, S, or string control sets that are enclosed in []
p70567
aVThe buffer size in characters is passed as an additional parameter immediately following the pointer to the buffer or variable
p70568
as(dp70569
g7
V505088
p70570
stp70571
a((dp70572
g2
(lp70573
VThe issue of what  is covered in another Stack Overflow question: POINTER_32 - what is it, and why
p70574
aVYou would use it when performing interop with structs that are defined in a different process, one that has 32 bit pointers
p70575
aVYou don't have the equivalent of  in Delphi so you have simply no choice other than to declare it as a 32 bit integer
p70576
aVI would use an unsigned type
p70577
as(dp70578
g7
V505088
p70579
stp70580
a((dp70581
g2
(lp70582
VFirst of all change the C++ code to use only one level of indirection:
p70583
aVOn the C# side you want this:
p70584
aVYou'll also need to export a function that will deallocate the array you allocated using the C++ heap
p70585
aVOtherwise you'll leak it
p70586
aVPerhaps an easier approach would be to change the design to have the caller allocating the buffer
p70587
as(dp70588
g7
V505088
p70589
stp70590
a((dp70591
g2
(lp70592
VThe casting is fine, and I'm going to assume that you send the correct number of bytes
p70593
aVWhich can be found with  and equals 8 for the code in your question, assuming that  is a 2 byte UTF-16 character
p70594
aVOr if your  is a 4 byte UTF-32 character then  will be 16
p70595
aVThe problem would then be at the other end, in the code that reads the data
p70596
aVI can imagine three obvious failure modes:
p70597
aVYou fail to read the entire buffer
p70598
aVPerhaps you assume that the content is null terminated and read up to the first zero byte
p70599
aVThat would be incorrect since a null  is actually two zero bytes
p70600
aVYou read the entire buffer correctly, but you interpret the data as  rather than
p70601
aVYou read the data correctly and interpret it correctly as
p70602
aVBut  is UTF-32 on the sender and UTF-16 for the receiver
p70603
aVWhich means that you'd interpret the data as UTF-16 when it is in fact UTF-32
p70604
aVAny of those explanations would explain why you only received the first character
p70605
aVIn any case I think you are going about the problem in the wrong way
p70606
aVYou should probably not be passing UTF-16/UTF-32 down the wire
p70607
aVYou'd be much better off with a byte oriented encoding for your text and the natural choice is UTF-8
p70608
aVUpdate
p70609
aVYour update makes it a little clearer what is going on
p70610
aVYou are sending UTF-32 data over the wire, but then interpreting that data as UTF-16 (assuming your Windows program is a Unicode program)
p70611
aVThis mis-match leads to the data being interpreted incorrectly and explains why you only receive the first character
p70612
aVThat's item 3 above
p70613
aVIn order to solve this you need to be very clear about how your text is to be encoded
p70614
aVThe fundamental problem you have can be observed by the fact that not anywhere in your question do you talk about text encoding
p70615
aVIf you want to pass data between different programs you need to agree on a common text encoding
p70616
aVAgain, I recommend that you put UTF-8 encoded text on the wire
p70617
aVYou also have a problem that you are assuming that the text is null-terminated
p70618
aVIf you have a transmission error then your receiving program has a buffer overrun
p70619
aVThe other issue you will need to get on top of is that of endianness
p70620
aVYou need all parties to agree a common endianness for the data on the wire
p70621
aVUse network byte order
p70622
as(dp70623
g7
V505088
p70624
stp70625
a((dp70626
g2
(lp70627
VYour long running task is running on the GUI thread and it is blocking the GUI thread
p70628
aVThe GUI thread must service its message queue in a timely fashion
p70629
aVYou need to move the long running code to a separate thread
p70630
aVThat is the only viable solution
p70631
aVYour attempts to call  no doubt fail because they would need to be made from inside the script to have any impact
p70632
aVIn any case calling  is never a real solution to a problem and should be avoided
p70633
as(dp70634
g7
V505088
p70635
stp70636
a((dp70637
g2
(lp70638
VThe problem is that you should not be performing any UTF-8 encoding
p70639
aVPass strings to the XML library, and let it do the encoding
p70640
aVSo, replace
p70641
aVwith
p70642
aVYou must remove that call to
p70643
aVYou are passing an interface reference and  is for object instance references
p70644
aVSimply remove it and let the interface reference counting code do its work
p70645
as(dp70646
g7
V505088
p70647
stp70648
a((dp70649
g2
(lp70650
VLet's look at the code:
p70651
aV004520F4 55             push ebp
p70652
aV004520F5 8BEC           mov ebp, esp
p70653
aV004520F7 6A00           push $00
p70654
aV004520F9 53             push ebx
p70655
aV004520FA 33D2           xor edx,edx
p70656
aVEach line here represent a single machine instruction
p70657
aVThe information presented is as follows:
p70658
aVThe first column is the address at which the instruction starts, displayed in hex
p70659
aVThe second column is the machine code for the instruction, displayed in hex
p70660
aVThe third column is the instruction disassembled to assembler language
p70661
aVSo the second and third columns represent the exact same information
p70662
aVThe third column is provided to make the code more understandable
p70663
aVNote that different instructions have different lengths
p70664
aVThe first and fourth instructions are only a single byte long
p70665
aVThe others are two bytes long
p70666
aVAnd that explains why the instruction address increments by more than a single byte following two byte instructions
p70667
aVThere are instructions that can take even more than two bytes and so you can have increments of 3, 4 and so on for such instructions
p70668
aVA good example would be call or jump instructions which encode the target address or offset
p70669
aVSo, an absolute jump on a 32 bit machine might be encoded in 5 bytes, one for the opcode and four for the address
p70670
aVBack in the good old days, long before I was even born, programmers didn't even have assemblers and wrote code directly in machine instructions
p70671
aVThat must have been a whole load of fun
p70672
as(dp70673
g7
V505088
p70674
stp70675
a((dp70676
g2
(lp70677
VYou've got a multi-line edit control
p70678
aVAs soon as it has the focus, then it will process all presses of the ENTER key
p70679
aVThat's by design
p70680
aVIf the button handled presses of the ENTER key when the edit control has focus, how could you enter a new line in the edit control
p70681
aVIf you do need to stop the multi-line edit control from eating the ENTER key then you can handle  to arrange that
p70682
aVThe technique is explained here: http://blogs
p70683
aVmsdn
p70684
aVcom/b/oldnewthing/archive/2006/10/12/819674
p70685
aVaspx
p70686
aVAs an aside, the strcpy_s is spurious
p70687
aVCall c_str() on your string and pass that directly to the API function
p70688
as(dp70689
g7
V505088
p70690
stp70691
a((dp70692
g2
(lp70693
VYour question boils down to this:
p70694
aVHow do I specify a single quote character in a Delphi string
p70695
aVYou do that by escaping the quote like this:
p70696
aVSo, to specify a string containing a single quote surrounded by spaces, say, you write this:
p70697
aVTo run your macro you quote it like this:
p70698
aVThe full details can be found in the documentation
p70699
as(dp70700
g7
V505088
p70701
stp70702
a((dp70703
g2
(lp70704
VYou can use  and  to obtain the information that you require
p70705
aVNote that since  is passed to the  parameter of , elevated rights are not required
p70706
aVThis is explained, albeit somewhat opaquely, in the documentation:
p70707
aVDirect access to the disk or to a volume is restricted
p70708
aVThe following requirements must be met for such a call to succeed:
p70709
aVThe caller must have administrative privileges
p70710
aVThe dwCreationDisposition parameter must have the OPEN_EXISTINGflag
p70711
aVWhen opening a volume or floppy disk, the dwShareMode parameter must have the FILE_SHARE_WRITEflag
p70712
aVNote The dwDesiredAccess parameter can be zero, allowing the application to query device attributes without accessing a device
p70713
aVThis is useful for an application to determine the size of a floppy
p70714
aVdisk drive and the formats it supports without requiring a floppy disk
p70715
aVin a drive, for instance
p70716
aVIt can also be used for reading statistics
p70717
aVwithout requiring higher-level data read/write permission
p70718
as(dp70719
g7
V505088
p70720
stp70721
a((dp70722
g2
(lp70723
VTo me the problem looks to stem from this declaration:
p70724
aVHere you are telling the compiler that  is a pointer to a function that returns
p70725
aVBut you have not specified the parameters of the function and so the compiler will let you pass anything you like and it will attempt to work out what types to pass
p70726
aVThat's very bad practice
p70727
aVYou should stop doing this
p70728
aVChange the declaration of normal to be as follows:
p70729
aVI cannot see anywhere in the C++ code that specifies calling convention so the assumption is that the default of  is in effect
p70730
aVObviously you need to match that on your side of the interface and if you specify no calling convention for your function pointer then you'll get the default of  as well
p70731
as(dp70732
g7
V505088
p70733
stp70734
a((dp70735
g2
(lp70736
VYou simply need to pass  in the  parameter
p70737
as(dp70738
g7
V505088
p70739
stp70740
a((dp70741
g2
(lp70742
VThe compiler makes it quite clear
p70743
aVThe problematic line is this one:
p70744
aVThe error is:
p70745
aV[dcc32 Error] E2010 Incompatible types: 'Unit2
p70746
aVTSomeGeneric' and
p70747
aVUnit1
p70748
aVTSomeGeneric'
p70749
aVThat's because in that method call:
p70750
aVis of type  and
p70751
aVexpects a parameter of type
p70752
aVAnd those are not the same type because you explicitly made them different
p70753
aVdefines a new type and now you have two types that are not compatible
p70754
aVYou will simply have to remove
p70755
aVIt serves no purpose other than to stop reasonable code compiling
p70756
as(dp70757
g7
V505088
p70758
stp70759
a((dp70760
g2
(lp70761
VA method of object is what is known as a two pointer type
p70762
aVIt encapsulates the following information:
p70763
aVThe address of the function
p70764
aVThe address of the object, or the subject
p70765
aVThe former is known at compile time but generally the latter is not
p70766
aVWhich is why you typically need to create these things at runtime
p70767
aVIf you can arrange that the subject is known at compile time then you can declare a typed constant of your record type
p70768
aVFor example:
p70769
aVOf course, that's only going to be useful to you if your functions are viable as class methods rather than instance methods
p70770
aVI'm just adding the code above to illustrate that you can have constant method pointers, so long as the subject is a compile time constant
p70771
as(dp70772
g7
V505088
p70773
stp70774
a((dp70775
g2
(lp70776
VThe first three bytes are skipped because the RTL code assumes that the file contains a UTF-8 BOM
p70777
aVClearly your file does not
p70778
aVThe  class implements a  method that specifies the  BOM
p70779
aVAnd  skips the preamble specified by the encoding that you pass
p70780
aVOne simple solution would be to read the file into a byte array and then use  to decode it into a string
p70781
aVAn more comprehensive alternative would be to make a  instance that ignored the UTF-8 BOM
p70782
aVInstantiate one of these (you only need one instance per process) and pass it to
p70783
aVThe advantage of using a singleton instance of  is that you can use it anywhere that expects a
p70784
as(dp70785
g7
V505088
p70786
stp70787
a((dp70788
g2
(lp70789
VThe Microsoft C compiler only supports a 25 year old version of the language
p70790
aVAnd one of the limitations is that all variables must be declared before any other statements
p70791
aVSo move all your variable declarations to the top of the function
p70792
aVThe next error I can see is the use of  with the  format string
p70793
aVYou must pass a pointer to the variable, and pass the number of characters to read
p70794
aVAnd likewise you need to pass an address for the read of
p70795
aVYou also need to change the switch statement so that it just contains cases
p70796
aVMove the bare instructions outside
p70797
aVYour reading of  won't work
p70798
aVBecause when you check for  you are checking for the character with ASCII code 1
p70799
aVChange  to be an  and read using
p70800
aVPerhaps you are looking for something like this:
p70801
as(dp70802
g7
V505088
p70803
stp70804
a((dp70805
g2
(lp70806
VIt's a bit hard to tell for sure what is wrong, because we are missing a lot of the details
p70807
aVNot least the fact that you included none of the information about the types, and no error message
p70808
aVThe thing that leaps out at me is that you set  to be the type specified by
p70809
aVThen you iterate across its properties and read them from an instance  that is of type
p70810
aVThat looks wrong
p70811
aVThe parameter that you pass to  must be of type
p70812
aVI expect that you need to pass a different instance to
p70813
aVI'd also question the use of an unchecked cast
p70814
aVThat just makes like hard for you
p70815
aVUse a checked cast:
p70816
aVYour code also assumes that all properties of  are of type
p70817
aVPerhaps that's a reasonable assumption, I don't know
p70818
as(dp70819
g7
V505088
p70820
stp70821
a((dp70822
g2
(lp70823
VClearly the code in the question bears no relation to the error
p70824
aVSince you've obviously pasted that error message, the real code must indeed produce the error
p70825
aVLet's look at the error:
p70826
aVYou see error E2010 when you attempt an assignment of two things that are not assignment compatible
p70827
aVIn this case you are attempting to assign a string to a dynamic array, something that is a syntax error
p70828
aVYour code therefore looks like this:
p70829
as(dp70830
g7
V505088
p70831
stp70832
a((dp70833
g2
(lp70834
VYou are linking to a function that has been exported with a mangled name, and that name is
p70835
aVThe DLL that is being loaded does not export a function of that name and hence the error
p70836
aVThe name mangling encodes the function's name, parameters and return value
p70837
aVSo the most likely cause for the mismatch is that you have changed the name, parameters or return value of the function in one place but not the other
p70838
aVIf you have changed the DLL you'll need to re-compile it to produce new
p70839
aVlib and
p70840
aVdll files
p70841
aVYou will also have modified the
p70842
aVh file
p70843
aVMake sure that the modified versions of all three of those files are used by the program that links to the DLL
p70844
aVThis error message is actually helpful to you because it will make sure that both sides of the interface match before you can proceed to execute the code
p70845
aVUpdate
p70846
aVI didn't make it clear enough in the text above
p70847
aVWhenever you change the interface of the DLL you must do the following:
p70848
aVUpdate any
p70849
aVh files that are used by the application
p70850
aVRe-compile the DLL to produce new
p70851
aVlib and
p70852
aVdll files
p70853
aVRe-compile the application using the updated
p70854
aVlib and
p70855
aVh files
p70856
aVDistribute the new
p70857
aVdll file so that the updated application loads the updated DLL
p70858
as(dp70859
g7
V505088
p70860
stp70861
a((dp70862
g2
(lp70863
VYour code is fine in all versions of Delphi
p70864
aVAlthough clearly it involves a UTF-16 to ANSI conversion when compiled by a pre-Unicode Delphi
p70865
aVHowever, since you use Delphi 2009 that is not an issue
p70866
aVThere are no problems regarding Unicode conversions
p70867
aVThe  function fills out the buffer that you supply with a null-terminated UTF-16 string
p70868
aVAnd since you declared  to be exactly that, Delphi will generate code necessary to copy to a Delphi  variable
p70869
aVIs it possible that  is returning false and so  is not initialized properly
p70870
aVOther than that, the only conclusions that one can make are that:
p70871
aVis lying to you when it returns
p70872
aVThe serial number returned by calling  really is
p70873
as(dp70874
g7
V505088
p70875
stp70876
a((dp70877
g2
(lp70878
V works fine
p70879
aVThe problem is that you are attempting to load a 32 bit DLL into a 64 bit process
p70880
aVThis cannot be done and the error message that you quote is the result of attempting to mix modules with non-matching bitness
p70881
aVThe problem is not in the p/invoke signature for , rather the call to  that is not shown in the question
p70882
aVThat call is resulting in an attempt to load a 32 bit DLL into your 64 bit process
p70883
aVUnless you have 64 bit versions of all the native DLLs that you load, you'll need to stick to x86
p70884
aVAs an aside there's really no point in using  for this function
p70885
aVSince
p70886
aVnet use UTF-16 text natively you would be far better off using , avoiding any character set conversions and making sure that your program can support Unicode file names
p70887
aVUpdate
p70888
aVIn the comments you ask if it is possible to load a 32 bit DLL from a 64 bit process for the purpose of extracting resources
p70889
aVIt is possible, but not with
p70890
aVYou need to call  passing
p70891
as(dp70892
g7
V505088
p70893
stp70894
a((dp70895
g2
(lp70896
VThere's padding in the struct which you are not allowing for that, hence the  error
p70897
aVThe easiest and most reliable way to find out the size of the struct is to get the compiler to work it out:
p70898
aVAnyway, you can work it out by hand readily enough:
p70899
aVType         Name              Offset   Size
p70900
aV----         ----              ------   ----
p70901
aVNTSTATUS     ExitStatus;        0        4
p70902
aVPadding            4        4
p70903
aVPVOID        TebBaseAddress;    8        8
p70904
aVCLIENT_ID    ClientId;          16      16
p70905
aVKAFFINITY    AffinityMask;      32       8
p70906
aVKPRIORITY    Priority;          40       4
p70907
aVKPRIORITY    BasePriority;      44       4
p70908
aVSo that would make the total size of the struct 48 bytes, or
p70909
aVThe padding is to ensure that  is 8 byte aligned
p70910
as(dp70911
g7
V505088
p70912
stp70913
a((dp70914
g2
(lp70915
VWhat you are trying to achieve cannot be done very easily and is not supported
p70916
aVHowever, it is possible using a modicum of hacking
p70917
aVAaron Margosis wrote an article describing one technique
p70918
aVTo quote the pertinent section, you will need to carry out these steps:
p70919
aVEnable the SeIncreaseQuotaPrivilege in your current token
p70920
aVGet an HWND representing the desktop shell (GetShellWindow)
p70921
aVGet the Process ID (PID) of the process associated with that window (GetWindowThreadProcessId)
p70922
aVOpen that process (OpenProcess)
p70923
aVGet the access token from that process (OpenProcessToken)
p70924
aVMake a primary token with that token (DuplicateTokenEx)
p70925
aVStart the new process with that primary token (CreateProcessWithTokenW)
p70926
aVThe article contains a download link for some demo C++ source from which it should be simple enough to translate to Delphi
p70927
as(dp70928
g7
V505088
p70929
stp70930
a((dp70931
g2
(lp70932
VIt looks to me as though you have sparse solver code written in C and are trying to link that to your Delphi program
p70933
aVI think you have a fundamental problem in the way you have declared your external imports
p70934
aVRather than answer the question you asked directly, I'll show you what I believe to be the right way to declare and call such external imports
p70935
aVThe first thing I would say is that the large static array types that you have declared are not what you need here
p70936
aVThose array types can sometimes be useful, but only really when you cast another array to
p70937
aVIn your situation you don't need those arrays at all and I do suggest that you remove them
p70938
aVI'm going to assume that you are calling a function called  that takes , , , ,  and  as input parameters and returns  as an output parameter
p70939
aVThe function returns  such that  where  is the  dimensional square sparse matrix specified by ,  and
p70940
aVThe  parameter specifies the number of non-zero elements
p70941
aVNo doubt the actual function will vary in details, but the concepts will be just the same
p70942
aVFor example, it's common to infer  from , but those details are for you to resolve
p70943
aVI suggest that you declare the function to receive the parameters as pointers to the first element
p70944
aVSo the function declarations looks like this:
p70945
aVThen you need to populate your sparse matrix arrays
p70946
aVDeclare these as dynamic arrays:
p70947
aVI expect that you will only know the value of ,  etc
p70948
aVat runtime and that the content of the matrix will be filled out using loops and so on
p70949
aVThe code in the question is presumably test code to try and test out the external code
p70950
aVArnaud's answer gives you sound advice on how to populate a dynamic array
p70951
aVYou will also need to initialise  and :
p70952
aVNow you can call the function:
p70953
aVOne final point, converning the use of generic arrays
p70954
aVSince you are using a modern Delphi I do suggest that you use generic dynamic arrays
p70955
aVSo, instead of  you should use
p70956
aVThe reason for this is that generic types have different type compatibility rules from old-style dynamic arrays
p70957
aVIn the code above, for example,  and  are assignment compatible
p70958
aVBut if they were declared like this:
p70959
aVthen they would not be assignment compatible
p70960
aVYou can get around that issue by declaring a type,
p70961
aVHowever, if you use the generic array then you can use generic container classes such as  than return values of type  which you can readily consume
p70962
aVI know this isn't quite the question that you asked but I have a feeling that it may be useful to you
p70963
as(dp70964
g7
V505088
p70965
stp70966
a((dp70967
g2
(lp70968
VThe  is aligned in the C++ code, but VBA structs are packed
p70969
aVIn 32 bit, for your struct, it does not matter since all members have alignment 4
p70970
aVBut in 64 bit the pointers need 8 byte alignment and the struct has some extra padding
p70971
aVPut it in like this:
p70972
aVI guess you'll want some conditional compilation to switch better 32 and 64 bit versions but I must confess to having no idea how to do that with VBA
p70973
as(dp70974
g7
V505088
p70975
stp70976
a((dp70977
g2
(lp70978
V does not offer you a means to receive progress callbacks
p70979
aVYou can either accept the progress feedback dialog provided by the system, or do without any progress reporting at all
p70980
aVThere is  which supports progress callbacks
p70981
aVBut that only caters for copying a single file and not an entire directory
p70982
aVOn Vista and later there is  which is the replacement for
p70983
aVThis interface is more capable than
p70984
aVYou can use  to copy entire directories, and receive progress notification
p70985
aVIf you need to support XP or earlier then you would need to write your own directory copy routine
p70986
aVYou would have to calculate the total size of files to be copied, and then perform each individual file copy with
p70987
aVYou'd receive progress callbacks from  and then turn them into overall progress events for your application to display
p70988
as(dp70989
g7
V505088
p70990
stp70991
a((dp70992
g2
(lp70993
VC parameters are always passed by value rather than by reference
p70994
aVHowever, if you think of the address of an object as being a reference to that object then you can pass that reference by value
p70995
aVFor example:
p70996
aVYou ask in a comment:
p70997
aVSo why do we need pointers in C when we can pass all the parameters by value
p70998
aVBecause in a language that only supports pass-by-value, lack of pointers would be limiting
p70999
aVIt would mean that you could not write a function like this:
p71000
aVIn Java for example, it is not possible to write that function because it only has pass-by-value and has no pointers
p71001
aVIn C++ you would write the function using references like this:
p71002
aVAnd similarly in C#:
p71003
as(dp71004
g7
V505088
p71005
stp71006
a((dp71007
g2
(lp71008
VException code  is the code for an access violation
p71009
aVThat means that your program is accessing (either reading or writing) a memory address to which it does not have rights
p71010
aVMost commonly this is caused by:
p71011
aVAccessing a stale pointer
p71012
aVThat is accessing memory that has already been deallocated
p71013
aVNote that such stale pointer accesses do not always result in access violations
p71014
aVOnly if the memory manager has returned the memory to the system do you get an access violation
p71015
aVReading off the end of an array
p71016
aVThis is when you have an array of length  and you access elements with index
p71017
aVTo solve the problem you'll need to do some debugging
p71018
aVIf you are not in a position to get the fault to occur under your debugger on your development machine you should get a crash dump file and load it into your debugger
p71019
aVThis will allow you to see where in the code the problem occurred and hopefully lead you to the solution
p71020
aVYou'll need to have the debugging symbols associated with the executable in order to see meaningful stack traces
p71021
as(dp71022
g7
V505088
p71023
stp71024
a((dp71025
g2
(lp71026
V and  are completely unrelated
p71027
aVThe  function is badly named
p71028
aVIts inverse function,  is similarly badly named given that it restores windows
p71029
aVI suspect these names dates back a very long way indeed, probably to Windows version 1 or 2
p71030
aVI'm speculating that what we now call minimize and restore were, back then, called close and open
p71031
aVThe usual way to minimize or restore a window is to call  passing  or
p71032
aVI suggest that you forget all about  and
p71033
as(dp71034
g7
V505088
p71035
stp71036
a((dp71037
g2
(lp71038
VThe most important thing for you to learn here is how to interpret the error messages that the compiler produces
p71039
aVSometimes they don't help that much, but in this case the messages tells you all you need to know
p71040
aVThe error message is:
p71041
aVThat means that you are accessing element 2 of the list and that element two does not exist
p71042
aVThis means that the list has a could of 0 or 1
p71043
aVWhen you write , the list raises an exception because  does not exist
p71044
aVThis is entirely to be expected
p71045
aVIf you split  then the result is:
p71046
aVand there is no element indexed 2
p71047
aVThe reason that your code accesses  can be found here:
p71048
aVfor i := 48 to 57 do
p71049
aVif A[1]<>char(i) then
p71050
aVc:=1
p71051
aVelse
p71052
aVif A[1]=char(i) then
p71053
aVc:=2;
p71054
aVClearly  is never equal to  for any value of  and so set  to be
p71055
aVWhich then leads to this code executing:
p71056
as(dp71057
g7
V505088
p71058
stp71059
a((dp71060
g2
(lp71061
VLet's look at your delegate:
p71062
aVFirst of all, I don't know what  is so I cannot comment on how it is marshalled
p71063
aVThat's certainly a possible failure vector
p71064
aVThe  handle presents no issues
p71065
aVPresumably on the native side that is a pointer of some sort, perhaps
p71066
aVThe most obvious problem with the code then is the string parameter,
p71067
aVThe marshaller assumes that you will pass a pointer to null terminated array of wide characters
p71068
aVIn native terms that is
p71069
aVHowever, the marshaller also takes on responsibility for destroying the native memory
p71070
aVAnd it assumes that the memory was allocated from the COM heap and so calls
p71071
aVI think it likely that your native code does not allocate the null terminated character array on the COM heap
p71072
aVThis would certainly explain crashes on some platforms but not others
p71073
aVHere are a few ways to solve the issue:
p71074
aVGet the native code to allocate off the COM heap and let the managed code deallocate it
p71075
aVIf the native code allocates and deallocates, then declare the parameter in your delegate as  and call  in your delegate to convert to a managed string
p71076
aVYour comments tell me that option 2 is the right solution
p71077
aVYour delegate should be:
p71078
aVAnd implement it like this:
p71079
aVThe other thing that you clearly have to do is make sure that the delegate is kept alive so that it still exists when the native code calls it
p71080
as(dp71081
g7
V505088
p71082
stp71083
a((dp71084
g2
(lp71085
VThe Delphi 7 version of the component can be found here: https://code
p71086
aVgoogle
p71087
aVcom/p/cubicexplorer/downloads/detail
p71088
aVname=PngComponents
p71089
aVzip&can;=2&q;=
p71090
aVFor what it is worth, I just did a simple web search to find that link
p71091
aVLearning how to use web search is one of the most important skills in development
p71092
as(dp71093
g7
V505088
p71094
stp71095
a((dp71096
g2
(lp71097
V simply performs a byte by byte comparison
p71098
aVThere are two main ways in which  fails to be valid for equality testing by value:
p71099
aVThe types being tested contain padding
p71100
aVThe types being tested are or contain reference types
p71101
aVYou are asking about arrays
p71102
aVSince arrays are always packed, they contain no padding
p71103
aVSince you are comparing the array values, the question can focus on the elements of the array
p71104
aVValue comparison of arrays will be an appropriate thing to do if and only if the array elements are value types that contain no padding bytes and contain no reference types
p71105
aVThis is the case for all simple value types
p71106
aVFor records, you need to check whether or not the record contains reference types
p71107
aVThis must be a recursive check
p71108
aVDoes the record contain records that contain reference types, and so on
p71109
aVAnd then you must look for padding
p71110
aVAs soon as you find padding, the use of  is not appropriate
p71111
as(dp71112
g7
V505088
p71113
stp71114
a((dp71115
g2
(lp71116
VIn your pre-Unicode version of Delphi,  and  write and read an  value
p71117
aVThe writing code writes the length, and then the string content
p71118
aVThe reading code reads the length, allocates the string, and then fills it with the content
p71119
aVThis has the potential of involving a truncation when you assign the result of  to your 80 character short string
p71120
as(dp71121
g7
V505088
p71122
stp71123
a((dp71124
g2
(lp71125
VThe main problem is that Delphi strings are 1-based
p71126
aVYour loop needs to run from  to
p71127
aVIf you enabled range checking in the compiler options, then the compiler would have raised an error at runtime which would have led you to the fault
p71128
aVI cannot stress enough that you should enable range checking
p71129
aVIt will lead to the compiler finding errors in your code
p71130
aVNote also that this means that the returned values will also be 1-based
p71131
aVSo an input of  will give the result  since that is the index of the first difference
p71132
aVYou should also check that  and  are the same length
p71133
aVIf not raise an exception
p71134
aVAnother tip
p71135
aVThe idiomatic way to increment a variable by 1 is like so:
p71136
aVIf you want to increment by a different value write:
p71137
aVSo, I would write the function like this:
p71138
as(dp71139
g7
V505088
p71140
stp71141
a((dp71142
g2
(lp71143
VIn this declaration,  is a public field
p71144
aVThis is described by the documentation
p71145
as(dp71146
g7
V505088
p71147
stp71148
a((dp71149
g2
(lp71150
VDelphi does not support an equivalent to Java's break to label
p71151
aVConsider the following:
p71152
aVIn Delphi the  always breaks out of the innermost statement, the  for loop in the example above
p71153
aVIn Java you can label a block and break out of that labelled block
p71154
aVSo in Java you could break out of the  for loop using a labelled break
p71155
aVFor example:
p71156
aVSuch a break is not possible in Delphi
p71157
aVThe closest equivalent in Delphi is the dreaded , which is still considered harmful
p71158
as(dp71159
g7
V505088
p71160
stp71161
a((dp71162
g2
(lp71163
VIf multiple threads modify the variable without protection then yes you have a data race
p71164
aVIf two threads attempt to increment or decrement at the same instance then what happens is:
p71165
aVThe variable is read into a register
p71166
aVThe modification is made in the register
p71167
aVThe new value is written back to the variable
p71168
aVThat read/modify/write is not atomic
p71169
aVIf you have two threads executing at the same time then you have the canonical data race
p71170
aVThread 1 reads the value, N say
p71171
aVThread 2 reads the value, the same value as was read by thread 1, N
p71172
aVThread 1 writes N+1 to the variable
p71173
aVThread 2 writes N+1 to the variable
p71174
aVAnd instead of the variable being incremented twice, it is incremented only once
p71175
aVIn this case there's no need for a full blown critical section
p71176
aVUse  to perform lock-free, thread safe modification
p71177
as(dp71178
g7
V505088
p71179
stp71180
a((dp71181
g2
(lp71182
VThat rectangle is part of the explorer theme
p71183
aVThe explorer theme is optional and the list view class elects to use it and imposes it in its  by calling
p71184
aVYou can override that behaviour by calling  to undo the change
p71185
aVAn example using an interposer class:
p71186
as(dp71187
g7
V505088
p71188
stp71189
a((dp71190
g2
(lp71191
VIt seems that you are trying wanting to convert the struct so that you can pass it to a native function using p/invoke
p71192
aVI would do that like so:
p71193
aVThen to declare the function you must make sure that a pointer to the struct is passed
p71194
aVSo declare the p/invoke like this:
p71195
aVI've assumed that the calling convention is , but you need to substitute the true value
p71196
as(dp71197
g7
V505088
p71198
stp71199
a((dp71200
g2
(lp71201
VThis is the code for :
p71202
aVAs you can see, the code checks to see if the file is a Windows bitmap
p71203
aVIf so then it loads it directly by calling
p71204
aVIf not then it loads into a  and then assigns to this instance
p71205
aVThe point is that  only understands Windows bitmaps
p71206
aVIt does not understand any other file format
p71207
aVAnd you are trying to load a PNG
p71208
aVSo, there's no way to do what you need without using an intermediate object
p71209
aVThe solution for you is to:
p71210
aVInstantiate a  object
p71211
aVCall  on that instance
p71212
aVCall  on the  instance passing the  instance
p71213
as(dp71214
g7
V505088
p71215
stp71216
a((dp71217
g2
(lp71218
VI think you don't need the C++/CLI ref class layer
p71219
aVYou can write a native class that wraps the managed objects directly
p71220
aVFor example:
p71221
as(dp71222
g7
V505088
p71223
stp71224
a((dp71225
g2
(lp71226
VYou code is badly broken
p71227
aVYour declaration of  is wrong
p71228
aVYou are passing the address of the process handle but you need to pass the process handle by value
p71229
aVWhat's more there is no need at all for  code here
p71230
aVI suggest you stop using
p71231
aVHere's how you declare :
p71232
aVYour declaration of  is fine
p71233
aVTo call the function you simply do this:
p71234
as(dp71235
g7
V505088
p71236
stp71237
a((dp71238
g2
(lp71239
VThe most obvious flaw in what you have shown is that you are attempting to pass the 64 bit pointer as 32 bit value which clearly cannot work
p71240
aVThe  parameter is declared as , which is 32 bits wide
p71241
aVBut you clearly have a 64 bit process
p71242
aVThat almost certainly explains the error that your are experiencing
p71243
aVRemember that in C++ on Windows,  is 32 bits wide
p71244
aVIn C# it is 64 bits wide
p71245
aVIn any case you should not use integral types to pass pointers
p71246
aVIf you have a pointer, design your functions to operate on pointers
p71247
aVYou need to make sure that  is declared to be pointer sized
p71248
aVI don't understand why it is not declared as
p71249
aVThere may be other problems, but you did not show very much code
p71250
aVYou did not show struct declarations, or anything on the managed side of the interface
p71251
as(dp71252
g7
V505088
p71253
stp71254
a((dp71255
g2
(lp71256
VThe class has three destructors
p71257
aVThe inherited virtual destructor, and the two declared here
p71258
aVHowever, I have never seen a situation where the correct design is to declare a new destructor
p71259
aVYou should always override the virtual destructor declared in
p71260
aVThere is simply no need for either of these destructors and they should be deleted
p71261
aVIf the user of a string list wishes for the list to take ownership of the objects held in the list, then the  property should be set to
p71262
aVAnd even if the base class did not already support this particular functionality, the right solution is always to override the virtual destructor
p71263
aVIf you need to vary behaviour of that destructor, then that needs to be effected using state or some other mechanism
p71264
aVBut never by implementing new destructors
p71265
aVThe reason for all this is that all Delphi developers expect to be able to call  on an instance and be confident that the object has been successfully destroyed
p71266
aVSince  calls the virtual destructor declared in , the conclusion is that all destruction code should reside in overrides of that method
p71267
aVHow I can replicate two destructor in C#
p71268
aVYou cannot
p71269
aVA C# class can have only one destructor
p71270
aVWhat's more, you don't write C# destructors in the same way as you do in Delphi
p71271
aVC# is a garbage collected language
p71272
aVAnd Delphi does not have garbage collection
p71273
aVMy more general advice to you is that you should not be attempting to translate literally from Delphi to C#
p71274
aVYou should write code that fits the language
p71275
aVThe way classes are implemented in Delphi is similar, yet different, from C#
p71276
aVWrite code to suit the target language
p71277
as(dp71278
g7
V505088
p71279
stp71280
a((dp71281
g2
(lp71282
VThere are a couple of possible causes for this
p71283
ag5537
aVYou are not calling the function
p71284
aVDelphi will only include functions that you actually refer to in the import table
p71285
aVSo add a call to the function to your code
p71286
aVYou can arrange that the code is never executed, but you'll need to ensure that the smart linker doesn't optimise it away
p71287
aVProbably the easiest way to do that is to take the address of the function
p71288
aVSo you could add this code to the  section of one of your units:
p71289
ag25125
aVThe function is delay loaded, or explicitly loaded
p71290
aVIn the section above, I'm assuming that you are using a declaration of  that uses the  keyword
p71291
aVIf you are linking it using a call to , then that will clearly not put it in your import table
p71292
aVLooking at the declaration of  in the XE2  unit I can see that it is delay loaded
p71293
aVThat means that it will not appear in your import table, even if you call it
p71294
aVTo force the function into your import table you'd need to redeclare it without using delay loading:
p71295
aVAnd you'd have to make sure that you included a call to this alternative declaration, for reasons described above
p71296
aVOf course, doing this would mean that your program would not start on XP because the function doesn't exist
p71297
aVRemember that if you insist on forcing this function into your import table, then it can only ever run on Windows versions that implement the function
p71298
aVIf I were you I would contemplate hooking the function in a different way, using a hooking method that does not rely on the function being imported via the import table
p71299
as(dp71300
g7
V505088
p71301
stp71302
a((dp71303
g2
(lp71304
VYour question contains two Delphi declarations for the external function
p71305
aVOne of them uses  as a parameter
p71306
aVThat is completely wrong
p71307
aVDon't do that
p71308
aVYou cannot use a Delphi dynamic array as an interop type
p71309
aVThe reason being that  is a complex managed type that can only be created and consumed by Delphi code
p71310
aVYou need to do as I do below, and as I explained in my answer to your previous question, and declare the array parameter as pointer to element type
p71311
aVFor example, , , etc
p71312
aVThere's quite a lot of confusion here, and needless complexity
p71313
aVWhat you need is the simplest possible example that shows how to pass an array from your Delphi code to C code
p71314
aVHere is is
p71315
aVC code
p71316
aVDelphi code
p71317
aVCompile the C code using, for example, the Borland C compiler like this:
p71318
aVbcc32 -c testarray
p71319
ag25651
aVAnd the output is:
p71320
ag5537
aV00000000000000E+0000
p71321
ag25125
aV00000000000000E+0000
p71322
ag23064
aV00000000000000E+0000
p71323
ag34876
aV20000000000000E+0001
p71324
ag42641
aV66000000000000E+0002
p71325
aVNote that I linked to the C code statically because that was easier for me
p71326
aVNothing much changes if you put the C code in a DLL
p71327
aVThe conclusion is that the code I gave you in my answer to your previous, and that I repeat here, is correct
p71328
aVThat approach succeeds in passing an array from Delphi code to C
p71329
aVIt looks like your diagnostics and debugging is in error
p71330
aVYou are only inspecting  so it's hardly surprising that you only see one value
p71331
aVIf only you would look at , ,
p71332
aV,  you would see that that all the values are being passed correctly
p71333
aVOr perhaps your debugging was carried out on the erroneous declaration of the external function that used  as a parameter
p71334
as(dp71335
g7
V505088
p71336
stp71337
a((dp71338
g2
(lp71339
VThe reason your code returns a  method is that the object's type does not contain a method named
p71340
aVThe type that contains that method is the helper type
p71341
aVSo, you could write this which will return a non-nil method:
p71342
aVOf course, you should immediately see the first problem, namely the use of a compile time specified type,
p71343
aVCan we use RTTI to discover  at run time based on the type of the instance
p71344
aVNo we cannot, as I will explain below
p71345
aVEven if we put that to one side, as far as I can see, there's no way to invoke the method using RTTI
p71346
aVIf you call  then the code in  blocks an attempt to call the helper method
p71347
aVIt blocks it because it decrees that the type of the instance is not compatible with the class of the method
p71348
aVThe pertinent code is:
p71349
aVWell, you can obtain the code address of the helper method with  but you'll need to find some other way to invoke that method
p71350
aVIt's easy enough to cast it to a method with the appropriate signature and invoke it
p71351
aVBut why bother with  in any case
p71352
aVWhy not use  and cut RTTI out of the loop
p71353
aVDiscussion
p71354
aVHelper resolution is performed statically based on the active helper at the point of compilation
p71355
aVOnce you attempt to invoke a helper method using RTTI there is no active helper
p71356
aVYou've long since finished compiling
p71357
aVSo you have to decide which helper class to use
p71358
aVAt which point, you don't need RTTI
p71359
aVThe fundamental issue here is that class helper method resolution is fundamentally a static process performed using the context of the compiler
p71360
aVSince there is not compiler context at run time, class helper method resolution cannot be performed using RTTI
p71361
aVFor more insight into this have a read of Allen Bauer's answer here: Find all Class Helpers in Delphi at runtime using RTTI
p71362
as(dp71363
g7
V505088
p71364
stp71365
a((dp71366
g2
(lp71367
VSuppose that  has the value
p71368
aVThen
p71369
aVevaluates to
p71370
aVThis is the post-increment operator
p71371
aVevaluates to
p71372
aVThis is the pre-increment operator
p71373
aVAnd the value of  is incremented by  in both cases
p71374
aVThe difference between post-increment and pre-increment operators is clearly explained in your text book
p71375
aVOh, I should also say that your  function is declared incorrectly
p71376
aVIt should be
p71377
aVYou'd probably find the output of your programs easier to understand if you added in the missing  statements
p71378
as(dp71379
g7
V505088
p71380
stp71381
a((dp71382
g2
(lp71383
VEach process has its own virtual address space
p71384
aVAn address in one process only has meaning in that process
p71385
aVDe-referencing a pointer in C++ code will access the virtual address space of the executing process
p71386
aVWhen you de-referenced the pointer in your code you were actually attempting to access memory in your process
p71387
aVNo amount of wishful thinking on the part of your tutors can make pointer de-reference access memory in another process
p71388
aVIf you wish to read and write memory from other processes then you must use ReadProcessMemory and WriteProcessMemory
p71389
aVI don't think you really need to go to all those lengths with tokens and privileges
p71390
aVIf I recall correctly you add the debug privilege, call OpenProcess and go straight to it
p71391
aVAnd I think you can typically skip adding the privilege
p71392
aVSome search did yield the first answer: using ReadProcessMemory and WriteProcessMemory one can easily change values in the memory of another process without
p71393
aVany need to get debug privileges
p71394
aVWhat my tutors want, however, is to have the ability to define pointers (let's say unsigned int) which should point into the memory space of the debuggee process, effectively holding the base addresses I wrote about earlier
p71395
aVThey really want this and I couldn't even talk this out of them so I'm stuck to do this at the end
p71396
aVWhat they want is impossible
p71397
aVI suggest you tell them to get a better understanding of virtual memory before making impossible requirements
p71398
aV@Cody Gray helpfully mentions memory mapped files
p71399
aVIf debuggee and debugger co-operate then they can use memory mapped files to share a common region of memory
p71400
aVIn that situation then both process can map the memory into their virtual address space and access it in the normal manner
p71401
aVI rather assumed that your debuggee was an unwilling victim, but if it is prepared to co-operate then sharing memory could be an option
p71402
aVEven then you'd need to be careful with any pointers in that shared memory because the memory would, in general, be mapped onto different virtual addresses in each process
p71403
as(dp71404
g7
V505088
p71405
stp71406
a((dp71407
g2
(lp71408
VYou aren't wrapping the native library the way you are supposed to
p71409
aVIn fact you are not using any JNA in the code in the question
p71410
aVThe key is that you must call Native
p71411
aVloadLibrary
p71412
aVYour Java code should look like this:
p71413
aVNote that I have taken the liberty of assuming that you will change  into  in your Delphi code
p71414
aVSince Java does not have unsigned types, and since 16 byte types are so 1990s, I think a 32 bit signed integer makes most sense
p71415
as(dp71416
g7
V505088
p71417
stp71418
a((dp71419
g2
(lp71420
VYou are modifying the DACL when you call SetSecurityInfo
p71421
aVSo, just before you do that call GetSecurityInfo and make a note of the original process DACL
p71422
aVWhen the time comes, call SetSecurityInfo again to restore it
p71423
aVDo note that a determined user can also do this so you cannot actually stop them from killing the process
p71424
aVYou are just making it a little awkward
p71425
as(dp71426
g7
V505088
p71427
stp71428
a((dp71429
g2
(lp71430
VThere is no compiler bug here
p71431
aVThe compiler is behaving as designed
p71432
aVThe assignments fail because the types are indeed not compatible
p71433
aVDelphi generic types are invariant
p71434
aVThe documentation says:
p71435
aVTwo instantiated generics are considered assignment compatible if the base types are identical (or are aliases to a common type) and the type arguments are identical
p71436
aVNow, let's look at the first assignment that fails:
p71437
aVThis fails because the type arguments are not identical
p71438
aVAnd for  we have
p71439
aVAgain, the type arguments are not identical
p71440
aVThere's a very good reason for the language designers choosing to make generic types invariant
p71441
aVConsider the following example
p71442
aVSince  and  are the same object, we have now succeeded in putting an object of type  into  which breaks the type system
p71443
aVIn fact your attempt to assign
p71444
aVillustrates this very issue
p71445
aVSuppose that assignment was valid and then you added to  something that implemented  but that was not
p71446
aVThen that same thing would have been added to  and all of a sudden you'd succeeded in adding to  something that was not  and you've broken the type system
p71447
aVIn languages that support generic variance there need to be runtime checks to stop this happening
p71448
aVAs it happens, only yesterday our very own Jon Skeet blogged on this very topic: Array covariance: not just ugly, but slow too
p71449
aVSo, be careful what you wish for
p71450
aVBecause of this the Delphi designers elected to make Delphi generic types invariant
p71451
as(dp71452
g7
V505088
p71453
stp71454
a((dp71455
g2
(lp71456
VThe WM_PASTE message does not use the parameters
p71457
aVIt's just an instruction to the recipient to take the contents of the clipboard and paste them
p71458
aVSo if you wish the recipient to do anything, you'll need to populate the clipboard first
p71459
aVIf you don't wish to pollute the clipboard, and you should not since it belongs to the user, then you can send an EM_REPLACESEL message passing the text in lParam
p71460
aVIf you want to find the window which the user is currently working on, use GetForegroundWindow
p71461
aVHowever, rather than faking low level messages, best of all would be to use the automation API
p71462
as(dp71463
g7
V505088
p71464
stp71465
a((dp71466
g2
(lp71467
VArnaud has explained that  returns a signed value which is the source of the warning
p71468
aVBoth Arnaud and Ken have suggested how to remove the warning by avoiding the use of unsigned operands
p71469
aVI would like to offer an alternative opinion and suggest that you instead choose to use signed operands
p71470
aVLet's suppose that you perform the calculation using only signed operands
p71471
aVConsider the following program:
p71472
aVI'm sure that you would hope that the output of this program would be 50
p71473
aVIt's not
p71474
aVThe output is 4294962396
p71475
aVWhat happens is that you perform  in an unsigned context where
p71476
aVWhen you do this you have integer overflow and the result is a very large positive value
p71477
aVSince you are using unsigned arithmetic, you cannot expect this to be a negative value because there are no negative values in unsigned
p71478
aVOf course, if the compiler option for overflow checking was enabled, you would encounter a runtime error
p71479
aVBut even that is not what you want
p71480
aVThe simple way to get the answer you need is to perform the operation using signed arithmetic
p71481
aVAnd this program produces the desired output of 50
p71482
aVIf for some reason, you need to store the value back to an unsigned variable, then do that outside the calculation
p71483
aVIt's important for the reasons illustrated above that the calculation is performed with signed values
p71484
aVOf course, it's true that you can come up with input values that will overflow the calculation, even if it is written using signed arithmetic
p71485
aVBut in practise you will find that such input is exceptionally unlikely
p71486
aVOn the other hand, it's very easy to trip your equation up when it is performed unsigned, using quite reasonable input data
p71487
as(dp71488
g7
V505088
p71489
stp71490
a((dp71491
g2
(lp71492
V code of  is
p71493
aVMost likely your program is 32 bit and is trying to load 64 DLLs
p71494
aVGiven that you mention OpenCV, I suspect that it's the OpenCV DLLs that are at the root of this
p71495
aVSolutions:
p71496
aVMake sure that your process finds 32 bit versions of the DLLs
p71497
aVSwitch your project to target 64 bit
p71498
as(dp71499
g7
V505088
p71500
stp71501
a((dp71502
g2
(lp71503
VOut of the box, VS does not include a standalone assembler
p71504
aVYou can write inline assembly in your C or C++ source code, but only for x86 targets
p71505
aVFor anything beyond inline assembly you'll need to use a separate assembler
p71506
aVYou can of course link the object files produced by an assembler into your MSVC project
p71507
aVAs for C, the MS compiler will compile code that broadly follows the C89 standard
p71508
aVBut MS have stated repeatedly that they will not update their C compiler to newer standards
p71509
aVIf what MS support is enough you just include files with a
p71510
aVc extension in your project and compile
p71511
aVOtherwise, if what MS support is not sufficient for you, then you are looking at external compilers
p71512
aVUpdate
p71513
aVI stand corrected
p71514
aVVisual Studio does indeed ship with the standalone Microsoft assembler MASM
p71515
as(dp71516
g7
V505088
p71517
stp71518
a((dp71519
g2
(lp71520
VWell, first of all  is not a typed constant
p71521
aVIt's not a typed constant because you did not declare a type
p71522
aVA typed constant would be
p71523
aVBut, as you know, you cannot make a true constant out of a typed constant
p71524
aVAnd you cannot expect the compiler to know how to interpret  in your expression because you have not stated a type
p71525
aVSo, you cannot use set notation to declare a true constant, because you can only use set notation if you specify the type of the set
p71526
aVWhich means that what you are attempting to do is probably not realistically possible
p71527
aVI mean, you could write this:
p71528
aVbut it would be insane to do so
p71529
as(dp71530
g7
V505088
p71531
stp71532
a((dp71533
g2
(lp71534
VYou cannot pass Delphi managed types like dynamic arrays to non-Delphi code
p71535
aVYou cannot expect to call functions with those data types
p71536
aVYou will need to re-design your interface
p71537
aVYou need to use simple types and records containing simple types
p71538
aVIf you need arrays then you'll have to pass a pointer to the first element, and the length, rather than using Delphi specific managed types
p71539
aVUse the Windows API as your template for how to design interop interfaces
p71540
aVThe other thing you'll need to deal with is that function return values are handled differently in Delphi than in most other Windows compilers
p71541
aVSo records that do not fit in a register will need to be passed as var parameters rather than as function return values
p71542
as(dp71543
g7
V505088
p71544
stp71545
a((dp71546
g2
(lp71547
VPre-compiled headers don't have any semantic meaning that differs from standard headers
p71548
aVThey are simply an optimisation to improve compilation times
p71549
aVTypically Delphi compilation much faster than C++ compilers and so the optimisation is not needed
p71550
aVYou cannot use unit A and transitively use all of unit A's dependencies
p71551
aVIf you want to use definitions from a unit, it must be listed in the uses clause
p71552
as(dp71553
g7
V505088
p71554
stp71555
a((dp71556
g2
(lp71557
VYou didn't tell ctypes what type the return value is, and so it assumes that it is an integer
p71558
aVBut it is in fact a pointer
p71559
aVSet the restype attribute to let ctypes know how to interpret the return value
p71560
as(dp71561
g7
V505088
p71562
stp71563
a((dp71564
g2
(lp71565
VAt this point you have created a new list which is empty
p71566
aVYou do not add any members and so this list is still empty when you attempt to enumerate it
p71567
as(dp71568
g7
V505088
p71569
stp71570
a((dp71571
g2
(lp71572
VYou'll need to pass a pointer by reference
p71573
aVAssuming that  is passed from native to managed, i
p71574
ag192
aVthat it has out semantics, here's the signature:
p71575
aVOnce you've called this you will need to convert it to a string:
p71576
aVIt's not clear who is responsible for freeing the memory that the native code allocates
p71577
aVPresumably that is documented somewhere and you already know how to handle that issue
p71578
as(dp71579
g7
V505088
p71580
stp71581
a((dp71582
g2
(lp71583
VIf you declare an external import multiple times, in different units, it will appear in the import table multiple times
p71584
aVThe compiler/linker does not merge them together
p71585
aVIf you declare an external import multiple times in the same unit, the compiler/linker does merge them into one
p71586
aVRegarding , it is declared in the  unit
p71587
aVBut in addition it is declared in  which is included by the  unit
p71588
aVSo that's two declarations for starters
p71589
aVClearly your program uses other units which re-declare
p71590
as(dp71591
g7
V505088
p71592
stp71593
a((dp71594
g2
(lp71595
VIt is perfectly safe to execute code after a call to an inherited destructor, so long as that code does not rely on something that has been destroyed by that inherited destructor
p71596
aVIn the same way it is safe to execute code before a call to an inherited constructor, so long as the code does not rely on anything instantiated in that inherited constructor
p71597
aVBut it is certainly true that this is not good style
p71598
aVThere are on occasions reasons that would lead you to such code, but usually such reasons should be taken as indication that something is wrong in your design
p71599
aVIn the example that you give there is simply no need to write the code that way
p71600
aVThe call to  could perfectly well happen before the call to the inherited destructor
p71601
as(dp71602
g7
V505088
p71603
stp71604
a((dp71605
g2
(lp71606
VCreate a two dimensional array like this:
p71607
aVThis creates an array whose primary dimension has bounds 1
p71608
aV10 and whose secondary dimension has bounds 1
p71609
ag7303
aVWhen you say that you want to create an array that contains strings, I presume you are referring to the COM BSTR
p71610
aVIn which case pass  as the var type parameter when you call
p71611
as(dp71612
g7
V505088
p71613
stp71614
a((dp71615
g2
(lp71616
VI'd call it like this:
p71617
aVThis function would be much better if you return buffer length rather than size
p71618
aVI tested this using the following code:
p71619
aVDelphi
p71620
aVPython
p71621
aVOutput
p71622
aV[1L, 2L, 3L, 4L, 5L]
p71623
as(dp71624
g7
V505088
p71625
stp71626
a((dp71627
g2
(lp71628
VThe main reason for the different performance characteristics of these two functions are that they do different things
p71629
aVYou are not comparing like with like
p71630
aVWhen the input value is in the range 1 to 7 inclusive, the behaviour is identical
p71631
aVHowever, when the input value is outside that range then the behaviour diverges
p71632
aVThe first version, that which uses , must first check that the value is in the range 1 to 7
p71633
aVOnly then is it allowed to actually assign to
p71634
aVIf the value is in the range 1 to 7 then the compiler turns the case statement into an unconditional  statement which looks like this:
p71635
aVHere  is the day index
p71636
aVAnd the target of these jump are instructions that simply assign string literals to the  variable
p71637
aVThe second version, that which uses an array, does not check whether or not the input value is in range
p71638
aVIt indexes into the array directly even if the input value is out of range, and of course such array index lead to undefined behaviour
p71639
aVSo this is where the behaviour diverges
p71640
aVLooking at this purely from performance, and ignoring the semantic differences in your functions, the main difference is that the version using  has a test and branch on the input value which is not present in the array version
p71641
aVIn addition, the version using  has larger code and so is probably less cache friendly
p71642
aVSo, from an analysis of the code we might expect the array version to be faster
p71643
aVIt has less to do, it doesn't branch, the code is smaller
p71644
aVIf performance actually matters to you then you would need to perform some realistic timings in the actual setting in which this code runs
p71645
aVI cannot perform those timings because they would be artificial
p71646
aVAny times only have real meaning in the context of your code
p71647
aVIt is very plausible indeed that in the setting of your program, you would not be able to measure the difference between the two versions
p71648
aVIn which case the analysis above would be moot
p71649
as(dp71650
g7
V505088
p71651
stp71652
a((dp71653
g2
(lp71654
VNote: The answer below addresses the original version of the question
p71655
aVThere only is one calling convention on Linux x86_64
p71656
aVIt's known as System V AMD64 ABI
p71657
aVWhatever the mismatch is, it is surely not in the calling conventions
p71658
aVPerhaps the struct declarations do not match, or there is something else wrong that we cannot see
p71659
aVThe next thing I would do, in your shoes, would be to write some simple test code
p71660
aVI'd write a C++ function that received a pair of  parameters
p71661
aVCheck that they get passed in the correct order
p71662
aVConvince yourself that the calling convention is not the problem, and then dig deeper to find out the real cause of the problem
p71663
as(dp71664
g7
V505088
p71665
stp71666
a((dp71667
g2
(lp71668
VYou need to wait until the process handle is signaled
p71669
aVFor example by a call to WaitForSingleObject
p71670
aVObviously CreateProcess returns you a process handle on which you can wait
p71671
aVYou cannot persuade ShellExecute to return a process handle, but its more capable brother ShellExecuteEx will do so
p71672
aVHowever, I personally would choose CreateProcess here
p71673
aVYou will get more flexibility and control, and it's not that complex
p71674
aVFor example, you can suppress display of the console window if you wish
p71675
as(dp71676
g7
V505088
p71677
stp71678
a((dp71679
g2
(lp71680
VI would do it like this:
p71681
aVI think you should avoid using strings for what is in essence a character operation
p71682
aVIf you know up front which code pages you need to support then you can hard code the conversions into a lookup table expressed as an array constant
p71683
aVNote that all the characters that are defined in the ANSI code pages map to Unicode characters from the Basic Multilingual Plane and so are represented by a single UTF-16 character
p71684
aVHence the size assumptions of the code above
p71685
aVHowever, the assumption that you are making, and that this answer persists, is that a single byte represents a character in an ANSI character set
p71686
aVThat's a valid assumption for many character sets, for example the single byte western character sets like 1252
p71687
aVBut there are character sets like 932 (Japanese), 949 (Koren) etc
p71688
aVthat are double byte character sets
p71689
aVYour entire approach breaks down for those code pages
p71690
aVMy guess is that only wish to support single byte character sets
p71691
aVIf you are writing cross-platform code then you can replace  with
p71692
as(dp71693
g7
V505088
p71694
stp71695
a((dp71696
g2
(lp71697
VThis is really two different questions
p71698
aVOne for the console, and one for a GUI app
p71699
aVI'm choosing to cover the console
p71700
aVIf you just need powers 2 and 3 you can do this:
p71701
aVThis makes use of characters U+00B2 and U+00B3
p71702
aVIf it turns out that you require different powers then you are out of luck at the console
p71703
aVWhilst there are Unicode characters for other numerals, font support is poor and you will have no success with code like this:
p71704
aVMany commonly used console fonts do not include superscript glyphs for these characters
p71705
aVFor example, this is what it looks like on my machine using Consolas:
p71706
aVIf you are using the default console font of Lucinda Console, then the results are the same
p71707
as(dp71708
g7
V505088
p71709
stp71710
a((dp71711
g2
(lp71712
VThere's no way to enforce an implicit cast or method call on an object instance
p71713
aVIf this was a record that you controlled then you could implement an  class operator that would perform a cast to
p71714
aVThe issue discussed link that you refer to is simply an implementation detail of
p71715
aVThat relies on the ability of  to come up with a string representation for any object which in turn relies on
p71716
aVIn fact the discussion there concerning  is unrelated to the way the  operator in Java works which is the pertinent issue in your question
p71717
aVDelphi's  has a virtual  method that could be used to perform the same purpose
p71718
aVSo it would be easy enough to use the exact same technique as  in Delphi code
p71719
as(dp71720
g7
V505088
p71721
stp71722
a((dp71723
g2
(lp71724
VWindows shows that animation the first time a window is shown
p71725
aVSo all you need to do is make sure that every time your form is shown, the associated window is being shown for the first time
p71726
aVYou could destroy the form when it closes and create a new instance when you need to show it again
p71727
aVHowever, that may be inconvenient for you depending on how your form manages state
p71728
aVJudging from your edit and comments, you cannot afford to destroy the form when you close it
p71729
aVInstead you would need to force a new window to be created for your form, each time you show it
p71730
aVFor example, add a call to  in the  event of the form
p71731
aVOr make a call to  immediately before you show the window
p71732
aVNote that the latter will involve making the protected method  visible to whoever calls  on the form
p71733
as(dp71734
g7
V505088
p71735
stp71736
a((dp71737
g2
(lp71738
VYour code maps a C# class onto a native struct
p71739
aVBecause a C# class is a reference type then it will be marshalled as a reference
p71740
aVSo your code passes an array of references that gets marshalled to an array of pointers on the native side
p71741
aVBut the native code expects a pointer to an array of structs which are value types
p71742
aVSo the simplest solution is to change the declaration of  to be a  rather than a
p71743
aVThe other issues that I can see:
p71744
aVThe native code appears to be using the  calling convention
p71745
aVYou'll need to change the C# code to match
p71746
aVYou are decorating the array parameter with
p71747
aVYou cannot marshal modifications to the  fields back to the managed code
p71748
aVYou will need to make sure that you keep alive the delegates that you pass to   to stop them being collected
p71749
as(dp71750
g7
V505088
p71751
stp71752
a((dp71753
g2
(lp71754
VYou need to declare the parameters as special types that convey the fact that they are passed by reference
p71755
aVSo if the Delphi parameters are like this:
p71756
aVyou would map that to a Java function like this:
p71757
aVAnd to call the function:
p71758
aVThis is all covered in some detail in the documentation:
p71759
aVUsing ByReference Arguments
p71760
aVWhen a function accepts a pointer-to-type argument you can use one of
p71761
aVthe ByReference types to capture the returned value, or subclass your
p71762
aVown
p71763
aVFor example:
p71764
aVAlternatively, you could use a Java array with a single element of the
p71765
aVdesired type, but the ByReference convention better conveys the intent
p71766
aVof the code
p71767
aVThe Pointer class provides a number of accessor methods
p71768
aVin addition to getByteArray() which effectively function as a typecast
p71769
aVonto the memory
p71770
aVType-safe pointers may be declared by deriving from the PointerType
p71771
aVclass
p71772
as(dp71773
g7
V505088
p71774
stp71775
a((dp71776
g2
(lp71777
VWhich one is better in terms of performance
p71778
aVEarly bound is quicker than late bound
p71779
aVLate bound method dispatch involves the following:
p71780
aVLooking up the entry point from the name
p71781
aVAssembling the parameters to be passed to the method, and performing any necessary type conversions
p71782
aVCalling the function
p71783
aVUnmarshalling any out parameters and the return value
p71784
aVMany of these steps are not present at all for early bound dispatch
p71785
aVOf course, if the function does anything significant at all, the performance different during method dispatch may well not be detectable
p71786
as(dp71787
g7
V505088
p71788
stp71789
a((dp71790
g2
(lp71791
VThe error that you report in the question is not thrown by a call to
p71792
aVThe error that you report is a Delphi exception and  is a Windows API call
p71793
aVA call to  will not raise a Delphi exception
p71794
aVThe  is thrown by
p71795
aVAnd that method is called when you are attempting to register (or unregister) a COM server
p71796
aVWhich is something that requires administrator rights because it involves modifications to
p71797
aVSo, it would seem that the call to  is not the problem at all
p71798
aVThe problem is that you are attempting to modify the COM registry under  which is something that requires elevation
p71799
aVNaturally, when you elevate, this modification succeeds
p71800
aVIf your program worked on your Windows 7 machine it is most likely that the machine has UAC disabled, or the process was running elevated
p71801
as(dp71802
g7
V505088
p71803
stp71804
a((dp71805
g2
(lp71806
VMoving global variables to local scope in fact increases stack allocation requirements
p71807
aVMoving global variables to local scope will reduce the size of the executable
p71808
aVPerhaps that's what you mean
p71809
aVIn general, moving a variable from global scope to local scope, and vice versa probably makes little performance difference
p71810
aVIf anything using local scope will have better performance because you will have better cache usage patterns
p71811
aVHowever, performance should never be the driving criteria for choosing between global and local scope
p71812
aVAlways make that choice based on semantics
p71813
aVAlways prefer local scope over global scope, where it is semantically reasonable to do so
p71814
as(dp71815
g7
V505088
p71816
stp71817
a((dp71818
g2
(lp71819
VHow do I solve this issue using just standard C
p71820
aVIs there a syntax for asking the compiler to make sure my struct looks exactly the way I specify it
p71821
aVThe C standard does not provide a standard way to control struct layout
p71822
aVSo, if you are dead set on only using what is specified by the standard, you cannot use structs to process Windows bitmap files
p71823
aVTo solve this using standard C you need to write/read byte arrays and serialize/deserialize them yourself
p71824
as(dp71825
g7
V505088
p71826
stp71827
a((dp71828
g2
(lp71829
VThat border is caused by the use of
p71830
aVThe fact that  is defined as  makes it very clear what is going on
p71831
aVRemove that extended style and the border goes away
p71832
as(dp71833
g7
V505088
p71834
stp71835
a((dp71836
g2
(lp71837
VThe Windows API function MultiByteToWideChar is provided to perform this conversion
p71838
aVNaturally you need to specify the codepage of the input data
p71839
aVFor example:
p71840
aVNote that all the characters that are defined in the ANSI code pages map to Unicode characters from the Basic Multilingual Plane and so are represented by a single UTF-16 character
p71841
aVHence the size assumptions of the code above
p71842
aVHowever, the assumption that you are making, and that this answer persists, is that a single byte represents a character in an ANSI character set
p71843
aVThat's a valid assumption for many character sets, for example the single byte western character sets like 1252
p71844
aVBut there are character sets like 932 (Japanese), 949 (Koren) etc
p71845
aVthat are double byte character sets
p71846
aVYour entire approach, and the code above, breaks down for those code pages
p71847
as(dp71848
g7
V505088
p71849
stp71850
a((dp71851
g2
(lp71852
VThe problem is with p161[0]/p351[0] and the other divisions
p71853
aVOn the Mac I get 0
p71854
aV76 and on Windows 0
p71855
ag9193
aVThat sounds rather like your division operator is performing floating point division on the Mac and truncating integer division on Windows
p71856
aVThat would happen if you were running Python 3 on the Mac, and Python 2 on Windows
p71857
aVBut the old style  statements suggest otherwise
p71858
aVIt would also happen if you had executed
p71859
aVon the Mac but not in the Windows code
p71860
aVSince you clearly want floating point division you should do one of the following, everywhere:
p71861
aVUse Python 3 where  always means true floating point division
p71862
aVUse
p71863
aVConvert one of your operands to  before performing the division
p71864
as(dp71865
g7
V505088
p71866
stp71867
a((dp71868
g2
(lp71869
VWhen a sub-menu is shown, its parent menu item's OnClick event is fired
p71870
as(dp71871
g7
V505088
p71872
stp71873
a((dp71874
g2
(lp71875
VIt seems that what you are actually looking for is to detect a change of focus
p71876
aVYou want to detect when a control gets focus, and then when it loses focus
p71877
aVFor that you should use the  and  events
p71878
aVThe  event is simply the wrong event for the task
p71879
aVFrom the documentation for :
p71880
aVUse the OnEnter event handler to cause any special processing to occur
p71881
aVwhen a control becomes active
p71882
aVThe OnEnter event does not occur when switching between forms or
p71883
aVbetween another application and the application that includes the
p71884
aVcontrol
p71885
aVWhen switching between controls in separate container controls such as
p71886
aVthe TPanel and the TGroupBox controls, an OnEnter event occurs for the
p71887
aVcontainer before the OnEnter event of the contained control
p71888
aVSimilarly, an OnExit event of the container occurs after the OnExit
p71889
aVevent of the control in a container when focus moves to another
p71890
aVcontrol outside the container
p71891
aVFor example, consider a form with an OK button and a group box that
p71892
aVcontains three radio buttons, where focus is currently on the OK
p71893
aVbutton
p71894
aVWhen the user clicks one of the radio buttons, an OnExit event
p71895
aVof the button occurs, followed by an OnEnter event on the group box,
p71896
aVand finally an OnEnter event on the radio button that was clicked
p71897
aVIf
p71898
aVthe user then clicks on the OK button, an OnExit event for the radio
p71899
aVbutton occurs followed by an OnExit event for the group box, and then
p71900
aVthe button's OnEnter event occurs
p71901
as(dp71902
g7
V505088
p71903
stp71904
a((dp71905
g2
(lp71906
VThe best way to handle shortcut keys is to let the menu items handle them
p71907
aVYou say that you have a popup menu that has these actions
p71908
aVUse the  property of the menu item to associate that menu item with the shortcut key
p71909
aVThat allows you to remove all the manual keyboard event handling and let the framework do it for you
p71910
aVThat has many benefits
p71911
aVNot least of which is that the event will fire when the key goes down rather than when it goes up as you currently have it
p71912
aVEven better would be to use actions which if I recall correctly do exist in Delphi 5
p71913
aVThese allow you to associate a single action, for example copy to clipboard with multiple independent UI elements
p71914
aVFor example that action can be associated with a main menu, a popup menu, and a shortcut key
p71915
as(dp71916
g7
V505088
p71917
stp71918
a((dp71919
g2
(lp71920
VYou need to decide which directory you want the file to be relative to
p71921
aVOnce you have done that, you construct the full path like this:
p71922
aVIf you don't supply the base directory  then you will be at the total mercy of whatever happens to the working directory of your process
p71923
aVThat is something that can be out of your control
p71924
aVFor example, shortcuts to your application may specify it
p71925
aVUsing file dialogs can change it
p71926
aVFor a console application it is reasonable to use relative files directly because console applications are designed so that the working directory is a critical input and is a well-defined part of the execution environment
p71927
aVHowever, for a GUI app that is not the case which is why I recommend you explicitly convert your relative file name to a full absolute path using some well-defined base directory
p71928
aVNow, since you have a console application, it is reasonable for you to use a relative path, provided that the expectation is that the files in question will be located in the working directory
p71929
aVBut it would be very common for that not to be the case
p71930
aVNormally the working directory is used to specify where the user's input and output files are to be stored
p71931
aVIt does not typically point to the location where the program's files are
p71932
aVOne final option is that you don't attempt to deploy these program files as external text files
p71933
aVPerhaps a better option is to link them to the executable as resources
p71934
aVThat way they are bound up with the executable and you can completely side-step this issue
p71935
as(dp71936
g7
V505088
p71937
stp71938
a((dp71939
g2
(lp71940
VThe documentation describes these particular warnings as follows:
p71941
aVHIDDEN_VIRTUAL: Turns on or off warnings produced when a descendant declares a method of the same name as a method in an
p71942
aVancestor, and the ancestor method is virtual, but the descendant's
p71943
aVmethod is not an override
p71944
aV(See W1010 Method '%s' hides virtual method of base type '%s' (Delphi)
p71945
aVHIDING_MEMBER: Turns on or off warnings produced when a descendant declares a new property of the same name as a property in an ancestor
p71946
aV(See W1009 Redeclaration of '%s' hides a member in the base class (Delphi)
p71947
aVNeither warning applies to your code
p71948
aVIn the case of , you do not have any virtual methods
p71949
aVAnd in the case of  you do not have any properties
p71950
aVFollow the links in the quoted section above (or from the main documentation link in the first sentence) to find the full details for these warnings
p71951
as(dp71952
g7
V505088
p71953
stp71954
a((dp71955
g2
(lp71956
V is a fairly normal Win32 function
p71957
aVIt is available in two flavours, the ANSI and Unicode versions
p71958
aVThe need for these different versions comes from the fact that Windows 95/98/ME did not support Unicode and only had support for 8 bit encodings
p71959
aVSince you can safely ignore those ancient versions of Windows, you can use the Unicode versions of the Win32 API
p71960
aVIn your case this means that you make sure that you compile your application to target Unicode
p71961
aVThis will make sure that  is mapped to , the Unicode version which uses the UTF-16 encoding
p71962
aVYour character arrays should use the Windows 16 bit character type  as the base character type
p71963
aVYou must not use  because that is 8 bit
p71964
aVI'm not sure that this change will resolve your actual problem because the question is unclear and lacking in detail
p71965
aVHowever, the above advice is what you need to do to be able to properly support international characters in your program
p71966
as(dp71967
g7
V505088
p71968
stp71969
a((dp71970
g2
(lp71971
VThe  instance returned by calling  has the information you need
p71972
aVProvided that both processes have the same bitness
p71973
aVSo, if the target process is a 32 bit process, make sure your process is also a 32 bit process
p71974
aVAnd if the target process is a 64 bit process, then make sure your process is a 64 bit process
p71975
aVFrom the output you include in the question it is clear that the scenario that produced that output is:
p71976
aVA 64 bit OS
p71977
aVYour code executes in a 64 bit process
p71978
aVThe target process is a 32 bit process
p71979
aVThe reason that you only enumerate those handful of modules is (presumably) that they are the 64 bit modules that are included in the 32 bit process running under the WOW64 emulator, together with the executable module
p71980
aVYou might be tempted to think that you can use the Windows API to enumerate modules in a process with a different bitness
p71981
aVBut you cannot
p71982
aVAttempts to use ,  and  yield the same results as your C# code that uses
p71983
aVAnd that's not at all surprising really
p71984
aVIt makes perfect sense that
p71985
aVnet, which is implemented in Win32, would call the native Win32 API that is designed for this task
p71986
aVYour solution is to make sure that the call to  is made from a 32 bit process
p71987
aVYou will need to use some helper processes of different bitness if you need to be able to target both 32 and 64 bit processes
p71988
aVUpdate
p71989
aVBen Voigt point me to EnumerateLoadedModules64 from the Debug Help API
p71990
aVI confess to being unaware of this
p71991
aVHowever, it does appear to have the same bitness limitations as the tool help API
p71992
aVFinally, there is also EnumProcessModulesEx which can enumerate 32 bit modules from a 64 bit process
p71993
aVIf you pass  then you can indeed extract the 32 bit modules loaded into an external 32 bit process, from a calling process that is 64 bit
p71994
as(dp71995
g7
V505088
p71996
stp71997
a((dp71998
g2
(lp71999
VYou appear to want to copy the entire stream onto
p72000
aVDo that like this:
p72001
aVYou'll also need to change your  to allocate enough memory
p72002
aVOr perhaps more elegantly:
p72003
aVAs it stands your code does not take account of that part of the record which appears before
p72004
as(dp72005
g7
V505088
p72006
stp72007
a((dp72008
g2
(lp72009
VYou cannot call that function from C++
p72010
aVThe Delphi  type is a private Delphi type
p72011
aVFor interop you'll want to use a pointer to null-terminated array of characters
p72012
aVIn C++ that is , and in Delphi that is
p72013
aVWhat's more, your Delphi function uses the  calling convention which is a register based  convention
p72014
aVAgain, you cannot access that from other languages
p72015
aVYou'll need to use one of the standard calling conventions
p72016
aVThe function pointer in your C++ code already passes a , and uses the  calling convention
p72017
aVSo you just need to make the Delphi function match:
p72018
aVThe above declaration is compatible with the C++ code in your question
p72019
aVIf you prefer to use  then you need to change both Delphi and C++ code
p72020
aVDelphi
p72021
aVC++
p72022
as(dp72023
g7
V505088
p72024
stp72025
a((dp72026
g2
(lp72027
VIt is not your responsibility to free the reference returned by the call to
p72028
aVThat responsibility lies with the object that you call  on, in your code that is
p72029
aVYou must remove the line that calls
p72030
aVThe reason you are encountering a invalid pointer operation error is that  is trying to destroy an object that you already destroyed
p72031
aVYou typically do not call  in case the reference on which you call it happens to be
p72032
aVInstead call  which performs the  check and skips the call to  if the reference is nil
p72033
aVFinally, your use of finally is not correct
p72034
aVThe correct pattern is:
p72035
aVYou must put the  immediately after the constructor assigns to the reference
p72036
aVIf you put it before, then your call to  can act on an uninitialized reference
p72037
aVIf you don't put it immediately after, then you may leak
p72038
aVFor your JSON object you'd write it like this:
p72039
aVOr equally you might do this:
p72040
as(dp72041
g7
V505088
p72042
stp72043
a((dp72044
g2
(lp72045
VI think you've used the wrong event
p72046
aVYou appear to be showing and hiding the form
p72047
aVSo you want to attach the event to  rather than
p72048
aVIt's also a mistake to call  on
p72049
aVThe  of a windows control is it's containing control
p72050
aVFor example when you put a button inside a panel, the button's parent is the panel
p72051
aVIn you situation you want to call  on the other form
p72052
as(dp72053
g7
V505088
p72054
stp72055
a((dp72056
g2
(lp72057
VTyped constants can only be declared in terms of constant expressions
p72058
aVYou are attempting to declare a typed constant in terms of typed constants
p72059
aVSince typed constants are not constant expressions, the compiler message that you see is by design
p72060
aVThe conclusion is that concatenation of two typed constant arrays can only be performed at runtime
p72061
aVAnd consequently the result of the concatenation can only be stored to a variable rather than a constant
p72062
aVThe documentation for array constants makes this clear (emphasis mine):
p72063
aVTo declare an array constant, enclose the values of the
p72064
aVarray's elements, separated by commas, in parentheses at
p72065
aVthe end of the declaration
p72066
aVThese values must be
p72067
aVrepresented by constant expressions
p72068
as(dp72069
g7
V505088
p72070
stp72071
a((dp72072
g2
(lp72073
VThe Windows API provides a function that will return stack traces
p72074
aVIt is
p72075
aVThe will return code addresses rather than function names
p72076
aVIf you want to display information like the third party components you mention, then you'll need to do more work
p72077
aVYou need access to the information from the map file emitted by the Delphi linker
p72078
as(dp72079
g7
V505088
p72080
stp72081
a((dp72082
g2
(lp72083
VWindows 8 does not provide support for the glass effect of Vista/7
p72084
aVIf you want to make your windows display with glass effect, you need to code it yourself, or use one of the 3rd party solutions that do so
p72085
as(dp72086
g7
V505088
p72087
stp72088
a((dp72089
g2
(lp72090
VLike this:
p72091
aVIt would be easy enough to re-work this to avoid the duplication
p72092
aVAnd so on
p72093
aVI'll leave it to you to polish it up
p72094
as(dp72095
g7
V505088
p72096
stp72097
a((dp72098
g2
(lp72099
VThe reason that your DLL is not reporting leaks stems from this code in the FastMM shutdown:
p72100
aVIn your options,  is defined
p72101
aVWhat's more, in the DLL,  is equal to , presumably because you are debugging the application rather than the DLL
p72102
aVThis means that you call  passing
p72103
aVAnd that  disables reporting of leaks
p72104
aVYou can resolve this by undefining
p72105
as(dp72106
g7
V505088
p72107
stp72108
a((dp72109
g2
(lp72110
VOn the face of it you ought to be able to control this using the  message:
p72111
aVThe EM_LIMITTEXT message limits only the text the user can enter
p72112
aVIt does not affect any text already in the edit control when the message is sent, nor does it affect the length of the text copied to the edit control by the WM_SETTEXT message
p72113
aVIf an application uses the WM_SETTEXT message to place more text into an edit control than is specified in the EM_LIMITTEXT message, the user can edit the entire contents of the edit control
p72114
aVBefore EM_LIMITTEXT is called, the default limit for the amount of text a user can enter in an edit control is 32,767 characters
p72115
aVAnd this message is exposed by the  property of
p72116
aVHowever, setting  to a large value doesn't appear to help
p72117
aVI cannot persuade a single line edit control to display a large number of characters
p72118
aVI suspect the only viable option for you is to use a multi-line edit control, that is a
p72119
aVI'm sure MS would argue that single line edit controls are not designed to hold thousands of characters and so they have no motivation to make that control more capable
p72120
aVFWIW, with the Unicode version of the control, the cutoff appears to be at 37444 rather than 37440
p72121
as(dp72122
g7
V505088
p72123
stp72124
a((dp72125
g2
(lp72126
VYou are adding the least significant digits to the start of the string
p72127
aVYou'll need to reverse the string, or add the digits in reverse order, or insert them rather than append them
p72128
aVAnd you'll need to do some casting
p72129
aVFor example, here's one way to do it:
p72130
aVFinally, you cannot use  like that
p72131
aVYou want this:
p72132
aVAlthough  might be more suitable
p72133
aVAnd note that your code won't work properly for negative input values, or for zero
p72134
aVSo, here's a version that handles all of that:
p72135
aVThis is pretty ugly though
p72136
as(dp72137
g7
V505088
p72138
stp72139
a((dp72140
g2
(lp72141
VThere is a layout mismatch between the struct definitions in your two modules
p72142
aVIt seems that the offset to the url member in your DLL has an offset of 4 more than the offset to that field in your ActiveX
p72143
aVMake sure that the struct definitions match in both modules
p72144
aVMake sure that the compiler options relating to struct layout are the same in both modules
p72145
aVI cannot give a definitive fix because there are so many ways in which this mismatch could occur, but for sure the root problem is a mismatch
p72146
as(dp72147
g7
V505088
p72148
stp72149
a((dp72150
g2
(lp72151
VYou cannot instantiate a generic type without specifying all the type parameters
p72152
aVProbably the best you can do is to add that unused type parameter of the interface to your generic type paramaters:
p72153
aVThis allows you not to care when writing the generic code, but naturally any specialisations will need to supply that type
p72154
as(dp72155
g7
V505088
p72156
stp72157
a((dp72158
g2
(lp72159
VThere is indeed a matching ENTER (Art of Assembly Language) instruction
p72160
aVIt's seldom used however, because it is very slow, as explained in the link
p72161
as(dp72162
g7
V505088
p72163
stp72164
a((dp72165
g2
(lp72166
VThis is a run-time error
p72167
aVWhat it is telling you is that  is being read before it has been initialised
p72168
aVAnd that means that the  case statement executed before
p72169
aVFrom the comments you've assigned  to  to suppress the warning, but then of course the call to  cannot succeed since the window handle you pass is
p72170
aVTo tackle the problem you need to understand why  is being handled before
p72171
as(dp72172
g7
V505088
p72173
stp72174
a((dp72175
g2
(lp72176
VYour problems are in the pointers contained in the structs:
p72177
aVYou cannot persuade the p/invoke marshaller to marshal pointers to arrays that are embedded inside structs
p72178
aVThat form of marshalling is only available for function parameters
p72179
aVYou'll need to declare both of those fields as  and do the marshalling by hand
p72180
as(dp72181
g7
V505088
p72182
stp72183
a((dp72184
g2
(lp72185
VThat does not work
p72186
aVAs you have said, to maintain compatibility, you cannot modify an already published interface
p72187
aVBut by changing the inheritance you are modifying the interface
p72188
aVSo, you could add the new methods to a new subclass and then you would have this structure:
p72189
aVIBaseInterface
p72190
aV|
p72191
aVIDerivedInterface
p72192
ag72191
aVIDerivedInterface2
p72193
aVOr perhaps what you should do is add a new interface which the implementing objects support
p72194
aVSo, instead of using inheritance, you simply declare that you implementing class supports multiple interfaces
p72195
aVIn that case you would leave the existing inheritance structure alone, and have something like this:
p72196
aVIBaseInterface         INewInterface
p72197
ag72191
aVIDerivedInterface
p72198
aVand then implement the class like this:
p72199
as(dp72200
g7
V505088
p72201
stp72202
a((dp72203
g2
(lp72204
VThe term normal is synonymous with restored
p72205
aVThis terminology dates back to older versions of windows and nowadays all the MSDN documentation uses restored rather than normal or normalized
p72206
aVSo,  sets the window state to restored and makes the window visible
p72207
aVOn the other hand,  simply makes the window visible
p72208
aVBack in the day, restored was called normalized, minimized was called iconic, and maximized was called full screen
p72209
aVIf memory serves, that older terminology was still in use in Windows 3
p72210
aV1, but was changed with Windows 95 and NT
p72211
as(dp72212
g7
V505088
p72213
stp72214
a((dp72215
g2
(lp72216
VYou can use
p72217
aVto indicate support for all architectures
p72218
aVIf your application is a 32 bit application then you can use
p72219
aVWith such a manifest your process will be just fine on a 64 bit system since it will be running as a 32 bit process under the WOW64 emulator
p72220
aVFor a 64 bit application running on x64 you use
p72221
aVAnd finally, for 64 bit Itanium the value is
p72222
aVFor the  attribute, the value is always
p72223
aVThe documentation (which is admittedly a little sparse) is here: http://msdn
p72224
aVmicrosoft
p72225
aVcom/en-us/library/windows/desktop/aa374191
p72226
aVaspx
p72227
aVFor what it is worth, it doesn't seem to me as though you need to change anything
p72228
aVIf you have a 32 bit executable built with a  manifest then that executable is already configured perfectly for both 32 and 64 bit systems
p72229
aVRemember that it is the architecture of the process that counts here, and not the architecture of the system that runs the process
p72230
aVYour 32 bit executable runs as a 32 bit process even on a 64 bit system
p72231
as(dp72232
g7
V505088
p72233
stp72234
a((dp72235
g2
(lp72236
VYour project is configured for Unicode which means that the  macro evaluates to , which is a 16 bit UTF-16 data type on Windows
p72237
aVBut the library you are calling accepts 8 bit  data
p72238
aVSo, you will need to make both sides of the interface match
p72239
aVLots of ways to do that
p72240
aVThe obvious options are:
p72241
aVChange your project to target ANSI (change the character set to multi byte in the VS project configuration)
p72242
aVConvert the input argument from UTF-16 to ANSI before calling the library
p72243
aVIt seems to me to be needlessly complex to use  these days
p72244
aVThat was useful when we needed to support Win9x (no Unicode support) and WinNT (supports Unicode) from a single code base
p72245
aVBut I expect that nowadays you are targeting NT based systems and so you are safe to assume support for Unicode
p72246
aVIn which case you can use ,  etc
p72247
aVOn the other hand, perhaps this is just a simple program for your personal use
p72248
aVIn which case, since your library wants 8 bit characters, maybe it's simplest for you to target ANSI
p72249
aVBut either way I rather suspect that  is just going to confuse you
p72250
aVI'd abandon that if I were you
p72251
aVOne final point is that you mention that you target x64 since your system is 64 bit
p72252
aVDo be aware that 64 bit systems can run 32 bit code perfectly well
p72253
aVIf you want your program to be capable of running on a 32 bit system, and you don't have a pressing need to run under 64 bit, then it may be easier to target x86
p72254
aVYour edit to the question asks a separate question, which I'll attempt to answer in spite of my reservations
p72255
aVThe unresolved external symbol error indicates that the linker could not resolve that particular symbol
p72256
aVIn order for the linker to resolve it, it needs to be passed the
p72257
aVlib file that defines that symbol
p72258
aVYou should double check that you have included all required
p72259
aVlib files in your additional dependencies
p72260
aVFrom what I can glean, there are multiple
p72261
aVlib files for OpenCV and you are probably missing the one which defines
p72262
as(dp72263
g7
V505088
p72264
stp72265
a((dp72266
g2
(lp72267
VThere is nothing in the language or compiler that allows you to supply hints for branch prediction
p72268
aVAnd in any case, modern architectures would ignore those hints even if the compiler emitted object code that contained hints
p72269
as(dp72270
g7
V505088
p72271
stp72272
a((dp72273
g2
(lp72274
VFirst of all, the direct answer to your question
p72275
aVI need to get the way, to disable everything on main form
p72276
aVSet  to  to disable the window associated with the main form
p72277
aVAnd to re-enable set it to  instead
p72278
aVYour fundamental problem however, is that you are executing long running tasks in the GUI thread
p72279
aVThat's always a bad idea and the way out is to execute those long running tasks in a separate thread
p72280
aVOnce you move the long running tasks to a separate thread then you will find that  is exactly what you need to show your progress form
p72281
as(dp72282
g7
V505088
p72283
stp72284
a((dp72285
g2
(lp72286
VWell, you certainly cannot hope to do anything like that with conditional compilation
p72287
aVRemember that conditional compilation for generics are handled in the generic compilation phase rather than the instantiation phase
p72288
aVAnd so you cannot expect different instantiations to be compiled with different branches of your conditional statement
p72289
aVAnd you certainly can never get the compiler to accept  where the type of  is parametrised, because there is no way to specify a constraint that would allow the use of
p72290
aVThe only option is a run-time check
p72291
as(dp72292
g7
V505088
p72293
stp72294
a((dp72295
g2
(lp72296
VLike this:
p72297
aVAlthough  returns a tuple, you don't need to unpack it
p72298
aVYou can simply select the item that you need and ignore the one that you don't need
p72299
as(dp72300
g7
V505088
p72301
stp72302
a((dp72303
g2
(lp72304
VI'd guess that it is simply a very literal reflection of the underlying Win32 process creation flag named
p72305
aVOnly the author of the
p72306
aVnet class can explain why the choice was made to reflect the Win32 convention onto the
p72307
aVnet class
p72308
aVIt could easily have been done the other way
p72309
aVIf I had to guess, I'd suggest that the choice was made to make it very clear that the property maps directly onto
p72310
as(dp72311
g7
V505088
p72312
stp72313
a((dp72314
g2
(lp72315
VWell, the error tells you what is the problem
p72316
aVThe class you are requesting is not registered in the COM registry
p72317
aVIt could be that the IID of class that you registered is not the one that you are requesting
p72318
aVAnother common failure mode is that you registered a 32 bit DLL and your calling process is 64 bit
p72319
aVOr vice versa
p72320
as(dp72321
g7
V505088
p72322
stp72323
a((dp72324
g2
(lp72325
VThe problem with the compiler appears to be that at the generic phase of the compilation,  is not known
p72326
aVAnd so the compiler appears to use a place holder value of
p72327
aVBy the time you instantiate the generic type,  is replace by the true value
p72328
aVBut it's too late
p72329
aVThe array type bounds checking is performed at the generic phase of the compilation at which point  is  and so the compiler gags
p72330
aVThat this is the case can be seen by the following code:
p72331
aVwhich produces this compiler error:
p72332
aV[dcc32 Error]: E2098 Division by zero
p72333
aVBut, if you try this variant:
p72334
aVthe output is:
p72335
ag34876
ag57182
aVThis shows that your constant declaration has a place holder value for the array type bounds checking, but has a true value once the generic has been instantiated
p72336
aVSo, if the compiler postponed array type bounds checking until instantiation, then all would be well in terms of the compiler warning
p72337
aVBut even then, the code would not do what you expect and desire
p72338
aVThis program:
p72339
aVproduces somewhat undesirable output:
p72340
ag9193
ag9193
aVSo it seems that not only are the array bounds checked at the generic phase of compilation, but the array bounds are fixed at that phase, and fixed using the place holder value of the type parameter size
p72341
aVWhat this means is that you cannot hope to achieve array bounds that vary based on the size of the data type
p72342
aVThe same behaviour is present in XE3, and I don't have XE4 at hand to check there
p72343
aVI personally feel that this is a design flaw in the compiler that warrants a QC report
p72344
aVIn my opinion, the only viable way to resolve this is to give up trying to specify array bounds
p72345
aVI would declare it like this:
p72346
aVObviously you'll need to disable range checking in this unit, but that's no real hardship since range checking doesn't do you any favours for the original code
p72347
as(dp72348
g7
V505088
p72349
stp72350
a((dp72351
g2
(lp72352
VIt would appear that changes that you make to  during the  event are subsequently overwritten by the framework
p72353
aVEither the Windows API, or the VCL, I have not investigated which
p72354
aVOne solution is to postpone the actual change until processing of the original input event has completed
p72355
aVLike this:
p72356
as(dp72357
g7
V505088
p72358
stp72359
a((dp72360
g2
(lp72361
VThat is not a multi-dimensional array
p72362
aVIt is a
p72363
aVIt happens to contain other lists
p72364
aVThere's nothing to say that your list could not be:
p72365
aVIn which case, what value would you expect such a function to return
p72366
aVThere is no general function that does what you ask, not least because Python itself does not define a matrix/array class
p72367
aVYou certainly can write your own function which operates on iterable objects like lists and tuples if you are prepared to make assumptions, or write assertions, as to the uniformity of the list
p72368
aVUse  for the first dimension,  for the second, and so on
p72369
aVRecursion will be your friend here
p72370
aVIf you used a numpy array for your matrix, which to be honest would make a lot of sense, then your function would exist (it is the  property of the ndarray class) and be meaningful
p72371
as(dp72372
g7
V505088
p72373
stp72374
a((dp72375
g2
(lp72376
VTo the best of my knowledge you cannot do what you need with casting
p72377
aVYou can, I suppose, use  to make an assignment:
p72378
aVI've honestly no idea how robust this is
p72379
aVWill it work on multiple Delphi versions
p72380
aVIs it wise to rely on obscure undocumented implementation details
p72381
aVOnly you can determine whether the gains you make outweigh the negatives of relying on implementation details
p72382
as(dp72383
g7
V505088
p72384
stp72385
a((dp72386
g2
(lp72387
VIf you want a fixed point representation then you simply need to decide on the scale
p72388
aVOnce you have decided that you convert from floating to fixed like this:
p72389
aVAnd in the other direction like this:
p72390
aVAs to what scale to use, that depends on what you are trying to achieve and what the input data are
p72391
as(dp72392
g7
V505088
p72393
stp72394
a((dp72395
g2
(lp72396
VDelphi has for a long time, and XE4 is no different, shipped with DUnit
p72397
aVYou need to make sure that you select it in the install options
p72398
aVThe version that is shipped with Delphi is already updated to work with the version of Delphi that it ships with
p72399
aVLooking at the DUnit sourceforge project, it seems rather moribund
p72400
aVThe last commit to the SVN archive that mentions Delphi versions is for Delphi 2009
p72401
aVSo it seems clear to me that you are best sticking with the version that ships with Delphi
p72402
as(dp72403
g7
V505088
p72404
stp72405
a((dp72406
g2
(lp72407
VIf you are struggling understanding a complex nested use of the conditional operator, then simply expand it to an if statement:
p72408
aVAnd then expand the inner conditional operator:
p72409
aVOnce you've expanded it like this, it should be clear what the expression is doing
p72410
as(dp72411
g7
V505088
p72412
stp72413
a((dp72414
g2
(lp72415
VThere is no reliable way to detect, when given as input an array of 8 bit characters, which 8 bit encoding has been used for those characters
p72416
as(dp72417
g7
V505088
p72418
stp72419
a((dp72420
g2
(lp72421
VExcerpt 1
p72422
aVSince  is a struct or class of type , you access its members with the  operator, known as element selection by reference
p72423
aVExcerpt 2
p72424
aVHere,  is a pointer to  and so you can first de-reference the pointer and then use the  operator like before:
p72425
aVOr the short cut way that you used, which uses the element selection through pointer operator, :
p72426
aVAs Armin correctly points out, the form of element access that you need to use is determined by the type of the variable through which you access the element
p72427
aVIt is not determined by the way in which the object is created
p72428
aVFor example:
p72429
as(dp72430
g7
V505088
p72431
stp72432
a((dp72433
g2
(lp72434
VYou don't need to do anything more than you have here
p72435
aVThe unmanaged memory is owned by the system
p72436
aVIt allocated it, and it will dispose of it
p72437
aVYou did not allocate any unmanaged memory
p72438
aVYou simply copied the contents of the unmanaged struct that you were passed into a new managed struct
p72439
aVThe
p72440
aVnet GC will take take of the lifetime of that managed object
p72441
as(dp72442
g7
V505088
p72443
stp72444
a((dp72445
g2
(lp72446
VLike this perhaps:
p72447
aVAnd now you can use  to refer to elements of the overlayed  array
p72448
as(dp72449
g7
V505088
p72450
stp72451
a((dp72452
g2
(lp72453
VThe type of  is  which is a type that cannot take the value
p72454
aVFrom what you currently have, it is not possible to detect whether or not  has been set
p72455
aVSuppose that its default value is
p72456
aVThen the value is set to , and then back to
p72457
aVNow, how can you distinguish the current  from the original unmodified
p72458
aVIf what you want to do is detect whether or not the value is , well I don't think I need to tell you how to do that
p72459
aVIf you really want to detect whether or not the value has ever been set you'll need to maintain a  flag and set that flag the first time the property's setter executes
p72460
as(dp72461
g7
V505088
p72462
stp72463
a((dp72464
g2
(lp72465
VYou cannot marshal the pointers contained in the struct as C# arrays
p72466
aVYou are going to need to declare them as , and then marshal them yourself
p72467
aVYou'll need  for that process
p72468
aVI'm not sure about the memory ownership rules
p72469
aVPresumably the native code allocates the arrays that come back in the struct
p72470
aVIf so then I guess you'll have to call the native library again when you are done with the struct so that it can deallocate the arrays
p72471
as(dp72472
g7
V505088
p72473
stp72474
a((dp72475
g2
(lp72476
VIf  is your unsafe pointer, and the array has length , you can use  like this:
p72477
aVBut I do wonder how you came by an unsafe pointer to native memory
p72478
aVDo you really need unsafe here, or can you solve the problem by using  instead of an unsafe pointer
p72479
aVAnd if so then there's probably no need for unsafe code at all
p72480
as(dp72481
g7
V505088
p72482
stp72483
a((dp72484
g2
(lp72485
VThe Delphi  can indeed be a flickery beast
p72486
aVMany people will recommend double buffering, but I don't like that
p72487
aVIt brings other problems
p72488
aVIn particular, if you are using themes then double buffering can interfere with the themed rendering
p72489
aVMy trick for dealing with label flicker is to use a  instead of a
p72490
aVThis is a windowed control, a wrapper around the Windows  control, and in my experience it invariably will not flicker in the scenario where  would
p72491
aVAs others mention, throttling update rate is a sound idea, and is wise irrespective of flickering
p72492
aVThere's no need to spend resources updating the UI any faster than the human eye can absorb
p72493
aVFor something like download progress you should not really need any more than 5Hz in my view
p72494
aVThis may very well be the root cause of your problem, and if throttling update rate solves the problem then you can stick with
p72495
aVMy answer here has some more general anti-flicker tips: TLabel and TGroupbox Captions Flicker on Resize
p72496
as(dp72497
g7
V505088
p72498
stp72499
a((dp72500
g2
(lp72501
VYou cannot disable mangling for a C++ class method, but you may well be able to export the function under a name of your choice using  or a
p72502
aVdef file
p72503
aVHowever, your entire approach is brittle because you rely on an implementation detail, namely that  is passed as an implicit parameter
p72504
aVAnd what's more, exporting individual methods of a class is a recipe for pain
p72505
aVThe most sensible strategies for exposing a C++ class to
p72506
aVnet languages are:
p72507
aVCreate flat C wrapper functions and p/invoke those
p72508
aVCreate a C++/CLI mixed mode layer that publishes a managed class that wraps the native class
p72509
aVOption 2 is preferable in my opinion
p72510
as(dp72511
g7
V505088
p72512
stp72513
a((dp72514
g2
(lp72515
VYou are using the wrong name to import the function
p72516
aVIts name is  but you are trying to import
p72517
aVLetter case matters when you call
p72518
aVIf that still doesn't result in the  call succeeding, double check the name with which the function is exported using a tool like Dependency Walker
p72519
aVThe function is cdecl so you should declare it like this:
p72520
aVAnd the other problem is that you are responsible for allocating the buffer behind cid
p72521
aVYou did not do that
p72522
aVDo it like this:
p72523
aVAnd delete the aCID variable
p72524
aVAnd that >32 error check is wrong, compare against 0
p72525
as(dp72526
g7
V505088
p72527
stp72528
a((dp72529
g2
(lp72530
VThe system is behaving exactly as designed, but be aware that your code is going against all sound design principles
p72531
aVSpecifically the use of  and  in an input event handler are both to be frowned upon
p72532
aVThe reason that the program behaves this way is as follows:
p72533
aVThe user generates an input message by clicking the mouse
p72534
aVThis input event is placed in the input queue for the appropriate thread
p72535
aVThat thread is not servicing its input queue (it is sleeping) and so the input message, which is a mouse down, mouse up combo, sits there
p72536
aVThe thread wakes up and enables the button
p72537
aVThe button  handler returns and the application's message loop continues
p72538
aVIn due course the mouse down and mouse up messages are processed (before the  message) and so the button  handler runs again
p72539
aVThe button  handler calls  which then handles the  and kills the form
p72540
aVBOOM
p72541
aVThe whole concept of acknowledging the second click by the system when the respective button is disabled does not seem to be sound
p72542
aVThe key point is that the enabled state of the button is checked when the input message is processed and not when the input message is generated
p72543
aVIt has to be this way because input messages are extremely low level things, and it's only the application that can interpret them as things like button clicks
p72544
aVThere are plenty of ways to fix your code, but I'm loathe to suggest any because this is clearly code for illustration
p72545
aVBut I will say that all sound solutions will involve the removal of the calls to  and `ProcessMessages
p72546
as(dp72547
g7
V505088
p72548
stp72549
a((dp72550
g2
(lp72551
VMoving the caret when performing undo of edit actions is very much by design
p72552
aVThis is for sure not strange behaviour and all editors behave this way
p72553
aVIf the caret was not moved, and the window now scrolled, you would have absolutely no feedback that an undo event had occurred
p72554
aVFor instance, the edit that you undo could perhaps be in code that is not currently visible
p72555
aVFor sure in plain Delphi there is no way to change the behaviour and I'd be astounded if any plugin offered such functionality because it would render the undo functionality completely unusable
p72556
aVPerhaps what you want to do is to undo some changes, and then return to where you were in the edit window before performing the undo operations
p72557
aVWell, the way to achieve that is to drop a bookmark, perform the undo, and then jump to the bookmark
p72558
as(dp72559
g7
V505088
p72560
stp72561
a((dp72562
g2
(lp72563
VYou are compiling targeting  and so  maps to  which expects wide character arrays,
p72564
aVBut  is a  literal
p72565
aVChange it to
p72566
aVThe compiler told you that  is undeclared
p72567
aVIt's right
p72568
aVAnd same for
p72569
aVThe variable you declared is named
p72570
aVAnd you did not declare  at all
p72571
as(dp72572
g7
V505088
p72573
stp72574
a((dp72575
g2
(lp72576
VThe C++ code uses the cdecl calling convention
p72577
aVBut you've specified stdcall in your p/invoke
p72578
aVChange that in the C# code and your two declarations will match
p72579
as(dp72580
g7
V505088
p72581
stp72582
a((dp72583
g2
(lp72584
VYour main form constructor and destructor must be like this:
p72585
aVYou need to use an override of the virtual constructor introduced in  because otherwise the form streaming framework will not find your constructor
p72586
aVIt calls the virtual constructor introduced in  so that's why you must override that one
p72587
aVAnd the only destructor you should ever have is an override of the one named  that was introduced in
p72588
aVOtherwise calls to  will not make your destructor run
p72589
aVHaving said that I think you've done this the wrong way
p72590
aVYour requirement was to merge the two units
p72591
aVThere's no need at all to merge the two classes
p72592
aVNow you mixed everything in together which makes the code much harder to understand
p72593
aVYou should keep the classes as they were before, but just declare them in the same unit
p72594
as(dp72595
g7
V505088
p72596
stp72597
a((dp72598
g2
(lp72599
VIt's just tuple indexing
p72600
aVNo different from this:
p72601
aVwhich assigns  to
p72602
aVIn your more complex variant, an element of the tuple is selected and then passed to
p72603
aVThe confusion is that the code makes it look like you are calling a function named
p72604
aVThis confusion was removed in Python 3 by dint of  being turned into a function
p72605
aVThe code in your question does something utterly different in Python 3
p72606
as(dp72607
g7
V505088
p72608
stp72609
a((dp72610
g2
(lp72611
VAn object reference variable of type  is no different from any other object reference
p72612
aVYou use  with it just as you would any other object reference variable
p72613
aVNote that  can only test for initialization of object reference variables that have been initialized to
p72614
aVFor example, class instance members are initialized to  before the instance's constructor starts to execute
p72615
aVObject references allocated with a call to  are initialized to
p72616
aVOr those set to the default value with an assignment to
p72617
aVBut object reference variables that are local variables are not initialized to
p72618
aVIn fact they are not initialized at all
p72619
aVLikewise for object reference variables that are allocated by a call to
p72620
aVThe bottom line is that the treatment of object reference variables of type  or indeed any other generic class, is identical to the treatment for any other  descendent
p72621
as(dp72622
g7
V505088
p72623
stp72624
a((dp72625
g2
(lp72626
VIs there any way to simulate CTRL+C
p72627
aVThe way to do this is to use the  function of Win32 to synthesize keystrokes
p72628
aVHere is an example:
p72629
aVNaturally the application which you wish to receive the CTRL+C key stroke will need to have input focus
p72630
as(dp72631
g7
V505088
p72632
stp72633
a((dp72634
g2
(lp72635
VUse  from the command line:
p72636
aVThe  switch instructs  to recurse into all subdirectories
p72637
aVExecute the command with the working directory set to the top level directory which contains these files
p72638
aVYou are having no luck from the Explorer shell because it does not regard such a file (no name, only an extension) as being valid
p72639
aVBut  is quite happy to delete such files
p72640
as(dp72641
g7
V505088
p72642
stp72643
a((dp72644
g2
(lp72645
VThe fundamental problem here is that you have translated ,  and  as 32 bit integers
p72646
aVBut they are actually pointer sized integers
p72647
aVYou should declare them as
p72648
aVThere are also other more minor problems with your translation
p72649
aVMy comments:
p72650
aVDon't invent your own types, use the types declared in the Windows unit
p72651
aVDon't rename Windows API functions
p72652
aVIf the function is called  in the Windows API, you should use that name also
p72653
aVDoing otherwise leads to confusion
p72654
aVDon't be too literal in your translations
p72655
aVBe prepared to use  parameters rather than pointers
p72656
aVFor example the first parameter to  would be better as a  parameter
p72657
aVMy final recommendation would be to use an existing translation of the API, one that is tried and tested
p72658
aVI expect you will find one in the JEDI code
p72659
aVThat said, I despair of the JEDI project and their inability to make it discoverable
p72660
as(dp72661
g7
V505088
p72662
stp72663
a((dp72664
g2
(lp72665
VI think the key to this can be found in this line from the documentation (my emphasis):
p72666
aVThe replacement file assumes the name of the replaced file and its identity
p72667
aVWhen you use , the replacement file has a different identity
p72668
aVIts creation date is not preserved, the creator is not preserved, any ACLs are not preserved and so on
p72669
aVUsing  allows you to make it look as though you opened the file, and modified its contents
p72670
aVThe documentation says it like this:
p72671
aVAnother advantage is that ReplaceFile not only copies the new file data, but also preserves the following attributes of the original file:
p72672
aVCreation time
p72673
aVShort file name
p72674
aVObject identifier
p72675
aVDACLs
p72676
aVSecurity resource attributes
p72677
aVEncryption
p72678
aVCompression
p72679
aVNamed streams not already in the replacement file
p72680
aVFor example, if the replacement file is encrypted, but the
p72681
aVreplaced file is not encrypted, the resulting file is not
p72682
aVencrypted
p72683
as(dp72684
g7
V505088
p72685
stp72686
a((dp72687
g2
(lp72688
Vcreates a pointer to non-modifiable memory, a string literal
p72689
aVAttempting to modify the character array that  points to invokes undefined behaviour
p72690
aVInstead you need to declare a modifiable string:
p72691
aVAnd then you can modify individual characters
p72692
aVBut, as others say, if this really is C++ rather than C then you would be much better using the standard library string
p72693
as(dp72694
g7
V505088
p72695
stp72696
a((dp72697
g2
(lp72698
VYou can declare a record and then use operator overloading to supply whichever operators you wish to support:
p72699
aVClearly you'll want to add more functionality, but this record meets the requirements stated in the question
p72700
as(dp72701
g7
V505088
p72702
stp72703
a((dp72704
g2
(lp72705
VThere are many things wrong with your code
p72706
aVHere's a non-exhaustive list:
p72707
aVYou don't allocate any storage for your arrays
p72708
ag25125
aVYou pass  to  which you then cast to  in the callback
p72709
aVYour arrays are fixed length and you make no attempt to handle out of bounds access to the arrays
p72710
aVBut your biggest problem is that your code is attempting to run before you can walk
p72711
aVIt has full complexity and all the functionality that you need
p72712
aVYet you cannot yet manage to make a single successful call to
p72713
aVMy biggest piece of advice here is not in the detail, but the generality of problem solving
p72714
aVStart by writing a simple piece of code
p72715
aVUnderstand it
p72716
aVThen enhance it
p72717
aVSo, in that vein, here is how to make a call to :
p72718
aVStarting from here you can expand this concept, because all the tricky parts are already taken care of
p72719
aVSpecifically the pointer, casting and memory management
p72720
as(dp72721
g7
V505088
p72722
stp72723
a((dp72724
g2
(lp72725
VThe fundamental issue here is that you cannot share Delphi class types between modules using DLLs
p72726
aVThe reason is that there will be multiple versions of what needs to be a single type
p72727
aVOne version in the executable, and one version in each DLL that uses it
p72728
aVThis is the same well known issue that exists with the VCL and is the reason why runtime packages were developed
p72729
aVAnd that's your solution for FMX also
p72730
aVIf you need to share Delphi class types between modules you need there to be one single definition of a type
p72731
aVAnd runtime packages are the mechanism that makes that possible
p72732
aVSo, stop using DLLs, move the code into a runtime package, make sure that the RTL and FMX are linked using runtime packages, and that problem will be solved
p72733
as(dp72734
g7
V505088
p72735
stp72736
a((dp72737
g2
(lp72738
VThe most common failure mode for  is that the paths need to be double null-terminated
p72739
aVI suspect that you have forgotten to do that and if you do so an access violation is one possible outcome
p72740
aVAs for packing of the struct, it's a standard Win32 struct
p72741
aVIt's not packed, it is aligned
p72742
aVRemove the  parameter from the  attribute
p72743
aVI cannot understand why you would not call
p72744
as(dp72745
g7
V505088
p72746
stp72747
a((dp72748
g2
(lp72749
VThe only way for the value of Tag to have any impact here would be if there is an event handler that responds to the change in Value
p72750
aVAnd for that event handler to switch behaviour on the value of Tag
p72751
aVTypically you'd do that if you wanted a programmatic modification of the track bar value to be treated differently than a user modification
p72752
aVTo work out exactly what's going on you need to look for the other uses of Tag in the rest of the code
p72753
aVWithout seeing the rest of the code (should have been in the question) I cannot verify that the explanation is as above but it's the only plausible explanation for that code in my view
p72754
aVNo matter what, that use of Tag is pretty lame
p72755
aVI'd always like to see a variable with a name that described its purpose
p72756
aVUpdate
p72757
aVAnd now that the full code has been added, it can be seen that the use of Tag is exactly as described above
p72758
as(dp72759
g7
V505088
p72760
stp72761
a((dp72762
g2
(lp72763
VThe Delphi 2007 IDE cannot handle large Vista icons, which use PNG compression
p72764
aVAnd neither can the  resource compiler that ships with Delphi 2007
p72765
aVMy solution, when I was still using legacy Delphi versions, was to make a
p72766
aVrc file containing the icons, and compile using the MS resource compiler,
p72767
aVThe MS resource compiler does support such icons, and is readily available, for example with the Windows SDK
p72768
as(dp72769
g7
V505088
p72770
stp72771
a((dp72772
g2
(lp72773
V displays a modal dialog
p72774
aVThis means that the call to  does not return until the dialog is closed
p72775
aVYour problem is that you wish to execute a long-running task without blocking the UI
p72776
aVThe way to achieve that is to put the long-running task, the search, into a separate thread
p72777
aVSend messages from the search thread to the UI thread to allow the UI to inform the user of progress
p72778
as(dp72779
g7
V505088
p72780
stp72781
a((dp72782
g2
(lp72783
VThe only function that you can call is
p72784
aVAll the others use C++ classes that you cannot access
p72785
aVSo I suggest that you do the following:
p72786
aVRemove all the other functions from the header file
p72787
aVRemove the  and the  lines
p72788
aVRemove the  and replace  with
p72789
aVEither include  or add some  statements for the Win32 types
p72790
aVPossibly deal with the  type depending on whether or not MATLAB knows how to deal with it
p72791
aVIf MATLAB won't recognise it, replace  with
p72792
aVAt that point the call to  should work and then you just need to write the code that calls
p72793
aVThe resulting header file might look like something this:
p72794
aVFinally, do note that  is a rather surprising type to encounter
p72795
aVIt suggests that the DLL is going to allocate  C strings, and then return them to you through the three description parameters
p72796
aVThis presents a memory allocation issue
p72797
aVWho is going to deallocate the memory
p72798
aVDoes it even need to be deallocated, or is it static
p72799
aVThose issues will need to be resolved by consulting the documentation for the DLL
p72800
as(dp72801
g7
V505088
p72802
stp72803
a((dp72804
g2
(lp72805
VNote that this access violation is not the more common type where you attempt to read or write a memory address
p72806
aVIn this case the error is that you are attempting to execute code at address
p72807
aVSo that would indicate that you are calling a function whose address is the null pointer
p72808
aVThe most obvious explanation would seem to be that  is in fact not a
p72809
aVIf that is the case, and since  is a virtual function, your code will be trying to perform vtable lookup on
p72810
aVAnd obviously that can only work if  really is what you think it is
p72811
as(dp72812
g7
V505088
p72813
stp72814
a((dp72815
g2
(lp72816
VManaged types have their references counted and when the count drops to zero, they are finalized
p72817
aVIf you have a local variable, then when it goes out of scope, its reference count will drop to zero
p72818
aVSo, you can create a descendent of  which you refer to using an interface
p72819
aVSomething like this:
p72820
aVYou can then use it like this:
p72821
aVWhen  leaves scope, the implementing object is destroyed and the procedure that you passed to  is executed
p72822
aVIt would be easy enough to specialise this idea to be dedicated to your use case
p72823
aVAnd that would make the code at the call site more concise
p72824
aVThat would look like this:
p72825
aVAnd you'd use it like this:
p72826
as(dp72827
g7
V505088
p72828
stp72829
a((dp72830
g2
(lp72831
Vis an inline array
p72832
aVThe C++ declaration that matches is:
p72833
aVBut you are trying to match it to:
p72834
aVand that's completely different
p72835
aVYou will need to marshal this by hand
p72836
aVIn the C# struct declare  to be
p72837
aVThen allocate native memory with  to hold an array of pointers
p72838
aVAnd then populate those pointers with pointers to your strings
p72839
aVAn alternative would be to use a pinned IntPtr[] and put that in testInfo
p72840
aVParameters
p72841
as(dp72842
g7
V505088
p72843
stp72844
a((dp72845
g2
(lp72846
VThe path  is relative to the root directory of the drive of the current working directory
p72847
aVYou probably mean to pass  to
p72848
aVOr even better,
p72849
aVFor example, this program demonstrates that you code works correctly provided that you pass an appropriate path to
p72850
as(dp72851
g7
V505088
p72852
stp72853
a((dp72854
g2
(lp72855
VYou can delete that entry from your system path variable
p72856
aVNote that if you do then any packages that you compile, that have their
p72857
aVbpl files written to that directory, will not be found at runtime
p72858
aVIf that does not matter to you then fine, remove that directory from your path
p72859
aVI would comment however, that there is no  character limit on the length of an environment variable
p72860
aVThe limits are described here: http://msdn
p72861
aVmicrosoft
p72862
aVcom/en-us/library/windows/desktop/ms682653
p72863
aVaspx
p72864
as(dp72865
g7
V505088
p72866
stp72867
a((dp72868
g2
(lp72869
VSince you are coding in C++ you should simply use the C++ inequality operator:
p72870
aVYou use  when you need to obtain a non-modifiable null-terminated C string
p72871
aVAnd you generally only need that when performing interop with C code
p72872
aVIt's never meaningful to compare the pointer values return by calls to
p72873
as(dp72874
g7
V505088
p72875
stp72876
a((dp72877
g2
(lp72878
VYour app includes the comctl32 v6 manifest, because the Enable runtime themes option is selected
p72879
aVDisable that option and your app will not be themed
p72880
as(dp72881
g7
V505088
p72882
stp72883
a((dp72884
g2
(lp72885
VDeclare a type for HCRYPTPROV:
p72886
aVThen declare the functions:
p72887
aVNote that var and out parameters are passed as pointers to the actual parameter
p72888
aVSo in your code you would have had too much indirection
p72889
aVIn my translation here I have adopted the following policy:
p72890
aVValue parameters don't use const
p72891
aVThere seems little benefit for an external declaration
p72892
aVPointer parameters are passed by var or out by preference
p72893
aVFor simple types like these, out and var have the same implementation and the only reason for using one or the other is to document the parameter semantics
p72894
aVOptional pointer parameters are declared as pointers to allow the caller to pass nil
p72895
as(dp72896
g7
V505088
p72897
stp72898
a((dp72899
g2
(lp72900
VYou are missing a parameter, have the wrong return type, and have the wrong character set
p72901
aVIt should be:
p72902
aVI've assumed the string parameter is an input parameter
p72903
aVIf not, then you need to declare it as StringBuilder and pass a StringBuilder instance with sufficient capacity for the output buffer
p72904
as(dp72905
g7
V505088
p72906
stp72907
a((dp72908
g2
(lp72909
VOlder versions of Windows do have that key
p72910
aVHowever, use of that key is an implementation detail
p72911
aVYou should use the CSIDL API to locate the program files directory and other special locations
p72912
aVYou are looking for CSIDL_PROGRAM_FILES and SHGetSpecialFolderPath
p72913
as(dp72914
g7
V505088
p72915
stp72916
a((dp72917
g2
(lp72918
VThis is down to the file system redirector
p72919
aVYou are executing under the WOW64 emulator that emulates 32 bit Windows on a 64 bit system
p72920
aVUnder WOW64, the  is redirected to
p72921
aVYou'll need to put your DLL there
p72922
aVWith that said, the system directory is owned by, and private to, the system
p72923
aVYou are expected not to put DLLs into the system directory
p72924
aVYou should find a way to put your DLL in some other location
p72925
as(dp72926
g7
V505088
p72927
stp72928
a((dp72929
g2
(lp72930
VAs Sir Rufo has discovered the issue is a VCL bug introduced in Delphi 7 as described in QC#2246
p72931
aVAccording to that report the bug is resolved in a build with major version number 7 so you may be able to fix the problem by applying the latest Delphi 7 updates
p72932
aVIf not then you can fix the problem from the outside
p72933
aVI don't actually have a Delphi 7 installation to test this on, but I believe that this interposer class will work
p72934
aVThe bug that was introduced in Delphi 7 is simply that the  statement reads:
p72935
aVSo, when  is zero, that is when the item is the empty string, the  branch of the  is chosen
p72936
aVThen, the  becomes:
p72937
aVNow,  has special treatment and evaluates to a pointer to read only memory containing a zero character
p72938
aVAnd so when the combo box window procedure attempts to write to that memory, an access violation occurs because the memory is read only
p72939
as(dp72940
g7
V505088
p72941
stp72942
a((dp72943
g2
(lp72944
VThe C++ function is declared like so:
p72945
aVThe final parameter could be a single struct, passed by reference
p72946
aVIn which case the C# would be:
p72947
aVNote that there is no need for unsafe here, so I removed it
p72948
aVAnd it looks very much like the C++ function uses
p72949
aVHowever, the use of the plural in , and the  parameter makes me suspect that the C++ code expects an array
p72950
aVIn which case you write:
p72951
aVI'm also somewhat sceptical of your use of  in the struct definition
p72952
aVWhat made you do that
p72953
aVI would expect an aligned struct in which case you should remove
p72954
aVI don't think it matters since the C++ struct puts reserved members in the spaces where padding would be added, but I'd still rather see the struct declared as aligned
p72955
as(dp72956
g7
V505088
p72957
stp72958
a((dp72959
g2
(lp72960
VThe runtime takes ownership of exceptions after they are raised
p72961
aVYou do not need to free them
p72962
aVThe exception is destroyed at the end of the block in which it is handled, as demonstrated by this program:
p72963
aVwhich outputs:
p72964
aVMyException: Boo
p72965
aVMyException
p72966
aVDestroy
p72967
aVAfter try/except block
p72968
aVWhilst the debugger may still show you information about the exception after it has been freed, that behaviour is undefined
p72969
aVThe compiler understands that the exception has left scope, even if the debugger is ignorant of that fact
p72970
aVIf you want an exception's lifetime to extend beyond the  block which handles it then you would need to call
p72971
aVOnce you do that, it becomes your responsibility to free the exception whose lifetime you acquired
p72972
as(dp72973
g7
V505088
p72974
stp72975
a((dp72976
g2
(lp72977
VC++98 does not have any support for threading, neither in the language nor the standard library
p72978
aVYou need to use a third party library and you have already listed a number of the main candidates
p72979
as(dp72980
g7
V505088
p72981
stp72982
a((dp72983
g2
(lp72984
VThe documentation explains that you can use AVI files with raw uncompressed frames, or with run length encoding compression
p72985
aVThe AVI of yours that fails does not meet those requirements
p72986
as(dp72987
g7
V505088
p72988
stp72989
a((dp72990
g2
(lp72991
VYou simply need to call the  method of the document:
p72992
aVSince you specified the encoding already, the component will use that encoding
p72993
aVThis won't include a BOM, but that's generally what you want for an XML file
p72994
aVThe content of the file will specify the encoding
p72995
aVAs regards your  method, it is not needed, but it is easy to fix
p72996
aVAnd that may be instructive to you
p72997
aVThe problem is that you are converting to UTF-16 when you assign to a  variable
p72998
aVYou should instead put the UTF-8 text into an  variable
p72999
aVChanging the type of the variable that you named  to  is enough
p73000
aVThe function might look like this:
p73001
as(dp73002
g7
V505088
p73003
stp73004
a((dp73005
g2
(lp73006
VThe compiler complains because  is not a declaration
p73007
aVYou'll need to move the  so that it comes after the declarations
p73008
aVUsing a C compiler that supported a standard more recent that C89 would be a good move
p73009
as(dp73010
g7
V505088
p73011
stp73012
a((dp73013
g2
(lp73014
VThe two forms of DLL linking are perhaps better named implicit and explicit
p73015
aVImplicit linking is what you refer to as static linking
p73016
aVAnd explicit linking is what you refer to as runtime linking
p73017
aVFor implicit linking the linker writes entries into the import table of the executable file
p73018
aVThis import table is metadata that is used by the loader to resolve DLL imports at module load time
p73019
aVA stub function is included for each implicit import that is only a few bytes in size
p73020
aVThe executable size implications of implicit linking are negligible
p73021
aVWith explicit linking the imported function's address is resolved by a call to GetProcAddress
p73022
aVThis call is made when the programmer chooses
p73023
aVIf the DLL or the function cannot be resolved, the programmer can code fall back behaviour
p73024
aVThere are size implications to explicit linking that I estimate to be similar to implicit linking
p73025
aVIf the function address is evaluated once and remembered between calls then the performance characteristics are similar to implicit linking
p73026
aVMy advice is as follows:
p73027
aVPrefer implicit linking
p73028
aVIt is more convenient to code
p73029
aVIf the DLL may not be present, use explicit linking
p73030
aVIf the DLL must be loaded using a full path, use explicit linking
p73031
aVIf you want to unload the DLL during program execution, use explicit linking
p73032
aVYou specifically mention Windows DLLs
p73033
aVYou can safely assume that they will be present
p73034
aVDon't try to code to allow your program to run in case user32
p73035
aVdll is missing
p73036
aVSome functions may not be present in older versions of Windows
p73037
aVIf you support those older versions you'll need to use explicit linking and provide a fallback
p73038
aVDecide which version you support and use MSDN to be sure that a function is available on your minimum supported platform
p73039
as(dp73040
g7
V505088
p73041
stp73042
a((dp73043
g2
(lp73044
VTList supports searching for items using either linear or binary search
p73045
aVWith binary search, the algorithm assumes an ordering
p73046
aVThat's not appropriate for your needs
p73047
aVLinear search seems to me to be what you need, and it's available through the Contains method
p73048
aVThe problem is that Contains assumes that you are searching for an entire instance of T
p73049
aVYou want to pass a single string to Contains but it won't accept that
p73050
aVIt wants a complete record, in your case
p73051
aVYou could provide a Comparer that only compares a single field
p73052
aVAnd then pass Contains a record with just that one field specified
p73053
aVBut that's pretty ugly
p73054
aVFrankly the design of this class is very weak when it comes to searching and sorting
p73055
aVThe fact that the comparer is a state variable rather than a parameter is a shocking lapse in my view
p73056
aVThe bottom line is that TList does not readily offer what you are looking for without resorting to ugliness
p73057
aVYou should probably implement an old-fashion loop across the list to look for your match
p73058
aVNote that I'm assuming you want to provide a single string and search for an entry that has a field matching the string
p73059
aVIf in fact you do want to provide a complete record and match every field, then Contains does what you need, with suitable Comparer using a lexicographic ordering
p73060
as(dp73061
g7
V505088
p73062
stp73063
a((dp73064
g2
(lp73065
VIf you were to remove class names from the executable, then your application would stop working
p73066
aVThe
p73067
aVdfm files that are compiled into your application contain the class names
p73068
aVThe runtime streaming framework needs to be able to look those classes up in the class registry and without the names then your forms and their properties could not be streamed
p73069
aVOn top of that, as AlexSC points out, the implementation of  requires the names of the classes to be present in the executable file
p73070
as(dp73071
g7
V505088
p73072
stp73073
a((dp73074
g2
(lp73075
V includes a generic constraint that  is a class
p73076
aVThe type declaration is as follows:
p73077
aVYou might think that constraints are inherited, but that is not the case
p73078
aVAnd so you need to include the constraint in your class
p73079
aVSpecify the constraint like so:
p73080
as(dp73081
g7
V505088
p73082
stp73083
a((dp73084
g2
(lp73085
VIn the second call to  you are passing an , but the format string is  which expects a floating point value to be passed
p73086
aVThis invokes undefined behaviour
p73087
aVIf you want to treat  as a floating point value when you pass it to , you'll need an explicit conversion:
p73088
as(dp73089
g7
V505088
p73090
stp73091
a((dp73092
g2
(lp73093
VHere is a Delphi a translation of C code found here: http://www
p73094
aVcs
p73095
aVrit
p73096
aVedu/~ncs/color/t_convert
p73097
aVhtml
p73098
aVI've given this minimal testing
p73099
aVPlease do feel free to double check it
p73100
as(dp73101
g7
V505088
p73102
stp73103
a((dp73104
g2
(lp73105
VThe type that you defined in your code is
p73106
aVBut you then went on to use  which is a type defined in
p73107
aVSimply replace
p73108
aVwith
p73109
aVin your code, and it will compile
p73110
aVHaving said that, it would be simpler if you used the code in the answer you accepted
p73111
aVThere's no need for a two parameter predicate since variable capture is used to provide the search string
p73112
as(dp73113
g7
V505088
p73114
stp73115
a((dp73116
g2
(lp73117
VThis is a basic design flaw with the Delphi 5 implementation of
p73118
aVThe underlying Windows thread is started in the constructor of
p73119
aVWhich leads to the race that you describe
p73120
aVIn the Delphi 6 version of the RTL, the thread start mechanism was changed
p73121
aVFrom Delphi 6 onwards, the thread is started in
p73122
aVAnd that runs after the constructor completes
p73123
aVThat would render your code race free
p73124
aVIn Delphi 6 and later, the underlying Windows thread is created in the  constructor, but is created suspended using the  flag
p73125
aVThen in , so long as  is , the thread is resumed
p73126
aVOne way to work around the issue in Delphi 5 is to call the inherited constructor last
p73127
aVLike this:
p73128
aVRather ugly I know
p73129
aVSo, your approach of creating the thread suspended and resuming once the constructor has completed is probably better
p73130
aVThat approach mirrors how the RTL solves the problem in Delphi 6 and up
p73131
as(dp73132
g7
V505088
p73133
stp73134
a((dp73135
g2
(lp73136
VTo convert from a floating point value x, in the range 0
p73137
aVN, to an integer i, in the range 0
p73138
aVM, do this:
p73139
aVIn the opposite direction:
p73140
aVOften one of M or N is equal to 1 which simplifies matters
p73141
aVThese are all the equations you will need for color space scale conversions
p73142
as(dp73143
g7
V505088
p73144
stp73145
a((dp73146
g2
(lp73147
VIn Delphi 7, TRecBuf was a pointer of some type, I'm not sure exactly what
p73148
aVIn XE4, it is declared as NativeInt
p73149
aVYou'd need to cast it to be a pointer to make your code compile
p73150
aVI would also point out that HoldRec is now PWideChar in Unicode XE4, but it was PAnsiChar in Delphi 7
p73151
aVI suspect you'll need to deal with that one way or another
p73152
aVQuite possibly you'd need to change the declaration to PAnsiChar, but I cannot say for sure from here
p73153
as(dp73154
g7
V505088
p73155
stp73156
a((dp73157
g2
(lp73158
VI expect that what you are measuring is the time to open and close the files
p73159
aVThere are rather a lot of files
p73160
aVYou should be able to read 57MB from a disk in around one second
p73161
aVSo the overhead would appear to be the file opening rather than the reading
p73162
aVYou should try again with fewer, but larger, files
p73163
aVCreate, say, 20 100MB files and read those
p73164
aVIt looks like, on your system at least, that it is slower to open files with  than without
p73165
aVIn any case, don't expect  to speed things up
p73166
aVThe time spent copying from the file handle's buffer to your buffer is trivial in comparison to pulling the data off the disk
p73167
as(dp73168
g7
V505088
p73169
stp73170
a((dp73171
g2
(lp73172
VA jump instruction moves the instruction pointer to a new location
p73173
aVIt's the machine language equivalent of goto
p73174
aVAbsolute jumps move the instruction pointer to an absolute address
p73175
aVA relative jump jumps to an address specified relative to the current instruction pointer
p73176
aVThe $E9 opcode is a relative jump with a 32 bit offset
p73177
aVNote that there are different jump opcodes for jumps with differently sized offsets
p73178
aVThe address is relative to the end of the jump instruction, hence the SizeOf(NewCode) adjustment
p73179
aVThat code does look familiar to me
p73180
aVI think I wrote it
p73181
as(dp73182
g7
V505088
p73183
stp73184
a((dp73185
g2
(lp73186
VThere's lots wrong with your code
p73187
aVThe main faults are:
p73188
aVThe Delphi function receives a pointer by reference, but the VB code passes it by value
p73189
aVThe Delphi code would need to copy the string into the buffer provided
p73190
aVThe Delphi code should use PAnsiChar to match the VB
p73191
aVOr PWideChar and CharSet
p73192
aVUnicode on the p/invoke
p73193
aVThe VB code needs to use StringBuilder rather than String in order for the string to be marshalled back to the caller
p73194
aVThe function would need to accept a length parameter in order to avoid buffer overruns
p73195
aVHowever, I'm not sure it's worth trying to understand it in too much depth
p73196
aVThe simplest way to do this is to use a BSTR which is allocated on the shared COM heap
p73197
aVThis makes the function much easier to use and hides all the memory allocation complexity
p73198
aVDelphi
p73199
aVVB
p73200
as(dp73201
g7
V505088
p73202
stp73203
a((dp73204
g2
(lp73205
VThe message queue associated with a thread is a threadsafe queue
p73206
aVBoth synchronous and asynchronous messages from multiple other thread are delivered safely no harmful date races
p73207
aVThere is no need for any external synchronization when calling the Windows message API functions like SendMessage and PostMessage
p73208
aVIf two threads post or send messages to the same window at the same time, then there is no guarantee as to which message will be processed first
p73209
aVThis is what is known as a benign race condition
p73210
aVIf you want one message to be processed before the other then you must impose an ordering
p73211
as(dp73212
g7
V505088
p73213
stp73214
a((dp73215
g2
(lp73216
VThere are a couple of obvious problems:
p73217
aVYou have an infinite loop in the OnStart event
p73218
aVThis event allows you to perform one time actions when the service starts
p73219
aVThat code belongs in OnExecute
p73220
aVServices cannot show UI and so ShowMessage cannot work
p73221
aVYou'll need to use a non-visual mechanism to give feedback
p73222
aVBecause your OnStart doesn't return, the SCM regards your service as not having started
p73223
aVSo I guess that item 1 above is the explanation as to why your service won't start
p73224
as(dp73225
g7
V505088
p73226
stp73227
a((dp73228
g2
(lp73229
V tells the marshaller to marshal as ANSI unless otherwise instructed
p73230
aVLikewise  is an instruction to marshal as UTF-16 unless otherwise instructed
p73231
aVSince options B and D do indeed instruct otherwise, the  parameter is overridden and so option B and D are in fact equivalent
p73232
aVThey are both incorrect since you asked for the function named  which expects ANSI text
p73233
aVThat leaves A and C
p73234
aVOption A calls the ANSI variant of the function  and option C calls the Unicode variant,
p73235
aVBehind the scenes the p/invoke marshaller picks the appropriate entry point using the value of the  parameter
p73236
aVNow, you could use either A or C, but the difference is just that with option A you will pass ANSI encoded text
p73237
aVAnd if text you pass contains characters that cannot be encoded in ANSI, there will be a loss of information
p73238
aVWhich is why C is to be preferred
p73239
aVIt will always receive the exact same text that exists in the
p73240
aVnet calling code
p73241
as(dp73242
g7
V505088
p73243
stp73244
a((dp73245
g2
(lp73246
VThe problem here is that the Embarcadero engineer who translated  does not understand COM reference counting, and how it is handled by different compilers
p73247
aVHere's how  is implemented in the C++ header file
p73248
aVIt's actually an inline wrapper of other core API calls:
p73249
aVAnd the Delphi translation is very faithful, indeed too faithful:
p73250
aVThe problem is the call to
p73251
aVThe Delphi compiler manages reference counting, and so this explicit call to  is bogus and should not be there
p73252
aVSince the compiler will arrange for a call to , this extra one simply unbalances the reference counting
p73253
aVThe reason why  and  are prefixed with  is to remind people not to call them and to let the compiler do that
p73254
aVThe call to  in the C++ version is accurate because C++ compilers don't automatically call  for you unless you wrap the interface in a COM smart pointer
p73255
aVBut the Embarcadero engineer has blindly copied it across and you are left with the consequences
p73256
aVClearly this code has never even been executed by the Embarcadero engineers
p73257
aVYou'll need to supply your own corrected implementation of this function
p73258
aVAnd also any other erroneously translated function
p73259
aVSearch for  in the  unit, and remove them in your corrected versions
p73260
aVThere are other bugs in the translation, so watch out
p73261
aVFor example,  (and others) declare local variable  which should be
p73262
aVI submitted a QC report: QC#117351
p73263
as(dp73264
g7
V505088
p73265
stp73266
a((dp73267
g2
(lp73268
VYou need to call
p73269
aVLike this:
p73270
aVFor the sake of completeness, here is a minimal example:
p73271
as(dp73272
g7
V505088
p73273
stp73274
a((dp73275
g2
(lp73276
VYour code works fine
p73277
aVMost likely the problem is a local one
p73278
aVPerhaps a problem with your network connection
p73279
aVOr perhaps the directory  does not exist
p73280
aVTo investigate your local problem, you'll need to make a note of the value returned by the function
p73281
aVIt's an  and  indicates success
p73282
aVOther values indicate failure
p73283
aVOnce you know what the error code is, you should be able to track down your problem
p73284
aVHaving said that,  doesn't seem to do a good job of returning meaningful error codes
p73285
aVFor example, if you make  be a path with non-existant folders, then the function still returns
p73286
as(dp73287
g7
V505088
p73288
stp73289
a((dp73290
g2
(lp73291
VI'm going to attempt to walk you through how to solve such a problem yourself
p73292
aVStep 1: Work out what the compiler error means
p73293
aVFrankly, this error is self-explanatory
p73294
aVNot enough actual parameters
p73295
aVWell, you did not pass enough parameters
p73296
aVHowever, if it's not obvious, then type the error message text, and the error code, E2035 in this case, into your favoured search engine
p73297
aVThat will lead you to the documentation for the compiler error which says:
p73298
aVThis error message occurs when a call to procedure or function gives less parameters than specified in the procedure or function declaration
p73299
aVAnd there are some examples to demonstrate how it can happen
p73300
aVThat's all useful information
p73301
aVTake some time to read it carefully
p73302
aVStep 2: Identify the line of code which leads to the error
p73303
aVThere are three instances which all look like this:
p73304
aVStep 3: Apply what we learnt in step 1 to the failing line of code
p73305
aVThere are 4 function/procedure calls
p73306
aVCheck the parameters for each one
p73307
aVCheck the declaration of the function against parameters you pass when the calling, that is the actual parameters
p73308
aVFor the three inner functions, the parameter counts match
p73309
aVBut look at the call to
p73310
aVThat function has six parameters, but you passed only three
p73311
aVThe above is a general procedure to adopt when facing a compiler error that you do not understand
p73312
aVYou will be able to apply this technique when you face other, different, compiler errors
p73313
as(dp73314
g7
V505088
p73315
stp73316
a((dp73317
g2
(lp73318
VYour code is formatted so that it is next to impossible to read and analyse
p73319
aVIf it was better formatted then I think you'd get more comprehensive answers
p73320
aVHere's what I can see:
p73321
aVThe records should not be packed
p73322
aVThe second parameter to  should not be a var parameter
p73323
aVBy making it a  parameter you force yourself to pass it
p73324
aVSince you don't want to use it, you should declare it as a pointer to  so that you can opt not to use it
p73325
aVIn  you did not assign anything to
p73326
aVWhat's more you then passed it to
p73327
aVYou are using a Unicode Delphi and so have no reason to use  here
p73328
aVSimply cast a , which is already UTF-16, to
p73329
aVYou are not allowing for the fact that  is 2 in your Unicode Delphi
p73330
aVSo your treatment of  in wrong
p73331
aVpassed an unitialised pointer to
p73332
aVleaks the memory allocated with
p73333
aVI don't really know what  is attempting to do, but it's clearly broken
p73334
aVI can't fix it since I've no idea what your goals are
p73335
aVHowever, I'm sure there are more problems
p73336
aVI have some general advice for you
p73337
aVThere is too much code in the question
p73338
aVYou should remove as much as possible
p73339
aVYou should make the smallest possible SSCCE
p73340
aVThis should be a simple console application
p73341
aVThe code should be formatted to be readable, and preferably without resort to horizontal scrolling
p73342
aVThis will help you as much as it helps us
p73343
aVThe point is that you are searching for errors
p73344
aVIf you cut the code down to be as simple as possible, then there is less to check
p73345
aVIf the code is visible and layed out neatly, it is easier to check
p73346
aVAs much as getting the specific details right, the general principle of knowing how to make your code readable and concise is much more important here
p73347
aVSo, just to show you what I mean, here is your original post converted into an SSCCE, and with a number of the bugs fixed:
p73348
aVI used the code formatting feature of the Delphi IDE to lay the code out in a readable style
p73349
aVAnd I converted it to a console application so that you have a single file that contains the entire program
p73350
aVThis version does at least run and not raise access violations
p73351
aVNow it's up to you to make it actually do what you want it to do
p73352
as(dp73353
g7
V505088
p73354
stp73355
a((dp73356
g2
(lp73357
VI'm hypothesising that the issue is related to window ownership
p73358
aVIn Delphi 7, file dialogs have the hidden application window as their window owner
p73359
aVBut the window owner really needs to be the window of the active form
p73360
aVThere are plenty of ways to fix this, but perhaps the simplest is to subclass  and override its  like this:
p73361
aVI don't have Delphi 7 at hand to test this, but I'm reasonably confident that something along these lines (with perhaps some tweaking of the  choice) will sort it out
p73362
as(dp73363
g7
V505088
p73364
stp73365
a((dp73366
g2
(lp73367
VThe best way to handle this is as follows:
p73368
aVCreate an action list, or action manager, or re-use an existing one
p73369
aVAdd an action that clears the memo and moves to the next one
p73370
aVYou'll need to check that the active control really is a memo
p73371
aVGive the action the shortcut that you desire, CTRL+ENTER
p73372
aVNote that you don't need to attach the action to anything
p73373
aVIt's mere presence is enough to ensure that the shortcut will be handled
p73374
aVFor compound keyboard actions using modifier keys it's always simplest to use an action shortcut and so keep at arm's length from the lower level keyboard handling code
p73375
aVYour action handler might look like this:
p73376
aVIn this code I'm assuming that there are multiple memos and the text is moved from one memo to the next one in the tab order
p73377
aVBut your needs may well differ
p73378
aVIn which case I'm sure it will be obvious what you need to do for your scenario
p73379
as(dp73380
g7
V505088
p73381
stp73382
a((dp73383
g2
(lp73384
VThe screen saver timeout is obtained by calling  with the action
p73385
as(dp73386
g7
V505088
p73387
stp73388
a((dp73389
g2
(lp73390
VYou'll need to call some Win32 functions using whichever interop technique you feel most comfortable with
p73391
aVHere's the outline of what you do:
p73392
aVCall  passing  for the  parameter, and the agreed mutex name
p73393
aVTo acquire the mutex call  passing the mutex handle
p73394
aVWhen you are done with the mutex, call
p73395
aVFinally call  to return the unmanaged resource to the system
p73396
aVYou'll clearly need to perform error checking in the usual way for Win32 functions
p73397
as(dp73398
g7
V505088
p73399
stp73400
a((dp73401
g2
(lp73402
VThe most simple example of a branch is an if statement:
p73403
aVNow if  is  then  is executed
p73404
aVIf not then the execution branches, by jumping to the statement that follows the end of the
p73405
aVIn very simple machine pseudo code this might be compiled to something along these lines:
p73406
aVThe branch point is the  instruction
p73407
aVThe subsequent execution point depends on the outcome of the test of
p73408
aVBranching affects performance because modern processors predict the outcome of branches and perform speculative execution, ahead of time
p73409
aVIf the prediction turns out to be wrong then the speculative execution has to be unwound
p73410
aVIf you can arrange the code so that prediction success rates are higher, then performance is increased
p73411
aVThat's because the speculatively executed code is now less of an overhead since it has already been executed before it was even needed
p73412
aVThat this is possible is down to the fact that modern processors are highly parallel
p73413
aVSpare execution units can be put to use performing this speculative execution
p73414
aVNow, there's one sort of code that never has branch prediction misses
p73415
aVAnd that is code with no branches
p73416
aVFor branch free code, the results of speculative execution are always useful
p73417
aVSo, all other things being equal, code without branches executes faster than code with branches
p73418
as(dp73419
g7
V505088
p73420
stp73421
a((dp73422
g2
(lp73423
VTo summarise the comment trail, I think that there is a fault in the WTS library code, that afflicts the  and  functions
p73424
aVThe SSCCE that I added to the question gives a pretty clear demonstration of that
p73425
aVSo, your options to work around the fault would appear to be:
p73426
aVOnly call  when you get notified that a session is created or destroyed
p73427
aVThat would minimise the number of calls you make
p73428
aVYou'd still be left with a leak, but I suspect that it would take a very long time before you encountered problems
p73429
aVSwitch to  and then call  to obtain any extra information that you need
p73430
aVFrom my trials,  would appear not to be afflicted by the same problem as
p73431
as(dp73432
g7
V505088
p73433
stp73434
a((dp73435
g2
(lp73436
V is of type
p73437
aVAnd  is a property of type  with a getter and a setter
p73438
aVNote that  is a record, which is a value type rather than a reference type
p73439
aVThat detail is crucially important
p73440
aVSo, when you write  you are referring to a copy of the vector
p73441
aVIt is a copy because  is a value type
p73442
aVSo, the non-working code is equivalent to:
p73443
aVClearly the call to  won't modify  because the call to  merely mutates the temporary local
p73444
aVIn your code, that temporary local variable is still present, but you have not given it a name
p73445
aVIt's a hidden, implicit variable
p73446
aVIn order to modify the position, you must make an assignment to the  property, which is exactly what the working code does
p73447
aVAs a general rule, value types which support in-place mutation are generally indicative of poor design
p73448
aVSo, in my view, the Embarcadero engineers should never have added the mutating instance methods like , ,  and so on
p73449
aVSuch methods lead to this confusion
p73450
aVInstead the functionality is better implemented with functions that return new values, just as the overloaded operators do
p73451
as(dp73452
g7
V505088
p73453
stp73454
a((dp73455
g2
(lp73456
VYour p/invoke is correct
p73457
aVThe only plausible explanation for the call to WaitForSingleObject never returning is that the event never becomes signaled
p73458
aVAs an aside, it would seem to me to be simpler to use EventWaitHandle instead of p/invoke
p73459
as(dp73460
g7
V505088
p73461
stp73462
a((dp73463
g2
(lp73464
VThere's no concept of optional members of an interface
p73465
aVWhat you need here is to define two interfaces
p73466
aVOne contains , and the other contains
p73467
aVSomething like this:
p73468
aVThen the implementing classes can choose to implement either  or
p73469
aVAt runtime you simply use the  operator to determine whether or not  is implemented by the object at hand
p73470
aVAnd to actually use the more derived interface use the  operator:
p73471
as(dp73472
g7
V505088
p73473
stp73474
a((dp73475
g2
(lp73476
VIn VB6, that function creates a string that contains 33 characters, all of whom have zero ordinal value
p73477
aVTypically you do that because you are about to pass the string to some native function which fills out the buffer
p73478
aVIn C# the closest equivalent to that would be to create a  instance which you would then pass to the native code in a p/invoke function call
p73479
aVI think that a direct translation of that single line of code is not particularly useful
p73480
aVThat code exists in context and I strongly suspect that the context is important
p73481
aVSo, whilst you could create a new C#  with 33 null characters, what would be the point of that
p73482
aVSince the
p73483
aVnet string is immutable, you cannot do very much of interest with it
p73484
aVIn your VB6 code you will surely be mutating that object, and so  is, in my view, the most likely tool for the job
p73485
as(dp73486
g7
V505088
p73487
stp73488
a((dp73489
g2
(lp73490
VWhen you do not specify the working directory, the new process will inherit the working directory of your process
p73491
aVThat is, the new process will inherit the working directory of the process that called
p73492
aVThat's the only difference between the two attempts to start
p73493
aVOne of them inherits the working directory, and one of them specifies it
p73494
aVClearly  does not like to run with the initial working directory being the directory of your parent process
p73495
aVWhy that is so, I cannot say for sure
p73496
aVIt would seem that  is attempting some XML parsing at startup
p73497
aVSo perhaps that XML parsing reads a file that is presumed to be in the working directory
p73498
aVBut in fact the file is located in the same directory as the executable
p73499
aVIf that is the case then you need to modify  to solve the problem
p73500
aVInstead of using a relative path for this XML file, you need to build an absolute path based on the directory of the executable file
p73501
aVThe  startup code can that directory, like this:
p73502
aVAnd then you would use  to form the full path to the XML file
p73503
as(dp73504
g7
V505088
p73505
stp73506
a((dp73507
g2
(lp73508
VAt this point:
p73509
aVYou loop over the following values:
p73510
aVand the loop will (probably) terminate when  wraps around to a positive value
p73511
aVIf indeed that's what happens with your long out-of-date compiler
p73512
aVWhen you then calculate
p73513
aVThe exponent becomes a large positive value and you will overflow in due course
p73514
aVI expect that's your fundamental problem
p73515
as(dp73516
g7
V505088
p73517
stp73518
a((dp73519
g2
(lp73520
VYou should only ever call  when passing something allocated with a call to
p73521
aVWhich means that you should only ever call  with
p73522
aVFurthermore, your assignment  is a syntax error
p73523
aVYou would need to use  to fill
p73524
aVLike this:
p73525
aVC strings are null-terminated by convention, and string literals, i
p73526
ag192
aVare null-terminated
p73527
as(dp73528
g7
V505088
p73529
stp73530
a((dp73531
g2
(lp73532
VIf you use an MS compiler later than version 6, then you will have to link to the runtime specific to that compiler
p73533
aVYou do not have any choice in the matter
p73534
aVSince the MSVC runtimes are not system DLLs, you will need to distribute them with your application
p73535
aVIf you use MSVC6, or a compiler that can link against msvcrt
p73536
aVdll, then you can link against msvcrt
p73537
aVdll
p73538
aVThe mingw compiler is quite configurable
p73539
aVHowever, I believe that it usually will link against msvcrt
p73540
aVdll
p73541
aVSince msvcrt
p73542
aVdll is a system DLL (since Windows 2000 IIRC) you do not need to distribute it
p73543
aVI'm assuming in all of this that you link to the runtime dynamically
p73544
aVThat is the preferred option, but it is always possible to link to the runtime statically
p73545
aVWhen you do that, you make your application standalone
p73546
aVIt all boils down to which compiler you prefer to use
p73547
aVIf you prefer to use a modern MSVC, then you'll need to accept the runtime distribution, or link statically
p73548
as(dp73549
g7
V505088
p73550
stp73551
a((dp73552
g2
(lp73553
VYou will need to send the control a  message
p73554
aVThe difficulty is that the message fills the contents of a struct that is passed as a pointer to the struct
p73555
aVBut that pointer must refer to memory allocated in the process which owns the list view
p73556
aVIn your scenario the list view is owned by a different process
p73557
aVYou can work around this by using  to allocate memory in the other processes
p73558
aVYou can then initialize that memory with
p73559
aVThen send the message before reading the contents using
p73560
aVFinally, deallocate with
p73561
aVThis is quite a fiddle to get right, and it's even more complicated if the target process is a different bitness
p73562
aVHaving seen your comment to the question, it's clear that you are already familiar with this technique
p73563
aVIn my opinion, you may well be better off using the automation API, which I believe will give you the information much more readily
p73564
as(dp73565
g7
V505088
p73566
stp73567
a((dp73568
g2
(lp73569
VSince there is no mention otherwise, you are safe to assume that  is threadsafe
p73570
aVThat is the default setting for Windows API functions
p73571
aVUnless otherwise mentioned, they are threadsafe
p73572
as(dp73573
g7
V505088
p73574
stp73575
a((dp73576
g2
(lp73577
VYou need to include the  extended window style
p73578
aVYou say that you have already tried including  without success
p73579
aVI'm going to take a wild guess that you have been trying to include it in the window style rather than the extended window style
p73580
aVYour code should look like this:
p73581
as(dp73582
g7
V505088
p73583
stp73584
a((dp73585
g2
(lp73586
VError code  is an access violation
p73587
aVWhen SSE is involved that invariably means that you are attempting misaligned memory access
p73588
aVYou'll need to work out which operation uses operands that are not aligned
p73589
as(dp73590
g7
V505088
p73591
stp73592
a((dp73593
g2
(lp73594
VAlthough you claim otherwise, the value returned by  is clearly not exactly equal to
p73595
aVIf it was, then  would be exactly equal to
p73596
aVWe can say that because  is exactly representable in binary floating point
p73597
aVIt's easy enough to see that
p73598
aVYou will find, in your scenario, that
p73599
aVevaluates as
p73600
aVIn general, it can always be a dangerous thing to try to compare floating point values exactly
p73601
aVParticularly if the values are the result of arithmetic operations, then the inherent imprecision of floating point operations will mean that exact comparison will often not give the results that you expect
p73602
aVI hypothesise that  actually performs arithmetic rather than, as you claim, returning
p73603
aVSometimes the best way to check for equality with floating point values is to check for approximate equality
p73604
aVFor example,  where  is some small number
p73605
aVThe difficulty with that is that it can be hard to come up with a robust choice of
p73606
aVExactly how you should implement this test is hard to say without knowing more detail
p73607
as(dp73608
g7
V505088
p73609
stp73610
a((dp73611
g2
(lp73612
VYou should use an open array:
p73613
aVAnd call it like this, using an open array constructor:
p73614
aVand so on
p73615
aVIn fact, you'll find this very function (names  for the integer version), and many similar, already implemented in the  unit
p73616
as(dp73617
g7
V505088
p73618
stp73619
a((dp73620
g2
(lp73621
VAt most one helper can active at any one point in your code
p73622
aVThe documentation says this:
p73623
aVYou can define and associate multiple helpers with a single
p73624
aVtype
p73625
aVHowever, only zero or one helper applies in any
p73626
aVspecific location in source code
p73627
aVThe helper defined in the
p73628
aVnearest scope will apply
p73629
aVClass or record helper scope is
p73630
aVdetermined in the normal Delphi fashion (for example, right
p73631
aVto left in the unit's uses clause)
p73632
aVSince record helpers do not support inheritance, there's no way to have both the standard helper's and your helper's functionality active at the same time, other than re-implementing the standard helper's functionality
p73633
as(dp73634
g7
V505088
p73635
stp73636
a((dp73637
g2
(lp73638
VI'm going to assume that your addresses are IPv4 addresses stored in a 32 bit integer in host byte order
p73639
aVAnd I'm also assuming that you want a lexicographic ordering so that:
p73640
aVis compared by first comparing  and , and if equal then comparing  and , and so on
p73641
aVIn which case, the natural unsigned integer ordering (using the  or  operators) will produce the ordering that you desire
p73642
aVIf the addresses are in network byte order, then you need to convert to host byte order before comparing
p73643
aVIn your question, you have addresses as strings
p73644
aVSo you'd need to convert them to network byte order 32 bit unsigned integers with , and then to host byte order with
p73645
aVAnd then you could compare
p73646
as(dp73647
g7
V505088
p73648
stp73649
a((dp73650
g2
(lp73651
VThis question appears to be:
p73652
aVHow do I determine which unit a symbol is defined in
p73653
aVOnce you have compiled the project, hover the cursor over the symbol and the IDE will display a hint which names the unit where the symbol is defined
p73654
aVOr, use CTRL+click to open the unit that declares the symbol in the editor
p73655
as(dp73656
g7
V505088
p73657
stp73658
a((dp73659
g2
(lp73660
VThis is an intentional and documented feature of the language
p73661
aVThis is the part of the documentation that describes this feature, with my added emphasis:
p73662
aVWhile a class can be declared in either the interface or the
p73663
aVimplementation section of a unit, defining declarations for a class
p73664
aVmethods must be in the implementation section
p73665
aVIn the heading of a defining declaration, the method name is always
p73666
aVqualified with the name of the class to which it belongs
p73667
aVThe heading
p73668
aVcan repeat the parameter list from the class declaration; if it does,
p73669
aVthe order, type, and names of the parameters must match exactly, and
p73670
aVif the method is a function, the return value must match as well
p73671
as(dp73672
g7
V505088
p73673
stp73674
a((dp73675
g2
(lp73676
VThe simplest way is like this:
p73677
aVIf you have a large number of candidate values, then this will result in a linear search which could be expensive
p73678
aVIf that matters then a set could result in better performance:
p73679
aVNote that any performance benefit from using a set could only come if the set could be instantiated once, but tested for membership multiple times
p73680
aVIt looks to me that you are actually testing divisibility by 5 which can be done like this:
p73681
as(dp73682
g7
V505088
p73683
stp73684
a((dp73685
g2
(lp73686
VThis is covered by the documentation:
p73687
aVExtended Identifiers
p73688
aVYou might encounter identifiers (e
p73689
ag217
aVtypes, or methods in a class)
p73690
aVhaving the same name as a Delphi language reserved word
p73691
aVFor example,
p73692
aVa class might have a method called
p73693
aVDelphi reserved words such
p73694
aVas begin cannot be used for an identifier name
p73695
aVIf you fully qualify the identifier, then there is no problem
p73696
aVFor
p73697
aVexample, if you want to use the Delphi reserved word type for an
p73698
aVidentifer name, you must use its fully qualified name:
p73699
aVAs a shorter alternative, the ampersand (&) operator can be used
p73700
aVto resolve ambiguities between identifiers and Delphi language
p73701
aVreserved words
p73702
aVThe & prevents a keyword from being parsed as a
p73703
aVkeyword (that is, a reserved word)
p73704
aVIf you encounter a method or type
p73705
aVthat is the same name as a Delphi keyword, you can omit the namespace
p73706
aVspecification if you prefix the identifier name with an ampersand
p73707
aVBut
p73708
aVwhen you are declaring an identifier that has the same name as a
p73709
aVkeyword, you must use the &:
p73710
as(dp73711
g7
V505088
p73712
stp73713
a((dp73714
g2
(lp73715
VIn general, you cannot obtain the length of an array unless the array includes a pre-determined terminating sentinel
p73716
aVSo, a C string is the canonical example of an array that has a pre-determined terminating sentinel, namely the null terminator
p73717
aVYou will need to keep track of the length of the array in a separate variable, or use a terminating sentinel
p73718
aVAn example of the latter would be an array declared like this:
p73719
aVwhere  is deemed to be the terminator
p73720
aVThat technique is only viable when you can reserve a value for use as a terminator
p73721
aVI'm assuming that you are looking to obtain the length of a dynamically allocated array, since that is the most likely scenario for the question to be asked
p73722
aVAfter all, if your array is declared like this, , then it's pretty obvious how long it is
p73723
as(dp73724
g7
V505088
p73725
stp73726
a((dp73727
g2
(lp73728
V is a pointer to an array of  of length
p73729
aVAnd so  is the size of an array of  of length
p73730
aVHence  is equal to
p73731
aVCasting of the return value of  is not needed since  returns
p73732
aVAs a general rule, in C code, you should not cast the return value of
p73733
as(dp73734
g7
V505088
p73735
stp73736
a((dp73737
g2
(lp73738
VIn comments you state that you are most interested in dealing with this function:
p73739
aVYou cannot expect the p/invoke marshaller to marshal the return value for you
p73740
aVYou'll need to do that by hand
p73741
aVWhat's more, you cannot reliably call the function as it is currently designed
p73742
aVThat's because the caller has no way of obtaining the length of the returned array
p73743
aVYou'll need to add an extra parameter to return the array length to the caller:
p73744
aVOn the C# side you'd declare it like this:
p73745
aVAnd you'll need to make sure that the calling convention you specify in your  matches that of the native code
p73746
aVI'm assuming , but only you know for sure
p73747
aVCall it like this:
p73748
aVTo avoid a memory leak you'll need to export another function that deallocates the memory allocated by
p73749
aVCall that once you have finished calling
p73750
aVQuite frankly this looks very much like it would be more suited to a mixed mode C++/CLI solution
p73751
as(dp73752
g7
V505088
p73753
stp73754
a((dp73755
g2
(lp73756
VThere is no such thing as "minimizing to the systray"
p73757
aVFor a start it's actually called the notification area
p73758
aVBut you cannot minimize to the notification area either
p73759
aVHere's what you can do:
p73760
aVCreate (and destroy) a notification area icon
p73761
aVHide (or show) a form
p73762
aVNow, what people mean by minimize to the notification area is simply the two items in the list above, performed at the same time
p73763
aVYou are free to do any combination of these things
p73764
aVThere is no special minimize to the notification area action
p73765
aVIn your scenario, it's not compulsory to create any UI at all
p73766
aVYou can do the following:
p73767
aVAt application startup, create one (or more) forms
p73768
aVLet those forms do whatever work they need to do
p73769
aVDo not show the forms until they are ready
p73770
aVSimply put, you do not need to make forms visible in order for code to execute
p73771
as(dp73772
g7
V505088
p73773
stp73774
a((dp73775
g2
(lp73776
VYou cannot refer to a variable outside its enclosing scope
p73777
aVEither:
p73778
aVMove the variable to a wider scope
p73779
aVThe downside of this is that we always strive to keep scope as narrow as possible
p73780
aVExtract the switch statement into a function and have it return the value
p73781
aVOption 1 is, I think, obvious
p73782
aVTo expand on option 2, the code would look like this:
p73783
as(dp73784
g7
V505088
p73785
stp73786
a((dp73787
g2
(lp73788
VADL VCL is not available for XE4, since it was discontinued some time before XE4 was released
p73789
aVIf you have the ADL source code, and have ported it to XE4, then it's plausible that you may have some success
p73790
aVThe error message you describe is symptomatic of not having the design-time packages for the components installed
p73791
aVYou'll need to build and install design-time packages for any components that you want to interact with at design-time
p73792
as(dp73793
g7
V505088
p73794
stp73795
a((dp73796
g2
(lp73797
VThe JEDI project is hosted on github
p73798
aVYou can pull the latest source, which has support for XE4, from there: https://github
p73799
aVcom/project-jedi
p73800
aVAs a general rule, you should get into the habit of using the appropriate VCS repository whenever you want to obtain open source software
p73801
aVThat will always have the latest version
p73802
as(dp73803
g7
V505088
p73804
stp73805
a((dp73806
g2
(lp73807
VYou can use the command line utility  to import the type library on Windows 8
p73808
aVYou can find  in the  directory of your Delphi installation
p73809
aVSince you want to avoid installing Delphi on your Windows 8 machine, transfer  to the Windows 8 machine
p73810
aVAnd then run this command:
p73811
aVThis will generate the Pascal type library import file that you need
p73812
as(dp73813
g7
V505088
p73814
stp73815
a((dp73816
g2
(lp73817
VThe fundamental issue in this question, to my mind is:
p73818
aVWhat happens when you raise an exception in a thread's  event handler
p73819
aVA thread's  event handler is invoked on the main thread, by a call to
p73820
aVNow, your  event handler is raising an exception
p73821
aVSo we need to work out how that exception propagates
p73822
aVIf you examine the call stack in your  event handler you will see that it is called on the main thread from
p73823
aVThe code that is relevant is this:
p73824
aVSo,  catches your exception and stashes it away in
p73825
aVExcecution then continues, and  is later raised
p73826
aVAnd it turns out, that the stashed away exception is raised in
p73827
aVThe last dying act of  is:
p73828
aVWhat this means is that your attempts to get the exception to be raised in the main thread have been thwarted by the framework which moved it back onto your thread
p73829
aVNow, this is something of a disaster because at the point at which  is executed, in this scenario, there is no exception handler active
p73830
aVThat means that the thread procedure will throw an SEH exception
p73831
aVAnd that will bring the house down
p73832
aVSo, my conclusion from all this is the following rule:
p73833
aVNever raise an exception in a thread's  event handler
p73834
aVYou will have to find a different way to surface this event in your main thread
p73835
aVFor example, queueing a message to the main thread, for example by a call to
p73836
aVAs an aside, you don't need to implement an exception handler in your  method since  already does so
p73837
aVThe implementation of  wraps the call to  in an try/except block
p73838
aVThis is in the  function in
p73839
aVThe pertinent code is:
p73840
aVThe  event handler is called after the exception has been caught and so you could perfectly well elect to re-surface it from there, although not by naively raising it as we discovered above
p73841
aVYour code would then look like this:
p73842
aVAnd just to be clear,  is some functionality that you have to write
p73843
as(dp73844
g7
V505088
p73845
stp73846
a.